
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of TCSH</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../contrib.css">
</HEAD>
<BODY>
<DIV ALIGN="right">
本ページは <A HREF="http://www.jp.freebsd.org/man-jp/">FreeBSD jpman project</A>
(man-jp@jp.FreeBSD.org) より寄贈いただきました。
</DIV>


<H1>TCSH</H1>
Section: User Commands  (1)<BR>Updated: 2 September 2001<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/tcsh/contrib/man1/tcsh.1">roff page</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>名称</H2>

tcsh  - ファイル名補完とコマンド行編集を追加した C シェル
<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<B>tcsh </B>[<B>-bcdefFimnqstvVxX</B>] [<B>-Dname</B>[<B>=value</B>]] [arg ...]

<BR>

<B>tcsh -l</B>

<A NAME="lbAD">&nbsp;</A>
<H2>解説</H2>

<I>tcsh</I> は、バークレイ版 UNIX の C シェル <I>csh</I>(1) と完全に
互換性があり、さらに機能強化したシェルです。
対話的なログインシェル、またシェルスクリプトのコマンドプロセッサの
両方の用途で使われるコマンドインタプリタです。
<I>tcsh</I> には、コマンド行編集 (<B>コマンド行編集</B>の項を参照)、
プログラム可能な単語の補完 (<B>補完と一覧</B>の項を参照)、
スペル訂正 (<B>スペル訂正</B>の項を参照)、
履歴 (<B>ヒストリ置換</B>の項を参照)、
ジョブ制御 (<B>ジョブ</B>の項を参照)、
C 言語風の文法があります。
<B>新機能</B>の章では、<I>csh</I>(1) には存在しない、<I>tcsh</I> の
主な追加機能について説明しています。
このマニュアルを通じ、<I>tcsh</I> の機能のうち、
<I>csh</I>(1) のほとんどの実装 (特に 4.4BSD の <I>csh</I>) に
ない機能について、ラベル (+) をつけてあります。
そして、<I>csh</I>(1) にあったけれども文書化されていなかった機能に
ラベル (u) をつけてあります。
<A NAME="lbAE">&nbsp;</A>
<H3>引数リスト処理</H3>

シェルへの 1 番目の引数 (引数 0 番) が `-' の場合、シェルは
ログインシェルになります。
シェルを <B>-l</B> フラグを指定して起動することでも
ログインシェルにできます。
<P>

残りのフラグは以下のように解釈されます。
<DL COMPACT>
<DT><B>-b</B>

<DD>
このフラグは、オプションの処理を強制的に中断させる場合に使用します。
このフラグ以降の引数はすべて、オプションではないものとして
処理されます。これにより、混乱を避け、小細工をしなくても、
シェルスクリプトにオプションを渡すことが可能になります。
set-user ID スクリプトは本オプションなしでは実行できません。
<DT><B>-c</B>

<DD>
コマンドを、本フラグの次にくる引数 (この引数は省略できません。
また、1 つだけである必要があります) から読み込み、実行します。
この引数は、あとで参照できるように、シェル変数 <B>command</B> に
格納されます。残りの引数は、シェル変数 <B>argv</B> に代入されます。
<DT><B>-d</B>

<DD>
ログインシェルであるかどうかにかかわらず、
<B>スタートアップとシャットダウン</B>の項で解説されているように
<I>~/.cshdirs</I> から、ディレクトリスタックを読み込みます。(+)
<DT><B>-D</B><I>name</I>[=<I>value</I>]

<DD>
環境変数 <I>name</I> に値 <I>value</I> を設定します。(Domain/OS のみ) (+)
<DT><B>-e</B>

<DD>
起動したコマンドが異常終了したり、0 でない終了ステータスを返したときに、
ただちにシェルを終了します。
<DT><B>-f</B>

<DD>
<I>~/.tcshrc </I>を読み込まずに無視するので、
起動が高速になります。
<DT><B>-F</B>

<DD>
プロセスを生成する際に <I><A HREF="../../LDP_man-pages/man2/vfork.2.html">vfork</A></I>(2) の代わりに
<I><A HREF="../../LDP_man-pages/man2/fork.2.html">fork</A></I>(2) を使います。(Convex/OS のみ) (+)
<DT><B>-i</B>

<DD>
たとえ端末上で実行されていなくても、対話的に動作し最上位レベルの
入力の際にプロンプトを表示します。入力と出力がともに端末である場合、
本オプションなしでもシェルは対話的に動作します。
<DT><B>-l</B>

<DD>
ログインシェルとなります (<B>-l</B> が、指定された唯一のフラグである
場合にのみ有効です)。
<DT><B>-m</B>

<DD>
実効ユーザに属していなくても <I>~/.tcshrc</I> をロードします。
新しいバージョンの <I><A HREF="../../0MultiFileIdx/man1/su.1.html">su</A></I>(1) は <B>-m</B> をシェルに渡すことが
できます。(+)
<DT><B>-n</B>

<DD>
コマンドの解析は行いますが、実行はしません。
シェルスクリプトのデバッグに役立ちます。
<DT><B>-q</B>

<DD>
SIGQUIT (<B>シグナル処理</B>の項を参照) を受け付けるようにし、
デバッガのもとで使われても作動するようになります。
ジョブ制御は無効になります。(u)
<DT><B>-s</B>

<DD>
標準入力からコマンドを読み込みます。
<DT><B>-t</B>

<DD>
入力から 1 行だけ読み込み、それを実行します。入力行の改行の直前に
`\' を置くことで、次の行への継続を行うことができます。
<DT><B>-v</B>

<DD>
シェル変数 <B>verbose</B> を設定します。
これにより、ヒストリ置換された状態のコマンド行を表示するようになります。
<DT><B>-x</B>

<DD>
シェル変数 <B>echo</B> を設定します。これにより、実行直前に、
実行するコマンドを表示するようになります。
<DT><B>-V</B>

<DD>
<I>~/.tcshrc</I> を実行する前に、シェル変数 <B>verbose</B> を設定します。
<DT><B>-X</B>

<DD>
<I>~/.tcshrc</I> を実行する前に、シェル変数 <B>echo</B> を設定します。
<DT><B>-X</B>

<DD>
に対する <B>-x</B> の関係は、<B>-V</B> に対する <B>-v</B> の関係に
相当します。
</DL>
<P>

フラグ引数の処理のあと、もし引数が残っていて、かつ、
<B>-c</B>, <B>-i</B>, <B>-s</B>, <B>-t</B> のいずれのフラグも
指定されていなければ、残っている引数のうち最初のものは
コマンドファイル、つまり「スクリプト」の名前とみなされます。
シェルはこのファイルをオープンし、`$0' による置換に備えて
ファイル名を保存します。
多くのシステムは、スクリプトが本シェルと互換性のない
version 6 または version 7 の標準のシェルを使っているため、
スクリプトの先頭の文字が `#' でない場合、
つまりスクリプトがコメントから始まらない場合、本シェルは
それらの「標準」のシェルを起動して実行します。
<P>

残りの引数はシェル変数 <B>argv</B> に設定されます。
<A NAME="lbAF">&nbsp;</A>
<H3>スタートアップとシャットダウン</H3>

ログインシェルの場合は、実行開始に際し、まずシステムファイル
<I>/etc/csh.cshrc</I> と <I>/etc/csh.login</I> を読み込んで実行します。
そしてシェルを起動したユーザの<B>ホーム</B>ディレクトリの中から、
まずはじめに <I>~/.tcshrc</I> (+) を読み込んで実行します。
もし、<I>~/.tcshrc</I> が見つからない場合は、<I>~/.cshrc</I> を
読み込んで実行します。
次に、<I>~/.history</I> (もしくは、シェル変数 <B>histfile</B> の値) を、
その次に <I>~/.login</I> を、最後に、<I>~/.cshdirs</I> (もしくは、
シェル変数 <B>dirsfile</B> の値) (+) を読み込んで実行します。
コンパイルの仕方によって、シェルは <I>/etc/csh.cshrc</I> の後ではなく前に
<I>/etc/csh.login</I> を読み込み、
<I>~/.tcshrc</I> (または <I>~/.cshrc</I>) と <I>~/.history</I> の後ではなく前に
<I>~/.login</I> を読み込む場合があります。
シェル変数 <B>version</B> を参照してください。(+)
<P>

ログインシェルでない場合は、<I>/etc/csh.cshrc</I> と、
<I>~/.tcshrc</I> (または <I>~/.cshrc</I>) のみを起動時に読み込みます。
<P>

スタートアップファイルの例は、
<I><A HREF="http://tcshrc.sourceforge.net">http://tcshrc.sourceforge.net</A></I>
を見てください。
<P>

<I><A HREF="../../0MultiFileIdx/man1/stty.1.html">stty</A></I>(1) や <I>tset</I>(1) のようなコマンドは、ログインする
ごとに 1 度だけ実行される必要がありますが、これらのコマンドは、
普通は <I>~/.login</I> ファイルに入れます。
<I>csh</I>(1) と <I>tcsh</I> の両方で同じファイルのセットを使う
必要があるユーザは、<I>~/.cshrc</I> だけを使い、その中で
シェル変数 <B>tcsh</B> (値は任意) があるかどうかチェックして
から、<I>tcsh</I> 特有のコマンドを使うようにします。または、
<I>~/.cshrc</I> と <I>~/.tcshrc</I> の両方を使うが、<I>~/.tcshrc</I> で、
<I>source</I> コマンド (組み込みコマンドの項を参照) を使い
<I>~/.cshrc</I> を読み込むようにします。
以下、このマニュアルの残りの部分で `<I>~/.tcshrc</I>' と表現したときは、
「<I>~/.tcshrc</I>、または <I>~/.tcshrc</I> が見つからない
場合は <I>~/.cshrc</I>」という意味で使います。
<P>

通常、シェルはプロンプト `&gt; ' を表示し、端末からコマンドの読み込みを
開始します (引数処理と、コマンドスクリプトを含むファイルの処理のための
シェルの使用については、後で説明します)。
シェルは、入力されたコマンド行の読み込み、読み込んだコマンド行を単語に
分解、およびコマンド履歴への格納、コマンド行の解析、
コマンド行の中のコマンドそれぞれの実行を繰り返します。
<P>

ログアウトするには、空の行で `^D' とタイプするか、`logout' するか、
`login' するか、シェルの自動ログアウト機構 (シェル変数
<B>autologout</B> を参照) を使います。
ログインシェルが実行終了する際には、ログアウトの状況に応じて
シェル変数 <B>logout</B> を `normal' か `automatic' に設定し、
<I>/etc/csh.logout</I> ファイルと <I>~/.logout</I> ファイルにある
コマンドを実行します。
コンパイルの仕方によっては、シェルは、ログアウト時に DTR を落とす
ことがあります。これについてはシェル変数 <B>version</B> を参照してください。
<P>

システムのログインファイル名、ログアウトファイル名は、
異なる <I>csh</I>(1) 間での互換性を保つために、
システムごとにファイルが違います。これについては、
<B>関連ファイル</B>を参照してください。
<A NAME="lbAG">&nbsp;</A>
<H3>編集</H3>

はじめに、<B>コマンド行エディタ</B>について説明します。
<B>補完と一覧</B>と、<B>スペル訂正</B>の 2 つの機能は、
編集コマンドとして実装されていますが、
特に分けて説明する必要があるため、項を改めて説明します。
最後に、<B>編集コマンド</B>の項で、シェルに特有の編集コマンドについて、
一覧をあげ、デフォルトのバインドとともに説明します。
<A NAME="lbAH">&nbsp;</A>
<H3>コマンド行編集 (+)</H3>

コマンド行の入力データは、GNU Emacs や <I>vi</I>(1) で使われているものと、
よく似たキーシーケンスを使って編集できます。
シェル変数 <B>edit</B> がセットされているときのみ、編集できるように
なっています。対話的なシェルでは、この値はデフォルトで
設定されています。
組み込みコマンド <I>bindkey</I> で、キーバインドを変更したり、
表示したりできます。
デフォルトでは、Emacs 形式のキーバインドが使われています
(違う方法でコンパイルしなければそうなります。
シェル変数 <B>version</B> を参照)。
しかし、コマンド <I>bindkey</I> で、キーバインドを <I>vi</I> 形式に
一括して変更できます。
<P>

シェルは、つねに矢印キー (環境変数
<B>TERMCAP</B> で定義されたものです) を、次のように割り付けています。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>下矢印<DD>
<I>down-history</I>
<DT>上矢印<DD>
<I>up-history</I>
<DT>左矢印<DD>
<I>backward-char</I>
<DT>右矢印<DD>
<I>forward-char</I>

</DL>
</DL>

<P>

他の 1 文字バインドによって、変わっていなければこのようになります。
このようなバインドにしたくない場合、<I>settc</I> を使って、矢印キーの
エスケープシーケンスを空の文字列にセットすることができます。
ANSI/VT100 の矢印キーシーケンスは、つねにバインドされています。
<P>

その他のキーバインドは、そのほとんどは、Emacs、<I>vi</I>(1) ユーザが
予想できるものです。また、簡単に <I>bindkey</I> コマンドで表示させる
こともできるので、ここで、それらのバインドを並べあげる必要は
ないでしょう。
同じく、<I>bindkey</I> コマンドは、それぞれの編集コマンドを
簡単な説明付きで、表示させることができます。
<P>

注意: 「単語」という概念に関して、編集コマンドは、シェルと同じ概念を
持たないことに注意してください。
エディタは、シェル変数 <B>wordchars</B> の中にはない非英数文字
(英文字、数字のどちらでもない文字) によって単語の区切りを決めます。
一方、シェルは、ホワイトスペース (空白、タブ、改行) と、
<B>字句構造</B>の項で列挙する特殊な意味を持つ文字のいくつかを
識別します。
<A NAME="lbAI">&nbsp;</A>
<H3>補完と一覧 (+)</H3>

シェルは、一意に決まる短縮形を与えられると、しばしば単語の補完を
行うことができます。
単語の一部 (たとえば `ls /usr/lost') をタイプして、タブキーを押すと、
編集コマンド <I>complete-word</I> が実行します。シェルは、
ファイル名 `/usr/lost' を補完して `/usr/lost+found/' にします。
このとき、入力バッファの中で、不完全な単語を完全な単語で置き換えます。
(注意: 末端の `/' について: 補完では、ディレクトリ名を補完すると
最後に `/' を付け加えます。
そして、ディレクトリ名以外の単語を補完すると、末尾に空白文字を
付け加えます。こうすることで、タイプ入力が速くなり、また、
補完が成功したことが一目で分かります。
シェル変数 <B>addsuffix</B> のセットをはずせば、
これらを付け加えなくすることもできます。)
合致するものが見当たらない場合 (おそらく `/usr/lost+found' が
存在しない場合でしょう)、端末のベルが鳴ります。
単語がすでに補完されている場合 (システムに `/usr/lost' が
存在する場合か、あるいは、ユーザがはるか先まで考えて、すべてを
入力してしまっていた場合でしょう)、`/' または空白文字が末尾に
まだなければ、付け加えられます。
<P>

補完は、行の一番最後でなくても、途中どこででも機能します。
そして、テキストの補完によって、その分、行の残りは右方向へ押されます。
単語の中間で補完された場合、しばしばカーソルの右側に文字が残り、
それを消すはめになることもあります。
<P>

コマンドと変数は、ほとんど同じ方法で補完できます。
たとえば、`em[tab]' とタイプした時、使用しているシステムで
`em' から始まるコマンドが唯一 <I>emacs</I> だけならば、
`em' は `emacs' と補完されます。
補完は、<B>path</B> 中のディレクトリにあるコマンドか、
フルパスが与えられれば、そこにあるコマンドを見つけ出すことができます。
`echo $ar[tab]' とタイプした時、他に `ar' から始まる変数がなければ、
`$ar' は `$argv' と補完されます。
<P>

シェルは、入力バッファを解析して、補完したい単語を、ファイル名としてか、
コマンドとしてか、変数としてか、どのように補完すべきかを決めます。
バッファの中の最初の単語と、`;', `|', `|&amp;', `&amp;&amp;', `||' の
すぐ次にくる単語は、コマンドとみなします。
`$' で始まる単語は、変数とみなします。
その他のものは、ファイル名とみなします。
空の行は、ファイル名として `補完されて' います。
<P>

いつでも、`^D' とタイプすることで、編集コマンド
<I>delete-char-or-list-or-eof</I> を実行させて、
補完可能な単語の候補を並べ挙げることができます。
シェルは、組み込みコマンド <I>ls-F</I> (q.v.) を使って、
補完可能な候補を並べ挙げます。
そして、プロンプトと未完成のコマンドラインを再表示します。
次に例を示します。
<DL COMPACT>
<DT><DD>
&gt; ls /usr/l[^D]
<BR>

lbin/       lib/    local/      lost+found/
<BR>

&gt; ls /usr/l
</DL>
<P>

シェル変数 <B>autolist</B> をセットしていれば、シェルは、
補完に失敗したときはいつでも残りの選択肢を表示します。
<DL COMPACT>
<DT><DD>
&gt; set autolist
<BR>

&gt; nm /usr/lib/libt[tab]
<BR>

libtermcap.a@ libtermlib.a@
<BR>

&gt; nm /usr/lib/libterm
</DL>
<P>

シェル変数 <B>autolist</B> を `ambiguous (あいまいな)' に
セットした場合は、補完に失敗して補完される単語へ新しい文字を
それ以上追加できなくなったときに限り、選択肢を表示します。
<P>

補完するファイル名には、変数、自分もしくは他人のホームディレクトリ
(`~' で短縮したもの。<B>ファイル名置換</B>の項を参照)、
ディレクトリスタックエントリ (`=' で短縮したもの。
<B>ディレクトリスタック置換</B>の項を参照) を含めることができます。
たとえば、次のようになります。
<DL COMPACT>
<DT><DD>
&gt; ls ~k[^D]
<BR>

kahn    kas    kellogg
<BR>

&gt; ls ~ke[tab]
<BR>

&gt; ls ~kellogg/
</DL>
<P>

あるいは、
<DL COMPACT>
<DT><DD>
&gt; set local = /usr/local
<BR>

&gt; ls $lo[tab]
<BR>

&gt; ls $local/[^D]
<BR>

bin/ etc/ lib/ man/ src/
<BR>

&gt; ls $local/
</DL>
<P>

変数については、編集コマンド <I>expand-variables</I> を指定して使っても
展開できることに注意してください。
<P>

コマンド <I>delete-char-or-list-or-eof</I> は、行の最後でのみ
リストを表示します。
行の中間の場合、カーソル位置の文字を消去します。
空行の場合、ログアウトします。ただし、<B>ignoreeof</B> がセットされて
いれば、何もしません。
`M-^D' は、編集コマンド <I>list-choices</I> にバインドされていますが、
これは行中のどこでも、補完の候補のリストを表示します。
<I>list-choices</I> (または、<I>delete-char-or-list-or-eof</I> のところで
列挙するコマンドで、消去するコマンド、しないコマンド、
リスト表示するコマンド、ログアウトするコマンドのどれでも)
は、そうしたい場合、組み込みコマンド <I>bindkey</I> で
`^D' にバインドすることもできます。
<P>

編集コマンド <I>complete-word-fwd</I> と <I>complete-word-back</I>
(デフォルトでは、どのキーにも割り付けられていません) を使うことで、
補完候補のリストを上または下に順に巡り、リスト上の現在の単語を、
次の単語または 1 つ前の単語に置き換えることができます。
<P>

シェル変数 <B>fignore</B> に、補完の際に無視するファイルの
サフィックスのリストをセットできます。
次の例を考えてみます。
<DL COMPACT>
<DT><DD>
&gt; ls
<BR>

Makefile    condiments.h~   main.o    side.c
<BR>

README    main.c    meal     side.o
<BR>

condiments.h    main.c~
<BR>

&gt; set fignore = (.o \~)
<BR>

&gt; emacs ma[^D]
<BR>

main.c   main.c~  main.o
<BR>

&gt; emacs ma[tab]
<BR>

&gt; emacs main.c
</DL>
<P>

`main.c~' と `main.o' は、<B>fignore</B> にサフィックスが
登録されているために、補完では無視されます
(しかしリスト上には表示されます)。
<B>ファイル名置換</B>の項で解説しているように、<B>home</B> に
拡張されないようにするために、`~' の前に `\' が必要なことに
注意してください。補完の候補が1 つしかない場合は、
<B>fignore</B> の設定は無視されます。
<P>

シェル変数 <B>complete</B> が `enhance(拡張)'
にセットされていた場合、補完は 1) 大文字小文字の区別を無視し、
2) ピリオド、ハイフン、アンダスコア (`.', `-', `_')を、
単語を分ける記号であるとみなし、ハイフンとアンダスコアは
同等なものとみなします。
次のようなファイルがある場合、
<DL COMPACT>
<DT><DD>
comp.lang.c     comp.lang.perl   comp.std.c++
<BR>

comp.lang.c++    comp.std.c
</DL>
<P>

`mail -f c.l.c[tab]' とタイプすれば、`mail -f comp.lang.c'
のように補完され、^D の場合には、`comp.lang.c' と `comp.lang.c++' が
リストとして表示されます。
`mail -f c..c++[^D]' とタイプした場合は、`comp.lang.c++' と
`comp.std.c++' が表示されます。
次のファイルがあるディレクトリで、`rm a--file[^D]' とタイプした
場合、
<DL COMPACT>
<DT><DD>
A_silly_file    a-hyphenated-file    another_silly_file
</DL>
<P>

の 3 つのファイルすべてが一覧表示されます。
なぜならば、大文字小文字の区別は無視されて、
ハイフンとアンダスコアは同等と解釈されるからです。しかしながら、
ピリオドは、ハイフンやアンダスコアと同等ではありません。
<P>

補完と一覧は、他にもいくつかのシェル変数の影響を受けます。
そのひとつ、<B>recexact</B> をセットすると、続けてタイプすれば
より長い単語に合致するような場合でさえも、
最短で一意に一致する単語に合致するようになります。たとえば、
<DL COMPACT>
<DT><DD>
&gt; ls
<BR>

fodder   foo      food     foonly
<BR>

&gt; set recexact
<BR>

&gt; rm fo[tab]
</DL>
<P>

この場合はベルが鳴るだけです。
なぜなら、`fo' は、`fod' または `foo' に展開できるからです。
しかし、さらに `o' とタイプすると、
<DL COMPACT>
<DT><DD>
&gt; rm foo[tab]
<BR>

&gt; rm foo
</DL>
<P>

`food' や `foonly' も合致するにもかかわらず、
補完は `foo' で完了します。
<B>autoexpand</B> をセットすると、補完を試みる前に、毎回、
編集コマンド <I>expand-history</I> を実行するようになります。
<B>autocorrect</B> をセットすると、補完を試みる前に、毎回、
その単語のスペル訂正をするようになります
(<B>スペル訂正</B>の項を参照)。
<B>correct</B> をセットすると、`return (enter)' キーを押したあと、
自動的にコマンドを補完するようになります。
<B>matchbeep</B> をセットすると、補完に際して、状況の変化に応じて、
ベルを鳴らしたり、鳴らないようにできます。
<B>nobeep</B> をセットすると、まったくベルを鳴らさないようにできます。
<B>nostat</B> には、ディレクトリのリストやディレクトリに
合致するパターンをセットでき、これらのディレクトリで補完機構が
<I><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></I>(2) を実行しないようにすることができます。
<B>listmax</B> や <B>listmaxrows</B> にセットすることで、
まず問い合わせずに一覧表示する項目の数や、列の数を、それぞれ
制限することができます。
<B>recognize_only_executables</B> をセットすると、
シェルがコマンド一覧を表示する際に、実行可能ファイルだけを
一覧表示するようにさせることができます。ただし、動作はきわめて
遅くなります。
<P>

最後に、組み込みコマンド <I>complete</I> を使って、ファイル名、
コマンド、変数以外の単語を補完する方法をシェルに教えることができます。
補完と一覧は、グロブパターン (<B>ファイル名置換</B>の項を参照)
上では機能しませんが、編集コマンド <I>list-glob</I> と
<I>expand-glob</I> はグロブパターンに対し同等の機能として実行されます。
<A NAME="lbAJ">&nbsp;</A>
<H3>スペル訂正 (+)</H3>

シェルは、補完したり一覧表示するのと同様に、ファイル名、コマンド、
変数名のスペルを訂正することができることがあります。
<P>

個々の単語は、編集コマンド <I>spell-word</I> (普通は M-s と M-S に
バインドされています) でスペル訂正できます。入力バッファ全体は
<I>spell-line</I>  (普通は M-$ に割り付けられています) で
スペル訂正できます。
シェル変数 <B>correct</B> に `cmd' を設定されておけば、コマンド名が
スペル訂正されます。`all' を設定しておけば、リターンがタイプされる
たびに行全体がスペル訂正されます。
<B>autocorrect</B> がセットされていれば、単語に補完を試みる前に
その単語をスペル訂正します。
<P>

スペル訂正が、ここで説明した方法のいずれかにより呼び出され、
コマンド行のどこかにスペル誤りがあると判断すると、
シェルは、次のように訂正済みのコマンド行を表示し入力を待ちます。
<DL COMPACT>
<DT><DD>
&gt; set correct = cmd
<BR>

&gt; lz /usr/bin
<BR>

CORRECT&gt;ls /usr/bin (y|n|e|a)?
</DL>
<P>

これに対し、`y' または空白文字で答えると、訂正済み行を実行し、
`e' で答えると、入力バッファに訂正前のコマンドを残し、
`a' で答えると、`^C' が押された場合と同様にコマンドを中止し、
それ以外の場合は、元のままの行を変えないで実行します。
<P>

スペル訂正は、ユーザ定義の補完を識別します
(組み込みコマンド <I>complete</I> を参照)。
もし、補完が実行される位置で、入力された単語が補完リストの中の単語に
似ていたとき、スペル訂正は、ミススペル記録して、見つかった単語を
訂正候補として提案します。しかし、入力された単語がその位置で、
どの補完候補にも合致しなかった時、スペル訂正は、
ミススペルを示しません。
<P>

補完と同様、スペル訂正は行のどこでも機能します。行の残りを右に
押し出したり、残りの余分な文字をカーソルの右に残したりします。
<P>

注意: スペル訂正は、意図どおりに動作する保証はありません。
そして、ほとんど実験的な機能として提供されています。
提案、改善する点があれば歓迎します。
<A NAME="lbAK">&nbsp;</A>
<H3>編集コマンド (+)</H3>

`bindkey' はキーバインド一覧を表示し、
`bindkey -l' は編集コマンドの一覧と短い解説を表示します。
ここでは、新しい編集コマンド、または、特に興味深い編集コマンドに
ついてのみ解説します。
エディタのキーバインド割り付けの記述については、
<I>emacs</I>(1) と <I>vi</I>(1) を参照してください。
<P>

デフォルトでそれぞれのコマンドにバインドられた文字 (あるいは複数文字)
は、括弧の中に示しました。
`^<I>character</I>' は制御文字を意味します。
`M-<I>character</I>'はメタ文字です。
メタキーがない端末の場合は、escape-<I>character</I> とタイプします。
大文字小文字の区別はありますが、
デフォルトで英文字に割り付けられるコマンドは、便宜上、
大文字、小文字の両方にキーバインドされています。
<DL COMPACT>
<DT><B>complete-word </B>(tab)

<DD>
<B>補完と一覧</B>の項で解説しているとおり、単語を補完します。
<DT><B>complete-word-back </B>(not bound)

<DD>
<I>complete-word-fwd</I> と同様ですが、単語リストの終わりから、
上へあがって行きます。
<DT><B>complete-word-fwd </B>(not bound)

<DD>
現在の単語を、補完可能単語リスト上の始めの単語で置き換えます。
本コマンドを繰り返すことで、単語リスト上を下へ降りていくことができます。
単語リストの最後までいくと、ベルが鳴り、未補完の単語へ戻ります。
<DT><B>complete-word-raw </B>(^X-tab)

<DD>
<I>complete-word</I> と同様ですが、ユーザ定義した補完は無視されます。
<DT><B>copy-prev-word </B>(M-^_)

<DD>
現在の行で、1 つ前の単語を入力バッファへコピーします。
<I>insert-last-word</I> も参照してください。
<DT><B>dabbrev-expand </B>(M-/)

<DD>
以前入力した単語の中で、現在の単語が先頭部分文字列であり、しかも
最近のものを見つけて、それで展開します。
必要ならば、ヒストリリストを一周回って元に戻って探します。
<I>dabbrev-expand</I> を中断せず繰り返すことで、
その次の単語に変わります。
<I>history-search-backward</I> と同様に、同一のマッチングは
スキップします。
<DT><B>delete-char </B>(割り付けなし)

<DD>
カーソル下の文字を削除します。
<I>delete-char-or-list-or-eof</I> も参照してください。
<DT><B>delete-char-or-eof </B>(割り付けなし)

<DD>
カーソル下に文字があれば <I>delete-char</I> を実行し、
空行では <I>end-of-file</I> を実行します。
<I>delete-char-or-list-or-eof</I> も参照してください。
<DT><B>delete-char-or-list </B>(割り付けなし)

<DD>
カーソル下に文字があれば <I>delete-char</I> を実行し、
行の末尾では <I>list-choices</I> を実行します。
<I>delete-char-or-list-or-eof</I> も参照してください。
<DT><B>delete-char-or-list-or-eof </B>(^D)

<DD>
カーソル下に文字があれば <I>delete-char</I> を実行し、
行の末尾では <I>list-choices</I> を実行し、
空行では <I>end-of-file</I> を実行します。
これらの 3 つのコマンドも参照してください。
これらのコマンドは、それぞれ 1 つの動作を実行するだけです。
<I>delete-char-or-eof</I>, <I>delete-char-or-list</I>, <I>list-or-eof</I> は、
それぞれ 3 つのうちの異なる 2 つを実行します。
<DT><B>down-history </B>(下矢印, ^N)

<DD>
<I>up-history</I> と同様ですが、1 つずつ下に移動し、もとの入力行で止まります。
<DT><B>end-of-file </B>(割り付けなし)

<DD>
ファイルの終端であることをシェルに通知します。
シェル変数 <B>ignoreeof</B> (そちらも参照) がセットされて
いない場合、その結果として、シェルは実行を終了します。
<I>delete-char-or-list-or-eof</I> も参照してください。
<DT><B>expand-history </B>(M-space)

<DD>
現在の単語のヒストリ置換を展開します。
<B>ヒストリ置換</B>を参照してください。
<I>magic-space</I>, <I>toggle-literal-history</I> と、シェル変数
<B>autoexpand</B> も参照してください。
<DT><B>expand-glob </B>(^X-*)

<DD>
カーソルの左にグロブパターンを展開します。
<B>ファイル名置換</B>を参照してください。
<DT><B>expand-line </B>(割り付けなし)

<DD>
<I>expand-history</I> と同様ですが、入力バッファのそれぞれの単語の
ヒストリ置換を展開します。
<DT><B>expand-variables </B>(^X-$)

<DD>
カーソルの左に変数を展開します。
<B>変数置換</B>を参照してください。
<DT><B>history-search-backward </B>(M-p, M-P)

<DD>
ヒストリリストを後方へ向かって、入力バッファの現在の中身
(カーソル位置まで) で始まるコマンドを検索し、
それを入力バッファへコピーします。
検索文字列は、`*', `?', `[]', `{}' を含んだグロブパターン
(<B>ファイル名置換</B>を参照)
であってもかまいません。
<I>up-history</I> と <I>down-history</I> は、ヒストリリストの該当する
地点から始める事ができます。
Emacs モードのみです。
<I>history-search-forward</I> と <I>i-search-back</I> も参照してください。
<DT><B>history-search-forward </B>(M-n, M-N)

<DD>
<I>history-search-backward</I> と同様ですが、前方へ検索します。
<DT><B>i-search-back </B>(割り付けなし)

<DD>
後方へ、<I>history-search-backward</I> のように検索して、
最初に合致したものを入力バッファへコピーし、
カーソルをパターンの最後に位置させます。
そして、`bck: 'プロンプトと最初に合致したものを表示します。
追加の文字をタイプして、その検索を延長することができます。
<I>i-search-back</I> をタイプして、同じパターンで検索を延長する
こともできます。必要があれば、ヒストリリストを一周回って
元に戻って検索を続けます。
(これを行うためには、<I>i-search-back</I> は、1 文字に
バインドされていなければなりません。)
あるいは、以下の特殊文字をタイプすることもできます。
</DL>
<P>

<DL COMPACT><DT><DD>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>^W<DD>
カーソル下の単語の残りを検索パターンに加えます。
<DT>delete (あるいは <I>backward-delete-char</I> にバインドされた文字)<DD>
最後にタイプされた文字の効果をとりけし、
適当なら検索パターンから文字を削除します。
<DT>^G<DD>
前の検索が成功していたなら、検索全体を中止します。
そうでないなら、一番最後に成功した検索まで戻ります。
<DT>escape<DD>
検索を終え、入力バッファの現在の行をそのまま残します。
</DL>
</DL>


<P>

この他の文字で、<I>self-insert-command</I> にバインドされている
以外のものをタイプすると、検索が終了します。入力バッファの現在の行は
そのままになり、タイプした文字は通常の入力として解釈されます。
特に、キャリッジリターンの場合は、現在の行を実行に移します。
Emacs モードのみです。
<I>i-search-fwd</I> と <I>history-search-backward</I> も参照してください。
</DL>

<DL COMPACT>
<DT><B>i-search-fwd </B>(割り付けなし)

<DD>
<I>i-search-back</I> と同様ですが、前方へ検索します。
<DT><B>insert-last-word </B>(M-_)

<DD>
1 つ前の入力行 (`!$') の最後の単語を入力バッファに挿入します。
<I>copy-prev-word</I> も参照してください。
<DT><B>list-choices </B>(M-^D)

<DD>
<B>補完と一覧</B>で解説しているように、補完の可能性を一覧表示します。
<I>delete-char-or-list-or-eof</I> と <I>list-choices-raw</I> も
参照してください。
<DT><B>list-choices-raw </B>(^X-^D)

<DD>
<I>list-choices</I> と同様ですが、ユーザ定義された補完を無視します。
<DT><B>list-glob </B>(^X-g, ^X-G)

<DD>
カーソルの左側のグロブパターン (<B>ファイル名置換</B>を参照) に
合致したものを (組み込みコマンド <I>ls-F</I> を用いて) 一覧表示します。
<DT><B>list-or-eof </B>(割り付けなし)

<DD>
<I>list-choices</I> を実行するか、または、空行の場合 <I>end-of-file</I> を
実行します。<I>delete-char-or-list-or-eof</I> も参照してください。
<DT><B>magic-space </B>(割り付けなし)

<DD>
まず <I>expand-history</I> と同様に、現在の行のヒストリ置換を展開して、
その後で空白を 1 つ付け加えます。
<I>magic-space</I> はスペースキーにバインドするように
設計されていますが、デフォルトではバインドされていません。
<DT><B>normalize-command </B>(^X-?)

<DD>
パスの中の現在の単語を検索します。そして、見つかった場合、
実行可能ファイルを指すフルパスで置き換えます。
特殊文字はクォートされます。エイリアスは展開されて、クォートされますが、
エイリアス中のコマンドは展開 / クォートされません。
このコマンドは、たとえば、`dbx' や `sh -x' などのように、
コマンドが引数を取得する場合に役立ちます。
<DT><B>normalize-path </B>(^X-n, ^X-N)

<DD>
シェル変数 <B>symlinks</B> の設定 `expand' の項で説明されているように、
現在の単語を展開します。
<DT><B>overwrite-mode </B>(割り付けられていません)

<DD>
入力モードと上書きモードの間で切り替えます。
<DT><B>run-fg-editor </B>(M-^Z)

<DD>
現在の入力行を保存します。そして、環境変数 <B>EDITOR</B> または
<B>VISUAL</B> のファイル名部分の最後の構成要素
(または、どちらもセットされていなければ、`ed' か `vi')
と等しい名前を持ち、ストップしているジョブを探します。
そのようなジョブが見つかれば、`fg %<I>job</I>' とタイプしたのと
同じように、実行再開されます。
これは、エディタとシェルの間を抜けて交互に切り替えるのを容易にする
ために使われます。
このコマンドを `^Z' にバインドし、もっと簡単に交互の切り替えが
できるようにする人もいます。
<DT><B>run-help </B>(M-h, M-H)

<DD>
補完ルーチンの `現在のコマンド' と同じ概念による
現在のコマンドのドキュメントを検索し、表示します。
ページャを使う方法はありません。<I>run-help</I> は短いヘルプファイルと
のために設計されているためです。
特別なエイリアス <B>helpcommand</B> が定義されていた場合、
コマンド名を唯一の引数としてその値が実行されます。
ほかに、ドキュメントのファイル名は、<I>コマンド名</I>.help,
<I>コマンド名</I>.1, <I>コマンド名</I>.6,
<I>コマンド名</I>.8, <I>コマンド名</I>のいずれかでなければなりません。
また、そのファイルは、環境変数 <B>HPATH</B> の中で、
一覧にあがっているディレクトリのうちの 1 つに入っていなければなりません。
もし、1 つ以上のヘルプファイルがある場合は、最初の 1 つのみが
プリントされます。
<DT><B>self-insert-command </B>(テキスト文字)

<DD>
挿入モード (デフォルト) では、タイプした文字を、
カーソル下の文字の後に挿入します。
上書きモードでは、タイプした文字で、カーソル下の文字を置き換えます。
入力モードは、通常、各行の間で維持されていますが、
シェル変数 <B>inputmode</B> を `insert(挿入)' あるいは、
`overwrite(上書き)' にセットしておくと、
エディタを、各行の始まりで、そのモードにすることができます。
<I>overwrite-mode</I> も参照してください。
<DT><B>sequence-lead-in </B>(矢印接頭辞、メタ接頭辞、^X)

<DD>
次に続く文字がマルチキーシーケンス (複数文字の連続) であることを
表します。マルチキーシーケンスをコマンドにバインドする場合、
実際には、次の 2 つのバインドを作ります。
まず、最初の文字を <I>sequence-lead-in</I> とします。そして、
シーケンス全体をそのコマンドにバインドします。
<I>sequence-lead-in</I> にバインドされた文字で始まる
すべてのシーケンスは、他のコマンドにバインドされていなければ、
実質的には <I>undefined-key</I> にバインドされたのと同じことに
なります。
<DT><B>spell-line </B>(M-$)

<DD>
<I>spell-word</I> と同様に、入力バッファ中の各単語のスペル訂正を
試みます。しかし、単語の最初の文字が、
`-', `!', `^', `%' のうちのどれかの場合と、
単語中に `\', `*', `?' のいずれかを含んでいる場合は、
スイッチや、置換などの問題を避けるために、これらの単語を無視します。
<B>スペル訂正</B>を参照してください。
<DT><B>spell-word </B>(M-s, M-S)

<DD>
<B>スペル訂正</B>の項で説明されているのと同じやり方で、現在の単語の
スペルの訂正を試みます。
パス名として現れる単語の部分をそれぞれにチェックします。
<DT><B>toggle-literal-history </B>(M-r, M-R)

<DD>
入力バッファのヒストリ置換を展開したり、`しなかったり' します。
<I>expand-history</I> と、シェル変数 <B>autoexpand</B> も参照してください。
<DT><B>undefined-key </B>(割り付けのコマンドが無いキー)

<DD>
ベルを鳴らします。
<DT><B>up-history </B>(上矢印, ^P)

<DD>
ヒストリリストの中から 1 つ前のエントリを入力バッファにコピーします。
<B>histlit</B> がセットされている場合、その記入された文字どおりの
形式を使います。
ヒストリリストを上の方へ 1 つずつ移動を繰り返した場合、
一番上で止まります。
<DT><B>vi-search-back </B>(?)

<DD>
検索文字列 (<I>history-search-backward</I> と同様、グロブパターンでも
構いません) の入力のために `?' をプロンプト表示します。
その文字列を検索して、同じ文字列を入力バッファへコピーします。
合致するものが見つからなければ、ベルが鳴ります。
リターンキー (enter キー) を押すと、検索を終了して、入力バッファ中に
最後に合致した単語を残します。
escape キーを押すと、検索を終了して、合致したものを実行します。
<I>vi</I> モードのみです。
<DT><B>vi-search-fwd </B>(/)

<DD>
<I>vi-search-back</I> と同様ですが、前方へ検索します。
<DT><B>which-command </B>(M-?)

<DD>
入力バッファの最初の単語に対して、<I>which</I> (組み込みコマンド
の解説を参照) を実行します。
</DL>
<A NAME="lbAL">&nbsp;</A>
<H3>字句構造</H3>

シェルは入力された行をタブや空白で単語に分割します。
特殊文字 `&amp;', `|', `;', `&lt;', `&gt;', `(', `)', 2 文字繰り返しの
`&amp;&amp;', `||', `&lt;&lt;' , `&gt;&gt;' は、空白で囲まれているか
どうかにかかわらず、常に単語の区切りになります。
<P>

シェルの入力が端末からではないとき、文字 `#' は、コメントの始まりと
して扱われます。`#' とその後ろの入力行の残りはコメントと解釈され、
文法解析されずに捨てられます。
<P>

特殊文字 (空白、タブ含む) は、その文字の直前にバックスラッシュ `\'
を置くことで、または、単一引用符 `''、二重引用符 `&quot;'、
逆引用符 ``' で囲むことで、特殊な意味合いを持たないようにしたり、
場合によっては、他の単語の一部分にすることもできます。
他に引用がなされない限り、`\' の直後に改行文字を置くと、改行文字は
空白扱いになります。しかし、引用中では、この文字の並びは改行文字に
なります。
<P>

さらに、<B>ヒストリ置換</B>を除く、すべての<B>置換</B>
(次項を参照) は、置換を含む文字列 (あるいは文字列の一部) を
単一引用符で囲むことで防ぐことができます。
あるいは、重大な文字 (たとえば、<B>変数置換</B>
ならば `$' や、<B>コマンド置換</B>ならば ``') を `\' で
クォートすることで
防ぐことができます。(<B>エイリアス置換</B>も例外ではありません。
一度定義された <I>alias</I> に対して、何らかの方法でその単語の
どれかの文字をクォートすることで、そのエイリアスの置換を防ぐことが
できます。エイリアスをクォートする普通の方法は、そのエイリアスの前に
バックスラッシュを置くことです。)
<B>ヒストリ置換</B>は、バックスラッシュを用いることで防ぐことが
できますが、単一引用符では防ぐことができません。。
二重引用符、逆引用符でクォートされた文字列は、
<B>変数置換</B>と<B>コマンド置換</B>は受けますが、
その他の置換は受けません。
<P>

単一引用符、二重引用符で囲まれたテキストは 1 つの単語 (または
その一部) となります。
それらの文字列中のメタ文字 (空白、タブを含む) は、単語を分割しません。
ひとつだけ特殊な場合 (次の<B>コマンド置換</B>を参照) として、
二重引用符で囲まれた文字列を 1 つ以上の単語に分けることができます。
これは、単一引用符で囲まれた文字列では決してできません。
逆引用符は特殊で、<B>コマンド置換</B> (そちらも参照) に、
影響を与え、その結果が 1 つ以上の単語になることもあります。
<P>

複雑な文字列をクォートする場合、特に、文字列自身にクォート文字が
含まれている場合は、わかりにくいかもしれません。
人間が書いたものの中では、引用符を引用のために使う必要はないことを
忘れないように!
文字列全体をクォートするのではなく、もし適当ならば異なるタイプの
引用符を用い、クォートする必要のある文字列の一部分のみをクォートする
ことの方が、簡単かもしれません。
<P>

シェル変数 <B>backslash_quote</B> (そちらも参照) を
セットすると、
バックスラッシュが常に `\', `'', `&quot;' をクォートするようにできます。(+)
これによって、複雑な引用をする仕事が簡単になるかもしれません。
しかし <I>csh</I>(1) のスクリプトでは、構文エラーの原因になります。
<A NAME="lbAM">&nbsp;</A>
<H3>置換</H3>

ここで、シェルが入力に対して行うさまざまな変換を、
処理が行われる順に記述します。同時に、処理に関わるデータ構造と、
データ構造に影響を与えるコマンドと変数とにも触れておきます。
<B>字句構造</B>のところで説明する引用により、置換を抑制できることを
覚えておいてください。
<A NAME="lbAN">&nbsp;</A>
<H3>ヒストリ置換</H3>

端末から入力したコマンドひとつひとつ (イベント) は、ヒストリリストに
保存されます。直前のコマンドは常に保存されます。さらに、保存する
コマンド数を、シェル変数 <B>history</B> に設定することができます。
重複するイベントを保存するかどうか、同じイベントの連続をそのまま
保存するかどうかを、シェル変数 <B>histdup</B> に設定することが
できます。
<P>

保存されたコマンドには、1 から始まる連続した番号が振られ、
タイムスタンプが打たれます。普通イベント番号を用いる必要はありませんが、
シェル変数 <B>prompt</B> の中に `!' を置くことで、現在のイベント番号を
プロンプトの一部にすることができます。
<P>

実際のところ、シェルは、ヒストリを展開形式と
文字どおり (未展開) の形式とで保存しています。
シェル変数 <B>histlit</B> を設定しておくと、
ヒストリを表示する / ヒストリに保存するコマンドで
文字どおりの形式を用いるようになります。
<P>

組み込みコマンド <I>history</I> により、ヒストリリストの表示、
ファイルに保存、ファイルからの読み込み、クリアをいつでも行えます。
シェル変数 <B>savehist</B> と <B>histfile</B> により、
ヒストリリストのログアウト時の自動保存と、ログイン時の自動読み込みを
設定することができます。
<P>

ヒストリ置換により、ヒストリリストから単語の列を入力ストリームに
持ち込みます。これにより、前のコマンドの繰り返し、前のコマンドで使った
引数の繰り返し、前のコマンドで間違えたスペルの修正を
わずかなキー入力で、かなり確実に
容易に行うことができるようになります。
<P>

ヒストリ置換は、文字 `!' で始まります。ヒストリ置換は、
入力ストリームのどこから開始してもかまいませんが、入れ子には
できません。
文字 `!' の前に `\' を置くことで、`!' の特殊な意味を打ち消すことが
できます。文字 `!' が、空白文字、タブ文字、改行文字、`='、`(' の
前にある場合は、そうした方が便利なので、無変更のまま渡されます。
入力行が `^' で始まる場合にも、ヒストリ置換が生じます。
この省略表現については後で説明します。
ヒストリ置換を示すための文字 (`!' と `^') は、
シェル変数 <B>histchars</B> を設定することにより変更することが
できます。入力行がヒストリ置換を含む場合、実行前に置換結果が
常に表示されます。
<P>

ヒストリ置換には「イベント指定」、「単語指定子 (word designator)」、
「修飾子 (modifier)」を含めることができます。イベント指定は、
どのイベントから単語の列を取り出すかを指定します。単語指定子は、
選択したイベントからどの単語を選ぶかを指定します。修飾子は、
選択した単語をどう操作するかを指定します。
<P>

イベント指定には、次のものがあります。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><I>n</I>

<DD>
番号: これはある特定のイベントを指定します。
<DT>-<I>n</I><DD>
オフセット: これは現在のイベントの前 <I>n</I> 個目のイベントを
指定します。
<DT>#<DD>
現在のイベントを指定します。これは <I>csh</I>(1) の中では注意して
扱わねばなりません。<I>csh</I>(1) では、再帰呼び出しのチェックを
していないからです。<I>tcsh</I> では、再帰呼び出しは 10 レベルまで
許されています。(+)
<DT>!<DD>
1 つ前のイベントを指定します (`-1' と等価)。
<DT><I>s</I>

<DD>
先頭の単語が <I>s</I> で始まるイベントのうち、最も新しいものを
指定します。
<DT>?<I>s</I>?<DD>
文字列 <I>s</I> を含むイベントのうち、最も新しいものを指定します。
直後が改行文字の場合は、2 番目の `?' は省略可能です。
</DL>
</DL>


<P>

たとえば、次のようなヒストリリストがあるとします。
<DL COMPACT>
<DT><DD>
&nbsp;9  8:30    nroff -man wumpus.man
<BR>

10  8:31    cp wumpus.man wumpus.man.old
<BR>

11  8:36    vi wumpus.man
<BR>

12  8:37    diff wumpus.man.old wumpus.man
</DL>
<P>

コマンドが、イベント番号とタイムスタンプ付きで表示されています。
現在のイベントは、まだ入力していませんが、イベント 13 です。
`!11' と `!-2' は、イベント 11 を指します。`!!' は、直前の
イベントであるイベント 12 を指します。`!!' は、後ろに `:' が
付いている場合、`!' と省略することができます
(`:' は後で説明します)。`!n' は、`n' から始まっている、
イベント 9 を指します。`!?old?' は、`old' を含んでいる
イベント 12 を指します。単語指示子も単語修飾子もどちらも含まない場合、
ヒストリ参照はそのイベント全体を展開するだけです。ですから、
コピーコマンドを再実行したいときは `!cp' と入力しますし、`diff' の
出力が画面上端からスクロールして消えてしまう場合、`!!|more' と
入力します。
<P>

必要に応じ、中括弧で囲むことで、ヒストリ置換を前後のテキストから
分離することができます。たとえば、`!vdoc' とすると、`vdoc' で始まる
コマンドを探しますが、この例で見つからないにしても、`!{v}doc' では、
あいまいさもなく `vi wumpus.mandoc' に展開されます。
中括弧の中でも、ヒストリ置換は入れ子になりません。
<P>

(+) <I>csh</I>(1) では、たとえば `!3d' は、イベント 3 の後ろに
英文字 `d' を付加して展開しますが、<I>tcsh</I> では、これを `3d' で
始まるイベントのうち最新のものに展開します。つまり、完全な数値引数
だけをイベント番号と見なします。これにより、数字から始まるイベントを
呼び出すことが可能となります。`!3d' を <I>csh</I>(1) のように
展開させるには、`!\3d' と指定してください。
<P>

イベントから単語を選択する場合、`:' と選択する単語を表す指示子を使い、
イベント指定を行うことができます。入力行の単語には、0 から始まる
番号が振られています。最初の単語 (普通、コマンドです) は 0 で、
2 番目の単語 (第 1 引数) は 1 といった具合です。基本的な単語指示子は
次のようになります。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>0<DD>
最初の単語 (コマンド)
<DT><I>n</I>

<DD>
<I>n</I> 番目の引数
<DT>^<DD>
最初の引数、`1' と等価
<DT>$<DD>
最後の引数
<DT>%<DD>
?<I>s</I>? 検索で一致した単語
<DT>x-y<DD>
ある範囲の単語
<DT><I>-y</I>

<DD>
<I>`0-y'</I> と等価
<DT>*<DD>
`^-$' と等価。但し、イベントが 1 単語しか含まない場合は何も返さない。
<DT><I>x*</I>

<DD>
<I>`x-$'</I> と等価
<DT><I>x-</I>

<DD>
<I>`x*'</I> と等価。但し、最後の単語 (`$') は除く。

</DL>
</DL>

<P>

選択した単語は、空白文字 1 つで区切られてコマンド行に挿入されます。
たとえば、`diff !!:1.old !!:1' と打ち込むことで、先の例の
`diff' コマンドを入力することもできます (`:1' で、直前のイベントから
最初の引数を選択しています)。また、`diff !-2:2 !-2:1' と
打ち込むことで `cp' コマンドの引数を選択し、入れ換えることができます。
`diff' コマンドの引数の順番を気にしなければ、`diff !-2:1-2' と
打ち込んでも構いませんし、単に `diff !-2:*' でも構いません。
`cp' コマンドは、現在のイベントを指す `#' を使い、
`cp wumpus.man !#:1.old' と書くことができます。`!n:- hurkle.man' は、
`nroff' コマンドから最初の 2 単語を再利用し、
`nroff -man hurkle.man' とすることになります。
<P>

文字 `:' は単語指定からイベント指定を分離しますが、引数選択子が
`^', `$', `*', `%', `-' で始まるとき、この文字 `:' は省略可能
です。たとえば、先ほどの `diff' コマンドは `diff !!^.old !!^'
もしくは `diff !!$.old !!$' でも構わなかったのです。
しかし、`!!' が `!' に省略可能である場合、`-' で始まる引数選択子は
イベント指定として解釈されます。
<P>

ヒストリ参照に、イベント指定のない単語指示子があっても構いません。
その場合、直前のコマンドを参照します。

`diff' の例を続けるなら、単純に `diff !^.old !^' と入力することが
できます。もしくは、逆順の引数を得るだけならば、単に `diff !*' で
いいです。
<P>

ヒストリ参照の中の単語は編集可能です。つまり、単語の後ろに 1 つまたは
複数の修飾子 (修飾子それぞれは `:' で始まります) を付けることで
「修飾」可能です。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>h<DD>
先頭のもの 1 つを残し、パス名の構成要素の後ろの部分を削除します。
<DT>t<DD>
末尾のもの 1 つを残し、パス名の構成要素の先頭の部分を削除します。
<DT>r<DD>
ファイル名拡張子 `.xxx' を削除し、名前の基本部分だけを残します。
<DT>e<DD>
拡張子だけを残し、他をすべて削除します。
<DT>u<DD>
最初の英小文字を大文字に変換します。
<DT>l<DD>
最初の英大文字を小文字に変換します。
<DT>s<I>/l/r/</I><DD>
<I>l</I> を <I>r</I> で置換します。
<I>l</I> は <I>r</I> と同様に、単なる文字列です。名付け親である <I><A HREF="../../GNU_ed/man1/ed.1.html">ed</A></I>(1)
コマンドのような正規表現ではありません。
`/' の代わりに任意の文字を区切り文字として使うことができます。
`\' を使い、<I>l</I> や <I>r</I> の中で区切り文字をクォートすることが
できます。
<I>r</I> 中の文字 `&amp;' は、<I>l</I> で置き換えられます。`\' で `&amp;' も
クォートできます。<I>l</I> が空 (``'') の場合、以前の置換の <I>l</I> 、
または以前のイベント指定 `?<I>s</I>?' の <I>s</I> を使用します。
最後の区切り文字の直後が改行文字の場合、その区切り文字を省略できます。
<DT>&amp;<DD>
以前の置換を繰り返します。
<DT>g<DD>
後ろの修飾子を単語それぞれに適用します。
<DT>a (+)<DD>
後ろの修飾子を、ある単語だけにできるだけ多くの回数、適用します。
`a' と `g' をいっしょに用いて、修飾子をグローバルに適用することが
できます。現在の実装では、修飾子 `a' と修飾子 `s' を同時に使用すると、
無限ループに陥る可能性があります。たとえば、`:as/f/ff/' は決して
終わりません。この動作は今後変更されるかもしれません。
<DT>p<DD>
新しいコマンド行を表示しますが、実行はしません。
<DT>q<DD>
置換された単語をクォートし、それ以上の置換が起きないようにします。
<DT>x<DD>
q と同じです。ただし、単語を空白 / タブ / 改行文字のところで分割します。

</DL>
</DL>

<P>

修飾子は最初に見つかった修飾可能な単語だけに適用されます (`g' を
使用しない限り)。修飾可能な単語がない場合はエラーになります。
<P>

たとえば、先の例の `diff' コマンドは、`diff wumpus.man.old !#^:r' とも
書くことができます。これは、`r' を用いて、同じ行 (`!#^') の最初の
引数から `.old' を削除しています。`echo hello out there' と
言っておいてから、`echo !*:u' を使い `hello' を大文字にできます。
`echo !*:au' を使い大声で言うようにできます。`echo !*:agu' を使い
絶叫させることもできます。`mail -s &quot;I forgot my password&quot; rot'
の後で `!:s/rot/root' を続けることで、`root' のスペル間違いを直すこと
ができます (スペル間違いの訂正については、<B>スペル訂正</B>の項に
別のやり方があります)。
<P>

置換には特別な省略記法があります。`^' が入力行の先頭にある場合、
`!:s^' と等価です。よって、先の例でスペルを訂正するには、
^rot^root と言うこともできたわけです。これは明示的に `!' で
始まらないヒストリ置換としては唯一のものです。
<P>

(+) <I>csh</I> では、ヒストリ展開または変数展開に適用される修飾子は
1 つだけです。<I>tcsh</I> では、1 つ以上の修飾子が使用される可能性が
あります。たとえば、次のような場合を考えます。
<DL COMPACT>
<DT><DD>
% mv wumpus.man /usr/man/man1/wumpus.1
<BR>

% man !$:t:r
<BR>

man wumpus
<P>
</DL>
<P>

<I>csh</I> では、この結果は `wumpus.1:r' となります。コロンが後ろに続く
置換は、中括弧を用いてコロンと区切る必要があります。
<DL COMPACT>
<DT><DD>
&gt; mv a.out /usr/games/wumpus
<BR>

&gt; setenv PATH !$:h:$PATH
<BR>

Bad ! modifier: $.
<BR>

&gt; setenv PATH !{-2$:h}:$PATH
<BR>

setenv PATH /usr/games:/bin:/usr/bin:.
</DL>
<P>

最初の試みは <I>csh</I> では成功しますが、<I>tcsh</I> では失敗します。
この理由は、<I>tcsh</I> は 2 番目のコロンの後ろに、`$' ではなく
修飾子があると思っているからです。
<P>

最後に、ヒストリはここで説明してきた置換だけでなく、エディタでも
利用することができます。編集コマンド
<I>up-history</I>, <I>down-history</I>,
<I>history-search-backward</I>, <I>history-search-forward</I>,
<I>i-search-back</I>, <I>i-search-fwd</I>,
<I>vi-search-back</I>, <I>vi-search-fwd</I>,
<I>copy-prev-word</I>, <I>insert-last-word</I> は
ヒストリリスト中のイベントを検索し、入力バッファにイベントを
コピーします。編集コマンド <I>toggle-literal-history</I> は、
入力バッファでヒストリ行を展開するか文字どおりに扱うかを切り替えます。
<I>expand-history</I>, <I>expand-line</I> はそれぞれ、現在の単語、
または、入力バッファ全体でヒストリ置換を展開します。
<A NAME="lbAO">&nbsp;</A>
<H3>エイリアス置換</H3>

シェルは、エイリアスのリストを保持しています。このリストは、
<I>alias</I>, <I>unalias</I> コマンドを使って設定、削除、表示する
ことができます。コマンド行を解釈し単純コマンド (<B>コマンド</B>を参照)
に分割したあと、複数のコマンドを左から右へ、それぞれの最初の単語が
エイリアスを持っているかをチェックします。エイリアスを持っている
場合、最初の単語をエイリアスで置き換えます。置き換えたエイリアスが
ヒストリ参照を含む場合、元のコマンドを直前の入力行とみなして、
<B>ヒストリ置換</B> (そちらも参照) が適用されます。
エイリアスがヒストリ置換を含まない場合、引数リストは変更されず
そのままです。
<P>

そのため、たとえば `ls' のエイリアスが `ls -l' だった場合、コマンド
`ls /usr' は `ls -l /usr' になります。ここで、引数リストは
影響を受けません。`lookup' のエイリアスが `grep !^ /etc/passwd'
だとすると、コマンド `lookup bill' は `grep bill /etc/passwd' に
なります。エイリアスを使い、パーザのメタ記法を利用できます。
たとえば、`alias print 'pr \!* | lpr'' は、引数を
ラインプリンタに <I><A HREF="../../0MultiFileIdx/man1/pr.1.html">pr</A></I>(1) する ``コマンド''(`print') を
定義します。
<P>

コマンドの最初の単語がエイリアスを持たなくなるまで、エイリアス置換は
繰り返されます。(先の例のように) エイリアス置換が最初の単語を
変更しない場合、そのエイリアスに印を付けてループが生じない
ようにします。それ以外のループは検出され、エラー扱いになります。
<P>

シェルが参照するエイリアスがいくつかあります。<B>特殊エイリアス</B>
を参照してください。
<A NAME="lbAP">&nbsp;</A>
<H3>変数置換</H3>

シェルは変数のリストを管理しており、それらは 0 個またはそれ以上の
個数の単語のリストを値として持ちます。シェル変数の値は、コマンド
<I>set</I>, <I>unset</I> により表示、変更することができます。システムは、
自分自身の ``環境'' 変数のリストを保持しています。環境変数は
コマンド <I>printenv</I>, <I>setenv</I>, <I>unsetenv</I> により表示、
変更することができます。
<P>

(+) `set -r' (参照) により変数を読み出し専用にすることが
できます。読み出し専用変数は、変更や unset ができません。これを
試みるとエラーになります。一度読み出し専用にした変数は、
書き込み可能に戻すことはできません。ですから、`set -r' は
注意して使用する必要があります。環境変数は読み出し専用に
することはできません。
<P>

シェルが設定、参照する変数がいくつかあります。たとえば、変数 <B>argv</B>
は、シェルの引数リストの複製で、この変数の値である単語は特別な方法で
参照されます。シェルが参照する変数の中には、トグルスイッチがあります。
シェルは、これらの変数が何の値を持っているかではなく、値が設定されて
いるかどうかにだけ影響を受けます。たとえば、変数 <B>verbose</B> は、
コマンド入力をエコーするかどうかを制御するトグルスイッチです。
コマンド行オプション <B>-v</B> がこの変数に値を設定します。
シェルが参照する変数すべてのリストは、<B>特別なシェル変数</B>にあります。
<P>

変数を数値として扱う操作もあります。コマンド `@' により、
数値計算を実行し、結果を変数に代入することが可能となります。
しかしながら、変数の値は常に (0 個以上の) 文字列として表現されて
います。数値として扱うために、空文字列は 0 と見なされます。
複数の単語からなる値の、2 番目以後の単語は無視されます。
<P>

入力行のエイリアス処理を終え、字句解析を終えた後で、そして、
各コマンドを実行する前に、`$' 文字をキーとして変数置換が行われます。
この展開は `$' の前に `\' を置くことで抑止できます。ただし、`&quot;' の
中は別で、ここでは<I>常に</I>変数置換が行われます。また、`'' の中も
別で、ここでは<I>決して</I>変数置換が行われません。``' で
クォートした文字列は後で解釈されますから、
(後の<B>コマンド置換</B>を参照)
そこでの `$' 置換は後になるまで行われません。`$' の後ろが空白、
タブ、改行文字の場合は、`$' 置換は発生しません。
<P>

入出力リダイレクトは、変数展開の前に識別され、別々に変数展開されます。
それ以外では、コマンド名と引数リスト全体が一緒に展開されます。ですから、
(この時点での) 最初の単語 (コマンド) から 2 つ以上の単語が生成される
可能性があります。展開後の複数の単語のうち最初のものがコマンド名となり、
残りの単語は引数になります。
<P>

`&quot;' で囲まれているか、修飾子 `:q' が指定されている場合を除き、
最終的には、変数置換の結果に対し、コマンド置換とファイル名置換が
適用されます。`&quot;' で囲まれている場合、値が複数の単語で構成される変数は、
1 つの単語 (の一部) に展開されます。
この単語には、その変数の値である単語が空白で区切られたものを
含みます。置換の際に修飾子 `:q' が適用される場合、変数は複数の単語に
展開されます。それぞれの単語は空白で区切られ、以後、コマンド置換と
ファイル名置換が適用されないようにクォートされます。
<P>

シェルへの入力に変数の値を持ち込むための方法として、以下の構文が
あります。特に注がない限り、設定されていない値の参照はエラーになります。
<P>


$<I>name</I>
<DL COMPACT>
<DT>${<I>name</I>}<DD>
変数 <I>name</I> の値である単語に置換します。この単語は、
それぞれが空白で区切られたものです。
中括弧は <I>name</I> とそれ以後の文字列とを分離し、以後の文字列も含めて
1 つの変数名として解釈されないようにします。シェル変数の名前は上限が
20 文字であり、先頭は英文字で、2 文字目以後は英文字か数字で
構成されます。アンダスコアは英文字と見なします。<I>name</I> が
シェル変数ではないが、環境に設定されている場合、環境の値を返します
(ただし、修飾子 `:' と次で示す他の形式は利用可能です)。
</DL>
<P>

$<I>name</I>[<I>selector</I>]
<DL COMPACT>
<DT>${<I>name</I>[<I>selector</I>]}<DD>
<I>name</I> の値のうち選択した単語のみで置換します。<I>selector</I> は
`$' 置換が適用され、1 つの数値または `-' で区切った 2 つの数値で
構成することができます。変数の値の先頭の単語は 1 番目として数えます。
範囲の最初の値を省略した場合、デフォルトの値 1 になります。範囲の
最後の数値を省略した場合、デフォルトの値 `$#<I>name</I> になります。
<I>selector</I> `*' はすべての単語を選択します。2 番目の引数が
省略されるか、あるいは範囲に収まっている場合、範囲が空になっても
エラーになりません。
<DT>$0<DD>
コマンド入力を読み込んでいるファイル名で置換します。ファイル名が
不明の場合エラーになります。
</DL>
<P>

$<I>number</I>
<DL COMPACT>
<DT>${<I>number</I>}<DD>
`$argv[<I>number</I>]' と等価です。
<DT>$*<DD>
`$argv' と等価です。これは `$argv[*]' と等価です。

</DL>
<P>

<B>ヒストリ置換</B>のところで説明した `:' 修飾子 (`:p' を除く) が、
上記の置換に対して適用できます。2 つ以上の修飾子も適用できます。
(+) <B>ヒストリ置換</B> (そちらも参照) と同様に、
変数置換とリテラルのコロンとを分離するために、中括弧が必要なことが
あります。修飾子は中括弧の中に置かねばなりません。
<P>

以下の置換は `:' 修飾子で修飾することはできません。
<P>


$?<I>name</I>
<DL COMPACT>
<DT>${?<I>name</I>}<DD>
<I>name</I> が設定されているときは、文字列 `1' で置き換えられます。
設定されていないときは、文字列 `0' で置き換えられます。
<DT>$?0<DD>
現在の入力ファイル名がわかっているときは、`1' で置き換えられます。
わかっていないときは、`0' で置き換えられます。
対話型のシェルでは、常に `0' です。
</DL>
<P>

$#<I>name</I>
<DL COMPACT>
<DT>${#<I>name</I>}<DD>
<I>name</I> 中の単語の数で置き換えられます。
<DT>$#<DD>
`$#argv' と等価です。(+)
</DL>
<P>

$%<I>name</I>
<DL COMPACT>
<DT>${%<I>name</I>}<DD>
<I>name</I> の文字数で置き換えられます。(+)
</DL>
<P>

$%<I>number</I>
<DL COMPACT>
<DT>${%<I>number</I>}<DD>
$argv[<I>number</I>] の文字数で置き換えられます。(+)
<DT>$?<DD>
`$status' と等価です。(+)
<DT>$$<DD>
(親) シェルの (10 進数の) プロセス番号で置き換えられます。
<DT>$!<DD>
本シェルが開始したバックグラウンドプロセスのうち最新のものの
(10 進数の) プロセス番号で置き換えられます。(+)
<DT>$_<DD>
最後に実行したコマンドのコマンド行で置き換えます。(+)
<DT>$&lt;<DD>
標準入力から読み込んだ 1 行を、一切解釈をせずにこの変数と置き換えます。
シェルスクリプト中で、キーボードから読み込む際に用います。(+)
<I>csh</I> は、`$&lt;:q' と等価であるかのように、$&lt; をクォートしますが、
<I>tcsh</I> はそうしません。それだけでなく、<I>tcsh</I> がユーザの
入力行を待つとき、ユーザは割り込みを入力して、置換されるべき行が
入る列を中断することができます。しかし <I>csh</I> ではそうすることが
できません。

</DL>
<P>

編集コマンド <I>expand-variables</I> は、
通常は `^X-$' にバインドされていますが、
これを使って、個々の変数を対話的に展開することができます。
<A NAME="lbAQ">&nbsp;</A>
<H3>コマンド置換、ファイル名置換、ディレクトリスタック置換</H3>

組み込みコマンドの引数に対し、残りの置換が選択的に適用されます。
選択的とは、行の中で評価されなかった部分は、これらの展開の対象に
ならないという意味です。シェルの内部コマンドでないコマンドに対しては、
コマンド名は引数リストとは別個に置換されます。この置換は最後の方、
入出力リダイレクトを実行したあと、メインシェルの子供の中で生じます。
<A NAME="lbAR">&nbsp;</A>
<H3>コマンド置換</H3>

``' で囲まれたコマンドは、コマンド置換を示します。囲まれたコマンドの
出力を、空白、タブ、改行文字のところで別々の単語に分割します。
この出力に変数置換、コマンド置換を実行し、
元の文字列があった場所に置きます。
<P>

ニ重引用符 (`&quot;') の内側のコマンド置換は、空白、タブを保存します。
改行文字だけは新しく単語分けを行います。
ただし、どのような場合でも最後の改行文字だけは新しい単語になりません。
ですから、1 行まるまる出力するようなコマンドでも、コマンド置換を
用いると単語の一部だけを生成することができます。
<A NAME="lbAS">&nbsp;</A>
<H3>ファイル名置換</H3>

単語が `*', `?', `[', `{' のいずれかの文字を含む場合、または先頭が `~'
で始まる場合、その単語はファイル名置換 (あるいはグロブ (globbing) と
呼ばれます) の候補になります。このような単語をパターン
(グロブパターン) と見なし、そのパターンにマッチするファイル名の
リストをアルファベット順で整列したもので置き換えます。
<P>

ファイル名マッチの際に、ファイル名の先頭、または `/' の直後の
文字 `.' は、`/' と同様に、明示的にマッチさせなければなりません。
文字 `*' は、空文字列を含むどのような文字列にもマッチします。
文字 `?' は、どのような 1 文字にもマッチします。列 `[...]' は、
括弧の中で指定した文字のいずれかにマッチします。`[...]' 内では、
文字の対を `-' でつなぐことで、(文字順序で) その 2 文字の範囲にある
文字のいずれかにマッチします。
<P>

(+) グロブパターンの中には反転を指定できるものがあります。
列 `[^...]' は、括弧内の文字 / 範囲で指定して<I>いない</I>文字
ちょうど 1 つにマッチします。
<P>

`^' により、グロブパターン全体を反転させることもできます。
<DL COMPACT>
<DT><DD>
&gt; echo *
<BR>

bang crash crunch ouch
<BR>

&gt; echo ^cr*
<BR>

bang ouch
</DL>
<P>

`?', `*', `[]' のいずれも使わないグロブパターンや、
`{}', `~' (あとで説明します) を使うグロブパターンは、
反転しても正しい結果を得られません。
<P>

メタ記法 `a{b,c,d}e' は、`abe ace ade' の省略記法です。左から右への
出現順序は保存されます。`/usr/source/s1/{oldls,ls}.c' は、
`/usr/source/s1/oldls.c /usr/source/s1/ls.c' に展開します。
マッチングの結果は下位のレベルで個別に整列され、出現順序は保存
されます。
`../{memo,*box}' は、`../memo ../box ../mbox' などに
展開されるでしょう (ここで、`memo' が `*box' のマッチング結果とともに
整列されていないことに注意してください)。この指定が展開された結果
ファイルが存在しなくてもエラーになりませんが、展開結果を渡した先の
コマンドでエラーになる可能性はあります。この指定は入れ子にすることが
できます。特殊な場合として、単語 `{', `}', `{}' は変更されずに
そのまま渡されます。
<P>

ファイル名先頭の文字 `~' は、ホームディレクトリを指します。単独で
用いられた場合、つまり `~' だけの場合、シェル変数 <B>home</B> の値に
反映されているように、呼び出したユーザの
ホームディレクトリに展開されます。`~' の直後に英文字、
数字、または文字 `-' で構成される名前が続く場合、シェルはその
名前を持つユーザを検索し、そのユーザのホームディレクトリに展開します。
ですから、`~ken' はたとえば `/usr/ken' に展開されます。
また、`~ken/chmach'は、たとえば `/usr/ken/chmach' に展開されます。
文字 `~' の後ろに英文字でもなく `/' でもない文字が続いた場合、
もしくは、文字 `~' が単語の先頭以外に現れた場合、変更されずに
そのまま渡されます。ですから、
`setenv MANPATH /usr/man:/usr/local/man:~/lib/man' のようなコマンド
では、期待通りのホームディレクトリ置換が起こりません。
<P>

`*', `?', `[', `~' のどれかを含むグロブパターン
(`^' は付いていてもいなくとも同じ) は、マッチするファイルが
ひとつもないとエラーになります。
しかし、グロブパターンのリストのうちのひとつでも
マッチすれば (他のものはマッチするものがなくても) エラーになりません
(したがって、たとえば `rm *.a *.c *.o' は、カレントディレクトリに
`.a', `.c', `.o' で終わるファイルがひとつもないときに限って
エラーになります)。
また、シェル変数 <B>nonomatch</B> が設定されている場合、
どれにもマッチしないパターン (あるいはパターンの列) は
エラーにならずに無変換のまま残されます。
<P>

ファイル名置換を止めるために、シェル変数 <B>noglob</B> を設定することが
できます。編集コマンド <I>expand-glob</I> は、通常は `^X-*' に結合されて
いますが、これを使い、個々のファイル名置換の展開を対話的に
行うことができます。
<A NAME="lbAT">&nbsp;</A>
<H3>ディレクトリスタック置換 (+)</H3>

ディレクトリスタックはディレクトリの列であり、0 から番号付けられ、
組み込みコマンド <I>pushd</I>, <I>popd</I>, <I>dirs</I>
(そちらも参照) が使用します。
<I>dirs</I> コマンドを使用すると、ディレクトリスタックを
いつでも表示でき、ファイルに書き込むことができ、
ファイルから読み込むことができ、そしてクリアすることが
できます。シェル変数 <B>savedirs</B>, <B>dirsfile</B> に
値を設定することで、ログアウト時のディレクトリスタックの書き込みと、
ログイン時の読み込みを自動的に行うことができます。シェル変数
<B>dirstack</B> を使い、ディレクトリスタックの中を調べることができ、
ディレクトリスタックに任意のディレクトリを設定することができます。
<P>

文字 `=' の後ろに 1 桁以上の数字が続くと、それは
ディレクトリスタック中のエントリに展開されます。特殊な場合として、
`=-' はスタックの最新のディレクトリに展開します。たとえば、
次のようにです。
<DL COMPACT>
<DT><DD>
&gt; dirs -v
<BR>

0       /usr/bin
<BR>

1       /usr/spool/uucp
<BR>

2       /usr/accts/sys
<BR>

&gt; echo =1
<BR>

/usr/spool/uucp
<BR>

<BR>&nbsp;echo&nbsp;=0/calendar
<BR>

/usr/bin/calendar
<BR>

&gt; echo =-
<BR>

/usr/accts/sys
</DL>
<P>

シェル変数 <B>noglob</B>, <B>nonomatch</B> と編集コマンド
<I>expand-glob</I> はファイル名置換と同様に
ディレクトリスタックにも適用されます。
<A NAME="lbAU">&nbsp;</A>
<H3>その他の置換 (+)</H3>

ファイル名を含む変換が他にいくつかあります。厳密には先に説明した
ものと関係があるわけではありませんが、完全を期するために
ここで説明しておきます。変数 <B>symlinks</B> (そちらも参照)
が `expand' に設定されている場合、<I>どのような</I>ファイル名も
フルパスに展開される可能性があります。クォートすることで
この展開を止めることができ、編集コマンド <I>normalize-path</I> を
使用すると要求に応じて展開を止めることができます。また、編集コマンド
<I>normalize-command</I> は、PATH にあるコマンドを、
要求に応じてフルパスに展開します。
最後に、<I>cd</I> と <I>pushd</I> は `-' を以前の作業ディレクトリ
(シェル変数 <B>owd</B> と等価) と解釈します。これは置換でもなんでも
なく、このコマンドだけで認識される省略記法です。それでも、この表記も
クォートすることでこの解釈を止めることができます。
<A NAME="lbAV">&nbsp;</A>
<H3>コマンド</H3>

次の 3 つのセクションでは、シェルがどのようにコマンドを実行し、
それらの入出力をどのように扱うかを説明します。
<A NAME="lbAW">&nbsp;</A>
<H3>単純コマンド、パイプライン、コマンド列</H3>

単純コマンドは、単語の列であり、
その最初の単語が実行されるコマンドです。
`|' 文字によって区切られた一連の単純コマンドは
パイプラインを形成します。
パイプライン内のそれぞれのコマンドの出力は次のコマンドの
入力に接続されます。
<P>

単純コマンドとパイプラインは `;' 文字を使って
コマンド列に組み入れることができ、並んでいる順に実行されます。
コマンドとパイプラインは `||' や `&amp;&amp;' でコマンド列に
組み込むこともでき、C 言語で扱われるのと同様に、
最初のコマンドが失敗した時にだけ (`||'の場合)、
あるいは成功した時にだけ (`&amp;&amp;'の場合)、次のコマンドが実行されます。
<P>

単純コマンド、パイプライン、またはコマンド列は、
括弧 `()' を使って単純コマンドを形成することができ、
パイプラインやコマンド列の一部として使用できます。
コマンド、パイプライン、またはコマンド列の後に `&amp;' を
置いて実行すると、そのコマンドの終了を待たずに
次のコマンドを実行できます。
<A NAME="lbAX">&nbsp;</A>
<H3>組み込みコマンド、非組み込みコマンドの実行</H3>

組み込みコマンドは、シェルの中で実行されます。
パイプラインの構成要素の最後以外が組み込みコマンドのとき、
パイプラインは、サブシェル内で実行されます。
<P>

括弧で括られたコマンドは、常にサブシェル内で実行されます。
<DL COMPACT>
<DT><DD>
(cd; pwd); pwd
</DL>
<P>

これは、現在のディレクトリを移動することなくく<B>ホーム</B>
ディレクトリを表示 (その後に現在のディレクトリを表示) し、
その一方、
<DL COMPACT>
<DT><DD>
cd; pwd
</DL>
<P>

この場合は<B>ホーム</B>ディレクトリに移動します。
括弧で括られたコマンドは、たいてい <I>cd</I> が現在のシェルに
影響するのを防ぐために使用します。
<P>

実行するコマンドが組み込みコマンドでないことが判明すると、
シェルはそのコマンドを <I><A HREF="../../LDP_man-pages/man2/execve.2.html">execve</A></I>(2) を通じて実行しようとします。
環境変数 <B>path</B> 内の各語は、シェルがコマンドを検索する
ディレクトリを指定します。
<B>-c</B>, <B>-t</B> オプションのいずれも指定されていない場合、
これらのディレクトリ内の名前を内部テーブルでハッシュし、
そのコマンドが存在する可能性のあるディレクトリだけで
<I><A HREF="../../LDP_man-pages/man2/execve.2.html">execve</A></I>(2) の実行を試みます。
このことは、検索パス内のディレクトリの数が多い場合に、
コマンドの位置確定を大いに高速化します。
この機構が (<I>unhash</I> によって) オフにされ、
シェルに <B>-c</B> または <B>-t</B> のオプションが与えられるか、
それぞれの <B>path</B> のディレクトリ構成要素のいずれかが
`/' で始まっていない場合、シェルは現在の作業ディレクトリと
与えられたコマンド名を結合して実行するファイルのパス名を形成します。
<P>

ファイルに実行許可であってシステムが実行可能ではない場合、
(例 : 実行可能バイナリ、インタプリンタを指定したスクリプト
ではないとき)、それをシェルコマンドを含むファイルであるとみなし、
新しいシェルを起動してそのファイルを読み込みます。
<I>シェル</I>の特殊なエイリアスで、シェル自体ではなくインタプリタを
指定するように設定することもできます。
<P>

慣習的な‘#!' スクリプトインタプリタを理解しないシステム上では、
シェルはそれをエミュレートするようにコンパイルされます ; シェル変数
<B>version</B> を参照してください。
その場合、シェルがファイルの最初の行をチェックし、それが
`#!<I>interpreter</I> <I>arg</I> ...' の形式であるかどうかを
確認します。
この形式であれば、シェルは与えられた<I>引数</I>とともに
<I>インタプリタ</I>を起動して、そのファイルを標準入力に供給します。
<A NAME="lbAY">&nbsp;</A>
<H3>入出力</H3>

コマンドの標準入力と標準出力は以下の文法に従って
リダイレクトすることができます:
<P>


<DL COMPACT>
<DT>&lt; <I>name<DD>
ファイル name</I> (変数、コマンド、ファイル名展開を受けます)
をオープンし、コマンドの標準入力とします。
<DT>&lt;&lt; <I>word<DD>
word</I> と同一の行が出現するまで、シェルの入力を読み込みます。
<I>word</I> は変数、ファイル名、コマンド置換を受けません。
シェル入力の行は読み込まれるとすぐ、置換を行う前に
<I>word</I> と比較されます。<I>word</I> に `\', `&quot;', `'', ``'
のクォートが出現しなければ、行の中でコマンド置換が実行されます。
この置換を抑制するために、`\' によって
`$', `\', ``' をクォートすることができます。コマンド置換において、
すべての空白、タブ、改行は保存されますが、最後の改行は削除されます。
読み込んだ行はすべてテンポラリファイルに保存され、
コマンドの標準入力として用いられます。
</DL>
<P>

&gt; <I>name
<BR>

&gt;! name
<BR>

&gt;&amp; name
<DL COMPACT>
<DT>&gt;&amp;! name<DD>
ファイル name</I> を標準出力として用います。
ファイルが存在しなければ作成されます。すでにファイルが存在すれば
その内容は切り捨てられ、以前の内容は失われます。
<DL COMPACT><DT><DD>

<P>

シェル変数 <B>noclobber</B> がセットされている場合、
ファイルが存在しないか文字型特殊ファイル
(端末や `/dev/null' のような) でなければ
エラーになります。これは、すでに存在するファイルを間違えて
削除してしまうことを防止します。`!' を用いた形式を使うと、
この検査を抑制することができます。
<P>

`&amp;' を用いた形式では、標準出力とともに診断メッセージ
出力もファイルへリダイレクトされます。 <I>name</I> は、`&lt;' の
入力ファイル名の場合と同様の展開を受けます。

</DL>

</DL>
<P>

&gt;&gt; <I>name
<BR>

&gt;&gt;&amp; name
<BR>

&gt;&gt;! name
<DL COMPACT>
<DT>&gt;&gt;&amp;! name<DD>
`&gt;' と同様に、ファイル name</I> を標準出力として用います。
ただし、コマンドの出力はファイルへ追加されます。
変数 <B>noclobber</B> がセットされている場合、ファイルが
<I>存在しなければ</I>エラーとなります。
`!' を用いることで、この検査を抑制することができます。

</DL>
<P>

コマンドは、シェルが起動されたときの環境を引き継ぎます。
ただしこの環境は入出力のパラメータによって変更されますし、
コマンドがパイプラインの中にあった場合も変更されます。
したがって、以前のいくつかのシェルとは異なり、シェルの
コマンドファイルから起動されたコマンドは、デフォルトでは
そのコマンドのテキストへアクセスできません。かわりに
それらのコマンドは、シェルのもともとの標準入力をそのまま
受け継ぎます。
シェルスクリプトの内部で、コマンドにあらかじめ決まった
(inline) データを渡す場合には、標準入出力の形式ではなく、
`&lt;&lt;' の機構を使うことができます。
このように制限することにより、シェルコマンドスクリプトを
パイプラインの一部として用いることができます。
バックグラウンドで実行されているコマンドの標準入力も
<I>/dev/null</I> 等にリダイレクトされること<I>なく</I>、
シェルの標準入力をそのまま受け継いでいます。
もし標準入力が端末で、コマンドが端末から読み込もうとした場合、
そのプロセスはブロックされ、シェルはユーザにそのことを通知します
(<B>ジョブ</B>の項を参照)。
<P>

診断メッセージ出力もパイプにリダイレクトすることが
できます。単に `|' のかわりに `|&amp;' を使います。
<P>

シェルは、標準出力のリダイレクトなしで、診断メッセージ出力を
リダイレクトできなくなります。
そのため、`(<I>コマンド</I> &gt; <I>出力ファイル</I>) &gt;&amp;
<I>エラーファイル</I>' は、無難な予備手段としてされてます。
<I>出力ファイル</I>、<I>エラーファイル</I>のどちらかが、
端末に出力を送るための `/dev/tty' です。
<A NAME="lbAZ">&nbsp;</A>
<H3>特徴</H3>

ここではシェルがどのようにコマンドラインを受け入れ、
解釈し、実行するかを説明しました。
次は、便利な特徴について説明します。
<A NAME="lbBA">&nbsp;</A>
<H3>制御フロー</H3>

このシェルには、
コマンドファイル (シェルスクリプト) や
(制約はあるものの便利な) 端末からの入力
処理の流れを制御するために使用できる
多くのコマンドを備えています。
これらのコマンドは、
入力の再読み込みや読み飛ばしを行うため
シェルを強制的に操作します。
これらの実装のために、幾つかのコマンドには制限があります。
<P>

<I>foreach</I>、<I>switch</I>、<I>while</I> 文は、
<I>if</I> 文の <I>if-then-else</I> 形式と同様に、
後で示すように入力行の単独の単純コマンド中に
主要なキーワードが現れることを要求します。
<P>

シェルの入力がシーク可能でない場合は、
ループが読み込まれると常に入力をバッファし、
この内部バッファをシークすることでループによる
再読み込みを可能にします。
(これを許可した結果、
後方へ向かう <I>goto</I> がシーク可能でない入力についても
成功することになります。)
<A NAME="lbBB">&nbsp;</A>
<H3>式</H3>

組み込みコマンドの <I>if</I>, <I>while</I>, <I>exit</I> は
共通した文法を持った式を使います。
式には、次の 3 つのセクションの中で説明される
任意の演算子を含めることができます。
<I>@</I> 組み込みコマンド (そちらも参照) 自体は、
文法を区切るので注意してください。
<A NAME="lbBC">&nbsp;</A>
<H3>論理演算子, 算術演算子, 比較演算子</H3>

これらの演算子は C の演算子と
同じ優先順位となっています。
演算子には、次のものがあります。
<DL COMPACT>
<DT><DD>
||  &amp;&amp;  |  ^  &amp;  ==  !=  =~  !~  &lt;=  &gt;=
<BR>

&lt;  &gt; &lt;&lt;  &gt;&gt;  +  -  *  /  %  !  ~  (  )
</DL>
<P>

ここに挙げた演算子は右側のものほど優先順位が高くなっています。
ただし、`==' `!=' `=~' `!~' の 4 つ、`&lt;=' `&gt;=' `&lt;' `&gt;' の 4 つ、
`&lt;&lt;' `&gt;&gt;' の 2 つ、`+' `-' の 2 つ、`*' `/' `%' の 3 つは
それぞれ同一のグループに所属しており、同じグループに所属している
演算子の優先順位は同じレベルとなっています。
演算子 `==' `!=' `=~' `!~' は引数を文字列として比較します。
他の演算子はすべて数値で比較します。
演算子 `=~' `!~' は `!=' `==' と似ていますが、
左側のオペランドにマッチするグロブパターン
(<B>ファイル名置換</B>を参照)
を右側に置くことが異なります。
必要なものに対してだけパターンマッチを行うので、
シェルスクリプト中における
<I>switch</I> 組み込みコマンドの使用の必要を減らします。
<P>

`0' で始まる文字列は 8 進数とみなされます。
空の文字列や引数がぬけているものは `0' とみなされます。
すべての式の結果は 10 進数で表される文字列になります。
特に、式の構成要素が同一の単語中に複数個現れることはないと
いうことに注意してください。
例外として、パーサに文法的に特別な意味を持つ式の構成要素
(`&amp;' `|' `&lt;' `&gt;' `(' `)') が隣りにくることは構いません。
ただし、これらは空白で区切られるべきです。
<A NAME="lbBD">&nbsp;</A>
<H3>コマンド終了ステータス</H3>

式の中でコマンドを実行することができ、
式を中括弧 (`{}') で囲むと
終了ステータスが返されます。
中括弧は、コマンドの単語から空白で区切ることを
忘れないでください。
コマンドの実行が成功した場合は、
真 (たとえば `1') を返します。
コマンドが 0 のステータスで終了した場合、
または実行に失敗した場合は、偽 (たとえば `0') を返します。
もっと詳しいステータスの情報が必要な場合は、
コマンドを式の外部で実行し、
シェル変数 <B>status</B> を調べてください。
<A NAME="lbBE">&nbsp;</A>
<H3>ファイル問い合わせ演算子</H3>

これらの演算子のうち幾つかは
ファイルと関連するオブジェクトについて
真/偽の判定を行います。
これらは <B>-</B><I>op file</I> の形式です。
<I>op</I> は次のうちのどれか 1 つです。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>r</B>

<DD>
読み取りアクセス
<DT><B>w</B>

<DD>
書き込みアクセス
<DT><B>x</B>

<DD>
実行アクセス
<DT><B>X</B>

<DD>
パス中にある実行可能ファイルやシェル組み込みコマンド。
たとえば `-X ls' と `-X ls-F' は一般に真であり、
`-X /bin/ls' はそうではない (+)
<DT><B>e</B>

<DD>
存在
<DT><B>o</B>

<DD>
所有者
<DT><B>z</B>

<DD>
サイズ 0
<DT><B>s</B>

<DD>
サイズが 0 でない (+)
<DT><B>f</B>

<DD>
通常ファイル
<DT><B>d</B>

<DD>
ディレクトリ
<DT><B>l</B>

<DD>
シンボリックリンク (+) *
<DT><B>b</B>

<DD>
ブロック型特殊ファイル (+)
<DT><B>c</B>

<DD>
キャラクタ型特殊ファイル (+)
<DT><B>p</B>

<DD>
名前付きパイプ (fifo) (+) *
<DT><B>S</B>

<DD>
ソケット型特殊ファイル (+) *
<DT><B>u</B>

<DD>
set-user-ID ビットがセットされている (+)
<DT><B>g</B>

<DD>
set-group-ID ビットがセットされている (+)
<DT><B>k</B>

<DD>
スティッキービットがセットされている (+)
<DT><B>t</B>

<DD>
<I>file</I> (これは数字でなければならない) は
端末デバイスに対してオープンしている
ファイル記述子である (+)
<DT><B>R</B>

<DD>
migrate されている (convex システムのみ有効) (+)
<DT><B>L</B>

<DD>
多重演算子の中でこの演算子の後にくる演算子は、
シンボリックリンクが指されているファイルではなく、
シンボリックリンクそのものに適用される (+) *
</DL>
</DL>


<P>

<I>file</I> はコマンドと展開されたファイル名で、
指定された実ユーザに対する関係があるかどうか
テストします。
<I>file</I> が存在していない場合、
もしくはアクセスできない場合、
`*' で示した演算子については、
指定のファイルタイプが現在のシステムに
存在していなければ
すべての問い合わせは偽 (たとえば `0') を返します。
<P>

s true
これらの演算子は、簡潔にするために連結することができます。
`-<I>xy file</I>' は `-<I>x file</I> &amp;&amp; -<I>y file</I>' と等価です。(+)
たとえば `-fx' は
通常の実行可能ファイルに対しては真 (`1' を返す) ですが、
ディレクトリに対してはそうではありません。
<P>

s
<B>L</B> は多重演算子の中で使用できます。
この演算子の後にくる演算子は、
シンボリックリンクが指されているファイルではなく、
シンボリックリンクそのものに適用されます。
たとえば `-lLo' は
呼び出しユーザが所有しているリンクに対しては真です。
<B>Lr</B>, <B>Lw</B>, <B>Lx</B> は
リンクに対しては常に真で、
リンクでないものに対しては偽です。
<B>L</B> は
多重演算子の中で最後の演算子になった場合、
異なった意味を持ちます。
以下を参照してください。
<P>

s
<I>file</I> に渡すべき演算子と、そうでない演算子
(たとえば <B>X</B> と <B>t</B>)
を連結することは可能ですが、
実用的ではなく、しばしば間違いの元になります。
特に、ファイルでない演算子に <B>L</B> をつけると、
妙な結果になります。
<P>

他の演算子は他の情報、つまり単なる `0' や `1' だけ
ではない情報を返します。(+)
これらは前に示したのと同じ書式になります。
<I>op</I> は次のうちのどれか 1 つです。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>A</B>

<DD>
エポックからの秒数で表した、最後にファイルにアクセスした時間
<DT><B>A:</B>

<DD>
<B>A</B> と同じで、タイムスタンプの書式。
例: `Fri May 14 16:36:10 1993'
<DT><B>M</B>

<DD>
最後にファイルを変更した時間
<DT><B>M:</B>

<DD>
<B>M</B> と同じで、タイムスタンプの書式
<DT><B>C</B>

<DD>
最後に inode を変更した時間
<DT><B>C:</B>

<DD>
<B>C</B> と同じで、タイムスタンプの書式
<DT><B>D</B>

<DD>
デバイス番号
<DT><B>I</B>

<DD>
inode 番号
<DT><B>F</B>

<DD>
<I>device</I>:<I>inode</I> の形式で表した
複合 <B>f</B>ile 識別子
<DT><B>L</B>

<DD>
シンボリックリンクが指しているファイルの名前
<DT><B>N</B>

<DD>
(ハード) リンクの数
<DT><B>P</B>

<DD>
先頭に 0 がついていない 8 進数で表したパーミッション
<DT><B>P:</B>

<DD>
<B>P</B> と同じで、先頭に 0 がつく
<DT><B>P</B><I>mode</I>

<DD>
`-P <I>file</I> &amp; <I>mode</I>' と等価。
たとえば、`-P22 <I>file</I>' は
<I>file</I> のグループと他者が書き込み可であれば `22' を、
グループのみであれば `20' を、何もなければ `0' を返す。
<DT><B>P</B><I>mode</I><B>:</B>

<DD>
<B>P</B><I>mode</I><B>:</B> と同じで、先頭に 0 がつく
<DT><B>U</B>

<DD>
数値で表したユーザ ID
<DT><B>U:</B>

<DD>
ユーザ名、ユーザ名が見つからなかった場合は数値で表したユーザ ID
<DT><B>G</B>

<DD>
数値で表したグループ ID
<DT><B>G:</B>

<DD>
グループ名、グループ名が見つからなかった場合は数値で表したグループ ID
<DT><B>Z</B>

<DD>
バイト数で表したサイズ
</DL>
</DL>


<P>

これらの演算子のうち 1 つだけ多重演算子の中に
現れることを許されていますが、必ず最後につける必要があります。
ただし、<B>L</B> は多重演算子の中の
最後とそれ以外の箇所では違った意味になるので注意してください。
なぜなら、`0' はこれらの演算子の多くにとって正当な返り値のためです。
これらが失敗した場合、`0' を返しません。
たいていの場合、`-1' を返し、<B>F</B> は `:' を返します。
<P>

このシェルが POSIX を定義してコンパイルされている
(シェル変数 <B>version</B> を参照)
場合、ファイル問い合わせの結果は、
<I><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></I>(2) システムコールの結果に基づいたものではなく、
ファイルの許可ビットに基づいたものになります。
たとえば、
通常は書き込み可であるが
読み取り専用でマウントされたファイルシステム上にある
ファイルを <B>-w</B> で検査した場合、
POSIX シェルでは成功し、
非 POSIX シェルでは失敗することになります。
<P>

ファイル問い合わせ演算子は
<I>filetest</I> 組み込みコマンド (そちらも参照)
と等価になり得ます。(+)
<A NAME="lbBF">&nbsp;</A>
<H3>ジョブ</H3>

シェルはパイプラインの各々に対し<I>ジョブ</I>を 1 つずつ関連付けます。
シェルは、現在実行中のジョブの一覧表を保持しており、
これは、<I>jobs</I> コマンドによって表示することができます。
ジョブには整数の番号が割り当てられます。
ジョブが `&amp;' を用いて非同期に起動された場合、
シェルは以下のような出力を行います:
<DL COMPACT>
<DT><DD>
[1] 1234
</DL>
<P>

これは、非同期に起動したジョブがジョブ番号 1 であり、
プロセス ID が 1234 である (トップレベルの) プロセスを
1 つ持っていることを示します。
<P>

もし、あるジョブを実行中に他のことをしたくなった場合、サスペンドキー
(通常 ^Z) を押すことにより実行中のジョブに
STOP シグナルを送信することができます。
通常、シェルはそのジョブが一時停止した (Suspended) ことを出力し、
プロンプトを表示します。
シェル変数の <B>listjobs</B> が設定されていると、
組み込みコマンドの <I>jobs</I> のようにすべてのジョブがリストされます。
もしそれが `long' と設定されているとリストは `jobs -l' のような
長い形式になります。
ここで、一時停止したジョブの状態を操作することができます。
つまり、<I>bg</I> コマンドにより停止したプロセスを
``バックグラウンド'' で走行させたり、他のコマンドを実行してから、
停止していたジョブを <I>fg</I> コマンドにより
``フォアグラウンド'' で再実行させることなどができます。
(編集コマンドの <I>run-fg-editor</I> も参照してください。)
`^Z' は即座に効力を発揮し、割り込みと同様に、それまで待たされていた
出力とまだ読み込まれていない入力は捨てられます。
組み込みコマンドの <I>wait</I> はすべてのバックグラウンドのジョブが
終了するまでシェルを待機状態にさせます。
<P>

`^]' キーは遅延サスペンドシグナルを現在のジョブに送信します。
この場合はプログラムが <I><A HREF="../../LDP_man-pages/man2/read.2.html">read</A></I>(2)
によって読み込もうとした時点で STOP シグナルが送信されます。
これは、実行中のジョブに対していくつかの入力を先に入力しておき、
先行入力を読み終えた時点でジョブを停止させたいときに便利です。
<I>csh</I>(1) ではこの機能は `^Y' キーに割り当てられていました。
<I>tcsh</I> では `^Y' は編集コマンドです。(+)
<P>

バックグラウンドで実行しているジョブが端末からの入力を試みた場合、
そのジョブは停止します。通常、バックグラウンドジョブが端末に
出力することは可能ですが、これはコマンド `stty tostop' により
禁止することができます。もしこの tty オプションを指定したなら、
バックグラウンドで実行しているジョブは、端末から入力を試みたときと
同様に、端末に出力を試みたときに停止します。
<P>

シェルでジョブを参照するにはいくつかの方法があります。文字 `%' は
ジョブ名を表すのに用いられます。番号 1 のジョブを参照する場合は
`%1' とします。単にジョブ名を入力した場合、そのジョブは
フォアグラウンドに移動されます。すなわち `%1' は `fg %1' と等価で、
ジョブ 1 をフォアグラウンドに移行します。同様に `%1 &amp;' は、
ちょうど `bg %1' と同じようにのジョブ 1 をバックグラウンドで
再開させます。ジョブはそのジョブを起動したときにタイプされた文字列の
先頭部分によって参照することもできます。ただしこの先頭部分は
あいまいでない必要があります。すなわち `%ex' は、`ex' という文字列で
始まる名前のサスペンドされたジョブが 1 つしかない場合に限り、
サスペンドされた <I>ex</I>(1) のジョブを再開します。
文字列 <I>string</I> を含むジョブが 1 つしかない場合、`%?<I>string</I>' と
入力することでそれを指定することもできます。
<P>

シェルは現在のジョブと直前のジョブを覚えています。
ジョブに関係する出力で、`+' 記号が付加されているのが現在のジョブ、
`-' 記号が付加されているのが直前のジョブです。
`%+', `%' と (<I>ヒストリ</I>機構の文法との類似から) `%%' は
すべて現在のジョブ、`%-' は直前のジョブを参照するための省略形です。
<P>

ある種のシステムではジョブ制御機構を利用するために <I><A HREF="../../0MultiFileIdx/man1/stty.1.html">stty</A></I>(1) の
オプション `new' を設定しておく必要があります。
ジョブ制御機構は `新型の' 端末ドライバの実装の上に構築されているからで、
新型の端末ドライバによりジョブを停止させるための割り込み文字を
キーボードから入力できるようになるからです。
新型の端末ドライバのオプション設定については <I><A HREF="../../0MultiFileIdx/man1/stty.1.html">stty</A></I>(1) と
組み込みコマンドの <I>setty</I> を参照してください。
<A NAME="lbBG">&nbsp;</A>
<H3>状態通知</H3>

シェルは、プロセスが状態の変化を起こすとすぐにそれを検知します。
通常はプロンプトが表示される直前にのみ、あるジョブが停止して
それ以上処理が進まなくなったことを通知します。これはユーザの仕事を
邪魔しないようにするためです。しかしながら、シェル変数 <B>notify</B> を
設定することにより、シェルにバックグラウンドジョブの状態が
変化したことをただちに通知させることができます。また、
シェルコマンド <I>notify</I> により、特定のジョブの状態の変化をただちに
通知させるようにマークすることもできます。引数なしの <I>notify</I> は
現在のプロセスに対してマークをつけます。バックグラウンドジョブの
開始直後に単に `notify' と打つとそのジョブをマークします。
<P>

停止したジョブが存在する状態でシェルを終了しようとすると
`You have stopped jobs.' という警告を受けます。このとき
<I>jobs</I> コマンドによりどのジョブが停止中であるのかを
確認することができます。警告を受けた直後に <I>jobs</I> コマンドで
確認した場合と、警告を受けた直後に再度シェルを終了させようとした
場合には、シェルは 2 度目の警告を行わずに停止中のジョブを
終了させてからシェルを終了します。
<A NAME="lbBH">&nbsp;</A>
<H3>自動イベント、定期イベント、時刻指定イベント (+)</H3>

シェルの ``ライフサイクル'' において、いろいろな時間に自動的に
コマンドの実行と他のアクションを行うさまざまな方法が用意されています。
それらをここに要約し、詳しくは
<B>組み込みコマンド</B>、<B>特別なシェル変数</B>、<B>特別なエイリアス</B>の
適切な場所で説明します。
<P>

組み込みコマンドの <I>sched</I> はコマンドをイベントの予定表に置き、
指定された時刻にシェルによって実行されるようにします。
<P>

<B>特別なエイリアス</B>として <I>beepcmd</I>, <I>cwdcmd</I>,
<I>periodic</I>, <I>precmd</I>, <I>postcmd</I>, <I>jobcmd</I> があり、それぞれ
シェルがベルを鳴らす時、作業ディレクトリが変わる時、
<B>tperiod</B> 分毎、各プロンプトの前、各コマンドの実行前、
各コマンドの実行後、ジョブの起動時またはフォアグラウンド移行時に
実行させたいコマンドを設定できます。
<P>

シェル変数の <B>autologout</B> を使って、指定した分数の休止後に
ログアウトまたはシェルをロックするように設定できます。
<P>

シェル変数の <B>mail</B> を使って、定期的に新しいメールを
チェックするように設定できます。
<P>

シェル変数の <B>printexitvalue</B> を使って、0 以外のステータスで
終了したコマンドの終了ステータスを表示するように指定できます。
<P>

シェル変数の <B>rmstar</B> を使って、`rm *' が入力されたときに
ユーザに間違いないかどうか確認を求めるように指定できます。
<P>

シェル変数の <B>time</B> を使って、指定した秒数より多く CPU 時間を
使ったプロセスの終了後に組み込みコマンドの <I>time</I> を実行するように
設定できます。
<P>

シェル変数の <B>watch</B> と <B>who</B> を使って、指定したユーザが
ログインまたはログアウトした時にレポートするように設定できます。
また組み込みコマンドの <I>log</I> でいつでもそれらのユーザに
ついてのレポートを得られます。
<A NAME="lbBI">&nbsp;</A>
<H3>固有言語システムのサポート (+)</H3>

シェルは 8 ビットクリーンなので
(そのようにコンパイルされていれば。シェル変数の <B>version</B> を
参照)、それを必要とする文字セットをサポートします。
NLS サポートはシェルがシステムの NLS を使うようにコンパイルされているか
どうかによって異なります (再び、<B>version</B> を参照)。
どちらの場合でも 7 ビット ASCII がデフォルトの文字分類
(たとえばそれらの文字は表示可能) であり、そして順序づけです。
環境変数の <B>LANG</B> または <B>LC_CTYPE</B> を変更すると、
これらの点について変化の有無がチェックされます。
<P>

システムの NLS を使う場合には、文字の適切な分類と順序づけを決定するために
<I><A HREF="../../LDP_man-pages/man3/setlocale.3.html">setlocale</A></I>(3) 関数が呼び出されます。この関数は典型的には
環境変数の <B>LANG</B> と <B>LC_CTYPE</B> を調べます。
より詳細についてはシステムのドキュメントを参照してください。
システムの NLS を使わない場合には、シェルは ISO 8859-1 文字セットが
使われていると仮定することでシミュレートします。
変数 <B>LANG</B> と <B>LC_CTYPE</B> のいずれかが設定されていても、
それらの値を無視します。
シミュレートされた NLS では順序づけに影響しません。
<P>

加えて、本物とシミュレートされた NLS の両方で、\200-\377 の範囲、
つまり M-<I>char</I> でバインドされているすべての表示可能文字は、
自動的に <I>self-insert-command</I> に再バインドされます。
対応する escape-<I>char</I> へのバインドは、もしあればそのまま残ります。
これらの文字は環境変数の <B>NOREBIND</B> が設定されていれば
再バインドされません。この機能はシミュレートされた NLS や
すべてが ISO 8859-1 であると仮定した原始的な本物の NLS で有効でしょう。
そうでなければ、\240-\377 の範囲の M-<I>char</I> へのバインドは
事実上解除されます。この場合でも、もちろん <I>bindkey</I> で明示的に
関連するキーに再バインドする事は可能です。
<P>

未知の文字 (つまり表示可能でも制御文字でもないような文字) は
\nnn のような形式で表示されます。tty が 8 ビットモードになっていない
場合は、ASCII に変換して強調表示モードを使うことで別の 8 ビット文字が
表示されます。シェルは tty の 7/8 ビットモードを変更することはなく、
ユーザによる 7/8 ビットモードの変更に従います。NLS 利用者 (または
メタキーを利用したい利用者) は、たとえば <I>~/.login</I> ファイルで
適切に <I><A HREF="../../0MultiFileIdx/man1/stty.1.html">stty</A></I>(1) コマンドを呼び出すことで、
明示的に tty を 8 ビットモードに設定する必要があるかもしれません。
<A NAME="lbBJ">&nbsp;</A>
<H3>OS 固有機能のサポート (+)</H3>

個々のオペレーティングシステムで提供されている機能をサポートするために、
多くの新しい組み込みコマンドが提供されています。すべて
<B>組み込みコマンド</B>セクションで詳細に説明されています。
<P>

TCF をサポートするシステム (aix-ibm370, aix-ps2) では、
<I>getspath</I> と <I>setspath</I> でシステム実行パスを取得、設定し、
<I>getxvers</I> と <I>setxvers</I> で試験バージョンプリフィックスを取得、
設定して、<I>migrate</I> でプロセスをサイト間で移動させます。
組み込みコマンドの <I>jobs</I> は各ジョブが実行されているサイトを表示します。
<P>

Domain/OS では、<I>inlib</I> で共有ライブラリを現環境に追加し、
<I>rootnode</I> で rootnode を変更し、<I>ver</I> で systype を変更します。
<P>

Mach では、<I>setpath</I> が Mach の <I>setpath</I>(1) と等価です。
<P>

Masscomp/RTU と Harris CX/UX では、<I>universe</I> で universe を設定します。
<P>

Harris CX/UX では、<I>ucb</I> か <I>att</I> によって指定した universe で
コマンドを走らせます。
<P>

Convex/OS では、<I>warp</I> で universe を表示または設定します。
<P>

環境変数の <B>VENDOR</B>, <B>OSTYPE</B>, <B>MACHTYPE</B> は、
シェルが自身が実行されていると考えているシステムの、それぞれ
ベンダー、オペレーティングシステム、マシンタイプ
(マイクロプロセッサのクラスまたはマシンのモデル) を表示します。
これはいろいろなタイプのマシン間でホームディレクトリを共有する場合に
特に便利です。利用者はたとえば各自の <I>~/.login</I> 中で
<DL COMPACT>
<DT><DD>
set path = (~/bin.$MACHTYPE /usr/ucb /bin /usr/bin .)
</DL>
<P>

とし、各マシン用にコンパイルされた実行形式を適切なディレクトリに
置くことができます。
<P>

シェル変数の <B>version</B> は、どのオプションを選択して
シェルがコンパイルされたかを表示します。
<P>

組み込みの <I>newgrp</I>、シェル変数の <B>afsuser</B> と
<B>echo_style</B>、そしてシステムに依存するシェルの入力ファイル
(<B>ファイル</B>を参照) の位置にも注意してください。
<A NAME="lbBK">&nbsp;</A>
<H3>シグナル処理</H3>

ログインシェルは <I>~/.logout</I> ファイルを読んでいる間は
割り込みを無視します。
シェルは起動時に <B>-q</B> の指定が無ければ QUIT シグナルを無視します。
ログインシェルは TERM シグナルを捕捉しますが、非ログインシェルは
TERM シグナルへの挙動を親から継承します。
他のシグナルについては親からシェルに継承された値を持っています。
<P>

シェルスクリプトでは、シェルの INT と TERM シグナルの扱いを
<I>onintr</I> で制御できます。そして HUP の扱いを
<I>hup</I> と <I>nohup</I> で制御できます。
<P>

シェルは HUP で終了します (シェル変数の <B>logout</B> も参照)。
デフォルトでは、シェルの子供たちもそうしますが、シェルは終了時に
HUP を子供たちに送りません。<I>hup</I> はシェルが終了時に
子供に HUP を送るようにし、<I>nohup</I> は子供が HUP を無視するように
設定します。
<A NAME="lbBL">&nbsp;</A>
<H3>端末管理 (+)</H3>

シェルは 3 つの異なる端末 (``tty'') モードの設定を使います。それらは
編集時に使う `edit'、文字リテラルをクォートする場合に使う `quote'、
コマンド実行時に使う `execute' です。
シェルは各モードでいくつかの設定を一定に保つので、
tty を混乱状態にして終了するコマンドがシェルに干渉することはありません。
シェルは tty のスピードとパディングの変更にも対応します。
一定に保たれる tty モードのリストは組み込みの <I>setty</I> で
取得、設定できます。エディタは CBREAK モード (または同等のモード) を
使いますが、先行入力された文字はいつでも受け付けられます。
<P>

<I>echotc</I>, <I>settc</I>, <I>telltc</I> コマンドを使って、
コマンドラインから端末のケーパビリティを操作、デバッグすることができます。
<P>

SIGWINCH か SIGWINDOW をサポートするシステムでは、シェルは
ウィンドウのリサイズに自動的に適応して、環境変数の
<B>LINES</B> と <B>COLUMNS</B> が設定されていれば値を補正します。
環境変数の <B>TERMCAP</B> が li# と co# のフィールドを含んでいると、
シェルは新しいウィンドウサイズを反映するようにそれらを補正します。
<A NAME="lbBM">&nbsp;</A>
<H2>参照</H2>

このマニュアルの以下のセクションでは使用可能なすべての
<B>組み込みコマンド</B>、<B>特別なエイリアス</B>、
<B>特別なシェル変数</B>について説明します。
<A NAME="lbBN">&nbsp;</A>
<H3>組み込みコマンド</H3>

<DL COMPACT>
<DT><B>%</B><I>job</I>

<DD>
組み込みコマンド <I>fg</I> と同義です。
<DT><B>%</B><I>job </I><B>&amp;</B>

<DD>
組み込みコマンド <I>bg</I> と同義です。
<DT><B>:</B>

<DD>
何もしません。常に成功します。
</DL>
<P>

<B>@</B>

<BR>

<B>@ </B><I>name</I><B> = </B><I>expr</I>

<BR>

<B>@ </B><I>name</I>[<I>index</I>]<B> = </B><I>expr</I>

<BR>

<B>@ </B><I>name</I><B>++</B>|<B>--</B>


<DL COMPACT>
<DT><B>@ </B><I>name</I>[<I>index</I>]<B>++</B>|<B>--</B>

<DD>
最初の形式は、すべてのシェル変数の値を表示します。

<DL COMPACT><DT><DD>
<P>

2 番目の書式は、<I>name</I> に値 <I>expr</I> を設定します。
3 番目の書式は、値 <I>expr</I> を <I>name</I> の <I>index</I> 番目の要素に
定義します。
<I>name</I> とその <I>index</I> 番目の要素の両方が既に存在していなければ
なりません。
<P>

<I>expr</I> は C と同様に、`*', `+'のような演算子を含むことがあります。
もし <I>expr</I> が `&lt;', `&gt;', `&amp;', `' を含むのであれば、少なくとも
<I>expr</I> のその部分は `()' の中に書かれる必要があります。
<I>expr</I> の書式は、以下の <B>Expressions</B> で説明されるものとは
一切関係がないことに注意してください。
<P>

4 番目、5 番目の書式は <I>name</I> またはその <I>index</I> 番目の要素を
インクリメント (`++') またはデクリメント (`--') します。
<P>

`@' と <I>name</I> の間の空白は必須です。<I>name</I> と `=' の間、また `=' と
<I>expr</I> の間の空白はオプションです。<I>expr</I> の要素は空白によって
区切られていなければなりません。
</DL>


<DT><B>alias </B>[<I>name </I>[<I>wordlist</I>]]

<DD>
引数がなければ、すべてのエイリアスを表示します。
<I>name</I> を与えると、そのエイリアスの内容を表示します。
<I>name</I> と <I>wordlist</I> を与えると、
<I>wordlist</I> を <I>name</I> のエイリアスとして定義します。
<I>wordlist</I> は、エイリアスされるコマンドとファイル名です。
<I>name</I> は `alias' または `unalias' であってはなりません。
組み込みコマンド <I>unalias</I> についても参照してください。

<DT><B>alloc</B>

<DD>
動的に取得しているメモリのうちの使用量と空き容量を表示します。
何らかの引数を与えるとブロックサイズごとの使用中 / 空きブロックの数を
表示します。このコマンドの出力はシステムによって大きく異なります。
VAX 以外のシステムでは、異なるメモリ管理を行っているかもしれない
からです。
<DT><B>bg </B>[<B>%</B><I>job</I> ...]

<DD>
指定したジョブ (引数がなければ現在のジョブ) をバックグラウンドに
移動します。もしそれらが停止していれば再開されます。<I>job</I> は
以下の <B>Jobs</B> で説明するように番号、
文字列、`', `%', `+', `-' で構成されます。

</DL>
<P>

<B>bindkey </B>[<B>-l</B>|<B>-d</B>|<B>-e</B>|<B>-v</B>|<B>-u</B>] (+)

<BR>

<B>bindkey </B>[<B>-a</B>] [<B>-b</B>] [<B>-k</B>] [<B>-r</B>] [<B>--</B>]
<I>key </I>(+)

<DL COMPACT>
<DT><B>bindkey </B>[<B>-a</B>] [<B>-b</B>] [<B>-k</B>] [<B>-c</B>|<B>-s</B>]<DD>
[<B>--</B>] <I>key command </I>(+)



オプション無しでは、第 1 の形式ではバインドされているすべてのキーと
編集コマンドを表示し、第 2 の形式では <I>key</I> にバインドされている
編集コマンドを表示し、第 3 の形式では
編集コマンド <I>command</I> を <I>key</I> にバインドします。
オプションは以下のものを含みます。

</DL>
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>-l</B>

<DD>
すべての編集コマンドの一覧と、それぞれの簡単な解説を表示します。
<DT><B>-d</B>

<DD>
デフォルトのエディタの標準キーバインドをすべてのキーに適用します。
<DT><B>-e</B>

<DD>
GNU Emacs に似たキーバインドをすべてのキーに適用します。
<DT><B>-v</B>

<DD>
標準の <I>vi</I>(1) に似たキーバインドをすべてのキーに適用します。
<DT><B>-a</B>

<DD>
代替キーマップを表示またはそのキーバインドを変更します。
代替キーマップは <I>vi</I> コマンドモードのものです。
<DT><B>-b</B>

<DD>
<I>key</I> を次のように解釈します。
^<I>character</I> (たとえば `^A')、C-<I>character</I> (たとえば `C-A')
のようなものはコントロールキャラクタ、
M-<I>character</I> (たとえば `M-A')のようなものはメタキャラクタ、
F-<I>string</I> (たとえば `F-string')のようなものは
ファンクションキー、X-<I>character</I> (たとえば `X-A') のような
ものは拡張プリフィックスキーです。
<DT><B>-k</B>

<DD>
<I>key</I> は矢印キーの名前、`down', `up', `left', `right' の
いずれかとして解釈されます。
<DT><B>-r</B>

<DD>
<I>key</I> のバインドを解除します。
`bindkey -r' は <I>key</I> を <I>self-insert-command</I> にバインドする
のでは<I>なく</I>、そのキーのバインドを完全に解除してしまうことに
注意してください。
<DT><B>-c</B>

<DD>
<I>command</I> は編集コマンドでなく、組み込みコマンドか
外部コマンドの名前として解釈されます。
<DT><B>-s</B>

<DD>
<I>command</I> は通常の文字列として解釈され、<I>key</I> がタイプされた
時に端末から入力されたように扱われます。<I>command</I> で
バインドされたキー自体も再び解釈が行われ、10 レベルまで繰り返し
解釈が行われます。
<DT><B>--</B>

<DD>
オプション処理の中断を行います。したがって、次の単語が '-' で
始まっていたとしても、<I>key</I> として解釈されます。
<DT><B>-u </B> (または何らかの無効なオプション)

<DD>
使い方を表示します。

</DL>
<P>

<I>key</I> は 1 文字であっても、文字列であっても構いません。
もしコマンドが文字列にバインドされているならば、文字列の最初の
文字は <I>sequence-lead-in</I> にバインドされ、文字列全体が
コマンドにバインドされます。
<P>

<I>key</I> に含まれるコントロール文字はコントロール文字そのもの
(通常 `^V' にバインドされているエディタの <I>quoted-insert</I>
コマンドで入力できるもの) であっても、`^A' のような
キャレット-文字形式であっても構いません。削除文字は
`^?' (キャレット-疑問符) のように表します。<I>key</I> と
<I>command</I> は下に示す、バックスラッシュで始まる
エスケープシーケンスを含むことができます
(System V の <I><A HREF="../../0MultiFileIdx/man1/echo.1.html">echo</A></I>(1) で用いられる形式です)。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>\a</B>

<DD>
ベル
<DT><B>\b</B>

<DD>
バックスペース
<DT><B>\e</B>

<DD>
エスケープ
<DT><B>\f</B>

<DD>
改ページ (フォームフィード)
<DT><B>\n</B>

<DD>
改行
<DT><B>\r</B>

<DD>
キャリッジリターン
<DT><B>\t</B>

<DD>
水平タブ
<DT><B>\v</B>

<DD>
垂直タブ
<DT><B>\</B><I>nnn</I>

<DD>
8 進数 <I>nnn</I> で表されるアスキー文字

</DL>
</DL>

<P>

`\' は後に続く文字に特別な意味があればそれを無効にします。
特に `\' や `^' の場合です。
</DL>

<DL COMPACT>
<DT><B>break</B>

<DD>
実行を一番近い <I>foreach</I> または <I>while</I> と <I>end</I> の
組の、<I>end</I> の後から再開します。現在の行の残りのコマンドは
実行されます。したがって、複数のレベルのブレークは、1 行にそれらを
並べることで可能になります。
<DT><B>breaksw</B>

<DD>
<I>switch</I> からのブレークで、<I>endsw</I> の後から
実行が開始されます。
<DT><B>builtins </B>(+)

<DD>
すべての組み込みコマンドの名前を表示します。
<DT><B>bye </B>(+)

<DD>
組み込みコマンド <I>logout</I> の別名です。
これが使えるようにコンパイルされている場合にのみ有効です。
シェル変数 <B>version</B> を参照してください。
<DT><B>case </B><I>label</I><B>:</B>

<DD>
下で説明する <I>switch</I> 文で用いられるラベルです。
<DT><B>cd </B>[<B>-p</B>] [<B>-l</B>] [<B>-n</B>|<B>-v</B>] [<I>name</I>]

<DD>
もしディレクトリ名 <I>name</I> が与えられれば、シェルの
作業ディレクトリを <I>name</I> に変更します。与えられなければ
<B>home</B> に変更します。もし <I>name</I> が `-' であれば、
ひとつ前の作業ディレクトリとして解釈されます
(<B>Other substitutions</B> を参照)。<I>name</I> が
現在のディレクトリのサブディレクトリでなく、
`/', `./' , `../' のいずれかで始まるものでもない場合、
変数 <B>cdpath</B> の要素がひとつひとつチェックされ、
サブディレクトリ <I>name</I> が探されます。最後に、そのどれもが
失敗した場合に <I>name</I> が `/' ではじまる値をもつシェル変数で
あれば、その変数が指すディレクトリが探されます。
<DL COMPACT><DT><DD>
<P>

<B>-p</B> を付けると、<I>dirs</I> と同じように最終的な
ディレクトリスタックの内容を表示します。<I>cd</I> の <B>-l</B>,
<B>-n</B>, <B>-v</B> フラグは <I>dirs</I> のそれと同じ意味を持ち、
<B>-p</B> の動作を含んでいます (+)。
<P>

シェル変数 <B>implicitcd</B> についても参照してください。
</DL>

<DT><B>chdir</B>

<DD>
組み込みコマンド <I>cd</I> の別名です。
<DT><B>complete </B>[<I>command</I>

<DD>
[<I>word</I><B>/</B><I>pattern</I><B>/</B><I>list</I>[<B>:</B><I>select</I>]<B>/</B>[[<I>suffix</I>]
<B>/</B>] ...]] (+) 引数なしの場合は、すべての補完の候補を表示します。
<I>command</I> をつけると、<I>command</I> の補完候補を表示します。
<I>command</I> と <I>word</I> などをつけると、補完を定義します。
<DL COMPACT><DT><DD>
<P>

<I>command</I> はコマンドのフルネームでも、何らかのパターンでも
構いません (<B>ファイル名置換</B>を参照)。
補完候補がひとつでないことを示すために、`-' ではじめることができます。
<P>

<I>word</I> は現在の語の補完にどの単語が関係するのかを指定する
もので、以下のうちどれか 1 つです。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>c</B>

<DD>
現在の語の補完。
<I>pattern</I> は、コマンドライン上の現在の語にマッチするパターンで
なければなりません。
<I>pattern</I> は現在の語の補完が完了すると無視されます。
<DT><B>C</B>

<DD>
<B>c</B> に似ていますが、現在の語の補完後に <I>pattern</I> を含みます。
<DT><B>n</B>

<DD>
次の語の補完。
<I>pattern</I> はコマンドライン上のひとつ前の語にマッチする
パターンでなければなりません。
<DT><B>N</B>

<DD>
<B>n</B> に似ていますが、現在の語のふたつ前の語に
マッチするパターンでなければなりません。
<DT><B>p</B>

<DD>
位置に依存した補完。
<I>pattern</I> は数値の範囲を指定するものであり、シェル変数の
インデックスと同じ文法が用いられます。
現在の語を含むものでなければなりません。

</DL>
</DL>


<P>

<I>list</I> は以下のリストの中から可能な補完のリストを示します。
<P>


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>a</B>

<DD>
エイリアス
<DT><B>b</B>

<DD>
バインディング (編集コマンド)
<DT><B>c</B>

<DD>
コマンド (組み込みコマンドも外部コマンドも含みます)
<DT><B>C</B>

<DD>
指定されたパスではじまる外部コマンド
<DT><B>d</B>

<DD>
ディレクトリ
<DT><B>D</B>

<DD>
指定されたパスではじまるディレクトリ
<DT><B>e</B>

<DD>
環境変数
<DT><B>f</B>

<DD>
ファイル名
<DT><B>F</B>

<DD>
指定されたパスではじまるファイル名
<DT><B>g</B>

<DD>
グループ名
<DT><B>j</B>

<DD>
ジョブ
<DT><B>l</B>

<DD>
制限値
<DT><B>n</B>

<DD>
何にも補完しません
<DT><B>s</B>

<DD>
シェル変数
<DT><B>S</B>

<DD>
シグナル
<DT><B>t</B>

<DD>
プレイン (``テキスト'') ファイル
<DT><B>T</B>

<DD>
プレイン (``テキスト'') ファイルで、指定されたパスではじまるもの
<DT><B>v</B>

<DD>
すべての変数
<DT><B>u</B>

<DD>
ユーザ名
<DT><B>x</B>

<DD>
<B>n</B> に似ていますが、<I>list-choices</I> が使われている時には
<I>select</I> を表示します。
<DT><B>X</B>

<DD>
補完
<DT>$<I>var</I><DD>
変数 <I>var</I> に格納されている語
<DT>(...)<DD>
リスト中の語
<DT>`...`<DD>
コマンドの出力に含まれる語

</DL>
</DL>

<P>

<I>select</I> は glob パターンです (省略可能)。
これを指定すると、<I>list</I> にある単語のうち
<I>select</I> にマッチするものだけが対象となり、
シェル変数 <B>fignore</B> は無視されます。
最後の 3 つの補完形式には
<I>select</I> パターンを与えることはできません。
また <B>x</B> は <I>list-choices</I> 編集コマンドが用いられた時には
<I>select</I> を説明メッセージとして扱います。
<P>

<I>suffix</I> は単一の文字で、補完が成功するとそのあとに追加されます。
空の場合は何も追加されません。省略されると
(この場合 4 番目のデリミタも省略できます)
ディレクトリにはスラッシュ文字が、
その他の文字にはスペース文字が追加されます。
<P>

ではいくつか例を示します。
コマンドによっては、ディレクトリのみを引数として取るものがあります。
(そのようなコマンドに対して) 通常ファイルを補完することは、的外れです。
<DL COMPACT>
<DT><DD>
&gt; complete cd 'p/1/d/'
</DL>
<P>

`cd' に続く最初の単語のみ (`p/1') をディレクトリで補完します。
コマンド補完を絞りこむために <B>p</B>-形式の補完を用いることもできます。
`cd' に続く最初の単語のみ (`p/1') をディレクトリで補完します。
<DL COMPACT>
<DT><DD>
&gt; co[^D]
<BR>

complete compress
<BR>

&gt; complete -co* 'p/0/(compress)/'
<BR>

&gt; co[^D]
<BR>

&gt; compress
</DL>
<P>

これは `co' で始まる (すなわち `co*' にマッチする)
コマンド (位置 0 にある単語 `p/0') を補完して、
`compress' (リストにある唯一の単語) を与えたものです。
先頭にある `-' は、
この補完がコマンドを確定できない場合にのみ用いられることを意味します。
<DL COMPACT>
<DT><DD>
&gt; complete find 'n/-user/u/'
</DL>
<P>

これは <B>n</B>-形式の補完の例です。
`find' の後で、かつ `-user' の直後にある単語を、
ユーザーのリストで補完します。
<DL COMPACT>
<DT><DD>
&gt; complete cc 'c/-I/d/'
</DL>
<P>

<B>c</B>-形式の補完の例です。`cc' の後にあり、
かつ `-I' ではじまる単語をディレクトリで補完します。
ここでは小文字の <B>c</B> を用いているので、
`-I' はディレクトリの一部とはみなされません。
<P>

コマンドに応じて、便利な <I>list</I> も異なります。
<DL COMPACT>
<DT><DD>
&gt; complete alias 'p/1/a/'
<BR>

&gt; complete man 'p/*/c/'
<BR>

&gt; complete set 'p/1/s/'
<BR>

&gt; complete true 'p/1/x:Truth has no options./'
</DL>
<P>

これらでは、
`alias' に続く単語をエイリアスで、
`man' に続く単語をコマンドで、
`set' に続く単語をシェル変数で置き換えています。
`true' はオプションを取らないので、
補完が試みられたときに何も行わず、
補完リストの選択画面には `Truth has no options.' を表示する
<B>x</B> を指定しています。
<P>


<I>man</I> の例や、以下に示すいくつかの例では、
`p/*' の代わりに `c/*' や `n/*' を用いることもできます。
<P>

単語の補完を変数で行うこともできます。これらの変数は補完の際に評価されます。
<DL COMPACT>
<DT><DD>
&gt; complete ftp 'p/1/$hostnames/'
<BR>

&gt; set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)
<BR>

&gt; ftp [^D]
<BR>

rtfm.mit.edu tesla.ee.cornell.edu
<BR>

&gt; ftp [^C]
<BR>

&gt; set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)
<BR>

&gt; ftp [^D]
<BR>

rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net
</DL>
<P>

また補完の際にコマンドを実行し、そこから補完を行うこともできます。
<DL COMPACT>
<DT><DD>
&gt; complete kill 'p/*/`ps | awk \{print\ \$1\}`/'
<BR>

&gt; kill -9 [^D]
<BR>

23113 23377 23380 23406 23429 23529 23530 PID
</DL>
<P>

<I>complete</I> コマンド自身は、その引数をクォートしません。
したがって `{print $1}' にある括弧、スペース、`$' は
明示的にクォートしなければなりません。
<P>

1 つのコマンドに複数の補完を指定することもできます。
<DL COMPACT>
<DT><DD>
&gt; complete dbx 'p/2/(core)/' 'p/*/c/'
</DL>
<P>

これは `dbx' の第 2 引数を `core' という単語で補完し、
他のすべての引数をコマンドで補完します。
位置指定タイプの補完は、逐次補完より前に指定することに注意してください。
補完は左から右に評価されるので、
(常にマッチする) 逐次補完が先に指定されていると、
位置指定補完は決して行われなくなってしまいます。
これは補完定義の際によくやるミスなので注意してください。
<P>

<I>select</I> パターンは、
コマンドが特定の形式を持ったファイルだけを引数にとるような場合に便利です。
以下に例を示します。
<DL COMPACT>
<DT><DD>
&gt; complete cc 'p/*/f:*.[cao]/'
</DL>
<P>

これは `cc' の引数を、`.c', `.a', `.o' で終わるファイルだけから補完します。
以下の<B>ファイル名置換</B>で述べるようなやり方で
グロブパターンの否定を指定すれば、
<I>select</I> で特定のファイルを排除することもできます。
<DL COMPACT>
<DT><DD>
&gt; complete rm 'p/*/f:^*.{c,h,cc,C,tex,1,man,l,y}/'
</DL>
<P>

これは大事なソースコードを `rm' の補完に現れないようにします。
もちろんこの排除された名前を手で打ったり、
<I>complete-word-raw</I> や <I>list-choices-raw</I>
などの編集コマンドを用いて補完の仕組みを変更することもできます
(それぞれ該当の部分を参照)。
<P>

`C', `D', `F', `T' 各<I>リスト</I>は、
それぞれ `c', `d', `f', `t' と似ていますが、
<I>select</I> の引数の解釈の仕方が異なり、
補完対象のファイルを前置パス名が特定のものに限ります。
たとえば、メールプログラム Elm は `=' を
ユーザのメールディレクトリの省略名として用います。
この場合 `elm -f =' を `elm -f ~/Mail/' であるかのように補完するには
<DL COMPACT>
<DT><DD>
&gt; complete elm c@=@F:$HOME/Mail/@
</DL>
<P>

とすべきです。ここでは `/' の代わりに `@' を用い、
<I>select</I> 引数を見やすくしています。
またホームディレクトリの置換は単語の先頭でのみ動作するので、
`~' の代わりに `$HOME' を用いています。
<P>

<I>suffix</I> は標準では用意されていないサフィックス
(スペースやディレクトリに対する `/' 以外)
を単語補完用に追加するために用います。
<DL COMPACT>
<DT><DD>
&gt; complete finger 'c/*@/$hostnames/' 'p/1/u/@'
</DL>
<P>

これは `finger' の引数を、まずユーザのリストから補完し、
それに `@' を追加し、さらに `@' の後を変数 `hostnames' のリストから
補完します。ここでも補完指定の順序に注意してください。
<P>

最後に、示唆に富む複雑な例を示しましょう。
<DL COMPACT>
<DT><DD>
&gt; complete find \
<BR>

'n/-name/f/' 'n/-newer/f/' 'n/-{,n}cpio/f/' \
<BR>

'n/-exec/c/' 'n/-ok/c/' 'n/-user/u/' \
<BR>

'n/-group/g/' 'n/-fstype/(nfs 4.2)/' \
<BR>

'n/-type/(b c d f l p s)/' \
<BR>

'c/-/(name newer cpio ncpio exec ok user \
<BR>

group fstype type atime ctime depth inum \
<BR>

ls mtime nogroup nouser perm print prune \
<BR>

size xdev)/' \
<BR>

'p/*/d/'
</DL>
<P>

これは `-name', `-newer', `-cpio', `ncpio' に続く単語を
ファイルで補完し (最後の両者にマッチするパターンに注意)、
`-exec', `-ok' に続く単語をコマンドで補完し、
`user' の後をユーザ名で、`group' の後をグループ名で補完し、
`-fstype' と `-type' の後をそれぞれに与えたリストのメンバーで補完します。
また find に与えるスイッチ達も与えたリストから補完し
(<B>c</B>-型の補完を用いていることに注意)、
それ以外のものすべてをディレクトリで補完します。ふぅ。
<P>

補完指定は、対象となる単語がチルダ置換 (`~' ではじまる) や
変数 (`$' ではじまる) の場合は無視されることに留意してください。
<I>complete</I> は実験的な機能であり、
文法はこのシェルの将来のバージョンでは変更されるかもしれません。
組み込みコマンド <I>uncomplete</I> の説明も見てください。
</DL>

<DT><B>continue</B>

<DD>
もっとも近い <I>while</I> または <I>foreach</I> ループの実行を継続します。
現在の行にある残りのコマンドは実行されます。
<DT><B>default:</B>

<DD>
<I>switch</I> 文のデフォルトの場合のラベルです。
これはすべての <I>case</I> ラベルの後に置くべきです。
</DL>
<P>

<B>dirs </B>[<B>-l</B>] [<B>-n</B>|<B>-v</B>]

<BR>

<B>dirs -S</B>|<B>-L </B>[<I>filename</I>] (+)


<DL COMPACT>
<DT><B>dirs -c </B>(+)

<DD>
最初の形式はディレクトリスタックを表示します。
スタックの上が左に来て、
スタック先頭のディレクトリは現在のディレクトリになります。
<B>-l</B> を指定すると、出力の `~' や `~<I>name</I>' は、
<B>home</B> や、ユーザ <I>name</I> のホームディレクトリのパス名に
明示的に展開されます。 (+)
<B>-n</B> を指定すると、エントリはスクリーンの終端に達する前に
桁折りされます。 (+)
<B>-v</B> を指定すると、各エントリが 1 行に 1 つずつ表示され、
スタック内部での位置がエントリの前に表示されます。 (+)
<B>-n</B> や <B>-v</B> がひとつ以上指定されると <B>-v</B> が優先されます。

<DL COMPACT><DT><DD>
<P>

<B>-S</B> を指定した 2 番目の形式では、
ディレクトリスタックを
<I>cd</I> と <I>pushd</I> からなるコマンド列として
<I>filename</I> に保存します。
<B>-L</B> を指定すると、このシェルは <I>filename</I> を source します。
このファイルは、以前に <B>-S</B> オプションや
<B>savedirs</B> 機構で保存されたディレクトリスタックです。
いずれの場合でも、 <I>filename</I> が与えられなければ
<B>dirsfile</B> を用います。
<B>dirsfile</B> も指定されていなければ <I>~/.cshdirs</I> を用います。
<P>

ログインシェルは `dirs -L' と同様のことを起動時に行っており、
また <B>savedirs</B> が設定されていれば終了前に
`dirs -S' と同様のことを行います。
通常 <I>~/.tcshrc</I> だけが <I>~/.cshdirs</I> の前に source されるので、
<B>dirsfile</B> は <I>~/.login</I> ではなく
<I>~/.tcshrc</I> で設定すべきです。
<P>

最後の形式はディレクトリスタックをクリアします。
</DL>

<DT><B>echo </B>[<B>-n</B>] <I>word</I> ...

<DD>
各 <I>word</I> をスペースで区切り、改行で終端させて
シェルの標準出力に書き出します。
シェル変数 <B>echo_style</B> を指定すると、
BSD や System V の <I>echo</I> のフラグやエスケープシーケンスを
エミュレートする (しない) ようにできます。
詳細は <I><A HREF="../../0MultiFileIdx/man1/echo.1.html">echo</A></I>(1) を見てください。
<DT><B>echotc </B>[<B>-sv</B>] <I>arg</I> ... (+)

<DD>
<I>arg</I> で与えられた端末の機能 (<I><A HREF="../../LDP_man-pages/man5/termcap.5.html">termcap</A></I>(5) を参照)
を実行します。
たとえば `echotc home' はカーソルをホームポジションに移動し、
`echotc cm 3 10' はカーソルを 3 列 10 行に移動し、
`echotc ts 0; echo &quot;This is a test.&quot;; echotc fs' は
&quot;This is a test.&quot; をステータス行に表示します。
<DL COMPACT><DT><DD>
<P>

<I>arg</I> が `baud', `cols', `lines', `meta', `tabs' の
いずれかであった場合は、その機能の値を表示します
(&quot;yes&quot; または &quot;no&quot; は、端末がその機能を持っているかいないかを示します)。
遅い端末でシェルスクリプトの出力をより寡黙にしたり、
コマンドの出力をスクリーンの行数に制限したりするような場合には、
以下のコマンドを使うと良いでしょう。
<DL COMPACT>
<DT><DD>
&gt; set history=`echotc lines`
<BR>

&gt; @ history--
</DL>
<P>

termcap 文字列はワイルドカードを含むことができますが、
これは正しく echo されません。
シェル変数に端末機能文字列を設定するときには、
以下の例のようにダブルクォートを用いてください。
この例では日付をステータス行に表示しています。
<DL COMPACT>
<DT><DD>
&gt; set tosl=&quot;`echotc ts 0`&quot;
<BR>

&gt; set frsl=&quot;`echotc fs`&quot;
<BR>

&gt; echo -n &quot;$tosl&quot;;date; echo -n &quot;$frsl&quot;
</DL>
<P>

<B>-s</B> を指定すると、存在しない機能を指定したとき、
エラーをおこさずに空文字列を返します。
<B>-v</B> を指定するとメッセージが冗長になります。
</DL>

</DL>
<P>

<B>else</B>

<BR>

<B>end</B>

<BR>

<B>endif</B>


<DL COMPACT>
<DT><B>endsw</B>

<DD>
以下の <I>foreach</I>, <I>if</I>, <I>switch</I>,
<I>while 文の説明を見てください。

<DT></I><B>eval </B><I>arg</I> ...

<DD>
引数をシェルへの入力として扱い、
残りのコマンドを現在のシェルのコンテキストで実行します。
これは通常、コマンド置換や変数置換の結果として生成されたコマンド列を
実行する場合に用いられます。
これはそれらの置換に先立って文法解析が行われてしまうためです。
<I>eval</I> の利用例は <I>tset</I>(1) を見てください。
<DT><B>exec </B><I>command</I>

<DD>
指定したコマンドを現在のシェルの代わりに実行します。
<DT><B>exit </B>[<I>expr</I>]

<DD>
指定した <I>expr</I> (<B>式</B>で解説した式) の値で
(<I>expr</I> が指定されていなければ <B>status</B> 変数の値で)
シェルを終了します。
<DT><B>fg </B>[<B>%</B><I>job</I> ...]

<DD>
指定したジョブ (あるいは引数がなければ現在のジョブ)
をフォアグラウンドに移動します。停止状態にあるものは再開します。
<I>job</I> には<B>ジョブ</B>で解説されているように、
数値、文字列、`', `%', `+', `-' のどれかを指定できます。
<I>run-fg-editor 編集コマンドも見てください。
<DT></I><B>filetest -</B><I>op file</I> ... (+)

<DD>
(<B>ファイル問合わせ演算子</B>で解説されている)
ファイル問合わせ演算子 <I>op</I> を各 <I>file</I> に適用し、
結果をスペース区切りのリストで返します。
</DL>
<P>

<B>foreach </B><I>name </I><B>(</B><I>wordlist</I><B>)</B>

<BR>

...

<DL COMPACT>
<DT><B>end</B>

<DD>
<I>wordlist</I> のメンバーを <I>name</I> に順々に代入し、
これと対応する <I>end</I> に挟まれた範囲の
コマンドシーケンスを実行します。
(<I>foreach</I> と <I>end</I> は 1 行に単独で現れなければなりません。)
組み込みコマンド <I>continue</I> を用いると
ループを途中で継続することができ、
組み込みコマンド <I>break</I> を用いると
ループを途中で終了させることができます。
このコマンドが端末から読み込まれると、
一度ループを `foreach?' プロンプト (あるいは <B>prompt2</B>)
で読み込み、全体を読み終えてからループの各文を実行します。
端末からの入力時にループの途中でタイプミスをした場合は
修正できます。

<DT><B>getspath </B>(+)

<DD>
システムの実行パスを表示します。 (TCF のみ)
<DT><B>getxvers </B>(+)

<DD>
実験的バージョンのプレフィックスを表示します。 (TCF のみ)
<DT><B>glob </B><I>wordlist</I>

<DD>
<I>echo</I> と似ていますが、`\' でのエスケープを認識せず、
また出力での単語区切りをヌル文字にします。
単語リストをファイル名に展開するために
プログラムからシェルを利用したいような場合に便利です。
<DT><B>goto </B><I>word</I>

<DD>
<I>word</I> はファイル名と `label' 形式の文字列を出力するコマンド置換です。
シェルは入力を可能なかぎりさかのぼり、
`label:' 形式の行 (空白やタブが前置されていても良い) を検索し、
その行の次から実行を継続します。
<DT><B>hashstat</B>

<DD>
内部のハッシュテーブルが、
これまでのコマンド探索にどの程度効率的であったか
(そして <I>exec</I> 類を使わずに済んだか) を示す統計行を表示します。
<B>path</B> の各成分のうち、
ハッシュ関数がヒットの可能性があるとしたものや、
`/' で始まらないものに対して <I>exec</I> が試みられます。
<DT><DD>
<I><A HREF="../../LDP_man-pages/man2/vfork.2.html">vfork</A></I>(2) のないマシンでは、
単にハッシュバケツのサイズを表示します。
</DL>
<P>

<B>history </B>[<B>-hTr</B>] [<I>n</I>]

<BR>

<B>history -S</B>|<B>-L|-M </B>[<I>filename</I>] (+)


<DL COMPACT>
<DT><B>history -c </B>(+)

<DD>
最初の形式はイベントリストの履歴を表示します。
<I>n</I> を与えると、新しい方最大 <I>n</I> 個のイベントを
表示または保存します。
<B>-h</B> を指定すると、行頭の数字抜きでリストを表示します。
<B>-T</B> を指定すると、タイムスタンプもコメントのかたちで表示されます。
(これを用いると、
`history -L' や `source -h' でのロードに適したファイルが作成できます。)
<B>-r</B> を指定すると、
表示の順番がデフォルトの古い順ではなく新しい順になります。

<DL COMPACT><DT><DD>
<P>

2 番目の形式で <B>-S</B> を指定すると、履歴リストを <I>filename</I>
に保存します。シェル変数 <B>savehist</B> の最初の単語が
数値に設定されていると、最大でその数値までの行数が保存されます。
<B>savehist</B> の 2 番目の単語が `merge' だった場合には、
履歴リストが現存の履歴ファイルにマージされ、タイムスタンプ順にソートされます
(デフォルトでは現存のファイルを置き換えます)。 (+)
マージは X Window System のように、
複数のシェルを同時に用いるような場合向けのものです。
現在は、シェルが行儀良く順々に終了するような場合でないと、
マージは成功しません。
<P>

<B>-L</B> を指定すると、シェルは <I>filename</I> を
履歴リストに追加します。<I>filename</I> は以前に <B>-S</B> オプションや
<B>savehist</B> 機構で保存された履歴リストファイルです。
<B>-M</B> は <B>-L</B> と似ていますが、
<I>filename</I> の内容は履歴リストにマージされ、
タイムスタンプの順にソートされます。
いずれの場合でも、<I>filename</I> が与えられなければ
<B>histfile</B> を用い、
<B>histfile</B> も設定されていなければ <I>~/.history</I> を用います。
`history -L' はほとんど `source -h' と同じですが、
前者ではファイル名を省略できます。
<P>

ログインシェルは `history -L' と同様のことを起動時に行っており、
また <B>savehist</B> が設定されていれば終了前に
`history -S' と同様のことを行います。
通常 <I>~/.tcshrc</I> だけが <I>~/.history</I> の前に source されるので、
<B>histfile</B> は <I>~/.login</I> ではなく
<I>~/.tcshrc</I> で設定すべきです。
<P>

<B>histlit</B> が設定されていると、
最初の形式と 2 番目の形式は履歴リストを
文字通りの (展開されない) かたちで表示、保存します。
<P>

最後の形式は履歴リストをクリアします。
</DL>

<DT><B>hup </B>[<I>command</I>] (+)

<DD>
<I>command</I> を指定すると、
hangup シグナルが送られたときに終了するようにして
<I>command</I> を実行し、
シェルが終了するときにそのコマンドに hangup シグナルを送るようにします。
コマンドによっては hangup に対するそれぞれ独自の反応を設定することがあり、
これは <I>hup</I> より優先されるかもしれません。
引数を設定しないと (シェルスクリプト内部のみで許されます)、
そのシェルは残りのスクリプトの途中で
hangup シグナルを受け取ると終了するようになります。
<B>シグナル処理</B>と組み込みコマンド <I>nohup</I> の部分も見てください。
<DT><B>if (</B><I>expr</I><B>) </B><I>command</I>

<DD>
<I>expr</I> (<B>式</B>で解説した式) の評価結果が真なら、
<I>command</I> が実行されます。
<I>command</I> に対する変数置換は、実行に先だって
<I>if</I> コマンドの残りの部分と同時に行われます。
<I>command</I> は単純なコマンドでなければならず、
エイリアス、パイプライン、(括弧で括られた / ていない)
コマンドリストは指定できません。ただし引数は指定できます。
<I>expr</I> が偽で、
<I>command</I> が<I>実行されない</I>場合でも
入出力リダイレクションは行われてしまいます。
これはバグです。
</DL>
<P>

<B>if (</B><I>expr</I><B>) then</B>

<BR>

...
<BR>

<B>else if (</B><I>expr2</I><B>) then</B>

<BR>

...
<BR>

<B>else</B>

<BR>

...

<DL COMPACT>
<DT><B>endif</B>

<DD>
指定した <I>expr</I> が真の場合、
最初の <I>else までのコマンド群が実行されます。
expr</I> が偽で <I>expr2</I> が真の場合は、
2 番目の <I>else</I> までのコマンド群が実行されます。以下同じです。
<I>else-if</I> のペアはいくつでも指定できますが、
<I>endif</I> はひとつしかいりません。
また <I>else</I> 部は省略可能です。
(<I>else</I> と <I>endif</I> の各単語は入力行の先頭にしか置けません。
<I>if</I> は入力行の先頭に単独で置くか、
<I>else</I> の後に置くかしなければなりません。)

<DT><B>inlib </B><I>shared-library</I> ... (+)

<DD>
各 <I>shared-library</I> を現在の環境に追加します。
共有ライブラリを削除する方法はありません。 (Domain/OS のみ)
<DT><B>jobs </B>[<B>-l</B>]

<DD>
アクティブなジョブをリストします。
<B>-l</B> を指定すると、
通常の情報に加えてプロセス ID もリストします。
TCF システムでは、各ジョブが実行されているサイトも表示します。
</DL>
<P>


<DL COMPACT>
<DT><B>kill </B>[<B>-s </B><I>signal</I>] <B>%</B><I>job</I>|<I>pid</I> ...

<DD>

<DT><B>kill -l</B>

<DD>
1 番目または 2 番目の形式は <I>signal</I> を
(何も指定されなければ TERM (terminate) シグナルを)
指定したジョブやプロセスに送ります。
<I>job</I> には<B>ジョブ</B>で解説されているように、
数値、文字列、`', `%', `+', `-' のどれかを指定できます。
シグナルは数値または名前 (<I>/usr/include/signal.h</I>
にあるものから前の `SIG' を取り除いたもの) のいずれかで与えます。
デフォルトの <I>job</I> はありません。
単に `kill' としても、現在のジョブへはシグナルを送りません。
TERM (terminate) または HUP (hangup) シグナルを送った場合は、
そのジョブやプロセスには CONT (continue) シグナルも送信されます。
3 番目の形式はシグナルの名前をリストします。


<DT><B>limit </B>[<B>-h</B>] [<I>resource</I> [<I>maximum-use</I>]]

<DD>
現在のプロセスと、
現在のプロセスが生成するプロセスが消費する資源が、
指定した <I>resource</I> に対してプロセスひとつにつき
<I>maximum-use</I> を越えないようにします。
<I>maximum-use</I> を指定しないと、current limit が表示されます。
<I>resource を指定しないと、すべての制限値を表示します。
</I><B>-h</B> フラグを指定すると、
current limit の代わりに hard limit を用います。
hard limit は current limit の限度を与えます。
hard limit はスーパーユーザーしか増やすことができませんが、
current limit は一般ユーザも可能な範囲内で増減できます。
<DL COMPACT><DT><DD>
<P>

現在制御できる資源は、
<I>cputime</I> (プロセスひとつにつき利用できる cpu 秒)、
<I>filesize</I> (作成できる単一ファイルの最大サイズ)、
<I>datasize</I> (プログラムテキストの終端を越えて <A HREF="../../LDP_man-pages/man2/sbrk.2.html">sbrk</A>(2) で増やせる
データ領域+スタック領域の最大サイズ)、
<I>stacksize</I> (自動的に拡張されるスタック領域の最大サイズ)、
<I>coredumpsize</I> (生成されるコアダンプの最大サイズ)、
<I>memoryuse</I>
(プロセスひとつにいちどきに割り当てることのできる物理メモリの最大サイズ)、
です。
<P>

<I>maximum-use</I> は浮動小数点値または整数値に、
単位をつけて指定します。
<I>cputime</I> 以外の制限値は、`k' または
`kilobytes' (1024 バイト) をデフォルトの単位としています。
単位として `m' または `megabytes' を用いることもできます。
<I>cputime</I> のデフォルトの単位は `seconds' です。
分を表す `m', 時間を表す `h', 分 + 秒を表す
`mm:ss' の形式などを用いることもできます。
<P>

<I>resource</I> も単位も、他と区別がつく範囲で後半部を省略可能です。
</DL>

<DT><B>log </B>(+)

<DD>
シェル変数 <B>watch</B> を表示し、そこにリストアップされている
ユーザがログインしていればログインした時刻に関わらず報告します。
<I>watchlog</I> についても参照してください。
<DT><B>login</B>

<DD>
ログインシェルを終了して、<I>/bin/login</I> (訳注: FreeBSD では
/usr/bin/login です) のインスタンスで置き換えます。これはログオフする
方法のひとつであり、<I>sh</I>(1) との互換性を保つ意味もあります。
<DT><B>logout</B>

<DD>
ログインシェルを終了します。<B>ignoreeof</B> がセットされている場合に
特に役立つでしょう。
<DT><B>ls-F </B>[-<I>switch</I> ...] [<I>file</I> ...] (+)

<DD>
`ls -F' と同じようにファイルのリストを表示しますが、ずっと高速です。
各種の特別なファイル形式は特殊文字を用いて以下のように示されます。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>/<DD>
ディレクトリ
<DT>*<DD>
実行可能
<DT>#<DD>
ブロック型デバイス
<DT>%<DD>
キャラクタ型デバイス
<DT>|<DD>
名前付きパイプ (名前付きパイプのあるシステムでのみ)
<DT>=<DD>
ソケット (ソケットのあるシステムでのみ)
<DT>@<DD>
シンボリックリンク (シンボリックリンクのあるシステムでのみ)
<DT>+<DD>
隠しディレクトリ (AIX のみ) またはコンテキスト依存 (HP/UX のみ)
<DT>:<DD>
ネットワーク特殊型 (HP/UX のみ)

</DL>
<P>

シェル変数 <B>listlinks</B> がセットされている場合は、
シンボリックリンクに関してより詳しく表示されます
(もちろん、シンボリックリンクを持つシステムでだけです)。
<P>


<DL COMPACT>
<DT>@<DD>
ディレクトリでないものへのシンボリックリンク
<DT>&gt;<DD>
ディレクトリへのシンボリックリンク
<DT>&amp;<DD>
どこへのリンクでもないシンボリックリンク

</DL>
<P>

<B>listlinks</B> はシンボリックリンクの指し示すファイルが
存在するパーティションのマウントを引き起こすため、<I>ls-F</I> を
遅くしてしまいます。
<P>

もしシェル変数 <B>listfrags</B> が `x', `a', `A' のいずれかに
セットされているか、それらの組合せ (たとえば `xA') に
セットされている場合は、これが `ls -xF' や `ls -Fa'、
もしくは組み合わせて `ls -FxA' のように <I>ls-F</I> の
フラグとして使われます。`ls -C' がデフォルトでないマシンでは
<B>listflags</B> が `x' を含む場合には <I>ls -xF' のように、
そうでなければ ls -F</I> は `ls -CF' のように振舞います。
<I>ls -F</I> は、何らかのスイッチが与えられた場合には <I><A HREF="../../0MultiFileIdx/man1/ls.1.html">ls</A></I>(1)
に引数を渡すので、`alias ls ls-F' は通常、正しく動作します。
<P>

組み込みの <B>ls-F</B> はファイルタイプや拡張子によってファイル名を
色分けすることができます。シェル変数 <B>color</B> <I>tcsh</I> と
環境変数 <B>LS_COLORS</B> を参照してください。
</DL>

<P>

<B>migrate </B>[<B>-</B><I>site</I>] <I>pid</I>|<B>%</B><I>jobid</I> ... (+)


<DL COMPACT>
<DT><B>migrate -</B><I>site</I> (+)

<DD>
最初の形式では指定したプロセスまたはジョブを、指定した場所もしくは
システムパスによって決定されるデフォルトの場所に移動します。
<P>
2 番目の形式は `migrate -<I>site</I> $$' と同じ意味を持ちます。
これは現在のプロセスを指定した場所に移動します。シェルは
その tty を失わないことになっているので、シェル自身を移動することは
予期しない動作の原因となります。(TCF のみ)

<DT><B>newgrp </B>[<B>-</B>] <I>group</I> (+)

<DD>
`exec newgrp' と同じ意味をもちます。<I><A HREF="../../0MultiFileIdx/man1/newgrp.1.html">newgrp</A></I>(1) を
参照してください。
シェルがこれを使うことができるようにコンパイルされている場合に
のみ使用可能です。シェル変数 <B>version</B> を参照してください。
<DT><B>nice </B>[<B>+</B><I>number</I>] [<I>command</I>]

<DD>
シェルのスケジューリング優先度を <I>number</I> に設定するか、
<I>number</I> が指定されていない場合は 4 に設定します。<I>command</I>
をつけると、コマンド <I>command</I> を適切な優先度で実行します。
<I>number</I> が大きいほど、そのプロセスが獲得する
CPU 時間は短くなります。
スーパーユーザは `nice -number ...' とすることにより負の値を
設定することができます。コマンドは常にサブシェルから実行され、
コマンドには単純な <I>if</I> 文の場合と同じ制限が課されます。
<DT><B>nohup </B>[<I>command</I>]

<DD>
<I>command</I> をつけると、コマンド <I>command</I> を
ハングアップシグナルを無視して実行するようにします。
これらのコマンドが <I>nohup</I> をオーバーライドして
ハングアップシグナルに対して自分自身で応答するようにすることが
あることに注意してください。引数のない場合 (シェルスクリプト中で
のみ許されます)、スクリプトのそれ以降の部分でシェルは
ハングアップシグナルを無視するようになります。
<B>シグナル処理</B>と、組み込みコマンド <I>hup</I> についても
参照してください。
<DT><B>notify </B>[<B>%</B><I>job</I> ...]

<DD>
ユーザに非同期的に指定したジョブ (%<I>job</I> が省略された場合は
カレントジョブ) の状態に何らかの変化があった場合に非同期的に、
通知するようにします。この場合は通常と異なり、次のプロンプトが
出力されるまで待ちません。
<I>job</I> は <B>Jobs</B> に記述されているように番号、文字列、`', `%',
`+', `-' のどれでも許されます。
シェル変数 <B>notify</B> も参照してください。
<DT><B>onintr </B>[<B>-</B>|<I>label</I>]

<DD>
割り込み時のシェルの動作を制御します。
引数がなければ、シェルのデフォルトの割り込み時の動作に設定されます。
この場合は、シェルスクリプトは割り込みで中断され、
コマンド実行時はコマンドの実行を中断してコマンド入力待ちに戻ります。
`-' が指定された場合はすべての割り込みが無視されます。
<I>label</I> を指定すると、割り込みが発生したり子プロセスが
割り込みで中断したりした場合に `goto <I>label</I>' を実行します。
<DT><DD>
<I>onintr</I> は、システムのスタートアップファイル
(<B>FILES</B> を参照) で割り込みが禁止されている場合には無視されます。
<DT><B>popd </B>[<B>-p</B>] [<B>-l</B>] [<B>-n</B>|<B>-v</B>] [<B>+</B><I>n</I>]

<DD>
引数がなければ、ディレクトリスタックからひとつ値を取り出して、
そこに移動します。`+<I>n</I>' のように数値を与えると、
ディレクトリスタックの <I>n</I>' 番目のエントリを破棄します。
<DT><DD>
また、すべての形式の <I>popd</I> は <I>dirs</I> のように
ディレクトリスタックの最後のエントリを表示します。
シェル変数 <B>pushdsilent</B> はこれを抑制し、
<B>-p</B> フラグによって <B>pushdsilent</B> の動作を
オーバーライドすることができます。
<B>-l</B>, <B>-n</B>, <B>-v</B> フラグは <I>popd</I> でも、<I>dirs</I>
と同じ意味をもちます。
<DT><B>printenv </B>[<I>name</I>] (+)

<DD>
すべての環境変数の名前と値を表示するか、<I>name</I> を与えた場合には
環境変数 <I>name</I> の値を表示します。
<DT><B>pushd </B>[<B>-p</B>] [<B>-l</B>] [<B>-n</B>|<B>-v</B>] [<I>name</I>|<B>+</B><I>n</I>]

<DD>
引数がなければ、ディレクトリスタックの一番上にあるふたつの
エントリを入れ換えます。もし <B>pushdtohome</B> がセットされていれば、
引数なしの <I>pushd</I> は <I>cd</I> のように `pushd ~'
を行います。 (+)
<I>name</I> をつけると、現在の作業ディレクトリを
ディレクトリスタックに積んで <I>name</I> に移動します。
もし <I>name</I> が `-' であれば、ひとつ前の作業ディレクトリとして
解釈されます (<B>ファイル名置換</B>を参照)。 (+)
<B>dunique</B> がセットされていれば、<I>pushd</I> は、スタックに
<I>name</I> を積む前にすべてのそれと同じものを指すエントリを
スタックから除去します。(+)
`+<I>n</I>' として番号をつけると、ディレクトリスタックの
<I>n</I> 番目のエントリがトップにくるようにスタックを回転します。
<B>dextract</B> がセットされている場合、`pushd +<I>n</I>' を行うと
<I>n</I> 番目のディレクトリが展開されて、
スタックのトップに移動されます。(+)
<DT><DD>
また、すべての形式の <I>pushd</I> は <I>dirs</I> と同じように
ディレクトリスタックの最終的な内容を表示します。シェル変数
<B>pushdsilent</B> をセットすることでこれをやめることができ、
またさらにこれは <B>-p</B> フラグによってオーバーライドすることが
可能です。<I>pushd</I> に対する <B>-l</B>,
<B>-n</B>, <B>-v</B> フラグの意味は <I>dirs</I> のものと同様です。(+)
<DT><B>rehash</B>

<DD>
<B>path</B> 変数の示すディレクトリの内容を保持する
内部ハッシュテーブルを再構成します。これはログインしている間に
新しいコマンドが <B>path</B> の示すディレクトリに追加された場合に
必要です。これはあなたが自分の個人的なディレクトリにコマンドを
追加した場合か、システム管理者がシステムディレクトリの内容を変更した
場合にのみ行われるべきです。このコマンドはまた、チルダ記号を
用いたホームディレクトリ記述のキャッシュもフラッシュします。
<DT><B>repeat </B><I>count command</I>

<DD>
指定されたコマンド <I>command</I> を <I>count</I> 回
繰り返し実行します。<I>command</I> に指定するものは
一行 <I>if</I> 文で指定する <I>command</I> と同様の制限を受けます。
入出力リダイレクションは <I>count</I> が 0 であっても、
必ず一回だけ処理されます。
<DT><B>rootnode //</B><I>nodename </I>(+)

<DD>
ルートノードを //<I>nodename</I> に変更します。結果として `/' は
`//<I>nodename</I>' として解釈されます。 (Domain/OS のみ)
</DL>
<P>

<B>sched </B>(+)

<BR>

<B>sched </B>[<B>+</B>]<I>hh:mm command</I> (+)


<DL COMPACT>
<DT><B>sched -</B><I>n</I> (+)

<DD>
最初の形式は、予定されているイベントのリストを表示します。
シェル変数 <B>sched</B> は予定されているイベントのリストを
表示する形式を設定するためにセットされます。
3 番目の形式は <I>command</I> を予定されているイベントのリストに
追加します。たとえば、

<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; sched 11:00 echo It\'s eleven o\'clock.
</DL>
<P>

は、午前 11 時に `It's eleven o'clock.' を表示させます。
時間は 12 時間制の AM/PM を指定する書式でも構いません。
<DL COMPACT>
<DT><DD>
&gt; sched 5pm set prompt='[%h] It\'s after 5; go home: &gt;'
</DL>
<P>

また、現在時刻からの相対的な時間でも構いません。
<DL COMPACT>
<DT><DD>
&gt; sched +2:15 /usr/lib/uucp/uucico -r1 -sother
</DL>
<P>

相対的な指定では AM/PM を使うべきではありません。
3 番目の書式では <I>n</I> 番のイベントをリストから削除します。
<DL COMPACT>
<DT><DD>
&gt; sched
<BR>

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;&nbsp;4&nbsp;15:42&nbsp;&nbsp;/usr/lib/uucp/uucico&nbsp;-r1&nbsp;-sother
<BR>

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;&nbsp;4&nbsp;17:00&nbsp;&nbsp;set&nbsp;prompt=[%h]&nbsp;It's&nbsp;after&nbsp;5;&nbsp;go&nbsp;home:&nbsp;&gt;
<BR>

&gt; sched -2
<BR>

&gt; sched
<BR>

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;Wed&nbsp;Apr&nbsp;&nbsp;4&nbsp;15:42&nbsp;&nbsp;/usr/lib/uucp/uucico&nbsp;-r1&nbsp;-sother
</DL>
<P>

予定イベントのリストにあるコマンドは、コマンドがリストに
入れられてから最初のプロンプトが出たあとで実行されます。
実行の正確な時間を過ぎてしまうことはありますが、
次のプロンプトでは遅れたコマンドが実行されます。
シェルがユーザのコマンド入力を待っている間に実行予定時間が来た
コマンドは直ちに実行されます。しかし、既に実行されているコマンドの
実行に割り込むことはできませんし、
予定されていたコマンドの実行についても同様です。
<P>

この仕組みはいくつかの Unix システムに実装されている <I><A HREF="../../at/man1/at.1.html">at</A></I>(1) に
似ていますが同じではありません。
指定した時刻通りにコマンドが実行できないことがあるのは非常に大きな
短所です。しかしこの仕組みの長所は、<I>sched</I> はシェルから
直接実行でき、シェル変数やその他の資源へのアクセスが
できるということです。これは時刻によってユーザの作業環境を
変化させることを可能にします。
</DL>

</DL>
<P>

<B>set</B>

<BR>

<B>set </B><I>name</I> ...

<BR>

<B>set </B><I>name</I><B>=</B><I>word</I> ...

<BR>

<B>set [-r] [-f|-l] </B><I>name</I><B>=(</B><I>wordlist</I><B>)</B> ... (+)

<BR>

<B>set </B><I>name[index]</I><B>=</B><I>word</I> ...

<BR>

<B>set -r </B>(+)

<BR>

<B>set -r </B><I>name</I> ... (+)


<DL COMPACT>
<DT><B>set -r </B><I>name</I><B>=</B><I>word</I> ... (+)

<DD>
1 番目の形式ではすべてのシェル変数の値を表示します。
複数の単語からなる値を持つ変数は括弧で囲まれた値のリストとして表示します。
2 番目の形式では <I>name</I> に空文字列をセットします。
3 番目の形式では <I>name</I> に単一の単語 <I>word</I> をセットします。
4 番目の形式では <I>name</I> に <I>wordlist</I> で示した単語の
リストをセットします。すべての場合においてコマンド置換や
ファイル名置換が値に対して行われます。-r が指定された場合には、
値は読み取り専用でセットされます。-f または -l が
指定された場合には、単語リストの中での順番を保ちながら
重複した単語が取り除かれます。
-f は最初に出てきたものをリストに残し、-l は最後に出てきたものを
リストに残します。
5 番目の書式では変数 name の <I>index</I> 番目の要素に <I>word</I> を
セットします。この場合この要素は既に存在していなければなりません。
6 番目の書式は読み取り専用にセットされているシェル変数の
名前の一覧を表示します。
7 番目の書式は <I>name</I> を、値の有無に関わらず読み取り専用に
セットします。
8 番目の書式は 3 番目の書式と同じですが、同時に <I>name</I> を
読み取り専用にセットします。

<DT><DD>
複数の変数をセットしたり、読み取り専用にセットするために
ひとつの set コマンドへの引数を繰り返すことができます。
しかし、変数への代入処理を開始する前に変数展開処理が一度に
行われることに注意してください。また、`=' は <I>name</I> と
<I>word</I>の両方と接しているか、空白で区切られているかの
どちらかであり、片方だけと接してはいけないことに注意してください。
組み込みコマンド <I>unset</I> についても参照してください。
<DT><B>setenv </B>[<I>name </I>[<I>value</I>]]

<DD>
引数がなければ、すべての環境変数の名前と値を表示します。
<I>name</I> を与えられた場合は、環境変数 <I>name</I> の値を <I>value</I> に
セットするか、<I>value</I> がなければ空文字列にセットします。
<DT><B>setpath </B><I>path </I>(+)

<DD>
<I>setpath</I>(1) と同様です。(Mach のみ)
<DT><B>setspath</B> LOCAL|<I>site</I>|<I>cpu</I> ...  (+)

<DD>
システム実行パスを設定します。(TCF のみ)
<DT><B>settc </B><I>cap value </I>(+)

<DD>
シェルに端末ケーパビリティ <I>cap</I> (<I><A HREF="../../LDP_man-pages/man5/termcap.5.html">termcap</A></I>(5) で定義されたもの) は
値 <I>value</I> を持つことを教えます。
妥当性のチェックは行われません。
Concept 端末のユーザは、一番右の桁で適切な折り返しを行うために
`settc xn no' を行う必要があるかもしれません。
<DT><B>setty </B>[<B>-d</B>|<B>-q</B>|<B>-x</B>] [<B>-a</B>] [[<B>+</B>|<B>-</B>]<I>mode</I>] (+)

<DD>
シェルが変更してはならない tty モード
(<B>端末管理</B>を参照) を制御します。
<B>-d</B>, <B>-q</B>, <B>-x</B> は <I>setty</I> に、
それぞれ `edit', `quote', `execute' 時の tty モードをセットします。
<B>-d</B>, <B>-q</B>, <B>-x</B> が指定されない場合、
`execute' が使用されます。
<DT><DD>
他の引数がなければ、<I>setty</I> はオン (`+mode') または
オフ (`-mode') に固定されているモードを一覧表示します。
使用可能なモードはシステムごとに異なるため、表示も異なります。
<B>-a</B> をつけると、固定されているかどうかにかかわらず
すべての tty モードを一覧表示します。
<B>+</B><I>mode</I>, <B>-</B><I>mode</I>, <I>mode</I> は、それぞれモード
<I>mode</I> をオンに固定、オフに固定、非固定にします。
たとえば、`setty +echok echoe' は `echok' をオンに固定し、
シェルがコマンドを実行する際に `echoe' モードを
オンにしたりオフにしたりできるようにします。
<DT><B>setxvers</B> [<I>string</I>] (+)

<DD>
<I>string</I> に試験的なバージョンプリフィックスをセットし、
<I>string</I> が省略された場合にはそれを削除します。(TCF のみ)
<DT><B>shift </B>[<I>variable</I>]

<DD>
引数がなければ、<B>argv</B>[1] を破棄してメンバを左にずらします。
<B>argv</B> がセットされていなかったり、
値が 1 つもなかった場合にはエラーになります。
変数名 <I>variable</I> を指定すると、
変数 <I>variable</I> に対して同じ動作を行います。
<DT><B>source </B>[<B>-h</B>] <I>name</I> [<I>args</I> ...]

<DD>
<I>name</I> からコマンドを読み取って実行します。
コマンドはヒストリリストには残されません。
もし引数 <I>args</I> が与えられればそれは <B>argv</B> に
入れられます。(+)
<I>source</I> コマンドは入れ子にすることができます。
もし入れ子のレベルがあまりに深くなり過ぎると、
シェルはファイル記述子の不足を起こすでしょう。
<I>source</I> でのエラーはすべての入れ子になっている <I>source</I> の
実行を停止します。
<B>-h</B> を付けると、コマンドを実行するかわりに `history -L' の
ようにヒストリリストに入力されます。
<DT><B>stop %</B><I>job</I>|<I>pid</I> ...

<DD>
指定したバックグラウンドで実行されているジョブまたはプロセスを
停止します。<I>job</I> は番号か、文字列か、あるいは<B>ジョブ</B>に
示されている `', `%', `+', `-' のいずれかを指定します。
デフォルトの <I>job</I> は存在しないので、
ただ `stop' を実行するだけではカレントジョブを
停止することにはなりません。
<DT><B>suspend</B>

<DD>
<B>^Z</B> で送られるような stop シグナルが送られたかのように、
その場でシェルを停止させます。
これは多くの場合 <I><A HREF="../../0MultiFileIdx/man1/su.1.html">su</A></I>(1) で起動したシェルを停止するのに用いられます。
</DL>
<P>

<B>switch (</B><I>string</I><B>)</B>

<BR>

<B>case </B><I>str1</I><B>:</B>


<DL COMPACT>
<DT><DD>
...
<BR>

<B>breaksw</B>

</DL>
<P>

...
<P>

<B>default:</B>

<DL COMPACT>
<DT><DD>
...
<BR>

<B>breaksw</B>

<DT><B>endsw</B>

<DD>
指定された文字列 <I>string</I> に対して、各 case ラベルを連続的に
マッチさせます。<I>string</I> にはそれに先だってコマンド置換と
ファイル名置換が行われます。case ラベルには変数置換が行われ、
ファイル名メタキャラクタの `*', `?', `[...]' を用いることができます。
`default' ラベルが出てくるまでにどの case ラベルとも
マッチしなかった場合、default ラベルの後から実行が開始されます。
各 case ラベルと default ラベルは行の最初になければなりません。
<I>breaksw</I> コマンドは実行を中断して <I>endsw</I> の後から
再開させます。
<I>breaksw</I> を使用しない場合は C 言語と同様に case ラベルや
default ラベルを通過して実行が続けられます。
もしマッチするラベルも default ラベルも存在しない場合は、
実行は <I>endsw</I> の後から再開されます。

<DT><B>telltc </B>(+)

<DD>
端末ケーパビリティのすべての値を一覧表示します
(<I><A HREF="../../LDP_man-pages/man5/termcap.5.html">termcap</A></I>(5) を参照)。
<DT><B>time </B>[<I>command</I>]

<DD>
コマンド <I>command</I> (エイリアスやパイプライン、コマンドリストや
括弧でくくったコマンドリストでない単純なものでなければなりません)
を実行し、変数 <B>time</B> の項で説明する形式で、実行所用時間に
関する要約を表示します。必要ならば、コマンド終了時に時間を
表示するための追加のシェルが生成されます。<I>command</I> を
指定しなかった場合は、現在のシェルとその子プロセスが使用した時間に
関する要約が表示されます。
<DT><B>umask </B>[<I>value</I>]

<DD>
8 進数で指定されたファイル作成マスクを <I>value</I> に設定します。
一般的なマスクの値としては、グループにすべての権限を与え、
その他には読み取りと実行のみを許可する 002 や、グループとその他に
読み取りと実行を許可する 022 があります。
<I>value</I> を省略すると、現在のファイル作成マスクを表示します。
<DT><B>unalias </B><I>pattern</I>

<DD>
<BR>

パターン <I>pattern</I> にマッチするすべてのエイリアスを削除します。
したがって `unalias *' とすることですべてのエイリアスを
削除できます。
<I>unalias</I> するものがなかった場合もエラーにはなりません。
<DT><B>uncomplete </B><I>pattern</I> (+)

<DD>
パターン <I>pattern</I> にマッチするすべての補完対象を削除します。
したがって `uncomplete *' とすることですべての補完対象を
削除します。
<I>uncomplete</I> するものがなかった場合もエラーにはなりません。
<DT><B>unhash</B>

<DD>
実行プログラムの検索を高速化する内部ハッシュテーブルの使用を
禁止します。
<DT><B>universe </B><I>universe</I> (+)

<DD>
universe を <I>universe</I> に設定します。(Masscomp/RTU のみ)
<DT><B>unlimit </B>[<B>-h</B>] [<I>resource</I>]

<DD>
リソース <I>resource</I> の制限を解除します。<I>resource</I> が
指定されない場合は、すべてのリソースに関する制限が解除されます。
<B>-h</B> が指定されると、対応するハードリミットが解除されます。
これはスーパーユーザのみが行うことができます。
<DT><B>unset </B><I>pattern</I>

<DD>
パターン <I>pattern</I> にマッチするすべての変数を、読み取り専用の
場合も含めて削除します。したがって `unset *' とすることによって
読み取り専用のものも含めてすべての変数が削除されますが、
これは良いことではありません。
<I>unset</I> するものがなかった場合もエラーにはなりません。
<DT><B>unsetenv </B><I>pattern</I>

<DD>
パターン <I>pattern</I> にマッチするすべての環境変数を削除します。
したがって `unsetenv *' とすることによってすべての環境変数を
削除することができますが、これは良いことではありません。
<I>unsetenv</I> する環境変数がなかった場合もエラーにはなりません。
<DT><B>ver </B>[<I>systype</I> [<I>command</I>]] (+)

<DD>
引数が与えられなかった場合は <B>SYSTYPE</B> を表示します。
<I>systype</I> を指定した場合は、<B>SYSTYPE</B> を
<I>systype</I> に設定します。<I>systype</I> とコマンド
<I>command</I> を指定した場合は、<I>systype</I> で <I>command</I> を
実行します。<I>systype</I> は `bsd4.3' か `sys5.3' のいずれかです。
(Domain/OS のみ)
<DT><B>wait</B>

<DD>
すべてのバックグラウンドジョブの終了を待ちます。対話的にシェルが
実行されている場合、割り込みにより wait を停止することが
できます。この際シェルはまだ終了していないすべてのジョブの名前と
その番号を表示します。
<DT><B>warp </B><I>universe</I> (+)

<DD>
universe を <I>universe</I> に設定します。(Convex/OS のみ)
<DT><B>watchlog </B>(+)

<DD>
組み込みコマンド <I>log</I> の別名です (そちらも参照)。
コンパイル時に使用できるように設定されている場合にのみ使用可能です。
シェル変数 <B>version</B> を参照してください。
<DT><B>where </B><I>command</I> (+)

<DD>
コマンド <I>command</I> について、エイリアスや組み込みコマンド、
<B>path</B> にある実行可能ファイルを含めてシェルの知っている
すべての実体を一覧表示します。
<DT><B>which</B> <I>command</I> (+)

<DD>
コマンド <I>command</I> が、<B>path</B> の検索などの処理のあとで、
実際に実行されるコマンドを表示します。組み込みのものは
<I><A HREF="../../GNU_which/man1/which.1.html">which</A></I>(1) とほとんど同じですが、
<I>tcsh</I> のエイリアスや組み込みコマンドついても正しく報告し、
また 10 から 100 倍高速です。
編集コマンド <I>which-command</I> についても参照してください。
</DL>
<P>

<B>while (</B><I>expr</I><B>)</B>

<BR>

...

<DL COMPACT>
<DT><B>end</B>

<DD>
指定された式 <I>expr</I> (<B>式</B>で述べられている式) の評価結果が 0
でない限り、<I>while</I> とそれに対応する <I>end</I> の間のコマンド
を繰り返し実行します。
<I>while</I> と <I>end</I> はその行に単独で書かれなければなりません。
<I>break</I> と <I>continue</I> は、ループを途中で中断したり再開する
場合に使用します。
入力が端末の場合は、<I>foreach</I> の場合と同じように、
ループの内容を一通り入力するまでユーザにプロンプトが出力されます。

</DL>
<A NAME="lbBO">&nbsp;</A>
<H3>特別なエイリアス (+)</H3>

これらのエイリアスは、設定されている場合それぞれ指示された時刻に
自動的に実行されます。これらのエイリアスは、初期状態ではすべて
未定義です。
<DL COMPACT>
<DT><B>beepcmd</B>

<DD>
シェルが端末ベルを鳴らしたいときに実行されます。
<DT><B>cwdcmd</B>

<DD>
作業ディレクトリが変更されるたびに実行されます。たとえば、
ユーザが X Window System 上で作業していて、
<I>xterm</I>(1) および <I>twm</I>(1) のように、
タイトルバーをサポートしている
リペアレントウインドウマネージャを使用していて、
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; alias cwdcmd  'echo -n &quot;^[]2;${HOST}:$cwd ^G&quot;'
</DL>
<P>

を実行すると、シェルは、動作中の <I>xterm</I>(1) のタイトルを
ホスト名、コロン、そしてカレント作業ディレクトリのフルパスに
変更します。
これをもっと面白く実行するには、次のようにします。
<DL COMPACT>
<DT><DD>
&gt; alias cwdcmd 'echo -n &quot;^[]2;${HOST}:$cwd^G^[]1;${HOST}^G&quot;'
</DL>
<P>

こうすると、ホスト名および作業ディレクトリはタイトルバーに
変更されますが、アイコンマネージャのメニューにはホスト名しか
表示されなくなります。
<P>

<I>cwdcmd</I> 中に <I>cd</I>, <I>pushd</I> あるいは <I>popd</I> を置くと、
無限ループを引き起こす可能性があることに注意してください。
そういうことをする人は、そうしてしまった代償は受けるものだというのが
作者の見解です。
</DL>

<DT><B>jobcmd</B>

<DD>
各コマンドが実行される前またはコマンドが状態を変える前に実行します。
<I>postcmd</I> と似ていますが、組み込みコマンドでは表示しません。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; alias jobcmd  'echo -n &quot;^[]2\;\!#^G&quot;'
</DL>
<P>

として <I>vi foo.c</I> を実行すると、
コマンド文字列が xterm タイトルバーに表示されます。
</DL>

<DT><B>helpcommand</B>

<DD>
<B>run-help</B> 編集コマンドが実行します。ヘルプが探すコマンド名は、
単一の引数として渡されます。
たとえば、
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; alias helpcommand '\!:1 --help'
</DL>
<P>

とすると、GNU のヘルプ呼び出し方法を使った、
コマンドそのもののヘルプ表示が実行されます。
現在のところ、たくさんのコマンドを書いたテーブルを使う以外には、
いろいろな呼び出し方法 (たとえば、Unix の `-h' オプション）を
使い分ける簡単な方法はありません。
</DL>

<DT><B>periodic</B>

<DD>
<B>tperiod</B> 分おきに実行されます。このエイリアスは、
たとえば新しいメールが届いたというような、
日常的ではあってもそれほど頻繁には起こらない変更点を
チェックするのに便利な手段を提供します。
たとえば、
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; set tperiod = 30
<BR>

&gt; alias periodic checknews
</DL>
<P>

とすると、30 分おきに <I>checknews</I>(1) プログラムが起動します。
<I>periodic</I> が設定されているが、<B>tperiod</B> が設定されていないか
あるいは 0 に設定されている場合、<I>periodic</I> は <I>precmd</I>
のように振る舞います。
</DL>

<DT><B>precmd</B>

<DD>
プロンプトが表示される直前に実行されます。たとえば、
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; alias precmd date
</DL>
<P>

とすると、各コマンド用にシェルプロンプトが表示される直前に
<I><A HREF="../../0MultiFileIdx/man1/date.1.html">date</A></I>(1) が起動します。
<I>precmd</I> に何を設定できるかには制限はありませんが、
慎重に選んでください。
</DL>

<DT><B>postcmd</B>

<DD>
各コマンドが実行される前に実行されます。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; alias postcmd  'echo -n &quot;^[]2\;\!#^G&quot;'
</DL>
<P>

とすると、<I>vi foo.c</I> を実行すると xterm のタイトルバーに
このコマンド文字列が書かれます。
</DL>

<DT><B>shell</B>

<DD>
スクリプト中でインタプリタを指定していない実行可能スクリプト用の
インタプリタを指定します。
最初の単語は、使用したいインタプリタへのフルパスでなくてはなりません
(たとえば、`/bin/csh' や `/usr/local/bin/tcsh')。
</DL>
<A NAME="lbBP">&nbsp;</A>
<H3>特別なシェル変数</H3>

このセクションで述べる変数は、シェルにとっては特別な意味のあるものです。
<P>

シェルは、起動時に次の変数を設定します。<B>addsuffix</B>, <B>argv</B>,
<B>autologout</B>, <B>command</B>, <B>echo_style</B>,
<B>edit</B>, <B>gid</B>, <B>group</B>, <B>home</B>, <B>loginsh</B>,
<B>oid</B>, <B>path</B>, <B>prompt</B>, <B>prompt2</B>, <B>prompt3</B>,
<B>shell</B>, <B>shlvl</B>, <B>tcsh</B>, <B>term</B>, <B>tty</B>,
<B>uid</B>, <B>user</B> そして <B>version</B> です。
これらの変数は、起動後はユーザが変更しない限り変更されません。
シェルは、必要があれば、<B>cwd</B>, <B>dirstack</B>, <B>owd</B>
および <B>status</B> を更新し、ログアウト時に <B>logout</B> を設定します。
<P>

シェルは、シェル変数 <B>afsuser</B>, <B>group</B>, <B>home</B>,
<B>path</B>, <B>shlvl</B>, <B>term</B> および <B>user</B> と同名の
環境変数との同期を取ります。
つまり、環境変数が変更されると、シェルは対応するシェル変数を合致するように
変更するのです (シェル変数が読み込み専用でない場合です)。また、その逆も
行います。ここで、<B>cwd</B> と <B>PWD</B> は同じ意味を持ちますが、
この方法では同期は行われないということに注意してください。
また、シェルは、自動的に <B>path</B> と <B>PATH</B> の違った形式を
相互変換するということにも注意してください。
<DL COMPACT>
<DT><B>addsuffix </B>(+)

<DD>
これが設定されている場合、ファイル名が補完の際に完全に一致するときに、
一致したものがディレクトリの場合には末尾に `/' を付け加え、
通常のファイルの場合には末尾にスペースを加えます。
デフォルトで設定されています。
<DT><B>afsuser </B>(+)

<DD>
これが設定されている場合、<B>autologout</B> の autolock 機能は、
ローカルのユーザ名の代わりにこの値を kerberos 認証用に使います。
<DT><B>ampm </B>(+)

<DD>
これが設定されている場合、時刻が 12 時間単位の AM/PM フォーマットで
すべて表示されます。
<DT><B>argv</B>

<DD>
シェルへの引数です。位置パラメータは <B>argv</B> から取られます。
すなわち、`$1' は `$argv[1]' に置き換えられるといった具合です。
デフォルトで設定されていますが、通常対話型シェルでは空です。
<DT><B>autocorrect </B>(+)

<DD>
これが設定されている場合は、補完を試みる前に
自動的に <I>spell-word</I>
編集コマンドが実行されます。
<DT><B>autoexpand </B>(+)

<DD>
これが設定されている場合は、補完を試みる前に自動的に
<I>expand-history</I> 編集コマンドが実行されます。
<DT><B>autolist </B>(+)

<DD>
これが設定されている場合は、あいまいな補完を行った後、
可能性のあるものをリストします。
<BR>&nbsp;`ambiguous'&nbsp;が設定されている場合、可能性のあるものを
リストするのは、補完によって何の文字も
追加されなかった場合に限られます。
<DT><B>autologout </B>(+)

<DD>
1 番目の単語は、時間を分単位で表しており、
この時間以上の間、何の処理もしていなければ
自動的にログアウトされます。2 番目の単語はオプションであり、
ここで指定された時間以上の間、何の処理もしていなければ
自動ロックがかかります。
シェルが自動的にログアウトする際には、
シェルは `auto-logout' と出力し、logout 変数を `automatic' に
設定し、そして終了します。
シェルが自動的にロックされたユーザは、作業を続けたいなら
自分のパスワードを入力することが必要になります。5 回入力に
失敗すると、自動的にログアウトします。
ログインシェルおよびスーパユーザのシェルでは、デフォルトで
`60'(60 分後自動的にログアウトし、ロックはかけない) に
設定されています。しかし、シェルがウインドウシステムの
もとで動いていると認識した場合
(すなわち、<B>DISPLAY</B> 環境変数が設定されている) や、
tty が疑似 tty(pty) である場合、あるいは、シェルがそのようには
コンパイルされていない場合 (<B>version</B> シェル変数を参照)
には設定されません。
<B>afsuser</B> および <B>logout</B> シェル変数も
参照してください。
<DT><B>backslash_quote </B>(+)

<DD>
これが設定されている場合、バックスラッシュ (`\') は
常に `\', `'', および `&quot;' でクォートされます。これによって、
複雑なクォートをする手間が緩和されますが、
<I>csh</I>(1) スクリプト中で文法エラーをひき起こす
可能性が出てきます。
<DT><B>catalog</B>

<DD>
メッセージカタログのファイル名です。
これが設定されている場合、
デフォルトの `tcsh' の代りに `tcsh.${catalog}' を、
メッセージカタログとして tcsh は使用します。
<DT><B>cdpath</B>

<DD>
カレントディレクトリ中にサブディレクトリが見つからなかった場合に、
<I>cd</I> が探索すべきディレクトリのリストです。
<DT><B>color</B>

<DD>
これが設定されている場合、組み込みコマンド <B>ls-F</B> 用の
カラー表示を有効にし、<B>--color=auto</B> を
<B>ls</B> に渡します。あるいは、ただ 1 つのコマンドに
対してカラー表示を有効にするため、<B>ls-F</B>
または <B>ls</B> のみに設定することができます。
何に対しても設定しない場合は、<B>(ls-F ls)</B> に対して
設定したのと等価です。
<DT><B>colorcat</B>

<DD>
これが設定されている場合は、NLS メッセージファイルに対して
カラー用エスケープシーケンスを有効にします。これによって、
色のついた NLS メッセージが表示されます。
<DT><B>command </B>(+)

<DD>
これが設定されている場合、シェルに渡されたコマンドは、
<B>-c</B> フラグ (そちらも参照) をつけたものに
なります。
<DT><B>complete </B>(+)

<DD>
これが `enhance' に設定されている場合、補完は、
1) 大文字小文字を無視し、2) ピリオド、ハイフン、および
アンダスコア (`.', `-', `_') を単語の区切り文字と
みなし、ハイフンとアンダスコアを等価なものとみなします。
<DT><B>continue </B>(+)

<DD>
コマンドリストに対してこれが設定されている場合、シェルは
リストされているコマンドを継続実行し、新たにコマンドを
開始しません。
<DT><B>continue_args </B>(+)

<DD>
continue と同じですが、シェルは次のコマンドを実行します:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
echo `pwd` $argv &gt; ~/.&lt;cmd&gt;_pause; %&lt;cmd&gt;
</DL>
</DL>

<DT><B>correct </B>(+)

<DD>
`cmd' に設定されている場合、コマンドは自動的にスペル訂正されます。
`complete' に設定されている場合、コマンドは自動的に補完されます。
`all' に設定されている場合、コマンドライン全体が訂正されます。
<DT><B>cwd</B>

<DD>
カレントディレクトリのフルパス名です。
シェル変数 <B>dirstack</B> および <B>owd</B> も参照してください。
<DT><B>dextract </B>(+)

<DD>
これが設定されている場合、`pushd +<I>n</I>' はディレクトリを先頭に
持っていくのではなく、ディレクトリスタックから <I>n</I> 番目の
ディレクトリを取り出します。
<DT><B>dirsfile </B>(+)

<DD>
`dirs -S' および `dirs -L' がヒストリファイルを探すデフォルトの
場所です。設定していない場合は、<I>~/.cshdirs</I> が使われます。
通常、<I>~/.tcshrc</I> の方が <I>~/.cshdirs</I> よりも先に
ソースとして使われるため、<B>dirsfile</B> は、<I>~/.login</I> ではなく
<I>~/.tcshrc</I> 中で設定すべきです。
<DT><B>dirstack </B>(+)

<DD>
ディレクトリスタック上の全ディレクトリの配列です。
`$dirstack[1]' はカレントディレクトリであり、`$dirstack[2]' は
スタック上の最初のディレクトリといった具合です。
カレントディレクトリは `$dirstack[1]' ですが、
ディレクトリスタックの置換では `=0' であるなどということに
注意してください。<B>dirstack</B> を設定することでスタックを
任意に変更することができますが、最初の要素 (カレント
ディレクトリ) は常に正しいものになります。
シェル変数 <B>cwd</B> および <B>owd</B> も参照してください。
<DT><B>dspmbyte </B>(+)

<DD>
`euc' に設定されている場合、EUC-kanji(Japanese) コードで
表示および編集ができるようになります。
`sjis' に設定されている場合、Shift-JIS(Japanese) コードで
表示および編集ができるようになります。
`big5' に設定されている場合、Big5(Chinese) コードで
表示および編集ができるようになります。
次のようなフォーマットに設定されている場合、
独自のマルチバイトコードフォーマットで
表示および編集ができるようになります:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
&gt; set dspmbyte = 0000....(256 bytes)....0000
</DL>
<P>

テーブルには<B>ちょうど</B> 256 バイト必要です。
256 文字それぞれは、ASCII コード 0x00, 0x01, ... 0xff に
(左から右に向かって) 対応しています。
各キャラクタは、

数値 0, 1, 2, 3 に設定されます。各数字には次のような意味があります:
<BR>

<BR>&nbsp;&nbsp;0&nbsp;...&nbsp;マルチバイト文字に対しては使われません。
<BR>

<BR>&nbsp;&nbsp;1&nbsp;...&nbsp;マルチバイト文字の最初の&nbsp;1&nbsp;バイトに対して使われます。
<BR>

<BR>&nbsp;&nbsp;2&nbsp;...&nbsp;マルチバイト文字の&nbsp;2&nbsp;バイト目に対して使われます。
<BR>

<BR>&nbsp;&nbsp;3&nbsp;...&nbsp;マルチバイト文字の&nbsp;1,&nbsp;2&nbsp;バイト両方に対して使われます。
















<P>

<BR>&nbsp;&nbsp;使用例:
<BR>

`001322' に設定した場合、最初の文字 (すなわち、ASCII コードで 0x00)
と 2 番目の文字 (すなわち、ASCII コードで 0x01) は `0' に設定されます。
つまり、マルチバイト文字に対してはこれらの文字は使用しません。
3 番目の文字 (0x02) は `2' に設定されます。これは、マルチバイト文字の
最初の 1 バイトにこの文字が使用されることを表しています。
4 番目の文字 (0x03) は `3' に設定されます。この文字は、
マルチバイト文字の 1 バイト目にも 2 バイト目にも使用されます。
5 番目および 6 番目の文字 (0x04, 0x05) は `2' に設定されます。
これは、これらの文字がマルチバイト文字の 2 バイト目に使用されることを
表しています。
<P>

GNU fileutils バージョンの ls では、-N ( --literal ) オプションが
ついていないとマルチバイト文字のファイル名を表示できません。
もし、fileutils バージョンを使っている場合は、dspmbyte の
2 番目の文字を &quot;ls&quot; に設定してください。そうしないと、
たとえば &quot;ls-F -l&quot; でマルチバイト文字のファイル名が表示できません。
</DL>

<DT><B>dunique </B>(+)

<DD>
これが設定されている場合、<I>pushd</I> は、ディレクトリ名を
スタックに置く前に <I>name</I> である任意の要素をスタックから削除します。
<DT><B>echo</B>

<DD>
これが設定されている場合、各コマンドは、実行される直前に
引数と一緒にエコーされます。組み込みコマンド以外のコマンドについては、
展開がすべて行われた後にエコーされます。組み込みコマンドについては、
コマンドおよびファイル名の置換が行われるよりも前にエコーされます。
これは、置換がユーザの選択によって行われるものだからです。
このシェル変数は、コマンドラインオプション <B>-x</B> で設定されます。
<DT><B>echo_style </B>(+)

<DD>
echo 組み込みコマンドのスタイルです。次のように設定できます。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>bsd<DD>
第 1 引数が `-n' である場合、改行をエコーしません。
<DT>sysv<DD>
echo 中の文字列のバックスラッシュで始まるエスケープシーケンスを
認識します。
<DT>both<DD>
`-n' フラグとバックスラッシュで始まるエスケープシーケンスの
両方ともを認識します。これがデフォルトです。
<DT>none<DD>
どちらも認識しません。

</DL>
<P>

デフォルトでは、ローカルシステムのデフォルトに設定されます。
BSD ならびに System V オプションは、適当なシステムの
<I><A HREF="../../0MultiFileIdx/man1/echo.1.html">echo</A></I>(1) マニュアルページに解説があります。
</DL>

<DL COMPACT>
<DT><B>edit </B>(+)

<DD>
これが設定されている場合、コマンドラインエディタが使われます。
対話型シェルではデフォルトで設定されています。
<DT><B>ellipsis </B>(+)

<DD>
これが設定されている場合、`%c'/`%.' および `%C' プロンプトシーケンス
(<B>prompt</B> シェル変数を参照) は、`/&lt;skipped&gt;' の代わりに
省略記号 (`...') つきのスキップディレクトリを示すようになります。
<DT><B>fignore </B>(+)

<DD>
補完する際に無視されるファイル名のサフィックスリストです。
<DT><B>filec</B>

<DD>
<I>tcsh</I> では補完は常に行われますので、この変数は無視されます。
<I>csh</I> で設定されている場合は、ファイル名の補完が使われる
ようになります。
<DT><B>gid </B>(+)

<DD>
ユーザの実グループ ID です。
<DT><B>group </B>(+)

<DD>
ユーザのグループ名です。
<DT><B>histchars</B>

<DD>
<B>ヒストリ置換</B> (そちらも参照) で使われる文字を
決定する文字列です。この値の最初の文字は、デフォルトの `!' の
代わりにヒストリ置換文字として使われます。2 番目の文字は、
クイック置換の際の文字 `^' の代わりをします。
<DT><B>histdup </B>(+)

<DD>
ヒストリリスト中の重複エントリの扱いを制御します。
この値が `all' に設定されている場合、単一のヒストリイベントが
ヒストリリストに入力されます。`prev' に設定されている場合、
最後のヒストリイベントは現在のコマンドと同じとなり、そのため、
現在のコマンドはヒストリには入力されません。`erase' に設定されて
いる場合、ヒストリリスト中に同じイベントが見つかったときには、
古い方のイベントは消去され、現在のものが挿入されます。
`prev' および `all' オプションはヒストリイベントの番号づけを
やり直しますので、すき間はあかないのだということに注意してください。
<DT><B>histfile </B>(+)

<DD>
`history -S' および `history -L' が探すヒストリファイルの
デフォルトの場所です。これが設定されていない場合、<I>~/.history</I> が
使われます。別々のマシン間で同じホームディレクトリを共有していたり、
端末ごとにヒストリを分けて保存していたりする場合、<B>histfile</B> は
便利なものです。通常、<I>~/.history</I> ファイルよりも前に読み込まれる
のは <I>~/.tcshrc</I> だけなので、<B>histfile</B> は<I>~/.login</I>
ではなく、<I>~/.tcshrc</I> で設定してください。
<DT><B>histlit </B>(+)

<DD>
これが設定されている場合、組み込みコマンド、編集コマンド
および <B>savehist</B> 機構はヒストリリスト中のコマンド行を
文字通りの (展開しない) 形式で使用します。<I>toggle-literal-history</I>
編集コマンドも参照してください。
<DT><B>history</B>

<DD>
最初の単語は、記録しておくべきヒストリイベント数を表します。
オプションである 2 番目の単語 (+) は、ヒストリが
どういう形式で表示されるかを示しています。
これが与えられていなければ、 `%h\t%T\t%R\n' が使われます。
フォーマットシーケンスは、<B>prompt</B> 下に記述されており、
そこでは、`%R' の意味が変わることの注意がされています。
デフォルトでは `100' です。
<DT><B>home</B>

<DD>
起動したユーザのホームディレクトリに初期化されます。
ファイル名での `<I>~</I> の展開には、この変数が参照されています。
<DT><B>ignoreeof</B>

<DD>
これが空文字列あるいは `0' に設定されており、
入力デバイスが端末である場合には、
<I>end-of-file</I> コマンド (通常は、ユーザが空行に `~D' を打つことで
生成されます) を入力すると、シェルは終了してしまう代わりに
`Use &quot;exit&quot; to leave tcsh.' と表示します。
これによって、シェルがうっかり kill されてしまうのを防ぐことができます。
番号 <I>n</I> を設定している場合には、
シェルは <I>n</I> - 1 回連続した <I>end-of-file</I> を無視し、
<I>n</I> 回目の <I>end-of-file</I> があればそのときに終了します。(+)
これが設定されていない場合には、`1' が使われます。
つまり、シェルは `^D' 1 回で終了します。
<DT><B>implicitcd </B>(+)

<DD>
これが設定されている場合、シェルは、コマンドとして入力された
ディレクトリ名を、あたかもそのディレクトリへ移動する要求であるものと
解釈します。<I>verbose</I> に設定されている場合、ディレクトリの移動が
行われることが標準出力にエコーされるようになります。
この振る舞いは、非対話的なシェルスクリプト、あるいは
2 語以上あるコマンド行では禁止されています。
ディレクトリを移動するのは、ディレクトリ名のような名前を持ったコマンドを
実行するよりも優先されますが、エイリアスの置換よりは後になります。
チルダおよび変数の展開も動作します。
<DT><B>inputmode </B>(+)

<DD>
`insert' あるいは `overwrite' に設定されている場合、
各行の先頭でエディタが入力モードに入るようになります。
<DT><B>killdup </B>(+)

<DD>
キルリング中の重複エントリの扱いを制御します。
`all' にセットすると、一意なエントリのみがキルリングに登録されます。
`prev' にセットすると、
最後にキルされた文字列が現在のキル文字列にマッチする場合、
現在の文字列はリングに登録されません。
`erase' にセットすると、同じ文字列がキルリング中に見付かった場合、
古い文字列が削除されて現在の文字列が挿入されます。
<DT><B>killring </B>(+)

<DD>
何個のキルされた字列をメモリ中に保持するかを示します。
デフォルトで `30' にセットされます。
セットしないか、`2' より小さい値を設定すると、
最近キルした文字列のみをシェルは保持します。
<DT><B>listflags </B>(+)

<DD>
`x', `a', `A' あるいはこれらの組合せ (たとえば、`xA') に設定されている場合、
これらの値は、<I>ls-F</I> へのフラグとして使われ、`ls -xF',
`ls -Fa', `ls -FA' あるいはこれらの組合せ (たとえば、`ls -FxA')
のように振る舞うようになります。
`a' はすべてのファイルを表示します (たとえ、`.' で始まるファイルで
あっても)。`A' は `.' および `..' 以外のファイルすべてを表示し、
`x' は上から下に向かってではなく、左から右に向かってソートします。
<B>listflags</B> に 2 番目の単語が設定されていれば、
それは `<A HREF="../../0MultiFileIdx/man1/ls.1.html">ls</A>(1)' へのパスとして使われます。
<DT><B>listjobs </B>(+)

<DD>
これが設定されていれば、ジョブが一時停止したときにすべての
ジョブがリストされます。`long' に設定されていれば、
リストは長い形式のものになります。
<DT><B>listlinks </B>(+)

<DD>
これが設定されていれば、組み込みコマンド <I>ls-F</I> は
各シンボリックリンクが指しているファイルの種類を表示します。
<DT><B>listmax </B>(+)

<DD>
<I>list-choices</I> 編集コマンドがユーザに最初に尋ねてこないで
リストする最大要素数です。
<DT><B>listmaxrows </B>(+)

<DD>
<I>list-choices</I> 編集コマンドがユーザに最初に尋ねてこないで
リストする要素の最大行数です。
<DT><B>loginsh </B>(+)

<DD>
シェルがログインシェルである場合に設定されます。
シェル中でこの変数を設定したり設定を解除したりしても
何の効力もありません。<B>shlvl</B> も参照してください。
<DT><B>logout </B>(+)

<DD>
通常のログアウトの前には、シェルによって `normal' が、
自動ログアウトの前には `automatic' が、そして、
シェルがハングアップシグナルによって終了させられた場合
(<B>シグナルの扱い</B>を参照) には `hangup' が設定されます。
<B>autologout</B> シェル変数も参照してください。
<DT><B>mail</B>

<DD>
届けられるメールをチェックするためのファイルあるいは
ディレクトリ名です。これは、スペースで区切られ、
オプションで数字を前につけます。
プロンプトを出す前に、最後にメールチェックをしてから
10 分経っていた場合、シェルは各ファイルをチェックし、
もしファイルサイズが 0 より大きいか、あるいはアクセス時刻よりも
変更時刻の方が大きかった場合には `You have new mail.'
(あるいは、<B>mail</B> に複数のファイルが含まれていた場合、
`You have new mail in <I>name</I>.') と表示します。
</DL>
<P>

<DL COMPACT><DT><DD>

<P>

ログインシェルにいる場合には、シェルの起動時刻後にファイルが
変更されない限り、どのメールファイルも報告されません。
これは、余計に通知しないようにするためです。
大部分の login プログラムでは、ログイン時にメールが届いているかどうかを
教えてくれるものです。
<P>

<B>mail</B> で指定されたファイルがディレクトリである場合、
シェルは、ディレクトリ中の各ファイルを別々のメッセージとして計算し、
`You have <I>n</I> mails.' とか `You have <I>n</I> mails in <I>name</I>.'
とかと適切に報告します。この機能は、主に Andrew Mail System のように、
メールをこの方式で保存するシステム用に提供されたものです。
<P>

<B>mail</B> の最初の単語が数値である場合、それはメールチェックの
間隔を変えるものとして受け取られます。秒単位です。
<P>

とても稀な状況下ですが、シェルが `You have new mail.' ではなく
`You have mail.' と報告することがあります。
</DL>

<DL COMPACT>
<DT><B>matchbeep </B>(+)

<DD>
これが `never' に設定されている場合、補完が行われてもビープ音は
鳴りません。
`nomatch' に設定されている場合、マッチするものがないときにのみ
ビープ音が鳴ります。
`ambiguous' に設定されている場合、マッチするものが複数あるときに
ビープ音が鳴ります。
`notunique' に設定されている場合、完全にマッチするものが 1 つあり、
また、それとは別にもっと長くマッチするものがあったときにビープ音が
鳴ります。
これが設定されていない場合、`ambiguous' が使われます。
<DT><B>nobeep </B>(+)

<DD>
これが設定されている場合、ビープ音は完全に無効になります。
<B>visiblebell</B> も参照してください。
<DT><B>noclobber</B>

<DD>
これが設定されている場合、出力リダイレクションに制限がおかれるようになり、
<B>入出力</B>セクションで述べているように、
ファイルをうっかり壊さないように、また、`&gt;&gt;' リダイレクションが存在する
ファイルを指すように保証できます。
<DT><B>noding</B>

<DD>
<B>prompt</B> の時刻指定子において、時間の変わり目に `DING!' と
表示するのを無効にします。
<DT><B>noglob</B>

<DD>
これが設定されている場合、<B>ファイル名置換</B>および、
<B>ディレクトリスタック置換</B> (そちらも参照) が
禁止されます。この機能は、ファイル名を扱わないシェルスクリプトや、
ファイル名のリストを取得した後、さらに展開をされたくない
スクリプトには最も有効なものです。
<DT><B>nokanji </B>(+)

<DD>
これが設定されており、シェルが漢字をサポートしている場合
(シェル変数 <B>version</B> を参照)、漢字のサポートを無効にし、
メタキーが使えるようにします。
<DT><B>nonomatch</B>

<DD>
これが設定されている場合、<B>ファイル名置換</B>および
<B>ディレクトリスタック置換</B> (そちらも参照) の際に、
存在するファイルにマッチしなかったときに、エラーを出さずに
そのまま放置するようになります。置換が機能しないときには
相変わらずエラーになります。
たとえば、`echo [' は相変わらずエラーとなります。
<DT><B>nostat </B>(+)

<DD>
補完処理が行われている間に <I><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></I>(2) をかけるべきではない
ディレクトリのリスト (あるいは、ディレクトリにマッチする
グロブパターンです。<B>ファイル名置換</B>を参照) です。
この機能は、<I><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></I>(2) を実行するととてつもない時間が
かかってしまうようなディレクトリ、
たとえば <I>/afs</I> などを除外するのに通常使われます。
<DT><B>notify</B>

<DD>
これが設定されている場合、シェルはジョブが完了したことを非同期に
通知します。デフォルトは、プロンプトが表示される直前に
ジョブの完了を提示します。
<DT><B>oid </B>(+)

<DD>
ユーザの実組織 ID です (Domain/OS のみです)。
<DT><B>owd </B>(+)

<DD>
前の作業ディレクトリで、<I>cd</I> が使う `-' および
<I>pushd</I> と等価です。
<B>cwd</B> および <B>dirstack</B> シェル変数も参照してください。
<DT><B>path</B>

<DD>
実行可能なコマンドを探すディレクトリのリストです。
null 文字はカレントディレクトリを示します。
<B>path</B> 変数がない場合、フルパス名での指定のみ実行されます。
<B>path</B> は、起動時にシェルが環境変数 <B>PATH</B> から設定するか、
あるいは <B>PATH</B> が存在しなかった場合には、システム依存の
デフォルト、たとえば
`(/usr/local/bin /usr/bsd /bin /usr/bin .)' のようなものに
設定します。
シェルは、`.' を <B>path</B> の先頭あるいは末尾に置くことができ、
また、コンパイルの仕方に依存しますが、 `.' を完全に省いてしまうことも
できます。<B>-c</B>, <B>-t</B> オプションのどちらも与えられていない
シェルは、<I>~/.tcshrc</I> を読み込んだ後および <B>path</B> が
リセットされるたびにディレクトリの中身をハッシュに格納します。
シェルがアクティブである間に、ユーザが <B>path</B> 中の
ディレクトリに新しいコマンドを追加した場合、
シェルがそのコマンドを見つけられるように
<I>rehash</I> を実行する必要があるかもしれません。
<DT><B>printexitvalue </B>(+)

<DD>
これが設定されており、対話型のプログラムが 0 以外のステータスで
終了した場合、シェルは `Exit <B>status</B>' と表示します。
<DT><B>prompt</B>

<DD>
端末からコマンドを読み込む前に表示される文字列です。
<B>prompt</B> には、次のフォーマット列 (+) のどれを含んでも構いません。
このフォーマット列は、与えられた情報で書き換えられます。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>%/<DD>
カレント作業ディレクトリです。
<DT>%~<DD>
カレント作業ディレクトリですが、`~' で表現される
ユーザのホームディレクトリおよび `~user' で表現される
他のユーザのホームディレクトリを
<B>ファイル名置換</B>します。
`~user' の置換は、現在のセッションにおいて、
シェルがパス名に `~<I>user</I>' を使っている場合にのみ起こります。
<DT>%c[[0]<I>n</I>], %.[[0]<I>n</I>]<DD>
現在の作業ディレクトリの、末尾の要素です。
数字 <I>n</I> が指定されている場合、末尾の <I>n</I> 個の要素です。
<I>n</I> が `0' で開始する場合、スキップされた要素数が
末尾要素の前に付き、次の書式となります
`/&lt;<I>スキップされた数</I>&gt;末尾要素'。
シェル変数 <B>ellipsis</B> が設定されている場合、
スキップされた要素は省略記号で置換されますので、
全体的には `...末尾要素' となります。
`~' 置換は、前述の `%~' と同様に行われますが、
`~' 要素は、末尾要素数を数える対象からは除外されます。
<DT>%C<DD>
%c に似ていますが、`~' の置換を行いません。
<DT>%h, %!, !<DD>
現在のヒストリイベント番号です。
<DT>%M<DD>
完全なホスト名です。
<DT>%m<DD>
最初の `.' までのホスト名です。
<DT>%S (%s)<DD>
強調表示モードを開始 (終了) します。
<DT>%B (%b)<DD>
ボールド体表示モードを開始 (終了) します。
<DT>%U (%u)<DD>
アンダラインモードを開始 (終了) します。
<DT>%t, %@<DD>
AM/PM の 12 時間表記での時刻です。
<DT>%T<DD>
`%t' に似ていますが、こちらは 24 時間表記です
(ただし、シェル変数 <B>ampm</B> も参照)。
<DT>%p<DD>
秒まで含めた、AM/PM の 12 時間表記での `正確な' 時刻です。
<DT>%P<DD>
`%p' に似ていますが、こちらは 24 時間表記です
(ただし、シェル変数 <B>ampm</B> も参照)。
<DT>\<I>c</I><DD>
<I>c</I> は <I>bindkey</I> 中にあるものとしてパースされます。
<DT>^<I>c</I><DD>
<I>c</I> は <I>bindkey</I> 中にあるものとしてパースされます。
<DT>%%<DD>
`%' 1 つです。
<DT>%n<DD>
ユーザ名です。
<DT>%d<DD>
`Day' 形式の曜日。
<DT>%D<DD>
`dd' 形式の日にち。
<DT>%w<DD>
`Mon' 形式の月。
<DT>%W<DD>
`mm' 形式の月。
<DT>%y<DD>
`yy' 形式の年。
<DT>%Y<DD>
`yyyy' 形式の年。
<DT>%l<DD>
シェルの tty。
<DT>%L<DD>
プロンプトの終わりから、
ディスプレイの終わりまたは行末までクリアします。
<DT>%$<DD>
`$' の直後のシェル変数または環境変数を展開します。
<DT>%#<DD>
普通のユーザは `&gt;' (または <B>promptchars</B> シェル変数の最初の文字)、
スーパーユーザは `#' (または <B>promptchars</B> の 2 番目の文字)。
<DT>%{<I>string</I>%}<DD>
<I>string</I> を文字通りのエスケープシーケンスとして取り込みます。
これは端末属性を変更するためにのみ使うべきで、
カーソル位置の移動をこれで行ってはいけません。
これは <B>prompt</B> の最後のシーケンスであってはいけません。
<DT>%?<DD>
プロンプトの直前で実行されたコマンドの戻り値。
<DT>%R<DD>
<B>prompt2</B> の中ではパーザの状態。
<B>prompt3</B> の中では修正された文字列。
<B>history</B> の中では履歴文字列。

</DL>
<P>

`%B', `%S', `%U', `%{<I>string</I>%}' は、
8bit クリーンなシェルでのみ利用できます。
<B>version</B> シェル変数を参照してください。
<P>

ボールド、スタンドアウト、下線といったシーケンスは、
スーパーユーザのシェルを区別するために使われることが多いです。
たとえば、
<DL COMPACT>
<DT><DD>
&gt; set prompt = &quot;%m [%h] %B[%@]%b [%/] you rang? &quot;
<BR>

tut [37] <B>[2:54pm]</B> [/usr/accts/sys] you rang? _
</DL>
<P>

`%t', `%@', `%T', `%p', `%P' のどれかが使われていて、
かつ <B>noding</B> が設定されていなければ、
毎正時 (`:00' 分) には実際の時刻の代わりに `DING!' を表示します。
<P>

対話的シェルでのデフォルトは `%# ' です。
</DL>

<DL COMPACT>
<DT><B>prompt2 </B>(+)

<DD>
<I>while</I> ループや <I>foreach</I> ループの中で、
また `\' で終った行の次の行で、
プロンプトとして用いられる文字列。
<B>prompt</B> (そちらも参照) と同じ
フォーマットシーケンスが使えます。
`%R' の意味が変わることに注意してください。
対話的シェルでのデフォルトは `%R?' です。
<DT><B>prompt3 </B>(+)

<DD>
自動スペル訂正の確定時のプロンプト文字列。
<B>prompt</B> (そちらも参照) と同じ
フォーマットシーケンスが使えます。
`%R' の意味が変わることに注意してください。
対話的シェルでのデフォルトは `CORRECT&gt;%R (y|n|e|a)?' です。
<DT><B>promptchars </B>(+)

<DD>
(2 文字の文字列に) 設定すると、<B>prompt</B> シェル変数中の
`%#' フォーマットシーケンスが、普通のユーザでは最初の文字で、
スーパーユーザでは 2 番目の文字で置き換えられます。
<DT><B>pushdtohome </B>(+)

<DD>
設定すると、引数をとらない <I>pushd</I> は、
<I>cd</I> のように `pushd ~' を実行します。
<DT><B>pushdsilent </B>(+)

<DD>
設定すると、<I>pushd</I> と <I>popd</I> の際に
ディレクトリスタックが表示されなくなります。
<DT><B>recexact </B>(+)

<DD>
設定すると、補完の際に正確なマッチがあれば、
より長いマッチが可能な場合でも、正確なほうに補完します。
<DT><B>recognize_only_executables </B>(+)

<DD>
設定すると、コマンドリストは
パス中にある実行可能なファイルのみを表示します。遅いです。
<DT><B>rmstar </B>(+)

<DD>
設定すると、ユーザは `rm *' を実行する前に確認を受けます。
<DT><B>rprompt </B>(+)

<DD>
(コマンド入力後) prompt が左に表示される際に、
スクリーンの右側 (コマンド入力の後ろ側) に表示される文字列。
prompt と同じフォーマット文字列が使えます。
この文字列は、コマンド入力を邪魔しないように自動的に隠れたり、
また再度現れたりします。
(左側の) プロンプト、コマンド入力、この文字列が
最初の 1 行に収まる場合に限り、この文字列は表示されます。
<B>edit</B> が設定されていなければ、
<B>rprompt</B> はプロンプトの後、コマンド入力の前に表示されます。
<DT><B>savedirs </B>(+)

<DD>
設定すると、シェルは終了する前に `dirs -S' を行います。
最初の単語を数字に設定すると、
その個数までディレクトリスタックのエントリを保存します。
<DT><B>savehist</B>

<DD>
設定すると、シェルは終了する前に `history -S' を行います。
最初の単語を数字に設定すると、その個数までの行が保存されます。
(個数は <B>history</B> 以下でなければなりません。)
2 番目の単語を `merge' にすると、
履歴ファイルが存在する場合に、置換ではなく追加を行います。
そしてタイムスタンプによってソートを行い、
最近のイベントを残します。(+)
<DT><B>sched </B>(+)

<DD>
<I>sched</I> 組み込みコマンドがスケジュールイベントを表示する書式。
特に指定しなければ `%h\t%T\t%R\n' が使われます。
フォーマットシーケンスは上記の <B>prompt</B> 以下に書いてあります。
`%R' の意味が変わることに注意してください。
<DT><B>shell</B>

<DD>
シェルのファイル。これはシェルをフォークして、
実行ビットが設定されているがシステムによる実行が不可能なファイルを
実行するために用いられます
(<B>組み込みコマンド、非組み込みコマンドの実行</B>を参照)。
初期値は、(システム依存の) シェルの置き場所です。
<DT><B>shlvl </B>(+)

<DD>
入れ子になったシェルの数。ログインシェルでは 1 にリセットされます。
<B>loginsh</B> も参照してください。
<DT><B>status</B>

<DD>
最後のコマンドによって返された状態。
コマンドが異常終了した場合には 0200 が加えられます。
組み込みコマンドは、失敗すると終了状態 `1' を返します。
その他の場合は、すべての組み込みコマンドは状態 `0' を返します。
<DT><B>symlinks </B>(+)

<DD>
いくつか異なった値に設定でき、
シンボリックリンク (`symlink') の解決を制御できます。
<DL COMPACT><DT><DD>
<P>

`chase' に設定すると、
カレントディレクトリがシンボリックリンクを含むディレクトリになったら、
リンクをそれが指しているディレクトリの実名に展開します。
この機能はユーザのホームディレクトリでは働きません。これはバグです。
<P>

`ignore' にすると、
このシェルはリンクを通ってカレントディレクトリを移動する場合、
移動先のディレクトリを現在のディレクトリに対する
相対位置として構築しようとします。
これはすなわち、シンボリックリンクを通して cd を行い、
続いて `cd ..' を行うと、
元のディレクトリに戻る、ということを意味します。
これは組み込みコマンドとファイル名補完にのみ影響します。
<P>

`expand' に設定すると、シェルはパス名のように見える引き数を
実際に展開して、シンボリックリンクを元に戻そうとします。
これは組み込みコマンドのみならず、すべてのコマンドに影響します。
残念ながら、これは認識しにくいファイル名
(たとえばコマンドオプションに埋めこまれたものなど) には動作しません。
クォートすれば展開は行われません。
たいていの場合はこの設定が便利ですが、
展開すべき引き数を認識できないと、誤解や混乱の元になるかもしれません。
妥協案として、 `ignore' にしておいて、
必要な場合には編集コマンド <I>normalize-path</I>
(デフォルトでは ^X-n にバインドされています)
を使うのがいいかもしれません。
<P>

順にいくつか例を示します。
まずは遊び場となるディレクトリを準備しましょう。
<DL COMPACT>
<DT><DD>
&gt; cd /tmp
<BR>

&gt; mkdir from from/src to
<BR>

&gt; ln -s from/src to/dst
</DL>
<P>

<B>symlinks</B> が設定されていない場合の動作:
<DL COMPACT>
<DT><DD>
&gt; cd /tmp/to/dst; echo $cwd
<BR>

/tmp/to/dst
<BR>

&gt; cd ..; echo $cwd
<BR>

/tmp/from
</DL>
<P>

<B>symlinks</B> が `chase' に設定されている場合の動作:
<DL COMPACT>
<DT><DD>
&gt; cd /tmp/to/dst; echo $cwd
<BR>

/tmp/from/src
<BR>

&gt; cd ..; echo $cwd
<BR>

/tmp/from
</DL>
<P>

<B>symlinks</B> が `ignore' に設定されている場合の動作:
<DL COMPACT>
<DT><DD>
&gt; cd /tmp/to/dst; echo $cwd
<BR>

/tmp/to/dst
<BR>

&gt; cd ..; echo $cwd
<BR>

/tmp/to
</DL>
<P>

<B>symlinks</B> が `expand' に設定されている場合の動作:
<DL COMPACT>
<DT><DD>
&gt; cd /tmp/to/dst; echo $cwd
<BR>

/tmp/to/dst
<BR>

&gt; cd ..; echo $cwd
<BR>

/tmp/to
<BR>

&gt; cd /tmp/to/dst; echo $cwd
<BR>

/tmp/to/dst
<BR>

&gt; cd &quot;..&quot;; echo $cwd
<BR>

/tmp/from
<BR>

&gt; /bin/echo ..
<BR>

/tmp/to
<BR>

&gt; /bin/echo &quot;..&quot;
<BR>

..
</DL>
<P>

いくつか注意しますと、`expand' による展開は、
1) <I>cd</I> のような組み込みコマンドに対しては `ignore' のように働きます。
2) クォートすれば行われません。
3) 非組み込みコマンドの場合は、ファイル名を渡す前に行われます。
</DL>

<DT><B>tcsh </B>(+)

<DD>
`R.VV.PP' 形式のシェルのバージョン番号です。
`R' はメジャーリリース番号、
`VV' はカレントバージョン、
`PP' はパッチレベルです。
<DT><B>term</B>

<DD>
端末の種類。
<B>スタートアップとシャットダウン</B>
で述べているように、通常は <I>~/.login</I> で設定されます。
<DT><B>time</B>

<DD>
数値を設定すると、それ以上の CPU 時間 (秒)
を消費したコマンドの実行後に、
自動的に組み込みコマンド <I>time</I> (そちらも参照)
を実行します。2 番目の単語があれば、
<I>time</I> 組み込みコマンドの出力フォーマット文字列として
使われます。
(u) 以下のシーケンスがフォーマット文字列で使えます。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>%U<DD>
プロセスがユーザモードで消費した CPU 時間 (秒)。
<DT>%S<DD>
プロセスがカーネルモードで消費した CPU 時間 (秒)。
<DT>%E<DD>
(壁時計での) 経過時間 (秒)。
<DT>%P<DD>
(%U + %S) / %E として計算される CPU 使用率。
<DT>%W<DD>
プロセスがスワップされた回数。
<DT>%X<DD>
(共有) テキスト空間の平均使用量。 Kbyte 単位。
<DT>%D<DD>
(非共有) データ/スタック空間の平均使用量。 Kbyte 単位。
<DT>%K<DD>
(%X + %D) の総使用量。 Kbyte 単位。
<DT>%M<DD>
プロセスが使用したメモリの瞬間最大値。 Kbyte 単位。
<DT>%F<DD>
メジャーページフォールトの回数
(ディスクから取って来る必要があったページ数)。
<DT>%R<DD>
マイナーページフォールトの回数。
<DT>%I<DD>
入力操作の回数。
<DT>%O<DD>
出力操作の回数。
<DT>%r<DD>
ソケットメッセージを受け取った回数。
<DT>%s<DD>
ソケットメッセージを送った回数。
<DT>%k<DD>
シグナルを受け取った回数。
<DT>%w<DD>
自発的なコンテキストスイッチの回数 (wait の回数)。
<DT>%c<DD>
非自発的なコンテキストスイッチの回数。

</DL>
<P>

BSD 資源制限機能の無いシステムでは、
最初の 4 つのシーケンスだけがサポートされています。
デフォルトの時間フォーマットは、
資源使用報告をサポートしているシステムでは
`%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww' で、
そうでないシステムでは `%Uu %Ss %E %P' です。
<P>

Sequent の DYNIX/ptx では、 %X, %D, %K, %r, %s が使えませんが、
以下の追加シーケンスが利用できます。
<P>


<DL COMPACT>
<DT>%Y<DD>
システムコールが実行された回数。
<DT>%Z<DD>
要求に応じてゼロで埋められたページ数。
<DT>%i<DD>
プロセスの常駐サイズがカーネルによって増加させられた回数。
<DT>%d<DD>
プロセスの常駐サイズがカーネルによって減少させられた回数。
<DT>%l<DD>
read システムコールが実行された回数。
<DT>%m<DD>
write システムコールが実行された回数。
<DT>%p<DD>
raw ディスク装置から読み込んだ回数。
<DT>%q<DD>
raw ディスク装置へ書き込んだ回数。

</DL>
<P>

デフォルトの時間フォーマットは `%Uu %Ss $E %P %I+%Oio %Fpf+%Ww' です。
マルチプロセッサでは CPU 使用率が 100% より高くなることがあります。
</DL>

<DL COMPACT>
<DT><B>tperiod </B>(+)

<DD>
特別なエイリアス <I>periodic</I> の実行される周期 (分単位)。
<DT><B>tty </B>(+)

<DD>
tty の名前。端末にアタッチされていない場合は空。
<DT><B>uid </B>(+)

<DD>
ユーザの実ユーザ ID。
<DT><B>user</B>

<DD>
ユーザのログイン名。
<DT><B>verbose</B>

<DD>
設定すると、ヒストリ置換後に、
各コマンドの単語を (あれば) 表示します。
コマンドラインオプション <B>-v</B> によって設定されます。
<DT><B>version </B>(+)

<DD>
バージョン ID スタンプ。
シェルのバージョン番号 (<B>tcsh</B> を参照) 、
配布元、リリース日、ベンダー、オペレーティングシステム、
マシン (<B>VENDOR</B>, <B>OSTYPE</B>, <B>MACHTYPE</B> を参照)、
コンパイル時に設定されたオプションをカンマで区切ったリストからなります。
ディストリビューションのデフォルトとして
セットされたオプションが記録されています。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>8b<DD>
シェルは 8bit クリーン。デフォルト。
<DT>7b<DD>
シェルは 8bit クリーンでない。
<DT>nls<DD>
システムの NLS を使う。 NLS のあるシステムではデフォルト。
<DT>lf<DD>
ログインシェルは <I>/etc/csh.cshrc</I> の後ではなく先に
<I>/etc/csh.login</I> を実行し、
<I>~/.tcshrc</I> と <I>~/.history</I>
の後ではなく先に <I>~/.login</I> を実行する。
<DT>dl<DD>
セキュリティ上の理由から `.' を <B>path</B> の最後に置く。デフォルト。
<DT>nd<DD>
セキュリティ上の理由から `.' を <B>path</B> に含めない。
<DT>vi<DD>
<I>emacs</I>-形式ではなく <I>vi</I>-形式の編集をデフォルトにする。
<DT>dtr<DD>
ログインシェルは終了時に DTR を落とす。
<DT>bye<DD>
<I>bye</I> を <I>logout</I> の同義語とし、
<I>log</I> を <I>watchlog</I> の別名として扱う。
<DT>al<DD>
<B>autologout</B> を有効にする。デフォルト。
<DT>kan<DD>
<B>nokanji</B> シェル変数が設定されない限り、
ロケール設定が適切であれば、漢字を使う。
<DT>sm<DD>
システムの <I><A HREF="../../LDP_man-pages/man3/malloc.3.html">malloc</A></I>(3) を使う。
<DT>hb<DD>
シェルスクリプトの実行時に
`#!&lt;program&gt; &lt;args&gt;' 方式をエミュレートする。
<DT>ng<DD>
<I>newgrp</I> 組み込みコマンドが利用可能。
<DT>rh<DD>
シェルは <B>REMOTEHOST</B> 環境変数を設定しようとする。
<DT>afs<DD>
シェルはもしローカルな認証が失敗したら、
kerberos サーバにパスワードを確認する。
<B>afsuser</B> シェル変数か <B>AFSUSER</B> 環境変数が
設定されていたら、その内容でローカルユーザ名を上書きする。

</DL>
<P>

システム管理者は、文字列を追加して
ローカルバージョンでの違いを示すようにできます。
</DL>

<DL COMPACT>
<DT><B>visiblebell </B>(+)

<DD>
設定すると、音声ベルの代わりに画面をフラッシュします。
<B>nobeep</B> も参照してください。
<DT><B>watch </B>(+)

<DD>
ログイン / ログアウトの監視対象とする、「ユーザ / 端末」ペアのリスト。
ユーザに対する端末が `any' なら、指定したユーザをすべての端末で監視します。
逆にユーザが `any' なら、指定した端末ですべてのユーザを監視します。
<B>watch</B> を `(any any)' に設定すると、
すべてのユーザと端末を監視します。
たとえば、
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><DD>
set watch = (george ttyd1 any console $user any)
</DL>
<P>

は、ユーザ `george' の ttyd1 での行動を、
そしてあらゆるユーザのコンソールでの行動を、
そして自分自身 (または不法侵入者) のすべての端末での行動を報告します。
<P>

デフォルトでは、ログインとログアウトは 10 分毎に調べられますが、
<B>watch</B> の最初の単語に、調べる間隔を分単位で書くこともできます。
たとえば、
<DL COMPACT>
<DT><DD>
set watch = (1 any any)
</DL>
<P>

は 1 分おきにあらゆるログイン / ログアウトを報告します。
我慢の効かない人は、<I>log</I> 組み込みコマンドを用いれば、
いつでも <B>watch</B> のレポートを見ることができます。
<B>watch</B> が最初に設定された時には、
現在ログインしているユーザリストが
(<I>log</I> 組み込みコマンドによって) 報告されます。
<P>

<B>watch</B> の報告形式は <B>who</B> シェル変数で制御します。
</DL>

<DT><B>who </B>(+)

<DD>
<B>watch</B> メッセージのフォーマット文字列。
以下のシーケンスが得られた情報で置換されます。
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>%n<DD>
ログイン / ログアウトしたユーザの名前。
<DT>%a<DD>
観察された行動: `logged on', `logged off',
`replaced <I>olduser</I> on' のいずれか。
<DT>%l<DD>
ユーザがログイン / ログアウトした端末 (tty)。
<DT>%M<DD>
リモートホストの完全なホスト名。
ローカルホストでのログイン / ログアウトの場合は `local'。
<DT>%m<DD>
リモートホストの、最初の `.' までのホスト名。
IP アドレスや X Window System ディスプレイの場合は名前全体。

</DL>
<P>

%M と %m は <I>/etc/utmp</I> にリモートホスト名を
格納するシステムでのみ利用できます。
設定しなければ `%n has %a %l from %m.' が用いられます。
ただしリモートホスト名を格納しないシステムでは
`%n has %a %l.' が用いられます。
</DL>

<DL COMPACT>
<DT><B>wordchars </B>(+)

<DD>
<I>forward-word</I>, <I>backward-word</I> 等の編集コマンドで、
単語の一部とみなされる非英数文字のリスト。
設定されなければ `*?_-.[]~=' が使われます。
</DL>
<A NAME="lbBQ">&nbsp;</A>
<H2>環境変数</H2>

<DL COMPACT>
<DT><B>AFSUSER </B>(+)

<DD>
<B>afsuser</B> シェル変数と同じです。
<DT><B>COLUMNS</B>

<DD>
端末の桁数です (<B>端末管理</B> を参照)。
<DT><B>DISPLAY</B>

<DD>
X Window System によって使われます (<I>X</I>(1) を参照)。
設定されると、このシェルは <B>autologout</B> (そちらも参照)
を設定しません。
<DT><B>EDITOR</B>

<DD>
デフォルトのエディタのパス名です。
<B>VISUAL</B> 環境変数と
<I>run-fg-editor</I> 編集コマンドも参照してください。
<DT><B>GROUP </B>(+)

<DD>
<B>group</B> シェル変数と同じです。
<DT><B>HOME</B>

<DD>
<B>home</B> シェル変数と同じです。
<DT><B>HOST </B>(+)

<DD>
シェルが実行されているマシンの名前で初期化されます。
これは <I><A HREF="../../LDP_man-pages/man2/gethostname.2.html">gethostname</A></I>(2) システムコールで決定されます。
<DT><B>HOSTTYPE </B>(+)

<DD>
シェルが実行されているマシンのタイプで初期化されます。
これはコンパイル時に決定されます。
この変数は廃止される予定であり、将来のバージョンで削除されるでしょう。
<DT><B>HPATH </B>(+)

<DD>
<I>run-help</I> 編集コマンドがコマンドの解説文書を探す
ディレクトリのリストです。区切り文字はコロンです。
<DT><B>LANG</B>

<DD>
優先的に使用される文字環境を与えます。
<B>固有言語システムのサポート</B>を参照してください。
<DT><B>LC_CTYPE</B>

<DD>
設定されていると、ctype キャラクタの扱いだけが変更されます。
<B>固有言語システムのサポート</B>を参照してください。
<DT><B>LINES</B>

<DD>
端末の行数です。
<B>端末管理</B>を参照してください。
<DT><B>LS_COLORS</B>

<DD>
この変数のフォーマットは <B><A HREF="../../LDP_man-pages/man5/termcap.5.html">termcap</A></B>(5) ファイルのフォーマットと
似ています。&quot;<I>xx=string</I>&quot; の形をした式をコロンで区切って並べた
リストです。&quot;<I>xx</I>&quot; は 2 文字の変数名です。
変数とそれらのデフォルト値は以下の通りです。
</DL>
<P>

<DL COMPACT><DT><DD>
<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>no      0<DD>
Normal (non-filename) text: ファイル名を除く通常のテキスト
<DT>fi      0<DD>
Regular file: 通常のファイル
<DT>di      01;34<DD>
Directory: ディレクトリ
<DT>ln      01;36<DD>
Symbolic link: シンボリックリンク
<DT>pi      33<DD>
Named pipe (FIFO): 名前付きパイプ
<DT>so      01;35<DD>
Socket: ソケット
<DT>bd      01;33<DD>
Block device: ブロック型デバイス
<DT>cd      01;32<DD>
Character device: キャラクタ型デバイス
<DT>ex      01;32<DD>
Executable file: 実行可能ファイル
<DT>mi      (none)<DD>
Missing file (defaults to fi): 行方不明のファイル
<DT>or      (none)<DD>
Orphaned symbolic link (defaults to ln): リンク先のないシンボリックリンク
<DT>lc      ^[[<DD>
Left code: 色指定シーケンス開始コード
<DT>rc      m<DD>
Right code: 色指定シーケンス終了コード
<DT>ec      (none)<DD>
End code (replaces lc+no+rc): 色出力を終えるシーケンス

</DL>
</DL>

<P>

デフォルトから変更したい変数だけを指定すれば OK です。
<P>

ファイルの名前を、ファイル名の拡張子をもとに色づけすることもできます。
これの指定は、<B>LS_COLORS</B> 変数に
<B>&quot;*ext=string&quot;</B> のシンタックスを用いて行います。
たとえば、ISO 6429 のコードを使いすべての C 言語のソースファイルを
ブルーに色づけするには <B>&quot;*.c=34&quot;</B> と指定すればよいでしょう。
これは <B>.c</B> で終わるすべてのファイルをブルー (34) に色づけします。
<P>

コントロールキャラクタは C スタイルのエスケープ表記か stty のような
^- 表記のどちらかで書くことができます。C スタイルの表記では
エスケープコードの記述に <B>^[</B>, スペースコードの記述に
<B>_</B>, デリートコードの記述に <B>?</B> を追加します。
さらに、<B>^[</B> エスケープキャラクタを用いると、
<B>^[</B>, <B>^</B>, <B>:</B>, <B>=</B> のデフォルトの解釈を
変更することができます。
<P>

それぞれのファイルは <B>&lt;lc&gt;</B> <B>&lt;color-code&gt;</B>
<B>&lt;rc&gt;</B> <B>&lt;filename&gt;</B> <B>&lt;ec&gt;</B> のように書かれます。
<B>&lt;ec&gt;</B> が未定義ならば、<B>&lt;lc&gt;</B> <B>&lt;no&gt; &lt;rc&gt;</B>
のシーケンスが代わりに使われます。
こちらの方が通常便利に使えますが、あまり一般的ではありません。
left, right, end のコードを用意した理由は、
同じシーケンスを繰り返し入力しなくてもいいように、また、
妙な端末に対応できるようにするためです。
通常は、ISO 6429 カラーシーケンスと異なるシステムを使っていない
限り、これらを変更する必要はほとんどありません。
<P>

端末が ISO 6429 color コードを使っていれば、(<B>lc</B>, <B>rc</B>,
<B>ec</B> コードを全く使わずに) セミコロンで区切られた数字のコマンドで
タイプコードを構成することができます。
良く用いられるコマンドは以下の通りです。
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>0<DD>
デフォルトの色に戻します。
<DT>1<DD>
高輝度色
<DT>4<DD>
アンダライン付きテキスト
<DT>5<DD>
点滅テキスト
<DT>30<DD>
前景色黒
<DT>31<DD>
前景色赤
<DT>32<DD>
前景色グリーン
<DT>33<DD>
前景色黄 (ブラウン)
<DT>34<DD>
前景色ブルー
<DT>35<DD>
前景色紫
<DT>36<DD>
前景色シアン
<DT>37<DD>
前景色白 (グレー)
<DT>40<DD>
背景色黒
<DT>41<DD>
背景色赤
<DT>42<DD>
背景色グリーン
<DT>43<DD>
背景色黄 (ブラウン)
<DT>44<DD>
背景色ブルー
<DT>45<DD>
背景色紫
<DT>46<DD>
背景色シアン
<DT>47<DD>
背景色白 (グレー)

</DL>
</DL>

<P>

すべてのコマンドがすべてのシステムや表示装置で
動作するわけではありません。
<P>

少なからぬ端末プログラムではデフォルトの終了コードを正しく
認識しません。ディレクトリのリストをした後ですべてのテキストに
色を付けるためには、<B>no</B> コードと <B>fi</B> コードを、
それぞれ 0 から前景色、背景色の数値コードへ変更してみてください。
</DL>

<DL COMPACT>
<DT><B>MACHTYPE </B>(+)

<DD>
コンパイル時に決定されたマシンタイプ (マイクロプロセッサまたは、
マシンモデル) です。
<DT><B>NOREBIND </B>(+)

<DD>
設定されていると、印刷可能文字は <I>self-insert-command</I> を
繰り返し実行されません。
<B>固有言語システムのサポート</B>を参照してください。
<DT><B>OSTYPE </B>(+)

<DD>
コンパイル時に決定されたオペレーションシステムです。
<DT><B>PATH</B>

<DD>
実行可能ファイルを探すディレクトリの、コロン区切り形式のリスト。
シェル変数 <B>path</B> によく似ていますがフォーマットに違いがあります。
<DT><B>PWD </B>(+)

<DD>
シェル変数 <B>cwd</B> に似ていますが、シェル変数とは同期していません。
実際のディレクトリ変更が行われたあとでだけアップデートされます。
<DT><B>REMOTEHOST </B>(+)

<DD>
ユーザがどのホストからログインしているかを示します
(リモートからのログインで、
かつこのシェルがこれらの情報を決定できる場合)。
シェルがそのようにコンパイルされている場合だけに設定されます。
<B>version</B> シェル変数を参照してください。
<DT><B>SHLVL </B>(+)

<DD>
<B>shlvl</B> と同じです。
<DT><B>SYSTYPE </B>(+)

<DD>
現在のシステムタイプです。 (Domain/OS のみ)
<DT><B>TERM</B>

<DD>
<B>term</B> シェル変数と同じです。
<DT><B>TERMCAP</B>

<DD>
端末のケーパビリティ文字列です。
<B>端末管理</B>を参照してください。
<DT><B>USER</B>

<DD>
<B>user</B> シェル変数と同じです。
<DT><B>VENDOR </B>(+)

<DD>
コンパイル時に決定されたベンダ名です。
<DT><B>VISUAL</B>

<DD>
デフォルトのフルスクリーンエディタへのパス名です。
<B>EDITOR</B> 環境変数と
<I>run-fg-editor</I> 編集コマンドも参照してください。
</DL>
<A NAME="lbBR">&nbsp;</A>
<H2>関連ファイル</H2>


<DL COMPACT>
<DT><I>/etc/csh.cshrc</I>

<DD>
すべてのシェルで最初に読み込まれます。
ConvexOS, Stellix, Intel では <I>/etc/cshrc</I> を使います。
NeXTs では <I>/etc/cshrc.std</I> を使います。
A/UX, AMIX, Cray, IRIX の <I>csh</I>(1) はこのファイルを読みませんが、
いずれにせよ <I>tcsh</I> ではこのファイルが読み込まれます。
Solaris 2.x もこのファイルを持ちませんが、<I>tcsh</I> は
<I>/etc/.cshrc</I> を読み込みます。(+)
<DT><I>/etc/csh.login</I>

<DD>
<I>/etc/csh.cshrc</I> の後にログインシェルによって読み込まれます。
ConvexOS, Stellix, Intel では <I>/etc/login</I> を使います。
NeXTs では <I>/etc/login.std</I> を使用します。
Solaris 2.x では <I>/etc/.login</I> を使います。
A/UX, AMIX, Cray, IRIX では <I>/etc/cshrc</I> を使います。
<DT><I>~/.tcshrc </I>(+)

<DD>
<I>/etc/csh.cshrc</I> かそれに相当するファイルの後に、
すべてのシェルで読み込まれます。
<DT><I>~/.cshrc</I>

<DD>
<I>~/.tcshrc</I> が存在しなければ、
<I>/etc/csh.cshrc</I> かそれに相当するファイルの後に、
すべてのシェルで読み込まれます。
このマニュアルでは `<I>~/.tcshrc</I>' を
「`<I>~/.tcshrc</I>' か
`<I>~/.tcshrc</I>' が見つからなかった場合の <I>~/.cshrc</I>'」
の意味で使用します。
<DT><I>~/.history</I>

<DD>
<B>savehist</B> が設定されている場合は
<I>~/.tcshrc</I> の後にログインシェルによって読み込まれます。
ただし <B>histfile</B> の部分も参照してください。
<DT><I>~/.login</I>

<DD>
<I>~/.tcshrc</I> または <I>~/.history</I> の後にログインシェルによって
読み込まれます。シェルは<I>~/.login</I> を <I>~/.tcshrc</I> と
<I>~/.history</I> の後にではなく、前に読み込むように
コンパイルされているかもしれません。
<B>version</B> シェル変数を参照してください。
<DT><I>~/.cshdirs </I>(+)

<DD>
<B>savedirs</B> が設定されている場合には、
<I>~/.login</I> の後にログインシェルによって読み込まれます。
ただし <B>dirsfile</B> も参照してください。
<DT><I>/etc/csh.logout</I>

<DD>
ログアウト時にログインシェルによって読み込まれます。
ConvexOS, Stellix, Intel では、 <I>/etc/logout</I> を使います。
A/UX, AMIX, Cray, IRIX では、
<I>csh</I>(1) はこれに対応するファイルを持ちませんが、
いずれにしても <I>tcsh</I> はこのファイルを読みます。
Solaris 2.x も <I>/etc/logout</I> を持っていませんが、
<I>tcsh</I> は <I>/etc/.logout</I> を読み込みます。 (+)
<DT><I>~/.logout</I>

<DD>
<I>/etc/csh.logout</I> またはその相当ファイルが実行された後に、
ログインシェルによって読み込まれます。
<DT><I>/bin/sh</I>

<DD>
`#' で始まらないシェルスクリプトを解釈実行するために使われます。
<DT><I>/tmp/sh*</I>

<DD>
`&lt;&lt;' 用の一時ファイルです。
<DT><I>/etc/passwd</I>

<DD>
ホームディレクトリ `~name' を代入するための情報源です。

</DL>
<P>

スタートアップファイルの読み込みの順番は、
シェルのコンパイル時に変更されているかもしれません。
<B>スタートアップとシャットダウン</B>と <B>version</B> を参照してください。
<A NAME="lbBS">&nbsp;</A>
<H2>新規機能 (+)</H2>

このマニュアルでは、<I>tcsh</I> をひとつの対象として記述してきました。
しかし <I>csh</I>(1) の経験者は、
<I>tcsh</I> の新しい機能に特に興味があるでしょう。
<P>

コマンド行編集: GNU Emacs スタイルや <I>vi</I>(1)-スタイルの
キーバインディングをサポートしています。
<B>コマンド行エディタ</B>と<B>編集コマンド</B>を参照してください。
<P>

プログラマブルで対話的な単語補完と一覧表示。
<B>補完と一覧</B>と、組み込みコマンド <I>complete</I>, <I>uncomplete</I>
の記述を見てください。
<P>

ファイル名、コマンド、変数名の<B>スペル訂正</B>
(そちらも参照)。
<P>

<B>エディタ編集コマンド</B> (そちらも参照) で、
コマンドのタイプ中に他の便利な機能を実行できます。
ヘルプファイルの参照してください (<I>run-help</I>)、
手軽にエディタの再起動 (<I>run-fg-editor</I>)、
コマンド解決 (<I>which-command</I>) などができます。
<P>

高性能化されたヒストリ機能。
ヒストリリストのイベントにタイムスタンプをつけられます。
<I>history</I> コマンドおよびそれに関連するシェル変数、
<B>ヒストリ置換</B>に記述されている、
以前には文書化されていなかった `#' イベント記述子と新しい修正子、
<I>*-history</I>, <I>history-search-*</I>, <I>i-search-*</I>,
<I>vi-search-*</I>, <I>toggle-literal-history</I> 各編集コマンド、
シェル変数 <B>histlit</B> なども参照してください。
<P>

高性能化されたディレクトリ解釈 (parsing) とディレクトリスタック操作。
<I>cd</I>, <I>pushd</I>, <I>popd</I> and <I>dirs</I> コマンドとそれらに
関連するシェル変数、<B>ディレクトリスタック置換</B>での説明、
<B>dirstack</B>, <B>owd</B>, <B>symlinks</B> シェル変数、
<I>normalize-command</I>,
<I>normalize-path</I> 編集コマンドなどを参照してください。
<P>

グロブパターンの否定。
<B>ファイル名置換</B>を見てください。
<P>

新しいファイル問い合わせ演算子 (そちらも参照)
とそれらを用いる組み込みコマンド <I>filetest</I>。
<P>

スケージューリングされたイベント、特別なエイリアス、自動ログアウト、
端末のロック、コマンド待ち、ログインとログアウトの監視などなどを含む、
各種の<B>自動イベント、定期イベント、時刻指定イベント</B>
(それぞれの項目を参照)。
<P>

固有言語システムのサポート
(<B>固有言語システムのサポート</B>を見てください)、
OS 固有の各種機能のサポート
(<B>OS 固有機能のサポート</B>と <B>echo_style</B>
シェル変数を参照)、
システム依存のファイル配置 (<B>関連ファイル</B>を参照)
<P>

拡張された端末管理能力 (<B>端末管理</B>を参照)。
<P>

<I>builtins</I>, <I>hup</I>, <I>ls-F</I>, <I>newgrp</I>,
<I>printenv</I>, <I>which</I>, <I>where</I> などの新しい
組み込みコマンド (それぞれの項目を参照)。
<P>

新しい変数。シェルから便利な情報を簡単に入手できます。
<B>gid</B>, <B>loginsh</B>, <B>oid</B>, <B>shlvl</B>, <B>tcsh</B>,
<B>tty</B>, <B>uid</B>, <B>version</B> シェル変数と、
<B>HOST</B>, <B>REMOTEHOST</B>, <B>VENDOR</B>, <B>OSTYPE</B>,
<B>MACHTYPE</B> 環境変数。
それぞれの説明を見てください。
<P>

有用な情報をプロンプト文字列に埋めこむための新しいシンタックス
(<B>prompt</B> を参照)。
ループとスペル訂正用の特別なプロンプト
(<B>prompt2</B> と <B>prompt3</B> を参照)。
<P>

読み取り専用の変数 (<B>変数置換</B>を参照)。
<A NAME="lbBT">&nbsp;</A>
<H2>バグ</H2>

サスペンドされたコマンドが再開されたときに、
カレントディレクトリが起動されたときと違っている場合には、
起動時のディレクトリを表示します。
ジョブが内部でディレクトリを変更することもあり得るので、
これは間違った情報を与えてしまうかもしれません。
<P>

シェルの組み込み機能は停止、再開できません。
`a ; b ; c' のような形のコマンド列を停止させるときの処理も
あまり上品なものではありません。
`b' コマンドをサスペンドさせると、
シェルは即座に `c' コマンドを実行してしまいます。
<I>alias</I> での展開結果を実行しているときには、
特にこの点に注意が必要です。
コマンド列を () の中に入れて、
サブシェルに押し込めてしまうのがいいでしょう。
つまり `( a ; b ; c )' のようにするのです。
<P>

プロセス開始後の端末出力の制御が原始的です。
誰かが仮想端末の良いインタフェースを作ってくれるといいのですが。
仮想端末インターフェースの分野では、
出力制御に関して面白いことがたくさん行えるはずです。
<P>

エイリアス置換がシェル手続きのシミュレートに大変良く用いられますが、
これはあまり気のきいたものではありません。
エイリアスよりもシェル手続きを提供すべきです。
<P>

ループの中のコマンドは、ヒストリリストに追加されません。
制御構造は、組み込みコマンドとしては認識されず、単に解釈されます。
したがって制御コマンドはどこにでも置くことができ、
パイプ `|' といっしょにも、
`&amp;' と `;' のようなメタシンタックスといっしょにも使えます。
<P>

<I>foreach</I> は <I>end</I> を探しているとき
ヒアドキュメントを無視しません。
<P>

`:' 修飾子は、
コマンド置換の出力に使えるべきです。
<P>

ダム端末のように、端末がカーソルを上に移動できない場合には、
スクリーン幅より長い行の更新が大変貧弱です。
<P>

<B>HPATH</B> と <B>NOREBIND</B> は環境変数である必要はありません。
<P>

`?' や `*' や `[]' を使わないグロブパターンや、
`{}' や `~' を使うグロブパターンは、否定が正しく扱われません。
<P>

<I>if</I> の単一コマンド形式では、たとえ式が偽で、
コマンドが実行されなかったとしても、リダイレクト出力をしてしまいます。
<P>

<I>ls-F</I> はファイル名をソートするとき、
ファイル識別キャラクタを勘定に入れてしまいます。
またファイル名の中の制御文字を正しく扱うことができません。
中断させることもできません。
<P>

バグレポートは <A HREF="mailto:tcsh-bugs@mx.gw.com">tcsh-bugs@mx.gw.com</A> まで送ってください。
修正もいっしょに送っていただけるとありがたいです。
もし tcsh のメンテナンスとテストを手伝って下さる場合には、
本文に &quot;subscribe tcsh &lt;your name&gt;&quot; と一行書いたメールを
<A HREF="mailto:listserv@mx.gw.com">listserv@mx.gw.com</A> に送ってください。
&quot;subscribe tcsh-bugs &lt;your name&gt;&quot; を講読すれば
すべてのバグレポートが取得できます。
&quot;subscribe tcsh-diffs &lt;your name&gt;&quot; を講読すれば
開発 ML に参加でき、各パッチレベルでの diff を入手できます。
<A NAME="lbBU">&nbsp;</A>
<H2>tcsh の T の由来</H2>

1964 年 DEC は PDP-6 を開発しました。
のちに PDP-10 が再実装されました。
1970 年前後に DEC がそのセカンドモデル KI10 を発表したとき、
これには DECsystem-10 という新しい名前がつけられました。
<P>

TENEX は 1972 年に Bolt, Beranek &amp; Newman
(Massachusetts 州 Cambridge のシンクタンク) において、
実験的なデマンドページ型仮想記憶 OS として作られました。
彼らは DEC PDP-10 用の新しいページャを構築し、
それを使った OS を作りました。
これは学術分野で非常に大きな成功を収めました。
<P>

1975 年 DEC  は PDP-10 の新しいモデル KL10 を発表しました。
DEC は BBN から TENEX のライセンスを受け、
KL10 は TENEX 版のみにするつもりでした。
DEC はそれらのバージョンを TOPS-20 と呼んでいました (大文字化は商標です)。
多くの TOPS-10 (&quot;The OPerating System for PDP-10&quot; の頭文字です) ユーザが
これに反対しました。
こうして DEC は同じハードウエアにふたつの互換性のないシステムを
サポートしなければならないことになりました。
--でもそのとき PDP-11 には 6 つの OS があったのですが!
<P>

TENEX の TOPS-20 はバージョン 3 までに、
ULTCMD と呼ばれるユーザコードレベルのコマンド補完機能サブルーチンを
備えていました。バージョン 3 で DEC は、
これらの機能すべてと、さらにそれ以上とをモニタ
(Unix でいうところのカーネル) に追加し、
COMND&amp; JSYS (`Jump to SYStem' 命令;
スーパーバイザーを呼び出す機能 [私が IBM 上がりだってバレちゃった?])
でアクセスできるようにしました
<P>

tcsh の作者たちは TENEX と TOPS-20 における
これらの機能に影響を受け、これを模倣した版の csh を作成したのです。
<A NAME="lbBV">&nbsp;</A>
<H2>制限</H2>

単語は 1024 文字より長くできません。
<P>

システムは引数並びを 10240 文字までに制限しています。
<P>

コマンドに与える引き数の数 (ファイル名展開を含む) は、
引き数リストに許された文字数の 1/6 までに制限されています。
<P>

コマンド置換では、
引数リストに許された文字数より多くの文字数に置換できません。
<P>

シェルはループを検出するために、 <I>alias</I> 置換の回数を
1 行当たり 20 に制限しています。
<A NAME="lbBW">&nbsp;</A>
<H2>関連項目</H2>

csh(1), emacs(1), <A HREF="../../0MultiFileIdx/man1/ls.1.html">ls</A>(1), <A HREF="../../0MultiFileIdx/man1/newgrp.1.html">newgrp</A>(1), sh(1), setpath(1), <A HREF="../../0MultiFileIdx/man1/stty.1.html">stty</A>(1), <A HREF="../../0MultiFileIdx/man1/su.1.html">su</A>(1),
tset(1), vi(1), x(1), <A HREF="../../LDP_man-pages/man2/access.2.html">access</A>(2), <A HREF="../../LDP_man-pages/man2/execve.2.html">execve</A>(2), <A HREF="../../LDP_man-pages/man2/fork.2.html">fork</A>(2), killpg(2),
<A HREF="../../LDP_man-pages/man2/pipe.2.html">pipe</A>(2), <A HREF="../../LDP_man-pages/man2/setrlimit.2.html">setrlimit</A>(2), sigvec(2), <A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A>(2), <A HREF="../../LDP_man-pages/man2/umask.2.html">umask</A>(2), <A HREF="../../LDP_man-pages/man2/vfork.2.html">vfork</A>(2), <A HREF="../../LDP_man-pages/man2/wait.2.html">wait</A>(2),
<A HREF="../../LDP_man-pages/man3/malloc.3.html">malloc</A>(3), <A HREF="../../LDP_man-pages/man3/setlocale.3.html">setlocale</A>(3), <A HREF="../../LDP_man-pages/man4/tty.4.html">tty</A>(4), a.out(5), <A HREF="../../LDP_man-pages/man5/termcap.5.html">termcap</A>(5), <A HREF="../../LDP_man-pages/man7/environ.7.html">environ</A>(7),
<A HREF="../../LDP_man-pages/man7/termio.7.html">termio</A>(7), Introduction to the C Shell
<A NAME="lbBX">&nbsp;</A>
<H2>バージョン</H2>

このマニュアルは tcsh 6.11.00 (Astron) 2001-09-02
に関するドキュメントです。
<A NAME="lbBY">&nbsp;</A>
<H2>作者</H2>


<DL COMPACT>
<DT>William Joy<DD>
<I>csh</I>(1) のオリジナル作者
<DT>J.E. Kulp, IIASA, Laxenburg, Austria<DD>
ジョブコントロールとディレクトリスタック機能
<DT>Ken Greer, HP Labs, 1981<DD>
ファイル名補完
<DT>Mike Ellis, Fairchild, 1983<DD>
コマンド名認識 / 補完
<DT>Paul Placeway, Ohio State CIS Dept., 1983-1993<DD>
コマンドラインエディタ、プロンプトルーチン、新しいグロブの文法、
たくさんの修正とスピードアップ
<DT>Karl Kleinpaste, CCI 1983-4<DD>
特別なエイリアス、ディレクトリスタックの取出し機能、
ログイン / ログアウト監視、スケジュールイベント、
新しいプロンプト書式のアイデア
<DT>Rayan Zachariassen, University of Toronto, 1984<DD>
<I>ls-F</I> と <I>which</I> の組み込み、たくさんのバクフィックス、
修正とスピードアップ
<DT>Chris Kingsley, Caltech<DD>
高速ストレージアロケータルーチン
<DT>Chris Grevstad, TRW, 1987<DD>
4.3BSD <I>csh</I> の <I>tcsh</I> へのマージ
<DT>Christos S. Zoulas, Cornell U. EE Dept., 1987-94<DD>
HPUX, SVR2, SVR3 に移植、SysV 版 getwd.c, SHORT_STRINGS をサポート、
sh.glob.c の新バージョン
<DT>James J Dempsey, BBN, and Paul Placeway, OSU, 1988<DD>
A/UX に移植
<DT>Daniel Long, NNSC, 1988<DD>
<B>wordchars</B>
<DT>Patrick Wolfe, Kuck and Associates, Inc., 1988<DD>
<I>vi</I> モードのクリーンアップ
<DT>David C Lawrence, Rensselaer Polytechnic Institute, 1989<DD>
<B>autolist</B> と、あいまい補完の一覧
<DT>Alec Wolman, DEC, 1989<DD>
プロンプト中の改行
<DT>Matt Landau, BBN, 1989<DD>
ファイル <I>~/.tcshrc</I>
<DT>Ray Moody, Purdue Physics, 1989<DD>
スペースバーの魔法によるヒストリ展開
<DT>Mordechai ????, Intel, 1989<DD>
printprompt() の修正と追加
<DT>Kazuhiro Honda, Dept. of Computer Science, Keio University, 1989<DD>
自動スペル訂正と <B>prompt3</B>
<DT>Per Hedeland, Ellemtel, Sweden, 1990-<DD>
さまざまなバグフィックス、改良とマニュアルのアップデート
<DT>Hans J. Albertsson (Sun Sweden)<DD>
<B>ampm</B>, <I>settc</I>, <I>telltc</I>
<DT>Michael Bloom<DD>
割り込みハンドリングの修正
<DT>Michael Fine, Digital Equipment Corp<DD>
拡張キーのサポート
<DT>Eric Schnoebelen, Convex, 1990<DD>
Convex サポート、<I>csh</I> の多数のバグフィックス、
ディレクトリスタックの保存と復帰
<DT>Ron Flax, Apple, 1990<DD>
A/UX 2.0 への (再) 移植
<DT>Dan Oscarsson, LTH Sweden, 1990<DD>
NLS サポートと非 NLS サイト用の NLS シミュレート機能、修正
<DT>Johan Widen, SICS Sweden, 1990<DD>
<B>shlvl</B>, Mach サポート、<I>correct-line</I>, 8 ビット表示
<DT>Matt Day, Sanyo Icon, 1990<DD>
POSIX termio サポート、SysV limit 修正
<DT>Jaap Vermeulen, Sequent, 1990-91<DD>
vi モード修正、expand-line, ウインドウ変更の修正、Symmetry 移植
<DT>Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991<DD>
<B>autolist</B> beeping オプション、
行の先頭からカーソルまでのすべてを対象とするヒストリ検索の修正
<DT>Scott Krotz, Motorola, 1991<DD>
Minix に移植
<DT>David Dawes, Sydney U. Australia, Physics Dept., 1991<DD>
SVR4 ジョブコントロールの修正
<DT>Jose Sousa, Interactive Systems Corp., 1991<DD>
拡張 <I>vi</I> の修正、<I>vi</I> デリートコマンド
<DT>Marc Horowitz, MIT, 1991<DD>
ANSIfication の修正、新しい exec ハッシュコード、
imake の修正、<I>where</I>
<DT>Bruce Sterling Woodcock, <A HREF="mailto:sterling@netcom.com">sterling@netcom.com</A>, 1991-1995<DD>
ETA と Pyramid への移植、
Makefile と lint の修正、<B>ignoreeof</B>=n 追加、
その他のさまざまな移植性向上のための変更、およびバグ修正
<DT>Jeff Fink, 1992<DD>
<I>complete-word-fwd</I> と <I>complete-word-back</I>
<DT>Harry C. Pulley, 1992<DD>
Coherent に移植
<DT>Andy Phillips, Mullard Space Science Lab U.K., 1992<DD>
VMS-POSIX に移植
<DT>Beto Appleton, IBM Corp., 1992<DD>
移動プロセスグループの修正、<I>csh</I> バグ修正、
POSIX file tests, POSIX SIGHUP
<DT>Scott Bolte, Cray Computer Corp., 1992<DD>
CSOS に移植
<DT>Kaveh R. Ghazi, Rutgers University, 1992<DD>
Tek, m88k, Titan と Masscomp への移植と修正、
autoconf サポートの追加
<DT>Mark Linderman, Cornell University, 1992<DD>
OS/2 に移植
<DT>Mika Liljeberg, <A HREF="mailto:liljeber@kruuna.Helsinki.FI">liljeber@kruuna.Helsinki.FI</A>, 1992<DD>
Linux に移植
<DT>Tim P. Starrin, NASA Langley Research Center Operations, 1993<DD>
読み取り専用変数
<DT>Dave Schweisguth, Yale University, 1993-4<DD>
新しいマニュアルページと tcsh.man2html
<DT>Larry Schwimmer, Stanford University, 1993<DD>
AFS と HESIOD パッチ
<DT>Luke Mewburn, RMIT University, 1994-6<DD>
プロンプトの中でのディレクトリ表示の拡張、
<B>ellipsis</B> と <B>rprompt</B>
<DT>Edward Hutchins, Silicon Graphics Inc., 1996<DD>
暗黙的な cd の追加。
<DT>Martin Kraemer, 1997<DD>
Siemens Nixdorf EBCDIC machine に移植
<DT>Amol Deshpande, Microsoft, 1997<DD>
WIN32 (Windows/95 and Windows/NT) に移植、
足りないライブラリすべてと、
メッセージカタログコードのすべてを作成し、
Windows と通信できるようにした
<DT>Taga Nayuta, 1998<DD>
色つき ls の追加

</DL>
<P>

<A NAME="lbBZ">&nbsp;</A>
<H2>謝辞</H2>

以下のみなさんに感謝します。
<BR>

Bryan Dunlap, Clayton Elwell, Karl Kleinpaste, Bob Manson, Steve Romig,
Diana Smetters, Bob Sutterfield, Mark Verber, Elizabeth Zwicky
そして提案と応援をしてくれたオハイオ州のすべてのみなさん。
<P>

あらゆるバージョンに耐え、バグレポートを送ってくれ、
提案と新規追加をしてくれたネット上のすべてのみなさん。
<P>

&quot;tcsh の T の由来&quot; の章を執筆してくれた Richard M. Alderson III。
<A NAME="lbCA">&nbsp;</A>
<H2>翻訳</H2>

t_ogawa &lt;<A HREF="mailto:BYH06106@nifty.ne.jp">BYH06106@nifty.ne.jp</A>&gt;
<BR>

おさな &lt;<A HREF="mailto:yasu@via2000.net">yasu@via2000.net</A>&gt;
<BR>

ゆ〜こ &lt;<A HREF="mailto:yuko@veltec.co.jp">yuko@veltec.co.jp</A>&gt;
<BR>

森浩二 &lt;<A HREF="mailto:mori@tri.asanuma.co.jp">mori@tri.asanuma.co.jp</A>&gt;
<BR>

NOKUBI Hirotaka &lt;<A HREF="mailto:nokubi@ff.iij4u.or.jp">nokubi@ff.iij4u.or.jp</A>&gt;
<BR>

中野武雄 &lt;<A HREF="mailto:nakano@apm.seikei.ac.jp">nakano@apm.seikei.ac.jp</A>&gt; (JM プロジェクト)
<BR>

蔭山 &lt;<A HREF="mailto:yt-kage@cb3.so-net.ne.jp">yt-kage@cb3.so-net.ne.jp</A>&gt;
<BR>

中村和志＠神戸 &lt;<A HREF="mailto:kaz@kobe1995.net">kaz@kobe1995.net</A>&gt;
<BR>

大澤千敏＠岐阜 &lt;<A HREF="mailto:ohsawa@catv1.ccn-net.ne.jp">ohsawa@catv1.ccn-net.ne.jp</A>&gt;
<BR>

熊谷典大 &lt;<A HREF="mailto:kumagai@home.com">kumagai@home.com</A>&gt;
<BR>

(順不同)
<P>

翻訳にあたり、JM プロジェクトの方々の御協力を頂きました。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名称</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">解説</A><DD>
<DL>
<DT><A HREF="#lbAE">引数リスト処理</A><DD>
<DT><A HREF="#lbAF">スタートアップとシャットダウン</A><DD>
<DT><A HREF="#lbAG">編集</A><DD>
<DT><A HREF="#lbAH">コマンド行編集 (+)</A><DD>
<DT><A HREF="#lbAI">補完と一覧 (+)</A><DD>
<DT><A HREF="#lbAJ">スペル訂正 (+)</A><DD>
<DT><A HREF="#lbAK">編集コマンド (+)</A><DD>
<DT><A HREF="#lbAL">字句構造</A><DD>
<DT><A HREF="#lbAM">置換</A><DD>
<DT><A HREF="#lbAN">ヒストリ置換</A><DD>
<DT><A HREF="#lbAO">エイリアス置換</A><DD>
<DT><A HREF="#lbAP">変数置換</A><DD>
<DT><A HREF="#lbAQ">コマンド置換、ファイル名置換、ディレクトリスタック置換</A><DD>
<DT><A HREF="#lbAR">コマンド置換</A><DD>
<DT><A HREF="#lbAS">ファイル名置換</A><DD>
<DT><A HREF="#lbAT">ディレクトリスタック置換 (+)</A><DD>
<DT><A HREF="#lbAU">その他の置換 (+)</A><DD>
<DT><A HREF="#lbAV">コマンド</A><DD>
<DT><A HREF="#lbAW">単純コマンド、パイプライン、コマンド列</A><DD>
<DT><A HREF="#lbAX">組み込みコマンド、非組み込みコマンドの実行</A><DD>
<DT><A HREF="#lbAY">入出力</A><DD>
<DT><A HREF="#lbAZ">特徴</A><DD>
<DT><A HREF="#lbBA">制御フロー</A><DD>
<DT><A HREF="#lbBB">式</A><DD>
<DT><A HREF="#lbBC">論理演算子, 算術演算子, 比較演算子</A><DD>
<DT><A HREF="#lbBD">コマンド終了ステータス</A><DD>
<DT><A HREF="#lbBE">ファイル問い合わせ演算子</A><DD>
<DT><A HREF="#lbBF">ジョブ</A><DD>
<DT><A HREF="#lbBG">状態通知</A><DD>
<DT><A HREF="#lbBH">自動イベント、定期イベント、時刻指定イベント (+)</A><DD>
<DT><A HREF="#lbBI">固有言語システムのサポート (+)</A><DD>
<DT><A HREF="#lbBJ">OS 固有機能のサポート (+)</A><DD>
<DT><A HREF="#lbBK">シグナル処理</A><DD>
<DT><A HREF="#lbBL">端末管理 (+)</A><DD>
</DL>
<DT><A HREF="#lbBM">参照</A><DD>
<DL>
<DT><A HREF="#lbBN">組み込みコマンド</A><DD>
<DT><A HREF="#lbBO">特別なエイリアス (+)</A><DD>
<DT><A HREF="#lbBP">特別なシェル変数</A><DD>
</DL>
<DT><A HREF="#lbBQ">環境変数</A><DD>
<DT><A HREF="#lbBR">関連ファイル</A><DD>
<DT><A HREF="#lbBS">新規機能 (+)</A><DD>
<DT><A HREF="#lbBT">バグ</A><DD>
<DT><A HREF="#lbBU">tcsh の T の由来</A><DD>
<DT><A HREF="#lbBV">制限</A><DD>
<DT><A HREF="#lbBW">関連項目</A><DD>
<DT><A HREF="#lbBX">バージョン</A><DD>
<DT><A HREF="#lbBY">作者</A><DD>
<DT><A HREF="#lbBZ">謝辞</A><DD>
<DT><A HREF="#lbCA">翻訳</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:46 GMT, December 05, 2022
</BODY>
</HTML>
