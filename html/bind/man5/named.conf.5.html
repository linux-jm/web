
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of NAMED.CONF</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../contrib.css">
</HEAD>
<BODY>
<DIV ALIGN="right">
本ページは <A HREF="http://www.jp.freebsd.org/man-jp/">FreeBSD jpman project</A>
(man-jp@jp.FreeBSD.org) より寄贈いただきました。
</DIV>


<H1>NAMED.CONF</H1>
Section: File Formats (5)<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/bind/contrib/man5/named.conf.5">roff page</A><HR>
<BR>BSD mandoc<BR>
BSD 4

<P>
<A NAME="lbAB">&nbsp;</A>
<H2>名称</H2>

<B>named.conf</B>

<A HREF="../man8/named.8.html">named</A>(8)


 - 用の設定ファイル

<P>
<A NAME="lbAC">&nbsp;</A>
<H2>概要</H2>

<P>
BIND 8 は、以前のリリースと比べて遥かに設定可能なものになっています。
完全に新しい設定項目があります。例えばアクセス制御リストやカテゴリ別の
ログなどです。以前はゾーンすべてに対して適用されていたオプションの多くが、
選択的に使えるようになっています。
こうした機能に加え、
将来必要とされる設定がどのようなものになるかをよく考えた結果、
新たに設定ファイルのフォーマットを作ることにしました。
<P>
<A NAME="lbAD">&nbsp;</A>
<H3>一般的な文法</H3>

<P>
BIND 8 の設定には、一般的な特徴が 2 つあります。
それは、ステートメントとコメントです。
ステートメントはすべてセミコロンで終わります。ステートメントの多くは
サブステートメントを持っており、サブステートメントもセミコロンで終わります。
<P>
<P>

次のようなステートメントをサポートしています :
<DL COMPACT>
<P>

<DT><B>logging</B>


<DD>
サーバが何をログに残すか、そしてどこにログメッセージを送るのかを指定します。
<P>
<DT><B>options</B>


<DD>
グローバルなサーバ設定オプションを制御し、
その他のステートメントに対するデフォルトを設定します。
<P>
<DT><B>zone</B>


<DD>
ゾーンを定義します。
<P>
<DT><B>acl</B>


<DD>
名前つきの IP アドレスマッチングリストを定義します。これは、アクセス制御や
その他の用途に使われます。
<P>
<DT><B>key</B>


<DD>
認証と許可に使われる鍵情報を指定します。
<P>
<DT><B>trusted-keys</B>


<DD>
DNSSEC 鍵を定義します。これは、事前にサーバに設定されており、暗黙のうちに
信頼します。
<P>
<DT><B>server</B>


<DD>
個々のリモートサーバ用の設定オプションを設定します。
<P>
<DT><B>controls</B>


<DD>
<B>ndc</B>

ユーティリティが使用する制御チャネルを宣言します。
<P>
<DT><B>include</B>


<DD>
他のファイルをインクルードします。
<P>
</DL>
<P>

<P>
<B>logging</B>

および
<B>options</B>

ステートメントは、各設定につき 1 回のみ記述可能です。それに対し、
その他のステートメントは何回でも記述可能です。各ステートメントの
詳細については、次に個々のセクションで述べます。
<P>
コメントは、BIND 設定ファイル中でホワイトスペースが現れて良い
所ならどこでも記述可能です。いろいろなプログラマの注意を引くように、
C や C++ 、あるいは シェルや perl の形式のコメントを書くことができます。
<P>
C のスタイルのコメントは、次の 2 つの文字から始まります。
<B>/*</B>

(スラッシュと星印) そして、
<B>*/</B>

(星印とスラッシュ) で終わります。
この形式のコメントは、これらの文字で完全に区切られるものであるので、
行の一部分のみでも複数行にまたがっても使用することができます。
<P>
C のスタイルのコメントは入れ子にはできません。例えば、次の例は
不適切なものです。なぜなら、コメント全体が最初の
<B>*/</B>

で終わってしまうからです。

<BLOCKQUOTE>
<PRE>
/* この行はコメントの最初です。
   この行もコメントの一部です。
/* この行は、間違えてコメントを入れ子にしようとしています。 */
   この行は、もうコメント内部ではありません。 */
</PRE>
</BLOCKQUOTE>

<P>
C++ スタイルのコメントは、次の 2 文字から始まります。
<B>//</B>

(スラッシュとスラッシュ) そして、その行の終わりまでがコメントとして
続きます。この種類のコメントは、複数行にわたって続きません。意味としては
1 つだが複数行にまたがるようなコメントを書きたい場合は、各行に
<B>//</B>

を書かなくてはなりません。例えば、次のようにです :
<P>

<BLOCKQUOTE>
<PRE>
// この行は、コメントの始まりです。次の行は、
// 新しいコメントになります。たとえ、意味としては
// 前の行のコメントの一部分であってもです。
</PRE>
</BLOCKQUOTE>

<P>
シェルスタイル (あるいは、お好みなら perl スタイル) のコメントは、
次の文字で始まります。
<B>#</B>

(ハッシュとかポンドとか番号とかナンバ記号とかどう呼んでも良い) そして、
C++ スタイルのコメントと同様に、その行の最後までコメントが続きます。
例えば、次のようにです :
<P>

<BLOCKQUOTE>
<PRE>
# この行は、コメントの始まりです。次の行は、
# 新しいコメントになります。たとえ、意味としては
# 前の行のコメントの一部分であってもです。
</PRE>
</BLOCKQUOTE>

<P>
<I>注</I>

 
ゾーンファイルで書くように、
<B>;</B>

(セミコロン) をコメントの始まりに使用することはできません。
セミコロンは、設定ステートメントの末尾を表すものですので、
その後ろに続く文字は、何であれ次のステートメントの先頭だと
解釈されてしまいます。
<P>
<A NAME="lbAE">&nbsp;</A>
<H3>BIND 4.9.x から変更する</H3>

<P>
<P>

BIND 4.9.x の設定ファイルは、
src/bin/named/named-bootconf

という名前の、BIND 8.2.x のソースキットに同梱されている
シェルスクリプトを使用することで新しいフォーマットに変換する
ことができます。
<P>
<A NAME="lbAF">&nbsp;</A>
<H2>記述方法の定義</H2>

<P>
次から述べていることは、BIND 設定ファイルを記述する間使用される要素
についてです。1 つのステートメントとしか結びつかない要素は、その
ステートメントについて述べているセクションにだけ記述があります。
<P>
<DL COMPACT>
<P>

<DT><B></B><I>acl_name</I>


<DD>
<B>acl</B>

ステートメントで定義される
<I>address_match_list</I>

の名称です。
<P>
<DT><B></B><I>address_match_list</I>


<DD>
<I>ip_addr</I>

 
<I>ip_prefix</I>

 
<I>key_id</I>

 
<I>acl_name</I>

要素が 1 つまたはそれ以上集まったリストです。これについては、
Sx アドレスマッチリスト

の項で述べます。
<P>
<DT><B></B><I>dotted-decimal</I>


<DD>
ドット (``.'') だけで区切られた、
1 つまたはそれ以上の数の 0 から 255 までの整数です。
例えば、
<B>123</B>

 
<B>45.67</B>

 
<B>89.123.45.67</B>

などです。
<P>
<DT><B></B><I>domain_name</I>


<DD>
DNS 名として使用される文字列をクォーテーションで囲んだものです。
例えば、
Qq Li my.test.domain

のようにです。
<P>
<DT><B></B><I>path_name</I>


<DD>
パス名として使用される文字列をクォーテーションで囲んだものです。
例えば、
Qq Li zones/master/my.test.domain

のようにです。
<P>
<DT><B></B><I>ip_addr</I>


<DD>
<I>dotted-decimal</I>

表記でちょうど 4 つの要素からなる IP アドレスです。
<P>
<DT><B></B><I>ip_port</I>


<DD>
IP ポートを表す
<I>number</I>

です。
<I>number</I>

は、
<B>0</B>

から
<B>65535</B>

までの値に限定されており、そのうち 1024 以下の値は、
典型的には、所有者が root のプロセスのみに制限されています。
場合によっては、適当に大きな番号を選択するように、穴埋めとしてアスタリスク文字
(``*'')  を使うことができます。
<P>
<DT><B></B><I>ip_prefix</I>


<DD>
<I>dotted-decimal</I>

表記で指定された IP ネットワークです。その後に、``/'' が続き、
そしてネットマスクのビット数が続きます。
例えば、
<B>127/8</B>

は、
ネットワーク
<B>127.0.0.0</B>

で、ネットマスクは
<B>255.0.0.0</B>

です。
<B>1.2.3.0/28</B>

はネットワーク
<B>1.2.3.0</B>

で、ネットマスクは
<B>255.255.255.240</B>

です。
<P>
<DT><B></B><I>key_name</I>


<DD>
共有鍵の名前を表した文字列です。
これはトランザクションセキュリティに使用します。
<P>
<DT><B></B><I>number</I>


<DD>
C 言語での符号つき整数
(32 ビット整数のマシンでは 2,147,483,647)
の範囲全体をとる、非負整数です。
取り得る値の範囲は、
使用されるコンテキストによってさらに制限されるかもしれません。
<P>
<DT><B></B><I>size_spec</I>


<DD>
<I>number</I>

または単語
<B>unlimited</B>

か単語
<B>default</B>

です。
<P>
<P>

<I>size_spec</I>

の最大値は、マシンの符号なし long 型整数の最大値になります。
<B>unlimited</B>

は、値を無制限に使用できるよう要求したり、
取り得る最大の値を要求したりするために使用します。
<B>default</B>

は、サーバが始動したときに有効だった制限が使われます。
<P>
<P>

<I>number</I>

には、次のようなスケールファクタを続けることもできます :
<B>K</B>

または
<B>k</B>

はキロバイトを、
<B>M</B>

または
<B>m</B>

はメガバイトを、そして
<B>G</B>

または
<B>g</B>

はギガバイトを表します。
これらはそれぞれ、
1024, 1024*1024, 1024*1024*1024
倍であることを表します。
<P>
<P>

スケールファクタの変換時に、整数値の格納場所でオーバフローが発生しても、
現状では黙って無視します。
その結果、期待した結果よりも小さな値、おそらくは負の値にさえなってしまいます。
本当に大きな値を安全に設定したいなら
<B>unlimited</B>

を使うのが最良の方法です。
<P>
<DT><B></B><I>yes_or_no</I>


<DD>
<B>yes</B>

または
<B>no</B>

です。あるいは
<B>true</B>

と
<B>false</B>

という単語でも受け付けます。
<B>1</B>

と
<B>0</B>

という番号でも同様です。
<P>
</DL>
<P>

<P>
<A NAME="lbAG">&nbsp;</A>
<H2>アドレスマッチリスト</H2>

<A NAME="lbAH">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
<I>address_match_list</I>    = 1*<I>address_match_element</I>

<I>address_match_element</I> = [ &quot;!&quot; ] ( <I>address_match_list</I> /
                                  <I>ip_address</I> / <I>ip_prefix</I> /
                                  <I>acl_name</I> / &quot;key &quot; <I>key_id</I> ) &quot;;&quot;
</PRE>

<P>
<A NAME="lbAI">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
アドレスマッチリストは、
主にいくつかのサーバの操作でのアクセス制御を決定するために使われます。
また、アドレスマッチリストは、他のネームサーバに問い合わせる際の優先順位や、
<B>named</B>

が問い合わせを待つアドレスを決定するためにも使われます。
アドレスマッチリストを構成する要素は、次のうちのどれでもありえます :
<P>
<UL><P>

<LI>

<I>ip-address</I>

(
<I>dotted-decimal</I>

表記
<LI>

<I>ip-prefix</I>

('/' での表記)
<LI>

<B>key</B>

ステートメントで定義された
<I>key_id</I>

<LI>

先に
<B>acl</B>

ステートメントで定義されたアドレスマッチリスト名
<LI>

別の
<I>address_match_list</I>

</UL><P>

<P>
<P>

要素は、エクスクラメーションマーク (``!'') で始めると無効にできます。
また、アドレスマッチリスト名に
<B>any</B>

 
<B>none</B>

 
<B>localhost</B>

 
<B>localnets</B>

が前もって定義されています。リスト名に関してのさらなる情報は、
<B>acl</B>

ステートメントの説明のところにあります。
<P>
<P>

<B>key</B>

節が追加されたことにより、この文法の構成要素名はある種の誤用
になってしまっています。なぜなら、ホストやネットワークアドレス
に関係なく、アクセスの認証には認証鍵を使用することができるからです。
それでもまだ、このドキュメントを通して「アドレスマッチリスト」という
用語が使われています。
<P>
<P>

与えられた IP アドレスまたはプレフィックスがアドレスマッチリストと
比較されるときには、要素が合致するまでリストをスキャンしていきます。
合致したことをどう解釈するかは、アクセス制御、
<B>listen-on</B>

ポート定義、またはトポロジのいずれの用途にリストを使ったか、
またその要素が無効にされていたかで決定します。
<P>
<P>

アクセス制御リストとしてアドレスマッチリストが使われる場合、合致した要素が
無効になっていないときはアクセスを許可し、無効になっているときはアクセスを
禁止します。アドレスマッチリスト中に合致するものが 1 つもない場合には、
アクセスは禁止されます。
<B>allow-query</B>

 
<B>allow-transfer</B>

 
<B>allow-update</B>

 
<B>allow-recursion</B>

 
<B>blackhole</B>

節はすべてこのようにアドレスマッチリストを使用します。同様に、
<B>listen-on</B>

オプションを使うと、リストに合致しないマシンのアドレスでの問い合わせは、
いずれもサーバが受け取らないようになります。
<P>
<P>

<B>topology</B>

オプションと一緒にアドレスマッチリストが使用される場合、合致した要素が
無効になっていない場合、リスト中で合致した位置に基づいた距離が返されます
(合致した箇所がリストの先頭に近ければそれだけ、サーバとの間の距離は
短いことになります)。合致した要素が無効になっている場合、サーバから
もっとも遠い距離が割り当てられることになるでしょう。合致するものが
なかった場合は、そのアドレスには、無効になっていないリスト要素よりは
遠く、無効になっている要素よりは近い距離が返されるでしょう。
<P>
<P>

ファーストマッチアルゴリズムを使用していますので、リスト中で
他の要素のサブセットを定義している要素のほうが、より広い範囲の定義を
している要素よりも、先に定義すべきです。これは、どちらか一方の要素が無効
になっていようがいまいが関係ありません。例えば、

<BLOCKQUOTE><TT>1.2.3/24; !1.2.3.13</TT></BLOCKQUOTE>
では、1.2.3.13 という要素は無意味です。なぜなら、
このアルゴリズムでは、1.2.3.13 の検索を 1.2.3/24 という要素に合致
してしまうからです。

<BLOCKQUOTE><TT>!1.2.3.13; 1.2.3/24</TT></BLOCKQUOTE>
を使うと、1.2.3.13 は要素が無効になっていることにより拒否されますが、
その他の 1.2.3.* のホストは素通りになりますので、この問題を回避できます。
<P>
<A NAME="lbAJ">&nbsp;</A>
<H2>logging ステートメント</H2>

<A NAME="lbAK">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
logging {
  [ channel <I>channel_name</I> {
    ( file <I>path_name</I>
       [ versions ( <I>number</I> | unlimited ) ]
       [ size <I>size_spec</I> ]
     | syslog ( kern | user | mail | daemon | auth | syslog | lpr |
                news | uucp | cron | authpriv | ftp |
                local0 | local1 | local2 | local3 |
                local4 | local5 | local6 | local7 )
     | null );

    [ severity ( critical | error | warning | notice |
                 info  | debug [ <I>level</I> ] | dynamic ); ]
    [ print-category <I>yes_or_no</I>; ]
    [ print-severity <I>yes_or_no</I>; ]
    [ print-time <I>yes_or_no</I>; ]
  }; ]

  [ category <I>category_name</I> {
    <I>channel_name</I>; [ <I>channel_name</I>; ... ]
  }; ]
  ...
};
</PRE>

<P>
<A NAME="lbAL">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>logging</B>

ステートメントは、ネームサーバに対する様々な種類のログ用オプションを
設定します。
その中の
<B>channel</B>

フレーズでは、出力方法とフォーマットオプションと重大度を
名前と結びつけます。
この名前は後で
<B>category</B>

フレーズで使用し、様々なメッセージクラスをどのようにログに落すかを選択します。
<P>
<P>

ただ 1 つの
<B>logging</B>

ステートメントを使用して、望むだけ多くのチャネルとカテゴリを
定義できます。設定中に、複数の logging ステートメントがあった場合、
最初以外の logging ステートメントに対しては警告が出されます。
logging ステートメントが 1 個も存在しなかった場合、ログ用の設定は
次のようになるでしょう :
<P>

<PRE>
    logging {
        category default { default_syslog; default_debug; };
        category panic { default_syslog; default_stderr; };
        category packet { default_debug; };
        category eventlib { default_debug; };
    };
</PRE>

<P>
ログ用の設定は、
<B>logging</B>

ステートメントがパースされたらすぐに確立されます。もし、設定ファイル
全体の処理状況についてのメッセージをリダイレクトしたいのであれば、
<B>logging</B>

ステートメントが最初に出てくるようにしなければなりません。たとえ、
設定ファイルのパース状況を表すメッセージをリダイレクトしたくなくても、
<B>logging</B>

ステートメントはファイルの先頭に置くことを勧めます。そうすることによって、
パーサの出すメッセージを再度設定する必要が生じたときに、意識して
このルールを思い出す必要がなくなります。
<P>
<A NAME="lbAM">&nbsp;</A>
<H3>チャネルフレーズ</H3>

<P>
ログの出力はすべて、1 つまたはそれ以上の「チャネル」へと渡ります。
チャネルは好きなだけ作ることができます。
<P>
<P>

それぞれのチャネルの定義には、そのチャネル用に選択したメッセージが
ファイルに落されるのか、特別な syslog ファシリティに渡されるのか、
または、捨てられるのかを指定する節が含まれていなくてはなりません。
チャネルの定義では、チャネルが受け取るメッセージの重大度を制限する
こともオプションでできます (デフォルトは
<B>info</B>

です)。また、
<B>named</B>

が生成するタイムスタンプと、
カテゴリ名と、重大度を含めるかどうかを制限することもできます。
デフォルトでは、この 3 つのいずれも含めないようになっています。
<P>
<P>

チャネルに対するログの送り先のオプションに
<B>null</B>

という単語を使用すると、そのチャネルに送られるメッセージはすべて
捨てられるようになります。チャネルに対するその他のオプションは意味が
ありません。
<P>
<P>

<B>file</B>

節を使用すると、ログファイルがどれだけ大きくなっても良いかということと、
ログファイルがオープンされるごとに
何個のバージョンを残すのかということに関する制限を、取り込むことができます。
<P>
<P>

ログファイルに対する
<B>size</B>

オプションは、単純にログが大きくなるのを制限する固い天井になるものです。
ログファイルが size を超えると、
ログファイルが再度オープンされるまで
<B>named</B>

はファイルに何も書き込みません。size を超えていても、自動的にはファイルは
オープンされません。デフォルトでは、ログファイルのサイズ制限はありません。
<P>
<P>

ログファイルオプションに
<B>version</B>

を使用すると、
<B>named</B>

は、ログファイルがオープンされるときにファイルのバックアップバージョンの
名前を変更して、指定した数だけ保持します。例えば、lamers.log というファイルの
古いバージョンを 3 つ保持するように選択した場合、lamer.log がオープンされる
直前に lamers.log.1 というファイルは lamers.log.2 という名前に変更され、
lamers.log.0  というファイルは lamers.log.1 という名前に変更され、そして
lamers.log というファイルが lamers.log.0 という名前に変更されます。バージョン名
が巡回するものはデフォルトでは保持されません。
すでに存在しているログファイルは、
ただ単に追加して書かれます。
<B>unlimited</B>

キーワードは、現在の BIND のリリースでは
<B>99</B>

と同義です。size および versions オプションの使用例は次の通りです :
<P>

<PRE>
    channel an_example_level {
        file &quot;lamers.log&quot; versions 3 size 20m;
        print-time yes;
        print-category yes;
    };
</PRE>

<P>
<P>

<B>syslog</B>

節の引数は、
<A HREF="../../LDP_man-pages/man3/syslog.3.html">syslog</A>(3)


マニュアルページに記述されている syslog ファシリティを表します。
<B>syslogd</B>

がこのファシリティに送られるメッセージをどのように扱うかについては、
syslog.conf5


マニュアルページに記述があります。
Fn openlog()

関数に 2 つの引数しか使用しない、とても古いバージョンの syslog を
使用しているシステムをお使いの場合は、この節は黙って無視されます。
<P>
<P>

<B>severity</B>

節は、syslog の「優先度」のように働きます。ただし、syslog を
使用するかわりにファイルを直接書いても使用できるところが違います。
与えられた重大度よりも低いレベルのメッセージは、
このチャネルに対しては選択されません。与えられた重大度
よりも高いレベルのメッセージが受け取られます。
<P>
<P>

syslog を使っている場合、
syslog.conf

での優先度によっても最終的に何が通り抜けるかが決定されます。
例えば、チャネルのファシリティおよび重大度を
<B>daemon</B>

および
<B>debug</B>

に定義しているが、
syslog.conf

では
<B>daemon.warning</B>

しかログに落とさないようにしている場合、
<B>info</B>

および
<B>notice</B>

の重大度を持ったメッセージは捨てられてしまいます。
状況が逆になり、
<B>named</B>

が
<B>warning</B>

かそれ以上の重大度を持ったメッセージしか書きださないように
なっている場合、
<B>syslogd</B>

は、そのチャネルから受け取ったメッセージをすべて書き出すことでしょう。
<P>
<P>

デバッグモードになっている場合、サーバはもっと多くのデバッグ情報を
提供できます。サーバのデバッグレベルが 0 より大きくなっていれば、
デバッグモードは有効になっています。全体でのデバッグレベルは、
-<B>d</B>

フラグに正の整数値を続けて指定して
<B>named</B>

サーバを開始するか、または、動いているサーバに
<B>SIGUSR1</B>

シグナルを送る (例えば、
<B>ndc trace</B>

を使って) ことによって設定します。
全体でのデバッグレベルは 0 にも設定でき、このときは、デバッグモードは
無効になります。この状態には、サーバに
<B>SIGUSR2</B>

シグナルを送る (
<B>ndc notrace</B>

を使って) ことによってもできます。
サーバでのデバッグメッセージにはすべてデバッグレベルがあります。
そして、デバッグレベルが高いほどより詳細な出力になっています。
例えば、特定のデバッグ重大度を次のように指定したチャネル
では、サーバがデバッグモードであればいつでも、レベル 3 または
それ以下のレベルのデバッグ出力が得られます。
<P>

<PRE>
    channel specific_debug_level {
        file &quot;foo&quot;;
        severity debug 3;
    };
</PRE>

<P>
それは、全体でのデバッグレベルには依りません。
<B>dynamic</B>

重大度を指定したチャネルでは、どのメッセージを出力するかを
決めるためにサーバ全体のデバッグレベルを使用します。
<P>
<P>

<B>print-time</B>

がオンになっていれば、日付および時刻がログに落とされます。
<B>print-time</B>

は、syslog チャネルに対しても指定できますが、通常は意味のないことです。
なぜなら、syslog も日付および時刻は出力するからです。
<B>print-category</B>

が要求されている場合、メッセージのカテゴリも同様にログに落とされます。
最後に、
<B>print-severity</B>

がオンになっていれば、メッセージの重大度がログに落とされます。
<B>print-</B>

オプションはどういう組合せでも使うことができ、
常に次のような順番で出力されます :
それは time, category, severity の順です。
次に示す例は、3 つすべての
<B>print-</B>

オプションをオンにした例です :
<P>

<PRE>
    28-Apr-1997 15:05:32.863 default: notice: Ready to answer queries.
</PRE>

<P>
<P>

<B>named</B>

でのデフォルトのログ取得用に使用されるチャネルには、次のような、
事前に定義された 4 つがあります。どのようにこのチャネルを使うのかに
ついては次節
Sx category フレーズ

に記述があります。
<P>

<PRE>
    channel default_syslog {
        syslog daemon;       # syslog の daemon ファシリティに送る
        severity info;       # 優先度が info およびそれ以上のものだけ送る
    };

    channel default_debug {
        file &quot;named.run&quot;;    # 作業ディレクトリ内の named.run ファイルに
                             # 書き込む     
                             # 注 : サーバが -f オプションつきで開始されている
                             # 場合は、&quot;named.run&quot; の代わりに標準エラー
                             # 出力が使われます。
        severity dynamic;    # サーバの現在のデバッグレベルをログに落とす
    };

    channel default_stderr { # 標準エラー出力に書き出す
        file &quot;&lt;stderr&gt;&quot;;     # ここでは、見えるように書いただけです。現在、
                             # 内部のファイルディスクリプタを設定ファイルの
                             # 文中に記述する方法はありません。
        severity info;       # 優先度が info およびそれ以上のものだけ送る
    };

    channel null {
        null;                # このチャネルに送られたメッセージはみなはじく
    };
</PRE>

<P>
いったんチャネルが定義されると、再設定はできません。そのため、組み込みの
チャネルは直接変更できないわけです。しかし、定義したチャネルでのカテゴリを
指し示すことによって、デフォルトのログ用機能を変更することができます。
<P>
<A NAME="lbAN">&nbsp;</A>
<H3>category フレーズ</H3>

<P>
カテゴリはたくさんあります。そのため、見たいと思うログをどこへでも送る
ことができ、見たくないログは見ないですますことができます。カテゴリに対して
チャネルのリストを指定しなかった場合は、代わりに
<B>default</B>

カテゴリにログが送られます。
default カテゴリを指定しなかった場合、次のような「デフォルトの
default カテゴリ」が使われます :
<P>

<PRE>
    category default { default_syslog; default_debug; };
</PRE>

<P>
例として、セキュリティのイベントをファイルにログとして落としたいが、
デフォルトのロギングの挙動は維持したいとしましょう。そうすると、次のように
指定することになるでしょう :
<P>

<PRE>
    channel my_security_channel {
        file &quot;my_security_file&quot;;
        severity info;
    };
    category security { my_security_channel;
                        default_syslog; default_debug; };
</PRE>

<P>
カテゴリ内のすべてのメッセージを捨てるには、
<B>null</B>

チャネルを指定してください :
<P>

<PRE>
    category lame-servers { null; };
    category cname { null; };
</PRE>

<P>
次のようなカテゴリが使用可能です :
<P>
<DL COMPACT>
<P>

<DT><B>default</B>


<DD>
すべて捕まえます。多くのメッセージがまだカテゴリ分けされておらず、
すべてここで捕まります。さらに、カテゴリに対して何のチャネルも
指定しなかった場合、代わりに default カテゴリが使われます。default
カテゴリを指定しなかった場合、次のような定義が使われます :

<BLOCKQUOTE><TT>category default { default_syslog; default_debug; };</TT></BLOCKQUOTE>
<P>
<DT><B>config</B>


<DD>
ハイレベルの設定ファイル処理です。
<P>
<DT><B>parser</B>


<DD>
ローレベルの設定ファイル処理です。
<P>
<DT><B>queries</B>


<DD>
サーバが受け取った問い合わせそれぞれに対して、短いログメッセージを生成します。
<P>
<DT><B>lame-servers</B>


<DD>
``Lame server on ...'' というようなメッセージです。
<P>
<DT><B>statistics</B>


<DD>
統計です。
<P>
<DT><B>panic</B>


<DD>
サーバ内部の問題でサーバ自体がシャットダウンしなくてはならなくなると、
問題の起きた元のカテゴリとこのカテゴリの両方に、
問題をログとして書きこみます。
panic カテゴリを定義していない場合には、次のような定義が使われます :

<BLOCKQUOTE><TT>category panic { default_syslog; default_stderr; };</TT></BLOCKQUOTE>
<P>
<DT><B>update</B>


<DD>
動的な更新です。
<P>
<DT><B>ncache</B>


<DD>
ネガティブキャッシングです。
<P>
<DT><B>xfer-in</B>


<DD>
サーバが受け取っているゾーン転送です。
<P>
<DT><B>xfer-out</B>


<DD>
サーバが送っているゾーン転送です。
<P>
<DT><B>db</B>


<DD>
すべてのデータベースの操作です。
<P>
<DT><B>eventlib</B>


<DD>
イベントシステムからのデバッグ情報です。このカテゴリには、ただ 1 つの
チャネルが指定でき、そのチャネルはファイルチャネルでなくてはなりません。
eventlib カテゴリを指定しない場合は、次のような定義が使われます :

<BLOCKQUOTE><TT>category eventlib { default_debug; };</TT></BLOCKQUOTE>
<P>
<DT><B>packet</B>


<DD>
受け取ったパケットおよび送ったパケットのダンプです。このカテゴリには、
ただ 1 つのチャネルが指定でき、そのチャネルはファイルチャネルでなくては
なりません。packet カテゴリを指定しない場合は、次のような定義が使われます :

<BLOCKQUOTE><TT>category packet { default_debug; };</TT></BLOCKQUOTE>
<P>
<DT><B>notify</B>


<DD>
NOTIFY プロトコルです。
<P>
<DT><B>cname</B>


<DD>
``... points to a CNAME'' のようなメッセージです。
<P>
<DT><B>security</B>


<DD>
許可された / 許可されなかったリクエストです。
<P>
<DT><B>os</B>


<DD>
オペレーティングシステムの問題です。
<P>
<DT><B>insist</B>


<DD>
内部の整合性チェックの失敗です。
<P>
<DT><B>maintenance</B>


<DD>
定期的に行われるメンテナンスのイベントです。
<P>
<DT><B>load</B>


<DD>
ゾーンへのロードメッセージです。
<P>
<DT><B>response-checks</B>


<DD>
応答のチェックから発生するメッセージです。例えば、
``Malformed response ...'', ``wrong ans. name ...'',
``unrelated additional info ...'', ``invalid RR type ...'',
``bad referral ...'' といったものです。
<P>
</DL>
<P>

<P>
<A NAME="lbAO">&nbsp;</A>
<H2>options ステートメント</H2>

<A NAME="lbAP">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
options {
  [ version <I>version_string</I>; ]
  [ directory <I>path_name</I>; ]
  [ named-xfer <I>path_name</I>; ]
  [ dump-file <I>path_name</I>; ]
  [ memstatistics-file <I>path_name</I>; ]
  [ pid-file <I>path_name</I>; ]
  [ statistics-file <I>path_name</I>; ]
  [ auth-nxdomain <I>yes_or_no</I>; ]
  [ deallocate-on-exit <I>yes_or_no</I>; ]
  [ dialup <I>yes_or_no</I>; ]
  [ fake-iquery <I>yes_or_no</I>; ]
  [ fetch-glue <I>yes_or_no</I>; ]
  [ has-old-clients <I>yes_or_no</I>; ]
  [ host-statistics <I>yes_or_no</I>; ]
  [ host-statistics-max <I>number</I>; ]
  [ multiple-cnames <I>yes_or_no</I>; ]
  [ notify <I>yes_or_no</I>; ]
  [ recursion <I>yes_or_no</I>; ]
  [ rfc2308-type1 <I>yes_or_no</I>; ]
  [ use-id-pool <I>yes_or_no</I>; ]
  [ treat-cr-as-space <I>yes_or_no</I>; ]
  [ also-notify <I>yes_or_no</I>; ]
  [ forward ( only | first ); ]
  [ forwarders { [ <I>in_addr</I> ; [ <I>in_addr</I> ; ... ] ] }; ]
  [ check-names ( master | slave | response ) ( warn | fail | ignore); ]
  [ allow-query { <I>address_match_list</I> }; ]
  [ allow-recursion { <I>address_match_list</I> }; ]
  [ allow-transfer { <I>address_match_list</I> }; ]
  [ blackhole { <I>address_match_list</I> }; ]
  [ listen-on [ port <I>ip_port</I> ] { <I>address_match_list</I> }; ]
  [ query-source [ address ( <I>ip_addr</I> | * ) ]
                 [ port ( <I>ip_port</I> | * ) ] ; ]
  [ lame-ttl <I>number</I>; ]
  [ max-transfer-time-in <I>number</I>; ]
  [ max-ncache-ttl <I>number</I>; ]
  [ min-roots <I>number</I>; ]
  [ serial-queries <I>number</I>; ]
  [ transfer-format ( one-answer | many-answers ); ]
  [ transfers-in  <I>number</I>; ]
  [ transfers-out <I>number</I>; ]
  [ transfers-per-ns <I>number</I>; ]
  [ transfer-source <I>ip_addr</I>; ]
  [ maintain-ixfr-base <I>yes_or_no</I>; ]
  [ max-ixfr-log-size <I>number</I>; ]
  [ coresize <I>size_spec</I> ; ]
  [ datasize <I>size_spec</I> ; ]
  [ files <I>size_spec</I> ; ]
  [ stacksize <I>size_spec</I> ; ]
  [ cleaning-interval <I>number</I>; ]
  [ heartbeat-interval <I>number</I>; ]
  [ interface-interval <I>number</I>; ]
  [ statistics-interval <I>number</I>; ]
  [ topology { <I>address_match_list</I> }; ]
  [ sortlist { <I>address_match_list|fR }; ]
  [ rrset-order { order_spec</I> ; [ <I>order_spec</I> ; ... [ [ };
};
</PRE>

<P>
<A NAME="lbAQ">&nbsp;</A>
<H3>定義および使用法</H3>

<P>
options ステートメントは BIND で使われるグローバルオプションを
設定します。このステートメントは、設定ファイル中で 1 度だけ出現できます。
もし複数のステートメントが出現した場合は、最初に出現したステートメントが
実際に使用されるオプションを決定し、警告が行われます。options ステートメントが
存在しない場合は、各オプションがデフォルトに設定された options ブロックが
使われます。
<P>
<A NAME="lbAR">&nbsp;</A>
<H3>パス名</H3>

<P>
<DL COMPACT>
<P>

<P>
<DT><B>version</B>


<DD>
ndc コマンドの問い合わせや chaos クラスの
version.bind

名の問い合わせを通してサーバがレポートするべきバージョンです。
デフォルトではサーバの本当のバージョン番号になっていますが、
サーバのオペレータの中にはこの文字列の方が好みという人もいます
(
<B>もちろん冗談に決まっていますが</B>

)。
<P>
<DT><B>directory</B>


<DD>
サーバの作業ディレクトリです。設定ファイル中の絶対パスでない
パス名は、どんなものでもこのディレクトリからの相対パスと受け取られます。
大部分のサーバの出力ファイル (例えば、
named.run)

のデフォルトの置き場所は、このディレクトリです。もし、ディレクトリの指定が
なければ、作業ディレクトリはデフォルトで
.

になります。このディレクトリは、サーバが起動したディレクトリです。
指定されたディレクトリは絶対パスでなくてはいけません。
<P>
<DT><B>named-xfer</B>


<DD>
内部へのゾーン転送用にサーバが使用する named-xfer プログラムへのパス名です。
指定されていない場合のデフォルトは、システム依存です
(例えば、
/usr/sbin/named-xfer

です)。
<P>
<DT><B>dump-file</B>


<DD>
<B>SIGINT</B>

シグナルをサーバが受け取ったとき (
<B>ndc dumpdb</B>

が送った場合のように) に、
データベースのダンプを落とすファイルへのパス名です。
指定されていない場合のデフォルトは、
named_dump.db

です。
<P>
<DT><B>memstatistics-file</B>


<DD>
<B>deallocate-on-exit</B>

が
<B>yes</B>

になっている場合に、
サーバが終了時にメモリ使用統計を書き出すファイルへのパス名です。
指定されていない場合のデフォルトは、
named.memstats

です。
<P>
<DT><B>pid-file</B>


<DD>
サーバが自分のプロセス ID を書き出すファイルへのパス名です。
指定されていない場合のデフォルトは、オペレーティングシステムに
依存しますが、通常は、
/var/run/named.pid

あるいは
/etc/named.pid

です。
pid-file は、
<B>ndc</B>

のような、動作しているネームサーバにシグナルを送りたい
プログラムが使用します。
<P>
<DT><B>statistics-file</B>


<DD>
サーバが
<B>SIGILL</B>

シグナルを
(
<B>ndc stats</B>

から)
受け取った場合に、統計を追加書き込みするファイルへのパス名です。
指定されていない場合のデフォルトは、
named.stats

です。
</DL>
<P>

<P>
<A NAME="lbAS">&nbsp;</A>
<H3>ブール値のオプション</H3>

<P>
<DL COMPACT>
<P>

<DT><B>auth-nxdomain</B>


<DD>
これが
<B>yes</B>

の場合、
<B>AA</B>

ビットは、常に
<B>NXDOMAIN</B>

の応答にセットされます。たとえサーバが実際には信頼できるものでは
なくてもです。
デフォルトでは、
<B>yes</B>

になっています。
古くからあるソフトウェアが嫌うので、
自分のしていることに確信が持てないでいるのであれば、
<B>auth-nxdomain</B>

をオフにしてはいけません。
<P>
<DT><B>deallocate-on-exit</B>


<DD>
これが
<B>yes</B>

の場合には、サーバは、終了時に自分が確保したオブジェクトを
徹底して開放して、
<B>memstatistics-file</B>

にメモリ使用レポートを書き出します。
デフォルトでは、
<B>no</B>

になっています。なぜなら、オペレーティングシステムにクリーンアップを
やらせたほうが高速だからです。
<B>deallocate-on-exit</B>

は、メモリリークを検出するために便利です。
<P>
<DT><B>dialup</B>


<DD>
これが
<B>yes</B>

の場合には、サーバは、すべてのゾーンを、
要求時ダイヤルによるダイヤルアップリンクを通して
ゾーン転送を行っているかのように扱います。
このダイヤルアップリンクは、このサーバから通信が始まった場合に
立ち上げられるものです。
これは、ゾーンの種類によって異なる効果をもたらし、ゾーンの保守に
専念できるようになります。これによって、
<B>heartbeat-interval</B>

ごとに 1 度、願わくは、1 回の呼び出しの間という短い間隔で
ゾーンの保守を行えるようになります。
このオプションはまた、通常のゾーン保守にかかるトラフィックを
いくらか抑えることもできます。
デフォルトは、
<B>no</B>

です。
<B>dialup</B>

オプションは、
<B>zone</B>

ステートメント中でも指定することができます。この場合は、
<B>options dialup</B>

ステートメントは上書きされます。
<P>
<P>

ゾーンが
<B>master</B>

である場合、
サーバは、すべてのスレーブに対して
<B>NOTIFY</B>

リクエストを送信するようになります。
これによって、スレーブをチェックし、呼び出しが生きている間に
スレーブがゾーンを検証できるようにすることで、
ゾーンを最新のものにする契機ができます (サーバが
<B>NOTIFY</B>

をサポートする場合です)。
<P>
<P>

ゾーンが
<B>slave</B>

もしくは
<B>stub</B>

である場合、
サーバは、通常のゾーンのアップデート問い合わせを抑制し、
<B>heartbeat-interval</B>

が時間切れになったときだけ問い合わせるようにします。
<P>
<DT><B>fake-iquery</B>


<DD>
これが
<B>yes</B>

の場合、
サーバは、
<B>IQUERY</B>

という、もう古くなって使われていない DNS 問い合わせをシミュレーション
します。
デフォルトは
<B>no</B>

です。
<P>
<DT><B>fetch-glue</B>


<DD>
これが
<B>yes</B>

の場合 (デフォルトではそうです)、サーバは、追加の応答用データセクションを
作る際には持っていない「糊」となるリソースレコードを取得します。
サーバのキャッシュが大きくなったり、破壊されたりしないようにするため
(こうなると、クライアントからもっと多くの仕事を要求されるという
代償を払うことになります)、
<B>fetch-glue no</B>

は、
<B>recursion no</B>

と一緒に使用できます。
<P>
<DT><B>has-old-clients</B>


<DD>
このオプションを
<B>yes</B>

に設定することと、次の 3 つのオプションを設定することとは等価です :
<B>auth-nxdomain yes ;,</B>

<B>maintain-ixfr-base yes ;,</B>

<B>rfc2308-type1 no</B>

 
<B>has-old-clients</B>

を
<B>auth-nxdomain</B>

 
<B>maintain-ixfr-base</B>

 
<B>rfc2308-type1</B>

と一緒に使用することで起こることは、指定の順番によります。
<P>
<DT><B>host-statistics</B>


<DD>
これが
<B>yes</B>

である場合、
ネームサーバと相互に作用する各ホストに対して統計が保持されます。
デフォルトでは
<B>no</B>

です。
<I>注</I>

 
<B>host-statistics</B>

をオンにすると、膨大な量のメモリを消費する可能性があります。
<P>
<DT><B>IC host-statistics-max</B>
<DD>
保持する最大のホストレコード数です。
この限界に達っすると、ホストの統計情報に新規ホストは追加されません。
0 に設定すると、限界はありません。
デフォルト値は 0 です。
<P>
<DT><B>maintain-ixfr-base</B>


<DD>
これが
<B>yes</B>

の場合、すべての動的に更新されるゾーンに対して、
単一の IXFR データベースファイルが保持されます。
これを有効にすると、
ゾーン転送を非常に高速化可能な IXFR 問い合わせに、サーバは答えます。
デフォルトは
<B>no</B>

です。
<P>
<DT><B>multiple-cnames</B>


<DD>
これが
<B>yes</B>

である場合、
1 つのドメイン名について複数の CNAME リソースレコードか許可されます。
デフォルトは
<B>no</B>

です。複数の CNAME レコードを許可するということは、標準からは
外れており、推奨されることではありません。
以前のバージョンの BIND が複数の CNAME レコードを持つことを許しており、
このレコードがいくつかのサイトでは負荷のバランスを取るために
使用されていたことから、複数の CNAME のサポートを利用できるということです。
<P>
<DT><B>notify</B>


<DD>
これが
<B>yes</B>

である場合 (それがデフォルトです)、
変更を行うためにゾーンサーバが信頼できる場合に DNS NOTIFY メッセージを
送るようになります。
NOTIFY を使用すると、マスタサーバとそのスレーブとの間の収束が
早まります。NOTIFY メッセージを受け取り、理解するスレーブサーバは
そのゾーン用にマスタサーバに接続し、ゾーン転送を行う必要があるかを
点検します。そして、必要がある場合は直ちにゾーン転送を開始します。
<B>notify</B>

オプションは
<B>zone</B>

ステートメント内でも指定できます。この場合は、
<B>options notify</B>

ステートメントは上書きされます。
<P>
<DT><B>recursion</B>


<DD>
これが
<B>yes</B>

であり、
DNS の問い合わせが再帰処理を要求している場合、
サーバはその問い合わせに答えるために必要な仕事をすべて行おうとします。
recursion がオンになっていない場合、サーバが答えを
知らない場合は、サーバはクライアントに照会を返します。デフォルトでは、
<B>yes</B>

です。前述の
<B>fetch-glue</B>

も参照してください。
<P>
<DT><B>rfc2308-type1</B>


<DD>
これが
<B>yes</B>

であれば、サーバは、否定応答用に SOA レコードと一緒に NS レコードを
送ります。もし、古い BIND サーバを持っていて、
SOA と NS の両方を含んだ否定応答を理解しないフォワード用サーバとして使用して
いる場合や、古いバージョンの sendmail を持っている場合は、この
オプションを no に設定する必要があります。正しい解決策は、
そういう壊れたサーバや sendmail を使用しないことです。デフォルトでは、
このオプションは
<B>no</B>

です。
<P>
<DT><B>use-id-pool</B>


<DD>
これが
<B>yes</B>

であれば、サーバは自分自身の未解決の問い合わせ ID を追跡して、
重複を避け、ランダム性を高めるようにします。これによって、
サーバが 128 KB も多くメモリを消費するようになります。
デフォルトは
<B>no</B>

です。
<P>
<DT><B>treat-cr-as-space</B>


<DD>
これが
<B>yes</B>

の場合、
サーバは、スペースやタブを扱うのと同じ方法で CR 文字を扱うように
なります。NT あるいは DOS マシンで生成したゾーンファイルを
UNIX システム上にロードするときに、このオプションは必要でしょう。
デフォルトでは、このオプションは
<B>no</B>

です。
<P>
<P>
</DL>
<P>

<P>
<A NAME="lbAT">&nbsp;</A>
<H3>Also-Notify</H3>

<P>
<B>also-notify</B>

<P>
ゾーンの新しいコピーがロードされるときはいつでも送信された
NOTIFY メッセージも受け取る IP アドレスのグローバルリストを定義します。
このオプションは、ゾーンのコピーが素早く「内密の」サーバ上で確実に収束
する助けになります。
<B>also-notify</B>

リストが
<B>zone</B>

ステートメントで与えられた場合、
<B>options also-notify</B>

ステートメントは上書きされます。
<B>zone notify</B>

ステートメントが
<B>no</B>

に設定されている場合、
グローバルの
<B>also-notify</B>

リストの IP アドレスは、このゾーンに対する NOTIFY メッセージを
送信されません。デフォルトでは、このリストは空です
(グローバルな notification リストはないということです)。
<P>
<A NAME="lbAU">&nbsp;</A>
<H3>フォワード</H3>

<P>
<P>

フォワード機能は、少数のサーバ上で大きなサイト単位のキャッシュを作成する
ために使用することができます。これによって、外部のネームサーバへの
リンクを越えたトラフィックを軽減できます。フォワード機能は、直接
インターネットに接続できないが、ともかく外部のホスト名を見つけ出したい
というサーバの問い合わせを許可するためにも使用できます。
フォワードが発生するのは、そうした問い合わせに対してサーバが
権限を持たず、キャッシュにその応答が入っていない場合だけです。
<P>
<DL COMPACT>
<P>

<DT><B>forward</B>


<DD>
このオプションは、
<B>forwarders</B>

リストが空でない場合にだけ意味があります。
<B>first</B>

という値がデフォルトですが、このときサーバは、まずフォワードを行うサーバに
問い合わせを行い、フォワードを行うサーバが要求に対して応答しない場合、
自分で応答を探します。
<B>only</B>

が指定された場合、サーバは、ただフォワードを行うサーバに問い合わせを
行うだけです。
<P>
<DT><B>forwarders</B>


<DD>
フォワードを行うために使用される IP アドレスを指定します。デフォルトでは、
これは空のリストです (フォワードを行いません)。
</DL>
<P>

<P>
<P>

フォワード機能は、ゾーン単位をもとにして設定することもできます。
このときは、グローバルのフォワード用オプションが、さまざまな方法で
上書きできるようになります。
特定のゾーンに対し、
別のフォワード用サーバを使用したり、別の
<B>forward only/first</B>

の振るまいをもたせたり、あるいはまったくフォワードしなかったり
できます。
さらなる情報については、
Sx ゾーンステートメント

のセクションを参照してください。
<P>
<P>

BIND 8 の将来のバージョンでは、もっと強力なフォワード用システムを
提供する予定です。先に述べた文法は引き続きサポートされる予定です。
<P>
<A NAME="lbAV">&nbsp;</A>
<H3>ネームチェック</H3>

<P>
サーバは、期待するクライアントの関係に基づいてドメイン名をチェックできます。
例えば、ホスト名として使用されるドメイン名は、正当なホスト名を
定義している RFC に準拠するかという点でチェックされます。
<P>
<P>

チェック方法には 3 通りのやり方が利用可能です :
<P>
<DL COMPACT>
<P>

<DT><B>ignore</B>


<DD>
何のチェックも行われません。
<P>
<DT><B>warn</B>


<DD>
期待するクライアントの関係から名前をチェックします。不正な名前は
ログに書かれますが、処理は普通に継続します。
<P>
<DT><B>fail</B>


<DD>
期待するクライアントの関係から名前をチェックします。不正な名前は
ログに書かれ、ルールに合わないデータは拒否されます。
</DL>
<P>

<P>
<P>

サーバは、名前を 3 つのエリアでチェックできます : マスタゾーンファイル、
スレーブゾーンファイル、そして、サーバが発行した問い合わせへの応答
です。
<B>check-names response fail</B>

が指定されており、クライアントの問い合わせに対する応答が
クライアントに不正な名前を送る必要のあるものであった場合、
サーバは、
<B>REFUSED</B>

応答コードをクライアントに送ります。
<P>
<P>

デフォルトは、次の通りです :
<P>

<PRE>
    check-names master fail;
    check-names slave warn;
    check-names response ignore;
</PRE>

<P>
<P>

<B>check-names</B>

は、
<B>zone</B>

ステートメントでも指定できます。この場合、
<B>options check-names</B>

は上書きされます。
<B>zone</B>

ステートメントで使用した場合、
エリアは指定されません (なぜなら、ゾーンの種類からエリアは推測できる
からです)。
<P>
<A NAME="lbAW">&nbsp;</A>
<H3>アクセス制御</H3>

<P>
<P>

サーバへのアクセスは、アクセスを要求したシステムの IP アドレス
または共有秘密鍵に基づいて制限することができます。
アクセス基準をどのように指定するかについての詳細は、
Sx アドレスマッチリスト

を参照してください。
<P>
<DL COMPACT>
<P>

<DT><B>allow-query</B>


<DD>
どのホストが通常の問い合せをすることができるかを指定します。
<B>allow-query</B>

は、
<B>zone</B>

ステートメントでも指定できます。この場合、
<B>options allow-query</B>

ステートメントを上書きします。もし、allow-query オプションが
指定されていない場合は、デフォルトは、
すべてのホストからの問い合わせを許可します。
<P>
<DL COMPACT>
<P>

<DT><B>allow-recursion</B>


<DD>
どのホストが再帰的な問い合わせが可能かを指定します。
指定されていない場合は、
デフォルトでは全てのホストから再帰的な問い合わせができます。
<P>
<DT><B>allow-transfer</B>


<DD>
どのホストがゾーン転送をサーバから受け取ることを許可されるかを
指定します。
<B>allow-transfer</B>

は、
<B>zone</B>

ステートメントでも指定できます。その場合、
<B>options allow-transfer</B>

ステートメントは上書きされます。もし、allow-transfer オプションが
指定されていない場合は、デフォルトでは、
すべてのホストからの転送を許可します。
<P>
<DT><B>blackhole</B>


<DD>
サーバが問い合わせを受け取らないようになったり、問い合わせを解決するために
使用しないようになるアドレスのリストを指定します。これらのアドレスからの
問い合わせは、応答されることはありません。
</DL>
<P>

</DL>
<P>

<P>
<A NAME="lbAX">&nbsp;</A>
<H3>インタフェース</H3>

<P>
<P>

サーバが問い合わせに答えるインタフェースならびにポートは、
<B>listen-on</B>

オプションを使って指定することができます。
<B>listen-on</B>

は、オプションのポートおよびアドレスマッチリストを取ります。
サーバは、アドレスマッチリストで許可されたインタフェース全てで待機します。
ポートを指定しない場合は、53 番ポートが使われます。
<P>
<P>

<B>listen-on</B>

ステートメントが複数あっても良いです。例えば、
<P>

<PRE>
    listen-on { 5.6.7.8; };
    listen-on port 1234 { !1.2.3.4; 1.2/16; };
</PRE>

<P>
では、IP アドレスが 5.6.7.8 のマシン用にネームサーバに 53 番ポートの使用を
許可し、1234 番ポートを 1.2 のネットワークにいて、IPアドレスが 1.2.3.4 ではない
マシンに使用を許可します。
<P>
<P>

<B>listen-on</B>

が指定されていない場合は、サーバは、すべてのインタフェース上で 53 番ポートでの
待機をします。
<P>
<A NAME="lbAY">&nbsp;</A>
<H3>問い合わせアドレス</H3>

<P>
<P>

サーバが問い合わせに対する答を知らない場合、そのサーバは、他の
ネームサーバに問い合わせを行います。
<B>query-source</B>

は、こうした問い合わせに使用されるアドレスおよびポートを指定します。
<B>address</B>

が
<B>*</B>

だったり、省略されている場合、ワイルドカード IP アドレス
(
<B>INADDR_ANY</B>

)
が使用されます。
<I>port</I>

が
<B>*</B>

だったり、省略されている場合、特権のいらないポートがランダムに
使用されます。デフォルトでは

<BLOCKQUOTE><TT>query-source address * port *;</TT></BLOCKQUOTE>
です。
<P>

注 :
<B>query-source</B>

は、現在 UDP 問い合わせのみ適用されます。
TCP 問い合わせには、常にワイルドカード IP アドレスとランダムに選ばれた
特権のいらないポートが使用されます。
<P>
<A NAME="lbAZ">&nbsp;</A>
<H3>ゾーン転送</H3>

<P>
<DL COMPACT>
<P>

<DT><B>max-transfer-time-in</B>


<DD>
ここで指定された時間より長く動作している内部へのゾーン転送 (
<B>named-xfer</B>

プロセス)
を終了します。
デフォルトでは、120 分 (2 時間) です。
<P>
<DT><B>transfer-format</B>


<DD>
サーバは 2 種類のゾーン転送方法をサポートしています。
<B>one-answer</B>

転送されるリソースレコードそれぞれについて 1 つの DNS メッセージを使用します。
<B>many-answers</B>

できるだけ多くのリソースレコードを 1 つのメッセージに押し込みます。
<B>many-answers</B>

の方が効率的ではありますが、BIND 8.1 および、パッチの当たった BIND 4.9.5 でのみ
理解されるものです。デフォルトでは、
<B>one-answer</B>

になります。
<B>transfer-format</B>

は、
<B>server</B>

ステートメントを使用してサーバ単位で上書きすることができます。
<P>
<DT><B>transfers-in</B>


<DD>
同時に動作させることのできる内部へのゾーン転送の最大値です。
デフォルトは 10 です。
<B>transfers-in</B>

の数を増やすと、スレーブのゾーンの収束が早まりますが、ローカルシステムの負荷も
上がってしまう恐れがあります。
<P>
<DT><B>transfers-out</B>


<DD>
このオプションは、将来、
同時に動作する外部へのゾーン転送数を制限するために使用する
予定です。現在、文法はチェックしていますが、それ以上のことは無視しています。
<P>
<DT><B>transfers-per-ns</B>


<DD>
あるリモートのネームサーバから同時に実行できる内部へのゾーン転送 (
<B>named-xfer</B>

プロセス) の最大値です。デフォルトは 2 です。
<B>transfers-per-ns</B>

の数を増やすと、スレーブゾーンの収束は早まりますが、リモートのネームサーバの
負荷が上がってしまう恐れがあります。
<B>transfers-per-ns</B>

は、
<B>server</B>

ステートメントの
<B>transfers</B>

フレーズを使用してサーバ単位で上書きすることができます。
<P>
<DT><B>transfer-source</B>


<DD>
<B>transfer-source</B>

は、サーバが内部に転送するゾーンをすべて取得するために使用される
TCP コネクションと
どのローカルアドレスとが結びつけられるかを決定します。
これが設定されていない場合、
システムが制御しているデフォルト値に設定されます。
この値は、通常、
リモート側の終端に「最も近い」インタフェースのアドレスになります。
このアドレスは、もし指定されているのなら、リモート側の終端の転送ゾーン用の
<B>allow-transfer</B>

オプションで登場していなくてはなりません。
このステートメントは、すべてのゾーンの
<B>transfer-source</B>

を設定しますが、設定ファイル中のゾーンブロック内に
<B>transfer-source</B>

ステートメントを含めることでゾーン単位で上書きすることができます。
</DL>
<P>

<P>
<A NAME="lbBA">&nbsp;</A>
<H3>リソースの制限</H3>

<P>
<P>

多種のシステムリソースをサーバがどこまで使用してよいか制限可能です。
オペレーティングシステムによっては、
この制限をいくつかサポートしていないものもあります。
そうしたシステムでは、サポートされていない制限を使用すると警告が発生します。
また、オペレーティングシステムによっては、
リソース制限自体をサポートしていないものも
あります。そうしたシステムでは、

というメッセージがログに記録されます。
<P>
<P>

リソース制限を指定する際には、スケールを変えた値を使用することができます。
例えば、1 ギガバイトの制限を指定したい場合に、
<B>1G</B>

を
<B>1073741824</B>

の代わりに使用することができます。
<B>unlimited</B>

は、無制限にリソースを使用する、
つまり、利用可能な最大の量のリソースを要求します。
<B>default</B>

は、サーバが開始したときに有効だった制限値を使用します。
詳細については、
Sx 記述方法の定義

のセクションの
<I>size_spec</I>

の項を参照してください。
<P>
<DL COMPACT>
<P>

<DT><B>coresize</B>


<DD>
コアダンプの最大サイズです。デフォルト値は
<B>default</B>

です。
<P>
<DT><B>datasize</B>


<DD>
サーバが使用できるデータメモリの最大領域です。デフォルト値は
<B>default</B>

です。
<P>
<DT><B>files</B>


<DD>
サーバが同時にオープンできるファイルの最大数です。デフォルト値は
<B>unlimited</B>

です。オペレーティングシステムによっては、unlimited という値を設定できず、
カーネルがサポートできるオープンするファイルの最大値を
決定できないものがあることに
注意してください。こうしたシステムでは、
<B>unlimited</B>

を選択すると、サーバが
Fn getrlimit RLIMIT_NOFILE

から得られる
<I>rlim_max</I>

の値よりも大きなファイル数を扱ってしまい、
Fn sysconf _SC_OPEN_MAX

を返してしまうことになります。
実際のカーネルの制限値がこの値よりも大きい場合は、
<B>limit files</B>

を使用して、明示的に制限値を指定してください。
<P>
<DT><B>max-ixfr-log-size</B>


<DD>
<B>max-ixfr-log-size</B>

は、将来のサーバのリリースでは、インクリメンタルゾーン転送用に保持しておく
トランザクションログの大きさに制限を設けるために使用する予定です。
<P>
<DT><B>stacksize</B>


<DD>
サーバが使用できるスタックメモリの最大量です。デフォルト値は
<B>default</B>

です。
</DL>
<P>

<P>
<A NAME="lbBB">&nbsp;</A>
<H3>定期的なタスクの間隔</H3>

<P>
<DL COMPACT>
<P>

<DT><B>cleaning-interval</B>


<DD>
サーバは、
<B>cleaning-interval</B>

分ごとに期限の切れたリソースレコードをキャッシュから削除します。
デフォルトは 60 分です。これが 0 に設定されているときは、
定期的にキャッシュがクリーニングされることはありません。
<P>
<DT><B>heartbeat-interval</B>


<DD>
サーバは、この間隔が過ぎればいつでも
<B>dialup yes</B>

の印のついたゾーンすべてに対してゾーン管理タスクを実行します。
デフォルトでは 60 分です。適切な値は 1 日 (1440 分) までです。
この値が 0 に設定されている場合、
これらのゾーンに対するゾーン管理は実行されません。
<P>
<DT><B>interface-interval</B>


<DD>
サーバは、
<B>interface-interval</B>

分ごとにネットワークインタフェースリストをスキャンします。
デフォルトでは 60 分です。
この値が 0 に設定されている場合、
インタフェースのスキャンを行うのは、設定ファイルが
ロードされたときだけです。スキャンした後、待機タスク (listener) は、どの
新しいインタフェース上でも始動します (そのタスクが
<B>listen-on</B>

の設定がされていて許可されている場合です)。
取り除かれたインタフェース上で動作している待機タスクは、消去されます。
<P>
<DT><B>statistics-interval</B>


<DD>
ネームサーバの統計が
<B>statistics-interval</B>

分ごとにログに記録されます。デフォルトは 60 です。
この値が 0 に設定されている場合、
何の統計も記録されません。
</DL>
<P>

<P>
<A NAME="lbBC">&nbsp;</A>
<H3>トポロジ</H3>

<P>
<P>

ネームサーバのリストから問い合わせ先のネームサーバをサーバが 1 つ選ぶとき、
他の点ではすべて対等である場合、このサーバは、
自分自身からトポロジ的に最も近いものを選びます。
<B>topology</B>

ステートメントは、アドレスマッチリストをとり、
特別な方法でそのリストを解釈します。
それぞれの一番上のリスト要素は距離が割り当てられています。
無効にされていない要素は、リスト中の位置に基づいて距離を取得します。ここで、
リストの先頭にマッチした地点が近ければ近いほど、サーバと要素との距離が
近いことになります。
無効にされているマッチには、サーバからの距離の最大が割り当てられます。
マッチするものがない場合は、そのアドレスは、無効にされていないリストの要素の
どれよりも遠い距離を取得します。例えば、
<P>

<PRE>
    topology {
        10/8;
        !1.2.3/24;
        { 1.2/16; 3/8; };
    };
</PRE>

<P>
の場合では、ネットワーク 10 上のサーバが最も好ましいものになります。
次が、ネットワーク
1.2.0.0 (ネットマスクが 255.255.255.0) 上のホスト
およびネットワーク 3 上のホストですが、
ネットワーク 1.2.3 (ネットマスクが 255.255.255.0) 上のホストは除外されます。
このネットワーク上のものは、どれよりも選ばれにくいものです。
<P>
<P>

デフォルトのトポロジは

<BLOCKQUOTE><TT>topology { localhost; localnets; };</TT></BLOCKQUOTE>
です。
<P>
<A NAME="lbBD">&nbsp;</A>
<H3>リソースレコードのソート</H3>

<P>
<P>

複数の RR (訳注: リソースレコード) が返ってくると、通常ネームサーバは、
<B>ラウンドロビン</B>

でそれらを返します。
すなわち、各要求の後に、最初の RR がリストの最後に置かれます。
RR の順番が決まっていないので、これで問題ありません。
<P>
クライアントのリゾルバのコードが、これらの RR を適切に
構成しなおさなくてはなりません。すなわち、他のアドレスよりも、
ローカルネット上の任意のアドレスを優先して使用するということです。
しかしながら、すべてのリゾルバがこうすることができたり、
適切に設定されているわけではありません。
<P>
クライアントがローカルサーバを使用しているとき、サーバ内で、クライアントの
アドレスに基づいたソートが実行できます。このソートのためには、
ただネームサーバを設定するだけでよく、すべてのクライアントを設定する
必要はありません。
<P>
<B>sortlist</B>

ステートメントは、アドレスマッチリストをとり、
<B>topology</B>

ステートメントより更に増した特別な方法でリストを解釈します。
<P>
ソートリスト中の各先頭のステートメントは、
それ自身、1 つまたは 2 つの要素を持った
明示的なアドレスマッチリストでなくてはなりません。各先頭のリストの最初の要素
(IP アドレス、IP のプレフィックス、ACL 名、
あるいはネストされたアドレスマッチリスト)
に対し、マッチが見つかるまで、問い合わせ元のアドレスをチェックします。
<P>
ひとたび問い合わせ元のアドレスがマッチしたなら、
先頭のステートメントがただ 1 つの要素のみの場合、
問い合わせ元のアドレスとマッチした要素そのものが
応答のアドレスを選択するために使用され、それが応答の先頭に移動します。
ステートメントが 2 つの要素を持ったリストであった場合、2 番目の要素は、
topology ステートメントのアドレスマッチリストのように扱われます。
各先頭要素には、
距離が割り当てられており、最も短い距離を持った応答中のアドレスが、
その応答の先頭に移動されます。
<P>
次の例では、ホストそれ自身のアドレスから受け取った問い合わせは、
ローカルに接続された
ネットワーク上のアドレスを優先するような応答を受け取ります。
次に優先されるのが、
192.168.1/24 ネットワーク上のアドレスで、その後に、192.168.2/24 あるいは
192.168.3/24 ネットワークがきます。
最後の 2 つのネットワーク間にはどちらが優先かは示されていません。
192.168.1/24 ネットワーク上のホストから受け取った問い合わせは、
そのネットワーク上の他のアドレスを 192.168.2/24 および 192.168.3/24
ネットワークよりも優先します。
192.168.4/24 あるいは 192.168.5/24 ネットワーク上の
ホストから受け取った問い合わせは、
直接接続されたネットワーク上のアドレスを優先する
だけです。
<P>

<PRE>
sortlist {
           { localhost;         // もし   ローカルホストなら
             { localnets;       //    次のネット上で
               192.168.1/24;    //    最初にフィットしたものにする
               { 192,168.2/24; 192.168.3/24; }; }; };
           { 192.168.1/24;      // もし   クラス C 192.168.1 上なら
             { 192.168.1/24;    //     .1 あるいは、.2 か .3 を使用する
               { 192.168.2/24; 192.168.3/24; }; }; };
           { 192.168.2/24;      // もし   クラス C 192.168.2 上なら
             { 192.168.2/24;    //     .2 あるいは、.1 か .3 を使用する
               { 192.168.1/24; 192.168.3/24; }; }; };
           { 192.168.3/24;      // もし   クラス C 192.168.3 上なら
             { 192.168.3/24;    //     .3 あるいは、.1 か .2 を使用する
               { 192.168.1/24; 192.168.2/24; }; }; };
           { { 192.168.4/24; 192.168.5/24; }; // .4 か .5 なら
           };                                 // そのネットを優先する
};
</PRE>

<P>
次の例は、ローカルホストおよび直接接続されたネットワーク上のホストに対する、
理にかなった振るまいを提供するものです。
これは、BIND 4.9.x でのアドレスのソートの振るまいと
似ています。ローカルホストからの問い合わせに対して送られた応答は、
直接接続された
ネットワーク上のホストを優先します。
他の直接接続されたネットワーク上のホストからの
問い合わせに対して送られた応答は、
同じネットワーク上のアドレスを優先するでしょう。
その他の問い合わせに対する応答についてはソートされません。
<P>

<PRE>
sortlist {
            { localhost; localnets; };
            { localnets; };
};
</PRE>

<P>
<A NAME="lbBE">&nbsp;</A>
<H3>RRset の順番付け</H3>

<P>
<P>

応答中に複数のレコードが返されている場合、
その応答中にレコードがどの順番で置かれるかを
設定するのが有益なことがあります。
例えば、あるゾーンに対するレコードは、ゾーンファイルで
定義された順番で常に返されるように設定されるかもしれません。
あるいは、
レコードが返されるときにランダムにシャッフルされるようにしたいということも
あるでしょう。
rrset-order ステートメントを使用すると、
複数レコードが含まれる応答中のレコードの順番を
設定することができます。順番が定義されていない場合、デフォルトでは、巡回順
(ラウンドロビン) になります
<P>
<B>order_spec</B>

は次のように定義されています :
<P>

<PRE>
  [ <I>class class_name</I> ][ <I>type type_name</I> ][ <I>name</I> &quot;FQDN&quot; ] <I>order</I> ordering
</PRE>

<P>
クラスが指定されていない場合、デフォルトは
<B>ANY</B>

です。
<B>Ictype</B>

が指定されていない場合、デフォルトは
<B>ANY</B>

です。
名前が指定されていない場合、デフォルトは &quot;*&quot; です。
<P>
<B>ordering</B>

の正当な値には、次のようなものがあります :
<P>

<PRE>
<B>fixed</B>
     レコードは、ゾーンファイルで定義された順番で返されます。
<B>random</B>
     レコードは、ある種のランダムな順番で返されます。
<B>cyclic</B>
     レコードは、ラウンドロビンに返されます。

例えば、

    rrset-order {
        class IN type A name &quot;rc.vix.com&quot; order random;
        order cyclic;
    };
</PRE>

<P>
では、サフィックスに &quot;rc.vix.com&quot; を持ち、
クラス IN でタイプ A のレコードに対する
応答は、常にランダムな順番で返されます。
その他のレコードはすべて巡回順に返されます。
<P>
<B>rrset-order</B>

ステートメントが複数現れた場合、ステートメントは連結されません。
最後のものが適用されます。
<P>
<B>rrset-order</B>

ステートメントが指定されていない場合、デフォルトは
<P>

<PRE>
    rrset-order { class ANY type ANY name &quot;*&quot; order cyclic ; };
</PRE>

<P>
が使われます。
<P>
<A NAME="lbBF">&nbsp;</A>
<H3>チューニング</H3>

<P>
<DL COMPACT>
<P>

<DT><B>lame-ttl</B>


<DD>
不完全なサーバの指示をキャッシュしておく秒数を設定します。
0 の場合、キャッシュしません。
デフォルトは 600 (10 分) です。最大値は 1800 (30 分) です。
<DT><B>max-ncache-ttl</B>


<DD>
ネットワークの負荷を軽減しパフォーマンスを上げるために、
サーバが否定応答を蓄えます。
<B>max-ncache-ttl</B>

は、サーバで、このような応答の最大保存時間を設定するために使います。
秒単位です。

デフォルトの
<B>max-ncache-ttl</B>

は 10800 秒 (3 時間) です。
<B>max-ncache-ttl</B>

通常の (肯定) 応答に対しては、最大保存時間を超えてはいけません (7 日)。
もし、この値が 7 日以上に設定されていた場合、
黙って 7 日に切り詰めてしまうでしょう。
<DT><B>min-roots</B>


<DD>
ルートサーバに対する要求を受け取るために必要なルートサーバの最小値です。
デフォルトは
2 です。
</DL>
<P>

<P>
<A NAME="lbBG">&nbsp;</A>
<H2>zone ステートメント</H2>

<A NAME="lbBH">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
zone <I>domain_name</I> [ ( in | hs | hesiod | chaos ) ] {
  type master;
  file <I>path_name</I>;
  [ check-names ( warn | fail | ignore ); ]
  [ allow-update { <I>address_match_list</I> }; ]
  [ allow-query { <I>address_match_list</I> }; ]
  [ allow-transfer { <I>address_match_list</I> }; ]
  [ forward ( only | first ); ]
  [ forwarders { [ <I>ip_addr</I> ; [ <I>ip_addr</I> ; ... ] ] }; ]
  [ dialup <I>yes_or_no</I>; ]
  [ notify <I>yes_or_no</I>; ]
  [ also-notify { <I>ip_addr</I>; [ <I>ip_addr</I>; ... ] };
  [ pubkey <I>number</I> <I>number</I> <I>number</I> <I>string</I>; ]
};

zone <I>domain_name</I> [ ( in | hs | hesiod | chaos ) ] {
  type ( slave | stub );
  [ file <I>path_name</I>; ]
  masters [ port <I>ip_port</I> ] { <I>ip_addr</I>; [ <I>ip_addr</I>; ... ] };
  [ check-names ( warn | fail | ignore ); ]
  [ allow-update { <I>address_match_list</I> }; ]
  [ allow-query { <I>address_match_list</I> }; ]
  [ allow-transfer { <I>address_match_list</I> }; ]
  [ forward ( only | first ); ]
  [ forwarders { [ <I>ip_addr</I> ; [ <I>ip_addr</I> ; ... ] ] }; ]
  [ transfer-source <I>ip_addr</I>; ]
  [ max-transfer-time-in <I>number</I>; ]
  [ notify <I>yes_or_no</I>; ]
  [ also-notify { <I>ip_addr</I>; [ <I>ip_addr</I>; ... ] };
  [ pubkey <I>number</I> <I>number</I> <I>number</I> <I>string</I>; ]
};

zone <I>domain_name</I> [ ( in | hs | hesiod | chaos ) ] {
  type forward;
  [ forward ( only | first ); ]
  [ forwarders { [ <I>ip_addr</I> ; [ <I>ip_addr</I> ; ... ] ] }; ]
  [ check-names ( warn | fail | ignore ); ]
};

zone &quot;.&quot; [ ( in | hs | hesiod | chaos ) ] {
  type hint;
  file <I>path_name</I>;
  [ check-names ( warn | fail | ignore ); ]
};
</PRE>

<P>
<A NAME="lbBI">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>zone</B>

ステートメントは、
特定の DNS ゾーンがサーバにどのように管理されるかを指定するために
使われます。ゾーンには 5 つの種類があります。
<P>
<DL COMPACT>
<P>

<DT><B>master</B>


<DD>
サーバは、
そのゾーン用データのマスタコピーを持っていて、ゾーンに対して信頼できる
応答を提供できます。
<P>
<DT><B>slave</B>


<DD>
<B>slave</B>

ゾーンはマスタゾーンの複製です。
<B>masters</B>

リストは、ゾーンの複製を更新するためにスレーブサーバが通信を行う 1 つ以上の
IP アドレスを指定します。
<B>port</B>

が指定されている場合、このポートに対し、
ゾーンが現在使用されているものであることの確認と、
ゾーン転送が行われます。
<B>file</B>

が指定されている場合、
指定されたファイルへゾーンの複製が書き出されます。
<B>file</B>

節を使用することを強く勧めます。
なぜなら、大体においてサーバの起動を早めますし、
通信回線を無駄に使用することを防いでくれるからです。
<P>
<DT><B>stub</B>


<DD>
<B>stub</B>

ゾーンは slave ゾーンのようなものですが、ゾーン全体を複製するのではなく、
マスタゾーンの NS レコードのみを複製するという点が違います。
<P>
<DT><B>forward</B>


<DD>
<B>forward</B>

ゾーンは、自分に向けられた問い合わせを他のサーバに振り分けるために使用します。
このことは、
Sx option ステートメント

のセクションで説明しています。これらのゾーンでのオプション仕様は、
<B>options</B>

ステートメントで宣言されたグローバルオプションを上書きします。
<P>
<P>

<B>forwarders</B>

節が zone ステートメント中に存在しないか、もしくは、
<B>forwarders</B>

に対して空リストが与えられている場合は、
そのゾーンに対してフォワードは行われず、
<B>options</B>

ステートメント中の
<B>forwarders</B>

は、すべて効力を失います。そのため、使用されるサーバではなく、グローバルの
<B>forward</B>

オプションの挙動を変更するためだけにこの種類のゾーンを使用したいのであれば、
グローバルの forwarders 節も指定しなおす必要があります。
<P>
<DT><B>hint</B>


<DD>
ルートネームサーバの初期集合は、
<B>hint</B>

ゾーンを使用して指定されます。サーバが起動する際に、ルートヒントを使用して
ルートネームサーバを見つけ、ルートネームサーバの最新リストを取得します。
</DL>
<P>

<P>
<P>

注 : 以前の BIND リリースでは、マスタゾーンに対しては
<B>primary</B>

という用語を使用し、スレーブゾーンに対しては、
<B>secondary</B>

を、hint ゾーンに対しては
<B>cache</B>

という用語を使用していました。
<P>
<A NAME="lbBJ">&nbsp;</A>
<H3>クラス</H3>

<P>
ゾーン名には、オプションでクラスを続けることができます。
もし、クラスが指定されていない場合は、
<B>in</B>

クラス
(「インターネット」用) であると仮定されます。これは、大半の場合正しいです。
<P>
<P>

<B>hesiod</B>

クラスは、MIT の Project Athena 由来の情報サービス用のクラスです。
このクラスは、ユーザ、グループ、プリンタなどといった、
さまざまなシステムデータベースに
関する情報を共有するために使用されます。さらなる情報は、
<A HREF="ftp://athena-dist.mit.edu/pub/ATHENA/usenix/athena_changes.PS">ftp://athena-dist.mit.edu/pub/ATHENA/usenix/athena_changes.PS</A>
から入手できます。
キーワード
<B>hs</B>

は
<B>hesiod</B>

と同義語です。
<P>
<P>

MIT が開発したもう 1 つのものが、1970 年代半ばに作られた LAN プロトコルである
CHAOSnet です。これは、LISP ステーションや AI コミュニティで使われている
他のハードウェアで、まだ時折見受けられます。CHAOSnet 用のゾーンデータは、
<B>chaos</B>

クラスを使用して指定できます。
<P>
<A NAME="lbBK">&nbsp;</A>
<H3>オプション</H3>

<P>
<DL COMPACT>
<P>

<DT><B>check-names</B>


<DD>
Sx options ステートメント

の
Sx ネームチェック

に関するサブセクションを参照してください。
<P>
<DT><B>allow-query</B>


<DD>
Sx options ステートメント

の
Sx アクセス制御

サブセクションの中の
<B>allow-query</B>

に関する説明を参照してください。
<P>
<DT><B>allow-update</B>


<DD>
どのホストが動的な DNS の更新をサーバに提出するかを指定します。デフォルトは、
どのホストからも更新を許可しないというものです。
<P>
<DT><B>allow-transfer</B>


<DD>
Sx options ステートメント

の
Sx アクセス制御

サブセクションの中の
<B>allow-transfer</B>

に関する説明を参照してください。
<P>
<DT><B>transfer-source</B>


<DD>
<B>transfer-source</B>

どのローカルアドレスが、
このゾーンを取得するために使用される TCP 接続と結びつけられるかを
指定します。
これが設定されていない場合は、システムが制御する値がデフォルトになります。
この値は、通常は、リモート側の終端に「最も近い」インタフェースのアドレスです。
このアドレスは、
もし指定されているのであれば、このゾーンに対するリモート側の終端の
<B>allow-transfer</B>

オプション中に出てこなくてはなりません。
<P>
<DT><B>max-transfer-time-in</B>


<DD>
Sx options ステートメント

の
Sx ゾーン転送

サブセクション中の
<B>max-transfer-time-in</B>

の説明を参照してください。
<P>
<DT><B>dialup</B>


<DD>
Sx options ステートメント

の
Sx ブール値オプション

サブセクション中の
<B>dialup</B>

の説明を参照してください。
<P>
<DT><B>notify</B>


<DD>
Sx options ステートメント

の
Sx ブール値オプション

サブセクション中の
Sx notify

の説明を参照してください。
<P>
<DT><B>also-notify</B>


<DD>
<B>notify</B>

がこのゾーンに対してアクティブである場合のみ
<B>also-notify</B>

は意味を持ちます。
このゾーンに対する DNS NOTIFY メッセージを受け取るマシン群は、
そのゾーン用にリストされた
すべてのネームサーバ (プライマリマスタを除く) と、
<B>also-notify</B>

で指定された IP アドレスからなっています。
<B>also-notify</B>

は
<B>stub</B>

ゾーンに対しては意味を持ちません。デフォルトでは、これは空のリストです。
<P>
<DT><B>forward</B>


<DD>
<B>forward</B>

は、そのゾーンが
<B>forwarders</B>

リストを持っている場合のみ意味を持ちます。
<B>only</B>

値は、先に
<B>forwarders</B>

を試し、応答がなかった場合に検索を失敗させます。
それに対し、
<B>first</B>

は、通常の検索を許可します。
<P>
<DT><B>forwarders</B>


<DD>
ゾーン中で
<B>forwarders</B>

オプションを使用すると、グローバルの forwarders リストが上書きされます。
<B>forward</B>

タイプのゾーン中でこれが指定されていなかった場合は、
このゾーンに対しては
<I>何の</I>

フォワードも行いません。グローバルのオプションは使われないということです。
<P>
<DT><B>pubkey</B>


<DD>
DNSSEC のフラグ、プロトコル、アルゴリズムと、
base-64 でエンコードされた鍵を表す文字列を指定します。
</DL>
<P>

<P>
<A NAME="lbBL">&nbsp;</A>
<H2>acl ステートメント</H2>

<A NAME="lbBM">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
acl <I>name</I> {
  <I>address_match_list</I>
};
</PRE>

<P>
<A NAME="lbBN">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>acl</B>

ステートメントは、名前のついたアドレスマッチリストを生成します。
このステートメントは、プライマリで使用しているアドレスマッチリスト、つまり、
アクセス制御リスト (ACL) からその名前を取得します。
<P>
<P>

アドレスマッチリスト名は、他のところで使用する前に
<B>acl</B>

を使用して定義しなくてはなりません。ファイルの前方への参照は許されていません。
<P>
<P>

次のような組み込みの ACL があります :
<P>
<DL COMPACT>
<P>

<DT><B>any</B>


<DD>
すべてのホストを許可します。
<DT><B>none</B>


<DD>
すべてのホストを拒否します。
<DT><B>localhost</B>


<DD>
システム上のすべてのインタフェースの IP アドレスを許可します。
<DT><B>localnets</B>


<DD>
システムがインタフェースを持ったネットワーク上のすべてのホストを許可します。
</DL>
<P>

<P>
<A NAME="lbBO">&nbsp;</A>
<H2>key ステートメント</H2>

<A NAME="lbBP">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
key <I>key_id</I> {
  algorithm <I>algorithm_id</I>;
  secret <I>secret_string</I>;
};
</PRE>

<P>
<A NAME="lbBQ">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>key</B>

ステートメントは、鍵の ID を指定します。この ID は、
<B>server</B>

ステートメントで使用され、単純な IP アドレスでのマッチングよりも厳格な
特定のネームサーバと認証方法とを関連づけます。
鍵の ID は、
<B>server</B>

の定義やアドレスマッチリスト中で使用される前に
<B>key</B>

ステートメントを使用して作成されていなくてはなりません。
<P>
<P>

<I>algorithm_id</I>

は、セキュリティ / 認証アルゴリズムを指定する文字列です。
<I>secret_string</I>

は、指定されたアルゴリズムが使用する秘密の鍵で、
base-64 でエンコードされた文字列として扱われます。
言わずとも当然のことですが、為念指摘しておくと、
named.conf

中に
<I>secret_string</I>

を入れている場合、
named.conf をスーパユーザ以外の誰にも読み込み可能にしてはいけません。
<P>
<A NAME="lbBR">&nbsp;</A>
<H2>trusted-keys ステートメント</H2>

<A NAME="lbBS">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
trusted-keys {
  [ <I>domain_name</I> <I>flags</I> <I>protocol</I> <I>algorithm</I> <I>key</I>; ]
};
</PRE>

<P>
<A NAME="lbBT">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>trusted-keys</B>

ステートメントは、もともと、RFC 2065 で仕様が決められている DNSSEC スタイルの
セキュリティとともに使用されます。DNSSEC は、
3 つの異なったサービスを提供するものです :
それは、鍵の配布、データの発生元の認証、
そして、トランザクションおよび要求の認証です。DNSSEC についての完全な説明と
このドキュメントの範囲を超えた使い方を知りたい場合、
そして、読者がさらなる情報に
興味がある場合は、まず、RFC2065 を読むことから始めてください。そして、
<A HREF="http://www.ietf.org/ids.by.wg/dnssec.html">http://www.ietf.org/ids.by.wg/dnssec.html</A> から入手できるインターネット
ドラフトへと続いてください。
<P>
<P>

信頼された鍵はそれぞれ、ドメイン名と関連づけられています。その属性は、
非負の整数値である、
<I>flags</I>

 
<I>protocol</I>

 
<I>algorithm</I>

と、
<I>key</I>

を表す base-64 でエンコードされた文字列です。
<P>
<P>

信頼された鍵の番号はすべて指定可能です。
<P>
<A NAME="lbBU">&nbsp;</A>
<H2>server ステートメント</H2>

<A NAME="lbBV">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
server <I>ip_addr</I> {
  [ bogus <I>yes_or_no</I>; ]
  [ transfers <I>number</I>; ]
  [ transfer-format ( one-answer | many-answers ); ]
  [ keys { <I>key_id</I> [ <I>key_id</I> ... ] }; ]
};
</PRE>

<P>
<A NAME="lbBW">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
server ステートメントは、リモートのネームサーバに関連付けられる
特徴を定義します。
<P>
<P>

サーバが間違ったデータを送っていることに気がついた場合、そのサーバを
<B>bogus</B>

にすることで、そのサーバへの問い合わせを抑止することができます。
<B>bogus</B>

のデフォルト値は
<B>no</B>

です。
サーバに
<B>bogus</B>

の印を付けると、当該サーバのアドレスを名前で検索してマッチしたときに、
当該サーバに対する他のアドレスもすべて
<B>bogus</B>

の印を付けます。
<P>
<P>

サーバは、2 つのゾーン転送方式をサポートしています。1 つ目は、
<B>one-answer</B>

であり、
これは、転送される各リソースレコードに 1 つの DNS メッセージを使用します。
<B>many-answers</B>

は、できるだけ多くのリソースレコードを 1 つのメッセージに押し込みます。
<B>many-answers</B>

の方が効率的ではありますが、BIND 8.1 および、
パッチの当たった BIND 4.9.5 でのみ
理解されるものです。
サーバに対してどちらの方法を使用するかは、
<B>transfer-format</B>

オプションを使用して指定することができます。
<B>transfer-format</B>

が指定されていない場合は、
<B>options</B>

ステートメントで指定された
<B>transfer-format</B>

が使用されます。
<P>
<P>

<B>transfers</B>

は、将来のリリースでのサーバで、
指定されたサーバから同時に行われる内部へのゾーン転送数を
制限するために使用される予定です。
現在は、文法はチェックしますが、その他のことは
無視されます。
<P>
<P>

<B>keys</B>

節は、
<B>key</B>

ステートメントで定義された
<I>key_id</I>

を識別するために使用されます。これは、リモートサーバと通信する際の
トランザクションのセキュリティ用に使用されます。
<B>key</B>

ステートメントは、それを参照する
<B>server</B>

ステートメントよりも先に現れなくてはなりません。
<P>
<P>

<B>keys</B>

ステートメントは、将来、サーバによって使用されることを期待されています。
現在は、文法はチェックされますが、その他のことは無視されます。
<P>
<A NAME="lbBX">&nbsp;</A>
<H2>controls ステートメント</H2>

<A NAME="lbBY">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
controls {
  [ inet <I>ip_addr</I>
    port <I>ip_port</I>
    allow { <I>address_match_list</I>; }; ]
  [ unix <I>path_name</I>
    perm <I>number</I>
    owner <I>number</I>
    group <I>number</I>; ]
};
</PRE>

<P>
<A NAME="lbBZ">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>controls</B>

ステートメントは、
システム管理者がローカルのネームサーバの操作に影響を与えるために
使用する制御チャネルを宣言します。制御チャネルは、
<B>ndc</B>

ユーティリティが、ネームサーバにコマンドを送り、
DNS 以外の結果を受け取るために
使用します。
<P>
<P>

<B>unix</B>

制御チャネルは、ファイルシステムでの FIFO です。このチャネルへのアクセスは、
通常のファイルシステムのパーミッションによって制御されます。
この制御チャネルは、
指定されたファイルモードのビット (
<A HREF="../../0MultiFileIdx/man1/chmod.1.html">chmod</A>(1)


を参照) とユーザおよびグループの所有者情報を使用し、
<B>named</B>

が作成します。
注意することは、
<B>chmod</B>

とは違い、
<B>perm</B>

に対して指定されるモードのビットには、通常先頭に
<B>0</B>

がついていることです。そのため、数字は 8 進数として解釈されます。
さらに注意することは、
<B>owner</B>

および
<B>group</B>

として指定されるユーザおよびグループの所有者情報は、数字で与えなくては
ならないということです。名前ではありません。
このパーミッションは、管理者のみに制限することを勧めます。
そうしないと、このシステム上のユーザなら誰でもローカルネームサーバを
操作できてしまいます。
<P>
<P>

<B>inet</B>

制御チャネルは、インターネット接続のできる TCP/IP ソケットです。
これは、指定された
<I>ip_addr</I>

上の指定された
<I>ip_port</I>

にあります。
最近の
<B>telnet</B>

クライアントは、こうしたソケットと直接対話ができます。
このときの制御プロトコルは、ARPAnet 形式のテキストです。
127.0.0.1 だけを
<I>ip_addr</I>

に使用することを勧めます。これは、ネームサーバを管理するために、
ローカルホスト上の特権を持たないユーザを皆信用している場合だけに限ります。
<P>
<A NAME="lbCA">&nbsp;</A>
<H2>include ステートメント</H2>

<A NAME="lbCB">&nbsp;</A>
<H3>文法</H3>

<P>

<PRE>
include <I>path_name</I>;
</PRE>

<P>
<A NAME="lbCC">&nbsp;</A>
<H3>定義と使用法</H3>

<P>
<B>include</B>

ステートメントは、そのステートメントが現れた地点に、指定された
ファイルを挿入します。ただし、他のステートメント内で使用することは
できません。ですので、

<BLOCKQUOTE><TT>acl internal_hosts { include &quot;internal_hosts.acl&quot;; };</TT></BLOCKQUOTE>
というようには使用できません。
<P>
<P>

<B>include</B>

を使用して、設定ファイルを簡単に管理できるかたまりに分けるように
してください。例えば、次のようにです :
<P>

<PRE>
include &quot;/etc/security/keys.bind&quot;;
include &quot;/etc/acls.bind&quot;;
</PRE>

<P>
この例は、任意の ACL または 認証鍵情報を取り込むために、
BIND 設定ファイルの先頭で使うことができるでしょう。
<P>
<P>

C 言語でのプログラムでするように ``#include'' とタイプしないでください。
``#'' はコメントの開始として使用するものだからです。
<P>
<A NAME="lbCD">&nbsp;</A>
<H2>使用例</H2>

<P>
実際に使用する場面でも実用的で、最も単純な設定ファイルは、
ただ単にルートサーバファイルへのフルパスを持ったヒントゾーンを
定義したものです。

<PRE>
zone &quot;.&quot; in {
        type hint;
        file &quot;/var/named/root.cache&quot;;
};
</PRE>

<P>
次の例は、もっと実世界に即したものです。
<P>

<PRE>
/*
 * 単純な BIND 8 の設定
 */

logging {
        category lame-servers { null; };
        category cname { null; };
};

options {
        directory &quot;/var/named&quot;;
};

controls {
        inet * port 52 allow { any; };                  // これは良くない
        unix &quot;/var/run/ndc&quot; perm 0600 owner 0 group 0;  // デフォルト
};

zone &quot;isc.org&quot; in {
        type master;
        file &quot;master/isc.org&quot;;
};

zone &quot;vix.com&quot; in {
        type slave;
        file &quot;slave/vix.com&quot;;
        masters { 10.0.0.53; };
};

zone &quot;0.0.127.in-addr.arpa&quot; in {
        type master;
        file &quot;master/127.0.0&quot;;
};

zone &quot;.&quot; in {
        type hint;
        file &quot;root.cache&quot;;
};
</PRE>

<P>
<A NAME="lbCE">&nbsp;</A>
<H2>ファイル</H2>

<DL COMPACT>
<P>

<DT><B>/etc/namedb/named.conf

</B>
<DD>
BIND 8
<B>named</B>

設定ファイル
</DL>
<P>

<P>
<A NAME="lbCF">&nbsp;</A>
<H2>関連項目</H2>

<A HREF="../man8/named.8.html">named</A>(8),


<A HREF="../man8/ndc.8.html">ndc</A>(8)


<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名称</A><DD>
<DT><A HREF="#lbAC">概要</A><DD>
<DL>
<DT><A HREF="#lbAD">一般的な文法</A><DD>
<DT><A HREF="#lbAE">BIND 4.9.x から変更する</A><DD>
</DL>
<DT><A HREF="#lbAF">記述方法の定義</A><DD>
<DT><A HREF="#lbAG">アドレスマッチリスト</A><DD>
<DL>
<DT><A HREF="#lbAH">文法</A><DD>
<DT><A HREF="#lbAI">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbAJ">logging ステートメント</A><DD>
<DL>
<DT><A HREF="#lbAK">文法</A><DD>
<DT><A HREF="#lbAL">定義と使用法</A><DD>
<DT><A HREF="#lbAM">チャネルフレーズ</A><DD>
<DT><A HREF="#lbAN">category フレーズ</A><DD>
</DL>
<DT><A HREF="#lbAO">options ステートメント</A><DD>
<DL>
<DT><A HREF="#lbAP">文法</A><DD>
<DT><A HREF="#lbAQ">定義および使用法</A><DD>
<DT><A HREF="#lbAR">パス名</A><DD>
<DT><A HREF="#lbAS">ブール値のオプション</A><DD>
<DT><A HREF="#lbAT">Also-Notify</A><DD>
<DT><A HREF="#lbAU">フォワード</A><DD>
<DT><A HREF="#lbAV">ネームチェック</A><DD>
<DT><A HREF="#lbAW">アクセス制御</A><DD>
<DT><A HREF="#lbAX">インタフェース</A><DD>
<DT><A HREF="#lbAY">問い合わせアドレス</A><DD>
<DT><A HREF="#lbAZ">ゾーン転送</A><DD>
<DT><A HREF="#lbBA">リソースの制限</A><DD>
<DT><A HREF="#lbBB">定期的なタスクの間隔</A><DD>
<DT><A HREF="#lbBC">トポロジ</A><DD>
<DT><A HREF="#lbBD">リソースレコードのソート</A><DD>
<DT><A HREF="#lbBE">RRset の順番付け</A><DD>
<DT><A HREF="#lbBF">チューニング</A><DD>
</DL>
<DT><A HREF="#lbBG">zone ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBH">文法</A><DD>
<DT><A HREF="#lbBI">定義と使用法</A><DD>
<DT><A HREF="#lbBJ">クラス</A><DD>
<DT><A HREF="#lbBK">オプション</A><DD>
</DL>
<DT><A HREF="#lbBL">acl ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBM">文法</A><DD>
<DT><A HREF="#lbBN">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbBO">key ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBP">文法</A><DD>
<DT><A HREF="#lbBQ">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbBR">trusted-keys ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBS">文法</A><DD>
<DT><A HREF="#lbBT">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbBU">server ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBV">文法</A><DD>
<DT><A HREF="#lbBW">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbBX">controls ステートメント</A><DD>
<DL>
<DT><A HREF="#lbBY">文法</A><DD>
<DT><A HREF="#lbBZ">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbCA">include ステートメント</A><DD>
<DL>
<DT><A HREF="#lbCB">文法</A><DD>
<DT><A HREF="#lbCC">定義と使用法</A><DD>
</DL>
<DT><A HREF="#lbCD">使用例</A><DD>
<DT><A HREF="#lbCE">ファイル</A><DD>
<DT><A HREF="#lbCF">関連項目</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:36 GMT, December 05, 2022
</BODY>
</HTML>
