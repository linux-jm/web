
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of HEXDUMP</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../jm.css">
</HEAD>
<BODY>

<H1>HEXDUMP</H1>
Section: User Commands (1)<BR>Updated: April 2013<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/util-linux/release/man1/hexdump.1">roff page</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

hexdump - ファイルの内容を 16 進数、10 進数、8 進数、ASCII 文字で表示する
<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<B>hexdump</B> [options]<I> file</I>...
<A NAME="lbAD">&nbsp;</A>
<H2>読者へのご注意</H2>

これは、util-linux 版の <B>hexdump</B> コマンドのマニュアルである。<B>hexdump</B>
コマンドの実装には、いくつかの系統がある。御使用のディストリビューションが
util-linux 版以外の <B>hexdump</B> コマンドを採用している場合は、
動作やオプションがここで説明しているものとかなり違っているかもしれない。
そういうときは、英語版しかないかもしれないが、お手元の <B>hexdump</B>
コマンドに付属するマニュアルに当たってみていただきたい。
<A NAME="lbAE">&nbsp;</A>
<H2>説明</H2>

<B>hexdump</B> ユーティリティは、指定されたファイルをユーザーが指定したフォーマットで表示するフィルタである。
ファイルが指定されていない場合は、標準入力を処理の対象にする。
<A NAME="lbAF">&nbsp;</A>
<H2>オプション</H2>

以下で使用する引き数 <I>length</I> や <I>offset</I>
の後ろには、KiB (=1024), MiB (=1024*1024)
のような乗数を表す接尾辞を付けることができる。GiB, TiB, PiB, EiB, ZiB, YiB
も同様に使える (&quot;iB&quot; を続けるのは任意であり、たとえば、&quot;K&quot; は &quot;KiB&quot;
と同じ意味だ)。また、KB (=1000), MB (=1000*1000)
のような接尾辞を付けてもよい。GB, TB, PB, EB, ZB, YB も同様に使える。
<DL COMPACT>
<DT><B>-b</B>, <B>--one-byte-octal</B><DD>
<I>1 バイト単位の 8 進数表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを 1 バイトずつ
0 で字詰めした 3 桁の 8 進数で表現し、それを 1 行当たり 16 個、空白で区切って表示する。
<DT><B>-c</B>, <B>--one-byte-char</B><DD>
<I>1 バイト単位の ASCII 文字表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを
1 キャラクタずつ、空白で字詰めした 3 桁の ASCII 文字で表現し、それを
1 行当たり 16 個、空白で区切って表示する
(訳注: 表示不能文字は、エスケープ表記が可能なものはエスケープ表記で、
できないものは、3 桁の 8 進数で表示される)。
<DT><B>-C</B>, <B>--canonical</B><DD>
<I>標準的な 16 進数 + ASCII での表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを 1 バイトずつ
2 桁の 16 進数で表現し、それを 1 行当たり 16 個、空白で区切って表示する。
その後に、2 つの '<B>|</B>' で囲まれた中に同じ 16 バイトを
<B>%_p</B> フォーマットで表示する。
<DT><B>-d</B>, <B>--two-bytes-decimal</B><DD>
<I>2 バイト単位の 10 進数表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを 2 バイトずつ 0 で字詰めした
5 桁の符号なし 10 進数で表現し、それを 1 行当たり 8 個、空白で区切って表示する。
<DT><B>-e</B>, <B>--format</B> <I>format_string</I><DD>
データを表示するために使われるフォーマット文字列を指定する
(訳注: フォーマット文字列は、シングルクォート (' ') で囲む必要がある)。
<DT><B>-f</B>, <B>--format-file</B> <I>file</I><DD>
1 個以上のフォーマット文字列を、改行で区切って書き込んだファイルを指定する。
空行や、空白を除いた最初の文字がハッシュマーク (#) である行は無視される
(訳注: <B>-e</B> オプションと違って、こちらでは、
フォーマット文字列、すなわち各行をシングルクォートで囲んではいけない)。
<DT><B>-L</B>, <B>--color</B>[=<I>when</I>]<DD>
フォーマット中のカラー指定単位 (color unit) を出力に使用する。
指定が任意の引き数 <I>when</I> は、<B>auto</B>, <B>never</B>, <B>always</B>
のいずれかである。引き数 <I>when</I> を省略すると、デフォルトの <B>auto</B> になる。
カラー表示は、無効にすることもできる。
プログラムに埋め込まれた現在のデフォルトが有効か無効かは、<B>--help</B> の出力を見ればわかる。
後述の「<B>カラー指定</B>」サブセクションと「<B>カラー表示</B>」セクションも参照していただきたい
(訳注: 短いオプション <B>-L</B> に引き数を付けるときは、間に空白を入れずに
<B>-Lalways</B> のように直接続けなければならない)。
<DT><B>-n</B>, <B>--length</B> <I>length</I><DD>
入力の <I>length</I> バイト分だけを処理する。
<DT><B>-o</B>, <B>--two-bytes-octal</B><DD>
<I>2 バイト単位の 8 進数表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを 2 バイトずつ 0 で字詰めした
6 桁の 8 進数で表現し、それを 1 行当たり 8 個、空白で区切って表示する。
<DT><B>-s</B>, <B>--skip</B> <I>offset</I><DD>
入力の先頭から <I>offset</I> バイトを読み飛ばす。
<DT><B>-v</B>, <B>--no-squeezing</B><DD>
<B>-v</B> オプションを指定すると、<B>hexdump</B> は、入力データをすべて表示するようになる。
<B>-v</B> オプションを指定しない場合は、直前の出力行と (入力オフセット以外が)
同じ内容の行は、何行であっても、ただ 1 個のアスタリスクからなる
1 行に置き換えられる。
<DT><B>-x</B>, <B>--two-bytes-hex</B><DD>
<I>2 バイト単位の 16 進数表示</I>。
入力オフセットを 16 進数で表示し、その後に、入力データを 2 バイトずつ 0 で字詰めした
4 桁の 16 進数で表現し、それを 1 行当たり 8 個、空白で区切って表示する。
<DT><B>-V</B>,<B> --version</B><DD>
バージョン情報を表示して、終了する。
<DT><B>-h</B>,<B> --help</B><DD>
ヘルプを表示して、終了する。
</DL>
<P>

各入力ファイルに対して、<B>hexdump</B> は、入力を <B>-e</B> や <B>-f</B>
オプションで指定されたフォーマット文字列に従い、
フォーマット文字列が指定された順序でデータを変換しながら、標準出力に順次書き出していく。
<A NAME="lbAG">&nbsp;</A>
<H2>フォーマット</H2>

フォーマット文字列は、空白 (またはタブ)
で区切られた任意の数のフォーマット単位から構成される。1 つのフォーマット単位は、最大で
3 個の要素、すなわち、繰り返し回数、バイト数、フォーマットを含んでいる。
<P>

<DL COMPACT>
<DT>[<B>訳注</B>]<DD>
各フォーマット文字列は 1 行からなる。フォーマット文字列を複数個指定すると、
その各々が、同じ 1 つの処理単位 
(後述の<I>ブロック</I>である。「<B>処理されるバイト数</B>」セクションを参照)
に対して、重ねて適用されることになる
(すなわち、どのフォーマット文字列もブロックの先頭から適用される)。
複数のフォーマット文字列を指定するには、<B>-e</B>
オプションでは、<B>-e</B> を複数回使えばよい。<B>-f</B>
オプションでは、改行で区切って複数行にする。
<P>
フォーマット単位は、「繰り返し回数 / バイト数 &quot;フォーマット&quot;」という書式になる。&quot;フォーマット&quot;
以外は省略できる。
</DL>
<P>

繰り返し回数は、指定が任意の (訳注: すなわち、省略可能な)
正の整数であり、デフォルトは 1 である。各フォーマットは繰り返し回数だけ適用される。
<P>

バイト数も、指定が任意の正の整数である。これが指定されている場合は、そのフォーマットを
1 回適用するごとに処理するバイト数を示している。
<P>

繰り返し回数やバイト数を指定する場合、どちらの数字か区別できるように、
繰り返し回数の後や、バイト数の前にスラッシュを 1 個置かなければならない。
スラッシュの前後に空白があっても、無視される。
<P>

フォーマットは必須であり、ダブルクォート (&quot; &quot;) で囲まなければならない。
このフォーマットは、fprintf 形式のフォーマット文字列
(<B><A HREF="../../LDP_man-pages/man3/fprintf.3.html">fprintf</A></B>(3) を参照) として解釈されるが、以下のような例外がある。
<DL COMPACT>
<DT>1.<DD>
フィールドの幅や精度としてアスタリスク (*) を使えない。
<DT>2.<DD>
変換文字 <B>s</B> のそれぞれについて、バイト数かフィールド精度が必要である。
(その点が、精度が指定されていない場合に全ての文字列を表示する <B><A HREF="../../LDP_man-pages/man3/fprintf.3.html">fprintf</A></B>(3)
のデフォルトとは異なる)。
<DT>3.<DD>
変換文字 <B>h</B>,<B>&nbsp;l</B>,<B>&nbsp;n</B>,<B>&nbsp;p</B>,<B>&nbsp;q</B> がサポートされていない。
<DT>4.<DD>
C 言語の規格に書かれている
1 文字のエスケープシーケンスがサポートされている:
</DL>
<P>

<DL COMPACT><DT><DD>

<DL COMPACT>
<DT>NULL<DD>
\0
<DT>&lt;アラート文字&gt;<DD>
\a
<DT>バックスペース<DD>
\b
<DT>フォームフィード<DD>
\f
<DT>改行<DD>
\n
<DT>復帰<DD>
\r
<DT>タブ<DD>
\t
<DT>垂直タブ<DD>
\v

</DL>
</DL>

<P>

<A NAME="lbAH">&nbsp;</A>
<H3>変換文字列</H3>

<B>hexdump</B> ユーティリティは、さらに以下の変換文字列もサポートしている:
<DL COMPACT>
<DT><B>_a[dox]</B><DD>
次に表示されるバイトの入力オフセット (複数の入力ファイルで通算した値) を表示する。
文字 <B>d</B>, <B>o</B>, <B>x</B> を後ろに付けると、オフセットの表示がそれぞれ
10, 8, 16 進数になる。
<DT><B>_A[dox]</B><DD>
変換文字列 <B>_a</B> とほぼ同じ。ただし、この変換は全ての入力データが処理された後で
1 回だけ実行される。
<DT><B>_c</B><DD>
デフォルト文字セットの文字で出力する。表示不能な文字は、0 で字詰めした
3 桁の 8 進数で表示される。ただし、標準エスケープ表記で表現できる文字
(上記を参照) は、その 2 文字の文字列で表示される。
<DT><B>_p</B><DD>
デフォルト文字セットの文字で出力する。表示不能な文字は、1 個の '<B>.</B>' として表示される。
<DT><B>_u</B><DD>
US ASCII 文字で出力する。
ただし、制御文字は以下のような小文字の名前を使って表示される。
16 進数で 0x7f より大きい文字は、16 進数の文字列として表示される。
<DL COMPACT><DT><DD>
<TABLE>
<TR VALIGN=top><TD>000 nul</TD><TD>001 soh</TD><TD>002 stx</TD><TD>003 etx</TD><TD>004 eot</TD><TD>005 enq<BR></TD></TR>
<TR VALIGN=top><TD>006 ack</TD><TD>007 bel</TD><TD>008 bs</TD><TD>009 ht</TD><TD>00A lf</TD><TD>00B vt<BR></TD></TR>
<TR VALIGN=top><TD>00C ff</TD><TD>00D cr</TD><TD>00E so</TD><TD>00F si</TD><TD>010 dle</TD><TD>011 dc1<BR></TD></TR>
<TR VALIGN=top><TD>012 dc2</TD><TD>013 dc3</TD><TD>014 dc4</TD><TD>015 nak</TD><TD>016 syn</TD><TD>017 etb<BR></TD></TR>
<TR VALIGN=top><TD>018 can</TD><TD>019 em</TD><TD>01A sub</TD><TD>01B esc</TD><TD>01C fs</TD><TD>01D gs<BR></TD></TR>
<TR VALIGN=top><TD>01E rs</TD><TD>01F us</TD><TD>07F del</TD><TD></TD><TD></TD><TD><BR></TD></TR>
</TABLE>

</DL>
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>カラー指定</H3>

フォーマット指定子 (訳注: 変換文字や変換文字列)
の末尾にカラー指定を追加すると、hexdump は、対応する文字列
(訳注: たいていは 16 進数などの数値) を指定された色でハイライトする。
条件が存在する場合は、ハイライトする前に評価される
(訳注: カラー指定の実例については、「<B>用例</B>」セクションの
3 番目の例をご覧になっていただきたい)。
<P>

<PRE>
<B>_L[color_unit_1,color_unit_2,...,color_unit_n]</B>
</PRE>

<P>

カラー指定単位 (color unit) の完全な書式は以下のとおりである:
<P>

<PRE>
<B>[!]COLOR[:VALUE][@OFFSET_START[-END]]</B>
</PRE>

<DL COMPACT>
<DT><B>!</B><DD>
条件を否定する。
注意していただきたいが、あるカラー指定単位について否定することに意味があるのは、
値/文字列と、オフセットの両方を指定したときだけである。
その場合は、値/文字列がそのオフセットにあるものとマッチしなかったときにのみ、
対応する出力文字列がハイライトされることになる。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>[<B>訳注</B>]<DD>
上で言っているのは、否定は、あるオフセット、または比較的狭いオフセットの範囲に、
ある値が存在しないことを調べるためのものだということだろう。
広範囲についてそれをやるのは、色彩を反転させるだけで、否定しないときと事実上同じことになる。
</DL>
</DL>

<DT><B>COLOR</B><DD>
シェルで使われる 8 種の基本色の 1 つ。
<DT><B>VALUE</B><DD>
マッチすべき値。16 進数、8 進数、または文字列で指定する。
hexdump はカラー指定単位の中では、通常の
C 言語のエスケープシーケンスを解釈しないことに注意していただきたい。
<DT><B>OFFSET</B><DD>
マッチするか否かをチェックするオフセット、またはオフセットの範囲
(訳注: このオフセットは 10 進数で指定するようだ)。OFFSET_START
だけ指定すると、END オフセットが同じ値になることに注意していただきたい。
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>処理されるバイト数</H3>

変換文字で使われるデフォルトのバイト数とサポートされるバイト数は、以下の通りである。
<DL COMPACT>
<DT><B>%_c</B>,<B>&nbsp;%_p</B>,<B>&nbsp;%_u</B>,<B>&nbsp;%c</B><DD>
1 バイトのみ。
<DT><B>%d</B>,<B>&nbsp;%i</B>,<B>&nbsp;%o</B>,<B>&nbsp;%u</B>,<B>&nbsp;%X</B>,<B>&nbsp;%x</B><DD>
4 バイトがデフォルト。1, 2, 4 バイトがサポートされている。
<DT><B>%E</B>,<B>&nbsp;%e</B>,<B>&nbsp;%f</B>,<B>&nbsp;%G</B>,<B>&nbsp;%g</B><DD>
8 バイトがデフォルト。4 バイトがサポートされている。
</DL>
<P>

各フォーマット文字列によって解釈・変換されるデータの量は、
各フォーマット単位が要求するデータの合計である。
各フォーマット単位が要求するデータは、(繰り返し回数) x (バイト数) である。
バイト数が指定されていない場合は、
(繰り返し回数) x (そのフォーマットが要求するバイト数) になる。
<P>

入力は <I>ブロック</I> 単位で処理される。ここで言うブロックとは、
フォーマット文字列のいずれかによって指定されるデータの量のうちで、
最大のもののことである (訳注: そのようにブロックの大きさが決まると、
複数のフォーマット文字列が指定されている場合は、
その各フォーマット文字列が、同じ 1 つの処理単位 (つまり、<I>ブロック</I>)
に繰り返し適用されることになる)。入力ブロック
1 個分のデータより少ないバイト数しか解釈しないフォーマット文字列については、
<I>その最後のフォーマット単位</I>が、何バイトかを解釈・変換するものであり、
しかも繰り返し回数が<I>指定されていない</I>ならば、
その繰り返し回数を増加させて、入力ブロック全体の処理が済むか、
あるいは、フォーマット文字列の要求を満たすだけのデータがブロックになくなるまで、処理を続ける。
<P>

ユーザの指定によって、あるいは、上述のように <B>hexdump</B>
が繰り返し回数を変更していることによって、繰り返し回数が
2 回以上になっている場合は、(訳注: そのフォーマット単位で、たとえば
'8/1 &quot;%02x &quot;' や '&quot;%_p &quot;'
のように、各出力項目の末尾に空白を追加することになっていても)
最後の繰り返しにおける末尾の空白は出力されない。
<P>

フォーマット単位で、バイト数とともに複数の変換文字や変換文字列を指定するのは誤用である。
ただし、変換文字や変換文字列の 1 つ以外のすべてが、
<B>_a</B> や <B>_A</B> であるときは、問題がない。
<P>

<B>-n</B> オプションを指定したり、ファイルの終わりに達したために、
入力データがフォーマット文字列の一部しか満たさなかった場合、
その入力ブロックには、利用できるすべてのデータを表示するのに足りるだけのゼロバイト
(ASCII NUL) が補われる
(換言すると、フォーマット単位が、データの末尾からはみ出している場合、
そのフォーマット単位は、いくつかのゼロバイトを表示することになる)。
<P>

そうしたフォーマット文字列による追加の出力は、相当する数の空白で置き換えられる。
相当する数の空白というのは、<B>s</B>
変換文字が、実際に指定されている変換文字や変換文字列と同じフィールド幅と精度を持ち、
'<B>+</B>', ' ', '<B>#</B>'
と言った変換フラグが付いていれば、それを取り除いたときに、
NULL 文字列に対して出力する数の空白のことである。
<P>

フォーマット文字列が指定されていない場合、デフォルトの表示は、<B>-x</B>
オプションの出力形式とよく似たものになる (ただし、<B>-x</B>
オプションを付けた方が、フォーマット単位間のスペースがデフォルトの出力より広くなる)。
<A NAME="lbAK">&nbsp;</A>
<H2>終了ステータス</H2>

<B>hexdump</B> は成功すると 0 を返して終了する。
エラーが起きた場合は、1 以上を返して終了する。
<A NAME="lbAL">&nbsp;</A>
<H2>用例</H2>

入力を「ためつすがめつ見直し」フォーマットで表示する:
<PRE>
   &quot;%06.6_ao &quot;  12/1 &quot;%3_u &quot;
   &quot;\t\t&quot; &quot;%_p &quot;
   &quot;\n&quot;
</PRE>

<P>

-x オプションを実装する:
<PRE>
   &quot;%07.7_Ax\n&quot;
   &quot;%07.7_ax  &quot; 8/2 &quot;%04x &quot; &quot;\n&quot;
</PRE>

<P>

MBR ブートシグネチャの例: アドレスをシアンで、オフセット 510 と 511
にあるバイトの値が 0xAA55 の場合は緑、その他の場合は赤でハイライトする。
<PRE>
   &quot;%07.7_Ax_L[cyan]\n&quot;
   &quot;%07.7_ax_L[cyan]  &quot; 8/2 &quot;   %04x_L[green:<A HREF="mailto:0xAA55@510-511">0xAA55@510-511</A>,!red:<A HREF="mailto:0xAA55@510-511">0xAA55@510-511</A>] &quot; &quot;\n&quot;
</PRE>

<A NAME="lbAM">&nbsp;</A>
<H2>カラー表示</H2>

空ファイル <I>/etc/terminal-colors.d/hexdump.disable</I>
を置くことで、暗黙のカラー表示を無効化できる。
<P>
カラー設定の詳細については <B>terminal-colors.d</B>(5) を参照していただきたい。
<A NAME="lbAN">&nbsp;</A>
<H2>規格</H2>

<B>hexdump</B> ユーティリティは IEEE Std 1003.2 (&quot;POSIX.2&quot;)
に適合しているはずである。
<A NAME="lbAO">&nbsp;</A>
<H2>入手方法</H2>

この hexdump コマンドは、util-linux パッケージの一部であり、Linux Kernel Archive
&lt;<A HREF="https://www.kernel.org/pub/linux/utils/util-linux/">https://www.kernel.org/pub/linux/utils/util-linux/</A>&gt;
から入手できる。
<A NAME="lbAP">&nbsp;</A>
<H2>翻訳者謝辞</H2>

この man ページの翻訳の最初のバージョンは、NetBSD jman proj
から寄贈していただいたものだった。また、翻訳にあたっては、FreeBSD
jpman project &lt;<A HREF="http://www.jp.freebsd.org/man-jp/">http://www.jp.freebsd.org/man-jp/</A>&gt;
の翻訳を参考にさせていただいた。両プロジェクトの翻訳者の方々にお礼を申し上げる。
<A NAME="lbAQ">&nbsp;</A>
<H2>おまけ</H2>

説明がわかりにくかったと思うので、翻訳者の判断で、用例をもう一つ追加して、説明を補足してみる。
却って混乱が増すようなら、読み飛ばしていただきたい。<B>hexdump -C</B>
のエミュレーションをしてみよう。次のような内容のファイルを
hexchar.fmt という名前で作成する。
<P>

<PRE>
   &quot;%08.8_Ax\n&quot;
   &quot;%08.8_ax  &quot; 8/1 &quot;%02x &quot; &quot;  &quot; 8/1 &quot;%02x &quot;
   &quot;  |&quot; &quot;%_p&quot;
   &quot;|\n&quot;
</PRE>

<P>

各行がフォーマット文字列であり、「&quot;%08.8_ax&nbsp;&nbsp;&quot;」 「8/1&nbsp;&quot;%02x&nbsp;&quot;」
「&quot;&nbsp;&nbsp;&quot;」 「&quot;&nbsp;&nbsp;|&quot;」 「&quot;%_p&quot;」 といった部分がフォーマット単位、
ダブルクォート (&quot; &quot;) で囲まれた部分がフォーマットである。
フォーマット単位には、繰り返し回数やバイト数の指定がなく、
フォーマットしか含まれていないこともある。
<P>
入力データは、一定の量ごとに分割されて処理される。その一定の量がブロックだが、
ブロックの大きさは、フォーマット文字列の中で最大のデータを要求しているものによって決まる。
上の場合なら、最大のデータを要求しているのは、2 行目であり
(ほかの行はデータの量を指定していない)、1 バイトが 8 回、さらに 1 バイトが
8 回繰り返し処理されるわけだから、合計で 16 バイトが要求されていることになる。
従って、ブロックの大きさは 16 バイトである。言い換えれば、この例では、入力データは
16 バイトずつ処理されるということだ。
<P>
<P>
各フォーマット文字列は、同一のブロックに対して順番に適用される。
しかも、それぞれが、そのブロックの先頭に戻って、適用されていく。
<P>
1 行目は、「すべての入力データの処理が終わったときに、最後から 
1 つ先のオフセットを表示せよ」ということだから、ブロックのデータの処理とは関係がない。
<P>
2 行目の「&quot;%08.8_ax&nbsp;&nbsp;&quot; 8/1 &quot;%02x&nbsp;&quot; &quot;&nbsp;&nbsp;&quot; 8/1 &quot;%02x&nbsp;&quot;」の意味はこうである。
「まず、次に表示するバイトのオフセットを 8 桁の
16 進数で、先頭を 0 で埋めて表示し、空白を 2 個続ける。それから、1 バイトずつ
8 個 のデータを、2 桁の 16 進数で後ろに空白を付けて
(つまり、空白で区切って) 表示し、空白を 2 個置いて、さらに 1 バイトずつ
8 個のデータを、2 桁の 16 進数で空白で区切って表示せよ」。
<P>
3 行目の「&quot;&nbsp;&nbsp;|&quot; &quot;%_p&quot;」が指示しているのは、「2
行目による出力にすぐ続けて、同じ出力行にまず '&nbsp;&nbsp;|'
という文字列を表示し、それから、2 行目が処理したのと同じブロックに対して
1 バイトずつ '_p' 変換をして (つまり、ASCII 文字で) 出力せよ」ということだ。
3 行目は、「最後のフォーマット単位が、何バイトかを解釈・変換するものであり、
しかも繰り返し回数が指定されていない」ので、ブロック全体の処理が済むまで、
最後のフォーマット単位 &quot;%_p&quot; による処理が繰り返されることになる。
<P>
仮に、3 行目と 4 行目を 1 つにし、3 行目を「&quot;&nbsp;&nbsp;|&quot; &quot;%_p&quot; &quot;|\n&quot;」という形にすると、
フォーマット文字列の「最後のフォーマット単位が、
何バイトかを解釈・変換するもの」ではなくなるので、
自動的な繰り返しの増加が行われないことになる。それ故、両者は別の行になっている。
<P>
4 行目は、データに対する処理は何も指定せず、「3 行目による出力のすぐ後ろに '|'
という文字を書き出してから改行せよ」とだけ指示している。
<P>
このすべてが終わると、次のブロックに移って、同じ処理を繰り返していく。
<P>
結果として、<B>hexdump -f hexchar.fmt sample.txt</B> を実行すれば、
<B>hexdump -C sample.txt</B> と同じ結果が得られるはずである。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">読者へのご注意</A><DD>
<DT><A HREF="#lbAE">説明</A><DD>
<DT><A HREF="#lbAF">オプション</A><DD>
<DT><A HREF="#lbAG">フォーマット</A><DD>
<DL>
<DT><A HREF="#lbAH">変換文字列</A><DD>
<DT><A HREF="#lbAI">カラー指定</A><DD>
<DT><A HREF="#lbAJ">処理されるバイト数</A><DD>
</DL>
<DT><A HREF="#lbAK">終了ステータス</A><DD>
<DT><A HREF="#lbAL">用例</A><DD>
<DT><A HREF="#lbAM">カラー表示</A><DD>
<DT><A HREF="#lbAN">規格</A><DD>
<DT><A HREF="#lbAO">入手方法</A><DD>
<DT><A HREF="#lbAP">翻訳者謝辞</A><DD>
<DT><A HREF="#lbAQ">おまけ</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:47 GMT, December 05, 2022
</BODY>
</HTML>
