
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of FIND</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../jm.css">
</HEAD>
<BODY>

<H1>FIND</H1>
Section: User Commands  (1)<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/GNU_findutils/release/man1/find.1">roff page</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

find - ディレクトリ階層内のファイル検索
<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<B>find</B> [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...]
[expression]
<A NAME="lbAD">&nbsp;</A>
<H2>説明</H2>

このマニュアルページは GNU 版 <B>find</B> の使用法を説明しています。 GNU <B>find</B> は、 指定された検索開始ポイント
(starting-point) を基準にして、 ディレクトリツリーを検索します。 そして優先規則に従って (「オペレーター」のセクション参照)、
指定された式 (expression) を左から右の順で評価していきます。 たとえば、 <I>and</I> 演算で左辺が false になった場合や、
<I>or</I> 演算で左辺が true になった場合のように、 式の結果が確定すると、 <B>find</B> は次のファイル名を処理対象とします。
検索開始ポイントが指定されていない場合は、 `.' が指定されたものとみなします。
<P>

セキュリティを重視する必要がある状況 (たとえば、 別ユーザーが書き込み可能なディレクトリを、 自分が検索しようとしている場合) のもとで、
<B>find</B> を利用する場合には、 findutils 文書の 「Security Considerations」の章をよく読んでください。
この文書は <B>Finding Files</B> というものであり、 findutils に含まれています。 この文書の方がマニュアルページに比べて、
詳しい説明や検討が行われているので、 役に立つ情報が得られるかもしれません。
<A NAME="lbAE">&nbsp;</A>
<H2>オプション</H2>

<B>-H</B>, <B>-L</B>, <B>-P</B> というオプションは、 シンボリックリンクの取り扱いを制御します。 このオプションに続くコマンドライン引数は、
検索対象となるファイル名やディレクトリ名として扱われます。 ただしそのように扱われるのは、 次に `-' で始まる引数や、 `(' や `!'
という引数が現れるところまでです。 その引数以降の記述は、 検索方法を示した式として扱われます。 検索開始ポイントのパスが指定されなかった場合は、
カレントディレクトリが検索対象になります。 また、 式が指定されなかった場合は、 式 <B>-print</B> が使用されます (ただしどのような場合でも、
<B>-print</B> ではなく <B>-print0</B> の利用を検討してください)。
<P>

このマニュアルページでは、 式の中で用いる「オプション」について説明しています。 オプションは、 <B>find</B> の動作を制御します。
これを指定するのは、 パス名の指定を終えた後ろです。 これとは別に、 「本当の」オプションとして <B>-H</B>, <B>-L</B>, <B>-P</B>, <B>-D</B>,
<B>-O</B> という 5 つがあります。 これを用いるのであれば、 パス名の指定よりも前でなければなりません。 なお仕様上は、 ダッシュを 2 つ重ねた
<B>--</B> を使用することで、 それ以降の引数が、 オプションでないことを表すことができるとされます。 ただし、
この後に続く引数がパス引数であるかどうかを決定する処理が原因となって、 2 重のダッシュは実際には動作しません。 つまり式を表す引数 (これも `-'
で始まります) が現れるところまで、 引数を読み込むことで、 パス引数の終わりが判断されます。 仮にパス引数が `-' で始まっていたとしたら、
<B>find</B> はこれを式として取り扱ってしまいます。 このように、 検索開始点であるパス引数は、 適切に解釈されない場合があり、 他にも、
ワイルドカードパターンをシェルが展開する際に、 誤って式のように展開してしまうことがあります。 このような状況を避けるため、
一般的に行う安全策としては、 不安に思うパス名称やワイルドカードの前には、 `./' をつけるようにするか、 '/'
で始まる絶対パス名を用いるようにします。 別の方法として移植性には欠けますが安全な方法があります。 GNU オプションの <B>-files0-from</B>
を使って <B>find</B> の検索開始ポイントを任意に定める方法です。
<P>
<DL COMPACT>
<DT>-P<DD>
シンボリックリンクをたどりません。 これがデフォルトの動作です。 <B>find</B> がファイルの情報を調べたり表示したりする際に、
そのファイルがシンボリックリンクであれば、 シンボリックリンクそのもののプロパティから取得される情報が用いられます。
<P>
<DT>-L<DD>
シンボリックリンクをたどります。 <B>find</B> がファイルの情報を調べたり表示したりする際には、
リンク先ファイルのプロパティから情報が取得され利用されます。 つまりリンクそのものの情報は利用されません (ただし、 シンボリックリンクが切れていたり、
<B>find</B> がリンク先のファイルを調べることができなかった場合は除きます)。 このオプションの指定は、 暗に <B>-noleaf</B>
の指定を含みます。 この指定の後ろに <B>-P</B> オプションを指定しても、 <B>-noleaf</B> の効果は変わりません。 <B>-L</B> が有効であって、
<B>find</B> がサブディレクトリを指し示すシンボリックリンクを見つけた場合は、 サブディレクトリ内が検索されます。
<DT><DD>
<B>-L</B> オプションが有効な場合に、 述語表現である <B>-type</B> を用いると、 シンボリックリンクそのものではなく、
シンボリックリンク先のファイルのタイプに対して、 確認が行われます (リンク切れである場合は除きます)。 <B>find</B> の実行中に、
シンボリックリンク切れを起こすようなアクションを行うと (たとえば、 <B>-delete</B> を指定すると)、 混乱を招く動作が発生することになります。
<B>-L</B> を使用すると、 述語表現の <B>-lname</B> や <B>-ilname</B> は必ず false を返します。
<P>
<DT>-H<DD>
シンボリックリンクをたどりません。 ただしコマンドライン引数を処理する場合は別です。<B>find</B> がファイルの情報を調べたり表示したりする際には、
シンボリックリンクそのものからプロパティを取得して、 その情報が利用されます。 このような動作は、
コマンドライン上のファイルがシンボリックリンクであった場合には行われません。 このときには、 リンク先が読み取られます。
つまりその状況では、リンク先が何であっても、 リンク先から取得した情報が利用されます (つまりリンクをたどります)。
シンボリックリンク自体の情報は、リンク先が確認できなかった場合の予備情報として利用されます。 <B>-H</B> が有効であって、
コマンドラインで指定されたパスのうち、 ディレクトリへのシンボリックリンクがあった場合も、 そのディレクトリの中身が調べられることになります (ただし
<B>-maxdepth&nbsp;0</B> が指定されていれば、 当然そのような処理にはなりません)。
</DL>
<P>

複数の <B>-H</B>, <B>-L</B>, <B>-P</B> を指定した場合は、 前のものが上書きされます。 つまり、 適用されるものは、
コマンドライン上で最後に指定されたものです。 <B>-P</B> がデフォルトなので、 <B>-H</B> や <B>-L</B> の指定がなければ、 <B>-P</B>
オプションが有効であると判断できます。
<P>
GNU <B>find</B> は、 検索処理に入る前のコマンドライン処理においても、 ファイル情報を調べることがあります。 上に示したオプションは、
そのような引数の処理に対しても、 影響を及ぼします。 具体的に見てみると、 数多くのテストでは、 その時点で処理対象となっている 1 つのファイルと、
コマンドライン上の複数ファイルとの間で、 比較処理を行います。 どの状況でも、 コマンドラインから指定されたファイルは、 プロパティが調べられて、
その一部は保存されます。 引数上のファイルがシンボリックリンクであって、 <B>-P</B> オプションが有効な場合 (あるいは <B>-H</B> と <B>-L</B>
オプションの指定がどちらもない場合)、 比較処理に用いられるのは、 シンボリックリンクのプロパティ情報です。 そうでない場合には、
リンク先ファイルのプロパティ情報が用いられます。 <B>find</B> がリンク先をたどれなかった場合 (たとえば権限が不足していた場合や、
リンク先が存在しないファイルであった場合)、 シンボリックリンクそのもののプロパティが用いられます。
<P>

<B>-H</B> あるいは <B>-L</B> オプションが有効な場合、 <B>-newer</B> の引数として指定されたものがシンボリックリンクなら、
その参照をたどって、 リンク先のファイルからタイムスタンプを取得します。 このような処理は、 <B>-newerXY</B>, <B>-anewer</B>,
<B>-cnewer</B> でも同様に行われます。
<P>
<B>-follow</B> オプションは、 <B>-L</B> と同様の効果がありますが、 オプションの指定位置以降に対して有効になります。 (つまり、 <B>-L</B>
を使わずに、 <B>-follow</B> が使われた場合、 コマンドライン上、 シンボリックリンクが <B>-follow</B> の後ろに指定されている場合は、
参照をたどるのに対して、 その前に指定されたものは参照をたどりません。)
<P>
<DL COMPACT>
<DT>-D debugopts<DD>
診断情報を出力します。 <B>find</B> が思うように動かない場合に、 原因調査に役立てることができます。 デバッグオプションを複数指定するときは、
カンマで区切ります。 findutils のリリース間において、 デバッグオプションの互換性は保証されません。 有効なデバッグオプションの一覧は、
<B>find -D&nbsp;help</B> の出力を確認してください。 有効なデバッグオプションには、 以下のものがあります。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>exec<DD>
-exec, -execdir, -ok, -okdir に関連する診断情報を表示します。
<DT>opt<DD>
式ツリー (expression tree) の最適化に関する診断情報を表示します。 -O オプションを参照してください。
<DT>rates<DD>
述語表現が成功あるいは失敗した回数を、 取りまとめて表示します。
<DT>search<DD>
ディレクトリツリーを詳細に示します。
<DT>stat<DD>
システムコールの <B>stat</B> や <B>lstat</B> を使って、 ファイルが調べられた場合に、 メッセージを表示します。 <B>find</B>
プログラムは、 そのようなシステムコールの呼び出しを、 最小となるように処理します。
<DT>tree<DD>
式ツリー (expression tree) を、 元の形と最適化した形で示します。
<DT>all<DD>
すべてのデバッグオプションを有効にします (ただし <B>help</B> は除きます)。
<DT>help<DD>
デバッグ用オプションを説明します。
</DL>
</DL>

<DT>-Olevel<DD>
問い合わせの最適化を有効にします。 <B>find</B> プログラムは、 複数テスト全体の処理内容を変えることなく、 テストの順番を並べ替えて、
実行速度を上げます。 ただし、 副作用を持つ述語は、 他の述語と入れ替えは行いません。 最適化レベルごとの最適化の違いは以下のとおりです。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>0<DD>
最適化レベル 1 と同じです。
<DT>1<DD>
これはデフォルトの最適化レベルであり、 従来からある動作です。 ファイル名だけを確認するテスト (たとえば <B>-name</B> や <B>-regex</B>)
が先に実行されるように、 式の並び替えを行います。
<DT>2<DD>
ファイル名だけを確認するテストよりも、<B>-type</B> あるいは <B>-xtype</B> を後に処理します。 ただし i
ノードからの情報を必要とするテストよりは、 前に処理します。 最近の Unix では、 <B>readdir()</B>
関数がファイルタイプを返すようになっているため、 これらの述語表現は、 ファイル情報を最初に調べる述語表現に比べて、 処理が高速になります。 述語表現の
<B>-fstype</B> <I>FOO</I> を用いた際に、 指定したファイルシステムタイプ <I>FOO</I> が、 <B>find</B> の起動時点において不明なもの
(`/etc/mtab' に存在しないもの) であった場合、 この述語表現は <B>-false</B> に等しくなります。
<DT>3<DD>
この最適化レベルでは、 コストベースによって最適化を行う、 完全な問合せオプティマイザー (query optimiser) を有効にします。
コストの低い (つまり高速になる) テストを先に処理し、 コストの高いものは後に処理するというように、 必要に応じた並び替えが行われます。
一定のコストの幅の中では、 述語表現が成功するか否かの可能性を考慮して、 述語表現の評価を先に行ったり、 後に行ったりします。 <B>-o</B> の場合は、
成功する可能性のあるものが、 先に評価されます。 <B>-a</B> の場合は、 失敗する可能性のあるものが、 先に評価されます。
</DL>
</DL>

<DT><DD>
コストベースのオプティマイザーは、 対象のテストが成功するかどうかに関して、 一定の取り決めを設けています。 成功するかどうかの判断は、
テストの性質を配慮して、 状況により変化する場合があります (たとえば <B>-type&nbsp;f</B> の場合は、 <B>-type&nbsp;c</B> よりも、
成功する可能性が高いとみなしています)。 コストベースのオプティマイザーは現在、 評価中の段階です。 したがって、 <B>find</B>
の性能が実際に向上しなければ、 削除される予定です。 逆に、 この機能に信頼性や確実さが確認されて、 効果的であることが分かれば、 後々、
下位の最適化レベルにおいて実現するかもしれません。 ただし、 4.3.x 系のリリースにおいては、 デフォルトの動作 (最適化レベル 1)
を変更する予定はありません。 findutils のテストスイートでは、 <B>find</B> に対するテストすべてにおいて、
各最適化レベルでの処理を実施していて、 その結果が同一になることを確認しています。
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>式</H2>

コマンドライン上で、 検索開始ポイント (starting-point) のリストの次にくるものが、式 (<I>expression</I>) です。 式は、
検索方法を定めます。 どのファイルに一致するか、 一致したファイルをどう処理するか、 ということを表します。 式は、 以下の項目から構成されます。
<P>
<DL COMPACT>
<DT>テスト (test)<DD>
テストは true または false を返します。 通常その値は、 処理時点での対象ファイルの所定のプロパティに基づいて決まります。 たとえば
<B>-empty</B> というテストは、 対象ファイルが空の場合に true になります。
<P>
<DT>アクション (action)<DD>
アクションには副作用があり (たとえば、 標準出力に何かを表示するなどして)、 その上で true または false を返します。 通常その値は、
副作用による処理の成功または失敗に基づいて決まります。 たとえば <B>-print</B> というアクションは、 対象ファイルの名前を標準出力に出力します。
<P>
<DT>グローバルオプション (global option)<DD>
グローバルオプションは、 コマンドライン上に指定されているテストやアクションすべてに影響を及ぼします。 グローバルオプションは、 必ず true
を返します。 たとえば、 <B>-depth</B> オプションを指定すると、 <B>find</B> がファイルシステムをたどるときに、 深い方から先
(depth-first order) に処理します。
<P>
<DT>位置オプション (positional option)<DD>
位置オプションは、 この後ろにあるテストやアクションに対してのみ影響を及ぼします。 位置オプションは、 必ず true を返します。 たとえば
<B>-regextype</B> オプションは、 その記述位置によって動作が決まります。 コマンドライン上で、 この記述以降に現れる正規表現が、
どういった方言の正規表現であるかを指定します。
<P>
<DT>オペレーター (operator)<DD>
オペレーターは、 式を構成する項目どうしを結びつけます。 オペレーターには、 <B>-o</B> (論理 OR の意味) や <B>-a</B> (論理 AND
の意味) があります。 オペレーターがないところは、 <B>-a</B> があるものとみなされます。
<P>
</DL>
<P>

式がすべて true になったファイルに対して、 アクション <B>-print</B> が実行されます。 ただしアクション <B>-prune</B> または
<B>-quit</B> を除いた、 他のアクションがある場合は、 実行されません。 デフォルトの <B>-print</B> の動作を発生させないアクションは、
以下のものです。 <B>-delete</B>, <B>-exec</B>, <B>-execdir</B>, <B>-ok</B>, <B>-okdir</B>, <B>-fls</B>,
<B>-fprint</B>, <B>-fprintf</B>, <B>-ls</B>, <B>-print</B>, <B>-printf</B>
<P>
<P>
<B>-delete</B> というアクションは、 オプションのようにも働きます (<B>-depth</B> の指定を暗に含むためです)。
<P>
<A NAME="lbAG">&nbsp;</A>
<H3>位置オプション</H3>

位置オプションは、 常に true を返します。 位置オプションは、 この後ろにあるテストに対してのみ影響を及ぼします。
<P>
<DL COMPACT>
<DT>-daystart<DD>
時間の計測を、 24 時間前からではなく、 本日の始まりからとします (対象は <B>-amin</B>, <B>-atime</B>, <B>-cmin</B>,
<B>-ctime</B>, <B>-mmin</B>, <B>-mtime</B> です)。 このオプションの指定が有効になるのは、
コマンドライン上でこれよりも後ろに記述されたテストに対してのみです。
<P>
<DT>-follow<DD>
非推奨とされています。 代わりに <B>-L</B> オプションを使ってください。 これはシンボリックリンクをたどます。 <B>-noleaf</B>
の指定を暗に含みます。 <B>-follow</B> オプションが影響を及ぼすのは、 コマンドライン上で、 これよりも後ろに指定されたテストに対してのみです。
<B>-H</B> あるいは <B>-L</B> オプションの指定がなければ、 <B>-follow</B> オプションが記述されると、 述語表現 <B>-newer</B>
の動作は変わります。 <B>-newer</B> の引数として指定されたファイルが、 シンボリックリンクであった場合は、 そのリンク先が参照されます。
<B>-newerXY</B>, <B>-anewer</B>, <B>-cnewer</B> についても同様です。 また、 述語表現の <B>-type</B> も、
シンボリックリンクそのものではなく、 シンボリックリンク先のファイルタイプに一致するようになります。 <B>-follow</B> を指定すると、 述語表現
<B>-lname</B> と <B>-ilname</B> は、 必ず false を返します。
<P>
<DT>-regextype <I>type</I><DD>
コマンドライン上で、 この後に記述されるテスト <B>-regex</B> と <B>-iregex</B> に対して、 解釈する正規表現文法を変更します。
正規表現の種類には何があるかについては、 <B>-regextype&nbsp;help</B> を実行して確認してください。 Texinfo 文書
(「関連項目」参照) では、 各種正規表現の意味や違いについて説明しています。
<P>
<DT>-warn, -nowarn<DD>
警告メッセージの表示、非表示を切り替えます。 この警告は、 コマンドラインの使用法に関するものだけを対象とします。 逆に <B>find</B>
のディレクトリ検索時における処理状況に関するものは、 対象としません。 デフォルトの動作は、 標準入力が tty であれば <B>-warn</B> になり、
そうでなければ <B>-nowarn</B> になります。 コマンドラインの使用法に関する警告メッセージが出力された場合であっても、 <B>find</B>
の終了ステータスには影響しません。 環境変数 <B>POSIXLY_CORRECT</B> が設定された状態で、 <B>-warn</B> が指定されると、
警告が発生したとしても、 どの警告を出すのかは未定です。
<P>
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>グローバルオプション</H3>

グローバルオプションは、必ず true を返します。 グローバルオプションは、 コマンドライン上で、
これよりも前にあるテストに対しても影響を及ぼします。 混乱を避けるために、 コマンドライン上でのグローバルオプションの指定は、
検索開始ポイントのリストの後ろで、 テスト、位置オプション、 アクションの直前に指定してください。 グローバルオプションを、
それとは別の場所で指定すると、 <B>find</B> は、 混乱する可能性があることを示す警告メッセージを出力します。
<P>
グローバルオプションの指定位置は、 検索開始ポイントのリストより後ろです。 このため <B>-L</B> とは異なる種類のものです。 たとえば以下のとおりです。
<P>
<DL COMPACT>
<DT>-d<DD>
-depth と同じです。 FreeBSD, NetBSD, MacOS X, OpenBSD との互換性のためにあります。
<P>
<DT>-depth<DD>
ディレクトリそのものより前に、 ディレクトリの中を処理します。 アクション <B>-delete</B> には <B>-depth</B>
オプションが暗に含まれています。
<P>
<DT>-files0-from <I>file</I><DD>
検索開始ポイントを、 コマンドラインから指定されたものを使わずに、 <I>file</I> から読み込みます。
コマンドラインからの引数として検索開始ポイントを指定することには、 一定の制約がありました。 つまりファイルの指定数に上限があったことです。
またオプション名とかぶるようなファイル名の場合に、 見誤ってしまうことがありました。 このオプションを使うと、 <B>find</B>
に指定する検索開始ポイントを、 安全にまた任意の数だけ受け渡すことができます。
<P>
このオプションを用いることと、 コマンドラインから検索開始ポイントを受け渡すことは、 互いに排他的な関係にあります。
つまり両方を同時に用いることはできません。
<P>
引数 <I>file</I> は必須です。 検索開始ポイントの一覧を <I>標準入力</I> ストリームからとることは可能であり、
たとえばパイプを使って受け渡すことができます。 その場合、 アクション <B>-ok</B> と <B>-okdir</B> は用いることができません。
これらはユーザーからの入力確認を行うものであるため、 <I>標準入力</I> からの読み込みとは、 明らかに相容れないものになるからです。
<P>
<I>file</I> 内の検索開始ポイントは、 ASCII NUL 文字によって区切ります。 2 つの連続した NUL 文字、
つまり検索開始ポイントのファイル名の長さがゼロであるものは、 指定することができません。
その場合はエラーメッセージが出力されて、最後にゼロ以外の終了コードが返されます。
<P>
指定された <I>file</I> が空の場合、 <B>find</B> は検索開始ポイントがないものとして処理をするため、 プログラム引数を解析した後に、
すぐに終了します。 これは、 パス引数が受け渡されなかった場合に、 <B>find</B> の標準的な呼び出しを行えば、
カレントディレクトリを検索開始ポイントとする動作とは異なることになります。
<P>
検索開始ポイントからの処理は、 それ以外の点では通常どおり行われます。 つまり <B>find</B> は特に指示がない限りは、
サブディレクトリを再帰的に処理します。 検索開始ポイントだけを処理するには、 さらに <B>-maxdepth&nbsp;0</B> を指定することができます。
<P>
さらに注意点です。 入力ファイル内に所定のファイルが複数回記述されていた場合、 それが複数回検索されることになるかどうかは不定です。 <B>find</B>
の処理中に <I>file</I> が変更された場合も、 同様に不定です。 また <B>find</B> が終了する際の、その指定された <I>file</I>
内の検索位置も、 終了方法が <B>-quit</B> であるか別の方法であるかを問わず、 不定となります。 ここで &quot;不定&quot; と言っているのは、
動作するしないは分からず、何か特定の処理がなされるかもしれないということであり、 その動作は、 プラットフォームによって変わるかもしれないし、
<B>findutils</B> のリリースによって変わるかもしれないということです。
<P>
<DT>-help, --help<DD>
<B>find</B> のコマンドラインの使用方法の概要を表示して終了します。
<P>
<DT>-ignore_readdir_race<DD>
通常 <B>find</B> は、 ファイル情報の取得に失敗したときには、 エラーメッセージを出力します。 このオプションを指定した場合、
ディレクトリからファイル名を読み込んだときと、 ファイル情報を取得しようとしたときの間で、 ファイルが削除されてしまっていても、
エラーは表示されません。 この動作は、 コマンドライン上から指定されるファイルやディレクトリに対しても適用されます。 このオプションは、
コマンドラインから読み込みを行う段階で有効となるので、 ファイルシステムの一部に対して、 このオプションをオンとし、
残りの部分はオフとするような指定はできません。 (これを実現しなければならない場合は、 <B>find</B> コマンドを 2 つ実行することが必要です。1
つは本オプションをオンにして、 もう 1 つはオフにして実行します。)
<P>
さらに、 <B>-ignore_readdir_race</B> オプションを指定した <B>find</B> の実行では、 親ディレクトリを読み込んだ後に、
対象ファイルが消失している状況が発生した場合、 <B>-delete</B> アクションからのエラーも無視します。 その場合には、 診断エラーは出力されず、
<B>-delete</B> アクションからの返り値も true になります。
<P>
<DT>-maxdepth <I>levels</I><DD>
検索開始ポイントから最大で、 <I>levels</I> で示される階層数のディレクトリまで検索します (<I>levels</I> は負ではない整数です)。
<B>-maxdepth 0</B> を指定すると、 テストやアクションの対象は、 検索開始ポイントだけになります。
<P>
<DT>-mindepth <I>levels</I><DD>
検索開始ポイントから <I>levels</I> で示される階層数のディレクトリに至るまでは、 テストやアクションを適用しません (<I>levels</I>
は負ではない整数です。)。 <B>-mindepth 1</B> を指定すると、 検索開始ポイントを除いたファイルを、 すべて処理することになります。
<P>
<DT>-mount<DD>
ファイルシステムが異なる場合は、 ディレクトリを検索しません。 これは <B>-xdev</B> の別名であり、 バージョンが異なる <B>find</B>
との互換性のために設けられています。
<P>
<DT>-noignore_readdir_race<DD>
<B>-ignore_readdir_race</B> の効果を無効にします。
<P>
<DT>-noleaf<DD>
ディレクトリに含まれるサブディレクトリ数が、 ハードリンク数よりも 2 つ少ない、 とする想定のもとでの最適化を無効にします。
このオプションが必要になるのは、 Unix のディレクトリとリンクに関する慣例に従っていないファイルシステム、 たとえば CD-ROM、 MS-DOS
ファイルシステム、 AFS ボリュームマウントポイントを検索する場合です。 通常の Unix ファイルシステムにおいては、 各ディレクトリに最低でも 2
つのハードリンクがあります。 ディレクトリ名そのものと、 `.' エントリです。 そしてサブディレクトリがある場合に、 そのサブディレクトリには、
親ディレクトリにリンクする `..' というエントリがあります。 そこで <B>find</B> がディレクトリを調べる際に、
ディレクトリへのリンク数よりも 2 つ分だけ少ないサブディレクトリを調べた後であれば、 ディレクトリ内の残りのエントリは、 ディレクトリではない
(ディレクトリツリー内の「葉」(leaf) ファイルである) ことが決定します。 ファイル名を調べるだけで十分であれば、
ファイル情報を調べる必要がなくなるので、 これを利用すれば、 検索速度が明らかに向上します。
<P>
<DT>-version, --version<DD>
<B>find</B> のバージョンを表示して終了します。
<P>
<DT>-xdev<DD>
異なるファイルシステムのディレクトリを検索しません。
<P>
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>テスト (test)</H3>

テストの中には、 <B>-newerXY</B> や <B>-samefile</B> のように、 その時点で対象となっているファイルと、
コマンドラインから指定する参照ファイル (reference file) との間で、 比較を行うものがあります。 そのようなテストが指定された際に、
参照ファイルに対する解釈は、 <B>-H</B>, <B>-L</B>, <B>-P</B> といったオプションや、 先行する <B>-follow</B> の存在によって決定します。
ただし、 参照ファイルが調べられるのは、 コマンドラインが解析されるときの 1 回だけです。 参照ファイルが調べられなかった場合 (たとえば、
<B><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></B>(2) システムコールに失敗した場合)、 エラーメッセージが出力されて、 <B>find</B> は 0 以外のステータスを返して終了します。
<P>

数値引数である <I>n</I> は、 以下のテスト、 <B>-amin</B>, <B>-mtime</B>, <B>-gid</B>, <B>-inum</B>, <B>-links</B>,
<B>-size</B>, <B>-uid</B>, <B>-used</B> において指定できます。 そして以下のような指定方法があります。
<DL COMPACT>
<DT><I>+n</I><DD>
<I>n</I> より大きい。
<DT><I>-n</I><DD>
<I>n</I> より小さい。
<DT><I>n</I><DD>
<I>n</I> にちょうど等しい。
</DL>
<P>

サポートされているテスト:
<P>
<DL COMPACT>
<DT>-amin <I>n</I><DD>
ファイルの最終アクセス時間が、 <I>n</I> 分前と比較して、 それよりも前か後かちょうど同じかをテストします。
<P>
<DT>-anewer <I>reference</I><DD>
現在ファイルの最終アクセス時間が、 <I>reference</I> (参照ファイル) の最終更新時間よりも、 新しいかどうかをテストします。 引数
<I>reference</I> がシンボリックリンクであり、 <B>-H</B> や <B>-L</B> オプションが有効になっている場合は、
リンク先ファイルの最終更新時間が常に利用されます。
<P>
<DT>-atime <I>n</I><DD>
ファイルの最終アクセス時間が、 <I>n</I>*24 時間前と比較して、 それよりも前か後かちょうど同じかをテストします。 ファイルの最終アクセス時間が、
24 時間の何倍であるかを割り算して計算する際に、 端数は無視されます。 したがって、 <B>-atime&nbsp;+1</B> に一致するためには、
ファイルは少なくとも 2 日前にアクセスされていなければなりません。
<P>
<DT>-cmin <I>n</I><DD>
ファイルステータスの最終変更時間が、 <I>n</I> 分前と比較して、 それよりも前か後かちょうど同じかをテストします。
<P>
<DT>-cnewer <I>reference</I><DD>
現在ファイルの最終ステータス変更時間が、 <I>reference</I> (参照ファイル) の最終更新時間よりも、 新しいかどうかをテストします。 引数
<I>reference</I> がシンボリックリンクであり、 <B>-H</B> や <B>-L</B> オプションが有効になっている場合は、
リンク先ファイルの最終更新時間が常に利用されます。
<P>
<DT>-ctime <I>n</I><DD>
ファイルステータスの最終変更時間が、 <I>n</I>*24 時間前と比較して、
それよりも前か後かちょうど同じかをテストします。ファイルステータスの更新時間の解釈にあたって、丸め処理がどのように影響するかについては、
<B>-atime</B> の説明を参照してください。
<P>
<DT>-empty<DD>
ファイルが空であって、 通常のファイルかディレクトリであるかどうかをテストします。
<P>
<DT>-executable<DD>
実行可能なファイルか、 あるいは、 現在のユーザーが  (ファイル名解決の観点で) 検索可能なディレクトリであるかどうかをテストします。 このテストは、
アクセスコントロールリスト (access control list; ACL) や、 この他のパーミッション機能を考慮します。 ちなみに、 テスト
<B>-perm</B> では無視されます。 本テストは、 システムコール <B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2) を利用するので、 NFS サーバーが UID マッピング
(つまり root squash) を行っている場合に、 適切に動作しない場合があります。 多くのシステムでは、 クライアントのカーネルにおいて
<B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2) を実装しているため、 サーバー側にある UID マッピング情報を利用できないからです。 このテストは、
<B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2) システムコールの結果だけに基づいているため、 このテストが true となったファイルが、
実際に実行できるかどうかの保証はありません。
<P>
<DT>-false<DD>
必ず false を返します。
<P>
<DT>-fstype <I>type</I><DD>
ファイルが存在するファイルシステムが、 <I>type</I> かどうかをテストします。 いろいろな Unix システムに対して、
有効なファイルシステムは変わります。 Unix などの各種システムにおいて、 許容されるファイルシステムタイプを、 その一部だけあげてみると、 ufs,
4.2, 4.3, nfs, tmp, mfs, S51K, S52K といったものです。 <B>-printf</B> のディレクティブ %F を使えば、
現在のファイルシステムタイプを確認することができます。
<P>
<DT>-gid <I>n</I><DD>
ファイルのグループ ID 番号が、 <I>n</I> と比較して、 それよりも小さいか大きいかちょうど同じかをテストします。
<P>
<DT>-group <I>gname</I><DD>
ファイルの属するグループが <I>gname</I> かどうかをテストします (グループ ID 番号による指定も可)。
<P>
<DT>-ilname <I>pattern</I><DD>
<B>-lname</B> と同様ですが、 大文字小文字は区別しません。 <B>-L</B> または <B>-follow</B> オプションが有効な場合、
シンボリックリンクが切れていない限り、 このテストは false を返します。
<P>
<P>
<DT>-iname <I>pattern</I><DD>
<B>-name</B> と同様ですが、 大文字小文字は区別しません。 たとえば、 パターン `fo*' や `F??' は、 `Foo', `FOO',
`foo', `fOo' などのファイル名に一致します。 また、 パターン `*foo*' は、 `.foobar' というファイルにも一致します。
<P>
<DT>-inum <I>n</I><DD>
ファイルの i ノード番号が、 <I>n</I> と比較して、 それよりも小さいか大きいかちょうど同じかをテストします。 普通はこれよりも、
<B>-samefile</B> を使った方が簡単です。
<P>
<DT>-ipath <I>pattern</I><DD>
<B>-path</B> と同様です。  ただし大文字小文字を区別しません。
<P>
<DT>-iregex <I>pattern</I><DD>
<B>-regex</B> と同様です。 ただし大文字小文字を区別しません。
<P>
<DT>-iwholename <I>pattern</I><DD>
<B>-ipath</B> を参照してください。 この別名は、 <B>-ipath</B> よりも移植性に劣ります。
<P>
<DT>-links <I>n</I><DD>
ファイルが持つハードリンクの数が、 <I>n</I> と比較して、 小さいか大きいかちょうど同じかをテストします。
<P>
<DT>-lname <I>pattern</I><DD>
ファイルがシンボリックリンクであって、 その内容がシェルパターン <I>pattern</I> に一致するかどうかをテストします。 メタ文字は、 `/' や
`.' を特別扱いしません。 <B>-L</B> または <B>-follow</B> オプションが有効な場合には、 シンボリックリンクが切れていない限り、
このテストは false を返します。
<P>
<DT>-mmin <I>n</I><DD>
ファイルの最終更新時間が、 <I>n</I> 分前と比較して、 それよりも前か後かちょうど同じかをテストします。
<P>
<DT>-mtime <I>n</I><DD>
ファイルの最終更新時間が、 <I>n</I>*24 時間前と比較して、 それよりも前か後かちょうど同じかをテストします。 何日前かを計算する際、 時間差を 24
時間で割った結果を丸めるため、 ファイル更新時間の解釈にあたって、 その処理がどのように影響するかについては、 <B>-atime</B>
の説明を参照してください。
<P>
<DT>-name <I>pattern</I><DD>
ファイルのベース名 (パス名から、 先行するディレクトリを取り除いたもの) が、 シェルのパターン <I>pattern</I>
に一致するかどうかをテストします。 先行するディレクトリを取り除いているので、 <B>-name</B> を使って一致の確認を行うファイル名には、
スラッシュが含まれないものとして扱われます。 つまり `-name a/b' としても、 一致するものはありません (その場合は、 おそらく
<B>-path</B> を用いる必要があります)。 これを行ってしまった場合、 環境変数 <B>POSIXLY_CORRECT</B> が設定されていない限りは、
警告メッセージが出力されます。 メタ文字 (`*', `?', `[]') は、 ベース名の先頭にある `.' に一致します (これは
findutils-4.2.2 から変更されました。以降のセクション「規格への準拠」を参照してください)。 1
つのディレクトリとそこに含まれるファイルを無視したい場合は、 ディレクトリツリー内の全ファイルを確認するのではなく、 <B>-prune</B>
を使います。<B>-prune</B> の説明において、 例を説明しているので参照してください。 波カッコ ('{}') は、 特別な文字としては扱われません。
bash などのシェルにおいては、 シェルパターン内の波カッコに特別な意味を持つものがありますが、 この点は異なります。 ファイル名のマッチングは、
<B><A HREF="../../LDP_man-pages/man3/fnmatch.3.html">fnmatch</A></B>(3) ライブラリ関数を用いて行われます。 シェルによってパターンが展開されないように、
パターンはクォートで囲むことを忘れないでください。
<P>
<DT>-newer <I>reference</I><DD>
対象ファイルの最終更新時間が、 <I>reference</I> ファイルの最終更新時間よりも、 最新であるかどうかをテストします。 <I>reference</I>
がシンボリックリンクであって、 <B>-H</B> または <B>-L</B> オプションが有効である場合は、 リンク先ファイルの更新時間が用いられます。
<P>
<DT>-newerXY <I>reference</I><DD>
対象ファイルのタイムスタンプ <I>X</I> が、 <I>reference</I> ファイルのタイムスタンプ <I>Y</I> より、 新しいかどうかをテストします。
<I>X</I> と <I>Y</I> の位置に記述する文字は、 以下の文字とします。
<P>
<TABLE>
<TR VALIGN=top><TD>a</TD><TD><I>reference</I> ファイルのアクセス時間<BR></TD></TR>
<TR VALIGN=top><TD>B</TD><TD><I>reference</I> ファイルの生成時間<BR></TD></TR>
<TR VALIGN=top><TD>c</TD><TD><I>reference</I> ファイルの i ノードステータスが変更された時間<BR></TD></TR>
<TR VALIGN=top><TD>m</TD><TD><I>reference</I> ファイルの内容更新時間<BR></TD></TR>
<TR VALIGN=top><TD>t</TD><TD><I>reference</I> に直接時間表現が書かれたとして解釈<BR></TD></TR>
</TABLE>

<P>
組み合わせによっては、 無効になるものも発生します。 たとえば、 <I>X</I> に <I>t</I> を指定しても無効です。 またシステムによっては、
特定の組み合わせを実装していない場合があります。 たとえば <I>B</I> は、 すべてのシステムでサポートされているわけではありません。 指定された
<I>XY</I> の組み合わせが、 無効や未サポートの場合は、 致命的エラーが発生します。 時間表現は、 GNU <B>date</B> における <B>-d</B>
オプションに対する引数と同様のものとして解釈されます。 参照ファイルの生成時間を使用しようとて、 その生成時間が決定できなかった場合は、
致命的エラーになります。 また、 対象ファイルの生成時間を参照するテストを用いた際に、 生成時間が不明な場合は、 そのテストは失敗します。
<P>
<DT>-nogroup<DD>
ファイルのグループ ID 番号が、 システムに存在していないことをテストします。
<P>
<DT>-nouser<DD>
ファイルのユーザー ID 番号が、 システムに存在しないことをテストします。
<P>
<DT>-path <I>pattern</I><DD>
ファイル名が、 シェルのパターン <I>pattern</I> に一致するかどうかをテストします。 メタ文字は、 `/' や `.' を特別扱いしません。
したがってたとえば、

<PRE>
find . -path &quot;./sr*sc&quot;
</PRE>


は、 <I>./src/misc</I> というディレクトリ (それが存在している場合) の内容を表示します。 ディレクトリツリー全体を対象としないのであれば、
ツリー内の各ファイルを確認していくのではなく、 <B>-prune</B> を用います。 パターン一致を確認するようなテストは、
ファイル名すべてに対して適用されます。 つまりそのファイル名は、 コマンドライン上から指定された検索開始点から始まる、 検索対象すべてです。
このパターンにおいて、 絶対パスを指定するなら、 検索開始点も絶対パスでなければ意味がありません。 つまり以下のようなコマンドでは、
どのファイルも一致しません。
<BR>


<PRE>
find bar -path /foo/bar/myfile -print
</PRE>


<B>find</B> が <B>-path</B> の引数と比較するのは、 その時点で対象としているファイルのディレクトリとベース名を連結した文字列です。
その文字列の末尾がスラッシュになることはないため、 <B>-path</B> の引数の末尾にスラッシュを指定すると、 何にも一致しないことになります。
(ただし、 コマンドラインで指定された検索開始ポイントには、 おそらく一致します)。 述語表現 <B>-path</B> は、 HP-UX の <B>find</B>
でもサポートされていて、 POSIX 2008 規格に存在します。
<P>
<DT>-perm <I>mode</I><DD>
ファイルの許可属性が <I>mode</I> (8 進数表現またはシンボル表現) に一致するかどうかをテストします。 <I>mode</I> 指定のこの形式では、
完全一致が求められるので、 この形式をシンボリックモードで使う場合には、 モード文字列の指定が多少複雑になるかもしれません。 たとえば `-perm
g=w' は、 許可属性が 0020 のファイルにのみ一致します (つまり、 グループの書き込み権限のみを設定します)。 おそらく、 `/' や `-'
を用いる形式を必要とすることがあります。 たとえば、 `-perm -g=w' とすれば、 グループの書き込み許可があるファイルに一致します。
具体例については「例」セクションを参照してください。
<P>
<DT>-perm -<I>mode</I><DD>
<I>mode</I> で指定した許可属性ビットすべてが、 対象ファイルのものに一致するかどうかをテストします。 この形式でも、
シンボリックモード指定が可能です。 このモードは、 ごく普通に用いたくなるはずです。 シンボリックモードでは、 `u'、 `g'、 `o'
を用いる必要があります。 具体例については「例」セクションを参照してください。
<P>
<DT>-perm /<I>mode</I><DD>
<I>mode</I> で指定した許可属性ビットの一部が、 対象ファイルのものに一致するかどうかをテストします。 この形式でも、
シンボリックモード指定が可能です。 シンボリックモードでは、 `u'、 `g'、 `o' を用いる必要があります。
具体例については「例」セクションを参照してください。 なお、 <I>mode</I> の許可属性ビットが何も設定されていない場合、 このテストは、
どんなファイルにも一致します (この動作は、 <B>-perm&nbsp;-000</B> と一貫性を持たせるためです)。
<P>
<DT>-perm +<I>mode</I><DD>
この書式は、 もうサポートされていません (2005 年以来、 非推奨となっています)。 代わりに <B>-perm /</B><I>mode</I>
を用いてください。
<P>
<DT>-readable<DD>
現在のユーザーによって読み込み可能なファイルであるかどうかをテストします。 このテストは、 アクセスコントロールリスト (access control
list; ACL) や、 その他のパーミッション機能を考慮します。 ちなみに、 テスト <B>-perm</B> では無視されます。 本テストは、
システムコール <B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2) を利用するので、 NFS サーバーが UID マッピング (つまり root squash)
を行っている場合に、 適切に動作しない場合があります。 多くのシステムでは、 クライアントのカーネルにおいて <B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2)
を実装しているため、 サーバー側にある UID マッピング情報を利用できないからです。
<P>
<DT>-regex <I>pattern</I><DD>
ファイル名が正規表現 <I>pattern</I> に一致するかどうかをテストします。 この処理は、 パス全体への一致を確認するものであって、
ファイル検索ではありません。 したがってたとえば、 `./fubar3' ファイルに一致する正規表現として、 `.*bar.' や `.*b.*3'
は利用できますが、 `f.*r3' は利用できません。 <B>find</B> が扱う正規表現のデフォルトは、 Emacs 正規表現です ('.'
が改行に一致する点は除きます)。 これは、 <B>-regextype</B> オプションを用いて変更することができます。
<P>
<DT>-samefile <I>name</I><DD>
対象ファイルが、 <I>name</I> と同じ i ノードを参照しているかどうかをテストします。 <B>-L</B> が有効であれば、
シンボリックリンクを対象とすることができます。
<P>
<DT>-size <I>n</I>[cwbkMG]<DD>
ファイルが <I>n</I> 単位分の容量と比較して、 それよりも小さいか大きいかちょうど同じかをテストします。 ここでは丸め処理が行われます。
以下のサフィックスが利用できます。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>`b'<DD>
512 バイトブロックを表します (サフィックスの指定がない場合は、 これがデフォルトとなります)。
<DT>`c'<DD>
バイトを表します。
<DT>`w'<DD>
2 バイトワードを表します。
<DT>`k<DD>
キビバイトを表します (kibibyte, KiB, 1024 バイト単位)。
<DT>`M'<DD>
メビバイトを表します (mebibyte, MiB, 1024 * 1024 単位 = 1048576 バイト)。
<DT>`G'<DD>
ギビバイトを表します (gibibyte, GiB, 1024 * 1024 * 1024 単位 =
10737418241073741824)。
</DL>
</DL>

<DT><DD>
サイズというのは単純に、 システムコールの lstat (あるいは stat) に含まれている struct stat の メンバー st_size
のことであり、 上に示すようにして切り上げられます。言い換えると、 その結果は <B>ls&nbsp;-l</B> で得られるものと一致します。<B>-printf</B>
における `%k' と `%b' の書式指定子は、 スパースファイルに対して、 異なる扱いをする点に注意してください。 サフィックス `b' は、 常に
512 バイトブロックを表していて、 1024 バイトブロックを表すことはありません。 この点は、 <B>-ls</B> の動作とは異なるところです。
<DT><DD>
プレフィックスの + と - は、 ごく普通に、 それより上、 それより下、 を表します。 したがって、 <I>n</I> とちょうど同じ数には一致しません。
サイズとは、 次の数単位に向けて切り上げられることに注意してください。 つまり <B>-size&nbsp;-1M</B> というのは、 <B>-size&nbsp;-1048576c</B> と同じではありません。 前者は、 空のファイルにしか一致しません。 また後者は、 バイトサイズが 0 から
1,048,575 までのファイルに一致します。
<DT>-true<DD>
常に true です。
<P>
<DT>-type <I>c</I><DD>
ファイルタイプが <I>c</I> であるかどうかをテストします。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>b<DD>
ブロックスペシャルファイル (バッファーあり)
<DT>c<DD>
キャラクタースペシャルファイル (バッファーなし)
<DT>d<DD>
ディレクトリ
<DT>p<DD>
名前付きパイプ (FIFO)
<DT>f<DD>
通常のファイル
<DT>l<DD>
シンボリックリンク。 オプション <B>-L</B> や <B>-follow</B> が有効な場合、 シンボリックリンク切れの場合を除いて、 このテストが true
になることはありません。 <B>-L</B> が有効なときに、 シンボリックリンクを検索するには、 <B>-xtype</B> を用いてください。
<DT>s<DD>
ソケット
<DT>D<DD>
ドア (door) (Solaris の場合)
</DL>
</DL>

<DT><DD>
一度に複数のファイルタイプを検索したい場合は、 タイプを表す英字を、 カンマ `,' で区切ったリストで指定します。 (GNU 拡張)
<DT>-uid <I>n</I><DD>
ファイル所有者のユーザー ID 番号が、 <I>n</I> と比較して、 それよりも小さいか大きいかちょうど同じかをテストします。
<P>
<DT>-used <I>n</I><DD>
ファイルのステータスが変更されてから、 ファイルにアクセスした最終時間が、 <I>n</I> 日間と比較して、 小さいか大きいかちょうど同じかをテストします。
<P>
<DT>-user <I>uname</I><DD>
ファイルの所有者が、 <I>uname</I> というユーザーであるかどうかをテストします (ユーザー ID 番号による指定も可)。
<P>
<DT>-wholename <I>pattern</I><DD>
<B>-path</B> を参照してください。 この別名は、 <B>-path</B> よりも移植性に劣ります。
<P>
<DT>-writable<DD>
現在のユーザーによって書き込み可能なファイルであるかどうかをテストします。 このテストは、 アクセスコントロールリスト (access control
list; ACL) や、 その他のパーミッション機能を考慮します。 ちなみに、 テスト <B>-perm</B> では無視されます。 本テストは、
システムコール <B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2) を利用するので、 NFS サーバーが UID マッピング (つまり root squash)
を行っている場合に、 適切に動作しない場合があります。 多くのシステムでは、 クライアントのカーネルにおいて <B><A HREF="../../LDP_man-pages/man2/access.2.html">access</A></B>(2)
を実装しているため、 サーバー側にある UID マッピング情報を利用できないからです。
<P>
<DT>-xtype <I>c</I><DD>
対象ファイルがシンボリックリンクでなければ、 <B>-type</B> と同様です。 シンボリックリンクのときは、 以下のように動作します。 <B>-H</B> や
<B>-P</B> オプションの指定時は、 リンク先がタイプ <I>c</I> のファイルであれば、 true を返します。 <B>-L</B> オプションの指定時は、
<I>c</I> が `l' ならば true を返します。 言い換えると、 シンボリックリンクに対して、 <B>-xtype</B> は、 <B>-type</B>
がチェックしないファイルタイプをチェックします。
<DT>-context <I>pattern</I><DD>
(SELinux 有効時のみ) 対象ファイルのセキュリティコンテキストが glob パターン <I>pattern</I> に一致するかどうかをテストします。
<P>
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H3>アクション</H3>

<DL COMPACT>
<DT>-delete<DD>
ファイルまたはディレクトリを削除します。 削除に成功すると true を返します。 削除に失敗した場合は、
エラーメッセージを表示して、　ゼロ以外の終了ステータスを返します (最終終了するときです)。
<P>
<B>警告</B>: <B>find</B> はコマンドラインを式として評価する点を忘れないでください。 したがって <B>-delete</B> を一番初めに記述すると、
それは <B>find</B> に対して、 検索開始ポイント以下のものをすべて削除させることになります。
<P>
コマンドラインから <B>-delete</B> オプションを指定すると、 自動的に <B>-depth</B> オプションがオンとなります。 一方で
<B>-depth</B> は <B>-prune</B> を無効にするので、 <B>-delete</B> アクションは <B>-prune</B> と同時に用いることはできません。
<P>
ユーザーの中ではよく、 コマンドライン上において <B>-delete</B> の前に <B>-print</B> を指定して、
削除が実際にどのように行われるかをテストしようとします。 予期しない結果を起こさないためにも、 そのようなテストを行うときから、 <B>-depth</B>
オプションを明示的に指定することを忘れないでください。
<P>
<B>-delete</B> アクションは、 ディレクトリが空でない場合には削除に失敗します。
<P>
<B>-ignore_readdir_race</B> オプションとともに、 このオプションを指定し、 さらに、 親ディレクトリを読み込んだ後に、
対象ファイルが消失している状況が発生した場合、 <B>-delete</B> アクションからのエラーは無視されます。 その場合には、 診断エラーは出力されず、
終了コードをゼロ以外には変えずに <B>-delete</B> アクションからの返り値も true になります。
<P>
<P>
<DT>-exec <I>command</I> ;<DD>
<I>command</I> を実行します。 <I>command</I> の返り値が 0 なら、 true を返します。 <B>find</B> のコマンドラインで、
これ以降に指定されている引数は、 `;' という引数が現れるまで、 すべてそのコマンドに対する引数とみなされます。 文字列 `{}' は、
コマンド引数内に現れるすべての箇所で、 対象ファイル名に置き換えられます。 <B>find</B> の他の実装においては、 引数の中で `{}'
が単独で用いられていないと、 対象ファイル名に置き換えられないものがあります。 文字列 `{}' は、 シェルによって展開されないように、 どちらも
`\' でエスケープするか、 クォートで囲む必要があります。 アクション <B>-exec</B> の具体例については、 「例」セクションを参照してください。
指定されたコマンドは、 一致したファイルごとに一回ずつ実行されます。 そのコマンドは、 <B>find</B> を実行したディレクトリにおいて実行されます。
そこで、 <B>-exec</B> アクションの実行にあたっては、 セキュリティの問題が避けられません。 したがって、 <B>-exec</B> の代わりに、
<B>-execdir</B> アクションを使用してください。
<P>
<DT>-exec <I>command</I> {} +<DD>
この形式の <B>-exec</B> アクションは、  対象ファイルに対して、 指定されたコマンド (<I>command</I>) を実行します。 各対象ファイルは、
コマンドラインの末尾に追加されながら、 コマンドラインが構成されるので、 指定コマンドの呼び出し回数は、 対象ファイル数よりも大幅に少なくて済みます。
コマンドラインが構成される処理方法は、 <B>xargs</B> の場合とほぼ同じです。 `{}' の記述は、 コマンドライン中に 1
度しか用いることはできず、 しかも最後に `+' を伴って、 コマンドラインの最終記述としなければなりません。 また、
シェルによって誤った解釈が行われないように、 (`\' を使って)  エスケープするか、 全体をクォートで囲むことが必要です。 そのコマンドは、
<B>find</B> を実行したディレクトリにおいて実行されます。 '+' 形式を使った呼び出しにおいて、 終了ステータスにゼロでない値が返ってきたら、
<B>find</B> も、 終了ステータスにゼロ以外を返します。 <B>find</B> においてエラーが発生すると、 その場ですぐに終了する場合があります。
その際には、 残りのコマンドがまったく実行されないこともあります。 このため、 <B>-exec&nbsp;</B><I>my-command</I><B>&nbsp;...&nbsp;{}&nbsp;+&nbsp;-quit</B> では、 <I>my-command</I> が実際には実行されない場合があります。 なおこの <B>-exec</B> の形式は、 必ず true
を返します。
<P>
<DT>-execdir <I>command</I> ;<DD>
<DT>-execdir <I>command</I> {} +<DD>
<B>-exec</B> と同様ですが、 指定したコマンドは、 一致したファイルが存在するサブディレクトリ内で実行されます。 このサブディレクトリは、  普通は
<B>find</B> を実行したディレクトリとは異なるはずです。 <B>-exec</B> と同じように、 find をシェルから呼び出す場合には {}
をクォートでくくる必要があります。 この形式は、 コマンドを呼び出す方法として、 非常に安全なものです。 一致したファイルのパスを確定させる際に、
競合状態を避けることができるためです。 <B>-exec</B> アクションの場合と同様、 <B>-execdir</B> の `+' 形式の実行においても、
一致した複数ファイルを処理するようなコマンドラインが構成されます。 ただし、 指定された <I>command</I> の呼び出しは、 どの場合であっても、
必ず同一サブディレクトリ内にあるファイルだけを対象にして実行されます。 このオプションの利用にあたっては、 環境変数 <B>PATH</B> が、  `.'
を参照していないようにする必要があります。 そうしていないと、 攻撃者が、 <B>-execdir</B> を実行するディレクトリ内に、
いかにも正しいファイルを置くだけで、 任意のコマンド実行を許してしまうことになります。 <B>PATH</B> 内のエントリに、 空のものや、
相対パスのディレクトリ名を含んでいる場合にも、 同じことが言えます。 '+' 形式を使った呼び出しにおいて、
終了ステータスにゼロでない値が返ってきたら、 <B>find</B> も、 終了ステータスにゼロ以外を返します。 <B>find</B> においてエラーが発生すると、
その場ですぐに終了する場合があります。 その際には、 残りのコマンドがまったく実行されないこともあります。 このアクションが返す値は、 <B>+</B> と
<B>;</B> のどちらの形式を使うかによって異なります。 <B>-execdir&nbsp;</B><I>command</I><B>&nbsp;{}&nbsp;+</B> は必ず true
を返しますが、 <B>-execdir&nbsp;</B><I>command</I><B>&nbsp;{}&nbsp;;</B> は、 <I>command</I> が 0 を返したときだけ、 true
を返します。
<P>
<P>
<DT>-fls <I>file</I><DD>
true を返します。 <B>-ls</B> と同様ですが、 <B>-fprint</B> のように、 <I>file</I> への出力を行います。 出力ファイルは、
この述語表現に一致するものがなくても、 必ず生成されます。 ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-fprint <I>file</I><DD>
true を返します。 パス付きのファイル名を、 ファイル <I>file</I> に出力します。　<B>find</B> の実行時に、 <I>file</I>
が存在しなければ、 新たに生成されます。 すでに存在していたら、 元の中身は失われます。 ファイル名 <I>/dev/stdout</I> と
<I>/dev/stderr</I> は特別に扱われます。 それぞれ、 標準出力、 標準エラー出力を意味します。 出力ファイルは、
この述語表現に一致するものがなくても、 必ず生成されます。 ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-fprint0 <I>file</I><DD>
true を返します。 <B>-print0</B> と同様ですが、 <B>-fprint</B> のように、 <I>file</I> への出力を行います。 出力ファイルは、
この述語表現に一致するものがなくても、 必ず生成されます。 ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-fprintf <I>file</I> <I>format</I><DD>
true を返します。 <B>-printf</B> と同様ですが、 <B>-fprint</B> のように、 <I>file</I> への出力を行います。 出力ファイルは、
この述語表現に一致するものがなくても、 必ず生成されます。 ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-ls<DD>
true を返します。 対象ファイルを、 <B>ls -dils</B> の書式で標準出力に出力します。 ブロック数は、 1 ブロックに 1&nbsp;KB
バイトです。　ただし、 環境変数 <B>POSIXLY_CORRECT</B> が設定されている場合は、 1 ブロック 512
バイトが使用されます。　ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-ok <I>command</I> ;<DD>
<B>-exec</B> と同様ですが、 ユーザーへの問い合わせを行います。　ユーザーが同意すれば、 コマンドを実行します。 同意しなければ、 何もせずに
false を返します。 コマンドが実行される際に、 標準入力はリダイレクトされて、 <I>/dev/null</I> になります。 このオプションは
<B>-files0-from</B> オプションとともに指定することはできません。
<P>
<DT><DD>
プロンプトに対するユーザーの入力は、 肯定、 否定を表す一組の正規表現との一致確認が行われて、 同意したかどうかが決定します。 この正規表現は、
環境変数 <B>POSIXLY_CORRECT</B> が設定されていれば、 システムから取得されます。 環境変数が設定されていなければ、 <B>find</B>
が持つメッセージ翻訳から取得されます。 システムに適切な定義が存在しなかった場合は、 <B>find</B> 自体が持つ定義が使用されます。 どの場合でも、
正規表現そのものの解釈は、 環境変数 <B>LC_CTYPE</B> (文字クラス) や <B>LC_COLLATE</B> (文字の範囲や等価クラス)
の影響を受けます。
<P>
<P>
<P>
<DT>-okdir <I>command</I> ;<DD>
<B>-execdir</B> と同様ですが、 <B>-ok</B> と同じように、 ユーザーへの問い合わせを行ないます。 ユーザーが同意しなければ、 何もせずに
false を返します。 コマンドが実行される際に、 標準入力はリダイレクトされて、 <I>/dev/null</I> になります。 このオプションは
<B>-files0-from</B> オプションとともに指定することはできません。
<P>
<P>
<DT>-print<DD>
true を返します。 パス付きのファイル名と、 最後に改行文字をつけて、 標準出力に出力します。 <B>find</B> の出力を、
パイプを使って他のプログラムに受け渡している場合、 対象ファイル名に改行文字が含まれている可能性が、 少しでもあるなら、 <B>-print</B> ではなく、
<B>-print0</B> アクションの使用を是非考えてください。 ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、
「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>-print0<DD>
true を返します。 パス付きのファイル名と、 最後にヌル文字をつけて、 標準出力に出力します (<B>-print</B>
が改行文字をつけるのとは異なります)。 このアクションを使えば、 <B>find</B> の出力を処理するプログラムが、
改行文字やホワイトスペースを含むファイル名を、 正しく解釈できるようになります。 このアクションは、 <B>xargs</B> の <B>-0</B>
オプションに対応します。
<P>
<DT>-printf <I>format</I><DD>
true を返します。 これは標準出力に <I>format</I> を出力します。 <I>format</I> 内の `\' によるエスケープや、 `%'
に始まるディレクティブを解釈します。 フィールドの幅や精度は、 C 言語の <B><A HREF="../../LDP_man-pages/man3/printf.3.html">printf</A></B>(3) 関数と同じ方法で指定することができます。
多くのフィールドは、 %d としてではなく、 %s として出力されます。 このため、 フラグが期待通りに動作しないことも発生します。 一方で、 `-'
フラグ (フィールドを必ず左揃えにする指定) を使えば、 必ず動作します。 <B>-print</B> とは違って、 <B>-printf</B> は、
文字列の末尾に改行文字を追加しません。 エスケープとディレクティブには、 以下のものがあります。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>\a<DD>
警告ベル。
<DT>\b<DD>
バックスペース。
<DT>\c<DD>
このフォーマットによる出力をすぐに停止して、 出力をフラッシュします。
<DT>\f<DD>
フォームフィード。
<DT>\n<DD>
改行文字。
<DT>\r<DD>
復帰文字。
<DT>\t<DD>
水平タブ。
<DT>\v<DD>
垂直タブ。
<DT>\0<DD>
ASCII NUL 文字。
<DT>\\<DD>
バックスラッシュ文字そのもの (`\')。
<DT>\NNN<DD>
ASCII コードが NNN (8 進数) の文字。
</DL>
<P>

バックスラッシュ文字 `\' に、 上記以外の文字が続いた場合は、 `\' が普通の文字として扱われます。　つまり、 2
文字とも表示されることになります。
<DL COMPACT>
<DT>%%<DD>
パーセント文字そのもの。
<DT>%a<DD>
ファイルの最終アクセス時間を、 C 言語の <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3) 関数が返す形式で表したものです。
<DT>%A<I>k</I><DD>
<I>k</I> で指定された書式に基づいて、 ファイルの最終アクセス時間を表したものです。 <I>k</I> に指定するのは、 `@' か、 あるいは C 言語の
<B>strftime</B> 関数で用いるディレクティブです。 以下に、 <I>k</I> に指定可能な値を示します。 ただし、 すべてを示すものではありません。
完全な一覧については、 <B><A HREF="../../LDP_man-pages/man3/strftime.3.html">strftime</A></B>(3) のドキュメントを参照してください。 指定文字に応じた文字列変換は、
システムによっては利用できない場合があります。 それは、 ライブラリ関数 <B><A HREF="../../LDP_man-pages/man3/strftime.3.html">strftime</A></B>(3) の実装が、 システムよって異なるからです。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>@<DD>
Jan. 1, 1970, 00:00 GMT からの経過秒数。 小数点以下も表示します。
</DL>
<P>

時刻フィールド:
<DL COMPACT>
<DT>H<DD>
時 (00..23)
<DT>I<DD>
時 (01..12)
<DT>k<DD>
時 ( 0..23)
<DT>l<DD>
時 ( 1..12)
<DT>M<DD>
分 (00..59)
<DT>p<DD>
現在のロケールにおいて AM/PM に相当する文字列。
<DT>r<DD>
12 時間制の時刻 (hh:mm:ss [AP]M)
<DT>S<DD>
秒 (00.00 .. 61.00)。 小数点以下も表示します。
<DT>T<DD>
24 時間制の時刻 (hh:mm:ss.xxxxxxxxxx)
<DT>+<DD>
日付と時刻。 両者の間は `2004-04-28+22:22:05.0' といったように '+' で 区切られます。 これは GNU 拡張です。
時間は、 現在のタイムゾーンによるものが用いられます (したがって、 環境変数 <B>TZ</B> の設定に影響を受ける場合があります)。 秒は、
小数点以下が含まれます。
<DT>X<DD>
現在のロケールによる時刻表示 (H:M:S)。 秒は小数点以下を含みます。
<DT>Z<DD>
タイムゾーン (JST など)。 タイムゾーンが決定できなかった場合は、 何も表示されません。
</DL>
<P>

日付フィールド:
<DL COMPACT>
<DT>a<DD>
現在のロケールによる曜日の短縮形 (Sun..Sat)。
<DT>A<DD>
現在のロケールによる、 曜日の省略しない表示。 長さは可変 (Sunday..Saturday)。
<DT>b<DD>
現在のロケールによる月名の短縮形 (Jan..Dec)。
<DT>B<DD>
現在のロケールによる月名の省略しない表示。 長さは可変 (January..December)。
<DT>c<DD>
現在のロケールによる日付と時刻の表示 (Sat Nov 04 12:02:33 EST 1989)。 この表示形式は、 <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3)
のものと同じであり、 <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3) の形式との互換性を維持するためのものです。 秒は小数点表記されません。
<DT>d<DD>
その月の何日目かの表示 (01..31)。
<DT>D<DD>
日付 (mm/dd/yy)。
<DT>F<DD>
日付 (yyyy-mm-dd)。
<DT>h<DD>
b と同じ。
<DT>j<DD>
その年の何日目かの表示 (001..366)。
<DT>m<DD>
月 (01..12)。
<DT>U<DD>
その年の何週目か (日曜日を週の始まりとする) (00..53)。
<DT>w<DD>
曜日 (0..6)。
<DT>W<DD>
その年の何週目か (月曜日を週の始まりとする) (00..53)。
<DT>x<DD>
現在のロケールによる日付表示 (mm/dd/yy)。
<DT>y<DD>
年の下二桁 (00..99)。
<DT>Y<DD>
年 (1970...)。
</DL>
</DL>

<DT>%b<DD>
ファイルが使用するディスク容量を、 1 ブロック 512 バイトのブロック数で表示します。 ディスク領域は、
ファイルシステムブロックサイズの倍数によって割り当てられるので、 たいていは %s/512 より大きくなります。 ただしスパースファイルの場合は、
%s/512 より小さくなることがあります。
<P>
<DT>%B<I>k</I><DD>
ファイルの生成時間。 フォーマットは  <I>k</I> によって指定します。 これは %A に対するものと同じです。
処理を行っているオペレーティングシステムやファイルシステムが、 生成時間をサポートしていない場合、 このディレクティブは空文字を返します。
<P>
<DT>%c<DD>
ファイルの最終ステータス変更時間を、 C 言語の <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3) 関数が返す形式で表したものです。
<DT>%C<I>k</I><DD>
ファイルの最終ステータス変更時間を、 <I>k</I> で指定した書式で表したものです。　<I>k</I> は %A の場合と同様です。
<DT>%d<DD>
ディレクトリツリー内で、 対象ファイルがどれだけ深い階層数にあるかを示します。 0 は、 対象ファイルが検索開始ポイントにあることを意味します。
<DT>%D<DD>
ファイルがどのデバイス上にあるかを、 10 進数のデバイス番号 (stat 構造体の st_dev フィールド) で示します。
<DT>%f<DD>
ベース名を表します。 ファイル名から、 先頭にあるディレクトリ名を取り除きます (最後の要素のみを残します)。 <B>/</B> に対する結果は `/' です。
処理例については「<B>例</B>」セクションを参照してください。
<P>
<DT>%F<DD>
ファイルがあるファイルシステムのタイプを表します。 ここで表示される値は -fstype の引数に指定することができます。
<DT>%g<DD>
ファイルのグループ名を表します。 グループ名が存在しない場合は、 グループ ID 番号を表します。
<DT>%G<DD>
ファイルのグループ ID 番号。
<DT>%h<DD>
ディレクトリ名を表します。 つまり、 ファイル名の先頭にあるディレクトリ部分 (最後の要素以外のすべて) を表します。
ファイル名にスラッシュが一つも含まれない場合 (カレントディレクトリ内にあることになるので)、 書式指定子 %h は `.'
に展開されます。対象ファイルがディレクトリそのものであって、 スラッシュ <B>/</B> を含む場合、 %h は空文字に展開されます。
具体例は「<B>例</B>」セクションを参照してください。
<DT>%H<DD>
検索開始ポイントのうち、 対象ファイルが見つかったものを表します。
<DT>%i<DD>
ファイルの i ノード番号 (10 進数表示)。
<DT>%k<DD>
ファイルが利用するディスク容量を、  1 ブロック 1 KB のブロック数で表示します。 ディスク領域は、
ファイルシステムのブロックサイズの倍数によって割り当てられるので、 たいていは %s/1024 より大きくなります。 スパースファイルの場合は、
%s/1024 より小さくなることがあります。
<DT>%l<DD>
シンボリックリンク先 (シンボリックリンクでない場合は、 空文字列) を表します。
<DT>%m<DD>
ファイルの許可属性ビット (8 進数表示) を表します。 このオプションが使用している数値は、 たいていの Unix
実装において用いられる「従来の」数値です。 しかし利用中のシステム実装においては、 8 進数で表示する許可属性ビットの並び方が、
普通とは異なるかもしれません。 その場合は、 ファイルの許可属性の実際の値と、 %m の出力とが異なることになります。 数値の先頭に 0
をつけて表示したい場合があります。 そのときは、 <B>#</B> フラグを使って、 たとえば `%#m' のようにします。
<DT>%M<DD>
ファイルの許可属性を表します (<B>ls</B> と同様のシンボルによる表現)。 このディレクティブは、 findutils 4.2.5
以降にサポートされるようになりました。
<DT>%n<DD>
ファイルのハードリンク数。
<DT>%p<DD>
ファイル名。
<DT>%P<DD>
検索開始ポイント名を使って表現した、 対象ファイル名であって、 現在削除されたものを表します。
<DT>%s<DD>
バイト単位によるファイルサイズ。
<DT>%S<DD>
ファイルが「まばら」である度合い (sparseness) を表します。 この値は (BLOCKSIZE*st_blocks / st_size)
として計算されます。 ある程度の大きさを持つ普通のファイルの場合、 その正確な値は、 システムによってさまざまです。 スパースファイルであれば、
「まばら」な度合いは、 普通は 1.0 未満です。 一方で、 間接ブロックを使用しているファイルの場合は、 1.0 以上になることがあります。
BLOCKSIZE に設定される値は、 システムに依存しますが、 通常は 512 バイトです。 ファイルサイズが 0 の場合、
この値は未定義として出力されます。 st_blocks をサポートしていないシステムでは、 ファイルの「まばら」な度合いは、 1.0 とみなされます。
<DT>%t<DD>
ファイルの最終更新時間を、 C 言語の <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3) 関数が返す形式で表したものです。
<DT>%T<I>k</I><DD>
<I>k</I> で指定された書式に基づいて、 ファイルの最終更新時間を表したものです。 <I>k</I> は %A の場合と同様です。
<DT>%u<DD>
ファイルを所有するユーザー名。 ユーザーに名前がない場合は、 ユーザー ID 番号が用いられます。
<DT>%U<DD>
ファイルを所有するユーザーの ID 番号。
<DT>%y<DD>
ファイルタイプ (<B>ls -l</B> の表現と同様です)。 U はタイプ不明 (unknown type) を表します (発生することはありません)。
<DT>%Y<DD>
ファイルタイプ (%y と同様)。 さらに、 シンボリックリンクをたどります。 `L' はループ、 `N' は非存在、 `?' はその他のエラーであり、
シンボリックリンク先のタイプが決定できなかった場合です。
<DT>%Z<DD>
(SELinux 有効時のみ) ファイルのセキュリティコンテキスト。
<DT>%{ %[ %(<DD>
将来の利用のために予約されています。
</DL>
<P>

1 つの `%' に対して、 上記以外の文字が続く場合、 `%' 文字は無視されて、 それに続いた文字が表示されます
(新たに指定文字が定義されるかもしれないため、 この動作に期待するのは避けてください)。 書式指定の文字列の最後に `%' だけが 1 つあると、
次に文字がないため、 その動作は不定となります。 何が起きるか分かりませんから、 ロケールによっては、 ドアの鍵を紛失するかもしれませんし、
せっかく読んでいる小説の最後のページが、 なくなってしまうかもしれません。
<P>
ディレクティブ %m と %d は、 書式フラグ <B>#</B>, <B>0</B>, <B>+</B> をサポートします。 これ以外のディレクティブは、
数値を表す場合であっても、 このフラグをサポートしません。 このフラグをサポートしない数値関連のディレクティブには、 <B>G</B>, <B>U</B>, <B>b</B>,
<B>D</B>, <B>k</B>, <B>n</B> があります。 書式フラグとして `-' もサポートされています。これを使えば、 欄出力の右揃え (デフォルト)
を左揃えに変更することができます。
<P>

ファイル名に、 普通は使わない文字が含まれている場合の扱いについては、 「普通ではないファイル名」のセクションを参照してください。
<P>
<P>
</DL>

<DT>-prune<DD>
true を返します。 処理対象がディレクトリである場合、 ディレクトリ内に入っていきません。 <B>-depth</B> が指定してあると、
<B>-prune</B> は何もしません。 <B>-delete</B> の指定には、 暗に <B>-depth</B> の指定が含まれているので、 <B>-prune</B> と
<B>-delete</B> を同時に使うことはできません。 たとえば、 <I>src/emacs</I>
というディレクトリとその下にあるファイルやディレクトリはスキップするとします。 そしてそれ以外のファイルを表示しようとする場合には、
以下のように実行します。

<PRE>
find . -path ./src/emacs -prune -o -print
</PRE>


<P>
<P>
<DT>-quit<DD>
すぐに終了します (エラーが発生していなければ 0 を返します)。 これは <B>-prune</B> とは異なります。 <B>-prune</B> は、
適用されたディレクトリの内容を、 対象外とするものですが、 <B>-quit</B> は単純に <B>find</B> をその場で止めます。
子プロセスが残ることはありません。 コマンドラインが、 <B>-exec&nbsp;...&nbsp;+</B> や <B>-execdir&nbsp;...&nbsp;+</B>
の形式で構成されていた場合、 そのコマンドはすべて呼び出されてから、 プログラムが終了します。 <B>-quit</B> が実行されると、
コマンドライン上に指定されていた残りのファイルは、 処理されません。 たとえば `<B>find&nbsp;</B><I>/tmp/foo</I><B>&nbsp;</B>
<I>/tmp/bar</I><B>&nbsp;-print&nbsp;-quit</B>` では、 `/tmp/foo` だけが表示されます。
<BR>

<B>-quit</B> を利用するごく普通のケースとして、 ファイルシステム内から検索したいものが見つかったら、 検索をやめるという使い方があります。
たとえば、 1 つのファイルだけを見つけたい場合には、 以下のようにすることができます。

<PRE>
find / -name needle -print -quit
</PRE>


<P>
</DL>
<A NAME="lbAK">&nbsp;</A>
<H3>オペレーター</H3>

以下ではオペレーターを、 優先順位の高いものから順に示します。
<P>
<DL COMPACT>
<DT>( <I>expr</I> )<DD>
カッコ内を優先的に処理します。 シェルにとって、 カッコには特別な意味があるため、 普通はクォートでくくる必要があります。
このマニュアルページであげている例では、 この目的でバックスラッシュを多用しています。 つまり `(...)' は、 `\(...\)'
のように記述しています。
<P>
<DT>! <I>expr</I><DD>
<I>expr</I> が false の場合に　true となります。 通常この記号も、 シェルによって解釈されないようにする必要があります。
<P>
<DT>-not <I>expr</I><DD>
! <I>expr</I> と同様ですが、 POSIX には準拠していません。
<P>
<DT><I>expr1 expr2</I><DD>
2 つ並んだ式は、 暗に <B>-a</B> によって結合されたものとして扱われます。 そして <I>expr1</I> が false の場合、 <I>expr2</I>
は評価されません。
<P>
<DT><I>expr1</I> -a <I>expr2</I><DD>
<I>expr1 expr2</I> と同じです。
<P>
<DT><I>expr1</I> -and <I>expr2</I><DD>
<I>expr1 expr2</I> と同様ですが、 POSIX には準拠していません。
<P>
<DT><I>expr1</I> -o <I>expr2</I><DD>
OR 結合です。 <I>expr1</I> が true のとき、 <I>expr2</I> は評価されません。
<P>
<DT><I>expr1</I> -or <I>expr2</I><DD>
<I>expr1</I> <B>-o</B> <I>expr2</I> と同様ですが、 POSIX には準拠していません。
<P>
<DT><I>expr1</I> , <I>expr2</I><DD>
リストを表します。 必ず <I>expr1</I> と <I>expr2</I> の両方が評価されます。 <I>expr1</I> の値は無視されて、 <I>expr2</I>
の値が、 リストとしての値になります。 このカンマオペレーターは、 さまざまな種類のものを探すときに便利です。 ただしファイルシステム内の検索は、
一度しか行われません。 さまざまなものに一致した結果を、 複数ファイルに出力するには、 <B>-fprintf</B> アクションを利用します。
</DL>
<P>

暗に <B>-a</B> の指定を意図した場合 (たとえばテストとテストの間に、 このオペレーターを記述しなかった場合)、 あるいは明示的に指定した場合は、
<B>-o</B> よりも優先順位が高いことを覚えておいてください。 たとえば、 <B>find . -name afile -o -name bfile
-print</B> とした場合、 <I>afile</I> が出力されることはない、 ということです。
<A NAME="lbAL">&nbsp;</A>
<H2>普通ではないファイル名</H2>

<B>find</B> のアクションの多くでは、 他ユーザーが、 出力されるデータを自由に制御できます。 データには、 ファイル名、 サイズ、 更新時間など、
さまざまなものがあります。 ファイル名は、 `\0' と `/' 以外の文字であれば、 何でも含めることができるため、 潜在的な問題を抱えています。
ファイル名の中に、 普段用いない文字が含まれていると、 端末に対して、 予期しない動作や、 時には望ましくない事態を引き起こすことも可能です。
(たとえば端末次第では、 ファンクションキーの設定変更が行われてしまうかもしれません)。 普段使わない文字を、 どのように処理するかについては、
アクションごとに動作が異なります。 以下にこのことを示します。
<P>
<DL COMPACT>
<DT>-print0, -fprint0<DD>
常にファイル名を修正せずに、 そのまま出力します。 出力先が端末であっても同じです。
<P>
<DT>-ls, -fls<DD>
普段使わない文字は、 必ずエスケープされます。 ホワイトスペース、 バックスラッシュ、 ダブルクォートは、  C
言語のようなエスケープ表現で出力されます (`\f', `\&quot;' など)。 その他の文字では、 8 進数表記によってエスケープして出力されます。
通常の表示可能な文字 (<B>-ls</B> や <B>-fls</B> においては、 8 進数の 041 から 0176 に相当する文字) は、
そのまま出力されます。
<P>
<DT>-printf, -fprintf<DD>
出力先が端末でない場合は、 そのまま出力されます。 出力先が端末の場合は、 利用するディレクティブによって、 出力は変わります。 ディレクティブ %D,
%F, %g, %G, %H, %Y, %y が展開される値は、 ファイル所有者が制御するものではないため、 そのまま出力されます。 ディレクティブ
%a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u, %U の値は、 ファイル所有者が制御可能なものですが、
だからと言って、 端末に任意にデータ送信してよいものではありません。 したがってこのときのデータも、 そのまま出力されます。 ディレクティブ %f,
%h, %l, %p, %P の出力値は、 クォートでくくられます。 クォートでくくるこの方法は、 GNU <B>ls</B> の場合と同じです。 逆に
<B>-ls</B> や <B>-fls</B> における方法とは異なります。 <B>find</B> の出力書式を自由に定めてよい、 ということになれば、 普通は、
終端文字として改行ではなく、 `\0' を用いるように変更するのが適切です。 これを行うのは、 ファイル名に、
空白や改行が含まれる場合があるためです。 どの文字をクォートでくくるかは、 環境変数 <B>LC_CTYPE</B> の設定を用いて決定されます。
<P>
<DT>-print, -fprint<DD>
クォートでくくる方法は、 <B>-printf</B> や <B>-fprintf</B> と同じです。 <B>find</B> をスクリプト内で利用する場合や、
一致したファイルにあらゆる文字が含まれる可能性がある場合には、 <B>-print</B> を用いるのではなく、 <B>-print0</B>
を用いるようにしてください。
</DL>
<P>

アクション <B>-ok</B> と <B>-okdir</B> は、 対象ファイル名をそのまま出力します。 この動作は、 将来のリリースで変わるかもしれません。
<A NAME="lbAM">&nbsp;</A>
<H2>規格への準拠</H2>

POSIX 規格にできるだけ準拠した動作が必要であれば、 環境変数 <B>POSIXLY_CORRECT</B> を設定してください。 以下のオプションは、
POSIX 規格 (IEEE Std 1003.1-2008, 2016 Edition) の中で規定されています。
<P>
<DL COMPACT>
<DT><B>-H</B><DD>
このオプションはサポートされています。
<P>
<DT><B>-L</B><DD>
このオプションはサポートされています。
<P>
<DT><B>-name</B><DD>
このオプションはサポートされていますが、 POSIX への適応は、 システムの <B><A HREF="../../LDP_man-pages/man3/fnmatch.3.html">fnmatch</A></B>(3) ライブラリ関数が、 どれだけ POSIX
に準拠しているかによって、 変わります。 findutils-4.2.2 以降、 シェルのメタ文字 (たとえば `*', `?', `[]') は、
ファイル名先頭の `.' 文字に一致するようになりました。 これは IEEE PASC interpretation 126 の要求に従ったものです。
これは、 それ以前の findutils のバージョンから、 変更されている点です。
<P>
<DT><B>-type</B><DD>
サポートされています。 POSIX では `b', `c', `d', `l', `p', `f', `s' を規定しています。 GNU find は、
この他にドア (door) を表す `D' もサポートしています。 これが使えるのは、 OS がこの機能を提供している場合です。 さらに、 GNU
find では、 複数の型指定を一度に行うことが可能であり、 その場合には、 カンマで区切ったリストを指定します。
<P>
<DT><B>-ok</B><DD>
サポートされています。 プロンプトに対する入力は、 `yes'、 `no' を表すパターンに従って解釈されます。 そのパターンは、 環境変数
<B>LC_MESSAGES</B> の設定内容により決定します。 環境変数 <B>POSIXLY_CORRECT</B> が設定されている場合は、 そのパターンが、
`yes'、 `no' の入力に対するシステム定義として扱われます。 <B><A HREF="../../LDP_man-pages/man3/nl_langinfo.3.html">nl_langinfo</A></B>(3) に関するドキュメント、 特に YESEXPR
と NOEXPR について参照してください。 <B>POSIXLY_CORRECT</B> が設定されていない場合、 そのパターンは、 <B>find</B>
が持っているメッセージカタログから取得されます。
<P>
<DT><B>-newer</B><DD>
サポートされています。 指定されたファイルがシンボリックリンクの場合は、 必ずリンク先が参照されます。 これは以前のバージョンから変更されたものであり、
以前は、 比較に用いる時間をシンボリックリンクから取得していました。 「履歴」セクションを参照してください。
<P>
<DT><B>-perm</B><DD>
サポートされています。 環境変数 <B>POSIXLY_CORRECT</B> が設定されていない場合には、 POSIX では認められていない (たとえば、
+a+x のような) モード引数であっても、 後方互換のために利用できるものがあります。
<P>
<DT>その他のプライマリ<DD>
式を構成するプライマリ (primary) として、 <B>-atime</B>, <B>-ctime</B>, <B>-depth</B>, <B>-group</B>,
<B>-links</B>, <B>-mtime</B>, <B>-nogroup</B>, <B>-nouser</B>, <B>-perm</B>, <B>-print</B>,
<B>-prune</B>, <B>-size</B>, <B>-user</B> <B>-xdev</B> が、 すべてサポートされています。
<P>
</DL>
<P>

POSIX 規格は、 カッコ `(', `)'、 否定 `!'、 論理 AND/OR のオペレーター <B>-a</B>, <B>-o</B> を規定しています。
<P>

上記を除いたオプション、 述語、 式などは、 すべて POSIX 規格にはない拡張です。 ただしその拡張の多くは、 GNU find
に特有なものではありません。
<P>

POSIX 規格における <B>find</B> は、 ループの検出ができなければならないと定めています。
<DL COMPACT>
<DT><DD>
<B>find</B> ユーティリティは、 無限ループを検出できなければなりません。 無限ループとは、 処理対象となったファイルの上位ディレクトリが、
以前に処理していたものであって、 そのディレクトリに入ることです。 無限ループを検出した場合、 find は、
診断メッセージを標準エラー出力に書き出すものとします。 そして、 ディレクトリ階層上での検索位置を復旧するか、 あるいは終了するものとします。
</DL>
<P>

GNU <B>find</B> は、 この要件を満たしています。 上位ディレクトリへのハードリンクを含んだディレクトリと、
そういったものを含まないディレクトリを比較してみると、 ディレクトリのリンク数は、 前者の方が少なくなることがよくあります。 このことがあるため、
上位ディレクトリへのリンクであるサブディレクトリに対して、 GNU find は、 最適化によって、 そのディレクトリを調べないケースが発生します。
<B>find</B> は実際に、 そういったサブディレクトリに入っていかないため、 診断メッセージの出力を抑えることができます。
わかりにくい処理かもしれませんが、 実際にこの動作に期待する人は、 まずいません。 <B>-noleaf</B> オプションの指定によって、 葉 (leaf)
に関する最適化処理が無効になっていた場合、 ディレクトリの各エントリは、 必ず調べられます。 したがって診断メッセージは、 必要な場面で表示されます。
シンボリックリンクを使っていれば、 ファイルシステム上にこのようなリンクを作り出すことはできません。 ただし <B>-L</B> オプションや
<B>-follow</B> オプションを指定しているときには、 シンボリックリンクのループが見つかると、 診断メッセージが表示されます。
ハードリンクを含むループの場合と同様に、 葉に関する最適化によって、 <B>find</B> がシンボリックリンクに対して、 <I>stat()</I> や
<I>chdir()</I> を用いる必要がないと判断することがあるため、 診断情報は、 かなりの頻度で必要なくなります。
<P>

<B>-d</B> オプションは、 各種の BSD システムとの互換性のためにサポートされています。 したがって、 これを使うのではなく、 POSIX
に準拠する <B>-depth</B> オプションを用いてください。
<P>

環境変数 <B>POSIXLY_CORRECT</B> は、 テスト <B>-regex</B> や <B>-iregex</B> の動作に影響を与えません。
こういったテストは、 POSIX では規定されていないためです。
<A NAME="lbAN">&nbsp;</A>
<H2>環境変数</H2>

<P>
<DL COMPACT>
<DT>LANG<DD>
国際化関連の環境変数において、 値が設定されていない、 あるいは null であるものに対して、 デフォルト値を提供します。
<P>
<DT>LC_ALL<DD>
この環境変数に、 空文字列ではない値が設定されていれば、 国際化関連の環境変数を上書きします。
<P>
<DT>LC_COLLATE<DD>
POSIX の規定では、 この環境変数は、 テスト <B>-name</B> で用いられるパターンマッチングに影響を及ぼします。 GNU find は、
<B><A HREF="../../LDP_man-pages/man3/fnmatch.3.html">fnmatch</A></B>(3) ライブラリ関数を利用しているので、 <B>LC_COLLATE</B> への対応は、 システムのライブラリ次第です。
またこの変数は、 アクション <B>-ok</B> の入力値の解釈にも影響します。 <B>-ok</B> における入力値を解釈するものとして、
実際に用いられるパターンは、 <B>LC_MESSAGES</B> 変数の値によって決定されますが、 そのパターンの中に角カッコによる表現が用いられていると、
<B>LC_COLLATE</B> の影響を受けることになります。
<P>
<DT>LC_CTYPE<DD>
システムの <B><A HREF="../../LDP_man-pages/man3/fnmatch.3.html">fnmatch</A></B>(3) ライブラリ関数がこの環境変数をサポートしている場合、 この環境変数は、 正規表現で使用される文字クラスと、
<B>-name</B> テストで使われる文字クラスの扱い方に影響を及ぼします。アクション <B>-ok</B> のプロンプトにおけるユーザー入力値の解釈には、
正規表現が用いられますが、 この変数は、 その正規表現内の文字クラスの判断に影響します。 環境変数 <B>LC_CTYPE</B> は、 ファイル名の表示時に、
表示できない文字を判断する処理に影響します。 「普通ではないファイル名」のセクションを参照してください。
<P>
<DT>LC_MESSAGES<DD>
国際化されたメッセージで使用するロケールを設定します。 環境変数 <B>POSIXLY_CORRECT</B> が設定されている場合は、 この変数によって、
アクション <B>-ok</B> のプロンプト入力値に対する解釈が決定します。
<P>
<DT>NLSPATH<DD>
国際化メッセージカタログを置く場所を設定します。
<P>
<DT>PATH<DD>
<B>-exec</B>, <B>-execdir</B>, <B>-ok</B>, <B>-okdir</B> から呼び出される実行ファイルが、
どこにあるかを検索するディレクトリに影響します。
<P>
<DT>POSIXLY_CORRECT<DD>
<B>-ls</B> や <B>-fls</B> が使用するブロックサイズを決定します。 <B>POSIXLY_CORRECT</B> が設定されている場合は、 1 ブロックが
512 バイト、 設定されていない場合は、 1 ブロックが 1024 バイトになります。
<DT><DD>
またこの変数を設定すると、 デフォルトで警告メッセージを出力しません (つまり <B>-nowarn</B> が暗に指定されます)。 なぜなら POSIX
の規定では、 <B>-ok</B> のプロンプトを除くと、 標準エラーに出力されるメッセージは、 すべて診断情報であり、 終了ステータスは 0
以外を返さなければならないからです。
<DT><DD>
<B>POSIXLY_CORRECT</B> が設定されていない場合、 <I>+zzz</I> が適正なシンボリックモード表現でなかったら、 <B>-perm
</B><I>+zzz</I> という記述は、 <B>-perm</B> <I>/zzz</I> として扱われます。 <B>POSIXLY_CORRECT</B> が設定されている場合、
この記述はエラーになります。
<DT><DD>
<B>POSIXLY_CORRECT</B> が設定されていると、 アクション <B>-ok</B> のプロンプトに対する入力値の解釈は、 <B>find</B>
の持つメッセージ翻訳を用いるのではなく、 システムのメッセージカタログに従って行われます。
<P>
<DT>TZ<DD>
タイムゾーンに影響します。 タイムゾーンは、 <B>-printf</B> や <B>-fprintf</B> の時間関連ディレクティブにおいて利用されます。
</DL>
<A NAME="lbAO">&nbsp;</A>
<H2>例</H2>


<A NAME="lbAP">&nbsp;</A>
<H3>単純な `find|xargs` のアプローチ</H3>

<DL COMPACT>
<DT>&bull;<DD>
<I>/tmp</I> ディレクトリ以下にある、 <I>core</I> という名前のファイルを探して、 それを削除します。
<PRE>

<B>$ find /tmp -name core -type f -print | xargs /bin/rm -f</B>

</PRE>

ただし、 ファイル名の中に、 改行、 シングルクォート、 ダブルクォート、 空白文字が含まれる場合には、 このコマンドは正しく動作しません。
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H3>安全な `find -print0 | xargs -0` によるアプローチ</H3>

<DL COMPACT>
<DT>&bull;<DD>
<I>/tmp</I> ディレクトリ以下にある、 <I>core</I> という名前のファイルを探して、 それを削除します。 ファイルやディレクトリの名前に、
シングルクォート、 ダブルクォート、 空白、 改行などが含まれていても、 適切に処理されます。
<PRE>

<B>$ find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f</B>

</PRE>

テスト <B>-name</B> は、 <B>-type</B> よりも前に置いています。 これは、 <B><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></B>(2) の呼び出しが、
すべてのファイルに対して行われることを防ぐためです。
</DL>
<P>

ただし、 <B>find</B> がファイルシステム内を検索して、 一致するファイルを出力する時間と、 <B>xargs</B>
によるコマンド起動がそのファイルを処理する時間との間では、 まだ競合が発生する点に注意してください。
<A NAME="lbAR">&nbsp;</A>
<H3>任意の検索開始ポイントからの処理</H3>

<DL COMPACT>
<DT>&bull;<DD>
プログラム <I>proggy</I> というものがあるとして、 あらかじめ処理を行って、 大量のNUL 区切りのファイル一覧を作るものであったとします。
これを検索開始ポイントととして処理を行って、 その中から通常ファイルと空のファイルを検索します。
<PRE>

<B>$ proggy | find -files0-from - -maxdepth 0 -type f -empty</B>

</PRE>

<B>`-files0-from&nbsp;-`</B> と記述している部分は、 検索開始ポイントとする名前を <I>標準入力</I> から、
つまりパイプから読み込むことを表しています。 そして <B>-maxdepth&nbsp;0</B> はサブディレクトリへの再帰的な検索は行わずに、
そこに明示された対象のみを検索するようにしています (検索開始ポイントの指定がただ 1 つである場合)。
</DL>
<A NAME="lbAS">&nbsp;</A>
<H3>各ファイルに対するコマンド実行</H3>

<DL COMPACT>
<DT>&bull;<DD>
カレントディレクトリ以下の各ファイルに対して <I>file</I> を実行します。
<PRE>

<B>$ find . -type f -exec file '{}' \;</B>

</PRE>

波カッコをシングルクォートで囲んでいる点に注意してください。 これは、 句読点がシェルスクリプトの記号として、 解釈されないようにするためです。
同様のこととして、 セミコロンもバックスラッシュを使ってエスケープしています。 シングルクォートを使うのでもかまいません。
</DL>
<P>

性能やセキュリティのことを考慮すると、 <B>`-exec&nbsp;...&nbsp;+`</B> という記述が望まれるケースが多いかもしれません。
<A NAME="lbAT">&nbsp;</A>
<H3>異なる 2 つのアクション、 ファイルシステム検索は 1 回</H3>

<DL COMPACT>
<DT>&bull;<DD>
ファイルシステムを検索するのは 1 回だけにして、 setuid ビットが立っているファイルやディレクトリの一覧は <B>/root/suid.txt</B>
に出力し、 サイズが大きいファイルの一覧は <B>/root/big.txt</B> に出力するようにします。
<PRE>

<B>$ find / \</B>
<B>\( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \</B>
<BR>
<B>\( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)</B>

</PRE>

この例では、 初めの 2 つの行に対して、 行継続文字 '\' を用いています。 シェルがコマンド読み込みを行うにあたって、
次の行も継続して読み込むように指示しています。
</DL>
<A NAME="lbAU">&nbsp;</A>
<H3>期間の指定を使ったファイル検索</H3>

<DL COMPACT>
<DT>&bull;<DD>
ホームディレクトリ内のファイルの中から、 修正時間が 24 時間未満のファイルを検索します。
<PRE>

<B>$ find $HOME -mtime 0</B>

</PRE>

このコマンドがそういう動作になるのは、 各ファイルの最終更新時間が、 24 時間単位で割られて、 余りは捨てられるからです。 つまり、 ファイルが
<B>-mtime 0</B> に一致するのは、 過去 24 時間未満の間に更新されていることを表します。
</DL>
<A NAME="lbAV">&nbsp;</A>
<H3>許可属性を使ったファイル検索</H3>

<DL COMPACT>
<DT>&bull;<DD>
実行可能であり、 読み出し不能なファイルを探します。
<PRE>

<B>$ find /sbin /usr/sbin -executable \! -readable -print</B>

</PRE>

<DT>&bull;<DD>
ファイルの所有者とグループが読み書き可能であって、 他ユーザーは、 読み込みのみで書き込み不可であるファイルを探します。
<PRE>

<B>$ find . -perm 664</B>

</PRE>

上に示す条件を満たすファイルであっても、 さらに別の許可属性ビットも立っているようなファイル (たとえば、 他ユーザーが実行できるなど) は、
この条件に一致しません。
<DT>&bull;<DD>
ファイルの所有者とグループが読み書き可能であり、 他ユーザーも読み込みが可能であるようなファイルを探します。　それ以外の許可属性ビット
(たとえば実行ビット) が立っていてもかまいません。
<PRE>

<B>$ find . -perm -664</B>

</PRE>

したがって上は、 たとえばモードが <I>0777</I> であるようなファイルにも一致します。
<DT>&bull;<DD>
(ファイルの所有者、 グループ、 他ユーザーの誰でも良いから) 書き込み可能なファイルを探します
<PRE>

<B>$ find . -perm /222</B>

</PRE>

<DT>&bull;<DD>
ファイルの所有者あるいはグループのいずれかが、 書き込み可能なファイルを探します。
<PRE>

<B>$ find . -perm /220</B>
<B>$ find . -perm /u+w,g+w</B>
<B>$ find . -perm /u=w,g=w</B>

</PRE>

上のコマンドは 3 つとも同じ動作をします。 1 つめは、 ファイルの許可属性を 8 進数で表しています。 残りの 2 つは、
シンボルによる表現形式を利用しています。 ファイルが一致する際には、 所有者とグループの両方が書き込み可能である必要はなく、
どちらか一方が満たされれば一致します。
<DT>&bull;<DD>
ファイルの所有者あるいはグループが、 ともに書き込み可能であるようなファイルを探します。
<PRE>

<B>$ find . -perm -220</B>
<B>$ find . -perm -g+w,u+w</B>

</PRE>

上のコマンドは同じ処理を行ないます。
<DT>&bull;<DD>
権限に関して、 さらに複雑な検索を以下に示します。
<PRE>

<B>$ find . -perm -444 -perm /222 \! -perm /111</B>
<B>$ find . -perm -a+r -perm /a+w \! -perm /a+x</B>

</PRE>

この 2 つのコマンドは、 両方とも次のような条件のファイルを探します。 つまり、 誰にでも読み出すことが可能 (<B>-perm -444</B> または
<B>-perm -a+r</B>) であって、 書き込み許可ビットが少なくとも 1 つは立っているもの (<B>-perm /222</B> または <B>-perm
/a+w</B>)、 ただし誰にも実行ができないもの (<B>! -perm /111</B> や <B>! -perm /a+x</B>)、 というものです。
</DL>
<A NAME="lbAW">&nbsp;</A>
<H3>除外 - ファイルやサブディレクトリの除き方</H3>

<DL COMPACT>
<DT>&bull;<DD>
<I>/source-dir</I> の内容を <I>/dest-dir</I> にコピーします。 ただし <I>.snapshot</I> という名前のファイル、
またはディレクトリ (その中身) は除きます。 さらに、 名前が `~' で終わるファイル、 またはディレクトリも除きますが、
その中身までは除きません。
<PRE>

<B>$ cd /source-dir</B>
<B>$ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) \</B>
<BR>
<B>| cpio -pmd0 /dest-dir</B>

</PRE>

<B>-prune -o \( ... -print0 \)</B> という形は、 ごく普通に利用されます。 考え方としては、 <B>-prune</B>
の前にある式が、 取り除く対象になるということです。 アクション <B>-prune</B> 自体は、 返り値として true を返します。 したがって、
直後に <B>-o</B> があるおかげで、 取り除き (prune) の対象にならなかったディレクトリが、 <B>-o</B> の右辺によって評価されることになります
(取り除きの対象になったディレクトリの中身は、 処理の対象になっていないので、 中身を考慮する必要はありません)。 <B>-o</B>
の右辺の式をカッコで囲んでいるのは、 わかりやすくするためです。 このように記述することで、 アクション <B>-print0</B> の処理対象が、
<B>-prune</B> の処理対象以外あることが、 はっきりします。 テストとテストの間にある `and' 条件は、 <B>-o</B>
よりも強く結びつくものであって、 それがデフォルトになっていますが、 カッコで囲めば、 どのように処理されるかがよくわかります。
<DT>&bull;<DD>
以下に示されるようなプロジェクトディレクトリがあって、 さらに、 関連する SCM の管理ディレクトリがあるとします。 これに対して、
プロジェクトルートから効率の良い検索を行います。
<PRE>

<B>$ find repo/ \</B>
<B>\( -exec test -d '{}/.svn' \; \</B>
<B>-or -exec test -d '{}/.git' \; \</B>
<B>-or -exec test -d '{}/CVS' \; \</B>
<B>\) -print -prune</B>

</PRE>

出力例:
<PRE>

<B>repo/project1/CVS</B>
<B>repo/gnu/project2/.svn</B>
<B>repo/gnu/project3/.svn</B>
<B>repo/gnu/project3/src/.svn</B>
<B>repo/project4/.git</B>

</PRE>

この例では、 <B>-prune</B> を指定することによって、 すでに対象が見つかったディレクトリの配下は、 それ以上の検索が不要なので、
検索を行わないようにしています (たとえば <I>project3/src</I> は検索されません。 その理由は <I>project3/.svn</I> が、
すでに見つかっているからです)。 しかし、 となり合わせのディレクトリ (たとえば、 <I>project2</I> と <I>project3</I>) は、
確実に検索されます。
</DL>
<A NAME="lbAX">&nbsp;</A>
<H3>この他の利用例</H3>

<DL COMPACT>
<DT>&bull;<DD>
複数のファイルタイプを検索します。
<PRE>

<B>$ find /tmp -type f,d,l</B>

</PRE>

ファイルタイプとして、  カンマ区切りのリスト (GNU 拡張) を指定して、 それぞれファイル、 ディレクトリ、 シンボリックリンクを <I>/tmp</I>
ディレクトリの中から検索します。 同じことは、 やや長くなりますが、 移植性の高い記述として、 以下のようにしても同じです。
<PRE>

<B>$ find /tmp \( -type f -o -type d -o -type l \)</B>

</PRE>

<DT>&bull;<DD>
特定の名前 <I>needle</I> を持ったファイルを検索して、 最初にそれが見つかった時点で、 すぐに終了するようにします。
<PRE>

<B>$ find / -name needle -print -quit</B>

</PRE>

<DT>&bull;<DD>
<B>-printf</B> アクションの書式ディレクティブ <B>%f</B> と <B>%h</B> が、 境界条件において、 どのように解釈されるかを示します。
<PRE>

<B>$ find . .. / /tmp /tmp/TRACE compile compile/64/tests/find -maxdepth 0 -printf '[%h][%f]\n'</B>
<B>[.][.]</B>
<B>[.][..]</B>
<B>[][/]</B>
<B>[][tmp]</B>
<B>[/tmp][TRACE]</B>
<B>[.][compile]</B>
<B>[compile/64/tests][find]</B>

</PRE>

</DL>
<A NAME="lbAY">&nbsp;</A>
<H2>終了ステータス</H2>

<B>find</B> は、 すべてのファイルを正常に処理できれば、 ステータス 0 で終了します。 エラーが起きた場合は、 1 以上を返します。 ここでは、
わざと大まかな説明としていますが、 返り値が 0 以外だった場合、 <B>find</B> の結果は正しいと思わないでください。
<P>
エラーが発生した場合、 <B>find</B> は、 指定されたアクションを完了しないまま、 その場で終了することがあります。 たとえば、
検索開始ポイントの中には、 検索されずに終わるものもあります。 あるいは <B>-exec&nbsp;...&nbsp;{}&nbsp;+</B> や <B>-execdir&nbsp;...&nbsp;{}&nbsp;+</B> において、 まだ呼び出しが行われていないプログラムが、 実行されないまま終了することもあります。
<A NAME="lbAZ">&nbsp;</A>
<H2>履歴</H2>

findutils-4.2.2 以降、 ファイル名のパターンに使われるシェルのメタ文字 (`*', `?', `[]' など) は、 先頭の `.'
に一致します。 これは IEEE POSIX interpretation 126 が要求しているためです。
<P>

findutils-4.3.3 以降 <B>-perm&nbsp;/000</B> は、 どんなファイルにも一致しない、 ではなく、 すべてのファイルに一致する、
になりました。
<P>

ナノ秒まで表現するタイムスタンプは、 findutils-4.3.3 で実装されました。
<P>

findutils-4.3.11 以降、 アクション <B>-delete</B> の処理に失敗すると、 <B>find</B> の終了ステータスは 0
以外の値になります。 ただし、 <B>find</B> は、 その場ですぐには終了しません。 以前のバージョンでは、 <B>-delete</B> の処理が失敗しても、
<B>find</B> の終了ステータスとは無関係でした。
<TABLE>
<TR VALIGN=top><TD>機能</TD><TD>追加時期</TD><TD>他システムの対応<BR></TD></TR>
<TR VALIGN=top><TD>-files0-from</TD><TD>4.9.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-newerXY</TD><TD>4.3.3</TD><TD>BSD<BR></TD></TR>
<TR VALIGN=top><TD>-D</TD><TD>4.3.1</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-O</TD><TD>4.3.1</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-readable</TD><TD>4.3.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-writable</TD><TD>4.3.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-executable</TD><TD>4.3.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-regextype</TD><TD>4.2.24</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-exec ... +</TD><TD>4.2.12</TD><TD>POSIX<BR></TD></TR>
<TR VALIGN=top><TD>-execdir</TD><TD>4.2.12</TD><TD>BSD<BR></TD></TR>
<TR VALIGN=top><TD>-okdir</TD><TD>4.2.12</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-samefile</TD><TD>4.2.11</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-H</TD><TD>4.2.5</TD><TD>POSIX<BR></TD></TR>
<TR VALIGN=top><TD>-L</TD><TD>4.2.5</TD><TD>POSIX<BR></TD></TR>
<TR VALIGN=top><TD>-P</TD><TD>4.2.5</TD><TD>BSD<BR></TD></TR>
<TR VALIGN=top><TD>-delete</TD><TD>4.2.3</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-quit</TD><TD>4.2.3</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-d</TD><TD>4.2.3</TD><TD>BSD<BR></TD></TR>
<TR VALIGN=top><TD>-wholename</TD><TD>4.2.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-iwholename</TD><TD>4.2.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-ignore_readdir_race</TD><TD>4.2.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-fls</TD><TD>4.0</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-ilname</TD><TD>3.8</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-iname</TD><TD>3.8</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-ipath</TD><TD>3.8</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>-iregex</TD><TD>3.8</TD><TD><BR></TD></TR>
</TABLE>

<P>

<B>-perm +MODE</B> という文法は、 findutils-4.5.12 において削除されました。 代わりに、 <B>-perm /MODE</B>
を使用してください。　<B>+MODE</B> という文法は、 2005 年にリリースされた findutils-4.2.21 以降、 非推奨となっています。
<A NAME="lbBA">&nbsp;</A>
<H2>バグではないもの</H2>

<A NAME="lbBB">&nbsp;</A>
<H3>意外なオペレーター優先順位</H3>

以下のようなコマンド <B>find . -name afile -o -name bfile -print</B> は、 <I>afile</I> を出力しません。
なぜなら実際には <B>find . -name afile -o \( -name bfile -a -print \)</B> と同じものだからです。
<B>-a</B> の優先順位は <B>-o</B> よりも高いことを忘れないでください。 またテストとテストの間に、 オペレーターが指定されていないければ、
<B>-a</B> であるとみなされる点も注意してください。
<A NAME="lbBC">&nbsp;</A>
<H3>エラーメッセージ "paths must precede expression"</H3>

<PRE>
<B>$ find . -name *.c -print</B>
find: paths must precede expression
find: possible unquoted pattern after predicate `-name'?
</PRE>

<P>

<I>*.c</I> というパターンをシェルが展開した際に、 カレントディレクトリの複数ファイルに該当した場合に、 このエラーが発生します。 この場合には、
対象となったファイル名が、 <B>find</B> におけるコマンドライン上に、 以下のように受け渡されることになります。
<PRE>
<B>find . -name frcode.c locate.c word_io.c -print</B>
</PRE>

上のコマンドは、 もちろん動作しません。 述語表現である <B>-name</B> の引数は、 パターンを 1 つしか受けつけないからです。
そのような記述とするのではなく、 パターンの表現部分は、 クォートでくくるか、 ワイルドカードをエスケープしてください。 以下のようにすることで、
ファイル名がシェルによって展開されることなく、 <B>find</B> のファイル名の一致検索の際に、
ワイルドカードを用いたパターン検索ができるようになります。
<PRE>
<B>$ find . -name '*.c' -print</B>
<B>$ find . -name \*.c -print</B>
</PRE>

<A NAME="lbBD">&nbsp;</A>
<H2>バグ</H2>

POSIX が規定する <B>find</B> の動作には、 セキュリティ上の問題があって、 これを修正することはできません。 たとえば、 アクション
<B>-exec</B> は、 本質的に安全ではないため。 代わりに <B>-execdir</B> を使ってください。
<P>

環境変数 <B>LC_COLLATE</B> は、 アクション <B>-ok</B> に対しては、 何の効果も及ぼしません。
<A NAME="lbBE">&nbsp;</A>
<H2>バグ報告</H2>

GNU findutils オンラインヘルプ:
&lt;<A HREF="https://www.gnu.org/software/findutils/#get-help">https://www.gnu.org/software/findutils/#get-help</A>&gt;
<BR>

翻訳に関するバグ報告 &lt;<A HREF="https://translationproject.org/team/">https://translationproject.org/team/</A>&gt;
<P>

その他の問題について GNU Savannah バグトラッカー経由での報告:
<DL COMPACT><DT><DD>
&lt;<A HREF="https://savannah.gnu.org/bugs/?group=findutils">https://savannah.gnu.org/bugs/?group=findutils</A>&gt;
</DL>

GNU findutils パッケージのメーリングリスト <I>bug-findutils</I> において議論されている全般的なトピック:
<DL COMPACT><DT><DD>
&lt;<A HREF="https://lists.gnu.org/mailman/listinfo/bug-findutils">https://lists.gnu.org/mailman/listinfo/bug-findutils</A>&gt;
</DL>

<A NAME="lbBF">&nbsp;</A>
<H2>著作権</H2>

Copyright &#169; 1990-2022 Free Software Foundation, Inc.  License GPLv3+: GNU
GPL version 3 or later &lt;<A HREF="https://gnu.org/licenses/gpl.html">https://gnu.org/licenses/gpl.html</A>&gt;.
<BR>

This is free software: you are free to change and redistribute it.  There is
NO WARRANTY, to the extent permitted by law.
<A NAME="lbBG">&nbsp;</A>
<H2>関連項目</H2>

<B><A HREF="../../0MultiFileIdx/man1/chmod.1.html">chmod</A></B>(1), <B><A HREF="../man1/locate.1.html">locate</A></B>(1), <B><A HREF="../../0MultiFileIdx/man1/ls.1.html">ls</A></B>(1), <B><A HREF="../man1/updatedb.1.html">updatedb</A></B>(1), <B><A HREF="../man1/xargs.1.html">xargs</A></B>(1),
<B><A HREF="../../LDP_man-pages/man2/lstat.2.html">lstat</A></B>(2), <B><A HREF="../../LDP_man-pages/man2/stat.2.html">stat</A></B>(2), <B><A HREF="../../LDP_man-pages/man3/ctime.3.html">ctime</A></B>(3)  <B><A HREF="../../LDP_man-pages/man3/fnmatch.3.html">fnmatch</A></B>(3), <B><A HREF="../../LDP_man-pages/man3/printf.3.html">printf</A></B>(3),
<B><A HREF="../../LDP_man-pages/man3/strftime.3.html">strftime</A></B>(3), <B><A HREF="../man5/locatedb.5.html">locatedb</A></B>(5), <B><A HREF="../../LDP_man-pages/man7/regex.7.html">regex</A></B>(7)
<P>

完全なドキュメント &lt;<A HREF="https://www.gnu.org/software/findutils/find">https://www.gnu.org/software/findutils/find</A>&gt;
<BR>

またローカルにおいては <B>info find</B> により参照できます。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">説明</A><DD>
<DT><A HREF="#lbAE">オプション</A><DD>
<DT><A HREF="#lbAF">式</A><DD>
<DL>
<DT><A HREF="#lbAG">位置オプション</A><DD>
<DT><A HREF="#lbAH">グローバルオプション</A><DD>
<DT><A HREF="#lbAI">テスト (test)</A><DD>
<DT><A HREF="#lbAJ">アクション</A><DD>
<DT><A HREF="#lbAK">オペレーター</A><DD>
</DL>
<DT><A HREF="#lbAL">普通ではないファイル名</A><DD>
<DT><A HREF="#lbAM">規格への準拠</A><DD>
<DT><A HREF="#lbAN">環境変数</A><DD>
<DT><A HREF="#lbAO">例</A><DD>
<DL>
<DT><A HREF="#lbAP">単純な `find|xargs` のアプローチ</A><DD>
<DT><A HREF="#lbAQ">安全な `find -print0 | xargs -0` によるアプローチ</A><DD>
<DT><A HREF="#lbAR">任意の検索開始ポイントからの処理</A><DD>
<DT><A HREF="#lbAS">各ファイルに対するコマンド実行</A><DD>
<DT><A HREF="#lbAT">異なる 2 つのアクション、 ファイルシステム検索は 1 回</A><DD>
<DT><A HREF="#lbAU">期間の指定を使ったファイル検索</A><DD>
<DT><A HREF="#lbAV">許可属性を使ったファイル検索</A><DD>
<DT><A HREF="#lbAW">除外 - ファイルやサブディレクトリの除き方</A><DD>
<DT><A HREF="#lbAX">この他の利用例</A><DD>
</DL>
<DT><A HREF="#lbAY">終了ステータス</A><DD>
<DT><A HREF="#lbAZ">履歴</A><DD>
<DT><A HREF="#lbBA">バグではないもの</A><DD>
<DL>
<DT><A HREF="#lbBB">意外なオペレーター優先順位</A><DD>
<DT><A HREF="#lbBC">エラーメッセージ "paths must precede expression"</A><DD>
</DL>
<DT><A HREF="#lbBD">バグ</A><DD>
<DT><A HREF="#lbBE">バグ報告</A><DD>
<DT><A HREF="#lbBF">著作権</A><DD>
<DT><A HREF="#lbBG">関連項目</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:23 GMT, December 05, 2022
</BODY>
</HTML>
