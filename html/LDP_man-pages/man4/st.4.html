
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of ST</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../jm.css">
</HEAD>
<BODY>

<H1>ST</H1>
Section: Linux Programmer's Manual (4)<BR>Updated: 2020-04-11<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/LDP_man-pages/release/man4/st.4">roff page</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

st - SCSI テープデバイス
<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/mtio.h">sys/mtio.h</A>&gt;</B>

<B>int ioctl(int </B><I>fd</I><B>, int </B><I>request</I><B> [, (void *)</B><I>arg3</I><B>]);</B>
<B>int ioctl(int </B><I>fd</I><B>, MTIOCTOP, (struct mtop *)</B><I>mt_cmd</I><B>);</B>
<B>int ioctl(int </B><I>fd</I><B>, MTIOCGET, (struct mtget *)</B><I>mt_status</I><B>);</B>
<B>int ioctl(int </B><I>fd</I><B>, MTIOCPOS, (struct mtpos *)</B><I>mt_pos</I><B>);</B>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>説明</H2>

<B>st</B> ドライバーは様々な SCSI テープデバイスのインターフェイスを提供する。 現在では、ドライバーは検出された全ての
"シーケンシャルアクセス (sequential-access) " タイプのデバイスへの 制御を行う。 <B>st</B>
ドライバーはメジャーデバイス番号 9 を用いる。
<P>

それぞれのデバイスは 8 つのマイナーデバイス番号を使う。 マイナー番号の低位側の 5 ビットは、検出された順に割り当てられる。 カーネル 2.6
では、 低位側 8 ビットよりも上位にあるビット群がこの 5 ビットに連結 (concatenate)  され、テープ番号となる。
マイナー番号は、それぞれ 4 つの数字からなる二つのセットに グループ分けされる。 基本 (自動巻き戻し) デバイス番号 <I>n</I>、 および
"非巻き戻し (no-rewind) " デバイス番号 (<I>n</I> + 128).  である。
基本デバイス番号を用いてオープンされたデバイスには、 クローズする時に <B>REWIND</B> コマンドが送られる。 "非巻き戻し"
デバイス番号を用いてオープンされた場合は <FONT SIZE="-1">REWIND</FONT> コマンドは送られない (自動巻き戻しデバイスをテープの位置決めに (例えば mt
で) 用いても、 望む結果は得られない。テープは mt コマンドの後で巻き戻され、 次のコマンドはテープの先頭から始まってしまう)。
<P>

それぞれのグループで、異なった特性 (ブロックサイズ・圧縮・ 密度など) のデバイスを定義するために 4 つのマイナー番号が利用できる。
システムが起動したときには、最初のデバイスだけが使える。 他の 3 つはデフォルトの特性が定義されて初めて使えるようになる (後述)。
(コンパイル時の定数を変更することによって、テープドライブの最大数と、 それぞれのドライブに割り当てられるマイナー番号の個数とを調整できる。
デフォルトの割り当てでは 32 台までのテープドライブを制御できる。 例えば 64 台までのテープドライブを、異なったオプションを持つ
二つのマイナー番号で制御するようにもできる。)
<P>

デバイスは普通次のように作られる:
<P>



mknod -m 666 /dev/st0 c 9 0
mknod -m 666 /dev/st0l c 9 32
mknod -m 666 /dev/st0m c 9 64
mknod -m 666 /dev/st0a c 9 96
mknod -m 666 /dev/nst0 c 9 128
mknod -m 666 /dev/nst0l c 9 160
mknod -m 666 /dev/nst0m c 9 192
mknod -m 666 /dev/nst0a c 9 224


<P>

これらには対応するブロックデバイスは存在しない。
<P>

ドライバは内部バッファーを使い、その大きさは少なくともテープの 1 ブロックを保持できるように取られる。 2.1.121 以前のカーネルでは、
バッファーは連続する一つのブロックとして割り当てられる。この方法だと、 ブロックサイズの最大値はカーネルの割り当て可能な連続メモリーブロックに
制限される。この制限は 32 ビットアーキテクチャーでは 128&nbsp;kB、 64 ビットアーキテクチャーでは 256&nbsp;kB
である。これ以降のカーネルでは、 ドライバは必要に応じていくつかにわかれたバッファーを割り当てる。 デフォルトでは 16
個までの部分に分割できる。すなわち ブロックサイズの最大値は非常に大きい (128&nbsp;kB のブロック 16 個の 割り当てに成功すれば 2&nbsp;MB
となる)。
<P>

ドライバの内部バッファーのサイズはコンパイル時の定数で定義される。 これはカーネルの起動時オプションによって上書き可能である。
さらにドライバは実行時にも、必要に応じてより大きな一時バッファーを 割り当てようとする。しかし実行時に大きな連続メモリーブロックを
割り当てようとすると失敗することがあるので、 2.1.121 以前のカーネルでは、動的なバッファー割り当てはあまりあてにしないほうが良い (これは
kerneld や kmod によるドライバのデマンドロードに関しても当てはまる)。
<P>

ドライバはドライブのメーカやモデルを特定してサポートするわけではない。 システムが起動すると、テープデバイスのオプションがドライブの
ファームウェアによって定義される。例えば、 ドライブのファームウェアが固定長ブロックモードを選択すれば、
テープデバイスは固定長ブロックモードを使うことになる。このオプションは <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  コールを明示的に使えば変更でき、
その変更はデバイスがクローズされて再びオープンされたときも残る。 オプションの設定は、 自動巻き戻しデバイスと非巻き戻しデバイスの両方に影響する。
<P>

4 つのサブグループそれぞれのデバイスに対して異なるオプションを 与えることができる。オプションはデバイスがオープンされたときに
効力を発揮する。例えば、システム管理者はあるデバイスを 適当なブロックサイズの固定長ブロックモードで書き込むように定義し、
別のデバイスを可変長ブロックモードで書き込むようにできる (ドライブが 両方のモードをサポートしていれば)。
<P>

このドライバは、 <B>テープのパーティション</B> をサポートしている (ドライブがサポートしている場合)。
(テープのパーティションはディスクパーティションとはなんの関係もない。 パーティション化されたテープは、一つのメディアに複数の論理テープが
存在するかのように見える。)  パーティションのサポートは <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  によって有効にできる。 パーティションが変更されると、
テープの位置はそれぞれのパーティション内部で保存される。 パーティションの選択は <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  で行う。
それ以降のテープ操作の対象は、そのパーティションになる。 パーティションの切り替えは、次のテープ操作と同時に行われ、
不必要なテープ移動をしなくてすむようになっている。 一つのテープにおけるパーティションの最大数は コンパイル時の定数によって定義される (通常は 4)。
ドライバには、テープの 1 つまたは 2 つのパーティションをフォーマットできるような <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  が用意されている。
<P>

通常、システムのデフォルトのテープデバイスに対するハードリンク またはソフトリンクとして、デバイス <I>/dev/tape</I> が作成される。
<P>

カーネル 2.6.2 以降では、このドライバは sysfs ディレクトリ <I>/sys/class/scsi_tape</I>
に、アタッチしたデバイスとそのデバイスに割当てたパラメーターをエクスポートする。
<A NAME="lbAE">&nbsp;</A>
<H3>データ転送</H3>

このドライバは固定長ブロックモードと可変長ブロックモードの 両方をサポートしている (ドライブがサポートしていれば)。
固定長ブロックモードでは、ドライブは決まったサイズのブロックを (複数個) 書き込む。このブロックサイズは write
システムコールのバイト数によらない。 可変長ブロックモードでは、 write コールごとに一つのテープブロックに書き込みが行われる。
したがってバイト数が対応するテープブロックのサイズを決める。 テープ上のブロックには、書き込みモードの情報は一切含まれない。
読み込みのときに重要なことは、テープのブロックサイズを受け入れる コマンドを使うかどうかだけである。
<P>

可変長ブロックモードでは、読み込みバイト数はテープのブロックサイズと 必ずしも一致していなくても良い。バイト数がテープの次のブロックよりも
大きければ、ドライバはそのデータを返し、関数は実際のブロックサイズを返す。 ブロックサイズがバイト数よりも大きければ、エラーが返される。
<P>

固定長ブロックモードでは、バッファーリングが有効になっていれば 読み込みバイト数は任意の大きさでよい。バッファーリングが無効の場合は、
テープのブロックサイズの整数倍でなければならない。 2.1.121 以前の カーネルでは、バッファーリングが有効な場合には
任意のバイト数の書き込みができる。その他の場合すべて (2.1.121 以前のカーネルでバッファーが無効な場合と、新しいカーネルの場合)
では、書き込みバイト数はテープブロックサイズの整数倍でなければならない。
<P>

2.6 カーネルでは、このドライバはユーザーバッファーとデバイス間で、 データの直接転送 (direct transfer) を試みる。
これが不可能な場合は、ドライバの内部バッファーを用いる。 直接転送ができない理由としては、ユーザーバッファーのアラインメントが適切でない (デフォルトは
512 バイトだが HBA ドライバによって変更されている可能性がある)、 ユーザーバッファーのページが SCSI アダプターから見えない、
などが考えられる。
<P>

テープをクローズする直前のテープ操作命令が書き込みであれば、 ファイルマークが自動的にテープへ書き込まれる。
<P>

読み込み時にファイルマークに出会うと、以下が実行される。 ファイルマークが見付かったときにバッファーにデータが残っていると、
バッファーのデータが返される。次の読み込み操作は 0 バイトを返す。 その次の読み込みは次のファイルからのデータを返す。
記録データの末尾は、読み込み操作が二回続けて 0 バイトを返して来るかたちで通知される。三回目の読み込みはエラーを返す。
<A NAME="lbAF">&nbsp;</A>
<H3>ioctl</H3>

ドライバは 3 つの <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  要求をサポートしている。 <B>st</B> ドライバによって認識されなかった要求は <B>SCSI</B>
ドライバにわたされる。 以下の定義は <I>/usr/include/linux/mtio.h</I> による。
<A NAME="lbAG">&nbsp;</A>
<H3>MTIOCTOP --- テープ操作の実行</H3>

<P>

この要求は <I>(struct mtop&nbsp;*)</I> 型の引数をとる。全てのドライブが全ての操作をサポートしているわけではない。
ドライブが操作を拒否すると、ドライバは <B>EIO</B> エラーを返す。
<P>



/* Structure for MTIOCTOP - mag tape op command: */
struct mtop {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;mt_op;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;operations&nbsp;defined&nbsp;below&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_count;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;how&nbsp;many&nbsp;of&nbsp;them&nbsp;*/
};


<P>

通常のテープ利用のための磁気テープ操作:
<DL COMPACT>
<DT><B>MTBSF</B><DD>
<I>mt_count</I> 個のファイルマーク (filemark) 分の後方スペース (backward space)。
<DT><B>MTBSFM</B><DD>
<I>mt_count</I> 個のファイルマーク分の後方スペース。 テープの位置を最後のファイルマークの EOT 側に変更する。
<DT><B>MTBSR</B><DD>
<I>mt_count</I> 個のレコード (テープブロック) 分の後方スペース。
<DT><B>MTBSS</B><DD>
<I>mt_count</I> 個のセットマーク分の後方スペース。
<DT><B>MTCOMPRESSION</B><DD>
<I>mt_count</I> が 0 以外なら、ドライブのデータ圧縮を有効にする。 0 なら圧縮を無効にする。このコマンドは MODE ページ 15
を用いる。 これはほとんどの DAT でサポートされている。
<DT><B>MTEOM</B><DD>
(ファイルを追加するために) メディアの記録部分の最後まで進める。
<DT><B>MTERASE</B><DD>
テープの内容を消去する。 2.6 カーネルでは、引数が 0 ならば short erase (テープが空だと印をつける)  を行う。それ以外の場合は
long erase (全体を消去する) を行う。
<DT><B>MTFSF</B><DD>
<I>mt_count</I> 個のファイルマーク分の前方スペース (forward space)。
<DT><B>MTFSFM</B><DD>
<I>mt_count</I> 個のファイルマーク分の前方スペース。 テープの位置は最後のファイルマークの BOT 側変更される。
<DT><B>MTFSR</B><DD>
<I>mt_count</I> 個のレコード (テープブロック) 分の前方スペース。
<DT><B>MTFSS</B><DD>
<I>mt_count</I> 個のセットマーク分の前方スペース。
<DT><B>MTLOAD</B><DD>
SCSI ロードコマンドを実行する。 HP オートローダーに限って利用できる。 <I>mt_count</I> が定数
<B>MT_ST_HPLOADER_OFFSET</B> とある数値の和である場合、 その数値がドライブに送られ、オートローダーの制御に用いられる。
<DT><B>MTLOCK</B><DD>
テープドライブの扉をロックする。
<DT><B>MTMKPART</B><DD>

Format the tape into one or two partitions.  If <I>mt_count</I> is positive, it
gives the size of partition 1 and partition 0 contains the rest of the
tape.  If <I>mt_count</I> is zero, the tape is formatted into one partition.
From kernel version 4.6, a negative <I>mt_count</I> specifies the size of
partition 0 and the rest of the tape contains partition 1.  The physical
ordering of partitions depends on the drive.  This command is not allowed
for a drive unless the partition support is enabled for the drive (see
<B>MT_ST_CAN_PARTITIONS</B> below).
<DT><B>MTNOP</B><DD>
何も操作を行わない。---副次的な効果として、ドライバーのバッファー をフラッシュする。 <B>MTIOCGET</B>
を使って状態を読み出す前にはこの操作を行うべきである。
<DT><B>MTOFFL</B><DD>
巻き戻し (rewind) を行い、ドライブをオフライン (off line) にする。
<DT><B>MTRESET</B><DD>
ドライブをリセットする。
<DT><B>MTRETEN</B><DD>
テープをリテンション (re-tension) する (テープを最後まで巻いた後、最初まで巻き戻す)。
<DT><B>MTREW</B><DD>
巻き戻し。
<DT><B>MTSEEK</B><DD>
<I>mt_count</I> で指定されたテープブロック番号をシークする。 この操作が行えるのは、 <FONT SIZE="-1">LOCATE</FONT> コマンド
(デバイス固有のアドレス)  をサポートする SCSI-2 ドライブか、あるいは Tandberg 互換の SCSI-1 ドライブ (Tandberg,
Archive, Viper, Wangtek,…) である。 デバイス固有のアドレスが利用されている場合は、ブロック番号は 以前に
<FONT SIZE="-1">MTIOCPOS</FONT> によって返されたものにすべきである。
<DT><B>MTSETBLK</B><DD>
<I>mt_count</I> の値をドライブのブロック長 (block length) としてセットする。 ブロック長を 0
にするとドライブは可変長ブロックサイズモードにセッ トされる。
<DT><B>MTSETDENSITY</B><DD>
テープ密度 (tape density) を <I>mt_count</I> で示されるコードに変更する。ドライブでサポートされている密度コード
については、ドライブの文書に書いてあるだろう。
<DT><B>MTSETPART</B><DD>
アクティブなパーティションを第 <I>mt_count</I> 番目に切り替える。パーティションは 0 から数える。
このコマンドは、パーティションのサポートが有効にされた ドライブでなければ使えない (以下の <B>MT_ST_CAN_PARTITIONS</B> を見よ)。
<DT><B>MTUNLOAD</B><DD>
SCSI unload コマンドを実行する (テープのイジェクトは行わない)。
<DT><B>MTUNLOCK</B><DD>
テープドライブの扉のロックを解除する。
<DT><B>MTWEOF</B><DD>
<I>mt_count</I> 個のファイルマークを書き込む。
<DT><B>MTWSM</B><DD>
<I>mt_count</I> 個のセットマークを書き込む。
</DL>
<P>

デバイスオプションの設定のための (スーパーユーザーによる) 磁気テープ操作:
<DL COMPACT>
<DT><B>MTSETDRVBUFFER</B><DD>
いろいろなドライブとドライバーのオプションを <I>mt_count</I> にエンコードされた各ビットに従って設定する。
オプションには、ドライブのバッファーリングモード、 ブール値のドライバオプションの集合、 バッファーの書き込み閾値
(デフォルトはブロックサイズと密度)、 タイムアウト値が含まれる (カーネル 2.1 以降)。
一回の操作で変えられるのは、下記のリストのどれか一つだけである (複数のブール値はまとめて一つと勘定される)。
<DT><DD>
高位の4ビットがゼロである値は、 ドライブのバッファーリングモードの設定に使われる。 バッファーリングモードは以下の通り:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>0<DD>
ドライブはライトコマンドに対し、 データブロックが実際に媒体に書き込まれるまで <B>GOOD</B> のステータスを返さない。
<DT>1<DD>
ドライブはライトコマンドに対し、 すべてのデータがドライブの内部バッファーに転送されるとすぐに、 <B>GOOD</B> のステータスを返すことができる。
<DT>2<DD>
ライトコマンドに対し、以下の 2 つの条件がそろった場合、 ドライブはすぐに <B>GOOD</B> ステータスを返す事ができる。 (a)
すべてのデータがドライブの内部バッファーに転送された。 (b) 別々のイニシエーターから来たバッファーデータが、 すべて媒体へ問題なく書き込まれた。
</DL>
</DL>

<DT><DD>
書き込み閾値を制御するには、 <I>mt_count</I> には、定数 <B>MT_ST_WRITE_THRESHOLD</B> とブロックカウントのビット毎の OR
をとった値を 下位の 28ビットに含まねばならない。 このブロックカウントは 1024 バイトブロックを単位としたもので、
テープの物理ブロックサイズを単位としたものではない。 また、閾値はドライバの内部バッファー (上記の説明参照)  のサイズを越える事はできない。
<DT><DD>
ブール値のフラグを設定・解除するには、 <I>mt_count</I> の値は <B>MT_ST_BOOLEANS</B>, <B>MT_ST_SETBOOLEANS</B>,
<B>MT_ST_CLEARBOOLEANS</B>, <B>MT_ST_DEFBOOLEANS</B>
のいずれか一つの値に、以下のオプションの任意の組み合わせに対して ビット毎の OR を取ったものを指定する。
<B>MT_ST_BOOLEANS</B>を用いると、 オプションを対応するビットに対して定義されている値に設定できる。
<B>MT_ST_SETBOOLEANS</B>を用いると、 オプションは選択的に設定され、 <B>MT_ST_DEFBOOLEANS</B>を用いると
選択的に解除される。
<DT><DD>
テープデバイスのデフォルトのオプションは <B>MT_ST_DEFBOOLEANS</B> によって設定される。 アクティブでないテープデバイス (例:
マイナー番号 が 32 や 160 のデバイス)  は、それらに対するデフォルトのオプションが最初に定義されたときに
アクティブになる。アクティブにされたデバイスは、 起動時にアクティブにされたデバイスから、 明示的に指定されなかったオプションを継承する。
<DT><DD>
ブール値のオプションは以下の通り:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>MT_ST_BUFFER_WRITES</B> (デフォルト: 真)<DD>
固定長ブロックモードにおけるすべての書き込み操作をバッファーリングする。 このオプションが偽であり、かつドライブが固定長ブロックサイズの時は、
すべての書き込み操作はブロックサイズの倍数の大きさで行わなければならない。 信頼性のあるマルチボリュームアーカイブを書き込むためには、
このオプションは偽に設定されていなければならない。
<DT><B>MT_ST_ASYNC_WRITES</B> (デフォルト: 真)<DD>
このオプションが真の時には、データがドライバのバッファーに収まる時には データがドライブに転送されるのを待たずに、すぐに書き込み操作が返って来る。
バッファーがどのくらい空いたら次の SCSI write コマンドを発行できるかは、 書き込み閾値によって決まる。
ドライブが返すすべてのエラーは、次の操作まで保存される。 信頼性のあるマルチボリュームアーカイブを書き込むためには、
このオプションは偽に設定されていなければならない。
<DT><B>MT_ST_READ_AHEAD</B> (デフォルト: 真)<DD>
このオプションを指定すると、 ドライバは固定長ブロックモードで読み込みバッファーリングと先読みをするようになる。
このオプションが偽であり、かつドライブが固定長ブロックサイズの時は、 すべての読み込み操作はブロックサイズの倍数の大きさで行わなければならない。
<DT><B>MT_ST_TWO_FM</B> (デフォルト: 偽)<DD>
このオプションはファイルがクローズされた時のドライバーの振舞いを変更する。 一つのファイルマークを書き込むのが通常の動作である。
このオプションが真の時には、 ドライバーは 2 つのファイルマークを書き込んで、 2 つめのファイルマークのところに戻る。
<DT><DD>
注意： QICテープドライブはファイルマークに上書きすることができないので、 このオプションを真にしてはならない。
これらのドライブは記録データの末尾の検知に、 ファイルマークが 2つ続けてあるかではなく、 ブランクテープかどうかのテストを用いる。
現在の他のほとんどのドライブも、記録データの末尾を検知する。 2 つのファイルマークが必要になるのは、 他のシステムとテープをやりとりする場合である。
<DT><B>MT_ST_DEBUGGING</B> (デフォルト: 偽)<DD>
このオプションを真にすると、 ドライバはいろいろなデバッグ用メッセージを出すようになる (<B>DEBUG</B>
を非ゼロに定義してドライバをコンパイルしている時のみ有効)。
<DT><B>MT_ST_FAST_EOM</B> (デフォルト: 偽)<DD>
このオプションを真にすると、 <B>MTEOM</B> 操作が直接ドライブに送られるようになる。 操作が早くなるはずだが、
ドライバが現在のファイル番号を見失うことになる (これは通常なら <B>MTIOCGET</B> リクエストによって返される)。
<B>MT_ST_FAST_EOM</B> が偽の時には、ドライバは <B>MTEOM</B> リクエストに応えるとき、前方にファイルを一つ一つ進めていく。
<DT><B>MT_ST_AUTO_LOCK</B> (デフォルト: 偽)<DD>
このオプションが真の時には、 デバイスファイルがオープンされるとドライブの扉がロックされ、 クローズされるとアンロックされる。
<DT><B>MT_ST_DEF_WRITES</B> (デフォルト: 偽)<DD>
テープオプション (ブロックサイズ、モード、圧縮など)  があるドライブにリンクされたデバイスで変更されると、
その同じドライブにリンクされた他のデバイスでも変更されることがある (そのデバイスの定義による)。このオプションは、 ドライバによる変更をいつ SCSI
コマンドによって反映させるかと、 ドライブの自動検知機能がいつ信頼して良いのかを定義する。 このオプションを偽にしておくと、
デバイスの変更があるとドライバはすぐに SCSI コマンドを送る。 真にしておくと、 SCSI コマンドは書き込みが要求されるまで送られない。
後者の場合は、読み込みの際にドライブのファームウェアによって テープ構造の検知が行える。また SCSI コマンドは、
テープが正しい指定に沿って書き込まれているかどうかの 確認のためだけに用いられる。
<DT><B>MT_ST_CAN_BSR</B> (デフォルト: 偽)<DD>
先読みを使うと、テープをクローズするときに、 場合によってはテープを正しい位置に逆戻ししなければならないことがある。
これには、レコードを越えて逆戻しする SCSI コマンドが用いられる。 古いドライブでは、このコマンド処理の信頼性が低いことがあるが、
このオプションを指定すると、 ドライバにこのコマンドの利用を禁止することができる。 先読みと固定長ブロックモードを用いていると、最終的な結果として、
デバイスのクローズ時にテープが正しい位置にならないことがある。 2.6 カーネルでは、SCSI-3 をサポートしているドライブに対して、
この値のデフォルトは真となる。
<DT><B>MT_ST_NO_BLKLIMS</B> (デフォルト: 偽)<DD>
ドライブによっては <B>READ BLOCK LIMITS SCSI</B> コマンドを受けつけないことがある。
このオプションを用いると、ドライバはこのコマンドを用いない。 欠点は、指定したブロックサイズがドライブに受理されてしまうと、
ドライバのコマンド送信前チェックができなくなる点である。
<DT><B>MT_ST_CAN_PARTITIONS</B> (デフォルト: 偽)<DD>
このオプションは、一つのテープに複数パーティションを置くことを サポートするかどうかを決める。
このオプションはドライブにリンクされた全てのデバイスに適用される。
<DT>このオプションは、<DD>
seek および tell 操作 (両者とも <B>MTSEEK</B>・<B>MTIOCPOS</B> コマンドを伴い、テープ位置を変更するとき) の際に、
SCSI-2 の標準で定義されている論理ブロックアドレスを用いるかどうかを ドライバに伝える。 偽だとデバイス固有のアドレスが用いられる。
ドライブが論理アドレスをサポートしているときは、 このオプションをセットすることを強く勧める。 このモードではファイルマークもカウントするからである。
論理ブロックアドレスしかサポートしないドライブもいくつか存在している。
<DT><B>MT_ST_SYSV</B> (デフォルト: 偽)<DD>
このオプションが真になっていると、テープデバイスは System V のルールを用いる。偽だと BSD のルールを用いる。
これらのルール間の最も大きな違いは、読み込みを行っていた デバイスがクローズされたときの振舞いである。 System V
のルールでは、テープは次のファイルマークを越えて移動する (デバイスの利用時にこれが行われなかった場合)。 BSD
のルールではテープ位置は変更されない。
<DT><B>MT_NO_WAIT</B> (デフォルト: 偽)<DD>
即時モード (immediate mode; コマンドの終了を待たない)  を、ある種のコマンド (rewind など) に対して有効にする。
</DL>
<P>

例:
<P>



struct mtop mt_cmd;
mt_cmd.mt_op = MTSETDRVBUFFER;
mt_cmd.mt_count = MT_ST_BOOLEANS |
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MT_ST_BUFFER_WRITES&nbsp;|&nbsp;MT_ST_ASYNC_WRITES;
ioctl(fd, MTIOCTOP, mt_cmd);


</DL>

<DT><DD>
デバイスのデフォルトのブロックサイズは <B>MT_ST_DEF_BLKSIZE</B> によって設定でき、デフォルトの密度コードは
<B>MT_ST_DEFDENSITY</B> によって設定できる。 これらのパラメーターの値は操作コードと OR して与える。
<DT><DD>
2.1.x 以降のカーネルでは、タイムアウト値の設定は、 サブコマンド <B>MT_ST_SET_TIMEOUT</B> に秒単位のタイムアウト値を OR
して与えることによって行える。 long タイムアウト (巻き戻しなど、長い時間がかかるコマンドに対して用いられる) は
<B>MT_ST_SET_LONG_TIMEOUT</B> で設定できる。 カーネルのデフォルトは非常に長く、どのドライブでも
成功しているコマンドが決してタイムアウトしないようになっている。 したがって、ドライバはタイムアウトを待っているだけなのに、 刺さった (stuck
した) ように見えることがある。これらのコマンドを使えば、 特定のドライブに対してもう少し実際的な値に設定することができる。
一つのデバイスに設定したタイムアウト値は、 それと同じドライブにリンクした全てのデバイスに適用される。
<DT><DD>
2.4.19 および 2.5.43 以降のカーネルでは、 このドライバはドライブのクリーニングが必要かどうかを示す 状態ビットをサポートする。
ドライブがクリーニング情報を返させるかどうかは、 <B>MT_ST_SEL_CLN</B> サブコマンドによって設定できる。 この値が 0
だと、クリーニングビットは常に 0 となる。 値を 1 にすると、SCSI-3 標準で規定されている TapeAlert データが用いられる
(まだ実装されていない)  値としては 2 から 17 が予約されている。 低位側の 8 ビットが 18 以上だと、拡張状態データ (extended
sense data)  が用いられる。第 9-16 ビットは注目すべきビットを選択するためのマスクを指定し、 第 17-23
ビットは探すべきビットパターンを指定する。 このビットパターンが 0 のときは、 マスク下のビット (群) がクリーニング要求を示す。パターンが 0
でなければ、 このパターンがマスク後の状態データバイトにマッチしなければならない。
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>MTIOCGET --- ステータスの取得</H3>

<P>

このリクエストは <I>(struct mtget&nbsp;*)</I> という型の引数をとる。
<P>



/* structure for MTIOCGET - mag tape get status command */
struct mtget {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_type;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_resid;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;following&nbsp;registers&nbsp;are&nbsp;device&nbsp;dependent&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_dsreg;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_gstat;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mt_erreg;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;next&nbsp;two&nbsp;fields&nbsp;are&nbsp;not&nbsp;always&nbsp;used&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;daddr_t&nbsp;&nbsp;mt_fileno;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;daddr_t&nbsp;&nbsp;mt_blkno;
};


<DL COMPACT>
<DT><I>mt_type</I><DD>
ヘッダーファイル中には多くの <I>mt_type</I> の値が定義されているが、現行のドライバは汎用のタイプである <B>MT_ISSCSI1</B> (汎用
SCSI-1 テープ) および <B>MT_ISSCSI2</B> (汎用 SCSI-2 テープ) のみを返す。
<DT><I>mt_resid</I><DD>
現在のテープ位置番号。
<DT><I>mt_dsreg</I><DD>
ドライブのブロックサイズと密度の現在の設定を報告する (下位 24 ビットがブロックサイズ、上位 8 ビットが密度)。 これらのフィールドは、
<B>MT_ST_BLKSIZE_SHIFT</B>, <B>MT_ST_BLKSIZE_MASK</B>, <B>MT_ST_DENSITY_SHIFT</B>,
<B>MT_ST_DENSITY_MASK</B> で定義されている。
<DT><I>mt_gstat</I><DD>
汎用の (デバイスに依存しない) ステータスを報告する。 これらのステータスビットをテストするためのマクロが ヘッダーファイルで定義されている。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>
<B>GMT_EOF</B>(<I>x</I>): テープはファイルマークの直後に位置している。 (<B>MTSEEK</B> 操作の後では常に偽)
<DT>
<B>GMT_BOT</B>(<I>x</I>): テープは最初のファイルの先頭に位置している。 (<B>MTSEEK</B> 操作の後では常に偽)
<DT>
<B>GMT_EOT</B>(<I>x</I>): テープ操作はテープの物理的な終点に達した。
<DT>
<FONT SIZE="-1">GMT_SM(</FONT><I>x</I><FONT SIZE="-1">)</FONT>: テープは現在セットマークに位置している。 (<B>MTSEEK</B> 操作の後では常に偽)
<DT>
<B>GMT_EOD</B>(<I>x</I>): テープは記録データの末尾に位置している。
<DT>
<B>GMT_WR_PROT</B>(<I>x</I>): ドライブはライトプロテクトされている。 これはドライブによっては、
ドライブが現在のメディアタイプへの書き込みを サポートしていない事を意味する場合もある。
<DT>
<B>GMT_ONLINE</B>(<I>x</I>): もっとも最近の <B><A HREF="../man2/open.2.html">open</A></B>(2)  が、テープが入っていて操作の準備ができているドライブを検知した。
<DT>
<B>GMT_D_6250</B>(<I>x</I>), <B>GMT_D_1600</B>(<I>x</I>), <B>GMT_D_800</B>(<I>x</I>):
この「汎用」のステータス情報は、 9-トラック &#189;&quot; テープドライブの場合にのみ、 現在の密度の設定を報告する。
<DT>
<B>GMT_DR_OPEN</B>(<I>x</I>): ドライブにテープが入っていない。
<DT>
<B>GMT_IM_REP_EN</B>(<I>x</I>): 即時報告モード。 write コールが戻ったとき、
テープに対して物理的な書き込みが行われたかどうかを保証できない場合に、 このビットがセットされる。ドライバがデータをバッファーリングせず、
ドライブもデータをバッファーリングしない場合に限って、 この値は 0 にセットされる。
<DT>
<B>GMT_CLN</B>(<I>x</I>): ドライブがクリーニングを要求している。 カーネル 2.4.19 および 2.5.43 以降で実装された。
</DL>
</DL>

<DT><I>mt_erreg</I><DD>
<I>mt_erreg</I> で定義されているフィールドは一つだけで、 下位の 16 ビットがエラーをリカバーした回数である
(<B>MT_ST_SOFTERR_SHIFT</B> と <B>MT_ST_SOFTERR_MASK</B> で定義されている)。
ドライブの報告するエラーリカバー数と矛盾することがあるので、 この数はほとんどの場合維持されない
(ほとんどのドライブでは、デフォルトではソフトエラーを報告しない。 しかしこれは SCSI MODE SELECT コマンドによって変更できる)。
<DT><I>mt_fileno</I><DD>
(ゼロから数えた) 現在のファイル番号を報告する。 ファイル番号がわからない時 (例えば <B>MTBSS</B> や <B>MTSEEK</B> の後など) には
-1 にセットされる。
<DT><I>mt_blkno</I><DD>
現在のファイル中の(ゼロから数えた)ブロック番号を報告する。 ブロック番号がわからない時 (例えば <B>MTBSF</B>, <B>MTBSS</B>,
<B>MTSEEK</B> の後など) には -1 にセットされる。
</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>MTIOCPOS --- テープ位置の取得</H3>

<P>

このリクエストは <I>(struct mtpos&nbsp;*)</I> 型の引数をとり、ドライブが保持している現在のテープブロック番号を報告する。 これは、
<B>MTIOCGET</B> により返される <I>mt_blkno</I> と同じではない。 ドライブは <B>READ POSITION</B> コマンド
(デバイス固有アドレス)  をサポートする SCSI-2ドライブか、 Tandberg 互換の SCSI-1 ドライブ (Tandberg,
<DD>Archive, Viper, Wangtek, ... ) でなければならない。
<P>



/* structure for MTIOCPOS - mag tape get position command */
struct mtpos {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;mt_blkno;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;current&nbsp;block&nbsp;number&nbsp;*/
};


<A NAME="lbAJ">&nbsp;</A>
<H2>返り値</H2>

<DL COMPACT>
<DT><B>EACCES</B><DD>
書き込み保護されているテープに書き込みまたは消去を行おうとした。 (このエラーは <B><A HREF="../man2/open.2.html">open</A></B>(2)  中には検知されない。)
<DT><B>EBUSY</B><DD>
デバイスがすでに使われているか、 ドライバがバッファーを割当てられなかった。
<DT><B>EFAULT</B><DD>
コマンドの引数が、 呼びだしプロセスに属していないメモリー位置を指している。
<DT><B>EINVAL</B><DD>
<B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  の引数が不正であるか、要求したブロックサイズが不正。
<DT><B>EIO 14</B><DD>
要求された操作が最後まで行えなかった。
<DT><B>ENOMEM</B><DD>

<B><A HREF="../man2/read.2.html">read</A></B>(2)  のバイト数が、テープにある次の物理ブロックより小さい (2.2.18 および 2.4.0
以前では、黙って余分のバイトを無視していた)。
<DT><B>ENOSPC</B><DD>
メディアの終点に達したため、書き込み操作が完了しなかった。
<DT><B>ENOSYS</B><DD>
不明な <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)。
<DT><B>ENXIO</B><DD>
オープンする時にテープデバイスが存在しなかった。
<DT><B>EOVERFLOW</B><DD>
ドライバの内部バッファーより大きいサイズの可変長ブロックを 読み書きしようとした。
<DT><B>EROFS</B><DD>
ドライブに入っているテープがライトプロテクトされている場合に、 <B>O_WRONLY</B> または <B>O_RDWR</B> で open を行おうとした。
</DL>
<A NAME="lbAK">&nbsp;</A>
<H2>ファイル</H2>

<DL COMPACT>
<DT><I>/dev/st*</I><DD>
自動巻き戻しの SCSI テープデバイス。
<DT><I>/dev/nst*</I><DD>





巻き戻しをしない SCSI テープデバイス。
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>注意</H2>

<DL COMPACT>
<DT>1.<DD>
異なるシステムでデータを相互にやりとりする場合、 両方のシステムで物理的なテープブロックサイズを一致させる必要がある。
起動直後のドライブのパラメーターは、大多数の OS がそのデバイスに対して 用いている値と異なっていることもよくある。多くのシステムは、
ドライブが対応していれば可変長ブロックモードを用いる。 DAT、 8mm ヘリカルスキャンドライブ、 DLT などの最近のドライブの
ほとんどは可変長ブロックモードに対応しているから。 これらのドライブは (少なくとも他のシステムとのデータ交換が ある場合は)、 Linux
でも可変長ブロックモードで使うほうが 良いかもしれない (つまりシステムの起動時のモード設定に <B>MTSETBLK</B> または
<B>MTSETDEFBLK</B> を用いる)。 欠点としては、比較的大きなテープブロックサイズを用いなければ、 SCSI
バス上で満足のいく転送速度が得られないことである。
<DT>2.<DD>
多くのプログラム (<B><A HREF="../../GNU_tar/man1/tar.1.html">tar</A></B>(1)  など) では、 コマンドラインからユーザーがブロック関連の値を指定できる。
この値によってテープ上の物理的なブロックサイズを決定できるのは、 可変長ブロックモードに限られることに注意。
<DT>3.<DD>
SCSI テープドライブを用いるには、基本の SCSI ドライバ、 SCSI アダプターのドライバ、 SCSI テープドライバのすべてが
カーネルに組み込まれているか、あるいはモジュールとしてロードされている 必要がある。 SCSI テープドライバがないと、 ドライブは認識されるが、
このページで記述されているテープのサポートは利用できない。
<DT>4.<DD>
ドライバはエラーメッセージをコンソールとログとに書き出す。 カーネル設定で verbose SCSI messages が有効にされていると、
SENSE コードが自動的にテキストに変換されて、 いくつかのメッセージに書きだされる。
<DT>5.<DD>
このドライバの内部バッファーリングは、固定ブロックモードなら <B><A HREF="../man2/read.2.html">read</A></B>(2)  や <B><A HREF="../man2/write.2.html">write</A></B>(2)
のバイト数が小さくても良いスループットを出す。 直接転送ではこれは不可能なので、2.6 カーネルに移行したときに驚くかもしれない。
解決法としては、ソフトウェアにより大きな転送を行うよう伝える (たいていはより大きなブロックを使わせる) ことである。
これが不可能なら、直接転送を無効にすることもできる。
</DL>
<A NAME="lbAM">&nbsp;</A>
<H2>関連項目</H2>

<B><A HREF="../../GNU_cpio/man1/mt.1.html">mt</A></B>(1)
<P>

Linux カーネルソースの <I>drivers/scsi/README.st</I> や <I>Documentation/scsi/st.txt</I>
(カーネル 2.6 以降) の各ファイルには、 ドライバに関するより新しい情報や、 その設定可能な範囲に関する内容が含まれている。
<A NAME="lbAN">&nbsp;</A>
<H2>この文書について</H2>

この man ページは Linux <I>man-pages</I> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は
<A HREF="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</A> に書かれている。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">説明</A><DD>
<DL>
<DT><A HREF="#lbAE">データ転送</A><DD>
<DT><A HREF="#lbAF">ioctl</A><DD>
<DT><A HREF="#lbAG">MTIOCTOP --- テープ操作の実行</A><DD>
<DT><A HREF="#lbAH">MTIOCGET --- ステータスの取得</A><DD>
<DT><A HREF="#lbAI">MTIOCPOS --- テープ位置の取得</A><DD>
</DL>
<DT><A HREF="#lbAJ">返り値</A><DD>
<DT><A HREF="#lbAK">ファイル</A><DD>
<DT><A HREF="#lbAL">注意</A><DD>
<DT><A HREF="#lbAM">関連項目</A><DD>
<DT><A HREF="#lbAN">この文書について</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:34 GMT, December 05, 2022
</BODY>
</HTML>
