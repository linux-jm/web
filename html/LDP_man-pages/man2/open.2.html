
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of OPEN</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../jm.css">
</HEAD>
<BODY>

<H1>OPEN</H1>
Section: Linux Programmer's Manual (2)<BR>Updated: 2020-11-01<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/LDP_man-pages/release/man2/open.2">roff page</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

open, openat, creat - ファイルのオープン、作成を行う
<A NAME="lbAC">&nbsp;</A>
<H2>書式</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/sys/stat.h">sys/stat.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/fcntl.h">fcntl.h</A>&gt;</B>

<B>int open(const char *</B><I>pathname</I><B>, int </B><I>flags</I><B>);</B>
<B>int open(const char *</B><I>pathname</I><B>, int </B><I>flags</I><B>, mode_t </B><I>mode</I><B>);</B>

<B>int creat(const char *</B><I>pathname</I><B>, mode_t </B><I>mode</I><B>);</B>

<B>int openat(int </B><I>dirfd</I><B>, const char *</B><I>pathname</I><B>, int </B><I>flags</I><B>);</B>
<B>int openat(int </B><I>dirfd</I><B>, const char *</B><I>pathname</I><B>, int </B><I>flags</I><B>, mode_t </B><I>mode</I><B>);</B>

/* Documented separately, in <B>openat2</B>(2): */
<B>int openat2(int </B><I>dirfd</I><B>, const char *</B><I>pathname</I><B>,</B>
<B>            const struct open_how *</B><I>how</I><B>, size_t </B><I>size</I><B>);</B>
</PRE>

<P>


glibc 向けの機能検査マクロの要件 (<B><A HREF="../man7/feature_test_macros.7.html">feature_test_macros</A></B>(7)  参照):

<P>

<B>openat</B>():


<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>glibc 2.10 以降:<DD>
_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200809L
<DT>glibc 2.10 より前:<DD>
_ATFILE_SOURCE
</DL>
</DL>



<A NAME="lbAD">&nbsp;</A>
<H2>説明</H2>

The <B>open</B>()  system call opens the file specified by <I>pathname</I>.  If the
specified file does not exist, it may optionally (if <B>O_CREAT</B> is specified
in <I>flags</I>)  be created by <B>open</B>().
<P>

The return value of <B>open</B>()  is a file descriptor, a small, nonnegative
integer that is used in subsequent system calls (<B><A HREF="../man2/read.2.html">read</A></B>(2), <B><A HREF="../man2/write.2.html">write</A></B>(2),
<B><A HREF="../man2/lseek.2.html">lseek</A></B>(2), <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2), etc.) to refer to the open file.  The file
descriptor returned by a successful call will be the lowest-numbered file
descriptor not currently open for the process.
<P>

デフォルトでは、新しいファイルディスクリプターは <B><A HREF="../man2/execve.2.html">execve</A></B>(2) を実行した後も
オープンされたままとなる (つまり、 <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) に説明がある <B>FD_CLOEXEC</B>
ファイルディスクリプターフラグは最初は無効である); 後述の <B>O_CLOEXEC</B> フラグ
を使うとこのデフォルトを変更することができる。 ファイルオフセット
(file offset) はファイルの先頭に設定される (<B><A HREF="../man2/lseek.2.html">lseek</A></B>(2) 参照)。
<P>

<B>open</B>()  を呼び出すと、「オープンファイル記述」 <I>(open file description)</I>
が作成される。ファイル記述とは、システム全体のオープン中のファイルのテーブルのエントリーである。
このオープンファイル記述は、ファイルオフセットとファイル状態フラグ (下記参照) が保持する。
ファイルディスクリプターはオープンファイルっ記述への参照である。 この後で <I>pathname</I>
が削除されたり、他のファイルを参照するように変更されたりしても、 この参照は影響を受けない。 オープンファイル記述の詳細な説明は「注意」の節を参照。
<P>

引数 <I>flags</I> には、アクセスモード <B>O_RDONLY</B>, <B>O_WRONLY</B>, <B>O_RDWR</B>
のどれかひとつが入っていなければならない。 これらはそれぞれ読み込み専用、書き込み専用、読み書き用に ファイルをオープンすることを要求するものである。
<P>













In addition, zero or more file creation flags and file status flags can be
bitwise-<I>or</I>'d in <I>flags</I>.  The <I>file creation flags</I> are <B>O_CLOEXEC</B>,
<B>O_CREAT</B>, <B>O_DIRECTORY</B>, <B>O_EXCL</B>, <B>O_NOCTTY</B>, <B>O_NOFOLLOW</B>,
<B>O_TMPFILE</B>, and <B>O_TRUNC</B>.  The <I>file status flags</I> are all of the
remaining flags listed below.  The distinction between these two groups of
flags is that the file creation flags affect the semantics of the open
operation itself, while the file status flags affect the semantics of
subsequent I/O operations.  The file status flags can be retrieved and (in
some cases)  modified; see <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  for details.
<P>

すべてのファイル作成フラグとファイル状態フラグを以下のリストに示す。
<DL COMPACT>
<DT><B>O_APPEND</B><DD>
The file is opened in append mode.  Before each <B><A HREF="../man2/write.2.html">write</A></B>(2), the file offset
is positioned at the end of the file, as if with <B><A HREF="../man2/lseek.2.html">lseek</A></B>(2).  The
modification of the file offset and the write operation are performed as a
single atomic step.
<DT><DD>



<B>O_APPEND</B> may lead to corrupted files on NFS filesystems if more than one
process appends data to a file at once.  This is because NFS does not
support appending to a file, so the client kernel has to simulate it, which
can't be done without a race condition.
<DT><B>O_ASYNC</B><DD>
シグナル駆動 I/O (signal-driven I/O) を有効にする: このファイルディスクリプターへの
入力または出力が可能になった場合に、シグナルを生成する (デフォルトは <B>SIGIO</B> であるが、 <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)
によって変更可能である)。 この機能が使用可能なのは端末、疑似端末、ソケットのみであり、 (Linux 2.6 以降では) パイプと FIFO
に対しても使用できる。 さらに詳しい説明は <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  を参照すること。 下記の「バグ」も参照。
<DT><B>O_CLOEXEC</B> (Linux 2.6.23 以降)<DD>





新しいファイルディスクリプターに対して close-on-exec フラグを有効にする。 このフラグを指定することで、 プログラムは
<B>FD_CLOEXEC</B> フラグをセットするために <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) <B>F_SETFD</B> 操作を別途呼び出す必要がなくなる。
<DT><DD>



ある種のマルチスレッドのプログラムはこのフラグの使用は不可欠である点に注意すること。 なぜなら、個別に <B>FD_CLOEXEC</B> フラグを設定する
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) <B>F_SETFD</B> 操作を呼び出したとしても、あるスレッドがファイルディスクリプターを オープンするのと同時に別のスレッドが
<B><A HREF="../man2/fork.2.html">fork</A></B>(2) と <B><A HREF="../man2/execve.2.html">execve</A></B>(2) を実行するという競合条件を避けるのには十分ではないからである。
実行の順序に依存して、この競合条件の結果、 <B>open</B>() が返したファイルディスクリプターが <B><A HREF="../man2/fork.2.html">fork</A></B>(2)
で作成された子プロセスにより実行されるプログラムに意図せず見えてしまう可能性がある。 (この種の競合は、 本質的に、 close-on-exec
フラグをセットすべきファイルディスクリプターを作成するどのシステムコールでも起こり得るものであり、 他のいろいろな Linux
システムコールでこの問題に対処するために <B>O_CLOEXEC</B> と同等の機能が提供されている。)
<DT><B>O_CREAT</B><DD>
If <I>pathname</I> does not exist, create it as a regular file.
<DT><DD>
The owner (user ID) of the new file is set to the effective user ID of the
process.
<DT><DD>


The group ownership (group ID) of the new file is set either to the
effective group ID of the process (System V semantics)  or to the group ID
of the parent directory (BSD semantics).  On Linux, the behavior depends on
whether the set-group-ID mode bit is set on the parent directory: if that
bit is set, then BSD semantics apply; otherwise, System V semantics apply.
For some filesystems, the behavior also depends on the <I>bsdgroups</I> and
<I>sysvgroups</I> mount options described in <B><A HREF="../../util-linux/man8/mount.8.html">mount</A></B>(8).
<DT><DD>
The <I>mode</I> argument specifies the file mode bits to be applied when a new
file is created.  If neither <B>O_CREAT</B> nor <B>O_TMPFILE</B> is specified in
<I>flags</I>, then <I>mode</I> is ignored (and can thus be specified as 0, or simply
omitted).  The <I>mode</I> argument <B>must</B> be supplied if <B>O_CREAT</B> or
<B>O_TMPFILE</B> is specified in <I>flags</I>; if it is not supplied, some arbitrary
bytes from the stack will be applied as the file mode.
<DT><DD>
The effective mode is modified by the process's <I>umask</I> in the usual way:
in the absence of a default ACL, the mode of the created file is <I>(mode&nbsp;&amp;&nbsp;~umask)</I>.
<DT><DD>
Note that <I>mode</I> applies only to future accesses of the newly created file;
the <B>open</B>()  call that creates a read-only file may well return a
read/write file descriptor.
<DT><DD>
<I>mode</I> のために以下のシンボル定数が提供されている :
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>S_IRWXU</B><DD>
00700 ユーザー (ファイルの所有者) に読み込み、書き込み、 実行の許可がある。
<DT><B>S_IRUSR</B><DD>
00400 ユーザーに読み込みの許可がある。
<DT><B>S_IWUSR</B><DD>
00200 ユーザーに書き込みの許可がある。
<DT><B>S_IXUSR</B><DD>
00100 ユーザーに実行の許可がある。
<DT><B>S_IRWXG</B><DD>
00070 グループに読み込み、書き込み、実行の許可がある。
<DT><B>S_IRGRP</B><DD>
00040 グループに読み込みの許可がある。
<DT><B>S_IWGRP</B><DD>
00020 グループに書き込みの許可がある。
<DT><B>S_IXGRP</B><DD>
00010 グループに実行の許可がある。
<DT><B>S_IRWXO</B><DD>
00007 他人 (others) に読み込み、書き込み、実行の許可がある。
<DT><B>S_IROTH</B><DD>
00004 他人に読み込みの許可がある。
<DT><B>S_IWOTH</B><DD>
00002 他人に書き込みの許可がある。
<DT><B>S_IXOTH</B><DD>
00001 他人に実行の許可がある。
</DL>
</DL>

<DT><DD>
According to POSIX, the effect when other bits are set in <I>mode</I> is
unspecified.  On Linux, the following bits are also honored in <I>mode</I>:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>S_ISUID</B><DD>
0004000 set-user-ID bit
<DT><B>S_ISGID</B><DD>
0002000 set-group-ID bit (see <B>inode</B>(7)).
<DT><B>S_ISVTX</B><DD>
0001000 sticky bit (see <B>inode</B>(7)).
</DL>
</DL>

<DT><B>O_DIRECT</B> (Linux 2.4.10 以降)<DD>
このファイルに対する I/O のキャッシュの効果を最小化しようとする。このフラグを使うと、一般的に性能が低下する。
しかしアプリケーションが独自にキャッシングを行っているような 特別な場合には役に立つ。 ファイルの I/O
はユーザー空間バッファーに対して直接行われる。 <B>O_DIRECT</B> フラグ自身はデータを同期で転送しようとはするが、 <B>O_SYNC</B>
フラグのようにデータと必要なメタデータの転送が保証されるわけではない。同期 I/O を保証するためには、 <B>O_DIRECT</B> に加えて
<B>O_SYNC</B> を使用しなければならない。下記の「注意」の節の議論も参照。
<DT><DD>
ブロックデバイスに対する似通った意味のインターフェースが <B><A HREF="../../util-linux/man8/raw.8.html">raw</A></B>(8)  で説明されている (但し、このインターフェースは非推奨である)。
<DT><B>O_DIRECTORY</B><DD>




<I>pathname</I> がディレクトリでなければオープンは失敗する。 このフラグは、 <B><A HREF="../man3/opendir.3.html">opendir</A></B>(3)  が FIFO
やテープデバイスに対してコールされた場合の サービス不能 (denial-of-service) 攻撃を避けるために カーネル 2.1.126
で追加された。
<DT><B>O_DSYNC</B><DD>
ファイルに対する書き込み操作は、同期 I/O の<I>データ</I>完全性完了の要件に基づいて行われる。
<DT><DD>
<B><A HREF="../man2/write.2.html">write</A></B>(2) (や同様のコール) が返るまでに、
書き込まれたデータおよびデータを取得するのに必要なファイルメタデータが裏で利用されているハードウェアに転送される (つまり、<B><A HREF="../man2/write.2.html">write</A></B>(2)
の後に <B><A HREF="../man2/fdatasync.2.html">fdatasync</A></B>(2) を呼び出したのと同じようになる)。 <I>下記の「注意」も参照のこと</I>。
<DT><B>O_EXCL</B><DD>
この呼び出しでファイルが作成されることを保証する。このフラグが <B>O_CREAT</B> と一緒に指定され、 <I>pathname</I>
のファイルが既に存在した場合、 <B>open</B>() は <B>EEXIST</B> エラーで失敗する。
<DT><DD>

これら二つのフラグが指定された際、シンボリックリンクは辿られない。 <I>pathname</I> がシンボリックリンクの場合、
シンボリックリンクがどこを指しているかに関わらず <B>open</B>()  は失敗する。
<DT><DD>
一般的には、 <B>O_CREAT</B> を指定せずに <B>O_EXCL</B> を使用した場合の
<B>O_EXCL</B> の動作は規定されていない。
これには一つ例外があり、Linux 2.6 以降では、
<I>pathname</I> がブロックデバイスを参照している場合、
<B>O_CREAT</B> なしで <B>O_EXCL</B> を使用することができる。
システムがそのブロックデバイスを使用中の場合 (例えば、
マウントされているなど)、 <B>open</B>() はエラー <B>EBUSY</B> で失敗する。
<DT><DD>
NFS では、 <B>O_EXCL</B> は、Linux 2.6 以降で NFSv3 以降を使っている場合でのみサポートされる。 <B>O_EXCL</B>
サポートが提供されていない NFS 環境では、このフラグに頼って ロック処理を実行するプログラムは競合状態 (race condition) に出会う
可能性がある。 ロックファイルを使用して不可分 (atomic) なファイルロックを実現し、 NFS が <B>O_EXCL</B>
をサポートしているかに依存しないようにしたい場合、 移植性のある方法は、同じファイルシステム上に他と名前の重ならない ファイル (例えばホスト名と
PID を組み合わせた名前) を作成し、 <B><A HREF="../man2/link.2.html">link</A></B>(2)  を使用してそのロックファイルへのリンクを作成することである。 <B><A HREF="../man2/link.2.html">link</A></B>(2)
コールの返り値が 0 ならばロックに成功している。 あるいは、そのファイルに <B><A HREF="../man2/stat.2.html">stat</A></B>(2)  を使用してリンク数 (link count) が
2 になっているかをチェックする。 そうなっていれば、同じくロックに成功しているということである。
<DT><B>O_LARGEFILE</B><DD>
(LFS) <I>off_t</I> ではサイズを表せない (だだし <I>off64_t</I> ではサイズを表せる)ファ
イルをオープン可能にする。この定義を有効にするためには、(<I>どの</I>ヘッダーファイ
ルをインクルードするよりも前に) <B>_LARGEFILE64_SOURCE</B> マクロを定義しなければ
ならない。
32 ビットシステムにおいて大きなファイルにアクセスしたい場合、
(<B>O_LARGEFILE</B> を使うよりも) <B>_FILE_OFFSET_BITS</B> 機能検査マクロを 64 に
セットする方が望ましい方法である (<B><A HREF="../man7/feature_test_macros.7.html">feature_test_macros</A></B>(7) を参照)。
<DT><B>O_NOATIME</B> (Linux 2.6.8 以降)<DD>
Do not update the file last access time (<I>st_atime</I> in the inode)  when the
file is <B><A HREF="../man2/read.2.html">read</A></B>(2).
<DT><DD>
This flag can be employed only if one of the following conditions is true:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>

The effective UID of the process matches the owner UID of the file.
<DT>*<DD>
The calling process has the <B>CAP_FOWNER</B> capability in its user namespace
and the owner UID of the file has a mapping in the namespace.
</DL>
</DL>

<DT><DD>


このフラグはインデックス作成やバックアッププログラムで使うことを意図している。 これを使うとディスクに対する操作を大幅に減らすことができる。
このフラグは全てのファイルシステムに対して有効であるわけではない。 その一例が NFS であり、サーバがアクセス時刻を管理している。
<DT><B>O_NOCTTY</B><DD>
<I>pathname</I> が端末 (terminal) デバイス --- <B><A HREF="../man4/tty.4.html">tty</A></B>(4) 参照 --- を指している
場合に、たとえそのプロセスが制御端末を持っていなくても、オープンしたファイル
は制御端末にはならない。
<DT><B>O_NOFOLLOW</B><DD>
If the trailing component (i.e., basename) of <I>pathname</I> is a symbolic
link, then the open fails, with the error <B>ELOOP</B>.  Symbolic links in
earlier components of the pathname will still be followed.  (Note that the
<B>ELOOP</B> error that can occur in this case is indistinguishable from the
case where an open fails because there are too many symbolic links found
while resolving components in the prefix part of the pathname.)
<DT><DD>
This flag is a FreeBSD extension, which was added to Linux in version
2.1.126, and has subsequently been standardized in POSIX.1-2008.
<DT><DD>



See also <B>O_PATH</B> below.
<DT><B>O_NONBLOCK</B> または <B>O_NDELAY</B><DD>
可能ならば、ファイルは非停止 (nonblocking) モードでオープンされる。 <B>open</B>()
も、返したファイルディスクリプターに対する以後のすべての操作も呼び出したプロセスを待たせることはない。
<DT><DD>
Note that the setting of this flag has no effect on the operation of
<B><A HREF="../man2/poll.2.html">poll</A></B>(2), <B><A HREF="../man2/select.2.html">select</A></B>(2), <B><A HREF="../man7/epoll.7.html">epoll</A></B>(7), and similar, since those interfaces
merely inform the caller about whether a file descriptor is &quot;ready&quot;, meaning
that an I/O operation performed on the file descriptor with the
<B>O_NONBLOCK</B> flag <I>clear</I> would not block.
<DT><DD>
Note that this flag has no effect for regular files and block devices; that
is, I/O operations will (briefly) block when device activity is required,
regardless of whether <B>O_NONBLOCK</B> is set.  Since <B>O_NONBLOCK</B> semantics
might eventually be implemented, applications should not depend upon
blocking behavior when specifying this flag for regular files and block
devices.
<DT><DD>
FIFO (名前付きパイプ) を扱う場合には <B><A HREF="../man7/fifo.7.html">fifo</A></B>(7) も参照すること。 強制ファイルロック (mandatory file lock)
やファイルリース (file lease) と組み合わせた場合の、 <B>O_NONBLOCK</B> の効果についての議論は、 <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)
を参照すること。
<DT><B>O_PATH</B> (Linux 2.6.39 以降)<DD>








このフラグを指定して取得したファイルディスクリプターは、 ファイルシステムツリー内での場所を示すため、
純粋にファイルディスクリプターレベルでの作用する操作を実行するため、 の二つの目的で使用することができる。 ファイル自身はオープンされず、
他のファイル操作 (例えば <B><A HREF="../man2/read.2.html">read</A></B>(2), <B><A HREF="../man2/write.2.html">write</A></B>(2), <B><A HREF="../man2/fchmod.2.html">fchmod</A></B>(2), <B><A HREF="../man2/fchown.2.html">fchown</A></B>(2),
<B><A HREF="../man2/fgetxattr.2.html">fgetxattr</A></B>(2), <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2), <B><A HREF="../man2/mmap.2.html">mmap</A></B>(2)) はエラー <B>EBADF</B> で失敗する。
<DT><DD>
取得したファイルディスクリプターに対して以下の操作を行うことが「できる」。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
<B><A HREF="../man2/close.2.html">close</A></B>(2).
<DT>*<DD>

<B><A HREF="../man2/fchdir.2.html">fchdir</A></B>(2), if the file descriptor refers to a directory (since Linux
3.5).
<DT>*<DD>
<B><A HREF="../man2/fstat.2.html">fstat</A></B>(2) (Linux 3.6 以降).
<DT>*<DD>


<B><A HREF="../man2/fstatfs.2.html">fstatfs</A></B>(2) (Linux 3.12 以降).
<DT>*<DD>
ファイルディスクリプターの複製 (<B><A HREF="../man2/dup.2.html">dup</A></B>(2), <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  <B>F_DUPFD</B> など)
<DT>*<DD>
ファイルディスクリプターフラグの取得と設定 (<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) の <B>F_GETFD</B> と <B>F_SETFD</B>)
<DT>*<DD>
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) の <B>F_GETFL</B> 操作を使ったオープンされたファイルの状態フラグの取得。 返されるフラグには <B>O_PATH</B>
ビットが含まれる。
<DT>*<DD>
<B>openat</B>() や他の &quot;*at()&quot; 系のシステムコールの <I>dirfd</I> 引数としてそのファイルディスクリプターを渡す。 これには、
ファイルがディレクトリでない場合に <B><A HREF="../man2/linkat.2.html">linkat</A></B>(2) に <B>AT_EMPTY_PATH</B> が指定された場合 (や procfs 経由で
<B>AT_SYMLINK_FOLLOW</B> が使用された場合) を含む。
<DT>*<DD>
そのファイルディスクリプターを別のプロセスに UNIX ドメインソケット経由で渡す。 (<B><A HREF="../man7/unix.7.html">unix</A></B>(7) の <B>SCM_RIGHTS</B> を参照)
</DL>
</DL>

<DT><DD>
<I>flags</I> に <B>O_PATH</B> が指定された場合、 <B>O_CLOEXEC</B>, <B>O_DIRECTORY</B>, <B>O_NOFOLLOW</B>
以外のフラグビットは無視される。
<DT><DD>
Opening a file or directory with the <B>O_PATH</B> flag requires no permissions
on the object itself (but does require execute permission on the directories
in the path prefix).  Depending on the subsequent operation, a check for
suitable file permissions may be performed (e.g., <B><A HREF="../man2/fchdir.2.html">fchdir</A></B>(2)  requires
execute permission on the directory referred to by its file descriptor
argument).  By contrast, obtaining a reference to a filesystem object by
opening it with the <B>O_RDONLY</B> flag requires that the caller have read
permission on the object, even when the subsequent operation (e.g.,
<B><A HREF="../man2/fchdir.2.html">fchdir</A></B>(2), <B><A HREF="../man2/fstat.2.html">fstat</A></B>(2))  does not require read permission on the object.
<DT><DD>
<I>pathname</I> がシンボリックリンクで <B>O_NOFOLLOW</B> フラグも合わせて指定された場合、
この呼び出しではシンボリックリンクを参照するファイルディスクリプターを返す。 このファイルディスクリプターは、 空のパス名を指定した
<B><A HREF="../man2/fchownat.2.html">fchownat</A></B>(2), <B><A HREF="../man2/fstatat.2.html">fstatat</A></B>(2), <B><A HREF="../man2/linkat.2.html">linkat</A></B>(2), <B><A HREF="../man2/readlinkat.2.html">readlinkat</A></B>(2) の呼び出しで
<I>dirfd</I> 引数として使うことで、 そのシンボリックリンクに対して操作を行うことができる。
<DT><DD>
If <I>pathname</I> refers to an automount point that has not yet been triggered,
so no other filesystem is mounted on it, then the call returns a file
descriptor referring to the automount directory without triggering a mount.
<B><A HREF="../man2/fstatfs.2.html">fstatfs</A></B>(2)  can then be used to determine if it is, in fact, an
untriggered automount point (<B>.f_type == AUTOFS_SUPER_MAGIC</B>).
<DT><DD>
One use of <B>O_PATH</B> for regular files is to provide the equivalent of
POSIX.1's <B>O_EXEC</B> functionality.  This permits us to open a file for which
we have execute permission but not read permission, and then execute that
file, with steps something like the following:
<DT><DD>


char buf[PATH_MAX];
fd = open(&quot;some_prog&quot;, O_PATH);
snprintf(buf, PATH_MAX, &quot;/proc/self/fd/%d&quot;, fd);
execl(buf, &quot;some_prog&quot;, (char *) NULL);


<DT><DD>
An <B>O_PATH</B> file descriptor can also be passed as the argument of
<B><A HREF="../man3/fexecve.3.html">fexecve</A></B>(3).
<DT><B>O_SYNC</B><DD>
ファイルに対する書き込み操作は、同期 I/O の<I>ファイル</I>完全性完了の要件に基づいて行われる (これに対し <B>O_DSYNC</B> では同期 I/O
の<I>データ</I>完全性完了が提供される)。
<DT><DD>
<B><A HREF="../man2/write.2.html">write</A></B>(2) (や同様のコール) が返るまでに、 書き込まれたデータと関連するファイルメタデータが裏で利用されているハードウェアに転送される
(つまり、<B><A HREF="../man2/write.2.html">write</A></B>(2) の後に <B><A HREF="../man2/fsync.2.html">fsync</A></B>(2) を呼び出したのと同じようになる)。 <I>下記の「注意」も参照のこと</I>。
<DT><B>O_TMPFILE</B> (Linux 3.11 以降)<DD>



名前なしの一時的な通常ファイルを作成する。 <I>pathname</I> 引数はディレクトリを指定する。 名前なしの inode
がそのディレクトリが存在するファイルシステムに作成される。 そのファイルに名前を付与しない限り、 作成されたファイルに書き込まれた内容は、
最後のファイルディスクリプターがクローズされる際に失われる。
<DT><DD>
<B>O_TMPFILE</B> は必ず <B>O_RDWR</B> か <B>O_WRONLY</B> のいずれかと一緒に使わなければならない。 <B>O_EXCL</B>
も指定することができる。 <B>O_EXCL</B> が指定されなかった場合、 <B><A HREF="../man2/linkat.2.html">linkat</A></B>(2)
を使って、そのファイルシステムにこの一時ファイルへのリンクを作成し、ファイルを永続化することができる。 以下のコードのようにすればよい。
<DT><DD>


char path[PATH_MAX];
fd = open(&quot;/path/to/dir&quot;, O_TMPFILE | O_RDWR,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_IRUSR&nbsp;|&nbsp;S_IWUSR);
<P>
/* 'fd' に対するファイル I/O ... */
<P>
linkat(fd, NULL, AT_FDCWD, &quot;/path/for/file&quot;, AT_EMPTY_PATH);
<P>
/* If the caller doesn't have the CAP_DAC_READ_SEARCH
<BR>&nbsp;&nbsp;&nbsp;capability&nbsp;(needed&nbsp;to&nbsp;use&nbsp;AT_EMPTY_PATH&nbsp;with&nbsp;<A HREF="../man2/linkat.2.html">linkat</A>(2)),
<BR>&nbsp;&nbsp;&nbsp;and&nbsp;there&nbsp;is&nbsp;a&nbsp;<A HREF="../man5/proc.5.html">proc</A>(5)&nbsp;filesystem&nbsp;mounted,&nbsp;then&nbsp;the
<BR>&nbsp;&nbsp;&nbsp;<A HREF="../man2/linkat.2.html">linkat</A>(2)&nbsp;call&nbsp;above&nbsp;can&nbsp;be&nbsp;replaced&nbsp;with:
<P>
snprintf(path, PATH_MAX,  &quot;/proc/self/fd/%d&quot;, fd);
linkat(AT_FDCWD, path, AT_FDCWD, &quot;/path/for/file&quot;,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AT_SYMLINK_FOLLOW);
*/


<DT><DD>
この場合、 <B>open</B>() の <I>mode</I> 引数は <B>O_CREAT</B> と同様にファイルのアクセス許可モードの決定に使われる。
<DT><DD>
<B>O_TMPFILE</B> とともに <B>O_EXCL</B> を指定すると、
一時ファイルに対して上記の方法でファイルシステムへのリンクを行うことができなくなる (この場合の <B>O_EXCL</B> の意味は他の場合の
<B>O_EXCL</B> の意味とは異なる点に注意)。
<DT><DD>

<B>O_TMPFILE</B> には主に二つの用途がある。
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>*<DD>
改善された <B><A HREF="../man3/tmpfile.3.html">tmpfile</A></B>(3) の機能: (1) クローズ時に自動的に削除される、 (2) パス名では決して参照できない、 (3)
シンボリックリンク攻撃ができない、 (4) 呼び出し元が一意な名前を考える必要がない、 という特長を持つ競合のない一時ファイルの作成。
<DT>*<DD>
最初は見えないファイルを作成し、 それからデータを書き込んだり、適切なファイルシステム属性を持つように調整したり (<B><A HREF="../man2/fchown.2.html">fchown</A></B>(2),
<B><A HREF="../man2/fchmod.2.html">fchmod</A></B>(2), <B><A HREF="../man2/fsetxattr.2.html">fsetxattr</A></B>(2) など) した後、 準備が全て整った状態で (上述の <B><A HREF="../man2/linkat.2.html">linkat</A></B>(2) を使って)
ファイルシステム内にアトミックにリンクを行う。
</DL>
</DL>

<DT><DD>





<B>O_TMPFILE</B> requires support by the underlying filesystem; only a subset of
Linux filesystems provide that support.  In the initial implementation,
support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem
filesystems.  Support for other filesystems has subsequently been added as
follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs
(Linux 4.9)
<DT><B>O_TRUNC</B><DD>
ファイルが既に存在し、通常ファイルであり、 アクセスモードで書き込みが許可されている (つまり、 <B>O_RDWR</B> または <B>O_WRONLY</B>
の) 場合、長さ 0 に切り詰め (truncate) られる。 ファイルが FIFO または端末デバイスファイルの場合、 <B>O_TRUNC</B>
フラグは無視される。 それ以外の場合、 <B>O_TRUNC</B> の効果は未定義である。
</DL>
<A NAME="lbAE">&nbsp;</A>
<H3>creat()</H3>

<B>creat</B>() の呼び出しは、 <I>flags</I> に <B>O_CREAT|O_WRONLY|O_TRUNC</B> を指定して <B>open</B>()
を呼び出すのと等価である。
<A NAME="lbAF">&nbsp;</A>
<H3>openat()</H3>

<B>openat</B>() システムコールは <B>open</B>() と全く同様に動作するが、以下で説明する点が異なる。
<P>

<I>pathname</I> で指定されたパス名が相対パスの場合、このパス名はファイルディスクリプター <I>dirfd</I>
が参照するディレクトリに対する相対パスと解釈される (<B>open</B>()
に相対パス名を渡した場合のように、呼び出したプロセスのカレントワーキングディレクトリに対する相対パスではない)。
<P>

<I>pathname</I> で指定されたパス名が相対パスで、 <I>dirfd</I> が特別な値 <B>AT_FDCWD</B> の場合、 (<B>open</B>()
と同様に) <I>pathname</I> は呼び出したプロセスのカレントワーキングディレクトリに対する相対パスと解釈される。
<P>


<I>pathname</I> で指定されたパス名が絶対パスの場合、 <I>dirfd</I> は無視される。
<A NAME="lbAG">&nbsp;</A>
<H3>openat2(2)</H3>

The <B>openat2</B>(2)  system call is an extension of <B>openat</B>(), and provides
a superset of the features of <B>openat</B>().  It is documented separately, in
<B>openat2</B>(2).
<A NAME="lbAH">&nbsp;</A>
<H2>返り値</H2>

<B>open</B>(), <B>openat</B>(), and <B>creat</B>()  return the new file descriptor (a
nonnegative integer), or -1 if an error occurred (in which case, <I>errno</I> is
set appropriately).
<A NAME="lbAI">&nbsp;</A>
<H2>エラー</H2>

<B>open</B>(), <B>openat</B>(), <B>creat</B>() は以下のエラーで失敗する。
<DL COMPACT>
<DT><B>EACCES</B><DD>
ファイルに対する要求されたアクセスが許されていないか、 <I>pathname</I> のディレクトリ部分の何れかのディレクトリに検索許可がなかった。
またはファイルが存在せず、親ディレクトリへの書き込み許可がなかった。 (<B><A HREF="../man7/path_resolution.7.html">path_resolution</A></B>(7)  も参照すること。)
<DT><B>EACCES</B><DD>

Where <B>O_CREAT</B> is specified, the <I>protected_fifos</I> or
<I>protected_regular</I> sysctl is enabled, the file already exists and is a
FIFO or regular file, the owner of the file is neither the current user nor
the owner of the containing directory, and the containing directory is both
world- or group-writable and sticky.  For details, see the descriptions of
<I>/proc/sys/fs/protected_fifos</I> and <I>/proc/sys/fs/protected_regular</I> in
<B><A HREF="../man5/proc.5.html">proc</A></B>(5).
<DT><B>EBUSY</B><DD>
<B>O_EXCL</B> was specified in <I>flags</I> and <I>pathname</I> refers to a block device
that is in use by the system (e.g., it is mounted).
<DT><B>EDQUOT</B><DD>
<B>O_CREAT</B> が指定された場合で、そのファイルが存在せず、ディスクブロックか inode がそのファイルシステムのユーザークォータに達していた。
<DT><B>EEXIST</B><DD>
<I>pathname</I> は既に存在し、 <B>O_CREAT</B> と <B>O_EXCL</B> が使用された。
<DT><B>EFAULT</B><DD>
<I>pathname</I> がアクセス可能なアドレス空間の外を指している。
<DT><B>EFBIG</B><DD>
<B>EOVERFLOW</B> 参照。
<DT><B>EINTR</B><DD>
遅いデバイス (例えば FIFO、 <B><A HREF="../man7/fifo.7.html">fifo</A></B>(7)  参照) のオープンが完了するのを待って停止している間に
システムコールがシグナルハンドラーにより割り込まれた。 <B><A HREF="../man7/signal.7.html">signal</A></B>(7)  参照。
<DT><B>EINVAL</B><DD>
ファイルシステムが <B>O_DIRECT</B> フラグをサポートしていない。 詳細は<B>注意</B>を参照。
<DT><B>EINVAL</B><DD>

<I>flags</I> に無効な値が入っている。
<DT><B>EINVAL</B><DD>
<I>flags</I> に <B>O_TMPFILE</B> が指定されたが、 <B>O_WRONLY</B> も <B>O_RDWR</B> も指定されていなかった。
<DT><B>EINVAL</B><DD>
<B>O_CREAT</B> was specified in <I>flags</I> and the final component (&quot;basename&quot;) of
the new file's <I>pathname</I> is invalid (e.g., it contains characters not
permitted by the underlying filesystem).
<DT><B>EINVAL</B><DD>
The final component (&quot;basename&quot;) of <I>pathname</I> is invalid (e.g., it
contains characters not permitted by the underlying filesystem).
<DT><B>EISDIR</B><DD>
<I>pathname</I> はディレクトリを参照しており、書き込み要求が含まれていた (つまり <B>O_WRONLY</B> または <B>O_RDWR</B>
が設定されている)。
<DT><B>EISDIR</B><DD>
<I>pathname</I> が存在するディレクトリを参照していて、 <B>O_TMPFILE</B> および <B>O_WRONLY</B> と <B>O_RDWR</B>
の一方が <I>flags</I> に指定されていたが、 このカーネルバージョンでは <B>O_TMPFILE</B> 機能が提供されていない。
<DT><B>ELOOP</B><DD>
<I>pathname</I> を解決する際に遭遇したシンボリックリンクが多過ぎる。
<DT><B>ELOOP</B><DD>
<I>pathname</I> がシンボリックリンクで、 <I>flags</I> に <B>O_NOFOLLOW</B> が指定されたが、 <B>O_PATH</B>
が指定されていなかった。
<DT><B>EMFILE</B><DD>
The per-process limit on the number of open file descriptors has been
reached (see the description of <B>RLIMIT_NOFILE</B> in <B><A HREF="../man2/getrlimit.2.html">getrlimit</A></B>(2)).
<DT><B>ENAMETOOLONG</B><DD>
<I>pathname</I> が長過ぎる。
<DT><B>ENFILE</B><DD>
オープンされているファイルの総数がシステム全体の制限に達している。
<DT><B>ENODEV</B><DD>
<I>pathname</I> がデバイススペシャルファイルを参照しており、対応するデバイスが存在しない。 (これは Linux
カーネルのバグであり、この場合には <B>ENXIO</B> が返されるべきである)
<DT><B>ENOENT</B><DD>
<B>O_CREAT</B> is not set and the named file does not exist.
<DT><B>ENOENT</B><DD>
<I>pathname</I> の中のディレクトリ部分が存在しないか、壊れた (dangling)  シンボリックリンク (symbolic link)
である。
<DT><B>ENOENT</B><DD>
<I>pathname</I> が存在しないディレクトリを参照していて、 <B>O_TMPFILE</B> および <B>O_WRONLY</B> と <B>O_RDWR</B>
の一方が <I>flags</I> に指定されていたが、 このカーネルバージョンでは <B>O_TMPFILE</B> 機能が提供されていない。
<DT><B>ENOMEM</B><DD>
The named file is a FIFO, but memory for the FIFO buffer can't be allocated
because the per-user hard limit on memory allocation for pipes has been
reached and the caller is not privileged; see <B><A HREF="../man7/pipe.7.html">pipe</A></B>(7).
<DT><B>ENOMEM</B><DD>
十分なカーネルメモリーがない。
<DT><B>ENOSPC</B><DD>
<I>pathname</I> を作成する必要があるが、 <I>pathname</I> を含んでいるデバイスに新しいファイルのための空き容量がない。
<DT><B>ENOTDIR</B><DD>
<I>pathname</I> に含まれるディレクトリ部分のどれかが実際にはディレクトリでない。 または <B>O_DIRECTORY</B> が指定されており、
<I>pathname</I> がディレクトリでない。
<DT><B>ENXIO</B><DD>
<B>O_NONBLOCK</B> | <B>O_WRONLY</B> が設定されており、指定したファイルが FIFO で そのファイルを読み込み用でオープンしている
FIFO が存在しない。
<DT><B>ENXIO</B><DD>
ファイルがデバイススペシャルファイルで、対応するデバイスが存在しない。
<DT><B>ENXIO</B><DD>
The file is a UNIX domain socket.
<DT><B>EOPNOTSUPP</B><DD>
<I>pathname</I> を含んでいるファイルシステムが <B>O_TMPFILE</B> をサポートしていない。
<DT><B>EOVERFLOW</B><DD>



<I>pathname</I> が参照しているのが、大き過ぎてオープンできない通常のファイルである。 通常、このエラーが発生するは、32
ビットプラットフォーム上で <I>-D_FILE_OFFSET_BITS=64</I> を指定せずにコンパイルされたアプリケーションが、ファイルサイズが
<I>(1&lt;31)-1</I> バイトを超えるファイルを開こうとした場合である。 上記の <B>O_LARGEFILE</B> も参照。 これは POSIX.1
で規定されているエラーである。 2.6.24 より前のカーネルでは、Linux はこの場合にエラー <B>EFBIG</B> を返していた。
<DT><B>EPERM</B><DD>

<B>O_NOATIME</B> フラグが指定されたが、呼び出し元の実効ユーザー ID が ファイルの所有者と一致せず、かつ呼び出し元に特権がない。
<DT><B>EPERM</B><DD>
操作が file seal により禁止されている。 <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  参照。
<DT><B>EROFS</B><DD>
<I>pathname</I> が読み込み専用のファイルシステム上のファイルを参照しており、 書き込みアクセスが要求された。
<DT><B>ETXTBSY</B><DD>
<I>pathname</I> が現在実行中の実行イメージを参照しており、書き込みが要求された。
<DT><B>ETXTBSY</B><DD>
<I>pathname</I> refers to a file that is currently in use as a swap file, and
the <B>O_TRUNC</B> flag was specified.
<DT><B>ETXTBSY</B><DD>
<I>pathname</I> refers to a file that is currently being read by the kernel
(e.g., for module/firmware loading), and write access was requested.
<DT><B>EWOULDBLOCK</B><DD>
<B>O_NONBLOCK</B> フラグが指定されたが、そのファイルには矛盾するリースが設定されていた (<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  参照)。
</DL>
<P>

<B>openat</B>() では以下のエラーも発生する。
<DL COMPACT>
<DT><B>EBADF</B><DD>
<I>dirfd</I> が有効なファイルディスクリプターではない。
<DT><B>ENOTDIR</B><DD>
<I>pathname</I> が相対パス名で、 <I>dirfd</I> がディレクトリ以外のファイルを参照しているファイルディスクリプターである。
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>バージョン</H2>

<B>openat</B>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサポートはバージョン 2.4 で glibc
に追加された。
<A NAME="lbAK">&nbsp;</A>
<H2>準拠</H2>

<B>open</B>(), <B>creat</B>()  SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.
<P>

<B>openat</B>(): POSIX.1-2008.
<P>

<B>openat2</B>()  は Linux 固有である。
<P>

フラグ <B>O_DIRECT</B>, <B>O_NOATIME</B>, <B>O_PATH</B>, <B>O_TMPFILE</B> は Linux 特有のものである。
これらのフラグの定義を得るためには <B>_GNU_SOURCE</B> を定義しなければならない。
<P>

フラグ <B>O_CLOEXEC</B>, <B>O_DIRECTORY</B>, <B>O_NOFOLLOW</B> は POSIX.1-2001 では規定されていないが、
POSIX.1-2008 では規定されている。 glibc 2.12 以降では、これらの定義を得るには、 <B>_POSIX_C_SOURCE</B> を
200809L 以上の値で定義するか、 <B>_XOPEN_SOURCE</B> を 700 以上の値で定義する。 glibc 2.11 以前では、
これらの定義を得るには <B>_GNU_SOURCE</B> を定義する。
<P>

<B><A HREF="../man7/feature_test_macros.7.html">feature_test_macros</A></B>(7) に注意書きがあるように、 <B>_POSIX_C_SOURCE</B>, <B>_XOPEN_SOURCE</B>,
<B>_GNU_SOURCE</B> などの機能検査マクロは<I>どの</I>ヘッダーファイルをインクルードするより前に定義しなければならない。
<A NAME="lbAL">&nbsp;</A>
<H2>注意</H2>

Under Linux, the <B>O_NONBLOCK</B> flag is sometimes used in cases where one
wants to open but does not necessarily have the intention to read or write.
For example, this may be used to open a device in order to get a file
descriptor for use with <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2).
<P>







<B>O_RDONLY | O_TRUNC</B> の影響は未定義であり、その動作は実装によって異なる。 多くのシステムではファイルは実際に切り詰められる。
<P>

<B>open</B>()  はスペシャルファイルをオープンすることができるが、 <B>creat</B>()  でスペシャルファイルを作成できない点に注意すること。
代わりに <B><A HREF="../man2/mknod.2.html">mknod</A></B>(2)  を使用する。
<P>

ファイルが新しく作成されると、 ファイルの <I>st_atime</I>, <I>st_ctime</I>, <I>st_mtime</I> フィールド
(それぞれ最終アクセス時刻、最終状態変更時刻、最終修正時刻である。 <B><A HREF="../man2/stat.2.html">stat</A></B>(2)  参照) が現在時刻に設定される。 さらに親ディレクトリの
<I>st_ctime</I> と <I>st_mtime</I> も現在時刻に設定される。 それ以外の場合で、O_TRUNC フラグでファイルが修正されたときは、
ファイルの <I>st_ctime</I> と <I>st_mtime</I> フィールドが現在時刻に設定される。
<P>

The files in the <I>/proc/[pid]/fd</I> directory show the open file descriptors
of the process with the PID <I>pid</I>.  The files in the <I>/proc/[pid]/fdinfo</I>
directory show even more information about these file descriptors.  See
<B><A HREF="../man5/proc.5.html">proc</A></B>(5)  for further details of both of these directories.
<P>



The Linux header file <B>&lt;<A HREF="file:///usr/include/asm/fcntl.h">asm/fcntl.h</A>&gt;</B> doesn't define <B>O_ASYNC</B>;
the (BSD-derived)  <B>FASYNC</B> synonym is defined instead.
<A NAME="lbAM">&nbsp;</A>
<H3>オープンファイル記述</H3>

オープンファイル記述という用語は POSIX
で使用されている用語で、オープンされているファイルのシステム共通のテーブルのエントリーを参照するものである。
別の文脈では、このオブジェクトはいろいろな呼び方があり、
「オープンファイルオブジェクト」、「ファイルハンドル」、「オープンファイルテーブルエントリー」、 カーネル開発者の用語では <I>struct file</I>
などと呼ばれる。
<P>

ファイルディスクリプターが (<B><A HREF="../man2/dup.2.html">dup</A></B>(2) や同様のシステムコールを使って) 複製される際に、
複製されたファイルディスクリプターは元のファイルディスクリプターと同じオープンファイル記述を参照する。 結果として 2
つのファイルディスクリプターはファイルオフセットとファイル状態フラグを共有する。 このような共有はプロセス間でも起こり得る。 <B><A HREF="../man2/fork.2.html">fork</A></B>(2)
で作成された子プロセスは親プロセスのファイルディスクリプターの複製を継承し、これらの複製は同じオープンファイル記述を参照する。
<P>

1 つのファイルに対して <B>open</B>() を行う毎に、新しいオープンファイル記述が作成される。 したがって、 1 つのファイル inode
に対して複数のオープンファイル記述が存在することがありえる。
<P>



On Linux, one can use the <B><A HREF="../man2/kcmp.2.html">kcmp</A></B>(2)  <B>KCMP_FILE</B> operation to test whether
two file descriptors (in the same process or in two different processes)
refer to the same open file description.
<A NAME="lbAN">&nbsp;</A>
<H3>同期 I/O</H3>

POSIX.1-2008 の「同期 I/O」の選択肢として複数種類が規定されており、 動作を制御するために <B>open</B>() フラグとして
<B>O_SYNC</B>, <B>O_DSYNC</B>, <B>O_RSYNC</B> が規定されている。 この選択肢を実装がサポートしているかに関わらず、
各実装では少なくとも通常のファイルに対して <B>O_SYNC</B> が利用できなければならない。
<P>

Linux implements <B>O_SYNC</B> and <B>O_DSYNC</B>, but not <B>O_RSYNC</B>.  Somewhat
incorrectly, glibc defines <B>O_RSYNC</B> to have the same value as <B>O_SYNC</B>.
(<B>O_RSYNC</B> is defined in the Linux header file <I>&lt;<A HREF="file:///usr/include/asm/fcntl.h">asm/fcntl.h</A>&gt;</I> on
HP PA-RISC, but it is not used.)
<P>

<B>O_SYNC</B> は、 同期 I/O での<I>ファイル</I>完全性完了を提供する。 つまり、
書き込み操作はデータとすべての関連メタデータを裏で利用されているハードウェアにフラッシュすることを意味する。 <B>O_DSYNC</B> は、 同期 I/O
での<I>データ</I>完全性完了を提供する。 つまり、 書き込み操作はデータを裏で利用されているハードウェアにフラッシュするが、
それ以降の読み出し操作が正常に完了するのに必要なメタデータの更新のみをフラッシュする。 データ完全性完了は、
ファイル完全性完了を必要としないアプリケーションで、 ディスク操作の数を減らすことができる。
<P>

2 種類の完了の違いを理解するために、 ファイルメタデータの 2 つの要素、 ファイルの最終修正時刻 (<I>st_mtime</I>)
とファイル長、を考える。 すべての書き込み操作は最終修正時刻を更新するが、 ファイルの末尾にデータを追加する書き込み操作のみがファイル長を変更する。
最終修正時刻は、 読み出しが正常に完了するのに必要ではないが、 ファイル長は必要である。 したがって、 <B>O_DSYNC</B>
はファイル長のメタデータの更新がフラッシュされることだけを保証する (これに対して <B>O_SYNC</B>
では最終修正時刻のメタデータも常にフラッシュされる)。
<P>

Linux 2.6.33 より前では、 Linux は <B>open</B>() では <B>O_SYNC</B> フラグのみを実装していた。 しかしながら、
このフラグが指定された場合、 ほとんどのファイルシステムで提供されていたのは実際には同期 I/O での<I>データ</I>完全性完了と等価なものであった
(つまり、 <B>O_SYNC</B> は実際には <B>O_DSYNC</B> と等価なものとして実装されていた)。
<P>


Linux 2.6.33 以降では、 正しい <B>O_SYNC</B> のサポートが提供されている。しかしながら、バイナリレベルの後方互換性を保証するため、
<B>O_DSYNC</B> は以前の <B>O_SYNC</B> と同じ値で定義されており、 <B>O_SYNC</B> は <B>O_DSYNC</B> フラグの値を含む新しい
(2 ビットの) フラグ値として定義されている。これにより、新しいヘッダーを使ってコンパイルされたアプリケーションで、 2.6.33
より前のカーネルで少なくとも <B>O_DSYNC</B> の動作は同じになることが保証される。
<A NAME="lbAO">&nbsp;</A>
<H3>C ライブラリとカーネルの違い</H3>


Since version 2.26, the glibc wrapper function for <B>open</B>()  employs the
<B>openat</B>()  system call, rather than the kernel's <B>open</B>()  system call.
For certain architectures, this is also true in glibc versions before 2.26.
<A NAME="lbAP">&nbsp;</A>
<H3>NFS</H3>

NFS を実現しているプロトコルには多くの不備があり、特に <B>O_SYNC</B> と <B>O_NDELAY</B> に影響する。
<P>



UID マッピングを使用している NFS ファイルシステムでは、 <B>open</B>()  がファイルディスクリプターを返した場合でも <B><A HREF="../man2/read.2.html">read</A></B>(2)
が <B>EACCES</B> で拒否される場合がある。 これはクライアントがアクセス許可のチェックを行って <B>open</B>()
を実行するが、読み込みや書き込みの際には サーバーで UID マッピングが行われるためである。
<A NAME="lbAQ">&nbsp;</A>
<H3>FIFOs</H3>



Opening the read or write end of a FIFO blocks until the other end is also
opened (by another process or thread).  See <B><A HREF="../man7/fifo.7.html">fifo</A></B>(7)  for further details.
<A NAME="lbAR">&nbsp;</A>
<H3>ファイルアクセスモード</H3>

「アクセスモード」の値 <B>O_RDONLY</B>, <B>O_WRONLY</B>, <B>O_RDWR</B> は、 <I>flags</I>
に指定できる他の値と違い、個々のビットを指定するものではなく、 これらの値は <I>flags</I> の下位 2 ビットを定義する。 <B>O_RDONLY</B>,
<B>O_WRONLY</B>, <B>O_RDWR</B> はそれぞれ 0, 1, 2 に定義されている。 言い換えると、 <B>O_RDONLY |
O_WRONLY</B> の組み合わせは論理的に間違いであり、確かに <B>O_RDWR</B> と同じ意味ではない。
<P>








Linux では、特別な、非標準なアクセスモードとして 3 (バイナリでは 11) が 予約されており <I>flags</I> に指定できる。
このアクセスモードを指定すると、ファイルの読み出し/書き込み許可をチェックし、 読み出しにも書き込みにも使用できないファイルディスクリプターを返す。
この非標準のアクセスモードはいくつかの Linux ドライバで、デバイス固有の <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)
操作にのみ使用されるファイルディスクリプターを返すために使われている。
<A NAME="lbAS">&nbsp;</A>
<H3>openat() や他のディレクトリファイルディスクリプター API の基本原理</H3>

<B>openat</B>()  and the other system calls and library functions that take a
directory file descriptor argument (i.e., <B><A HREF="../man2/execveat.2.html">execveat</A></B>(2), <B><A HREF="../man2/faccessat.2.html">faccessat</A></B>(2),
<B><A HREF="../man2/fanotify_mark.2.html">fanotify_mark</A></B>(2), <B><A HREF="../man2/fchmodat.2.html">fchmodat</A></B>(2), <B><A HREF="../man2/fchownat.2.html">fchownat</A></B>(2), <B>fspick</B>(2),
<B><A HREF="../man2/fstatat.2.html">fstatat</A></B>(2), <B><A HREF="../man2/futimesat.2.html">futimesat</A></B>(2), <B><A HREF="../man2/linkat.2.html">linkat</A></B>(2), <B><A HREF="../man2/mkdirat.2.html">mkdirat</A></B>(2),
<B>move_mount</B>(2), <B><A HREF="../man2/mknodat.2.html">mknodat</A></B>(2), <B><A HREF="../man2/name_to_handle_at.2.html">name_to_handle_at</A></B>(2), <B>open_tree</B>(2),
<B>openat2</B>(2), <B><A HREF="../man2/readlinkat.2.html">readlinkat</A></B>(2), <B><A HREF="../man2/renameat.2.html">renameat</A></B>(2), <B>statx</B>(2),
<B><A HREF="../man2/symlinkat.2.html">symlinkat</A></B>(2), <B><A HREF="../man2/unlinkat.2.html">unlinkat</A></B>(2), <B><A HREF="../man2/utimensat.2.html">utimensat</A></B>(2), <B><A HREF="../man3/mkfifoat.3.html">mkfifoat</A></B>(3), and
<B><A HREF="../man3/scandirat.3.html">scandirat</A></B>(3))  address two problems with the older interfaces that
preceded them.  Here, the explanation is in terms of the <B>openat</B>()  call,
but the rationale is analogous for the other interfaces.
<P>

First, <B>openat</B>()  allows an application to avoid race conditions that
could occur when using <B>open</B>()  to open files in directories other than
the current working directory.  These race conditions result from the fact
that some component of the directory prefix given to <B>open</B>()  could be
changed in parallel with the call to <B>open</B>().  Suppose, for example, that
we wish to create the file <I>dir1/dir2/xxx.dep</I> if the file <I>dir1/dir2/xxx</I>
exists.  The problem is that between the existence check and the
file-creation step, <I>dir1</I> or <I>dir2</I> (which might be symbolic links)
could be modified to point to a different location.  Such races can be
avoided by opening a file descriptor for the target directory, and then
specifying that file descriptor as the <I>dirfd</I> argument of (say)
<B><A HREF="../man2/fstatat.2.html">fstatat</A></B>(2)  and <B>openat</B>().  The use of the <I>dirfd</I> file descriptor
also has other benefits:
<DL COMPACT>
<DT>*<DD>
the file descriptor is a stable reference to the directory, even if the
directory is renamed; and
<DT>*<DD>
the open file descriptor prevents the underlying filesystem from being
dismounted, just as when a process has a current working directory on a
filesystem.
</DL>
<P>

二つ目として、 <B>openat</B>() を使うと、アプリケーションが管理するファイルディスクリプターにより、
スレッド単位の「カレントワーキングディレクトリ」を実装することができる (この機能は、 <I>/proc/self/fd/dirfd</I>
を使った方法でも実現することができるが、 効率の面で落とる)。
<P>

The <I>dirfd</I> argument for these APIs can be obtained by using <B>open</B>()  or
<B>openat</B>()  to open a directory (with either the <B>O_RDONLY</B> or the
<B>O_PATH</B> flag).  Alternatively, such a file descriptor can be obtained by
applying <B><A HREF="../man3/dirfd.3.html">dirfd</A></B>(3)  to a directory stream created using <B><A HREF="../man3/opendir.3.html">opendir</A></B>(3).
<P>



When these APIs are given a <I>dirfd</I> argument of <B>AT_FDCWD</B> or the
specified pathname is absolute, then they handle their pathname argument in
the same way as the corresponding conventional APIs.  However, in this case,
several of the APIs have a <I>flags</I> argument that provides access to
functionality that is not available with the corresponding conventional
APIs.
<A NAME="lbAT">&nbsp;</A>
<H3>O_DIRECT</H3>

<B>O_DIRECT</B> フラグを使用する場合、ユーザー空間バッファーの長さやアドレス、 I/O
のファイルオフセットに関してアラインメントの制限が課されることがある。 Linux では、アラインメントの制限はファイルシステムやカーネルのバージョンに
よって異なり、全く制限が存在しない場合もある。 しかしながら、現在のところ、指定されたファイルやファイルシステムに対して
こうした制限があるかを見つけるための、アプリケーション向けのインターフェースで ファイルシステム非依存のものは存在しない。
いくつかのファイルシステムでは、制限を確認するための独自のインターフェースが 提供されている。例えば、 <B>xfsctl</B>(3)  の
<B>XFS_IOC_DIOINFO</B> 命令である。
<P>

Linux 2.4 では、転送サイズ、 ユーザーバッファーのアライメント、ファイルオフセットは、
ファイルシステムの論理ブロックサイズの倍数でなければならない。 Linux 2.6.0 以降では、
内部で使われるストレージの論理ブロックサイズのアライメント (通常は 512 バイト) で十分である。 論理ブロックサイズは <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)
<B>BLKSSZGET</B> 操作や以下のシェルコマンドから知ることができる。
<P>



blockdev --getss


<P>

メモリーバッファーがプライベートマッピング (<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2) の <B>MAP_PRIVATE</B>
フラグで作成されたマッピング) の場合には、<B>O_DIRECT</B> I/O は
<B><A HREF="../man2/fork.2.html">fork</A></B>(2) システムコールと同時に決して実行すべきではない
(プライベートマッピングには、ヒープ領域に割り当てられたメモリーや静的に
割り当てたバッファーも含まれる)。非同期 I/O インターフェース (AIO) 経由
やプロセス内の他のスレッドから発行された、このような I/O は、
<B><A HREF="../man2/fork.2.html">fork</A></B>(2) が呼び出される前に完了されるべきである。
そうしなかった場合、データ破壊や、親プロセスや子プロセスでの予期しない
動作が起こる可能性がある。
<B>O_DIRECT</B> I/O 用のメモリーバッファーが <B><A HREF="../man2/shmat.2.html">shmat</A></B>(2) や<B>MAP_SHARED</B> フラグ
付きの <B><A HREF="../man2/mmap.2.html">mmap</A></B>(2) で作成された場合には、この制限はあてはまらない。
<B><A HREF="../man2/madvise.2.html">madvise</A></B>(2) でメモリーバッファーにアドバイス <B>MADV_DONTFORK</B> が設定され
ている場合にも、この制限はあてはまらない(<B>MADV_DONTFORK</B> はそのメモリー
バッファーが <B><A HREF="../man2/fork.2.html">fork</A></B>(2) 後に子プロセスからは利用できないことを保証するも
のである)。
<P>

<B>O_DIRECT</B> フラグは SGI IRIX で導入された。SGI IRIX にも Linux 2.4 と同様の (ユーザーバッファーの)
アラインメントの制限がある。 また、IRIX には適切な配置とサイズを取得するための <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  コールがある。 FreeBSD 4.x
も同じ名前のフラグを導入したが、アラインメントの制限はない。
<P>

<B>O_DIRECT</B> support was added under Linux in kernel version 2.4.10.  Older
Linux kernels simply ignore this flag.  Some filesystems may not implement
the flag, in which case <B>open</B>()  fails with the error <B>EINVAL</B> if it is
used.
<P>

アプリケーションは、同じファイル、 特に同じファイルの重複するバイト領域に対して、 <B>O_DIRECT</B> と通常の I/O
を混ぜて使うのは避けるべきである。 ファイルシステムがこのような状況において一貫性の問題を正しく 扱うことができる場合であっても、全体の I/O
スループットは どちらか一方を使用するときと比べて低速になるであろう。 同様に、アプリケーションは、同じファイルに対して <B><A HREF="../man2/mmap.2.html">mmap</A></B>(2)  と直接
I/O (<B>O_DIRECT</B>)  を混ぜて使うのも避けるべきである。
<P>

NFS で <B>O_DIRECT</B> を使った場合の動作はローカルのファイルシステムの場合と違う。
古いカーネルや、ある種の設定でコンパイルされたカーネルは、 <B>O_DIRECT</B> と NFS の組み合わせをサポートしていないかもしれない。 NFS
プロトコル自体はサーバにフラグを渡す機能は持っていないので、 <B>O_DIRECT</B> I/O
はクライアント上のページキャッシュをバイパスするだけになり、 サーバは I/O をキャッシュしているかもしれない。 クライアントは、
<B>O_DIRECT</B> の同期機構を保持するため、サーバに対して I/O を同期して行うように依頼する。 サーバによっては、こうした状況下、特に I/O
サイズが小さい場合に 性能が大きく劣化する。 また、サーバによっては、I/O が安定したストレージにまで行われたと、
クライアントに対して嘘をつくものもある。 これは、サーバの電源故障が起こった際にデータの完全性が保たれない
危険は少しあるが、性能面での不利な条件を回避するために行われている。 Linux の NFS クライアントでは <B>O_DIRECT</B> I/O
でのアラインメントの制限はない。
<P>

まとめると、 <B>O_DIRECT</B> は、注意して使うべきであるが、強力なツールとなる可能性を持っている。 アプリケーションは <B>O_DIRECT</B>
をデフォルトでは無効になっている性能向上のためのオプションと 考えておくのがよいであろう。
<A NAME="lbAU">&nbsp;</A>
<H2>バグ</H2>



現在のところ、 <B>open</B>()  の呼び出し時に <B>O_ASYNC</B> を指定してシグナル駆動 I/O を有効にすることはできない。
このフラグを有効にするには <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)  を使用すること。
<P>

カーネルが <B>O_TMPFILE</B> 機能をサポートしているかを判定する際に、 <B>EISDIR</B> と <B>ENOENT</B> の 2
つのエラーコードをチェックしなければならない。
<P>

When both <B>O_CREAT</B> and <B>O_DIRECTORY</B> are specified in <I>flags</I> and the
file specified by <I>pathname</I> does not exist, <B>open</B>()  will create a
regular file (i.e., <B>O_DIRECTORY</B> is ignored).
<A NAME="lbAV">&nbsp;</A>
<H2>関連項目</H2>

<B><A HREF="../man2/chmod.2.html">chmod</A></B>(2), <B><A HREF="../man2/chown.2.html">chown</A></B>(2), <B><A HREF="../man2/close.2.html">close</A></B>(2), <B><A HREF="../man2/dup.2.html">dup</A></B>(2), <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2), <B><A HREF="../man2/link.2.html">link</A></B>(2),
<B><A HREF="../man2/lseek.2.html">lseek</A></B>(2), <B><A HREF="../man2/mknod.2.html">mknod</A></B>(2), <B><A HREF="../man2/mmap.2.html">mmap</A></B>(2), <B><A HREF="../man2/mount.2.html">mount</A></B>(2), <B><A HREF="../man2/open_by_handle_at.2.html">open_by_handle_at</A></B>(2),
<B>openat2</B>(2), <B><A HREF="../man2/read.2.html">read</A></B>(2), <B><A HREF="../man2/socket.2.html">socket</A></B>(2), <B><A HREF="../man2/stat.2.html">stat</A></B>(2), <B><A HREF="../man2/umask.2.html">umask</A></B>(2),
<B><A HREF="../man2/unlink.2.html">unlink</A></B>(2), <B><A HREF="../man2/write.2.html">write</A></B>(2), <B><A HREF="../man3/fopen.3.html">fopen</A></B>(3), <B><A HREF="../../acl/man5/acl.5.html">acl</A></B>(5), <B><A HREF="../man7/fifo.7.html">fifo</A></B>(7), <B>inode</B>(7),
<B><A HREF="../man7/path_resolution.7.html">path_resolution</A></B>(7), <B><A HREF="../man7/symlink.7.html">symlink</A></B>(7)
<A NAME="lbAW">&nbsp;</A>
<H2>この文書について</H2>

この man ページは Linux <I>man-pages</I> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は
<A HREF="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</A> に書かれている。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">書式</A><DD>
<DT><A HREF="#lbAD">説明</A><DD>
<DL>
<DT><A HREF="#lbAE">creat()</A><DD>
<DT><A HREF="#lbAF">openat()</A><DD>
<DT><A HREF="#lbAG">openat2(2)</A><DD>
</DL>
<DT><A HREF="#lbAH">返り値</A><DD>
<DT><A HREF="#lbAI">エラー</A><DD>
<DT><A HREF="#lbAJ">バージョン</A><DD>
<DT><A HREF="#lbAK">準拠</A><DD>
<DT><A HREF="#lbAL">注意</A><DD>
<DL>
<DT><A HREF="#lbAM">オープンファイル記述</A><DD>
<DT><A HREF="#lbAN">同期 I/O</A><DD>
<DT><A HREF="#lbAO">C ライブラリとカーネルの違い</A><DD>
<DT><A HREF="#lbAP">NFS</A><DD>
<DT><A HREF="#lbAQ">FIFOs</A><DD>
<DT><A HREF="#lbAR">ファイルアクセスモード</A><DD>
<DT><A HREF="#lbAS">openat() や他のディレクトリファイルディスクリプター API の基本原理</A><DD>
<DT><A HREF="#lbAT">O_DIRECT</A><DD>
</DL>
<DT><A HREF="#lbAU">バグ</A><DD>
<DT><A HREF="#lbAV">関連項目</A><DD>
<DT><A HREF="#lbAW">この文書について</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:32 GMT, December 05, 2022
</BODY>
</HTML>
