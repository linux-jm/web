
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of SIGNAL</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../jm.css">
</HEAD>
<BODY>

<H1>SIGNAL</H1>
Section: Linux Programmer's Manual (7)<BR>Updated: 2020-12-21<BR><A HREF="#index">Index</A>
<A HREF="../../../index.html">JM Home Page</A>
<A HREF="../../../manual/LDP_man-pages/release/man7/signal.7">roff page</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>名前</H2>

signal - シグナルの概要
<A NAME="lbAC">&nbsp;</A>
<H2>説明</H2>

Linux は POSIX 信頼シグナル (reliable signal; 以後 &quot;標準シグナル&quot;と表記)  と POSIX
リアルタイムシグナルの両方に対応している。
<A NAME="lbAD">&nbsp;</A>
<H3>シグナル処理方法</H3>

シグナルはそれぞれ現在の「処理方法 (disposition)」を保持しており、 この処理方法によりシグナルが配送された際にプロセスが
どのような振舞いをするかが決まる。
<P>

後述の表の &quot;動作&quot; の欄のエントリーは各シグナルのデフォルトの 処理方法を示しており、以下のような意味を持つ。
<DL COMPACT>
<DT>Term<DD>
デフォルトの動作はプロセス終了。
<DT>Ign<DD>
デフォルトの動作はこのシグナルの無視。
<DT>Core<DD>
デフォルトの動作はプロセス終了とコアダンプ出力 (<B><A HREF="../man5/core.5.html">core</A></B>(5)  参照)。
<DT>Stop<DD>
デフォルトの動作はプロセスの一時停止。
<DT>Cont<DD>
デフォルトの動作は、プロセスが停止中の場合にその実行の再開。
</DL>
<P>

プロセスは、 <B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)  や <B><A HREF="../man2/signal.2.html">signal</A></B>(2)  を使って、シグナルの処理方法を変更することができる
(<B><A HREF="../man2/signal.2.html">signal</A></B>(2)  の方がシグナルハンドラーを設定する際の移植性が低い; 詳細は <B><A HREF="../man2/signal.2.html">signal</A></B>(2)  を参照)。
シグナルの配送時に起こる動作として プロセスが選択できるのは、次のいずれか一つである。 デフォルトの動作を実行する、シグナルを無視する、
<I>シグナルハンドラー (signal handler)</I> でシグナルを捕捉する。シグナルハンドラーとは、シグナル配送時に
自動的に起動されるプログラマ定義の関数である。
<P>

デフォルトでは、シグナルハンドラーは通常のプロセスのスタック上で起動される。 シグナルハンドラーが代替スタック (alternate stack)
を使用するように設定する こともできる。代替スタックを使用するように設定する方法と、どのような際に 代替スタックが役に立つかについての議論については
<B><A HREF="../man2/sigaltstack.2.html">sigaltstack</A></B>(2) を参照のこと。
<P>

シグナルの処理方法はプロセス単位の属性である。 マルチスレッドのアプリケーションでは、あるシグナルの処理方法は 全てのスレッドで同じである。
<P>

<B><A HREF="../man2/fork.2.html">fork</A></B>(2) 経由で作成された子プロセスは、親プロセスのシグナルの処理方法の コピーを継承する。 <B><A HREF="../man2/execve.2.html">execve</A></B>(2)
の前後で、ハンドラーが設定されているシグナルの処理方法はデフォルトにリセットされ、 無視が設定されているシグナルの処理方法は変更されずそのままとなる。
<A NAME="lbAE">&nbsp;</A>
<H3>シグナルの送信</H3>

以下のシステムコールとライブラリ関数を使って、 呼び出し者はシグナルを送信することができる。
<DL COMPACT>
<DT><B><A HREF="../man3/raise.3.html">raise</A></B>(3)<DD>
呼び出したスレッドにシグナルを送る。
<DT><B><A HREF="../man2/kill.2.html">kill</A></B>(2)<DD>
指定されたプロセスや、指定されたプロセスグループの全メンバー、 システムの全プロセスにシグナルを送る。
<DT><B>pidfd_send_signal</B>(2)<DD>
Sends a signal to a process identified by a PID file descriptor.
<DT><B>killpg</B>(3)<DD>
指定されたプロセスグループの全メンバーにシグナルを送る。
<DT><B><A HREF="../man3/pthread_kill.3.html">pthread_kill</A></B>(3)<DD>
呼び出し者と同じプロセス内の指定された POSIX スレッドにシグナルを送る。
<DT><B><A HREF="../man2/tgkill.2.html">tgkill</A></B>(2)<DD>
指定されたプロセス内の指定されたスレッドにシグナルを送る (このシステムコールを使って <B><A HREF="../man3/pthread_kill.3.html">pthread_kill</A></B>(3)  は実装されている)。
<DT><B><A HREF="../man3/sigqueue.3.html">sigqueue</A></B>(3)<DD>
指定されたプロセスに付属データとともにリアルタイムシグナルを送る。
</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>シグナルが捕捉されるのを待つ</H3>

以下のシステムコールを使って、シグナルが捕捉されるまで 呼び出したスレッドの実行を中断 (suspend) することができる
(ハンドラーが設定されていないシグナルによりそのプロセスが終了した 場合にも実行の停止は終了する)。
<DL COMPACT>
<DT><B><A HREF="../man2/pause.2.html">pause</A></B>(2)<DD>
何かシグナルが捕捉されるまで実行を停止する。
<DT><B><A HREF="../man2/sigsuspend.2.html">sigsuspend</A></B>(2)<DD>

一時的にシグナルマスク (下記参照) を変更し、 マスクされていないシグナルのいずれかが捕捉されるまで 実行を中断する。
</DL>
<A NAME="lbAG">&nbsp;</A>
<H3>シグナルの同期受信</H3>

シグナルハンドラー経由でシグナルを非同期 (asynchronously) で捕捉する以外にも、 シグナルを同期 (synchronously)
して受け付けることもできる。 同期して受け付けるとは、シグナルが配送されるまで実行を停止 (block)
するということである。シグナルを受け付けた際に、カーネルは そのシグナルに関する情報を呼び出し者に返す。 これを行う一般的な方法が二つある。
<DL COMPACT>
<DT>*<DD>
<B><A HREF="../man2/sigwaitinfo.2.html">sigwaitinfo</A></B>(2), <B><A HREF="../man2/sigtimedwait.2.html">sigtimedwait</A></B>(2), <B><A HREF="../man3/sigwait.3.html">sigwait</A></B>(3)
は、指定されたシグナル集合のシグナルの一つが配送されるまで実行を中断する。 どのシステムコールや関数でも、配送されたシグナルに関する情報が返される。
<DT>*<DD>
<B><A HREF="../man2/signalfd.2.html">signalfd</A></B>(2)  が返すファイルディスクリプターを使うと、呼び出し元に配送された シグナルに関する情報を読み出すことができる。
このファイルディスクリプターからの <B><A HREF="../man2/read.2.html">read</A></B>(2)  は、 <B><A HREF="../man2/signalfd.2.html">signalfd</A></B>(2)
の呼び出し時に指定されたシグナル集合のシグナルの一つが呼び出し元に 配送されるまで停止 (block) する。 <B><A HREF="../man2/read.2.html">read</A></B>(2)
が返すバッファーにはシグナルに関する情報を格納した構造体が入っている。
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>シグナルマスクと処理待ちシグナル</H3>

シグナルは <I>ブロック (block)</I> されることがある。ブロックされると、そのシグナルは その後ブロックを解除されるまで配送されなくなる。
シグナルが生成されてから配送されるまでの間、そのシグナルは <I>処理待ち (pending)</I> であると呼ばれる。
<P>

プロセス内の各スレッドは、それぞれ独立な <I>シグナルマスク (signal mask)</I> を持つ。シグナルマスクはそのスレッドが現在ブロックしている
シグナル集合を示すものである。 スレッドは、 <B><A HREF="../man3/pthread_sigmask.3.html">pthread_sigmask</A></B>(3)  を使って自分のシグナルマスクを操作できる。
伝統的なシングルスレッドのアプリケーションでは、 <B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)  を使って、シグナルマスクを操作できる。
<P>

<B><A HREF="../man2/fork.2.html">fork</A></B>(2)  経由で作成された子プロセスは親プロセスのシグナルマスクのコピーを継承する。 <B><A HREF="../man2/execve.2.html">execve</A></B>(2)
の前後でシグナルマスクは保持される。
<P>

A signal may be process-directed or thread-directed.  A process-directed
signal is one that is targeted at (and thus pending for)  the process as a
whole.  A signal may be process-directed because it was generated by the
kernel for reasons other than a hardware exception, or because it was sent
using <B><A HREF="../man2/kill.2.html">kill</A></B>(2)  or <B><A HREF="../man3/sigqueue.3.html">sigqueue</A></B>(3).  A thread-directed signal is one that
is targeted at a specific thread.  A signal may be thread-directed because
it was generated as a consequence of executing a specific machine-language
instruction that triggered a hardware exception (e.g., <B>SIGSEGV</B> for an
invalid memory access, or <B>SIGFPE</B> for a math error), or because it was
targeted at a specific thread using interfaces such as <B><A HREF="../man2/tgkill.2.html">tgkill</A></B>(2)  or
<B><A HREF="../man3/pthread_kill.3.html">pthread_kill</A></B>(3).
<P>



















A process-directed signal may be delivered to any one of the threads that
does not currently have the signal blocked.  If more than one of the threads
has the signal unblocked, then the kernel chooses an arbitrary thread to
which to deliver the signal.
<P>

スレッドは、 <B><A HREF="../man2/sigpending.2.html">sigpending</A></B>(2)  を使って、現在処理待ちのシグナル集合を取得することができる。
この集合は、プロセス宛ての処理待ちシグナルと 呼び出したスレッド宛てのシグナルの両方から構成される。
<P>


<B><A HREF="../man2/fork.2.html">fork</A></B>(2)  経由で作成された子プロセスでは、処理待ちのシグナル集合は空の集合で初期化される。 <B><A HREF="../man2/execve.2.html">execve</A></B>(2)
の前後で、処理待ちのシグナル集合は保持される。
<A NAME="lbAI">&nbsp;</A>
<H3>Execution of signal handlers</H3>

Whenever there is a transition from kernel-mode to user-mode execution
(e.g., on return from a system call or scheduling of a thread onto the CPU),
the kernel checks whether there is a pending unblocked signal for which the
process has established a signal handler.  If there is such a pending
signal, the following steps occur:
<DL COMPACT>
<DT>1.<DD>
The kernel performs the necessary preparatory steps for execution of the
signal handler:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>a)<DD>
The signal is removed from the set of pending signals.
<DT>b)<DD>
If the signal handler was installed by a call to <B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)  that
specified the <B>SA_ONSTACK</B> flag and the thread has defined an alternate
signal stack (using <B><A HREF="../man2/sigaltstack.2.html">sigaltstack</A></B>(2)), then that stack is installed.
<DT>c)<DD>
Various pieces of signal-related context are saved into a special frame that
is created on the stack.  The saved information includes:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>+<DD>
the program counter register (i.e., the address of the next instruction in
the main program that should be executed when the signal handler returns);
<DT>+<DD>
architecture-specific register state required for resuming the interrupted
program;
<DT>+<DD>
the thread's current signal mask;
<DT>+<DD>
the thread's alternate signal stack settings.
</DL>
</DL>

<DT><DD>
(If the signal handler was installed using the <B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)
<B>SA_SIGINFO</B> flag, then the above information is accessible via the
<I>ucontext_t</I> object that is pointed to by the third argument of the signal
handler.)
<DT>d)<DD>
Any signals specified in <I>act-&gt;sa_mask</I> when registering the handler
with <B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)  are added to the thread's signal mask.  The signal
being delivered is also added to the signal mask, unless <B>SA_NODEFER</B> was
specified when registering the handler.  These signals are thus blocked
while the handler executes.
</DL>
</DL>

<DT>2.<DD>
The kernel constructs a frame for the signal handler on the stack.  The
kernel sets the program counter for the thread to point to the first
instruction of the signal handler function, and configures the return
address for that function to point to a piece of user-space code known as
the signal trampoline (described in <B><A HREF="../man2/sigreturn.2.html">sigreturn</A></B>(2)).
<DT>3.<DD>
The kernel passes control back to user-space, where execution commences at
the start of the signal handler function.
<DT>4.<DD>
When the signal handler returns, control passes to the signal trampoline
code.
<DT>5.<DD>
The signal trampoline calls <B><A HREF="../man2/sigreturn.2.html">sigreturn</A></B>(2), a system call that uses the
information in the stack frame created in step 1 to restore the thread to
its state before the signal handler was called.  The thread's signal mask
and alternate signal stack settings are restored as part of this procedure.
Upon completion of the call to <B><A HREF="../man2/sigreturn.2.html">sigreturn</A></B>(2), the kernel transfers control
back to user space, and the thread recommences execution at the point where
it was interrupted by the signal handler.
</DL>
<P>

Note that if the signal handler does not return (e.g., control is
transferred out of the handler using <B><A HREF="../man3/siglongjmp.3.html">siglongjmp</A></B>(3), or the handler
executes a new program with <B><A HREF="../man2/execve.2.html">execve</A></B>(2)), then the final step is not
performed.  In particular, in such scenarios it is the programmer's
responsibility to restore the state of the signal mask (using
<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)), if it is desired to unblock the signals that were
blocked on entry to the signal handler.  (Note that <B><A HREF="../man3/siglongjmp.3.html">siglongjmp</A></B>(3)  may or
may not restore the signal mask, depending on the <I>savesigs</I> value that was
specified in the corresponding call to <B><A HREF="../man3/sigsetjmp.3.html">sigsetjmp</A></B>(3).)
<P>


From the kernel's point of view, execution of the signal handler code is
exactly the same as the execution of any other user-space code.  That is to
say, the kernel does not record any special state information indicating
that the thread is currently excuting inside a signal handler.  All
necessary state information is maintained in user-space registers and the
user-space stack.  The depth to which nested signal handlers may be invoked
is thus limited only by the user-space stack (and sensible software
design!).
<A NAME="lbAJ">&nbsp;</A>
<H3>標準シグナル</H3>

Linux supports the standard signals listed below.  The second column of the
table indicates which standard (if any)  specified the signal: &quot;P1990&quot;
indicates that the signal is described in the original POSIX.1-1990
standard; &quot;P2001&quot; indicates that the signal was added in SUSv2 and
POSIX.1-2001.
<TABLE>
<TR VALIGN=top><TD>シグナル</TD><TD ALIGN=center>標準</TD><TD ALIGN=center>動作</TD><TD>コメント<BR></TD></TR>
<TR VALIGN=top><TD><HR></TD><TD><HR></TD><TD><HR></TD><TD><HR></TD></TR>
<TR VALIGN=top><TD><B>SIGABRT</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Core</TD><TD><B><A HREF="../man3/abort.3.html">abort</A></B>(3) からの中断 (Abort) シグナル<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGALRM</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD><B><A HREF="../man2/alarm.2.html">alarm</A></B>(2) からのタイマーシグナル<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGBUS</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Core</TD><TD>バスエラー (不正なメモリーアクセス)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCHLD</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Ign</TD><TD>子プロセスの一時停止 (stop) または終了<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCLD</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Ign</TD><TD><B>SIGCHLD</B> と同義<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCONT</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Cont</TD><TD>一時停止 (stop) からの再開<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGEMT</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Term</TD><TD>Emulator trap<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGFPE</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Core</TD><TD>浮動小数点例外<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGHUP</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>制御端末(controlling terminal)のハングアップ検出、<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>または制御しているプロセスの死<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGILL</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Core</TD><TD>不正な命令<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGINFO</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center></TD><TD><B>SIGPWR</B> と同義<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGINT</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>キーボードからの割り込み (Interrupt)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGIO</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Term</TD><TD>入出力が可能になった (4.2BSD)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGIOT</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Core</TD><TD>IOT トラップ。 <B>SIGABRT</B> と同義<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGKILL</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>Kill シグナル<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGLOST</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Term</TD><TD>ファイルロックが失われた (未使用)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPIPE</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>パイプ破壊:<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>readers; see <B><A HREF="../man7/pipe.7.html">pipe</A></B>(7)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPOLL</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Term</TD><TD>ポーリング可能なイベント (Sys V);<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD><B>SIGIO</B> と同義<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPROF</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Term</TD><TD>profiling タイマーの時間切れ<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPWR</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Term</TD><TD>電源喪失 (Power failure) (System V)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGQUIT</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Core</TD><TD>キーボードによる中止 (Quit)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSEGV</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Core</TD><TD>不正なメモリー参照<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSTKFLT</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Term</TD><TD>数値演算プロセッサにおけるスタックフォルト (未使用)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSTOP</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Stop</TD><TD>プロセスの一時停止 (stop)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTSTP</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Stop</TD><TD>端末より入力された一時停止 (stop)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSYS</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Core</TD><TD>Bad system call (SVr4);<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>see also <B>seccomp</B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTERM</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>終了 (termination) シグナル<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTRAP</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Core</TD><TD>トレース/ブレークポイント トラップ<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTTIN</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Stop</TD><TD>バックグランドプロセスの端末入力<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTTOU</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Stop</TD><TD>バックグランドプロセスの端末出力<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUNUSED</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Core</TD><TD><B>SIGSYS</B> と同義<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGURG</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Ign</TD><TD>ソケットの緊急事態 (urgent condition) (4.2BSD)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUSR1</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>ユーザー定義シグナル 1<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUSR2</B></TD><TD ALIGN=center>P1990</TD><TD ALIGN=center>Term</TD><TD>ユーザー定義シグナル 2<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGVTALRM</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Term</TD><TD>仮想アラームクロック (4.2BSD)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGXCPU</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Core</TD><TD>CPU時間制限超過 (4.2BSD);<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>see <B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGXFSZ</B></TD><TD ALIGN=center>P2001</TD><TD ALIGN=center>Core</TD><TD>ファイルサイズ制限の超過 (4.2BSD);<BR></TD></TR>
<TR VALIGN=top><TD><B></B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>see <B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGWINCH</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>Ign</TD><TD>ウィンドウ リサイズ シグナル (4.3BSD, Sun)<BR></TD></TR>
</TABLE>

<P>

シグナル <B>SIGKILL</B> と <B>SIGSTOP</B> はキャッチ、ブロック、無視できない。
<P>

Linux 2.2 以前では、 <B>SIGSYS</B>, <B>SIGXCPU</B>, <B>SIGXFSZ</B> および SPARC と MIPS
以外のアーキテクチャーでの <B>SIGBUS</B> のデフォルトの振る舞いは (コアダンプ出力なしの) プロセス終了であった。 (他の UNIX
システムにも <B>SIGXCPU</B> と <B>SIGXFSZ</B> のデフォルトの動作がコアダンプなしのプロセス終了のものがある。)  Linux 2.4
では、POSIX.1-2001 での要求仕様に準拠して、 これらのシグナルで、プロセスを終了させ、コアダンプを出力する ようになっている。
<P>

<B>SIGEMT</B> は POSIX.1-2001 に規定されていないが、 その他の多くの UNIX システムに存在する。
デフォルトの動作は多くの場合、コアダンプ出力を伴うプロセスの終了である。
<P>

<B>SIGPWR</B> は (POSIX.1-2001 に規定されていないが) このシグナルが存在する 他の UNIX
システムでは多くの場合、デフォルト動作は無視である。
<P>


<B>SIGIO</B> は (POSIX.1-2001 に規定されていないが) いくつかの他の UNIX システムでは デフォルト動作は無視である。
<A NAME="lbAK">&nbsp;</A>
<H3>Queueing and delivery semantics for standard signals</H3>

If multiple standard signals are pending for a process, the order in which
the signals are delivered is unspecified.
<P>


Standard signals do not queue.  If multiple instances of a standard signal
are generated while that signal is blocked, then only one instance of the
signal is marked as pending (and the signal will be delivered just once when
it is unblocked).  In the case where a standard signal is already pending,
the <I>siginfo_t</I> structure (see <B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2))  associated with that
signal is not overwritten on arrival of subsequent instances of the same
signal.  Thus, the process will receive the information associated with the
first instance of the signal.
<A NAME="lbAL">&nbsp;</A>
<H3>Signal numbering for standard signals</H3>

The numeric value for each signal is given in the table below.  As shown in
the table, many signals have different numeric values on different
architectures.  The first numeric value in each table row shows the signal
number on x86, ARM, and most other architectures; the second value is for
Alpha and SPARC; the third is for MIPS; and the last is for PARISC.  A dash
(-) denotes that a signal is absent on the corresponding architecture.
<TABLE>
<TR VALIGN=top><TD>シグナル</TD><TD ALIGN=center>x86/ARM</TD><TD ALIGN=center>Alpha/</TD><TD ALIGN=center>MIPS</TD><TD ALIGN=center>PARISC</TD><TD>Notes<BR></TD></TR>
<TR VALIGN=top><TD></TD><TD ALIGN=center>most others</TD><TD ALIGN=center>SPARC</TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><HR></TD><TD><HR></TD><TD><HR></TD><TD><HR></TD><TD><HR></TD><TD><HR></TD></TR>
<TR VALIGN=top><TD><B>SIGHUP</B></TD><TD ALIGN=center>&nbsp;1</TD><TD ALIGN=center>&nbsp;1</TD><TD ALIGN=center>&nbsp;1</TD><TD ALIGN=center>&nbsp;1</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGINT</B></TD><TD ALIGN=center>&nbsp;2</TD><TD ALIGN=center>&nbsp;2</TD><TD ALIGN=center>&nbsp;2</TD><TD ALIGN=center>&nbsp;2</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGQUIT</B></TD><TD ALIGN=center>&nbsp;3</TD><TD ALIGN=center>&nbsp;3</TD><TD ALIGN=center>&nbsp;3</TD><TD ALIGN=center>&nbsp;3</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGILL</B></TD><TD ALIGN=center>&nbsp;4</TD><TD ALIGN=center>&nbsp;4</TD><TD ALIGN=center>&nbsp;4</TD><TD ALIGN=center>&nbsp;4</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTRAP</B></TD><TD ALIGN=center>&nbsp;5</TD><TD ALIGN=center>&nbsp;5</TD><TD ALIGN=center>&nbsp;5</TD><TD ALIGN=center>&nbsp;5</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGABRT</B></TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGIOT</B></TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD ALIGN=center>&nbsp;6</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGBUS</B></TD><TD ALIGN=center>&nbsp;7</TD><TD ALIGN=center>10</TD><TD ALIGN=center>10</TD><TD ALIGN=center>10</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGEMT</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>&nbsp;7</TD><TD ALIGN=center>&nbsp;7</TD><TD ALIGN=center>-</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGFPE</B></TD><TD ALIGN=center>&nbsp;8</TD><TD ALIGN=center>&nbsp;8</TD><TD ALIGN=center>&nbsp;8</TD><TD ALIGN=center>&nbsp;8</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGKILL</B></TD><TD ALIGN=center>&nbsp;9</TD><TD ALIGN=center>&nbsp;9</TD><TD ALIGN=center>&nbsp;9</TD><TD ALIGN=center>&nbsp;9</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUSR1</B></TD><TD ALIGN=center>10</TD><TD ALIGN=center>30</TD><TD ALIGN=center>16</TD><TD ALIGN=center>16</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSEGV</B></TD><TD ALIGN=center>11</TD><TD ALIGN=center>11</TD><TD ALIGN=center>11</TD><TD ALIGN=center>11</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUSR2</B></TD><TD ALIGN=center>12</TD><TD ALIGN=center>31</TD><TD ALIGN=center>17</TD><TD ALIGN=center>17</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPIPE</B></TD><TD ALIGN=center>13</TD><TD ALIGN=center>13</TD><TD ALIGN=center>13</TD><TD ALIGN=center>13</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGALRM</B></TD><TD ALIGN=center>14</TD><TD ALIGN=center>14</TD><TD ALIGN=center>14</TD><TD ALIGN=center>14</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTERM</B></TD><TD ALIGN=center>15</TD><TD ALIGN=center>15</TD><TD ALIGN=center>15</TD><TD ALIGN=center>15</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSTKFLT</B></TD><TD ALIGN=center>16</TD><TD ALIGN=center>-</TD><TD ALIGN=center>-</TD><TD ALIGN=center>&nbsp;7</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCHLD</B></TD><TD ALIGN=center>17</TD><TD ALIGN=center>20</TD><TD ALIGN=center>18</TD><TD ALIGN=center>18</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCLD</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>-</TD><TD ALIGN=center>18</TD><TD ALIGN=center>-</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGCONT</B></TD><TD ALIGN=center>18</TD><TD ALIGN=center>19</TD><TD ALIGN=center>25</TD><TD ALIGN=center>26</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSTOP</B></TD><TD ALIGN=center>19</TD><TD ALIGN=center>17</TD><TD ALIGN=center>23</TD><TD ALIGN=center>24</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTSTP</B></TD><TD ALIGN=center>20</TD><TD ALIGN=center>18</TD><TD ALIGN=center>24</TD><TD ALIGN=center>25</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTTIN</B></TD><TD ALIGN=center>21</TD><TD ALIGN=center>21</TD><TD ALIGN=center>26</TD><TD ALIGN=center>27</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGTTOU</B></TD><TD ALIGN=center>22</TD><TD ALIGN=center>22</TD><TD ALIGN=center>27</TD><TD ALIGN=center>28</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGURG</B></TD><TD ALIGN=center>23</TD><TD ALIGN=center>16</TD><TD ALIGN=center>21</TD><TD ALIGN=center>29</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGXCPU</B></TD><TD ALIGN=center>24</TD><TD ALIGN=center>24</TD><TD ALIGN=center>30</TD><TD ALIGN=center>12</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGXFSZ</B></TD><TD ALIGN=center>25</TD><TD ALIGN=center>25</TD><TD ALIGN=center>31</TD><TD ALIGN=center>30</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGVTALRM</B></TD><TD ALIGN=center>26</TD><TD ALIGN=center>26</TD><TD ALIGN=center>28</TD><TD ALIGN=center>20</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPROF</B></TD><TD ALIGN=center>27</TD><TD ALIGN=center>27</TD><TD ALIGN=center>29</TD><TD ALIGN=center>21</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGWINCH</B></TD><TD ALIGN=center>28</TD><TD ALIGN=center>28</TD><TD ALIGN=center>20</TD><TD ALIGN=center>23</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGIO</B></TD><TD ALIGN=center>29</TD><TD ALIGN=center>23</TD><TD ALIGN=center>22</TD><TD ALIGN=center>22</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPOLL</B></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD ALIGN=center></TD><TD>Same as SIGIO<BR></TD></TR>
<TR VALIGN=top><TD><B>SIGPWR</B></TD><TD ALIGN=center>30</TD><TD ALIGN=center>29/-</TD><TD ALIGN=center>19</TD><TD ALIGN=center>19</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGINFO</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>29/-</TD><TD ALIGN=center>-</TD><TD ALIGN=center>-</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGLOST</B></TD><TD ALIGN=center>-</TD><TD ALIGN=center>-/29</TD><TD ALIGN=center>-</TD><TD ALIGN=center>-</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGSYS</B></TD><TD ALIGN=center>31</TD><TD ALIGN=center>12</TD><TD ALIGN=center>12</TD><TD ALIGN=center>31</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD><B>SIGUNUSED</B></TD><TD ALIGN=center>31</TD><TD ALIGN=center>-</TD><TD ALIGN=center>-</TD><TD ALIGN=center>31</TD><TD><BR></TD></TR>
</TABLE>

<P>

Note the following:
<DL COMPACT>
<DT>*<DD>
Where defined, <B>SIGUNUSED</B> is synonymous with <B>SIGSYS</B>.  Since glibc 2.26,
<B>SIGUNUSED</B> is no longer defined on any architecture.
<DT>*<DD>

Signal 29 is <B>SIGINFO</B>/<B>SIGPWR</B> (synonyms for the same value) on Alpha but
<B>SIGLOST</B> on SPARC.
</DL>
<A NAME="lbAM">&nbsp;</A>
<H3>リアルタイムシグナル</H3>

Starting with version 2.2, Linux supports real-time signals as originally
defined in the POSIX.1b real-time extensions (and now included in
POSIX.1-2001).  The range of supported real-time signals is defined by the
macros <B>SIGRTMIN</B> and <B>SIGRTMAX</B>.  POSIX.1-2001 requires that an
implementation support at least <B>_POSIX_RTSIG_MAX</B> (8) real-time signals.
<P>

The Linux kernel supports a range of 33 different real-time signals,
numbered 32 to 64.  However, the glibc POSIX threads implementation
internally uses two (for NPTL) or three (for LinuxThreads) real-time signals
(see <B><A HREF="../man7/pthreads.7.html">pthreads</A></B>(7)), and adjusts the value of <B>SIGRTMIN</B> suitably (to 34
or 35).  Because the range of available real-time signals varies according
to the glibc threading implementation (and this variation can occur at run
time according to the available kernel and glibc), and indeed the range of
real-time signals varies across UNIX systems, programs should <I>never refer
to real-time signals using hard-coded numbers</I>, but instead should always
refer to real-time signals using the notation <B>SIGRTMIN</B>+n, and include
suitable (run-time) checks that <B>SIGRTMIN</B>+n does not exceed <B>SIGRTMAX</B>.
<P>

標準シグナルと異なり、リアルタイムシグナルには 事前に定義された意味はない。 リアルタイムシグナルの全部をアプリケーションで定義した用途に使える。
<P>

ハンドリングしないリアルタイムシグナルのデフォルトの動作は 受信したプロセスの終了である。
<P>

リアルタイムシグナルは以下の特徴がある:
<DL COMPACT>
<DT>1.<DD>
リアルタイムシグナルは複数の実体をキューに入れることができる。 一方、標準シグナルの場合、そのシグナルがブロックされている間に
同じシグナルの複数のインスタンスが配送されても、 1 つだけがキューに入れられる。
<DT>2.<DD>
シグナルが <B><A HREF="../man3/sigqueue.3.html">sigqueue</A></B>(3)  を用いて送信された場合、 付属データ (整数かポインター) をシグナルと共に送信できる。 受信側プロセスが
<B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)  に <B>SA_SIGINFO</B> フラグを指定してシグナルハンドラーを設定した場合、 このデータは
<I>siginfo_t</I> 構造体の <I>si_value</I> フィールド経由でハンドラーの第 2 引数として渡され、 利用することができる。
さらに、この構造体の <I>si_pid</I> と <I>si_uid</I> フィールドでシグナルを送信したプロセスの PID と実ユーザー ID を
得ることができる。
<DT>3.<DD>
リアルタイムシグナルでは配送される順序が保証される。 同じタイプのリアルタイムシグナルは送信された順番に到着する。
異なるリアルタイムシグナルが一つのプロセスに送信された場合、 番号の小さいシグナルから先に到着する。
(つまり小さい番号のシグナルが高い優先順位を持つ。)  対照的に、一つのプロセスに対して複数の標準シグナルが処理待ちとなった場合、
これらのシグナルが配送される順序は不定である。
</DL>
<P>

一つのプロセスに対して標準シグナルとリアルタイムシグナルの両方が 処理待ちの場合、POSIX はどちらが先に配送されるかを規定していない。 Linux
では、他の多くの実装と同様、このような場合には 標準シグナルが優先される。
<P>

POSIX によれば、1 プロセス毎に最低 <B>_POSIX_SIGQUEUE_MAX</B> (32)
個のリアルタイムシグナルをキューに入れられるべきとしている。 しかし、 Linux では違った実装になっている。カーネル 2.6.7 までは
(2.6.7 を含む)、全プロセスでキューに入っているリアルタイムシグナル の数の合計についてシステム全体での制限がある。 この制限は
<I>/proc/sys/kernel/rtsig-max</I> ファイルで見ることができ、 (権限があれば) 変更もできる。 関係するファイルとして、
<I>/proc/sys/kernel/rtsig-nr</I> を見ることで、いくつのリアルタイムシグナルが現在キューに入っているかを 知ることができる。
Linux 2.6.8 で、これらの <I>/proc</I> 経由のインターフェースは、 <B>RLIMIT_SIGPENDING</B>
リソース制限に置き換えられた。 これは、キューに入るシグナル数に関してユーザー単位に 上限を指定するものである。 詳しくは
<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2)  を参照。
<P>

The addition of real-time signals required the widening of the signal set
structure (<I>sigset_t</I>)  from 32 to 64 bits.  Consequently, various system
calls were superseded by new system calls that supported the larger signal
sets.  The old and new system calls are as follows:
<TABLE>
<TR VALIGN=top><TD><B>Linux 2.0 and earlier</B></TD><TD><B>Linux 2.2 and later</B><BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigaction.2.html">rt_sigaction</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigpending.2.html">sigpending</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigpending.2.html">rt_sigpending</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigprocmask.2.html">rt_sigprocmask</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigreturn.2.html">sigreturn</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigreturn.2.html">rt_sigreturn</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigsuspend.2.html">sigsuspend</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigsuspend.2.html">rt_sigsuspend</A></B>(2)<BR></TD></TR>
<TR VALIGN=top><TD><B><A HREF="../man2/sigtimedwait.2.html">sigtimedwait</A></B>(2)</TD><TD><B><A HREF="../man2/rt_sigtimedwait.2.html">rt_sigtimedwait</A></B>(2)<BR></TD></TR>
</TABLE>


<A NAME="lbAN">&nbsp;</A>
<H3>シグナルハンドラーによるシステムコールやライブラリ関数への割り込み</H3>

システムコールやライブラリが停止 (block) している間にシグナルハンドラーが 起動されると、以下のどちらかとなる。
<DL COMPACT>
<DT>*<DD>
シグナルが返った後、呼び出しは自動的に再スタートされる。
<DT>*<DD>
呼び出しはエラー <B>EINTR</B> で失敗する。
</DL>
<P>

これらの二つの挙動のうちどちらが起こるかは、インターフェイスにより依存し、 シグナルハンドラーが <B>SA_RESTART</B> フラグ
(<B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2)  参照) を使って設定されていたかにも依存する。 詳細は UNIX システムによって異なる。 Linux
における詳細を以下で説明する。
<P>



If a blocked call to one of the following interfaces is interrupted by a
signal handler, then the call is automatically restarted after the signal
handler returns if the <B>SA_RESTART</B> flag was used; otherwise the call fails
with the error <B>EINTR</B>:
<DL COMPACT>
<DT>*<DD>
<B><A HREF="../man2/read.2.html">read</A></B>(2), <B><A HREF="../man2/readv.2.html">readv</A></B>(2), <B><A HREF="../man2/write.2.html">write</A></B>(2), <B><A HREF="../man2/writev.2.html">writev</A></B>(2), and <B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)  calls
on &quot;slow&quot; devices.  A &quot;slow&quot; device is one where the I/O call may block for
an indefinite time, for example, a terminal, pipe, or socket.  If an I/O
call on a slow device has already transferred some data by the time it is
interrupted by a signal handler, then the call will return a success status
(normally, the number of bytes transferred).  Note that a (local) disk is
not a slow device according to this definition; I/O operations on disk
devices are not interrupted by signals.
<DT>*<DD>
停止 (block) する可能性のある <B><A HREF="../man2/open.2.html">open</A></B>(2)  (例えば、FIFO のオープン時; <B><A HREF="../man7/fifo.7.html">fifo</A></B>(7)  参照)。
<DT>*<DD>
<B><A HREF="../man2/wait.2.html">wait</A></B>(2), <B><A HREF="../man2/wait3.2.html">wait3</A></B>(2), <B><A HREF="../man2/wait4.2.html">wait4</A></B>(2), <B><A HREF="../man2/waitid.2.html">waitid</A></B>(2), <B><A HREF="../man2/waitpid.2.html">waitpid</A></B>(2).
<DT>*<DD>





ソケットインターフェイス: <B><A HREF="../man2/accept.2.html">accept</A></B>(2), <B><A HREF="../man2/connect.2.html">connect</A></B>(2), <B><A HREF="../man2/recv.2.html">recv</A></B>(2), <B><A HREF="../man2/recvfrom.2.html">recvfrom</A></B>(2),
<B><A HREF="../man2/recvmmsg.2.html">recvmmsg</A></B>(2), <B><A HREF="../man2/recvmsg.2.html">recvmsg</A></B>(2), <B><A HREF="../man2/send.2.html">send</A></B>(2), <B><A HREF="../man2/sendto.2.html">sendto</A></B>(2), <B><A HREF="../man2/sendmsg.2.html">sendmsg</A></B>(2).
但し、ソケットにタイムアウトが設定されていない場合 (下記参照)。
<DT>*<DD>
ファイルロック用インターフェイス: <B><A HREF="../man2/flock.2.html">flock</A></B>(2), <B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2) の <B>F_SETLKW</B> と <B>F_OFD_SETLKW</B>
操作。
<DT>*<DD>
POSIX メッセージキューインターフェイス: <B><A HREF="../man3/mq_receive.3.html">mq_receive</A></B>(3), <B><A HREF="../man3/mq_timedreceive.3.html">mq_timedreceive</A></B>(3),
<B><A HREF="../man3/mq_send.3.html">mq_send</A></B>(3), <B><A HREF="../man3/mq_timedsend.3.html">mq_timedsend</A></B>(3).
<DT>*<DD>

<B><A HREF="../man2/futex.2.html">futex</A></B>(2)  <B>FUTEX_WAIT</B> (Linux 2.6.22 以降; それ以前は常に <B>EINTR</B> で失敗していた)。
<DT>*<DD>
<B>getrandom</B>(2).
<DT>*<DD>
<B><A HREF="../../glibc-linuxthreads/man3/pthread_mutex_lock.3.html">pthread_mutex_lock</A></B>(3), <B><A HREF="../../glibc-linuxthreads/man3/pthread_cond_wait.3.html">pthread_cond_wait</A></B>(3) と関連 API。
<DT>*<DD>
<B><A HREF="../man2/futex.2.html">futex</A></B>(2)  <B>FUTEX_WAIT_BITSET</B>.
<DT>*<DD>

POSIX セマフォインターフェイス: <B><A HREF="../man3/sem_wait.3.html">sem_wait</A></B>(3), <B><A HREF="../man3/sem_timedwait.3.html">sem_timedwait</A></B>(3)  (Linux 2.6.22 以降;
それ以前は常に <B>EINTR</B> で失敗していた)。
<DT>*<DD>

<B><A HREF="../man2/read.2.html">read</A></B>(2)  from an <B><A HREF="../man7/inotify.7.html">inotify</A></B>(7)  file descriptor (since Linux 3.8;
beforehand, always failed with <B>EINTR</B>).
</DL>
<P>



以下のインターフェイスは、 <B>SA_RESTART</B> を使っているどうかに関わらず、シグナルハンドラーにより割り込まれた後、
再スタートすることは決してない。 これらは、シグナルハンドラーにより割り込まれると、常にエラー <B>EINTR</B> で失敗する。
<DL COMPACT>
<DT>*<DD>
<B><A HREF="../man2/setsockopt.2.html">setsockopt</A></B>(2)  を使ってタイムアウト (<B>SO_RCVTIMEO</B>) が設定されている「入力」ソケットインターフェース:
<B><A HREF="../man2/accept.2.html">accept</A></B>(2), <B><A HREF="../man2/recv.2.html">recv</A></B>(2), <B><A HREF="../man2/recvfrom.2.html">recvfrom</A></B>(2), <B><A HREF="../man2/recvmmsg.2.html">recvmmsg</A></B>(2) (NULL 以外の
<I>timeout</I> 引数も指定されている場合), <B><A HREF="../man2/recvmsg.2.html">recvmsg</A></B>(2)
<DT>*<DD>

&quot;Output&quot; socket interfaces, when a timeout (<B>SO_RCVTIMEO</B>)  has been set on
the socket using <B><A HREF="../man2/setsockopt.2.html">setsockopt</A></B>(2): <B><A HREF="../man2/connect.2.html">connect</A></B>(2), <B><A HREF="../man2/send.2.html">send</A></B>(2), <B><A HREF="../man2/sendto.2.html">sendto</A></B>(2),
and <B><A HREF="../man2/sendmsg.2.html">sendmsg</A></B>(2).
<DT>*<DD>
シグナル待ちに使われるインターフェイス: <B><A HREF="../man2/pause.2.html">pause</A></B>(2), <B><A HREF="../man2/sigsuspend.2.html">sigsuspend</A></B>(2), <B><A HREF="../man2/sigtimedwait.2.html">sigtimedwait</A></B>(2),
<B><A HREF="../man2/sigwaitinfo.2.html">sigwaitinfo</A></B>(2).
<DT>*<DD>
ファイルディスクリプター多重インターフェイス: <B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2), <B><A HREF="../man2/epoll_pwait.2.html">epoll_pwait</A></B>(2), <B><A HREF="../man2/poll.2.html">poll</A></B>(2),
<B><A HREF="../man2/ppoll.2.html">ppoll</A></B>(2), <B><A HREF="../man2/select.2.html">select</A></B>(2), <B><A HREF="../man2/pselect.2.html">pselect</A></B>(2).
<DT>*<DD>

System V IPC インターフェイス: <B><A HREF="../man2/msgrcv.2.html">msgrcv</A></B>(2), <B><A HREF="../man2/msgsnd.2.html">msgsnd</A></B>(2), <B><A HREF="../man2/semop.2.html">semop</A></B>(2),
<B><A HREF="../man2/semtimedop.2.html">semtimedop</A></B>(2).
<DT>*<DD>
スリープ用のインターフェイス: <B><A HREF="../man2/clock_nanosleep.2.html">clock_nanosleep</A></B>(2), <B><A HREF="../man2/nanosleep.2.html">nanosleep</A></B>(2), <B><A HREF="../man3/usleep.3.html">usleep</A></B>(3).
<DT>*<DD>
<B><A HREF="../man2/io_getevents.2.html">io_getevents</A></B>(2).
</DL>
<P>

<B><A HREF="../man3/sleep.3.html">sleep</A></B>(3)  関数も、ハンドラーにより割り込まれた場合、決して再スタートされることはない。 しかし、成功となり、残っている停止時間を返す。
<A NAME="lbAO">&nbsp;</A>
<H3>一時停止シグナルによるシステムコールやライブラリ関数への割り込み</H3>

Linux では、シグナルハンドラーが設定されていない場合でも、 いくつかのブロッキング型のインターフェイスは、 プロセスが一時停止 (stop)
シグナルの一つにより停止され、 <B>SIGCONT</B> により再開された後に、エラー <B>EINTR</B> で失敗する可能性がある。 この挙動は
POSIX.1 で認められておらず、他のシステムでは起こらない。
<P>

この挙動を示す Linux のインターフェイスは以下の通りである。
<DL COMPACT>
<DT>*<DD>
<B><A HREF="../man2/setsockopt.2.html">setsockopt</A></B>(2)  を使ってタイムアウト (<B>SO_RCVTIMEO</B>) が設定されている「入力」ソケットインターフェース:
<B><A HREF="../man2/accept.2.html">accept</A></B>(2), <B><A HREF="../man2/recv.2.html">recv</A></B>(2), <B><A HREF="../man2/recvfrom.2.html">recvfrom</A></B>(2), <B><A HREF="../man2/recvmmsg.2.html">recvmmsg</A></B>(2) (NULL 以外の
<I>timeout</I> 引数も指定されている場合), <B><A HREF="../man2/recvmsg.2.html">recvmsg</A></B>(2)
<DT>*<DD>

&quot;Output&quot; socket interfaces, when a timeout (<B>SO_RCVTIMEO</B>)  has been set on
the socket using <B><A HREF="../man2/setsockopt.2.html">setsockopt</A></B>(2): <B><A HREF="../man2/connect.2.html">connect</A></B>(2), <B><A HREF="../man2/send.2.html">send</A></B>(2), <B><A HREF="../man2/sendto.2.html">sendto</A></B>(2),
and <B><A HREF="../man2/sendmsg.2.html">sendmsg</A></B>(2), if a send timeout (<B>SO_SNDTIMEO</B>)  has been set.
<DT>*<DD>
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2), <B><A HREF="../man2/epoll_pwait.2.html">epoll_pwait</A></B>(2).
<DT>*<DD>
<B><A HREF="../man2/semop.2.html">semop</A></B>(2), <B><A HREF="../man2/semtimedop.2.html">semtimedop</A></B>(2).
<DT>*<DD>
<B><A HREF="../man2/sigtimedwait.2.html">sigtimedwait</A></B>(2), <B><A HREF="../man2/sigwaitinfo.2.html">sigwaitinfo</A></B>(2).
<DT>*<DD>

Linux 3.7 and earlier: <B><A HREF="../man2/read.2.html">read</A></B>(2)  from an <B><A HREF="../man7/inotify.7.html">inotify</A></B>(7)  file descriptor
<DT>*<DD>
Linux 2.6.21 以前: <B><A HREF="../man2/futex.2.html">futex</A></B>(2)  <B>FUTEX_WAIT</B>, <B><A HREF="../man3/sem_timedwait.3.html">sem_timedwait</A></B>(3),
<B><A HREF="../man3/sem_wait.3.html">sem_wait</A></B>(3).
<DT>*<DD>
Linux 2.6.8 以前: <B><A HREF="../man2/msgrcv.2.html">msgrcv</A></B>(2), <B><A HREF="../man2/msgsnd.2.html">msgsnd</A></B>(2).
<DT>*<DD>
Linux 2.4 以前: <B><A HREF="../man2/nanosleep.2.html">nanosleep</A></B>(2).
</DL>
<A NAME="lbAP">&nbsp;</A>
<H2>準拠</H2>

POSIX.1 (注記した内容以外)。
<A NAME="lbAQ">&nbsp;</A>
<H2>注意</H2>

For a discussion of async-signal-safe functions, see <B>signal-safety</B>(7).
<P>

The <I>/proc/[pid]/task/[tid]/status</I> file contains various fields that show
the signals that a thread is blocking (<I>SigBlk</I>), catching (<I>SigCgt</I>), or
ignoring (<I>SigIgn</I>).  (The set of signals that are caught or ignored will
be the same across all threads in a process.)  Other fields show the set of
pending signals that are directed to the thread (<I>SigPnd</I>)  as well as the
set of pending signals that are directed to the process as a whole
(<I>ShdPnd</I>).  The corresponding fields in <I>/proc/[pid]/status</I> show the
information for the main thread.  See <B><A HREF="../man5/proc.5.html">proc</A></B>(5)  for further details.
<A NAME="lbAR">&nbsp;</A>
<H2>バグ</H2>

There are six signals that can be delivered as a consequence of a hardware
exception: <B>SIGBUS</B>, <B>SIGEMT</B>, <B>SIGFPE</B>, <B>SIGILL</B>, <B>SIGSEGV</B>, and
<B>SIGTRAP</B>.  Which of these signals is delivered, for any given hardware
exception, is not documented and does not always make sense.
<P>

For example, an invalid memory access that causes delivery of <B>SIGSEGV</B> on
one CPU architecture may cause delivery of <B>SIGBUS</B> on another
architecture, or vice versa.
<P>

For another example, using the x86 <I>int</I> instruction with a forbidden
argument (any number other than 3 or 128)  causes delivery of <B>SIGSEGV</B>,
even though <B>SIGILL</B> would make more sense, because of how the CPU reports
the forbidden operation to the kernel.
<A NAME="lbAS">&nbsp;</A>
<H2>関連項目</H2>

<B><A HREF="../../0MultiFileIdx/man1/kill.1.html">kill</A></B>(1), <B><A HREF="../man2/clone.2.html">clone</A></B>(2), <B><A HREF="../man2/getrlimit.2.html">getrlimit</A></B>(2), <B><A HREF="../man2/kill.2.html">kill</A></B>(2),
<B>pidfd_send_signal</B>(2), <B><A HREF="../man2/restart_syscall.2.html">restart_syscall</A></B>(2), <B>rt_sigqueueinfo</B>(2),
<B><A HREF="../man2/setitimer.2.html">setitimer</A></B>(2), <B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2), <B><A HREF="../man2/sgetmask.2.html">sgetmask</A></B>(2), <B><A HREF="../man2/sigaction.2.html">sigaction</A></B>(2),
<B><A HREF="../man2/sigaltstack.2.html">sigaltstack</A></B>(2), <B><A HREF="../man2/signal.2.html">signal</A></B>(2), <B><A HREF="../man2/signalfd.2.html">signalfd</A></B>(2), <B><A HREF="../man2/sigpending.2.html">sigpending</A></B>(2),
<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2), <B><A HREF="../man2/sigreturn.2.html">sigreturn</A></B>(2), <B><A HREF="../man2/sigsuspend.2.html">sigsuspend</A></B>(2), <B><A HREF="../man2/sigwaitinfo.2.html">sigwaitinfo</A></B>(2),
<B><A HREF="../man3/abort.3.html">abort</A></B>(3), <B><A HREF="../man3/bsd_signal.3.html">bsd_signal</A></B>(3), <B>killpg</B>(3), <B><A HREF="../man3/longjmp.3.html">longjmp</A></B>(3),
<B><A HREF="../man3/pthread_sigqueue.3.html">pthread_sigqueue</A></B>(3), <B><A HREF="../man3/raise.3.html">raise</A></B>(3), <B><A HREF="../man3/sigqueue.3.html">sigqueue</A></B>(3), <B><A HREF="../man3/sigset.3.html">sigset</A></B>(3),
<B><A HREF="../man3/sigsetops.3.html">sigsetops</A></B>(3), <B><A HREF="../man3/sigvec.3.html">sigvec</A></B>(3), <B><A HREF="../man3/sigwait.3.html">sigwait</A></B>(3), <B><A HREF="../man3/strsignal.3.html">strsignal</A></B>(3),
<B><A HREF="../man3/swapcontext.3.html">swapcontext</A></B>(3), <B><A HREF="../man3/sysv_signal.3.html">sysv_signal</A></B>(3), <B><A HREF="../man5/core.5.html">core</A></B>(5), <B><A HREF="../man5/proc.5.html">proc</A></B>(5), <B>nptl</B>(7),
<B><A HREF="../man7/pthreads.7.html">pthreads</A></B>(7), <B><A HREF="../man7/sigevent.7.html">sigevent</A></B>(7)
<A NAME="lbAT">&nbsp;</A>
<H2>この文書について</H2>

この man ページは Linux <I>man-pages</I> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は
<A HREF="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</A> に書かれている。
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">名前</A><DD>
<DT><A HREF="#lbAC">説明</A><DD>
<DL>
<DT><A HREF="#lbAD">シグナル処理方法</A><DD>
<DT><A HREF="#lbAE">シグナルの送信</A><DD>
<DT><A HREF="#lbAF">シグナルが捕捉されるのを待つ</A><DD>
<DT><A HREF="#lbAG">シグナルの同期受信</A><DD>
<DT><A HREF="#lbAH">シグナルマスクと処理待ちシグナル</A><DD>
<DT><A HREF="#lbAI">Execution of signal handlers</A><DD>
<DT><A HREF="#lbAJ">標準シグナル</A><DD>
<DT><A HREF="#lbAK">Queueing and delivery semantics for standard signals</A><DD>
<DT><A HREF="#lbAL">Signal numbering for standard signals</A><DD>
<DT><A HREF="#lbAM">リアルタイムシグナル</A><DD>
<DT><A HREF="#lbAN">シグナルハンドラーによるシステムコールやライブラリ関数への割り込み</A><DD>
<DT><A HREF="#lbAO">一時停止シグナルによるシステムコールやライブラリ関数への割り込み</A><DD>
</DL>
<DT><A HREF="#lbAP">準拠</A><DD>
<DT><A HREF="#lbAQ">注意</A><DD>
<DT><A HREF="#lbAR">バグ</A><DD>
<DT><A HREF="#lbAS">関連項目</A><DD>
<DT><A HREF="#lbAT">この文書について</A><DD>
</DL>
<HR>
This document was created by
<A HREF="../../man/man1/man2html.1.html">man2html</A>,
using the manual pages.<BR>
Time: 03:33:34 GMT, December 05, 2022
</BODY>
</HTML>
