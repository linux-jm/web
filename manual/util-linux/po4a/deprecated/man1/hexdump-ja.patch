--- hexdump.1.orig	2020-11-21 10:14:03.800661091 +0900
+++ hexdump.1	2020-11-21 10:16:53.724666685 +0900
@@ -36,11 +36,38 @@
 .\" This file was generated with po4a. Translate the source file.
 .\"
 .\"*******************************************************************
+.\"
+.\" The original version of this translation was contributed 
+.\" to Linux JM project from NetBSD jman proj.
+.\"
+.\" The copyright for the modified parts of the translation blongs to us
+.\" with Linux JM project.
+.\"
+.\" Japanese Version Copyright for the modified parts (c) 2001-2020 Yuichi SATO
+.\"   and 2020 Yoichi Chonan,
+.\"         all rights reserved.
+.\" Translated Tue 11 Jan 1994
+.\"         by NetBSD jman proj. <jman@spa.is.uec.ac.jp>
+.\" Updated Sun Jan 14 00:49:38 JST 2001
+.\"         by Yuichi SATO <sato@complex.eng.hokudai.ac.jp>
+.\" Updated Sun Mar 24 11:54:42 JST 2002
+.\"         by Yuichi SATO <ysato@h4.dion.ne.jp>
+.\" Updated & Modified (util-linux 2.34) Wed Sep  9 15:42:10 JST 2020
+.\"         by Yuichi SATO <ysato444@ybb.ne.jp>
+.\"         and Yoichi Chonan <cyoichi@maple.ocn.ne.jp>
+.\"
 .TH HEXDUMP 1 "April 2013" util\-linux "User Commands"
 .SH 名前
 hexdump \- ファイルの内容を 16 進数、10 進数、8 進数、ASCII 文字で表示する
 .SH 書式
 \fBhexdump\fP [options]\fI file\fP...
+.SH 読者へのご注意
+これは、util-linux 版の \fBhexdump\fP コマンドのマニュアルである。\fBhexdump\fP
+コマンドの実装には、いくつかの系統がある。御使用のディストリビューションが
+util-linux 版以外の \fBhexdump\fP コマンドを採用している場合は、
+動作やオプションがここで説明しているものとかなり違っているかもしれない。
+そういうときは、英語版しかないかもしれないが、お手元の \fBhexdump\fP
+コマンドに付属するマニュアルに当たってみていただきたい。
 .SH 説明
 \fBhexdump\fP ユーティリティは、指定されたファイルをユーザーが指定したフォーマットで表示するフィルタである。
 ファイルが指定されていない場合は、標準入力を処理の対象にする。
@@ -133,6 +160,19 @@
 で区切られた任意の数のフォーマット単位から構成される。1 つのフォーマット単位は、最大で
 3 個の要素、すなわち、繰り返し回数、バイト数、フォーマットを含んでいる。
 .PP
+.IP "[\fB訳注\fP]"
+各フォーマット文字列は 1 行からなる。フォーマット文字列を複数個指定すると、
+その各々が、同じ 1 つの処理単位 
+(後述の\fIブロック\fRである。「\fB処理されるバイト数\fR」セクションを参照)
+に対して、重ねて適用されることになる
+(すなわち、どのフォーマット文字列もブロックの先頭から適用される)。
+複数のフォーマット文字列を指定するには、\fB\-e\fR
+オプションでは、\fB\-e\fR を複数回使えばよい。\fB\-f\fR
+オプションでは、改行で区切って複数行にする。
+.sp
+フォーマット単位は、「繰り返し回数 / バイト数 "フォーマット"」という書式になる。"フォーマット"
+以外は省略できる。
+.PP
 繰り返し回数は、指定が任意の (訳注: すなわち、省略可能な)
 正の整数であり、デフォルトは 1 である。各フォーマットは繰り返し回数だけ適用される。
 .PP
@@ -234,18 +274,28 @@
 (訳注: カラー指定の実例については、「\fB用例\fP」セクションの
 3 番目の例をご覧になっていただきたい)。
 .PP
-\fB\&_L[color_unit_1,\:color_unit_2,\:...,\:color_unit_n]\fP
+.nf
+\fB\&_L[color_unit_1,color_unit_2,...,color_unit_n]\fP
+.fi
 .PP
 カラー指定単位 (color unit) の完全な書式は以下のとおりである:
 .PP
-\fB[!]COLOR\:[:VALUE]\:[@OFFSET_START[\-END]]\fP
+.nf
+\fB[!]COLOR[:VALUE][@OFFSET_START[\-END]]\fP
+.fi
 .TP 
 \fB!\fP
 条件を否定する。
 注意していただきたいが、あるカラー指定単位について否定することに意味があるのは、
-値/\:文字列と、オフセットの両方を指定したときだけである。
-その場合は、値/\:文字列がそのオフセットにあるものとマッチしなかったときにのみ、
+値/文字列と、オフセットの両方を指定したときだけである。
+その場合は、値/文字列がそのオフセットにあるものとマッチしなかったときにのみ、
 対応する出力文字列がハイライトされることになる。
+.RS
+.IP "[\fB訳注\fP]"
+上で言っているのは、否定は、あるオフセット、または比較的狭いオフセットの範囲に、
+ある値が存在しないことを調べるためのものだということだろう。
+広範囲についてそれをやるのは、色彩を反転させるだけで、否定しないときと事実上同じことになる。
+.RE
 .TP 
 \fBCOLOR\fP
 シェルで使われる 8 種の基本色の 1 つ。
@@ -326,20 +376,20 @@
    "%06.6_ao "  12/1 "%3_u "
    "\et\et" "%_p "
    "\en"
-.nf
+.fi
 .PP
 \-x オプションを実装する:
 .nf
    "%07.7_Ax\en"
    "%07.7_ax  " 8/2 "%04x " "\en"
-.nf
+.fi
 .PP
 MBR ブートシグネチャの例: アドレスをシアンで、オフセット 510 と 511
 にあるバイトの値が 0xAA55 の場合は緑、その他の場合は赤でハイライトする。
 .nf
    "%07.7_Ax_L[cyan]\en"
    "%07.7_ax_L[cyan]  " 8/2 "   %04x_L[green:0xAA55@510\-511,!red:0xAA55@510\-511] " "\en"
-.nf
+.fi
 .SH カラー表示
 空ファイル \fI/etc/terminal\-colors.d/hexdump.disable\fP
 を置くことで、暗黙のカラー表示を無効化できる。
@@ -349,8 +399,72 @@
 \fBhexdump\fP ユーティリティは IEEE Std 1003.2 ("POSIX.2")
 に適合しているはずである。
 .SH 入手方法
-この hexdump コマンドは、util\-linux パッケージの一部であり、
-.UR https://\:www.kernel.org\:/pub\:/linux\:/utils\:/util\-linux/
-Linux Kernel Archive
-.UE
+この hexdump コマンドは、util\-linux パッケージの一部であり、Linux Kernel Archive
+<https://www.kernel.org/pub/linux/utils/util\-linux/>
 から入手できる。
+.SH 翻訳者謝辞
+この man ページの翻訳の最初のバージョンは、NetBSD jman proj
+から寄贈していただいたものだった。また、翻訳にあたっては、FreeBSD
+jpman project <http://www.jp.freebsd.org/man-jp/>
+の翻訳を参考にさせていただいた。両プロジェクトの翻訳者の方々にお礼を申し上げる。
+.SH "おまけ"
+説明がわかりにくかったと思うので、翻訳者の判断で、用例をもう一つ追加して、説明を補足してみる。
+却って混乱が増すようなら、読み飛ばしていただきたい。\fBhexdump -C\fP
+のエミュレーションをしてみよう。次のような内容のファイルを
+hexchar.fmt という名前で作成する。
+.PP
+.nf
+   "%08.8_Ax\en"
+   "%08.8_ax  " 8/1 "%02x " "  " 8/1 "%02x "
+   "  |" "%_p"
+   "|\en"
+.fi
+.PP
+各行がフォーマット文字列であり、「"%08.8_ax\ \ "」 「8/1\ "%02x\ "」
+「"\ \ "」 「"\ \ |"」 「"%_p"」 といった部分がフォーマット単位、
+ダブルクォート (" ") で囲まれた部分がフォーマットである。
+フォーマット単位には、繰り返し回数やバイト数の指定がなく、
+フォーマットしか含まれていないこともある。
+.sp
+入力データは、一定の量ごとに分割されて処理される。その一定の量がブロックだが、
+ブロックの大きさは、フォーマット文字列の中で最大のデータを要求しているものによって決まる。
+上の場合なら、最大のデータを要求しているのは、2 行目であり
+(ほかの行はデータの量を指定していない)、1 バイトが 8 回、さらに 1 バイトが
+8 回繰り返し処理されるわけだから、合計で 16 バイトが要求されていることになる。
+従って、ブロックの大きさは 16 バイトである。言い換えれば、この例では、入力データは
+16 バイトずつ処理されるということだ。
+.sp
+.sp
+各フォーマット文字列は、同一のブロックに対して順番に適用される。
+しかも、それぞれが、そのブロックの先頭に戻って、適用されていく。
+.sp
+1 行目は、「すべての入力データの処理が終わったときに、最後から 
+1 つ先のオフセットを表示せよ」ということだから、ブロックのデータの処理とは関係がない。
+.sp
+2 行目の「"%08.8_ax\ \ " 8/1 "%02x\ " "\ \ " 8/1 "%02x\ "」の意味はこうである。
+「まず、次に表示するバイトのオフセットを 8 桁の
+16 進数で、先頭を 0 で埋めて表示し、空白を 2 個続ける。それから、1 バイトずつ
+8 個 のデータを、2 桁の 16 進数で後ろに空白を付けて
+(つまり、空白で区切って) 表示し、空白を 2 個置いて、さらに 1 バイトずつ
+8 個のデータを、2 桁の 16 進数で空白で区切って表示せよ」。
+.sp
+3 行目の「"\ \ |" "%_p"」が指示しているのは、「2
+行目による出力にすぐ続けて、同じ出力行にまず '\ \ |'
+という文字列を表示し、それから、2 行目が処理したのと同じブロックに対して
+1 バイトずつ '_p' 変換をして (つまり、ASCII 文字で) 出力せよ」ということだ。
+3 行目は、「最後のフォーマット単位が、何バイトかを解釈・変換するものであり、
+しかも繰り返し回数が指定されていない」ので、ブロック全体の処理が済むまで、
+最後のフォーマット単位 "%_p" による処理が繰り返されることになる。
+.sp
+仮に、3 行目と 4 行目を 1 つにし、3 行目を「"\ \ |" "%_p" "|\en"」という形にすると、
+フォーマット文字列の「最後のフォーマット単位が、
+何バイトかを解釈・変換するもの」ではなくなるので、
+自動的な繰り返しの増加が行われないことになる。それ故、両者は別の行になっている。
+.sp
+4 行目は、データに対する処理は何も指定せず、「3 行目による出力のすぐ後ろに '|'
+という文字を書き出してから改行せよ」とだけ指示している。
+.sp
+このすべてが終わると、次のブロックに移って、同じ処理を繰り返していく。
+.sp
+結果として、\fBhexdump -f hexchar.fmt sample.txt\fP を実行すれば、
+\fBhexdump -C sample.txt\fP と同じ結果が得られるはずである。
