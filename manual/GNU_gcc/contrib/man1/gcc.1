.\" %FreeBSD: src/contrib/gcc/gcc.1,v 1.15.2.1 2001/04/10 19:23:09 obrien Exp %
.\" Copyright (c) 1991, 1992, 1993, 1994 Free Software Foundation    -*-Text-*-
.\" See section COPYING for conditions for redistribution
.\"
.\" $FreeBSD: doc/ja_JP.eucJP/man/man1/gcc.1,v 1.10 2001/05/14 01:07:23 horikawa Exp $
.\" Set up \*(lq, \*(rq if -man hasn't already set it up.
.if @@\*(lq@ \{\
.      ds lq "
.      if t .ds lq ``
.      if !@@\(lq@ .ds lq "\(lq
.\}
.if @@\*(rq@ \{\
.      ds rq "
.      if t .ds rq ''
.      if !@@\(rq@ .ds rq "\(rq
.\}
.de Id
.ds Rv \\$3
.ds Dt \\$4
..
.de Sp
.if n .sp
.if t .sp 0.4
..
.Id %Id: gcc.1,v 1.9 1998/12/16 20:55:57 law Exp %
.TH GCC 1 "\*(Dt" "GNU Tools" "GNU Tools"
.SH 名称
gcc, g++ \- GNU プロジェクト C および C++ コンパイラ (gcc-2.95.3)
.SH 書式
.B gcc
.RI "[ " option " | " filename " ].\|.\|."
.br
.SH 注意
このマニュアルに書かれた情報は GNU C コンパイラの完全な
ドキュメンテーションからの抜粋であり、オプションの意味の記述にとどめます。
.PP
このマニュアルはボランティアのメンテナンスが行なわれた時にのみ更新され
るもので、常に最新の情報を示しているわけではありません。
もしこのマニュアルと実際のソフトウェアの間に矛盾点があれば、
正式なドキュメントである Info ファイルのほうを参照して下さい。
.PP
このマニュアル中の古い記述が重大な混乱や不具合をきたすことになれば、
このマニュアルページの配布は中止します。
GNU CCのメンテナンス作業の都合上、
Info ファイルを更新した時にマニュアルページも併せて更新することは
できません。マニュアルページは時代遅れであり、
これに時間をかけるべきではないと GNU プロジェクトでは考えています。
.PP
完全な最新のドキュメンテーションが必要な場合は、Info ファイルの`\|\c
.B gcc\c
\&\|' またはマニュアルの
.I
Using and Porting GNU CC (for version 2.0)\c
\& を参照して下さい。この双方は Texinfo のソースファイル
.B gcc.texinfo
から生成されます。
.SH 解説
C と C++ のコンパイラは統合されています。どちらの場合も、入力ファイル
は、プリプロセス、コンパイル、アセンブル、リンクの 4 つの処理ステージの
うちの 1 つ以上のステージを踏んで処理されます。
ソースファイル名の拡張子によってソースの言語を識別しますが、
デフォルトの動作は、どちらの名前でコンパイラを使うかに依存しています:
.TP
.B gcc
プリプロセス済みの (\c
.B .i\c
\&) ファイルを C のファイルと仮定し、C スタイルのリンクを行います。
.TP
.B g++
プリプロセス済みの(\c
.B .i\c
\&) ファイルを C++ のファイルと仮定し、C++ スタイルのリンクを行います。
.PP
ソースファイル名の拡張子は、その言語が何であるかと、どのような処理が行われる
べきかを示します:
.Sp
.nf
.ta \w'\fB.cxx\fP  'u
\&\fB.c\fP     C言語ソースです。プリプロセッサ、コンパイラ、アセンブラにかけられます。
\&\fB.C\fP     C++言語ソースです。プリプロセッサ、コンパイラ、アセンブラにかけられます。
\&\fB.cc\fP    C++言語ソースです。プリプロセッサ、コンパイラ、アセンブラにかけられます。
\&\fB.cxx\fP   C++言語ソースです。プリプロセッサ、コンパイラ、アセンブラにかけられます。
\&\fB.m\fP     Objective-C 言語ソースです。プリプロセッサ、コンパイラ、アセンブラにかけられます。
\&\fB.i\fP     プリプロセッサにかけられたC言語ソースです。コンパイラ、アセンブラにかけられます。
\&\fB.ii\fP    プリプロセッサにかけられたC++言語ソースです。コンパイラ、アセンブラにかけられます。
\&\fB.s\fP     アセンブリ言語ソースです。アセンブラにかけられます。
\&\fB.S\fP     アセンブリ言語ソースです。プリプロセッサ、アセンブラにかけられます。
\&\fB.h\fP     プリプロセッサファイルです。通常はコマンドラインには現れません。
.Sp
.fi
その他の拡張子を持つファイルはリンカに渡されます。以下のものがあります。
.Sp
.nf
\&\fB.o\fP     オブジェクトファイルです。
\&\fB.a\fP     アーカイブファイルです。
.br
.fi
.Sp
リンクは、オプション
.BR \-c ,
.BR \-S ,
.B \-E
を指定して抑制しないかぎり(もしくはコンパイルエラーによってすべての処理が中断
しないかぎり)、常に最終ステージで実行されます。
リンクのステージにおいては、ソースファイルに対応した全ての
.B .o
ファイルと、
.B \-l
で指定したライブラリと、認識されなかったファイル名 (名前に
.B .o
のついたオブジェクトファイルや
.B .a
のついたアーカイブを含む) は、
コマンドラインに並べられた順番でリンカに渡されます。
.SH オプション
オプションは分割されていなければなりません。すなわち `\|\c
.B \-dr\c
\&\|' は `\|\c
.B \-d \-r
\&\|'とは異なった扱いを受けます。
.PP
ほとんどの `\|\c
.B \-f\c
\&\|' と `\|\c
.B \-W\c
\&\|' 形式のオプションには、
.BI \-f name
と
.BI \-fno\- name\c
\& (または
.BI \-W name
と
.BI \-Wno\- name\c
\&) の形式の、対照的な表現があります。ここではデフォルトでない形式の
みを示します。
.PP
すべてのオプションを種類別に分けてまとめました。詳しい解説は
以下の節で行ないます。
.hy 0
.SH FreeBSD 固有のオプション
.TP
.BI "\-pthread"
スレッド化ユーザプロセスに libc の代りに libc_r をリンクします。
スレッド化ユーザプロセスにリンクされるオブジェクトは -D_THREAD_SAFE 付きで
コンパイルする必要があります。
.TP
.BI "\-kthread"
スレッド化カーネルプロセスに libc に加えて libpthread をリンクします。
スレッド化カーネルプロセスにリンクされるオブジェクトは -D_THREAD_SAFE 付きで
コンパイルする必要があります。
.na
.TP
.B 全体的なオプション
.br
\-c
\-S
\-E
.RI "\-o " file
\-pipe
\-v
.RI "\-x " language
.TP
.B 言語オプション
\-ansi
\-fall\-virtual
\-fcond\-mismatch
\-fdollars\-in\-identifiers
\-fenum\-int\-equiv
\-fexternal\-templates
\-fno\-asm
\-fno\-builtin
\-fhosted
\-fno\-hosted
\-ffreestanding
\-fno\-freestanding
\-fno\-strict\-prototype
\-fsigned\-bitfields
\-fsigned\-char
\-fthis\-is\-variable
\-funsigned\-bitfields
\-funsigned\-char
\-fwritable\-strings
\-traditional
\-traditional\-cpp
\-trigraphs
.TP
.B 警告オプション
\-fsyntax\-only
\-pedantic
\-pedantic\-errors
\-w
\-W
\-Wall
\-Waggregate\-return
\-Wcast\-align
\-Wcast\-qual
\-Wchar\-subscript
\-Wcomment
\-Wconversion
\-Wenum\-clash
\-Werror
\-Wformat
.RI \-Wid\-clash\- len
\-Wimplicit
\-Wimplicit\-int
\-Wimplicit\-function\-declaration
\-Winline
\-Wlong\-long
\-Wmain
\-Wmissing\-prototypes
\-Wmissing\-declarations
\-Wnested\-externs
\-Wno\-import
\-Wparentheses
\-Wpointer\-arith
\-Wredundant\-decls
\-Wreturn\-type
\-Wshadow
\-Wstrict\-prototypes
\-Wswitch
\-Wtemplate\-debugging
\-Wtraditional
\-Wtrigraphs
\-Wuninitialized
\-Wunused
\-Wwrite\-strings
.TP
.B デバッグオプション
\-a
.RI \-d letters
\-fpretend\-float
\-g
.RI \-g level
\-gcoff
\-gxcoff
\-gxcoff+
\-gdwarf
\-gdwarf+
\-gstabs
\-gstabs+
\-ggdb
\-p
\-pg
\-save\-temps
.RI \-print\-file\-name= library
\-print\-libgcc\-file\-name
.TP
.B 最適化オプション
\-fcaller\-saves
\-fcse\-follow\-jumps
\-fcse\-skip\-blocks
\-fdelayed\-branch
\-felide\-constructors
\-fexpensive\-optimizations
\-ffast\-math
\-ffloat\-store
\-fforce\-addr
\-fforce\-mem
\-finline\-functions
\-fkeep\-inline\-functions
\-fmemoize\-lookups
\-fno\-default\-inline
\-fno\-defer\-pop
\-fno\-function\-cse
\-fno\-inline
\-fno\-peephole
\-fomit\-frame\-pointer
\-frerun\-cse\-after\-loop
\-fschedule\-insns
\-fschedule\-insns2
\-fstrength\-reduce
\-fthread\-jumps
\-funroll\-all\-loops
\-funroll\-loops
\-O
\-O2
\-O3
\-O0
\-Os
.TP
.B プリプロセッサオプション
.RI \-A assertion
\-C
\-dD
\-dM
\-dN
.RI \-D macro [\|= defn \|]
\-E
\-H
.RI "\-idirafter " dir
.RI "\-include " file
.RI "\-imacros " file
.RI "\-iprefix " file
.RI "\-iwithprefix " dir
\-M
\-MD
\-MM
\-MMD
\-nostdinc
\-P
.RI \-U macro
\-undef
.TP
.B アセンブラオプション
.RI \-Wa, option
.TP
.B リンカオプション
.RI \-l library
\-nostartfiles
\-nostdlib
\-static
\-shared
\-symbolic
.RI "\-Xlinker\ " option
.RI \-Wl, option
.RI "\-u " symbol
.TP
.B ディレクトリオプション
.RI \-B prefix
.RI \-I dir
\-I\-
.RI \-L dir
.TP
.B ターゲットオプション
.RI "\-b  " machine
.RI "\-V " version
.TP
.B コンフィギュレーション依存オプション
.I M680x0\ オプション
.br
\-m68000
\-m68020
\-m68020\-40
\-m68030
\-m68040
\-m68881
\-mbitfield
\-mc68000
\-mc68020
\-mfpa
\-mnobitfield
\-mrtd
\-mshort
\-msoft\-float
.Sp
.I VAX オプション
.br
\-mg
\-mgnu
\-munix
.Sp
.I SPARC オプション
.br
\-mepilogue
\-mfpu
\-mhard\-float
\-mno\-fpu
\-mno\-epilogue
\-msoft\-float
\-msparclite
\-mv8
\-msupersparc
\-mcypress
.Sp
.I Convex オプション
.br
\-margcount
\-mc1
\-mc2
\-mnoargcount
.Sp
.I AMD29K オプション
.br
\-m29000
\-m29050
\-mbw
\-mdw
\-mkernel\-registers
\-mlarge
\-mnbw
\-mnodw
\-msmall
\-mstack\-check
\-muser\-registers
.Sp
.I M88K オプション
.br
\-m88000
\-m88100
\-m88110
\-mbig\-pic
\-mcheck\-zero\-division
\-mhandle\-large\-shift
\-midentify\-revision
\-mno\-check\-zero\-division
\-mno\-ocs\-debug\-info
\-mno\-ocs\-frame\-position
\-mno\-optimize\-arg\-area
\-mno\-serialize\-volatile
\-mno\-underscores
\-mocs\-debug\-info
\-mocs\-frame\-position
\-moptimize\-arg\-area
\-mserialize\-volatile
.RI \-mshort\-data\- num
\-msvr3
\-msvr4
\-mtrap\-large\-shift
\-muse\-div\-instruction
\-mversion\-03.00
\-mwarn\-passed\-structs
.Sp
.I RS6000 オプション
.br
\-mfp\-in\-toc
\-mno\-fop\-in\-toc
.Sp
.I RT オプション
.br
\-mcall\-lib\-mul
\-mfp\-arg\-in\-fpregs
\-mfp\-arg\-in\-gregs
\-mfull\-fp\-blocks
\-mhc\-struct\-return
\-min\-line\-mul
\-mminimum\-fp\-blocks
\-mnohc\-struct\-return
.Sp
.I MIPS オプション
.br
\-mcpu=\fIcpu type\fP
\-mips2
\-mips3
\-mint64
\-mlong64
\-mlonglong128
\-mmips\-as
\-mgas
\-mrnames
\-mno\-rnames
\-mgpopt
\-mno\-gpopt
\-mstats
\-mno\-stats
\-mmemcpy
\-mno\-memcpy
\-mno\-mips\-tfile
\-mmips\-tfile
\-msoft\-float
\-mhard\-float
\-mabicalls
\-mno\-abicalls
\-mhalf\-pic
\-mno\-half\-pic
\-G \fInum\fP
\-nocpp
.Sp
.I i386 オプション
.br
\-m386
\-m486
\-mpentium
\-mpentiumpro
\-mno\-486
\-mcpu=\fIcpu type\fP
\-march=\fIcpu type\fP
\-msoft\-float
\-mrtd
\-mregparm
\-msvr3\-shlib
\-mno\-ieee\-fp
\-mno\-fp\-ret\-in\-387
\-mfancy\-math\-387
\-mno\-wide\-multiply
\-mdebug\-addr
\-mno\-move
\-mprofiler\-epilogue
\-reg\-alloc=LIST
.Sp
.I HPPA オプション
.br
\-mpa\-risc\-1\-0
\-mpa\-risc\-1\-1
\-mkernel
\-mshared\-libs
\-mno\-shared\-libs
\-mlong\-calls
\-mdisable\-fpregs
\-mdisable\-indexing
\-mtrailing\-colon
.Sp
.I i960 オプション
.br
\-m\fIcpu-type\fP
\-mnumerics
\-msoft\-float
\-mleaf\-procedures
\-mno\-leaf\-procedures
\-mtail\-call
\-mno\-tail\-call
\-mcomplex\-addr
\-mno\-complex\-addr
\-mcode\-align
\-mno\-code\-align
\-mic\-compat
\-mic2.0\-compat
\-mic3.0\-compat
\-masm\-compat
\-mintel\-asm
\-mstrict\-align
\-mno\-strict\-align
\-mold\-align
\-mno\-old\-align
.Sp
.I DEC Alpha オプション
.br
\-mfp\-regs
\-mno\-fp\-regs
\-mno\-soft\-float
\-msoft\-float
.Sp
.I System V オプション
.br
\-G
\-Qy
\-Qn
.RI \-YP, paths
.RI \-Ym, dir
.TP
.B コード生成オプション
.RI \-fcall\-saved\- reg
.RI \-fcall\-used\- reg
.RI \-ffixed\- reg
\-finhibit\-size\-directive
\-fnonnull\-objects
\-fno\-common
\-fno\-ident
\-fno\-gnu\-linker
\-fpcc\-struct\-return
\-fpic
\-fPIC
\-freg\-struct\-return
\-fshared\-data
\-fshort\-enums
\-fshort\-double
\-fvolatile
\-fvolatile\-global
\-fverbose\-asm
.ad b
.hy 1
.SH 全体的なオプション
.TP
.BI "\-x " "language"
このオプションに続く入力ファイルの言語を
.I language\c
\& であると明示的に指定します
(拡張子に基づくデフォルトの選択よりも優先されます)。このオプションは、
次の `\|\c
.B \-x\c
\&\|' オプションが出てくるまで、後続する全ての入力ファイルに対して
適用されます。\c
.I language\c
\& としては、
`\|\c
.B c\c
\&\|', `\|\c
.B objective\-c\c
\&\|', `\|\c
.B c\-header\c
\&\|', `\|\c
.B c++\c
\&\|',
`\|\c
.B cpp\-output\c
\&\|', `\|\c
.B assembler\c
\&\|', `\|\c
.B assembler\-with\-cpp\c
\&\|' を指定することが可能です。
.TP
.B \-x none
言語の指定を解除します。このオプションのあとに続くファイルは、それらの拡張子に
基づいて (あたかも何の `\|\c
.B \-x\c
\&\|'
オプションも使用されたことがないように) 処理されます。
.PP
もし、4 つのステージ (プリプロセス、コンパイル、アセンブル、リンク) の
うちの一部のみが必要な場合は、
`\|\c
.B \-x\c
\&\|' オプション (またはファイル名の拡張子) を使用して \c
.B gcc\c
\& に対してどのステージから開始するかを伝え、さらに
`\|\c
.B \-c\c
\&\|', `\|\c
.B \-S\c
\&\|', `\|\c
.B \-E\c
\&\|' のオプションのうちのどれかを使用して
.B gcc\c
\& に対してどこで処理を停止させるかを指定します。ここで、
いくつかの組み合わせ (例えば
`\|\c
.B \-x cpp\-output \-E\c
\&\|') は \c
.B gcc\c
\& に対して何の動作も行なわないように指定することになることに注意してください。
.TP
.B \-c
ソースファイルを、コンパイルまたはアセンブルまではしますが、リンクはしません。
コンパイラの出力は、それぞれのソースファイルに対応したオブジェクトファイル
となります。
.Sp
デフォルトでは、GCC はオブジェクトファイルのファイル名として、
ソースファイルの拡張子
`\|\c
.B .c\c
\&\|', `\|\c
.B .i\c
\&\|', `\|\c
.B .s\c
\&\|' 等を `\|\c
.B .o\c
\&\|' で置き換えたものを使用します。
.B \-o\c
\& オプションを使用することによって、他の名前を指定することも可能です。
.Sp
GCC は
.B \-c
オプションを使用した場合は、理解できない入力ファイル (コンパイルやアセンブル
を必要としないファイル) を無視します。
.TP
.B \-S
コンパイルが終った所で処理を停止し、アセンブルは行いません。
アセンブラコードではない入力ファイルが指
定された場合は、出力はアセンブラコードのファイルになります。
.Sp
デフォルトでは、GCC はアセンブラファイルのファイル名として、
ソースファイルの拡張子
`\|\c
.B .c\c
\&\|', `\|\c
.B .i\c
\&\|' 等を `\|\c
.B .s\c
\&\|' で置き換えたものを使用します。
.B \-o\c
\& オプションを使用することによって、他の名前を指定することも可能です。
.Sp
GCC はコンパイルを必要としない入力ファイルを全て無視します。
.TP
.B \-E
プリプロセス処理が終了したところで停止します。コンパイルはしません。
出力はプリプロセス済みのソースコードであり、標準出力へと送られます。
.Sp
GCC はプリプロセスを必要としない入力ファイルを全て無視します。
.TP
.BI "\-o " file
出力先を \c
.I file\c
\& に指定します。このオプションは GCC が実行可能ファイル、
オブジェクトファイル、アセンブラファイル、プリプロセス済み C コードなどの、
いかなる種類の出力を行なう場合にも適用可能です。
.Sp
出力ファイルは 1 つしか指定できないため、
`\|\c
.B \-o\c
\&\|' を複数の入力ファイルをコンパイルする際に使用することは、実行ファ
イルを出力する時以外は無意味です。
.Sp
`\|\c
.B \-o\c
\&\|'オプションを指定しなかった場合のデフォルトは、実行ファイルを作る場
合は `\|\c
.B a.out\c
\&\|' という名前であり、`\|\c
.I source\c
.B \&.\c
.I suffix\c
\&\c
\&\|' の形式のファイル名を持ったソースファイルのオブジェクトファイルは
`\|\c
.I source\c
.B \&.o\c
\&\|' であり、アセンブラのファイルは `\|\c
.I source\c
.B \&.s\c
\&\|' です。
プリプロセス済みの C 言語は、全て標準出力に送られます。
.TP
.B \-v
(標準エラー出力に対して) コンパイルの各ステージで実行されるコマンドを
表示します。コンパイラドライバ、プリプロセッサおよび本来のコンパイラの
各バージョン番号も表示します。
.TP
.B -pipe
コンパイル時のステージの間のデータの受け渡しに、テンポラリファイルではなく
パイプを使用します。いくつかのシステムではアセンブラがパイプからの入力を受け
付けることができないために、このオプションを指定すると失敗します。
GNU アセンブラでは問題なく使用できます。
.PP
.SH 言語オプション
.TP
以下のオプションは、コンパイラが受け付ける C の方言に関する制御を行ないます:
.TP
.B \-ansi
全ての ANSI 標準の C プログラムをサポートします。
.Sp
このオプションは、GNU C が持つ ANSI C との非互換な機能を全て排除します。
例えば、\c
.B asm\c
\&, \c
.B inline\c
\&, \c
.B typeof
などのキーワードや、\c
.B unix\c
\& や \c
.B vax
などの現在使用しているシステムを規定する定義済みマクロなどが抑制されます。
さらに、好ましくなくかつほとんど使用されない ANSI のトライグラフの機能を使
用可能とし、さらに `\|\c
.B $\c
\&\|' を識別子の一部として使用できないようにします。
.Sp
代替キーワードである\c
.B _\|_asm_\|_\c
\&, \c
.B _\|_extension_\|_\c
\&,
.B _\|_inline_\|_\c
\&, \c
.B _\|_typeof_\|_\c
\& は、
`\|\c
.B \-ansi\c
\&\|' が指定された場合でも使用することが可能です。もちろん、
これらを ANSI C プログラムで使用することが望ましくないのは当然ですが、`\|\c
.B \-ansi\c
\&\|' をつけてコンパイルされる場合でも、インクルードされるヘッダファイル中に
これらが記述できるということは有用です。
\c
.B _\|_unix_\|_\c
\& や \c
.B _\|_vax_\|_\c
\& などの代替定義済みマクロは、
`\|\c
.B \-ansi\c
\&\|' を指定する場合でも指定しない場合でも、利用可能となっています。
.Sp
`\|\c
.B \-ansi\c
\&\|' オプションは、ANSI 準拠でないプログラムを不必要に拒否することは
ありません。もしこのような動作を行なわせたい場合には`\|\c
.B \-ansi\c
\&\|'に加えて\c
.B \-pedantic\c
\&\|' オプションを指定する必要があります。
.Sp
プリプロセッサ定義済みマクロ \c
.B _\|_STRICT_ANSI_\|_\c
\& が `\|\c
.B \-ansi\c
\&\|'
オプションを使用した際には定義されます。いくつかのヘッダファイルは、この
マクロを識別して、ANSI 標準が望まない関数やマクロの定義を抑制します。
これは、
それらの関数やマクロと同じ名前を別の目的で使用するプログラム
を混乱させないようにするためです。
.TP
.B \-fno\-asm
\c
.B asm\c
\&, \c
.B inline\c
\&, \c
.B typeof\c
\& をキーワードとして解釈しません。
これらの単語は識別子として解釈されるようになります。これらの代用として
\c
.B _\|_asm_\|_\c
\&, \c
.B _\|_inline_\|_\c
\&, \c
.B _\|_typeof_\|_\c
\& が使用できます。
`\|\c
.B \-ansi\c
\&\|' を指定すると、暗黙のうちに `\|\c
.B \-fno\-asm\c
\&\|' を指定したものとみなされます。
.TP
.B \-fno\-builtin
ビルトイン関数のうち、2 つのアンダースコアで始まるもの以外を認識しなくなり
ます。現在、この指定は\c
.B _exit\c
\&,
.B abort\c
\&, \c
.B abs\c
\&, \c
.B alloca\c
\&, \c
.B cos\c
\&, \c
.B exit\c
\&,
.B fabs\c
\&, \c
.B labs\c
\&, \c
.B memcmp\c
\&, \c
.B memcpy\c
\&, \c
.B sin\c
\&,
.B sqrt\c
\&, \c
.B strcmp\c
\&, \c
.B strcpy\c
\&, \c
.B strlen\c
\& の関数に影響を及ぼします。
.Sp
`\|\c
.B \-ansi\c
\&\|' オプションを指定すると、\c
.B alloca\c
\& と \c
.B _exit\c
\& はビルトイン関数として扱われなくなります。
.TP
.B \-fhosted
ホスト実行環境 (hosted environment) 用にコンパイルを行います。
これにより、`\|\c
.B \-fbuiltin\c
\&\|' オプションが有効になり、また、不審な
.B main\c
\& 宣言に対して警告を発するようになります。
.TP
.B \-ffreestanding
フリースタンディング実行環境 (freestanding environment) 用に
コンパイルを行います。
これにより、`\|\c
.B \-fno-builtin\c
\&\|' オプションが有効になり、また、
.B main\c
\& に特別な条件は不要とみなします。
.TP
.B \-fno\-strict\-prototype
`\|\c
.B int foo
();\c
\&\|' のような、引数を指定しない関数宣言を、C 言語のように引数の数や
型について何の仮定もしないという扱いにします (C++ のみ)。通常はこのよう
な宣言は、C++ では \c
.B foo\c
\& という関数が 1 つも引数をとらないことを意味します。
.TP
.B \-trigraphs
ANSI C のトライグラフを使用可能とします。`\|\c
.B \-ansi\c
\&\|' オプションを指定すると、暗黙のうちに `\|\c
.B \-trigraphs\c
\&\|' を指定したものとみなされます。
.TP
.B \-traditional
伝統的な C コンパイラのいくつかの特徴をサポートします。詳しくは GNU C の
マニュアルを参照してください。以前はここにそのリストの複製を載せていましたが、
それらが完全に時代遅れになった時に我々に文句が来ないように削除してしまいま
した。
.Sp
しかし、C++ のプログラムだけについて (C ではありません) 特記しておくこと
が 1 つあります。
`\|\c
.B \-traditional\c
\&\|' オプションは C++ に対して 1 つだけ特別な効果を持ちます。それは、
.B this
への代入を許可するというものです。これは `\|\c
.B \-fthis\-is\-variable\c
\&\|'オプションの指定が及ぼす効果と同一のものです。
.TP
.B \-traditional\-cpp
伝統的な C プリプロセッサのいくつかの特徴をサポートします。これは上に挙
げた中で特にプリプロセッサに関係したものを含みますが、
`\|\c
.B \-traditional\c
\&\|' の指定によって引き起こされる以外の効果を及ぼすことはありません。
.TP
.B \-fdollars\-in\-identifiers
識別子中の `\|\c
.B $\c
\&\|' の使用を許可します (C++ のみ)。
`\|\c
.B \-fno\-dollars\-in\-identifiers\c
\&\|' を使用することによって、明示的に
`\|\c
.B $\c
\&\|'の使用を禁止することも可能です。(GNU C++ では、デフォルトで `\|\c
.B $\c
\&\|' を許可しているシステムと禁止しているシステムがあります)。
.TP
.B \-fenum\-int\-equiv
\c
.B int\c
\& から列挙型への暗黙の変換を許可します (C++ のみ)。通常は GNU C++ は \c
.B enum\c
\& から \c
.B int\c
\& への変換は許可していますが、
逆は許していません。
.TP
.B \-fexternal\-templates
テンプレート関数について、その関数が定義された場所にのみ単一のコピー
を生成することによって、テンプレート宣言に対してより小さなコードを生成
します (C++ のみ)。このオプションを使用して正しいコードを得るためには、
テンプレートを使用する全てのファイルにおいて、`\|\c
.B #pragma implementation\c
\&\|' (定義) または
`\|\c
.B #pragma interface\c
\&\|' (宣言) を記述しておく必要があります。

`\|\c
.B \-fexternal\-templates\c
\&\|' を指定してコンパイルを行なう場合には、全てのテンプレートの
実体は external となります。全ての使用される実体はインプリメンテーション
ファイル中にまとめて記述しておかなければなりません。これはその必要とされ
る実体に対応した \c
.B typedef\c
\& 宣言を行なうことによって実現できます。
逆に、デフォルトのオプション
`\|\c
.B \-fno\-external\-templates\c
\&\|' でコンパイルした場合には全てのテンプレートの実体は internal と
なります。
.TP
.B \-fall\-virtual
可能な限り全てのメンバ関数を暗黙のうちに仮想関数として扱います。
全てのメンバ関数 (コンストラクタと
.B new
,
.B delete
メンバ演算子を除きます) は、出現した時点でそのクラスの仮想関数とし
て扱われます。
.Sp
これは、これらのメンバ関数への全ての呼び出しが仮想関数のための内部
テーブルを参照して間接的に決定されるということを意味しません。特定の状況
においては、コンパイラは与えられた仮想関数への呼び出しを直接決定できます。
このような場合にはその関数呼び出しは常に直接呼び出しとなります。
.TP
.B \-fcond\-mismatch
条件演算子の第 2, 第 3 引数の型が異なる記述を許します。このような式の型は void
となります。
.TP
.B \-fthis\-is\-variable
\c
.B this\c
\& への代入を許可します (C++ のみ)。ユーザ定義による記憶管理が可
能となった現在では、
`\|\c
.B this\c
\&\|' への代入は時代遅れのものとなりました。従ってデフォルトでは、クラスの
メンバ関数からの \c
.B this\c
\& への代入は不当なものとして扱われています。しかし、後方互換性のために、
`\|\c
.B \-fthis-is-variable\c
\&\|' を指定することによってこの効果を得ることができます。
.TP
.B \-funsigned\-char
\c
.B char\c
\& 型を \c
.B unsigned char\c
\& のように符号無しとして扱います。
.Sp
それぞれのマシンには
\c
.B char\c
\& がどちらであるべきかというデフォルトがあります。
デフォルトで \c
.B unsigned char\c
\& であることもあれば、デフォルトで
.B signed char\c
\& であることもあります。
.Sp
理想的には、可搬性のあるプログラムは、オブジェクトの符号の有無に依
存する記述を行なう場合には常に \c
.B signed char\c
\&、もしくは
.B unsigned char\c
\& を使用すべきです。
しかし実際には多くのプログラムが単なる \c
.B char\c
\& を用いて記述されており、さらにそのプログラムを記述した
環境に依存して、符号付きである、あるいは符号無しであるという暗黙の仮定が
行なわれています。このオプション、あるいはこの逆のオプションは、デフォル
トと逆の動作を行なわせることにより、これらのプログラムを正しく動作させ
ることを可能にします。
.Sp
\c
.B char\c
\& 型は常に
.B signed char\c
\& あるいは \c
.B unsigned char\c
\& とは区別された型として扱われます。常にそれらの振舞いがそのどち
らかと全く同じであるということに関わらず、このような扱いを行います。
.TP
.B \-fsigned\-char
\c
.B char\c
\& 型を \c
.B signed char\c
\& 型のように符号付きとして扱います。
.Sp
ただし、このオプションは `\|\c
.B \-fno\-unsigned\-char\c
\&\|' と等価です。これは `\|\c
.B \-funsigned\-char\c
\&\|'の否定形です。同様に
`\|\c
.B \-fno\-signed\-char\c
\&\|' は `\|\c
.B \-funsigned\-char\c
\&\|' と等価です。
.TP
.B \-fsigned\-bitfields
.TP
.B \-funsigned\-bitfields
.TP
.B \-fno\-signed\-bitfields
.TP
.B \-fno\-unsigned\-bitfields
これらのオプションは、明示的に
`\|\c
.B signed\c
\&\|' または `\|\c
.B unsigned\c
\&\|' の指定が行なわれていないビットフィールドに対して、符号つきであるかある
いは符号なしであるかを制御します。デフォルトではこのようなビットフィール
ドは符号つきとなっています。なぜなら、
.B int\c
\& のような基本的な型は符号つきであるという点で、整合性がとれるからです。
.Sp
ただし、`\|\c
.B \-traditional\c
\&\|' を指定した場合は、ビットフィールドは常に全て符号無しであるとされます。
.TP
.B \-fwritable\-strings
文字列定数を書き込み可能なデータセグメントに配置し、同内容の文字列を 1
つの共有オブジェクトにする処理を行いません。これは、文字定数に書き込む
ことができることを仮定した昔のプログラムとの互換性をとるために提供され
ています。`\|\c
.B \-traditional\c
\&\|' オプションも同様の効果を含みます。
.Sp
文字定数に書き込むという考えは非常によくない考えです。\*(lq定数\*(rq
はまさに定数であり、変化すべきではありません。
.PP
.SH プリプロセッサオプション
これらのオプションは C プリプロセッサを制御します。
各 C ソースファイルは、実際にコンパイルする前に、C プリプロセッサに
かけられます。
.PP
`\|\c
.B \-E\c
\&\|' オプションを使用すると、GCC はプリプロセス以外の処理を行いません。
以下に示すオプションのうちのいくつかは、`\|\c
.B \-E\c
\&\|' と同時に使用された時のみ意味をもちます。なぜならば、これらのオプション
によって、実際のコンパイルには不適当なプリプロセッサ出力が生成されるためです。
.TP
.BI "\-include " "file"
\c
.I file\c
\& を、通常の入力ファイルが処理される前に処理します。結果的に \c
.I file\c
\& に含まれる内容は、一番最初にコンパイルされることになります。コマンドラ
インに指定されたすべての `\|\c
.B \-D\c
\&\|'
や `\|\c
.B \-U\c
\&\|' オプションは、その記述された順番に関わらず常に `\|\c
.B \-include \c
.I file\c
\&\c
\&\|' が処理される前に処理されます。全ての `\|\c
.B \-include\c
\&\|' や `\|\c
.B \-imacros\c
\&\|' オプションは、それらが記述された順番通りに処理されます。
.TP
.BI "\-imacros " file
通常の入力ファイルを処理する前に\c
.I file\c
\& を入力として処理しますが、その結果の出力を捨てます。
.I file\c
\& によって生成された出力は捨てられるため、`\|\c
.B \-imacros \c
.I file\c
\&\c
\&\|' の処理結果の影響は、\c
.I file\c
\& 中に記述されたマクロがメインの入力ファイル中で使用可能になることだけです。
プリプロセッサは、`\|\c
.B \-imacros \c
.I file\c
\&\|' が記述された順番に関わらず、これを処理する前に、
コマンドラインから与えられた全ての `\|\c
.B \-D\c
\&\|' や `\|\c
.B \-U\c
\&\|' オプションを評価します。全ての `\|\c
.B \-include\c
\&\|' および `\|\c
.B \-imacros\c
\&\|'
オプションは、それらが記述された順番通りに処理されます。
.TP
.BI "\-idirafter " "dir"
ディレクトリ \c
.I dir\c
\& を第 2 インクルードパスに加えます。第 2 インクルードパス中のディレクトリは、
メインインクルードパス (オプション
`\|\c
.B \-I\c
\&\|' によって追加されます) 中にヘッダファイルを探した結果発見できな
かった場合に検索されます。
.TP
.BI "\-iprefix " "prefix"
\c
.I prefix\c
\& を、その後に続く `\|\c
.B \-iwithprefix\c
\&\|'
オプション用のプレフィックスとして使用します。
.TP
.BI "\-iwithprefix " "dir"
ディレクトリを第 2 インクルードパスに追加します。ディレクトリ名は \c
.I prefix\c
\& と \c
.I dir\c
\& を連結することによって得られます。ここで \c
.I prefix
は、`\|\c
.B \-iprefix\c
\&\|' オプションによって指定されたものです。
.TP
.B \-nostdinc
ヘッダファイルのための標準のシステムディレクトリを検索しません。`\|\c
.B \-I\c
\&\|' オプションによって指定したディレクトリ (またはカレントディレクト
リ) のみを検索します。
.Sp
`\|\c
.B \-nostdinc\c
\&\|' と `\|\c
.B \-I\-\c
\&\|'を使用することにより、インクルードファイルの検索パスを明示的に指
定したディレクトリのみに限定することが可能となります。
.TP
.B \-nostdinc++
ヘッダファイルの検索に、C++\-固有の標準ディレクトリを用いません。ただ
しそれ以外の標準ディレクトリは検索されます。
(このオプションは `\|\c
.B libg++\c
\&\|' の構築に使用されます。)
.TP
.B \-undef
標準でない定義済みマクロ(アーキテクチャフラグも含めて)を定義しません。
.TP
.B \-E
C プリプロセッサの処理のみを行います。指定された全ての C のソースファイル
に対してプリプロセスを行ない、標準出力、または指定された出力ファイルに
対して出力を行います。
.TP
.B \-C
プリプロセッサに対してコメントの削除を行なわないように指示します。
`\|\c
.B \-E\c
\&\|' オプションとともに使用されます。
.TP
.B \-P
プリプロセッサに対して `\|\c
.B #line\c
\&\|' コマンドを生成しないように指示します。
`\|\c
.B \-E\c
\&\|' オプションとともに使用されます。
.TP
.B \-M\  [ \-MG ]
プリプロセッサに対して\c
.B make
で使用可能な、オブジェクト間の依存関係を記述した出力を生成するように指示
します。それぞれのソースファイルに対して、プリプロセッサは\c
.B make\c
\& のための規則を 1 つ出力します。この出力は、ターゲットとして
そのソースファイルから生成されるオブジェクトファイルのファイル名をとり、
依存するファイルのリストとしては
`\|\c
.B #include\c
\&\|' によってソースファイルに
読み込まれる全てのファイルの名前が並びます。この
規則は 1 行、あるいは長い場合には`\|\c
.B \e\c
\&\|' と改行を入れて複数行で出力されます。この規則のリストは、プリプロセス済
みの C プログラムのかわりに、標準出力へと出力されます。
.Sp
`\|\c
.B \-M\c
\&\|' は暗黙のうちに `\|\c
.B \-E\c
\&\|' を含みます。
.Sp
`\|\c
.B \-MG\c
\&\|' を指定すると、見つからないヘッダファイルは生成されたファイルであり、
それらはソースファイルと同じディレクトリに存在するとみなします。
これは `\|\c
.B \-M\c
\&\|' と同時に指定しなければなりません。
.TP
.B \-MM\  [ \-MG ]
`\|\c
.B \-M\c
\&\|' と似ていますが、`\|\c
.B
#include "\c
.I file\c
.B
\&"\c
\&\|'によってインクルードされるユーザ定義のヘッダファイルのみを対象に
した出力ファイルを生成します。`\|\c
.B
#include <\c
.I file\c
.B
\&>\c
\&\|' によってインクルードされるシステムヘッダファイルは省略されます。
.TP
.B \-MD
`\|\c
.B \-M\c
\&\|' と似ていますが、依存情報は出力ファイル名の最後の `\|\c
.B .o\c
\&\|' を `\|\c
.B .d\c
\&\|' に置き換えたファイル名のファイルに対して出力されます。
\&`\|\c
.B \-MD\c
\&\|' を指定したファイルのコンパイルもこれに加えて行なわれ、
`\|\c
.B \-M\c
\&\|' のように通常のコンパイルを抑制することはありません。
.Sp
Mach のユーティリティである`\|\c
.B md\c
\&\|' は、これらの複数の `\|\c
.B .d\c
\&\|' ファイルを `\|\c
.B make\c
\&\|'
コマンドによって使用できる単一の依存記述ファイルへとマージするのに使用
することができます。
.TP
.B \-MMD
`\|\c
.B \-MD\c
\&\|' と似ていますが、ユーザヘッダファイルのみを対象とし、システムヘッダ
ファイルを無視します。
.TP
.B \-H
通常の動作に加えて、使用されたヘッダファイルの名前を表示します。
.TP
.BI "\-A" "question" ( answer )
.I question\c
に対するアサーション
.I answer
\& を定義します。これは `\|\c
.BI "#if #" question ( answer )\c
\&\|' のようなプリプロセッサ条件節によってテストされます。`\|\c
.B \-A\-\c
\&\|' は標準のアサーション(通常はターゲットマシンに関
する情報を表している)を禁止します。
.TP
.BI \-D macro
マクロ \c
.I macro\c
\& に対して文字列 `\|\c
.B 1\c
\&\|' を定義として与えます。
.TP
.BI \-D macro = defn
マクロ \c
.I macro\c
\& を \c
.I defn\c
\& として定義します。コマンドライン上の全ての `\|\c
.B \-D\c
\&\|' オプションは `\|\c
.B \-U\c
\&\|' オプションの処理を行なう前に処理されます。
.TP
.BI \-U macro
マクロ \c
.I macro\c
\& の定義を無効にします。`\|\c
.B \-U\c
\&\|' オプションは全ての `\|\c
.B \-D\c
\&\|' オプションの処理が終了した後、`\|\c
.B \-include\c
\&\|' と `\|\c
.B \-imacros\c
\&\|' オプションの処理の前に処理されます。
.TP
.B \-dM
プリプロセッサに対して、プリプロセス終了時に有効であったマクロの定義の
みを出力するように指示します。`\|\c
.B \-E\c
\&\|'
オプションとともに使用します。
.TP
.B \-dD
プリプロセッサに対して、全てのマクロ定義を適切な順番で出力中にそのまま
出力するように指示します。
.TP
.B \-dN
`\|\c
.B \-dD\c
\&\|' と似ていますが、マクロの引数と内容を削除します。
出力には`\|\c
.B #define \c
.I name\c
\&\c
\&\|' のみが含まれます。
.PP
.SH アセンブラオプション
.TP
.BI "\-Wa," "option"
\c
.I option\c
\& をアセンブラに対するオプションとして渡します。\c
.I option
がコンマを含む場合は、そのコンマで区切られた複数のオプションとして与え
られます。
.PP
.SH リンカオプション
これらのオプションは、コンパイラがオブジェクトファイル群をリンクして 1 つ
の実行可能ファイルを出力する際に使用されるものです。これらはコンパイラが
リンクステップを行なわない場合には意味を持ちません。
.TP
.I object-file-name
特別に認識される拡張子で終っていないファイル名は、オブジェクトファイル、
またはライブラリであると認識されます。(オブジェクトファイルとライブラリ
はリンカがその内容を参照することで区別されます。) GCC がリンクステップを
行なう場合は、これらのファイルはリンカへの入力として使用されます。
.TP
.BI \-l library
名前が
.I library\c
\& であるライブラリをリンク時に使用します。
.Sp
リンカは、標準のライブラリ用ディレクトリのリスト中から、
実際のファイル名が `\|\c
.B lib\c
.I library\c
\&.a\c
\&\|' であるファイルを検索します。リンカはこのファイルを、ファイル
名で直接指定した場合と同様に使用します。
.Sp
検索するディレクトリには、いくつかの標準システムディレクトリと、`\|\c
.B \-L\c
\&\|' によって指定したディレクトリが含まれます。
.Sp
通常、この方法で発見されるファイルはライブラリファイル、つまりいくつかの
オブジェクトファイルをメンバとして含むアーカイブファイルです。
リンカは、アーカイブファイルの中を検索して、
参照されているが定義されていないシンボルを定義しているメンバを
探し出します。
しかし、もしリンカがライブラリでなく通常のオブジェクトファイルを発見した
場合は、そのオブジェクトファイルを通常の方法でリンクします。`\|\c
.B \-l\c
\&\|' オプションを使用する場合とファイル名を直接指定する場合の違いは、`\|\c
.B \-l\c
\&\|' の場合が
.I library
を `\|\c
.B lib\c
\&\|' と `\|\c
.B .a\c
\&\|' で囲み、いくつものディレクトリを検索することだけです。
.TP
.B \-lobjc
Objective C のプログラムをリンクする場合は、この特別な
.B \-l
オプションを指定する必要があります。
.TP
.B \-nostartfiles
リンク時に、標準のシステムスタートアップファイルを使用しません。
標準ライブラリは通常通りに使用されます。
.TP
.B \-nostdlib
リンク時に、標準のシステムライブラリとスタートアップファイルを使用しません。
指定したファイルのみがリンカに渡されます。
.TP
.B \-static
ダイナミックリンクをサポートするシステムにおいて、このオプションは共有
ライブラリとのリンクを抑制します。それ以外のシステムではこのオプションは
意味を持ちません。
.TP
.B \-shared
他のオブジェクトとリンクして実行可能プログラムを形成し得る共有オブジェクトを
生成します。ごく少数のシステムでのみ、このオプションはサポートされ
ています。
.TP
.B \-symbolic
共有オブジェクトを構築する際に、グローバルなシンボルへの参照をバインド
します。全ての解決できなかった参照に対して警告を与えます
(ただしリンクエディタオプション `\|\c
.B
\-Xlinker \-z \-Xlinker defs\c
\&\|' によってこれを無効化した場合を除きます)。ごく少数のシステムでのみ、
このオプションはサポートされています。
.TP
.BI "\-Xlinker " "option"
オプション \c
.I option
をリンカに対して渡します。リンカに渡すシステム固有のオプションが、
GNU CC が理解できないものである場合に利用できます。
.Sp
引数を持ったオプションを渡したい場合は、
`\|\c
.B \-Xlinker\c
\&\|' を 2 度使用すれば可能です。1 度目でオプションを渡し、2 度目で引数を
渡します。例えば `\|\c
.B
\-assert definitions\c
\&\|' を渡すには、
`\|\c
.B
\-Xlinker \-assert \-Xlinker definitions\c
\&\|' のように記述すれば可能です。
`\|\c
.B
\-Xlinker "\-assert definitions"\c
\&\|' のように指定した場合は正常に動作しません。なぜならこれは、文字列全
体を 1 つの引数として渡してしまい、リンカの期待する形式と異なってしま
うからです。
.TP
.BI "\-Wl," "option"
オプション \c
.I option\c
\& をリンカに渡します。\c
.I option\c
\& がコンマを含む場合は、それらのコンマで複数のオプションとして分割されます。
.TP
.BI "\-u " "symbol"
シンボル
.I symbol
が未定義であるかのように振舞います。これは強制的にこのシンボルを定義してい
るライブラリモジュールをリンクするために使用します。`\|\c
.B \-u\c
\&\|' は異なったシンボルに対して複数回使用することができます。これによっ
て、さらに多くのライブラリモジュールを読み込ませることができます。
.SH ディレクトリオプション
これらのオプションは、ヘッダファイル、ライブラリ、コンパイラの一部を検
索するディレクトリを指定するために使用されます。
.TP
.BI "\-I" "dir"
ディレクトリ \c
.I dir\c
\& を、インクルードファイルの検索するディレクトリのリスト中に追加します。
.TP
.B \-I\-
`\|\c
.B \-I\-\c
\&\|' オプション指定前に `\|\c
.B \-I\c
\&\|'
オプションによって指定された全てのディレクトリは、`\|\c
.B
#include "\c
.I file\c
.B
\&"\c
\&\|' の形式によってのみ検索されます。
これらのディレクトリは `\|\c
.B
#include <\c
.I file\c
.B
\&>\c
\&\|' によっては検索されません。
.Sp
\&\|`
.B \-I\-\c
\&\|' オプション指定後に `\|\c
.B \-I\c
\&\|' で指定したディレクトリは、全ての `\|\c
.B #include\c
\&\|'
命令によって検索されます。(通常は \c
.I 全ての\c
\& `\|\c
.B \-I\c
\&\|' で指定されたディレクトリは
この方法で検索されます。)
.Sp
これに加えて `\|\c
.B \-I\-\c
\&\|' オプションは、カレントディレクトリ (現在の入力ファイルが存在する
ディレクトリ) が `\|\c
.B
#include "\c
.I file\c
.B
\&"\c
\&\|' に対する最初の検索対象となることを抑制します。`\|\c
.B \-I\-\c
\&\|' によるこの効果を上書きする方法はありません。`\|\c
.B \-I.\c
\&\|' を指定することによって、コンパイラが起動されたディレクトリが検索
されることを指定することは可能です。これはプリプロセッサが行なう
デフォルトの動作とは異なりますが、たいていはこれで十分です。
.Sp
`\|\c
.B \-I\-\c
\&\|' は、ヘッダファイルの検索に標準のシステムディレクトリを使うことを抑制
するわけではありません。
従って、`\|\c
.B \-I\-\c
\&\|' と `\|\c
.B \-nostdinc\c
\&\|' は
独立です。
.TP
.BI "\-L" "dir"
ディレクトリ\c
.I dir\c
\& を `\|\c
.B \-l\c
\&\|' による検索が行なわれるディレクトリのリストに加えます。
.TP
.BI "\-B" "prefix"
このオプションはコンパイラ自身の実行形式、ライブラリ、データファイルの
検索場所を指定します。
.Sp
コンパイラドライバはサブプログラム
`\|\c
.B cpp\c
\&\|', `\|\c
.B cc1\c
\&\|' (または C++ においては `\|\c
.B cc1plus\c
\&\|'), `\|\c
.B as\c
\&\|', そして `\|\c
.B ld\c
\&\|' を 1 つ、あるいはそれ以上起動します。コンパイラドライバは、
起動するプログラムのプレフィックスとして
.I prefix\c
\& に `\|\c
.I machine\c
.B /\c
.I version\c
.B /\c
\&\|' をつけたものとつけないものの双方を
使用します。
.Sp
コンパイラドライバは各サブプログラムの起動時に、
`\|\c
.B \-B\c
\&\|' プレフィックスの指定がある場合は、それを最初に利用します。もしその
名前が見つからなければ、または `\|\c
.B \-B\c
\&\|'
が指定されていなければ、ドライバは 2 つの標準プレフィックス `\|\c
.B /usr/lib/gcc/\c
\&\|' と `\|\c
.B /usr/local/lib/gcc-lib/\c
\&\|' を試します。このどちらにも見つからなければ、コンパイラドライバは、
環境変数 `\|\c
.B PATH\c
\&\|' のディレクトリリストを利用して、そのプログラム名を検索します。
.Sp
ランタイムサポートファイル `\|\c
.B libgcc.a\c
\&\|' も、必要ならば
`\|\c
.B \-B\c
\&\|' プレフィックスを用いて検索されます。もしそこに見つからなければ、
前記 2 つの標準プレフィックスが試みられますが、それで終りです。この場合は
リンクの対象から外されます。ほとんどの場合、またほとんどのマシンでは、`\|\c
.B libgcc.a\c
\&\|' は実際には必要ではありません。
.Sp
これと同じ効果を、環境変数
.B GCC_EXEC_PREFIX\c
\& によっても得ることができます。もしこの環境変数が定義されていれば、こ
の値がプレフィックスとして同様に使用されます。もし `\|\c
.B \-B\c
\&\|' オプションと
.B GCC_EXEC_PREFIX\c
\& 環境変数の双方が存在した場合は、`\|\c
.B \-B\c
\&\|' オプションが最初に使用され、環境変数は次に使用されます。
.SH 警告オプション
警告は、本質的に間違いであるわけではありませんが、危険な構造を報告したり、
エラーがあるかもしれないような部分を示唆する診断メッセージです。
.Sp
以下のオプションは、GNU CC が生成する警告の量と種類を制御します。
.TP
.B \-fsyntax\-only
コードの文法エラーをチェックしますが、一切出力は行いません。
.TP
.B \-w
全ての警告メッセージを抑制します。
.TP
.B \-Wno\-import
.BR #import
の利用による警告メッセージを抑制します。
.TP
.B \-pedantic
厳密な ANSI 標準 C 言語で規定している全ての警告を表示し、許されていない拡張を
使用したプログラムを全て拒否します。
.Sp
正当な ANSI 標準 C プログラムは、このオプションの有無に関わらず
コンパイルできるべきです (もっとも、ほんのわずかではありますが `\|\c
.B \-ansi\c
\&\|' を必要とするものはあります)。しかし、このオプションを使用しない場合、
GNU 拡張や伝統的な C の特徴も、これに加えてサポートされます。このオプション
を使用すれば、それらは拒絶されます。このオプションを\c
.I 使う\c
\&理由はありませんが、こだわりのある人々を満足させるためにのみ
存在しています。
.Sp
`\|\c
.B \-pedantic\c
\&\|' は、始まりと終りとが `\|\c
.B _\|_\c
\&\|' である代替キーワードの使用については、警告しません。
同様に
.B _\|_extension_\|_\c
\& に続く表現についても警告しません。しかし、システムヘッダファイルのみ
がこの抜け道を使用すべきであり、アプリケーションプログラムはこれを避け
るべきです。
.TP
.B \-pedantic\-errors
`\|\c
.B \-pedantic\c
\&\|' と似ていますが、警告のかわりにエラーを出します。
.TP
.B \-W
以下のイベントに対して、特別な警告メッセージを表示します。
.TP
\ \ \ \(bu
volatile でない自動変数が
.B longjmp\c
\& の呼び出しによって変更され得る場合です。これらの警告は、最適化コンパイル
の時のみ問題になり得ます。
.Sp
コンパイラは
.B setjmp\c
\& の呼び出しのみを見ています。コンパイラは、どこで \c
.B longjmp\c
\& が呼び出されるかを知ることはできません。実際には、シグナルハンドラは
コード中の任意の場所で
.B longjmp\c
\& を呼び出すことができます。従って、実際には \c
.B longjmp\c
\& への呼び出しが危険な部分からはおこなわれていないために問題のないプ
ログラムであっても、警告が発せられることになります。
.TP
\ \ \ \(bu
関数が、値を伴ってリターンする場合と、値を伴わずにリターンする場合の両方
が起こりうる場合です。
(関数の最後を抜けていくことは、値を伴わずに関数をリターンするとみなされます。)
例えば、次の関数がこの種類の警告を引き起こします。
.Sp
.nf
foo (a)
{
  if (a > 0)
    return a;
}
.Sp

.fi
ある関数 (\c
.B abort\c
\& や\c
.B longjmp\c
\& を含む)
が決してリターンしないということを GNU CC が理解できないために、にせの警告
が発生するかもしれません。
.TP
\ \ \ \(bu
式文 (expression-statement) またはコンマ式の左部分が
一切の副作用を含まない場合です。
警告を抑制するには、使用しない式を void にキャストして下さい。
例えば `\|\c
.B x[i,j]\c
\&\|' といった式は警告されますが、`\|\c
.B x[(void)i,j]\c
\&\|' は警告されません。
.TP
\ \ \ \(bu
符号無しの値が 0 と `\|\c
.B >\c
\&\|' または `\|\c
.B <=\c
\&\|' で比較される場合です。
.PP
.TP
.B \-Wimplicit-int
型を指定していない宣言に対して警告します。
.TP
.B \-Wimplicit-function-declaration
宣言に先立って用いられた関数に対して警告します。
.TP
.B \-Wimplicit
-Wimplicit-int および -Wimplicit-function-declaration と同じです。
.TP
.B \-Wmain
.B main
関数が不審な型で宣言あるいは定義されている場合に警告します。
通常、main は外部リンケージを持ち、
.B int\c
\& を返し、0 個または 2 個の引数をとる関数です。

.TP
.B \-Wreturn\-type
関数の戻り値の型が、デフォルトである \c
.B int\c
\& に定義された時に常に警告します。また、戻り値の型が \c
.B void\c
でない関数内に、戻り値のない \c
.B return\c
\& 文がある場合にも常に警告します。
.TP
.B \-Wunused
ローカル変数が宣言されたにも関わらず使用されていない場合、静的に宣言さ
れた関数の実体が定義されていない場合、計算結果が明らかに
利用されていない場合に常に警告します。
.TP
.B \-Wswitch
.B switch\c
\& 文がインデックスとして列挙型をとっている時、その列挙型中のいくつ
かの値に対する \c
.B case\c
\& が欠けている場合に常に警告します。(\c
.B default\c
\& ラベルが存在する場合、この警告は出ません。) このオプションを使用した場合
には、列挙型の範囲を越えた \c
.B case\c
\& ラベルも、常に警告されます。
.TP
.B \-Wcomment
コメントの開始文字列 `\|\c
.B /\(**\c
\&\|' がコメント中に現れた時に常に警告します。
.TP
.B \-Wtrigraphs
トライグラフの出現を常に警告します (トライグラフが使用可能であると仮定します)。
.TP
.B \-Wformat
.B printf\c
\&, \c
.B scanf\c
\& などへの呼び出しに対して、与えられた引数が、フォーマット文字列の指
定を満足する型を持っているかを検査します。
.TP
.B \-Wchar\-subscripts
配列の添字の型が
.BR char
であった場合に警告します。これはよくある間違いのもとです。
いくつかのマシンにおいてはこの型が符号付きであることを、
プログラマはしばしば忘れてしまいます。
.TP
.B \-Wuninitialized
初期化されていない自動変数が使用されています。
.Sp
これらの警告は、最適化コンパイルを行なう時のみ発生します。なぜなら、
コンパイラは最適化を行なう時にのみデータフロー情報を必要とするからです。
もし `\|\c
.B \-O\c
\&\|' を指定しなかった場合は、この警告を得ることはできません。
.Sp
これらの警告は、レジスタ割り当ての対象となった変数についてのみ発生します。
従って、\c
.B volatile\c
\& であると宣言された変数や、アドレス上に割り当てられた変数、サイズが
1, 2, 4, 8 バイト以外の変数に関してはこれらの警告は発生しません。
さらに、構造体、共用体、配列については、たとえそれらがレジスタに
割り当てられたとしても、これらの警告は発生しません。
.Sp
ある変数によって計算された値が結局使用されないような変数については、一切の
警告が生じないことに注意して下さい。このような計算は、警告が表示される前に
データフロー解析によって削除されます。
.Sp
これらの警告をオプションにした理由の一つは、GNU CC がまだあまり賢くなくて、
あるコードが一見間違いを含むかのように見えても
それは実は正しいものかもしれない、
ということを GNU CC が理解できない、というものです。
ここにその 1 つの例を挙げます。
.Sp
.nf
{
  int x;
  switch (y)
    {
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    }
  foo (x);
}
.Sp
.fi
もし \c
.B y\c
\& の値が常に 1, 2 あるいは 3 である限りは \c
.B x\c
\& は常に
初期化されます。しかし GNU CC はこれを知ることはできません。もう 1 つの一般
的な例を挙げます。
.Sp
.nf
{
  int save_y;
  if (change_y) save_y = y, y = new_y;
  .\|.\|.
  if (change_y) y = save_y;
}
.Sp
.fi
これはバグを含みません。なぜなら \c
.B save_y\c
\& は、その値が設定された時のみ使用されるからです。
.Sp
いくつかのにせの警告は、使用している決してリターンしない関数全てに対して
.B volatile\c
\& と宣言することによって防ぐことが可能です。
.TP
.B \-Wparentheses
ある特定の文脈中で括弧が省略されていた場合に警告します。
.TP
.B \-Wtemplate\-debugging
C++ プログラムにおいてテンプレートを使用している際に、デバッグが完全に
可能でない場合を警告します (C++ のみ)。
.TP
.B \-Wall
全ての上に挙げた `\|\c
.B \-W\c
\&\|' オプションを結合したものです。これらのオプションは全て、
たとえマクロとの組み合わせ
であっても、避けたほうがいいと我々が推奨する用法や、
簡単に避けることができると我々が信じている用法に関するものです。
.PP
残りの `\|\c
.B \-W.\|.\|.\c
\&\|' オプションは `\|\c
.B \-Wall\c
\&\|'
によっては暗黙のうちに指定されません。なぜならこれらは、クリーンなプ
ログラムにおいても、ある状況においては使用することが妥当であると我々が
考える構造についての警告を行なうオプションだからです。
.TP
.B \-Wtraditional
伝統的な C と ANSI C において異なった振舞いをする特定の構造について警
告します。
.TP
\ \ \ \(bu
マクロ引数がマクロ本体内の文字列定数に現れるものです。これは、伝統的な C に
おいてはその引数で置換しましたが、ANSI C においては定数の一部として扱わ
れます。
.TP
\ \ \ \(bu
ブロック内で外部宣言であると宣言され、かつそのブロックの終端の後で
使用されている関数です。
.TP
\ \ \ \(bu
オペランドとして \c
.B long\c
\& 型をとる \c
.B switch\c
\& 文です。
.PP
.TP
.B \-Wshadow
ローカル変数が他のローカル変数を隠している時に常に警告します。
.TP
.BI "\-Wid\-clash\-" "len"
2 つの全く別の識別子の最初の \c
.I len
文字が一致した時に警告します。これはある種の旧式な
おばかさんコンパイラでコンパイルされ得るプログラムを作る場合に役に立ちます。
.TP
.B \-Wpointer\-arith
関数型や \c
.B void\c
\& の \*(lqサイズ\*(rq に依存するものを全て警告します。GNU C はこれらに対して、
サイズ 1 を割り当てています。これは \c
.B void \(**\c
\& ポインタと関数へのポインタにおける計算を簡便にするためです。
.TP
.B \-Wcast\-qual
ポインタが、型修飾子が削除されるようにキャストされる全ての場合に警告します。
例えば \c
.B const char \(**\c
\& を
普通の \c
.B char \(**\c
\& にキャストした場合に警告がなされます。
.TP
.B \-Wcast\-align
ポインタのキャストにおいて、そのターゲットに要求される境界条件が
大きくなるようなキャストを全て警告します。例えば \c
.B char \(**\c
\& が \c
.B int \(**\c
\& へとキャストされると、整数が 2、あるいは 4 バイト境界でしかアクセスで
きないマシンにおいては警告が発せられます。
.TP
.B \-Wwrite\-strings
文字定数に対して、型 \c
.B const char[\c
.I length\c
.B ]\c
\& を与え、非-\c
.B const\c
\& の \c
.B char \(**
ポインタへのアドレスのコピーに対して警告するようにします。この警告は、
宣言とプロトタイプにおいて \c
.B const\c
\& の使用を非常に注意深くおこなっていさえすれば、
文字列定数に書き込みをしそうなコードをコンパイル時に発見することを助けますが、
そうでない場合は有害無益な指定です。これが、我々がこの警告を `\|\c
.B \-Wall\c
\&\|' のリクエストに含めなかった理由です。
.TP
.B \-Wconversion
同じ引数が与えられた時に、プロトタイプが存在する場合とプロトタイプが
存在しない場合とで、異なった型変換を引き起こす場合について警告します。
これは固定小数点から浮動小数点への変換やその逆、デフォルトの動作と異なる固定
小数点引数の幅や符号の有無の変換が含まれます。
.TP
.B \-Waggregate\-return
構造体や共用体を返す関数を定義した場合や、
それらを呼び出す全ての場合に警告します。
(配列を返すことができる言語においても、これは警告を引き起こします。)
.TP
.B \-Wstrict\-prototypes
引数の型を指定せずに関数を宣言、あるいは定義した場合に警告します。
(以前に引数の型を指定した宣言が存在する場合には、旧式の関数宣言に対しては
警告をしません。)
.TP
.B \-Wmissing\-declarations
グローバルな関数を、その前にプロトタイプ宣言をせずに定義した場合に
警告します。
この警告は、たとえその定義自身がプロトタイプを含んでいたとしても発生します。
この警告の目的は、ヘッダファイル中にグローバル関数の定義を忘れるこ
とを防ぐことにあります。
.TP
.B \-Wredundant-decls
同一スコープ中で複数回、同一対象を宣言した場合に、たとえそれが正当で何も
変化させない場合であっても警告します。
.TP
.B \-Wnested-externs
関数内で \c
.B extern\c
\& 宣言を行なった場合に警告します。
.TP
.B \-Wenum\-clash
異なる列挙型の間で変換を行なった際に警告します (C++ のみ)。
.TP
.B \-Wlong-long
.B long long \c
型が使用されている場合に警告します。これはデフォルトです。
この警告メッセージを抑止するには `\|\c
.B \-Wno\-long\-long\c
\&\|' フラグを用いて下さい。フラグ `\|\c
.B \-Wlong\-long\c
\&\|' および `\|\c
.B \-Wno\-long\-long\c
\&\|' は、フラグ `\|\c
.B \-pedantic\c
\&\|' 使用時のみ考慮されます。
.TP
.B \-Woverloaded\-virtual
(C++ のみ。)
導出クラスにおいて、仮想関数の定義は基底クラスで定義された仮想関数の型
の記述と一致していなければなりません。このオプションを使用することによっ
て、基底クラスにおける仮想関数と同一の名前を持ち、基底クラスのいかなる
仮想関数とも異なった型の記述を持つ関数に対して警告が行われます。これに
よって、導出クラスが仮想関数を定義しようとして失敗する場合を警告するこ
とができます。
.TP
.B \-Winline
関数がインライン宣言されている、あるいは
.B \-finline\-functions
オプションが与えられている場合に、関数をインライン展開できなかった場合
に警告します。
.TP
.B \-Werror
警告をエラーとして扱います。警告の後にコンパイルを中断します。
.SH デバッグオプション
GNU CC は、ユーザのプログラムや GCC の双方をデバッグするために、
多くのオプションを備えています。
.TP
.B \-g
オペレーティングシステムのネイティブのフォーマット (stabs, COFF,
XCOFF, DWARF) でデバッグ情報を生成します。GDB はこのデバッグ情報に基づい
て動作することができます。
.Sp
stabs フォーマットを使用するほとんどのシステムにおいては、`\|\c
.B \-g\c
\&\|' を指定すると、GDB だけが使用できる余分なデバッグ情報が使用可能に
なります。
この特別の情報は GDB に対してはよりよいデバッグを行なうことを可能
としますが、おそらく他のデバッガに対してはクラッシュ、あるいはそのプログラムを
読めなくしてしまいます。この特別な情報の生成を制御するためには `\|\c
.B \-gstabs+\c
\&\|', `\|\c
.B \-gstabs\c
\&\|',
`\|\c
.B \-gxcoff+\c
\&\|', `\|\c
.B \-gxcoff\c
\&\|', `\|\c
.B \-gdwarf+\c
\&\|', `\|\c
.B \-gdwarf\c
\&\|'
を使用してください (下記参照)。
.Sp
他の多くの C コンパイラと異なり、GNU CC は `\|\c
.B \-g\c
\&\|' を
`\|\c
.B \-O\c
\&\|' とともに使用することを許しています。最適化されたコードが通る近道は、
時には驚くべき結果を生み出すかもしれません。
定義したはずの変数が存在しなかったり、
制御の流れが予想もしなかった場所に移動したり、結果が定数とわかる計算や、
結果がすでに手元にある文は実行されなくなり、ある文がループの外に追い出されて
別の場所で実行されたりします。
.Sp
それにも関わらず、このオプションは最適化された出力のデバッグを可能とし
ています。これによって、バグを含むかもしれないプログラムに対して
オプティマイザを使用することができるようになります。
.PP
以下のオプションは、GNU CC を 1 つ以上のデバッグフォーマットを扱
えるように作成してある場合に有益です。
.TP
.B \-ggdb
(もしサポートされていれば)ネイティブのフォーマットでデバッグ情報を生成
します。これは可能な限りの全ての GDB 拡張を含みます。
.TP
.B \-gstabs
(もしサポートされていれば) stabs フォーマットでデバッグ情報を生成します。
ただし GDB 拡張は含みません。このフォーマットはほとんどの BSD システム上
の DBX で利用できるフォーマットです。
.TP
.B \-gstabs+
(もしサポートされていれば) stabs フォーマットでデバッグ情報を生成します。
ただし GNU デバッガ (GDB) でしか理解できない GNU 拡張を使用します。
この拡張を使用すると、他のデバッガでは、クラッシュや
プログラムが読めなくなるなどの影響がおそらく出ます。
.TP
.B \-gcoff
(サポートされていれば) COFF フォーマットでデバッグ情報を生成します。
これは、System V Release 4 より前の ほとんどの System V 上の
SDB で利用できるフォーマットです。
.TP
.B \-gxcoff
(サポートされていれば) XCOFF フォーマットでデバッグ情報を生成します。こ
れは IBM RS/6000 システムにおいて DBX デバッガによって使用される
フォーマットです。
.TP
.B \-gxcoff+
(もしサポートされていれば) XCOFF フォーマットでデバッグ情報の生成を行
います。ただし、GNU デバッガ (GDB) によってのみ理解され得る GNU 拡張を使
用します。これらの拡張を使用すると、他のデバッガに対してはクラッシュやプ
ログラムを読みとり不能にするなどの影響を及ぼし得ます。
.TP
.B \-gdwarf
(もしサポートされていれば) DWARF フォーマットでデバッグ情報の生成を行
います。これはほとんどの System V Release 4 システムにおいて SDB によっ
て使用される形式です。
.TP
.B \-gdwarf+
(もしサポートされていれば) DAWRF フォーマットでデバッグ情報の生成を行
います。ただし、GNU デバッガ (GDB) によってのみ理解され得る GNU 拡張を使
用します。これらの拡張を使用すると、他のデバッガに対してはクラッシュや
プログラムを読みとり不能にするなどの影響を及ぼし得ます。
.PP
.BI "\-g" "level"
.br
.BI "\-ggdb" "level"
.br
.BI "\-gstabs" "level"
.br
.BI "\-gcoff" "level"
.BI "\-gxcoff" "level"
.TP
.BI "\-gdwarf" "level"
デバッグ情報を要求しますが、同時に \c
.I level\c
\& によってどの程度の情報が必要かを指定します。デフォルトのレベルは 2 です。
.Sp
レベル 1 は、デバッグを予定しないプログラムの部分に対してバックトレース
を生成するに十分な最低限の情報を生成します。これは関数と外部変数の記述
を含みますが、ローカル変数や行番号に関する情報は含みません。
.Sp
レベル 3 はプログラムに含まれる全てのマクロ定義などの特別な情報を含みます。
いくつかのデバッガは `\|\c
.B \-g3\c
\&\|' の使用によってマクロの展開をサポートします。
.TP
.B \-p
プログラム \c
.B prof\c
\& によって使用されるプロファイル情報を書き込む特別なコードを生成します。
.TP
.B \-pg
プログラム \c
.B gprof\c
\& によって使用されるプロファイル情報を書き込む特別なコードを生成します。
.TP
.B \-a
基本ブロックのプロファイル情報を書き込む特別なコードを生成します。これは
それぞれのブロックが何回実行されたかを記録します。このデータは \c
.B tcov\c
\& のようなプログラムによって解析されます。ただし、このデータフォーマットは \c
.B tcov\c
\& が期待するものとは異なっています。最終的には、GNU \c
.B gprof\c
\& が処理できるように拡張されるべきです。
.TP
.B \-ax
ファイル `bb.in' から基本ブロックプロファイルパラメータを読み出し、
ファイル `bb.out' にプロファイル結果を書き出すための、
特別なコードを生成します。
`bb.in' は関数のリストを保持しています。
このリストに含まれる関数に入ると、プロファイリングがオンになります。
最外側関数を抜けると、プロファイリングはオフになります。
関数名が `-' で始まっている場合、その関数はプロファイル対象外に
なります。もし関数名が唯一に定まらない場合は、
`/path/filename.d:functionname' と記述することでこれらを区別できます。
`bb.out' には、いくつかの利用可能な関数がリストされます。
特別な意味をもつ関数が 4 つあります:
`__bb_jumps__' はジャンプ頻度を `bb.out' に書き出します。
`__bb_trace__' は基本ブロック列を `gzip' にパイプし、
ファイル `bbtrace.gz' に書き出します。
`__bb_hidecall__' は call 命令をトレースから除外します。
`__bb_showret__' は return 命令をトレースに含めるようにします。
.TP
.BI "\-d" "letters"
コンパイル中の
.I letters\c
\& で指定されるタイミングに、デバッグ用のダンプを生成するように指示します。
これはコンパイラをデバッグするために使用されます。ほとんどのダンプのファイル
名はソースファイル名に 1 単語をつなげたものになります。(例えば、`\|\c
.B foo.c.rtl\c
\&\|' や `\|\c
.B foo.c.jump\c
\&\|' などです)。
.TP
.B \-dM
全てのマクロ定義をダンプし、プリプロセス終了時に出力に書き出します。
その他には何も書き出しません。
.TP
.B \-dN
全てのマクロ名をダンプし、プリプロセス終了時に出力に書き出します。
.TP
.B \-dD
全てのマクロ定義をプリプロセス終了時に通常の出力に加えてダンプします。
.TP
.B \-dy
パース中にデバッグ情報を標準エラー出力にダンプします。
.TP
.B \-dr
RTL 生成後に `\|\c
.I file\c
.B \&.rtl\c
\&\|' に対してダンプします。
.TP
.B \-dx
関数をコンパイルするかわりに、RTL を生成するのみの処理を行います。通常は
`\|\c
.B r\c
\&\|' とともに使用されます。
.TP
.B \-dj
最初のジャンプ最適化の後に、`\|\c
.I file\c
.B \&.jump\c
\&\|' に対してダンプします。
.TP
.B \-ds
共通部分式削除 (しばしば共通部分式削除に続くジャンプ最適化も含みます) の終了
時に `\|\c
.I file\c
.B \&.cse\c
\&\|' に対してダンプします。
.TP
.B \-dL
ループ最適化終了時に `\|\c
.I file\c
.B \&.loop\c
\&\|' に対してダンプします。
.TP
.B \-dt
第 2 共通部分式削除段階 (しばしば共通部分式削除に続くジャンプ最適化も
含みます) の終了時に、`\|\c
.I file\c
.B \&.cse2\c
\&\|' に対してダンプします。
.TP
.B \-df
フロー解析終了後に、`\|\c
.I file\c
.B \&.flow\c
\&\|' に対してダンプします。
.TP
.B \-dc
命令コンビネーション終了時に `\|\c
.I file\c
.B \&.combine\c
\&\|' に対してダンプします。
.TP
.B \-dS
第 1 命令スケジューリング段階終了時に `\|\c
.I file\c
.B \&.sched\c
\&\|' に対してダンプします。
.TP
.B \-dl
ローカルレジスタ割り当て終了時に `\|\c
.I file\c
.B \&.lreg\c
\&\|' に対してダンプします。
.TP
.B \-dg
グローバルレジスタ割り当て終了時に `\|\c
.I file\c
.B \&.greg\c
\&\|' に対してダンプします。
.TP
.B \-dR
第 2 命令スケジューリング段階終了時に `\|\c
.I file\c
.B \&.sched2\c
\&\|' に対してダンプします。
.TP
.B \-dJ
最終ジャンプ最適化終了時に `\|\c
.I file\c
.B \&.jump2\c
\&\|' に対してダンプします。
.TP
.B \-dd
遅延分岐スケジューリング終了時に `\|\c
.I file\c
.B \&.dbr\c
\&\|' に対してダンプします。
.TP
.B \-dk
レジスタからスタックへの転換終了時に `\|\c
.I file\c
.B \&.stack\c
\&\|' に対してダンプします。
.TP
.B \-da
以上の全てのダンプを生成します。
.TP
.B \-dm
処理の終了時に、メモリ使用に関する統計情報を標準エラー出力に出力します。
.TP
.B \-dp
どのようなパターンや選択肢が使用されたかを示すコメントをアセンブラ出力
中のコメントで解説します。
.TP
.B \-fpretend\-float
クロスコンパイラで処理を行なう際に、ホストマシンと同じ浮動小数点フォーマット
をターゲットマシンが持つかのように振舞わせます。これは浮動小数点定
数の誤った出力を引き起こしますが、実際の命令列はおそらく GNU CC を
ターゲットマシンで起動した場合と同じものとなるでしょう。
.TP
.B \-save\-temps
通常の \*(lq一時\*(rq 中間ファイルを消去せずに保存します。これらは
カレントディレクトリに置かれ、ソースファイルに基づいた名前が付けられます。
従って、`\|\c
.B foo.c\c
\&\|' を `\|\c
.B \-c \-save\-temps\c
\&\|' を使用してコンパイルした場合は、
`\|\c
.B foo.cpp\c
\&\|', `\|\c
.B foo.s\c
\&\|' が、`\|\c
.B foo.o\c
\&\|' と同様に生成されます。
.TP
.BI "\-print\-libgcc\-file\-name=" "library"
ライブラリファイル `\|\c
.nh
.I library
.hy
\&\|' の完全な絶対名を表示します。このファイルはリンクの際のみに使用され、
それ以外の働きはありません。このオプションが指定された場合は、GNU CC は
コンパイルやリンクを何も行なわず、ただファイル名を表示するのみです。
.TP
.B \-print\-libgcc\-file\-name
`\|\c
.B \-print\-file\-name=libgcc.a\c
\&\|' と同じです。
.TP
.BI "\-print\-prog\-name=" "program"
`\|\c
.B \-print\-file\-name\c
\&\|' と似ていますが、`\|\c
cpp\c
\&\|' のような program を検索します。
.SH 最適化オプション
これらのオプションは様々な種類の最適化処理を制御します。
.TP
.B \-O
.TP
.B \-O1
最適化を行います。最適化コンパイルは幾分長めの処理時間と、大きな関数に対
する非常に多くのメモリを必要とします。
.Sp
`\|\c
.B \-O\c
\&\|' が指定されなかった場合は、コンパイラの目標はコンパイルのコストを
低減することや、目的の結果を得るためのデバッグを可能とすることに置かれ
ます。それぞれの文は独立しています。つまり、ブレークポイントでプログラムを
停止させることによって、任意の変数に新し
い値を代入したり、プログラムカウンタを他の文へと変更することを可能とし、
そのソースコードにプログラマが望む正しい結果を得ることを可能にします。
.Sp
`\|\c
.B \-O\c
\&\|' を指定しなかった場合は、\c
.B register\c
\& と宣言した変数のみがレジスタへと割り当てられます。コンパイルの結果と
して得られるコードは、PCC を `\|\c
.B \-O\c
\&\|' なしで使用した場合と比較して若干良くないものとなります。
.Sp
`\|\c
.B \-O\c
\&\|' が指定されると、コンパイラはコードのサイズと実行時間を減少させる
ことを試みます。
.Sp
`\|\c
.B \-O\c
\&\|' を指定することによって、 `\|\c
.B \-fthread\-jumps\c
\&\|' と
`\|\c
.B \-fdefer\-pop\c
\&\|' のフラグが指定されます。遅延スロットをもつマシンでは `\|\c
.B \-fdelayed\-branch\c
\&\|' が指定されます。フレームポインタを使わないデバッグをサポートしている
マシンでは、`\|\c
.B \-fomit\-frame\-pointer\c
\&\|' も指定されます。マシンによってはさらにその他のフラグが
指定されることもあります。
.TP
.B \-O2
さらに最適化を行います。サポートされている最適化手段のうち、
空間と速度のトレードオフを含まないものはほとんどの全て使用されます。
例えばループのアンローリングや関数のインライン化は行われません。
.B \-O\c
\&
と比較して、このオプションはコンパイル時間と生成コードの性能の双方を増加
させます。
.TP
.B \-O3
さらなる最適化を行います。これは
.B \-O2
が行う全ての最適化手段に加えて
.B \-finline\-functions
も有効にします。
.TP
.B \-Os
サイズ優先で最適化します。
普通、コードを増大させることのない全ての
.B \-O2
最適化が有効になります。
更に、コードサイズを減らすように設計された最適化も行います。
.TP
.B \-O0
最適化を行いません。
.Sp
複数の
.B \-O
オプションを指定した場合は、レベル番号の有無に関わらず、最後に指定した
ものが有効になります。
.PP
`\|\c
.B \-f\c
.I flag\c
\&\c
\&\|' の形式を持ったオプションは、マシン独立のフラグです。ほとんどの
フラグは有効形式と無効形式の双方を持っています。`\|\c
.B \-ffoo\c
\&\|' の無効形式は `\|\c
.B \-fno\-foo\c
\&\|' です。以下のリストでは、デフォルトではない方の形式のみを示します。
これに対して `\|\c
.B no\-\c
\&\|' を削除する、あるいは追加することによって双方の形式を生成すること
が可能です。
.TP
.B \-ffloat\-store
浮動小数点変数をレジスタに格納しません。このオプションは 68000 のように
(68881 の) 浮動小数点レジスタが \c
.B double\c
\& よりも高い精度を持っていると思われるマシンにおいて、望まない超過精度を
抑制することを可能にします。
.Sp
ほとんどのプログラムにおいては、超過精度は単に良い結果を生むだけですが、
いくつかのプログラムは正確な IEEE の浮動小数点フォーマット定義に依
存しています。
このようなプログラムに対して `\|\c
.B \-ffloat\-store\c
\&\|' を使用します。
.TP
.B \-fmemoize\-lookups
.TP
.B \-fsave\-memoized
コンパイルを高速に行なうために、ヒューリスティックスを使用します
(C++ のみ)。これらのヒューリスティックスはデフォルトでは有効になってい
ません。なぜなら、これはある種の入力ファイルにしか効果がなく、その他の
ファイルではかえってコンパイルが低速になるからです。
.Sp
最初に、コンパイラはメンバ関数への呼び出し (あるいはデータメンバへの参
照) を構築します。これは (1) どのクラスでその名前のメンバ関数が実装さ
れているかを決定し、(2) どのメンバ関数への呼び出しであるかという問題
(これはどの種類の型変換が必要となるかという決定も含みます) を解決し、(3)
呼び出し側に対するその関数の可視性を検査するという作業を行なう必要があります。
これらは全て、コンパイルをより低速にしてしまいます。通常は、そのメンバ
関数への 2 度目の呼び出しが起こった場合も、この長い処理がまた行なわれ
ることになります。これは次のようなコード
.Sp
\&  cout << "This " << p << " has " << n << " legs.\en";
.Sp
は、これらの 3 つの手順を 6 回繰り返すということを意味します。これに対し
て、ソフトウェアキャッシュを使用すると、そのキャッシュへの\*(lqヒット
\*(rqは、コストを劇的に低減することが期待できます。不幸なことに、キャッシュ
の導入によって異なったレイヤの機構を実装することが必要となり、それ
自身のオーバヘッドが生じてしまいます。`\|\c
.B \-fmemoize\-lookups\c
\&\|' はこのソフトウェアキャッシュを有効にします。
.Sp
メンバとメンバ関数へのアクセス特権 (可視性) はある関数におけるコンテキスト
と別の関数におけるものとでは異なるので、
.B g++
はキャッシュをフラッシュしなければなりません。`\|\c
.B \-fmemoize\-lookups\c
\&\|' フラグを使用すると、全ての関数をコンパイルするたびに毎回キャッシュを
フラッシュします。`\|\c
.B \-fsave\-memoized\c
\&\|' フラグは同一のソフトウェアキャッシュについて、コンパイラが前回
コンパイルした関数のコンテキストが、次にコンパイルするコンテキストと同
一のアクセス特権を有しているとみなせる時には、キャッシュを保持します。
これは同一クラス中に多くのメンバ関数を定義している時に特に有効です。
他のクラスのフレンドになっているメンバ関数を除き、同一のクラスに属して
いる全てのメンバ関数のアクセス特権は、全て同一です。このような場合は
キャッシュをフラッシュする必要はありません。
.TP
.B \-fno\-default\-inline
クラススコープ中に定義されたメンバ関数をデフォルトでインライン関数とす
る処理を行ないません (C++ のみ)。
.TP
.B \-fno\-defer\-pop
それぞれの関数呼び出しに対して、関数のリターン直後に常に引数をポップします。
関数呼出後に引数をポップしなければならないマシンにおいては、
コンパイラは通常、いくつかの関数の引数をスタックに積んで、
それらを同時にポップします。
.TP
.B \-fforce\-mem
メモリオペランドに対して、それらに対する演算が行なわれる前に、
レジスタにコピーします。これは全てのメモリ参照を、潜在的な共通部分式であると
定めることによって、より良いコードを生成します。もしそれが共通部分式でな
かった場合は、命令コンビネーションによってレジスタへの読み込みは削
除されます。私はこれがどのような違いを生み出すかということに興味があります。
.TP
.B \-fforce\-addr
メモリアドレス定数について、それらに対する演算が行なわれる前にレジスタ
にコピーします。これは `\|\c
.B \-fforce\-mem\c
\&\|' と同じ手法でより良いコードを生成します。私はこれがどのような違いを
生み出すかということに興味があります。
.TP
.B \-fomit\-frame\-pointer
フレームポインタをレジスタに格納する必要のない関数において、この処理を
行いません。これはフレームポインタの保存、設定、復帰にかかる命令を省略
し、さらに、多くの関数でレジスタ変数として使用できる余分なレジスタを
得ることを可能にします。\c
.I ただし、このオプションはほとんどのマシンにおいてデバッグを不可能にします。
.Sp
Vax などのいくつかのマシンでは、このフラグは効果を持ちません。なぜならこ
れらのマシンでは標準の呼び出し手順が自動的にフレームポインタの設定を
行なってしまい、これが存在しないとしたところで何も節約ができないからです。
マシン記述マクロ \c
.B FRAME_POINTER_REQUIRED\c
\& が、ターゲットマシンがこのフラグをサポートするかどうかを制御しています。
.TP
.B \-finline\-functions
全ての単純な関数を呼び出し側に組み込んでしまいます。コンパイラは
ヒューリスティックスを用いて、
どの関数がこの方法で組み込むに足りるほど単純かを決定します。
.Sp
もし、ある関数に対する全ての呼び出しを組み込むことができ、かつその関数が \c
.B static\c
\& と宣言されていた場合は、GCC はその関数を独立したアセンブラコードと
しては出力をしません。
.TP
.B \-fcaller\-saves
関数呼び出しにおいて破壊されるであろう値を、レジスタに保持することを可
能とします。これはこのような呼び出しの周囲にレジスタに対する保存、復帰の
特別なコードを出力することによって実現されます。このような割り当ては、そ
れが通常よりも良いコードを出力するとみなされる場合にのみ行われます。
.Sp
このオプションは特定のマシンではデフォルトで有効となっています。これらは
通常、このオプションの処理の代わりに使うことができる呼び出し時保存
レジスタが存在しないマシンです。
.TP
.B \-fkeep\-inline\-functions
ある関数への呼び出しが全て呼び出し側に組み込むことができて、かつその関数が \c
.B static\c
\& と宣言されていたとしても、実行時に呼び出し可能な関数も生成します。
.TP
.B \-fno\-function\-cse
関数のアドレスをレジスタに置きません。つまり、定まった関数を呼び出すコードは、
それぞれ明示的な関数のアドレスを含むコードとなります。
.Sp
このオプションは効率の低いコードを生成しますが、アセンブラ出力を書き換え
るようなハックを行なう場合には、このオプションを使用しなければ
混乱させられることでしょう。
.TP
.B \-fno\-peephole
マシン固有のピープホール最適化を禁止します。
.TP
.B \-ffast-math
このオプションは生成コードのスピードのために、GCC に対して、いくつかの
ANSI または IEEE の規則/規格を侵させます。例えば、このオプションは \c
.B sqrt\c
\& 関数の引数は非負の数であることを仮定します。
.Sp
このオプションはどの `\|\c
.B \-O\c
\&\|' オプションによっても有効とされません。なぜなら、このオプションは数
学関数に関する IEEE または ANSI の規則/規格の厳密な実装に依存して書かれた
プログラムに対して誤った出力を与えるからです。
.PP
以下のオプションは特殊な最適化に関する制御を行います。`\|\c
.B \-O2\c
\&\|'
オプションは`\|\c
.B \-funroll\-loops\c
\&\|'
と `\|\c
.B \-funroll\-all\-loops\c
\&\|' を除くこれらの全てのオプションを有効にします。
.PP
`\|\c
.B \-O\c
\&\|' オプションは通常 `\|\c
.B \-fthread\-jumps\c
\&\|' と `\|\c
.B \-fdelayed\-branch\c
\&\|' を有効とします。ただし、特殊なマシンではデフォルトの最適化に対して
変更が加えられているかもしれません。
.PP
最適化に関する \*(lqきめ細かいチューニング\*(rq が必要な場合に、以下の
フラグを使用することが可能です。
.TP
.B \-fstrength\-reduce
ループのストレングスリダクションと繰り返し変数の除去を行います。
.TP
.B \-fthread\-jumps
分岐ジャンプによってある場所にジャンプした時に、最初の分岐に包括される
比較が存在した時に、最初の分岐のジャンプ先を後者の分岐先に変更します。
この変更先は、2 番目の分岐条件の真偽によって、2 番目の分岐のジャンプ先か、
あるいは2 番目の分岐の直後に定められます。
.TP
.B \-funroll\-loops
ループ展開の最適化を行います。これはループの繰り返し数がコンパイル時、
あるいはランタイムに決定できる時においてのみ、実行されます。
.TP
.B \-funroll\-all\-loops
ループ展開の最適化を行います。これは全てのループに対して行われます。この
オプションは大抵、より遅く動作するプログラムを生成します。
.TP
.B \-fcse\-follow\-jumps
共通部分式削除の処理において、ジャンプ命令の行先が
他の経路から到達できない場合は、そのジャンプ命令を越えてスキャンを行
ないます。例えば、共通部分式削除処理中に \c
.B else \c
\& 節を伴った
.B if \c
\& 文に出会った場合、条件が偽ならば分岐先に対しても共通部分式削除を続けます。
.TP
.B \-fcse\-skip\-blocks
これは `\|\c
.B \-fcse\-follow\-jumps\c
\&\|' に似ていますが、ブロックを跨ぐジャンプに対しても共通部分式削除を継
続します。共通部分式削除処理中に、else 節を持たない単純な \c
.B if\c
\& 文にであった時、
`\|\c
.B \-fcse\-skip\-blocks\c
\&\|' は \c
.B if\c
\& のボディを跨いだジャンプに対する共通部分式削除処理を継続します。
.TP
.B \-frerun\-cse\-after\-loop
ループ最適化が行なわれた後に、再度共通部分式削除の処理を行います。
.TP
.B \-felide\-constructors
コンストラクタへの呼び出しが省略できるように思われる場合に、その呼び出
しを省略します (C++ のみ)。このフラグを指
定した場合は、GNU C++ は以下のコードに対して、一時オブジェクトを経由せずに \c
.B y\c
\& を \c
.B foo
への呼び出しの結果から直接初期化します。
.Sp
A foo ();
A y = foo ();
.Sp
このオプションを使用しない場合は、GNU C++ は最初に \c
.B y\c
\& を\c
.B A\c
\& 型の適切なコンストラクタを呼び出すことによって初期化します。そして、
.B foo\c
\& の結果を一時オブジェクトに格納し、最終的には
`\|\c
.B y\c
\&\|' の値を一時オブジェクトの値に入れ換えます。
.Sp
デフォルトの振舞い (`\|\c
.B \-fno\-elide\-constructors\c
\&\|') が、ANSI C++ 標準のドラフトには規定されています。コンストラクタ
が副作用を含むプログラムに対して、`\|\c
.B \-felide-constructors\c
\&\|' を指定すると、そのプログラムは異なった動作をする可能性があります。な
ぜなら、いくつかのコンストラクタの呼び出しが省略されるからです。
.TP
.B \-fexpensive\-optimizations
比較的コストの高いいくつかの些細な最適化を行います。
.TP
.B \-fdelayed\-branch
ターゲットマシンにおいてこのフラグがサポートされている場合は、遅延分岐
命令後の命令スロットを命令の順番変更によって利用するように設定します。
.TP
.B \-fschedule\-insns
ターゲットマシンにおいてこのフラグがサポートされている場合は、必要な
データを利用可能になるまで待つことによる実行の遅滞を防ぐために、命令
の順番の変更を行います。これは遅い浮動小数点命令やメモリ読み込み命令の実
行において、それらの結果を必要とする命令の前に他の命令を詰め込みます。
.TP
.B \-fschedule\-insns2
`\|\c
.B \-fschedule\-insns\c
\&\|' と似ていますが、レジスタ割当て処理の後にもう一度命令スケジューリングの
段階を置きます。これは、比較的レジスタ数が少なく、メモリロード命令
が 1 サイクルよりも多くを要するマシンにおいて、特に効果的です。
.SH ターゲットオプション
デフォルトでは、GNU CC コンパイラは、現在使用しているマシンと同じタイプの
コードをコンパイルします。しかし、GNU CC はクロスコンパイラ
としてもインストールすることが可能です。実際には、異なったターゲット
マシンのための様々なコンフィギュレーションの GNU CC は、同時にいくつ
もインストールすることが可能です。そこで、どの GNU CC を使用するかを
指定するために、`\|\c
.B \-b\c
\&\|' オプションを使用することができます。
.PP
これに加えて、古い、あるいはより新しいバージョンの GNU CC も同時にいく
つもインストールしていくことができます。これらのうち 1 つ (おそらくもっ
とも新しいもの) がデフォルトとなります。しかし、ひょっとしたら別のものを使
いたくなるかもしれません。
.TP
.BI "\-b " "machine"
引数 \c
.I machine\c
\& は、コンパイルのターゲットマシンを規定します。これは GNU CC をクロス
コンパイラとしてインストールした時に有用です。
.Sp
.I machine\c
\& に指定する値は、GNU CC をクロスコンパイラとしてコンフィギュレーション
した時に与えたマシンタイプと同じです。例えば、80386 上の System V
で実行されるプログラムのために `\|\c
.B configure
i386v\c
\&\|' というコンフィギュレーションを行なったクロスコンパイラを起動した
い場合は、`\|\c
.B \-b i386v\c
\&\|' と指定します。
.Sp
`\|\c
.B \-b\c
\&\|' の設定を省略した場合は、通常は使用しているマシンと同タイプのマシン
のためのコンパイルが行われます。
.TP
.BI "\-V " "version"
引数 \c
.I version\c
\& は、起動される GNU CC のバージョンを規定します。これは複数のバージョンが
インストールされている場合に有用です。例えば、
.I version\c
\& が `\|\c
.B 2.0\c
\&\|' ならば、GNU CC バージョン 2.0 を起動することを意味します。
.Sp
`\|\c
.B \-V\c
\&\|' を指定しなかった場合のデフォルトのバージョンは、GNU CC をインストール
する時に調整可能です。通常は、もっとも一般的な使用に勧めることができる
バージョンがここに指定されます。
.SH マシン依存オプション
それぞれのターゲットマシンタイプは、それぞれの特別なオプションを持つ
ことが可能です。`\|\c
.B \-m\c
\&\|' で始まるオプション群は、様々なハードウェアモデルや
コンフィギュレーション\(em\&例えば 68010 と 68020、
浮動小数点コプロセッサの有無\(em\&
などを選択できます。このオプションを指定することによって、コンパイラは
どれか 1 つのモデル、
あるいはコンフィギュレーションに対するコンパイルが可能です。
.PP
いくつかのコンフィギュレーションは、通常はそのプラットフォーム上の
他のコンパイラとのコマンドラインに関するの互換性をとるため
の特別なオプションを用意しています。
.PP
以下は 68000 シリーズのために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-m68000
.TP
.B \-mc68000
68000 のためのコードを生成します。これは 68000 ベースのシステムに対して
コンフィギュレーションを行なったコンパイラのデフォルトです。
.TP
.B \-m68020
.TP
.B \-mc68020
(68000 ではなく) 68020 のためのコードを生成します。これは 68020 ベースの
システムに対してコンフィギュレーションを行なったコンパイラのデフォルト
です。
.TP
.B \-m68881
浮動小数点演算のために 68881 命令を含んだ出力を行います。これはほとんどの
68020 ベースのシステムにおいて、コンパイラのコンフィギュレーション時に
.B \-nfp
を指定されなかった場合のデフォルトです。
.TP
.B \-m68030
68030 のためのコードを生成します。これは 68030 ベースのシステムに対して
コンフィギュレーションを行なったコンパイラのデフォルトです。
.TP
.B \-m68040
68040 のためのコードを生成します。これは 68040 ベースのシステムに対して
コンフィギュレーションを行なったコンパイラのデフォルトです。
.TP
.B \-m68020\-40
68040 のためのコードを生成しますが、新しい命令を使用しません。この結果とし
て得られるコードは、68020/68881, 68030, 68040 のいずれのシステムにおいても、
比較的高い性能を持ちます。
.TP
.B \-mfpa
浮動小数点演算のために Sun FPA 命令を含んだ出力を行います。
.TP
.B \-msoft\-float
浮動小数点演算のためにライブラリを呼び出す出力を行います。
.I 警告:
この必須のライブラリは GNU CC の一部としては含まれません。通常はそのマシン
の一般的な C コンパイラの提供するものを使用しますが、これは通常の方法
ではクロスコンパイルで直接使用することはできません。クロスコンパイルを行
ないたい場合は、自分自身で必要なライブラリ関数を用意する必要があります。
.TP
.B \-mshort
.B int\c
\& 型を \c
.B short int\c
\& 型のように 16 ビット幅とみなします。
.TP
.B \-mnobitfield
ビットフィールド命令を使用しません。`\|\c
.B \-m68000\c
\&\|' は暗黙のうちに
`\|\c
.B \-mnobitfield\c
\&\|' を含みます。
.TP
.B \-mbitfield
ビットフィールド命令を使用します。`\|\c
.B \-m68020\c
\&\|' は暗黙のうちに
`\|\c
.B \-mbitfield\c
\&\|' を含みます。これは変更されていないソースの場合のデフォルトです。
.TP
.B \-mrtd
固定個数の引数をとる関数に対して、異なった関数呼び出し規約を使用します。
これは、リターン時に引数をポップする \c
.B rtd
命令を利用するものです。これは呼び出し側で引数をポップさせる必要がな
いために、1 命令を省略することが可能となります。
.Sp
この呼び出し規約は通常の Unix で使用されている方式とは互換性がありません。そ
のため、Unix コンパイラでコンパイルされたライブラリを呼び出す必要があ
る限りは、使用することはできません。
.Sp
さらに、全ての可変引数をとり得る関数 (
.B printf\c
を含みます) に対して、関数プロトタイプを用意する必要があります。さもないと、
これらの関数に対して誤ったコードが生成されます。
.Sp
さらに、関数に対して多過ぎる引数をつけて呼び出すコードを書いた場合、こ
れは深刻な誤ったコードを生成します。(通常は多過ぎる変数は害を及ぼすこと
なく無視されます。)
.Sp
.B rtd\c
\& 命令は 68010 と 68020 によってサポートされますが、 68000 では使用でき
ません。
.PP
以下は Vax のために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-munix
特定のいくつかのジャンプ命令 (\c
.B aobleq\c
\& 等)
を出力しません。これらの命令で長いレンジを使用した場合、
Vax 用の Unix アセンブラはこれを処理できません。
.TP
.B \-mgnu
これらのジャンプ命令を出力します。アセンブルには GNU アセンブラの使用
を仮定します。
.TP
.B \-mg
浮動小数点数について、d-フォーマットではなく、g-フォーマットのための
コードを出力します。
.PP
以下は SPARC でサポートされている `\|\c
.B \-m\c
\&\|' スイッチです。
.PP
.B \-mfpu
.TP
.B \-mhard\-float
浮動小数点命令を含む出力を行います。これはデフォルトです。
.PP
.B \-mno\-fpu
.TP
.B \-msoft\-float
浮動小数点の処理のためにライブラリを呼び出す出力を行います。
.I 警告:
SPARC 用の GNU 浮動小数点ライブラリは存在しません。
通常はそのマシンの一般的な C コンパイラの提供するものを使用しますが、
これは通常の方法ではクロスコンパイルで直接使用することはできません。
クロスコンパイルを行ないたい場合は、
自分自身で必要なライブラリ関数を用意する必要があります。
.Sp
.B \-msoft\-float
は呼び出し規約を変更します。したがって、
.I 全て
のプログラムをこのオプションでコンパイルしない限り、
このオプションは意味をなしません。
.PP
.B \-mno\-epilogue
.TP
.B \-mepilogue
.B \-mepilogue
を指定することによって (デフォルト)、コンパイラは関数を抜けるため
のコードを常に関数の最後に出力します。関数の途中で関数を抜けるコードは全て、
関数の最後の終了コードへのジャンプとして生成されます。
.Sp
.BR \-mno\-epilogue
を設定することによって、コンパイラは関数から抜けるコードをインライン化
することを試みます。
.PP
.B \-mno\-v8
.TP
.B \-mv8
.TP
.B \-msparclite
これらの 3 つのオプションは SPARC アーキテクチャのバリエーションを選択
するために使用されます。
.Sp
デフォルトでは、(Fujitsu SPARClite 用にコンフィギュレーションしない限
りは) GCC は SPARC アーキテクチャ v7 用のコードを生成します。
.Sp
.B \-mv8
は、SPARC v8 用コードを生成します。v7 コードとの違いは、整数の乗算と整数
の除算が v7 では存在しないが v8 には存在するという点のみです。
.Sp
.B \-msparclite
は、SPARClite 用のコードを生成します。これは v7 には存在せず SPARClite
に存在する、整数乗算、整数除算とスキャン (ffs) 命令を追加します。
.PP
.B \-mcypress
.TP
.B \-msupersparc
これら 2 つのオプションはコード最適化対象のプロセッサを選択するための
ものです。
.Sp
.B \-mcypress
を用いると(これがデフォルト)、
コンパイラは Cypress CY7C602 チップ用にコードを最適化します。
このチップは SparcStation/SparcServer 3xx シリーズに用いられています。
このオプションは古い SparcStation 1, 2, IPX などにも適用できます。
.Sp
.B \-msupersparc
を用いると、コンパイラは SuperSparc CPU 用にコードを最適化します。
このチップは SparcStation 10, 1000, 2000 シリーズに用いられています。
このオプションを用いると、SPARC v8 の全命令セットを用いるようになります。
.PP
以下は Convex のために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-mc1
C1 用の出力を行います。これはコンパイラが C1 用にコンフィギュレーション
を行なわれた時のデフォルトです。
.TP
.B \-mc2
C2 用の出力を行います。これはコンパイラが C2 用にコンフィギュレーション
を行なわれた時のデフォルトです。
.TP
.B \-margcount
引数列の前に、引数の数をワードに置くコードを生成します。いくつかの可搬性
のない Convex や Vax のプログラムはこのワードを必要とします。(デバッガは
不定長引数リストを持つ関数を除いて、このワードを必要としません。これらの
情報はシンボルテーブルに書かれます。)
.TP
.B \-mnoargcount
引数の数を示すワードを省略します。これは変更されていないソースを使用した
場合のデフォルトです。
.PP
以下は、AMD Am29000 のために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-mdw
DW ビットが立っていることを仮定したコードを出力します。これは、ハードウェア
によってバイト操作やハーフワード操作がサポートされているということを
意味します。これはデフォルトです。
.TP
.B \-mnodw
DW ビットが立っていないことを仮定したコードを出力します。
.TP
.B \-mbw
システムがバイト操作やハーフワード書き込み操作をサポートしていることを仮定した
コードを生成します。これはデフォルトです。
.TP
.B \-mnbw
システムがバイト操作やハーフワード書き込み操作をサポートしていないことを仮定し
たコードを生成します。これは暗黙のうちに `\|\c
.B \-mnodw\c
\&\|' を含みます。
.TP
.B \-msmall
スモールメモリモデルを使用します。これは全ての関数のアドレスが単一の
256KB のセグメント内に入ることと、関数の絶対アドレスが 256K 以下にある
ことを仮定します。このオプションは \c
.B call\c
\& 命令を \c
.B const\c
\&, \c
.B consth\c
\&, \c
.B calli\c
\& シーケンスの代わりに使用することを可能にします。
.TP
.B \-mlarge
.B call\c
\& 命令が使用できることを仮定しません。これはデフォルトです。
.TP
.B \-m29050
Am29050 用のコードを生成します。
.TP
.B \-m29000
Am29000 用のコードを生成します。これはデフォルトです。
.TP
.B \-mkernel\-registers
.B gr96-gr127\c
\& レジスタへの参照の代わりに
.B gr64-gr95\c
\& を参照するコードを生成します。このオプションは、ユーザのコードか
ら使用できるグローバルレジスタから区別されたグローバルレジスタの集合
を利用するカーネルのコードをコンパイルする時に使用できます。
.Sp
ただし、このオプションが使用されている時にも `\|\c
.B \-f\c
\&\|'
フラグ中のレジスタ名は通常のユーザモードでの名前を使用します。
.TP
.B \-muser\-registers
通常のグローバルレジスタの集合 \c
.B gr96-gr127\c
\& を使用します。これはデフォルトです。
.TP
.B \-mstack\-check
.B _\|_msp_check\c
\& への呼び出しをそれぞれのスタック調整の後に挿入します。これはしばしば
カーネルのコードにおいて用いられます。
.PP
以下は、Motorola 88K アーキテクチャのために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-m88000
m88100 と m88110 の双方で比較的高性能で動作するコードを生成します。
.TP
.B \-m88100
m88100 に最適なコードを生成します。ただし m88110 においても動作します。
.TP
.B \-m88110
m88110 に最適なコードを生成します。
ただし m88100 においては動作しないかも知れません
.TP
.B \-midentify\-revision
アセンブラ出力中に、ソースファイル名、コンパイラ名とバージョン、
タイムスタンプ、使用されたコンパイルフラグを記した \c
.B ident\c
\& ディレクティブを挿入します。
.TP
.B \-mno\-underscores
シンボル名の最初にアンダースコアキャラクタをつけないアセンブラ出力を生
成します。デフォルトでは個々の名前に対して、アンダースコアをプレフィック
スとして使用します。
.TP
.B \-mno\-check\-zero\-division
.TP
.B \-mcheck\-zero\-division
初期の 88K のモデルはゼロによる除算の処理に問題を持っていました。特に、そ
れらの多くにおいてトラップが生じなかったことは問題でした。これ
らのオプションを使用することによって、ゼロ除算を発見し、例外を知らせる
コードを埋め込むことを禁止 (あるいは明示的に許可) することができます。全
ての 88K 用の GCC のコンフィギュレーションは `\|\c
.B \-mcheck\-zero\-division\c
\&\|' をデフォルトとして使用しています。
.TP
.B \-mocs\-debug\-info
.TP
.B \-mno\-ocs\-debug\-info
88Open Object Compatibility Standard \*(lqOCS\*(rq で定義された
(それぞれのスタックフレーム中で使用されるレジスタに関する) 付加的なデバッグ
情報を取り込みます (または省略します)。これらの付加的な情報は GDB によっ
ては必要とされません。DG/UX, SVr4, Delta 88 SVr3.2 ではデフォルトでこの情
報を含めます。その他の 88K コンフィギュレーションではデフォルトで省略します。
.TP
.B \-mocs\-frame\-position
.TP
.B \-mno\-ocs\-frame\-position
OCS で規定されているように、レジスタの値に対して、スタックフレーム中の
特定の場所に保存されるという動作を強制します (あるいは要求しません)。
DG/UX, Delta88 SVr3.2, BCS のコンフィギュレーションでは `\|\c
.B \-mocs\-frame\-position\c
\&\|' をデフォルトとして、それ以外の 88k コンフィギュレーションでは `\|\c
.B \-mno\-ocs\-frame\-position\c
\&\|' をデフォルトとして使用しています。
.TP
.B \-moptimize\-arg\-area
.TP
.B \-mno\-optimize\-arg\-area
関数の引数がどのような方法でスタックフレームに格納されるかを指定します。
`\|\c
.B \-moptimize\-arg\-area\c
\&\|' はスペースを節約しますが、いくつかのデバッガ (GDB は含まれない) を
クラッシュさせます。`\|\c
.B \-mno\-optimize\-arg\-area\c
\&\|' はより標準に従っています。デフォルトでは GCC は引数エリアの最適化
を行いません。
.TP
.BI "\-mshort\-data\-" "num"
データ参照時に、それらの処理を \c
.B r0\c
\& からの相対参照で行なうことによって小さなコードにすることを可能とします。
これは値のロードを (その他の場合は 2 命令かかるところを) 1 命令で行な
うことを可能にします。\c
.I num\c
\& をこのオプションとともに指定することによって、どのデータ参照が影響
を受けるかを指定することができます。例えば `\|\c
.B \-mshort\-data\-512\c
\&\|' を指定すると、512 バイト以内のディスプレースメントのデータ参照が
影響を受けることになります。
`\|\c
.B \-mshort\-data\-\c
.I num\c
\&\c
\&\|' は \c
.I num\c
\& が 64K よりも大きな時は効果を持ちません。
.PP
.B \-mserialize-volatile
.TP
.B \-mno-serialize-volatile
volatile なメモリへの参照について、シーケンシャルな整合性を持った
コードを生成する、あるいは生成しません。
.Sp
GNU CC はデフォルトではどのプロセッササブモデルを選んだ場合においても、
整合性を常に保証します。これがどのように実現されているかは、サブモデルに
依存しています。
.Sp
m88100 プロセッサはメモリ参照の順番を入れ換えないので、常にシーケンシャルな
整合性は保たれます。もし `\|\c
.B \-m88100\c
\&\|' を使用した場合は、GNU CC はシーケンシャルな整合性を保つための特
別な命令を生成しません。
.Sp
m88110 プロセッサにおけるメモリ参照の順番は、必ずしもそれらの要求を行
なった命令の順番とは一致しません。特に、読み込み命令は、先行する書き込み
命令よりも先に実行され得ます。このような順番の入れ換えは、マルチプロセッサ時に
volatile なメモリの参照におけるシーケンシャルな整合性を崩してしまいます。
`\|\c
.B \-m88000\c
\&\|' または `\|\c
.B \-m88110\c
\&\|' を指定した場合には、GNU CC は、必要な場合は特別な命令を生成し、
命令の実行が正しい順番で行なわれることを強制します。
.Sp
ここで生成される整合性を保証するための特別な命令はアプリケーションの性
能に対して影響を及ぼします。もしこの保証無しで問題がないということがわかっ
ている場合は、`\|\c
.B \-mno-serialize-volatile\c
\&\|' を使用することができます。
.Sp
`\|\c
.B \-m88100\c
\&\|' オプションを使用しているが、m88110 における実行時にシーケンシャルな
整合性が必要とされる場合は、`\|\c
.B \-mserialize-volatile\c
\&\|' を使用するべきです。
.PP
.B \-msvr4
.TP
.B \-msvr3
System V release 4 (SVr4) に関連したコンパイラの拡張を有効 (`\|\c
.B \-msvr4\c
\&\|') あるいは無効 (`\|\c
.B \-msvr3\c
\&\|') にします。これは以下の内容を制御します。
.TP
\ \ \ \(bu
生成するアセンブラの文法の種類 (これは
`\|\c
.B \-mversion\-03.00\c
\&\|' を使用することによって独立に制御できます)。
.TP
\ \ \ \(bu
`\|\c
.B \-msvr4\c
\&\|' は C プリプロセッサに対して `\|\c
.B #pragma weak\c
\&\|' を理解させます。
.TP
\ \ \ \(bu
`\|\c
.B \-msvr4\c
\&\|' は、GCC に SVr4 によって使用されている付加的な宣言ディレクティブ
を生成させます。
.PP
`\|\c
.B \-msvr3\c
\&\|' は、SVr4 を除く全ての m88K コンフィギュレーションにおけるデフォ
ルトです。
.TP
.B \-mtrap\-large\-shift
.TP
.B \-mhandle\-large\-shift
31 ビットより大きいビットシフトを検出するコードを埋め込みます。これらの
オプションを指定することによって、それぞれトラップ、あるいは適切に処理す
るコードが埋め込まれます。デフォルトでは GCC は大きなビットシフトには
特別な対策を行いません。
.TP
.B \-muse\-div\-instruction
非常に初期の 88K アーキテクチャのモデルは除算命令を持っていません。従っ
て、GCC はデフォルトでは除算命令を生成しません。このオプションは除算命令
が安全に使用できるということを指定します。
.TP
.B \-mversion\-03.00
DG/UX コンフィギュレーションには、2 つの SVr4 の種類があります。このオプション
は
.B \-msvr4
オプションによって hybrid-COFF と real-ELF のどちらが使用されるかを選択します。
他のコンフィギュレーションはこのオプションを無視します。
.TP
.B \-mwarn\-passed\-structs
関数に対して構造体を渡した場合と、関数が構造体を返した場合に警告します。
構造体を渡す規約は C 言語の発展の中で変化しており、移植性の問題をしば
しば生じることになります。デフォルトでは GCC はこの警告を行いません。
.PP
以下のオプションは IBM RS6000 のために定義されたものです。
.PP
.B \-mfp\-in\-toc
.TP
.B \-mno\-fp\-in\-toc
浮動小数点定数を Table of Contents (TOC) に入れるかどうかを指定します。
このテーブルは全てのグローバル変数と関数のアドレスを格納します。デフォルト
では GCC は浮動小数点定数をここに格納します。もし TOC が算術あふれをおこす
場合は、`\|\c
.B \-mno\-fp\-in\-toc\c
\&\|' を使用することによって TOC のサイズを小さくすることが可能であり、
算術あふれを防ぐことができるでしょう。
.PP
以下は IBM RT PC 用に定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-min\-line\-mul
整数の乗算に対してインラインのコード列を生成します。これはデフォルトです。
.TP
.B \-mcall\-lib\-mul
整数の乗算に対して \c
.B lmul$$\c
\& を呼び出します。
.TP
.B \-mfull\-fp\-blocks
フルサイズの浮動小数点データブロックを生成します。これは IBM によって推
奨されている最低限のスクラッチスペースの量を包含します。これはデフォルトです。
.TP
.B \-mminimum\-fp\-blocks
浮動小数点データブロック内に特別なスクラッチスペースを含めません。これに
よって、より小さなコードが生成されますが、実行は遅くなります。
なぜならスクラッチスペースが動的に確保されるからです。
.TP
.B \-mfp\-arg\-in\-fpregs
IBM の関数呼び出し規約とは互換性のない呼び出し手順を使用します。
この規約では浮動小数点引数を浮動小数点レジスタに入れて渡します。
このオプションを指定すると、\c
.B varargs.h\c
\& や \c
.B stdarg.h\c
\& で浮動小数点オペランドが使用できなくなることに注意して下さい。
.TP
.B \-mfp\-arg\-in\-gregs
浮動小数点に対して通常の関数呼び出し規約を使用します。これはデフォルトです。
.TP
.B \-mhc\-struct\-return
1 ワードより大きな構造体を返す時に、レジスタではなくメモリを使用して返します。
これは MetaWare HighC (hc) コンパイラとの互換性を提供します。`\|\c
.B \-fpcc\-struct\-return\c
\&\|' を使用することによって Portable C Compiler (pcc) との互換性を得
ることができます。
.TP
.B \-mnohc\-struct\-return
1 ワードより大きな構造体を返す時に、レジスタによって返される場合があります。
これはその方が便利であると考えられる時に使用されます。これはデフォルトです。
IBM が提供するコンパイラとの互換性を得るためには、`\|\c
.B \-fpcc\-struct\-return\c
\&\|' と
`\|\c
.B \-mhc\-struct\-return\c
\&\|' の双方を使用します。
.PP
以下は MIPS ファミリのために定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.BI "\-mcpu=" "cpu-type"
命令スケジューリング時に、デフォルトのマシンタイプを
.I cpu-type
に仮定します。デフォルトの
.I cpu-type
は
.BR default
です。この選択はすべてのマシンに対する最長のサイクル数を元にコードを
生成します。これは、生成されるコードがどの MIPS cpu においても適当な速度
で処理されるようにするためです。これ以外の
.I cpu-type
の選択としては、
.BR r2000 ,
.BR r3000 ,
.BR r4000 ,
.BR r6000
があります。特定の
.I cpu-type
を選択した場合は、その特定のチップに適したスケジュールが行われます。
コンパイラは、
.B \-mips2
または
.B \-mips3
スイッチが使用されていない場合は、MIPS ISA (instruction set
architecture) のレベル 1 に合致しないコードを生成することはありません。
.TP
.B \-mips2
MIPS ISA のレベル 2 (branch likely 命令, 平方根命令) による命令群
を出力します。
.B \-mcpu=r4000
と
.B \-mcpu=r6000
スイッチは、
.BR \-mips2
と共に使用される必要があります。
.TP
.B \-mips3
MIPS ISA のレベル 3 (64 ビット命令) を含む命令群を出力します。
.B \-mcpu=r4000
スイッチは、
.BR \-mips2
と同時に使用する必要があります。
.TP
.B \-mint64
.TP
.B \-mlong64
.TP
.B \-mlonglong128
これらのオプションは現在動作しません。
.TP
.B \-mmips\-as
MIPS アセンブラのためのコードを生成し、
.B mips\-tfile
を起動して通常のデバッグ情報を追加します。
これは OSF/1 リファレンスプラットフォーム
以外の全てのプラットフォームにおけるデフォルトです。
OSF/1 リファレンスプラットフォームは OSF/rose オブジェクトフォーマットを
使用します。スイッチ
.BR \-ggdb ,
.BR \-gstabs ,
.B \-gstabs+
のうちのどれかが使用されている場合は、
.B mips\-tfile
プログラムは、stabs を MIPS ECOFF 中にカプセル化します。
.TP
.B \-mgas
GNU アセンブラ用のコードを生成します。これは OSF/1 リファレンスプラットフォーム
におけるデフォルトです。OSF/1 リファレンスプラットフォームは
OSF/rose オブジェクトフォーマットを使用します。
.TP
.B \-mrnames
.TP
.B \-mno\-rnames
.B \-mrnames
スイッチは出力コードにおいて、レジスタの名前として、ハードウェア名の代
わりに MIPS ソフトウェア名を使用することを指定します。(つまり、
.B a0
を
.BR $4
の代わりに使用します)。
GNU アセンブラは
.B \-mrnames
スイッチをサポートしません。MIPS アセンブラはソースファイルに対して MIPS
C プリプロセッサを起動するでしょう。
.B \-mno\-rnames
スイッチがデフォルトです。
.TP
.B \-mgpopt
.TP
.B \-mno\-gpopt
.B \-mgpopt
スイッチは、全てのデータ宣言をテキストセクション中の全命令の前に書き出
すことを指定します。これによって、全ての MIPS アセンブラは、
ショートグローバル、あるいは静的なデータアイテムに対して、2 ワードではなく、1 ワードのメモリ参照命令を生成します。
これは最適化が指定された場合のデフォルトです。
.TP
.B \-mstats
.TP
.B \-mno\-stats
.B \-mstats
が指定された場合は、コンパイラによってインラインでない関数が処理される
ごとに、標準エラー出力ファイルに対して、そのプログラムに対する統計情報
を示す 1 行のメッセージを出力します。このメッセージは、保存したレジスタ
の数、スタックのサイズなどを示します。
.TP
.B \-mmemcpy
.TP
.B \-mno\-memcpy
.B \-mmemcpy
スイッチは、全てのブロック転送に対して、インラインコードを生成する代わ
りに、適切なストリング関数
.RB ( memcpy
または
.BR bcopy )
を呼び出すコードを生成します。
.TP
.B \-mmips\-tfile
.TP
.B \-mno\-mips\-tfile
.B \-mno\-mips\-tfile
スイッチを指定すると、
MIPS アセンブラがデバッグサポートのために生成したオブジェクトファイルに対し、
.B mips\-tfile
を使用した後処理を行いません。
.B mips\-tfile
が実行されないと、デバッガからはローカル変数を扱うことができません。
さらに、
.B stage2
と
.B stage3
のオブジェクトはアセンブラに渡される一時的なファイル名をオブジェクトファイル
中に埋め込まれて持っており、このためそれらを比較した場合に同一のも
のとはみなされません。
.TP
.B \-msoft\-float
浮動小数点演算のためにライブラリを呼び出す出力を行います。
.I 警告:
この必須のライブラリは GNU CC の一部としては含まれません。通常はそのマシンの
一般的な C コンパイラの提供するものを使用しますが、これは通常の方法
ではクロスコンパイルで直接使用することはできません。クロスコンパイルを行
ないたい場合は、自分自身で必要なライブラリ関数を用意する必要があります。
.TP
.B \-mhard\-float
浮動小数点命令を含んだ出力を生成します。これは変更されないソースを使用し
た場合のデフォルトです。
.TP
.B \-mfp64
ステータスワード中の
.B FR
ビットが立っていることを仮定します。これは 32 個の 32 ビット浮動小数点
レジスタの代わりに、32 個の 64 ビットの浮動小数点レジスタが存在するとい
うことを示します。この場合は、同時に
.B \-mcpu=r4000
と
.B \-mips3
スイッチを指定する必要があります。
.TP
.B \-mfp32
32 個の 32 ビット浮動小数点レジスタが存在するということを仮定します。こ
れはデフォルトです。
.PP
.B \-mabicalls
.TP
.B \-mno\-abicalls
いくつかの System V.4 の移植が位置独立コードのために使用する疑似命令
.BR \&.abicalls ,
.BR \&.cpload ,
.B \&.cprestore
を出力する、あるいは出力しません。
.TP
.B \-mhalf\-pic
.TP
.B \-mno\-half\-pic
.B \-mhalf\-pic
スイッチは、テキストセクション中に参照を配置する代わりに、外部参照を行
なうポインタをデータセクションに配置し、それをロードする動作を指定します。
このオプションは現在まだ動作しません。
.B
.BI \-G num
は
.I num
バイト以下のグローバル、あるいは静的なアイテムを、通常のデータや bss
セクションではなく、小さなデータ、または bss セクションに配置することを
指定します。
これによりアセンブラは、通常では 2 ワードの参照を行うところを、
グローバルポインタ
.RB ( gp
または
.BR $28 )
を基準とした 1 ワードのメモリ参照命令を生成可能となります。
デフォルトでは MIPS アセンブラが使用される場合、
.I num
は 8 です。また、GNU アセンブラが使用される場合のデフォルトは 0 です。
.BI \-G num
スイッチはアセンブラ、リンカにも同様に渡されます。全てのモジュールは同一の
.BI \-G num
の値でコンパイルされなければなりません。
.TP
.B \-nocpp
MIPS アセンブラに、ユーザアセンブラファイル (`\|\c
.B .s\c
\&\|' 拡張子を持ちます) に対するアセンブル時のプリプロセッサの起動を抑制さ
せます。
.PP
以下は、Intel 80386 ファミリ用に定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-m486
.TP
.B \-mno\-486
386 ではなく 486 に最適化されたコードを出力する、あるいはその逆を行な
う指定を行います。486 用に生成されたコードは 386 で実行可能であり、逆も
また可能です。
.TP
.B \-mpentium
.B \-mcpu=pentium
と同義です。
.TP
.B \-mpentiumpro
.B \-mcpu=pentiumpro
と同義です。
.TP
.B \-mcpu=\fIcpu type\fP
命令をスケジューリングする際のマシンタイプのデフォルトを設定します。
CPU TYPE の選択肢は
.B i386,
.B i486,
.B i586
(pentium),
.B pentium,
.B i686
(pentiumpro), および
.B pentiumpro
です。
ある CPU TYPE を選ぶと、その特定チップに適するようにスケジューリングを
行いますが、
.B \-march=\fIcpu type\fP
オプションを指定しない限り、コンパイラは i386 で実行できないような
コードは生成しません。
.TP
.B \-march=\fIcpu type\fP
マシンタイプ CPU TYPE 用に命令を生成します。
CPU TYPE の選択肢は
.B i386,
.B i486,
.B pentium,
および
.B pentiumpro
です。
.B \-march=\fIcpu type\fP
を指定すると
.B \-mcpu=\fIcpu type\fP
も指定されたものとみなします。
.TP
.B \-msoft\-float
浮動小数点演算のためにライブラリを呼び出す出力を行います。
.I 警告:
この必須のライブラリは GNU CC の一部としては含まれません。通常はそのマシンの
一般的な C コンパイラの提供するものを使用しますが、これは通常の方法
ではクロスコンパイルで直接使用することはできません。クロスコンパイルを行
ないたい場合は、自分自身で必要なライブラリ関数を用意する必要があります。
.Sp
関数が浮動小数点数を返す時に 80387 レジスタスタックを使用するマシンに
おいては、`\|\c
.B \-msoft-float\c
\&\|' を使用した場合でも、いくつかの浮動小数点命令が生成されます。
.TP
.B \-mno-fp-ret-in-387
関数からの返り値に FPU のレジスタを使用しません。
.Sp
通常の関数呼び出し規約は、たとえ FPU が存在しなくても
.B float\c
\& と \c
.B double\c
\& の結果を FPU レジスタに入れて返します。したがってこの場合、
オペレーティングシステムは FPU をエミュレートしなければなりません。
.Sp
`\|\c
.B \-mno-fp-ret-in-387\c
\&\|' オプションを指定すると、浮動小数点数も通常の CPU レジスタに入れ
て返されます。
.TP
.B \-mprofiler-epilogue
.TP
.B \-mno-profiler-epilogue
関数から抜けるコードにてプロファイル情報を書き出す追加コードを生成します。
.PP
以下は HPPA ファミリ用に定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-mpa-risc-1-0
PA 1.0 プロセッサ用のコードを出力します。
.TP
.B \-mpa-risc-1-1
PA 1.1 プロセッサ用のコードを出力します。
.TP
.B \-mkernel
カーネルに適したコードを生成します。特に、引数の 1 つとして DP レジスタを
とる
.B add\c
\& 命令の使用を抑制し、その代わりに、\c
.B addil\c
\& 命令を生成します。これは HP-UX リンカの深刻なバグを避けるための措置です。
.TP
.B \-mshared-libs
HP-UX 共有ライブラリとリンクさせるコードを生成します。このオプションはま
だ完全に動作しているわけではなく、どの PA ターゲットにおいてもデフォルト
になっていません。このオプションを指定すると、コンパイラは誤ったコード
を出力し得ます。
.TP
.B \-mno-shared-libs
共有ライブラリとリンクしないコードを生成します。これは全ての PA ターゲット
においてデフォルトのオプションです。
.TP
.B \-mlong-calls
関数の呼び出し先と呼び出し元が同一ファイルに含まれた場合、呼び出し時の
距離が 256K を越える場合でも動作するようなコードを出力します。
このオプションは、リンカから \*(lqbranch out of range errors\*(rq で
リンクを拒否された時以外には使用しないようにしてください。
.TP
.B \-mdisable-fpregs
いかなる形においても、浮動小数点レジスタの使用を禁止します。
これは浮動小数点レジスタに配慮しないコンテキストスイッチを行なう
カーネルに対して有効です。
このオプションを使用して、浮動小数点処理を行なおうとすると、
コンパイラはアボートします。
.TP
.B \-mdisable-indexing
コンパイラに対して、indexing addressing mode を使用しないように指定します。
これによって MACH において MIG によって生成されたコードをコンパイルす
る際の、あまり重要でないいくつかの問題を防ぐことができます。
.TP
.B \-mtrailing-colon
ラベル定義の後にコロンを加えます (ELF アセンブラ用)。
.PP
以下は、Intel 80960 ファミリ用に定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.BI "\-m" "cpu-type"
デフォルトのマシンタイプを
.I cpu-type
に仮定します。これは生成する命令とアドレッシングモード、そして境界条件に
関係します。
デフォルトの
.I cpu-type
は
.BR kb
です。その他の選択としては
.BR ka ,
.BR mc ,
.BR ca ,
.BR cf ,
.BR sa ,
.BR sb
があります。
.TP
.B \-mnumerics
.TP
.B \-msoft\-float
.B \-mnumerics
オプションはプロセッサが浮動小数点命令をサポートすることを示します。
.B \-msoft\-float
オプションは浮動小数点サポートを仮定しないことを示します。
.TP
.B \-mleaf\-procedures
.TP
.B \-mno\-leaf\-procedures
葉に位置する手続きについて、
.IR call
命令と同様に
.I bal
命令でも呼び出すことを可能とします (あるいは、しません)。これは
.I bal
命令がアセンブラ、またはリンカによって置き換えられ得る場合には、直接呼
び出しに対して効率の良いコードを得ることができます。ただし、それ以外の場
合は効率の良くないコードを生成します。例えば、関数へのポインタ経由の呼び
出しや、この最適化をサポートしないリンカを使用した場合などがこれ
に該当します。
.TP
.B \-mtail\-call
.TP
.B \-mno\-tail\-call
(マシン非依存の部分を越えて) 末尾再帰を分岐に変換する処理に関するさ
らなる最適化を行います(または行いません)。
この手法の適用が正当でないということに関する判断
が完全ではないので、まだこのオプションを使用することは適当でないかも
しれません。デフォルトは
.BR \-mno\-tail\-call
です。
.TP
.B \-mcomplex\-addr
.TP
.B \-mno\-complex\-addr
この i960 の実装では複雑なアドレッシングモードの使用が優位であると仮定
します (あるいは仮定しません)。複雑なアドレッシングモードは K-シリーズでは
使用する価値は無いかも知れませんが、
C-シリーズでは確かに使用する価値があります。
現在は
.B \-mcomplex\-addr
が、CB と CC を除く全てのプロセッサにおけるデフォルトです。
.TP
.B \-mcode\-align
.TP
.B \-mno\-code\-align
より高速なフェッチのためにコードを 8 バイトにアラインします (または何も
しません)。現在では C シリーズの実装においてのみデフォルトで有効にしています。
.TP
.B \-mic\-compat
.TP
.B \-mic2.0\-compat
.TP
.B \-mic3.0\-compat
iC960 v2.0 または v3.0 との互換性を持たせます。
.TP
.B \-masm\-compat
.TP
.B \-mintel\-asm
iC960 アセンブラとの互換性を持たせます。
.TP
.B \-mstrict\-align
.TP
.B \-mno\-strict\-align
アラインされないアクセスを許可しません (あるいは許可します)。
.TP
.B \-mold\-align
Intel による gcc リリースバージョン 1.3 (gcc 1.37 ベース) との構造体の
境界条件に関する互換性を持たせます。現在は、
.B #pragma align 1
が同時に仮定されてしまい、無効化できないというバグを持っています。
.PP
以下は、DEC Alpha 用に定義された `\|\c
.B \-m\c
\&\|' オプションです。
.TP
.B \-mno-soft-float
.TP
.B \-msoft-float
浮動小数点操作に対して、ハードウェアによる浮動小数点命令を使用します (し
ません)。もし、\c
.B \-msoft-float\c
\& が指定された場合は、`\|\c
.B libgcc1.c\c
\&\|' 内の関数が浮動小数点演算に使用されます。ただし、これらのルーチンが
浮動小数点演算をエミュレートするルーチンによって置き換えられているか、
そのようなエミュレーションルーチンを呼び出すようにコンパイルされている
のでない限り、これらのルーチンは浮動小数点演算を行なってしまいます。浮動小
数点演算のない Alpha のためのコンパイルを行なうためには、ライブラリも
これらを呼び出さないようにコンパイルされていなければなりません。
.Sp
浮動小数点演算のない Alpha の実装は、浮動小数点レジスタを必要とすると
いうことに注意して下さい。
.TP
.B \-mfp-reg
.TP
.B \-mno-fp-regs
浮動小数点レジスタセットを使用する (使用しない)コードを生成します。
.B \-mno-fp-regs\c
\& は暗黙のうちに \c
.B \-msoft-float\c
\& を含みます。浮動小数点レジスタセットが使用されない場合は、浮動小数点
オペランドは整数レジスタに入れられて渡され、浮動小数点数の結果は $f0 では
なく $0 に入れて返されます。これは非標準の関数呼び出し手順であり、
浮動小数点数の引数や返り値を持つ関数で、\c
.B \-mno-fp-regs\c
\& をつけてコンパイルされたコードから呼び出される関数はすべてこのオプションを
つけてコンパイルされている必要があります。
.Sp
このオプションの典型的な用法は、浮動小数点レジスタを使用せず、したがっ
て浮動小数点レジスタへのセーブもリストアも必要のないカーネルを構築する
時などがあるでしょう。
.PP
ここに追加するオプションは System V Release 4 において、これらのシステム上の
他のコンパイラとの互換性のために提供されるものです。
.TP
.B \-G
SVr4 システムにおいて、\c
.B gcc\c
\& は `\|\c
.B \-G\c
\&\|' オプションを受け付けます (そして
これをシステムリンカに渡します)。これは他のコンパイラとの互換性のためです。
しかし、リンカオプションを \c
.B gcc
のコマンドラインから渡すよりも、我々は `\|\c
.B \-symbolic\c
\&\|' または `\|\c
.B \-shared\c
\&\|' の使用が適当であると考えています。
.TP
.B \-Qy
コンパイラが使用したそれぞれのツールのバージョンを
.B .ident\c
\& アセンブラディレクティブを使用して、出力で明示します。
.TP
.B \-Qn
.B .ident\c
\& ディレクティブを出力に加えることを抑制します (これは
デフォルトです)。
.TP
.BI "\-YP," "dirs"
`\|\c
.B \-l\c
\&\|' で指定されたライブラリに対して、
.I dirs\c
で規定されたディレクトリのみを検索し、他は検索しません。
.I dirs\c
\& 中は、1 つのコロンで区切ることにより、
複数のディレクトリエントリを記述します。
.TP
.BI "\-Ym," "dir"
M4 プリプロセッサを \c
.I dir\c
\& に検索します。アセンブラがこのオプションを使用します。
.SH コード生成オプション
これらのマシン独立オプションは、
コード生成にて使用されるインタフェース規約を制御します。
.PP
これらのほとんどは `\|\c
\-f\c
\&\|' で始まります。これらのオプションは有効形式と無効形式の 2 つの形式を持っ
ています。`\|\c
.B \-ffoo\c
\&\|' の無効形式は `\|\c
.B \-fno\-foo\c
\&\|' です。以下に挙げる表においては、このうち、デフォルトではない片
方のみが挙げられています。`\|\c
.B no\-\c
\&\|' を追加するか、削除するかによって双方の形式を得ることができます。
.TP
.B \-fnonnull\-objects
参照型によって参照されるオブジェクトはヌルでないと仮定します (C++ のみ)。
.Sp
通常は GNU C++ は参照型によって参照されるオブジェクトに関しては保守的
な仮定を行います。例えば、コンパイラは \c
.B a
が以下のコードにおいてヌルでないことをチェックする必要があります。
.Sp
obj &a = g ();
a.f (2);
.Sp
この種の参照がヌルでないことのチェックは、特別なコードを必要とします。
しかし、これは多くのプログラムにとって無用なものです。
このヌルに対するチェックを必要のない場合 `\|\c
.B \-fnonnull-objects\c
\&\|' を使用することにより、省略することができます。
.TP
.B \-fpcc\-struct\-return
.B struct\c
\& と \c
.B union
の値を返す場合に、普通の C コンパイラが行なうのと同じ規約を使用します。
この規約は小規模な構造体に対して非効率なものとなり、また多くのマシンでその
関数を再入不可能としてしまいます。しかしこれは、GCC でコンパイルされたコード
と PCC でコンパイルされたコードを相互に呼び出すことを可能とするとい
う利点を持ちます。
.TP
.B \-freg\-struct\-return
.B struct
と
.B union
の値を返す場合に、可能な場合はレジスタを使用する規約を使用します。これは
.BR \-fpcc\-struct\-return
を使用した場合と比較して、小さな構造体を返す場合に高い性能を発揮します。
.Sp
.B \-fpcc\-struct\-return
と
.BR \-freg\-struct\-return
のどちらも使用しなかった場合には、GNU CC は各ターゲットに対して標準で
あると考えられる規約をデフォルトとして使用します。
もし標準規約がなかった場合は、
.BR \-fpcc\-struct\-return
をデフォルトとして使用します。
.TP
.B \-fshort\-enums
.B enum\c
\& 型に対して、ちょうど取り得る値の範囲に応じたバイト数の型を与えます。
具体的には、\c
.B enum\c
\& 型は、その値域を格納するに十分な最小の整数型と等価になります。
.TP
.B \-fshort\-double
.B double
を
.B float
\& と同サイズにします。
.TP
.B \-fshared\-data
データと非 \c
.B const\c
\& 変数を、プライベートなデータではなく、共有データとしてコンパイルします。
このオプションは、走行中の同じプログラム間は共有データが共有され、
プライベートデータがそれぞれのプロセスに 1 つずつ与えられるような一部
のオペレーティングシステムで意味を持ちます。
.TP
.B \-fno\-common
bss セクション中の初期化されていないグローバル変数に対してでも、共通ブロック
に生成するのではなく、領域を割り当てます。このオプションは、(\c
.B extern\c
\& をつけずに) 同一の変数を宣言した 2 つのコンパイルに対して、リンク時
にエラーを発生するという効果があります。このオプションは、常にこのような動
作を行なうシステムにおいても、プログラムが正常に動作するかどうかを検査
する場合にのみ有用です。
.TP
.B \-fno\-ident
`\|\c
.B #ident\c
\&\|' ディレクティブを無視します。
.TP
.B \-fno\-gnu\-linker
(C++ のコンストラクタとデストラクタのような) グローバルな初期化のコードを
(GNU リンカがこれらを扱う標準のシステムであるようなシステムにおいて)
GNU リンカで使用される形式で出力しません。これは GNU リンカではない
リンカを使用する場合に指定します。この場合、
.B collect2\c
\& を使用して、確実にシステムリンカにコンストラクタとデストラクタを含
んだコードを出力させる必要があります。(\c
.B collect2\c
\& は GNU CC
のディストリビューションに含まれます。) \c
.B collect2 \c
を\c
.I 必ず使用しなければならない\c
\& システムにおいては、
コンパイラドライバ \c
.B gcc\c
\& は自動的にそのようにコンフィギュレーションされます。
.TP
.B \-finhibit-size-directive
.B .size\c
アセンブラディレクティブなど、関数が途中で分割され、メモリ上の異なった
位置にそれぞれの部分が配置されるような場合に不都合が生じるような要素を
出力しません。このオプションは `\|\c
.B crtstuff.c\c
\&\|' をコンパイルする時に使用されます。それ以外の場所ではこれを使用する
必要はありません。
.TP
.B \-fverbose-asm
出力のアセンブラ中に特別なコメント情報を追加し、可読性を高めます。この
オプションは一般的には、出力のアセンブラコードを本当に読みたい場合 (例え
ばコンパイラ自身をデバッグしているような場合) にのみ効果があります。
.TP
.B \-fvolatile
ポインタによるメモリの参照を全て volatile として扱います。
.TP
.B \-fvolatile\-global
外部変数やグローバルデータアイテムへのメモリ参照を全て volatile として
扱います。
.TP
.B \-fpic
このオプションがターゲットマシンでサポートされていれば、位置独立なコードを
出力します。このオプションは共有ライブラリでの使用に適します。
.TP
.B \-fPIC
このオプションがターゲットマシンでサポートされていれば、位置独立なコードを
出力します。このオプションはダイナミックリンクに適しており、分岐にお
いて大きなディスプレースメントを要求する場合にも適応します。
.TP
.BI "\-ffixed\-" "reg"
名前が \c
.I reg\c
\& のレジスタを固定レジスタとして扱います。生成されたコードはこのレジスタ
を参照しません (ただし、スタックポインタ、フレームポインタ、その他固定用
途の場合を除きます)。
.Sp
.I reg\c
\& はレジスタ名でなければなりません。受け付けられるレジスタ名はマシン固
有であり、マシン記述マクロファイル内の \c
.B REGISTER_NAMES
マクロに記述されたものです。
.Sp
このフラグは無効形式を持ちません。なぜなら、これは 3 通りの指定が可能で
あるからです。
.TP
.BI "\-fcall\-used\-" "reg"
名前が \c
.I reg\c
\& のレジスタを、関数呼び出しによって破壊される割り当て可能のレジスタ
として取り扱います。これは、関数呼び出しを跨いで存在しない一時領域や変数
として割り当ることができます。この指定でコンパイルされた関数は、レジスタ \c
.I reg\c
\& の保存や復帰を行いません。
.Sp
このフラグをマシンの実行モデルにおいて、ある固定的で特殊な役割を持って
いるレジスタ、例えばスタックポインタやフレームポインタに対して適用する
ことは、破滅的な結果を生みます。
.Sp
このフラグは無効形式を持ちません。なぜなら、これは 3 通りの指定が可能で
あるからです。
.TP
.BI "\-fcall\-saved\-" "reg"
名前が \c
.I reg\c
\& のレジスタを、関数によって保存される割り当て可能なレジスタとして取
り扱います。これは、関数呼び出しを跨いで存在する一時領域や変数としても割り
当てることができます。この指定でコンパイルされた関数は、レジスタ \c
.I reg\c
\& を使用する場合、その保存と復帰を行います。
.Sp
このフラグをマシンの実行モデルにおいて、ある固定的で特殊な役割を持って
いるレジスタ、例えばスタックポインタやフレームポインタに対して適用する
ことは、破滅的な結果を生みます。
.Sp
また、このフラグを関数の返り値が格納されるレジスタに使用すると、これも
破滅的な結果を生みます。
.Sp
このフラグは無効形式を持ちません。なぜなら、これは 3 通りの指定が可能で
あるからです。
.SH プラグマ
2 つの `\|\c
.B #pragma\c
\&\|' ディレクティブ(指令)が GNU C++ によってサポートされています。これは、1
つのヘッダファイルを 2 つの目的、つまりあるオブジェクトクラスのための
インタフェースの定義としての目的と、オブジェクトクラスに含まれる内容
の完全な定義としての目的の、両方の目的で使用するためのものです。
.TP
.B #pragma interface
(C++ のみ)
このディレクティブを、オブジェクトクラスを定義しているヘッダファイル中
に使用することによって、それらのクラスを使用するほとんどのオブジェクト
ファイルの大きさを減少させることができます。通常は、
特定の情報 (インラインメンバ関数のバックアップコピー、デバッグ情報、
仮想関数実現のための内部テーブル) の複製がそのクラス定義をインクルードした
それぞれのオブジェクトファイル中に置かれます。
このプラグマを使用することによって、このような複製を防ぐことが
可能となります。`\|\c
.B #pragma interface\c
\&\|' を含んだヘッダファイルをインクルードした場合は、これらの追加情報
は生成されません (ただし、メインの入力ソースファイル自身が `\|\c
.B #pragma implementation\c
\&\|' を含んでいる場合を除きます)。そのかわり、オブジェクトファイルは
リンク時に解決される参照を含むことになります。
.TP
.B #pragma implementation
.TP
\fB#pragma implementation "\fP\fIobjects\fP\fB.h"\fP
(C++ のみ)
インクルードされたヘッダファイルによる完全な出力を生成させたい (またそ
れをグローバルに可視化したい) 場合には、メインの入力ファイル中でこの
プラグマを使用します。この場合、インクルードされるヘッダファイルは、`\|\c
.B #pragma interface\c
\&\|' を使用していなければなりません。インライン関数のバックアップ情報、
デバッグ情報、仮想関数実現用の内部テーブルは、全てインプリメンテーション
ファイル中に生成されます。
.Sp
`\|\c
.B #pragma implementation\c
\&\|' を、引数をつけずに使用した場合は、これはそのソースファイルと同じ
ベースネーム(basename)を持つファイルに対して適用されます。例えば、`\|\c
.B allclass.cc\c
\&\|' 中の `\|\c
.B #pragma implementation\c
\&\|' は、`\|\c
.B #pragma implementation \*(lqallclass.h\*(rq \c
\&\|' と等価です。もし複数のヘッダファイルに対して、
1 つのインプリメンテーションファイルを対応させたい場合は、
文字列の引数を使用する必要があります。
.Sp
1 つのヘッダファイルに対して、複数のインプリメンテーションファイルを対
応させる方法はありません。
.SH 関連ファイル
.nf
.ta \w'LIBDIR/g++\-include 'u
file.c	C 言語ソースファイル
file.h	C 言語ヘッダ (プリプロセッサ) ファイル
file.i	プリプロセス済みの C 言語ソースファイル
file.C	C++ ソースファイル
file.cc	C++ ソースファイル
file.cxx	C++ ソースファイル
file.m	Objective-C ソースファイル
file.s	アセンブリ言語ファイル
file.o	オブジェクトファイル
a.out	リンクエディット済みの出力
\fITMPDIR\fR/cc\(**	一時ファイル群
\fILIBDIR\fR/cpp	プリプロセッサ
\fILIBDIR\fR/cc1	C 言語コンパイラ
\fILIBDIR\fR/cc1plus	C++ コンパイラ
\fILIBDIR\fR/collect	いくつかのマシンで必要となるリンカのフロントエンド
\fILIBDIR\fR/libgcc.a	GCC サブルーチンライブラリ
/lib/crt[01n].o	スタートアップルーチン
\fILIBDIR\fR/ccrt0	C++ 用の付加的なスタートアップルーチン
/lib/libc.a	標準ライブラリ、\c
.IR intro (3) \c
を参照
/usr/include	\fB#include\fP ファイルのための標準ディレクトリ
\fILIBDIR\fR/include	\fB#include\fP ファイルのための GCC 標準ディレクトリ
\fILIBDIR\fR/g++\-include	\fB#include\fP ファイルのための付加的な g++ ディレクトリ
.Sp
.fi
.I LIBDIR
は通常
.B /usr/local/lib/\c
.IR machine / version
の形式を持ちます
.br
.I TMPDIR
は環境変数
.B TMPDIR
(もし使用可能ならば
.B /usr/tmp
を、そうでなければ
.B /tmp\c
\& を使用します) からとられます。
.SH "関連項目"
as(1), cpp(1), gdb(1), ld(1)
.br
.B info \c
中の
.RB "`\|" gcc "\|', `\|" cpp \|',
.RB "`\|" as "\|', `\|" ld \|',
.RB `\| gdb \|'
\& エントリ
.br
.I
Using and Porting GNU CC (for version 2.0)\c
, Richard M. Stallman;
.I
The C Preprocessor\c
, Richard M. Stallman;
.I
Debugging with GDB: the GNU Source-Level Debugger\c
, Richard M. Stallman and Roland H. Pesch;
.I
Using as: the GNU Assembler\c
, Dean Elsner, Jay Fenlason & friends;
.I
ld: the GNU linker\c
, Steve Chamberlain and Roland Pesch.
.SH バグ
バグを報告する方法については、GCC マニュアルを参照してください。
.SH COPYING
Copyright
.if t \(co
1991, 1992, 1993 Free Software Foundation, Inc.
.PP
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.
.PP
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.PP
Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be included in
translations approved by the Free Software Foundation instead of in
the original English.
.SH 作者
GNU CC に対して貢献した人々に関しては、GNU CC マニュアルを参照してください。
.SH 日本語訳
細川 達己(hosokawa@mt.cs.keio.ac.jp): NetBSD 用に翻訳
.br
sakai@csl.cl.nec.co.jp,
h-nokubi@nmit.mt.nec.co.jp,
.br
kumano@strl.nhk.or.jp,
horikawa@isrd.hitachi.co.jp: FreeBSD 向けに修正, 査閲
