.\" Copyright 1993 David Metcalfe (david@prism.demon.co.uk)
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" References consulted:
.\"     Linux libc source code
.\"     Lewine's _POSIX Programmer's Guide_ (O'Reilly & Associates, 1991)
.\"     386BSD man pages
.\" Modified Sun Jul 25 10:54:31 1993, Rik Faith (faith@cs.unc.edu)
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 1997 YOSHINO Takashi
.\"       all rights reserved.
.\" Translated Mon Jan 20 18:57:06 JST 1997
.\"       by YOSHINO Takashi <yoshino@civil.jcn.nihon-u.ac.jp>
.\"
.TH STRING 3 2019\-03\-06 "" "Linux Programmer's Manual"
.SH 名前
stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn,
strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk,
strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex \- 文字列を操作する関数
.SH 書式
\fB#include <strings.h>\fP
.TP 
\fBint strcasecmp(const char *\fP\fIs1\fP\fB, const char *\fP\fIs2\fP\fB);\fP
文字列 \fIs1\fP と \fIs2\fP を大文字小文字の違いを無視して比較する。
.TP 
\fBint strncasecmp(const char *\fP\fIs1\fP\fB, const char *\fP\fIs2\fP\fB, size_t \fP\fIn\fP\fB);\fP
文字列 \fIs1\fP と \fIs2\fP の最初の \fIn\fP バイトを、大文字小文字の違いを無視して比較する。
.TP 
\fBchar *index(const char *\fP\fIs\fP\fB, int \fP\fIc\fP\fB);\fP
文字列 \fIs\fP 中に最初に文字 \fIc\fP が 現れた位置へのポインターを返す。
.TP 
\fBchar *rindex(const char *\fP\fIs\fP\fB, int \fP\fIc\fP\fB);\fP
文字列 \fIs\fP 中に最後に文字 \fIc\fP が 現れた位置へのポインターを返す。
.TP 
\fB#include <string.h>\fP
.TP 
\fBchar *stpcpy(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB);\fP
文字列を \fIsrc\fP から \fIdest\fP にコピーし、 \fIdest\fP に格納された文字列の末尾へのポインターを返す。
.TP 
\fBchar *strcat(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB);\fP
文字列 \fIsrc\fP を文字列 \fIdest\fP に追加し、 \fIdest\fP へのポインターを返す。
.TP 
\fBchar *strchr(const char *\fP\fIs\fP\fB, int \fP\fIc\fP\fB);\fP
文字列 \fIs\fP 中に最初に文字 \fIc\fP が 現れた位置へのポインターを返す。
.TP 
\fBint strcmp(const char *\fP\fIs1\fP\fB, const char *\fP\fIs2\fP\fB);\fP
文字列 \fIs1\fP と \fIs2\fP を比較する。
.TP 
\fBint strcoll(const char *\fP\fIs1\fP\fB, const char *\fP\fIs2\fP\fB);\fP
現在のロケールを使用して、文字列 \fIs1\fP を \fIs2\fP と比較する
.TP 
\fBchar *strcpy(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB);\fP
文字列 \fIsrc\fP を \fIdest\fP にコピーし、 \fIdest\fP の先頭へのポインターを返す。
.TP 
\fBsize_t strcspn(const char *\fP\fIs\fP\fB, const char *\fP\fIreject\fP\fB);\fP
文字列 \fIs\fP の、文字列 \fIreject\fP に含まれないバイトだけで構成される最初の部分文字列の長さを計算する。
.TP 
\fBchar *strdup(const char *\fP\fIs\fP\fB);\fP
文字列 \fIs\fP を、\fBmalloc\fP(3) を使って確保したメモリーに複製して返す。
.TP 
\fBchar *strfry(char *\fP\fIstring\fP\fB);\fP
\fIstring\fP 中の文字をランダムに並び替える。
.TP 
\fBsize_t strlen(const char *\fP\fIs\fP\fB);\fP
文字列 \fIs\fP の長さを返す。
.TP 
\fBchar *strncat(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB, size_t \fP\fIn\fP\fB);\fP
文字列 \fIsrc\fP の最大 \fIn\fP バイトを文字列 \fIdest\fP に追加し、\fIdest\fP へのポインターを返す。
.TP 
\fBint strncmp(const char *\fP\fIs1\fP\fB, const char *\fP\fIs2\fP\fB, size_t \fP\fIn\fP\fB);\fP
文字列 \fIs1\fP と \fIs2\fP を最大 \fIn\fP バイトまで比較する。
.TP 
\fBchar *strncpy(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB, size_t \fP\fIn\fP\fB);\fP
文字列 \fIsrc\fP から \fIdest\fP へ最大 \fIn\fP バイトをコピーし、 \fIdest\fP の先頭へのポインターを返す。
.TP 
\fBchar *strpbrk(const char *\fP\fIs\fP\fB, const char *\fP\fIaccept\fP\fB);\fP
文字列 \fIaccept\fP に含まれるバイトのいずれかが、文字列 \fIs\fP 内で最初に現れる位置を特定する。
.TP 
\fBchar *strrchr(const char *\fP\fIs\fP\fB, int \fP\fIc\fP\fB);\fP
文字列 \fIs\fP 中に最後に文字 \fIc\fP が 現れた位置へのポインターを返す。
.TP 
\fBchar *strsep(char **\fP\fIstringp\fP\fB, const char *\fP\fIdelim\fP\fB);\fP
文字列 \fIs\fP から、\fIdelim\fP のいずれかのバイトで区切った最初のトークンを取り出す。
.TP 
\fBsize_t strspn(const char *\fP\fIs\fP\fB, const char *\fP\fIaccept\fP\fB);\fP
文字列 \fIs\fP 中の \fIaccept\fP に含まれる文字だけで構成される最初の部分文字列の長さを計算する。
.TP 
\fBchar *strstr(const char *\fP\fIhaystack\fP\fB, const char *\fP\fIneedle\fP\fB);\fP
部分文字列 \fIneedle\fP が文字列 \fIhaystack\fP 中 で最初に現れる位置を探し、その部分文字列へのポインターを返す。
.TP 
\fBchar *strtok(char *\fP\fIs\fP\fB, const char *\fP\fIdelim\fP\fB);\fP
文字列 \fIs\fP から、\fIdelim\fP のいずれかのバイトで区切ったトークンを取り出す。
.TP 
\fBsize_t strxfrm(char *\fP\fIdest\fP\fB, const char *\fP\fIsrc\fP\fB, size_t \fP\fIn\fP\fB);\fP
\fIsrc\fP を現在のロケールに変換し、最初の \fIn\fP バイトを \fIdest\fP にコピーする。
.SH 説明
文字列関数は、ヌル終端された文字列に対して操作を実行する。 それぞれの関数の説明については、個々の man ページを参照のこと。
.SH 関連項目
\fBindex\fP(3), \fBrindex\fP(3), \fBstpcpy\fP(3), \fBstrcasecmp\fP(3), \fBstrcat\fP(3),
\fBstrchr\fP(3), \fBstrcmp\fP(3), \fBstrcoll\fP(3), \fBstrcpy\fP(3), \fBstrcspn\fP(3),
\fBstrdup\fP(3), \fBstrfry\fP(3), \fBstrlen\fP(3), \fBstrncasecmp\fP(3), \fBstrncat\fP(3),
\fBstrncmp\fP(3), \fBstrncpy\fP(3), \fBstrpbrk\fP(3), \fBstrrchr\fP(3), \fBstrsep\fP(3),
\fBstrspn\fP(3), \fBstrstr\fP(3), \fBstrtok\fP(3), \fBstrxfrm\fP(3)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は
\%https://www.kernel.org/doc/man\-pages/ に書かれている。
