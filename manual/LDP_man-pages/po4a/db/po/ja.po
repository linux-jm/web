# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-19 09:43+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/btree.3:36
#, no-wrap
msgid "BTREE"
msgstr "BTREE"

#. type: TH
#: build/C/man3/btree.3:36
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: TH
#: build/C/man3/btree.3:36 build/C/man3/dbopen.3:36 build/C/man3/hash.3:36
#: build/C/man3/mpool.3:36 build/C/man3/recno.3:36
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/btree.3:38 build/C/man3/dbopen.3:38 build/C/man3/hash.3:38
#: build/C/man3/mpool.3:38 build/C/man3/recno.3:38
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/btree.3:40
msgid "btree - btree database access method"
msgstr "btree - btree データベースへのアクセスメソッド"

#. type: SH
#: build/C/man3/btree.3:40 build/C/man3/dbopen.3:40 build/C/man3/hash.3:40
#: build/C/man3/mpool.3:40 build/C/man3/recno.3:40
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/btree.3:45 build/C/man3/hash.3:45 build/C/man3/recno.3:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"

#. type: SH
#: build/C/man3/btree.3:47 build/C/man3/dbopen.3:51 build/C/man3/hash.3:47
#: build/C/man3/mpool.3:62 build/C/man3/recno.3:47
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/btree.3:54 build/C/man3/dbopen.3:58 build/C/man3/hash.3:54
#: build/C/man3/mpool.3:69 build/C/man3/recno.3:54
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces.  "
"Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""
"I<大事な注意>:\n"
"このページは、バージョン 2.1 までの glibc が提供するインターフェースに\n"
"ついて説明している。バージョン 2.2 以降の glibc では、もはやこれらの\n"
"インターフェースは提供されていない。おそらく、このページではなく、\n"
"I<libdb> ライブラリが提供する API をお探しなのだろう。"

#. type: Plain text
#: build/C/man3/btree.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is btree files.  The general description of "
"the database access methods is in B<dbopen>(3), this manual page describes "
"only the btree-specific information."
msgstr ""
"ルーチン B<dbopen>(3)  はデータベースファイルに対するライブラリインターフェー"
"スである。 サポートされているファイルフォーマットのひとつに btree ファイルが"
"ある。 データベースへのアクセスメソッドに関する一般的な記述は B<dbopen>(3)  "
"に書かれている。 このマニュアルページでは btree 特有の情報についてのみ記述す"
"る。"

#. type: Plain text
#: build/C/man3/btree.3:65
msgid ""
"The btree data structure is a sorted, balanced tree structure storing "
"associated key/data pairs."
msgstr ""
"btree データ構造では、ソートされたバランスツリー構造に 互いに関連づけられた"
"キー/データ対を格納している。"

#. type: Plain text
#: build/C/man3/btree.3:71
msgid ""
"The btree access-method-specific data structure provided to B<dbopen>(3)  is "
"defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""
"B<dbopen>(3)  に渡される btree アクセスメソッドに特有のデータ構造体は、 "
"I<E<lt>db.hE<gt>> インクルードファイルで次のように定義されている。"

#. type: Plain text
#: build/C/man3/btree.3:84
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    int           maxkeypage;\n"
"    int           minkeypage;\n"
"    unsigned int  psize;\n"
"    int         (*compare)(const DBT *key1, const DBT *key2);\n"
"    size_t      (*prefix)(const DBT *key1, const DBT *key2);\n"
"    int           lorder;\n"
"} BTREEINFO;\n"
msgstr ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    int           maxkeypage;\n"
"    int           minkeypage;\n"
"    unsigned int  psize;\n"
"    int         (*compare)(const DBT *key1, const DBT *key2);\n"
"    size_t      (*prefix)(const DBT *key1, const DBT *key2);\n"
"    int           lorder;\n"
"} BTREEINFO;\n"

#. type: Plain text
#: build/C/man3/btree.3:88 build/C/man3/hash.3:85
msgid "The elements of this structure are as follows:"
msgstr "この構造体の要素を以下に示す。"

#. type: TP
#: build/C/man3/btree.3:88 build/C/man3/recno.3:93
#, no-wrap
msgid "I<flags>"
msgstr "I<flags>"

#. type: Plain text
#: build/C/man3/btree.3:91 build/C/man3/recno.3:97
msgid "The flag value is specified by ORing any of the following values:"
msgstr "I<flags> の値は以下の値の論理和で指定される。"

#. type: TP
#: build/C/man3/btree.3:92
#, no-wrap
msgid "B<R_DUP>"
msgstr "B<R_DUP>"

#. type: Plain text
#: build/C/man3/btree.3:111
msgid ""
"Permit duplicate keys in the tree, that is, permit insertion if the key to "
"be inserted already exists in the tree.  The default behavior, as described "
"in B<dbopen>(3), is to overwrite a matching key when inserting a new key or "
"to fail if the B<R_NOOVERWRITE> flag is specified.  The B<R_DUP> flag is "
"overridden by the B<R_NOOVERWRITE> flag, and if the B<R_NOOVERWRITE> flag is "
"specified, attempts to insert duplicate keys into the tree will fail."
msgstr ""
"ツリーの中にキーの重複を許す。すなわちツリーの中に挿入されようとしている キー"
"が既に存在していても、その挿入を許可する。デフォルトの動作は B<dbopen>(3)  に"
"記述されているように、新しいキーが挿入されると一致したキーを上書きする。 ある"
"いは B<R_NOOVERWRITE> フラグが指定されていると挿入に失敗する。 B<R_DUP> フラ"
"グは B<R_NOOVERWRITE> フラグによって上書きされる。つまり B<R_NOOVERWRITE> フ"
"ラグが指定された場合、ツリーに複製キーを挿入しようとすると失敗する。"

#. type: Plain text
#: build/C/man3/btree.3:121
msgid ""
"If the database contains duplicate keys, the order of retrieval of key/data "
"pairs is undefined if the I<get> routine is used, however, I<seq> routine "
"calls with the B<R_CURSOR> flag set will always return the logical \"first\" "
"of any group of duplicate keys."
msgstr ""
"データベースにキーの重複があると、 I<get> ルーチンを使った場合のキー/データ対"
"の取得順は未定義である。それに対し、 B<R_CURSOR> フラグをセットして I<seq> "
"ルーチンを使うと、複製キーのグループの中の 論理的に「最初」のキーを必ず返して"
"くる。"

#. type: TP
#: build/C/man3/btree.3:122 build/C/man3/hash.3:102 build/C/man3/recno.3:129
#, no-wrap
msgid "I<cachesize>"
msgstr "I<cachesize>"

#. type: Plain text
#: build/C/man3/btree.3:137
msgid ""
"A suggested maximum size (in bytes) of the memory cache.  This value is "
"I<only> advisory, and the access method will allocate more memory rather "
"than fail.  Since every search examines the root page of the tree, caching "
"the most recently used pages substantially improves access time.  In "
"addition, physical writes are delayed as long as possible, so a moderate "
"cache can reduce the number of I/O operations significantly.  Obviously, "
"using a cache increases (but only increases) the likelihood of corruption or "
"lost data if the system crashes while a tree is being modified.  If "
"I<cachesize> is 0 (no size is specified), a default cache is used."
msgstr ""
"想定されるメモリーキャッシュの最大サイズ (バイト単位)。 この値は I<あくまで> "
"参考であり、アクセスメソッドはこの値を越えたメモリーの 割り当てに成功すること"
"もある。 加えて、物理的な書き込みは可能な限り遅延されるので、 キャッシュの大"
"きさを適度にしておけば I/O 操作の回数をかなり減らすこと ができる。 あきらかに"
"キャッシュを使うと、ツリーが変更されている途中で システムがクラッシュした場合"
"のデータ破壊やデータロストの可能性は 増える (まあでもそれだけのこと)。 "
"I<cachesize> が 0 (サイズが指定されていない) の場合、デフォルトのキャッシュが"
"使われる。"

#. type: TP
#: build/C/man3/btree.3:137
#, no-wrap
msgid "I<maxkeypage>"
msgstr "I<maxkeypage>"

#.  The maximum number of keys which will be stored on any single page.
#.  Because of the way the btree data structure works,
#.  .I maxkeypage
#.  must always be greater than or equal to 2.
#.  If
#.  .I maxkeypage
#.  is 0 (no maximum number of keys is specified), the page fill factor is
#.  made as large as possible (which is almost invariably what is wanted).
#. type: Plain text
#: build/C/man3/btree.3:149
msgid ""
"The maximum number of keys which will be stored on any single page.  Not "
"currently implemented."
msgstr "単一ページに納められる最大キー数である。現在実装されていない。"

#. type: TP
#: build/C/man3/btree.3:149
#, no-wrap
msgid "I<minkeypage>"
msgstr "I<minkeypage>"

#. type: Plain text
#: build/C/man3/btree.3:159
msgid ""
"The minimum number of keys which will be stored on any single page.  This "
"value is used to determine which keys will be stored on overflow pages, that "
"is, if a key or data item is longer than the pagesize divided by the "
"minkeypage value, it will be stored on overflow pages instead of in the page "
"itself.  If I<minkeypage> is 0 (no minimum number of keys is specified), a "
"value of 2 is used."
msgstr ""
"単一ページに納められる最小キー数である。この値は、どのキーを オーバーフロー"
"ページ に納めるか決めるのに使われる。すなわちキーまたはデータが minkeypage の"
"値で分割されたページサイズより大きい時、そのページに納め る代わりにオーバーフ"
"ローページに納めるということである。 I<minkeypage> が 0 (キーの最小値が指定さ"
"れていない) の場合、値として 2 が使われる。"

#. type: TP
#: build/C/man3/btree.3:159 build/C/man3/recno.3:138
#, no-wrap
msgid "I<psize>"
msgstr "I<psize>"

#. type: Plain text
#: build/C/man3/btree.3:167
msgid ""
"Page size is the size (in bytes) of the pages used for nodes in the tree.  "
"The minimum page size is 512 bytes and the maximum page size is 64\\ KiB.  "
"If I<psize> is 0 (no page size is specified), a page size is chosen based on "
"the underlying filesystem I/O block size."
msgstr "ツリーの中のノードに使われるページサイズ (バイト単位)。 最小値は 512 バイトで、最大値は 64\\ KiB である。 I<psize> が 0 (ページサイズが指定されていない) の場合、 ファイルシステムの I/O ブロックサイズに基づいて決められる。"

#. type: TP
#: build/C/man3/btree.3:167
#, no-wrap
msgid "I<compare>"
msgstr "I<compare>"

#. type: Plain text
#: build/C/man3/btree.3:179
msgid ""
"Compare is the key comparison function.  It must return an integer less "
"than, equal to, or greater than zero if the first key argument is considered "
"to be respectively less than, equal to, or greater than the second key "
"argument.  The same comparison function must be used on a given tree every "
"time it is opened.  If I<compare> is NULL (no comparison function is "
"specified), the keys are compared lexically, with shorter keys considered "
"less than longer keys."
msgstr ""
"I<compare> はキーの比較関数である。 最初のキー引数に対し、二番目のキー引数が"
"大きい場合には正の整数を、 同じ場合にはゼロを、小さい場合には負の整数を返"
"す。 ツリーを開く際には、常に同じ比較関数が使われなければならない。 "
"I<compare> が NULL (比較関数が指定されていない) の場合、 辞書的に比較される。"
"短いキーは長いキーより小さいことになる。"

#. type: TP
#: build/C/man3/btree.3:179
#, no-wrap
msgid "I<prefix>"
msgstr "I<prefix>"

#. type: Plain text
#: build/C/man3/btree.3:198
msgid ""
"Prefix is the prefix comparison function.  If specified, this routine must "
"return the number of bytes of the second key argument which are necessary to "
"determine that it is greater than the first key argument.  If the keys are "
"equal, the key length should be returned.  Note, the usefulness of this "
"routine is very data-dependent, but, in some data sets can produce "
"significantly reduced tree sizes and search times.  If I<prefix> is NULL (no "
"prefix function is specified), I<and> no comparison function is specified, a "
"default lexical comparison routine is used.  If I<prefix> is NULL and a "
"comparison routine is specified, no prefix comparison is done."
msgstr ""
"I<prefix> は前置比較関数である。 このルーチンは (指定された場合には)、二番目"
"のキー引数の バイト数を返さなくてはならない。これは二番目のキー引数が 一番目"
"のキー引数より大きいかどうか決めるのに必要である。 キーが同じ場合、キーの長さ"
"が返る。このルーチンが有用かどうかは、 データに強く依存する。しかしデータセッ"
"トによっては、明らかにツリー のサイズと検索時間を減らしてくれる。 I<prefix> "
"が NULL (prefix 関数が指定されていない) で、 I<かつ> 比較関数が指定されていな"
"いと、デフォルトの辞書比較ルーチンが使われる。 I<prefix> が NULL で比較関数が"
"指定されている場合は、前置比較は行われない。"

#. type: TP
#: build/C/man3/btree.3:198 build/C/man3/hash.3:117 build/C/man3/recno.3:150
#, no-wrap
msgid "I<lorder>"
msgstr "I<lorder>"

#. type: Plain text
#: build/C/man3/btree.3:206 build/C/man3/recno.3:158
msgid ""
"The byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used."
msgstr ""
"データベースに格納されているメタデータの整数値のバイトオーダー。 この数字は、"
"順序を整数で表したものである。 例えばビッグエンディアンなら、この数値は "
"4,321 となる。 I<lorder> が 0 (指定されていない) の場合、現在のホスト で使わ"
"れているバイトオーダーが使われる。"

#. type: Plain text
#: build/C/man3/btree.3:217
msgid ""
"If the file already exists (and the B<O_TRUNC> flag is not specified), the "
"values specified for the arguments I<flags>, I<lorder>, and I<psize> are "
"ignored in favor of the values used when the tree was created."
msgstr ""
"ファイルが既に存在している (または B<O_TRUCT> フラグが指定されていない) と、 "
"引数 I<flag>, I<lorder>, I<psize> に指定された値は無視され、 ツリーが作られ"
"た時に使った値が用いられる。"

#. type: Plain text
#: build/C/man3/btree.3:219
msgid ""
"Forward sequential scans of a tree are from the least key to the greatest."
msgstr "ツリーの前方順検索は、最小キーから最大キーに向かって行われる。"

#. type: Plain text
#: build/C/man3/btree.3:225
msgid ""
"Space freed up by deleting key/data pairs from the tree is never reclaimed, "
"although it is normally made available for reuse.  This means that the btree "
"storage structure is grow-only.  The only solutions are to avoid excessive "
"deletions, or to create a fresh tree periodically from a scan of an existing "
"one."
msgstr ""
"ツリーからキー/データ対が削除されることによってできたスペースは、 通常再利用"
"できる形になっているが再利用されることは無い。 つまり brtee 記憶構造は肥大す"
"る一方である。 対策は過度の削除を避けるか、 存在するツリーを調べて定期的に新"
"しいツリーを作るか、だけである。"

#. type: Plain text
#: build/C/man3/btree.3:231
msgid ""
"Searches, insertions, and deletions in a btree will all complete in O lg "
"base N where base is the average fill factor.  Often, inserting ordered data "
"into btrees results in a low fill factor.  This implementation has been "
"modified to make ordered insertion the best case, resulting in a much better "
"than normal page fill factor."
msgstr ""
"Searches, insertions, and deletions in a btree will all complete in O lg "
"base N where base is the average fill factor.  Often, inserting ordered data "
"into btrees results in a low fill factor.  This implementation has been "
"modified to make ordered insertion the best case, resulting in a much better "
"than normal page fill factor."

#. type: SH
#: build/C/man3/btree.3:231 build/C/man3/dbopen.3:481 build/C/man3/hash.3:151
#: build/C/man3/mpool.3:185 build/C/man3/recno.3:210
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/btree.3:238
msgid ""
"The I<btree> access method routines may fail and set I<errno> for any of the "
"errors specified for the library routine B<dbopen>(3)."
msgstr ""
"I<btree> アクセスメソッドルーチンは失敗すると、ライブラリルーチン "
"B<dbopen>(3)  で定義されているエラーのいずれかを I<errno> として返す。"

#. type: SH
#: build/C/man3/btree.3:238 build/C/man3/dbopen.3:543 build/C/man3/hash.3:158
#: build/C/man3/recno.3:222
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/btree.3:240 build/C/man3/recno.3:224
msgid "Only big and little endian byte order is supported."
msgstr ""
"バイトオーダーとしてはビッグエンディアンとリトルエンディアンのみが サポートさ"
"れている。"

#. type: SH
#: build/C/man3/btree.3:240 build/C/man3/dbopen.3:554 build/C/man3/hash.3:160
#: build/C/man3/mpool.3:230 build/C/man3/recno.3:224
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/btree.3:245
msgid "B<dbopen>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"
msgstr "B<dbopen>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"

#. type: Plain text
#: build/C/man3/btree.3:248
msgid ""
"I<The Ubiquitous B-tree>, Douglas Comer, ACM Comput. Surv. 11, 2 (June "
"1979), 121-138."
msgstr ""
"I<The Ubiquitous B-tree>, Douglas Comer, ACM Comput. Surv. 11, 2 (June "
"1979), 121-138."

#. type: Plain text
#: build/C/man3/btree.3:252
msgid ""
"I<Prefix B-trees>, Bayer and Unterauer, ACM Transactions on Database "
"Systems, Vol. 2, 1 (March 1977), 11-26."
msgstr ""
"I<Prefix B-trees>, Bayer and Unterauer, ACM Transactions on Database "
"Systems, Vol. 2, 1 (March 1977), 11-26."

#. type: Plain text
#: build/C/man3/btree.3:255
msgid ""
"I<The Art of Computer Programming Vol. 3: Sorting and Searching>, D.E. "
"Knuth, 1968, pp 471-480."
msgstr ""
"I<The Art of Computer Programming Vol. 3: Sorting and Searching>, D.E. "
"Knuth, 1968, pp 471-480."

#. type: SH
#: build/C/man3/btree.3:255 build/C/man3/dbopen.3:562 build/C/man3/hash.3:171
#: build/C/man3/mpool.3:235 build/C/man3/recno.3:233
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/btree.3:263 build/C/man3/dbopen.3:570 build/C/man3/hash.3:179
#: build/C/man3/mpool.3:243 build/C/man3/recno.3:241
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/dbopen.3:36
#, no-wrap
msgid "DBOPEN"
msgstr "DBOPEN"

#. type: TH
#: build/C/man3/dbopen.3:36 build/C/man3/hash.3:36 build/C/man3/mpool.3:36
#: build/C/man3/recno.3:36
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/dbopen.3:40
msgid "dbopen - database access methods"
msgstr "dbopen - データベースアクセスメソッド"

#. type: Plain text
#: build/C/man3/dbopen.3:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dbopen.3:50
#, no-wrap
msgid ""
"B<DB *dbopen(const char *>I<file>B<, int >I<flags>B<, int >I<mode>B<, DBTYPE >I<type>B<,>\n"
"B<           const void *>I<openinfo>B<);>\n"
msgstr ""
"B<DB *dbopen(const char *>I<file>B<, int >I<flags>B<, int >I<mode>B<, DBTYPE >I<type>B<,>\n"
"B<           const void *>I<openinfo>B<);>\n"

#. type: Plain text
#: build/C/man3/dbopen.3:72
msgid ""
"B<dbopen>()  is the library interface to database files.  The supported file "
"formats are btree, hashed and UNIX file oriented.  The btree format is a "
"representation of a sorted, balanced tree structure.  The hashed format is "
"an extensible, dynamic hashing scheme.  The flat-file format is a byte "
"stream file with fixed or variable length records.  The formats and file-"
"format-specific information are described in detail in their respective "
"manual pages B<btree>(3), B<hash>(3), and B<recno>(3)."
msgstr ""
"B<dbopen>()  はデータベースファイルに対するライブラリインターフェースであ"
"る。 サポートされているファイルフォーマットは btree, hash, UNIX ファイルに指"
"向したフォーマット, の 3 つである。 btree フォーマットは、ソートされたバラン"
"スツリー構造である。 hashed フォーマットは、拡張可能な動的 hash スキームであ"
"る。 フラットファイル (flat-file) フォーマットは、 固定長/可変長のレコードか"
"らなるバイトストリームファイルである。 それぞれのフォーマットと、ファイル"
"フォーマットに特有の情報は それぞれ対応するマニュアルページ B<btree>(3), "
"B<hash>(3), B<recno>(3)  に詳細に記述されている。"

#. type: Plain text
#: build/C/man3/dbopen.3:81
msgid ""
"B<dbopen>()  opens I<file> for reading and/or writing.  Files never intended "
"to be preserved on disk may be created by setting the I<file> argument to "
"NULL."
msgstr ""
"B<dbopen>()  は I<file> を読み込み (読み書き) するためにオープンする。 "
"I<file> 引数を NULL にすれば、 ディスク上に保存したくないファイルを作ること"
"もできる。"

#. Three additional options may be specified by ORing
#. them into the
#. .I flags
#. argument.
#. .TP
#. DB_LOCK
#. Do the necessary locking in the database to support concurrent access.
#. If concurrent access isn't needed or the database is read-only this
#. flag should not be set, as it tends to have an associated performance
#. penalty.
#. .TP
#. DB_SHMEM
#. Place the underlying memory pool used by the database in shared
#. memory.
#. Necessary for concurrent access.
#. .TP
#. DB_TXN
#. Support transactions in the database.
#. The DB_LOCK and DB_SHMEM flags must be set as well.
#. type: Plain text
#: build/C/man3/dbopen.3:121
msgid ""
"The I<flags> and I<mode> arguments are as specified to the B<open>(2)  "
"routine, however, only the B<O_CREAT>, B<O_EXCL>, B<O_EXLOCK>, "
"B<O_NONBLOCK>, B<O_RDONLY>, B<O_RDWR>, B<O_SHLOCK>, and B<O_TRUNC> flags are "
"meaningful.  (Note, opening a database file B<O_WRONLY> is not possible.)"
msgstr ""
"I<flags> と I<mode> 引数は B<open>(2)  ルーチンで指定するのと同様である。た"
"だし 意味を持つフラグは B<O_CREAT>, B<O_EXCL>, B<O_EXLOCK>, B<O_NONBLOCK>, "
"B<O_RDONLY>, B<O_RDWR>, B<O_SHLOCK>, B<O_TRUNC> だけである。 (注意: "
"B<O_WRONLY> でデータベースファイルを開く事は出来ない)"

#. type: Plain text
#: build/C/man3/dbopen.3:134
msgid ""
"The I<type> argument is of type I<DBTYPE> (as defined in the I<E<lt>db."
"hE<gt>> include file) and may be set to B<DB_BTREE>, B<DB_HASH>, or "
"B<DB_RECNO>."
msgstr ""
"I<type> 引数は I<DBTYPE> 型である (インクルードファイル I<E<lt>db.hE<gt>> "
"で定義されている)。 B<DB_BTREE>, B<DB_HASH>, B<DB_RECNO> のいずれかをセットで"
"きる。"

#. type: Plain text
#: build/C/man3/dbopen.3:143
msgid ""
"The I<openinfo> argument is a pointer to an access-method-specific structure "
"described in the access method's manual page.  If I<openinfo> is NULL, each "
"access method will use defaults appropriate for the system and the access "
"method."
msgstr ""
"I<openinfo> 引数はアクセスメソッドに固有な構造体へのポインターである。 それ"
"ぞれの構造体に関しては各アクセスメソッドの マニュアルページに記述されてい"
"る。 I<openinfo> が NULL の場合、それぞれのアクセスメソッドとシステムとに適合"
"した デフォルトが用いられる。"

#. type: Plain text
#: build/C/man3/dbopen.3:154
msgid ""
"B<dbopen>()  returns a pointer to a I<DB> structure on success and NULL on "
"error.  The I<DB> structure is defined in the I<E<lt>db.hE<gt>> include "
"file, and contains at least the following fields:"
msgstr ""
"B<dbopen>()  は、成功した場合 I<DB> 構造体へのポインターを、エラーの場合 "
"NULL を返す。 I<DB> 構造体は I<E<lt>db.hE<gt>> インクルードファイルの中で定義"
"されており、 少なくとも以下のようなフィールドを持っている。"

#. type: Plain text
#: build/C/man3/dbopen.3:170
#, no-wrap
msgid ""
"typedef struct {\n"
"    DBTYPE type;\n"
"    int (*close)(const DB *db);\n"
"    int (*del)(const DB *db, const DBT *key, unsigned int flags);\n"
"    int (*fd)(const DB *db);\n"
"    int (*get)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"    int (*put)(const DB *db, DBT *key, const DBT *data,\n"
"               unsigned int flags);\n"
"    int (*sync)(const DB *db, unsigned int flags);\n"
"    int (*seq)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"} DB;\n"
msgstr ""
"typedef struct {\n"
"    DBTYPE type;\n"
"    int (*close)(const DB *db);\n"
"    int (*del)(const DB *db, const DBT *key, unsigned int flags);\n"
"    int (*fd)(const DB *db);\n"
"    int (*get)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"    int (*put)(const DB *db, DBT *key, const DBT *data,\n"
"               unsigned int flags);\n"
"    int (*sync)(const DB *db, unsigned int flags);\n"
"    int (*seq)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"} DB;\n"

#. type: Plain text
#: build/C/man3/dbopen.3:178
msgid ""
"These elements describe a database type and a set of functions performing "
"various actions.  These functions take a pointer to a structure as returned "
"by B<dbopen>(), and sometimes one or more pointers to key/data structures "
"and a flag value."
msgstr ""
"各要素には、データベースのタイプと、 様々な動作をする関数のセットが記述されて"
"いる。 これらの関数は B<dbopen>()  によって返される構造体へのポインターを引"
"数にとる。 キー/データ構造体へのポインターやフラグ値を取るものもある。"

#. type: TP
#: build/C/man3/dbopen.3:178
#, no-wrap
msgid "I<type>"
msgstr "I<type>"

#. type: Plain text
#: build/C/man3/dbopen.3:181
msgid "The type of the underlying access method (and file format)."
msgstr "用いられているアクセスメソッド (とファイルフォーマット) の型。"

#. type: TP
#: build/C/man3/dbopen.3:181
#, no-wrap
msgid "I<close>"
msgstr "I<close>"

#. type: Plain text
#: build/C/man3/dbopen.3:195
msgid ""
"A pointer to a routine to flush any cached information to disk, free any "
"allocated resources, and close the underlying file(s).  Since key/data pairs "
"may be cached in memory, failing to sync the file with a I<close> or I<sync> "
"function may result in inconsistent or lost information.  I<close> routines "
"return -1 on error (setting I<errno>)  and 0 on success."
msgstr ""
"キャッシュされた情報をディスクに掃きだすためのルーチンへのポインター。 割り当"
"てられたリソースを解放し、利用したファイル(群)をクローズする。 キー/データ対"
"がメモリーにキャッシュされている場合、 I<close> や I<sync> 関数での同期に失敗"
"すると、情報に矛盾が生じるか情報を失う可能性がある。 I<close> ルーチンはエ"
"ラーの場合 -1 を返し (I<errno> をセットする)、成功すると 0 を返す。"

#. type: TP
#: build/C/man3/dbopen.3:195
#, no-wrap
msgid "I<del>"
msgstr "I<del>"

#. type: Plain text
#: build/C/man3/dbopen.3:198
msgid "A pointer to a routine to remove key/data pairs from the database."
msgstr "データベースからキー/データ対を削除するルーチンへのポインター。"

#. type: Plain text
#: build/C/man3/dbopen.3:202
msgid "The argument I<flag> may be set to the following value:"
msgstr "I<flag> 引数は次の値がセットできる。"

#. type: TP
#: build/C/man3/dbopen.3:203 build/C/man3/dbopen.3:259
#: build/C/man3/dbopen.3:359
#, no-wrap
msgid "B<R_CURSOR>"
msgstr "B<R_CURSOR>"

#. type: Plain text
#: build/C/man3/dbopen.3:207
msgid ""
"Delete the record referenced by the cursor.  The cursor must have previously "
"been initialized."
msgstr ""
"カーソル (cursor) が参照しているレコードを削除する。 カーソルは前もって初期化"
"されていなくてはならない。"

#. type: Plain text
#: build/C/man3/dbopen.3:215
msgid ""
"I<delete> routines return -1 on error (setting I<errno>), 0 on success, and "
"1 if the specified I<key> was not in the file."
msgstr ""
"I<delete> ルーチンはエラーの場合 -1 を返し (I<errno> をセットする)、成功する"
"と 0 を返す。また指定の I<key> がファイル中に無い場合 1 を返す。"

#. type: TP
#: build/C/man3/dbopen.3:215
#, no-wrap
msgid "I<fd>"
msgstr "I<fd>"

#. type: Plain text
#: build/C/man3/dbopen.3:237
msgid ""
"A pointer to a routine which returns a file descriptor representative of the "
"underlying database.  A file descriptor referencing the same file will be "
"returned to all processes which call B<dbopen>()  with the same I<file> "
"name.  This file descriptor may be safely used as an argument to the "
"B<fcntl>(2)  and B<flock>(2)  locking functions.  The file descriptor is not "
"necessarily associated with any of the underlying files used by the access "
"method.  No file descriptor is available for in memory databases.  I<fd> "
"routines return -1 on error (setting I<errno>), and the file descriptor on "
"success."
msgstr ""
"用いているデータベースのファイルディスクリプターを返すルーチン へのポイン"
"ター。 同じファイル名 I<file> で B<dbopen>()  を呼び出した全てのプロセスに対"
"して、 そのファイルを示す単一のファイルディスクリプターが返される。 このファ"
"イルディスクリプターはロック関数 B<fcntl>(2)  と B<flock>(2)  への引数とし"
"て安全に使用できる。 このファイルディスクリプターは、必ずしもアクセスメソッド"
"で 用いられているファイルのいずれかに関連づけられていなくても良い。 メモリー"
"内のデータベースにはファイルディスクリプターは無い。 I<fd> ルーチンはエラーの"
"場合 -1 を返し (I<errno> をセットする)、成功するとファイルディスクリプターを"
"返す。"

#. type: TP
#: build/C/man3/dbopen.3:237
#, no-wrap
msgid "I<get>"
msgstr "I<get>"

#. type: Plain text
#: build/C/man3/dbopen.3:251
msgid ""
"A pointer to a routine which is the interface for keyed retrieval from the "
"database.  The address and length of the data associated with the specified "
"I<key> are returned in the structure referenced by I<data>.  I<get> routines "
"return -1 on error (setting I<errno>), 0 on success, and 1 if the I<key> was "
"not in the file."
msgstr ""
"データベースからキーを用いてデータを取り出すための ルーチンへのポインター。 "
"指定した I<key> に関連づけられたデータのアドレスと長さが I<data> が参照する構"
"造体に返される。 I<get> ルーチンはエラーの場合 -1 を返し (I<errno> をセットす"
"る)、成功すると 0 を返す。また I<key> がファイル中に無い場合 1 を返す。"

#. type: TP
#: build/C/man3/dbopen.3:251
#, no-wrap
msgid "I<put>"
msgstr "I<put>"

#. type: Plain text
#: build/C/man3/dbopen.3:254
msgid "A pointer to a routine to store key/data pairs in the database."
msgstr "キー/データ対をデータベースに納めるルーチンへのポインター。"

#. type: Plain text
#: build/C/man3/dbopen.3:258
msgid "The argument I<flag> may be set to one of the following values:"
msgstr "I<flag> 引数には次の値のうちのどれか一つがセットできる。"

#. type: Plain text
#: build/C/man3/dbopen.3:263
msgid ""
"Replace the key/data pair referenced by the cursor.  The cursor must have "
"previously been initialized."
msgstr ""
"カーソルが参照しているキー/データ対を置き換える。 カーソルは前もって初期化さ"
"れている必要がある。"

#. type: TP
#: build/C/man3/dbopen.3:263
#, no-wrap
msgid "B<R_IAFTER>"
msgstr "B<R_IAFTER>"

#. type: Plain text
#: build/C/man3/dbopen.3:274
msgid ""
"Append the data immediately after the data referenced by I<key>, creating a "
"new key/data pair.  The record number of the appended key/data pair is "
"returned in the I<key> structure.  (Applicable only to the B<DB_RECNO> "
"access method.)"
msgstr ""
"I<key> で参照されるデータの直後に、 新しいキー/データ対を作ってデータを追加す"
"る。 追加されたキー/データ対のレコード番号は I<key> 構造体に返される。 "
"(B<DB_RECNO> アクセス方法でのみ使える。)"

#. type: TP
#: build/C/man3/dbopen.3:274
#, no-wrap
msgid "B<R_IBEFORE>"
msgstr "B<R_IBEFORE>"

#. type: Plain text
#: build/C/man3/dbopen.3:285
msgid ""
"Insert the data immediately before the data referenced by I<key>, creating a "
"new key/data pair.  The record number of the inserted key/data pair is "
"returned in the I<key> structure.  (Applicable only to the B<DB_RECNO> "
"access method.)"
msgstr ""
"I<key> で参照されるデータの直前に、 新しいキー/データ対を作ってデータを挿入す"
"る。 追加されたキー/データ対のレコード番号は I<key> 構造体に返される。 "
"(B<DB_RECNO> アクセスメソッドでのみ使える。)"

#. type: TP
#: build/C/man3/dbopen.3:285
#, no-wrap
msgid "B<R_NOOVERWRITE>"
msgstr "B<R_NOOVERWRITE>"

#. type: Plain text
#: build/C/man3/dbopen.3:288
msgid "Enter the new key/data pair only if the key does not previously exist."
msgstr "キーがあらかじめ存在しない場合に限り、新しいキー/データ対をいれる。"

#. type: TP
#: build/C/man3/dbopen.3:288
#, no-wrap
msgid "B<R_SETCURSOR>"
msgstr "B<R_SETCURSOR>"

#. type: Plain text
#: build/C/man3/dbopen.3:297
msgid ""
"Store the key/data pair, setting or initializing the position of the cursor "
"to reference it.  (Applicable only to the B<DB_BTREE> and B<DB_RECNO> access "
"methods.)"
msgstr ""
"キー/データ対を納め、それを指すようにカーソル位置をセットあるいは初期 化す"
"る。 (B<DB_BTREE> と B<DB_RECNO> アクセスメソッドでのみ使える。)"

#. type: Plain text
#: build/C/man3/dbopen.3:307
msgid ""
"B<R_SETCURSOR> is available only for the B<DB_BTREE> and B<DB_RECNO> access "
"methods because it implies that the keys have an inherent order which does "
"not change."
msgstr ""
"B<R_SETCURSOR> は B<DB_BTREE> と B<DB_RECNO> アクセスメソッドでしか利用できな"
"い。 なぜなら B<R_SETCURSOR> を用いるには、変更される事の無い固有の順序を"
"キー が持っていなければならないからである。"

#. type: Plain text
#: build/C/man3/dbopen.3:317
msgid ""
"B<R_IAFTER> and B<R_IBEFORE> are available only for the B<DB_RECNO> access "
"method because they each imply that the access method is able to create new "
"keys.  This is true only if the keys are ordered and independent, record "
"numbers for example."
msgstr ""
"B<R_IAFTER> と B<R_IBEFORE> は B<DB_RECNO> アクセスメソッドでしか利用できな"
"い。 これらを実現するには、アクセスメソッドが 新しいキーを作れなければならな"
"いからである。 これが成立するのは、例えば、順序づけらた独立なレコード番号が "
"キーになっているような場合だけである。"

#. type: Plain text
#: build/C/man3/dbopen.3:322
msgid ""
"The default behavior of the I<put> routines is to enter the new key/data "
"pair, replacing any previously existing key."
msgstr ""
"I<put> ルーチンのデフォルトの動作は、新しいキー/データ対を 既に存在するキーを"
"置き換える事て格納する動作である。"

#. type: Plain text
#: build/C/man3/dbopen.3:330
msgid ""
"I<put> routines return -1 on error (setting I<errno>), 0 on success, and 1 "
"if the B<R_NOOVERWRITE> I<flag> was set and the key already exists in the "
"file."
msgstr ""
"I<put> ルーチンはエラーの場合 -1 を返し (I<errno> をセットする)、成功すると "
"0 を返す。また I<flag> に B<R_NOOVERWRITE> がセットされていてキーが既に存在す"
"る場合 1 を返す。"

#. type: TP
#: build/C/man3/dbopen.3:330
#, no-wrap
msgid "I<seq>"
msgstr "I<seq>"

#. type: Plain text
#: build/C/man3/dbopen.3:341
msgid ""
"A pointer to a routine which is the interface for sequential retrieval from "
"the database.  The address and length of the key are returned in the "
"structure referenced by I<key>, and the address and length of the data are "
"returned in the structure referenced by I<data>."
msgstr ""
"データベースからシーケンシャルにデータを取り出すための ルーチンへのポイン"
"ター。 キーのアドレスと長さが I<key> が参照する構造体に返される。データのアド"
"レスと長さが I<data> が参照する構造体に返される。"

#. type: Plain text
#: build/C/man3/dbopen.3:354
msgid ""
"Sequential key/data pair retrieval may begin at any time, and the position "
"of the \"cursor\" is not affected by calls to the I<del>, I<get>, I<put>, or "
"I<sync> routines.  Modifications to the database during a sequential scan "
"will be reflected in the scan, that is, records inserted behind the cursor "
"will not be returned while records inserted in front of the cursor will be "
"returned."
msgstr ""
"シーケンシャルなキー/データ対の取得はいつでも行える。また 「カーソル」の位置"
"は I<del>, I<get>, I<put>, I<sync> ルーチンの呼び出しには影響されない。 シー"
"ケンシャルなスキャンの途中に行われたデータベースへの変更は スキャンに反映され"
"る。すなわち、カーソルの後ろに挿入されたレコードは 返されないが、カーソルの前"
"に挿入されたレコードは返される。"

#. type: Plain text
#: build/C/man3/dbopen.3:358
msgid "The flag value B<must> be set to one of the following values:"
msgstr ""
"フラグ値にはB<必ず>以下に示すうちの どれか一つをセットしなければならない。"

#. type: Plain text
#: build/C/man3/dbopen.3:372
msgid ""
"The data associated with the specified key is returned.  This differs from "
"the I<get> routines in that it sets or initializes the cursor to the "
"location of the key as well.  (Note, for the B<DB_BTREE> access method, the "
"returned key is not necessarily an exact match for the specified key.  The "
"returned key is the smallest key greater than or equal to the specified key, "
"permitting partial key matches and range searches.)"
msgstr ""
"指定したキーに関連づけられたデータが返される。 I<get> ルーチンとの違いは、"
"カーソルがキーの位置にセットあるいは 初期化される点である。 (注意: "
"B<DB_BTREE> アクセス方法では、返されたキーが 必ずしも指定したキーに正しくマッ"
"チしないかもしれない。 返されたキーは、指定されたキーに等しいかより大きいもの"
"のうち 最小のものになる (部分キーマッチか範囲検索が許可されている場合)。)"

#. type: TP
#: build/C/man3/dbopen.3:372
#, no-wrap
msgid "B<R_FIRST>"
msgstr "B<R_FIRST>"

#. type: Plain text
#: build/C/man3/dbopen.3:376
msgid ""
"The first key/data pair of the database is returned, and the cursor is set "
"or initialized to reference it."
msgstr ""
"データベースの最初のキー/データ対が返される。 カーソルはそれを参照するように"
"セットまたは初期化される。"

#. type: TP
#: build/C/man3/dbopen.3:376
#, no-wrap
msgid "B<R_LAST>"
msgstr "B<R_LAST>"

#. type: Plain text
#: build/C/man3/dbopen.3:385
msgid ""
"The last key/data pair of the database is returned, and the cursor is set or "
"initialized to reference it.  (Applicable only to the B<DB_BTREE> and "
"B<DB_RECNO> access methods.)"
msgstr ""
"データベースの最後のキー/データ対が返される。カーソルはそれを参照する ように"
"セットまたは初期化される。 (B<DB_BTREE> と B<DB_RECNO> アクセスメソッドだけで"
"使える。)"

#. type: TP
#: build/C/man3/dbopen.3:385
#, no-wrap
msgid "B<R_NEXT>"
msgstr "B<R_NEXT>"

#. type: Plain text
#: build/C/man3/dbopen.3:391
msgid ""
"Retrieve the key/data pair immediately after the cursor.  If the cursor is "
"not yet set, this is the same as the B<R_FIRST> flag."
msgstr ""
"カーソル直後のキー/データ対を取得する。 カーソルがセットされていない場合は "
"B<R_FIRST> フラグと同じ。"

#. type: TP
#: build/C/man3/dbopen.3:391
#, no-wrap
msgid "B<R_PREV>"
msgstr "B<R_PREV>"

#. type: Plain text
#: build/C/man3/dbopen.3:402
msgid ""
"Retrieve the key/data pair immediately before the cursor.  If the cursor is "
"not yet set, this is the same as the B<R_LAST> flag.  (Applicable only to "
"the B<DB_BTREE> and B<DB_RECNO> access methods.)"
msgstr ""
"カーソル直前のキー/データ対を取得する。 カーソルがセットされていない場合は "
"B<R_LAST> フラグと同じ。 (B<DB_BTREE> と B<DB_RECNO> アクセスメソッドだけで使"
"える。)"

#. type: Plain text
#: build/C/man3/dbopen.3:413
msgid ""
"B<R_LAST> and B<R_PREV> are available only for the B<DB_BTREE> and "
"B<DB_RECNO> access methods because they each imply that the keys have an "
"inherent order which does not change."
msgstr ""
"B<R_LAST> と B<R_PREV> は、 B<DB_BTREE> と B<DB_RECNO> アクセス方法でしか使え"
"ない。 なぜなら B<R_SETCURSOR> を用いるには、変更される事の無い固有の順序を"
"キーが持っていなければならないからである。"

#. type: Plain text
#: build/C/man3/dbopen.3:426
msgid ""
"I<seq> routines return -1 on error (setting I<errno>), 0 on success and 1 if "
"there are no key/data pairs less than or greater than the specified or "
"current key.  If the B<DB_RECNO> access method is being used, and if the "
"database file is a character special file and no complete key/data pairs are "
"currently available, the I<seq> routines return 2."
msgstr ""
"I<seq> ルーチンはエラーの場合 -1 を返し (I<errno> をセットする)、 成功の場合 "
"0 を返す。 指定したキーやカレントキーよりも大きい/小さいキー/データ対がない場"
"合は 1 を返す。 B<DB_RECNO> アクセスメソッドを使っていて、 かつデータベース"
"ファイルが文字型のスペシャルファイルで、 完成しているキー/データ対が無い場合"
"には、 I<seq> ルーチンは 2 を返す。"

#. type: TP
#: build/C/man3/dbopen.3:426
#, no-wrap
msgid "I<sync>"
msgstr "I<sync>"

#. type: Plain text
#: build/C/man3/dbopen.3:432
msgid ""
"A pointer to a routine to flush any cached information to disk.  If the "
"database is in memory only, the I<sync> routine has no effect and will "
"always succeed."
msgstr ""
"キャッシュされた情報をディスクに掃き出すルーチンへのポインター。 データベース"
"がメモリーの中だけにある場合、 I<sync> ルーチンは何の効果もなく常に成功する。"

#. type: Plain text
#: build/C/man3/dbopen.3:434
msgid "The flag value may be set to the following value:"
msgstr "flag には以下の値がセットできる。"

#. type: TP
#: build/C/man3/dbopen.3:435
#, no-wrap
msgid "B<R_RECNOSYNC>"
msgstr "B<R_RECNOSYNC>"

#. type: Plain text
#: build/C/man3/dbopen.3:447
msgid ""
"If the B<DB_RECNO> access method is being used, this flag causes the sync "
"routine to apply to the btree file which underlies the recno file, not the "
"recno file itself.  (See the I<bfname> field of the B<recno>(3)  manual page "
"for more information.)"
msgstr ""
"B<DB_RECNO> アクセスメソッドを使っている場合に このフラグをセットすると、 "
"recno ファイルそのものにではなく、 そのベースになっている btree ファイルに "
"sync が行われる。 (詳細は B<recno>(3)  マニュアルページで I<bfname> フィール"
"ドを説明している部分を参照のこと。)"

#. type: Plain text
#: build/C/man3/dbopen.3:453
msgid ""
"I<sync> routines return -1 on error (setting I<errno>)  and 0 on success."
msgstr ""
"I<sync> ルーチンはエラーの場合 -1 を返し (I<errno> をセットする)、成功すると "
"0 を返す。"

#. type: SS
#: build/C/man3/dbopen.3:453
#, no-wrap
msgid "Key/data pairs"
msgstr "キー/データ対"

#. type: Plain text
#: build/C/man3/dbopen.3:456
msgid ""
"Access to all file types is based on key/data pairs.  Both keys and data are "
"represented by the following data structure:"
msgstr ""
"全てのファイルタイプにおいて、 キー/データ対をベースにしてアクセスが行われ"
"る。 キーとデータのいずれも、次のデータ構造で記述される。"

#. type: Plain text
#: build/C/man3/dbopen.3:463
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *data;\n"
"    size_t size;\n"
"} DBT;\n"
msgstr ""
"typedef struct {\n"
"    void  *data;\n"
"    size_t size;\n"
"} DBT;\n"

#. type: Plain text
#: build/C/man3/dbopen.3:469
msgid "The elements of the I<DBT> structure are defined as follows:"
msgstr "I<DBT> 構造体の各要素は次のように定義されている。"

#. type: TP
#: build/C/man3/dbopen.3:469
#, no-wrap
msgid "I<data>"
msgstr "I<data>"

#. type: Plain text
#: build/C/man3/dbopen.3:472
msgid "A pointer to a byte string."
msgstr "バイト文字列へのポインター。"

#. type: TP
#: build/C/man3/dbopen.3:472
#, no-wrap
msgid "I<size>"
msgstr "I<size>"

#. type: Plain text
#: build/C/man3/dbopen.3:475
msgid "The length of the byte string."
msgstr "バイト文字列の長さ。"

#. type: Plain text
#: build/C/man3/dbopen.3:481
msgid ""
"Key and data byte strings may reference strings of essentially unlimited "
"length although any two of them must fit into available memory at the same "
"time.  It should be noted that the access methods provide no guarantees "
"about byte string alignment."
msgstr ""
"キーとデータのバイト文字列は、 基本的には無制限の長さの文字列を参照できる"
"が、 しかしいずれも使用可能なメモリーに収まっていなくてはならない。 アクセス"
"メソッドはバイト文字列のアラインメントについては 何も保証していない事に注意す"
"ること。"

#. type: Plain text
#: build/C/man3/dbopen.3:491
msgid ""
"The B<dbopen>()  routine may fail and set I<errno> for any of the errors "
"specified for the library routines B<open>(2)  and B<malloc>(3)  or the "
"following:"
msgstr ""
"B<dbopen>()  ルーチンは失敗するとライブラリルーチン B<open>(2)  と "
"B<malloc>(3)  で指定されているエラーに応じた I<errno> をセットする。あるいは"
"以下をセットする。"

#. type: TP
#: build/C/man3/dbopen.3:491
#, no-wrap
msgid "B<EFTYPE>"
msgstr "B<[EFTYPE]>"

#. type: Plain text
#: build/C/man3/dbopen.3:494
msgid "A file is incorrectly formatted."
msgstr "ファイルが正しくフォーマットされていない。"

#. type: TP
#: build/C/man3/dbopen.3:494 build/C/man3/mpool.3:198 build/C/man3/recno.3:218
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/dbopen.3:501
msgid ""
"A parameter has been specified (hash function, pad byte, etc.) that is "
"incompatible with the current file specification or which is not meaningful "
"for the function (for example, use of the cursor without prior "
"initialization) or there is a mismatch between the version number of file "
"and the software."
msgstr ""
"指定したパラメーター (ハッシュ関数、バイト埋めなど) が現在のファイル仕様\n"
"に合っていない、パラメーターが関数にとって無意味 (例えば、あらかじめ初期\n"
"化しないでカーソルを使うとか)、ファイルとソフトウェアのバージョンが\n"
"合っていない。"

#. type: Plain text
#: build/C/man3/dbopen.3:513
msgid ""
"The I<close> routines may fail and set I<errno> for any of the errors "
"specified for the library routines B<close>(2), B<read>(2), B<write>(2), "
"B<free>(3), or B<fsync>(2)."
msgstr ""
"I<close> ルーチンは失敗するとライブラリルーチン B<close>(2), B<read>(2), "
"B<write>(2), B<free>(3), B<fsync>(2)  で指定されているエラーに応じた "
"I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/dbopen.3:528
msgid ""
"The I<del>, I<get>, I<put>, and I<seq> routines may fail and set I<errno> "
"for any of the errors specified for the library routines B<read>(2), "
"B<write>(2), B<free>(3)  or B<malloc>(3)."
msgstr ""
"I<del>, I<get>, I<put>, I<seq> ルーチンは失敗するとライブラリルーチン "
"B<read>(2), B<write>(2), B<free>(3), B<malloc>(3)  で指定されているエラーに応"
"じた I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/dbopen.3:536
msgid ""
"The I<fd> routines will fail and set I<errno> to B<ENOENT> for in memory "
"databases."
msgstr ""
"I<fd> ルーチンはメモリー内データベースに対し失敗すると I<errno> に B<ENOENT> "
"をセットする。"

#. type: Plain text
#: build/C/man3/dbopen.3:543
msgid ""
"The I<sync> routines may fail and set I<errno> for any of the errors "
"specified for the library routine B<fsync>(2)."
msgstr ""
"I<sync> ルーチンは失敗するとライブラリルーチン B<fsync>(2)  で指定されている"
"エラーに応じた I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/dbopen.3:548
msgid ""
"The typedef I<DBT> is a mnemonic for \"data base thang\", and was used "
"because no one could think of a reasonable name that wasn't already used."
msgstr ""
"typedef I<DBT> は ``data base thang''の略語であるが、これが使われているの"
"は、 まだ使われていない妥当な名前が思い付かなかったためである。"

#. type: Plain text
#: build/C/man3/dbopen.3:551
msgid ""
"The file descriptor interface is a kludge and will be deleted in a future "
"version of the interface."
msgstr ""
"ファイルディスクリプターを使ったやりとりはひどい代物であり、 将来のバージョン"
"では削除されるだろう。"

#. type: Plain text
#: build/C/man3/dbopen.3:554
msgid ""
"None of the access methods provide any form of concurrent access, locking, "
"or transactions."
msgstr ""
"どのアクセスメソッドも、同時アクセス、ロック、トランザクション の仕組みは備え"
"ていない。"

#. type: Plain text
#: build/C/man3/dbopen.3:559
msgid "B<btree>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"
msgstr "B<btree>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"

#. type: Plain text
#: build/C/man3/dbopen.3:562
msgid ""
"I<LIBTP: Portable, Modular Transactions for UNIX>, Margo Seltzer, Michael "
"Olson, USENIX proceedings, Winter 1992."
msgstr ""
"I<LIBTP: Portable, Modular Transactions for UNIX>, Margo Seltzer, Michael "
"Olson, USENIX proceedings, Winter 1992."

#. type: TH
#: build/C/man3/hash.3:36
#, no-wrap
msgid "HASH"
msgstr "HASH"

#. type: Plain text
#: build/C/man3/hash.3:40
msgid "hash - hash database access method"
msgstr "hash - hash データベースへのアクセスメソッド"

#. type: Plain text
#: build/C/man3/hash.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is hash files.  The general description of the "
"database access methods is in B<dbopen>(3), this manual page describes only "
"the hash-specific information."
msgstr ""
"ルーチン B<dbopen>(3)  はデータベースファイルに対するライブラリインターフェー"
"スである。 サポートされているファイルフォーマットのひとつに hash ファイルがあ"
"る。 データベースへのアクセスメソッドに関する一般的な記述は B<dbopen>(3)  に"
"書かれている。 このマニュアルページでは hash 特有の情報についてのみ記述する。"

#. type: Plain text
#: build/C/man3/hash.3:64
msgid "The hash data structure is an extensible, dynamic hashing scheme."
msgstr "hash データ構造は、拡張可能な動的ハッシュスキームである。"

#. type: Plain text
#: build/C/man3/hash.3:70
msgid ""
"The access-method-specific data structure provided to B<dbopen>(3)  is "
"defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""
"B<dbopen>(3)  に渡される hash アクセスメソッドに特有のデータ構造体は、 "
"I<E<lt>db.hE<gt>> インクルードファイルで以下のように定義されている。"

#. type: Plain text
#: build/C/man3/hash.3:81
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned int       bsize;\n"
"    unsigned int       ffactor;\n"
"    unsigned int       nelem;\n"
"    unsigned int       cachesize;\n"
"    uint32_t         (*hash)(const void *, size_t);\n"
"    int         lorder;\n"
"} HASHINFO;\n"
msgstr ""
"typedef struct {\n"
"    unsigned int       bsize;\n"
"    unsigned int       ffactor;\n"
"    unsigned int       nelem;\n"
"    unsigned int       cachesize;\n"
"    uint32_t         (*hash)(const void *, size_t);\n"
"    int         lorder;\n"
"} HASHINFO;\n"

#. type: TP
#: build/C/man3/hash.3:85
#, no-wrap
msgid "I<bsize>"
msgstr "I<bsize>"

#. type: Plain text
#: build/C/man3/hash.3:90
msgid ""
"defines the hash table bucket size, and is, by default, 256 bytes.  It may "
"be preferable to increase the page size for disk-resident tables and tables "
"with large data items."
msgstr ""
"hash テーブルバケット (table bucket) のサイズを定義する。 デフォルトは 256 バ"
"イトである。 ディスクに置かれるテーブルやデータアイテムが大きいテーブルでは "
"ページサイズを大きくするほうが良いだろう。"

#. type: TP
#: build/C/man3/hash.3:90
#, no-wrap
msgid "I<ffactor>"
msgstr "I<ffactor>"

#. type: Plain text
#: build/C/man3/hash.3:96
msgid ""
"indicates a desired density within the hash table.  It is an approximation "
"of the number of keys allowed to accumulate in any one bucket, determining "
"when the hash table grows or shrinks.  The default value is 8."
msgstr ""
"ユーザーが望む hash テーブル中の密度である。 これはそれぞれのバケットに格納で"
"きるキーの概数であり、 hash テーブルを拡大・縮小を作用する。 デフォルトは 8 "
"である。"

#. type: TP
#: build/C/man3/hash.3:96
#, no-wrap
msgid "I<nelem>"
msgstr "I<nelem>"

#. type: Plain text
#: build/C/man3/hash.3:102
msgid ""
"is an estimate of the final size of the hash table.  If not set or set too "
"low, hash tables will expand gracefully as keys are entered, although a "
"slight performance degradation may be noticed.  The default value is 1."
msgstr ""
"hash テーブルの最終サイズを大まかに見積もった値である。 この値がセットされて"
"いなかったり、あまりに低くセットされていると、 hash テーブルはキーが入ってく"
"るに応じて拡張される。 しかし少しパフォーマンスが (おそらく気付く程度に) 落ち"
"る。 デフォルト値は 1 である。"

#. type: Plain text
#: build/C/man3/hash.3:108
msgid ""
"is the suggested maximum size, in bytes, of the memory cache.  This value is "
"I<only advisory>, and the access method will allocate more memory rather "
"than fail."
msgstr ""
"メモリーキャッシュの最大値 (バイト単位) の参考値。 この値は B<あくまで参考で"
"あり>、 アクセスメソッドはこの値を越えたメモリーの割り当てに成功することもあ"
"る。"

#. type: TP
#: build/C/man3/hash.3:108
#, no-wrap
msgid "I<hash>"
msgstr "I<hash>"

#. type: Plain text
#: build/C/man3/hash.3:117
msgid ""
"is a user-defined hash function.  Since no hash function performs equally "
"well on all possible data, the user may find that the built-in hash function "
"does poorly on a particular data set.  A user-specified hash functions must "
"take two arguments (a pointer to a byte string and a length) and return a 32-"
"bit quantity to be used as the hash value."
msgstr ""
"はユーザー定義の hash 関数である。 全てのデータに対してうまく作用する hash 関"
"数と言うのはないから、 特定のデータセットに対しては組み込みの hash 関数では "
"パフォーマンスが低いこともあるかもしれない。 ユーザー定義の hash 関数は二つの"
"引数をとらなくてはならない (バイト文字 列へのポインターと、長さ)。 そして "
"hash 値として使われる 32ビットの値を返さなくてはならない。"

#. type: Plain text
#: build/C/man3/hash.3:127
msgid ""
"is the byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used.  If the file already exists, the specified value "
"is ignored and the value specified when the tree was created is used."
msgstr ""
"データベースに格納されているメタデータの整数値のバイトオーダー。 この数字は、"
"順序を整数で表したものである。 例えばビッグエンディアンなら、この数値は "
"4,321 となる。 I<lorder> が 0 (指定されていない)場合、現在のホスト で使われて"
"いる並び順が使われる。 ファイルが既に存在する場合、指定した値は無視されツリー"
"が作られ た時に指定されていた値が使われる。"

#. type: Plain text
#: build/C/man3/hash.3:139
msgid ""
"If the file already exists (and the B<O_TRUNC> flag is not specified), the "
"values specified for I<bsize>, I<ffactor>, I<lorder>, and I<nelem> are "
"ignored and the values specified when the tree was created are used."
msgstr ""
"ファイルが既に存在している (または B<O_TRUNC> フラグが指定されていない) と、 "
"I<bsize>, I<ffactor>, I<lorder>, I<nelem> に指定された値は無視され、 ハッシュ"
"が作られた時に使った値が使われる。"

#. type: Plain text
#: build/C/man3/hash.3:144
msgid ""
"If a hash function is specified, I<hash_open> attempts to determine if the "
"hash function specified is the same as the one with which the database was "
"created, and fails if it is not."
msgstr ""
"hash 関数が指定されると、 I<hash_open> はデータベースが作られた時に指定されて"
"いた hash 関数と今回指定された hash 関数が同じかどうかを調べ、 同じでない場合"
"には失敗する。"

#. type: Plain text
#: build/C/man3/hash.3:151
msgid ""
"Backward-compatible interfaces to the routines described in B<dbm>(3), and "
"B<ndbm>(3)  are provided, however these interfaces are not compatible with "
"previous file formats."
msgstr ""
"B<dbm>(3), と B<ndbm>(3)  に記述されているルーチンへの過去互換を取るためのイ"
"ンターフェイスが 存在する。しかしこれらのインターフェイスは以前のファイル"
"フォー マットとは互換性がない。"

#. type: Plain text
#: build/C/man3/hash.3:158
msgid ""
"The I<hash> access method routines may fail and set I<errno> for any of the "
"errors specified for the library routine B<dbopen>(3)."
msgstr ""
"I<hash> アクセスメソッドルーチンは、失敗するとライブラリルーチン "
"B<dbopen>(3)  で指定されているエラーに応じた I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/hash.3:160
msgid "Only big and little endian byte order are supported."
msgstr ""
"バイトオーダーとしてはビッグエンディアンとリトルエンディアンのみが サポートさ"
"れている。"

#. type: Plain text
#: build/C/man3/hash.3:165
msgid "B<btree>(3), B<dbopen>(3), B<mpool>(3), B<recno>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<mpool>(3), B<recno>(3)"

#. type: Plain text
#: build/C/man3/hash.3:168
msgid ""
"I<Dynamic Hash Tables>, Per-Ake Larson, Communications of the ACM, April "
"1988."
msgstr ""
"I<Dynamic Hash Tables>, Per-Ake Larson, Communications of the ACM, April "
"1988."

#. type: Plain text
#: build/C/man3/hash.3:171
msgid ""
"I<A New Hash Package for UNIX>, Margo Seltzer, USENIX Proceedings, Winter "
"1991."
msgstr ""
"I<A New Hash Package for UNIX>, Margo Seltzer, USENIX Proceedings, Winter "
"1991."

#. type: TH
#: build/C/man3/mpool.3:36
#, no-wrap
msgid "MPOOL"
msgstr "MPOOL"

#. type: Plain text
#: build/C/man3/mpool.3:40
msgid "mpool - shared memory buffer pool"
msgstr "mpool - 共有メモリーバッファープール"

#. type: Plain text
#: build/C/man3/mpool.3:44
#, no-wrap
msgid ""
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>mpool.hE<gt>>\n"
msgstr ""
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>mpool.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mpool.3:47
#, no-wrap
msgid "B<MPOOL *mpool_open(DBT *>I<key>B<, int >I<fd>B<, pgno_t >I<pagesize>B<, pgno_t >I<maxcache>B<);>\n"
msgstr "B<MPOOL *mpool_open(DBT *>I<key>B<, int >I<fd>B<, pgno_t >I<pagesize>B<, pgno_t >I<maxcache>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:51
#, no-wrap
msgid ""
"B<void mpool_filter(MPOOL *>I<mp>B<, void (*pgin)(void *, pgno_t, void *),>\n"
"B<                  void (*>I<pgout>B<)(void *, pgno_t, void *),>\n"
"B<                  void *>I<pgcookie>B<);>\n"
msgstr ""
"B<void mpool_filter(MPOOL *>I<mp>B<, void (*pgin)(void *, pgno_t, void *),>\n"
"B<                  void (*>I<pgout>B<)(void *, pgno_t, void *),>\n"
"B<                  void *>I<pgcookie>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:53
#, no-wrap
msgid "B<void *mpool_new(MPOOL *>I<mp>B<, pgno_t *>I<pgnoaddr>B<);>\n"
msgstr "B<void *mpool_new(MPOOL *>I<mp>B<, pgno_t *>I<pgnoaddr>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:55
#, no-wrap
msgid "B<void *mpool_get(MPOOL *>I<mp>B<, pgno_t >I<pgno>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<void *mpool_get(MPOOL *>I<mp>B<, pgno_t >I<pgno>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:57
#, no-wrap
msgid "B<int mpool_put(MPOOL *>I<mp>B<, void *>I<pgaddr>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<int mpool_put(MPOOL *>I<mp>B<, void *>I<pgaddr>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:59
#, no-wrap
msgid "B<int mpool_sync(MPOOL *>I<mp>B<);>\n"
msgstr "B<int mpool_sync(MPOOL *>I<mp>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:61
#, no-wrap
msgid "B<int mpool_close(MPOOL *>I<mp>B<);>\n"
msgstr "B<int mpool_close(MPOOL *>I<mp>B<);>\n"

#. type: Plain text
#: build/C/man3/mpool.3:74
msgid ""
"I<Mpool> is the library interface intended to provide page oriented buffer "
"management of files.  The buffers may be shared between processes."
msgstr ""
"I<mpool> は、ファイルに対するページ指向のバッファー管理を実装した ライブラリ"
"インターフェイスである。"

#. type: Plain text
#: build/C/man3/mpool.3:95
msgid ""
"The function B<mpool_open>()  initializes a memory pool.  The I<key> "
"argument is the byte string used to negotiate between multiple processes "
"wishing to share buffers.  If the file buffers are mapped in shared memory, "
"all processes using the same key will share the buffers.  If I<key> is NULL, "
"the buffers are mapped into private memory.  The I<fd> argument is a file "
"descriptor for the underlying file, which must be seekable.  If I<key> is "
"non-NULL and matches a file already being mapped, the I<fd> argument is "
"ignored."
msgstr ""
"関数 B<mpool_open>()  はメモリープールを初期化する。 I<key> 引数はバイト文字"
"列であり、バッファーを共有したい複数プロセス間 でのネゴシエーションに使われ"
"る。 ファイルバッファーが共有メモリーにマップされると、 同じキーを使うプロセ"
"スは全てバッファーを共有する。 I<key> が NULL だと、バッファーはプライベート"
"なメモリーに割り付けられる。 I<fd> 引数はもとになるファイルのファイルディスク"
"リプターである。 このファイルディスクリプターはシーク可能でなくてはならな"
"い。 I<key> が NULL でなく、かつ既にマップされているファイルにマッチした場"
"合、 I<fd> 引数は無視される。"

#. type: Plain text
#: build/C/man3/mpool.3:106
msgid ""
"The I<pagesize> argument is the size, in bytes, of the pages into which the "
"file is broken up.  The I<maxcache> argument is the maximum number of pages "
"from the underlying file to cache at any one time.  This value is not "
"relative to the number of processes which share a file's buffers, but will "
"be the largest value specified by any of the processes sharing the file."
msgstr ""
"I<pagesize> 引数はバイト単位でのページサイズであり、ファイルはこのサイズに分"
"割される。 I<maxcache> 引数は基ファイルをキャッシュするときに用いる最大ページ"
"数である。 この値はファイルバッファーを共有しているプロセスの数には関係ない"
"が、 ファイルを共有するプロセスが指定したうちの最大値が実際に用いられる。"

#. type: Plain text
#: build/C/man3/mpool.3:122
msgid ""
"The B<mpool_filter>()  function is intended to make transparent input and "
"output processing of the pages possible.  If the I<pgin> function is "
"specified, it is called each time a buffer is read into the memory pool from "
"the backing file.  If the I<pgout> function is specified, it is called each "
"time a buffer is written into the backing file.  Both functions are called "
"with the I<pgcookie> pointer, the page number and a pointer to the page to "
"being read or written."
msgstr ""
"関数 B<mpool_filter>()  は透過的なページ入出力処理を可能にする。 関数 "
"I<pgin> が指定されていると、 ファイルからメモリープールに読み込まれる度にこの"
"関数が呼び出される。 関数 I<pgout> が指定されていと、 バッファーからファイル"
"に書き出される度にこの関数が呼び出される。 どちらの関数も、 I<pgcookie> ポイ"
"ンター、ページ数、読み書きされるページへのポインターを引数にとる。"

#. type: Plain text
#: build/C/man3/mpool.3:135
msgid ""
"The function B<mpool_new>()  takes an I<MPOOL> pointer and an address as "
"arguments.  If a new page can be allocated, a pointer to the page is "
"returned and the page number is stored into the I<pgnoaddr> address.  "
"Otherwise, NULL is returned and I<errno> is set."
msgstr ""
"関数 B<mpool_new>()  は I<MPOOL> ポインターとアドレスを引数にとる。 新しい"
"ページが割り当て可能な場合、ページへのポインターが返され、 ページ数が "
"I<pgnoaddr> アドレスに納められる。 割り当てが不可能な場合は NULL が返され、 "
"I<errno> がセットされる。"

#. type: Plain text
#: build/C/man3/mpool.3:148
msgid ""
"The function B<mpool_get>()  takes an I<MPOOL> pointer and a page number as "
"arguments.  If the page exists, a pointer to the page is returned.  "
"Otherwise, NULL is returned and I<errno> is set.  The I<flags> argument is "
"not currently used."
msgstr ""
"関数 B<mpool_get>()  は I<MPOOL> ポインターとページ数を引数にとる。ページが存"
"在していると、 ページへのポインターが返される。 存在していないと NULL が返さ"
"れ、 I<errno> がセットされる。 I<flags> 引数は現在使用されていない。"

#. type: Plain text
#: build/C/man3/mpool.3:160
msgid ""
"The function B<mpool_put>()  unpins the page referenced by I<pgaddr>.  "
"I<pgaddr> must be an address previously returned by B<mpool_get>()  or "
"B<mpool_new>().  The flag value is specified by ORing any of the following "
"values:"
msgstr ""
"関数 B<mpool_put>()  は I<pgaddr> が参照するページを解放する。 I<pgaddr> は以"
"前に B<mpool_get>()  か B<mpool_new>()  が返したアドレスでなければならない。 "
"flag の値は以下の値の論理和で指定する。"

#. type: TP
#: build/C/man3/mpool.3:160
#, no-wrap
msgid "B<MPOOL_DIRTY>"
msgstr "B<MPOOL_DIRTY>"

#. type: Plain text
#: build/C/man3/mpool.3:163
msgid "The page has been modified and needs to be written to the backing file."
msgstr "ページは変更されており、ファイルに書き出す必要がある。"

#. type: Plain text
#: build/C/man3/mpool.3:166
msgid "B<mpool_put>()  returns 0 on success and -1 if an error occurs."
msgstr "B<mpool_put>()  は成功すると 0 を、エラーがあると -1 を返す。"

#. type: Plain text
#: build/C/man3/mpool.3:175
msgid ""
"The function B<mpool_sync>()  writes all modified pages associated with the "
"I<MPOOL> pointer to the backing file.  B<mpool_sync>()  returns 0 on success "
"and -1 if an error occurs."
msgstr ""
"関数 B<mpool_sync>()  は I<MPOOL> ポインターの示すページのうち、 変更されたも"
"のを全てファイルに書き出す。 B<mpool_sync>()  は成功すると 0 を、エラーがある"
"と -1 を返す。"

#. type: Plain text
#: build/C/man3/mpool.3:185
msgid ""
"The B<mpool_close>()  function free's up any allocated memory associated "
"with the memory pool cookie.  Modified pages are B<not> written to the "
"backing file.  B<mpool_close>()  returns 0 on success and -1 if an error "
"occurs."
msgstr ""
"関数 B<mpool_close>()  はメモリープールクッキーの示す割り当て済みのメモリーを"
"解放する。 変更されたページはファイルにB<書き出されない>。 I<mpool_close ()> "
"は成功すると 0 を、エラーがあると -1 を返す。"

#. type: Plain text
#: build/C/man3/mpool.3:192
msgid ""
"The B<mpool_open>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<malloc>(3)."
msgstr ""
"関数 B<mpool_open>()  は失敗するとライブラリルーチン B<malloc>(3)  で指定され"
"ているエラーに応じた I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/mpool.3:198
msgid ""
"The B<mpool_get>()  function may fail and set I<errno> for the following:"
msgstr "関数 B<mpool_get>()  は失敗すると次のような I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/mpool.3:201
msgid "The requested record doesn't exist."
msgstr "要求のあったレコードは存在しない。"

#. type: Plain text
#: build/C/man3/mpool.3:213
msgid ""
"The B<mpool_new>()  and B<mpool_get>()  functions may fail and set I<errno> "
"for any of the errors specified for the library routines B<read>(2), "
"B<write>(2), and B<malloc>(3)."
msgstr ""
"関数 B<mpool_new>()  と B<mpool_get>()  は失敗するとライブラリルーチン "
"B<read>(2), B<write>(2), B<malloc>(3)  で指定されているエラーに応じた "
"I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/mpool.3:220
msgid ""
"The B<mpool_sync>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<write>(2)."
msgstr ""
"関数 B<mpool_sync>()  は失敗するとライブラリルーチン B<write>(2)  で指定され"
"ているエラーに応じた I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/mpool.3:227
msgid ""
"The B<mpool_close>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<free>(3)."
msgstr ""
"関数 B<mpool_close>()  は失敗するとライブラリルーチン B<free>(3)  で指定され"
"ているエラーに応じた I<errno> をセットする。"

#. type: SH
#: build/C/man3/mpool.3:227
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/mpool.3:230
msgid "Not in POSIX.1.  Present on the BSDs."
msgstr "POSIX.1 にはない。 BSD 系に存在する。"

#. type: Plain text
#: build/C/man3/mpool.3:235
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<recno>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<hash>(3), B<recno>(3)"

#. type: TH
#: build/C/man3/recno.3:36
#, no-wrap
msgid "RECNO"
msgstr "RECNO"

#. type: Plain text
#: build/C/man3/recno.3:40
msgid "recno - record number database access method"
msgstr "recno - レコード番号データベースへのアクセスメソッド"

#. type: Plain text
#: build/C/man3/recno.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is record number files.  The general "
"description of the database access methods is in B<dbopen>(3), this manual "
"page describes only the recno-specific information."
msgstr ""
"ルーチン B<dbopen>(3)  はデータベースファイルに対するライブラリインターフェー"
"スである。 サポートされているファイルフォーマットの一つに、 レコード番号ファ"
"イル (record number file: recno file) がある。 データベースへのアクセスメソッ"
"ドに関する一般的な記述は B<dbopen>(3), に書かれている。 このマニュアルページ"
"では recno 特有の情報についてのみ記述する。"

#. type: Plain text
#: build/C/man3/recno.3:71
msgid ""
"The record number data structure is either variable or fixed-length records "
"stored in a flat-file format, accessed by the logical record number.  The "
"existence of record number five implies the existence of records one through "
"four, and the deletion of record number one causes record number five to be "
"renumbered to record number four, as well as the cursor, if positioned after "
"record number one, to shift down one record."
msgstr ""
"レコード番号データ構造は、フラットなファイル形式に格納された 可変長/固定長レ"
"コードからなり、論理レコード番号でアクセスされる。 レコード番号 5 があれば、"
"レコード番号 1 から 4 も存在する。 レコード番号 1 を削除すると、レコード番号 "
"5 は 4 に付け替えられ、 カーソルも移動する。レコード番号 1 以降のものは一つ繰"
"り上がるわけである。"

#. type: Plain text
#: build/C/man3/recno.3:77
msgid ""
"The recno access-method-specific data structure provided to B<dbopen>(3)  is "
"defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""
"B<dbopen>(3)  で使う recno アクセスメソッドに特有のデータ構造体は、 "
"I<E<lt>db.hE<gt>> インクルードファイルで次のように定義されている。"

#. type: Plain text
#: build/C/man3/recno.3:89
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"
msgstr ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"

#. type: Plain text
#: build/C/man3/recno.3:93
msgid "The elements of this structure are defined as follows:"
msgstr "この構造体の要素を以下に示す。"

#. type: TP
#: build/C/man3/recno.3:98
#, no-wrap
msgid "B<R_FIXEDLEN>"
msgstr "B<R_FIXEDLEN>"

#. type: Plain text
#: build/C/man3/recno.3:109
msgid ""
"The records are fixed-length, not byte delimited.  The structure element "
"I<reclen> specifies the length of the record, and the structure element "
"I<bval> is used as the pad character.  Any records, inserted into the "
"database, that are less than I<reclen> bytes long are automatically padded."
msgstr ""
"レコード長が固定であり、バイト区切りではない。 構造体の要素 I<reclen> はレ"
"コードの長さを指定する。また、要素 I<bval> は埋め文字 (pad character) を指定"
"する。 データベースに入れられたレコードの内 I<reclen> バイトに満たないもので"
"は、残りの部分に埋め文字が自動的に入る。"

#. type: TP
#: build/C/man3/recno.3:109
#, no-wrap
msgid "B<R_NOKEY>"
msgstr "B<R_NOKEY>"

#. type: Plain text
#: build/C/man3/recno.3:122
msgid ""
"In the interface specified by B<dbopen>(3), the sequential record retrieval "
"fills in both the caller's key and data structures.  If the B<R_NOKEY> flag "
"is specified, the I<cursor> routines are not required to fill in the key "
"structure.  This permits applications to retrieve records at the end of "
"files without reading all of the intervening records."
msgstr ""
"B<dbopen>(3)  で指定されたインターフェイスでは、シーケンシャルなレコード取得"
"は 呼び出しキーとデータ構造体の両方を埋めていく。 B<R_NOKEY> フラグが指定され"
"ていると、キー構造体を埋めるのに I<cursor> ルーチンを必要としない。 これを用"
"いれば、アプリケーションがファイルの終りの方を取得する際に、 その途中のレコー"
"ドを読まなくても済む事になる。"

#. type: TP
#: build/C/man3/recno.3:122
#, no-wrap
msgid "B<R_SNAPSHOT>"
msgstr "B<R_SNAPSHOT>"

#. type: Plain text
#: build/C/man3/recno.3:128
msgid ""
"This flag requires that a snapshot of the file be taken when B<dbopen>(3)  "
"is called, instead of permitting any unmodified records to be read from the "
"original file."
msgstr ""
"このフラグを指定すると、 B<dbopen>(3)  の呼び出しの際、 オリジナルファイルか"
"ら変更されていないレコードを読む代わりに、 ファイルの snapshot を用いる。"

#. type: Plain text
#: build/C/man3/recno.3:138
msgid ""
"A suggested maximum size, in bytes, of the memory cache.  This value is "
"B<only> advisory, and the access method will allocate more memory rather "
"than fail.  If I<cachesize> is 0 (no size is specified), a default cache is "
"used."
msgstr ""
"想定されるメモリーキャッシュの最大サイズ (バイト単位)。 この値は B<あくまで> "
"参考であり、アクセスメソッドはこの値を越えたメモリーの 割り当てに成功すること"
"もある。 I<cachesize> が 0 (あるいは指定されていない) の場合、デフォルトの"
"キャッシュが使われる。"

#. type: Plain text
#: build/C/man3/recno.3:150
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  This value is the size (in bytes) of the pages used for nodes in "
"that tree.  If I<psize> is 0 (no page size is specified), a page size is "
"chosen based on the underlying filesystem I/O block size.  See B<btree>(3)  "
"for more information."
msgstr ""
"recno アクセスメソッドは、自身のレコードのコピーをメモリー内部に btree で保存"
"している。 この値は、その btree 中のノードに対して用いられる ページサイズ (バ"
"イト単位) である。 I<psize> が 0 (あるいは指定されていない) の場合、 ファイル"
"システムの I/O ブロックサイズを基にして ページサイズが決められる。 詳細は "
"B<btree>(3)  を参照。"

#. type: TP
#: build/C/man3/recno.3:158
#, no-wrap
msgid "I<reclen>"
msgstr "I<reclen>"

#. type: Plain text
#: build/C/man3/recno.3:161
msgid "The length of a fixed-length record."
msgstr "固定レコード長の長さ。"

#. type: TP
#: build/C/man3/recno.3:161
#, no-wrap
msgid "I<bval>"
msgstr "I<bval>"

#. type: Plain text
#: build/C/man3/recno.3:169
msgid ""
"The delimiting byte to be used to mark the end of a record for variable-"
"length records, and the pad character for fixed-length records.  If no value "
"is specified, newlines (\"\\en\") are used to mark the end of variable-"
"length records and fixed-length records are padded with spaces."
msgstr ""
"可変レコード長において、 レコードの終りを示す区切りバイト (区切り文字) であ"
"る。 固定レコード長では埋め文字として使われる。 値が指定されていないと、 可変"
"レコード長のレコードの終りには改行 (\"\\en\") が使われる。 固定レコード長のレ"
"コードは空白 (space) で埋められる。"

#. type: TP
#: build/C/man3/recno.3:169
#, no-wrap
msgid "I<bfname>"
msgstr "I<bfname>"

#. type: Plain text
#: build/C/man3/recno.3:179
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  If I<bfname> is non-NULL, it specifies the name of the btree file, "
"as if specified as the filename for a B<dbopen>(3)  of a btree file."
msgstr ""
"recno アクセスメソッドは、 自身のレコードのコピーをメモリー内部で btree に保"
"存している。 I<bfname> が NULL でない場合、これは btree ファイル名 (btree "
"ファイルを B<dbopen>(3)  する時に指定するファイル名) を指定する。"

#. type: Plain text
#: build/C/man3/recno.3:197
msgid ""
"The data part of the key/data pair used by the I<recno> access method is the "
"same as other access methods.  The key is different.  The I<data> field of "
"the key should be a pointer to a memory location of type I<recno_t>, as "
"defined in the I<E<lt>db.hE<gt>> include file.  This type is normally the "
"largest unsigned integral type available to the implementation.  The I<size> "
"field of the key should be the size of that type."
msgstr ""
"I<recno> アクセスメソッドで使われるキー/データ対のデータ部分は、 他のアクセス"
"メソッドと同じである。 しかしキーは異なっている。 キーの I<data> フィールド"
"は I<recno_t> 型の、メモリー位置へのポインターでなければならない。 "
"I<recno_t> は I<E<lt>db.hE<gt>> インクルードファイルで定義されている。 この型"
"は通常、その実装で利用可能な最大の符号無し整数である。 キーの I<size> フィー"
"ルドはその型のサイズとなる。"

#. type: Plain text
#: build/C/man3/recno.3:202
msgid ""
"Because there can be no metadata associated with the underlying recno access "
"method files, any changes made to the default values (e.g., fixed record "
"length or byte separator value) must be explicitly specified each time the "
"file is opened."
msgstr ""
"recno アクセスメソッドのファイルに関連づけられる メタデータは存在できないか"
"ら、 デフォルト値 (固定レコード長やセパレータ文字など)  に対する変更はファイ"
"ルを開く毎に明示的に指定しなければならない。"

#. type: Plain text
#: build/C/man3/recno.3:210
msgid ""
"In the interface specified by B<dbopen>(3), using the I<put> interface to "
"create a new record will cause the creation of multiple, empty records if "
"the record number is more than one greater than the largest record currently "
"in the database."
msgstr ""
"B<dbopen>(3)  で指定されたインターフェイスでは、 I<put> インターフェイスを"
"使って新しいレコードを作成するときに、 指定したレコード番号がデータベース中に"
"存在している最大レコード番号より 一つ以上大きいと、 空のレコードが同時にでき"
"てしまう。"

#. type: Plain text
#: build/C/man3/recno.3:218
msgid ""
"The I<recno> access method routines may fail and set I<errno> for any of the "
"errors specified for the library routine B<dbopen>(3)  or the following:"
msgstr ""
"I<recno> アクセスメソッドルーチンは失敗すると B<dbopen>(3)  で指定されている"
"エラーに応じた I<errno> か、 あるいは以下に示す I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/recno.3:222
msgid ""
"An attempt was made to add a record to a fixed-length database that was too "
"large to fit."
msgstr "固定長データベースにレコードを追加するとき、データが長すぎた。"

#. type: Plain text
#: build/C/man3/recno.3:229
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"

#. type: Plain text
#: build/C/man3/recno.3:233
msgid ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker, "
"Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No. "
"UCB/ERL M82/32, May 1982."
msgstr ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker, "
"Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No. "
"UCB/ERL M82/32, May 1982."

#~ msgid "2012-04-23"
#~ msgstr "2012-04-23"

#~ msgid "2012-05-04"
#~ msgstr "2012-05-04"

#~ msgid "2012-04-26"
#~ msgstr "2012-04-26"
