# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-19 09:46+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsd_signal.3:25
#, no-wrap
msgid "BSD_SIGNAL"
msgstr "BSD_SIGNAL"

#. type: TH
#: build/C/man3/bsd_signal.3:25 build/C/man2/sigsuspend.2:29
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man3/bsd_signal.3:25 build/C/man2/eventfd.2:22
#: build/C/man2/getitimer.2:13 build/C/man3/gsignal.3:27 build/C/man2/kill.2:44
#: build/C/man2/pause.2:30 build/C/man2/prctl.2:59 build/C/man3/profil.3:28
#: build/C/man3/psignal.3:30 build/C/man3/raise.3:29
#: build/C/man2/restart_syscall.2:33 build/C/man2/rt_sigqueueinfo.2:25
#: build/C/man2/s390_runtime_instr.2:25 build/C/man2/sgetmask.2:25
#: build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:26
#: build/C/man7/sigevent.7:26 build/C/man3/siginterrupt.3:31
#: build/C/man2/signal.2:36 build/C/man7/signal.7:45 build/C/man2/signalfd.2:20
#: build/C/man3/sigpause.3:25 build/C/man2/sigpending.2:29
#: build/C/man2/sigprocmask.2:29 build/C/man3/sigqueue.3:28
#: build/C/man2/sigreturn.2:30 build/C/man3/sigset.3:25
#: build/C/man3/sigsetops.3:31 build/C/man2/sigsuspend.2:29
#: build/C/man3/sigvec.3:25 build/C/man3/sigwait.3:26
#: build/C/man2/sigwaitinfo.2:25 build/C/man3/sysv_signal.3:25
#: build/C/man2/timer_create.2:26 build/C/man2/timer_delete.2:26
#: build/C/man2/timer_getoverrun.2:26 build/C/man2/timer_settime.2:26
#: build/C/man2/timerfd_create.2:19 build/C/man2/tkill.2:29
#: build/C/man2/wait.2:49 build/C/man2/wait4.2:33 build/C/man3/killpg.3:42
#: build/C/man7/signal-safety.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bsd_signal.3:26 build/C/man2/eventfd.2:23
#: build/C/man2/getitimer.2:14 build/C/man3/gsignal.3:28 build/C/man2/kill.2:45
#: build/C/man2/pause.2:31 build/C/man2/prctl.2:60 build/C/man3/profil.3:29
#: build/C/man3/psignal.3:31 build/C/man3/raise.3:30
#: build/C/man2/restart_syscall.2:34 build/C/man2/rt_sigqueueinfo.2:26
#: build/C/man2/s390_runtime_instr.2:26 build/C/man2/sgetmask.2:26
#: build/C/man2/sigaction.2:49 build/C/man2/sigaltstack.2:27
#: build/C/man7/sigevent.7:27 build/C/man3/siginterrupt.3:32
#: build/C/man2/signal.2:37 build/C/man7/signal.7:46 build/C/man2/signalfd.2:21
#: build/C/man3/sigpause.3:26 build/C/man2/sigpending.2:30
#: build/C/man2/sigprocmask.2:30 build/C/man3/sigqueue.3:29
#: build/C/man2/sigreturn.2:31 build/C/man3/sigset.3:26
#: build/C/man3/sigsetops.3:32 build/C/man2/sigsuspend.2:30
#: build/C/man3/sigvec.3:26 build/C/man3/sigwait.3:27
#: build/C/man2/sigwaitinfo.2:26 build/C/man3/sysv_signal.3:26
#: build/C/man2/timer_create.2:27 build/C/man2/timer_delete.2:27
#: build/C/man2/timer_getoverrun.2:27 build/C/man2/timer_settime.2:27
#: build/C/man2/timerfd_create.2:20 build/C/man2/tkill.2:30
#: build/C/man2/wait.2:50 build/C/man2/wait4.2:34 build/C/man3/killpg.3:43
#: build/C/man7/signal-safety.7:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bsd_signal.3:28
msgid "bsd_signal - signal handling with BSD semantics"
msgstr "bsd_signal - BSD 方式のシグナル処理"

#. type: SH
#: build/C/man3/bsd_signal.3:28 build/C/man2/eventfd.2:25
#: build/C/man2/getitimer.2:16 build/C/man3/gsignal.3:30 build/C/man2/kill.2:47
#: build/C/man2/pause.2:33 build/C/man2/prctl.2:62 build/C/man3/profil.3:31
#: build/C/man3/psignal.3:33 build/C/man3/raise.3:32
#: build/C/man2/restart_syscall.2:36 build/C/man2/rt_sigqueueinfo.2:28
#: build/C/man2/s390_runtime_instr.2:28 build/C/man2/sgetmask.2:28
#: build/C/man2/sigaction.2:51 build/C/man2/sigaltstack.2:29
#: build/C/man7/sigevent.7:29 build/C/man3/siginterrupt.3:34
#: build/C/man2/signal.2:39 build/C/man2/signalfd.2:23
#: build/C/man3/sigpause.3:28 build/C/man2/sigpending.2:32
#: build/C/man2/sigprocmask.2:32 build/C/man3/sigqueue.3:31
#: build/C/man2/sigreturn.2:33 build/C/man3/sigset.3:28
#: build/C/man3/sigsetops.3:35 build/C/man2/sigsuspend.2:32
#: build/C/man3/sigvec.3:28 build/C/man3/sigwait.3:29
#: build/C/man2/sigwaitinfo.2:29 build/C/man3/sysv_signal.3:28
#: build/C/man2/timer_create.2:29 build/C/man2/timer_delete.2:29
#: build/C/man2/timer_getoverrun.2:29 build/C/man2/timer_settime.2:30
#: build/C/man2/timerfd_create.2:23 build/C/man2/tkill.2:32
#: build/C/man2/wait.2:52 build/C/man2/wait4.2:36 build/C/man3/killpg.3:45
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bsd_signal.3:30 build/C/man2/sigaltstack.2:31
#: build/C/man2/signal.2:41 build/C/man2/sigpending.2:34
#: build/C/man2/sigprocmask.2:34 build/C/man3/sigqueue.3:33
#: build/C/man3/sigset.3:30 build/C/man3/sigsetops.3:37
#: build/C/man2/sigsuspend.2:34 build/C/man3/sigvec.3:30
#: build/C/man3/sysv_signal.3:32 build/C/man3/killpg.3:47
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr "B<#include E<lt>signal.hE<gt>>"

#. type: Plain text
#: build/C/man3/bsd_signal.3:32 build/C/man2/signal.2:43
#: build/C/man3/sigset.3:32 build/C/man3/sysv_signal.3:34
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr "B<typedef void (*sighandler_t)(int);>"

#. type: Plain text
#: build/C/man3/bsd_signal.3:34
msgid ""
"B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: build/C/man3/bsd_signal.3:38 build/C/man3/gsignal.3:44
#: build/C/man2/kill.2:58 build/C/man3/profil.3:42 build/C/man3/psignal.3:44
#: build/C/man2/sigaction.2:62 build/C/man2/sigaltstack.2:37
#: build/C/man3/siginterrupt.3:44 build/C/man2/sigpending.2:40
#: build/C/man2/sigprocmask.2:51 build/C/man3/sigqueue.3:39
#: build/C/man3/sigset.3:44 build/C/man3/sigsetops.3:51
#: build/C/man2/sigsuspend.2:40 build/C/man3/sigvec.3:44
#: build/C/man3/sigwait.3:39 build/C/man2/sigwaitinfo.2:42
#: build/C/man2/timer_create.2:43 build/C/man2/timer_delete.2:41
#: build/C/man2/timer_getoverrun.2:41 build/C/man2/timer_settime.2:45
#: build/C/man2/wait.2:69 build/C/man2/wait4.2:53 build/C/man3/killpg.3:53
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/bsd_signal.3:42
msgid "B<bsd_signal>():"
msgstr "B<bsd_signal>():"

#.     || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/bsd_signal.3:47
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _XOPEN_SOURCE E<gt>= 500\n"
"        && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
msgstr ""
"glibc 2.26 以降:\n"
"    _XOPEN_SOURCE E<gt>= 500\n"
"        && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"

#. type: Plain text
#: build/C/man3/bsd_signal.3:50
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:52 build/C/man2/eventfd.2:29
#: build/C/man2/getitimer.2:24 build/C/man3/gsignal.3:52 build/C/man2/kill.2:64
#: build/C/man2/pause.2:37 build/C/man2/prctl.2:69 build/C/man3/profil.3:54
#: build/C/man3/psignal.3:54 build/C/man3/raise.3:38
#: build/C/man2/restart_syscall.2:41 build/C/man2/rt_sigqueueinfo.2:38
#: build/C/man2/s390_runtime_instr.2:34 build/C/man2/sgetmask.2:35
#: build/C/man2/sigaction.2:71 build/C/man2/sigaltstack.2:50
#: build/C/man7/sigevent.7:54 build/C/man3/siginterrupt.3:55
#: build/C/man2/signal.2:45 build/C/man7/signal.7:48 build/C/man2/signalfd.2:27
#: build/C/man3/sigpause.3:36 build/C/man2/sigpending.2:46
#: build/C/man2/sigprocmask.2:57 build/C/man3/sigqueue.3:43
#: build/C/man2/sigreturn.2:35 build/C/man3/sigset.3:57
#: build/C/man3/sigsetops.3:63 build/C/man2/sigsuspend.2:46
#: build/C/man3/sigvec.3:51 build/C/man3/sigwait.3:51
#: build/C/man2/sigwaitinfo.2:47 build/C/man3/sysv_signal.3:36
#: build/C/man2/timer_create.2:47 build/C/man2/timer_delete.2:45
#: build/C/man2/timer_getoverrun.2:45 build/C/man2/timer_settime.2:50
#: build/C/man2/timerfd_create.2:35 build/C/man2/tkill.2:43
#: build/C/man2/wait.2:87 build/C/man2/wait4.2:73 build/C/man3/killpg.3:62
#: build/C/man7/signal-safety.7:28
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bsd_signal.3:57
msgid ""
"The B<bsd_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""
"B<bsd_signal>()  関数は B<signal>(2)  と同じ引数をとり、同じ処理を実行す"
"る。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:70
msgid ""
"The difference between the two is that B<bsd_signal>()  is guaranteed to "
"provide reliable signal semantics, that is: a) the disposition of the signal "
"is not reset to the default when the handler is invoked; b) delivery of "
"further instances of the signal is blocked while the signal handler is "
"executing; and c) if the handler interrupts a blocking system call, then the "
"system call is automatically restarted.  A portable application cannot rely "
"on B<signal>(2)  to provide these guarantees."
msgstr ""
"両者の違いは、 B<bsd_signal>()  では信頼性のあるシグナル処理方式の提供が保証"
"されていることである。 信頼性のあるシグナル処理方式は以下の特徴を持つ。 a) ハ"
"ンドラーが起動された場合に、シグナルの処理方法 (disposition) が デフォルトに"
"リセットされない、 b) シグナルハンドラーの実行中は、それ以降に発生した同じシ"
"グナルの配送が ブロックされない、 c) ハンドラーが停止中の (blocking してい"
"る) システムコールを 中断した場合、そのシステムコールが自動的に再開される。 "
"移植性が必要なアプリケーションでは、 B<signal>(2)  でこれらが保証されることを"
"前提にすべきではない。"

#. type: SH
#: build/C/man3/bsd_signal.3:70 build/C/man2/eventfd.2:226
#: build/C/man2/getitimer.2:133 build/C/man2/kill.2:99 build/C/man2/pause.2:42
#: build/C/man2/prctl.2:1909 build/C/man3/profil.3:76 build/C/man3/psignal.3:84
#: build/C/man3/raise.3:61 build/C/man2/restart_syscall.2:88
#: build/C/man2/rt_sigqueueinfo.2:138 build/C/man2/s390_runtime_instr.2:58
#: build/C/man2/sgetmask.2:58 build/C/man2/sigaction.2:847
#: build/C/man2/sigaltstack.2:189 build/C/man3/siginterrupt.3:73
#: build/C/man2/signal.2:98 build/C/man2/signalfd.2:291
#: build/C/man3/sigpause.3:48 build/C/man2/sigpending.2:52
#: build/C/man2/sigprocmask.2:108 build/C/man3/sigqueue.3:83
#: build/C/man2/sigreturn.2:67 build/C/man3/sigset.3:128
#: build/C/man3/sigsetops.3:107 build/C/man2/sigsuspend.2:70
#: build/C/man3/sigvec.3:203 build/C/man3/sigwait.3:75
#: build/C/man2/sigwaitinfo.2:106 build/C/man3/sysv_signal.3:51
#: build/C/man2/timer_create.2:202 build/C/man2/timer_delete.2:53
#: build/C/man2/timer_getoverrun.2:82 build/C/man2/timer_settime.2:173
#: build/C/man2/timerfd_create.2:407 build/C/man2/tkill.2:92
#: build/C/man2/wait.2:397 build/C/man2/wait4.2:146 build/C/man3/killpg.3:83
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bsd_signal.3:76
msgid ""
"The B<bsd_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""
"B<bsd_signal>()  関数はシグナルハンドラーの直前の値を返す。 エラーの場合、 "
"B<SIG_ERR> を返す。"

#. type: SH
#: build/C/man3/bsd_signal.3:76 build/C/man2/eventfd.2:233
#: build/C/man2/getitimer.2:138 build/C/man2/kill.2:104 build/C/man2/pause.2:53
#: build/C/man2/prctl.2:1936 build/C/man2/restart_syscall.2:92
#: build/C/man2/rt_sigqueueinfo.2:143 build/C/man2/s390_runtime_instr.2:69
#: build/C/man2/sgetmask.2:63 build/C/man2/sigaction.2:852
#: build/C/man2/sigaltstack.2:193 build/C/man3/siginterrupt.3:83
#: build/C/man2/signal.2:106 build/C/man2/signalfd.2:305
#: build/C/man2/sigpending.2:58 build/C/man2/sigprocmask.2:114
#: build/C/man3/sigqueue.3:91 build/C/man3/sigset.3:153
#: build/C/man3/sigsetops.3:127 build/C/man2/sigsuspend.2:76
#: build/C/man3/sigvec.3:220 build/C/man3/sigwait.3:80
#: build/C/man2/sigwaitinfo.2:115 build/C/man3/sysv_signal.3:57
#: build/C/man2/timer_create.2:210 build/C/man2/timer_delete.2:60
#: build/C/man2/timer_getoverrun.2:90 build/C/man2/timer_settime.2:182
#: build/C/man2/timerfd_create.2:422 build/C/man2/tkill.2:96
#: build/C/man2/wait.2:427 build/C/man2/wait4.2:149 build/C/man3/killpg.3:88
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/bsd_signal.3:79 build/C/man3/sysv_signal.3:60
msgid "As for B<signal>(2)."
msgstr "B<signal>(2)  と同じ。"

#. type: SH
#: build/C/man3/bsd_signal.3:79 build/C/man2/eventfd.2:270
#: build/C/man3/gsignal.3:98 build/C/man3/profil.3:78 build/C/man3/psignal.3:94
#: build/C/man3/raise.3:64 build/C/man2/sigaltstack.2:213
#: build/C/man3/siginterrupt.3:87 build/C/man3/sigpause.3:56
#: build/C/man3/sigqueue.3:117 build/C/man3/sigset.3:172
#: build/C/man3/sigsetops.3:132 build/C/man3/sigvec.3:232
#: build/C/man3/sigwait.3:86 build/C/man3/sysv_signal.3:60
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/bsd_signal.3:82 build/C/man2/eventfd.2:273
#: build/C/man3/gsignal.3:101 build/C/man3/profil.3:81
#: build/C/man3/psignal.3:97 build/C/man3/raise.3:67
#: build/C/man2/sigaltstack.2:216 build/C/man3/siginterrupt.3:90
#: build/C/man3/sigpause.3:59 build/C/man3/sigqueue.3:120
#: build/C/man3/sigset.3:175 build/C/man3/sigsetops.3:135
#: build/C/man3/sigvec.3:235 build/C/man3/sigwait.3:89
#: build/C/man3/sysv_signal.3:63
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277
#: build/C/man3/gsignal.3:105 build/C/man3/profil.3:85
#: build/C/man3/psignal.3:101 build/C/man3/raise.3:71
#: build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94
#: build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124
#: build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139
#: build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93
#: build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277
#: build/C/man3/gsignal.3:105 build/C/man3/profil.3:85
#: build/C/man3/psignal.3:101 build/C/man3/raise.3:71
#: build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94
#: build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124
#: build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139
#: build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93
#: build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277
#: build/C/man3/gsignal.3:105 build/C/man3/profil.3:85
#: build/C/man3/psignal.3:101 build/C/man3/raise.3:71
#: build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94
#: build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124
#: build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139
#: build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93
#: build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/bsd_signal.3:89
#, no-wrap
msgid "B<bsd_signal>()"
msgstr "B<bsd_signal>()"

#. type: tbl table
#: build/C/man3/bsd_signal.3:89 build/C/man2/eventfd.2:280
#: build/C/man3/gsignal.3:108 build/C/man3/gsignal.3:111
#: build/C/man3/profil.3:88 build/C/man3/psignal.3:105 build/C/man3/raise.3:74
#: build/C/man2/sigaltstack.2:223 build/C/man3/siginterrupt.3:97
#: build/C/man3/sigpause.3:66 build/C/man3/sigqueue.3:127
#: build/C/man3/sigset.3:186 build/C/man3/sigsetops.3:152
#: build/C/man3/sigvec.3:246 build/C/man3/sigwait.3:96
#: build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/bsd_signal.3:89 build/C/man2/eventfd.2:280
#: build/C/man3/gsignal.3:108 build/C/man3/raise.3:74
#: build/C/man2/sigaltstack.2:223 build/C/man3/sigpause.3:66
#: build/C/man3/sigqueue.3:127 build/C/man3/sigset.3:186
#: build/C/man3/sigsetops.3:152 build/C/man3/sigvec.3:246
#: build/C/man3/sigwait.3:96 build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/bsd_signal.3:91 build/C/man2/eventfd.2:283
#: build/C/man2/getitimer.2:159 build/C/man3/gsignal.3:114
#: build/C/man2/kill.2:120 build/C/man2/pause.2:57 build/C/man2/prctl.2:2359
#: build/C/man3/profil.3:91 build/C/man3/psignal.3:108 build/C/man3/raise.3:76
#: build/C/man2/restart_syscall.2:100 build/C/man2/rt_sigqueueinfo.2:188
#: build/C/man2/s390_runtime_instr.2:92 build/C/man2/sgetmask.2:72
#: build/C/man2/sigaction.2:864 build/C/man2/sigaltstack.2:225
#: build/C/man3/siginterrupt.3:99 build/C/man2/signal.2:111
#: build/C/man7/signal.7:928 build/C/man2/signalfd.2:347
#: build/C/man3/sigpause.3:76 build/C/man2/sigpending.2:63
#: build/C/man2/sigprocmask.2:128 build/C/man3/sigqueue.3:129
#: build/C/man2/sigreturn.2:70 build/C/man3/sigset.3:188
#: build/C/man3/sigsetops.3:154 build/C/man2/sigsuspend.2:85
#: build/C/man3/sigvec.3:248 build/C/man3/sigwait.3:98
#: build/C/man2/sigwaitinfo.2:134 build/C/man3/sysv_signal.3:72
#: build/C/man2/timer_create.2:242 build/C/man2/timer_delete.2:67
#: build/C/man2/timer_getoverrun.2:97 build/C/man2/timer_settime.2:207
#: build/C/man2/timerfd_create.2:501 build/C/man2/tkill.2:129
#: build/C/man2/wait.2:465 build/C/man2/wait4.2:152 build/C/man3/killpg.3:107
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bsd_signal.3:98
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<bsd_signal>(), recommending the use of B<sigaction>(2)  instead."
msgstr ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 では B<bsd_signal>()  の仕様が削除されて"
"いる。 代わりに、 B<sigaction>(2)  の使用が推奨されている。"

#. type: SH
#: build/C/man3/bsd_signal.3:98 build/C/man2/eventfd.2:288
#: build/C/man2/getitimer.2:169 build/C/man2/kill.2:122 build/C/man3/raise.3:78
#: build/C/man2/restart_syscall.2:102 build/C/man2/rt_sigqueueinfo.2:190
#: build/C/man2/s390_runtime_instr.2:96 build/C/man2/sgetmask.2:74
#: build/C/man2/sigaction.2:867 build/C/man2/sigaltstack.2:231
#: build/C/man2/signal.2:113 build/C/man7/signal.7:930
#: build/C/man2/signalfd.2:352 build/C/man3/sigpause.3:81
#: build/C/man2/sigpending.2:65 build/C/man2/sigprocmask.2:130
#: build/C/man3/sigqueue.3:131 build/C/man2/sigreturn.2:76
#: build/C/man3/sigset.3:205 build/C/man3/sigsetops.3:156
#: build/C/man2/sigsuspend.2:87 build/C/man3/sigvec.3:254
#: build/C/man3/sigwait.3:100 build/C/man2/sigwaitinfo.2:136
#: build/C/man3/sysv_signal.3:74 build/C/man2/timer_create.2:244
#: build/C/man2/timer_getoverrun.2:99 build/C/man2/timerfd_create.2:503
#: build/C/man2/tkill.2:135 build/C/man2/wait.2:467 build/C/man2/wait4.2:161
#: build/C/man3/killpg.3:111
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/bsd_signal.3:104
msgid ""
"Use of B<bsd_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""
"B<bsd_signal>()  の使用は避けるべきである。代わりに B<sigaction>(2)  を使うこ"
"と。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:115
msgid ""
"On modern Linux systems, B<bsd_signal>()  and B<signal>(2)  are equivalent.  "
"But on older systems, B<signal>(2)  provided unreliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""
"最近の Linux システムでは、 B<bsd_signal>()  と B<signal>(2)  は等価である。"
"しかし、以前のシステムでは、 B<signal>(2)  は信頼性に欠けるシグナル処理方式を"
"提供していた。 詳細は B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:122 build/C/man3/sysv_signal.3:99
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is defined only if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""
"I<sighandler_t> を使っているのは GNU による拡張である。 この型は機能検査マク"
"ロ B<_GNU_SOURCE> を定義した場合にのみ定義される。"

#. type: SH
#: build/C/man3/bsd_signal.3:122 build/C/man2/eventfd.2:442
#: build/C/man2/getitimer.2:259 build/C/man3/gsignal.3:124
#: build/C/man2/kill.2:170 build/C/man2/pause.2:59 build/C/man2/prctl.2:2377
#: build/C/man3/profil.3:102 build/C/man3/psignal.3:122 build/C/man3/raise.3:89
#: build/C/man2/restart_syscall.2:135 build/C/man2/rt_sigqueueinfo.2:200
#: build/C/man2/s390_runtime_instr.2:115 build/C/man2/sgetmask.2:88
#: build/C/man2/sigaction.2:1052 build/C/man2/sigaltstack.2:370
#: build/C/man7/sigevent.7:132 build/C/man3/siginterrupt.3:108
#: build/C/man2/signal.2:275 build/C/man7/signal.7:986
#: build/C/man2/signalfd.2:520 build/C/man3/sigpause.3:133
#: build/C/man2/sigpending.2:118 build/C/man2/sigprocmask.2:221
#: build/C/man3/sigqueue.3:166 build/C/man2/sigreturn.2:157
#: build/C/man3/sigset.3:281 build/C/man3/sigsetops.3:203
#: build/C/man2/sigsuspend.2:136 build/C/man3/sigvec.3:279
#: build/C/man3/sigwait.3:115 build/C/man2/sigwaitinfo.2:238
#: build/C/man3/sysv_signal.3:99 build/C/man2/timer_create.2:487
#: build/C/man2/timer_delete.2:69 build/C/man2/timer_getoverrun.2:141
#: build/C/man2/timer_settime.2:212 build/C/man2/timerfd_create.2:716
#: build/C/man2/tkill.2:148 build/C/man2/wait.2:705 build/C/man2/wait4.2:179
#: build/C/man3/killpg.3:130 build/C/man7/signal-safety.7:351
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bsd_signal.3:127
msgid "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"

#. type: SH
#: build/C/man3/bsd_signal.3:127 build/C/man2/eventfd.2:453
#: build/C/man2/getitimer.2:266 build/C/man3/gsignal.3:128
#: build/C/man2/kill.2:182 build/C/man2/pause.2:64 build/C/man2/prctl.2:2380
#: build/C/man3/profil.3:108 build/C/man3/psignal.3:127 build/C/man3/raise.3:96
#: build/C/man2/restart_syscall.2:144 build/C/man2/rt_sigqueueinfo.2:209
#: build/C/man2/s390_runtime_instr.2:118 build/C/man2/sgetmask.2:91
#: build/C/man2/sigaction.2:1075 build/C/man2/sigaltstack.2:377
#: build/C/man7/sigevent.7:142 build/C/man3/siginterrupt.3:110
#: build/C/man2/signal.2:294 build/C/man7/signal.7:1025
#: build/C/man2/signalfd.2:533 build/C/man3/sigpause.3:141
#: build/C/man2/sigpending.2:126 build/C/man2/sigprocmask.2:232
#: build/C/man3/sigqueue.3:174 build/C/man2/sigreturn.2:165
#: build/C/man3/sigset.3:291 build/C/man3/sigsetops.3:208
#: build/C/man2/sigsuspend.2:146 build/C/man3/sigvec.3:289
#: build/C/man3/sigwait.3:123 build/C/man2/sigwaitinfo.2:250
#: build/C/man3/sysv_signal.3:104 build/C/man2/timer_create.2:502
#: build/C/man2/timer_delete.2:75 build/C/man2/timer_getoverrun.2:151
#: build/C/man2/timer_settime.2:216 build/C/man2/timerfd_create.2:728
#: build/C/man2/tkill.2:153 build/C/man2/wait.2:718 build/C/man2/wait4.2:186
#: build/C/man3/killpg.3:136 build/C/man7/signal-safety.7:355
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bsd_signal.3:135 build/C/man2/eventfd.2:461
#: build/C/man2/getitimer.2:274 build/C/man3/gsignal.3:136
#: build/C/man2/kill.2:190 build/C/man2/pause.2:72 build/C/man2/prctl.2:2388
#: build/C/man3/profil.3:116 build/C/man3/psignal.3:135
#: build/C/man3/raise.3:104 build/C/man2/restart_syscall.2:152
#: build/C/man2/rt_sigqueueinfo.2:217 build/C/man2/s390_runtime_instr.2:126
#: build/C/man2/sgetmask.2:99 build/C/man2/sigaction.2:1083
#: build/C/man2/sigaltstack.2:385 build/C/man7/sigevent.7:150
#: build/C/man3/siginterrupt.3:118 build/C/man2/signal.2:302
#: build/C/man7/signal.7:1033 build/C/man2/signalfd.2:541
#: build/C/man3/sigpause.3:149 build/C/man2/sigpending.2:134
#: build/C/man2/sigprocmask.2:240 build/C/man3/sigqueue.3:182
#: build/C/man2/sigreturn.2:173 build/C/man3/sigset.3:299
#: build/C/man3/sigsetops.3:216 build/C/man2/sigsuspend.2:154
#: build/C/man3/sigvec.3:297 build/C/man3/sigwait.3:131
#: build/C/man2/sigwaitinfo.2:258 build/C/man3/sysv_signal.3:112
#: build/C/man2/timer_create.2:510 build/C/man2/timer_delete.2:83
#: build/C/man2/timer_getoverrun.2:159 build/C/man2/timer_settime.2:224
#: build/C/man2/timerfd_create.2:736 build/C/man2/tkill.2:161
#: build/C/man2/wait.2:726 build/C/man2/wait4.2:194 build/C/man3/killpg.3:144
#: build/C/man7/signal-safety.7:363
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr "EVENTFD"

#. type: TH
#: build/C/man2/eventfd.2:22 build/C/man3/psignal.3:30
#: build/C/man7/sigevent.7:26 build/C/man2/signalfd.2:20
#: build/C/man2/timer_create.2:26 build/C/man2/wait.2:49
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: TH
#: build/C/man2/eventfd.2:22 build/C/man2/getitimer.2:13 build/C/man2/kill.2:44
#: build/C/man2/pause.2:30 build/C/man2/prctl.2:59 build/C/man3/profil.3:28
#: build/C/man2/restart_syscall.2:33 build/C/man2/rt_sigqueueinfo.2:25
#: build/C/man2/sgetmask.2:25 build/C/man2/sigaction.2:48
#: build/C/man2/sigaltstack.2:26 build/C/man2/signal.2:36
#: build/C/man7/signal.7:45 build/C/man2/signalfd.2:20
#: build/C/man3/sigpause.3:25 build/C/man2/sigpending.2:29
#: build/C/man2/sigprocmask.2:29 build/C/man3/sigqueue.3:28
#: build/C/man2/sigreturn.2:30 build/C/man3/sigset.3:25
#: build/C/man3/sigsetops.3:31 build/C/man2/sigsuspend.2:29
#: build/C/man3/sigvec.3:25 build/C/man3/sigwait.3:26
#: build/C/man2/sigwaitinfo.2:25 build/C/man2/timer_create.2:26
#: build/C/man2/timer_delete.2:26 build/C/man2/timer_getoverrun.2:26
#: build/C/man2/timer_settime.2:26 build/C/man2/timerfd_create.2:19
#: build/C/man2/tkill.2:29 build/C/man2/wait.2:49 build/C/man2/wait4.2:33
#: build/C/man3/killpg.3:42 build/C/man7/signal-safety.7:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr "eventfd - イベント通知用のファイルディスクリプターを生成する"

#. type: Plain text
#: build/C/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr "B<#include E<lt>sys/eventfd.hE<gt>>"

#. type: Plain text
#: build/C/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""
"B<eventfd>()  は \"eventfd オブジェクト\" を生成する。 eventfd オブジェクトは"
"ユーザー空間アプリケーションがイベント待ち受け/通知用の 仕組みとして使うこと"
"ができる。また、カーネルがユーザー空間アプリケーションに イベントを通知するた"
"めにも使うことができる。 このオブジェクトには、unsigned の 64 ビット整数 "
"(I<uint64_t>)  型のカウンターが含まれており、このカウンターはカーネルにより管"
"理される。 このカウンターは I<initval> 引数で指定された値で初期化される。"

#. type: Plain text
#: build/C/man2/eventfd.2:44
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object."
msgstr "B<eventfd>()  は eventfd オブジェクトを参照するのに使用できる新しいファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man2/eventfd.2:49
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""
"以下の値のいくつかをビット単位の論理和 (OR) で指定することで、 B<eventfd>() "
"の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/eventfd.2:49
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr "B<EFD_CLOEXEC> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:59 build/C/man2/signalfd.2:97
#: build/C/man2/timerfd_create.2:140
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプターに対して close-on-exec (B<FD_CLOEXEC>)  フラグ"
"をセットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: TP
#: build/C/man2/eventfd.2:59
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr "B<EFD_NONBLOCK> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:69 build/C/man2/signalfd.2:87
#: build/C/man2/timerfd_create.2:130
#, fuzzy
#| msgid ""
#| "Set the B<O_NONBLOCK> file status flag on the new open file description.  "
#| "Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
#| "result."
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: TP
#: build/C/man2/eventfd.2:69
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr "B<EFD_SEMAPHORE> (Linux 2.6.30 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:73
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""
"新しいファイルディスクリプターからの読み出しにおいて、セマフォ風の動作を行"
"う。 下記参照。"

#. type: Plain text
#: build/C/man2/eventfd.2:77 build/C/man2/signalfd.2:101
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""
"バージョン 2.6.26 以前の Linux では、 I<flags> 引数は未使用であり、0 を指定"
"しなければならない。"

#. type: Plain text
#: build/C/man2/eventfd.2:80
msgid ""
"The following operations can be performed on the file descriptor returned by "
"B<eventfd>():"
msgstr ""

#. type: tbl table
#: build/C/man2/eventfd.2:80 build/C/man2/signalfd.2:104
#: build/C/man2/timerfd_create.2:273 build/C/man7/signal-safety.7:184
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:90
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  fails "
"with the error B<EINVAL> if the size of the supplied buffer is less than 8 "
"bytes."
msgstr ""
"B<read>(2) は成功すると、8 バイトの整数を返す。 渡されたバッファーの大きさが "
"8 バイト未満の場合、 B<read>(2)  はエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/eventfd.2:95
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""
"B<read>(2) が返す値は、ホストバイトオーダ、つまり、そのホストマシンにおける整"
"数の通常のバイトオーダである。"

#. type: Plain text
#: build/C/man2/eventfd.2:102
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""
"B<read>(2) の動作は、 eventfd カウンターの現在の値が 0 以外であるかと、 "
"eventfd ファイルディスクリプターを作成する際に B<EFD_SEMAPHORE> フラグが指定"
"されたか、により変化する。"

#. type: IP
#: build/C/man2/eventfd.2:103 build/C/man2/eventfd.2:110
#: build/C/man2/eventfd.2:117 build/C/man2/eventfd.2:162
#: build/C/man2/eventfd.2:172 build/C/man2/eventfd.2:182
#: build/C/man2/prctl.2:278 build/C/man2/prctl.2:280 build/C/man2/prctl.2:283
#: build/C/man2/prctl.2:288 build/C/man2/prctl.2:2051 build/C/man2/prctl.2:2056
#: build/C/man2/prctl.2:2061 build/C/man2/prctl.2:2071
#: build/C/man3/psignal.3:114 build/C/man3/psignal.3:118
#: build/C/man2/rt_sigqueueinfo.2:88 build/C/man2/rt_sigqueueinfo.2:97
#: build/C/man2/sigaction.2:131 build/C/man2/sigaction.2:134
#: build/C/man2/sigaction.2:137 build/C/man2/sigaction.2:366
#: build/C/man2/sigaction.2:381 build/C/man2/sigaction.2:397
#: build/C/man2/sigaction.2:412 build/C/man2/sigaction.2:459
#: build/C/man2/sigaction.2:523 build/C/man2/sigaction.2:541
#: build/C/man2/sigaction.2:590 build/C/man2/sigaction.2:593
#: build/C/man2/sigaction.2:598 build/C/man2/signal.2:69
#: build/C/man2/signal.2:74 build/C/man2/signal.2:81 build/C/man2/signal.2:237
#: build/C/man2/signal.2:241 build/C/man7/signal.7:153
#: build/C/man7/signal.7:161 build/C/man7/signal.7:529
#: build/C/man7/signal.7:537 build/C/man7/signal.7:670
#: build/C/man7/signal.7:672 build/C/man7/signal.7:692
#: build/C/man7/signal.7:708 build/C/man7/signal.7:712
#: build/C/man7/signal.7:719 build/C/man7/signal.7:737
#: build/C/man7/signal.7:747 build/C/man7/signal.7:754
#: build/C/man7/signal.7:761 build/C/man7/signal.7:763
#: build/C/man7/signal.7:767 build/C/man7/signal.7:770
#: build/C/man7/signal.7:779 build/C/man7/signal.7:798
#: build/C/man7/signal.7:812 build/C/man7/signal.7:823
#: build/C/man7/signal.7:830 build/C/man7/signal.7:839
#: build/C/man7/signal.7:847 build/C/man7/signal.7:853
#: build/C/man7/signal.7:871 build/C/man7/signal.7:885
#: build/C/man7/signal.7:899 build/C/man7/signal.7:902
#: build/C/man7/signal.7:905 build/C/man7/signal.7:908
#: build/C/man7/signal.7:915 build/C/man7/signal.7:921
#: build/C/man7/signal.7:925 build/C/man3/sigpause.3:116
#: build/C/man3/sigpause.3:120 build/C/man3/sigwait.3:68
#: build/C/man3/sigwait.3:73 build/C/man2/timer_create.2:265
#: build/C/man2/timer_create.2:268 build/C/man2/timer_create.2:271
#: build/C/man2/timer_create.2:275 build/C/man2/timer_create.2:278
#: build/C/man2/timer_create.2:301 build/C/man2/timer_create.2:315
#: build/C/man2/timer_create.2:322 build/C/man7/signal-safety.7:290
#: build/C/man7/signal-safety.7:297 build/C/man7/signal-safety.7:305
#: build/C/man7/signal-safety.7:318 build/C/man7/signal-safety.7:334
#: build/C/man7/signal-safety.7:344
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/eventfd.2:110
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""
"B<EFD_SEMAPHORE> が指定されておらず、eventfd カウンターが 0 以外の値の場合、 "
"B<read>(2) はカウンター値を格納した 8 バイトの値を返し、 カウンター値は 0 に"
"リセットされる。"

#. type: Plain text
#: build/C/man2/eventfd.2:117
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""
"B<EFD_SEMAPHORE> が指定されていて eventfd カウンターが 0 以外の値の場合、 "
"B<read>(2) は値 1 の 8 バイト値を返し、カウンター値は 1 減算される。"

#. type: Plain text
#: build/C/man2/eventfd.2:127
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""
"B<read>(2) を呼び出した時点で eventfd カウンターが 0 の場合、 B<read>(2) はカ"
"ウンターが 0 以外になるまで停止 (block) する (0 以外になった時点で "
"B<read>(2) は上記で述べた通り実行を再開する)、 もしくはファイルディスクリプ"
"ターが非停止 (nonblocking) に設定されている場合はエラー B<EAGAIN> で失敗す"
"る。"

#. type: tbl table
#: build/C/man2/eventfd.2:128 build/C/man7/signal-safety.7:286
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:145
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""
"B<write>(2)  は、引数のバッファーで渡された 8 バイトの整数値をカウンターに"
"加算する。 カウンターに格納可能な最大値は unsigned の 64 ビット整数の最大値か"
"ら 1 を引いた値 (すなわち 0xfffffffffffffffe) である。 加算を行うとカウンター"
"値が最大値を超過する場合には、 そのファイルディスクリプターに対して "
"B<read>(2)  が実行されるまで、 B<write>(2)  は停止 (block) する、 もしくは"
"ファイルディスクリプターが非停止 (nonblocking)  に設定されている場合はエラー "
"B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/eventfd.2:152
msgid ""
"A B<write>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes, or if an attempt is made to write the value "
"0xffffffffffffffff."
msgstr ""
"渡されたバッファーの大きさが 8 バイト未満の場合、もしくは 値 "
"0xffffffffffffffff を書き込もうとした場合、 B<write>(2)  はエラー B<EINVAL> "
"で失敗する。"

#. type: TP
#: build/C/man2/eventfd.2:152 build/C/man2/signalfd.2:142
#: build/C/man2/timerfd_create.2:346
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (と同様の操作)"

#. type: Plain text
#: build/C/man2/eventfd.2:161
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""
"返されたファイルディスクリプターは、 B<poll>(2)  (B<epoll>(7)  も同じ) や "
"B<select>(2)  をサポートしており、以下のような動作をする。"

#. type: Plain text
#: build/C/man2/eventfd.2:172
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""
"カウンターが 0 より大きい値の場合、 ファイルディスクリプターは読み出し可能と"
"なる (B<select>(2)  の I<readfds> 引数や B<poll>(2)  の B<POLLIN> フラグ)。"

#. type: Plain text
#: build/C/man2/eventfd.2:182
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""
"少なくとも値 \"1\" を、停止 (block) を伴わずに書き込める場合、 ファイルディス"
"クリプターは書き込み可能となる (B<select>(2)  の I<writefds> 引数や "
"B<poll>(2)  の B<POLLOUT> フラグ)。"

#. type: Plain text
#: build/C/man2/eventfd.2:202
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""
"カウンター値のオーバーフローが検出された場合、 B<select>(2)  はファイルディス"
"クリプターは読み出し可能と書き込み可能の両方を通知し、 B<poll>(2)  は "
"B<POLLERR> イベントを返す。 上述の通り、 B<write>(2)  でカウンターがオーバー"
"フローすることは決してない。 しかしながら、 KAIO サブシステムによって 2^64 回"
"の eventfd \"signal posts\" が 実行された場合にはオーバーフローが起こり得る "
"(理論的にはあり得るが、実用的にはあり得ない)。 オーバーフローが発生した場"
"合、 B<read>(2)  は I<uint64_t> の最大値 (すなわち 0xffffffffffffffff) を返"
"す。"

#. type: Plain text
#: build/C/man2/eventfd.2:209
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""
"eventfd ファイルディスクリプターは、これ以外のファイルディスクリプター 多重 "
"API である B<pselect>(2) と B<ppoll>(2) もサポートしている。"

#. type: tbl table
#: build/C/man2/eventfd.2:209 build/C/man2/signalfd.2:162
#: build/C/man2/timerfd_create.2:382 build/C/man7/signal-safety.7:112
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:214
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"ファイルディスクリプターがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ eventfd オブジェクトに関連付けられたファイルディスクリプターが全て "
"クローズされると、そのオブジェクト用の資源がカーネルにより解放される。"

#. type: Plain text
#: build/C/man2/eventfd.2:226
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""
"B<fork>(2) で生成された子プロセスは、 B<eventfd>() で生成されたファイルディス"
"クリプターのコピーを継承する。 複製されたファイルディスクリプターは同じ "
"eventfd オブジェクトに関連付けられる。 close-on-exec フラグが設定されていない"
"場合、 B<execve>(2) の前後で B<eventfd>() で生成されたファイルディスクリプ"
"ターは保持される。"

#. type: Plain text
#: build/C/man2/eventfd.2:233
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<eventfd>()  は新規の eventfd ファイルディスクリプターを返す。 "
"エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/eventfd.2:234 build/C/man2/getitimer.2:146
#: build/C/man2/kill.2:105 build/C/man2/prctl.2:2002 build/C/man2/prctl.2:2008
#: build/C/man2/prctl.2:2020 build/C/man2/prctl.2:2025
#: build/C/man2/prctl.2:2034 build/C/man2/prctl.2:2044
#: build/C/man2/prctl.2:2084 build/C/man2/prctl.2:2094
#: build/C/man2/prctl.2:2102 build/C/man2/prctl.2:2113
#: build/C/man2/prctl.2:2122 build/C/man2/prctl.2:2136
#: build/C/man2/prctl.2:2148 build/C/man2/prctl.2:2159
#: build/C/man2/prctl.2:2171 build/C/man2/prctl.2:2196
#: build/C/man2/prctl.2:2214 build/C/man2/prctl.2:2224
#: build/C/man2/prctl.2:2230 build/C/man2/prctl.2:2239
#: build/C/man2/rt_sigqueueinfo.2:150 build/C/man2/s390_runtime_instr.2:70
#: build/C/man2/s390_runtime_instr.2:75 build/C/man2/sigaction.2:857
#: build/C/man2/sigaltstack.2:198 build/C/man3/siginterrupt.3:84
#: build/C/man2/signal.2:107 build/C/man2/signalfd.2:311
#: build/C/man2/signalfd.2:319 build/C/man2/sigprocmask.2:122
#: build/C/man3/sigqueue.3:98 build/C/man3/sigsetops.3:128
#: build/C/man3/sigwait.3:81 build/C/man2/sigwaitinfo.2:130
#: build/C/man2/timer_create.2:214 build/C/man2/timer_delete.2:61
#: build/C/man2/timer_getoverrun.2:91 build/C/man2/timer_settime.2:191
#: build/C/man2/timer_settime.2:199 build/C/man2/timerfd_create.2:425
#: build/C/man2/timerfd_create.2:430 build/C/man2/timerfd_create.2:476
#: build/C/man2/timerfd_create.2:486 build/C/man2/timerfd_create.2:492
#: build/C/man2/tkill.2:109 build/C/man2/wait.2:460 build/C/man3/killpg.3:89
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/eventfd.2:238
msgid "An unsupported value was specified in I<flags>."
msgstr "I<flags> にサポートされていない値が指定された。"

#. type: TP
#: build/C/man2/eventfd.2:238 build/C/man2/signalfd.2:326
#: build/C/man2/timerfd_create.2:437
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:329
#: build/C/man2/timerfd_create.2:440
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"オープン済みのファイルディスクリプターの数がプロセスあたりの上限に 達してい"
"た。"

#. type: TP
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:329
#: build/C/man2/timerfd_create.2:440
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/eventfd.2:245 build/C/man2/signalfd.2:333
#: build/C/man2/timerfd_create.2:444
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープン済みのファイル総数がシステム全体の上限に達していた。"

#. type: TP
#: build/C/man2/eventfd.2:245 build/C/man2/prctl.2:2248
#: build/C/man2/signalfd.2:333 build/C/man2/timerfd_create.2:444
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/eventfd.2:253 build/C/man2/signalfd.2:336
#: build/C/man2/timerfd_create.2:447
msgid "Could not mount (internal) anonymous inode device."
msgstr "(カーネル内の) 無名 inode デバイスをマウントできなかった。"

#. type: TP
#: build/C/man2/eventfd.2:253 build/C/man2/s390_runtime_instr.2:84
#: build/C/man2/sigaltstack.2:202 build/C/man2/signalfd.2:336
#: build/C/man2/timer_create.2:222 build/C/man2/timerfd_create.2:447
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/eventfd.2:257
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""
"新しい eventfd ファイルディスクリプターを生成するのに十分なメモリーがなかっ"
"た。"

#. type: SH
#: build/C/man2/eventfd.2:257 build/C/man2/prctl.2:2354
#: build/C/man3/psignal.3:90 build/C/man2/restart_syscall.2:96
#: build/C/man2/rt_sigqueueinfo.2:181 build/C/man2/s390_runtime_instr.2:90
#: build/C/man2/sgetmask.2:65 build/C/man2/signalfd.2:339
#: build/C/man3/sigqueue.3:112 build/C/man3/sigvec.3:225
#: build/C/man2/timer_create.2:240 build/C/man2/timer_delete.2:65
#: build/C/man2/timer_getoverrun.2:95 build/C/man2/timer_settime.2:205
#: build/C/man2/timerfd_create.2:498 build/C/man2/tkill.2:120
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/eventfd.2:270
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""
"B<eventfd>()  はカーネル 2.6.22 以降の Linux で利用可能である。 正しく動作す"
"る glibc 側のサポートはバージョン 2.8 以降で提供されている。 B<eventfd2>()  "
"システムコール (「注意」参照) は カーネル 2.6.27 以降の Linux で利用可能であ"
"る。 バージョン 2.9 以降では、glibc の B<eventfd>()  のラッパー関数は、カーネ"
"ルが対応していれば B<eventfd2>()  システムコールを利用する。"

#. type: tbl table
#: build/C/man2/eventfd.2:280
#, no-wrap
msgid "B<eventfd>()"
msgstr "B<eventfd>()"

#. type: Plain text
#: build/C/man2/eventfd.2:288
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr "B<eventfd>()  と B<eventfd2>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/eventfd.2:296
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""
"アプリケーションは、パイプをイベントを通知するためだけに使用している 全ての場"
"面において、パイプの代わりに eventfd ファイルディスクリプターを 使用すること"
"ができる。 eventfd ファイルディスクリプターを使う方が、パイプを使う場合に比べ"
"て カーネルでのオーバヘッドは比べるとずっと小さく、ファイルディスクリプター"
"も 一つしか必要としない (パイプの場合は二つ必要である)。"

#.  or eventually syslets/threadlets
#. type: Plain text
#: build/C/man2/eventfd.2:302
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is complete."
msgstr ""
"カーネル内で使用すると、eventfd ファイルディスクリプターはカーネル空間から"
"ユーザー空間へのブリッジ機能を提供することができ、 例えば KAIO (kernel AIO)  "
"のような機能が、あるファイルディスクリプターに何らかの操作が完了したことを 通"
"知することができる。"

#. type: Plain text
#: build/C/man2/eventfd.2:319
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""
"eventfd ファイルディスクリプターの重要な点は、 eventfd ファイルディスクリプ"
"ターが B<select>(2), B<poll>(2), B<epoll>(7)  を使って他のファイルディスクリ"
"プターと全く同様に監視できる点である。 このことは、アプリケーションは「従来"
"の (traditional)」 ファイルの状態変化と eventfd インターフェースをサポートす"
"る他のカーネル機構の状態変化を同時に監視 できることを意味する (B<eventfd>()  "
"インターフェースがない時には、これらのカーネル機構は B<select>(2), "
"B<poll>(2), B<epoll>(7)  経由で多重することはできなかった)。"

#. type: Plain text
#: build/C/man2/eventfd.2:328
msgid ""
"The current value of an eventfd counter can be viewed via the entry for the "
"corresponding file descriptor in the process's I</proc/[pid]/fdinfo> "
"directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:328 build/C/man2/sigaction.2:962
#: build/C/man2/signalfd.2:413 build/C/man2/sigpending.2:85
#: build/C/man2/sigprocmask.2:167 build/C/man3/sigqueue.3:139
#: build/C/man2/sigreturn.2:143 build/C/man2/sigsuspend.2:109
#: build/C/man2/sigwaitinfo.2:196 build/C/man2/timer_create.2:297
#: build/C/man2/wait.2:582 build/C/man2/wait4.2:173 build/C/man3/killpg.3:125
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/eventfd.2:342
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""
"下層にある Linux システムコールは二種類あり、 B<eventfd>()  と、もっと新しい "
"B<eventfd2>()  である。 B<eventfd>()  は I<flags> 引数を実装していない。 "
"B<eventfd2>()  では上記の値の I<flags> が実装されている。 glibc のラッパー関"
"数は、 B<eventfd2>()  が利用可能であれば、これを使用する。"

#. type: SS
#: build/C/man2/eventfd.2:342
#, no-wrap
msgid "Additional glibc features"
msgstr "glibc の追加機能"

#. type: Plain text
#: build/C/man2/eventfd.2:346
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""
"GNU C ライブラリは、eventfd ファイルディスクリプターの読み出しと書き込みに を"
"関する詳細のいくつか抽象化するために、一つの型と、二つの関数を追加で 定義して"
"いる。"

#. type: Plain text
#: build/C/man2/eventfd.2:350
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr "typedef uint64_t eventfd_t;\n"

#. type: Plain text
#: build/C/man2/eventfd.2:353
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:360
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""
"これらの関数は、eventfd ファイルディスクリプターに対する読み出しと 書き込みの"
"操作を実行し、正しいバイト数が転送された場合には 0 を返し、そうでない場合は "
"-1 を返す。"

#. type: SH
#: build/C/man2/eventfd.2:360 build/C/man2/sigaction.2:1049
#: build/C/man2/sigaltstack.2:334 build/C/man2/signalfd.2:447
#: build/C/man3/sigwait.3:112 build/C/man2/timer_create.2:338
#: build/C/man2/timer_getoverrun.2:138 build/C/man2/timer_settime.2:209
#: build/C/man2/timerfd_create.2:555 build/C/man2/wait.2:621
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man2/eventfd.2:368
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""
"以下のプログラムは eventfd ファイルディスクリプターを生成し、 その後 fork を"
"実行して子プロセスを生成する。 親プロセスが少しの間 sleep する間に、子プロセ"
"スは プログラムのコマンドライン引数で指定された整数(列)をそれぞれ eventfd "
"ファイルディスクリプターに書き込む。 親プロセスは sleep を完了すると eventfd "
"ファイルディスクリプターから 読み出しを行う。"

#. type: Plain text
#: build/C/man2/eventfd.2:370
msgid "The following shell session shows a sample run of the program:"
msgstr "以下に示すシェルセッションにこのプログラムの使い方を示す。"

#. type: Plain text
#: build/C/man2/eventfd.2:382
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"

#. type: SS
#: build/C/man2/eventfd.2:384 build/C/man2/signalfd.2:470
#: build/C/man2/timer_create.2:369 build/C/man2/timerfd_create.2:583
#: build/C/man2/wait.2:656
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/eventfd.2:393
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>           /* Definition of PRIu64 & PRIx64 */\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>           /* Definition of PRIu64 & PRIx64 */\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"

#. type: Plain text
#: build/C/man2/eventfd.2:396 build/C/man2/signalfd.2:481
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/eventfd.2:403
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/eventfd.2:408
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/eventfd.2:412
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"

#. type: Plain text
#: build/C/man2/eventfd.2:424
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (int j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (int j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"

#. type: Plain text
#: build/C/man2/eventfd.2:426
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:429
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""
"    default:\n"
"        sleep(2);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:436
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %\"PRIu64\" (%#\"PRIx64\") from efd\\en\", u, u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %\"PRIu64\" (%#\"PRIx64\") from efd\\en\", u, u);\n"
"        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:441
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/eventfd.2:453
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"

#. type: TH
#: build/C/man2/getitimer.2:13
#, no-wrap
msgid "GETITIMER"
msgstr "GETITIMER"

#. type: TH
#: build/C/man2/getitimer.2:13 build/C/man3/gsignal.3:27
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man2/getitimer.2:16
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr "getitimer, setitimer - インターバルタイマーの値を取得または設定する"

#. type: Plain text
#: build/C/man2/getitimer.2:19
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"

#. type: Plain text
#: build/C/man2/getitimer.2:31
msgid ""
"These system calls provide access to interval timers, that is, timers that "
"initially expire at some point in the future, and (optionally) at regular "
"intervals after that.  When a timer expires, a signal is generated for the "
"calling process, and the timer is reset to the specified interval (if the "
"interval is nonzero)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:37
msgid ""
"Three types of timers\\(emspecified via the I<which> argument\\(emare "
"provided, each of which counts against a different clock and generates a "
"different signal on timer expiration:"
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:37
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr "B<ITIMER_REAL>"

#. type: Plain text
#: build/C/man2/getitimer.2:43
msgid ""
"This timer counts down in real (i.e., wall clock) time.  At each expiration, "
"a B<SIGALRM> signal is generated."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:43
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr "B<ITIMER_VIRTUAL>"

#. type: Plain text
#: build/C/man2/getitimer.2:50
msgid ""
"This timer counts down against the user-mode CPU time consumed by the "
"process.  (The measurement includes CPU time consumed by all threads in the "
"process.)  At each expiration, a B<SIGVTALRM> signal is generated."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:50
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr "B<ITIMER_PROF>"

#. type: Plain text
#: build/C/man2/getitimer.2:58
msgid ""
"This timer counts down against the total (i.e., both user and system)  CPU "
"time consumed by the process.  (The measurement includes CPU time consumed "
"by all threads in the process.)  At each expiration, a B<SIGPROF> signal is "
"generated."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:63
msgid ""
"In conjunction with B<ITIMER_VIRTUAL>, this timer can be used to profile "
"user and system CPU time consumed by the process."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:65
msgid "A process has only one of each of the three types of timers."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:67
msgid "Timer values are defined by the following structures:"
msgstr "タイマーの値は以下の構造体によって定義される:"

#. type: Plain text
#: build/C/man2/getitimer.2:74
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getitimer.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"

#. type: SS
#: build/C/man2/getitimer.2:82
#, no-wrap
msgid "getitimer()"
msgstr "getitimer()"

#. type: Plain text
#: build/C/man2/getitimer.2:89
msgid ""
"The function B<getitimer>()  places the current value of the timer specified "
"by I<which> in the buffer pointed to by I<curr_value>."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:100
msgid ""
"The I<it_value> substructure is populated with the amount of time remaining "
"until the next expiration of the specified timer.  This value changes as the "
"timer counts down, and will be reset to I<it_interval> when the timer "
"expires.  If both fields of I<it_value> are zero, then this timer is "
"currently disarmed (inactive)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:107
#, fuzzy
#| msgid ""
#| "The I<it_interval> field returns the interval of the timer.  If both "
#| "fields of this structure are zero, then the timer is set to expire just "
#| "once, at the time specified by I<curr_value.it_value>."
msgid ""
"The I<it_interval> substructure is populated with the timer interval.  If "
"both fields of I<it_interval> are zero, then this is a single-shot timer (i."
"e., it expires just once)."
msgstr ""
"I<it_interval> フィールドは、タイマーの間隔を返す。 この構造体の両方のフィー"
"ルドが 0 であれば、タイマーは I<new_value.it_value> で指定された時間後に一回"
"だけ満了して停止するように設定されている。"

#. type: SS
#: build/C/man2/getitimer.2:107
#, no-wrap
msgid "setitimer()"
msgstr "setitimer()"

#. type: Plain text
#: build/C/man2/getitimer.2:120
#, fuzzy
#| msgid ""
#| "The function B<setitimer>()  sets the specified timer to the value in "
#| "I<new_value>.  If I<old_value> is non-NULL, the old value of the timer (i."
#| "e., the same information as returned by B<getitimer>())  is stored there."
msgid ""
"The function B<setitimer>()  arms or disarms the timer specified by "
"I<which>, by setting the timer to the value specified by I<new_value>.  If "
"I<old_value> is non-NULL, the buffer it points to is used to return the "
"previous value of the timer (i.e., the same information that is returned by "
"B<getitimer>())."
msgstr ""
"B<setitimer>()  関数は指定されたタイマーに I<new_value> の値を設定する。 "
"I<old_value> が NULL 以外の場合、タイマーの古い値 (すなわち B<getitimer>() で"
"返されるのと同じ情報) が I<old_value> に格納される。"

#. type: Plain text
#: build/C/man2/getitimer.2:128
msgid ""
"If either field in I<new_value.it_value> is nonzero, then the timer is armed "
"to initially expire at the specified time.  If both fields in I<new_value."
"it_value> are zero, then the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:133
#, fuzzy
#| msgid ""
#| "The I<it_interval> field returns the interval of the timer.  If both "
#| "fields of this structure are zero, then the timer is set to expire just "
#| "once, at the time specified by I<curr_value.it_value>."
msgid ""
"The I<new_value.it_interval> field specifies the new interval for the timer; "
"if both of its subfields are zero, the timer is single-shot."
msgstr ""
"I<it_interval> フィールドは、タイマーの間隔を返す。 この構造体の両方のフィー"
"ルドが 0 であれば、タイマーは I<new_value.it_value> で指定された時間後に一回"
"だけ満了して停止するように設定されている。"

#. type: Plain text
#: build/C/man2/getitimer.2:138 build/C/man2/tkill.2:96
#: build/C/man3/killpg.3:88
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。エラーが発生した場合、-1 が返され、 I<errno> が適"
"切に設定される。"

#. type: TP
#: build/C/man2/getitimer.2:139 build/C/man2/prctl.2:1985
#: build/C/man2/prctl.2:1989 build/C/man2/sigaction.2:853
#: build/C/man2/sigaltstack.2:194 build/C/man2/sigpending.2:59
#: build/C/man2/sigprocmask.2:115 build/C/man2/sigsuspend.2:77
#: build/C/man2/timer_settime.2:184 build/C/man2/timerfd_create.2:469
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/getitimer.2:146 build/C/man2/timerfd_create.2:476
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr "I<new_value>, I<old_value>, I<curr_value> が有効なポインターではない。"

#. type: Plain text
#: build/C/man2/getitimer.2:159
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>; "
"or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""
"I<which> が B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, B<ITIMER_PROF> のどれでもな"
"い。 または (Linux 2.6.22 以降で)  I<new_value> で指定された構造体の "
"I<tv_usec> フィールドの一つが 0 以上 999999 以下の範囲に入らない値である。"

#. type: Plain text
#: build/C/man2/getitimer.2:169
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""
"POSIX.1-2001, SVr4, 4.4BSD (このコールは 4.2BSD で始めて現われた).  "
"POSIX.1-2008 では、 B<getitimer>()  と B<setitimer>()  は廃止予定とされてお"
"り、 代わりに POSIX タイマー API (B<timer_gettime>(2), B<timer_settime>(2)  "
"など) を使うことが推奨されている。"

#. type: Plain text
#: build/C/man2/getitimer.2:178
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  If the timer "
"expires while the process is active (always true for B<ITIMER_VIRTUAL>), the "
"signal will be delivered immediately when generated."
msgstr "要求した時間がくる前にタイマーが満了することはないが、 逆にある (短い) 時間だけ満了が遅れることはある。 どれだけ遅れるかはシステムの時間分解能とシステムの負荷に依存する (B<time>(7)  参照; 但し、バグの項も参照のこと)。プロセスがアクティブな時 (B<ITIMER_VIRTUAL> の場合には常にそうである) にタイマーが満了した場合、生成されたシグナルは すぐに配送される。"

#. type: Plain text
#: build/C/man2/getitimer.2:184
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスのインターバルタイマーを継承"
"しない。 B<execve>(2)  の前後ではインターバルタイマーは保存される。"

#. type: Plain text
#: build/C/man2/getitimer.2:194
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""
"POSIX.1 では、 B<setitimer>()  と、 B<alarm>(2), B<sleep>(3), B<usleep>(3)  "
"という 3 つのインターフェースとの相互の影響については規定していない。"

#. type: Plain text
#: build/C/man2/getitimer.2:196
msgid "The standards are silent on the meaning of the call:"
msgstr "標準では、次の呼び出しの意味については規定されていない。"

#. type: Plain text
#: build/C/man2/getitimer.2:198
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr "    setitimer(which, NULL, &old_value);\n"

#. type: Plain text
#: build/C/man2/getitimer.2:201
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr ""
"(Solaris, BSD 系やおそらく他のシステムもそうだが) 多くのシステムでは、この呼"
"び出しは以下と等価である。"

#. type: Plain text
#: build/C/man2/getitimer.2:203
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr "    getitimer(which, &old_value);\n"

#. type: Plain text
#: build/C/man2/getitimer.2:209
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr ""
"Linux では、この呼び出しは I<new_value> フィールドが 0 の呼び出しと等価なもの"
"と扱われる。 つまり、タイマーが無効になる。 I<Linux のこの間違った機能を使用"
"しないこと>。移植性もなく、不必要な機能である。"

#. type: SH
#: build/C/man2/getitimer.2:209 build/C/man2/kill.2:160
#: build/C/man3/profil.3:93 build/C/man3/psignal.3:110
#: build/C/man2/sigaction.2:1031 build/C/man2/sigaltstack.2:296
#: build/C/man7/signal.7:956 build/C/man2/signalfd.2:439
#: build/C/man2/sigpending.2:112 build/C/man3/sigset.3:247
#: build/C/man2/timer_getoverrun.2:116 build/C/man2/timerfd_create.2:549
#: build/C/man2/wait.2:606
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/getitimer.2:218
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an "
"event will be lost."
msgstr ""
"シグナルの生成と配送は別個のものであり、 前述のシグナルのそれぞれについて一つ"
"だけがプロセスのために 待機する。 非常に重い負荷の下では、 B<ITIMER_REAL> タ"
"イマーでは、時間切れにより生成された一つ前のシグナルが配送される前に、 次の時"
"間切れが起こる場合がある。 そのような場合、 2 個めのイベントに対するシグナル"
"は失われてしまう。"

#. type: Plain text
#: build/C/man2/getitimer.2:233
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If "
"a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux "
"2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""
"バージョン 2.6.16 より前の Linux カーネルでは、 タイマーの値は jiffy で表現さ"
"れる。 要求が jiffy 表現で (I<include/linux/jiffies.h> で定義されている)  "
"B<MAX_SEC_IN_JIFFIES> を越える値をタイマーに設定しようとするものの場合、 タイ"
"マーは暗黙にこの上限値に切り詰められる。 Linux/i386 の場合 (Linux 2.6.13 以降"
"では jiffy は 0.004 秒) の場合、 これはタイマーの上限値がおよそ 99.42 日にな"
"ることを意味する。 Linux 2.6.16 以降では、カーネルは時間に関する内部表現とし"
"て 異なる表現を使うようになっており、この上限はなくなった。"

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: build/C/man2/getitimer.2:240
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy "
"under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""
"(i386 を含む) いくつかのシステムでは、 バージョン 2.6.12 以前の Linux カーネ"
"ルは ある種の状況では 1 jiffy 早くタイマーが終了してしまうというバグがあっ"
"た。 このバグはカーネル 2.6.12 で修正された。"

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: build/C/man2/getitimer.2:259
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""
"POSIX.1-2001 では B<setitimer>()  は I<tv_usec> の値が 0 から 999999 の範囲外"
"である場合には失敗するべきだとしている。 しかし、2.6.21 以前のカーネルの "
"Linux ではエラーにならず、 対応する秒数の分だけそのタイマーの秒の値が暗黙に調"
"整される。 カーネル 2.6.22 以降では、この標準非準拠の動作は修正され、 "
"I<tv_usec> の値が不適切な場合には B<EINVAL> エラーとなる。"

#. type: Plain text
#: build/C/man2/getitimer.2:266
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"

#. type: TH
#: build/C/man3/gsignal.3:27
#, no-wrap
msgid "GSIGNAL"
msgstr "GSIGNAL"

#. type: Plain text
#: build/C/man3/gsignal.3:30
msgid "gsignal, ssignal - software signal facility"
msgstr "gsignal, ssignal - ソフトウェアシグナル機能"

#. type: Plain text
#: build/C/man3/gsignal.3:33 build/C/man3/psignal.3:36 build/C/man3/raise.3:35
#: build/C/man2/sigaction.2:54 build/C/man3/siginterrupt.3:37
#: build/C/man3/sigpause.3:31 build/C/man3/sigwait.3:32
#: build/C/man2/sigwaitinfo.2:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:35
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr "B<typedef void (*sighandler_t)(int);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:37
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr "B<int gsignal(int >I<signum>B<);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:39
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:52
#, no-wrap
msgid ""
"B<gsignal>(),\n"
"B<ssignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:60
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""
"Linux ではこれらの関数を使用しないこと。 過去に間違いがあり、Linux では "
"B<gsignal>()  と B<ssignal>()  はそれぞれ B<raise>(3)  と B<signal>(2)  の別"
"名になっている。"

#. type: Plain text
#: build/C/man3/gsignal.3:98
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1\\(en15 or 1\\(en17)."
msgstr ""
"一方、System V 風のシステムでは、これらの関数で、 従来の B<signal>(2)  や "
"B<kill>(2)  の関数群とは完全に独立な、 ソフトウェアシグナリングを実現してい"
"る。 B<ssignal>()  関数は、番号 I<signum> のソフトウェアシグナルが "
"B<gsignal>()  関数を使って発生された時にとるべきアクションを定義する。 "
"B<gsignal>()  の返り値は、一つ前に指定されていたアクション、もしくは "
"B<SIG_DFL> である。 B<gsignal>()  は以下のような動作を行う: I<signum> に対し"
"てアクションが指定されていないか、アクション B<SIG_DFL> が指定されていた場"
"合、何もせずに 0 を返す。 I<signum> に対して アクション B<SIG_IGN> が指定され"
"ていた場合、何もせずに 1 を返す。 それ以外の場合、アクションを B<SIG_DFL> に"
"リセットし、引数に I<signum> を指定してアクション関数を呼び出して、アクショ"
"ン関数の返り値を返す。 I<signum> がとり得る値の範囲は実装により異なる (多くの"
"場合 1〜15 か 1〜17 である)。"

#. type: tbl table
#: build/C/man3/gsignal.3:108
#, no-wrap
msgid "B<gsignal>()"
msgstr "B<gsignal>()"

#. type: tbl table
#: build/C/man3/gsignal.3:111
#, no-wrap
msgid "B<ssignal>()"
msgstr "B<ssignal>()"

#. type: tbl table
#: build/C/man3/gsignal.3:111
#, no-wrap
msgid "MT-Safe sigintr"
msgstr "MT-Safe sigintr"

#.  Linux libc and
#. type: Plain text
#: build/C/man3/gsignal.3:124
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64.  "
"They are called obsolete under most of these systems, and are broken under "
"glibc.  Some systems also have B<gsignal_r>()  and B<ssignal_r>()."
msgstr "これらの関数は、AIX, DG/UX, HP-UX, SCO, Solaris, Tru64 で使用可能である。 これらのシステムのほとんどで廃止されたことになっており、 glibc では正しく実装されていない。 B<gsignal_r>()  と B<ssignal_r>()  が実装されているシステムもある。"

#. type: Plain text
#: build/C/man3/gsignal.3:128
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr "B<kill>(2), B<signal>(2), B<raise>(3)"

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "KILL"
msgstr "KILL"

#. type: TH
#: build/C/man2/kill.2:44 build/C/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "2019-10-10"
msgstr "2019-10-10"

#. type: Plain text
#: build/C/man2/kill.2:47
msgid "kill - send signal to a process"
msgstr "kill - プロセスにシグナルを送る"

#. type: Plain text
#: build/C/man2/kill.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>signal.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/kill.2:53
#, no-wrap
msgid "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"
msgstr "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/kill.2:63
msgid "B<kill>(): _POSIX_C_SOURCE"
msgstr "B<kill>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man2/kill.2:69
msgid ""
"The B<kill>()  system call can be used to send any signal to any process "
"group or process."
msgstr ""
"システムコールの B<kill>()  は、任意のプロセスグループもしくはプロセスにシグ"
"ナルを 送るのに使われる。"

#. type: Plain text
#: build/C/man2/kill.2:72
msgid ""
"If I<pid> is positive, then signal I<sig> is sent to the process with the ID "
"specified by I<pid>."
msgstr ""
"I<pid> に正の値を指定した場合、シグナル I<sig> が I<pid> で指定された ID を持"
"つプロセスに送られる。"

#. type: Plain text
#: build/C/man2/kill.2:75
msgid ""
"If I<pid> equals 0, then I<sig> is sent to every process in the process "
"group of the calling process."
msgstr ""
"I<pid> に 0 を指定した場合、 呼び出し元のプロセスのプロセスグループに属するす"
"べてのプロセスに I<sig> で指定したシグナルが送られる。"

#. type: Plain text
#: build/C/man2/kill.2:79
msgid ""
"If I<pid> equals -1, then I<sig> is sent to every process for which the "
"calling process has permission to send signals, except for process 1 "
"(I<init>), but see below."
msgstr ""
"I<pid> に -1 を指定した場合、 I<sig> で指定したシグナルが、 呼び出し元のプロ"
"セスがシグナルを送る許可を持つ全てのプロセスに 送られる。但し、プロセス番号 "
"1 (I<init>) へはシグナルは送られない。 以下の関連部分も参照のこと。"

#. type: Plain text
#: build/C/man2/kill.2:82
msgid ""
"If I<pid> is less than -1, then I<sig> is sent to every process in the "
"process group whose ID is I<-pid>."
msgstr ""
"I<pid> に -1 より小さな値を指定した場合、 ID が I<-pid> のプロセスグループに"
"属するすべてのプロセスに I<sig> で指定したシグナルが送られる。"

#. type: Plain text
#: build/C/man2/kill.2:87
#, fuzzy
#| msgid ""
#| "If I<sig> is 0, then no signal is sent, but error checking is still "
#| "performed; this can be used to check for the existence of a process ID or "
#| "process group ID."
msgid ""
"If I<sig> is 0, then no signal is sent, but existence and permission checks "
"are still performed; this can be used to check for the existence of a "
"process ID or process group ID that the caller is permitted to signal."
msgstr ""
"I<sig> に 0 を指定した場合、シグナルは送られないが、 エラーのチェックは行われ"
"る。これを使って、プロセス ID や プロセスグループ ID の存在確認を行うことがで"
"きる。"

#. type: Plain text
#: build/C/man2/kill.2:99
#, fuzzy
#| msgid ""
#| "For a process to have permission to send a signal it must either be "
#| "privileged (under Linux: have the B<CAP_KILL> capability), or the real or "
#| "effective user ID of the sending process must equal the real or saved set-"
#| "user-ID of the target process.  In the case of B<SIGCONT> it suffices "
#| "when the sending and receiving processes belong to the same session.  "
#| "(Historically, the rules were different; see NOTES.)"
msgid ""
"For a process to have permission to send a signal, it must either be "
"privileged (under Linux: have the B<CAP_KILL> capability in the user "
"namespace of the target process), or the real or effective user ID of the "
"sending process must equal the real or saved set-user-ID of the target "
"process.  In the case of B<SIGCONT>, it suffices when the sending and "
"receiving processes belong to the same session.  (Historically, the rules "
"were different; see NOTES.)"
msgstr ""
"プロセスがシグナルを送信する許可を持つためには、 プロセスが特権 (Linux では "
"B<CAP_KILL> ケーパビリティ (capability)) を持つか、 送信元プロセスの実ユー"
"ザー ID または実効ユーザー ID が 送信先プロセスの実 set-user-ID または保存 "
"set-user-ID と 等しくなければならない。 B<SIGCONT> の場合、送信プロセスと受信"
"プロセスが 同じセッションに属していれば十分である。 (過去には、 ルールは違っ"
"ていた; 「注意」の節を参照。)"

#. type: Plain text
#: build/C/man2/kill.2:104
msgid ""
"On success (at least one signal was sent), zero is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 (少なくとも一つのシグナルが送信された場合)、 0 が返される。エ"
"ラーの場合 -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/kill.2:108
msgid "An invalid signal was specified."
msgstr "無効なシグナルを指定した。"

#. type: TP
#: build/C/man2/kill.2:108 build/C/man2/prctl.2:2280 build/C/man2/prctl.2:2292
#: build/C/man2/prctl.2:2300 build/C/man2/prctl.2:2310
#: build/C/man2/prctl.2:2318 build/C/man2/prctl.2:2326
#: build/C/man2/rt_sigqueueinfo.2:157 build/C/man2/rt_sigqueueinfo.2:162
#: build/C/man2/sigaltstack.2:208 build/C/man3/sigqueue.3:102
#: build/C/man2/timer_create.2:230 build/C/man2/timerfd_create.2:450
#: build/C/man2/tkill.2:112 build/C/man3/killpg.3:93
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/kill.2:112
msgid ""
"The calling process does not have permission to send the signal to any of "
"the target processes."
msgstr "呼び出し元のプロセスが、受信するプロセスのいずれに対しても シグナルを送る許可を持っていない。"

#. type: TP
#: build/C/man2/kill.2:112 build/C/man2/rt_sigqueueinfo.2:168
#: build/C/man3/sigqueue.3:108 build/C/man2/tkill.2:117
#: build/C/man3/killpg.3:99 build/C/man3/killpg.3:103
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/kill.2:120
#, fuzzy
#| msgid ""
#| "The pid or process group does not exist.  Note that an existing process "
#| "might be a zombie, a process which already committed termination, but has "
#| "not yet been B<wait>(2)ed for."
msgid ""
"The target process or process group does not exist.  Note that an existing "
"process might be a zombie, a process that has terminated execution, but has "
"not yet been B<wait>(2)ed for."
msgstr ""
"指定したプロセスまたはプロセスグループが存在しなかった。 ゾンビプロセスは存在"
"するプロセスとしてみなされる。 ゾンビプロセスとはすでに処理は終了しているが、"
"親プロセスによる B<wait>()  処理が行われていないプロセスのことである。"

#. type: Plain text
#: build/C/man2/kill.2:122 build/C/man2/pause.2:59
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/kill.2:130
msgid ""
"The only signals that can be sent to process ID 1, the I<init> process, are "
"those for which I<init> has explicitly installed signal handlers.  This is "
"done to assure the system is not brought down accidentally."
msgstr ""
"プロセス番号 1 の I<init> プロセスに送ることができるシグナルは、 I<init> が明"
"示的にシグナルハンドラーを設定したシグナルだけである。 こうなっているのは、"
"誤ってシステムをダウンさせないようにするためである。"

#. type: Plain text
#: build/C/man2/kill.2:136
msgid ""
"POSIX.1 requires that I<kill(-1,sig)> send I<sig> to all processes that the "
"calling process may send signals to, except possibly for some implementation-"
"defined system processes.  Linux allows a process to signal itself, but on "
"Linux the call I<kill(-1,sig)> does not signal the calling process."
msgstr "POSIX.1 では、 I<kill(-1,sig)> が 呼び出し元のプロセスがシグナルを送ることが出来るプロセス全てに I<sig> を送ることを要求している。 但し、システム実装時に定められたシステムプロセスは シグナルの送信対象から除外される。 Linux では、プロセスが自分自身にシグナルを送れるようになっているが、 Linux の I<kill(-1,sig)> は呼び出し元のプロセスにはシグナルを送らない。"

#. type: Plain text
#: build/C/man2/kill.2:146
msgid ""
"POSIX.1 requires that if a process sends a signal to itself, and the sending "
"thread does not have the signal blocked, and no other thread has it "
"unblocked or is waiting for it in B<sigwait>(3), at least one unblocked "
"signal must be delivered to the sending thread before the B<kill>()  returns."
msgstr "POSIX.1 では以下の動作になることを要求している。 自分自身にシグナルを送ると、シグナルを送ったスレッドがそのシグナルをブロック しておらず、他のどのスレッドもそのシグナルを受ける状態にもなく B<sigwait>(3)  でそのシグナルを待ってもいない場合、 B<kill>()  が返る前に少なくとも一つのブロックされていない シグナルがシグナルを送ったスレッドに配送されなければならない。"

#. type: SS
#: build/C/man2/kill.2:146 build/C/man3/sigpause.3:98 build/C/man2/wait.2:527
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#.  In the 0.* kernels things chopped and changed quite
#.  a bit - MTK, 24 Jul 02
#. type: Plain text
#: build/C/man2/kill.2:160
msgid ""
"Across different kernel versions, Linux has enforced different rules for the "
"permissions required for an unprivileged process to send a signal to another "
"process.  In kernels 1.0 to 1.2.2, a signal could be sent if the effective "
"user ID of the sender matched effective user ID of the target, or the real "
"user ID of the sender matched the real user ID of the target.  From kernel "
"1.2.3 until 1.3.77, a signal could be sent if the effective user ID of the "
"sender matched either the real or effective user ID of the target.  The "
"current rules, which conform to POSIX.1, were adopted in kernel 1.3.78."
msgstr "Linux では、特権のないプロセスが他のプロセスにシグナルを送信するために必要な権限についてのルールが、カーネルバージョンにより違っている。 カーネル 1.0 から 1.2.2 では、送信側の実効ユーザー ID が送信対象の実効ユーザー ID と一致するか、 送信側の実ユーザー ID が送信対象の実ユーザー ID と一致すれば、 シグナルを送信できた。 カーネル 1.2.3 から 1.3.77では、送信側の実効ユーザー ID が送信対象の実ユーザー ID か実効ユーザー ID のいずれかと一致すればシグナルを送信できた。 現在のルールは、POSIX.1 に準拠しており、カーネル 1.3.78 以降で 適用されている。"

#. type: Plain text
#: build/C/man2/kill.2:170
msgid ""
"In 2.6 kernels up to and including 2.6.7, there was a bug that meant that "
"when sending signals to a process group, B<kill>()  failed with the error "
"B<EPERM> if the caller did not have permission to send the signal to I<any> "
"(rather than I<all>) of the members of the process group.  Notwithstanding "
"this error return, the signal was still delivered to all of the processes "
"for which the caller had permission to signal."
msgstr ""
"バージョン 2.6.7 以前の 2.6 系のカーネルには、 プロセスグループにシグナルを"
"送ったときに、 呼び出し元のプロセスがプロセスグループの (全メンバーではなく) "
"一部のメンバーに対してのみシグナルを送る許可を持っていない場合に、 "
"B<kill>()  がエラー B<EPERM> で失敗するというバグがある。 このエラーが返るに"
"もかかわらず、そのシグナルは呼び出し元が シグナルを送る許可を持つ全てのプロセ"
"スへ送られる。"

#. type: Plain text
#: build/C/man2/kill.2:182
msgid ""
"B<kill>(1), B<_exit>(2), B<pidfd_send_signal>(2), B<signal>(2), B<tkill>(2), "
"B<exit>(3), B<killpg>(3), B<sigqueue>(3), B<capabilities>(7), "
"B<credentials>(7), B<signal>(7)"
msgstr "B<kill>(1), B<_exit>(2), B<pidfd_send_signal>(2), B<signal>(2), B<tkill>(2), B<exit>(3), B<killpg>(3), B<sigqueue>(3), B<capabilities>(7), B<credentials>(7), B<signal>(7)"

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr "PAUSE"

#. type: TH
#: build/C/man2/pause.2:30 build/C/man3/raise.3:29
#: build/C/man2/timer_delete.2:26
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: build/C/man2/pause.2:33
msgid "pause - wait for signal"
msgstr "pause - シグナルを待つ"

#. type: Plain text
#: build/C/man2/pause.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr "B<int pause(void);>"

#. type: Plain text
#: build/C/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""
"B<pause>()  は、呼び出したプロセス (またはスレッド) を、 そのプロセスを終了さ"
"せたり、シグナル捕捉関数が起動されるような シグナルが配送されるまで、スリープ"
"させる。"

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: build/C/man2/pause.2:53
msgid ""
"B<pause>()  returns only when a signal was caught and the signal-catching "
"function returned.  In this case, B<pause>()  returns -1, and I<errno> is "
"set to B<EINTR>."
msgstr ""
"B<pause>()  が返るのは、シグナルを受け取りシグナル捕獲関数から返った場合だけ"
"である。 この場合は B<pause>()  は -1 を返し、 I<errno> に B<EINTR> が設定さ"
"れる。"

#. type: TP
#: build/C/man2/pause.2:54 build/C/man2/sigsuspend.2:81
#: build/C/man2/sigwaitinfo.2:124 build/C/man2/wait.2:453
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr "シグナルを受け取り、シグナル捕獲関数から帰ってきた。"

#. type: Plain text
#: build/C/man2/pause.2:64
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"

#. type: TH
#: build/C/man2/prctl.2:59
#, no-wrap
msgid "PRCTL"
msgstr "PRCTL"

#. type: TH
#: build/C/man2/prctl.2:59 build/C/man2/sgetmask.2:25 build/C/man3/sigset.3:25
#: build/C/man3/sigvec.3:25 build/C/man2/timerfd_create.2:19
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man2/prctl.2:62
msgid "prctl - operations on a process or thread"
msgstr "prctl - プロセスやスレッドの操作を行なう"

#. type: Plain text
#: build/C/man2/prctl.2:65
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/prctl.2:68
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"

#. type: Plain text
#: build/C/man2/prctl.2:73
msgid ""
"B<prctl>()  manipulates various aspects of the behavior of the calling "
"thread or process."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:78
msgid ""
"Note that careless use of some B<prctl>()  operations can confuse the user-"
"space run-time environment, so these operations should be used with care."
msgstr ""

#.  prctl PR_CAP_AMBIENT
#. type: Plain text
#: build/C/man2/prctl.2:86
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""
"B<prctl>()  の動作は最初の引数によって決定される (この値は I<E<lt>linux/"
"prctl.hE<gt>> に定義されている)。 残りの引数は最初の引数によって変化す"
"る。 一番目の引数として以下のものを指定できる:"

#. type: TP
#: build/C/man2/prctl.2:86
#, no-wrap
msgid "B<PR_CAP_AMBIENT> (since Linux 4.3)"
msgstr "B<PR_CAP_AMBIENT> (Linux 4.3 以降)"

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: build/C/man2/prctl.2:93
msgid ""
"Reads or changes the ambient capability set of the calling thread, according "
"to the value of I<arg2>, which must be one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:95
#, no-wrap
msgid "B<PR_CAP_AMBIENT_RAISE>"
msgstr "B<PR_CAP_AMBIENT_RAISE>"

#. type: Plain text
#: build/C/man2/prctl.2:105
msgid ""
"The capability specified in I<arg3> is added to the ambient set.  The "
"specified capability must already be present in both the permitted and the "
"inheritable sets of the process.  This operation is not permitted if the "
"B<SECBIT_NO_CAP_AMBIENT_RAISE> securebit is set."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:105
#, no-wrap
msgid "B<PR_CAP_AMBIENT_LOWER>"
msgstr "B<PR_CAP_AMBIENT_LOWER>"

#. type: Plain text
#: build/C/man2/prctl.2:110
#, fuzzy
#| msgid ""
#| "If the capability specified in I<arg2> is not valid, then the call fails "
#| "with the error B<EINVAL>."
msgid "The capability specified in I<arg3> is removed from the ambient set."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#. type: TP
#: build/C/man2/prctl.2:110
#, no-wrap
msgid "B<PR_CAP_AMBIENT_IS_SET>"
msgstr "B<PR_CAP_AMBIENT_IS_SET>"

#. type: Plain text
#: build/C/man2/prctl.2:117
msgid ""
"The B<prctl>()  call returns 1 if the capability in I<arg3> is in the "
"ambient set and 0 if it is not."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:117
#, no-wrap
msgid "B<PR_CAP_AMBIENT_CLEAR_ALL>"
msgstr "B<PR_CAP_AMBIENT_CLEAR_ALL>"

#. type: Plain text
#: build/C/man2/prctl.2:123
msgid ""
"All capabilities will be removed from the ambient set.  This operation "
"requires setting I<arg3> to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:130
msgid ""
"In all of the above operations, I<arg4> and I<arg5> must be specified as 0."
msgstr ""

#.  prctl PR_CAPBSET_READ
#. type: Plain text
#: build/C/man2/prctl.2:140
msgid ""
"Higher-level interfaces layered on top of the above operations are provided "
"in the B<libcap>(3)  library in the form of B<cap_get_ambient>(3), "
"B<cap_set_ambient>(3), and B<cap_reset_ambient>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:140
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_READ> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:152
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr "I<arg2> で指定されたケーパビリティが呼び出したスレッドのケーパビリティ バインディングセット (capability bounding set) に含まれている場合、 (関数の結果として) 1 を返し、そうでない場合 0 を返す (ケーパビリティ定数は I<E<lt>linux/capability.hE<gt>> で定義されている)。 ケーパビリティバウンディングセットは、 B<execve>(2) を呼び出した際に、ファイルの許可 (permitted) ケーパビリティの中でそのプロセスが獲得できるケーパビリティを指示するものである。"

#. type: Plain text
#: build/C/man2/prctl.2:157
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#.  prctl PR_CAPBSET_DROP
#. type: Plain text
#: build/C/man2/prctl.2:163
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_get_bound>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:163
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_DROP> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:172
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability within its user "
"namespace, then drop the capability specified by I<arg2> from the calling "
"thread's capability bounding set.  Any children of the calling thread will "
"inherit the newly reduced bounding set."
msgstr "呼び出したスレッドが、そのスレッドのユーザー名前空間でケーパビリティ B<CAP_SETPCAP> を持っている場合、 呼び出したスレッドのケーパビリティバウンディングセットから I<arg2> で指定されたケーパビリティを外す。 呼び出したスレッドの子プロセスは変更後のバウンディングセットを 継承する。"

#. type: Plain text
#: build/C/man2/prctl.2:184
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""
"呼び出したスレッドが B<CAP_SETPCAP> を持っていない場合、呼び出しはエラー "
"B<EPERM> で失敗する。 I<arg2> に指定されたケーパビリティが有効でない場合、 "
"B<EINVAL> で失敗する。 ファイルケーパビリティがカーネルで有効になっていない場"
"合 (この場合にはバウンディングセットがサポートされない)、 B<EINVAL> で失敗す"
"る。"

#.  prctl PR_SET_CHILD_SUBREAPER
#. type: Plain text
#: build/C/man2/prctl.2:190
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_drop_bound>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:190
#, no-wrap
msgid "B<PR_SET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_SET_CHILD_SUBREAPER> (Linux 3.4 以降)"

#.  commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
#. type: Plain text
#: build/C/man2/prctl.2:200
msgid ""
"If I<arg2> is nonzero, set the \"child subreaper\" attribute of the calling "
"process; if I<arg2> is zero, unset the attribute."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:217
msgid ""
"A subreaper fulfills the role of B<init>(1)  for its descendant processes.  "
"When a process becomes orphaned (i.e., its immediate parent terminates), "
"then that process will be reparented to the nearest still living ancestor "
"subreaper.  Subsequently, calls to B<getppid>(2)  in the orphaned process "
"will now return the PID of the subreaper process, and when the orphan "
"terminates, it is the subreaper process that will receive a B<SIGCHLD> "
"signal and will be able to B<wait>(2)  on the process to discover its "
"termination status."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:225
msgid ""
"The setting of the \"child subreaper\" attribute is not inherited by "
"children created by B<fork>(2)  and B<clone>(2).  The setting is preserved "
"across B<execve>(2)."
msgstr ""

#.  prctl PR_GET_CHILD_SUBREAPER
#. type: Plain text
#: build/C/man2/prctl.2:237
msgid ""
"Establishing a subreaper process is useful in session management frameworks "
"where a hierarchical group of processes is managed by a subreaper process "
"that needs to be informed when one of the processes\\(emfor example, a "
"double-forked daemon\\(emterminates (perhaps so that it can restart that "
"process).  Some B<init>(1)  frameworks (e.g., B<systemd>(1))  employ a "
"subreaper process for similar reasons."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:237
#, no-wrap
msgid "B<PR_GET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_GET_CHILD_SUBREAPER> (Linux 3.4 以降)"

#.  prctl PR_SET_DUMPABLE
#. type: Plain text
#: build/C/man2/prctl.2:243
msgid ""
"Return the \"child subreaper\" setting of the caller, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""
"呼び出し元の \"child subreaper\" 設定を、 I<(int\\ *) arg2> が指す場所に返"
"す。"

#. type: TP
#: build/C/man2/prctl.2:243
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_SET_DUMPABLE> (Linux 2.3.20 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:248
msgid ""
"Set the state of the \"dumpable\" attribute, which determines whether core "
"dumps are produced for the calling process upon delivery of a signal whose "
"default behavior is to produce a core dump."
msgstr ""

#.  commit abf75a5033d4da7b8a7e92321d74021d1fcfb502
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: build/C/man2/prctl.2:270
#, fuzzy
#| msgid ""
#| "Set the state of the flag determining whether core dumps are produced for "
#| "the calling process upon delivery of a signal whose default behavior is "
#| "to produce a core dump.  (Normally, this flag is set for a process by "
#| "default, but it is cleared when a set-user-ID or set-group-ID program is "
#| "executed and also by various system calls that manipulate process UIDs "
#| "and GIDs).  In kernels up to and including 2.6.12, I<arg2> must be either "
#| "0 (process is not dumpable) or 1 (process is dumpable).  Between kernels "
#| "2.6.13 and 2.6.17, the value 2 was also permitted, which caused any "
#| "binary which normally would not be dumped to be dumped readable by root "
#| "only; for security reasons, this feature has been removed.  (See also the "
#| "description of I</proc/sys/fs/suid_dumpable> in B<proc>(5).)  Processes "
#| "that are not dumpable can not be attached via B<ptrace>(2)  "
#| "B<PTRACE_ATTACH>."
msgid ""
"In kernels up to and including 2.6.12, I<arg2> must be either 0 "
"(B<SUID_DUMP_DISABLE>, process is not dumpable) or 1 (B<SUID_DUMP_USER>, "
"process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 was "
"also permitted, which caused any binary which normally would not be dumped "
"to be dumped readable by root only; for security reasons, this feature has "
"been removed.  (See also the description of I</proc/sys/fs/\\:suid_dumpable> "
"in B<proc>(5).)"
msgstr ""
"(Linux 2.3.20 以降) デフォルトの振る舞いではコアダンプを引き起こすようなシグ"
"ナルを受信したときに、呼び出し元のプロセスでコアダンプを生成するかどうかを決"
"定するフラグを設定する (通常このフラグは、デフォルトではセットされているが、 "
"set-user-ID あるいは set-group-ID プログラムが実行されたり、 さまざまなシステ"
"ムコールによってプロセスの UID や GID が操作されたときに クリアされる)。 "
"2.6.12 以前のカーネルでは、 I<arg2> は 0 (プロセスはダンプ不可) あるいは 1 "
"(プロセスはダンプ可能) の どちらかでなければならない。 2.6.13 から 2.6.17 ま"
"でのカーネルでは、値 2 も認められていた。 この値を指定すると、通常はダンプさ"
"れないバイナリが root だけが 読み込み可能な形でダンプされた。 セキュリティ上"
"の理由から、この機能は削除された (B<proc>(5) の I</proc/sys/fs/"
"suid_dumpable> の説明も参照)。 ダンプ不可のプロセスを B<ptrace>(2) "
"B<PTRACE_ATTACH> 経由で接続することはできない。"

#.  See kernel/cred.c::commit_creds() (Linux 3.18 sources)
#. type: Plain text
#: build/C/man2/prctl.2:277
msgid ""
"Normally, the \"dumpable\" attribute is set to 1.  However, it is reset to "
"the current value contained in the file I</proc/sys/fs/\\:suid_dumpable> "
"(which by default has the value 0), in the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:280
msgid "The process's effective user or group ID is changed."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:283
msgid ""
"The process's filesystem user or group ID is changed (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:288
msgid ""
"The process executes (B<execve>(2))  a set-user-ID or set-group-ID program, "
"resulting in a change of either the effective user ID or the effective group "
"ID."
msgstr ""

#.  See kernel/cred.c::commit_creds()
#.  Also certain namespace operations;
#. type: Plain text
#: build/C/man2/prctl.2:297
msgid ""
"The process executes (B<execve>(2))  a program that has file capabilities "
"(see B<capabilities>(7)), but only if the permitted capabilities gained "
"exceed those already permitted for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:305
msgid ""
"Processes that are not dumpable can not be attached via B<ptrace>(2)  "
"B<PTRACE_ATTACH>; see B<ptrace>(2)  for further details."
msgstr ""

#.  prctl PR_GET_DUMPABLE
#. type: Plain text
#: build/C/man2/prctl.2:312
msgid ""
"If a process is not dumpable, the ownership of files in the process's I</"
"proc/[pid]> directory is affected as described in B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:312
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_GET_DUMPABLE> (Linux 2.3.20 以降)"

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#.  prctl PR_SET_ENDIAN
#. type: Plain text
#: build/C/man2/prctl.2:320
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable attribute."
msgstr "(Linux 2.3.20 以降)  呼び出し元プロセスにおけるダンプ可能属性の現在の状態を (関数の結果として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:320
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_SET_ENDIAN> (Linux 2.6.18 以降、PowerPC のみ)"

#.  Respectively 0, 1, 2
#.  prctl PR_GET_ENDIAN
#. type: Plain text
#: build/C/man2/prctl.2:331
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""
"呼び出し元プロセスのエンディアン設定 (endian-ness) を I<arg2> で指定された値"
"に設定する。 指定できる値は B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"B<PR_ENDIAN_PPC_LITTLE> (PowerPC 擬似リトルエンディアン)  のいずれか一つであ"
"る。"

#. type: TP
#: build/C/man2/prctl.2:331
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_GET_ENDIAN> (Linux 2.6.18 以降、PowerPC のみ)"

#.  prctl PR_SET_FP_MODE
#. type: Plain text
#: build/C/man2/prctl.2:337
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"呼び出し元プロセスのエンディアン設定 (endian-ness) を I<(int\\ *) arg2> が指"
"す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:337
#, no-wrap
msgid "B<PR_SET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr "B<PR_SET_FP_MODE> (Linux 4.0 以降, MIPS のみ)"

#.  commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
#. type: Plain text
#: build/C/man2/prctl.2:349
msgid ""
"On the MIPS architecture, user-space code can be built using an ABI which "
"permits linking with code that has more restrictive floating-point (FP) "
"requirements.  For example, user-space code may be built to target the O32 "
"FPXX ABI and linked with code built for either one of the more restrictive "
"FP32 or FP64 ABIs.  When more restrictive code is linked in, the overall "
"requirement for the process is to use the more restrictive floating-point "
"mode."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:357
msgid ""
"Because the kernel has no means of knowing in advance which mode the process "
"should be executed in, and because these restrictions can change over the "
"lifetime of the process, the B<PR_SET_FP_MODE> operation is provided to "
"allow control of the floating-point mode from user space."
msgstr ""

#.  https://dmz-portal.mips.com/wiki/MIPS_O32_ABI_-_FR0_and_FR1_Interlinking
#. type: Plain text
#: build/C/man2/prctl.2:362
msgid ""
"The I<(unsigned int) arg2> argument is a bit mask describing the floating-"
"point mode used:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:363
#, no-wrap
msgid "B<PR_FP_MODE_FR>"
msgstr "B<PR_FP_MODE_FR>"

#. type: Plain text
#: build/C/man2/prctl.2:374
msgid ""
"When this bit is I<unset> (so called B<FR=0> or B<FR0> mode), the 32 "
"floating-point registers are 32 bits wide, and 64-bit registers are "
"represented as a pair of registers (even- and odd- numbered, with the even-"
"numbered register containing the lower 32 bits, and the odd-numbered "
"register containing the higher 32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:384
msgid ""
"When this bit is I<set> (on supported hardware), the 32 floating-point "
"registers are 64 bits wide (so called B<FR=1> or B<FR1> mode).  Note that "
"modern MIPS implementations (MIPS R6 and newer) support B<FR=1> mode only."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:399
msgid ""
"Applications that use the O32 FP32 ABI can operate only when this bit is "
"I<unset> (B<FR=0>; or they can be used with FRE enabled, see below).  "
"Applications that use the O32 FP64 ABI (and the O32 FP64A ABI, which exists "
"to provide the ability to operate with existing FP32 code; see below)  can "
"operate only when this bit is I<set> (B<FR=1>).  Applications that use the "
"O32 FPXX ABI can operate with either B<FR=0> or B<FR=1>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:399
#, no-wrap
msgid "B<PR_FP_MODE_FRE>"
msgstr "B<PR_FP_MODE_FRE>"

#. type: Plain text
#: build/C/man2/prctl.2:420
msgid ""
"Enable emulation of 32-bit floating-point mode.  When this mode is enabled, "
"it emulates 32-bit floating-point operations by raising a reserved-"
"instruction exception on every instruction that uses 32-bit formats and the "
"kernel then handles the instruction in software.  (The problem lies in the "
"discrepancy of handling odd-numbered registers which are the high 32 bits of "
"64-bit registers with even numbers in B<FR=0> mode and the lower 32-bit "
"parts of odd-numbered 64-bit registers in B<FR=1> mode.)  Enabling this bit "
"is necessary when code with the O32 FP32 ABI should operate with code with "
"compatible the O32 FPXX or O32 FP64A ABIs (which require B<FR=1> FPU mode) "
"or when it is executed on newer hardware (MIPS R6 onwards)  which lacks "
"B<FR=0> mode support when a binary with the FP32 ABI is used."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:423
msgid ""
"Note that this mode makes sense only when the FPU is in 64-bit mode "
"(B<FR=1>)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:426
msgid ""
"Note that the use of emulation inherently has a significant performance hit "
"and should be avoided if possible."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:432
msgid ""
"In the N32/N64 ABI, 64-bit floating-point mode is always used, so FPU "
"emulation is not required and the FPU always operates in B<FR=1> mode."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:435
msgid ""
"This option is mainly intended for use by the dynamic linker (B<ld.so>(8))."
msgstr ""

#.  prctl PR_GET_FP_MODE
#. type: Plain text
#: build/C/man2/prctl.2:443
msgid "The arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:443
#, no-wrap
msgid "B<PR_GET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr "B<PR_GET_FP_MODE> (Linux 4.0 以降, MIPS のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:449
#, fuzzy
#| msgid ""
#| "Return (as the function result)  the current timer slack value of the "
#| "calling thread."
msgid ""
"Return (as the function result)  the current floating-point mode (see the "
"description of B<PR_SET_FP_MODE> for details)."
msgstr ""
"呼び出し元スレッドの現在のタイマーのスラック値を (関数の結果として) 返す。"

#. type: Plain text
#: build/C/man2/prctl.2:452
msgid ""
"On success, the call returns a bit mask which represents the current "
"floating-point mode."
msgstr ""

#.  prctl PR_SET_FPEMU
#. type: Plain text
#: build/C/man2/prctl.2:461
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or "
#| "I<arg5> is nonzero."
msgid "The arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""
"I<option> が B<PR_GET_THP_DISABLE> で I<arg2>, I<arg3>, I<arg4>, I<arg5> のい"
"ずれが 0 ではない。"

#. type: TP
#: build/C/man2/prctl.2:461
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_SET_FPEMU> (Linux 2.4.18 以降, 2.5.9, ia64 のみ)"

#.  prctl PR_GET_FPEMU
#. type: Plain text
#: build/C/man2/prctl.2:472
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate floating-point operation accesses, "
"or B<PR_FPEMU_SIGFPE> to not emulate floating-point operations and send "
"B<SIGFPE> instead."
msgstr ""
"浮動小数点エミュレーション (floating-point emulation) 制御ビットを I<arg2> で"
"指定された値に設定する。 指定できる値は B<PR_FPEMU_NOPRINT> (浮動小数点命令ア"
"クセスを黙って エミュレートする) か B<PR_FPEMU_SIGFPE> (浮動小数点命令をエ"
"ミュレートせず、 代わりに B<SIGFPE> を送る) である。"

#. type: TP
#: build/C/man2/prctl.2:472
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_GET_FPEMU> (Linux 2.4.18 以降, 2.5.9, ia64 のみ)"

#.  prctl PR_SET_FPEXC
#. type: Plain text
#: build/C/man2/prctl.2:478
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"浮動小数点エミュレーション制御ビットの値を I<(int\\ *) arg2> が指す場所に格納"
"して返す。"

#. type: TP
#: build/C/man2/prctl.2:478
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_SET_FPEXC> (Linux 2.4.21 および 2.5.32 以降、PowerPC のみ)"

#.  prctl PR_GET_FPEXC
#. type: Plain text
#: build/C/man2/prctl.2:492
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for floating-"
"point inexact result, B<PR_FP_EXC_INV> for floating-point invalid operation, "
"B<PR_FP_EXC_DISABLED> for FP exceptions disabled, B<PR_FP_EXC_NONRECOV> for "
"async nonrecoverable exception mode, B<PR_FP_EXC_ASYNC> for async "
"recoverable exception mode, B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""
"浮動小数点例外モード (floating-point exception mode) を I<arg2> で指定された"
"値に設定する。 指定できるのは以下の値である: B<PR_FP_EXC_SW_ENABLE> (FPEXC で"
"浮動小数点例外を有効にする)、 B<PR_FP_EXC_DIV> (0 除算)、 B<PR_FP_EXC_OVF> "
"(オーバーフロー)、 B<PR_FP_EXC_UND> (アンダーフロー)、 B<PR_FP_EXC_RES> (不正"
"確な結果 (inexact result))、 B<PR_FP_EXC_INV> (不正な命令 (invalid "
"operation))、 B<PR_FP_EXC_DISABLED> (浮動小数点例外を無効にする)、 "
"B<PR_FP_EXC_NONRECOV> (async nonrecoverable exception mode)、 "
"B<PR_FP_EXC_ASYNC> (async recoverable exception mode)、 B<PR_FP_EXC_PRECISE> "
"(precise exception mode)。"

#. type: TP
#: build/C/man2/prctl.2:492
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_GET_FPEXC>(Linux 2.4.21 および 2.5.32 以降、PowerPC のみ)"

#.  prctl PR_SET_IO_FLUSHER
#. type: Plain text
#: build/C/man2/prctl.2:498
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""
"浮動小数点例外モードの値を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:498
#, no-wrap
msgid "B<PR_SET_IO_FLUSHER> (since Linux 5.6)"
msgstr "B<PR_SET_IO_FLUSHER> (Linux 5.6 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:507
msgid ""
"If a user process is involved in the block layer or filesystem I/O path, and "
"can allocate memory while processing I/O requests it must set I<arg2> to 1.  "
"This will put the process in the IO_FLUSHER state, which allows it special "
"treatment to make progress when allocating memory.  If I<arg2> is 0, the "
"process will clear the IO_FLUSHER state, and the default behavior will be "
"used."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:511 build/C/man2/prctl.2:536
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_SET_MM>, and the caller does not have the "
#| "B<CAP_SYS_RESOURCE> capability."
msgid "The calling process must have the B<CAP_SYS_RESOURCE> capability."
msgstr ""
"I<option> が B<PR_SET_MM> で、呼び出し元がケーパビリティ B<CAP_SYS_RESOURCE> "
"を持っていない。"

#. type: Plain text
#: build/C/man2/prctl.2:517
#, fuzzy
#| msgid "I<arg4> or I<arg5> is nonzero;"
msgid "I<arg3>, I<arg4>, and I<arg5> must be zero."
msgstr "I<arg4> が I<arg5> で 0 以外である。"

#. type: Plain text
#: build/C/man2/prctl.2:522
msgid ""
"The IO_FLUSHER state is inherited by a child process created via B<fork>(2)  "
"and is preserved across B<execve>(2)."
msgstr ""

#.  prctl PR_GET_IO_FLUSHER
#. type: Plain text
#: build/C/man2/prctl.2:527
msgid ""
"Examples of IO_FLUSHER applications are FUSE daemons, SCSI device emulation "
"daemons, and daemons that perform error handling like multipath path "
"recovery applications."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:527
#, no-wrap
msgid "B<PR_GET_IO_FLUSHER (Since Linux 5.6)>"
msgstr "B<PR_GET_IO_FLUSHER (Linux 5.6 以降)>"

#. type: Plain text
#: build/C/man2/prctl.2:532
msgid ""
"Return (as the function result) the IO_FLUSHER state of the caller.  A value "
"of 1 indicates that the caller is in the IO_FLUSHER state; 0 indicates that "
"the caller is not in the IO_FLUSHER state."
msgstr ""

#.  prctl PR_SET_KEEPCAPS
#. type: Plain text
#: build/C/man2/prctl.2:544
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or "
#| "I<arg5> is nonzero."
msgid "I<arg2>, I<arg3>, I<arg4>, and I<arg5> must be zero."
msgstr ""
"I<option> が B<PR_GET_THP_DISABLE> で I<arg2>, I<arg3>, I<arg4>, I<arg5> のい"
"ずれが 0 ではない。"

#. type: TP
#: build/C/man2/prctl.2:544
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_SET_KEEPCAPS> (Linux 2.2.18 以降)"

#.  prctl PR_GET_KEEPCAPS
#. type: Plain text
#: build/C/man2/prctl.2:555
msgid ""
"Set the state of the calling thread's \"keep capabilities\" flag.  The "
"effect of this flag is described in B<capabilities>(7).  I<arg2> must be "
"either 0 (clear the flag)  or 1 (set the flag).  The \"keep capabilities\" "
"value will be reset to 0 on subsequent calls to B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:555
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_GET_KEEPCAPS> (Linux 2.2.18 以降)"

#.  prctl PR_MCE_KILL
#. type: Plain text
#: build/C/man2/prctl.2:563
#, fuzzy
#| msgid ""
#| "Return (as the function result) the current state of the calling "
#| "threads's \"keep capabilities\" flag."
msgid ""
"Return (as the function result) the current state of the calling thread's "
"\"keep capabilities\" flag.  See B<capabilities>(7)  for a description of "
"this flag."
msgstr ""
"呼び出し元スレッドにおける「ケーパビリティ保持」フラグの 現在の状態を (関数の"
"結果として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:563
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL> (Linux 2.6.32 以降)"

#.  prctl PR_MCE_KILL_GET
#. type: Plain text
#: build/C/man2/prctl.2:604
msgid ""
"Set the machine check memory corruption kill policy for the calling thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the system-"
"wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the thread "
"receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is killed "
"only when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr "呼び出し元スレッドの machine check memory corruption kill ポリシーを設定する。 I<arg2> が B<PR_MCE_KILL_CLEAR> の場合、 このスレッドの memory corruption kill ポリシーをクリアし、 システム全体のデフォルト値を使用する (システム全体のデフォルトは I</proc/sys/vm/memory_failure_early_kill> で定義される。 B<proc>(5) 参照)。 I<arg2> が B<PR_MCE_KILL_SET> の場合、 スレッド固有の memory corruption kill ポリシーを使用する。 この場合、 I<arg3> によりこのポリシーが I<early kill> (B<PR_MCE_KILL_EARLY> か、 I<late kill> (B<PR_MCE_KILL_LATE>) か、 システム全体のデフォルト値 (B<PR_MCE_KILL_DEFAULT>) が指定される。 early kill は、 ハードウェアメモリー破壊 (corruption) がスレッドのアドレス空間内で検出されるとすぐに、 そのスレッドが B<SIGBUS> シグナルを受信することを意味する。 late kill モードでは、 メモリー破壊が起こったページにアクセスした場合にのみ、 そのプロセスが kill される。 B<SIGBUS> シグナルの詳細は B<sigaction>(2) を参照。 このポリシーは子プロセスに継承される。 未使用の残りの B<prctl>() の引数は将来の互換性のため 0 にしなければならない。"

#. type: TP
#: build/C/man2/prctl.2:604
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL_GET> (Linux 2.6.32 以降)"

#.  prctl PR_SET_MM
#. type: Plain text
#: build/C/man2/prctl.2:612
#, fuzzy
#| msgid ""
#| "Return the current per-process machine check kill policy.  All unused "
#| "B<prctl>()  arguments must be zero."
msgid ""
"Return (as the function result)  the current per-process machine check kill "
"policy.  All unused B<prctl>()  arguments must be zero."
msgstr ""
"現在のプロセス単位の machine check kill ポリシーを返す。 未使用の B<prctl>() "
"の引数はすべて 0 にしなければならない。"

#. type: TP
#: build/C/man2/prctl.2:612
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr "B<PR_SET_MM> (Linux 3.3 以降)"

#.  commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
#. type: Plain text
#: build/C/man2/prctl.2:622
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see B<ld."
"so>(8)  for more information) and a regular application should not use this "
"feature.  However, there are cases, such as self-modifying programs, where a "
"program might find it useful to change its own memory map."
msgstr "呼び出したプロセスのカーネルメモリーマップディスクリプターのフィールドを変更する。 これらのフィールドは通常カーネルと動的リンカーにより設定される (詳しい情報は B<ld.so> を参照)。 通常のアプリケーションはこの機能を利用すべきではない。 しかしながら、自分を書き換えるプログラムなど、 プログラムが自分自身のメモリーマップを変更するのが有用な場面もある。"

#. type: Plain text
#: build/C/man2/prctl.2:636
msgid ""
"The calling process must have the B<CAP_SYS_RESOURCE> capability.  The value "
"in I<arg2> is one of the options below, while I<arg3> provides a new value "
"for the option.  The I<arg4> and I<arg5> arguments must be zero if unused."
msgstr "呼び出したプロセスは B<CAP_SYS_RESOURCE> ケーパビリティを持っていなければならない。 I<arg2> の値には以下のいずれかを指定し、 I<arg3> でそのオプションの新しい値を指定する。引数 I<arg4> と I<arg5> は、使用しない場合は 0 でなければならない。"

#.  commit 52b3694157e3aa6df871e283115652ec6f2d31e0
#. type: Plain text
#: build/C/man2/prctl.2:642
msgid ""
"Before Linux 3.10, this feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr "Linux 3.16 より前は、この機能は、カーネルが B<CONFIG_SGETMASK_SYSCALL> オプションを有効にして作成されている場合にのみ利用できる。"

#. type: TP
#: build/C/man2/prctl.2:643
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr "B<PR_SET_MM_START_CODE>"

#. type: Plain text
#: build/C/man2/prctl.2:652
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr ""
"プログラムテキストを実行できるアドレスの上限を設定する。 対応するメモリー領域"
"は読み出し可能で実行可能でなければならないが、 書き込み可能だったり共有可能"
"だったりしてはならない (詳しい情報は B<mprotect>(2) と B<mmap>(2) 参照)。"

#. type: TP
#: build/C/man2/prctl.2:652
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr "B<PR_SET_MM_END_CODE>"

#. type: Plain text
#: build/C/man2/prctl.2:657
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable."
msgstr ""
"プログラムテキストを実行できるアドレスの下限を設定する。 対応するメモリー領域"
"は読み出し可能で実行可能でなければならないが、 書き込み可能だったり共有可能"
"だったりしてはならない。"

#. type: TP
#: build/C/man2/prctl.2:657
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr "B<PR_SET_MM_START_DATA>"

#. type: Plain text
#: build/C/man2/prctl.2:663
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""
"初期化済データや未初期化 (bss) データを配置する領域のアドレス上限を指定す"
"る。 対応するメモリー領域は読み書き可能でなければならないが、 実行可能だった"
"り共有可能だったりしてはならない。"

#. type: TP
#: build/C/man2/prctl.2:663
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr "B<PR_SET_MM_END_DATA>"

#. type: Plain text
#: build/C/man2/prctl.2:669
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""
"初期化済データや未初期化 (bss) データを配置する領域のアドレス下限を指定す"
"る。 対応するメモリー領域は読み書き可能でなければならないが、 実行可能だった"
"り共有可能だったりしてはならない。"

#. type: TP
#: build/C/man2/prctl.2:669
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr "B<PR_SET_MM_START_STACK>"

#. type: Plain text
#: build/C/man2/prctl.2:673
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr ""
"スタックの開始アドレスを設定する。 対応するメモリー領域は読み書き可能でなけれ"
"ばならない。"

#. type: TP
#: build/C/man2/prctl.2:673
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr "B<PR_SET_MM_START_BRK>"

#. type: Plain text
#: build/C/man2/prctl.2:685
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)  "
"call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr ""
"B<brk>(2) コールで拡張できるプログラムのヒープ領域のアドレス上限を設定する。 "
"このアドレスは、プログラムの現在のデータセグメントの最終アドレスより大きくな"
"ければならない。 また、 変更後のヒープとデータセグメントのサイズを合わせたサ"
"イズが B<RLIMIT_DATA> リソースリミットを超えることはできない "
"(B<setrlimit>(2) 参照)。"

#. type: TP
#: build/C/man2/prctl.2:685
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr "B<PR_SET_MM_BRK>"

#. type: Plain text
#: build/C/man2/prctl.2:693
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr ""
"現在の B<brk>(2) 値を設定する。 このアドレスの要件は B<PR_SET_MM_START_BRK> "
"オプションと同じである。"

#.  commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
#. type: Plain text
#: build/C/man2/prctl.2:696
msgid "The following options are available since Linux 3.5."
msgstr "以下のオプションは Linux 3.5 以降で利用できる。"

#. type: TP
#: build/C/man2/prctl.2:696
#, no-wrap
msgid "B<PR_SET_MM_ARG_START>"
msgstr "B<PR_SET_MM_ARG_START>"

#. type: Plain text
#: build/C/man2/prctl.2:699
msgid "Set the address above which the program command line is placed."
msgstr "プログラムのコマンドラインを配置するアドレスの上限を設定する。"

#. type: TP
#: build/C/man2/prctl.2:699
#, no-wrap
msgid "B<PR_SET_MM_ARG_END>"
msgstr "B<PR_SET_MM_ARG_END>"

#. type: Plain text
#: build/C/man2/prctl.2:702
msgid "Set the address below which the program command line is placed."
msgstr "プログラムのコマンドラインを配置するアドレスの下限を設定する。"

#. type: TP
#: build/C/man2/prctl.2:702
#, no-wrap
msgid "B<PR_SET_MM_ENV_START>"
msgstr "B<PR_SET_MM_ENV_START>"

#. type: Plain text
#: build/C/man2/prctl.2:705
msgid "Set the address above which the program environment is placed."
msgstr ""
"プログラムの環境情報 (environment) を配置するアドレスの上限を設定する。"

#. type: TP
#: build/C/man2/prctl.2:705
#, no-wrap
msgid "B<PR_SET_MM_ENV_END>"
msgstr "B<PR_SET_MM_ENV_END>"

#. type: Plain text
#: build/C/man2/prctl.2:708
msgid "Set the address below which the program environment is placed."
msgstr ""
"プログラムの環境情報 (environment) を配置するアドレスの下限を設定する。"

#. type: Plain text
#: build/C/man2/prctl.2:721
msgid ""
"The address passed with B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START>, and B<PR_SET_MM_ENV_END> should belong to a process "
"stack area.  Thus, the corresponding memory area must be readable, writable, "
"and (depending on the kernel configuration) have the B<MAP_GROWSDOWN> "
"attribute set (see B<mmap>(2))."
msgstr ""
"B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, B<PR_SET_MM_ENV_START>, "
"B<PR_SET_MM_ENV_END> で指定されるアドレスはプロセスのスタック領域に属している"
"必要がある。 したがって、これらのメモリー領域は読み書き可能でなければならな"
"い。 また、 (カーネル設定によっては) B<MAP_GROWSDOWN> 属性がセットされていな"
"ければならない (B<mmap>(2) 参照)。"

#. type: TP
#: build/C/man2/prctl.2:721
#, no-wrap
msgid "B<PR_SET_MM_AUXV>"
msgstr "B<PR_SET_MM_AUXV>"

#. type: Plain text
#: build/C/man2/prctl.2:730
msgid ""
"Set a new auxiliary vector.  The I<arg3> argument should provide the address "
"of the vector.  The I<arg4> is the size of the vector."
msgstr ""
"新しい補助ベクトル (auxiliary vector) を設定する。 I<arg3> 引数はベクトルの"
"アドレスを指定し、 I<arg4> はベクトルのサイズを指定する。"

#. type: TP
#: build/C/man2/prctl.2:730
#, no-wrap
msgid "B<PR_SET_MM_EXE_FILE>"
msgstr "B<PR_SET_MM_EXE_FILE>"

#.  commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
#. type: Plain text
#: build/C/man2/prctl.2:742
msgid ""
"Supersede the I</proc/pid/exe> symbolic link with a new one pointing to a "
"new executable file identified by the file descriptor provided in I<arg3> "
"argument.  The file descriptor should be obtained with a regular B<open>(2)  "
"call."
msgstr ""
"I</proc/pid/exe> シンボリックリンクを I<arg3> 引数で渡された新しい実行可能"
"なファイルディスクリプターを指すシンボリックリンクで置き換える。 ファイルディ"
"スクリプターは通常の B<open>(2) コールで取得すべきである。"

#. type: Plain text
#: build/C/man2/prctl.2:749
msgid ""
"To change the symbolic link, one needs to unmap all existing executable "
"memory areas, including those created by the kernel itself (for example the "
"kernel usually creates at least one executable memory area for the ELF I<."
"text> section)."
msgstr ""
"シンボリックリンクを変更するには、 既存の実行可能なメモリー領域のすべてをアン"
"マップする必要がある。これにはカーネル自身が作成した領域も含まれる (例えば、"
"カーネルは通常 ELF I<.text> セクションに少なくとも一つの実行可能なメモリー領"
"域を作成する)。"

#.  commit 3fb4afd9a504c2386b8435028d43283216bf588e
#. type: Plain text
#: build/C/man2/prctl.2:760
msgid ""
"In Linux 4.9 and earlier, the B<PR_SET_MM_EXE_FILE> operation can be "
"performed only once in a process's lifetime; attempting to perform the "
"operation a second time results in the error B<EPERM>.  This restriction was "
"enforced for security reasons that were subsequently deemed specious, and "
"the restriction was removed in Linux 4.10 because some user-space "
"applications needed to perform this operation more than once."
msgstr ""

#.  commit f606b77f1a9e362451aca8f81d8f36a3a112139e
#. type: Plain text
#: build/C/man2/prctl.2:763
msgid "The following options are available since Linux 3.18."
msgstr "以下のオプションは Linux 3.18 以降で利用できる。"

#. type: TP
#: build/C/man2/prctl.2:763
#, no-wrap
msgid "B<PR_SET_MM_MAP>"
msgstr "B<PR_SET_MM_MAP>"

#. type: Plain text
#: build/C/man2/prctl.2:771
msgid ""
"Provides one-shot access to all the addresses by passing in a I<struct "
"prctl_mm_map> (as defined in I<E<lt>linux/prctl.hE<gt>>).  The I<arg4> "
"argument should provide the size of the struct."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:775 build/C/man2/prctl.2:788
msgid ""
"This feature is available only if the kernel is built with the "
"B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:775
#, no-wrap
msgid "B<PR_SET_MM_MAP_SIZE>"
msgstr "B<PR_SET_MM_MAP_SIZE>"

#. type: Plain text
#: build/C/man2/prctl.2:784
msgid ""
"Returns the size of the I<struct prctl_mm_map> the kernel expects.  This "
"allows user space to find a compatible struct.  The I<arg4> argument should "
"be a pointer to an unsigned int."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:790
#, no-wrap
msgid "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (since Linux 3.19, removed in Linux 5.4; only on x86)"
msgstr "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (Linux 3.19 以降; Linux 5.4 で削除; x86 のみ) "

#.  commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
#.  See also http://lwn.net/Articles/582712/
#.  See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
#.  commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
#. type: Plain text
#: build/C/man2/prctl.2:805
msgid ""
"Enable or disable kernel management of Memory Protection eXtensions (MPX)  "
"bounds tables.  The I<arg2>, I<arg3>, I<arg4>, and I<arg5> arguments must be "
"zero."
msgstr ""
"Memory Protection eXtensions (MPX) の境界テーブル (bounds table) のカーネル管"
"理の有効化/無効化を行う。 引数 I<arg2>, I<arg3>, I<arg4>, I<arg5> は 0 でな"
"ければならない。"

#. type: Plain text
#: build/C/man2/prctl.2:818
msgid ""
"MPX is a hardware-assisted mechanism for performing bounds checking on "
"pointers.  It consists of a set of registers storing bounds information and "
"a set of special instruction prefixes that tell the CPU on which "
"instructions it should do bounds enforcement.  There is a limited number of "
"these registers and when there are more pointers than registers, their "
"contents must be \"spilled\" into a set of tables.  These tables are called "
"\"bounds tables\" and the MPX B<prctl>()  operations control whether the "
"kernel manages their allocation and freeing."
msgstr ""
"MPX は、 ポインターの境界チェックを行うハードウェア支援機構である。 この機能"
"は、 境界情報を格納するレジスター群と、 境界チェックをどの命令に課すかを CPU "
"に教えるための特別な命令プレフィックスの集合で構成される。 これらのレジスター"
"数は限られており、 レジスター数よりも多くのポインターがある場合には、 その内"
"容をテーブル群に退避する (spilled) 必要がある。 これらのテーブル群は「境界"
"テーブル (bounds tables)」と呼ばれ、 MPX B<prctl> 命令はカーネルがこれらの割"
"り当てと解放を行うかどうかを制御する。"

#. type: Plain text
#: build/C/man2/prctl.2:828
msgid ""
"When management is enabled, the kernel will take over allocation and freeing "
"of the bounds tables.  It does this by trapping the #BR exceptions that "
"result at first use of missing bounds tables and instead of delivering the "
"exception to user space, it allocates the table and populates the bounds "
"directory with the location of the new table.  For freeing, the kernel "
"checks to see if bounds tables are present for memory which is not "
"allocated, and frees them if so."
msgstr ""
"管理が有効になっている場合、 カーネルが境界テーブルの割り当てと解放を担当す"
"る。 最初に存在しない境界テーブルを使おうとした際に上がる #BR 例外を捕捉し、 "
"ユーザー空間に例外を配送せずに、 テーブルの割り当てを行い、 新しいテーブルに"
"境界情報 (bounds directory) を書き込む。 解放に関しては、 カーネルが割り当て"
"られていないメモリーに対応する境界テーブルが存在するかを確認し、 そうであれば"
"解放を行う。"

#. type: Plain text
#: build/C/man2/prctl.2:835
msgid ""
"Before enabling MPX management using B<PR_MPX_ENABLE_MANAGEMENT>, the "
"application must first have allocated a user-space buffer for the bounds "
"directory and placed the location of that directory in the I<bndcfgu> "
"register."
msgstr ""
"B<PR_MPX_ENABLE_MANAGEMENT> を使って MPX 管理を有効にする前に、 アプリケー"
"ションはまず境界情報管理用のユーザー空間バッファーを割り当て、 その管理情報の"
"場所を I<bndcfgu> レジスターに設定しなければならない。"

#. type: Plain text
#: build/C/man2/prctl.2:843
msgid ""
"These calls fail if the CPU or kernel does not support MPX.  Kernel support "
"for MPX is enabled via the B<CONFIG_X86_INTEL_MPX> configuration option.  "
"You can check whether the CPU supports MPX by looking for the I<mpx> CPUID "
"bit, like with the following command:"
msgstr "CPU やカーネルが MPX をサポートしていない場合、 これらの呼び出しは失敗する。 カーネルによる MPX のサポートは B<CONFIG_X86_INTEL_MPX> 設定オプションで有効にできる。 CPU が MPX をサポートしているかを確認するには、 以下のように I<mpx> CPUID ビットを見ればよい。"

#. type: Plain text
#: build/C/man2/prctl.2:847
#, no-wrap
msgid "cat /proc/cpuinfo | grep \\(aq mpx \\(aq\n"
msgstr "cat /proc/cpuinfo | grep \\(aq mpx \\(aq\n"

#. type: Plain text
#: build/C/man2/prctl.2:852
msgid ""
"A thread may not switch in or out of long (64-bit) mode while MPX is enabled."
msgstr ""
"MPX が有効になっている間は、 スレッドはロング (64 ビット) モードのオン/オフの"
"切り替えはできない。"

#. type: Plain text
#: build/C/man2/prctl.2:854
msgid "All threads in a process are affected by these calls."
msgstr "プロセス内のすべてのスレッドがこれらの呼び出しの影響を受ける。"

#. type: Plain text
#: build/C/man2/prctl.2:863
msgid ""
"The child of a B<fork>(2)  inherits the state of MPX management.  During "
"B<execve>(2), MPX management is reset to a state as if "
"B<PR_MPX_DISABLE_MANAGEMENT> had been called."
msgstr ""
"B<fork>(2) で作成された子プロセスは MPX 管理の状態を継承する。 B<execve>(2) "
"の中で、 MPX 管理は B<PR_MPX_DISABLE_MANAGEMENT> が呼ばれた場合と同じ状態がリ"
"セットされる。"

#. type: Plain text
#: build/C/man2/prctl.2:866
msgid ""
"For further information on Intel MPX, see the kernel source file "
"I<Documentation/x86/intel_mpx.txt>."
msgstr ""
"Intel MPX についての詳しい情報は、カーネルソースファイル I<Documentation/x86/"
"intel_mpx.txt> を参照。"

#.  commit f240652b6032b48ad7fa35c5e701cc4c8d697c0b
#.  See also https://lkml.kernel.org/r/20190705175321.DB42F0AD@viggo.jf.intel.com
#.  prctl PR_SET_NAME
#. type: Plain text
#: build/C/man2/prctl.2:873
#, fuzzy
#| msgid ""
#| "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (since Linux "
#| "3.19) "
msgid ""
"Due to a lack of toolchain support, B<PR_MPX_ENABLE_MANAGEMENT> and "
"B<PR_MPX_DISABLE_MANAGEMENT> are not supported in Linux 5.4 and later."
msgstr ""
"B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (Linux 3.19 以降) "

#. type: TP
#: build/C/man2/prctl.2:873
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr "B<PR_SET_NAME> (Linux 2.6.9 以降)"

#.  TASK_COMM_LEN in include/linux/sched.h
#.  prctl PR_GET_NAME
#. type: Plain text
#: build/C/man2/prctl.2:896
#, fuzzy
#| msgid ""
#| "Set the name of the calling thread, using the value in the location "
#| "pointed to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, "
#| "including the terminating null byte.  (If the length of the string, "
#| "including the terminating null byte, exceeds 16 bytes, the string is "
#| "silently truncated.)  This is the same attribute that can be set via "
#| "B<pthread_setname_np>(3)  and retrieved using B<pthread_getname_np>(3).  "
#| "The attribute is likewise accessible via I</proc/self/task/[tid]/comm>, "
#| "where I<tid> is the name of the calling thread."
msgid ""
"Set the name of the calling thread, using the value in the location pointed "
"to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, including "
"the terminating null byte.  (If the length of the string, including the "
"terminating null byte, exceeds 16 bytes, the string is silently truncated.)  "
"This is the same attribute that can be set via B<pthread_setname_np>(3)  and "
"retrieved using B<pthread_getname_np>(3).  The attribute is likewise "
"accessible via I</proc/self/task/[tid]/comm> (see B<proc>(5)), where "
"I<[tid]> is the thread ID of the calling thread, as returned by B<gettid>(2)."
msgstr ""
"呼び出し元スレッドのプロセス名を I<(char\\ *) arg2> が指す場所に格納された値"
"を使って設定する。 名前は終端の NULL バイトを含めて最大で 16 バイトである (終"
"端の NULL バイトを含めた文字列の長さが 16 バイトを超える場合、 文字列は黙って"
"切り詰められる)。 これは、 B<pthread_setname_np>(3) で設定でき、 "
"B<pthread_getname_np>(3) で取得できるのと同じ属性である。 同様に、 I<tid> が"
"呼び出し元スレッドの ID の場合、 この属性は I</proc/self/task/[tid]/comm> 経"
"由でもアクセス可能である。"

#. type: TP
#: build/C/man2/prctl.2:896
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr "B<PR_GET_NAME> (Linux 2.6.11 以降)"

#.  prctl PR_SET_NO_NEW_PRIVS
#. type: Plain text
#: build/C/man2/prctl.2:904
msgid ""
"Return the name of the calling thread, in the buffer pointed to by I<(char\\ "
"*) arg2>.  The buffer should allow space for up to 16 bytes; the returned "
"string will be null-terminated."
msgstr ""
"呼び出し元スレッドの名前を I<(char\\ *) arg2> が指す場所に格納して返す。 バッ"
"ファーは最大で 16 バイトを格納できるようにすべきである。 返される文字列はヌル"
"終端される。"

#. type: TP
#: build/C/man2/prctl.2:904
#, no-wrap
msgid "B<PR_SET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_SET_NO_NEW_PRIVS> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:929
#, fuzzy
#| msgid ""
#| "Set the calling process's I<no_new_privs> bit to the value in I<arg2>.  "
#| "With I<no_new_privs> set to 1, B<execve>(2)  promises not to grant "
#| "privileges to do anything that could not have been done without the "
#| "B<execve>(2)  call (for example, rendering the set-user-ID and set-group-"
#| "ID permission bits, and file capabilities non-functional).  Once set, "
#| "this bit cannot be unset.  The setting of this bit is inherited by "
#| "children created by B<fork>(2)  and B<clone>(2), and preserved across "
#| "B<execve>(2)."
msgid ""
"Set the calling thread's I<no_new_privs> attribute to the value in I<arg2>.  "
"With I<no_new_privs> set to 1, B<execve>(2)  promises not to grant "
"privileges to do anything that could not have been done without the "
"B<execve>(2)  call (for example, rendering the set-user-ID and set-group-ID "
"mode bits, and file capabilities non-functional).  Once set, the "
"I<no_new_privs> attribute cannot be unset.  The setting of this attribute is "
"inherited by children created by B<fork>(2)  and B<clone>(2), and preserved "
"across B<execve>(2)."
msgstr ""
"呼び出し元プロセスの I<no_new_privs> ビットを I<arg2> の値に設定する。 "
"I<no_new_privs> が 1 に設定されると、 B<execve>(2) は、 B<execve>(2) の呼び出"
"しなしでは実行できなかったことに対する特権を許可しなくなる (例えば、 set-"
"user-ID/set-group-ID 許可ビットやファイルケーパビリティが動作しなくなる)。 一"
"度設定される、 このビットは解除することができない。 このビットの設定は "
"B<fork>(2) や B<clone>(2) で作成された子プロセスに継承され、 B<execve>(2) の"
"前後で保持される。"

#. type: Plain text
#: build/C/man2/prctl.2:938
msgid ""
"Since Linux 4.10, the value of a thread's I<no_new_privs> attribute can be "
"viewed via the I<NoNewPrivs> field in the I</proc/[pid]/status> file."
msgstr ""

#.  commit 40fde647ccb0ae8c11d256d271e24d385eed595b
#.  prctl PR_GET_NO_NEW_PRIVS
#. type: Plain text
#: build/C/man2/prctl.2:948
#, fuzzy
#| msgid ""
#| "For more information, see the kernel source file I<Documentation/prctl/"
#| "no_new_privs.txt>."
msgid ""
"For more information, see the kernel source file I<Documentation/userspace-"
"api/no_new_privs.rst> (or I<Documentation/prctl/no_new_privs.txt> before "
"Linux 4.13).  See also B<seccomp>(2)."
msgstr ""
"詳しい情報は、カーネルソースファイル I<Documentation/prctl/no_new_privs.txt> "
"を参照。"

#. type: TP
#: build/C/man2/prctl.2:948
#, no-wrap
msgid "B<PR_GET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_GET_NO_NEW_PRIVS> (Linux 3.5 以降)"

#.  prctl PR_PAC_RESET_KEYS
#.  commit ba830885656414101b2f8ca88786524d4bb5e8c1
#. type: Plain text
#: build/C/man2/prctl.2:961
msgid ""
"Return (as the function result) the value of the I<no_new_privs> attribute "
"for the calling thread.  A value of 0 indicates the regular B<execve>(2)  "
"behavior.  A value of 1 indicates B<execve>(2)  will operate in the "
"privilege-restricting mode described above."
msgstr "呼び出し元スレッドの I<no_new_privs> 属性の値を (関数の結果として) 返す。 値 0 は通常の B<execve>(2) の動作を意味する。 値 1 は B<execve>(2) が上記で述べた特権を制限する動作をすることを示す。"

#. type: TP
#: build/C/man2/prctl.2:961
#, no-wrap
msgid "B<PR_PAC_RESET_KEYS> (since Linux 5.0, only on arm64)"
msgstr "B<PR_PAC_RESET_KEYS> (Linux 5.0 以降, arm64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:965
msgid ""
"Securely reset the thread's pointer authentication keys to fresh random "
"values generated by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:969
msgid ""
"The set of keys to be reset is specified by I<arg2>, which must be a logical "
"OR of zero or more of the following:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:970
#, no-wrap
msgid "B<PR_PAC_APIAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:973
msgid "instruction authentication key A"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:973
#, no-wrap
msgid "B<PR_PAC_APIBKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:976
msgid "instruction authentication key B"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:976
#, no-wrap
msgid "B<PR_PAC_APDAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:979
msgid "data authentication key A"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:979
#, no-wrap
msgid "B<PR_PAC_APDBKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:982
msgid "data authentication key B"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:982
#, no-wrap
msgid "B<PR_PAC_APGAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:985
msgid "generic authentication \\(lqA\\(rq key."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:987
msgid "(Yes folks, there really is no generic B key.)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1002
msgid ""
"As a special case, if I<arg2> is zero, then all the keys are reset.  Since "
"new keys could be added in future, this is the recommended way to completely "
"wipe the existing keys when establishing a clean execution context.  Note "
"that there is no need to use B<PR_PAC_RESET_KEYS> in preparation for calling "
"B<execve>(2), since B<execve>(2)  resets all the pointer authentication keys."
msgstr ""

#.  Enforcement added in
#.  commit 3e91ec89f527b9870fe42dcbdb74fd389d123a95
#. type: Plain text
#: build/C/man2/prctl.2:1006 build/C/man2/prctl.2:1564
msgid "The remaining arguments I<arg3>, I<arg4>, and I<arg5> must all be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1014
msgid ""
"If the arguments are invalid, and in particular if I<arg2> contains set bits "
"that are unrecognized or that correspond to a key not available on this "
"platform, then the call fails with error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1023
msgid ""
"B<Warning:> Because the compiler or run-time environment may be using some "
"or all of the keys, a successful B<PR_PAC_RESET_KEYS> may crash the calling "
"process.  The conditions for using it safely are complex and system-"
"dependent.  Don't use it unless you know what you are doing."
msgstr ""

#. commit b693d0b372afb39432e1c49ad7b3454855bc6bed
#.  prctl PR_SET_PDEATHSIG
#. type: Plain text
#: build/C/man2/prctl.2:1031
#, fuzzy
#| msgid ""
#| "For more information, see the kernel source file I<Documentation/prctl/"
#| "no_new_privs.txt>."
msgid ""
"For more information, see the kernel source file I<Documentation/arm64/"
"pointer-authentication.rst> (or I<Documentation/arm64/pointer-authentication."
"txt> before Linux 5.3)."
msgstr ""
"詳しい情報は、カーネルソースファイル I<Documentation/prctl/no_new_privs.txt> "
"を参照。"

#. type: TP
#: build/C/man2/prctl.2:1031
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr "B<PR_SET_PDEATHSIG> (Linux 2.1.57 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1040
#, fuzzy
#| msgid ""
#| "Set the parent process death signal of the calling process to I<arg2> "
#| "(either a signal value in the range 1..maxsig, or 0 to clear).  This is "
#| "the signal that the calling process will get when its parent dies.  This "
#| "value is cleared for the child of a B<fork>(2)  and (since Linux 2.4.36 / "
#| "2.6.23)  when executing a set-user-ID or set-group-ID binary.  This value "
#| "is preserved across B<execve>(2)."
msgid ""
"Set the parent-death signal of the calling process to I<arg2> (either a "
"signal value in the range 1..B<NSIG>-1B<,> or 0 to clear).  This is the "
"signal that the calling process will get when its parent dies."
msgstr ""
"親プロセス死亡シグナル (parent process death signal) を I<arg2> に設定する "
"(設定できるシグナル値の範囲は 1..maxsig であり、0 は通知の解除である)。 呼び"
"出し元プロセスの親プロセスが死んだ際に、ここで設定した値が シグナルとして通知"
"される。この値は B<fork>(2) の子プロセスでは解除される。 (Linux 2.4.36 以降お"
"よび 2.6.23 以降では) set-user-ID もしくは set-group-ID されたバイナリを実行"
"した場合にも、このフラグは解除される。この値は B<execve>(2) の前後で保持され"
"る。"

#.  https://bugzilla.kernel.org/show_bug.cgi?id=43300
#. type: Plain text
#: build/C/man2/prctl.2:1050
msgid ""
"I<Warning>: the \"parent\" in this case is considered to be the I<thread> "
"that created this process.  In other words, the signal will be sent when "
"that thread terminates (via, for example, B<pthread_exit>(3)), rather than "
"after all of the threads in the parent process terminate."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1060
msgid ""
"The parent-death signal is sent upon subsequent termination of the parent "
"thread and also upon termination of each subreaper process (see the "
"description of B<PR_SET_CHILD_SUBREAPER> above) to which the caller is "
"subsequently reparented.  If the parent thread and all ancestor subreapers "
"have already terminated by the time of the B<PR_SET_PDEATHSIG> operation, "
"then no parent-death signal is sent to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1071
msgid ""
"The parent-death signal is process-directed (see B<signal>(7))  and, if the "
"child installs a handler using the B<sigaction>(2)  B<SA_SIGINFO> flag, the "
"I<si_pid> field of the I<siginfo_t> argument of the handler contains the PID "
"of the terminating parent process."
msgstr ""

#.  commit d2d56c5f51028cb9f3d800882eb6f4cbd3f9099f
#.  FIXME capability changes can also trigger this; see
#.  kernel/cred.c::commit_creds in the Linux 5.6 source.
#.  prctl PR_GET_PDEATHSIG
#. type: Plain text
#: build/C/man2/prctl.2:1089
msgid ""
"The parent-death signal setting is cleared for the child of a B<fork>(2).  "
"It is also (since Linux 2.4.36 / 2.6.23)  cleared when executing a set-user-"
"ID or set-group-ID binary, or a binary that has associated capabilities (see "
"B<capabilities>(7)); otherwise, this value is preserved across "
"B<execve>(2).  The parent-death signal setting is also cleared upon changes "
"to any of the following thread credentials: effective user ID, effective "
"group ID, filesystem user ID, or filesystem group ID."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1089
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr "B<PR_GET_PDEATHSIG> (Linux 2.3.15 以降)"

#.  prctl PR_SET_PTRACER
#. type: Plain text
#: build/C/man2/prctl.2:1095
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""
"親プロセス死亡シグナルの現在の値を I<(int\\ *) arg2> が指す場所に格納して返"
"す。"

#. type: TP
#: build/C/man2/prctl.2:1095
#, no-wrap
msgid "B<PR_SET_PTRACER> (since Linux 3.4)"
msgstr "B<PR_SET_PTRACER> (Linux 3.4 以降)"

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#.  commit bf06189e4d14641c0148bea16e9dd24943862215
#. type: Plain text
#: build/C/man2/prctl.2:1120
msgid ""
"This is meaningful only when the Yama LSM is enabled and in mode 1 "
"(\"restricted ptrace\", visible via I</proc/sys/kernel/yama/ptrace_scope>).  "
"When a \"ptracer process ID\" is passed in I<arg2>, the caller is declaring "
"that the ptracer process can B<ptrace>(2)  the calling process as if it were "
"a direct process ancestor.  Each B<PR_SET_PTRACER> operation replaces the "
"previous \"ptracer process ID\".  Employing B<PR_SET_PTRACER> with I<arg2> "
"set to 0 clears the caller's \"ptracer process ID\".  If I<arg2> is "
"B<PR_SET_PTRACER_ANY>, the ptrace restrictions introduced by Yama are "
"effectively disabled for the calling process."
msgstr ""
"この設定は Yama LSM が有効になっていてモード 1 (\"restricted ptrace\") の場合"
"のみに意味を持つ (モードは I</proc/sys/kernel/yama/ptrace_scope> で参照可"
"能)。 \"ptrace プロセス ID\" が I<arg2> で渡された場合、 呼び出し元は "
"ptracer プロセスがそのプロセスが直接のプロセスの先祖であるかのよう呼び出した"
"プロセスを B<ptrace> できる、 と宣言しているということだ。 B<PR_SET_PTRACER> "
"操作を行う毎に、 直前の \"ptracer プロセス ID\" は置きかえられる。 I<arg2> "
"で B<PR_SET_PTRACER> を 0 に設定すると、 呼び出し元の \"ptracer プロセス ID"
"\" がクリアされる。 I<arg2> が B<PR_SET_PTRACER> の場合、 Yama が導入した "
"ptrace の制限は呼び出し元プロセスに対しては無効になる。"

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#.  prctl PR_SET_SECCOMP
#. type: Plain text
#: build/C/man2/prctl.2:1128
#, fuzzy
#| msgid ""
#| "For further information, see the kernel source file I<Documentation/"
#| "security/Yama.txt>."
msgid ""
"For further information, see the kernel source file I<Documentation/admin-"
"guide/LSM/Yama.rst> (or I<Documentation/security/Yama.txt> before Linux "
"4.13)."
msgstr ""
"詳しい情報は、カーネルソースファイル I<Documentation/security/Yama.txt> を参"
"照。"

#. type: TP
#: build/C/man2/prctl.2:1128
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_SET_SECCOMP> (Linux 2.6.23 以降)"

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: build/C/man2/prctl.2:1139
msgid ""
"Set the secure computing (seccomp) mode for the calling thread, to limit the "
"available system calls.  The more recent B<seccomp>(2)  system call provides "
"a superset of the functionality of B<PR_SET_SECCOMP>."
msgstr ""
"呼び出したスレッドのセキュアコンピューティング (seccomp) モードを設定する。 "
"最近の B<seccomp>(2) システムコールは B<PR_SET_SECCOMP> の上位互換の機能を提"
"供する。"

#. type: Plain text
#: build/C/man2/prctl.2:1144
msgid ""
"The seccomp mode is selected via I<arg2>.  (The seccomp constants are "
"defined in I<E<lt>linux/seccomp.hE<gt>>.)"
msgstr ""
"seccomp モードは I<arg2> で指定できる (seccomp 定数は I<E<lt>linux/seccomp."
"hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man2/prctl.2:1167
#, fuzzy
#| msgid ""
#| "With I<arg2> set to B<SECCOMP_MODE_STRICT>, the only system calls that "
#| "the thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2), "
#| "and B<sigreturn>(2).  Other system calls result in the delivery of a "
#| "B<SIGKILL> signal.  Strict secure computing mode is useful for number-"
#| "crunching applications that may need to execute untrusted byte code, "
#| "perhaps obtained by reading from a pipe or socket.  This operation is "
#| "available only if the kernel is configured with B<CONFIG_SECCOMP> enabled."
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_STRICT>, the only system calls that the "
"thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2)  (but "
"not B<exit_group>(2)), and B<sigreturn>(2).  Other system calls result in "
"the delivery of a B<SIGKILL> signal.  Strict secure computing mode is useful "
"for number-crunching applications that may need to execute untrusted byte "
"code, perhaps obtained by reading from a pipe or socket.  This operation is "
"available only if the kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr ""
"I<arg2> を B<SECCOMP_MODE_STRICT> に設定すると、 そのスレッドが呼び出しを許可"
"されるシステムコールは B<read>(2), B<write>(2), B<_exit>(2), B<sigreturn>(2) "
"だけになる。 それ以外のシステムコールを呼び出すと、シグナル B<SIGKILL> が配送"
"される。 パイプやソケットから読み込んだ、 信頼できないバイトコードを実行する"
"必要がある大量の演算を行うアプリケーションにおいて、 strict secure computing "
"モードは役立つ。 この操作は利用できるのは、 カーネルが B<CONFIG_SECCOMP> を有"
"効にして作成されている場合だけである。"

#. type: Plain text
#: build/C/man2/prctl.2:1182
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_FILTER> (since Linux 3.5), the system "
"calls allowed are defined by a pointer to a Berkeley Packet Filter passed in "
"I<arg3>.  This argument is a pointer to I<struct sock_fprog>; it can be "
"designed to filter arbitrary system calls and system call arguments.  This "
"mode is available only if the kernel is configured with "
"B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""
"I<arg2> を B<SECCOMP_MODE_FILTER> (Linux 3.5 以降) に設定すると、 許可される"
"システムコールは I<arg3> で渡された Berkeley Packet Filter へのポインターで定"
"義される。 この引数は I<struct sock_fprog> へのポインターである。 これは任"
"意のシステムコールやシステムコール引数をフィルタリングするために設計され"
"た。 このモードはカーネルで B<CONFIG_SECCOMP_FILTER> が有効になっている場合に"
"のみ利用可能である。"

#. type: Plain text
#: build/C/man2/prctl.2:1197
msgid ""
"If B<SECCOMP_MODE_FILTER> filters permit B<fork>(2), then the seccomp mode "
"is inherited by children created by B<fork>(2); if B<execve>(2)  is "
"permitted, then the seccomp mode is preserved across B<execve>(2).  If the "
"filters permit B<prctl>()  calls, then additional filters can be added; they "
"are run in order until the first non-allow result is seen."
msgstr ""
"B<SECCOMP_MODE_FILTER> フィルターで B<fork>(2) が許可されている場合、 "
"seccomp モードは B<fork>(2) で作成された子プロセスに継承される。 "
"B<execve>(2) が許可されている場合、 seccomp モードは B<execve>(2) の前後で維"
"持される。 フィルターで B<prctl>() コールが許可されている場合、 追加でフィル"
"ターが定義され、 これらのフィルターは許可されないものが見つかるまで指定された"
"順序で実行される。"

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#.  prctl PR_GET_SECCOMP
#. type: Plain text
#: build/C/man2/prctl.2:1205
#, fuzzy
#| msgid ""
#| "For further information, see the kernel source file I<Documentation/prctl/"
#| "seccomp_filter.txt>."
msgid ""
"For further information, see the kernel source file I<Documentation/"
"userspace-api/seccomp_filter.rst> (or I<Documentation/prctl/seccomp_filter."
"txt> before Linux 4.13)."
msgstr ""
"詳しい情報は、カーネルソースファイル I<Documentation/prctl/seccomp_filter."
"txt> を参照。"

#. type: TP
#: build/C/man2/prctl.2:1205
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_GET_SECCOMP> (Linux 2.6.23 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1223
msgid ""
"Return (as the function result)  the secure computing mode of the calling "
"thread.  If the caller is not in secure computing mode, this operation "
"returns 0; if the caller is in strict secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"If the caller is in filter mode, and this system call is allowed by the "
"seccomp filters, it returns 2; otherwise, the process is killed with a "
"B<SIGKILL> signal.  This operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP> enabled."
msgstr ""
"呼び出したスレッドの secure computing モードを (関数の結果として) 返す。 呼び"
"出したスレッドが secure computing モードでなかった場合、 この操作は 0 を返"
"し、 呼び出したスレッドが strict secure computing モードの場合、 B<prctl>()  "
"を呼び出すとシグナル B<SIGKILL> がそのプロセスに送信される。 呼び出したスレッ"
"ドがフィルタモードで、 このシステムコールが seccomp フィルタにより許可されて"
"いる場合、 2 を返し、 そうでない場合プロセスは B<SIGKILL> シグナルで kill さ"
"れづ。 この操作が利用できるのは、カーネルが B<CONFIG_SECCOMP> を有効にして作"
"成されている場合だけである。"

#.  prctl PR_SET_SECUREBITS
#. type: Plain text
#: build/C/man2/prctl.2:1232
msgid ""
"Since Linux 3.8, the I<Seccomp> field of the I</proc/[pid]/status> file "
"provides a method of obtaining the same information, without the risk that "
"the process is killed; see B<proc>(5)."
msgstr ""
"Linux 3.8 以降では、 I</proc/[pid]/status> の I<seccomp> フィールドからも同じ"
"情報を取得できる。 この方法の場合はプロセスが kill される危険はない。 "
"B<proc>(5) を参照。"

#. type: TP
#: build/C/man2/prctl.2:1232
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_SET_SECUREBITS> (Linux 2.6.26 以降)"

#.  prctl PR_GET_SECUREBITS
#. type: Plain text
#: build/C/man2/prctl.2:1239
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""
"呼び出したスレッドの \"securebits\" フラグを I<arg2> で渡された値に設定す"
"る。 B<capabilities>(7)  参照。"

#. type: TP
#: build/C/man2/prctl.2:1239
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_GET_SECUREBITS> (Linux 2.6.26 以降)"

#.  prctl PR_GET_SPECULATION_CTRL
#. type: Plain text
#: build/C/man2/prctl.2:1246
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""
"呼び出したスレッドの \"securebits\" フラグを (関数の結果として) 返す。 "
"B<capabilities>(7)  参照。"

#. type: TP
#: build/C/man2/prctl.2:1246
#, no-wrap
msgid "B<PR_GET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr "B<PR_GET_SPECULATION_CTRL> (Linux 4.17 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1255
msgid ""
"Return (as the function result)  the state of the speculation misfeature "
"specified in I<arg2>.  Currently, the only permitted value for this argument "
"is B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error "
"B<ENODEV>)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1257
msgid "The return value uses bits 0-3 with the following meaning:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1258
#, no-wrap
msgid "B<PR_SPEC_PRCTL>"
msgstr "B<PR_SPEC_PRCTL>"

#. type: Plain text
#: build/C/man2/prctl.2:1262
msgid "Mitigation can be controlled per thread by B<PR_SET_SPECULATION_CTRL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1262 build/C/man2/prctl.2:1331
#, no-wrap
msgid "B<PR_SPEC_ENABLE>"
msgstr "B<PR_SPEC_ENABLE>"

#. type: Plain text
#: build/C/man2/prctl.2:1265 build/C/man2/prctl.2:1334
msgid "The speculation feature is enabled, mitigation is disabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1265 build/C/man2/prctl.2:1334
#, no-wrap
msgid "B<PR_SPEC_DISABLE>"
msgstr "B<PR_SPEC_DISABLE>"

#. type: Plain text
#: build/C/man2/prctl.2:1268 build/C/man2/prctl.2:1337
msgid "The speculation feature is disabled, mitigation is enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1268 build/C/man2/prctl.2:1337
#, no-wrap
msgid "B<PR_SPEC_FORCE_DISABLE>"
msgstr "B<PR_SPEC_FORCE_DISABLE>"

#. type: Plain text
#: build/C/man2/prctl.2:1273
msgid "Same as B<PR_SPEC_DISABLE> but cannot be undone."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1273 build/C/man2/prctl.2:1351
#, no-wrap
msgid "B<PR_SPEC_DISABLE_NOEXEC> (since Linux 5.1)"
msgstr "B<PR_SPEC_DISABLE_NOEXEC> (Linux 5.1 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1279
msgid ""
"Same as B<PR_SPEC_DISABLE>, but the state will be cleared on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1283
msgid ""
"If all bits are 0, then the CPU is not affected by the speculation "
"misfeature."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1290
msgid ""
"If B<PR_SPEC_PRCTL> is set, then per-thread control of the mitigation is "
"available.  If not set, B<prctl>()  for the speculation misfeature will fail."
msgstr ""

#.  prctl PR_SET_SPECULATION_CTRL
#. type: Plain text
#: build/C/man2/prctl.2:1299
#, fuzzy
#| msgid ""
#| "If the capability specified in I<arg2> is not valid, then the call fails "
#| "with the error B<EINVAL>."
msgid ""
"The I<arg3>, I<arg4>, and I<arg5> arguments must be specified as 0; "
"otherwise the call fails with the error B<EINVAL>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#. type: TP
#: build/C/man2/prctl.2:1299
#, no-wrap
msgid "B<PR_SET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr "B<PR_SET_SPECULATION_CTRL> (Linux 4.17 以降)"

#.  commit b617cfc858161140d69cc0b5cc211996b557a1c7
#.  commit 356e4bfff2c5489e016fdb925adbf12a1e3950ee
#. type: Plain text
#: build/C/man2/prctl.2:1306
msgid ""
"Sets the state of the speculation misfeature specified in I<arg2>.  The "
"speculation-misfeature settings are per-thread attributes."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1310
msgid "Currently, I<arg2> must be one of:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1311
#, no-wrap
msgid "B<PR_SPEC_STORE_BYPASS>"
msgstr "B<PR_SPEC_STORE_BYPASS>"

#.  commit 9137bb27e60e554dab694eafa4cca241fa3a694f
#. type: Plain text
#: build/C/man2/prctl.2:1315
msgid "Set the state of the speculative store bypass misfeature."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1315
#, no-wrap
msgid "B<PR_SPEC_INDIRECT_BRANCH> (since Linux 4.20)"
msgstr "B<PR_SPEC_INDIRECT_BRANCH> (Linux 4.20 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1318
msgid "Set the state of the indirect branch speculation misfeature."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1325
#, fuzzy
#| msgid ""
#| "If the capability specified in I<arg2> is not valid, then the call fails "
#| "with the error B<EINVAL>."
msgid ""
"If I<arg2> does not have one of the above values, then the call fails with "
"the error B<ENODEV>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/prctl.2:1330
msgid ""
"The I<arg3> argument is used to hand in the control value, which is one of "
"the following:"
msgstr ""

#.  commit 71368af9027f18fe5d1c6f372cfdff7e4bde8b48
#. type: Plain text
#: build/C/man2/prctl.2:1351
msgid ""
"Same as B<PR_SPEC_DISABLE>, but cannot be undone.  A subsequent "
"B<prctl>(I<arg2>, B<PR_SPEC_ENABLE>)  with the same value for I<arg2> will "
"fail with the error B<EPERM>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1361
msgid ""
"Same as B<PR_SPEC_DISABLE>, but the state will be cleared on B<execve>(2).  "
"Currently only supported for I<arg2> equal to B<PR_SPEC_STORE_BYPASS.>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1367
#, fuzzy
#| msgid ""
#| "If the capability specified in I<arg2> is not valid, then the call fails "
#| "with the error B<EINVAL>."
msgid ""
"Any unsupported value in I<arg3> will result in the call failing with the "
"error B<ERANGE>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/prctl.2:1374
#, fuzzy
#| msgid ""
#| "If the capability specified in I<arg2> is not valid, then the call fails "
#| "with the error B<EINVAL>."
msgid ""
"The I<arg4> and I<arg5> arguments must be specified as 0; otherwise the call "
"fails with the error B<EINVAL>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#.  prctl PR_SVE_SET_VL
#.  commit 2d2123bc7c7f843aa9db87720de159a049839862
#.  linux-5.6/Documentation/arm64/sve.rst
#. type: Plain text
#: build/C/man2/prctl.2:1387
msgid ""
"The speculation feature can also be controlled by the "
"B<spec_store_bypass_disable> boot parameter.  This parameter may enforce a "
"read-only policy which will result in the B<prctl>()  call failing with the "
"error B<ENXIO>.  For further details, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1387
#, no-wrap
msgid "B<PR_SVE_SET_VL> (since Linux 4.15, only on arm64)"
msgstr "B<PR_SVE_SET_VL> (Linux 4.15 以降, arm64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:1395
msgid ""
"Configure the thread's SVE vector length, as specified by I<(int) arg2>.  "
"Arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1411
msgid ""
"The bits of I<arg2> corresponding to B<PR_SVE_VL_LEN_MASK> must be set to "
"the desired vector length in bytes.  This is interpreted as an upper bound: "
"the kernel will select the greatest available vector length that does not "
"exceed the value specified.  In particular, specifying B<SVE_VL_MAX> "
"(defined in I<E<lt>asm/sigcontext.hE<gt>)> for the B<PR_SVE_VL_LEN_MASK> "
"bits requests the maximum supported vector length."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1415
msgid ""
"In addition, the other bits of I<arg2> must be set to one of the following "
"combinations of flags:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1416 build/C/man2/prctl.2:1547
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1424
msgid ""
"Perform the change immediately.  At the next B<execve>(2)  in the thread, "
"the vector length will be reset to the value configured in I</proc/sys/abi/"
"sve_default_vector_length>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1424
#, no-wrap
msgid "B<PR_SVE_VL_INHERIT>"
msgstr "B<PR_SVE_VL_INHERIT>"

#. type: Plain text
#: build/C/man2/prctl.2:1430
msgid ""
"Perform the change immediately.  Subsequent B<execve>(2)  calls will "
"preserve the new vector length."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1430
#, no-wrap
msgid "B<PR_SVE_SET_VL_ONEXEC>"
msgstr "B<PR_SVE_SET_VL_ONEXEC>"

#. type: Plain text
#: build/C/man2/prctl.2:1439
msgid ""
"Defer the change, so that it is performed at the next B<execve>(2)  in the "
"thread.  Further B<execve>(2)  calls will reset the vector length to the "
"value configured in I</proc/sys/abi/sve_default_vector_length>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1439
#, no-wrap
msgid "B<PR_SVE_SET_VL_ONEXEC | PR_SVE_VL_INHERIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1447
msgid ""
"Defer the change, so that it is performed at the next B<execve>(2)  in the "
"thread.  Further B<execve>(2)  calls will preserve the new vector length."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1451
msgid "In all cases, any previously pending deferred change is canceled."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1463
msgid ""
"The call fails with error B<EINVAL> if SVE is not supported on the platform, "
"if I<arg2> is unrecognized or invalid, or the value in the bits of I<arg2> "
"corresponding to B<PR_SVE_VL_LEN_MASK> is outside the range B<SVE_VL_MIN>.."
"B<SVE_VL_MAX> or is not a multiple of 16."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1483
msgid ""
"On success, a nonnegative value is returned that describes the I<selected> "
"configuration.  If B<PR_SVE_SET_VL_ONEXEC> was included in I<arg2>, then the "
"configuration described by the return value will take effect at the next "
"B<execve>().  Otherwise, the configuration is already in effect when the "
"B<PR_SVE_SET_VL> call returns.  In either case, the value is encoded in the "
"same way as the return value of B<PR_SVE_GET_VL>.  Note that there is no "
"explicit flag in the return value corresponding to B<PR_SVE_SET_VL_ONEXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1489
msgid ""
"The configuration (including any pending deferred change)  is inherited "
"across B<fork>(2)  and B<clone>(2)."
msgstr ""

#. commit b693d0b372afb39432e1c49ad7b3454855bc6bed
#.  prctl PR_SET_TAGGED_ADDR_CTRL
#.  commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
#. type: Plain text
#: build/C/man2/prctl.2:1496 build/C/man2/prctl.2:1538
#, fuzzy
#| msgid ""
#| "For more information, see the kernel source file I<Documentation/prctl/"
#| "no_new_privs.txt>."
msgid ""
"For more information, see the kernel source file I<Documentation/arm64/sve."
"rst> (or I<Documentation/arm64/sve.txt> before Linux 5.3)."
msgstr ""
"詳しい情報は、カーネルソースファイル I<Documentation/prctl/no_new_privs.txt> "
"を参照。"

#.  prctl PR_SVE_GET_VL
#. type: Plain text
#: build/C/man2/prctl.2:1505
msgid ""
"B<Warning:> Because the compiler or run-time environment may be using SVE, "
"using this call without the B<PR_SVE_SET_VL_ONEXEC> flag may crash the "
"calling process.  The conditions for using it safely are complex and system-"
"dependent.  Don't use it unless you really know what you are doing."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1505
#, no-wrap
msgid "B<PR_SVE_GET_VL> (since Linux 4.15, only on arm64)"
msgstr "B<PR_SVE_GET_VL> (Linux 4.15 以降, arm64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:1508
msgid "Get the thread's current SVE vector length configuration."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1512
msgid "Arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1526
msgid ""
"Provided that the kernel and platform support SVE, this operation always "
"succeeds, returning a nonnegative value that describes the I<current> "
"configuration.  The bits corresponding to B<PR_SVE_VL_LEN_MASK> contain the "
"currently configured vector length in bytes.  The bit corresponding to "
"B<PR_SVE_VL_INHERIT> indicates whether the vector length will be inherited "
"across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1529
msgid ""
"Note that there is no way to determine whether there is a pending vector "
"length change that has not yet taken effect."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1538
#, no-wrap
msgid "B<PR_SET_TAGGED_ADDR_CTRL> (since Linux 5.4, only on arm64)"
msgstr "B<PR_SET_TAGGED_ADDR_CTRL> (Linux 5.4 以降, arm64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:1542
msgid ""
"Controls support for passing tagged user-space addresses to the kernel (i."
"e., addresses where bits 56\\(em63 are not all zero)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1546
msgid ""
"The level of support is selected by I<arg2>, which can be one of the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1552
msgid ""
"Addresses that are passed for the purpose of being dereferenced by the "
"kernel must be untagged."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1552
#, no-wrap
msgid "B<PR_TAGGED_ADDR_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1557
msgid ""
"Addresses that are passed for the purpose of being dereferenced by the "
"kernel may be tagged, with the exceptions summarized below."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1577
msgid ""
"On success, the mode specified in I<arg2> is set for the calling thread and "
"the return value is 0.  If the arguments are invalid, the mode specified in "
"I<arg2> is unrecognized, or if this feature is unsupported by the kernel or "
"disabled via I</proc/sys/abi/tagged_addr_disabled>, the call fails with the "
"error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1584
msgid ""
"In particular, if B<prctl>(B<PR_SET_TAGGED_ADDR_CTRL>, 0, 0, 0, 0)  fails "
"with B<EINVAL>, then all addresses passed to the kernel must be untagged."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1588
msgid ""
"Irrespective of which mode is set, addresses passed to certain interfaces "
"must always be untagged:"
msgstr ""

#. type: IP
#: build/C/man2/prctl.2:1589 build/C/man2/prctl.2:1602
#: build/C/man2/timerfd_create.2:532 build/C/man2/timerfd_create.2:541
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1598
msgid ""
"B<brk>(2), B<mmap>(2), B<shmat>(2), B<shmdt>(2), and the I<new_address> "
"argument of B<mremap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1602
msgid ""
"(Prior to Linux 5.6 these accepted tagged addresses, but the behaviour may "
"not be what you expect.  Don't rely on it.)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1614
msgid ""
"\\(oqpolymorphic\\(cq interfaces that accept pointers to arbitrary types "
"cast to a I<void *> or other generic type, specifically B<prctl>(), "
"B<ioctl>(2), and in general B<setsockopt>(2)  (only certain specific "
"B<setsockopt>(2)  options allow tagged addresses)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1623
msgid ""
"This list of exclusions may shrink when moving from one kernel version to a "
"later kernel version.  While the kernel may make some guarantees for "
"backwards compatibility reasons, for the purposes of new software the effect "
"of passing tagged addresses to these interfaces is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1632
msgid ""
"The mode set by this call is inherited across B<fork>(2)  and B<clone>(2).  "
"The mode is reset by B<execve>(2)  to 0 (i.e., tagged addresses not "
"permitted in the user/kernel ABI)."
msgstr ""

#.  prctl PR_TASK_PERF_EVENTS_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1635 build/C/man2/prctl.2:1680
#, fuzzy
msgid ""
"For more information, see the kernel source file I<Documentation/arm64/"
"tagged-address-abi.rst>."
msgstr "詳しい情報は、カーネルソースファイル I<Documentation/arm64/tagged-address-abi.rst> を参照。"

#.  prctl PR_GET_TAGGED_ADDR_CTRL
#.  commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
#. type: Plain text
#: build/C/man2/prctl.2:1645
msgid ""
"B<Warning:> This call is primarily intended for use by the run-time "
"environment.  A successful B<PR_SET_TAGGED_ADDR_CTRL> call elsewhere may "
"crash the calling process.  The conditions for using it safely are complex "
"and system-dependent.  Don't use it unless you know what you are doing."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1645
#, fuzzy, no-wrap
#| msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgid "B<PR_GET_TAGGED_ADDR_CTRL> (since Linux 5.4, only on arm64)"
msgstr "B<PR_GET_FPEMU> (Linux 2.4.18 以降, 2.5.9, ia64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:1649
#, fuzzy
#| msgid ""
#| "Return (as the function result)  the current timer slack value of the "
#| "calling thread."
msgid "Returns the current tagged address mode for the calling thread."
msgstr ""
"呼び出し元スレッドの現在のタイマーのスラック値を (関数の結果として) 返す。"

#. type: Plain text
#: build/C/man2/prctl.2:1653
msgid "Arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> must all be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1668
msgid ""
"If the arguments are invalid or this feature is disabled or unsupported by "
"the kernel, the call fails with B<EINVAL>.  In particular, if "
"B<prctl>(B<PR_GET_TAGGED_ADDR_CTRL>, 0, 0, 0, 0)  fails with B<EINVAL>, then "
"this feature is definitely either unsupported, or disabled via I</proc/sys/"
"abi/tagged_addr_disabled>.  In this case, all addresses passed to the kernel "
"must be untagged."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1675
msgid ""
"Otherwise, the call returns a nonnegative value describing the current "
"tagged address mode, encoded in the same way as the I<arg2> argument of "
"B<PR_SET_TAGGED_ADDR_CTRL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1680
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_DISABLE> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1689
msgid ""
"Disable all performance counters attached to the calling process, regardless "
"of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the Linux "
"kernel source file I<tools/perf/design.txt>."
msgstr ""
"呼び出したプロセスに接続されたすべての性能カウンターを無効にする。 カウンター"
"がこのプロセスにより作成されたか他のプロセスにより作成されたかは関係ない。 呼"
"び出したプロセスが他のプロセス用に作成した性能カウンターは影響を受けない。 性"
"能カウンターの詳細については Linux カーネルソースの I<tools/perf/design.txt> "
"を参照。"

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  prctl PR_TASK_PERF_EVENTS_ENABLE
#. type: Plain text
#: build/C/man2/prctl.2:1697
#, fuzzy
#| msgid ""
#| "Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (with same "
#| "numerical value)  in Linux 2.6.32."
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (retaining the "
"same numerical value)  in Linux 2.6.32."
msgstr ""
"以前は B<PR_TASK_PERF_COUNTERS_DISABLE> と呼ばれていた。 Linux 2.6.32 で名前"
"が変更された (数値は同じままである)。"

#. type: TP
#: build/C/man2/prctl.2:1697
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_ENABLE> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:1702
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr ""
"B<PR_TASK_PERF_EVENTS_DISABLE> の逆。 呼び出したプロセスに接続された性能カウ"
"ンターを有効にする。"

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#.  prctl PR_SET_THP_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1711
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr ""
"以前は B<PR_TASK_PERF_COUNTERS_ENABLE> と呼ばれていた。 Linux 2.6.32 で名前が"
"変更された。"

#. type: TP
#: build/C/man2/prctl.2:1711
#, no-wrap
msgid "B<PR_SET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_SET_THP_DISABLE> (Linux 3.15 以降)"

#.  commit a0715cc22601e8830ace98366c0c2bd8da52af52
#.  prctl PR_GET_THP_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1728
msgid ""
"Set the state of the \"THP disable\" flag for the calling thread.  If "
"I<arg2> has a nonzero value, the flag is set, otherwise it is cleared.  "
"Setting this flag provides a method for disabling transparent huge pages for "
"jobs where the code cannot be modified, and using a malloc hook with "
"B<madvise>(2)  is not an option (i.e., statically allocated data).  The "
"setting of the \"THP disable\" flag is inherited by a child created via "
"B<fork>(2)  and is preserved across B<execve>(2)."
msgstr ""
"呼び出したスレッドの \"THP disable\" (THP 無効) フラグの状態を設定する。 "
"I<arg2> が 0 以外の場合、フラグは有効になり、そうでない場合はクリーンされ"
"る。 このフラグを設定する方法により、 コードを変更できなかったり "
"B<madvise>(2) の malloc hook をが有効ではないジョブ (この方法は静的に割り当て"
"られたデータには有効ではない)に対して、 transparent huge pages を無効にする手"
"段が提供される。 \"THP disable\" フラグの設定は B<fork>(2) で作成された子プロ"
"セスに継承され、 B<execve> の前後で維持される。"

#. type: TP
#: build/C/man2/prctl.2:1728
#, no-wrap
msgid "B<PR_GET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_GET_THP_DISABLE> (Linux 3.15 以降)"

#.  prctl PR_GET_TID_ADDRESS
#. type: Plain text
#: build/C/man2/prctl.2:1734
#, fuzzy
#| msgid ""
#| "Return (via the function result) the current setting of the \"THP disable"
#| "\" flag for the calling thread: either 1, if the flag is set, or 0, if it "
#| "is not."
msgid ""
"Return (as the function result) the current setting of the \"THP disable\" "
"flag for the calling thread: either 1, if the flag is set, or 0, if it is "
"not."
msgstr ""
"呼び出し元スレッドの \"THP disable\" フラグの現在の設定を (関数の結果として) "
"返す。フラグがセットされている場合は 1 が、セットされていない場合は 0 が返"
"る。"

#. type: TP
#: build/C/man2/prctl.2:1734
#, no-wrap
msgid "B<PR_GET_TID_ADDRESS> (since Linux 3.5)"
msgstr "B<PR_GET_TID_ADDRESS> (Linux 3.5 以降)"

#.  commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
#.  prctl PR_SET_TIMERSLACK
#. type: Plain text
#: build/C/man2/prctl.2:1756
#, fuzzy
#| msgid ""
#| "Retrieve the I<clear_child_tid> address set by B<set_tid_address>(2)  and "
#| "the B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to "
#| "by I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is "
#| "built with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgid ""
"Return the I<clear_child_tid> address set by B<set_tid_address>(2)  and the "
"B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to by "
"I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled.  Note that since the "
"B<prctl>()  system call does not have a compat implementation for the AMD64 "
"x32 and MIPS n32 ABIs, and the kernel writes out a pointer using the "
"kernel's pointer size, this operation expects a user-space buffer of 8 (not "
"4) bytes on these ABIs."
msgstr ""
"B<set_tid_address>(2) や B<clone>(2) B<CLONE_CHILD_CLEARTID> フラグで設定され"
"た I<clear_child_tid> を取得し、 I<(int\\ **)\\ arg2> が指す場所に格納して返"
"す。 この機能はカーネルが B<CONFIG_CHECKPOINT_RESTORE> オプションを有効にして"
"作成されている場合にのみ利用できる。"

#. type: TP
#: build/C/man2/prctl.2:1756
#, no-wrap
msgid "B<PR_SET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_SET_TIMERSLACK> (Linux 2.6.28 以降)"

#.  See https://lwn.net/Articles/369549/
#.  commit 6976675d94042fbd446231d1bd8b7de71a980ada
#. type: Plain text
#: build/C/man2/prctl.2:1774
msgid ""
"Each thread has two associated timer slack values: a \"default\" value, and "
"a \"current\" value.  This operation sets the \"current\" timer slack value "
"for the calling thread.  I<arg2> is an unsigned long value, then maximum "
"\"current\" value is ULONG_MAX and the minimum \"current\" value is 1.  If "
"the nanosecond value supplied in I<arg2> is greater than zero, then the "
"\"current\" value is set to this value.  If I<arg2> is equal to zero, the "
"\"current\" timer slack is reset to the thread's \"default\" timer slack "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1781
#, fuzzy
#| msgid ""
#| "Set the current timer slack for the calling thread to the nanosecond "
#| "value supplied in I<arg2>.  If I<arg2> is less than or equal to zero, "
#| "reset the current timer slack to the thread's default timer slack value.  "
#| "The timer slack is used by the kernel to group timer expirations for the "
#| "calling thread that are close to one another; as a consequence, timer "
#| "expirations for the thread may be up to the specified number of "
#| "nanoseconds late (but will never expire early).  Grouping timer "
#| "expirations can help reduce system power consumption by minimizing CPU "
#| "wake-ups."
msgid ""
"The \"current\" timer slack is used by the kernel to group timer expirations "
"for the calling thread that are close to one another; as a consequence, "
"timer expirations for the thread may be up to the specified number of "
"nanoseconds late (but will never expire early).  Grouping timer expirations "
"can help reduce system power consumption by minimizing CPU wake-ups."
msgstr ""
"呼び出し元スレッドの現在の timer slack を I<arg2> で指定されたナノ秒に設定す"
"る。 I<arg2> が 0 以下の場合、 現在の timer slack をそのスレッドのデフォルト"
"の timer slack 値にリセットする。 カーネルは timer slack を使って、 呼び出し"
"元スレッドのタイマー満了のうち、どのくらい近いものグルーピングする (一纏めに"
"する) かを決める。 その結果、 そのスレッドのタイマーの満了は最大で指定された"
"ナノ秒分だけ遅れる場合がある。 タイマー満了をグルーピングすることで、 CPU を"
"起こす回数が最小化されシステムの消費電力を減らすことができる。"

#.  List obtained by grepping for futex usage in glibc source
#. type: Plain text
#: build/C/man2/prctl.2:1801
msgid ""
"The timer expirations affected by timer slack are those set by B<select>(2), "
"B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), "
"B<clock_nanosleep>(2), B<nanosleep>(2), and B<futex>(2)  (and thus the "
"library functions implemented via futexes, including "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), and "
"B<sem_timedwait>(3))."
msgstr ""
"timer slack の影響を受けるのは、 システムコール B<select>(2), B<pselect>(2), "
"B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), "
"B<clock_nanosleep>(2), B<nanosleep>(2), B<futex>(2) により設定されたタイマー"
"満了である \n"
"(また、 futex を使って実装されているライブラリ関数 "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), "
"B<sem_timedwait>(3) も影響を受ける)。"

#. type: Plain text
#: build/C/man2/prctl.2:1805
msgid ""
"Timer slack is not applied to threads that are scheduled under a real-time "
"scheduling policy (see B<sched_setscheduler>(2))."
msgstr ""
"timer slack はリアルタイムスケジューリングポリシーでスケジューリングされるス"
"レッドには提供されない (B<sched_setscheduler>(2) 参照)。"

#. type: Plain text
#: build/C/man2/prctl.2:1820
#, fuzzy
#| msgid ""
#| "Each thread has two associated timer slack values: a \"default\" value, "
#| "and a \"current\" value.  The current value is the one that governs "
#| "grouping of timer expirations.  When a new thread is created, the two "
#| "timer slack values are made the same as the current value of the creating "
#| "thread.  Thereafter, a thread can adjust its current timer slack value "
#| "via B<PR_SET_TIMERSLACK> (the default value can't be changed).  The timer "
#| "slack values of I<init> (PID 1), the ancestor of all processes, are "
#| "50,000 nanoseconds (50 microseconds).  The timer slack values are "
#| "preserved across B<execve>(2)."
msgid ""
"When a new thread is created, the two timer slack values are made the same "
"as the \"current\" value of the creating thread.  Thereafter, a thread can "
"adjust its \"current\" timer slack value via B<PR_SET_TIMERSLACK>.  The "
"\"default\" value can't be changed.  The timer slack values of I<init> (PID "
"1), the ancestor of all processes, are 50,000 nanoseconds (50 "
"microseconds).  The timer slack value is inherited by a child created via "
"B<fork>(2), and is preserved across B<execve>(2)."
msgstr ""
"各スレッドには timer slack に関連する値が 2 つある。 「デフォルト値」と「現在"
"値」である。 現在値はタイマー満了のグルーピングを制御する。 新しいスレッドが"
"作成される際、 2 つの timer slack 値はそのスレッドを作成したスレッドの現在値"
"と同じに設定される。 その後、 スレッドは B<PR_SET_TIMERSLACK> で現在の timer "
"slack 値を調整できる (デフォルト値は変更できない)。 すべてのプロセスの先祖と"
"なる I<init> (PID 1) の timer slack 値は 50,000 ナノ秒 (50 ミリ秒) である。 "
"timer slack 値は B<execve>(2) の前後で保持される。"

#.  prctl PR_GET_TIMERSLACK
#. type: Plain text
#: build/C/man2/prctl.2:1827
msgid ""
"Since Linux 4.6, the \"current\" timer slack value of any process can be "
"examined and changed via the file I</proc/[pid]/timerslack_ns>.  See "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1827
#, no-wrap
msgid "B<PR_GET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_GET_TIMERSLACK> (Linux 2.6.28 以降)"

#.  prctl PR_SET_TIMING
#. type: Plain text
#: build/C/man2/prctl.2:1832
#, fuzzy
#| msgid ""
#| "Return (as the function result)  the current timer slack value of the "
#| "calling thread."
msgid ""
"Return (as the function result)  the \"current\" timer slack value of the "
"calling thread."
msgstr ""
"呼び出し元スレッドの現在のタイマーのスラック値を (関数の結果として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:1832
#, fuzzy, no-wrap
#| msgid "B<PR_SET_TIMING> (since Linux 2.6.0-test4)"
msgid "B<PR_SET_TIMING> (since Linux 2.6.0)"
msgstr "B<PR_SET_TIMING> (Linux 2.6.0-test4 以降)"

#.  Precisely: Linux 2.6.0-test4
#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#.  prctl PR_GET_TIMING
#. type: Plain text
#: build/C/man2/prctl.2:1851
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""
"(通常の、伝統的に使われてきた) 統計的なプロセスタイミングを使用するか、 正確"
"なタイムスタンプに基づくプロセスタイミングを使用するかを設定する。 I<arg2> に"
"指定できる値は B<PR_TIMING_STATISTICAL> か B<PR_TIMING_TIMESTAMP> である。 "
"B<PR_TIMING_TIMESTAMP> は現在のところ実装されていない (このモードに設定しよう"
"とするとエラー B<EINVAL> が起こることだろう)。"

#. type: TP
#: build/C/man2/prctl.2:1851
#, fuzzy, no-wrap
#| msgid "B<PR_GET_TIMING> (since Linux 2.6.0-test4)"
msgid "B<PR_GET_TIMING> (since Linux 2.6.0)"
msgstr "B<PR_GET_TIMING> (Linux 2.6.0-test4 以降)"

#.  Precisely: Linux 2.6.0-test4
#.  prctl PR_SET_TSC
#. type: Plain text
#: build/C/man2/prctl.2:1857
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr "現在使用中のプロセスタイミングを決める方法を (関数の結果として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:1857
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_SET_TSC> (Linux 2.6.26 以降, x86 のみ)"

#.  prctl PR_GET_TSC
#. type: Plain text
#: build/C/man2/prctl.2:1871
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""
"そのプロセスがタイムスタンプカウンターを読み出せるかを決定する フラグの状態を"
"設定する。 読み出しを許可する場合は I<arg2> に B<PR_TSC_ENABLE> を、そのプロ"
"セスがタイムスタンプカウンターを読み出そうとした際に B<SIGSEGV> を発生させる"
"場合には B<PR_TSC_SIGSEGV> を渡す。"

#. type: TP
#: build/C/man2/prctl.2:1871
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_GET_TSC> (Linux 2.6.26 以降, x86 のみ)"

#.  prctl PR_SET_UNALIGN
#. type: Plain text
#: build/C/man2/prctl.2:1878
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""
"そのプロセスがタイムスタンプカウンターを読み出せるかを決定する フラグの状態"
"を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:1878
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr "B<PR_SET_UNALIGN>"

#.  sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
#.  tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
#.  prctl PR_GET_UNALIGN
#. type: Plain text
#: build/C/man2/prctl.2:1902
#, fuzzy
#| msgid ""
#| "(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
#| "since Linux 2.6.18; Alpha, since Linux 2.6.22)  Set unaligned access "
#| "control bits to I<arg2>.  Pass B<PR_UNALIGN_NOPRINT> to silently fix up "
#| "unaligned user accesses, or B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on "
#| "unaligned user access."
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22; sh, since Linux 2.6.34; tile, "
"since Linux 3.12)  Set unaligned access control bits to I<arg2>.  Pass "
"B<PR_UNALIGN_NOPRINT> to silently fix up unaligned user accesses, or "
"B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned user access.  Alpha "
"also supports an additional flag with the value of 4 and no corresponding "
"named constant, which instructs kernel to not fix up unaligned accesses (it "
"is analogous to providing the B<UAC_NOFIX> flag in B<SSI_NVPAIRS> operation "
"of the B<setsysinfo>()  system call on Tru64)."
msgstr ""
"(ia64 では Linux 2.3.48 以降; parisc では Linux 2.6.15 以降; PowerPC では "
"Linux 2.6.18 以降; Alpha では　Linux 2.6.22 以降; これらのアーキテクチャーの"
"み)  unaligned アクセス制御ビットを I<arg2> で指定された値に設定する。 指定で"
"きる値は B<PR_UNALIGN_NOPRINT> (unaligned なユーザーアクセスを黙って 修正す"
"る) か B<PR_UNALIGN_SIGBUS> (unaligned なユーザーアクセスがあった場合 "
"B<SIGBUS> を生成する) である。"

#. type: TP
#: build/C/man2/prctl.2:1902
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr "B<PR_GET_UNALIGN>"

#. type: Plain text
#: build/C/man2/prctl.2:1909
#, fuzzy
#| msgid ""
#| "(see B<PR_SET_UNALIGN> for information on versions and architectures)  "
#| "Return unaligned access control bits, in the location pointed to by I<(int"
#| "\\ *) arg2>."
msgid ""
"(See B<PR_SET_UNALIGN> for information on versions and architectures.)  "
"Return unaligned access control bits, in the location pointed to by "
"I<(unsigned int\\ *) arg2>."
msgstr ""
"(バージョンとアーキテクチャーの情報は B<PR_SET_UNALIGN> 参照)  unaligned アク"
"セス制御ビットの値を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: Plain text
#: build/C/man2/prctl.2:1936
#, fuzzy
#| msgid ""
#| "On success, B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, "
#| "B<PR_GET_NO_NEW_PRIVS>, B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, "
#| "B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, "
#| "B<PR_MCE_KILL_GET>, and (if it returns)  B<PR_GET_SECCOMP> return the "
#| "nonnegative values described above.  All other I<option> values return 0 "
#| "on success.  On error, -1 is returned, and I<errno> is set appropriately."
msgid ""
"On success, B<PR_CAP_AMBIENT>+B<PR_CAP_AMBIENT_IS_SET>, B<PR_CAPBSET_READ>, "
"B<PR_GET_DUMPABLE>, B<PR_GET_FP_MODE>, B<PR_GET_IO_FLUSHER>, "
"B<PR_GET_KEEPCAPS>, B<PR_MCE_KILL_GET>, B<PR_GET_NO_NEW_PRIVS>, "
"B<PR_GET_SECUREBITS>, B<PR_GET_SPECULATION_CTRL>, B<PR_SVE_GET_VL>, "
"B<PR_SVE_SET_VL>, B<PR_GET_TAGGED_ADDR_CTRL>, B<PR_GET_THP_DISABLE>, "
"B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, and (if it returns)  "
"B<PR_GET_SECCOMP> return the nonnegative values described above.  All other "
"I<option> values return 0 on success.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功すると、 B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_GET_NO_NEW_PRIVS>, "
"B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, B<PR_GET_TIMING>, "
"B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET>, "
"B<PR_GET_SECCOMP> は上述の負でない値を返す (なお、B<PR_GET_SECCOMP> は返らな"
"い場合もある)。 I<option> が他の値の場合は成功時に 0 を返す。 エラーの場"
"合、-1 を返し、 I<errno> に適切な値を設定する。"

#. type: TP
#: build/C/man2/prctl.2:1937 build/C/man2/prctl.2:1953
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/prctl.2:1953
msgid ""
"I<option> is B<PR_SET_SECCOMP> and I<arg2> is B<SECCOMP_MODE_FILTER>, but "
"the process does not have the B<CAP_SYS_ADMIN> capability or has not set the "
"I<no_new_privs> attribute (see the discussion of B<PR_SET_NO_NEW_PRIVS> "
"above)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1963
msgid ""
"I<option> is B<PR_SET_MM>, and I<arg3> is B<PR_SET_MM_EXE_FILE>, the file is "
"not executable."
msgstr ""
"I<option> が B<PR_SET_MM>、かつ I<arg3> が B<PR_SET_MM_EXE_FILE> で、ファイル"
"が実行可能ではない。"

#. type: TP
#: build/C/man2/prctl.2:1963 build/C/man2/signalfd.2:306
#: build/C/man2/timerfd_create.2:465
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/prctl.2:1974
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and the file "
"descriptor passed in I<arg4> is not valid."
msgstr ""
"I<option> が B<PR_SET_MM> で、 I<arg3> が B<PR_SET_MM_EXE_FILE> で、 I<arg4> "
"で渡されたファイルディスクリプターが有効ではない。"

#. type: TP
#: build/C/man2/prctl.2:1974
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/prctl.2:1985
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and this the "
"second attempt to change the I</proc/pid/exe> symbolic link, which is "
"prohibited."
msgstr ""
"I<option> が B<PR_SET_MM> で、 I<arg3> が B<PR_SET_MM_EXE_FILE> で、 I</proc/"
"pid/exe> シンボリックリンクを変更しようとしたが、 禁止されている。"

#. type: Plain text
#: build/C/man2/prctl.2:1989
msgid "I<arg2> is an invalid address."
msgstr "I<arg2> が不正なアドレスである。"

#. type: Plain text
#: build/C/man2/prctl.2:2002
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, the "
"system was built with B<CONFIG_SECCOMP_FILTER>, and I<arg3> is an invalid "
"address."
msgstr ""
"I<option> が B<PR_SET_SECCOMP> で、 I<arg2> が B<SECCOMP_MODE_FILTER> で、 "
"カーネルが B<CONFIG_SECCOMP_FILTER> を有効にして作成されており、 I<arg3> が無"
"効なアドレスである。"

#. type: Plain text
#: build/C/man2/prctl.2:2008
#, fuzzy
#| msgid "The value of I<option> is not recognized."
msgid ""
"The value of I<option> is not recognized, or not supported on this system."
msgstr "I<option> の値が理解できない。"

#. type: Plain text
#: build/C/man2/prctl.2:2020
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr ""
"I<option> が B<PR_MCE_KILL>, B<PR_MCE_KILL_GET>, B<PR_SET_MM> のいずれかで、"
"かつ未使用の B<prctl>() 引数に 0 が指定されていなかった。"

#. type: Plain text
#: build/C/man2/prctl.2:2025
msgid "I<arg2> is not valid value for this I<option>."
msgstr "I<arg2> が指定された I<option> で有効な値ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:2034
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_GET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""
"I<option> が B<PR_SET_SECCOMP> か B<PR_GET_SECCOMP> だが、カーネルが "
"B<CONFIG_SECCOMP> を有効にして作成されていなかった。"

#. type: Plain text
#: build/C/man2/prctl.2:2044
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, and the "
"kernel was not configured with B<CONFIG_SECCOMP_FILTER>."
msgstr ""
"I<option> が B<PR_SET_SECCOMP> で、 I<arg2> が B<SECCOMP_MODE_FILTER> で、 "
"カーネルが B<CONFIG_SECCOMP> を有効にして作成されていなかった。"

#. type: Plain text
#: build/C/man2/prctl.2:2050
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr "I<option> が B<PR_SET_MM> で、以下のいずれかが真である。"

#. type: Plain text
#: build/C/man2/prctl.2:2056
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr "I<arg4> が I<arg5> で 0 以外である。"

#. type: Plain text
#: build/C/man2/prctl.2:2061
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr ""
"I<arg3> が B<TASK_SIZE> よりも大きい  (B<TASK_SIZE> はこのアーキテクチャーで"
"ユーザー空間アドレススペースの最大サイズである)。"

#. type: Plain text
#: build/C/man2/prctl.2:2071
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK>, "
"and the permissions of the corresponding memory area are not as required;"
msgstr ""
"I<arg2> が B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, B<PR_SET_MM_START_STACK> のど"
"れかで、対応するメモリー領域のアクセス許可が要件を満たしていない。"

#. type: Plain text
#: build/C/man2/prctl.2:2083
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would "
"cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr ""
"I<arg2> が B<PR_SET_MM_START_BRK> か B<PR_SET_MM_BRK> で、 I<arg3> データセグ"
"メントの末尾と同じかそれより前か、 I<arg3> に B<RLIMIT_DATA> リソースリミット"
"を超えてしまうような値が指定されている。"

#. type: Plain text
#: build/C/man2/prctl.2:2094
msgid ""
"I<option> is B<PR_SET_PTRACER> and I<arg2> is not 0, B<PR_SET_PTRACER_ANY>, "
"or the PID of an existing process."
msgstr ""
"I<option> が B<PR_SET_PTRACER> で I<arg2> が 0, B<PR_SET_PTRACER_ANY>, 既存プ"
"ロセスの PID のいずれでもない。"

#. type: Plain text
#: build/C/man2/prctl.2:2102
msgid ""
"I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgstr ""
"I<option> が B<PR_SET_PDEATHSIG> で、 I<arg2> で指定された値は無効なシグナル"
"番号である。"

#. type: Plain text
#: build/C/man2/prctl.2:2113
msgid ""
"I<option> is B<PR_SET_DUMPABLE> and I<arg2> is neither B<SUID_DUMP_DISABLE> "
"nor B<SUID_DUMP_USER>."
msgstr ""
"I<option> が B<PR_SET_DUMPABLE> で、 I<arg2> が B<SUID_DUMP_DISABLE> でも "
"B<SUID_DUMP_USER> でもない。"

#. type: Plain text
#: build/C/man2/prctl.2:2122
msgid ""
"I<option> is B<PR_SET_TIMING> and I<arg2> is not B<PR_TIMING_STATISTICAL>."
msgstr ""
"I<option> が B<PR_SET_TIMING> で、 I<arg2> が B<PR_TIMING_STATISTICAL> ではな"
"い。"

#. type: Plain text
#: build/C/man2/prctl.2:2136
msgid ""
"I<option> is B<PR_SET_NO_NEW_PRIVS> and I<arg2> is not equal to 1 or "
"I<arg3>, I<arg4>, or I<arg5> is nonzero."
msgstr ""
"I<option> が B<PR_SET_NO_NEW_PRIVS> で、 I<arg2> が 1 以外か、 I<arg3>, "
"I<arg4>, I<arg5> のどれかが 0 ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:2148
msgid ""
"I<option> is B<PR_GET_NO_NEW_PRIVS> and I<arg2>, I<arg3>, I<arg4>, or "
"I<arg5> is nonzero."
msgstr ""
"I<option> が B<PR_GET_NO_NEW_PRIVS> で、 I<arg2>, I<arg3>, I<arg4>, I<arg5> "
"のどれかが 0 ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:2159
msgid ""
"I<option> is B<PR_SET_THP_DISABLE> and I<arg3>, I<arg4>, or I<arg5> is "
"nonzero."
msgstr ""
"I<option> が B<PR_SET_THP_DISABLE> で I<arg3>, I<arg4>, I<arg5> のどれかが 0 "
"ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:2171
msgid ""
"I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or I<arg5> "
"is nonzero."
msgstr ""
"I<option> が B<PR_GET_THP_DISABLE> で I<arg2>, I<arg3>, I<arg4>, I<arg5> のい"
"ずれが 0 ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:2196
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and an unused argument (I<arg4>, I<arg5>, or, "
"in the case of B<PR_CAP_AMBIENT_CLEAR_ALL>, I<arg3>)  is nonzero; or I<arg2> "
"has an invalid value; or I<arg2> is B<PR_CAP_AMBIENT_LOWER>, "
"B<PR_CAP_AMBIENT_RAISE>, or B<PR_CAP_AMBIENT_IS_SET> and I<arg3> does not "
"specify a valid capability."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2214
msgid ""
"I<option> was B<PR_GET_SPECULATION_CTRL> or B<PR_SET_SPECULATION_CTRL> and "
"unused arguments to B<prctl>()  are not 0.  B<EINVAL> I<option> is "
"B<PR_PAC_RESET_KEYS> and the arguments are invalid or unsupported.  See the "
"description of B<PR_PAC_RESET_KEYS> above for details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2224
msgid ""
"I<option> is B<PR_SVE_SET_VL> and the arguments are invalid or unsupported, "
"or SVE is not available on this platform.  See the description of "
"B<PR_SVE_SET_VL> above for details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2230
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgid ""
"I<option> is B<PR_SVE_GET_VL> and SVE is not available on this platform."
msgstr ""
"I<option> が B<PR_SET_PDEATHSIG> で、 I<arg2> で指定された値は無効なシグナル"
"番号である。"

#. type: Plain text
#: build/C/man2/prctl.2:2239
msgid ""
"I<option> is B<PR_SET_TAGGED_ADDR_CTRL> and the arguments are invalid or "
"unsupported.  See the description of B<PR_SET_TAGGED_ADDR_CTRL> above for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2248
msgid ""
"I<option> is B<PR_GET_TAGGED_ADDR_CTRL> and the arguments are invalid or "
"unsupported.  See the description of B<PR_GET_TAGGED_ADDR_CTRL> above for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2254
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> the kernel or CPU does not support "
"the requested speculation misfeature."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2254 build/C/man2/prctl.2:2263
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man2/prctl.2:2263
msgid ""
"I<option> was B<PR_MPX_ENABLE_MANAGEMENT> or B<PR_MPX_DISABLE_MANAGEMENT> "
"and the kernel or the CPU does not support MPX management.  Check that the "
"kernel and processor have MPX support."
msgstr ""
"I<option> が B<PR_MPX_ENABLE_MANAGEMENT> か B<PR_MPX_DISABLE_MANAGEMENT> "
"で、 カーネルか CPU が MPX の管理をサポートしていない。 カーネルとプロセスが "
"MPX をサポートしているか確認すること。"

#. type: Plain text
#: build/C/man2/prctl.2:2272
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> implies that the control of the "
"selected speculation misfeature is not possible.  See "
"B<PR_GET_SPECULATION_CTRL> for the bit fields to determine which option is "
"available."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2272 build/C/man2/s390_runtime_instr.2:87
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2280
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgid ""
"I<option> is B<PR_SET_FP_MODE> and I<arg2> has an invalid or unsupported "
"value."
msgstr ""
"I<option> が B<PR_SET_PDEATHSIG> で、 I<arg2> で指定された値は無効なシグナル"
"番号である。"

#. type: Plain text
#: build/C/man2/prctl.2:2292
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""
"I<option> が B<PR_SET_SECUREBITS> で、呼び出し元がケーパビリティ "
"B<CAP_SETPCAP> を持っていない。 または、\"locked\" フラグを解除しようとし"
"た。 または、locked フラグがセットされているフラグをセットしようとした "
"(B<capabilities>(7)  参照)。"

#. type: Plain text
#: build/C/man2/prctl.2:2300
msgid ""
"I<option> is B<PR_SET_SPECULATION_CTRL> wherein the speculation was disabled "
"with B<PR_SPEC_FORCE_DISABLE> and caller tried to enable it again."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2310
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_SET_KEEPCAPS>, and the callers's "
#| "B<SECURE_KEEP_CAPS_LOCKED> flag is set (see B<capabilities>(7))."
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the caller's B<SECBIT_KEEP_CAPS_LOCKED> "
"flag is set (see B<capabilities>(7))."
msgstr ""
"I<option> が B<PR_SET_KEEPCAPS> で、呼び出し元のフラグ "
"B<SECURE_KEEP_CAPS_LOCKED> がセットされている (B<capabilities>(7)  参照)。"

#. type: Plain text
#: build/C/man2/prctl.2:2318
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""
"I<option> が B<PR_CAPBSET_DROP> で、呼び出し元がケーパビリティ "
"B<CAP_SETPCAP> を持っていない。"

#. type: Plain text
#: build/C/man2/prctl.2:2326
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr ""
"I<option> が B<PR_SET_MM> で、呼び出し元がケーパビリティ B<CAP_SYS_RESOURCE> "
"を持っていない。"

#. type: Plain text
#: build/C/man2/prctl.2:2341
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and I<arg2> is B<PR_CAP_AMBIENT_RAISE>, but "
"either the capability specified in I<arg3> is not present in the process's "
"permitted and inheritable capability sets, or the B<PR_CAP_AMBIENT_LOWER> "
"securebit has been set."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2341
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/prctl.2:2354
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> and I<arg3> is not "
"B<PR_SPEC_ENABLE>, B<PR_SPEC_DISABLE>, B<PR_SPEC_FORCE_DISABLE>, nor "
"B<PR_SPEC_DISABLE_NOEXEC>."
msgstr ""

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: build/C/man2/prctl.2:2359
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr "B<prctl>()  システムコールは Linux 2.1.57 で導入された。"

#. type: Plain text
#: build/C/man2/prctl.2:2366
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""
"このコールは Linux 特有である。 IRIX には B<prctl>()  システムコールがあるが "
"(MIPS アーキテクチャーにおいて irix_prctl として Linux 2.1.44 で同様に導入さ"
"れた)、 そのプロトタイプは"

#. type: Plain text
#: build/C/man2/prctl.2:2370
#, no-wrap
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"
msgstr "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"

#. type: Plain text
#: build/C/man2/prctl.2:2377
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr ""
"である。ユーザー当りのプロセス最大数を取得するオプション、 プロセスの使用でき"
"る最大プロッサー数を取得するオプション、 現在特定のプロセスが停止(block)させ"
"られているかどうか調べるオプション、 スタックサイズの最大値の取得や設定を行な"
"うオプションなどがある。"

#. type: Plain text
#: build/C/man2/prctl.2:2380
msgid "B<signal>(2), B<core>(5)"
msgstr "B<signal>(2), B<core>(5)"

#. type: TH
#: build/C/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr "PROFIL"

#. type: TH
#: build/C/man3/profil.3:28 build/C/man2/restart_syscall.2:33
#: build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:26
#: build/C/man7/signal.7:45 build/C/man3/sigsetops.3:31
#: build/C/man2/timer_getoverrun.2:26 build/C/man7/signal-safety.7:25
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man3/profil.3:31
msgid "profil - execution time profile"
msgstr "profil - 実行時間プロファイル (profile)"

#. type: Plain text
#: build/C/man3/profil.3:34
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/profil.3:37
#, no-wrap
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"
msgstr ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"

#. type: Plain text
#: build/C/man3/profil.3:45
msgid "B<profil>():"
msgstr "B<profil>():"

#.              commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: build/C/man3/profil.3:53
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""
"    glibc 2.21 以降:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 と 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    glibc 2.19 以前:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: build/C/man3/profil.3:76
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined: "
"I<offset> is subtracted and the result is multiplied by I<scale> and divided "
"by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""
"このルーティンはプログラムのどこの部分で時間を費やしているかを調べる 手段を提"
"供する。引数 I<buf> は I<bufsiz> バイトのメモリーを指している。仮想の 10 ミ"
"リ秒ごとに、ユーザーの プログラムカウンター (PC) が検査される: I<offset> が引"
"かれ、その結果が I<scale> 倍され 65536 で割られる。 結果が I<bufsiz> より小さ"
"い場合は I<buf> の対応するエントリーがインクリメントされる。 I<buf> が NULL "
"ならば、プロファイル (profile) は無効にされる。"

#. type: Plain text
#: build/C/man3/profil.3:78
msgid "Zero is always returned."
msgstr "常に 0 が返される。"

#. type: tbl table
#: build/C/man3/profil.3:88
#, no-wrap
msgid "B<profil>()"
msgstr "B<profil>()"

#. type: tbl table
#: build/C/man3/profil.3:88
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: build/C/man3/profil.3:93
msgid "Similar to a call in SVr4 (but not POSIX.1)."
msgstr "SVr4 のコールに似ている (しかし POSIX.1 ではない)。"

#. type: Plain text
#: build/C/man3/profil.3:99
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""
"B<profil>()  は B<ITIMER_PROF> インターバルタイマーも使用しているプログラムで"
"は使用できない (B<setitimer>(2)  参照)。"

#.  Libc 4.4 contained a kernel patch providing a system call profil.
#. type: Plain text
#: build/C/man3/profil.3:102
msgid "True kernel profiling provides more accurate results."
msgstr "本当のカーネルプロファイルはより正確な結果を与える。"

#. type: Plain text
#: build/C/man3/profil.3:108
msgid ""
"B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr ""
"B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"

#. type: TH
#: build/C/man3/psignal.3:30
#, no-wrap
msgid "PSIGNAL"
msgstr "PSIGNAL"

#. type: TH
#: build/C/man3/psignal.3:30 build/C/man3/raise.3:29 build/C/man7/sigevent.7:26
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/psignal.3:33
msgid "psignal, psiginfo - print signal description"
msgstr "psignal, psiginfo - シグナルの説明を表示する"

#. type: Plain text
#: build/C/man3/psignal.3:39
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/psignal.3:51
#, no-wrap
msgid ""
"B<psignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<psignal>():\n"
"    glibc 2.19 以降:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 以前:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man3/psignal.3:54
msgid "B<psiginfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "B<psiginfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man3/psignal.3:63
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the "
"string I<s>, a colon, a space, a string describing the signal number I<sig>, "
"and a trailing newline.  If the string I<s> is NULL or empty, the colon and "
"space are omitted.  If I<sig> is invalid, the message displayed will "
"indicate an unknown signal."
msgstr ""
"B<psignal>() 関数は、文字列 I<s>、コロン、スペース、シグナル番号 I<sig> を説"
"明する文字列、終端の改行から構成されるメッセージを I<stderr> に表示する。 文"
"字列 I<s> が NULL か空の場合、コロンとスペースは省略される。 I<sig> が不正な"
"らば、表示される メッセージは未知のシグナルを示す。"

#. type: Plain text
#: build/C/man3/psignal.3:84
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, "
"B<psiginfo>()  displays information about the origin of the signal, and "
"other information relevant to the signal (e.g., the relevant memory address "
"for hardware-generated signals, the child process ID for B<SIGCHLD>, and the "
"user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""
"B<psiginfo>() 関数は B<psignal>() と同じだが、 I<pinfo> に書かれたシグナルの"
"情報を表示する点が異なる。 I<pinfo> は有効な I<siginfo_t> 構造体を指している"
"必要がある。 B<psiginfo>() は、 シグナルの説明だけでなく、 シグナルの送信元や"
"そのシグナルに関連するその他の情報も表示する (例えば、ハードウェアが発生した"
"シグナルの関連メモリーアドレス、 B<SIGCHLD> の子プロセス ID、 I<kill>(2) や "
"B<sigqueue>(3) を使って送信されたシグナルの送信元プロセスのユーザー ID とプロ"
"セス ID など)。"

#. type: Plain text
#: build/C/man3/psignal.3:90
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr "関数 B<psignal>() と B<psiginfo>() は、値を返さない。"

#. type: Plain text
#: build/C/man3/psignal.3:94
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr "B<psiginfo>() 関数は glibc バージョン 2.10 で追加された。"

#. type: tbl table
#: build/C/man3/psignal.3:105
#, no-wrap
msgid ""
"B<psignal>(),\n"
"B<psiginfo>()"
msgstr ""
"B<psignal>(),\n"
"B<psiginfo>()"

#. type: tbl table
#: build/C/man3/psignal.3:105
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: build/C/man3/psignal.3:110
msgid "POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: build/C/man3/psignal.3:114
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr ""
"バージョン 2.12 までの glibc では B<psiginfo>() には以下のバグがあった。"

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:118
msgid "In some circumstances, a trailing newline is not printed."
msgstr "特定の状況で、末尾の改行が出力されない。"

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:122
msgid "Additional details are not displayed for real-time signals."
msgstr "リアルタイムシグナルの場合に、追加の詳細情報が表示されない。"

#. type: Plain text
#: build/C/man3/psignal.3:127
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/raise.3:29
#, no-wrap
msgid "RAISE"
msgstr "RAISE"

#. type: Plain text
#: build/C/man3/raise.3:32
msgid "raise - send a signal to the caller"
msgstr "raise - 呼び出し元にシグナルを送る"

#. type: Plain text
#: build/C/man3/raise.3:37
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr "B<int raise(int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/raise.3:43
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""
"B<raise>()  関数は、呼び出し元のプロセスもしくはスレッドにシグナルを送る。 シ"
"ングルスレッドのプログラムでは、以下と等価である。"

#. type: Plain text
#: build/C/man3/raise.3:47
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr "kill(getpid(), sig);\n"

#. type: Plain text
#: build/C/man3/raise.3:51
msgid "In a multithreaded program it is equivalent to"
msgstr "マルチスレッドのプログラムでは、以下と等価である。"

#. type: Plain text
#: build/C/man3/raise.3:55
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr "pthread_kill(pthread_self(), sig);\n"

#. type: Plain text
#: build/C/man3/raise.3:61
msgid ""
"If the signal causes a handler to be called, B<raise>()  will return only "
"after the signal handler has returned."
msgstr ""
"シグナルに起因してシグナルハンドラーが呼び出される場合には、 B<raise>()  が返"
"るのは必ずシグナルハンドラーが返った後になる。"

#. type: Plain text
#: build/C/man3/raise.3:64
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr "成功した場合は 0 を、失敗した場合は 0 以外の値を返す。"

#. type: tbl table
#: build/C/man3/raise.3:74
#, no-wrap
msgid "B<raise>()"
msgstr "B<raise>()"

#. type: Plain text
#: build/C/man3/raise.3:78 build/C/man2/signal.2:113
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: build/C/man3/raise.3:89
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""
"glibc バージョン 2.3.3 以降では、カーネルが B<tgkill>(2) システムコールをサ"
"ポートしている場合はB<raise>() は B<tgkill>(2) を使って実装されている。古い"
"バージョンの glibc では、B<raise>() は B<kill>(2) を使って実装されている。"

#. type: Plain text
#: build/C/man3/raise.3:96
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"
msgstr ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"

#. type: TH
#: build/C/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr "RESTART_SYSCALL"

#. type: Plain text
#: build/C/man2/restart_syscall.2:36
msgid ""
"restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""
"restart_syscall - 一時停止シグナルによる割り込み後にシステムコールを再開する"

#. type: Plain text
#: build/C/man2/restart_syscall.2:38
msgid "B<long restart_syscall(void);>"
msgstr "B<long restart_syscall(void);>"

#. type: Plain text
#: build/C/man2/restart_syscall.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには、glibc のラッパー関数はない。「注意」の節を参"
"照。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""
"B<restart_syscall>() システムコールは、 シグナル (B<SIGSTOP> や B<SIGTSTP> な"
"ど) によって停止されたプロセスが B<SIGCONT> シグナルを受信して再開された後"
"に、 特定のシステムコールを再開するのに使用される。 このシステムコールはカー"
"ネル内部での利用のみを想定している。"

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#.  Notable (as at Linux 3.17) is that poll() has such a "restart"
#.  function, but ppoll(), select(), and pselect() do not.
#.  This means that the latter system calls do not take account of the
#.  time spent in the stopped state when restarting.
#. type: Plain text
#: build/C/man2/restart_syscall.2:88
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since "
"Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduct the already elapsed "
"time when the process continued execution."
msgstr ""
"B<restart_syscall>() は、 再開時に時刻関連のパラメーターを調整する必要がある"
"システムコールを再開させる場合にのみ使用される。 概要するシステムコールは "
"B<poll>(2) (Linux 2.6.24 以降)、 B<nanosleep>(2) (Linux 2.6 以降)、 "
"B<clock_nanosleep>(2) (Linux 2.6 以降)、 B<FUTEX_WAIT> (Linux 2.6.22 以降) "
"や B<FUTEX_WAIT_BITSET> (Linux 2.6.31 以降) 操作を利用した場合の B<futex>(2) "
"である。 B<restart_syscall>() は、 中断されたシステムコールを、 経過した時間 "
"(プロセスがシグナルにより停止されていた時間も含む) を考慮に入れて適切に調整し"
"た時刻引数で再開する。 B<restart_syscall>() の仕組みがないと、 これらのシス"
"テムコールの再開で、 プロセスが実行を継続する際にすでに経過した時間を正しく減"
"算できない。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:92
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""
"B<restart_syscall>() の返り値は、 再開中のシステムコールの返り値となる。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:96
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""
"I<errno> は B<restart_syscall>() が再開しているシステムコールのエラーに基づい"
"て設定される。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:100
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr "B<restart_syscall>() システムコールは Linux 2.6 以降に存在する。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:102
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:106
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""
"このシステムコールには glibc のラッパー関数はない。 それはカーネルによる利用"
"だけが想定されており、 アプリケーションは決してこのシステムコールを呼び出すべ"
"きではない。"

#. type: Plain text
#: build/C/man2/restart_syscall.2:128
msgid ""
"The kernel uses B<restart_syscall>()  to ensure that when a system call is "
"restarted after a process has been stopped by a signal and then resumed by "
"B<SIGCONT>, then the time that the process spent in the stopped state is "
"counted against the timeout interval specified in the original system call.  "
"In the case of system calls that take a timeout argument and automatically "
"restart after a stop signal plus B<SIGCONT>, but which do not have the "
"B<restart_syscall>()  mechanism built in, then, after the process resumes "
"execution, the time that the process spent in the stop state is I<not> "
"counted against the timeout value.  Notable examples of system calls that "
"suffer this problem are B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"カーネルは B<restart_syscall>() を使用することで、 シグナルにより停止されたプ"
"ロセスが B<SIGCONT> により再開された後にシステムコールが再開される際に、 元の"
"システムコールに指定されたタイムアウト時間の計算に、 プロセスが停止中に経過し"
"た時間が含まれることを保証する。 タイムアウト引数を取り、停止シグナルの後"
"に B<SIGCONT> があった場合自動的に再開するシステムコールだが、 そのシステム"
"コールに B<restart_syscall>() の仕組みが組込まれていない場合には、 プロセスの"
"実行が再開された後、 停止中にプロセスが消費した時間はタイムアウト値としてカウ"
"ント「されない」。 この問題を持つ有名なシステムコールとしては B<ppoll>(2), "
"B<select>(2), B<pselect>(2) がある。"

#
#. type: Plain text
#: build/C/man2/restart_syscall.2:135
msgid ""
"From user space, the operation of B<restart_syscall>()  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""
"ユーザー空間からは B<restart_syscall>() の動作はほとんど見えない。 再開された"
"システムコールを呼び出したプロセスには、 そのシステムコールが通常通り実行され"
"返ったように見える。"

#.  FIXME . ppoll(2), select(2), and pselect(2)
#.      should probably get the restart_syscall() treatment:
#.      If a select() call is suspended by stop-sig+SIGCONT, the time
#.      spent suspended is *not* deducted when the select() is restarted.
#.  FIXME . check whether recvmmsg() handles stop-sig+SIGCONT properly.
#. type: Plain text
#: build/C/man2/restart_syscall.2:144
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr "RT_SIGQUEUEINFO"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<info>B<);>\n"
msgstr "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<info>B<);>\n"
msgstr ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:38 build/C/man2/sgetmask.2:35
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<注>: これらのシステムコールには、glibc のラッパー関数はない。「注意」の節を"
"参照。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group (i."
"e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<info> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:79 build/C/man7/sigevent.7:90
#: build/C/man2/wait.2:339
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:87
msgid ""
"This should be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>.  If the signal is being sent to any "
"process other than the caller itself, the following restrictions apply:"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:97
msgid ""
"The code can't be a value greater than or equal to zero.  In particular, it "
"can't be B<SI_USER>, which is used by the kernel to indicate a signal sent "
"by B<kill>(2), and nor can it be B<SI_KERNEL>, which is used to indicate a "
"signal generated by the kernel."
msgstr ""

#.  tkill(2) or
#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:103
msgid ""
"The code can't (since Linux 2.6.39) be B<SI_TKILL>, which is used by the "
"kernel to indicate a signal sent using B<tgkill>(2)."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:104 build/C/man2/wait.2:318
#, no-wrap
msgid "I<si_pid>"
msgstr "I<si_pid>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:108
msgid ""
"This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:108 build/C/man2/wait.2:321
#, no-wrap
msgid "I<si_uid>"
msgstr "I<si_uid>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:112
msgid ""
"This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:112 build/C/man7/sigevent.7:98
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:119
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:126
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:138
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:143
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:144 build/C/man3/sigqueue.3:92
#: build/C/man2/sigwaitinfo.2:116 build/C/man2/timer_create.2:211
#: build/C/man2/tkill.2:97 build/C/man2/tkill.2:104
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:150 build/C/man3/sigqueue.3:98
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"待ち行列に入れられるシグナルの最大数に達した (より詳しい情報は B<signal>(7)  "
"を参照すること)。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:157
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:162
#, fuzzy
#| msgid ""
#| "The process does not have permission to send the signal to the receiving "
#| "process.  For the required permissions, see B<kill>(2)."
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2)."
msgstr ""
"このプロセスには、受け取り側プロセスにシグナルを送る権限がない。 必要な権限に"
"ついては、 B<kill>(2)  を参照すること。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:168
msgid ""
"I<tgid> specifies a process other than the caller and I<info-E<gt>si_code> "
"is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:174
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:181
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:188
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version 2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:190 build/C/man2/sgetmask.2:74
#: build/C/man2/timerfd_create.2:503
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:195
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""
"これらのシステムコールはアプリケーションでの使用を目的として用意されたわけで"
"はないので、 glibc のラッパー関数は存在しない。おそらくないと思うが、このシス"
"テムコールを直接呼び出したい場合は B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:200
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:209
msgid ""
"B<kill>(2), B<pidfd_send_signal>(2), B<sigaction>(2), B<sigprocmask>(2), "
"B<tgkill>(2), B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr "B<kill>(2), B<pidfd_send_signal>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "S390_RUNTIME_INSTR"
msgstr ""

#. type: TH
#: build/C/man2/s390_runtime_instr.2:25 build/C/man3/sigwait.3:26
#: build/C/man2/timer_settime.2:26 build/C/man2/wait4.2:33
#: build/C/man3/killpg.3:42
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:28
msgid "s390_runtime_instr - enable/disable s390 CPU run-time instrumentation"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:31
#, no-wrap
msgid "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"
msgstr "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:33
#, no-wrap
msgid "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"
msgstr "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:39
msgid ""
"The B<s390_runtime_instr>()  system call starts or stops CPU run-time "
"instrumentation for the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:47
msgid ""
"The I<command> argument controls whether run-time instrumentation is started "
"(B<S390_RUNTIME_INSTR_START>, 1) or stopped (B<S390_RUNTIME_INSTR_STOP>, 2) "
"for the calling thread."
msgstr ""

#.  commit b38feccd663b55ab07116208b68e1ffc7c3c7e78
#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:58
msgid ""
"The I<signum> argument specifies the number of a real-time signal.  This "
"argument was used to specify a signal number that should be delivered to the "
"thread if the run-time instrumentation buffer was full or if the run-time-"
"instrumentation-halted interrupt had occurred.  This feature was never used, "
"and in Linux 4.4 support for this feature was removed; thus, in current "
"kernels, this argument is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:69
msgid ""
"On success, B<s390_runtime_instr>()  returns 0 and enables the thread for "
"run-time instrumentation by assigning the thread a default run-time "
"instrumentation control block.  The caller can then read and modify the "
"control block and start the run-time instrumentation.  On error, -1 is "
"returned and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:75
#, fuzzy
#| msgid "The value specified in I<how> was invalid."
msgid "The value specified in I<command> is not a valid command."
msgstr "I<how> に指定された値が有効ではない。"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:84
msgid ""
"The value specified in I<signum> is not a real-time signal number.  From "
"Linux 4.4 onwards, the I<signum> argument has no effect, so that an invalid "
"signal number will not result in an error."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:87
msgid ""
"Allocating memory for the run-time instrumentation control block failed."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:90
msgid "The run-time instrumentation facility is not available."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:92
msgid "This system call is available since Linux 3.7."
msgstr "このシステムコールは Linux 3.7 で初めて登場した。"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:96
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The run-time instrumentation facility is available beginning with System z "
"EC12."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:100
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2) を使用すること。"

#.  commit df2f815a7df7edb5335a3bdeee6a8f9f6f9c35c4
#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:106
#, fuzzy
#| msgid "This system call is available since Linux 2.6."
msgid "The I<asm/runtime_instr.h> header file is available since Linux 4.16."
msgstr "このシステムコールは Linux 2.6 以降で利用できる。"

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:115
msgid ""
"Starting with Linux 4.4, support for signalling was removed, as was the "
"check whether I<signum> is a valid real-time signal.  For backwards "
"compatibility with older kernels, it is recommended to pass a valid real-"
"time signal number in I<signum> and install a handler for that signal."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:118
msgid "B<syscall>(2), B<signal>(7)"
msgstr "B<syscall>(2), B<signal>(7)"

#. type: TH
#: build/C/man2/sgetmask.2:25
#, no-wrap
msgid "SGETMASK"
msgstr "SGETMASK"

#. type: Plain text
#: build/C/man2/sgetmask.2:28
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr "sgetmask, ssetmask - シグナルマスクの操作 (廃止予定)"

#. type: Plain text
#: build/C/man2/sgetmask.2:30
msgid "B<long sgetmask(void);>"
msgstr "B<long sgetmask(void);>"

#. type: Plain text
#: build/C/man2/sgetmask.2:32
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr "B<long ssetmask(long >I<newmask>B<);>"

#. type: Plain text
#: build/C/man2/sgetmask.2:41
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""
"これらのシステムコールは廃止予定であり、 「使用しないこと」。 代わりに "
"B<sigprocmask>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/sgetmask.2:44
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr "B<sgetmask>()  は、呼び出し元プロセスのシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:49
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""
"B<ssetmask>()  は、呼び出し元プロセスのシグナルマスクを I<newmask> で指定され"
"た値に設定し、変更前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:58
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""
"これら二つのシステムコールが扱うシグナルマスクは、 単純なビットマスクである "
"(この点が B<sigprocmask>(2)  で使用される I<sigset_t> と異なる)。 これらのマ"
"スクを作成したり検査するには B<sigmask>(3)  を使用すること。"

#. type: Plain text
#: build/C/man2/sgetmask.2:63
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""
"B<sgetmask>()  は常に成功し、シグナルマスクを返す。 B<ssetmask>()  は常に成功"
"し、直前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:65
msgid "These system calls always succeed."
msgstr "これらのシステムコールは常に成功する。"

#.  f6187769dae48234f3877df3c4d99294cc2254fa
#. type: Plain text
#: build/C/man2/sgetmask.2:72
msgid ""
"Since Linux 3.16, support for these system calls is optional, depending on "
"whether the kernel was built with the B<CONFIG_SGETMASK_SYSCALL> option."
msgstr ""
"Linux 3.16 以降では、これらのシステムコールのサポートは任意となり、利用できる"
"かはカーネルが B<CONFIG_SGETMASK_SYSCALL> オプションを有効にしてコンパイルさ"
"れているかに依存する。"

#. type: Plain text
#: build/C/man2/sgetmask.2:78
msgid ""
"Glibc does not provide wrappers for these obsolete system calls; in the "
"unlikely event that you want to call them, use B<syscall>(2)."
msgstr ""
"glibc はこれらの古いシステムコールに対するラッパー関数を提供していない。 あま"
"りないと思うが、これらを呼び出したい場合には B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/sgetmask.2:81
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., real-"
"time signals)."
msgstr ""
"これらのシステムコールは、 31 より大きいシグナル番号 (つまり、リアルタイムシ"
"グナル) を扱えない。"

#. type: Plain text
#: build/C/man2/sgetmask.2:83
msgid "These system calls do not exist on x86-64."
msgstr "これらのシステムコールは x86-64 には存在しない。"

#. type: Plain text
#: build/C/man2/sgetmask.2:88
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr "B<SIGSTOP> や B<SIGKILL> をブロックすることはできない。"

#. type: Plain text
#: build/C/man2/sgetmask.2:91
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr "B<sigprocmask>(2), B<signal>(7)"

#. type: TH
#: build/C/man2/sigaction.2:48
#, no-wrap
msgid "SIGACTION"
msgstr "SIGACTION"

#. type: Plain text
#: build/C/man2/sigaction.2:51
msgid "sigaction, rt_sigaction - examine and change a signal action"
msgstr "sigaction, rt_sigaction - シグナルの動作の確認と変更"

#. type: Plain text
#: build/C/man2/sigaction.2:57
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"

#. type: Plain text
#: build/C/man2/sigaction.2:67
msgid "B<sigaction>(): _POSIX_C_SOURCE"
msgstr "B<sigaction>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man2/sigaction.2:70
msgid "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"
msgstr "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"

#. type: Plain text
#: build/C/man2/sigaction.2:79
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""
"B<sigaction>()  システムコールは、特定のシグナルを受信した際の プロセスの動作"
"を変更するのに使用される (シグナルの概要については B<signal>(7)  を参照)。"

#. type: Plain text
#: build/C/man2/sigaction.2:85
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""
"I<signum> には、 B<SIGKILL> と B<SIGSTOP> 以外の有効なシグナルをどれでも指定"
"できる。"

#. type: Plain text
#: build/C/man2/sigaction.2:96
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in I<oldact>."
msgstr ""
"I<act> が NULL 以外であれば、シグナル I<signum> の新しい動作 (action) として "
"I<act> が設定される。 I<oldact> が NULL でなければ、今までの動作が I<oldact> "
"に格納される。"

#. type: Plain text
#: build/C/man2/sigaction.2:100
msgid "The I<sigaction> structure is defined as something like:"
msgstr "I<sigaction> 構造体は以下のような感じに定義される。"

#. type: Plain text
#: build/C/man2/sigaction.2:110
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"

#. type: Plain text
#: build/C/man2/sigaction.2:117
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""
"アーキテクチャーによっては共用体 (union) が用いられており、その場合には "
"I<sa_handler> と I<sa_sigaction> の両方を同時に割り当てることはできない。"

#. type: Plain text
#: build/C/man2/sigaction.2:126
msgid ""
"The I<sa_restorer> field is not intended for application use.  (POSIX does "
"not specify a I<sa_restorer> field.)  Some further details of the purpose of "
"this field can be found in B<sigreturn>(2)."
msgstr ""
"I<sa_restorer> はアプリケーションが使用することを意図したフィールドではない "
"(POSIX は I<sa_restorer> フィールドを規定していない)。 このフィールドの詳細な"
"目的については B<sigreturn>(2) に書かれている。"

#. type: Plain text
#: build/C/man2/sigaction.2:131
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and is be "
"one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:134
msgid "B<SIG_DFL> for the default action."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:137
msgid "B<SIG_IGN> to ignore this signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:140
msgid ""
"A pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:152
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives three arguments, as described below."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:162
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is used."
msgstr ""
"I<sa_mask> は、シグナルハンドラー実行中に禁止 (block) すべきシグナルのマスク"
"を指定する (ハンドラー実行中のシグナルの禁止は、シグナルハンドラーが起動され"
"たスレッド のシグナルのマスクに追加することで行われる)。 さらに、 "
"B<SA_NODEFER> フラグが指定されていない場合は、ハンドラーを起動するきっかけと"
"なる シグナルにも I<sa_mask> が適用される。"

#. type: Plain text
#: build/C/man2/sigaction.2:166
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""
"I<sa_flags> はシグナルハンドラーの動作を変更するためのフラグの集合を指定す"
"る。 I<sa_flags> には、以下に示すフラグの (0 個以上の) 論理和をとったものを指"
"定する。"

#. type: TP
#: build/C/man2/sigaction.2:166
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr "B<SA_NOCLDSTOP>"

#. type: Plain text
#: build/C/man2/sigaction.2:183
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is meaningful only when establishing a handler for B<SIGCHLD>."
msgstr ""
"I<signum> が B<SIGCHLD> の場合、 子プロセスが停止したり (子プロセスが "
"B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, B<SIGTTOU> を受けたとき) 再開したり (子プ"
"ロセスが B<SIGCONT> を受けたとき) したときに B<SIGCHLD> の通知を受けない。 こ"
"のフラグは、 B<SIGCHLD> に対してハンドラーを設定する際にのみ意味を持つ。"

#. type: TP
#: build/C/man2/sigaction.2:183
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr "B<SA_NOCLDWAIT> (Linux 2.6 以降)"

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: build/C/man2/sigaction.2:197
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is meaningful only when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""
"(Linux 2.6 以降)  I<signum> が B<SIGCHLD> の場合、子プロセスが終了したときに "
"子プロセスをゾンビプロセスに変化させない (B<waitpid>(2)  も参照)。 このフラグ"
"は、 B<SIGCHLD> に対してハンドラーを設定する際、もしくはそのシグナルの処理方"
"法を B<SIG_DFL> に設定する際にのみ意味を持つ。"

#. type: Plain text
#: build/C/man2/sigaction.2:209
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""
"B<SIGCHLD> に対してハンドラーを設定する際に B<SA_NOCLDWAIT> フラグをセットし"
"た場合、 子プロセスが終了した際に B<SIGCHLD> シグナルが生成されるかどうか"
"は、 POSIX.1 では規定されていない。 Linux では、この状況で B<SIGCHLD> シグナ"
"ルは生成される。 いくつかの他の実装では生成されない。"

#. type: TP
#: build/C/man2/sigaction.2:209
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr "B<SA_NODEFER>"

#. type: Plain text
#: build/C/man2/sigaction.2:217
#, fuzzy
#| msgid ""
#| "Call the signal handler on an alternate signal stack provided by "
#| "B<sigaltstack>(2).  If an alternate stack is not available, the default "
#| "stack will be used.  This flag is meaningful only when establishing a "
#| "signal handler."
msgid ""
"Do not add the signal to the thread's signal mask while the handler is "
"executing, unless the signal is specified in I<act.sa_mask>.  Consequently, "
"a further instance of the signal may be delivered to the thread while it is "
"executing the handler.  This flag is meaningful only when establishing a "
"signal handler."
msgstr ""
"B<sigaltstack>(2)  で提供される別のシグナルスタックでシグナルハンドラーを呼び"
"出す。 別のシグナルスタックが利用可能でなければ、デフォルトのスタックが 使用"
"される。 このフラグはシグナルハンドラーを設定する際にのみ意味を持つ。"

#. type: Plain text
#: build/C/man2/sigaction.2:220
msgid "B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:220
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr "B<SA_ONSTACK>"

#. type: Plain text
#: build/C/man2/sigaction.2:226
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is meaningful only when establishing a signal "
"handler."
msgstr ""
"B<sigaltstack>(2)  で提供される別のシグナルスタックでシグナルハンドラーを呼び"
"出す。 別のシグナルスタックが利用可能でなければ、デフォルトのスタックが 使用"
"される。 このフラグはシグナルハンドラーを設定する際にのみ意味を持つ。"

#. type: TP
#: build/C/man2/sigaction.2:226
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr "B<SA_RESETHAND>"

#. type: Plain text
#: build/C/man2/sigaction.2:230
#, fuzzy
#| msgid ""
#| "Restore the signal action to the default upon entry to the signal "
#| "handler.  This flag is meaningful only when establishing a signal "
#| "handler.  B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgid ""
"Restore the signal action to the default upon entry to the signal handler.  "
"This flag is meaningful only when establishing a signal handler."
msgstr ""
"シグナルハンドラーを設定する際に、シグナルの動作をデフォルトに戻す。 このフラ"
"グはシグナルハンドラーを設定する際にのみ意味を持つ。 B<SA_ONESHOT> はこのフラ"
"グと同じ意味だが、廃止されており、非標準である。"

#. type: Plain text
#: build/C/man2/sigaction.2:233
msgid "B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:233
#, no-wrap
msgid "B<SA_RESTART>"
msgstr "B<SA_RESTART>"

#. type: Plain text
#: build/C/man2/sigaction.2:241
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is meaningful only when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""
"いくつかのシステムコールをシグナルの通知の前後で再開できるようにして、 BSD シ"
"グナル方式 (semantics) と互換性のある動作を提供する。 このフラグはシグナルハ"
"ンドラーを設定する際にのみ意味を持つ。 B<signal>(7)  に書かれているシステム"
"コールの再開に関する議論を参照のこと。"

#. type: TP
#: build/C/man2/sigaction.2:241
#, no-wrap
msgid "B<SA_RESTORER>"
msgstr "B<SA_RESTORER>"

#. type: Plain text
#: build/C/man2/sigaction.2:250
msgid ""
"I<Not intended for application use>.  This flag is used by C libraries to "
"indicate that the I<sa_restorer> field contains the address of a \"signal "
"trampoline\".  See B<sigreturn>(2)  for more details."
msgstr ""
"I<アプリケーションでの使用を意図したものではない>。 このフラグは C ライブラリ"
"が I<sa_restorer> フィールドに \"signal trampoline\" のアドレスが入っているこ"
"とを示すために使用される。 詳細は B<sigreturn>(2) を参照。"

#. type: TP
#: build/C/man2/sigaction.2:250
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr "B<SA_SIGINFO> (Linux 2.2 以降)"

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: build/C/man2/sigaction.2:262
msgid ""
"The signal handler takes three arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is "
"meaningful only when establishing a signal handler."
msgstr ""
"シグナルハンドラーは一つではなく、三つの引数を持つ。この場合は "
"I<sa_handler> のかわりに I<sa_sigaction> を設定しなければならない このフラグ"
"はシグナルハンドラーを設定する際にのみ意味を持つ。"

#. type: SS
#: build/C/man2/sigaction.2:262
#, no-wrap
msgid "The siginfo_t argument to a SA_SIGINFO handler"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:271
msgid ""
"When the B<SA_SIGINFO> flag is specified in I<act.sa_flags>, the signal "
"handler address is passed via the I<act.sa_sigaction> field.  This handler "
"takes three arguments, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:279
#, no-wrap
msgid ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"
msgstr ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigaction.2:283
msgid "These three arguments are as follows"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:283
#, no-wrap
msgid "I<sig>"
msgstr "I<sig>"

#. type: Plain text
#: build/C/man2/sigaction.2:286
msgid "The number of the signal that caused invocation of the handler."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:286
#, no-wrap
msgid "I<info>"
msgstr "I<info>"

#. type: Plain text
#: build/C/man2/sigaction.2:292
msgid ""
"A pointer to a I<siginfo_t>, which is a structure containing further "
"information about the signal, as described below."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:292
#, no-wrap
msgid "I<ucontext>"
msgstr "I<ucontext>"

#. type: Plain text
#: build/C/man2/sigaction.2:308
msgid ""
"This is a pointer to a I<ucontext_t> structure, cast to I<void\\ *>.  The "
"structure pointed to by this field contains signal context information that "
"was saved on the user-space stack by the kernel; for details, see "
"B<sigreturn>(2).  Further information about the I<ucontext_t> structure can "
"be found in B<getcontext>(3)  and B<signal>(7).  Commonly, the handler "
"function doesn't make any use of the third argument."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:312
#, fuzzy
#| msgid ""
#| "The I<siginfo_t> argument to I<sa_sigaction> is a struct with the "
#| "following fields:"
msgid "The I<siginfo_t> data type is a structure with the following fields:"
msgstr ""
"I<sa_sigaction> のパラメーター I<siginfo_t> は以下のフィールドを持つ構造体で"
"ある:"

#.  FIXME
#.  The siginfo_t 'si_trapno' field seems to be used
#.  only on SPARC and Alpha; this page could use
#.  a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: build/C/man2/sigaction.2:357
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;     /* Signal number */\n"
"    int      si_errno;     /* An errno value */\n"
"    int      si_code;      /* Signal code */\n"
"    int      si_trapno;    /* Trap number that caused\n"
"                              hardware-generated signal\n"
"                              (unused on most architectures) */\n"
"    pid_t    si_pid;       /* Sending process ID */\n"
"    uid_t    si_uid;       /* Real user ID of sending process */\n"
"    int      si_status;    /* Exit value or signal */\n"
"    clock_t  si_utime;     /* User time consumed */\n"
"    clock_t  si_stime;     /* System time consumed */\n"
"    union sigval si_value; /* Signal value */\n"
"    int      si_int;       /* POSIX.1b signal */\n"
"    void    *si_ptr;       /* POSIX.1b signal */\n"
"    int      si_overrun;   /* Timer overrun count;\n"
"                              POSIX.1b timers */\n"
"    int      si_timerid;   /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;      /* Memory location which caused fault */\n"
"    long     si_band;      /* Band event (was I<int> in\n"
"                              glibc 2.3.2 and earlier) */\n"
"    int      si_fd;        /* File descriptor */\n"
"    short    si_addr_lsb;  /* Least significant bit of address\n"
"                              (since Linux 2.6.32) */\n"
"    void    *si_lower;     /* Lower bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    void    *si_upper;     /* Upper bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    int      si_pkey;      /* Protection key on PTE that caused\n"
"                              fault (since Linux 4.6) */\n"
"    void    *si_call_addr; /* Address of system call instruction\n"
"                              (since Linux 3.5) */\n"
"    int      si_syscall;   /* Number of attempted system call\n"
"                              (since Linux 3.5) */\n"
"    unsigned int si_arch;  /* Architecture of attempted system call\n"
"                              (since Linux 3.5) */\n"
"}\n"
msgstr ""
"siginfo_t {\n"
"    int      si_signo;     /* Signal number */\n"
"    int      si_errno;     /* An errno value */\n"
"    int      si_code;      /* Signal code */\n"
"    int      si_trapno;    /* Trap number that caused\n"
"                              hardware-generated signal\n"
"                              (unused on most architectures) */\n"
"    pid_t    si_pid;       /* Sending process ID */\n"
"    uid_t    si_uid;       /* Real user ID of sending process */\n"
"    int      si_status;    /* Exit value or signal */\n"
"    clock_t  si_utime;     /* User time consumed */\n"
"    clock_t  si_stime;     /* System time consumed */\n"
"    union sigval si_value; /* Signal value */\n"
"    int      si_int;       /* POSIX.1b signal */\n"
"    void    *si_ptr;       /* POSIX.1b signal */\n"
"    int      si_overrun;   /* Timer overrun count;\n"
"                              POSIX.1b timers */\n"
"    int      si_timerid;   /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;      /* Memory location which caused fault */\n"
"    long     si_band;      /* Band event (was I<int> in\n"
"                              glibc 2.3.2 and earlier) */\n"
"    int      si_fd;        /* File descriptor */\n"
"    short    si_addr_lsb;  /* Least significant bit of address\n"
"                              (since Linux 2.6.32) */\n"
"    void    *si_lower;     /* Lower bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    void    *si_upper;     /* Upper bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    int      si_pkey;      /* Protection key on PTE that caused\n"
"                              fault (since Linux 4.6) */\n"
"    void    *si_call_addr; /* Address of system call instruction\n"
"                              (since Linux 3.5) */\n"
"    int      si_syscall;   /* Number of attempted system call\n"
"                              (since Linux 3.5) */\n"
"    unsigned int si_arch;  /* Architecture of attempted system call\n"
"                              (since Linux 3.5) */\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigaction.2:366
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should read only the fields that are meaningful for the "
"given signal:"
msgstr ""
"I<si_signo>, I<si_errno>, I<si_code> は全てのシグナルに対して定義されている "
"(I<si_errno> は Linux では一般的には使用されない)。 構造体の残りの部分は、共"
"用体 (union) になっているかもしれない。 その場合は該当するシグナルにおいて意"
"味のあるフィールドのみを読み込む ことができる。"

#. type: Plain text
#: build/C/man2/sigaction.2:381
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""
"B<kill>(2) や B<sigqueue>(3) で送信されたシグナルでは I<si_pid> と I<si_uid> "
"が設定される。 さらに、 B<sigqueue>(3) で送信されたシグナルでは I<si_int> と "
"I<si_pid> にシグナルの送信者により指定された値が設定される。詳細は "
"B<sigqueue>(3) を参照。"

#. type: Plain text
#: build/C/man2/sigaction.2:397
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr ""
"POSIX.1b タイマー (Linux 2.6 以降) は I<si_overrun> と I<si_timerid> を設定す"
"る。 I<si_timerid> フィールドはカーネルがタイマーを特定するのに使用する内部 "
"ID であり、 B<timer_create>(2) が返すタイマー ID と同じではない。 "
"I<si_overrun> フィールドはタイマーが回り切った回数である。 これは "
"B<timer_getoverrun>(2) の呼び出しで取得できる情報と同じである。 これらの"
"フィールドは非標準で Linux による拡張である。"

#. type: Plain text
#: build/C/man2/sigaction.2:412
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""
"メッセージキューの通知用に送信されたシグナル (B<mq_notify>(3) の "
"B<SIGEV_SIGNAL> の説明を参照) では、 I<si_int>/I<si_ptr> に B<mq_notify>(3) "
"に渡された I<sigev_value> が設定される。 I<si_pid> にはメッセージ送信者のプロ"
"セス ID が設定され、 I<si_uid> にはメッセージ送信者の実ユーザー ID が設定され"
"る。"

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: build/C/man2/sigaction.2:459
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<times>(2)).  In kernels "
"up to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr ""
"B<SIGCHLD> は I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, I<si_stime> を"
"設定し、子プロセスに関する情報を提供する。 I<si_pid> フィールドは子プロセスの"
"プロセス ID で、 I<si_uid> フィールドは子プロセスの実ユーザー ID である。 "
"I<si_stime> フィールドには、 (I<si_code> が B<CLD_EXITED> の場合は) 子プロセ"
"スの終了ステータスが、それ以外の場合は状態が変化する原因となったシグナル番号"
"が格納される。 I<si_utime> と I<si_stime> には子プロセスが使用したユーザー "
"CPU 時間とシステム CPU 時間がそれぞれ格納される。(B<getrusage>(2) や "
"B<times>(2) と異なり) これらのフィールドには wait 待ちの子プロセスにより使用"
"された時間は含まれない。 2.6 より前と 2.6.27 以降のカーネルでは、 これらの"
"フィールドに格納される CPU 時間の単位は I<sysconf(_SC_CLK_TCK)> である。 "
"2.6.27 より前の 2.6 系のカーネルでは、バグがあり、 これらのフィールドの CPU "
"時間の単位が (カーネルのコンフィグで指定される) システムの jiffy であった "
"(B<time>(7) 参照)。"

#. type: Plain text
#: build/C/man2/sigaction.2:473
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> field."
msgstr "B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, B<SIGTRAP> では、 I<si_addr> に fault が発生したアドレスが設定される。 いくつかのアーキテクチャーでは、 これらのシグナルは I<si_trapno> フィールドにも設定される。"

#. type: Plain text
#: build/C/man2/sigaction.2:507
msgid ""
"Some suberrors of B<SIGBUS>, in particular B<BUS_MCEERR_AO> and "
"B<BUS_MCEERR_AR>, also fill in I<si_addr_lsb>.  This field indicates the "
"least significant bit of the reported address and therefore the extent of "
"the corruption.  For example, if a full page was corrupted, I<si_addr_lsb> "
"contains I<log2(sysconf(_SC_PAGESIZE))>.  When B<SIGTRAP> is delivered in "
"response to a B<ptrace>(2)  event (PTRACE_EVENT_foo), I<si_addr> is not "
"populated, but I<si_pid> and I<si_uid> are populated with the respective "
"process ID and user ID responsible for delivering the trap.  In the case of "
"B<seccomp>(2), the tracee will be shown as delivering the event.  "
"B<BUS_MCEERR_*> and I<si_addr_lsb> are Linux-specific extensions."
msgstr "B<SIGBUS> が発生するエラーのいくつか、特に B<BUS_MCEERR_AO> と B<BUS_MCEERR_AR> では、 I<si_addr_lsb> も設定される。 このフィールドは報告されるアドレスの最下位ビットを示し、 これによりメモリー破壊の程度を知ることができる。 例えば、ページ全体が壊れている場合には I<si_addr_lsb> には I<log2(sysconf(_SC_PAGESIZE))> が入る。 B<SIGTRAP> が B<ptrace>(2) イベント (PTRACE_EVENT_foo) に対応して配送される際、 I<si_addr> は設定されないが、 I<si_pid> と I<si_uid> にはトラップの配送に責任を負うプロセス ID とユーザー ID がそれぞれ格納される。 B<seccomp>(2) の場合、 トレース対象はイベントを配送した元として示される。 B<BUS_MCEERR_*> と I<si_addr_lsb> は Linux 固有の拡張である。"

#. type: Plain text
#: build/C/man2/sigaction.2:516
msgid ""
"The B<SEGV_BNDERR> suberror of B<SIGSEGV> populates I<si_lower> and "
"I<si_upper>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:523
msgid "The B<SEGV_PKUERR> suberror of B<SIGSEGV> populates I<si_pkey>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:541
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred; for further details, see the description of B<F_SETSIG> in "
"B<fcntl>(2)."
msgstr "B<SIGIO>/B<SIGPOLL> (2 つの名前は Linux では同義語) では I<si_band> と I<si_fd> が設定される。 I<si_band> イベントは、 B<poll>(2) が I<revents> フィールドに設定するのと同じ値が入ったビットマスクである。 I<si_fd> フィールドは I/O イベントが発生したファイルディスクリプターを示す。詳細については B<fcntl>(2) の B<F_SETSIG> の説明を参照のこと。"

#.  commit a0727e8ce513fe6890416da960181ceb10fbfae6
#. type: Plain text
#: build/C/man2/sigaction.2:555
msgid ""
"B<SIGSYS>, generated (since Linux 3.5)  when a seccomp filter returns "
"B<SECCOMP_RET_TRAP>, fills in I<si_call_addr>, I<si_syscall>, I<si_arch>, "
"I<si_errno>, and other fields as described in B<seccomp>(2)."
msgstr ""
"seccomp フィルターが B<SECCOMP_RET_TRAP> を返す際に (Linux 3.5 以降で) 生成さ"
"れる B<SIGSYS> シグナルでは、 I<si_call_addr>, I<si_syscall>, I<si_arch>, "
"I<si_arch> や B<seccomp>(2) で説明されている他のフィールドが設定される。"

#. type: SS
#: build/C/man2/sigaction.2:555
#, no-wrap
msgid "The si_code field"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:572
#, fuzzy
#| msgid ""
#| "I<si_code> is a value (not a bit mask) indicating why this signal was "
#| "sent.  For a B<ptrace>(2)  event, I<si_code> will contain B<SIGTRAP> and "
#| "have the ptrace event in the high byte:"
msgid ""
"The I<si_code> field inside the I<siginfo_t> argument that is passed to a "
"B<SA_SIGINFO> signal handler is a value (not a bit mask)  indicating why "
"this signal was sent.  For a B<ptrace>(2)  event, I<si_code> will contain "
"B<SIGTRAP> and have the ptrace event in the high byte:"
msgstr ""
"I<si_code> は、そのシグナルが送信された理由を示す値である (ビットマスクではな"
"い)。 B<ptrace>(2) イベントでは、 I<si_code> には B<SIGTRAP> が入り、 上位バ"
"イトには ptrace イベントが入る。"

#. type: Plain text
#: build/C/man2/sigaction.2:576
#, no-wrap
msgid "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"

#. type: Plain text
#: build/C/man2/sigaction.2:590
msgid ""
"For a non-B<ptrace>(2)  event, the values that can appear in I<si_code> are "
"described in the remainder of this section.  Since glibc 2.20, the "
"definitions of most of these symbols are obtained from I<E<lt>signal.hE<gt>> "
"by defining feature test macros (before including I<any> header file) as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:593
msgid "B<_XOPEN_SOURCE> with the value 500 or greater;"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:598
msgid "B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>; or"
msgstr "B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>; or"

#. type: Plain text
#: build/C/man2/sigaction.2:601
msgid "B<_POSIX_C_SOURCE> with the value 200809L or greater."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:606
msgid ""
"For the B<TRAP_*> constants, the symbol definitions are provided only in the "
"first two cases.  Before glibc 2.20, no feature test macros were required to "
"obtain these symbols."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:611
msgid ""
"For a regular signal, the following list shows the values which can be "
"placed in I<si_code> for any signal, along with the reason that the signal "
"was generated."
msgstr ""
"通常のシグナルの場合には、 以下のリストに示す値がどのシグナルの場合でも "
"I<si_code> に入りうる。シグナルが生成された理由も記載している。"

#. type: TP
#: build/C/man2/sigaction.2:612
#, no-wrap
msgid "B<SI_USER>"
msgstr "B<SI_USER>"

#. type: Plain text
#: build/C/man2/sigaction.2:615
msgid "B<kill>(2)."
msgstr "B<kill>(2)"

#. type: TP
#: build/C/man2/sigaction.2:615
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr "B<SI_KERNEL>"

#. type: Plain text
#: build/C/man2/sigaction.2:618
msgid "Sent by the kernel."
msgstr "カーネルにより送信された"

#. type: TP
#: build/C/man2/sigaction.2:618
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr "B<SI_QUEUE>"

#. type: Plain text
#: build/C/man2/sigaction.2:621
msgid "B<sigqueue>(3)."
msgstr "B<sigqueue>(3)"

#. type: TP
#: build/C/man2/sigaction.2:621
#, no-wrap
msgid "B<SI_TIMER>"
msgstr "B<SI_TIMER>"

#. type: Plain text
#: build/C/man2/sigaction.2:624
msgid "POSIX timer expired."
msgstr "POSIX タイマーが満了した"

#. type: TP
#: build/C/man2/sigaction.2:624
#, no-wrap
msgid "B<SI_MESGQ> (since Linux 2.6.6)"
msgstr "B<SI_MESGQ> (Linux 2.6.6 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:628
msgid "POSIX message queue state changed; see B<mq_notify>(3)."
msgstr "POSIX メッセージキューの状態が変化した; B<mq_notify>(3) 参照"

#. type: TP
#: build/C/man2/sigaction.2:628
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr "B<SI_ASYNCIO>"

#. type: Plain text
#: build/C/man2/sigaction.2:631
msgid "AIO completed."
msgstr "非同期 IO (AIO) が完了した"

#. type: TP
#: build/C/man2/sigaction.2:631
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr "B<SI_SIGIO>"

#. type: Plain text
#: build/C/man2/sigaction.2:640
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr ""
"B<SIGIO> がキューイングされた (Linux 2.2 以下のカーネルのみ; Linux 2.4 以降で"
"は以下で説明する B<SIGIO>/B<SIGPOLL> の I<si_code> が入る)"

#. type: TP
#: build/C/man2/sigaction.2:640
#, no-wrap
msgid "B<SI_TKILL> (since Linux 2.4.19)"
msgstr "B<SI_TKILL> (Linux 2.4.19 以降)"

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: build/C/man2/sigaction.2:648
msgid "B<tkill>(2)  or B<tgkill>(2)."
msgstr "B<tkill>(2) または B<tgkill>(2)"

#. type: Plain text
#: build/C/man2/sigaction.2:655
msgid ""
"The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr "B<SIGILL> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:656
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr "B<ILL_ILLOPC>"

#. type: Plain text
#: build/C/man2/sigaction.2:659
msgid "Illegal opcode."
msgstr "不正な命令コード"

#. type: TP
#: build/C/man2/sigaction.2:659
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr "B<ILL_ILLOPN>"

#. type: Plain text
#: build/C/man2/sigaction.2:662
msgid "Illegal operand."
msgstr "不正なオペランド"

#. type: TP
#: build/C/man2/sigaction.2:662
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr "B<ILL_ILLADR>"

#. type: Plain text
#: build/C/man2/sigaction.2:665
msgid "Illegal addressing mode."
msgstr "不正なアドレッシングモード"

#. type: TP
#: build/C/man2/sigaction.2:665
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr "B<ILL_ILLTRP>"

#. type: Plain text
#: build/C/man2/sigaction.2:668
msgid "Illegal trap."
msgstr "不正なトラップ"

#. type: TP
#: build/C/man2/sigaction.2:668
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr "B<ILL_PRVOPC>"

#. type: Plain text
#: build/C/man2/sigaction.2:671
msgid "Privileged opcode."
msgstr "特権が必要な命令コード"

#. type: TP
#: build/C/man2/sigaction.2:671
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr "B<ILL_PRVREG>"

#. type: Plain text
#: build/C/man2/sigaction.2:674
msgid "Privileged register."
msgstr "特権が必要なレジスター"

#. type: TP
#: build/C/man2/sigaction.2:674
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr "B<ILL_COPROC>"

#. type: Plain text
#: build/C/man2/sigaction.2:677
msgid "Coprocessor error."
msgstr "コプロセッサのエラー"

#. type: TP
#: build/C/man2/sigaction.2:677
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr "B<ILL_BADSTK>"

#. type: Plain text
#: build/C/man2/sigaction.2:680
msgid "Internal stack error."
msgstr "内部スタックエラー"

#. type: Plain text
#: build/C/man2/sigaction.2:687
msgid ""
"The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr "B<SIGFPE> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:688
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr "B<FPE_INTDIV>"

#. type: Plain text
#: build/C/man2/sigaction.2:691
msgid "Integer divide by zero."
msgstr "整数の 0 による除算"

#. type: TP
#: build/C/man2/sigaction.2:691
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr "B<FPE_INTOVF>"

#. type: Plain text
#: build/C/man2/sigaction.2:694
msgid "Integer overflow."
msgstr "整数のオーバーフロー"

#. type: TP
#: build/C/man2/sigaction.2:694
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr "B<FPE_FLTDIV>"

#. type: Plain text
#: build/C/man2/sigaction.2:697
msgid "Floating-point divide by zero."
msgstr "浮動小数点の 0 による除算"

#. type: TP
#: build/C/man2/sigaction.2:697
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr "B<FPE_FLTOVF>"

#. type: Plain text
#: build/C/man2/sigaction.2:700
msgid "Floating-point overflow."
msgstr "浮動小数点のオーバーフロー"

#. type: TP
#: build/C/man2/sigaction.2:700
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr "B<FPE_FLTUND>"

#. type: Plain text
#: build/C/man2/sigaction.2:703
msgid "Floating-point underflow."
msgstr "浮動小数点のアンダーフロー"

#. type: TP
#: build/C/man2/sigaction.2:703
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr "B<FPE_FLTRES>"

#. type: Plain text
#: build/C/man2/sigaction.2:706
msgid "Floating-point inexact result."
msgstr "浮動小数点の不正確な演算結果 (inexact result)"

#. type: TP
#: build/C/man2/sigaction.2:706
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr "B<FPE_FLTINV>"

#. type: Plain text
#: build/C/man2/sigaction.2:709
msgid "Floating-point invalid operation."
msgstr "浮動小数点の不正な操作"

#. type: TP
#: build/C/man2/sigaction.2:709
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr "B<FPE_FLTSUB>"

#. type: Plain text
#: build/C/man2/sigaction.2:712
msgid "Subscript out of range."
msgstr "範囲外の添字 (subscript)"

#. type: Plain text
#: build/C/man2/sigaction.2:719
msgid ""
"The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr "B<SIGSEGV> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:720
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr "B<SEGV_MAPERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:723
msgid "Address not mapped to object."
msgstr "オブジェクトにマッピングされていないアドレス"

#. type: TP
#: build/C/man2/sigaction.2:723
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr "B<SEGV_ACCERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:726
msgid "Invalid permissions for mapped object."
msgstr "マッピングされたオブジェクトに対するアクセス許可がない"

#. type: TP
#: build/C/man2/sigaction.2:726
#, no-wrap
msgid "B<SEGV_BNDERR> (since Linux 3.19)"
msgstr "B<SEGV_BNDERR> (Linux 3.19 以降)"

#.  commit ee1b58d36aa1b5a79eaba11f5c3633c88231da83
#. type: Plain text
#: build/C/man2/sigaction.2:730
msgid "Failed address bound checks."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:730
#, no-wrap
msgid "B<SEGV_PKUERR> (since Linux 4.6)"
msgstr "B<SEGV_PKUERR> (Linux 4.6 以降)"

#.  commit cd0ea35ff5511cde299a61c21a95889b4a71464e
#. type: Plain text
#: build/C/man2/sigaction.2:738
msgid ""
"Access was denied by memory protection keys.  See B<pkeys>(7).  The "
"protection key which applied to this access is available via I<si_pkey>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:745
msgid ""
"The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr "B<SIGBUS> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:746
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr "B<BUS_ADRALN>"

#. type: Plain text
#: build/C/man2/sigaction.2:749
msgid "Invalid address alignment."
msgstr "不正なアドレスアライメント (alignment)"

#. type: TP
#: build/C/man2/sigaction.2:749
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr "B<BUS_ADRERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:752
msgid "Nonexistent physical address."
msgstr "存在しない物理アドレス"

#. type: TP
#: build/C/man2/sigaction.2:752
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr "B<BUS_OBJERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:755
msgid "Object-specific hardware error."
msgstr "オブジェクト固有のハードウェアエラー"

#. type: TP
#: build/C/man2/sigaction.2:755
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AR> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:758
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""
"マシンチェックで使用中のハードウェアメモリーのエラーが検出された。対応が必"
"須。"

#. type: TP
#: build/C/man2/sigaction.2:758
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AO> (Linux 2.6.32  以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:761
msgid ""
"Hardware memory error detected in process but not consumed; action optional."
msgstr ""
"実行中にハードウェアメモリーエラーが検出されたが、使用中のメモリーではない。"
"対応は必須ではない。"

#. type: Plain text
#: build/C/man2/sigaction.2:768
msgid ""
"The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr "B<SIGTRAP> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:769
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr "B<TRAP_BRKPT>"

#. type: Plain text
#: build/C/man2/sigaction.2:772
msgid "Process breakpoint."
msgstr "プロセスのブレークポイント"

#. type: TP
#: build/C/man2/sigaction.2:772
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr "B<TRAP_TRACE>"

#. type: Plain text
#: build/C/man2/sigaction.2:775
msgid "Process trace trap."
msgstr "プロセスのトレーストラップ"

#. type: TP
#: build/C/man2/sigaction.2:775
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4, IA64 only)"
msgstr "B<TRAP_BRANCH> (Linux 2.4 以降, IA64 のみ)"

#. type: Plain text
#: build/C/man2/sigaction.2:778
msgid "Process taken branch trap."
msgstr "プロセスのブランチトラップ"

#. type: TP
#: build/C/man2/sigaction.2:778
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4, IA64 only)"
msgstr "B<TRAP_HWBKPT> (Linux 2.4 以降, IA64 のみ)"

#. type: Plain text
#: build/C/man2/sigaction.2:781
msgid "Hardware breakpoint/watchpoint."
msgstr "ハードウェアのブレークポイント/ウォッチポイント"

#. type: Plain text
#: build/C/man2/sigaction.2:788
msgid ""
"The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr "B<SIGCHLD> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:789
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr "B<CLD_EXITED>"

#. type: Plain text
#: build/C/man2/sigaction.2:792
msgid "Child has exited."
msgstr "子プロセスが終了した (exited)"

#. type: TP
#: build/C/man2/sigaction.2:792
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr "B<CLD_KILLED>"

#. type: Plain text
#: build/C/man2/sigaction.2:795
msgid "Child was killed."
msgstr "子プロセスが kill された"

#. type: TP
#: build/C/man2/sigaction.2:795
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr "B<CLD_DUMPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:798
msgid "Child terminated abnormally."
msgstr "子プロセスが異常終了した"

#. type: TP
#: build/C/man2/sigaction.2:798
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr "B<CLD_TRAPPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:801
msgid "Traced child has trapped."
msgstr "トレース対象の子プロセスがトラップを上げた"

#. type: TP
#: build/C/man2/sigaction.2:801
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr "B<CLD_STOPPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:804
msgid "Child has stopped."
msgstr "子プロセスが停止 (stop) した"

#. type: TP
#: build/C/man2/sigaction.2:804
#, no-wrap
msgid "B<CLD_CONTINUED> (since Linux 2.6.9)"
msgstr "B<CLD_CONTINUED> (Linux 2.6.9 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:807
msgid "Stopped child has continued."
msgstr "停止していた子プロセスが再開した"

#. type: Plain text
#: build/C/man2/sigaction.2:814
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr ""
"B<SIGIO>/B<SIGPOLL> シグナルの場合、 I<si_code> には以下の値が入る可能性があ"
"る:"

#. type: TP
#: build/C/man2/sigaction.2:815
#, no-wrap
msgid "B<POLL_IN>"
msgstr "B<POLL_IN>"

#. type: Plain text
#: build/C/man2/sigaction.2:818
msgid "Data input available."
msgstr "入力データが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:818
#, no-wrap
msgid "B<POLL_OUT>"
msgstr "B<POLL_OUT>"

#. type: Plain text
#: build/C/man2/sigaction.2:821
msgid "Output buffers available."
msgstr "出力バッファーが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:821
#, no-wrap
msgid "B<POLL_MSG>"
msgstr "B<POLL_MSG>"

#. type: Plain text
#: build/C/man2/sigaction.2:824
msgid "Input message available."
msgstr "入力メッセージが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:824
#, no-wrap
msgid "B<POLL_ERR>"
msgstr "B<POLL_ERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:827
msgid "I/O error."
msgstr "I/O エラー"

#. type: TP
#: build/C/man2/sigaction.2:827
#, no-wrap
msgid "B<POLL_PRI>"
msgstr "B<POLL_PRI>"

#. type: Plain text
#: build/C/man2/sigaction.2:830
msgid "High priority input available."
msgstr "高優先の入力が利用可能"

#. type: TP
#: build/C/man2/sigaction.2:830
#, no-wrap
msgid "B<POLL_HUP>"
msgstr "B<POLL_HUP>"

#. type: Plain text
#: build/C/man2/sigaction.2:833
msgid "Device disconnected."
msgstr "デバイスが接続されていない"

#. type: Plain text
#: build/C/man2/sigaction.2:840
msgid "The following value can be placed in I<si_code> for a B<SIGSYS> signal:"
msgstr "B<SIGSYS> シグナルの場合、 I<si_code> には以下の値が入る可能性がある:"

#. type: TP
#: build/C/man2/sigaction.2:841
#, no-wrap
msgid "B<SYS_SECCOMP> (since Linux 3.5)"
msgstr "B<SYS_SECCOMP> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:846
msgid "Triggered by a B<seccomp>(2)  filter rule."
msgstr "B<seccomp>(2) のフィルタールールによる配送された"

#. type: Plain text
#: build/C/man2/sigaction.2:852
msgid ""
"B<sigaction>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"B<sigaction>() 関数は成功すると 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man2/sigaction.2:857
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""
"I<act> か I<oldact> が指しているメモリーが正しいプロセスのアドレス空間にな"
"い。"

#. type: Plain text
#: build/C/man2/sigaction.2:864
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""
"無効なシグナルが指定された。補足 (catch) したり無視したりできない シグナルで"
"ある B<SIGKILL> や B<SIGSTOP> に対する動作を変更しようとした場合にも発生す"
"る。"

#.  SVr4 does not document the EINTR condition.
#. type: Plain text
#: build/C/man2/sigaction.2:867
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: build/C/man2/sigaction.2:875 build/C/man7/signal.7:105
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""
"B<fork>(2) 経由で作成された子プロセスは、親プロセスのシグナルの処理方法の コ"
"ピーを継承する。 B<execve>(2) の前後で、ハンドラーが設定されているシグナルの"
"処理方法はデフォルトにリセットされ、 無視が設定されているシグナルの処理方法は"
"変更されずそのままとなる。"

#. type: Plain text
#: build/C/man2/sigaction.2:893 build/C/man2/signal.2:135
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""
"POSIX では、 B<kill>(2)  や B<raise>(3)  で生成できないシグナル B<SIGFPE>, "
"B<SIGILL>, B<SIGSEGV> を無視 (ignore) した場合、その後の動作は未定義である。 "
"ゼロによる整数割り算の結果は未定義となる。 アーキテクチャーによっては、このと"
"き B<SIGFPE> シグナルが生成される。 (同様に負の最大整数を -1 で割ると "
"B<SIGFPE> が生成されるかもしれない)  このシグナルを無視すると無限ループに陥る"
"かもしれない。"

#. type: Plain text
#: build/C/man2/sigaction.2:910
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 and later allow this possibility, so that ignoring B<SIGCHLD> "
"can be used to prevent the creation of zombies (see B<wait>(2)).  "
"Nevertheless, the historical BSD and System\\ V behaviors for ignoring "
"B<SIGCHLD> differ, so that the only completely portable method of ensuring "
"that terminated children do not become zombies is to catch the B<SIGCHLD> "
"signal and perform a B<wait>(2)  or similar."
msgstr "POSIX.1-1990 では B<SIGCHLD> に B<SIG_IGN> を設定することを認めていない。 POSIX.1-2001 とそれ以降では認められており、 B<SIGCHLD> を無視することでゾンビプロセスの生成を防止することができる (B<wait>(2)  を参照)。 さらに、BSD と System\\ V では B<SIGCHLD> を無視した際の動作が異なっている。 そのため、完全に移植性がある方法で、終了した子プロセスがゾンビにならないこと を保証するには、 B<SIGCHLD> シグナルを補足し、 B<wait>(2)  などを実行するしかない。"

#. type: Plain text
#: build/C/man2/sigaction.2:926
msgid ""
"POSIX.1-1990 specified only B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, "
"B<SA_RESETHAND>, B<SA_RESTART>, and B<SA_SIGINFO>.  Use of these latter "
"values in I<sa_flags> may be less portable in applications intended for "
"older UNIX implementations."
msgstr "POSIX.1-1990 の仕様では B<SA_NOCLDSTOP> のみが定義されている。 POSIX.1-2001 では B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, B<SA_RESETHAND>, B<SA_RESTART>, B<SA_SIGINFO> が追加された。 UNIX の古い実装で動かすアプリケーションで、 他の I<sa_flags> フラグを使用すると移植性が下がる。"

#. type: Plain text
#: build/C/man2/sigaction.2:930
msgid ""
"The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr "B<SA_RESETHAND> フラグは SVr4 の同じ名前のフラグと互換性がある。"

#. type: Plain text
#: build/C/man2/sigaction.2:940
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and later.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""
"B<SA_NODEFER> フラグは 1.3.9 以降のカーネルでは同じ名前の SVr4 のフラグと互換"
"性がある。 ぞれ以前の Linux カーネルの実装では、このフラグを設定しているシグ"
"ナル だけでなく、どのシグナルでも受けることを許していた (実際には I<sa_mask> "
"の設定により無効にできる)。"

#. type: Plain text
#: build/C/man2/sigaction.2:946
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""
"B<sigaction>()  の二番目の引数に NULL を指定して呼び出すと、現在のシグナル"
"ハンドラーを確認する ことができる。また、二番目と三番目の引数を NULL にて呼"
"び出すことで、 指定されたシグナルが現在のマシンで使えるかどうかチェックでき"
"る。"

#. type: Plain text
#: build/C/man2/sigaction.2:952
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""
"B<SIGKILL> や B<SIGSTOP> を (I<sa_mask> に指定して) 禁止することはできない。 "
"禁止しようとしても黙って無視される。"

#. type: Plain text
#: build/C/man2/sigaction.2:956 build/C/man2/sigpending.2:69
#: build/C/man2/sigprocmask.2:160 build/C/man2/sigsuspend.2:109
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr "シグナル集合の操作に関する詳細は B<sigsetops>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sigaction.2:962
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called inside from inside a signal handler."
msgstr "シグナルハンドラー内から安全に呼び出すことができる、 async-signal-safe functions (非同期シグナルで安全な関数) の リストについては B<signal-safety>(7)  を参照。"

#. type: Plain text
#: build/C/man2/sigaction.2:972
msgid ""
"The glibc wrapper function for B<sigaction>()  gives an error (B<EINVAL>)  "
"on attempts to change the disposition of the two real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:985
msgid ""
"On architectures where the signal trampoline resides in the C library, the "
"glibc wrapper function for B<sigaction>()  places the address of the "
"trampoline code in the I<act.sa_restorer> field and sets the B<SA_RESTORER> "
"flag in the I<act.sa_flags> field.  See B<sigreturn>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1014
msgid ""
"The original Linux system call was named B<sigaction>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigaction>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal sets in I<act.sa_mask> and I<oldact.sa_mask>.  This argument is "
"currently required to have the value I<sizeof(sigset_t)> (or the error "
"B<EINVAL> results).  The glibc B<sigaction>()  wrapper function hides these "
"details from us, transparently calling B<rt_sigaction>()  when the kernel "
"provides it."
msgstr ""

#. type: SS
#: build/C/man2/sigaction.2:1014
#, no-wrap
msgid "Undocumented"
msgstr "非公式"

#. type: Plain text
#: build/C/man2/sigaction.2:1031
#, fuzzy
#| msgid ""
#| "Before the introduction of B<SA_SIGINFO> it was also possible to get some "
#| "additional information, namely by using a I<sa_handler> with second "
#| "argument of type I<struct sigcontext>.  See the relevant Linux kernel "
#| "sources for details.  This use is obsolete now."
msgid ""
"Before the introduction of B<SA_SIGINFO>, it was also possible to get some "
"additional information about the signal.  This was done by providing an "
"I<sa_handler> signal handler with a second argument of type I<struct "
"sigcontext>, which is the same structure as the one that is passed in the "
"I<uc_mcontext> field of the I<ucontext> structure that is passed (via a "
"pointer) in the third argument of the I<sa_sigaction> handler.  See the "
"relevant Linux kernel sources for details.  This use is obsolete now."
msgstr ""
"B<SA_SIGINFO> が導入される前は、 I<struct sigcontext> 型の二番目の引数と一"
"緒に I<sa_handler> を使用することで、 いくつかの追加の情報を入手することがで"
"きた。 詳細については Linux カーネルソースの関連部分を見てほしい。 現在はこの"
"使用法は廃止されている。"

#. type: Plain text
#: build/C/man2/sigaction.2:1039
msgid ""
"When delivering a signal with a B<SA_SIGINFO> handler, the kernel does not "
"always provide meaningful values for all of the fields of the I<siginfo_t> "
"that are relevant for that signal."
msgstr ""

#.  commit 69be8f189653cd81aae5a74e26615b12871bb72e
#. type: Plain text
#: build/C/man2/sigaction.2:1049
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""
"2.6.13 以前のカーネルでは、 I<sa_flags> に B<SA_NODEFER> を指定した場合、 ハ"
"ンドラーが実行中に配送されたシグナル自身がマスクされなくなるだけでなく、 "
"I<sa_mask> に指定されたシグナルもマスクされなくなる。 このバグは、カーネル "
"2.6.14 で修正された。"

#. type: Plain text
#: build/C/man2/sigaction.2:1052
msgid "See B<mprotect>(2)."
msgstr "B<mprotect>(2)  参照。"

#. type: Plain text
#: build/C/man2/sigaction.2:1075
msgid ""
"B<kill>(1), B<kill>(2), B<pause>(2), B<pidfd_send_signal>(2), "
"B<restart_syscall>(2), B<seccomp>(2), B<sigaltstack>(2), B<signal>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), "
"B<sigsuspend>(2), B<wait>(2), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr "B<kill>(1), B<kill>(2), B<pause>(2), B<pidfd_send_signal>(2), B<restart_syscall>(2), B<seccomp>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<wait>(2), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"

#. type: TH
#: build/C/man2/sigaltstack.2:26
#, no-wrap
msgid "SIGALTSTACK"
msgstr "SIGALTSTACK"

#. type: Plain text
#: build/C/man2/sigaltstack.2:29
msgid "sigaltstack - set and/or get signal stack context"
msgstr "sigaltstack - シグナルスタックのコンテキストを設定・取得する"

#. type: Plain text
#: build/C/man2/sigaltstack.2:33
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"
msgstr "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:40
msgid "B<sigaltstack>():"
msgstr "B<sigaltstack>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/sigaltstack.2:47 build/C/man3/siginterrupt.3:53
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:59
msgid ""
"B<sigaltstack>()  allows a thread to define a new alternate signal stack and/"
"or retrieve the state of an existing alternate signal stack.  An alternate "
"signal stack is used during the execution of a signal handler if the "
"establishment of that handler (see B<sigaction>(2))  requested it."
msgstr "B<sigaltstack>()  を使うと、 スレッドは新しい代替シグナルスタックを定義したり、 既存の代替シグナルスタックの状態を取得できる。 シグナルハンドラーが代替シグナルスタックを要求するように設定されていると (B<sigaction>(2)  参照)、ハンドラーの実行中はそのシグナルスタックが使われる。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:62
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr "代替シグナルスタックを使う際の一般的な手順は、以下の通りである:"

#. type: IP
#: build/C/man2/sigaltstack.2:62 build/C/man7/signal.7:262
#: build/C/man7/signal.7:586 build/C/man7/signal-safety.7:62
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/sigaltstack.2:66
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr "代替シグナルスタックで使うメモリー領域を確保する。"

#. type: IP
#: build/C/man2/sigaltstack.2:66 build/C/man7/signal.7:312
#: build/C/man7/signal.7:590 build/C/man7/signal-safety.7:68
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/sigaltstack.2:72
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""
"B<sigaltstack>()  を使って、 代替シグナルスタックの存在と場所をシステムに知ら"
"せる。"

#. type: IP
#: build/C/man2/sigaltstack.2:72 build/C/man7/signal.7:319
#: build/C/man7/signal.7:610
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man2/sigaltstack.2:79
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""
"B<sigaction>(2)  を使ってシグナルハンドラーを確立する際、 B<SA_ONSTACK> フラ"
"グを指定することにより、 そのシグナルハンドラーを代替シグナルスタック上で実行"
"することを システムに知らせる。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:86
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<old_ss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks, then the other argument can be specified as NULL."
msgstr "I<ss> 引数は、新しいシグナルスタックを指定するために使う。 また I<old_ss> 引数は、現在確立されている シグナルスタックの情報を取得するために使う。 この操作のうち 1 つだけを実行させるには、 使用しない引数を NULL に指定すればよい。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:90
msgid ""
"The I<stack_t> type used to type the arguments of this function is defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:98
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""
"typedef struct {\n"
"    void  *ss_sp;     /* スタックのベースアドレス */\n"
"    int    ss_flags;  /* フラグ */\n"
"    size_t ss_size;   /* スタックのバイト数 */\n"
"} stack_t;\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:103
msgid ""
"To establish a new alternate signal stack, the fields of this structure are "
"set as follows:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:103
#, no-wrap
msgid "I<ss.ss_flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:106
msgid "This field contains either 0, or the following flag:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:107
#, no-wrap
msgid "B<SS_AUTODISARM> (since Linux 4.7)"
msgstr "B<SS_AUTODISARM> (Linux 4.7 以降)"

#.  commit 2a74213838104a41588d86fd5e8d344972891ace
#.  See tools/testing/selftests/sigaltstack/sas.c in kernel sources
#. type: Plain text
#: build/C/man2/sigaltstack.2:114
msgid ""
"Clear the alternate signal stack settings on entry to the signal handler.  "
"When the signal handler returns, the previous alternate signal stack "
"settings are restored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:125
msgid ""
"This flag was added in order make it safe to switch away from the signal "
"handler with B<swapcontext>(3).  Without this flag, a subsequently handled "
"signal will corrupt the state of the switched-away signal handler.  On "
"kernels where this flag is not supported, B<sigaltstack>()  fails with the "
"error B<EINVAL> when this flag is supplied."
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:126
#, no-wrap
msgid "I<ss.ss_sp>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:132
#, fuzzy
#| msgid ""
#| "When a signal handler is invoked on the alternate stack, the kernel "
#| "automatically aligns the address given in I<ss.ss_sp> to a suitable "
#| "address boundary for the underlying hardware architecture."
msgid ""
"This field specifies the starting address of the stack.  When a signal "
"handler is invoked on the alternate stack, the kernel automatically aligns "
"the address given in I<ss.ss_sp> to a suitable address boundary for the "
"underlying hardware architecture."
msgstr ""
"代替スタックでシグナルハンドラーが起動された場合には、 カーネルにより自動的"
"に、I<ss.ss_sp> で指定されたアドレスは 動作しているハードウェアアーキテク"
"チャーに適したアドレス境界に 調整される。"

#. type: TP
#: build/C/man2/sigaltstack.2:132
#, no-wrap
msgid "I<ss.ss_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:139
#, fuzzy
#| msgid ""
#| "To establish a new alternate signal stack, I<ss.ss_flags> is set to zero, "
#| "and I<ss.ss_sp> and I<ss.ss_size> specify the starting address and size "
#| "of the stack.  The constant B<SIGSTKSZ> is defined to be large enough to "
#| "cover the usual size requirements for an alternate signal stack, and the "
#| "constant B<MINSIGSTKSZ> defines the minimum size required to execute a "
#| "signal handler."
msgid ""
"This field specifies the size of the stack.  The constant B<SIGSTKSZ> is "
"defined to be large enough to cover the usual size requirements for an "
"alternate signal stack, and the constant B<MINSIGSTKSZ> defines the minimum "
"size required to execute a signal handler."
msgstr ""
"新規の代替シグナルスタックを確立するには、 I<ss.ss_flags> を 0 に設定し、 "
"I<ss.ss_sp> と I<ss.ss_size> に スタックの開始アドレスとスタックサイズを指定"
"する。 定数 B<SIGSTKSZ> は、代替シグナルスタックが通常必要する サイズよりも充"
"分大きく定義されている。 また定数 B<MINSIGSTKSZ> は、 シグナルハンドラーの実"
"行に必要な最小サイズに定義されている。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:146
#, fuzzy
#| msgid ""
#| "To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  "
#| "In this case, the remaining fields in I<ss> are ignored."
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the kernel ignores any other flags in I<ss.ss_flags> and the "
"remaining fields in I<ss>."
msgstr ""
"既存のスタックを無効にするには、 I<ss.ss_flags> を B<SS_DISABLE> に指定す"
"る。 この場合、I<ss> の他のフィールドは無視される。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:154
msgid ""
"If I<old_ss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<old_ss.ss_sp> and I<old_ss.ss_size> fields return "
"the starting address and size of that stack.  The I<old_ss.ss_flags> may "
"return either of the following values:"
msgstr "I<old_ss> が NULL 以外の場合、 I<old_ss> に代替シグナルスタックの情報が返される。 これは (実質的に)  B<sigaltstack>()  の呼び出しより先に行われる。 I<old_ss.ss_sp> と I<old_ss.ss_size> フィールドに スタックの開始アドレスとスタックサイズが返される。 I<old_ss.ss_flags> には以下のどちらかの値が返される:"

#. type: TP
#: build/C/man2/sigaltstack.2:154
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr "B<SS_ONSTACK>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:160
msgid ""
"The thread is currently executing on the alternate signal stack.  (Note that "
"it is not possible to change the alternate signal stack if the thread is "
"currently executing on it.)"
msgstr "スレッドが代替シグナルスタック上で実行されている (スレッドが既にそのシグナルスタック上で実行されている場合は、 それと同じシグナルスタックには変更できない点に注意すること)。"

#. type: TP
#: build/C/man2/sigaltstack.2:160
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr "B<SS_DISABLE>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:163
msgid "The alternate signal stack is currently disabled."
msgstr "代替シグナルスタックが現在無効になっている。"

#.  FIXME Was it intended that one can set up a different alternative
#.  signal stack in this scenario? (In passing, if one does this, the
#.  sigaltstack(NULL, &old_ss) now returns old_ss.ss_flags==SS_AUTODISARM
#.  rather than old_ss.ss_flags==SS_DISABLE. The API design here seems
#.  confusing...
#. type: Plain text
#: build/C/man2/sigaltstack.2:178
msgid ""
"Alternatively, this value is returned if the thread is currently executing "
"on an alternate signal stack that was established using the B<SS_AUTODISARM> "
"flag.  In this case, it is safe to switch away from the signal handler with "
"B<swapcontext>(3).  It is also possible to set up a different alternative "
"signal stack using a further call to B<sigaltstack>()."
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:178
#, no-wrap
msgid "B<SS_AUTODISARM>"
msgstr "B<SS_AUTODISARM>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:182
#, fuzzy
#| msgid "The alternate signal stack is currently disabled."
msgid ""
"The alternate signal stack has been marked to be autodisarmed as described "
"above."
msgstr "代替シグナルスタックが現在無効になっている。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:189
msgid ""
"By specifying I<ss> as NULL, and I<old_ss> as a non-NULL value, one can "
"obtain the current settings for the alternate signal stack without changing "
"them."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:193
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""
"B<sigaltstack>()  は成功した場合 0 を返す。 失敗した場合は -1 を返して、 エ"
"ラーを示す値に I<errno> を設定する。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:198
msgid ""
"Either I<ss> or I<old_ss> is not NULL and points to an area outside of the "
"process's address space."
msgstr "I<ss> または I<old_ss> のどちらが、NULL 以外で、 かつプロセスのアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:202
msgid "I<ss> is not NULL and the I<ss_flags> field contains an invalid flag."
msgstr "I<ss> が NULL 以外で、I<ss_flags> フィールドが無効なフラグを含んでいる。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:208
msgid ""
"The specified size of the new alternate signal stack I<ss.ss_size> was less "
"than B<MINSIGSTKSZ>."
msgstr "新しい代替シグナルスタック (I<ss.ss_size>) に指定したサイズが B<MINSIGSTKSZ> より小さかった。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:213
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the thread was already executing on the current alternate signal "
"stack)."
msgstr "代替シグナルスタックが有効であるときに変更を行おうとした (つまり、スレッドが既に現在の代替シグナルスタック上で実行されていた)。"

#. type: tbl table
#: build/C/man2/sigaltstack.2:223
#, no-wrap
msgid "B<sigaltstack>()"
msgstr "B<sigaltstack>()"

#. type: Plain text
#: build/C/man2/sigaltstack.2:227
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."

#. type: Plain text
#: build/C/man2/sigaltstack.2:231
msgid "The B<SS_AUTODISARM> flag is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:239
#, fuzzy
#| msgid ""
#| "The most common usage of an alternate signal stack is to handle the "
#| "B<SIGSEGV> signal that is generated if the space available for the normal "
#| "process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
#| "cannot be invoked on the process stack; if we wish to handle it, we must "
#| "use an alternate signal stack."
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the standard "
"stack is exhausted: in this case, a signal handler for B<SIGSEGV> cannot be "
"invoked on the standard stack; if we wish to handle it, we must use an "
"alternate signal stack."
msgstr ""
"代替シグナルスタックを使用する最もよくある場面は、 B<SIGSEGV> シグナルを扱う"
"ときである。 B<SIGSEGV> はプロセスの通常のスタックが利用できる空間が使い果た"
"された際に 生成されるシグナルである。この場合には、 B<SIGSEGV> 用のシグナルハ"
"ンドラーをプロセスのスタック上では起動することができない。 そのため、このシグ"
"ナルを扱おうとする場合には、 代替シグナルスタックを使用しなければならない。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:249
#, fuzzy
#| msgid ""
#| "Establishing an alternate signal stack is useful if a process expects "
#| "that it may exhaust its standard stack.  This may occur, for example, "
#| "because the stack grows so large that it encounters the upwardly growing "
#| "heap, or it reaches a limit established by a call to "
#| "B<setrlimit(RLIMIT_STACK, &rlim)>.  If the standard stack is exhausted, "
#| "the kernel sends the process a B<SIGSEGV> signal.  In these circumstances "
#| "the only way to catch this signal is on an alternate signal stack."
msgid ""
"Establishing an alternate signal stack is useful if a thread expects that it "
"may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the thread a B<SIGSEGV> "
"signal.  In these circumstances the only way to catch this signal is on an "
"alternate signal stack."
msgstr ""
"プロセスが標準のシグナルスタックを使い果たすことが予想される場合は、 代替シグ"
"ナルスタックを確立すると便利である。 例えば、スタックが最上位アドレスから 下"
"位アドレス方向に非常にたくさん積まれてしまうことで、 最下位アドレスから上位ア"
"ドレス方向に積まれるヒープとぶつかってしまう場合や、 "
"B<setrlimit(RLIMIT_STACK, &rlim)> の呼び出しで確立された 制限に達してしまった"
"場合に、この様な事が起こる。 標準のスタックを使い果たしてしまうと、 カーネル"
"はプロセスに B<SIGSEGV> シグナルを送る。 このような状況では、代替シグナルス"
"タック上でしかシグナルをキャッチできない。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:255
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""
"Linux がサポートする多くのハードウェアアーキテクチャーでは、 スタックは下位ア"
"ドレス方向に積まれる。 B<sigaltstack>()  はスタックが積まれる方向を自動的に決"
"定する。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:264
#, fuzzy
#| msgid ""
#| "Functions called from a signal handler executing on an alternate signal "
#| "stack will also use the alternate signal stack.  (This also applies to "
#| "any handlers invoked for other signals while the process is executing on "
#| "the alternate signal stack.)  Unlike the standard stack, the system does "
#| "not automatically extend the alternate signal stack.  Exceeding the "
#| "allocated size of the alternate signal stack will lead to unpredictable "
#| "results."
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the thread is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""
"代替シグナルスタック上で実行されている シグナルハンドラーから呼ばれる関数も、"
"代替シグナルハンドラーを使う (プロセスが代替シグナルスタック上で実行されてい"
"る場合、 他のシグナルで呼び出されるハンドラーもこの代替シグナルハンドラーを使"
"う)。 標準のスタックとは異なり、 システムは代替シグナルスタックを自動的に拡張"
"しない。 代替シグナルスタック用に確保したサイズを越えた場合、 結果は予想でき"
"ない。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:280
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings.  The same is also true for a child "
"process created using B<clone>(2), unless the clone flags include "
"B<CLONE_VM> and do not include B<CLONE_VFORK>, in which case any alternate "
"signal stack that was established in the parent is disabled in the child "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:289
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""
"B<sigaltstack>()  は以前の B<sigstack>()  を置き換えるものである。 過去プログ"
"ラムとの互換性のため、glibc では B<sigstack>()  も提供している。 新しいのアプ"
"リケーションは全て B<sigaltstack>()  を使って書くべきである。"

#. type: SS
#: build/C/man2/sigaltstack.2:289 build/C/man3/sigpause.3:82
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man2/sigaltstack.2:296
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""
"4.2BSD には B<sigstack>()  システムコールがあった。 この関数は少し異なった構"
"造体を使っており、 呼び出した側がスタックの積まれる方向を知っていなければなら"
"ないという 大きな欠点があった。"

#.  Linux 2.3.40
#.  After quite a bit of web and mail archive searching,
#.  I could not find the patch on any mailing list, and I
#.  could find no place where the rationale for this change
#.  explained -- mtk
#.  See the source code of Illumos and FreeBSD, for example.
#. type: Plain text
#: build/C/man2/sigaltstack.2:334
msgid ""
"In Linux 2.2 and earlier, the only flag that could be specified in I<ss."
"sa_flags> was B<SS_DISABLE>.  In the lead up to the release of the Linux 2.4 "
"kernel, a change was made to allow B<sigaltstack>()  to allow I<ss."
"ss_flags==SS_ONSTACK> with the same meaning as I<ss.ss_flags==0> (i.e., the "
"inclusion of B<SS_ONSTACK> in I<ss.ss_flags> is a no-op).  On other "
"implementations, and according to POSIX.1, B<SS_ONSTACK> appears only as a "
"reported flag in I<old_ss.ss_flags>.  On Linux, there is no need ever to "
"specify B<SS_ONSTACK> in I<ss.ss_flags>, and indeed doing so should be "
"avoided on portability grounds: various other systems give an error if "
"B<SS_ONSTACK> is specified in I<ss.ss_flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:343
msgid ""
"The following code segment demonstrates the use of B<sigaltstack>()  (and "
"B<sigaction>(2))  to install an alternate signal stack that is employed by a "
"handler for the B<SIGSEGV> signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:347
#, no-wrap
msgid "stack_t ss;\n"
msgstr "stack_t ss;\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:353
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:360
#, no-wrap
msgid ""
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1) {\n"
"    perror(\"sigaltstack\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:368
#, no-wrap
msgid ""
"sa.sa_flags = SA_ONSTACK;\n"
"sa.sa_handler = handler();      /* Address of a signal handler */\n"
"sigemptyset(&sa.sa_mask);\n"
"if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n"
"    perror(\"sigaction\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:377
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"

#. type: TH
#: build/C/man7/sigevent.7:26
#, no-wrap
msgid "SIGEVENT"
msgstr "SIGEVENT"

#. type: Plain text
#: build/C/man7/sigevent.7:29
msgid "sigevent - structure for notification from asynchronous routines"
msgstr "sigevent - 非同期ルーチンからの通知用の構造体"

#. type: Plain text
#: build/C/man7/sigevent.7:32
#, no-wrap
msgid "#include E<lt>signal.hE<gt>\n"
msgstr "#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: build/C/man7/sigevent.7:37
#, no-wrap
msgid ""
"union sigval {            /* Data passed with notification */\n"
"    int     sival_int;    /* Integer value */\n"
"    void   *sival_ptr;    /* Pointer value */\n"
"};\n"
msgstr ""
"union sigval {            /* Data passed with notification */\n"
"    int     sival_int;    /* Integer value */\n"
"    void   *sival_ptr;    /* Pointer value */\n"
"};\n"

#. type: Plain text
#: build/C/man7/sigevent.7:53
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int    sigev_notify;  /* Notification method */\n"
"    int    sigev_signo;   /* Notification signal */\n"
"    union sigval sigev_value;\n"
"                          /* Data passed with notification */\n"
"    void (*sigev_notify_function) (union sigval);\n"
"                          /* Function used for thread\n"
"                             notification (SIGEV_THREAD) */\n"
"    void  *sigev_notify_attributes;\n"
"                          /* Attributes for notification thread\n"
"                             (SIGEV_THREAD) */\n"
"    pid_t  sigev_notify_thread_id;\n"
"                          /* ID of thread to signal\n"
"                             (SIGEV_THREAD_ID); Linux-specific */\n"
"};\n"
msgstr ""
"struct sigevent {\n"
"    int    sigev_notify;  /* Notification method */\n"
"    int    sigev_signo;   /* Notification signal */\n"
"    union sigval sigev_value;\n"
"                          /* Data passed with notification */\n"
"    void (*sigev_notify_function) (union sigval);\n"
"                          /* Function used for thread\n"
"                             notification (SIGEV_THREAD) */\n"
"    void  *sigev_notify_attributes;\n"
"                          /* Attributes for notification thread\n"
"                             (SIGEV_THREAD) */\n"
"    pid_t  sigev_notify_thread_id;\n"
"                          /* ID of thread to signal\n"
"                             (SIGEV_THREAD_ID); Linux-specific */\n"
"};\n"

#. type: Plain text
#: build/C/man7/sigevent.7:62
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""
"I<sigevent> 構造体は、イベントに関する情報をプロセスに通知するために様々な "
"API で使用される (イベントの例としては、 非同期処理要求の完了、 タイマーの満"
"了、 メッセージの到着など)。"

#. type: Plain text
#: build/C/man7/sigevent.7:70
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should employ only those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""
"「書式」に記載されている定義はおおよそのものである。 I<sigevent> 構造体のいく"
"つかのフィールドは、 共用体の一部として定義されているものもある。 プログラム"
"は、 I<sigev_notify> で指定された値に応じたフィールドだけを利用すべきである。"

#. type: Plain text
#: build/C/man7/sigevent.7:75
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""
"I<sigev_notify> フィールドは、通知をどのように処理すべきかを指定する。 この"
"フィールドは、以下のいずれかの値である。"

#. type: TP
#: build/C/man7/sigevent.7:75 build/C/man2/timer_create.2:142
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: build/C/man7/sigevent.7:78
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr "「空 (null)」の通知。 イベントが発生時には何もしないこと。"

#. type: TP
#: build/C/man7/sigevent.7:78 build/C/man2/timer_create.2:147
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#. type: Plain text
#: build/C/man7/sigevent.7:82
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr ""
"I<sigev_signo> で指定されたシグナルを送信することで、プロセスへの通知を行う。"

#. type: Plain text
#: build/C/man7/sigevent.7:89
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""
"B<sigaction>(2) の B<SA_SIGINFO> フラグを使った登録されたシグナルハンドラーに"
"よりシグナルが捕捉されると、 シグナルハンドラーの 2 番目の引数として渡され"
"た I<siginfo_t> 構造体の以下のフィールドが設定される。"

#. type: Plain text
#: build/C/man7/sigevent.7:94
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr "このフィールドには通知を配送した API に応じた決まる値が設定される。"

#. type: TP
#: build/C/man7/sigevent.7:94 build/C/man2/wait.2:325
#, no-wrap
msgid "I<si_signo>"
msgstr "I<si_signo>"

#. type: Plain text
#: build/C/man7/sigevent.7:98
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""
"このフィールドにはシグナル番号 (すなわち I<sigev_signo> と同じ値) が設定され"
"る。"

#. type: Plain text
#: build/C/man7/sigevent.7:102
msgid "This field is set to the value specified in I<sigev_value>."
msgstr "このフィールドには I<sigev_value> で指定された値が設定される。"

#. type: Plain text
#: build/C/man7/sigevent.7:107
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""
"API によっては I<siginfo_t> 構造体の他のフィールドが設定される場合もある。"

#. type: Plain text
#: build/C/man7/sigevent.7:110
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""
"シグナルを受け取ったときには B<sigwaitinfo>(2) でも同じ情報が得られる。"

#. type: TP
#: build/C/man7/sigevent.7:110 build/C/man2/timer_create.2:165
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man7/sigevent.7:127
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities "
"here are that each timer notification could result in the creation of a new "
"thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""
"「あたかも」新しいスレッドセーフの開始関数であるかのように "
"I<sigev_notify_function> を起動することで、 プロセスへの通知を行う (実装の可"
"能性としては、 タイマー通知の度に新しいスレッドセーフが作成される場合も、 一"
"つのスレッドを作成してすべての通知を受信する場合もある)。 この関数は "
"I<sigev_value> を唯一の引数として起動される。 I<sigev_notify_attributes> "
"は、 NULL 以外の場合は、 新しいスレッドセーフの属性を定義する "
"I<pthread_attr_t> 構造体を指していなければならない (B<pthread_attr_init>(3) "
"参照)。"

#. type: TP
#: build/C/man7/sigevent.7:127 build/C/man2/timer_create.2:173
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr "B<SIGEV_THREAD_ID> (Linux 固有)"

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: build/C/man7/sigevent.7:132
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr "現在のところ POSIX でのみ使用されている。 B<timer_create>(2) 参照。"

#. type: Plain text
#: build/C/man7/sigevent.7:142
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/siginterrupt.3:31
#, no-wrap
msgid "SIGINTERRUPT"
msgstr "SIGINTERRUPT"

#. type: TH
#: build/C/man3/siginterrupt.3:31
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: build/C/man3/siginterrupt.3:34
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr "siginterrupt - シグナルでシステムコールに割り込むことを許す"

#. type: Plain text
#: build/C/man3/siginterrupt.3:39
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"

#. type: Plain text
#: build/C/man3/siginterrupt.3:47
msgid "B<siginterrupt>():"
msgstr "B<siginterrupt>():"

#. type: Plain text
#: build/C/man3/siginterrupt.3:64
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""
"B<siginterrupt>()  関数は、システムコールがシグナル I<sig> によって割り込まれ"
"た後、再実行の際の振る舞いを変更する。 I<flag> 引数が偽 (0) ならば、システ"
"ムコールが指定した シグナル I<sig> によって割り込まれた後に、そのシステムコー"
"ルは 再実行される。これは Linux においてデフォルトの動作である。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:69
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a "
"system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""
"I<flag> 引数が真 (1) でデータの転送が全く行なわれていないならば、 シグナル "
"I<sig> でシステムコールは中断されて、-1 が返され、 I<errno> に B<EINTR> が設"
"定される。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:73
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""
"I<flag> 引数が真 (1) でデータの転送が開始されていれば、 システムコールは中"
"断され、それまでに実際に転送されたデータ の量が返される。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:83
msgid ""
"The B<siginterrupt>()  function returns 0 on success.  It returns -1 if the "
"signal number I<sig> is invalid, with I<errno> set to indicate the cause of "
"the error."
msgstr ""
"B<siginterrupt>()  関数は成功した場合 0 を返す。 シグナル番号 I<sig> が不正な"
"場合、 -1 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:87
msgid "The specified signal number is invalid."
msgstr "指定したシグナル番号が不正である。"

#. type: tbl table
#: build/C/man3/siginterrupt.3:97
#, no-wrap
msgid "B<siginterrupt>()"
msgstr "B<siginterrupt>()"

#. type: tbl table
#: build/C/man3/siginterrupt.3:97
#, no-wrap
msgid "MT-Unsafe const:sigintr"
msgstr "MT-Unsafe const:sigintr"

#. type: Plain text
#: build/C/man3/siginterrupt.3:108
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag instead."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 は、 B<siginterrupt>()  を廃止予定として"
"いる。 代わりに、 B<sigaction>(2)  に B<SA_RESTART> フラグを指定して使うこと"
"を推奨している。"

#. type: tbl table
#: build/C/man3/siginterrupt.3:110 build/C/man7/signal-safety.7:211
#, no-wrap
msgid "B<signal>(2)"
msgstr "B<signal>(2)"

#. type: TH
#: build/C/man2/signal.2:36 build/C/man7/signal.7:45
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#: build/C/man2/signal.2:36 build/C/man3/sigpause.3:25
#: build/C/man2/sigpending.2:29 build/C/man2/sigprocmask.2:29
#: build/C/man3/sigqueue.3:28 build/C/man2/sigreturn.2:30
#: build/C/man2/sigwaitinfo.2:25 build/C/man3/sysv_signal.3:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man2/signal.2:39
msgid "signal - ANSI C signal handling"
msgstr "signal - ANSI C シグナル操作"

#. type: Plain text
#: build/C/man2/signal.2:45
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<sighandler>B<);>"

#. type: Plain text
#: build/C/man2/signal.2:55
#, no-wrap
msgid ""
"B<WARNING>:\n"
" the behavior of\n"
"B<signal>()\n"
"varies across UNIX versions,\n"
"and has also varied historically across different versions of Linux.\n"
"B<Avoid its use>: use\n"
"B<sigaction>(2)\n"
"instead.\n"
"See I<Portability> below.\n"
msgstr ""
"B<警告>:\n"
" B<signal>()  の動作は UNIX のバージョンにより異なる。\n"
"また、歴史的に見て Linux のバージョンによっても異なっている。\n"
"B<このシステムコールの使用は避け、>\n"
"代わりに B<sigaction>(2)  を使用すること。\n"
"下記の「移植性」を参照。\n"

#. type: Plain text
#: build/C/man2/signal.2:65
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a programmer-"
"defined function (a \"signal handler\")."
msgstr ""
"B<signal>()  はシグナル I<signum> の処理方法を I<handler> に設定する。 "
"I<handler> には、 B<SIG_IGN>、 B<SIG_DFL>、 プログラマが定義した関数 (「シグ"
"ナルハンドラー」) のアドレスの いずれかを指定する。"

#. type: Plain text
#: build/C/man2/signal.2:69
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr ""
"シグナル I<signum> がプロセスに配送されると、以下のいずれかが発生する。"

#. type: Plain text
#: build/C/man2/signal.2:74
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr "処理方法が B<SIG_IGN> に設定されている場合、そのシグナルは無視される。"

#. type: Plain text
#: build/C/man2/signal.2:81
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""
"処理方法が B<SIG_DFL> に設定されている場合、シグナルに関連づけられた デフォル"
"トの動作が行われる (B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man2/signal.2:92
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""
"処理方法として関数が設定されている場合、 まず最初に処理方法が B<SIG_DFL> にリ"
"セットされるかそのシグナルのブロックが実行された後、 I<signum> を引数とし"
"て I<handler> が呼び出される。 ハンドラーが起動される際にシグナルがブロックさ"
"れた場合、 ハンドラーが返る際にそのシグナルのブロックが解除される。"

#. type: Plain text
#: build/C/man2/signal.2:98
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""
"シグナル B<SIGKILL> と B<SIGSTOP> は捕捉できず、無視することもできない。"

#. type: Plain text
#: build/C/man2/signal.2:106
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"B<signal>()  は、今までのシグナルハンドラーの値を返す。 エラーの場合は "
"B<SIG_ERR> を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/signal.2:111
msgid "I<signum> is invalid."
msgstr "I<signum> が不正である。"

#. type: Plain text
#: build/C/man2/signal.2:117
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""
"マルチスレッドプロセスにおける B<signal>()  の結果は、指定されていない。"

#. type: Plain text
#: build/C/man2/signal.2:142
#, fuzzy
#| msgid ""
#| "See B<sigaction>(2)  for details on what happens when B<SIGCHLD> is set "
#| "to B<SIG_IGN>."
msgid ""
"See B<sigaction>(2)  for details on what happens when the disposition "
"B<SIGCHLD> is set to B<SIG_IGN>."
msgstr ""
"B<SIGCHLD> の動作として B<SIG_IGN> を設定した場合の詳細な動作については、 "
"B<sigaction>(2)  を参照すること。"

#. type: Plain text
#: build/C/man2/signal.2:147
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called from inside a signal handler."
msgstr "シグナルハンドラー内から安全に呼び出すことができる、 async-signal-safe functions (非同期シグナルで安全な関数) のリストについては B<signal-safety>(7) を参照。"

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: build/C/man2/signal.2:167
#, fuzzy
#| msgid ""
#| "The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> "
#| "is defined; glibc also defines (the BSD-derived)  I<sig_t> if "
#| "B<_BSD_SOURCE> is defined.  Without use of such a type, the declaration "
#| "of B<signal>()  is the somewhat harder to read:"
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> "
"(glibc 2.19 and earlier)  or B<_DEFAULT_SOURCE> (glibc 2.19 and later)  is "
"defined.  Without use of such a type, the declaration of B<signal>()  is the "
"somewhat harder to read:"
msgstr ""
"I<sighandler_t> の使用は GNU 拡張であり、 B<_GNU_SOURCE> が定義された場合に公"
"開される。glibc では B<_BSD_SOURCE> が定義された場合には (BSD 由来の) "
"I<sig_t> も定義される。このような型を使用しないと、 B<signal>() の宣言は読み"
"にくいものとなる。"

#. type: Plain text
#: build/C/man2/signal.2:171
#, no-wrap
msgid "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"
msgstr "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"

#. type: SS
#: build/C/man2/signal.2:173
#, no-wrap
msgid "Portability"
msgstr "移植性"

#. type: Plain text
#: build/C/man2/signal.2:185
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""
"移植性のある B<signal>()  の使い方は、シグナルの処理方法を B<SIG_DFL> か "
"B<SIG_IGN> に設定する方法だけである。 シグナルハンドラーを設定するのに "
"B<signal>()  を使ったときの動作はシステムにより異なる (POSIX.1 は明示的にこの"
"違いを認めている)。 B<移植性が必要なときはこのシステムコールを使用しないこ"
"と。>"

#. type: Plain text
#: build/C/man2/signal.2:191
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""
"POSIX.1 は、 B<sigaction>(2)  を規定することで移植性に関する混乱を解決した。 "
"B<sigaction>(2)  はシグナルハンドラーが起動される際の挙動を明示的に制御でき"
"る。 B<signal>()  の代わりにこのインターフェイスを使うこと。"

#. type: Plain text
#: build/C/man2/signal.2:201
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  This is equivalent to calling "
"B<sigaction>(2)  with the following flags:"
msgstr ""
"オリジナルの UNIX システムでは、 B<signal>()  を使って設定されたハンドラーが"
"シグナルの配送により起動されると、 そのシグナルの処理方法は B<SIG_DFL> にリ"
"セットされ、システムは同じシグナルがさらに生成されても シグナルの配送をブロッ"
"クしなかった。これは、以下のフラグで B<sigaction>(2) を呼び出すのと等価であ"
"る。"

#. type: Plain text
#: build/C/man2/signal.2:205
#, no-wrap
msgid "sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"
msgstr "sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"

#. type: Plain text
#: build/C/man2/signal.2:214
msgid ""
"System\\ V also provides these semantics for B<signal>().  This was bad "
"because the signal might be delivered again before the handler had a chance "
"to reestablish itself.  Furthermore, rapid deliveries of the same signal "
"could result in recursive invocations of the handler."
msgstr ""
"System\\ V でも、 B<signal>()  に対してこれらの挙動を規定している。 こうした"
"挙動はまずく、ハンドラーがハンドラー自身を再設定する機会が 来るより前に、同じ"
"シグナルがまた配送される可能性がある。 さらに、同じシグナルが立て続けに配送さ"
"れると、同じシグナルが ハンドラーを繰り返し起動されることになる。"

#. type: Plain text
#: build/C/man2/signal.2:229
msgid ""
"BSD improved on this situation, but unfortunately also changed the semantics "
"of the existing B<signal>()  interface while doing so.  On BSD, when a "
"signal handler is invoked, the signal disposition is not reset, and further "
"instances of the signal are blocked from being delivered while the handler "
"is executing.  Furthermore, certain blocking system calls are automatically "
"restarted if interrupted by a signal handler (see B<signal>(7)).  The BSD "
"semantics are equivalent to calling B<sigaction>(2)  with the following "
"flags:"
msgstr ""
"BSD はこの状況が改善したが、残念なことに、その過程で既存の B<signal>() の挙動"
"も変更された。 BSD では、シグナルハンドラーが起動された際、 シグナルの処理方"
"法はリセットされず、 ハンドラーの実行中は、同じシグナルのさらなる生成は配送が"
"ブロックされる。 また、 シグナルハンドラーが中断された場合、 停止中のシステム"
"コールのいくつかは自動的に再スタートされる。 BSD の挙動は、 以下のフラグを指"
"定した B<sigaction>(2) の呼び出しと等価である。"

#. type: Plain text
#: build/C/man2/signal.2:233
#, no-wrap
msgid "sa.sa_flags = SA_RESTART;\n"
msgstr "sa.sa_flags = SA_RESTART;\n"

#. type: Plain text
#: build/C/man2/signal.2:237
msgid "The situation on Linux is as follows:"
msgstr "Linux での状況は以下の通りである。"

#. type: Plain text
#: build/C/man2/signal.2:241
msgid "The kernel's B<signal>()  system call provides System\\ V semantics."
msgstr ""
"カーネルの B<signal>()  システムコールは System\\ V 方式を提供している。"

#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#.  .IP *
#.  The
#.  .BR signal ()
#.  function in Linux libc4 and libc5 provide System\ V semantics.
#.  If one on a libc5 system includes
#.  .I <bsd/signal.h>
#.  instead of
#.  .IR <signal.h> ,
#.  then
#.  .BR signal ()
#.  provides BSD semantics.
#. type: Plain text
#: build/C/man2/signal.2:275
#, fuzzy
#| msgid ""
#| "By default, in glibc 2 and later, the B<signal>()  wrapper function does "
#| "not invoke the kernel system call.  Instead, it calls B<sigaction>(2)  "
#| "using flags that supply BSD semantics.  This default behavior is provided "
#| "as long as the B<_BSD_SOURCE> feature test macro is defined.  By default, "
#| "B<_BSD_SOURCE> is defined; it is also implicitly defined if one defines "
#| "B<_GNU_SOURCE>, and can of course be explicitly defined."
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as a suitable feature test macro is defined: B<_BSD_SOURCE> on glibc 2.19 "
"and earlier or B<_DEFAULT_SOURCE> in glibc 2.19 and later.  (By default, "
"these macros are defined; see B<feature_test_macros>(7)  for details.)  If "
"such a feature test macro is not defined, then B<signal>()  provides System"
"\\ V semantics."
msgstr ""
"デフォルトでは、glibc 2 以降では、 B<signal>()  ラッパー関数はカーネルのシス"
"テムコールを起動しない。 代わりに、ラッパー関数は BSD 方式を示すフラグを使っ"
"て B<sigaction>(2)  を呼び出す。 機能検査マクロ B<_BSD_SOURCE> を定義していれ"
"ば、このデフォルトの動作となる。 デフォルトでは、 B<_BSD_SOURCE> が定義され"
"る。 B<_BSD_SOURCE> は B<_GNU_SOURCE> が定義された場合には暗黙のうちに定義さ"
"れ、 もちろん明示的に定義することもできる。"

#. type: Plain text
#: build/C/man2/signal.2:294
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr "B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), B<signal>(7)"

#. type: Plain text
#: build/C/man7/signal.7:48
msgid "signal - overview of signals"
msgstr "signal - シグナルの概要"

#. type: Plain text
#: build/C/man7/signal.7:51
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard signals"
"\") and POSIX real-time signals."
msgstr ""
"Linux は POSIX 信頼シグナル (reliable signal; 以後 \"標準シグナル\"と表記)  "
"と POSIX リアルタイムシグナルの両方に対応している。"

#. type: SS
#: build/C/man7/signal.7:51
#, no-wrap
msgid "Signal dispositions"
msgstr "シグナル処理方法"

#. type: Plain text
#: build/C/man7/signal.7:56
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""
"シグナルはそれぞれ現在の「処理方法 (disposition)」を保持しており、 この処理方"
"法によりシグナルが配送された際にプロセスが どのような振舞いをするかが決まる。"

#. type: Plain text
#: build/C/man7/signal.7:59
msgid ""
"The entries in the \"Action\" column of the table below specify the default "
"disposition for each signal, as follows:"
msgstr ""
"後述の表の \"動作\" の欄のエントリーは各シグナルのデフォルトの 処理方法を示し"
"ており、以下のような意味を持つ。"

#. type: tbl table
#: build/C/man7/signal.7:59 build/C/man7/signal.7:378 build/C/man7/signal.7:383
#: build/C/man7/signal.7:385 build/C/man7/signal.7:389
#: build/C/man7/signal.7:390 build/C/man7/signal.7:392
#: build/C/man7/signal.7:393 build/C/man7/signal.7:394
#: build/C/man7/signal.7:396 build/C/man7/signal.7:398
#: build/C/man7/signal.7:399 build/C/man7/signal.7:402
#: build/C/man7/signal.7:407 build/C/man7/signal.7:413
#: build/C/man7/signal.7:414 build/C/man7/signal.7:415
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
#: build/C/man7/signal.7:61
msgid "Default action is to terminate the process."
msgstr "デフォルトの動作はプロセス終了。"

#. type: tbl table
#: build/C/man7/signal.7:61 build/C/man7/signal.7:380 build/C/man7/signal.7:381
#: build/C/man7/signal.7:412 build/C/man7/signal.7:420
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
#: build/C/man7/signal.7:63
msgid "Default action is to ignore the signal."
msgstr "デフォルトの動作はこのシグナルの無視。"

#. type: tbl table
#: build/C/man7/signal.7:63 build/C/man7/signal.7:377 build/C/man7/signal.7:379
#: build/C/man7/signal.7:384 build/C/man7/signal.7:387
#: build/C/man7/signal.7:391 build/C/man7/signal.7:400
#: build/C/man7/signal.7:401 build/C/man7/signal.7:405
#: build/C/man7/signal.7:408 build/C/man7/signal.7:411
#: build/C/man7/signal.7:416 build/C/man7/signal.7:418
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
#: build/C/man7/signal.7:66
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr "デフォルトの動作はプロセス終了とコアダンプ出力 (B<core>(5)  参照)。"

#. type: tbl table
#: build/C/man7/signal.7:66 build/C/man7/signal.7:403 build/C/man7/signal.7:404
#: build/C/man7/signal.7:409 build/C/man7/signal.7:410
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
#: build/C/man7/signal.7:68
msgid "Default action is to stop the process."
msgstr "デフォルトの動作はプロセスの一時停止。"

#. type: tbl table
#: build/C/man7/signal.7:68 build/C/man7/signal.7:382
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
#: build/C/man7/signal.7:70
msgid "Default action is to continue the process if it is currently stopped."
msgstr "デフォルトの動作は、プロセスが停止中の場合にその実行の再開。"

#. type: Plain text
#: build/C/man7/signal.7:86
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered."
msgstr "プロセスは、 B<sigaction>(2)  や B<signal>(2)  を使って、シグナルの処理方法を変更することができる (B<signal>(2)  の方がシグナルハンドラーを設定する際の移植性が低い; 詳細は B<signal>(2)  を参照)。 シグナルの配送時に起こる動作として プロセスが選択できるのは、次のいずれか一つである。 デフォルトの動作を実行する、シグナルを無視する、 I<シグナルハンドラー (signal handler)> でシグナルを捕捉する。シグナルハンドラーとは、シグナル配送時に 自動的に起動されるプログラマ定義の関数である。"

#. type: Plain text
#: build/C/man7/signal.7:93
msgid ""
"By default, a signal handler is invoked on the normal process stack.  It is "
"possible to arrange that the signal handler uses an alternate stack; see "
"B<sigaltstack>(2)  for a discussion of how to do this and when it might be "
"useful."
msgstr "デフォルトでは、シグナルハンドラーは通常のプロセスのスタック上で起動される。 シグナルハンドラーが代替スタック (alternate stack) を使用するように設定する こともできる。代替スタックを使用するように設定する方法と、どのような際に 代替スタックが役に立つかについての議論については B<sigaltstack>(2) を参照のこと。"

#. type: Plain text
#: build/C/man7/signal.7:97
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""
"シグナルの処理方法はプロセス単位の属性である。 マルチスレッドのアプリケーショ"
"ンでは、あるシグナルの処理方法は 全てのスレッドで同じである。"

#. type: SS
#: build/C/man7/signal.7:105
#, no-wrap
msgid "Sending a signal"
msgstr "シグナルの送信"

#. type: Plain text
#: build/C/man7/signal.7:108
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""
"以下のシステムコールとライブラリ関数を使って、 呼び出し者はシグナルを送信する"
"ことができる。"

#. type: tbl table
#: build/C/man7/signal.7:108 build/C/man7/signal-safety.7:183
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
#: build/C/man7/signal.7:111
msgid "Sends a signal to the calling thread."
msgstr "呼び出したスレッドにシグナルを送る。"

#. type: tbl table
#: build/C/man7/signal.7:111 build/C/man7/signal-safety.7:152
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: Plain text
#: build/C/man7/signal.7:116
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""
"指定されたプロセスや、指定されたプロセスグループの全メンバー、 システムの全プ"
"ロセスにシグナルを送る。"

#. type: TP
#: build/C/man7/signal.7:116
#, no-wrap
msgid "B<pidfd_send_signal>(2)"
msgstr "B<pidfd_send_signal>(2)"

#. type: Plain text
#: build/C/man7/signal.7:119
msgid "Sends a signal to a process identified by a PID file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:119
#, no-wrap
msgid "B<killpg>(3)"
msgstr "B<killpg>(3)"

#. type: Plain text
#: build/C/man7/signal.7:122
msgid "Sends a signal to all of the members of a specified process group."
msgstr "指定されたプロセスグループの全メンバーにシグナルを送る。"

#. type: tbl table
#: build/C/man7/signal.7:122 build/C/man7/signal-safety.7:180
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
#: build/C/man7/signal.7:126
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the caller."
msgstr ""
"呼び出し者と同じプロセス内の指定された POSIX スレッドにシグナルを送る。"

#. type: TP
#: build/C/man7/signal.7:126
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
#: build/C/man7/signal.7:131
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""
"指定されたプロセス内の指定されたスレッドにシグナルを送る (このシステムコール"
"を使って B<pthread_kill>(3)  は実装されている)。"

#. type: TP
#: build/C/man7/signal.7:131
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: Plain text
#: build/C/man7/signal.7:134
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr "指定されたプロセスに付属データとともにリアルタイムシグナルを送る。"

#. type: SS
#: build/C/man7/signal.7:134
#, no-wrap
msgid "Waiting for a signal to be caught"
msgstr "シグナルが捕捉されるのを待つ"

#. type: Plain text
#: build/C/man7/signal.7:138
msgid ""
"The following system calls suspend execution of the calling thread until a "
"signal is caught (or an unhandled signal terminates the process):"
msgstr "以下のシステムコールを使って、シグナルが捕捉されるまで 呼び出したスレッドの実行を中断 (suspend) することができる (ハンドラーが設定されていないシグナルによりそのプロセスが終了した 場合にも実行の停止は終了する)。"

#. type: tbl table
#: build/C/man7/signal.7:138 build/C/man7/signal-safety.7:175
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
#: build/C/man7/signal.7:141
msgid "Suspends execution until any signal is caught."
msgstr "何かシグナルが捕捉されるまで実行を停止する。"

#. type: tbl table
#: build/C/man7/signal.7:141 build/C/man7/signal.7:663
#: build/C/man7/signal-safety.7:217
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
#: build/C/man7/signal.7:146
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""
"一時的にシグナルマスク (下記参照) を変更し、 マスクされていないシグナルのいず"
"れかが捕捉されるまで 実行を中断する。"

#. type: SS
#: build/C/man7/signal.7:146
#, no-wrap
msgid "Synchronously accepting a signal"
msgstr "シグナルの同期受信"

#. type: Plain text
#: build/C/man7/signal.7:153
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""
"シグナルハンドラー経由でシグナルを非同期 (asynchronously) で捕捉する以外に"
"も、 シグナルを同期 (synchronously) して受け付けることもできる。 同期して受け"
"付けるとは、シグナルが配送されるまで実行を停止 (block)  するということであ"
"る。シグナルを受け付けた際に、カーネルは そのシグナルに関する情報を呼び出し者"
"に返す。 これを行う一般的な方法が二つある。"

#. type: Plain text
#: build/C/man7/signal.7:161
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), B<sigwait>(3)  は、指定されたシグナル"
"集合のシグナルの一つが配送されるまで実行を中断する。 どのシステムコールや関数"
"でも、配送されたシグナルに関する情報が返される。"

#. type: Plain text
#: build/C/man7/signal.7:174
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each "
"B<read>(2)  from this file descriptor blocks until one of the signals in the "
"set specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""
"B<signalfd>(2)  が返すファイルディスクリプターを使うと、呼び出し元に配送され"
"た シグナルに関する情報を読み出すことができる。 このファイルディスクリプター"
"からの B<read>(2)  は、 B<signalfd>(2)  の呼び出し時に指定されたシグナル集合"
"のシグナルの一つが呼び出し元に 配送されるまで停止 (block) する。 B<read>(2)  "
"が返すバッファーにはシグナルに関する情報を格納した構造体が入っている。"

#. type: SS
#: build/C/man7/signal.7:174
#, no-wrap
msgid "Signal mask and pending signals"
msgstr "シグナルマスクと処理待ちシグナル"

#. type: Plain text
#: build/C/man7/signal.7:181
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""
"シグナルは I<ブロック (block)> されることがある。ブロックされると、そのシグナ"
"ルは その後ブロックを解除されるまで配送されなくなる。 シグナルが生成されてか"
"ら配送されるまでの間、そのシグナルは I<処理待ち (pending)> であると呼ばれる。"

#. type: Plain text
#: build/C/man7/signal.7:190
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""
"プロセス内の各スレッドは、それぞれ独立な I<シグナルマスク (signal mask)> を持"
"つ。シグナルマスクはそのスレッドが現在ブロックしている シグナル集合を示すもの"
"である。 スレッドは、 B<pthread_sigmask>(3)  を使って自分のシグナルマスクを操"
"作できる。 伝統的なシングルスレッドのアプリケーションでは、 "
"B<sigprocmask>(2)  を使って、シグナルマスクを操作できる。"

#. type: Plain text
#: build/C/man7/signal.7:196 build/C/man2/sigprocmask.2:142
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスは親プロセスのシグナルマスクのコピーを"
"継承する。 B<execve>(2)  の前後でシグナルマスクは保持される。"

#. type: Plain text
#: build/C/man7/signal.7:219
msgid ""
"A signal may be process-directed or thread-directed.  A process-directed "
"signal is one that is targeted at (and thus pending for)  the process as a "
"whole.  A signal may be process-directed because it was generated by the "
"kernel for reasons other than a hardware exception, or because it was sent "
"using B<kill>(2)  or B<sigqueue>(3).  A thread-directed signal is one that "
"is targeted at a specific thread.  A signal may be thread-directed because "
"it was generated as a consequence of executing a specific machine-language "
"instruction that triggered a hardware exception (e.g., B<SIGSEGV> for an "
"invalid memory access, or B<SIGFPE> for a math error), or because it was "
"targeted at a specific thread using interfaces such as B<tgkill>(2)  or "
"B<pthread_kill>(3)."
msgstr ""

#
#
#
#.  Joseph C. Sible notes:
#.  On Linux, if the main thread has the signal unblocked, then the kernel
#.  will always deliver the signal there, citing this kernel code
#.      Per this comment in kernel/signal.c since time immemorial:
#.      /*
#.      * Now find a thread we can wake up to take the signal off the queue.
#.      *
#.      * If the main thread wants the signal, it gets first crack.
#.      * Probably the least surprising to the average bear.
#.      */
#.  But this does not mean the signal will be delivered only in the
#.  main thread, since if a handler is already executing in the main thread
#.  (and thus the signal is blocked in that thread), then a further
#.  might be delivered in a different thread.
#. type: Plain text
#: build/C/man7/signal.7:242
msgid ""
"A process-directed signal may be delivered to any one of the threads that "
"does not currently have the signal blocked.  If more than one of the threads "
"has the signal unblocked, then the kernel chooses an arbitrary thread to "
"which to deliver the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:249
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""
"スレッドは、 B<sigpending>(2)  を使って、現在処理待ちのシグナル集合を取得する"
"ことができる。 この集合は、プロセス宛ての処理待ちシグナルと 呼び出したスレッ"
"ド宛てのシグナルの両方から構成される。"

#. type: Plain text
#: build/C/man7/signal.7:256 build/C/man2/sigpending.2:85
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスでは、処理待ちのシグナル集合は空の集合"
"で初期化される。 B<execve>(2)  の前後で、処理待ちのシグナル集合は保持される。"

#. type: SS
#: build/C/man7/signal.7:256
#, no-wrap
msgid "Execution of signal handlers"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:262
msgid ""
"Whenever there is a transition from kernel-mode to user-mode execution (e."
"g., on return from a system call or scheduling of a thread onto the CPU), "
"the kernel checks whether there is a pending unblocked signal for which the "
"process has established a signal handler.  If there is such a pending "
"signal, the following steps occur:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:265
msgid ""
"The kernel performs the necessary preparatory steps for execution of the "
"signal handler:"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:266
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:268
msgid "The signal is removed from the set of pending signals."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:268
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:276
msgid ""
"If the signal handler was installed by a call to B<sigaction>(2)  that "
"specified the B<SA_ONSTACK> flag and the thread has defined an alternate "
"signal stack (using B<sigaltstack>(2)), then that stack is installed."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:276
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:280
msgid ""
"Various pieces of signal-related context are saved into a special frame that "
"is created on the stack.  The saved information includes:"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:281 build/C/man7/signal.7:285
#: build/C/man7/signal.7:288 build/C/man7/signal.7:290
#, no-wrap
msgid "+"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:285
msgid ""
"the program counter register (i.e., the address of the next instruction in "
"the main program that should be executed when the signal handler returns);"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:288
msgid ""
"architecture-specific register state required for resuming the interrupted "
"program;"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:290
#, fuzzy
#| msgid "Each of the threads in a process has its own signal mask."
msgid "the thread's current signal mask;"
msgstr "プロセス内の各スレッドはそれぞれ専用のシグナルマスクを持つ。"

#. type: Plain text
#: build/C/man7/signal.7:292
#, fuzzy
#| msgid "The alternate signal stack is currently disabled."
msgid "the thread's alternate signal stack settings."
msgstr "代替シグナルスタックが現在無効になっている。"

#. type: Plain text
#: build/C/man7/signal.7:300
#, fuzzy
#| msgid ""
#| "If the signal is caught with a signal handler that was registered using "
#| "the B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are "
#| "set in the I<siginfo_t> structure that is passed as the second argument "
#| "of the handler:"
msgid ""
"(If the signal handler was installed using the B<sigaction>(2)  "
"B<SA_SIGINFO> flag, then the above information is accessible via the "
"I<ucontext_t> object that is pointed to by the third argument of the signal "
"handler.)"
msgstr ""
"B<sigaction>(2) の B<SA_SIGINFO> フラグを使った登録されたシグナルハンドラーに"
"よりシグナルが捕捉されると、 シグナルハンドラーの 2 番目の引数として渡され"
"た I<siginfo_t> 構造体の以下のフィールドが設定される。"

#. type: IP
#: build/C/man7/signal.7:300
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:311
msgid ""
"Any signals specified in I<act-E<gt>sa_mask> when registering the handler "
"with B<sigprocmask>(2)  are added to the thread's signal mask.  The signal "
"being delivered is also added to the signal mask, unless B<SA_NODEFER> was "
"specified when registering the handler.  These signals are thus blocked "
"while the handler executes."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:319
msgid ""
"The kernel constructs a frame for the signal handler on the stack.  The "
"kernel sets the program counter for the thread to point to the first "
"instruction of the signal handler function, and configures the return "
"address for that function to point to a piece of user-space code known as "
"the signal trampoline (described in B<sigreturn>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:322
msgid ""
"The kernel passes control back to user-space, where execution commences at "
"the start of the signal handler function."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:322
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:324
msgid ""
"When the signal handler returns, control passes to the signal trampoline "
"code."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:324
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man7/signal.7:337
msgid ""
"The signal trampoline calls B<sigreturn>(2), a system call that uses the "
"information in the stack frame created in step 1 to restore the thread to "
"its state before the signal handler was called.  The thread's signal mask "
"and alternate signal stack settings are restored as part of this procedure.  "
"Upon completion of the call to B<sigreturn>(2), the kernel transfers control "
"back to user space, and the thread recommences execution at the point where "
"it was interrupted by the signal handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:355
msgid ""
"Note that if the signal handler does not return (e.g., control is "
"transferred out of the handler using B<siglongjmp>(3), or the handler "
"executes a new program with B<execve>(2)), then the final step is not "
"performed.  In particular, in such scenarios it is the programmer's "
"responsibility to restore the state of the signal mask (using "
"B<sigprocmask>(2)), if it is desired to unblock the signals that were "
"blocked on entry to the signal handler.  (Note that B<siglongjmp>(3)  may or "
"may not restore the signal mask, depending on the I<savesigs> value that was "
"specified in the corresponding call to B<sigsetjmp>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:366
msgid ""
"From the kernel's point of view, execution of the signal handler code is "
"exactly the same as the execution of any other user-space code.  That is to "
"say, the kernel does not record any special state information indicating "
"that the thread is currently excuting inside a signal handler.  All "
"necessary state information is maintained in user-space registers and the "
"user-space stack.  The depth to which nested signal handlers may be invoked "
"is thus limited only by the user-space stack (and sensible software design!)."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:366
#, no-wrap
msgid "Standard signals"
msgstr "標準シグナル"

#. type: Plain text
#: build/C/man7/signal.7:372
msgid ""
"Linux supports the standard signals listed below.  The second column of the "
"table indicates which standard (if any)  specified the signal: \"P1990\" "
"indicates that the signal is described in the original POSIX.1-1990 "
"standard; \"P2001\" indicates that the signal was added in SUSv2 and "
"POSIX.1-2001."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:376 build/C/man7/signal.7:486
#, no-wrap
msgid "Signal"
msgstr "シグナル"

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Standard"
msgstr "標準"

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Action"
msgstr "動作"

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Comment"
msgstr "コメント"

#. type: tbl table
#: build/C/man7/signal.7:377 build/C/man7/signal.7:493
#, no-wrap
msgid "SIGABRT"
msgstr "SIGABRT"

#. type: tbl table
#: build/C/man7/signal.7:377 build/C/man7/signal.7:378
#: build/C/man7/signal.7:380 build/C/man7/signal.7:382
#: build/C/man7/signal.7:384 build/C/man7/signal.7:385
#: build/C/man7/signal.7:387 build/C/man7/signal.7:389
#: build/C/man7/signal.7:392 build/C/man7/signal.7:394
#: build/C/man7/signal.7:400 build/C/man7/signal.7:401
#: build/C/man7/signal.7:403 build/C/man7/signal.7:404
#: build/C/man7/signal.7:407 build/C/man7/signal.7:409
#: build/C/man7/signal.7:410 build/C/man7/signal.7:413
#: build/C/man7/signal.7:414
#, no-wrap
msgid "P1990"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:377
#, no-wrap
msgid "Abort signal from B<abort>(3)"
msgstr "B<abort>(3) からの中断 (Abort) シグナル"

#. type: tbl table
#: build/C/man7/signal.7:378 build/C/man7/signal.7:503
#, no-wrap
msgid "SIGALRM"
msgstr "SIGALRM"

#. type: tbl table
#: build/C/man7/signal.7:378
#, no-wrap
msgid "Timer signal from B<alarm>(2)"
msgstr "B<alarm>(2) からのタイマーシグナル"

#. type: tbl table
#: build/C/man7/signal.7:379 build/C/man7/signal.7:495
#, no-wrap
msgid "SIGBUS"
msgstr "SIGBUS"

#. type: tbl table
#: build/C/man7/signal.7:379 build/C/man7/signal.7:396
#: build/C/man7/signal.7:398 build/C/man7/signal.7:405
#: build/C/man7/signal.7:408 build/C/man7/signal.7:412
#: build/C/man7/signal.7:415 build/C/man7/signal.7:416
#: build/C/man7/signal.7:418
#, no-wrap
msgid "P2001"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:379
#, no-wrap
msgid "Bus error (bad memory access)"
msgstr "バスエラー (不正なメモリーアクセス)"

#. type: tbl table
#: build/C/man7/signal.7:380 build/C/man7/signal.7:506
#, no-wrap
msgid "SIGCHLD"
msgstr "SIGCHLD"

#. type: tbl table
#: build/C/man7/signal.7:380
#, no-wrap
msgid "Child stopped or terminated"
msgstr "子プロセスの一時停止 (stop) または終了"

#. type: tbl table
#: build/C/man7/signal.7:381 build/C/man7/signal.7:507
#, no-wrap
msgid "SIGCLD"
msgstr "SIGCLD"

#. type: tbl table
#: build/C/man7/signal.7:381 build/C/man7/signal.7:383
#: build/C/man7/signal.7:388 build/C/man7/signal.7:390
#: build/C/man7/signal.7:391 build/C/man7/signal.7:393
#: build/C/man7/signal.7:399 build/C/man7/signal.7:402
#: build/C/man7/signal.7:411 build/C/man7/signal.7:420
#: build/C/man7/signal.7:496 build/C/man7/signal.7:505
#: build/C/man7/signal.7:507 build/C/man7/signal.7:522
#: build/C/man7/signal.7:523 build/C/man7/signal.7:525
#, no-wrap
msgid "-"
msgstr "-"

#. type: tbl table
#: build/C/man7/signal.7:381
#, no-wrap
msgid "A synonym for B<SIGCHLD>"
msgstr "B<SIGCHLD> と同義"

#. type: tbl table
#: build/C/man7/signal.7:382 build/C/man7/signal.7:508
#, no-wrap
msgid "SIGCONT"
msgstr "SIGCONT"

#. type: tbl table
#: build/C/man7/signal.7:382
#, no-wrap
msgid "Continue if stopped"
msgstr "一時停止 (stop) からの再開"

#. type: tbl table
#: build/C/man7/signal.7:383 build/C/man7/signal.7:496
#, no-wrap
msgid "SIGEMT"
msgstr "SIGEMT"

#. type: tbl table
#: build/C/man7/signal.7:383
#, no-wrap
msgid "Emulator trap"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:384 build/C/man7/signal.7:497
#, no-wrap
msgid "SIGFPE"
msgstr "SIGFPE"

#. type: tbl table
#: build/C/man7/signal.7:384
#, no-wrap
msgid "Floating-point exception"
msgstr "浮動小数点例外"

#. type: tbl table
#: build/C/man7/signal.7:385 build/C/man7/signal.7:488
#, no-wrap
msgid "SIGHUP"
msgstr "SIGHUP"

#. type: tbl table
#: build/C/man7/signal.7:385
#, no-wrap
msgid "Hangup detected on controlling terminal"
msgstr "制御端末(controlling terminal)のハングアップ検出、"

#. type: tbl table
#: build/C/man7/signal.7:386
#, no-wrap
msgid "or death of controlling process"
msgstr "または制御しているプロセスの死"

#. type: tbl table
#: build/C/man7/signal.7:387 build/C/man7/signal.7:491
#, no-wrap
msgid "SIGILL"
msgstr "SIGILL"

#. type: tbl table
#: build/C/man7/signal.7:387
#, no-wrap
msgid "Illegal Instruction"
msgstr "不正な命令"

#. type: tbl table
#: build/C/man7/signal.7:388 build/C/man7/signal.7:522
#, no-wrap
msgid "SIGINFO"
msgstr "SIGINFO"

#. type: tbl table
#: build/C/man7/signal.7:388
#, no-wrap
msgid "A synonym for B<SIGPWR>"
msgstr "B<SIGPWR> と同義"

#. type: tbl table
#: build/C/man7/signal.7:389 build/C/man7/signal.7:489
#, no-wrap
msgid "SIGINT"
msgstr "SIGINT"

#. type: tbl table
#: build/C/man7/signal.7:389
#, no-wrap
msgid "Interrupt from keyboard"
msgstr "キーボードからの割り込み (Interrupt)"

#. type: tbl table
#: build/C/man7/signal.7:390 build/C/man7/signal.7:519
#, no-wrap
msgid "SIGIO"
msgstr "SIGIO"

#. type: tbl table
#: build/C/man7/signal.7:390
#, no-wrap
msgid "I/O now possible (4.2BSD)"
msgstr "入出力が可能になった (4.2BSD)"

#. type: tbl table
#: build/C/man7/signal.7:391 build/C/man7/signal.7:494
#, no-wrap
msgid "SIGIOT"
msgstr "SIGIOT"

#. type: tbl table
#: build/C/man7/signal.7:391
#, no-wrap
msgid "IOT trap. A synonym for B<SIGABRT>"
msgstr "IOT トラップ。 B<SIGABRT> と同義"

#. type: tbl table
#: build/C/man7/signal.7:392 build/C/man7/signal.7:498
#, no-wrap
msgid "SIGKILL"
msgstr "SIGKILL"

#. type: tbl table
#: build/C/man7/signal.7:392
#, no-wrap
msgid "Kill signal"
msgstr "Kill シグナル"

#. type: tbl table
#: build/C/man7/signal.7:393 build/C/man7/signal.7:523
#, no-wrap
msgid "SIGLOST"
msgstr "SIGLOST"

#. type: tbl table
#: build/C/man7/signal.7:393
#, no-wrap
msgid "File lock lost (unused)"
msgstr "ファイルロックが失われた (未使用)"

#. type: tbl table
#: build/C/man7/signal.7:394 build/C/man7/signal.7:502
#, no-wrap
msgid "SIGPIPE"
msgstr "SIGPIPE"

#. type: tbl table
#: build/C/man7/signal.7:394
#, no-wrap
msgid "Broken pipe: write to pipe with no"
msgstr "パイプ破壊:"

#. type: tbl table
#: build/C/man7/signal.7:395
#, no-wrap
msgid "readers; see B<pipe>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:396 build/C/man7/signal.7:520
#, no-wrap
msgid "SIGPOLL"
msgstr "SIGPOLL"

#. type: tbl table
#: build/C/man7/signal.7:396
#, no-wrap
msgid "Pollable event (Sys V);"
msgstr "ポーリング可能なイベント (Sys V);"

#. type: tbl table
#: build/C/man7/signal.7:397
#, no-wrap
msgid "synonym for B<SIGIO>"
msgstr "B<SIGIO> と同義"

#. type: tbl table
#: build/C/man7/signal.7:398 build/C/man7/signal.7:517
#, no-wrap
msgid "SIGPROF"
msgstr "SIGPROF"

#. type: tbl table
#: build/C/man7/signal.7:398
#, no-wrap
msgid "Profiling timer expired"
msgstr "profiling タイマーの時間切れ"

#. type: tbl table
#: build/C/man7/signal.7:399 build/C/man7/signal.7:521
#, no-wrap
msgid "SIGPWR"
msgstr "SIGPWR"

#. type: tbl table
#: build/C/man7/signal.7:399
#, no-wrap
msgid "Power failure (System V)"
msgstr "電源喪失 (Power failure) (System V)"

#. type: tbl table
#: build/C/man7/signal.7:400 build/C/man7/signal.7:490
#, no-wrap
msgid "SIGQUIT"
msgstr "SIGQUIT"

#. type: tbl table
#: build/C/man7/signal.7:400
#, no-wrap
msgid "Quit from keyboard"
msgstr "キーボードによる中止 (Quit)"

#. type: tbl table
#: build/C/man7/signal.7:401 build/C/man7/signal.7:500
#, no-wrap
msgid "SIGSEGV"
msgstr "SIGSEGV"

#. type: tbl table
#: build/C/man7/signal.7:401
#, no-wrap
msgid "Invalid memory reference"
msgstr "不正なメモリー参照"

#. type: tbl table
#: build/C/man7/signal.7:402 build/C/man7/signal.7:505
#, no-wrap
msgid "SIGSTKFLT"
msgstr "SIGSTKFLT"

#. type: tbl table
#: build/C/man7/signal.7:402
#, no-wrap
msgid "Stack fault on coprocessor (unused)"
msgstr "数値演算プロセッサにおけるスタックフォルト (未使用)"

#. type: tbl table
#: build/C/man7/signal.7:403 build/C/man7/signal.7:509
#, no-wrap
msgid "SIGSTOP"
msgstr "SIGSTOP"

#. type: tbl table
#: build/C/man7/signal.7:403
#, no-wrap
msgid "Stop process"
msgstr "プロセスの一時停止 (stop)"

#. type: tbl table
#: build/C/man7/signal.7:404 build/C/man7/signal.7:510
#, no-wrap
msgid "SIGTSTP"
msgstr "SIGTSTP"

#. type: tbl table
#: build/C/man7/signal.7:404
#, no-wrap
msgid "Stop typed at terminal"
msgstr "端末より入力された一時停止 (stop)"

#. type: tbl table
#: build/C/man7/signal.7:405 build/C/man7/signal.7:524
#, no-wrap
msgid "SIGSYS"
msgstr "SIGSYS"

#. type: tbl table
#: build/C/man7/signal.7:405
#, no-wrap
msgid "Bad system call (SVr4);"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:406
#, no-wrap
msgid "see also B<seccomp>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:407 build/C/man7/signal.7:504
#, no-wrap
msgid "SIGTERM"
msgstr "SIGTERM"

#. type: tbl table
#: build/C/man7/signal.7:407
#, no-wrap
msgid "Termination signal"
msgstr "終了 (termination) シグナル"

#. type: tbl table
#: build/C/man7/signal.7:408 build/C/man7/signal.7:492
#, no-wrap
msgid "SIGTRAP"
msgstr "SIGTRAP"

#. type: tbl table
#: build/C/man7/signal.7:408
#, no-wrap
msgid "Trace/breakpoint trap"
msgstr "トレース/ブレークポイント トラップ"

#. type: tbl table
#: build/C/man7/signal.7:409 build/C/man7/signal.7:511
#, no-wrap
msgid "SIGTTIN"
msgstr "SIGTTIN"

#. type: tbl table
#: build/C/man7/signal.7:409
#, no-wrap
msgid "Terminal input for background process"
msgstr "バックグランドプロセスの端末入力"

#. type: tbl table
#: build/C/man7/signal.7:410 build/C/man7/signal.7:512
#, no-wrap
msgid "SIGTTOU"
msgstr "SIGTTOU"

#. type: tbl table
#: build/C/man7/signal.7:410
#, no-wrap
msgid "Terminal output for background process"
msgstr "バックグランドプロセスの端末出力"

#. type: tbl table
#: build/C/man7/signal.7:411 build/C/man7/signal.7:525
#, no-wrap
msgid "SIGUNUSED"
msgstr "SIGUNUSED"

#. type: tbl table
#: build/C/man7/signal.7:411
#, no-wrap
msgid "Synonymous with B<SIGSYS>"
msgstr "B<SIGSYS> と同義"

#. type: tbl table
#: build/C/man7/signal.7:412 build/C/man7/signal.7:513
#, no-wrap
msgid "SIGURG"
msgstr "SIGURG"

#. type: tbl table
#: build/C/man7/signal.7:412
#, no-wrap
msgid "Urgent condition on socket (4.2BSD)"
msgstr "ソケットの緊急事態 (urgent condition) (4.2BSD)"

#. type: tbl table
#: build/C/man7/signal.7:413 build/C/man7/signal.7:499
#, no-wrap
msgid "SIGUSR1"
msgstr "SIGUSR1"

#. type: tbl table
#: build/C/man7/signal.7:413
#, no-wrap
msgid "User-defined signal 1"
msgstr "ユーザー定義シグナル 1"

#. type: tbl table
#: build/C/man7/signal.7:414 build/C/man7/signal.7:501
#, no-wrap
msgid "SIGUSR2"
msgstr "SIGUSR2"

#. type: tbl table
#: build/C/man7/signal.7:414
#, no-wrap
msgid "User-defined signal 2"
msgstr "ユーザー定義シグナル 2"

#. type: tbl table
#: build/C/man7/signal.7:415 build/C/man7/signal.7:516
#, no-wrap
msgid "SIGVTALRM"
msgstr "SIGVTALRM"

#. type: tbl table
#: build/C/man7/signal.7:415
#, no-wrap
msgid "Virtual alarm clock (4.2BSD)"
msgstr "仮想アラームクロック (4.2BSD)"

#. type: tbl table
#: build/C/man7/signal.7:416 build/C/man7/signal.7:514
#, no-wrap
msgid "SIGXCPU"
msgstr "SIGXCPU"

#. type: tbl table
#: build/C/man7/signal.7:416
#, no-wrap
msgid "CPU time limit exceeded (4.2BSD);"
msgstr "CPU時間制限超過 (4.2BSD);"

#. type: tbl table
#: build/C/man7/signal.7:417 build/C/man7/signal.7:419
#, no-wrap
msgid "see B<setrlimit>(2)"
msgstr "see B<setrlimit>(2)"

#. type: tbl table
#: build/C/man7/signal.7:418 build/C/man7/signal.7:515
#, no-wrap
msgid "SIGXFSZ"
msgstr "SIGXFSZ"

#. type: tbl table
#: build/C/man7/signal.7:418
#, no-wrap
msgid "File size limit exceeded (4.2BSD);"
msgstr "ファイルサイズ制限の超過 (4.2BSD);"

#. type: tbl table
#: build/C/man7/signal.7:420 build/C/man7/signal.7:518
#, no-wrap
msgid "SIGWINCH"
msgstr "SIGWINCH"

#. type: tbl table
#: build/C/man7/signal.7:420
#, no-wrap
msgid "Window resize signal (4.3BSD, Sun)"
msgstr "ウィンドウ リサイズ シグナル (4.3BSD, Sun)"

#. type: Plain text
#: build/C/man7/signal.7:428
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr "シグナル B<SIGKILL> と B<SIGSTOP> はキャッチ、ブロック、無視できない。"

#. type: Plain text
#: build/C/man7/signal.7:439
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""
"Linux 2.2 以前では、 B<SIGSYS>, B<SIGXCPU>, B<SIGXFSZ> および SPARC と MIPS "
"以外のアーキテクチャーでの B<SIGBUS> のデフォルトの振る舞いは (コアダンプ出力"
"なしの) プロセス終了であった。 (他の UNIX システムにも B<SIGXCPU> と "
"B<SIGXFSZ> のデフォルトの動作がコアダンプなしのプロセス終了のものがある。)  "
"Linux 2.4 では、POSIX.1-2001 での要求仕様に準拠して、 これらのシグナルで、プ"
"ロセスを終了させ、コアダンプを出力する ようになっている。"

#. type: Plain text
#: build/C/man7/signal.7:445
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""
"B<SIGEMT> は POSIX.1-2001 に規定されていないが、 その他の多くの UNIX システム"
"に存在する。 デフォルトの動作は多くの場合、コアダンプ出力を伴うプロセスの終了"
"である。"

#. type: Plain text
#: build/C/man7/signal.7:449
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""
"B<SIGPWR> は (POSIX.1-2001 に規定されていないが) このシグナルが存在する 他の "
"UNIX システムでは多くの場合、デフォルト動作は無視である。"

#. type: Plain text
#: build/C/man7/signal.7:454
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""
"B<SIGIO> は (POSIX.1-2001 に規定されていないが) いくつかの他の UNIX システム"
"では デフォルト動作は無視である。"

#. type: SS
#: build/C/man7/signal.7:454
#, no-wrap
msgid "Queueing and delivery semantics for standard signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:457
msgid ""
"If multiple standard signals are pending for a process, the order in which "
"the signals are delivered is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:472
msgid ""
"Standard signals do not queue.  If multiple instances of a standard signal "
"are generated while that signal is blocked, then only one instance of the "
"signal is marked as pending (and the signal will be delivered just once when "
"it is unblocked).  In the case where a standard signal is already pending, "
"the I<siginfo_t> structure (see B<sigaction>(2))  associated with that "
"signal is not overwritten on arrival of subsequent instances of the same "
"signal.  Thus, the process will receive the information associated with the "
"first instance of the signal."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:472
#, fuzzy, no-wrap
#| msgid "Signal mask and pending signals"
msgid "Signal numbering for standard signals"
msgstr "シグナルマスクと処理待ちシグナル"

#. type: Plain text
#: build/C/man7/signal.7:481
msgid ""
"The numeric value for each signal is given in the table below.  As shown in "
"the table, many signals have different numeric values on different "
"architectures.  The first numeric value in each table row shows the signal "
"number on x86, ARM, and most other architectures; the second value is for "
"Alpha and SPARC; the third is for MIPS; and the last is for PARISC.  A dash "
"(-) denotes that a signal is absent on the corresponding architecture."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "x86/ARM"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "Alpha/"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "MIPS"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "PARISC"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486 build/C/man7/signal-safety.7:95
#, no-wrap
msgid "Notes"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:487
#, no-wrap
msgid "most others"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:487
#, no-wrap
msgid "SPARC"
msgstr "SPARC"

#. type: tbl table
#: build/C/man7/signal.7:488
#, no-wrap
msgid "\\01"
msgstr "\\01"

#. type: tbl table
#: build/C/man7/signal.7:489
#, no-wrap
msgid "\\02"
msgstr "\\02"

#. type: tbl table
#: build/C/man7/signal.7:490
#, no-wrap
msgid "\\03"
msgstr "\\03"

#. type: tbl table
#: build/C/man7/signal.7:491
#, no-wrap
msgid "\\04"
msgstr "\\04"

#. type: tbl table
#: build/C/man7/signal.7:492
#, no-wrap
msgid "\\05"
msgstr "\\05"

#. type: tbl table
#: build/C/man7/signal.7:493 build/C/man7/signal.7:494
#, no-wrap
msgid "\\06"
msgstr "\\06"

#. type: tbl table
#: build/C/man7/signal.7:495 build/C/man7/signal.7:496
#: build/C/man7/signal.7:505
#, no-wrap
msgid "\\07"
msgstr "\\07"

#. type: tbl table
#: build/C/man7/signal.7:495 build/C/man7/signal.7:499
#, no-wrap
msgid "10"
msgstr "10"

#. type: tbl table
#: build/C/man7/signal.7:497
#, no-wrap
msgid "\\08"
msgstr "\\08"

#. type: tbl table
#: build/C/man7/signal.7:498
#, no-wrap
msgid "\\09"
msgstr "\\09"

#. type: tbl table
#: build/C/man7/signal.7:499 build/C/man7/signal.7:514
#: build/C/man7/signal.7:515 build/C/man7/signal.7:521
#, no-wrap
msgid "30"
msgstr "30"

#. type: tbl table
#: build/C/man7/signal.7:499 build/C/man7/signal.7:505
#: build/C/man7/signal.7:513
#, no-wrap
msgid "16"
msgstr "16"

#. type: tbl table
#: build/C/man7/signal.7:500
#, no-wrap
msgid "11"
msgstr "11"

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:514
#: build/C/man7/signal.7:524
#, no-wrap
msgid "12"
msgstr "12"

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:515
#: build/C/man7/signal.7:524 build/C/man7/signal.7:525
#, no-wrap
msgid "31"
msgstr "31"

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:506
#: build/C/man7/signal.7:509
#, no-wrap
msgid "17"
msgstr "17"

#. type: tbl table
#: build/C/man7/signal.7:502
#, no-wrap
msgid "13"
msgstr "13"

#. type: tbl table
#: build/C/man7/signal.7:503
#, no-wrap
msgid "14"
msgstr "14"

#. type: tbl table
#: build/C/man7/signal.7:504
#, no-wrap
msgid "15"
msgstr "15"

#. type: tbl table
#: build/C/man7/signal.7:506 build/C/man7/signal.7:510
#: build/C/man7/signal.7:516 build/C/man7/signal.7:518
#, no-wrap
msgid "20"
msgstr "20"

#. type: tbl table
#: build/C/man7/signal.7:506 build/C/man7/signal.7:507
#: build/C/man7/signal.7:508 build/C/man7/signal.7:510
#, no-wrap
msgid "18"
msgstr "18"

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:509
#: build/C/man7/signal.7:521
#, no-wrap
msgid "19"
msgstr "19"

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:510
#: build/C/man7/signal.7:515
#, no-wrap
msgid "25"
msgstr "25"

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:511
#: build/C/man7/signal.7:516
#, no-wrap
msgid "26"
msgstr "26"

#. type: tbl table
#: build/C/man7/signal.7:509 build/C/man7/signal.7:513
#: build/C/man7/signal.7:518 build/C/man7/signal.7:519
#, no-wrap
msgid "23"
msgstr "23"

#. type: tbl table
#: build/C/man7/signal.7:509 build/C/man7/signal.7:510
#: build/C/man7/signal.7:514
#, no-wrap
msgid "24"
msgstr "24"

#. type: tbl table
#: build/C/man7/signal.7:511 build/C/man7/signal.7:513
#: build/C/man7/signal.7:517
#, no-wrap
msgid "21"
msgstr "21"

#. type: tbl table
#: build/C/man7/signal.7:511 build/C/man7/signal.7:512
#: build/C/man7/signal.7:517
#, no-wrap
msgid "27"
msgstr "27"

#. type: tbl table
#: build/C/man7/signal.7:512 build/C/man7/signal.7:519
#, no-wrap
msgid "22"
msgstr "22"

#. type: tbl table
#: build/C/man7/signal.7:512 build/C/man7/signal.7:516
#: build/C/man7/signal.7:518
#, no-wrap
msgid "28"
msgstr "28"

#. type: tbl table
#: build/C/man7/signal.7:513 build/C/man7/signal.7:517
#: build/C/man7/signal.7:519
#, no-wrap
msgid "29"
msgstr "29"

#. type: tbl table
#: build/C/man7/signal.7:520
#, no-wrap
msgid "Same as SIGIO"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:521 build/C/man7/signal.7:522
#, no-wrap
msgid "29/-"
msgstr "29/-"

#. type: tbl table
#: build/C/man7/signal.7:523
#, no-wrap
msgid "-/29"
msgstr "-/29"

#. type: Plain text
#: build/C/man7/signal.7:529
msgid "Note the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:537
#, fuzzy
#| msgid ""
#| "Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
#| "architectures."
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS>.  Since glibc 2.26, "
"B<SIGUNUSED> is no longer defined on any architecture."
msgstr ""
"B<SIGUNUSED> が定義されている場合には、ほとんどのアーキテクチャーで "
"B<SIGSYS> の同義語となっている。"

#. type: Plain text
#: build/C/man7/signal.7:544
#, fuzzy
#| msgid ""
#| "(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a "
#| "sparc.)"
msgid ""
"Signal 29 is B<SIGINFO>/B<SIGPWR> (synonyms for the same value) on Alpha but "
"B<SIGLOST> on SPARC."
msgstr ""
"(シグナル 29 は alpha では B<SIGINFO> / B<SIGPWR> だが、sparc では "
"B<SIGLOST> である。)"

#. type: SS
#: build/C/man7/signal.7:544
#, no-wrap
msgid "Real-time signals"
msgstr "リアルタイムシグナル"

#. type: Plain text
#: build/C/man7/signal.7:555
#, fuzzy
#| msgid ""
#| "Linux supports real-time signals as originally defined in the POSIX.1b "
#| "real-time extensions (and now included in POSIX.1-2001).  The range of "
#| "supported real-time signals is defined by the macros B<SIGRTMIN> and "
#| "B<SIGRTMAX>.  POSIX.1-2001 requires that an implementation support at "
#| "least B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgid ""
"Starting with version 2.2, Linux supports real-time signals as originally "
"defined in the POSIX.1b real-time extensions (and now included in "
"POSIX.1-2001).  The range of supported real-time signals is defined by the "
"macros B<SIGRTMIN> and B<SIGRTMAX>.  POSIX.1-2001 requires that an "
"implementation support at least B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""
"Linux はリアルタイムシグナルをサポートしている。 リアルタイムシグナルは元々 "
"POSIX.1b のリアルタイム拡張で定義されて いるものであり、現在では "
"POSIX.1-2001 に含まれている。 対応しているリアルタイムシグナルの範囲は、マク"
"ロ B<SIGRTMIN> と B<SIGRTMAX> で定義される。 POSIX.1-2001 では、少なくとも "
"B<_POSIX_RTSIG_MAX> (8) 個のリアルタイムシグナルに対応した実装が要求されてい"
"る。"

#. type: Plain text
#: build/C/man7/signal.7:577
#, fuzzy
#| msgid ""
#| "The Linux kernel supports a range of 32 different real-time signals, "
#| "numbered 33 to 64.  However, the glibc POSIX threads implementation "
#| "internally uses two (for NPTL) or three (for LinuxThreads) real-time "
#| "signals (see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> "
#| "suitably (to 34 or 35).  Because the range of available real-time signals "
#| "varies according to the glibc threading implementation (and this "
#| "variation can occur at run time according to the available kernel and "
#| "glibc), and indeed the range of real-time signals varies across UNIX "
#| "systems, programs should I<never refer to real-time signals using hard-"
#| "coded numbers>, but instead should always refer to real-time signals "
#| "using the notation B<SIGRTMIN>+n, and include suitable (run-time) checks "
#| "that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgid ""
"The Linux kernel supports a range of 33 different real-time signals, "
"numbered 32 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""
"Linux は、32 個の異なるリアルタイムシグナルに対応しており、 その番号は 33 か"
"ら 64 である。 しかしながら、glibc の POSIX スレッド実装は、 内部で 2個 "
"(NPTL の場合) か 3個 (LinuxThreads の場合) の リアルタイムシグナルを使用して"
"おり (B<pthreads>(7)  参照)、 B<SIGRTMIN> の値を適切に (34 か 35 に) 調整す"
"る。 利用可能なリアルタイムシグナルの範囲は glibc のスレッド実装により 異なる"
"し (使用するカーネルと glibc により実行時にも変化する)、 UNIX システムの種類"
"によっても異なる。したがって、 プログラムでは「ハードコーディングした数字を"
"使ってのリアルタイムシグナルの 参照は決してすべきではなく」、代わりに "
"B<SIGRTMIN>+n の形で参照すべきである。また、 B<SIGRTMIN>+n が B<SIGRTMAX> を"
"超えていないかのチェックを (実行時に) 適切に行うべきである。"

#. type: Plain text
#: build/C/man7/signal.7:581
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined purposes."
msgstr ""
"標準シグナルと異なり、リアルタイムシグナルには 事前に定義された意味はない。 "
"リアルタイムシグナルの全部をアプリケーションで定義した用途に使える。"

#. type: Plain text
#: build/C/man7/signal.7:584
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""
"ハンドリングしないリアルタイムシグナルのデフォルトの動作は 受信したプロセスの"
"終了である。"

#. type: Plain text
#: build/C/man7/signal.7:586
msgid "Real-time signals are distinguished by the following:"
msgstr "リアルタイムシグナルは以下の特徴がある:"

#. type: Plain text
#: build/C/man7/signal.7:590
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""
"リアルタイムシグナルは複数の実体をキューに入れることができる。 一方、標準シグ"
"ナルの場合、そのシグナルがブロックされている間に 同じシグナルの複数のインスタ"
"ンスが配送されても、 1 つだけがキューに入れられる。"

#. type: Plain text
#: build/C/man7/signal.7:610
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2), then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""
"シグナルが B<sigqueue>(3)  を用いて送信された場合、 付属データ (整数かポイン"
"ター) をシグナルと共に送信できる。 受信側プロセスが B<sigaction>(2)  に "
"B<SA_SIGINFO> フラグを指定してシグナルハンドラーを設定した場合、 このデータ"
"は I<siginfo_t> 構造体の I<si_value> フィールド経由でハンドラーの第 2 引数"
"として渡され、 利用することができる。 さらに、この構造体の I<si_pid> と "
"I<si_uid> フィールドでシグナルを送信したプロセスの PID と実ユーザー ID を 得"
"ることができる。"

#. type: Plain text
#: build/C/man7/signal.7:619
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""
"リアルタイムシグナルでは配送される順序が保証される。 同じタイプのリアルタイム"
"シグナルは送信された順番に到着する。 異なるリアルタイムシグナルが一つのプロセ"
"スに送信された場合、 番号の小さいシグナルから先に到着する。 (つまり小さい番号"
"のシグナルが高い優先順位を持つ。)  対照的に、一つのプロセスに対して複数の標準"
"シグナルが処理待ちとなった場合、 これらのシグナルが配送される順序は不定であ"
"る。"

#. type: Plain text
#: build/C/man7/signal.7:624
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""
"一つのプロセスに対して標準シグナルとリアルタイムシグナルの両方が 処理待ちの場"
"合、POSIX はどちらが先に配送されるかを規定していない。 Linux では、他の多くの"
"実装と同様、このような場合には 標準シグナルが優先される。"

#. type: Plain text
#: build/C/man7/signal.7:647
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, I</proc/"
"sys/kernel/rtsig-nr>, can be used to find out how many real-time signals are "
"currently queued.  In Linux 2.6.8, these I</proc> interfaces were replaced "
"by the B<RLIMIT_SIGPENDING> resource limit, which specifies a per-user limit "
"for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""
"POSIX によれば、1 プロセス毎に最低 B<_POSIX_SIGQUEUE_MAX> (32) 個のリアルタイ"
"ムシグナルをキューに入れられるべきとしている。 しかし、 Linux では違った実装"
"になっている。カーネル 2.6.7 までは (2.6.7 を含む)、全プロセスでキューに入っ"
"ているリアルタイムシグナル の数の合計についてシステム全体での制限がある。 こ"
"の制限は I</proc/sys/kernel/rtsig-max> ファイルで見ることができ、 (権限があれ"
"ば) 変更もできる。 関係するファイルとして、 I</proc/sys/kernel/rtsig-nr> を見"
"ることで、いくつのリアルタイムシグナルが現在キューに入っているかを 知ることが"
"できる。 Linux 2.6.8 で、これらの I</proc> 経由のインターフェースは、 "
"B<RLIMIT_SIGPENDING> リソース制限に置き換えられた。 これは、キューに入るシグ"
"ナル数に関してユーザー単位に 上限を指定するものである。 詳しくは "
"B<setrlimit>(2)  を参照。"

#. type: Plain text
#: build/C/man7/signal.7:655
msgid ""
"The addition of real-time signals required the widening of the signal set "
"structure (I<sigset_t>)  from 32 to 64 bits.  Consequently, various system "
"calls were superseded by new system calls that supported the larger signal "
"sets.  The old and new system calls are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:658
#, fuzzy, no-wrap
#| msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgid "Linux 2.0 and earlier"
msgstr "Linux 2.4 以前: B<nanosleep>(2)."

#. type: tbl table
#: build/C/man7/signal.7:658
#, fuzzy, no-wrap
#| msgid "Linux notes"
msgid "Linux 2.2 and later"
msgstr "Linux での注意"

#. type: tbl table
#: build/C/man7/signal.7:659 build/C/man7/signal-safety.7:204
#, no-wrap
msgid "B<sigaction>(2)"
msgstr "B<sigaction>(2)"

#. type: tbl table
#: build/C/man7/signal.7:659
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr "B<rt_sigaction>(2)"

#. type: tbl table
#: build/C/man7/signal.7:660 build/C/man7/signal-safety.7:213
#, no-wrap
msgid "B<sigpending>(2)"
msgstr "B<sigpending>(2)"

#. type: tbl table
#: build/C/man7/signal.7:660
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr "B<rt_sigpending>(2)"

#. type: tbl table
#: build/C/man7/signal.7:661 build/C/man7/signal-safety.7:214
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr "B<sigprocmask>(2)"

#. type: tbl table
#: build/C/man7/signal.7:661
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr "B<rt_sigprocmask>(2)"

#. type: tbl table
#: build/C/man7/signal.7:662
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr "B<sigreturn>(2)"

#. type: tbl table
#: build/C/man7/signal.7:662
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr "B<rt_sigreturn>(2)"

#. type: tbl table
#: build/C/man7/signal.7:663
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr "B<rt_sigsuspend>(2)"

#. type: tbl table
#: build/C/man7/signal.7:664
#, no-wrap
msgid "B<sigtimedwait>(2)"
msgstr "B<sigtimedwait>(2)"

#. type: tbl table
#: build/C/man7/signal.7:664
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr "B<rt_sigtimedwait>(2)"

#. type: SS
#: build/C/man7/signal.7:667
#, no-wrap
msgid "Interruption of system calls and library functions by signal handlers"
msgstr "シグナルハンドラーによるシステムコールやライブラリ関数への割り込み"

#. type: Plain text
#: build/C/man7/signal.7:670
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""
"システムコールやライブラリが停止 (block) している間にシグナルハンドラーが 起"
"動されると、以下のどちらかとなる。"

#. type: Plain text
#: build/C/man7/signal.7:672
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr "シグナルが返った後、呼び出しは自動的に再スタートされる。"

#. type: Plain text
#: build/C/man7/signal.7:675
msgid "the call fails with the error B<EINTR>."
msgstr "呼び出しはエラー B<EINTR> で失敗する。"

#. type: Plain text
#: build/C/man7/signal.7:683
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""
"これらの二つの挙動のうちどちらが起こるかは、インターフェイスにより依存し、 シ"
"グナルハンドラーが B<SA_RESTART> フラグ (B<sigaction>(2)  参照) を使って設定"
"されていたかにも依存する。 詳細は UNIX システムによって異なる。 Linux におけ"
"る詳細を以下で説明する。"

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: build/C/man7/signal.7:692
#, fuzzy
#| msgid ""
#| "If a blocked call to one of the following interfaces is interrupted by a "
#| "signal handler, then the call will be automatically restarted after the "
#| "signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
#| "call will fail with the error B<EINTR>:"
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call is automatically restarted after the signal "
"handler returns if the B<SA_RESTART> flag was used; otherwise the call fails "
"with the error B<EINTR>:"
msgstr ""
"以下のインターフェイスのいずれかの呼び出しが停止している間に シグナルハンド"
"ラーにより割り込まれた場合、 B<SA_RESTART> フラグが使用されていれば、シグナル"
"ハンドラーが返った後に その呼び出しは自動的に再スタートされることになる。 そ"
"れ以外の場合は、その呼び出しはエラー B<EINTR> で失敗することになる。"

#. type: Plain text
#: build/C/man7/signal.7:708
#, fuzzy
#| msgid ""
#| "B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  "
#| "calls on \"slow\" devices.  A \"slow\" device is one where the I/O call "
#| "may block for an indefinite time, for example, a terminal, pipe, or "
#| "socket.  (A disk is not a slow device according to this definition.)  A "
#| "B<read>(2)  on an B<eventfd>(2), B<signalfd>(2), B<timerfd>(2), "
#| "B<fanotify>(7), or B<inotify>(7)  file descriptor is also considered to "
#| "be a \"slow\" operation.  (Before Linux 3.8, reads from an B<inotify>(7)  "
#| "file descriptor were not restartable; when interrupted by a signal "
#| "handler, B<read>(2)  always failed with the error B<EINTR>.)  If an I/O "
#| "call on a slow device has already transferred some data by the time it is "
#| "interrupted by a signal handler, then the call will return a success "
#| "status (normally, the number of bytes transferred)."
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  If an I/O "
"call on a slow device has already transferred some data by the time it is "
"interrupted by a signal handler, then the call will return a success status "
"(normally, the number of bytes transferred).  Note that a (local) disk is "
"not a slow device according to this definition; I/O operations on disk "
"devices are not interrupted by signals."
msgstr ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), B<ioctl>(2)  の「遅い "
"(slow)」デバイスに対する呼び出し。 ここでいう「遅い」デバイスとは、I/O 呼び出"
"しが無期限に停止 (block) する 可能性のあるデバイスのことで、例としては端末、"
"パイプ、ソケットがある (この定義では、ディスクは遅いデバイスではない)。 "
"B<eventfd>(2), B<signalfd>(2), B<timerfd>(2), B<fanotify>(7), B<inotify>(7) "
"のファイルディスクリプターに対する B<read>(2) も「遅い」操作と考えられる。 "
"(Linux 3.8 より前であｈ， B<inotify>(7) ファイルディスクリプターからの読み出"
"しは再開できなかった。シグナルハンドラーによって割り込まれた場合、 "
"B<read>(2) は常にエラー B<EINTR> で失敗していた。) 遅いデバイスに対する I/O "
"呼び出しが、 シグナルハンドラーにより割り込まれた時点までに何らかのデータを "
"すでに転送していれば、呼び出しは成功ステータス (通常は、転送されたバイト数) "
"を返すことだろう。"

#. type: Plain text
#: build/C/man7/signal.7:712
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""
"停止 (block) する可能性のある B<open>(2)  (例えば、FIFO のオープン時; "
"B<fifo>(7)  参照)。"

#. type: Plain text
#: build/C/man7/signal.7:719
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:737
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), "
"unless a timeout has been set on the socket (see below)."
msgstr ""
"ソケットインターフェイス: B<accept>(2), B<connect>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), "
"B<sendmsg>(2).  但し、ソケットにタイムアウトが設定されていない場合 (下記参"
"照)。"

#. type: Plain text
#: build/C/man7/signal.7:747
msgid ""
"File locking interfaces: B<flock>(2)  and the B<F_SETLKW> and "
"B<F_OFD_SETLKW> operations of B<fcntl>(2)"
msgstr ""
"ファイルロック用インターフェイス: B<flock>(2), B<fcntl>(2) の B<F_SETLKW> と "
"B<F_OFD_SETLKW> 操作。"

#. type: Plain text
#: build/C/man7/signal.7:754
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""
"POSIX メッセージキューインターフェイス: B<mq_receive>(3), "
"B<mq_timedreceive>(3), B<mq_send>(3), B<mq_timedsend>(3)."

#.  commit 72c1bbf308c75a136803d2d76d0e18258be14c7a
#. type: Plain text
#: build/C/man7/signal.7:761
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""
"B<futex>(2)  B<FUTEX_WAIT> (Linux 2.6.22 以降; それ以前は常に B<EINTR> で失敗"
"していた)。"

#. type: Plain text
#: build/C/man7/signal.7:763
msgid "B<getrandom>(2)."
msgstr "B<getrandom>(2)."

#. type: Plain text
#: build/C/man7/signal.7:767
msgid "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3), and related APIs."
msgstr "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3) と関連 API。"

#. type: Plain text
#: build/C/man7/signal.7:770
msgid "B<futex>(2)  B<FUTEX_WAIT_BITSET>."
msgstr ""

#.  as a consequence of the 2.6.22 changes in the futex() implementation
#. type: Plain text
#: build/C/man7/signal.7:779
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""
"POSIX セマフォインターフェイス: B<sem_wait>(3), B<sem_timedwait>(3)  (Linux "
"2.6.22 以降; それ以前は常に B<EINTR> で失敗していた)。"

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: build/C/man7/signal.7:788
#, fuzzy
#| msgid ""
#| "B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
#| "with B<EINTR>)."
msgid ""
"B<read>(2)  from an B<inotify>(7)  file descriptor (since Linux 3.8; "
"beforehand, always failed with B<EINTR>)."
msgstr ""
"B<futex>(2)  B<FUTEX_WAIT> (Linux 2.6.22 以降; それ以前は常に B<EINTR> で失敗"
"していた)。"

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: build/C/man7/signal.7:798
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""
"以下のインターフェイスは、 B<SA_RESTART> を使っているどうかに関わらず、シグナ"
"ルハンドラーにより割り込まれた後、 再スタートすることは決してない。 これら"
"は、シグナルハンドラーにより割り込まれると、常にエラー B<EINTR> で失敗する。"

#. type: Plain text
#: build/C/man7/signal.7:812 build/C/man7/signal.7:885
msgid ""
"\"Input\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<accept>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2)  (also with a non-NULL I<timeout> argument), "
"and B<recvmsg>(2)."
msgstr ""
"B<setsockopt>(2)  を使ってタイムアウト (B<SO_RCVTIMEO>) が設定されている「入"
"力」ソケットインターフェース: B<accept>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2) (NULL 以外の I<timeout> 引数も指定されている場合), "
"B<recvmsg>(2)"

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:823
#, fuzzy
#| msgid ""
#| "\"Output\" socket interfaces, when a timeout (B<SO_SNDTIMEO>)  has been "
#| "set on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
#| "B<sendto>(2), and B<sendmsg>(2)."
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2)."
msgstr ""
"B<setsockopt>(2)  を使ってタイムアウト (B<SO_SNDTIMEO>) が設定されているソ"
"ケットインターフェース: B<connect>(2), B<send>(2), B<sendto>(2), "
"B<sendmsg>(2)"

#. type: Plain text
#: build/C/man7/signal.7:830
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""
"シグナル待ちに使われるインターフェイス: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
#: build/C/man7/signal.7:839
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"ファイルディスクリプター多重インターフェイス: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: build/C/man7/signal.7:847
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""
"System V IPC インターフェイス: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), "
"B<semtimedop>(2)."

#. type: Plain text
#: build/C/man7/signal.7:853
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""
"スリープ用のインターフェイス: B<clock_nanosleep>(2), B<nanosleep>(2), "
"B<usleep>(3)."

#. type: Plain text
#: build/C/man7/signal.7:855
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)."

#. type: Plain text
#: build/C/man7/signal.7:860
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""
"B<sleep>(3)  関数も、ハンドラーにより割り込まれた場合、決して再スタートされる"
"ことはない。 しかし、成功となり、残っている停止時間を返す。"

#. type: SS
#: build/C/man7/signal.7:860
#, no-wrap
msgid "Interruption of system calls and library functions by stop signals"
msgstr "一時停止シグナルによるシステムコールやライブラリ関数への割り込み"

#. type: Plain text
#: build/C/man7/signal.7:869
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""
"Linux では、シグナルハンドラーが設定されていない場合でも、 いくつかのブロッキ"
"ング型のインターフェイスは、 プロセスが一時停止 (stop) シグナルの一つにより停"
"止され、 B<SIGCONT> により再開された後に、エラー B<EINTR> で失敗する可能性が"
"ある。 この挙動は POSIX.1 で認められておらず、他のシステムでは起こらない。"

#. type: Plain text
#: build/C/man7/signal.7:871
msgid "The Linux interfaces that display this behavior are:"
msgstr "この挙動を示す Linux のインターフェイスは以下の通りである。"

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:899
#, fuzzy
#| msgid ""
#| "\"Output\" socket interfaces, when a timeout (B<SO_SNDTIMEO>)  has been "
#| "set on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
#| "B<sendto>(2), and B<sendmsg>(2)."
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2), if a send timeout (B<SO_SNDTIMEO>)  has "
"been set."
msgstr ""
"B<setsockopt>(2)  を使ってタイムアウト (B<SO_SNDTIMEO>) が設定されているソ"
"ケットインターフェース: B<connect>(2), B<send>(2), B<sendto>(2), "
"B<sendmsg>(2)"

#. type: Plain text
#: build/C/man7/signal.7:902
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
#: build/C/man7/signal.7:905
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
#: build/C/man7/signal.7:908
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: build/C/man7/signal.7:915
#, fuzzy
#| msgid ""
#| "Linux 3.7 and earlier: B<read>(2)  from an B<inotify>(7)  file descriptor."
msgid ""
"Linux 3.7 and earlier: B<read>(2)  from an B<inotify>(7)  file descriptor"
msgstr ""
"Linux 3.7 以前: B<inotify>(7)  ファイルディスクリプターからの B<read>(2)."

#. type: Plain text
#: build/C/man7/signal.7:921
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""
"Linux 2.6.21 以前: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."

#. type: Plain text
#: build/C/man7/signal.7:925
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux 2.6.8 以前: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
#: build/C/man7/signal.7:928
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux 2.4 以前: B<nanosleep>(2)."

#. type: Plain text
#: build/C/man7/signal.7:930
msgid "POSIX.1, except as noted."
msgstr "POSIX.1 (注記した内容以外)。"

#. type: Plain text
#: build/C/man7/signal.7:933
msgid ""
"For a discussion of async-signal-safe functions, see B<signal-safety>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:956
msgid ""
"The I</proc/[pid]/task/[tid]/status> file contains various fields that show "
"the signals that a thread is blocking (I<SigBlk>), catching (I<SigCgt>), or "
"ignoring (I<SigIgn>).  (The set of signals that are caught or ignored will "
"be the same across all threads in a process.)  Other fields show the set of "
"pending signals that are directed to the thread (I<SigPnd>)  as well as the "
"set of pending signals that are directed to the process as a whole "
"(I<ShdPnd>).  The corresponding fields in I</proc/[pid]/status> show the "
"information for the main thread.  See B<proc>(5)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:969
msgid ""
"There are six signals that can be delivered as a consequence of a hardware "
"exception: B<SIGBUS>, B<SIGEMT>, B<SIGFPE>, B<SIGILL>, B<SIGSEGV>, and "
"B<SIGTRAP>.  Which of these signals is delivered, for any given hardware "
"exception, is not documented and does not always make sense."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:975
msgid ""
"For example, an invalid memory access that causes delivery of B<SIGSEGV> on "
"one CPU architecture may cause delivery of B<SIGBUS> on another "
"architecture, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:986
msgid ""
"For another example, using the x86 I<int> instruction with a forbidden "
"argument (any number other than 3 or 128)  causes delivery of B<SIGSEGV>, "
"even though B<SIGILL> would make more sense, because of how the CPU reports "
"the forbidden operation to the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:1025
msgid ""
"B<kill>(1), B<clone>(2), B<getrlimit>(2), B<kill>(2), "
"B<pidfd_send_signal>(2), B<restart_syscall>(2), B<rt_sigqueueinfo>(2), "
"B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), "
"B<abort>(3), B<bsd_signal>(3), B<killpg>(3), B<longjmp>(3), "
"B<pthread_sigqueue>(3), B<raise>(3), B<sigqueue>(3), B<sigset>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<swapcontext>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), "
"B<pthreads>(7), B<sigevent>(7)"
msgstr "B<kill>(1), B<clone>(2), B<getrlimit>(2), B<kill>(2), B<pidfd_send_signal>(2), B<restart_syscall>(2), B<rt_sigqueueinfo>(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), B<killpg>(3), B<longjmp>(3), B<pthread_sigqueue>(3), B<raise>(3), B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), B<swapcontext>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), B<pthreads>(7), B<sigevent>(7)"

#. type: TH
#: build/C/man2/signalfd.2:20
#, no-wrap
msgid "SIGNALFD"
msgstr "SIGNALFD"

#. type: Plain text
#: build/C/man2/signalfd.2:23
msgid "signalfd - create a file descriptor for accepting signals"
msgstr "signalfd - シグナル受け付け用のファイルディスクリプターを生成する"

#. type: Plain text
#: build/C/man2/signalfd.2:25
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr "B<#include E<lt>sys/signalfd.hE<gt>>"

#. type: Plain text
#: build/C/man2/signalfd.2:27
msgid ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/signalfd.2:38
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""
"B<signalfd>()  は、呼び出し元宛てのシグナルを受け付けるために使用されるファイ"
"ル ディスクリプターを生成する。 この方法はシグナルハンドラーや "
"B<sigwaitinfo>(2)  を用いる方法の代わりとなるものであり、このファイルディスク"
"リプターを B<select>(2), B<poll>(2), B<epoll>(7)  で監視できるという利点があ"
"る。"

#. type: Plain text
#: build/C/man2/signalfd.2:58
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""
"I<mask> 引数には、呼び出し元がこのファイルディスクリプター経由で受け付けた"
"い シグナル集合を指定する。この引数で指定するシグナル集合の内容は、 "
"B<sigsetops>(3)  で説明されているマクロを使って初期化することができる。 通"
"常、ファイルディスクリプター経由で受信するシグナル集合は、 そのシグナルがデ"
"フォルトの配送方法に基いて処理されるのを防ぐために、 B<sigprocmask>(2)  を"
"使ってブロックしておくべきである。 シグナル B<SIGKILL> と B<SIGSTOP> を "
"signalfd ファイルディスクリプター経由で受信することはできない。 これらのシグ"
"ナルが I<mask> で指定された場合には黙って無視される。"

#. type: Plain text
#: build/C/man2/signalfd.2:72
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that file descriptor.  "
"If I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that file descriptor."
msgstr ""
"I<fd> 引数が -1 の場合、 B<signalfd>()  は新しいファイルディスクリプターを"
"生成し、 I<mask> で指定されたシグナル集合をそのファイルディスクリプターに関連"
"付ける。 I<fd> 引数が -1 以外の場合、 I<fd> には有効な既存の signalfd ファ"
"イルディスクリプターを指定しなければならず、 そのディスクリプターに関連付けら"
"れているシグナル集合は I<mask> を使って置き換えられる。"

#. type: Plain text
#: build/C/man2/signalfd.2:77
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<signalfd>():"
msgstr ""
"Linux 2.6.27 以降では、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<signalfd>()  の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/signalfd.2:77
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr "B<SFD_NONBLOCK>"

#. type: TP
#: build/C/man2/signalfd.2:87
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr "B<SFD_CLOEXEC>"

#. type: Plain text
#: build/C/man2/signalfd.2:104
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""
"B<signalfd>()  が返すファイルディスクリプターは以下の操作をサポートしている。"

#. type: Plain text
#: build/C/man2/signalfd.2:123
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr ""
"I<mask> に指定されているシグナルのうち一つ以上がそのプロセスに対して 処理待"
"ち (pending) であれば、それらのシグナルの情報が B<read>(2)  に渡されたバッ"
"ファーを使って、 I<signalfd_siginfo> 構造体に格納されて返される。 "
"B<read>(2)  は、バッファーに格納可能な範囲でできるだけ多くの処理待ちのシグナ"
"ルに ついての情報を返す。 バッファーは最低でも I<sizeof(struct "
"signalfd_siginfo)> バイトの大きさがなければならない。 B<read>(2)  の返り値は"
"読み出されたトータルのバイト数である。"

#. type: Plain text
#: build/C/man2/signalfd.2:131
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""
"B<read>(2)  が行われた結果、シグナルは消費され、 これらのシグナルはそのプロセ"
"スに対しては処理待ちではなくなる (つまり、シグナルハンドラーで捕捉されること"
"もなく、 B<sigwaitinfo>(2)  を使って受け取ることもできなくなる)。"

#. type: Plain text
#: build/C/man2/signalfd.2:142
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""
"I<mask> に指定されているシグナルがそのプロセスに対して一つも処理待ちでなけれ"
"ば、 B<read>(2)  は、 I<mask> で指定されたシグナルのうちいずれか一つがそのプ"
"ロセスに対して発生するまで 停止 (block) する、もしくはファイルディスクリプ"
"ターが非停止 (nonblocking)  に設定されている場合はエラー B<EAGAIN> で失敗す"
"る。"

#. type: Plain text
#: build/C/man2/signalfd.2:155
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""
"I<mask> に指定されたシグナルのうち一つ以上がそのプロセスに対して処理待ちであ"
"れば、 ファイルディスクリプターは読み出し可能となる (B<select>(2)  の "
"I<readfds> 引数や B<poll>(2)  の B<POLLIN> フラグ)。"

#. type: Plain text
#: build/C/man2/signalfd.2:162
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"signalfd ファイルディスクリプターは、これ以外のファイルディスクリプター 多重 "
"API である B<pselect>(2), B<ppoll>(2), B<epoll>(7)  もサポートしている。"

#. type: Plain text
#: build/C/man2/signalfd.2:167
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"ファイルディスクリプターがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ signalfd オブジェクトに関連付けられたファイルディスクリプターが全"
"て クローズされると、そのオブジェクト用の資源がカーネルにより解放される。"

#. type: SS
#: build/C/man2/signalfd.2:167
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr "signalfd_siginfo 構造体"

#. type: Plain text
#: build/C/man2/signalfd.2:173
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""
"signalfd ファイルディスクリプターからの B<read>(2)  で返される "
"I<signalfd_siginfo> 構造体のフォーマットは以下の通りである。"

#.  ssi_trapno is unused on most arches
#.  ssi_addr_lsb: commit b8aeec34175fc8fe8b0d40efea4846dfc1ba663e
#. type: Plain text
#: build/C/man2/signalfd.2:202
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* Signal number */\n"
"    int32_t  ssi_errno;    /* Error number (unused) */\n"
"    int32_t  ssi_code;     /* Signal code */\n"
"    uint32_t ssi_pid;      /* PID of sender */\n"
"    uint32_t ssi_uid;      /* Real UID of sender */\n"
"    int32_t  ssi_fd;       /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;     /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;   /* Trap number that caused signal */\n"
"    int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* System CPU time consumed\n"
"                              (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* Address that generated signal\n"
"                              (for hardware-generated signals) */\n"
"    uint16_t ssi_addr_lsb; /* Least significant bit of address\n"
"                              (SIGBUS; since Linux 2.6.37)\n"
"    uint8_t  pad[I<X>];       /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* シグナル番号 */\n"
"    int32_t  ssi_errno;    /* エラー番号 (未使用) */\n"
"    int32_t  ssi_code;     /* シグナルコード */\n"
"    uint32_t ssi_pid;      /* 送信元の PID */\n"
"    uint32_t ssi_uid;      /* 送信元の実 UID */\n"
"    int32_t  ssi_fd;       /* ファイルディスクリプター (SIGIO) */\n"
"    uint32_t ssi_tid;      /* カーネルタイマー ID (POSIX タイマー)\n"
"    uint32_t ssi_band;     /* Band イベント (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* POSIX タイマーのオーバーラン回数 */\n"
"    uint32_t ssi_trapno;   /* シグナルの原因となったトラップ番号 */\n"
"    int32_t  ssi_status;   /* 終了ステータスかシグナル (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* sigqueue(3) から送られた整数 */\n"
"    uint64_t ssi_ptr;      /* sigqueue(3) から送られたポインター */\n"
"    uint64_t ssi_utime;    /* 消費したユーザー CPU 時間 (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* 消費したシステム CPU 時間 (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* シグナルを生成したアドレス\n"
"                              (ハードウェアが生成したシグナルの場合) */\n"
"    uint16_t ssi_addr_lsb; /* アドレスの最下位ビット (LSB)\n"
"                              (SIGBUS; Linux 2.6.37 以降) */\n"
"    uint8_t  pad[I<X>];    /* pad の大きさは 128 バイト\n"
"                              (将来のフィールド追加用の場所の確保) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/signalfd.2:225
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""
"I<signalfd_siginfo> 構造体の各フィールドは、 I<siginfo_t> 構造体の同じような"
"名前のフィールドと同様である。 I<siginfo_t> 構造体については "
"B<sigaction>(2)  に説明がある。 返された I<signalfd_siginfo> 構造体の全ての"
"フィールドがあるシグナルに対して有効なわけではない。 どのフィールドが有効か"
"は、 I<ssi_code> フィールドで返される値から判定することができる。 このフィー"
"ルドは I<siginfo_t> の I<si_code> フィールドと同様である。詳細は "
"B<sigaction>(2)  を参照。"

#. type: SS
#: build/C/man2/signalfd.2:225 build/C/man2/timerfd_create.2:389
#, no-wrap
msgid "fork(2) semantics"
msgstr "fork(2) での扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:233
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""
"B<fork>(2)  が行われると、子プロセスは signalfd ファイルディスクリプターのコ"
"ピーを 継承する。 子プロセスでこのファイルディスクリプターから B<read>(2)  を"
"行うと、子プロセスに対するキューに入っているシグナルに関する 情報が返される。"

#. type: SS
#: build/C/man2/signalfd.2:233
#, fuzzy, no-wrap
#| msgid "Operating on a timer file descriptor"
msgid "Semantics of file descriptor passing"
msgstr "タイマーファイルディスクリプターに対する操作"

#. type: Plain text
#: build/C/man2/signalfd.2:242
msgid ""
"As with other file descriptors, signalfd file descriptors can be passed to "
"another process via a UNIX domain socket (see B<unix>(7)).  In the receiving "
"process, a B<read>(2)  from the received file descriptor will return "
"information about signals queued to that process."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:242 build/C/man2/timerfd_create.2:401
#, no-wrap
msgid "execve(2) semantics"
msgstr "execve(2) での扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:254
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""
"他のファイルディスクリプターと全く同様に、 signalfd ファイルディスクリプター"
"も B<execve>(2)  の前後でオープンされたままとなる。但し、そのファイルディスク"
"リプターに close-on-exec のマーク (B<fcntl>(2)  参照) が付いている場合はク"
"ローズされる。 B<execve>(2)  の前に読み出し可能となっていた全てのシグナルは新"
"しく起動されたプログラム でも引き続き読み出し可能である (これは伝統的なシグナ"
"ルの扱いと同じであり、 処理待ちのブロックされたシグナルは B<execve>(2)  の前"
"後で処理待ちのままとなる)。"

#. type: SS
#: build/C/man2/signalfd.2:254
#, no-wrap
msgid "Thread semantics"
msgstr "スレッドでの扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:265
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""
"マルチスレッドプログラムにおける signalfd ファイルディスクリプターの扱いは シ"
"グナルの標準的な扱いと全く同じである。 言い換えると、あるスレッドが signalfd "
"ファイルディスクリプターから 読み出しを行うと、そのスレッド自身宛てのシグナル"
"とプロセス (すなわち スレッドグループ全体) 宛てのシグナルが読み出される。 (ス"
"レッドは同じプロセスの他のスレッド宛てのシグナルを読み出すことはできない。)"

#. type: SS
#: build/C/man2/signalfd.2:265
#, fuzzy, no-wrap
#| msgid "fork(2) semantics"
msgid "epoll(7) semantics"
msgstr "fork(2) での扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:291
msgid ""
"If a process adds (via B<epoll_ctl>(2))  a signalfd file descriptor to an "
"B<epoll>(7)  instance, then B<epoll_wait>(2)  returns events only for "
"signals sent to that process.  In particular, if the process then uses "
"B<fork>(2)  to create a child process, then the child will be able to "
"B<read>(2)  signals that are sent to it using the signalfd file descriptor, "
"but B<epoll_wait>(2)  will B<not> indicate that the signalfd file descriptor "
"is ready.  In this scenario, a possible workaround is that after the "
"B<fork>(2), the child process can close the signalfd file descriptor that it "
"inherited from the parent process and then create another signalfd file "
"descriptor and add it to the epoll instance.  Alternatively, the parent and "
"the child could delay creating their (separate) signalfd file descriptors "
"and adding them to the epoll instance until after the call to B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:305
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<signalfd>()  は signalfd ファイルディスクリプターを返す。 返さ"
"れるファイルディスクリプターは、 I<fd> が -1 の場合は新規のファイルディスクリ"
"プターであり、 I<fd> が有効な signalfd ファイルディスクリプターだった場合は "
"I<fd> 自身である。 エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定"
"する。"

#. type: Plain text
#: build/C/man2/signalfd.2:311
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr ""
"ファイルディスクリプター I<fd> が有効なファイルディスクリプターでない。"

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: build/C/man2/signalfd.2:319
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr "I<fd> が有効な signalfd ファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/signalfd.2:326 build/C/man2/timerfd_create.2:437
msgid ""
"I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""
"I<flags> が無効である。もしくは、Linux 2.6.26 以前の場合には I<flags> が 0 以"
"外である。"

#. type: Plain text
#: build/C/man2/signalfd.2:339
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""
"新しい signalfd ファイルディスクリプターを生成するのに十分なメモリーがなかっ"
"た。"

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/signalfd.2:347
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""
"B<signalfd>()  はカーネル 2.6.22 以降の Linux で利用可能である。 正しく動作す"
"る glibc 側のサポートはバージョン 2.8 以降で提供されている。 B<signalfd4>()  "
"システムコール (「注意」参照) は カーネル 2.6.27 以降の Linux で利用可能であ"
"る。"

#. type: Plain text
#: build/C/man2/signalfd.2:352
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr "B<signalfd>()  と B<signalfd4>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/signalfd.2:366
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different file descriptors ready.)  If a signal appears in the I<mask> of "
"more than one of the file descriptors, then occurrences of that signal can "
"be read (once) from any one of the file descriptors."
msgstr ""
"一つのプロセスは複数の signalfd ファイルディスクリプターを生成することができ"
"る。 これにより、異なるファイルディスクリプターで異なるシグナルを受け取ること"
"が できる (この機能は B<select>(2), B<poll>(2), B<epoll>(7)  を使ってファイル"
"ディスクリプターを監視する場合に有用かもしれない。 異なるシグナルが到着する"
"と、異なるファイルディスクリプターが利用可能に なるからだ)。 一つのシグナルが"
"二つ以上のファイルディスクリプターの I<mask> に含まれている場合、そのシグナル"
"の発生はそのシグナルを I<mask> に含むファイルディスクリプターのうちいずれか一"
"つから読み出すことができる。"

#. type: Plain text
#: build/C/man2/signalfd.2:374
#, fuzzy
#| msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgid ""
"Attempts to include B<SIGKILL> and B<SIGSTOP> in I<mask> are silently "
"ignored."
msgstr "B<SIGKILL> と B<SIGSTOP> を待とうとした場合、黙って無視される。"

#. type: Plain text
#: build/C/man2/signalfd.2:383
msgid ""
"The signal mask employed by a signalfd file descriptor can be viewed via the "
"entry for the corresponding file descriptor in the process's I</proc/[pid]/"
"fdinfo> directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:383
#, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:392
msgid ""
"The signalfd mechanism can't be used to receive signals that are "
"synchronously generated, such as the B<SIGSEGV> signal that results from "
"accessing an invalid memory address or the B<SIGFPE> signal that results "
"from an arithmetic error.  Such signals can be caught only via signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:413
msgid ""
"As described above, in normal usage one blocks the signals that will be "
"accepted via B<signalfd>().  If spawning a child process to execute a helper "
"program (that does not need the signalfd file descriptor), then, after the "
"call to B<fork>(2), you will normally want to unblock those signals before "
"calling B<execve>(2), so that the helper program can see any signals that it "
"expects to see.  Be aware, however, that this won't be possible in the case "
"of a helper program spawned behind the scenes by any library function that "
"the program may call.  In such cases, one must fall back to using a "
"traditional signal handler that writes to a file descriptor monitored by "
"B<select>(2), B<poll>(2), or B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:423
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""
"実際の Linux のシステムコールでは I<size_t sizemask> という引数が追加で必要"
"である。この引数で I<mask> のサイズを指定する。 glibc の B<signalfd>()  "
"ラッパー関数にはこの引数は含まれず、 ラッパー関数が必要な値を計算して内部で"
"呼び出すシステムコールに提供する。"

#. type: Plain text
#: build/C/man2/signalfd.2:439
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""
"下層にある Linux システムコールは二種類あり、 B<signalfd>()  と、もっと新し"
"い B<signalfd4>()  である。 B<signalfd>()  は I<flags> 引数を実装していな"
"い。 B<signalfd4>()  では上記の値の I<flags> が実装されている。 glibc 2.9 以"
"降では、 B<signalfd>()  のラッパー関数は、 B<signalfd4>()  が利用可能であれ"
"ば、これを使用する。"

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: build/C/man2/signalfd.2:447
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""
"カーネル 2.6.25 より前では、 B<sigqueue>(3)  により送信されたシグナルと一緒に"
"渡されるデータでは、フィールド I<ssi_ptr> と I<ssi_int> は設定されない。"

#. type: Plain text
#: build/C/man2/signalfd.2:457
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""
"下記のプログラムは、シグナル B<SIGINT> と B<SIGQUIT> を signalfd ファイルディ"
"スクリプター経由で受信する。 シグナル B<SIGQUIT> 受信後にプログラムは終了す"
"る。 以下に示すシェルセッションにこのプログラムの使い方を示す。"

#. type: Plain text
#: build/C/man2/signalfd.2:468
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<\\(haC>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<\\(haC>\n"
"Got SIGINT\n"
"B<\\(ha\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""
"$B< ./signalfd_demo>\n"
"B<\\(haC>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<\\(haC>\n"
"Got SIGINT\n"
"B<\\(ha\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"

#. type: Plain text
#: build/C/man2/signalfd.2:478
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/signalfd.2:489
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/signalfd.2:493
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"

#. type: Plain text
#: build/C/man2/signalfd.2:496
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"

#. type: Plain text
#: build/C/man2/signalfd.2:499
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:503
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:508
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(fdsi));\n"
"        if (s != sizeof(fdsi))\n"
"            handle_error(\"read\");\n"
msgstr ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(fdsi));\n"
"        if (s != sizeof(fdsi))\n"
"            handle_error(\"read\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:519
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/signalfd.2:533
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/sigpause.3:25
#, no-wrap
msgid "SIGPAUSE"
msgstr "SIGPAUSE"

#. type: Plain text
#: build/C/man3/sigpause.3:28
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr "sigpause - ブロックされたシグナルをアトミックに解放して割り込みを待つ"

#. type: Plain text
#: build/C/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD (but see NOTES) */>\n"
msgstr "B<int sigpause(int >I<sigmask>B<);  /* BSD (ただし「備考」を参照) */>\n"

#. type: Plain text
#: build/C/man3/sigpause.3:35
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"

#. type: Plain text
#: build/C/man3/sigpause.3:41
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr "この関数を使わないこと。 代わりに B<sigsuspend>(2)  を使うこと。"

#. type: Plain text
#: build/C/man3/sigpause.3:48
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes "
"the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""
"関数 B<sigpause>()  はシグナルを待つように設計されている。 この関数はプロセス"
"のシグナルマスク (ブロックされたシグナルのセット) を変更し、 シグナルが到着す"
"るのを待つ。 シグナルが到着すると、シグナルマスクは元に戻される。"

#. type: Plain text
#: build/C/man3/sigpause.3:56
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""
"B<sigpause>()  が返った場合、この関数はシグナルによって割り込まれている。 返"
"り値は -1 で、 I<errno> は B<EINTR> に設定される。"

#. type: tbl table
#: build/C/man3/sigpause.3:66
#, no-wrap
msgid "B<sigpause>()"
msgstr "B<sigpause>()"

#. type: Plain text
#: build/C/man3/sigpause.3:81
msgid ""
"The System V version of B<sigpause>()  is standardized in POSIX.1-2001.  It "
"is also specified in POSIX.1-2008, where it is marked obsolete."
msgstr "System V 版の B<sigpause>()  は POSIX.1-2001 で標準化されている。 POSIX.1-2008 でも規定されているが、ここでは廃止予定 (obsolete) 扱いとなっている。"

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: build/C/man3/sigpause.3:98
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the B<\\"
"%sigsuspend>(2)  function, that takes a I<sigset_t\\ *> argument (instead of "
"an I<int>)."
msgstr ""
"この関数の古典的な BSD 版は 4.2BSD で登場した。 この関数はプロセスのシグナル"
"マスクを I<sigmask> に設定する。 UNIX 95 では BSD 版と互換性のない System V "
"版のこの関数が標準化された。 UNIX 95 版は、指定されたシグナル I<sig> をプロセ"
"スのシグナルマスクから削除するだけである。 同じ名前で互換性のない 2 つの関数"
"があるという不幸な事態は、 B<\\%sigsuspend>(2)  関数によって解消された。 この"
"関数は (I<int> の代わりに)  B<sigset_t\\ *> 引数をとる。"

#. type: Plain text
#: build/C/man3/sigpause.3:101
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""
"Linux では、このルーチンは Sparc (sparc64) アーキテクチャーでのみ システム"
"コールとなっている。"

#.  Libc4 and libc5 know only about the BSD version.
#. type: Plain text
#: build/C/man3/sigpause.3:116
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used, and feature test macros must be defined as follows to "
"obtain the declaration:"
msgstr "機能検査マクロ B<_BSD_SOURCE> が定義され、 B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_GNU_SOURCE>, B<_SVID_SOURCE> のいずれも定義されていない場合、 glibc は BSD 版を使う。 それ以外の場合には、System V 版を使用し、この場合には宣言を得るためには以下のように機能検査マクロを定義しなければならない。"

#.  || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man3/sigpause.3:120
msgid "Since glibc 2.26: _XOPEN_SOURCE E<gt>= 500"
msgstr "glibc 2.26 以降: _XOPEN_SOURCE E<gt>= 500"

#. type: Plain text
#: build/C/man3/sigpause.3:122
msgid "Glibc 2.25 and earlier: _XOPEN_SOURCE"
msgstr "glibc 2.25 以前: _XOPEN_SOURCE"

#
#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: build/C/man3/sigpause.3:133
msgid ""
"Since glibc 2.19, only the System V version is exposed by I<E<lt>signal."
"hE<gt>>; applications that formerly used the BSD B<sigpause>()  should be "
"amended to use B<sigsuspend>(2)."
msgstr "glibc 2.19 以降では、 I<E<lt>signal.hE<gt>> では System V 版だけが公開される。 BSD 版の B<sigpause>() を使用していたアプリケーションは B<sigsuspend>(2) を使用するように修正すべきである。"

#. type: Plain text
#: build/C/man3/sigpause.3:141
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"

#. type: TH
#: build/C/man2/sigpending.2:29
#, no-wrap
msgid "SIGPENDING"
msgstr "SIGPENDING"

#. type: Plain text
#: build/C/man2/sigpending.2:32
msgid "sigpending, rt_sigpending - examine pending signals"
msgstr "sigpending, rt_sigpending - 処理待ちのシグナルの検査"

#. type: Plain text
#: build/C/man2/sigpending.2:36
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr "B<int sigpending(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man2/sigpending.2:45
msgid "B<sigpending>(): _POSIX_C_SOURCE"
msgstr "B<sigpending>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man2/sigpending.2:52
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""
"B<sigpending>()  は、呼び出し元のスレッドへの配送を待っている (pending) シグ"
"ナル集合 (すなわち、禁止中に発生したシグナル) を返す。 処理待ちのシグナルのマ"
"スクが I<set> に格納される。"

#. type: Plain text
#: build/C/man2/sigpending.2:58
msgid ""
"B<sigpending>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"B<sigpending>() は成功した場合 0 を返す。 エラーの場合、 -1 を返し、I<errno> "
"にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/sigpending.2:63
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"I<set> が指しているメモリーが、プロセスのアドレス空間の有効な部分ではない。"

#. type: Plain text
#: build/C/man2/sigpending.2:65 build/C/man2/sigprocmask.2:130
#: build/C/man3/sigqueue.3:131 build/C/man3/sigsetops.3:156
#: build/C/man2/sigsuspend.2:87 build/C/man3/sigwait.3:100
#: build/C/man2/sigwaitinfo.2:136 build/C/man2/timer_create.2:244
#: build/C/man2/timer_delete.2:69 build/C/man2/timer_getoverrun.2:99
#: build/C/man2/timer_settime.2:209
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/sigpending.2:73
msgid ""
"If a signal is both blocked and has a disposition of \"ignored\", it is "
"I<not> added to the mask of pending signals when generated."
msgstr ""
"シグナルが禁止 (ブロック) されており、かつ配送方法が \"ignored\" (無視) に"
"なっている場合、そのシグナルが発生した場合に処理待ちシグナルのマスクにそのシ"
"グナルは追加I<されない>。"

#. type: Plain text
#: build/C/man2/sigpending.2:78
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""
"あるスレッドに対する処理待ちのシグナルの集合は、 そのスレッド自体への処理待ち"
"のシグナル集合と、プロセス全体への処理待ちの シグナル集合をあわせたものであ"
"る。 B<signal>(7)  参照。"

#.  This argument is currently required to be less than or equal to
#.  .IR sizeof(sigset_t)
#.  (or the error
#.  .B EINVAL
#.  results).
#. type: Plain text
#: build/C/man2/sigpending.2:112
msgid ""
"The original Linux system call was named B<sigpending>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> argument supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigpending>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  The glibc B<sigpending>()  wrapper function hides "
"these details from us, transparently calling B<rt_sigpending>()  when the "
"kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:118
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""
"バージョン 2.2.1 以前の glibc では、 B<sigpending>()  のラッパー関数に、処理"
"待ちのリアルタイムシグナルに関する情報が 正しく返されないというバグがある。"

#. type: Plain text
#: build/C/man2/sigpending.2:126
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigprocmask.2:29
#, no-wrap
msgid "SIGPROCMASK"
msgstr "SIGPROCMASK"

#. type: Plain text
#: build/C/man2/sigprocmask.2:32
msgid "sigprocmask, rt_sigprocmask - examine and change blocked signals"
msgstr "sigprocmask, rt_sigprocmask - 禁止するシグナルの確認と変更"

#. type: Plain text
#: build/C/man2/sigprocmask.2:38
#, no-wrap
msgid ""
"/* Prototype for the glibc wrapper function */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"
msgstr ""
"/* Prototype for the glibc wrapper function */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: build/C/man2/sigprocmask.2:42
#, no-wrap
msgid ""
"/* Prototype for the underlying system call */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t >I<sigsetsize>B<);>\n"
msgstr ""
"/* Prototype for the underlying system call */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t >I<sigsetsize>B<);>\n"

#. type: Plain text
#: build/C/man2/sigprocmask.2:46
#, no-wrap
msgid ""
"/* Prototype for the legacy system call (deprecated) */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"
msgstr ""
"/* Prototype for the legacy system call (deprecated) */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: build/C/man2/sigprocmask.2:56
msgid "B<sigprocmask>(): _POSIX_C_SOURCE"
msgstr "B<sigprocmask>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man2/sigprocmask.2:65
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""
"B<sigprocmask>()  を使うと、呼び出したスレッドのシグナルマスクの取得/変更がで"
"きる。 シグナルマスクは、呼び出し元に対して現在配送が禁止されているシグナル"
"の 集合のことである (詳細については B<signal>(7)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:69
msgid ""
"The behavior of the call is dependent on the value of I<how>, as follows."
msgstr "このコールの動作は I<how> の値によって決まる:"

#. type: TP
#: build/C/man2/sigprocmask.2:69
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr "B<SIG_BLOCK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:74
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""
"禁止されたシグナルの集合は現在の値と I<set> 引数を結合したものとなる。"

#. type: TP
#: build/C/man2/sigprocmask.2:74
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr "B<SIG_UNBLOCK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:80
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""
"現在禁止されているシグナルの集合から I<set> にあるシグナルを取り除く。禁止さ"
"れていないシグナルを取り除こうと することも認められている。"

#. type: TP
#: build/C/man2/sigprocmask.2:80
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr "B<SIG_SETMASK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:84
msgid "The set of blocked signals is set to the argument I<set>."
msgstr "禁止されているシグナルの集合に I<set> 引数を設定する。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:89
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""
"I<oldset> が NULL でなければ、シグナルマスクの今までの値を I<oldset> に格納す"
"る。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:98
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""
"I<set> が NULL であれば、シグナルマスクは変更されない (すなわち、 I<how> は無"
"視される)。 I<set> の値にかかわらず、現在のシグナルマスクの値は I<oldset> に"
"入れて返される (但し、 I<oldset> が NULL でない場合)。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:103
msgid ""
"A set of functions for modifying and inspecting variables of type "
"I<sigset_t> (\"signal sets\") is described in B<sigsetops>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:108
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""
"マルチスレッドのプロセスで B<sigprocmask>()  を使用した場合の動作は規定されて"
"いない。 B<pthread_sigmask>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:114
msgid ""
"B<sigprocmask>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"B<sigprocmask>() は成功した場合 0 を返す。 エラーの場合、 -1 を返し、 "
"I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:122
msgid ""
"The I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr ""
"引数 I<set> か I<oldset> がプロセスに割り当てられたアドレス空間の外を指して"
"いる。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:128
msgid ""
"Either the value specified in I<how> was invalid or the kernel does not "
"support the size passed in I<sigsetsize.>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:134
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""
"B<SIGKILL> や B<SIGSTOP> を禁止することはできない。 禁止しようとしても黙って"
"無視される。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:136
msgid "Each of the threads in a process has its own signal mask."
msgstr "プロセス内の各スレッドはそれぞれ専用のシグナルマスクを持つ。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:156
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""
"シグナル B<SIGBUS>, B<SIGFPE>, B<SIGILL>, B<SIGSEGV> が禁止されている間に生成"
"された場合で、 そのシグナルが B<kill>(2), B<sigqueue>(3), B<raise>(3)  によっ"
"て生成されたものでないときには、 その後の動作は未定義である。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:167
msgid ""
"Note that it is permissible (although not very useful) to specify both "
"I<set> and I<oldset> as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:177
msgid ""
"The kernel's definition of I<sigset_t> differs in size from that used by the "
"C library.  In this manual page, the former is referred to as "
"I<kernel_sigset_t> (it is nevertheless named I<sigset_t> in the kernel "
"sources)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:185
msgid ""
"The glibc wrapper function for B<sigprocmask>()  silently ignores attempts "
"to block the two real-time signals that are used internally by the NPTL "
"threading implementation.  See B<nptl>(7)  for details."
msgstr ""

#.  sizeof(kernel_sigset_t) == _NSIG / 8,
#.  which equals to 8 on most architectures, but e.g. on MIPS it's 16.
#. type: Plain text
#: build/C/man2/sigprocmask.2:214
msgid ""
"The original Linux system call was named B<sigprocmask>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> (referred to as I<old_kernel_sigset_t> in this manual page)  "
"type supported by that system call was no longer fit for purpose.  "
"Consequently, a new system call, B<rt_sigprocmask>(), was added to support "
"an enlarged I<sigset_t> type (referred to as I<kernel_sigset_t> in this "
"manual page).  The new system call takes a fourth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the signal sets in I<set> "
"and I<oldset>.  This argument is currently required to have a fixed "
"architecture specific value (equal to I<sizeof(kernel_sigset_t)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:221
msgid ""
"The glibc B<sigprocmask>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigprocmask>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:232
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"

#. type: TH
#: build/C/man3/sigqueue.3:28
#, no-wrap
msgid "SIGQUEUE"
msgstr "SIGQUEUE"

#. type: Plain text
#: build/C/man3/sigqueue.3:31
msgid "sigqueue - queue a signal and data to a process"
msgstr "sigqueue - シグナルとデータをプロセスに送る"

#. type: Plain text
#: build/C/man3/sigqueue.3:35
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"

#. type: Plain text
#: build/C/man3/sigqueue.3:43
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man3/sigqueue.3:55
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID "
"is given in I<pid>.  The permissions required to send a signal are the same "
"as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr ""
"B<sigqueue>()  は I<sig> で指定されたシグナルを、PID が I<pid> であるプロセス"
"に送る。 シグナルを送るのに必要な権限は B<kill>(2)  と同じである。 "
"B<kill>(2)  と同様に、ヌルシグナル (0) を使って 指定した PID のプロセスが存在"
"するかをチェックすることができる。"

#. type: Plain text
#: build/C/man3/sigqueue.3:60
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr ""
"I<value> 引数はシグナルと一緒に送るデータの付属アイテムを指定する。 "
"I<value> は (整数またはポインターの値であり) 以下のような型である。"

#. type: Plain text
#: build/C/man3/sigqueue.3:67
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"

#. type: Plain text
#: build/C/man3/sigqueue.3:83
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr ""
"受取先のプロセスに、このシグナルに対するハンドラーを (B<sigaction>(2)  に "
"B<SA_SIGINFO> を指定して) インストールしておくと、 そのハンドラーの第 2 引"
"数に渡される I<siginfo_t> 構造体の I<si_value> フィールドによって、このデータ"
"を取得できる。 さらに、この構造体の I<si_code> フィールドは B<SI_QUEUE> に設"
"定される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:91
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功した場合、 B<sigqueue>()  は 0 を返す。 これは受け取り側プロセスの待ち行"
"列に シグナルが正しく入れられたことを示す。 失敗した場合は -1 が返され、 "
"I<errno> がエラーを表す値に設定される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:102
msgid "I<sig> was invalid."
msgstr "I<sig> が不正である。"

#. type: Plain text
#: build/C/man3/sigqueue.3:108
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr ""
"このプロセスには、受け取り側プロセスにシグナルを送る権限がない。 必要な権限に"
"ついては、 B<kill>(2)  を参照すること。"

#. type: Plain text
#: build/C/man3/sigqueue.3:112
msgid "No process has a PID matching I<pid>."
msgstr "I<pid> にマッチする PID のプロセスがない。"

#. type: Plain text
#: build/C/man3/sigqueue.3:117
msgid ""
"B<sigqueue>()  and the underlying B<rt_sigqueueinfo>()  system call first "
"appeared in Linux 2.2."
msgstr "B<sigqueue>() とその裏で使われる B<rt_sigqueueinfo>() システムコールは Linux 2.2 で初めて登場した。"

#. type: tbl table
#: build/C/man3/sigqueue.3:127
#, no-wrap
msgid "B<sigqueue>()"
msgstr "B<sigqueue>()"

#. type: Plain text
#: build/C/man3/sigqueue.3:139
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr ""
"この関数を呼び出したプロセスにこの関数がシグナルを送ったときに、 シグナルが呼"
"び出し側スレッドにブロックされず、 かつ (シグナルがブロックされなかった、また"
"は B<sigwait>(3)  を使用するのを待っていることにより)  このシグナルを扱うス"
"レッドが何もない場合は、 この関数がリターンする前に、少なくとも そのスレッド"
"に対してシグナルが配送されていなければならない。"

#. type: Plain text
#: build/C/man3/sigqueue.3:156
msgid ""
"On Linux, B<sigqueue>()  is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr "Linux では、 B<sigqueue>() は B<rt_sigqueueinfo>(2)  システムコールを使って実装されている。 両者には 3 番目の引数に違いがあり、 B<rt_sigqueueinfo>(2)  では 3 番目の引数は I<siginfo_t> 構造体である。 I<siginfo_t> 構造体は、シグナルを受信するプロセスのシグナルハンドラーに渡されたり、 シグナル受信プロセスの B<sigtimedwait>(2)  システムコールから返されたりする。 glibc の B<sigqueue>()  ラッパー関数内部では、 この引数 I<uinfo> は以下のように初期化される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:164
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* Argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* Argument supplied to sigqueue() */\n"
msgstr ""
"uinfo.si_signo = sig;      /* Argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* Argument supplied to sigqueue() */\n"

#. type: Plain text
#: build/C/man3/sigqueue.3:174
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigreturn.2:30
#, no-wrap
msgid "SIGRETURN"
msgstr "SIGRETURN"

#. type: Plain text
#: build/C/man2/sigreturn.2:33
msgid ""
"sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame"
msgstr "sigreturn, rt_sigreturn - シグナルハンドラーから返り、スタックを掃除する"

#. type: Plain text
#: build/C/man2/sigreturn.2:35
msgid "B<int sigreturn(...);>"
msgstr "B<int sigreturn(...);>"

#.  See arch/x86/kernel/signal.c::__setup_frame() [in 3.17 source code]
#. type: Plain text
#: build/C/man2/sigreturn.2:45
msgid ""
"If the Linux kernel determines that an unblocked signal is pending for a "
"process, then, at the next transition back to user mode in that process (e."
"g., upon return from a system call or when the process is rescheduled onto "
"the CPU), it creates a new frame on the user-space stack where it saves "
"various pieces of process context (processor status word, registers, signal "
"mask, and signal stack settings)."
msgstr "Linux カーネルがプロセスに対してブロックされていないシグナルが処理待ちと判定した場合、 そのプロセスの次回のユーザーモードへの遷移 (すなわち、システムコールからのリターン時やそのプロセスが CPU に再スケジュールされる際)、カーネルはユーザー空間スタックの新しいフレームを作成し、そこにプロセスコンテキストの種々の値 (プロセッサーのステータスワード、レジスター、シグナルマスク、シグナルスタック設定) を保存する。"

#. type: Plain text
#: build/C/man2/sigreturn.2:52
msgid ""
"The kernel also arranges that, during the transition back to user mode, the "
"signal handler is called, and that, upon return from the handler, control "
"passes to a piece of user-space code commonly called the \"signal trampoline"
"\".  The signal trampoline code in turn calls B<sigreturn>()."
msgstr ""
"また、 カーネルは、 ユーザーモードへの遷移時にシグナルハンドラーが呼び出さ"
"れ、 ハンドラーからのリターン時に、 制御が \"signal trampoline\" と呼ばれる"
"ユーザー空間コードブロックに渡されるように、準備を行う。 signal trampoline の"
"コードが B<sigreturn>() を呼び出す。"

#. type: Plain text
#: build/C/man2/sigreturn.2:67
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching signal stacks (see "
"B<sigaltstack>(2))\\(emin order to invoke the signal handler.  Using the "
"information that was earlier saved on the user-space stack B<sigreturn>()  "
"restores the process's signal mask, switches stacks, and restores the "
"process's context (processor flags and registers, including the stack "
"pointer and instruction pointer), so that the process resumes execution at "
"the point where it was interrupted by the signal."
msgstr "B<sigreturn>()  は、シグナルハンドラーを起動するために行ったことの全て \\(em プロセスのシグナルマスクの変更、 シグナルスタックの切り替え (B<sigaltstack>(2)  参照) \\(em の取り消しを行う。以前にユーザー空間スタックに保存された情報を使って、 B<sigreturn>() はプロセスのシグナルマスクの復元、スタックの切り替え、プロセスのコンテキスト (プロセッサフラグ、レジスター (スタックポインター、命令ポインターを含む)) の復元を行い、 プロセスがシグナルにより割り込まれた場所から実行を再開できるようにする。"

#. type: Plain text
#: build/C/man2/sigreturn.2:70
msgid "B<sigreturn>()  never returns."
msgstr "B<sigreturn>()  が返ることはない。"

#. type: Plain text
#: build/C/man2/sigreturn.2:76
msgid ""
"Many UNIX-type systems have a B<sigreturn>()  system call or near "
"equivalent.  However, this call is not specified in POSIX, and details of "
"its behavior vary across systems."
msgstr ""
"多くの UNIX 系のシステムには B<sigreturn>() システムコールか似たようなシステ"
"ムコールがある。 しかしながら、 このシステムコールは POSIX には規定されておら"
"ず、 その動作の詳細はシステムにより異なる。"

#.  See sysdeps/unix/sysv/linux/sigreturn.c and
#.  signal/sigreturn.c in the glibc source
#. type: Plain text
#: build/C/man2/sigreturn.2:98
msgid ""
"B<sigreturn>()  exists only to allow the implementation of signal handlers.  "
"It should B<never> be called directly.  (Indeed, a simple B<sigreturn>()  "
"wrapper in the GNU C library simply returns -1, with I<errno> set to "
"B<ENOSYS>.)  Details of the arguments (if any) passed to B<sigreturn>()  "
"vary depending on the architecture.  (On some architectures, such as x86-64, "
"B<sigreturn>()  takes no arguments, since all of the information that it "
"requires is available in the stack frame that was previously created by the "
"kernel on the user-space stack.)"
msgstr ""

#.  See, for example, sysdeps/unix/sysv/linux/i386/sigaction.c and
#.  sysdeps/unix/sysv/linux/x86_64/sigaction.c in the glibc (2.20) source.
#. type: Plain text
#: build/C/man2/sigreturn.2:123
msgid ""
"Once upon a time, UNIX systems placed the signal trampoline code onto the "
"user stack.  Nowadays, pages of the user stack are protected so as to "
"disallow code execution.  Thus, on contemporary Linux systems, depending on "
"the architecture, the signal trampoline code lives either in the B<vdso>(7)  "
"or in the C library.  In the latter case, the C library's B<sigaction>(2)  "
"wrapper function informs the kernel of the location of the trampoline code "
"by placing its address in the I<sa_restorer> field of the I<sigaction> "
"structure, and sets the B<SA_RESTORER> flag in the I<sa_flags> field."
msgstr "かつて、 UNIX システムでは signal trampoline コードがユーザースタックに置かれていた。 今日では、 ユーザースタックのページは保護され、 コードの実行は禁止されている。 したがって、 現代の Linux システムでは、 アーキテクチャー依存ではあるが、 signal trampoline コードは B<vdso>(7) 内もしくは C ライブラリ内に置かれる。後者の場合、 C ライブラリの B<sigaction>(2) のラッパー関数は、 trampoline code の場所をそのアドレスを B<sigaction>(2) 構造体の I<sa_restorer> フィールドに設定してカーネルに伝え、 I<sa_flags> フィールドの B<SA_RESTORER> フラグをセットする。"

#. type: Plain text
#: build/C/man2/sigreturn.2:134
msgid ""
"The saved process context information is placed in a I<ucontext_t> structure "
"(see I<E<lt>sys/ucontext.hE<gt>>).  That structure is visible within the "
"signal handler as the third argument of a handler established via "
"B<sigaction>(2)  with the B<SA_SIGINFO> flag."
msgstr "保存されたプロセスコンテキスト情報は I<ucontext_t>構造体に置かれる (I<E<lt>sys/ucontext.hE<gt>> 参照)。 この構造体は、 B<sigaction>(2) の B<SA_SIGINFO> フラグで設定されたシグナルハンドラーの第 3 引数としてシングルハンドラー内で参照できる。"

#. type: Plain text
#: build/C/man2/sigreturn.2:143
msgid ""
"On some other UNIX systems, the operation of the signal trampoline differs a "
"little.  In particular, on some systems, upon transitioning back to user "
"mode, the kernel passes control to the trampoline (rather than the signal "
"handler), and the trampoline code calls the signal handler (and then calls "
"B<sigreturn>()  once the handler returns)."
msgstr ""
"他のいくつかの UNIX システムでは、 signal trampoline の扱いは少し異なる。 特"
"に、 いくつかのシステムでは、 ユーザーモードに戻る際に、 カーネルは制御を (シ"
"グナルハンドラーではなく) trampoline に渡し、 trampoline コードがシグナルハン"
"ドラーを呼び出す (その後ハンドラーが返ると B<sigreturn>() を呼び出す)。"

#. type: Plain text
#: build/C/man2/sigreturn.2:157
msgid ""
"The original Linux system call was named B<sigreturn>().  However, with the "
"addition of real-time signals in Linux 2.2, a new system call, "
"B<rt_sigreturn>()  was added to support an enlarged I<sigset_t> type.  The "
"GNU C library hides these details from us, transparently employing "
"B<rt_sigreturn>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:165
msgid ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<getcontext>(3), B<signal>(7), B<vdso>(7)"
msgstr "B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), B<getcontext>(3), B<signal>(7), B<vdso>(7)"

#. type: TH
#: build/C/man3/sigset.3:25
#, no-wrap
msgid "SIGSET"
msgstr "SIGSET"

#. type: Plain text
#: build/C/man3/sigset.3:28
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr "sigset, sighold, sigrelse, sigignore - System V 版シグナル API"

#. type: Plain text
#: build/C/man3/sigset.3:34
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:36
msgid "B<int sighold(int >I<sig>B<);>"
msgstr "B<int sighold(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:38
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr "B<int sigrelse(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:40
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr "B<int sigignore(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:51
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/sigset.3:55
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man3/sigset.3:64
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""
"これらの関数は、昔ながらの System V 版シグナル API を使用しているプログラム "
"に対して互換性のあるインターフェースを glibc で提供するものである。 この API "
"は過去のものであり、新しいアプリケーションでは POSIX シグナル API "
"(B<sigaction>(2), B<sigprocmask>(2)  など) を使用すべきである。"

#. type: Plain text
#: build/C/man3/sigset.3:73
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one "
"of the following constants:"
msgstr ""
"関数 B<sigset>()  はシグナル I<sig> のシグナルハンドラーの動作を変更する。 "
"I<disp> 引数には、シグナルハンドラー関数のアドレスか、 以下の定数のいずれか"
"一つを指定できる。"

#. type: TP
#: build/C/man3/sigset.3:73
#, no-wrap
msgid "B<SIG_DFL>"
msgstr "B<SIG_DFL>"

#. type: Plain text
#: build/C/man3/sigset.3:78
msgid "Reset the disposition of I<sig> to the default."
msgstr "I<sig> の動作をデフォルトにリセットする。"

#. type: TP
#: build/C/man3/sigset.3:78
#, no-wrap
msgid "B<SIG_IGN>"
msgstr "B<SIG_IGN>"

#. type: Plain text
#: build/C/man3/sigset.3:82
msgid "Ignore I<sig>."
msgstr "I<sig> を無視する。"

#. type: TP
#: build/C/man3/sigset.3:82
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr "B<SIG_HOLD>"

#. type: Plain text
#: build/C/man3/sigset.3:89
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig> "
"unchanged."
msgstr ""
"そのプロセスのシグナルマスクに I<sig> を追加するが、 I<sig> の動作は変更しな"
"い。"

#. type: Plain text
#: build/C/man3/sigset.3:95
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""
"I<disp> にシグナルハンドラーのアドレスが指定された場合、 シグナルハンドラーの"
"実行中は、そのプロセスのシグナルマスクに I<sig> が追加される。"

#. type: Plain text
#: build/C/man3/sigset.3:103
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""
"I<disp> に B<SIG_HOLD> 以外の値が指定された場合、 そのプロセスのシグナルマス"
"クから I<sig> が削除される。"

#. type: Plain text
#: build/C/man3/sigset.3:109 build/C/man3/sigvec.3:89
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr "シグナル B<SIGKILL> と B<SIGSTOP> に対する動作は変更できない。"

#. type: Plain text
#: build/C/man3/sigset.3:115
msgid ""
"The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""
"関数 B<sighold>()  は、呼び出し元プロセスのシグナルマスクに I<sig> を追加す"
"る。"

#. type: Plain text
#: build/C/man3/sigset.3:121
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal "
"mask."
msgstr ""
"関数 B<sigrelse>()  は、呼び出し元プロセスのシグナルマスクから I<sig> を削除"
"する。"

#. type: Plain text
#: build/C/man3/sigset.3:128
msgid ""
"The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr "関数 B<sigignore>()  は、 I<sig> の動作を B<SIG_IGN> に設定する。"

#. type: Plain text
#: build/C/man3/sigset.3:144
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""
"B<sigset>()  は成功すると、 呼び出し前に I<sig> がブロックされていた場合には "
"B<SIG_HOLD> を返し、 ブロックされていなかった場合には 変更前のそのシグナルの"
"動作を返す。 エラーの場合、 B<sigset>()  は -1 を返し、 I<errno> にエラーを示"
"す値をセットする。 但し、以下の「バグ」の節も参照のこと。"

#. type: Plain text
#: build/C/man3/sigset.3:153
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""
"関数 B<sighold>(), B<sigrelse>(), B<sigignore>()  は成功すると 0 を返す。エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sigset.3:160
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""
"B<sigset>()  に関しては、 B<sigaction>(2)  と B<sigprocmask>(2)  の「エラー」"
"の節を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:167
msgid ""
"For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""
"B<sighold>()  と B<sigrelse>()  に関しては、 B<sigprocmask>(2)  の「エラー」"
"の節を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:172
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr "B<sigignore>()  に関しては、 B<sigaction>(2)  の「エラー」の節を参照。"

#. type: tbl table
#: build/C/man3/sigset.3:183
#, no-wrap
msgid ""
"B<sigset>(),\n"
"B<sighold>(),\n"
msgstr ""
"B<sigset>(),\n"
"B<sighold>(),\n"

#. type: tbl table
#: build/C/man3/sigset.3:183 build/C/man3/sigsetops.3:143
#: build/C/man3/sigsetops.3:146 build/C/man3/sigsetops.3:149
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/sigset.3:186
#, no-wrap
msgid ""
"B<sigrelse>(),\n"
"B<sigignore>()"
msgstr ""
"B<sigrelse>(),\n"
"B<sigignore>()"

#. type: Plain text
#: build/C/man3/sigset.3:205
msgid ""
"SVr4, POSIX.1-2001, POSIX.1-2008.  These functions are obsolete: do not use "
"them in new programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), "
"B<sigpause>(3), B<sigrelse>(), and B<sigset>()  as obsolete, recommending "
"the use of B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and "
"B<sigsuspend>(2)  instead."
msgstr "SVr4, POSIX.1-2001, POSIX.1-2008.  これらの関数は廃止予定である。新しいプログラムでは使用しないこと。 POSIX.1-2008 は、 B<sighold>(), B<sigignore>(), B<sigpause>(3), B<sigrelse>(), B<sigset>()  を廃止予定としている。 代わりに、 B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), B<sigsuspend>(2)  の使用が推奨されている。"

#. type: Plain text
#: build/C/man3/sigset.3:207
msgid "These functions appeared in glibc version 2.1."
msgstr "これらの関数は glibc 2.1 で登場した。"

#. type: Plain text
#: build/C/man3/sigset.3:213
msgid ""
"The I<sighandler_t> type is a GNU extension; it is used on this page only to "
"make the B<sigset>()  prototype more easily readable."
msgstr ""
"I<sighandler_t> 型は GNU による拡張であり、この man page で B<sigset>()  のプ"
"ロトタイプをより読みやすくするために使われているだけである。"

#. type: Plain text
#: build/C/man3/sigset.3:221
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""
"関数 B<sigset>()  は信頼性のあるシグナル処理機構を提供する (I<sa_mask> を 0 "
"で B<sigaction>(2)  を呼び出したときと同様)。"

#. type: Plain text
#: build/C/man3/sigset.3:239
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See "
"B<signal>(2)  for further details."
msgstr ""
"System V では、関数 B<signal>()  が提供する処理機構は信頼性のないものである "
"(I<sa_mask> を I<SA_RESETHAND | SA_NODEFER> として B<sigaction>(2)  を呼び出"
"したときと同様)。 BSD では、 B<signal>()  は信頼性のある処理機構を提供する。 "
"POSIX.1-2001 では、 B<signal>()  のこの点は規定しないままとなっている。 さら"
"なる詳細については B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:247 build/C/man3/sigvec.3:279
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""
"BSD と System V のどちらのシステムでも シグナルを待つために、 "
"B<sigpause>(3)  という名前の関数が提供されているが、 この関数の引数は両方の"
"システムで異なる。 詳細は B<sigpause>(3)  を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:256
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""
"2.2 より前のバージョンの glibc では、 I<disp> に B<SIG_HOLD> 以外の値が指定さ"
"れた場合、 I<sig> のブロック解除を行っていなかった。"

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: build/C/man3/sigset.3:281
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""
"2.3.5 以前の全てのバージョンの glibc では、 B<sigset>()  が変更前のシグナルの"
"動作を正しく返さない場合が 2つある。 一つめは、 I<disp> に B<SIG_HOLD> が指定"
"されると、成功した場合 B<sigset>()  は常に B<SIG_HOLD> を返すことである。 正"
"しくは、(シグナルがブロックされていなかった場合には)  変更前のシグナルの動作"
"を返すべきである (シグナルがブロックされていた場合には、 B<SIG_HOLD> が返され"
"る)。 もう一つは、シグナルが現在ブロックされている場合には、 成功した場合の "
"B<sigset>()  の返り値は B<SIG_HOLD> になるべきであるが、実際には 変更前のシグ"
"ナルの動作が返されることである。 これらの問題は glibc 2.5 以降で修正されてい"
"る。"

#. type: Plain text
#: build/C/man3/sigset.3:291
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigsetops.3:31
#, no-wrap
msgid "SIGSETOPS"
msgstr "SIGSETOPS"

#. type: Plain text
#: build/C/man3/sigsetops.3:35
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations"
msgstr ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX シグナル集"
"合の操作"

#. type: Plain text
#: build/C/man3/sigsetops.3:39
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr "B<int sigemptyset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:41
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr "B<int sigfillset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:43
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:45
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:47
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:59
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"

#. type: Plain text
#: build/C/man3/sigsetops.3:61
msgid "_POSIX_C_SOURCE"
msgstr "_POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/sigsetops.3:65
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr "これらの関数は POSIX シグナル集合(signal set)を操作するため使用する。"

#. type: Plain text
#: build/C/man3/sigsetops.3:70
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""
"B<sigemptyset>()  は I<set> で与えられたシグナル集合を空に初期化し、シグナル"
"が一つも 含まれていない状態にする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:75
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""
"B<sigfillset>()  は I<set> で与えられたシグナル集合が全てのシグナルを含むよう"
"にする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:83
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""
"B<sigaddset>()  と B<sigdelset>()  は I<set> に I<signum> シグナルをそれぞれ"
"加えたり、削除したりする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:89
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""
"B<sigismember>()  は I<signum> が I<set> に含まれているかどうかをテストする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:107
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>(), and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""
"I<sigset_t> 型のオブジェクトは、関数 B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>()  や後述の glibc の追加関数 (B<sigisemptyset>(), "
"B<sigandset>(), B<sigorset>())  に渡す前に、 B<sigemptyset>()  か "
"B<sigfillset>()  を呼び出して初期化しなければならない。 初期化しなかった場合"
"の結果は未定義である。"

#. type: Plain text
#: build/C/man3/sigsetops.3:114
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>()  は成功すれ"
"ば 0 を、エラーの場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:123
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error."
msgstr ""
"B<sigismember>()  は I<signum> が I<set> のメンバの場合 1 を返し、メンバでな"
"い場合 0 を返す。 エラーの場合、-1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:127
msgid ""
"On error, these functions set I<errno> to indicate the cause of the error."
msgstr "エラーの場合、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/sigsetops.3:132
msgid "I<signum> is not a valid signal."
msgstr "I<signum> が有効なシグナルではない。"

#. type: tbl table
#: build/C/man3/sigsetops.3:143
#, no-wrap
msgid ""
"B<sigemptyset>(),\n"
"B<sigfillset>(),\n"
msgstr ""
"B<sigemptyset>(),\n"
"B<sigfillset>(),\n"

#. type: tbl table
#: build/C/man3/sigsetops.3:146
#, no-wrap
msgid ""
"B<sigaddset>(),\n"
"B<sigdelset>(),\n"
msgstr ""
"B<sigaddset>(),\n"
"B<sigdelset>(),\n"

#. type: tbl table
#: build/C/man3/sigsetops.3:149
#, no-wrap
msgid ""
"B<sigismember>(),\n"
"B<sigisemptyset>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigsetops.3:152
#, no-wrap
msgid ""
"B<sigorset>(),\n"
"B<sigandset>()"
msgstr ""
"B<sigorset>(),\n"
"B<sigandset>()"

#. type: Plain text
#: build/C/man3/sigsetops.3:165
msgid ""
"When creating a filled signal set, the glibc B<sigfillset>()  function does "
"not include the two real-time signals used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: SS
#: build/C/man3/sigsetops.3:165
#, no-wrap
msgid "Glibc extensions"
msgstr "glibc での拡張"

#. type: Plain text
#: build/C/man3/sigsetops.3:171
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then I<E<lt>signal."
"hE<gt>> exposes three other functions for manipulating signal sets:"
msgstr ""
"B<_GNU_SOURCE> 機能検査マクロが定義されていると、 I<E<lt>signal.hE<gt>> でシ"
"グナル集合を操作する 3 つの関数が追加で公開される。"

#. type: Plain text
#: build/C/man3/sigsetops.3:178
#, no-wrap
msgid ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
msgstr ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"

#. type: Plain text
#: build/C/man3/sigsetops.3:184
msgid ""
"B<sigisemptyset>()  returns 1 if I<set> contains no signals, and 0 otherwise."
msgstr ""
"B<sigisemptyset>() は I<set> にシグナルが一つも含まれていなければ 1 を返し、 "
"それ以外は 0 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:200
msgid ""
"B<sigorset>()  places the union of the sets I<left> and I<right> in "
"I<dest>.  B<sigandset>()  places the intersection of the sets I<left> and "
"I<right> in I<dest>.  Both functions return 0 on success, and -1 on failure."
msgstr ""
"B<sigorset>() は集合 I<left> と I<right> の和集合を I<dest> に設定する。 "
"B<sigandset>() は集合 I<left> と I<right> の積集合を I<dest> に設定する。 ど"
"ちらの関数も成功すると 0 を返し、失敗時には -1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:203
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""
"これらの関数は非標準であり、(他にも同様の関数を提供しているシステムも いくつ"
"かはあるが) 移植性を考慮したアプリケーションでは使用を避けるべき である。"

#. type: Plain text
#: build/C/man3/sigsetops.3:208
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"

#. type: TH
#: build/C/man2/sigsuspend.2:29
#, no-wrap
msgid "SIGSUSPEND"
msgstr "SIGSUSPEND"

#. type: Plain text
#: build/C/man2/sigsuspend.2:32
msgid "sigsuspend, rt_sigsuspend - wait for a signal"
msgstr "sigsuspend, rt_sigsuspend - シグナルを待つ"

#. type: Plain text
#: build/C/man2/sigsuspend.2:36
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr "B<int sigsuspend(const sigset_t *>I<mask>B<);>"

#. type: Plain text
#: build/C/man2/sigsuspend.2:45
msgid "B<sigsuspend>(): _POSIX_C_SOURCE"
msgstr "B<sigsuspend>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man2/sigsuspend.2:53
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling thread "
"with the mask given by I<mask> and then suspends the thread until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr "B<sigsuspend>()  は、呼び出し元スレッドのシグナルマスクを I<mask> で指定されたマスクに一時的に置き換え、 シグナルハンドラーの起動もしくはプロセスの終了がアクションとして 設定されたシグナルが配送されるまで、そのスレッドを停止する。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:62
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""
"シグナルがプロセスを終了させるものの場合、 B<sigsuspend>()  は返らない。シグ"
"ナルが捕捉された場合、 シグナルハンドラーの処理が終わった後に "
"B<sigsuspend>()  は返り、シグナルマスクは B<sigsuspend>()  が呼び出される前の"
"状態に復元される。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:70
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the thread's signal mask."
msgstr "B<SIGKILL> と B<SIGSTOP> を禁止 (block) することはできない; これらのシグナルを I<mask> に指定しても、そのスレッドのシグナルマスクは影響を受けない。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:76
msgid ""
"B<sigsuspend>()  always returns -1, with I<errno> set to indicate the error "
"(normally, B<EINTR>)."
msgstr ""
"B<sigsuspend>() は常に -1 を返し、 I<errno> にエラーの原因を示す値 (通常は "
"B<EINTR>) を設定する。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:81
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"I<mask> が指しているメモリーが、プロセスのアドレス空間の有効な部分ではない。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:85
msgid "The call was interrupted by a signal; B<signal>(7)."
msgstr "システムコールはシグナルにより割り込まれた。 B<signal>(7) を参照。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:104
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""
"B<sigsuspend>()  は、通常、クリティカルコードセクション (critical code "
"section) の 実行中にシグナルが配送されるのを防止するために、 "
"B<sigprocmask>(2)  と組み合わせて使用される。 まず最初に、呼び出し元は "
"B<sigprocmask>(2)  を使ってシグナルを禁止する。 クリティカルコードが完了する"
"と、呼び出し元は B<sigprocmask>(2)  が (I<oldset> 引数で) 返すシグナルマス"
"クを指定して B<sigsuspend>()  を呼び出すことで、クリティカルコード実行中に発"
"生した シグナルを待つことができる。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:136
msgid ""
"The original Linux system call was named B<sigsuspend>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigsuspend>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<mask>.  This argument is currently required to have the "
"value I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigsuspend>()  wrapper function hides these details from us, transparently "
"calling B<rt_sigsuspend>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:146
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigvec.3:25
#, no-wrap
msgid "SIGVEC"
msgstr "SIGVEC"

#. type: Plain text
#: build/C/man3/sigvec.3:28
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD 版シグナル API"

#. type: Plain text
#: build/C/man3/sigvec.3:32
msgid ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:34
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr "B<int sigmask(int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:36
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr "B<int sigblock(int >I<mask>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:38
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr "B<int sigsetmask(int >I<mask>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:40
msgid "B<int siggetmask(void);>"
msgstr "B<int siggetmask(void);>"

#. type: Plain text
#: build/C/man3/sigvec.3:51
#, no-wrap
msgid ""
"All functions shown above:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:58
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)."
msgstr ""
"これらの関数は、昔ながらの BSD 版シグナル API を使用しているプログラム に対し"
"て互換性のあるインターフェースを glibc で提供するものである。 この API は過去"
"のものであり、新しいアプリケーションでは POSIX シグナル API "
"(B<sigaction>(2), B<sigprocmask>(2)  など) を使用すべきである。"

#. type: Plain text
#: build/C/man3/sigvec.3:83
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-null pointer for I<ovec>."
msgstr ""
"関数 B<sigvec>()  は、(POSIX の B<sigaction>(2)  と同様に) シグナル I<sig> の"
"動作の設定・取得を行う。 I<vec> は、NULL 以外の場合、 I<sig> の新しい動作を定"
"義した I<sigvec> 構造体へのポインターである。 I<ovec> は、NULL 以外の場合、 "
"I<sig> の変更前の動作を返すために使用される I<sigvec> 構造体へのポインターで"
"ある。 I<sig> の動作を変更せずに現在の動作を取得するためには、 I<vec> に "
"NULL を指定し、 I<ovec> に NULL でないポインターを指定すればよい。"

#. type: Plain text
#: build/C/man3/sigvec.3:93
msgid "The I<sigvec> structure has the following form:"
msgstr "I<sigvec> 構造体は以下の通りである:"

#. type: Plain text
#: build/C/man3/sigvec.3:101
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* Signal disposition */\n"
"    int    sv_mask;          /* Signals to be blocked in handler */\n"
"    int    sv_flags;         /* Flags */\n"
"};\n"
msgstr ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* Signal disposition */\n"
"    int    sv_mask;          /* Signals to be blocked in handler */\n"
"    int    sv_flags;         /* Flags */\n"
"};\n"

#. type: Plain text
#: build/C/man3/sigvec.3:112
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; B<SIG_DFL>, meaning the "
"default disposition applies for the signal; or B<SIG_IGN>, meaning that the "
"signal is ignored."
msgstr ""
"I<sv_handler> フィールドはシグナルの動作を指定するもので、 シグナルハンドラー"
"関数のアドレスか、 B<SIG_DFL> と B<SIG_IGN> のいずれかを指定できる。 "
"B<SIG_DFL> はシグナルに適用されるデフォルトの動作を意味し、 B<SIG_IGN> はシグ"
"ナルを無視することを意味する。"

#. type: Plain text
#: build/C/man3/sigvec.3:126
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also "
"blocked.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently ignored."
msgstr ""
"I<sv_handler> にシグナルハンドラーのアドレスを指定した場合、 I<sv_mask> はハ"
"ンドラーが実行中にブロックされるべきシグナルのマスクを指定する。 また、ハンド"
"ラーを起動したシグナル自身はブロックされる。 B<SIGKILL> か B<SIGSTOP> をブ"
"ロックしようとした場合には、黙って無視される。"

#. type: Plain text
#: build/C/man3/sigvec.3:133
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""
"I<sv_handler> にシグナルハンドラーのアドレスを指定した場合、 I<sv_flags> "
"フィールドはハンドラーが呼ばれた際の挙動を制御するフラグを指定する。 この"
"フィールドには、0 か、以下のフラグを 1個以上指定できる:"

#. type: TP
#: build/C/man3/sigvec.3:133
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr "B<SV_INTERRUPT>"

#. type: Plain text
#: build/C/man3/sigvec.3:141
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call s not be restarted: instead it fails with "
"the error B<EINTR>.  If this flag is not specified, then system calls are "
"restarted by default."
msgstr ""
"シグナルハンドラーが停止中のシステムコールを中断した場合、 ハンドラーから復帰"
"しても、システムコールは再開されず、 エラー B<EINTR> で失敗する。 このフラグ"
"を指定しなかった場合、システムコールは デフォルトで再開される。"

#. type: TP
#: build/C/man3/sigvec.3:141
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr "B<SV_RESETHAND>"

#. type: Plain text
#: build/C/man3/sigvec.3:150
msgid ""
"Reset the disposition of the signal to the default before calling the signal "
"handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""
"シグナルハンドラーを呼び出す前にシグナルの動作を デフォルトにリセットする。 "
"このフラグを指定しなかった場合、もう一度 B<sigvec>()  を呼び出して明示的に削"
"除されるか、プロセスが B<execve>(2)  を実行するまで、ハンドラーは設定されたま"
"まとなる。"

#. type: TP
#: build/C/man3/sigvec.3:150
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr "B<SV_ONSTACK>"

#. type: Plain text
#: build/C/man3/sigvec.3:157
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""
"代替シグナルスタック上でシグナルハンドラーを実行する (歴史的に、BSD では代替"
"シグナルスタックは廃止された関数 B<sigstack>()  を使って設定する。POSIX で"
"は、代わりに B<sigaltstack>(2)  を使用する)。"

#. type: Plain text
#: build/C/man3/sigvec.3:167
msgid ""
"The B<sigmask>()  macro constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to "
"B<sigvec>()  using code such as the following:"
msgstr ""
"マクロ B<sigmask>()  は I<signum> に対する「シグナルマスク」を構成して返す。 "
"例えば、以下のようなコードを使うと、 B<sigvec>()  に渡す I<vec.sv_mask> を初"
"期化できる。"

#. type: Plain text
#: build/C/man3/sigvec.3:173
#, no-wrap
msgid ""
"vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"            /* Block SIGQUIT and SIGABRT during\n"
"               handler execution */\n"
msgstr ""
"vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"            /* Block SIGQUIT and SIGABRT during\n"
"               handler execution */\n"

#. type: Plain text
#: build/C/man3/sigvec.3:189
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""
"B<sigblock>()  関数は、 I<mask> にあるシグナルをプロセスのシグナルマスクに追"
"加し (POSIX の I<sigprocmask(SIG_BLOCK)> と同様)、変更前のプロセスのシグナル"
"マスクを返す。 B<SIGKILL> や B<SIGSTOP> をブロックしようとした場合には、黙っ"
"て無視される。"

#. type: Plain text
#: build/C/man3/sigvec.3:197
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""
"B<sigsetmask>()  関数はプロセスのシグナルマスクを I<mask> で指定された値に設"
"定し (POSIX の I<sigprocmask(SIG_SETMASK)> と同様)、変更前のプロセスのシグナ"
"ルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:203
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""
"B<siggetmask>()  関数はプロセスの現在のシグナルマスクを返す。この関数は "
"I<sigblock(0)> と等価である。"

#. type: Plain text
#: build/C/man3/sigvec.3:209
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""
"B<sigvec>()  関数は成功すると 0 を返す。エラーの場合、-1 を返し、 I<errno> に"
"エラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sigvec.3:215
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal "
"mask."
msgstr "B<sigblock>()  と B<sigsetmask>()  は変更前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:220
msgid "The B<sigmask>()  macro returns the signal mask for I<signum>."
msgstr "B<sigmask>() マクロは I<signum> のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:225
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr "B<sigaction>(2)  と B<sigprocmask>(2)  の「エラー」の節を参照。"

#. type: Plain text
#: build/C/man3/sigvec.3:232
msgid ""
"Starting with version 2.21, the GNU C library no longer exports the "
"B<sigvec>()  function as part of the ABI.  (To ensure backward "
"compatibility, the glibc symbol versioning scheme continues to export the "
"interface to binaries linked against older versions of the library.)"
msgstr ""
"バージョン 2.21 以降では、 GNU C ライブラリはもはや B<sigvec>() 関数を ABI の"
"一部として公開しなくなった。 (後方互換性を保証するために、glibc のシンボルの"
"バージョン付け機構により、 古いバージョンのライブラリとリンクされたバイナリに"
"対してはこのインターフェースが引き続き公開されている。)"

#. type: tbl table
#: build/C/man3/sigvec.3:246
#, no-wrap
msgid ""
"B<sigvec>(),\n"
"B<sigmask>(),\n"
"B<sigblock>(),\n"
"B<sigsetmask>(),\n"
"B<siggetmask>()"
msgstr ""
"B<sigvec>(),\n"
"B<sigmask>(),\n"
"B<sigblock>(),\n"
"B<sigsetmask>(),\n"
"B<siggetmask>()"

#. type: Plain text
#: build/C/man3/sigvec.3:254
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""
"これらの関数のうち B<siggetmask>()  以外の全ては 4.3BSD にあった。 "
"B<siggetmask>()  の出自ははっきりしない。 これらの関数は廃止予定であり、新し"
"いプログラムでは使用しないこと。"

#. type: Plain text
#: build/C/man3/sigvec.3:271
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, "
"B<signal>()  provides unreliable semantics.  POSIX.1 leaves these aspects of "
"B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr "4.3BSD では、信頼性のあるシグナル処理機構を提供する (I<vec.sv_mask> を 0 で B<sigvec>()  を呼び出したときと同様)。 System V が提供する処理機構は信頼性のないものである。 POSIX.1 では、 B<signal>()  のこの点は規定しないままとなっている。 さらなる詳細については B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sigvec.3:289
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigwait.3:26
#, no-wrap
msgid "SIGWAIT"
msgstr "SIGWAIT"

#. type: Plain text
#: build/C/man3/sigwait.3:29
msgid "sigwait - wait for a signal"
msgstr "sigwait - シグナルを待つ"

#. type: Plain text
#: build/C/man3/sigwait.3:34
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/sigwait.3:43
msgid "B<sigwait>():"
msgstr "B<sigwait>():"

#. type: Plain text
#: build/C/man3/sigwait.3:46
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"
msgstr ""
"glibc 2.26 以降:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"

#. type: Plain text
#: build/C/man3/sigwait.3:49
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _POSIX_C_SOURCE\n"
msgstr ""
"Glibc 2.25 以前:\n"
"    _POSIX_C_SOURCE\n"

#. type: Plain text
#: build/C/man3/sigwait.3:62
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"one of the signals specified in the signal set I<set> becomes pending.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""
"B<sigwait>()  関数は、シグナル集合 I<set> で指定されたシグナルの一つが処理待"
"ち (pending) になるまで、 呼び出したスレッドの実行を中断する。 この関数はその"
"シグナルを受け取り (つまり、処理待ちのシグナルのリスト からそのシグナルを削除"
"し)、そのシグナル番号を I<sig> に格納して返す。"

#. type: Plain text
#: build/C/man3/sigwait.3:68
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except that:"
msgstr ""
"B<sigwait>()  の動作は B<sigwaitinfo>(2)  と同じだが、以下の点が異なる。"

#. type: Plain text
#: build/C/man3/sigwait.3:73
msgid ""
"B<sigwait>()  returns only the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""
"B<sigwait>()  は、シグナルの内容を表す I<siginfo_t> 構造体を返すのではなく、"
"単にシグナル番号を返す。"

#. type: Plain text
#: build/C/man3/sigwait.3:75
msgid "The return values of the two functions are different."
msgstr "返り値が B<sigwaitinfo>(2)  とは異なる。"

#. type: Plain text
#: build/C/man3/sigwait.3:80
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""
"成功すると、 B<sigwait>()  は 0 を返す。 エラーの場合、(「エラー」の節のリス"
"トにある) 正のエラー番号を返す。"

#.  Does not occur for glibc.
#. type: Plain text
#: build/C/man3/sigwait.3:86
msgid "I<set> contains an invalid signal number."
msgstr "I<set> に無効なシグナル番号が入っている。"

#. type: tbl table
#: build/C/man3/sigwait.3:96
#, no-wrap
msgid "B<sigwait>()"
msgstr "B<sigwait>()"

#. type: Plain text
#: build/C/man3/sigwait.3:104
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr "B<sigwait>()  は B<sigtimedwait>(2)  を使って実装されている。"

#. type: Plain text
#: build/C/man3/sigwait.3:112
msgid ""
"The glibc implementation of B<sigwait>()  silently ignores attempts to wait "
"for the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:115
msgid "See B<pthread_sigmask>(3)."
msgstr "B<pthread_sigmask>(3)  を参照。"

#. type: Plain text
#: build/C/man3/sigwait.3:123
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigwaitinfo.2:25
#, no-wrap
msgid "SIGWAITINFO"
msgstr "SIGWAITINFO"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:29
msgid ""
"sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued "
"signals"
msgstr "sigwaitinfo, sigtimedwait, rt_sigtimedwait - キューに入れられたシグナルを同期して待つ"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:34
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:37
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<,>\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<,>\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:47
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""
"B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:57
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is pending (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately.)"
msgstr ""
"B<sigwaitinfo>()  は I<set> のうちのどれかのシグナルが処理待ちになるまで、 呼"
"び出しスレッドの実行を一時停止する (呼び出しスレッドに対して I<set> のうちの"
"どれかのシグナルが既に待機中 (pending) である場合、 B<sigwaitinfo>()  はすぐ"
"に戻る)。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:69
msgid ""
"B<sigwaitinfo>()  removes the signal from the set of pending signals and "
"returns the signal number as its function result.  If the I<info> argument "
"is not NULL, then the buffer that it points to is used to return a structure "
"of type I<siginfo_t> (see B<sigaction>(2))  containing information about the "
"signal."
msgstr ""
"B<sigwaitinfo>()  はそのシグナルを待機中のシグナルの集合から削除し、関数の結"
"果としてシグナル番号を返す。 I<info> 引数が NULL でない場合、配送されたシグ"
"ナルの情報が入った I<siginfo_t> 型 (B<sigaction>(2)  を参照) の構造体を "
"I<info> が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:77
msgid ""
"If multiple signals in I<set> are pending for the caller, the signal that is "
"retrieved by B<sigwaitinfo>()  is determined according to the usual ordering "
"rules; see B<signal>(7)  for further details."
msgstr ""
"呼び出し元に対して I<set> の複数のシグナルが処理待ちの場合、 "
"B<sigwaitinfo>() で取得するシグナルは通常の順序決定ルールに基づいて決定され"
"る。 詳細は B<signal>(7) を参照のこと。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:89
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies the "
"interval for which the thread is suspended waiting for a signal.  (This "
"interval will be rounded up to the system clock granularity, and kernel "
"scheduling delays mean that the interval may overrun by a small amount.)  "
"This argument is of the following type:"
msgstr ""
"B<sigtimedwait>() は、 B<sigwaitinfo>() と次の点を除いて全く同じように動作す"
"る。この関数にはもう 1 つの引数 I<timeout> があり、シグナル待ちでスレッドが"
"一時停止する時間を指定することができる(この時間はシステムクロックの粒度に切り"
"上げられ、カーネルのスケジューリング遅延により少しだけ長くなる可能性がある)。"
"この引数の型は以下のとおりである:"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:96
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* 秒 */\n"
"    long    tv_nsec;        /* ナノ秒 */\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:106
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""
"この構造体の 2 つのフィールドがともに 0 の場合、ポーリングが行われる: "
"B<sigtimedwait>()  は、呼び出し側プロセスに対して 待機しているシグナルの情報"
"を返して戻るか、 I<set> のうちのどのシグナルも待機していない場合はエラーを返"
"して戻る。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:115
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""
"成功した場合、 B<sigwaitinfo>()  と B<sigtimedwait>()  はシグナル番号 (すなわ"
"ち 0 より大きい数) を返す。 失敗した場合、2 つの関数は -1 を返し、 I<errno> "
"はエラーを表す値に設定される。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:124
msgid ""
"No signal in I<set> was became pending within the I<timeout> period "
"specified to B<sigtimedwait>()."
msgstr ""
"I<set> のうちのどのシグナルも B<sigtimedwait>()  に指定された I<timeout> の期"
"間内に処理待ちにならなかった。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:130
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""
"シグナル待ちがシグナルハンドラーによって中断 (interrupt) された (このハンド"
"ラーは I<set> にあるシグナル以外のものである)。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:134
msgid "I<timeout> was invalid."
msgstr "I<timeout> が不正である。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:154
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they become pending between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads, in order to prevent the signal being treated according to its "
"default disposition in a thread other than the one calling B<sigwaitinfo>()  "
"or B<sigtimedwait>())."
msgstr ""
"通常の使用法では、呼び出し側プロセスはこれらの関数より先に "
"B<sigprocmask>(2)  の呼び出すことにより I<set> に含まれるシグナルをブロック"
"し (そのためにこれらのシグナルがこの後に続く B<sigwaitinfo>()  や "
"B<sigtimedwait>()  の呼び出しの間に処理待ちになった場合には、デフォルトの動作"
"は行われず)、 これらのシグナルに対するハンドラーは設定しない。 マルチスレッド"
"プログラムでは、 B<sigwaitinfo>()  や B<sigtimedwait>() を呼び出したスレッド"
"以外のスレッドで、そのシグナルがデフォルトの動作に基いて処理されないように、"
"全てのスレッドで該当シグナルをブロックすべきである。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:159
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""
"指定されたスレッドに対する処理待ちのシグナルの集合は、 そのスレッド自体宛ての"
"処理待ちのシグナル集合と、プロセス全体宛ての 処理待ちのシグナル集合をあわせた"
"ものである (B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:165
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr "B<SIGKILL> と B<SIGSTOP> を待とうとした場合、黙って無視される。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:174
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it becomes pending for the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""
"一つのプロセス内の複数のスレッドが B<sigwaitinfo>()  や B<sigtimedwait>()  で"
"同じシグナルを待って停止した場合、 プロセス全体宛てのシグナルが処理待ちになる"
"と、複数のスレッドのうち一つだけが 実際にそのシグナルを受信することになる。 "
"どのスレッドがシグナルを受信するかは決まっていない。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:186
msgid ""
"B<sigwaitinfo>()  or B<sigtimedwait>(), can't be used to receive signals "
"that are synchronously generated, such as the B<SIGSEGV> signal that results "
"from accessing an invalid memory address or the B<SIGFPE> signal that "
"results from an arithmetic error.  Such signals can be caught only via "
"signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:196
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""
"POSIX では B<sigtimedwait>()  の引数 I<timeout> の値を NULL にした場合の意"
"味を未定義としている。 B<sigwaitinfo>()  を呼び出したのと同じ意味としてもよい"
"ことになっており、 実際 Linux ではこのように動作する。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:201
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""
"Linux では、 B<sigwaitinfo>()  は B<sigtimedwait>()  を用いて実装されたライブ"
"ラリ関数である。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:211
msgid ""
"The glibc wrapper functions for B<sigwaitinfo>()  and B<sigtimedwait>()  "
"silently ignore attempts to wait for the two real-time signals that are used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:238
msgid ""
"The original Linux system call was named B<sigtimedwait>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigtimedwait>(), was added "
"to support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  This argument is currently required to have the value "
"I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigtimedwait>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigtimedwait>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:250
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"

#. type: TH
#: build/C/man3/sysv_signal.3:25
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr "SYSV_SIGNAL"

#. type: Plain text
#: build/C/man3/sysv_signal.3:28
msgid "sysv_signal - signal handling with System V semantics"
msgstr "sysv_signal - System V 方式のシグナル処理"

#. type: Plain text
#: build/C/man3/sysv_signal.3:30
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/sysv_signal.3:36
msgid ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: build/C/man3/sysv_signal.3:41
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""
"B<sysv_signal>()  関数は B<signal>(2)  と同じ引数をとり、同じ処理を実行す"
"る。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:51
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics, "
"that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""
"しかしながら、 B<sysv_signal>()  は System V の信頼性に欠けるシグナル処理方式"
"を提供している。 信頼性に欠けるシグナル処理方式は以下の特徴を持つ。 a) ハンド"
"ラーが起動されると、シグナルの処理方法 (disposition) が デフォルトにリセット"
"される、 b) シグナルハンドラーの実行中は、それ以降に発生した同じシグナルの配"
"送が ブロックされない、 c) ハンドラーが停止中の (blocking している) システム"
"コールを中断した場合、 自動的に再開されないシステムコールがある。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:57
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""
"B<sysv_signal>()  関数はシグナルハンドラーの直前の値を返す。 エラーの場合、 "
"B<SIG_ERR> を返す。"

#. type: tbl table
#: build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "B<sysv_signal>()"
msgstr "B<sysv_signal>()"

#. type: Plain text
#: build/C/man3/sysv_signal.3:74
msgid "This function is nonstandard."
msgstr "この関数は非標準である。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:80
msgid ""
"Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""
"B<sysv_signal>()  の使用は避けるべきである。代わりに B<sigaction>(2)  を使う"
"こと。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:91
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were "
"equivalent.  But on newer systems, B<signal>(2)  provides reliable signal "
"semantics; see B<signal>(2)  for details."
msgstr ""
"以前の Linux システムでは、 B<sysv_signal>()  と B<signal>(2)  は等価であっ"
"た。しかし、新しめのシステムでは、 B<signal>(2)  は信頼性のあるシグナル処理方"
"式を提供している。 詳細は B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:104
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/timer_create.2:26
#, no-wrap
msgid "TIMER_CREATE"
msgstr "TIMER_CREATE"

#. type: Plain text
#: build/C/man2/timer_create.2:29
msgid "timer_create - create a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:33
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:36
#, no-wrap
msgid ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"
msgstr ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:39 build/C/man2/timer_delete.2:37
#: build/C/man2/timer_getoverrun.2:37 build/C/man2/timer_settime.2:41
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: Plain text
#: build/C/man2/timer_create.2:47
msgid "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_create.2:55
msgid ""
"B<timer_create>()  creates a new per-process interval timer.  The ID of the "
"new timer is returned in the buffer pointed to by I<timerid>, which must be "
"a non-null pointer.  This ID is unique within the process, until the timer "
"is deleted.  The new timer is initially disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:60
msgid ""
"The I<clockid> argument specifies the clock that the new timer uses to "
"measure time.  It can be specified as one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:60 build/C/man2/timerfd_create.2:67
#, no-wrap
msgid "B<CLOCK_REALTIME>"
msgstr "B<CLOCK_REALTIME>"

#. type: Plain text
#: build/C/man2/timer_create.2:63 build/C/man2/timerfd_create.2:70
msgid "A settable system-wide real-time clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:63 build/C/man2/timerfd_create.2:70
#, no-wrap
msgid "B<CLOCK_MONOTONIC>"
msgstr "B<CLOCK_MONOTONIC>"

#. type: Plain text
#: build/C/man2/timer_create.2:70 build/C/man2/timerfd_create.2:75
msgid ""
"A nonsettable monotonically increasing clock that measures time from some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:70
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:74
msgid ""
"A clock that measures (user and system) CPU time consumed by (all of the "
"threads in) the calling process."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:74
#, no-wrap
msgid "B<CLOCK_THREAD_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#.  The CLOCK_MONOTONIC_RAW that was added in 2.6.28 can't be used
#.  to create a timer -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:80
msgid ""
"A clock that measures (user and system) CPU time consumed by the calling "
"thread."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:80
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 2.6.39)"
msgstr "B<CLOCK_BOOTTIME> (Linux 2.6.39 以降)"

#.     commit 4a2378a943f09907fb1ae35c15de917f60289c14
#. type: Plain text
#: build/C/man2/timer_create.2:95 build/C/man2/timerfd_create.2:90
msgid ""
"Like B<CLOCK_MONOTONIC>, this is a monotonically increasing clock.  However, "
"whereas the B<CLOCK_MONOTONIC> clock does not measure the time while a "
"system is suspended, the B<CLOCK_BOOTTIME> clock does include the time "
"during which the system is suspended.  This is useful for applications that "
"need to be suspend-aware.  B<CLOCK_REALTIME> is not suitable for such "
"applications, since that clock is affected by discontinuous changes to the "
"system clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:95
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.0)"
msgstr "B<CLOCK_REALTIME_ALARM> (Linux 3.0 以降)"

#.  commit 11ffa9d6065f344a9bd769a2452f26f2f671e5f8
#. type: Plain text
#: build/C/man2/timer_create.2:104 build/C/man2/timerfd_create.2:99
msgid ""
"This clock is like B<CLOCK_REALTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:104
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.0)"
msgstr "B<CLOCK_BOOTTIME_ALARM> (Linux 3.0 以降)"

#.  commit 11ffa9d6065f344a9bd769a2452f26f2f671e5f8
#. type: Plain text
#: build/C/man2/timer_create.2:113 build/C/man2/timerfd_create.2:108
msgid ""
"This clock is like B<CLOCK_BOOTTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:113
#, no-wrap
msgid "B<CLOCK_TAI> (since Linux 3.10)"
msgstr "B<CLOCK_TAI> (Linux 3.10 以降)"

#. type: Plain text
#: build/C/man2/timer_create.2:116
msgid ""
"A system-wide clock derived from wall-clock time but ignoring leap seconds."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:120 build/C/man2/timerfd_create.2:112
msgid "See B<clock_getres>(2)  for some further details on the above clocks."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:129
msgid ""
"As well as the above values, I<clockid> can be specified as the I<clockid> "
"returned by a call to B<clock_getcpuclockid>(3)  or "
"B<pthread_getcpuclockid>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:138
msgid ""
"The I<sevp> argument points to a I<sigevent> structure that specifies how "
"the caller should be notified when the timer expires.  For the definition "
"and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:142
msgid "The I<sevp.sigev_notify> field can have the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:147
msgid ""
"Don't asynchronously notify when the timer expires.  Progress of the timer "
"can be monitored using B<timer_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:165
msgid ""
"Upon timer expiration, generate the signal I<sigev_signo> for the process.  "
"See B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_TIMER>.  At any point in time, at "
"most one signal is queued to the process for a given timer; see "
"B<timer_getoverrun>(2)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:173
msgid ""
"Upon timer expiration, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:187
msgid ""
"As for B<SIGEV_SIGNAL>, but the signal is targeted at the thread whose ID is "
"given in I<sigev_notify_thread_id>, which must be a thread in the same "
"process as the caller.  The I<sigev_notify_thread_id> field specifies a "
"kernel thread ID, that is, the value returned by B<clone>(2)  or "
"B<gettid>(2).  This flag is intended only for use by threading libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:202
msgid ""
"Specifying I<sevp> as NULL is equivalent to specifying a pointer to a "
"I<sigevent> structure in which I<sigev_notify> is B<SIGEV_SIGNAL>, "
"I<sigev_signo> is B<SIGALRM>, and I<sigev_value.sival_int> is the timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:210
msgid ""
"On success, B<timer_create>()  returns 0, and the ID of the new timer is "
"placed in I<*timerid>.  On failure, -1 is returned, and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:214
msgid "Temporary error during kernel allocation of timer structures."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:222
msgid ""
"Clock ID, I<sigev_notify>, I<sigev_signo>, or I<sigev_notify_thread_id> is "
"invalid."
msgstr ""

#.  glibc layer: malloc()
#. type: Plain text
#: build/C/man2/timer_create.2:226
msgid "Could not allocate memory."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:226
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man2/timer_create.2:230
msgid "The kernel does not support creating a timer against this I<clockid>."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:240 build/C/man2/timerfd_create.2:460
#, fuzzy
#| msgid ""
#| "I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
#| "B<CAP_SETPCAP> capability."
msgid ""
"I<clockid> was B<CLOCK_REALTIME_ALARM> or B<CLOCK_BOOTTIME_ALARM> but the "
"caller did not have the B<CAP_WAKE_ALARM> capability."
msgstr ""
"I<option> が B<PR_CAPBSET_DROP> で、呼び出し元がケーパビリティ "
"B<CAP_SETPCAP> を持っていない。"

#. type: Plain text
#: build/C/man2/timer_create.2:242 build/C/man2/timer_delete.2:67
#: build/C/man2/timer_getoverrun.2:97
msgid "This system call is available since Linux 2.6."
msgstr "このシステムコールは Linux 2.6 以降で利用できる。"

#. type: Plain text
#: build/C/man2/timer_create.2:247
msgid "A program may create multiple interval timers using B<timer_create>()."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:252
msgid ""
"Timers are not inherited by the child of a B<fork>(2), and are disarmed and "
"deleted during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:260
msgid ""
"The kernel preallocates a \"queued real-time signal\" for each timer created "
"using B<timer_create>().  Consequently, the number of timers is limited by "
"the B<RLIMIT_SIGPENDING> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:265
msgid ""
"The timers created by B<timer_create>()  are commonly known as \"POSIX "
"(interval) timers\".  The POSIX timers API consists of the following "
"interfaces:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:268
msgid "B<timer_create>(): Create a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:271
msgid "B<timer_settime>(2): Arm (start) or disarm (stop) a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:275
msgid ""
"B<timer_gettime>(2): Fetch the time remaining until the next expiration of a "
"timer, along with the interval setting of the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:278
msgid ""
"B<timer_getoverrun>(2): Return the overrun count for the last timer "
"expiration."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:281
msgid "B<timer_delete>(2): Disarm and delete a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:289
msgid ""
"Since Linux 3.10, the I</proc/[pid]/timers> file can be used to list the "
"POSIX timers for the process with PID I<pid>.  See B<proc>(5)  for further "
"information."
msgstr ""

#.  baa73d9e478ff32d62f3f9422822b59dd9a95a21
#. type: Plain text
#: build/C/man2/timer_create.2:297
#, fuzzy
#| msgid ""
#| "Since Linux 3.16, support for these system calls is optional, depending "
#| "on whether the kernel was built with the B<CONFIG_SGETMASK_SYSCALL> "
#| "option."
msgid ""
"Since Linux 4.10, support for POSIX timers is a configurable option that is "
"enabled by default.  Kernel support can be disabled via the "
"B<CONFIG_POSIX_TIMERS> option."
msgstr ""
"Linux 3.16 以降では、これらのシステムコールのサポートは任意となり、利用できる"
"かはカーネルが B<CONFIG_SGETMASK_SYSCALL> オプションを有効にしてコンパイルさ"
"れているかに依存する。"

#.  See nptl/sysdeps/unix/sysv/linux/timer_create.c
#. type: Plain text
#: build/C/man2/timer_create.2:301
msgid ""
"Part of the implementation of the POSIX timers API is provided by glibc.  In "
"particular:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:315
msgid ""
"Much of the functionality for B<SIGEV_THREAD> is implemented within glibc, "
"rather than the kernel.  (This is necessarily so, since the thread involved "
"in handling the notification is one that must be managed by the C library "
"POSIX threads implementation.)  Although the notification delivered to the "
"process is via a thread, internally the NPTL implementation uses a "
"I<sigev_notify> value of B<SIGEV_THREAD_ID> along with a real-time signal "
"that is reserved by the implementation (see B<nptl>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:322
msgid ""
"The implementation of the default case where I<evp> is NULL is handled "
"inside glibc, which invokes the underlying system call with a suitably "
"populated I<sigevent> structure."
msgstr ""

#.  See the glibc source file kernel-posix-timers.h for the structure
#.  that glibc uses to map user-space timer IDs to kernel timer IDs
#.  The kernel-level timer ID is exposed via siginfo.si_tid.
#. type: Plain text
#: build/C/man2/timer_create.2:328
msgid ""
"The timer IDs presented at user level are maintained by glibc, which maps "
"these IDs to the timer IDs employed by the kernel."
msgstr ""

#.  glibc commit 93a78ac437ba44f493333d7e2a4b0249839ce460
#. type: Plain text
#: build/C/man2/timer_create.2:338
msgid ""
"The POSIX timers system calls first appeared in Linux 2.6.  Prior to this, "
"glibc provided an incomplete user-space implementation (B<CLOCK_REALTIME> "
"timers only) using POSIX threads, and in glibc versions before 2.17, the "
"implementation falls back to this technique on systems running pre-2.6 Linux "
"kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:350
msgid ""
"The program below takes two arguments: a sleep period in seconds, and a "
"timer frequency in nanoseconds.  The program establishes a handler for the "
"signal it uses for the timer, blocks that signal, creates and arms a timer "
"that expires with the given frequency, sleeps for the specified number of "
"seconds, and then unblocks the timer signal.  Assuming that the timer "
"expired at least once while the program slept, the signal handler will be "
"invoked, and the handler displays some information about the timer "
"notification.  The program terminates after one invocation of the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:355
msgid ""
"In the following example run, the program sleeps for 1 second, after "
"creating a timer that has a frequency of 100 nanoseconds.  By the time the "
"signal is unblocked and delivered, there have been around ten million "
"overruns."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:367
#, no-wrap
msgid ""
"$ B<./a.out 1 100>\n"
"Establishing handler for signal 34\n"
"Blocking signal 34\n"
"timer ID is 0x804c008\n"
"Sleeping for 1 seconds\n"
"Unblocking signal 34\n"
"Caught signal 34\n"
"    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008\n"
"    overrun count = 10004886\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:378
#, no-wrap
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:381
#, no-wrap
msgid ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"
msgstr ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"

#. type: Plain text
#: build/C/man2/timer_create.2:384
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/timer_create.2:390
#, no-wrap
msgid ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"
msgstr ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:392
#, no-wrap
msgid "    tidp = si-E<gt>si_value.sival_ptr;\n"
msgstr "    tidp = si-E<gt>si_value.sival_ptr;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:395
#, no-wrap
msgid ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = %#jx\\en\", (uintmax_t) *tidp);\n"
msgstr ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = %#jx\\en\", (uintmax_t) *tidp);\n"

#. type: Plain text
#: build/C/man2/timer_create.2:402
#, no-wrap
msgid ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"
msgstr ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:411
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:416
#, no-wrap
msgid ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"
msgstr ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:426
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:432
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timer_create.2:434
#, no-wrap
msgid "    /* Establish handler for timer signal */\n"
msgstr "    /* Establish handler for timer signal */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:441
#, no-wrap
msgid ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:443
#, no-wrap
msgid "    /* Block timer signal temporarily */\n"
msgstr "    /* Block timer signal temporarily */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:449
#, no-wrap
msgid ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:451
#, no-wrap
msgid "    /* Create the timer */\n"
msgstr "    /* Create the timer */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:457
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"
msgstr ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:459
#, no-wrap
msgid "    printf(\"timer ID is %#jx\\en\", (uintmax_t) timerid);\n"
msgstr "    printf(\"timer ID is %#jx\\en\", (uintmax_t) timerid);\n"

#. type: Plain text
#: build/C/man2/timer_create.2:461
#, no-wrap
msgid "    /* Start the timer */\n"
msgstr "    /* Start the timer */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:467
#, no-wrap
msgid ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"
msgstr ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:470
#, no-wrap
msgid ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"
msgstr ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:473
#, no-wrap
msgid ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"
msgstr ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:476
#, no-wrap
msgid ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"
msgstr ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"

#. type: Plain text
#: build/C/man2/timer_create.2:479
#, no-wrap
msgid ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"
msgstr ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:483
#, no-wrap
msgid ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:486 build/C/man2/timerfd_create.2:715
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:502
msgid ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_settime>(2), B<timerfd_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_getcpuclockid>(3), B<pthreads>(7), "
"B<sigevent>(7), B<signal>(7), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_settime>(2), B<timerfd_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_getcpuclockid>(3), B<pthreads>(7), "
"B<sigevent>(7), B<signal>(7), B<time>(7)"

#. type: TH
#: build/C/man2/timer_delete.2:26
#, no-wrap
msgid "TIMER_DELETE"
msgstr "TIMER_DELETE"

#. type: Plain text
#: build/C/man2/timer_delete.2:29
msgid "timer_delete - delete a POSIX per-process timer"
msgstr "timer_delete - プロセス単位の POSIX タイマーを削除する"

#. type: Plain text
#: build/C/man2/timer_delete.2:32 build/C/man2/timer_getoverrun.2:32
#: build/C/man2/timer_settime.2:33
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timer_delete.2:34
#, no-wrap
msgid "B<int timer_delete(timer_t >I<timerid>B<);>\n"
msgstr "B<int timer_delete(timer_t >I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_delete.2:45
msgid "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_delete.2:53
msgid ""
"B<timer_delete>()  deletes the timer whose ID is given in I<timerid>.  If "
"the timer was armed at the time of this call, it is disarmed before being "
"deleted.  The treatment of any pending signal generated by the deleted timer "
"is unspecified."
msgstr ""
"B<timer_delete>() は I<timerid> で指定された ID のタイマーを削除する。 "
"B<timer_delete>() が呼び出された時点でタイマーが開始されている場合は、 削除す"
"る前にタイマーの解除が行われる。 削除されるタイマーにより生成された処理待ちシ"
"グナルの扱いは不定 (unspecified) である。"

#. type: Plain text
#: build/C/man2/timer_delete.2:60
msgid ""
"On success, B<timer_delete>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<timer_delete>() は 0 を返す。 失敗すると、 -1 が返り、 "
"I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/timer_delete.2:65 build/C/man2/timer_getoverrun.2:95
msgid "I<timerid> is not a valid timer ID."
msgstr "I<timerid> が有効なタイマー ID ではない。"

#. type: Plain text
#: build/C/man2/timer_delete.2:75
msgid ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"

#. type: TH
#: build/C/man2/timer_getoverrun.2:26
#, no-wrap
msgid "TIMER_GETOVERRUN"
msgstr "TIMER_GETOVERRUN"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:29
msgid "timer_getoverrun - get overrun count for a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:34
#, no-wrap
msgid "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"
msgstr "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:45
msgid "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:56
msgid ""
"B<timer_getoverrun>()  returns the \"overrun count\" for the timer referred "
"to by I<timerid>.  An application can use the overrun count to accurately "
"calculate the number of timer expirations that would have occurred over a "
"given time interval.  Timer overruns can occur both when receiving "
"expiration notifications via signals (B<SIGEV_SIGNAL>), and via threads "
"(B<SIGEV_THREAD>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:76
msgid ""
"When expiration notifications are delivered via a signal, overruns can occur "
"as follows.  Regardless of whether or not a real-time signal is used for "
"timer notifications, the system queues at most one signal per timer.  (This "
"is the behavior specified by POSIX.1.  The alternative, queuing one signal "
"for each timer expiration, could easily result in overflowing the allowed "
"limits for queued signals on the system.)  Because of system scheduling "
"delays, or because the signal may be temporarily blocked, there can be a "
"delay between the time when the notification signal is generated and the "
"time when it is delivered (e.g., caught by a signal handler) or accepted (e."
"g., using B<sigwaitinfo>(2)).  In this interval, further timer expirations "
"may occur.  The timer overrun count is the number of additional timer "
"expirations that occurred between the time when the signal was generated and "
"when it was delivered or accepted."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:82
msgid ""
"Timer overruns can also occur when expiration notifications are delivered "
"via invocation of a thread, since there may be an arbitrary delay between an "
"expiration of the timer and the invocation of the notification thread, and "
"in that delay interval, additional timer expirations may occur."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:90
msgid ""
"On success, B<timer_getoverrun>()  returns the overrun count of the "
"specified timer; this count may be 0 if no overruns have occurred.  On "
"failure, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:111
msgid ""
"When timer notifications are delivered via signals (B<SIGEV_SIGNAL>), on "
"Linux it is also possible to obtain the overrun count via the I<si_overrun> "
"field of the I<siginfo_t> structure (see B<sigaction>(2)).  This allows an "
"application to avoid the overhead of making a system call to obtain the "
"overrun count, but is a nonportable extension to POSIX.1."
msgstr ""

#.  FIXME . Austin bug filed, 11 Feb 09
#.  https://www.austingroupbugs.net/view.php?id=95
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:116
msgid ""
"POSIX.1 discusses timer overruns only in the context of timer notifications "
"using signals."
msgstr ""

#.  http://bugzilla.kernel.org/show_bug.cgi?id=12665
#.  commit 78c9c4dfbf8c04883941445a195276bb4bb92c76
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:138
msgid ""
"POSIX.1 specifies that if the timer overrun count is equal to or greater "
"than an implementation-defined maximum, B<DELAYTIMER_MAX>, then "
"B<timer_getoverrun>()  should return B<DELAYTIMER_MAX>.  However, before "
"Linux 4.19, if the timer overrun value exceeds the maximum representable "
"integer, the counter cycles, starting once more from low values.  Since "
"Linux 4.19, B<timer_getoverrun>()  returns B<DELAYTIMER_MAX> (defined as "
"B<INT_MAX> in I<E<lt>limits.hE<gt>>)  in this case (and the overrun value is "
"reset to 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:141 build/C/man2/timer_settime.2:212
msgid "See B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:151
msgid ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"

#. type: TH
#: build/C/man2/timer_settime.2:26
#, no-wrap
msgid "TIMER_SETTIME"
msgstr "TIMER_SETTIME"

#. type: Plain text
#: build/C/man2/timer_settime.2:30
msgid ""
"timer_settime, timer_gettime - arm/disarm and fetch state of POSIX per-"
"process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:38
#, no-wrap
msgid ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec *>I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec *>I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec *>I<curr_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:50
msgid ""
"B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""
"B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_settime.2:63
msgid ""
"B<timer_settime>()  arms or disarms the timer identified by I<timerid>.  The "
"I<new_value> argument is pointer to an I<itimerspec> structure that "
"specifies the new initial value and the new interval for the timer.  The "
"I<itimerspec> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:70 build/C/man2/timerfd_create.2:165
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:75
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:87
msgid ""
"Each of the substructures of the I<itimerspec> structure is a I<timespec> "
"structure that allows a time value to be specified in seconds and "
"nanoseconds.  These time values are measured according to the clock that was "
"specified when the timer was created by B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:101
msgid ""
"If I<new_value-E<gt>it_value> specifies a nonzero value (i.e., either "
"subfield is nonzero), then B<timer_settime>()  arms (starts) the timer, "
"setting it to initially expire at the given time.  (If the timer was already "
"armed, then the previous settings are overwritten.)  If I<new_value-"
"E<gt>it_value> specifies a zero value (i.e., both subfields are zero), then "
"the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:113
msgid ""
"The I<new_value-E<gt>it_interval> field specifies the period of the timer, "
"in seconds and nanoseconds.  If this field is nonzero, then each time that "
"an armed timer expires, the timer is reloaded from the value specified in "
"I<new_value-E<gt>it_interval>.  If I<new_value-E<gt>it_interval> specifies a "
"zero value, then the timer expires just once, at the time specified by "
"I<it_value>."
msgstr ""

#.  By experiment: the overrun count is set correctly, for CLOCK_REALTIME.
#. type: Plain text
#: build/C/man2/timer_settime.2:134
msgid ""
"By default, the initial expiration time specified in I<new_value-"
"E<gt>it_value> is interpreted relative to the current time on the timer's "
"clock at the time of the call.  This can be modified by specifying "
"B<TIMER_ABSTIME> in I<flags>, in which case I<new_value-E<gt>it_value> is "
"interpreted as an absolute value as measured on the timer's clock; that is, "
"the timer will expire when the clock value reaches the value specified by "
"I<new_value-E<gt>it_value>.  If the specified absolute time has already "
"passed, then the timer expires immediately, and the overrun count (see "
"B<timer_getoverrun>(2))  will be set correctly."
msgstr ""

#.  Similar remarks might apply with respect to process and thread CPU time
#.  clocks, but these clocks are not currently (2.6.28) settable on Linux.
#. type: Plain text
#: build/C/man2/timer_settime.2:144
msgid ""
"If the value of the B<CLOCK_REALTIME> clock is adjusted while an absolute "
"timer based on that clock is armed, then the expiration of the timer will be "
"appropriately adjusted.  Adjustments to the B<CLOCK_REALTIME> clock have no "
"effect on relative timers based on that clock."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:153
msgid ""
"If I<old_value> is not NULL, then it points to a buffer that is used to "
"return the previous interval of the timer (in I<old_value-"
"E<gt>it_interval>)  and the amount of time until the timer would previously "
"have next expired (in I<old_value-E<gt>it_value>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:173
msgid ""
"B<timer_gettime>()  returns the time until next expiration, and the "
"interval, for the timer specified by I<timerid>, in the buffer pointed to by "
"I<curr_value>.  The time remaining until the next timer expiration is "
"returned in I<curr_value-E<gt>it_value>; this is always a relative value, "
"regardless of whether the B<TIMER_ABSTIME> flag was used when arming the "
"timer.  If the value returned in I<curr_value-E<gt>it_value> is zero, then "
"the timer is currently disarmed.  The timer interval is returned in "
"I<curr_value-E<gt>it_interval>.  If the value returned in I<curr_value-"
"E<gt>it_interval> is zero, then this is a \"one-shot\" timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:182
msgid ""
"On success, B<timer_settime>()  and B<timer_gettime>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:184
msgid "These functions may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:191
msgid "I<new_value>, I<old_value>, or I<curr_value> is not a valid pointer."
msgstr ""

#.  FIXME . eventually: invalid value in flags
#. type: Plain text
#: build/C/man2/timer_settime.2:196
msgid "I<timerid> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:199
msgid "B<timer_settime>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:205
msgid ""
"I<new_value.it_value> is negative; or I<new_value.it_value.tv_nsec> is "
"negative or greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:207
msgid "These system calls are available since Linux 2.6."
msgstr "これらのシステムコールは Linux 2.6 以降で利用可能である。"

#. type: Plain text
#: build/C/man2/timer_settime.2:216
msgid "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"
msgstr "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"

#. type: TH
#: build/C/man2/timerfd_create.2:19
#, no-wrap
msgid "TIMERFD_CREATE"
msgstr "TIMERFD_CREATE"

#. type: Plain text
#: build/C/man2/timerfd_create.2:23
msgid ""
"timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via "
"file descriptors"
msgstr ""
"timerfd_create, timerfd_settime, timerfd_gettime - ファイルディスクリプター経"
"由で通知するタイマー"

#. type: Plain text
#: build/C/man2/timerfd_create.2:26
#, no-wrap
msgid "B<#include E<lt>sys/timerfd.hE<gt>>\n"
msgstr "B<#include E<lt>sys/timerfd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:28
#, no-wrap
msgid "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"
msgstr "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:32
#, no-wrap
msgid ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"
msgstr ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:34
#, no-wrap
msgid "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:47
msgid ""
"These system calls create and operate on a timer that delivers timer "
"expiration notifications via a file descriptor.  They provide an alternative "
"to the use of B<setitimer>(2)  or B<timer_create>(2), with the advantage "
"that the file descriptor may be monitored by B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""
"これらのシステムコールは、満了通知をファイルディスクリプター経由で配送する タ"
"イマーの生成と操作を行う。 これらは、 B<setitimer>(2)  や "
"B<timer_create>(2)  を用いる方法の代わりとなるものであり、このファイルディス"
"クリプターを B<select>(2), B<poll>(2), B<epoll>(7)  で監視できるという利点が"
"ある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:59
msgid ""
"The use of these three system calls is analogous to the use of "
"B<timer_create>(2), B<timer_settime>(2), and B<timer_gettime>(2).  (There is "
"no analog of B<timer_getoverrun>(2), since that functionality is provided by "
"B<read>(2), as described below.)"
msgstr ""
"これらのシステムコールを使うのは、それぞれ B<timer_create>(2), "
"B<timer_settime>(2), B<timer_gettime>(2)  を使うのと同様である "
"(B<timer_getoverrun>(2)  に対応するものはなく、以下で説明するように この機能"
"は B<read>(2)  により提供される)。"

#. type: SS
#: build/C/man2/timerfd_create.2:59
#, no-wrap
msgid "timerfd_create()"
msgstr "timerfd_create()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:67
msgid ""
"B<timerfd_create>()  creates a new timer object, and returns a file "
"descriptor that refers to that timer.  The I<clockid> argument specifies the "
"clock that is used to mark the progress of the timer, and must be one of the "
"following:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:75
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 3.15)"
msgstr "B<CLOCK_BOOTTIME> (Linux 3.15 以降)"

#. type: TP
#: build/C/man2/timerfd_create.2:90
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.11)"
msgstr "B<CLOCK_REALTIME_ALARM> (Linux 3.11 以降)"

#. type: TP
#: build/C/man2/timerfd_create.2:99
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.11)"
msgstr "B<CLOCK_BOOTTIME_ALARM> (Linux 3.11 以降)"

#. type: Plain text
#: build/C/man2/timerfd_create.2:115
msgid ""
"The current value of each of these clocks can be retrieved using "
"B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:120
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<timerfd_create>():"
msgstr ""
"Linux 2.6.27 以降では、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<timerfd_create>()  の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/timerfd_create.2:120
#, no-wrap
msgid "B<TFD_NONBLOCK>"
msgstr "B<TFD_NONBLOCK>"

#. type: TP
#: build/C/man2/timerfd_create.2:130
#, no-wrap
msgid "B<TFD_CLOEXEC>"
msgstr "B<TFD_CLOEXEC>"

#. type: Plain text
#: build/C/man2/timerfd_create.2:144
msgid ""
"In Linux versions up to and including 2.6.26, I<flags> must be specified as "
"zero."
msgstr ""
"バージョン 2.6.26 以前の Linux では、 I<flags> 引数は未使用であり、0 を指定"
"しなければならない。"

#. type: SS
#: build/C/man2/timerfd_create.2:144
#, no-wrap
msgid "timerfd_settime()"
msgstr "timerfd_settime()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:149
msgid ""
"B<timerfd_settime>()  arms (starts) or disarms (stops)  the timer referred "
"to by the file descriptor I<fd>."
msgstr ""
"B<timerfd_settime>()  は、ファイルディスクリプター I<fd> により参照されるタイ"
"マーを開始したり停止したりする。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:158
msgid ""
"The I<new_value> argument specifies the initial expiration and interval for "
"the timer.  The I<itimerspec> structure used for this argument contains two "
"fields, each of which is in turn a structure of type I<timespec>:"
msgstr ""
"I<new_value> 引数は、タイマーの満了時間 (expiration) の初期値と間隔 "
"(interval) を 指定する。この引数で使用されている I<itimerspec> 構造体には "
"2 つのフィールドがあり、各フィールドは I<timespec> 型の構造体である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:170
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:182
msgid ""
"I<new_value.it_value> specifies the initial expiration of the timer, in "
"seconds and nanoseconds.  Setting either field of I<new_value.it_value> to a "
"nonzero value arms the timer.  Setting both fields of I<new_value.it_value> "
"to zero disarms the timer."
msgstr ""
"I<new_value.it_value> はタイマーの満了時間の初期値を、秒とナノ秒で指定する。 "
"I<new_value.it_value> のフィールドのうち少なくとも一方に 0 以外の値を設定する"
"と、 タイマーが開始される。 両方のフィールドに 0 を設定すると、タイマーが停止"
"する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:191
msgid ""
"Setting one or both fields of I<new_value.it_interval> to nonzero values "
"specifies the period, in seconds and nanoseconds, for repeated timer "
"expirations after the initial expiration.  If both fields of I<new_value."
"it_interval> are zero, the timer expires just once, at the time specified by "
"I<new_value.it_value>."
msgstr ""
"I<new_value.it_interval> はタイマーの一回目の満了後に繰り返しタイマーの満了間"
"隔を、秒とナノ秒で指定する。 I<new_value.it_interval> のフィールドのうち少な"
"くとも一方に 0 以外の値を設定すると、 繰り返しタイマーが有効になる。 両方の"
"フィールドに 0 を設定した場合、タイマーは I<new_value.it_value> で指定された"
"時間後に、一回だけ満了して停止する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:203
msgid ""
"By default, the initial expiration time specified in I<new_value> is "
"interpreted relative to the current time on the timer's clock at the time of "
"the call (i.e., I<new_value.it_value> specifies a time relative to the "
"current value of the clock specified by I<clockid>).  An absolute timeout "
"can be selected via the I<flags> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:207
#, fuzzy
#| msgid ""
#| "The I<siginfo_t> argument to I<sa_sigaction> is a struct with the "
#| "following fields:"
msgid ""
"The I<flags> argument is a bit mask that can include the following values:"
msgstr ""
"I<sa_sigaction> のパラメーター I<siginfo_t> は以下のフィールドを持つ構造体で"
"ある:"

#. type: TP
#: build/C/man2/timerfd_create.2:207
#, no-wrap
msgid "B<TFD_TIMER_ABSTIME>"
msgstr "B<TFD_TIMER_ABSTIME>"

#. type: Plain text
#: build/C/man2/timerfd_create.2:215
msgid ""
"Interpret I<new_value.it_value> as an absolute value on the timer's clock.  "
"The timer will expire when the value of the timer's clock reaches the value "
"specified in I<new_value.it_value>."
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:215
#, no-wrap
msgid "B<TFD_TIMER_CANCEL_ON_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:232
msgid ""
"If this flag is specified along with B<TFD_TIMER_ABSTIME> and the clock for "
"this timer is B<CLOCK_REALTIME> or B<CLOCK_REALTIME_ALARM>, then mark this "
"timer as cancelable if the real-time clock undergoes a discontinuous change "
"(B<settimeofday>(2), B<clock_settime>(2), or similar).  When such changes "
"occur, a current or future B<read>(2)  from the file descriptor will fail "
"with the error B<ECANCELED>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:243
msgid ""
"If the I<old_value> argument is not NULL, then the I<itimerspec> structure "
"that it points to is used to return the setting of the timer that was "
"current at the time of the call; see the description of "
"B<timerfd_gettime>()  following."
msgstr ""
"I<old_value> 引数が NULL でない場合、 I<old_value> 引数が指す "
"I<itimerspec> 構造体は、 B<timerfd_settime>() を呼び出した時点でのタイマーの"
"設定を返すのに使用される。 下記の B<timerfd_gettime>() の説明を参照。"

#. type: SS
#: build/C/man2/timerfd_create.2:243
#, no-wrap
msgid "timerfd_gettime()"
msgstr "timerfd_gettime()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:252
msgid ""
"B<timerfd_gettime>()  returns, in I<curr_value>, an I<itimerspec> structure "
"that contains the current setting of the timer referred to by the file "
"descriptor I<fd>."
msgstr ""
"B<timerfd_gettime>()  は、ファイルディスクリプター I<fd> で参照されるタイマー"
"の現在の設定が入った I<itimerspec> 構造体を、 I<curr_value> に格納して返す。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:262
msgid ""
"The I<it_value> field returns the amount of time until the timer will next "
"expire.  If both fields of this structure are zero, then the timer is "
"currently disarmed.  This field always contains a relative value, regardless "
"of whether the B<TFD_TIMER_ABSTIME> flag was specified when setting the "
"timer."
msgstr ""
"I<it_value> フィールドは、タイマーが次に満了するまでの残り時間を返す。 この構"
"造体の両方のフィールドが 0 であれば、タイマーは現在停止している。 タイマー設"
"定時に B<TFD_TIMER_ABSTIME> フラグが指定されたかに関わらず、このフィールドは"
"常に相対値が格納される。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:269
msgid ""
"The I<it_interval> field returns the interval of the timer.  If both fields "
"of this structure are zero, then the timer is set to expire just once, at "
"the time specified by I<curr_value.it_value>."
msgstr ""
"I<it_interval> フィールドは、タイマーの間隔を返す。 この構造体の両方のフィー"
"ルドが 0 であれば、タイマーは I<new_value.it_value> で指定された時間後に一回"
"だけ満了して停止するように設定されている。"

#. type: SS
#: build/C/man2/timerfd_create.2:269
#, no-wrap
msgid "Operating on a timer file descriptor"
msgstr "タイマーファイルディスクリプターに対する操作"

#. type: Plain text
#: build/C/man2/timerfd_create.2:273
#, fuzzy
#| msgid ""
#| "The file descriptor returned by B<timerfd_create>()  supports the "
#| "following operations:"
msgid ""
"The file descriptor returned by B<timerfd_create>()  supports the following "
"additional operations:"
msgstr ""
"B<timerfd_create>()  が返すファイルディスクリプターは以下の操作をサポートして"
"いる。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:287
msgid ""
"If the timer has already expired one or more times since its settings were "
"last modified using B<timerfd_settime>(), or since the last successful "
"B<read>(2), then the buffer given to B<read>(2)  returns an unsigned 8-byte "
"integer (I<uint64_t>)  containing the number of expirations that have "
"occurred.  (The returned value is in host byte order\\(emthat is, the native "
"byte order for integers on the host machine.)"
msgstr ""
"B<timerfd_settime>()  を使ってタイマーの設定が最後変更されて以降、または "
"B<read>(2)  の呼び出しに最後に成功して以降に、タイマーの満了が一回以上発生し"
"ていれば、 B<read>(2)  に渡されたバッファーに、タイマー満了回数を示す 8 バイ"
"トの unsigned 型の整数 (I<uint64_t>)  が返される (返される値はホストバイト"
"オーダ、つまりそのホストマシンにおける 整数の通常のバイトオーダである)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:300
msgid ""
"If no timer expirations have occurred at the time of the B<read>(2), then "
"the call either blocks until the next timer expiration, or fails with the "
"error B<EAGAIN> if the file descriptor has been made nonblocking (via the "
"use of the B<fcntl>(2)  B<F_SETFL> operation to set the B<O_NONBLOCK> flag)."
msgstr ""
"B<read>(2)  を行った時点でタイマーの満了が発生していなければ、 B<read>(2)  は"
"停止 (block) する、もしくはファイルディスクリプターが 非停止 (nonblocking) に"
"設定されている場合はエラー B<EAGAIN> で失敗する (非停止モードにするには、 "
"B<fcntl>(2)  の B<F_SETFL> 命令で B<O_NONBLOCK> フラグをセットする)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:306
msgid ""
"A B<read>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes."
msgstr ""
"渡されたバッファーの大きさが 8 バイト未満の場合、 B<read>(2)  はエラー "
"B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:324
msgid ""
"If the associated clock is either B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM>, the timer is absolute (B<TFD_TIMER_ABSTIME>), and "
"the flag B<TFD_TIMER_CANCEL_ON_SET> was specified when calling "
"B<timerfd_settime>(), then B<read>(2)  fails with the error B<ECANCELED> if "
"the real-time clock undergoes a discontinuous change.  (This allows the "
"reading application to discover such discontinuous changes to the clock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:346
msgid ""
"If the associated clock is either B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM>, the timer is absolute (B<TFD_TIMER_ABSTIME>), and "
"the flag B<TFD_TIMER_CANCEL_ON_SET> was I<not> specified when calling "
"B<timerfd_settime>(), then a discontinuous negative change to the clock (e."
"g., B<clock_settime>(2))  may cause B<read>(2)  to unblock, but return a "
"value of 0 (i.e., no bytes read), if the clock change occurs after the time "
"expired, but before the B<read>(2)  on the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:357
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more timer expirations have occurred."
msgstr ""
"一つ以上のタイマー満了が発生していれば、 ファイルディスクリプターは読み出し可"
"能となる (B<select>(2)  の I<readfds> 引数や B<poll>(2)  の B<POLLIN> フラ"
"グ)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:364
msgid ""
"The file descriptor also supports the other file-descriptor multiplexing "
"APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"このファイルディスクリプターは、他のファイルディスクリプター多重 API である "
"B<pselect>(2), B<ppoll>(2), B<epoll>(7)  もサポートしている。"

#. type: TP
#: build/C/man2/timerfd_create.2:364
#, no-wrap
msgid "B<ioctl>(2)"
msgstr "B<ioctl>(2)"

#. type: Plain text
#: build/C/man2/timerfd_create.2:367
msgid "The following timerfd-specific command is supported:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:368
#, no-wrap
msgid "B<TFD_IOC_SET_TICKS> (since Linux 3.17)"
msgstr "B<TFD_IOC_SET_TICKS> (Linux 3.17 以降)"

#.  commit 5442e9fbd7c23172a1c9bc736629cd123a9923f0
#. type: Plain text
#: build/C/man2/timerfd_create.2:381
msgid ""
"Adjust the number of timer expirations that have occurred.  The argument is "
"a pointer to a nonzero 8-byte integer (I<uint64_t>*)  containing the new "
"number of expirations.  Once the number is set, any waiter on the timer is "
"woken up.  The only purpose of this command is to restore the expirations "
"for the purpose of checkpoint/restore.  This operation is available only if "
"the kernel was configured with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:389
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same timer object have been closed, "
"the timer is disarmed and its resources are freed by the kernel."
msgstr ""
"ファイルディスクリプターがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ timer オブジェクトに関連付けられたファイルディスクリプターが全て ク"
"ローズされると、そのタイマーは解除され、 そのオブジェクト用の資源がカーネルに"
"より解放される。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:401
msgid ""
"After a B<fork>(2), the child inherits a copy of the file descriptor created "
"by B<timerfd_create>().  The file descriptor refers to the same underlying "
"timer object as the corresponding file descriptor in the parent, and "
"B<read>(2)s in the child will return information about expirations of the "
"timer."
msgstr ""
"B<fork>(2)  が行われると、子プロセスは B<timerfd_create>()  により生成された"
"ファイルディスクリプターのコピーを 継承する。そのファイルディスクリプターは、"
"親プロセスの対応する ファイルディスクリプターと同じタイマーオブジェクトを参照"
"しており、 子プロセスの B<read>(2)  でも同じタイマーの満了に関する情報が返さ"
"れる。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:407
msgid ""
"A file descriptor created by B<timerfd_create>()  is preserved across "
"B<execve>(2), and continues to generate timer expirations if the timer was "
"armed."
msgstr ""
"B<execve>(2)  の前後で B<timerfd_create>()  により生成されたファイルディスク"
"リプターは保持され、 タイマーが開始されていた場合にはタイマーの満了が発生し続"
"ける。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:414
msgid ""
"On success, B<timerfd_create>()  returns a new file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<timerfd_create>()  は新しいファイルディスクリプターを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:422
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  return 0 on success; on "
"error they return -1, and set I<errno> to indicate the error."
msgstr ""
"B<timerfd_settime>()  と B<timerfd_gettime>()  は成功すると 0 を返す。 エラー"
"の場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:425
msgid "B<timerfd_create>()  can fail with the following errors:"
msgstr "B<timerfd_create>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:430
msgid "The I<clockid> is not valid."
msgstr "I<clockid> が有効ではない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:450
msgid "There was insufficient kernel memory to create the timer."
msgstr "タイマーを作成するのに十分なカーネルメモリーがなかった。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:465
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  can fail with the following "
"errors:"
msgstr ""
"B<timerfd_settime>()  と B<timerfd_gettime>()  は以下のエラーで失敗する可能性"
"がある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:469
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:480
msgid "I<fd> is not a valid timerfd file descriptor."
msgstr "I<fd> が有効な timerfd ファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:483
msgid "B<timerfd_settime>()  can also fail with the following errors:"
msgstr "B<timerfd_settime>()  は以下のエラーで失敗することもある。"

#. type: TP
#: build/C/man2/timerfd_create.2:483
#, no-wrap
msgid "B<ECANCELED>"
msgstr "B<ECANCELED>"

#. type: Plain text
#: build/C/man2/timerfd_create.2:486
msgid "See NOTES."
msgstr "「注意」を参照。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:492
msgid ""
"I<new_value> is not properly initialized (one of the I<tv_nsec> falls "
"outside the range zero to 999,999,999)."
msgstr ""
"I<new_value> が適切に初期化されていない (I<tv_nsec> の一つが 0 から "
"999,999,999 までの範囲に入っていない)。"

#.  This case only checked since 2.6.29, and 2.2.2[78].some-stable-version.
#.  In older kernel versions, no check was made for invalid flags.
#. type: Plain text
#: build/C/man2/timerfd_create.2:498
msgid "I<flags> is invalid."
msgstr "I<flags> が無効である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:501
msgid ""
"These system calls are available on Linux since kernel 2.6.25.  Library "
"support is provided by glibc since version 2.8."
msgstr ""
"これらのシステムコールはカーネル 2.6.25 以降の Linux で利用可能である。 ライ"
"ブラリ側のサポートはバージョン 2.8 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:510
msgid ""
"Suppose the following scenario for B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM> timer that was created with B<timerfd_create>():"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:510
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:518
msgid ""
"The timer has been started (B<timerfd_settime>())  with the "
"B<TFD_TIMER_ABSTIME> and B<TFD_TIMER_CANCEL_ON_SET> flags;"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:518
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:524
msgid ""
"A discontinuous change (e.g., B<settimeofday>(2))  is subsequently made to "
"the B<CLOCK_REALTIME> clock; and"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:524
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:530
msgid ""
"the caller once more calls B<timerfd_settime>()  to rearm the timer (without "
"first doing a B<read>(2)  on the file descriptor)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:532
msgid "In this case the following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:541
msgid ""
"The B<timerfd_settime>()  returns -1 with I<errno> set to B<ECANCELED>.  "
"(This enables the caller to know that the previous timer was affected by a "
"discontinuous change to the clock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:549
msgid ""
"The timer I<is successfully rearmed> with the settings provided in the "
"second B<timerfd_settime>()  call.  (This was probably an implementation "
"accident, but won't be fixed now, in case there are applications that depend "
"on this behaviour.)"
msgstr ""

#.  2.6.29
#. type: Plain text
#: build/C/man2/timerfd_create.2:555
msgid ""
"Currently, B<timerfd_create>()  supports fewer types of clock IDs than "
"B<timer_create>(2)."
msgstr ""
"現在のところ、 B<timerfd_create>()  が対応している clockid の種類は "
"B<timer_create>(2)  よりも少ない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:564
msgid ""
"The following program creates a timer and then monitors its progress.  The "
"program accepts up to three command-line arguments.  The first argument "
"specifies the number of seconds for the initial expiration of the timer.  "
"The second argument specifies the interval for the timer, in seconds.  The "
"third argument specifies the number of times the program should allow the "
"timer to expire before terminating.  The second and third command-line "
"arguments are optional."
msgstr ""
"以下のプログラムは、タイマーを作成し、その進捗をモニターするものである。 この"
"プログラムは最大で 3 個のコマンドライン引数を取り、 第一引数ではタイマー"
"の満了時間の初期値 (秒数単位) を、 第二引数ではタイマーの間隔 (秒数単位) "
"を、 第三引数ではタイマーが何回満了したらプログラムが終了するかを指定す"
"る。 第二引数と第三引数は省略可能である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:566 build/C/man2/wait.2:640
msgid "The following shell session demonstrates the use of the program:"
msgstr "以下のシェルのセッションはこのプログラムの使用例を示したものである。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:581
#, no-wrap
msgid ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<\\(haZ >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<\\(haC >                 # type control-C to suspend the program\n"
msgstr ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<\\(haZ >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<\\(haC >                 # type control-C to suspend the program\n"

#.  The commented out code here is what we currently need until
#.  the required stuff is in glibc
#. /* Link with -lrt */
#. #define _GNU_SOURCE
#. #include <sys/syscall.h>
#. #include <unistd.h>
#. #include <time.h>
#. #if defined(__i386__)
#. #define __NR_timerfd_create 322
#. #define __NR_timerfd_settime 325
#. #define __NR_timerfd_gettime 326
#. #endif
#. static int
#. timerfd_create(int clockid, int flags)
#. {
#.     return syscall(__NR_timerfd_create, clockid, flags);
#. }
#. static int
#. timerfd_settime(int fd, int flags, struct itimerspec *new_value,
#.         struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_settime, fd, flags, new_value,
#.                    curr_value);
#. }
#. static int
#. timerfd_gettime(int fd, struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_gettime, fd, curr_value);
#. }
#. #define TFD_TIMER_ABSTIME (1 << 0)
#. ////////////////////////////////////////////////////////////
#. type: Plain text
#: build/C/man2/timerfd_create.2:631
#, no-wrap
msgid ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>      /* Definition of PRIu64 */\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>      /* Definition of PRIu64 */\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:634
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:642
#, no-wrap
msgid ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"
msgstr ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:648
#, no-wrap
msgid ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"
msgstr ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:651
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:660
#, no-wrap
msgid ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"
msgstr ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:669
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:675
#, no-wrap
msgid ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:678
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:681
#, no-wrap
msgid ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"
msgstr ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:692
#, no-wrap
msgid ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"
msgstr ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:696
#, no-wrap
msgid ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"
msgstr ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:699
#, no-wrap
msgid ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"
msgstr ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:702
#, no-wrap
msgid ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"
msgstr ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:707
#, no-wrap
msgid ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
msgstr ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:712
#, no-wrap
msgid ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %\" PRIu64 \"; total=%\" PRIu64 \"\\en\", exp, tot_exp);\n"
"    }\n"
msgstr ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %\" PRIu64 \"; total=%\" PRIu64 \"\\en\", exp, tot_exp);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:728
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<epoll>(7), B<time>(7)"
msgstr ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<epoll>(7), B<time>(7)"

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "TKILL"
msgstr "TKILL"

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man2/tkill.2:32
msgid "tkill, tgkill - send a signal to a thread"
msgstr "tkill, tgkill - スレッドにシグナルを送る"

#. type: Plain text
#: build/C/man2/tkill.2:35
#, no-wrap
msgid "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"
msgstr "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/tkill.2:37
#, no-wrap
msgid "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"
msgstr "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/tkill.2:43
msgid "I<Note>: There is no glibc wrapper for B<tkill>(); see NOTES."
msgstr "I<注>: B<tkill>() には、glibc のラッパー関数はない。「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/tkill.2:56
msgid ""
"B<tgkill>()  sends the signal I<sig> to the thread with the thread ID I<tid> "
"in the thread group I<tgid>.  (By contrast, B<kill>(2)  can be used to send "
"a signal only to a process (i.e., thread group)  as a whole, and the signal "
"will be delivered to an arbitrary thread within that process.)"
msgstr ""
"B<tgkill>()  はスレッドグループ I<tgid> に属するスレッド ID が I<tid> のス"
"レッドにシグナル I<sig> を送る。 (これに対し、 B<kill>(2)  は一つのプロセス "
"(すなわち、スレッドグループ) にまとめてシグナルを 送るのにだけ利用できる。 "
"B<kill>(2)  で送信されたシグナルはプロセス内の任意のスレッドに配送される。)"

#.  FIXME Maybe say something about the following:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12889
#.  Quoting Rich Felker <bugdal@aerifal.cx>:
#.  There is a race condition in pthread_kill: it is possible that,
#.  between the time pthread_kill reads the pid/tid from the target
#.  thread descriptor and the time it makes the tgkill syscall,
#.  the target thread terminates and the same tid gets assigned
#.  to a new thread in the same process.
#.  (The tgkill syscall was designed to eliminate a similar race
#.  condition in tkill, but it only succeeded in eliminating races
#.  where the tid gets reused in a different process, and does not
#.  help if the same tid gets assigned to a new thread in the
#.  same process.)
#.  The only solution I can see is to introduce a mutex that ensures
#.  that a thread cannot exit while pthread_kill is being called on it.
#.  Note that in most real-world situations, like almost all race
#.  conditions, this one will be extremely rare. To make it
#.  measurable, one could exhaust all but 1-2 available pid values,
#.  possibly by lowering the max pid parameter in /proc, forcing
#.  the same tid to be reused rapidly.
#. type: Plain text
#: build/C/man2/tkill.2:89
msgid ""
"B<tkill>()  is an obsolete predecessor to B<tgkill>().  It allows only the "
"target thread ID to be specified, which may result in the wrong thread being "
"signaled if a thread terminates and its thread ID is recycled.  Avoid using "
"this system call."
msgstr ""
"B<tkill>()  はもう使われなくなった B<tgkill>()  の先祖である。 B<tkill>()  で"
"はシグナルの送り先のスレッド ID しか指定できない。 そのため、スレッドが終了し"
"て、そのスレッド ID が再利用される場合に、 意図しないスレッドにシグナルが送ら"
"れる可能性がある。 このシステムコールの使用は避けること。"

#. type: Plain text
#: build/C/man2/tkill.2:92
msgid ""
"These are the raw system call interfaces, meant for internal thread library "
"use."
msgstr ""
"これらはシステムコールへの直接のインターフェースであり、 スレッドライブラリ内"
"部での使用を意図したものである。"

#. type: Plain text
#: build/C/man2/tkill.2:104
msgid ""
"The B<RLIMIT_SIGPENDING> resource limit was reached and I<sig> is a real-"
"time signal."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:109
msgid ""
"Insufficient kernel memory was available and I<sig> is a real-time signal."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:112
msgid "An invalid thread ID, thread group ID, or signal was specified."
msgstr "指定されたスレッド ID、スレッドグループ ID、シグナルが不正であった。"

#. type: Plain text
#: build/C/man2/tkill.2:117
msgid "Permission denied.  For the required permissions, see B<kill>(2)."
msgstr ""
"許可がなかった。どのような許可が必要かについては、 B<kill>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/tkill.2:120
msgid "No process with the specified thread ID (and thread group ID) exists."
msgstr ""
"指定されたスレッドID (とスレッドグループID) を持つプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/tkill.2:125
msgid ""
"B<tkill>()  is supported since Linux 2.4.19 / 2.5.4.  B<tgkill>()  was added "
"in Linux 2.5.75."
msgstr ""
"B<tkill>()  は Linux 2.4.19 / 2.5.4 以降でサポートされ、 B<tgkill>()  は "
"Linux 2.5.75 で追加された。"

#. type: Plain text
#: build/C/man2/tkill.2:129
msgid "Library support for B<tgkill>()  was added to glibc in version 2.30."
msgstr "B<tgkill>() のライブラリでのサポートは glibc バージョン 2.30 で追加された。"

#. type: Plain text
#: build/C/man2/tkill.2:135
msgid ""
"B<tkill>()  and B<tgkill>()  are Linux-specific and should not be used in "
"programs that are intended to be portable."
msgstr ""
"B<tkill>()  と B<tgkill>()  は Linux 固有であり、 移植を想定したプログラムで"
"は使用すべきではない。"

#. type: Plain text
#: build/C/man2/tkill.2:141
msgid ""
"See the description of B<CLONE_THREAD> in B<clone>(2)  for an explanation of "
"thread groups."
msgstr ""
"スレッドグループの説明については B<clone>(2)  の B<CLONE_THREAD> の説明を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/tkill.2:148
msgid ""
"Glibc does not provide a wrapper for B<tkill>(); call it using "
"B<syscall>(2).  Before glibc 2.30, there was also no wrapper function for "
"B<tgkill>()."
msgstr "glibc は B<tkill>() に対するラッパー関数を提供していない。 B<syscall>(2) を使用すること。 glibc 2.30 より前では、 B<tgkill>() に対するラッパー関数も存在しない。"

#. type: Plain text
#: build/C/man2/tkill.2:153
msgid "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"
msgstr "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"

#. type: TH
#: build/C/man2/wait.2:49
#, no-wrap
msgid "WAIT"
msgstr "WAIT"

#. type: Plain text
#: build/C/man2/wait.2:52
msgid "wait, waitpid, waitid - wait for process to change state"
msgstr "wait, waitpid, waitid - プロセスの状態変化を待つ"

#. type: Plain text
#: build/C/man2/wait.2:54
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/wait.2:56
msgid "B<#include E<lt>sys/wait.hE<gt>>"
msgstr "B<#include E<lt>sys/wait.hE<gt>>"

#. type: Plain text
#: build/C/man2/wait.2:58
msgid "B<pid_t wait(int *>I<wstatus>B<);>"
msgstr "B<pid_t wait(int *>I<wstatus>B<);>"

#. type: Plain text
#: build/C/man2/wait.2:60
msgid ""
"B<pid_t waitpid(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<);>"
msgstr "B<pid_t waitpid(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<);>"

#. type: Plain text
#: build/C/man2/wait.2:65
#, no-wrap
msgid ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, int >I<options>B<);>\n"
"                /* This is the glibc and POSIX interface; see\n"
"                   NOTES for information on the raw system call. */\n"
msgstr ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, int >I<options>B<);>\n"
"                /* これは glibc と POSIX のインターフェイスである。\n"
"                   生のシステムコールについての情報は「注意」の節を参照。 */\n"

#. type: Plain text
#: build/C/man2/wait.2:74
msgid "B<waitid>():"
msgstr "B<waitid>():"

#.     (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man2/wait.2:79
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"_XOPEN_SOURCE E<gt>= 500 ||\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""
"glibc 2.26 以降:\n"
"_XOPEN_SOURCE E<gt>= 500 ||\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"

#. type: Plain text
#: build/C/man2/wait.2:84
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"glibc 2.25 以前:\n"
"    _XOPEN_SOURCE\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/wait.2:97
msgid ""
"All of these system calls are used to wait for state changes in a child of "
"the calling process, and obtain information about the child whose state has "
"changed.  A state change is considered to be: the child terminated; the "
"child was stopped by a signal; or the child was resumed by a signal.  In the "
"case of a terminated child, performing a wait allows the system to release "
"the resources associated with the child; if a wait is not performed, then "
"the terminated child remains in a \"zombie\" state (see NOTES below)."
msgstr ""
"これらのシステムコールはいずれも、呼び出し元プロセスの子プロセスの 状態変化を"
"待ち、状態が変化したその子プロセスの情報を取得するのに 使用される。 状態変化"
"とは以下のいずれかである: 子プロセスの終了、シグナルによる子プロセスの停止、 "
"シグナルによる子プロセスの再開。 子プロセスが終了した場合は、wait を実行する"
"ことで、 システムがその子プロセスに関連するリソースを解放できるようになる。 "
"wait が実行されなかった場合には、終了した子プロセスは 「ゾンビ」状態で残り続"
"ける (下記の注意の章を参照のこと)。"

#. type: Plain text
#: build/C/man2/wait.2:109
msgid ""
"If a child has already changed state, then these calls return immediately.  "
"Otherwise, they block until either a child changes state or a signal handler "
"interrupts the call (assuming that system calls are not automatically "
"restarted using the B<SA_RESTART> flag of B<sigaction>(2)).  In the "
"remainder of this page, a child whose state has changed and which has not "
"yet been waited upon by one of these system calls is termed I<waitable>."
msgstr ""
"子プロセスの状態変化がすでに発生していた場合、これらのコールは すぐに復帰す"
"る。それ以外の場合は、子プロセスの状態変化が起こるか、 シグナルハンドラーによ"
"りシステムコールが中断されるまで、 停止 (block) する (後者は、 "
"B<sigaction>(2)  の B<SA_RESTART> フラグによりシステムコールが自動的に再ス"
"タートするようになっていない 場合の動作である)。 以下の説明では、状態変化が起"
"こったがこれらのシステムコールのいずれかに よって待たれていない子プロセスを "
"I<waitable> (待ち可能) と呼ぶ。"

#. type: SS
#: build/C/man2/wait.2:109
#, no-wrap
msgid "wait() and waitpid()"
msgstr "wait() と waitpid()"

#. type: Plain text
#: build/C/man2/wait.2:117
msgid ""
"The B<wait>()  system call suspends execution of the calling thread until "
"one of its children terminates.  The call I<wait(&wstatus)> is equivalent to:"
msgstr "B<wait>()  システムコールは、子プロセスのいずれかが終了するまで 呼び出し元のスレッドの実行を一時停止する。 呼び出し I<wait(&wstatus)> は以下と等価である:"

#. type: Plain text
#: build/C/man2/wait.2:121
#, no-wrap
msgid "waitpid(-1, &wstatus, 0);\n"
msgstr "waitpid(-1, &wstatus, 0);\n"

#. type: Plain text
#: build/C/man2/wait.2:136
msgid ""
"The B<waitpid>()  system call suspends execution of the calling thread until "
"a child specified by I<pid> argument has changed state.  By default, "
"B<waitpid>()  waits only for terminated children, but this behavior is "
"modifiable via the I<options> argument, as described below."
msgstr "B<waitpid>() システムコールは、 I<pid> 引数で指定した子プロセスの状態変化が起こるまで、 呼び出し元のスレッドの実行を一時停止する。デフォルトでは、 B<waitpid>() は子プロセスの終了だけを待つが、この動作は I<options> 引数により変更可能である。"

#. type: Plain text
#: build/C/man2/wait.2:140
msgid "The value of I<pid> can be:"
msgstr "I<pid> に指定できる値は以下の通り:"

#. type: IP
#: build/C/man2/wait.2:140
#, no-wrap
msgid "E<lt> -1"
msgstr "E<lt> -1"

#. type: Plain text
#: build/C/man2/wait.2:144
msgid ""
"meaning wait for any child process whose process group ID is equal to the "
"absolute value of I<pid>."
msgstr ""
"プロセスグループID が I<pid> の絶対値に等しい子プロセスのいずれかが終了するま"
"でを待つ。"

#. type: IP
#: build/C/man2/wait.2:144
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: build/C/man2/wait.2:146
msgid "meaning wait for any child process."
msgstr "子プロセスのどれかが終了するまで待つ。"

#. type: IP
#: build/C/man2/wait.2:146
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man2/wait.2:150
msgid ""
"meaning wait for any child process whose process group ID is equal to that "
"of the calling process at the time of the call to B<waitpid>()."
msgstr "プロセスグループ ID が、B<waitpid>() が呼ばれた時点での呼び出し元のプロセスのプロセスグループ ID と等しい子プロセスを待つ。"

#. type: IP
#: build/C/man2/wait.2:150
#, no-wrap
msgid "E<gt> 0"
msgstr "E<gt> 0"

#. type: Plain text
#: build/C/man2/wait.2:154
msgid ""
"meaning wait for the child whose process ID is equal to the value of I<pid>."
msgstr "プロセスID が I<pid> に等しい子プロセスを待つ。"

#. type: Plain text
#: build/C/man2/wait.2:158
msgid ""
"The value of I<options> is an OR of zero or more of the following constants:"
msgstr "I<options> の値は次の定数の 0 個以上の論理和である:"

#. type: TP
#: build/C/man2/wait.2:158 build/C/man2/wait.2:303
#, no-wrap
msgid "B<WNOHANG>"
msgstr "B<WNOHANG>"

#. type: Plain text
#: build/C/man2/wait.2:161
msgid "return immediately if no child has exited."
msgstr "状態変化が起こった子プロセスがない場合にすぐに復帰する。"

#. type: TP
#: build/C/man2/wait.2:161
#, no-wrap
msgid "B<WUNTRACED>"
msgstr "B<WUNTRACED>"

#. type: Plain text
#: build/C/man2/wait.2:170
msgid ""
"also return if a child has stopped (but not traced via B<ptrace>(2)).  "
"Status for I<traced> children which have stopped is provided even if this "
"option is not specified."
msgstr ""
"子プロセスが停止した場合にも復帰する (子プロセスが B<ptrace>(2)  でトレースさ"
"れている場合は除く)。 このオプションが指定されていない場合でも、停止したプロ"
"セスが 「トレース (traced)」されていれば、子プロセスの状態が報告される。"

#. type: TP
#: build/C/man2/wait.2:170
#, no-wrap
msgid "B<WCONTINUED> (since Linux 2.6.10)"
msgstr "B<WCONTINUED> (Linux 2.6.10 以降)"

#. type: Plain text
#: build/C/man2/wait.2:174
msgid ""
"also return if a stopped child has been resumed by delivery of B<SIGCONT>."
msgstr "停止した子プロセスが B<SIGCONT> の配送により再開した場合にも復帰する。"

#. type: Plain text
#: build/C/man2/wait.2:176
msgid "(For Linux-only options, see below.)"
msgstr "(Linux 専用オプションについては後述する)"

#. type: Plain text
#: build/C/man2/wait.2:190
msgid ""
"If I<wstatus> is not NULL, B<wait>()  and B<waitpid>()  store status "
"information in the I<int> to which it points.  This integer can be inspected "
"with the following macros (which take the integer itself as an argument, not "
"a pointer to it, as is done in B<wait>()  and B<waitpid>()!):"
msgstr "I<wstatus> が NULL でなければ、 B<wait>()  や B<waitpid>()  は I<status> で指す I<int> に状態情報を格納する。 この整数は以下のマクロを使って検査できる。 (これらのマクロの引数には、 B<wait>()  や B<waitpid>()  が書き込んだ整数そのものを指定する。ポインターではない!)"

#. type: TP
#: build/C/man2/wait.2:190
#, no-wrap
msgid "B<WIFEXITED(>I<wstatus>B<)>"
msgstr "B<WIFEXITED(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:198
msgid ""
"returns true if the child terminated normally, that is, by calling "
"B<exit>(3)  or B<_exit>(2), or by returning from main()."
msgstr ""
"子プロセスが正常に終了した場合に真を返す。 「正常に」とは、 B<exit>(3)  か "
"B<_exit>(2)  が呼び出された場合、もしくは main() から復帰した場合である。"

#. type: TP
#: build/C/man2/wait.2:198
#, no-wrap
msgid "B<WEXITSTATUS(>I<wstatus>B<)>"
msgstr "B<WEXITSTATUS(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:211
msgid ""
"returns the exit status of the child.  This consists of the least "
"significant 8 bits of the I<status> argument that the child specified in a "
"call to B<exit>(3)  or B<_exit>(2)  or as the argument for a return "
"statement in main().  This macro should be employed only if B<WIFEXITED> "
"returned true."
msgstr ""
"子プロセスの終了ステータスを返す。 終了ステータスは I<status> 引数の下位 8"
"ビットで構成されており、 B<exit>(3)  や B<_exit>(2)  の呼び出し時に渡された"
"値、もしくは main() の return 文の 引数として指定された値である。 このマク"
"ロを使用するのは B<WIFEXITED> が真を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:211
#, no-wrap
msgid "B<WIFSIGNALED(>I<wstatus>B<)>"
msgstr "B<WIFSIGNALED(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:214
msgid "returns true if the child process was terminated by a signal."
msgstr "子プロセスがシグナルにより終了した場合に真を返す。"

#. type: TP
#: build/C/man2/wait.2:214
#, no-wrap
msgid "B<WTERMSIG(>I<wstatus>B<)>"
msgstr "B<WTERMSIG(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:221
msgid ""
"returns the number of the signal that caused the child process to "
"terminate.  This macro should be employed only if B<WIFSIGNALED> returned "
"true."
msgstr ""
"子プロセス終了の原因となったシグナルの番号を返す。 このマクロを使用するのは "
"B<WIFSIGNALED> が真を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:221
#, no-wrap
msgid "B<WCOREDUMP(>I<wstatus>B<)>"
msgstr "B<WCOREDUMP(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:228
#, fuzzy
#| msgid ""
#| "returns the number of the signal that caused the child process to "
#| "terminate.  This macro should be employed only if B<WIFSIGNALED> returned "
#| "true."
msgid ""
"returns true if the child produced a core dump (see B<core>(5)).  This macro "
"should be employed only if B<WIFSIGNALED> returned true."
msgstr ""
"子プロセス終了の原因となったシグナルの番号を返す。 このマクロを使用するのは "
"B<WIFSIGNALED> が真を返した場合だけにすべきである。"

#. type: Plain text
#: build/C/man2/wait.2:233
#, fuzzy
#| msgid ""
#| "returns true if the child produced a core dump.  This macro should be "
#| "employed only if B<WIFSIGNALED> returned true.  This macro is not "
#| "specified in POSIX.1-2001 and is not available on some UNIX "
#| "implementations (e.g., AIX, SunOS).  Only use this enclosed in #ifdef "
#| "WCOREDUMP ... #endif."
msgid ""
"This macro is not specified in POSIX.1-2001 and is not available on some "
"UNIX implementations (e.g., AIX, SunOS).  Therefore, enclose its use inside "
"I<#ifdef WCOREDUMP ... #endif>."
msgstr ""
"子プロセスがコアダンプを生成した場合に真を返す。 このマクロを使用するのは "
"B<WIFSIGNALED> が真を返した場合だけにすべきである。 このマクロは "
"POSIX.1-2001 では規定されておらず、 (AIX, SunOS などの) いくつかの UNIX の実"
"装では利用できない。 必ず #ifdef WCOREDUMP ... #endif で括って使用すること。"

#. type: TP
#: build/C/man2/wait.2:233
#, no-wrap
msgid "B<WIFSTOPPED(>I<wstatus>B<)>"
msgstr "B<WIFSTOPPED(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:240
msgid ""
"returns true if the child process was stopped by delivery of a signal; this "
"is possible only if the call was done using B<WUNTRACED> or when the child "
"is being traced (see B<ptrace>(2))."
msgstr ""
"子プロセスがシグナルの配送により停止した場合に真を返す。 これが真になるのは、"
"システムコールが B<WUNTRACED> を指定して呼び出された場合か、子プロセスがト"
"レースされている場合 (B<ptrace>(2)  参照) だけである。"

#. type: TP
#: build/C/man2/wait.2:240
#, no-wrap
msgid "B<WSTOPSIG(>I<wstatus>B<)>"
msgstr "B<WSTOPSIG(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:246
msgid ""
"returns the number of the signal which caused the child to stop.  This macro "
"should be employed only if B<WIFSTOPPED> returned true."
msgstr ""
"子プロセスを停止させたシグナルの番号を返す。 このマクロを使用するのは "
"B<WIFSTOPPED> が 0 以外を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:246
#, no-wrap
msgid "B<WIFCONTINUED(>I<wstatus>B<)>"
msgstr "B<WIFCONTINUED(>I<wstatus>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:251
msgid ""
"(since Linux 2.6.10)  returns true if the child process was resumed by "
"delivery of B<SIGCONT>."
msgstr ""
"(Linux 2.6.10 以降)  子プロセスが B<SIGCONT> の配送により再開した場合に真を返"
"す。"

#. type: SS
#: build/C/man2/wait.2:251
#, no-wrap
msgid "waitid()"
msgstr "waitid()"

#. type: Plain text
#: build/C/man2/wait.2:256
msgid ""
"The B<waitid>()  system call (available since Linux 2.6.9) provides more "
"precise control over which child state changes to wait for."
msgstr ""
"B<waitid>()  システムコール (Linux 2.6.9 以降で利用可能) を使うと、 子プロセ"
"スのどの状態変化を待つかについてより細かな制御ができる。"

#. type: Plain text
#: build/C/man2/wait.2:262
msgid ""
"The I<idtype> and I<id> arguments select the child(ren) to wait for, as "
"follows:"
msgstr "引数 I<idtype> と I<id> でどの子プロセスを待つかを選択する:"

#. type: IP
#: build/C/man2/wait.2:262
#, no-wrap
msgid "I<idtype> == B<P_PID>"
msgstr "I<idtype> == B<P_PID>"

#. type: Plain text
#: build/C/man2/wait.2:265
msgid "Wait for the child whose process ID matches I<id>."
msgstr "プロセスID が I<id> と一致する子プロセスを待つ。"

#. type: IP
#: build/C/man2/wait.2:265
#, no-wrap
msgid "I<idtype> == B<P_PIDFD> (since Linux 5.4)"
msgstr "I<idtype> == B<P_PIDFD> (since Linux 5.4)"

#.  commit 3695eae5fee0605f316fbaad0b9e3de791d7dfaf
#. type: Plain text
#: build/C/man2/wait.2:272
msgid ""
"Wait for the child referred to by the PID file descriptor specified in "
"I<id>.  (See B<pidfd_open>(2)  for further information on PID file "
"descriptors.)"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:272
#, no-wrap
msgid "I<idtype> == B<P_PGID>"
msgstr "I<idtype> == B<P_PGID>"

#.  commit 821cc7b0b205c0df64cce59aacc330af251fa8f7
#. type: Plain text
#: build/C/man2/wait.2:281
msgid ""
"Wait for any child whose process group ID matches I<id>.  Since Linux 5.4, "
"if I<id> is zero, then wait for any child that is in the same process group "
"as the caller's process group at the time of the call."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:281
#, no-wrap
msgid "I<idtype> == B<P_ALL>"
msgstr "I<idtype> == B<P_ALL>"

#. type: Plain text
#: build/C/man2/wait.2:285
msgid "Wait for any child; I<id> is ignored."
msgstr "子プロセス全部を対象に待つ。 I<id> は無視される。"

#. type: Plain text
#: build/C/man2/wait.2:289
msgid ""
"The child state changes to wait for are specified by ORing one or more of "
"the following flags in I<options>:"
msgstr ""
"子プロセスのどの状態変化を待つかは以下のフラグで指定する (I<options> には 1個"
"以上のフラグの論理和をとって指定する):"

#. type: TP
#: build/C/man2/wait.2:289
#, no-wrap
msgid "B<WEXITED>"
msgstr "B<WEXITED>"

#. type: Plain text
#: build/C/man2/wait.2:292
msgid "Wait for children that have terminated."
msgstr "子プロセスの終了を待つ。"

#. type: TP
#: build/C/man2/wait.2:292
#, no-wrap
msgid "B<WSTOPPED>"
msgstr "B<WSTOPPED>"

#. type: Plain text
#: build/C/man2/wait.2:295
msgid "Wait for children that have been stopped by delivery of a signal."
msgstr "子プロセスがシグナルの配送により停止するのを待つ。"

#. type: TP
#: build/C/man2/wait.2:295
#, no-wrap
msgid "B<WCONTINUED>"
msgstr "B<WCONTINUED>"

#. type: Plain text
#: build/C/man2/wait.2:300
msgid ""
"Wait for (previously stopped) children that have been resumed by delivery of "
"B<SIGCONT>."
msgstr "(停止していた) 子プロセスが B<SIGCONT> が配送されて再開するのを待つ。"

#. type: Plain text
#: build/C/man2/wait.2:303
msgid "The following flags may additionally be ORed in I<options>:"
msgstr "さらに以下のフラグを論理和の形で I<options> に指定できる:"

#. type: Plain text
#: build/C/man2/wait.2:307
msgid "As for B<waitpid>()."
msgstr "B<waitpid>()  と同様。"

#. type: TP
#: build/C/man2/wait.2:307
#, no-wrap
msgid "B<WNOWAIT>"
msgstr "B<WNOWAIT>"

#. type: Plain text
#: build/C/man2/wait.2:311
msgid ""
"Leave the child in a waitable state; a later wait call can be used to again "
"retrieve the child status information."
msgstr ""
"waitable 状態のプロセスをそのままにする。この後で wait コールを 使って、同じ"
"子プロセスの状態情報をもう一度取得することができる。"

#. type: Plain text
#: build/C/man2/wait.2:318
msgid ""
"Upon successful return, B<waitid>()  fills in the following fields of the "
"I<siginfo_t> structure pointed to by I<infop>:"
msgstr ""
"成功した場合には、 B<waitid>()  は I<infop> が指す I<siginfo_t> 構造体の以下"
"のフィールドを設定する:"

#. type: Plain text
#: build/C/man2/wait.2:321
msgid "The process ID of the child."
msgstr "子プロセスのプロセスID。"

#. type: Plain text
#: build/C/man2/wait.2:325
msgid ""
"The real user ID of the child.  (This field is not set on most other "
"implementations.)"
msgstr ""
"子プロセスの実ユーザーID (このフィールドは他のほとんどの実装では設定されな"
"い)。"

#. type: Plain text
#: build/C/man2/wait.2:329
msgid "Always set to B<SIGCHLD>."
msgstr "常に B<SIGCHLD> が設定される。"

#. type: TP
#: build/C/man2/wait.2:329
#, no-wrap
msgid "I<si_status>"
msgstr "I<si_status>"

#. type: Plain text
#: build/C/man2/wait.2:339
msgid ""
"Either the exit status of the child, as given to B<_exit>(2)  (or "
"B<exit>(3)), or the signal that caused the child to terminate, stop, or "
"continue.  The I<si_code> field can be used to determine how to interpret "
"this field."
msgstr ""
"B<_exit>(2)  (か B<exit>(3))  に指定された子プロセスの終了ステータス、もしく"
"は 子プロセスの終了、停止、再開の原因となったシグナルが設定される。 この"
"フィールドをどう解釈するかは、 I<si_code> フィールドを参照して決めることがで"
"きる。"

#. type: Plain text
#: build/C/man2/wait.2:356
msgid ""
"Set to one of: B<CLD_EXITED> (child called B<_exit>(2)); B<CLD_KILLED> "
"(child killed by signal); B<CLD_DUMPED> (child killed by signal, and dumped "
"core); B<CLD_STOPPED> (child stopped by signal); B<CLD_TRAPPED> (traced "
"child has trapped); or B<CLD_CONTINUED> (child continued by B<SIGCONT>)."
msgstr ""
"以下のいずれかが設定される: B<CLD_EXITED> (子プロセスが B<_exit>(2)  を呼び出"
"した); B<CLD_KILLED> (シグナルにより子プロセスが kill された); B<CLD_DUMPED> "
"(シグナルにより子プロセスが kill され、コアダンプが行われた); B<CLD_STOPPED> "
"(シグナルにより子プロセスが停止した); B<CLD_TRAPPED> (トレースされていた子プ"
"ロセスがトラップを受信した); B<CLD_CONTINUED> (B<SIGCONT> により子プロセスが"
"再開された)。"

#. type: Plain text
#: build/C/man2/wait.2:374
#, fuzzy
#| msgid ""
#| "If B<WNOHANG> was specified in I<options> and there were no children in a "
#| "waitable state, then B<waitid>()  returns 0 immediately and the state of "
#| "the I<siginfo_t> structure pointed to by I<infop> is unspecified.  To "
#| "distinguish this case from that where a child was in a waitable state, "
#| "zero out the I<si_pid> field before the call and check for a nonzero "
#| "value in this field after the call returns."
msgid ""
"If B<WNOHANG> was specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  returns 0 immediately and the state of the "
"I<siginfo_t> structure pointed to by I<infop> depends on the "
"implementation.  To (portably) distinguish this case from that where a child "
"was in a waitable state, zero out the I<si_pid> field before the call and "
"check for a nonzero value in this field after the call returns."
msgstr ""
"B<WNOHANG> が I<options> に指定されていて、 waitable 状態の子プロセスがなかっ"
"た場合には、 B<waitid>()  はすぐに 0 を返す。このとき、 I<infop> が指す "
"I<siginfo_t> 構造体の内容は不定である。 この場合を waitable 状態の子プロセス"
"があった場合と区別するには、 B<waitid>()  を呼び出す前に I<si_pid> を 0 にし"
"ておき、コールが復帰した後でこのフィールドが 0 以外の値かどうか をチェックす"
"ればよい。"

#.  POSIX.1-2001 leaves this possibility unspecified; most
#.  implementations (including Linux) zero out the structure
#.  in this case, but at least one implementation (AIX 5.1)
#.  does not -- MTK Nov 04
#. type: Plain text
#: build/C/man2/wait.2:397
msgid ""
"POSIX.1-2008 Technical Corrigendum 1 (2013) adds the requirement that when "
"B<WNOHANG> is specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  should zero out the I<si_pid> and "
"I<si_signo> fields of the structure.  On Linux and other implementations "
"that adhere to this requirement, it is not necessary to zero out the "
"I<si_pid> field before calling B<waitid>().  However, not all "
"implementations follow the POSIX.1 specification on this point."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:401
msgid ""
"B<wait>(): on success, returns the process ID of the terminated child; on "
"error, -1 is returned."
msgstr ""
"B<wait>(): 成功すると、終了した子プロセスのプロセスID を返す。 エラーの場合 "
"-1 を返す。"

#. type: Plain text
#: build/C/man2/wait.2:410
msgid ""
"B<waitpid>(): on success, returns the process ID of the child whose state "
"has changed; if B<WNOHANG> was specified and one or more child(ren) "
"specified by I<pid> exist, but have not yet changed state, then 0 is "
"returned.  On error, -1 is returned."
msgstr ""
"B<waitpid>(): 成功すると、状態が変化した子プロセスのプロセスID を返す。 "
"B<WNOHANG> が指定されていて、 I<pid> で指示された子プロセスが一つ以上存在する"
"が、どの子プロセスでも 状態変化が起こっていなかった場合は、 0 を返す。 エラー"
"の場合 -1 を返す。"

#.  FIXME As reported by Vegard Nossum, if infop is NULL, then waitid()
#.  returns the PID of the child.  Either this is a bug, or it is intended
#.  behavior that needs to be documented.  See my Jan 2009 LKML mail
#.  "waitid() return value strangeness when infop is NULL".
#. type: Plain text
#: build/C/man2/wait.2:423
msgid ""
"B<waitid>(): returns 0 on success or if B<WNOHANG> was specified and no "
"child(ren) specified by I<id> has yet changed state; on error, -1 is "
"returned."
msgstr ""
"B<waitid>(): 成功すると 0 を返す。 B<WNOHANG> が指定されていて、 I<pid> で指"
"示された子プロセスで状態変化が起こっていなかった場合にも 0 を返す。"

#. type: Plain text
#: build/C/man2/wait.2:427
msgid ""
"Each of these calls sets I<errno> to an appropriate value in the case of an "
"error."
msgstr ""
"エラーの場合 -1 を返す。 エラーの場合、これらのシステムコールはいずれも "
"I<errno> に適切な値を設定する。"

#. type: TP
#: build/C/man2/wait.2:428 build/C/man2/wait.2:433
#, no-wrap
msgid "B<ECHILD>"
msgstr "B<ECHILD>"

#. type: Plain text
#: build/C/man2/wait.2:433
msgid ""
"(for B<wait>())  The calling process does not have any unwaited-for children."
msgstr ""
"(B<wait>()  の場合)  呼び出し元プロセスには、wait を行っていない子プロセスは"
"ない。"

#. type: Plain text
#: build/C/man2/wait.2:453
msgid ""
"(for B<waitpid>()  or B<waitid>())  The process specified by I<pid> "
"(B<waitpid>())  or I<idtype> and I<id> (B<waitid>())  does not exist or is "
"not a child of the calling process.  (This can happen for one's own child if "
"the action for B<SIGCHLD> is set to B<SIG_IGN>.  See also the I<Linux Notes> "
"section about threads.)"
msgstr ""
"(B<waitpid>()  か B<waitid>()  の場合)  I<pid> (B<waitpid>())  か I<idtype> "
"と I<id> (B<waitid>())  で指定したプロセスが存在しないか、呼び出し元プロセス"
"の子プロセスでない (B<SIGCHLD> の動作に B<SIG_IGN> を設定した場合には、自分自"
"身の子プロセスでも起こりうる。 スレッドに関しては「Linux での注意」の節も参照"
"すること)。"

#. type: Plain text
#: build/C/man2/wait.2:460
msgid ""
"B<WNOHANG> was not set and an unblocked signal or a B<SIGCHLD> was caught; "
"see B<signal>(7)."
msgstr ""
"B<WNOHANG> が設定されておらず、禁止 (block) されていないシグナルや "
"B<SIGCHLD> を受信した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/wait.2:465
msgid "The I<options> argument was invalid."
msgstr "I<options> 引数が不正である。"

#. type: Plain text
#: build/C/man2/wait.2:467
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/wait.2:485
#, fuzzy
#| msgid ""
#| "A child that terminates, but has not been waited for becomes a \"zombie"
#| "\".  The kernel maintains a minimal set of information about the zombie "
#| "process (PID, termination status, resource usage information)  in order "
#| "to allow the parent to later perform a wait to obtain information about "
#| "the child.  As long as a zombie is not removed from the system via a "
#| "wait, it will consume a slot in the kernel process table, and if this "
#| "table fills, it will not be possible to create further processes.  If a "
#| "parent process terminates, then its \"zombie\" children (if any)  are "
#| "adopted by B<init>(1), which automatically performs a wait to remove the "
#| "zombies."
msgid ""
"A child that terminates, but has not been waited for becomes a \"zombie\".  "
"The kernel maintains a minimal set of information about the zombie process "
"(PID, termination status, resource usage information)  in order to allow the "
"parent to later perform a wait to obtain information about the child.  As "
"long as a zombie is not removed from the system via a wait, it will consume "
"a slot in the kernel process table, and if this table fills, it will not be "
"possible to create further processes.  If a parent process terminates, then "
"its \"zombie\" children (if any)  are adopted by B<init>(1), (or by the "
"nearest \"subreaper\" process as defined through the use of the B<prctl>(2)  "
"B<PR_SET_CHILD_SUBREAPER> operation); B<init>(1)  automatically performs a "
"wait to remove the zombies."
msgstr ""
"終了したが、wait されていない子プロセスは「ゾンビ」になる。 後で親プロセスが "
"wait を実行して子プロセスについての情報を取得できるように、 カーネルはゾンビ"
"プロセスについて最小限の情報 (PID、終了ステータス、 リソース使用状況) を保持"
"する。 ゾンビプロセスは、 wait によってシステムから削除されない限り、 カーネ"
"ルのプロセステーブルの 1 エントリーを消費する。このプロセステーブルが 一杯に"
"なると、新たにプロセスを作ることができなくなる。 親プロセスが終了すると、その"
"親プロセスの「ゾンビ」の 子プロセスは (もしあれば)  B<init>(1)  の養子とな"
"る。 B<init>(1)  は wait を自動的に実行し、ゾンビを削除する。"

#. type: Plain text
#: build/C/man2/wait.2:514
msgid ""
"POSIX.1-2001 specifies that if the disposition of B<SIGCHLD> is set to "
"B<SIG_IGN> or the B<SA_NOCLDWAIT> flag is set for B<SIGCHLD> (see "
"B<sigaction>(2)), then children that terminate do not become zombies and a "
"call to B<wait>()  or B<waitpid>()  will block until all children have "
"terminated, and then fail with I<errno> set to B<ECHILD>.  (The original "
"POSIX standard left the behavior of setting B<SIGCHLD> to B<SIG_IGN> "
"unspecified.  Note that even though the default disposition of B<SIGCHLD> is "
"\"ignore\", explicitly setting the disposition to B<SIG_IGN> results in "
"different treatment of zombie process children.)"
msgstr ""
"POSIX.1-2001 では以下のように規定されている。 B<SIGCHLD> の動作が B<SIG_IGN> "
"に設定されたか、 B<SIGCHLD> に対して B<SA_NOCLDWAIT> フラグが設定された場合 "
"(B<sigaction>(2)  参照)、終了した子プロセスはゾンビにはならず、 B<wait>()  "
"や B<waitpid>()  の呼び出しは全ての子プロセスが終了するまで停止し、 子プロセ"
"スが全部終了した後 I<errno> に B<ECHILD> を設定して失敗する。 (もともとの "
"POSIX 標準は B<SIGCHLD> に B<SIG_IGN> を設定した場合の振る舞いを未規定のまま"
"にしている。 B<SIGCHLD> のデフォルトの動作が「無視」であるにもかかわらず、 "
"B<SIGCHLD> の動作として B<SIG_IGN> を明示的に設定した場合にはゾンビプロセスの"
"子プロセスの扱いが 異なる点に注意すること。)"

#. type: Plain text
#: build/C/man2/wait.2:527
msgid ""
"Linux 2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and "
"earlier) does not: if a B<wait>()  or B<waitpid>()  call is made while "
"B<SIGCHLD> is being ignored, the call behaves just as though B<SIGCHLD> were "
"not being ignored, that is, the call blocks until the next child terminates "
"and then returns the process ID and status of that child."
msgstr ""
"Linux 2.6 はこの仕様に準拠している。 しかし、Linux 2.4 (とそれ以前のバージョ"
"ン) はそうではない: B<SIGCHLD> が無視される状態で B<wait>()  または "
"B<waitpid>()  が呼び出された場合、 B<SIGCHLD> が無視されていないかのように振"
"る舞う。 つまり、呼び出しによって次の子プロセスの終了までブロックされ、 終了"
"した子プロセスの PID と状態が返される。"

#. type: Plain text
#: build/C/man2/wait.2:543
msgid ""
"In the Linux kernel, a kernel-scheduled thread is not a distinct construct "
"from a process.  Instead, a thread is simply a process that is created using "
"the Linux-unique B<clone>(2)  system call; other routines such as the "
"portable B<pthread_create>(3)  call are implemented using B<clone>(2).  "
"Before Linux 2.4, a thread was just a special case of a process, and as a "
"consequence one thread could not wait on the children of another thread, "
"even when the latter belongs to the same thread group.  However, POSIX "
"prescribes such functionality, and since Linux 2.4 a thread can, and by "
"default will, wait on children of other threads in the same thread group."
msgstr ""
"Linux カーネルでは、カーネルによってスケジュールされるスレッドは プロセスと明"
"確に区別できる構成要素ではない。スレッドは Linux 固有の B<clone>(2)  システム"
"コールを使用して生成されるプロセスに過ぎない。 移植性のある "
"B<pthread_create>(3)  コールのような他のルーチンは B<clone>(2)  を使用して実"
"装されている; これらでは B<waitid>()  を使うことはできない。 Linux 2.4 より前"
"では、スレッドは単に特殊なプロセスであったので、 例え同じスレッドグループで"
"あっても、 あるスレッドが別のスレッドの子プロセスが終了するのを待つことは出来"
"なかった。 しかし、POSIX ではこのような機能を規定しており、 Linux 2.4 以降で"
"は、あるスレッドが同じスレッドグループの他のスレッドの 子プロセスが終了するの"
"を待つことができるようになった。 そして将来はこれがデフォルトの動作になるであ"
"ろう。"

#.  commit 91c4e8ea8f05916df0c8a6f383508ac7c9e10dba
#. type: Plain text
#: build/C/man2/wait.2:552
#, fuzzy
#| msgid ""
#| "The following Linux-specific I<options> are for use with children created "
#| "using B<clone>(2); they cannot be used with B<waitid>():"
msgid ""
"The following Linux-specific I<options> are for use with children created "
"using B<clone>(2); they can also, since Linux 4.7, be used with B<waitid>():"
msgstr ""
"B<clone>(2)  を用いて作られた子プロセスには、以下の Linux 固有の I<options> "
"が使用できる。"

#. type: TP
#: build/C/man2/wait.2:552
#, no-wrap
msgid "B<__WCLONE>"
msgstr "B<__WCLONE>"

#.  since 0.99pl10
#. type: Plain text
#: build/C/man2/wait.2:563
msgid ""
"Wait for \"clone\" children only.  If omitted, then wait for \"non-clone\" "
"children only.  (A \"clone\" child is one which delivers no signal, or a "
"signal other than B<SIGCHLD> to its parent upon termination.)  This option "
"is ignored if B<__WALL> is also specified."
msgstr ""
"\"clone\" な子プロセスだけを待つ。 指定されなかった場合は非 \"clone\" な子プ"
"ロセスだけを待つ (\"clone\" な子プロセスは、終了時に親プロセスへ全くシグナル"
"を送らないか、 B<SIGCHLD> 以外のシグナルを送る)。 このオプションは B<__WALL> "
"も指定された場合は無視される。"

#. type: TP
#: build/C/man2/wait.2:563
#, no-wrap
msgid "B<__WALL> (since Linux 2.4)"
msgstr "B<__WALL> (Linux 2.4 以降)"

#.  since patch-2.3.48
#. type: Plain text
#: build/C/man2/wait.2:568
msgid "Wait for all children, regardless of type (\"clone\" or \"non-clone\")."
msgstr "\"clone\" であるかないかに関わらず、 全ての子プロセスを待つ。"

#. type: TP
#: build/C/man2/wait.2:568
#, no-wrap
msgid "B<__WNOTHREAD> (since Linux 2.4)"
msgstr "B<__WNOTHREAD> (Linux 2.4 以降)"

#.  since patch-2.4.0-test8
#. type: Plain text
#: build/C/man2/wait.2:574
msgid ""
"Do not wait for children of other threads in the same thread group.  This "
"was the default before Linux 2.4."
msgstr ""
"同じスレッドグループの他のスレッドの子プロセスは待たない。 Linux 2.4 より前で"
"はデフォルトであった。"

#.  commit bf959931ddb88c4e4366e96dd22e68fa0db9527c
#.  prevents cases where an unreapable zombie is created if
#.  /sbin/init doesn't use __WALL.
#. type: Plain text
#: build/C/man2/wait.2:582
msgid ""
"Since Linux 4.7, the B<__WALL> flag is automatically implied if the child is "
"being ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:586
#, fuzzy
#| msgid ""
#| "On Linux, B<wait3>()  is a library function implemented on top of the "
#| "B<wait4>()  system call."
msgid ""
"B<wait>()  is actually a library function that (in glibc) is implemented as "
"a call to B<wait4>(2)."
msgstr ""
"Linux では、 B<wait3>()  はライブラリ関数であり、 B<wait4>()  システムコール"
"を使って実装されている。"

#.  e.g., i386 has the system call, but not x86-64
#. type: Plain text
#: build/C/man2/wait.2:594
msgid ""
"On some architectures, there is no B<waitpid>()  system call; instead, this "
"interface is implemented via a C library wrapper function that calls "
"B<wait4>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:606
msgid ""
"The raw B<waitid>()  system call takes a fifth argument, of type I<struct "
"rusage\\ *>.  If this argument is non-NULL, then it is used to return "
"resource usage information about the child, in the same manner as "
"B<wait4>(2).  See B<getrusage>(2)  for details."
msgstr ""
"生の B<waitid>() システムコールは I<struct rusage\\ *> 型の第 5 引数を取る。 "
"この引数が NULL 以外の場合、 この引数が子プロセスのリソース使用状況を返すのに"
"使用される。 これは B<wait4>(2) と同じ方法である。 詳細は B<getrusage>(2) を"
"参照。"

#. type: Plain text
#: build/C/man2/wait.2:621
msgid ""
"According to POSIX.1-2008, an application calling B<waitid>()  must ensure "
"that I<infop> points to a I<siginfo_t> structure (i.e., that it is a non-"
"null pointer).  On Linux, if I<infop> is NULL, B<waitid>()  succeeds, and "
"returns the process ID of the waited-for child.  Applications should avoid "
"relying on this inconsistent, nonstandard, and unnecessary feature."
msgstr ""
"POSIX.1-2008 によると、 B<waitid>() を呼び出すアプリケーションは、 I<infop> "
"が I<siginfo_t> 構造体を指していること (つまり I<infop> が NULL でないポイン"
"ターであること) を保証しなければならない。 Linux では、 I<infop> が NULL の場"
"合、 B<waitid>() は成功し、wait している子プロセスのプロセス ID を返す。 アプ"
"リケーションは、この食い違った、非標準で、不必要な機能に依存しないようにすべ"
"きである。"

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/wait.2:638
msgid ""
"The following program demonstrates the use of B<fork>(2)  and B<waitpid>().  "
"The program creates a child process.  If no command-line argument is "
"supplied to the program, then the child suspends its execution using "
"B<pause>(2), to allow the user to send signals to the child.  Otherwise, if "
"a command-line argument is supplied, then the child exits immediately, using "
"the integer supplied on the command line as the exit status.  The parent "
"process executes a loop that monitors the child using B<waitpid>(), and uses "
"the W*() macros described above to analyze the wait status value."
msgstr ""
"以下のプログラムは、 B<fork>(2)  と B<waitpid>()  の使用方法の例を示してい"
"る。 このプログラムでは子プロセスを生成する。 コマンドライン引数が指定され"
"なかったときは、 子プロセスは B<pause>(2)  を使ってその実行を一時停止し、ユー"
"ザーがその子プロセスに シグナルを送信できるようにする。 コマンドライン引数"
"が指定された場合は、 子プロセスは直ちに終了し、 コマンドラインで指定された整"
"数を終了ステータスとして使用する。 親プロセスは、 B<waitpid>()  を使って子プ"
"ロセスを監視し、 wait のステータス値を上記の W*() マクロを使って解析するとい"
"う ループを実行する。"

#. type: Plain text
#: build/C/man2/wait.2:654
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"
msgstr ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"

#. type: Plain text
#: build/C/man2/wait.2:664
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/wait.2:670
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int wstatus;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int wstatus;\n"

#. type: Plain text
#: build/C/man2/wait.2:676
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/wait.2:682
#, no-wrap
msgid ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %jd\\en\", (intmax_t) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"
msgstr ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %jd\\en\", (intmax_t) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"

#. type: Plain text
#: build/C/man2/wait.2:690
#, no-wrap
msgid ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: build/C/man2/wait.2:704
#, no-wrap
msgid ""
"            if (WIFEXITED(wstatus)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(wstatus));\n"
"            } else if (WIFSIGNALED(wstatus)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(wstatus));\n"
"            } else if (WIFSTOPPED(wstatus)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(wstatus));\n"
"            } else if (WIFCONTINUED(wstatus)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"            if (WIFEXITED(wstatus)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(wstatus));\n"
"            } else if (WIFSIGNALED(wstatus)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(wstatus));\n"
"            } else if (WIFSTOPPED(wstatus)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(wstatus));\n"
"            } else if (WIFCONTINUED(wstatus)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/wait.2:718
msgid ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), "
"B<sigaction>(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), "
"B<core>(5), B<credentials>(7), B<signal>(7)"
msgstr "B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), B<sigaction>(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), B<core>(5), B<credentials>(7), B<signal>(7)"

#. type: TH
#: build/C/man2/wait4.2:33
#, no-wrap
msgid "WAIT4"
msgstr "WAIT4"

#. type: Plain text
#: build/C/man2/wait4.2:36
msgid "wait3, wait4 - wait for process to change state, BSD style"
msgstr "wait3, wait4 - BSD スタイルでプロセスの状態変化を待つ"

#. type: Plain text
#: build/C/man2/wait4.2:42
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/wait4.2:45
#, no-wrap
msgid ""
"B<pid_t wait3(int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""
"B<pid_t wait3(int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"

#. type: Plain text
#: build/C/man2/wait4.2:48
#, no-wrap
msgid ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"

#.           || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/wait4.2:66
#, no-wrap
msgid ""
"B<wait3>():\n"
"    Since glibc 2.26:\n"
"        _DEFAULT_SOURCE ||\n"
"        (_XOPEN_SOURCE\\ E<gt>=\\ 500 &&\n"
"                ! (_POSIX_C_SOURCE E<gt>= 200112L || _XOPEN_SOURCE E<gt>= 600))\n"
"    From glibc 2.19 to 2.25:\n"
"        _DEFAULT_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:72
#, no-wrap
msgid ""
"B<wait4>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:79
#, fuzzy
#| msgid ""
#| "These functions are obsolete; use B<waitpid>(2)  or B<waitid>(2)  in new "
#| "programs."
msgid ""
"These functions are nonstandard; in new programs, the use of B<waitpid>(2)  "
"or B<waitid>(2)  is preferable."
msgstr ""
"これらの関数は廃止予定である。 新しいプログラムでは B<waitpid>(2) や "
"B<waitid>(2) を使用すること。"

#. type: Plain text
#: build/C/man2/wait4.2:89
msgid ""
"The B<wait3>()  and B<wait4>()  system calls are similar to B<waitpid>(2), "
"but additionally return resource usage information about the child in the "
"structure pointed to by I<rusage>."
msgstr ""
"システムコール B<wait3>()  と B<wait4>()  は B<waitpid>(2)  と同様の動作をす"
"る。それに加え、子プロセスのリソース使用状況の情報を I<rusage> が指す構造体に"
"入れて返す。"

#. type: Plain text
#: build/C/man2/wait4.2:95
msgid ""
"Other than the use of the I<rusage> argument, the following B<wait3>()  call:"
msgstr "I<rusage> を使用する点を除けば、次の B<wait3>()  の呼び出し"

#. type: Plain text
#: build/C/man2/wait4.2:99
#, no-wrap
msgid "wait3(wstatus, options, rusage);\n"
msgstr "wait3(wstatus, options, rusage);\n"

#. type: Plain text
#: build/C/man2/wait4.2:103 build/C/man2/wait4.2:121
msgid "is equivalent to:"
msgstr "は以下と等価である。"

#. type: Plain text
#: build/C/man2/wait4.2:107
#, no-wrap
msgid "waitpid(-1, wstatus, options);\n"
msgstr "waitpid(-1, wstatus, options);\n"

#. type: Plain text
#: build/C/man2/wait4.2:113
msgid "Similarly, the following B<wait4>()  call:"
msgstr "同様に、次の B<wait4>()  の呼び出し"

#. type: Plain text
#: build/C/man2/wait4.2:117
#, no-wrap
msgid "wait4(pid, wstatus, options, rusage);\n"
msgstr "wait4(pid, wstatus, options, rusage);\n"

#. type: Plain text
#: build/C/man2/wait4.2:125
#, no-wrap
msgid "waitpid(pid, wstatus, options);\n"
msgstr "waitpid(pid, wstatus, options);\n"

#. type: Plain text
#: build/C/man2/wait4.2:136
msgid ""
"In other words, B<wait3>()  waits of any child, while B<wait4>()  can be "
"used to select a specific child, or children, on which to wait.  See "
"B<wait>(2)  for further details."
msgstr ""
"言い換えると、 B<wait3>()  は全ての子プロセスを対象に待つが、 B<wait4>()  で"
"は特定の子プロセス (複数可) を選んで待つことができる。"

#. type: Plain text
#: build/C/man2/wait4.2:146
msgid ""
"If I<rusage> is not NULL, the I<struct rusage> to which it points will be "
"filled with accounting information about the child.  See B<getrusage>(2)  "
"for details."
msgstr ""
"I<rusage> が NULL でない場合、 I<rusage> が指す I<rusage 構造体> には子プロセ"
"スのアカウント情報が格納される。 詳しくは B<getrusage>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/wait4.2:149 build/C/man2/wait4.2:152
msgid "As for B<waitpid>(2)."
msgstr "B<waitpid>(2)  と同様。"

#. type: Plain text
#: build/C/man2/wait4.2:154
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man2/wait4.2:161
msgid ""
"SUSv1 included a specification of B<wait3>(); SUSv2 included B<wait3>(), but "
"marked it LEGACY; SUSv3 removed it."
msgstr ""
"SUSv1 には B<wait3>() の規定があった。 SUSv2 には B<wait3>() が含まれていた"
"が、「過去の名残 (LEGACY)」となっていた。 SUSv3 では B<wait3>() は削除され"
"た。"

#. type: Plain text
#: build/C/man2/wait4.2:173
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"現在では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、インクルード"
"しておくと 移植性を高めることができる (実際には I<E<lt>sys/resource.hE<gt>> "
"で I<rusage> 構造体が定義されているが、そのフィールドで使用されている "
"I<struct timeval> 型は I<E<lt>sys/time.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man2/wait4.2:179
msgid ""
"On Linux, B<wait3>()  is a library function implemented on top of the "
"B<wait4>()  system call."
msgstr ""
"Linux では、 B<wait3>()  はライブラリ関数であり、 B<wait4>()  システムコール"
"を使って実装されている。"

#. type: Plain text
#: build/C/man2/wait4.2:186
msgid ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"
msgstr ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"

#. type: TH
#: build/C/man3/killpg.3:42
#, no-wrap
msgid "KILLPG"
msgstr "KILLPG"

#. type: Plain text
#: build/C/man3/killpg.3:45
msgid "killpg - send signal to a process group"
msgstr "killpg - シグナルをプロセスグループに送る"

#. type: Plain text
#: build/C/man3/killpg.3:49
msgid "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"
msgstr "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"

#. type: TP
#: build/C/man3/killpg.3:55
#, no-wrap
msgid "B<killpg>():"
msgstr "B<killpg>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/killpg.3:61
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:71
msgid ""
"B<killpg>()  sends the signal I<sig> to the process group I<pgrp>.  See "
"B<signal>(7)  for a list of signals."
msgstr ""
"B<killpg>()  は I<sig> で指定したシグナルを I<pgrp> で指定したプロセスグルー"
"プに送る。 シグナルの定義の一覧は B<signal>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man3/killpg.3:80
msgid ""
"If I<pgrp> is 0, B<killpg>()  sends the signal to the calling process's "
"process group.  (POSIX says: if I<pgrp> is less than or equal to 1, the "
"behavior is undefined.)"
msgstr ""
"引数 I<pgrp> に 0 を指定した場合には B<killpg>()  は呼び出し元のプロセスが"
"属しているプロセスグループに対してシグナルを送る。 (POSIX では以下のように記"
"述されている: I<pgrp> が 1 以下である場合、動作は未定義である。)"

#. type: Plain text
#: build/C/man3/killpg.3:83
#, fuzzy
#| msgid ""
#| "The process does not have permission to send the signal to any of the "
#| "target processes."
msgid ""
"For the permissions required to send a signal to another process, see "
"B<kill>(2)."
msgstr ""
"プロセスが、受信するプロセスのいずれに対しても シグナルを送る許可を持っていな"
"い。"

#. type: Plain text
#: build/C/man3/killpg.3:93
msgid "I<sig> is not a valid signal number."
msgstr "I<sig> で指定された値は無効なシグナル番号である。"

#. type: Plain text
#: build/C/man3/killpg.3:99
#, fuzzy
#| msgid ""
#| "The process does not have permission to send the signal to the receiving "
#| "process.  For the required permissions, see B<kill>(2)."
msgid ""
"The process does not have permission to send the signal to any of the target "
"processes.  For the required permissions, see B<kill>(2)."
msgstr ""
"このプロセスには、受け取り側プロセスにシグナルを送る権限がない。 必要な権限に"
"ついては、 B<kill>(2)  を参照すること。"

#. type: Plain text
#: build/C/man3/killpg.3:103
msgid "No process can be found in the process group specified by I<pgrp>."
msgstr "I<pgrp> で指定されたプロセスグループに属するプロセスが存在しなかった。"

#. type: Plain text
#: build/C/man3/killpg.3:107
msgid ""
"The process group was given as 0 but the sending process does not have a "
"process group."
msgstr ""
"プロセスグループとして 0 が指定されたが、送信プロセスは プロセスグループを"
"持っていない。"

#. type: Plain text
#: build/C/man3/killpg.3:111
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<killpg>()  first appeared in "
"4BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<killpg>() は 4BSD で初めて登場した)."

#. type: Plain text
#: build/C/man3/killpg.3:125
msgid ""
"There are various differences between the permission checking in BSD-type "
"systems and System\\ V-type systems.  See the POSIX rationale for "
"B<kill>(3p).  A difference not mentioned by POSIX concerns the return value "
"B<EPERM>: BSD documents that no signal is sent and B<EPERM> returned when "
"the permission check failed for at least one target process, while POSIX "
"documents B<EPERM> only when the permission check failed for all target "
"processes."
msgstr "BSD 系システムと System\\ V 系システムでは、 許可のチェックに様々な違いがある。 B<kill>(3p) の POSIX の原理 (rationale) を参照すること。 POSIX で記述されていない違いとしては、返り値 B<EPERM> がある。 BSD では「送信先プロセスの許可のチェックが 1 つでも失敗した場合は、 シグナルが送信されず、 B<EPERM> が返される」と記述されている。 POSIX では「送信先プロセスの許可のチェックが全て失敗した場合にのみ、 B<EPERM> が返される」と記述されている。"

#. type: Plain text
#: build/C/man3/killpg.3:130
msgid ""
"On Linux, B<killpg>()  is implemented as a library function that makes the "
"call I<kill(-pgrp,\\ sig)>."
msgstr ""
"Linux では、 B<killpg>()  はライブラリ関数として実装されており、 I<kill(-"
"pgrp,\\ sig)> の呼び出しが行われる。"

#. type: Plain text
#: build/C/man3/killpg.3:136
msgid ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<capabilities>(7), "
"B<credentials>(7)"
msgstr ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<credentials>(7), "
"B<capabilities>(7)"

#. type: TH
#: build/C/man7/signal-safety.7:25
#, no-wrap
msgid "SIGNAL-SAFETY"
msgstr "SIGNAL-SAFETY"

#. type: Plain text
#: build/C/man7/signal-safety.7:28
msgid "signal-safety - async-signal-safe functions"
msgstr "signal-safety - 非同期シグナルで安全な関数 (async-signal-safe functions)"

#. type: Plain text
#: build/C/man7/signal-safety.7:37
msgid ""
"An I<async-signal-safe> function is one that can be safely called from "
"within a signal handler.  Many functions are I<not> async-signal-safe.  In "
"particular, nonreentrant functions are generally unsafe to call from a "
"signal handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:43
msgid ""
"The kinds of issues that render a function unsafe can be quickly understood "
"when one considers the implementation of the I<stdio> library, all of whose "
"functions are not async-signal-safe."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:60
msgid ""
"When performing buffered I/O on a file, the I<stdio> functions must maintain "
"a statically allocated data buffer along with associated counters and "
"indexes (or pointers)  that record the amount of data and the current "
"position in the buffer.  Suppose that the main program is in the middle of a "
"call to a I<stdio> function such as B<printf>(3)  where the buffer and "
"associated variables have been partially updated.  If, at that moment, the "
"program is interrupted by a signal handler that also calls B<printf>(3), "
"then the second call to B<printf>(3)  will operate on inconsistent data, "
"with unpredictable results."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:62
msgid ""
"To avoid problems with unsafe functions, there are two possible choices:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:68
msgid ""
"Ensure that (a) the signal handler calls only async-signal-safe functions, "
"and (b) the signal handler itself is reentrant with respect to global "
"variables in the main program."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:72
msgid ""
"Block signal delivery in the main program when calling functions that are "
"unsafe or operating on global data that is also accessed by the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:75
msgid ""
"Generally, the second choice is difficult in programs of any complexity, so "
"the first choice is taken."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:81
msgid ""
"POSIX.1 specifies a set of functions that an implementation must make async-"
"signal-safe.  (An implementation may provide safe implementations of "
"additional functions, but this is not required by the standard and other "
"implementations may not provide the same guarantees.)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:85
msgid ""
"In general, a function is async-signal-safe either because it is reentrant "
"or because it is atomic with respect to signals (i.e., its execution can't "
"be interrupted by a signal handler)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:91
msgid ""
"The set of functions required to be async-signal-safe by POSIX.1 is shown in "
"the following table.  The functions not otherwise noted were required to be "
"async-signal-safe in POSIX.1-2001; the table details changes in the "
"subsequent standards."
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:95
#, no-wrap
msgid "Function"
msgstr "関数"

#. type: tbl table
#: build/C/man7/signal-safety.7:96
#, no-wrap
msgid "B<abort>(3)"
msgstr "B<abort>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:96
#, no-wrap
msgid "Added in POSIX.1-2001 TC1"
msgstr "POSIX.1-2001 TC1 で追加"

#. type: tbl table
#: build/C/man7/signal-safety.7:97
#, no-wrap
msgid "B<accept>(2)"
msgstr "B<accept>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:98
#, no-wrap
msgid "B<access>(2)"
msgstr "B<access>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:99
#, no-wrap
msgid "B<aio_error>(3)"
msgstr "B<aio_error>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:100
#, no-wrap
msgid "B<aio_return>(3)"
msgstr "B<aio_return>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:101
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr "B<aio_suspend>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:101 build/C/man7/signal-safety.7:118
#: build/C/man7/signal-safety.7:133
#, no-wrap
msgid "See notes below"
msgstr "下記の「注意」を参照"

#. type: tbl table
#: build/C/man7/signal-safety.7:102
#, no-wrap
msgid "B<alarm>(2)"
msgstr "B<alarm>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:103
#, no-wrap
msgid "B<bind>(2)"
msgstr "B<bind>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:104
#, no-wrap
msgid "B<cfgetispeed>(3)"
msgstr "B<cfgetispeed>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:105
#, no-wrap
msgid "B<cfgetospeed>(3)"
msgstr "B<cfgetospeed>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:106
#, no-wrap
msgid "B<cfsetispeed>(3)"
msgstr "B<cfsetispeed>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:107
#, no-wrap
msgid "B<cfsetospeed>(3)"
msgstr "B<cfsetospeed>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:108
#, no-wrap
msgid "B<chdir>(2)"
msgstr "B<chdir>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:109
#, no-wrap
msgid "B<chmod>(2)"
msgstr "B<chmod>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:110
#, no-wrap
msgid "B<chown>(2)"
msgstr "B<chown>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:111
#, no-wrap
msgid "B<clock_gettime>(2)"
msgstr "B<clock_gettime>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:113
#, no-wrap
msgid "B<connect>(2)"
msgstr "B<connect>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:114
#, no-wrap
msgid "B<creat>(2)"
msgstr "B<creat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:115
#, no-wrap
msgid "B<dup>(2)"
msgstr "B<dup>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:116
#, no-wrap
msgid "B<dup2>(2)"
msgstr "B<dup2>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:117
#, no-wrap
msgid "B<execl>(3)"
msgstr "B<execl>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:117
#, no-wrap
msgid "Added in POSIX.1-2008; see notes below"
msgstr "POSIX.1-2008 で追加; 下記の「注意」を参照"

#. type: tbl table
#: build/C/man7/signal-safety.7:118
#, no-wrap
msgid "B<execle>(3)"
msgstr "B<execle>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:119
#, no-wrap
msgid "B<execv>(3)"
msgstr "B<execv>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:119 build/C/man7/signal-safety.7:123
#: build/C/man7/signal-safety.7:126 build/C/man7/signal-safety.7:128
#: build/C/man7/signal-safety.7:131 build/C/man7/signal-safety.7:135
#: build/C/man7/signal-safety.7:138 build/C/man7/signal-safety.7:154
#: build/C/man7/signal-safety.7:166 build/C/man7/signal-safety.7:168
#: build/C/man7/signal-safety.7:169 build/C/man7/signal-safety.7:170
#: build/C/man7/signal-safety.7:174 build/C/man7/signal-safety.7:186
#: build/C/man7/signal-safety.7:191 build/C/man7/signal-safety.7:241
#: build/C/man7/signal-safety.7:258 build/C/man7/signal-safety.7:260
#: build/C/man7/signal-safety.7:261
#, no-wrap
msgid "Added in POSIX.1-2008"
msgstr "POSIX.1-2008 で追加"

#. type: tbl table
#: build/C/man7/signal-safety.7:120
#, no-wrap
msgid "B<execve>(2)"
msgstr "B<execve>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:121
#, no-wrap
msgid "B<_exit>(2)"
msgstr "B<_exit>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:122
#, no-wrap
msgid "B<_Exit>(2)"
msgstr "B<_Exit>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:123
#, no-wrap
msgid "B<faccessat>(2)"
msgstr "B<faccessat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:124
#, no-wrap
msgid "B<fchdir>(2)"
msgstr "B<fchdir>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:124 build/C/man7/signal-safety.7:180
#: build/C/man7/signal-safety.7:181 build/C/man7/signal-safety.7:182
#, no-wrap
msgid "Added in POSIX.1-2008 TC1"
msgstr "POSIX.1-2008 TC1 で追加"

#. type: tbl table
#: build/C/man7/signal-safety.7:125
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:126
#, no-wrap
msgid "B<fchmodat>(2)"
msgstr "B<fchmodat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:127
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:128
#, no-wrap
msgid "B<fchownat>(2)"
msgstr "B<fchownat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:129
#, no-wrap
msgid "B<fcntl>(2)"
msgstr "B<fcntl>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:130
#, no-wrap
msgid "B<fdatasync>(2)"
msgstr "B<fdatasync>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:131
#, no-wrap
msgid "B<fexecve>(3)"
msgstr "B<fexecve>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:132
#, no-wrap
msgid "B<ffs>(3)"
msgstr "B<ffs>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:132 build/C/man7/signal-safety.7:150
#: build/C/man7/signal-safety.7:151 build/C/man7/signal-safety.7:159
#: build/C/man7/signal-safety.7:160 build/C/man7/signal-safety.7:161
#: build/C/man7/signal-safety.7:162 build/C/man7/signal-safety.7:163
#: build/C/man7/signal-safety.7:164 build/C/man7/signal-safety.7:171
#: build/C/man7/signal-safety.7:172 build/C/man7/signal-safety.7:223
#: build/C/man7/signal-safety.7:224 build/C/man7/signal-safety.7:225
#: build/C/man7/signal-safety.7:226 build/C/man7/signal-safety.7:227
#: build/C/man7/signal-safety.7:228 build/C/man7/signal-safety.7:229
#: build/C/man7/signal-safety.7:230 build/C/man7/signal-safety.7:231
#: build/C/man7/signal-safety.7:232 build/C/man7/signal-safety.7:233
#: build/C/man7/signal-safety.7:234 build/C/man7/signal-safety.7:235
#: build/C/man7/signal-safety.7:236 build/C/man7/signal-safety.7:237
#: build/C/man7/signal-safety.7:238 build/C/man7/signal-safety.7:239
#: build/C/man7/signal-safety.7:264 build/C/man7/signal-safety.7:265
#: build/C/man7/signal-safety.7:266 build/C/man7/signal-safety.7:267
#: build/C/man7/signal-safety.7:268 build/C/man7/signal-safety.7:269
#: build/C/man7/signal-safety.7:270 build/C/man7/signal-safety.7:271
#: build/C/man7/signal-safety.7:272 build/C/man7/signal-safety.7:273
#: build/C/man7/signal-safety.7:274 build/C/man7/signal-safety.7:275
#: build/C/man7/signal-safety.7:276 build/C/man7/signal-safety.7:277
#: build/C/man7/signal-safety.7:278 build/C/man7/signal-safety.7:279
#: build/C/man7/signal-safety.7:280 build/C/man7/signal-safety.7:281
#: build/C/man7/signal-safety.7:282 build/C/man7/signal-safety.7:283
#: build/C/man7/signal-safety.7:284 build/C/man7/signal-safety.7:285
#, no-wrap
msgid "Added in POSIX.1-2008 TC2"
msgstr "POSIX.1-2008 TC2 で追加"

#. type: tbl table
#: build/C/man7/signal-safety.7:133
#, no-wrap
msgid "B<fork>(2)"
msgstr "B<fork>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:134
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:135
#, no-wrap
msgid "B<fstatat>(2)"
msgstr "B<fstatat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:136
#, no-wrap
msgid "B<fsync>(2)"
msgstr "B<fsync>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:137
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:138
#, no-wrap
msgid "B<futimens>(3)"
msgstr "B<futimens>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:139
#, no-wrap
msgid "B<getegid>(2)"
msgstr "B<getegid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:140
#, no-wrap
msgid "B<geteuid>(2)"
msgstr "B<geteuid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:141
#, no-wrap
msgid "B<getgid>(2)"
msgstr "B<getgid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:142
#, no-wrap
msgid "B<getgroups>(2)"
msgstr "B<getgroups>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:143
#, no-wrap
msgid "B<getpeername>(2)"
msgstr "B<getpeername>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:144
#, no-wrap
msgid "B<getpgrp>(2)"
msgstr "B<getpgrp>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:145
#, no-wrap
msgid "B<getpid>(2)"
msgstr "B<getpid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:146
#, no-wrap
msgid "B<getppid>(2)"
msgstr "B<getppid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:147
#, no-wrap
msgid "B<getsockname>(2)"
msgstr "B<getsockname>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:148
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr "B<getsockopt>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:149
#, no-wrap
msgid "B<getuid>(2)"
msgstr "B<getuid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:150
#, no-wrap
msgid "B<htonl>(3)"
msgstr "B<htonl>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:151
#, no-wrap
msgid "B<htons>(3)"
msgstr "B<htons>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:153
#, no-wrap
msgid "B<link>(2)"
msgstr "B<link>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:154
#, no-wrap
msgid "B<linkat>(2)"
msgstr "B<linkat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:155
#, no-wrap
msgid "B<listen>(2)"
msgstr "B<listen>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:156
#, no-wrap
msgid "B<longjmp>(3)"
msgstr "B<longjmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:156 build/C/man7/signal-safety.7:210
#, no-wrap
msgid "Added in POSIX.1-2008 TC2; see notes below"
msgstr "POSIX.1-2008 TC2 で追加; 下記の「注意」を参照"

#. type: tbl table
#: build/C/man7/signal-safety.7:157
#, no-wrap
msgid "B<lseek>(2)"
msgstr "B<lseek>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:158
#, no-wrap
msgid "B<lstat>(2)"
msgstr "B<lstat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:159
#, no-wrap
msgid "B<memccpy>(3)"
msgstr "B<memccpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:160
#, no-wrap
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:161
#, no-wrap
msgid "B<memcmp>(3)"
msgstr "B<memcmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:162
#, no-wrap
msgid "B<memcpy>(3)"
msgstr "B<memcpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:163
#, no-wrap
msgid "B<memmove>(3)"
msgstr "B<memmove>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:164
#, no-wrap
msgid "B<memset>(3)"
msgstr "B<memset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:165
#, no-wrap
msgid "B<mkdir>(2)"
msgstr "B<mkdir>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:166
#, no-wrap
msgid "B<mkdirat>(2)"
msgstr "B<mkdirat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:167
#, no-wrap
msgid "B<mkfifo>(3)"
msgstr "B<mkfifo>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:168
#, no-wrap
msgid "B<mkfifoat>(3)"
msgstr "B<mkfifoat>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:169
#, no-wrap
msgid "B<mknod>(2)"
msgstr "B<mknod>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:170
#, no-wrap
msgid "B<mknodat>(2)"
msgstr "B<mknodat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:171
#, no-wrap
msgid "B<ntohl>(3)"
msgstr "B<ntohl>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:172
#, no-wrap
msgid "B<ntohs>(3)"
msgstr "B<ntohs>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:173
#, no-wrap
msgid "B<open>(2)"
msgstr "B<open>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:174
#, no-wrap
msgid "B<openat>(2)"
msgstr "B<openat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:176
#, no-wrap
msgid "B<pipe>(2)"
msgstr "B<pipe>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:177
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:178
#, no-wrap
msgid "B<posix_trace_event>(3)"
msgstr "B<posix_trace_event>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:179
#, no-wrap
msgid "B<pselect>(2)"
msgstr "B<pselect>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:181
#, no-wrap
msgid "B<pthread_self>(3)"
msgstr "B<pthread_self>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:182
#, no-wrap
msgid "B<pthread_sigmask>(3)"
msgstr "B<pthread_sigmask>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:185
#, no-wrap
msgid "B<readlink>(2)"
msgstr "B<readlink>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:186
#, no-wrap
msgid "B<readlinkat>(2)"
msgstr "B<readlinkat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:187
#, no-wrap
msgid "B<recv>(2)"
msgstr "B<recv>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:188
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr "B<recvfrom>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:189
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr "B<recvmsg>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:190
#, no-wrap
msgid "B<rename>(2)"
msgstr "B<rename>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:191
#, no-wrap
msgid "B<renameat>(2)"
msgstr "B<renameat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:192
#, no-wrap
msgid "B<rmdir>(2)"
msgstr "B<rmdir>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:193
#, no-wrap
msgid "B<select>(2)"
msgstr "B<select>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:194
#, no-wrap
msgid "B<sem_post>(3)"
msgstr "B<sem_post>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:195
#, no-wrap
msgid "B<send>(2)"
msgstr "B<send>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:196
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr "B<sendmsg>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:197
#, no-wrap
msgid "B<sendto>(2)"
msgstr "B<sendto>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:198
#, no-wrap
msgid "B<setgid>(2)"
msgstr "B<setgid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:199
#, no-wrap
msgid "B<setpgid>(2)"
msgstr "B<setpgid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:200
#, no-wrap
msgid "B<setsid>(2)"
msgstr "B<setsid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:201
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr "B<setsockopt>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:202
#, no-wrap
msgid "B<setuid>(2)"
msgstr "B<setuid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:203
#, no-wrap
msgid "B<shutdown>(2)"
msgstr "B<shutdown>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:205
#, no-wrap
msgid "B<sigaddset>(3)"
msgstr "B<sigaddset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:206
#, no-wrap
msgid "B<sigdelset>(3)"
msgstr "B<sigdelset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:207
#, no-wrap
msgid "B<sigemptyset>(3)"
msgstr "B<sigemptyset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:208
#, no-wrap
msgid "B<sigfillset>(3)"
msgstr "B<sigfillset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:209
#, no-wrap
msgid "B<sigismember>(3)"
msgstr "B<sigismember>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:210
#, no-wrap
msgid "B<siglongjmp>(3)"
msgstr "B<siglongjmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:212
#, no-wrap
msgid "B<sigpause>(3)"
msgstr "B<sigpause>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:215
#, no-wrap
msgid "B<sigqueue>(2)"
msgstr "B<sigqueue>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:216
#, no-wrap
msgid "B<sigset>(3)"
msgstr "B<sigset>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:218
#, no-wrap
msgid "B<sleep>(3)"
msgstr "B<sleep>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:219
#, no-wrap
msgid "B<sockatmark>(3)"
msgstr "B<sockatmark>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:219
#, no-wrap
msgid "Added in POSIX.1-2001 TC2"
msgstr "POSIX.1-2001 TC2 で追加"

#. type: tbl table
#: build/C/man7/signal-safety.7:220
#, no-wrap
msgid "B<socket>(2)"
msgstr "B<socket>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:221
#, no-wrap
msgid "B<socketpair>(2)"
msgstr "B<socketpair>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:222
#, no-wrap
msgid "B<stat>(2)"
msgstr "B<stat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:223
#, no-wrap
msgid "B<stpcpy>(3)"
msgstr "B<stpcpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:224
#, no-wrap
msgid "B<stpncpy>(3)"
msgstr "B<stpncpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:225
#, no-wrap
msgid "B<strcat>(3)"
msgstr "B<strcat>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:226
#, no-wrap
msgid "B<strchr>(3)"
msgstr "B<strchr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:227
#, no-wrap
msgid "B<strcmp>(3)"
msgstr "B<strcmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:228
#, no-wrap
msgid "B<strcpy>(3)"
msgstr "B<strcpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:229
#, no-wrap
msgid "B<strcspn>(3)"
msgstr "B<strcspn>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:230
#, no-wrap
msgid "B<strlen>(3)"
msgstr "B<strlen>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:231
#, no-wrap
msgid "B<strncat>(3)"
msgstr "B<strncat>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:232
#, no-wrap
msgid "B<strncmp>(3)"
msgstr "B<strncmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:233
#, no-wrap
msgid "B<strncpy>(3)"
msgstr "B<strncpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:234
#, no-wrap
msgid "B<strnlen>(3)"
msgstr "B<strnlen>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:235
#, no-wrap
msgid "B<strpbrk>(3)"
msgstr "B<strpbrk>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:236
#, no-wrap
msgid "B<strrchr>(3)"
msgstr "B<strrchr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:237
#, no-wrap
msgid "B<strspn>(3)"
msgstr "B<strspn>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:238
#, no-wrap
msgid "B<strstr>(3)"
msgstr "B<strstr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:239
#, no-wrap
msgid "B<strtok_r>(3)"
msgstr "B<strtok_r>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:240
#, no-wrap
msgid "B<symlink>(2)"
msgstr "B<symlink>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:241
#, no-wrap
msgid "B<symlinkat>(2)"
msgstr "B<symlinkat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:242
#, no-wrap
msgid "B<tcdrain>(3)"
msgstr "B<tcdrain>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:243
#, no-wrap
msgid "B<tcflow>(3)"
msgstr "B<tcflow>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:244
#, no-wrap
msgid "B<tcflush>(3)"
msgstr "B<tcflush>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:245
#, no-wrap
msgid "B<tcgetattr>(3)"
msgstr "B<tcgetattr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:246
#, no-wrap
msgid "B<tcgetpgrp>(3)"
msgstr "B<tcgetpgrp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:247
#, no-wrap
msgid "B<tcsendbreak>(3)"
msgstr "B<tcsendbreak>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:248
#, no-wrap
msgid "B<tcsetattr>(3)"
msgstr "B<tcsetattr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:249
#, no-wrap
msgid "B<tcsetpgrp>(3)"
msgstr "B<tcsetpgrp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:250
#, no-wrap
msgid "B<time>(2)"
msgstr "B<time>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:251
#, no-wrap
msgid "B<timer_getoverrun>(2)"
msgstr "B<timer_getoverrun>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:252
#, no-wrap
msgid "B<timer_gettime>(2)"
msgstr "B<timer_gettime>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:253
#, no-wrap
msgid "B<timer_settime>(2)"
msgstr "B<timer_settime>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:254
#, no-wrap
msgid "B<times>(2)"
msgstr "B<times>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:255
#, no-wrap
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:256
#, no-wrap
msgid "B<uname>(2)"
msgstr "B<uname>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:257
#, no-wrap
msgid "B<unlink>(2)"
msgstr "B<unlink>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:258
#, no-wrap
msgid "B<unlinkat>(2)"
msgstr "B<unlinkat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:259
#, no-wrap
msgid "B<utime>(2)"
msgstr "B<utime>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:260
#, no-wrap
msgid "B<utimensat>(2)"
msgstr "B<utimensat>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:261
#, no-wrap
msgid "B<utimes>(2)"
msgstr "B<utimes>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:262
#, no-wrap
msgid "B<wait>(2)"
msgstr "B<wait>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:263
#, no-wrap
msgid "B<waitpid>(2)"
msgstr "B<waitpid>(2)"

#. type: tbl table
#: build/C/man7/signal-safety.7:264
#, no-wrap
msgid "B<wcpcpy>(3)"
msgstr "B<wcpcpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:265
#, no-wrap
msgid "B<wcpncpy>(3)"
msgstr "B<wcpncpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:266
#, no-wrap
msgid "B<wcscat>(3)"
msgstr "B<wcscat>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:267
#, no-wrap
msgid "B<wcschr>(3)"
msgstr "B<wcschr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:268
#, no-wrap
msgid "B<wcscmp>(3)"
msgstr "B<wcscmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:269
#, no-wrap
msgid "B<wcscpy>(3)"
msgstr "B<wcscpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:270
#, no-wrap
msgid "B<wcscspn>(3)"
msgstr "B<wcscspn>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:271
#, no-wrap
msgid "B<wcslen>(3)"
msgstr "B<wcslen>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:272
#, no-wrap
msgid "B<wcsncat>(3)"
msgstr "B<wcsncat>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:273
#, no-wrap
msgid "B<wcsncmp>(3)"
msgstr "B<wcsncmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:274
#, no-wrap
msgid "B<wcsncpy>(3)"
msgstr "B<wcsncpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:275
#, no-wrap
msgid "B<wcsnlen>(3)"
msgstr "B<wcsnlen>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:276
#, no-wrap
msgid "B<wcspbrk>(3)"
msgstr "B<wcspbrk>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:277
#, no-wrap
msgid "B<wcsrchr>(3)"
msgstr "B<wcsrchr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:278
#, no-wrap
msgid "B<wcsspn>(3)"
msgstr "B<wcsspn>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:279
#, no-wrap
msgid "B<wcsstr>(3)"
msgstr "B<wcsstr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:280
#, no-wrap
msgid "B<wcstok>(3)"
msgstr "B<wcstok>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:281
#, no-wrap
msgid "B<wmemchr>(3)"
msgstr "B<wmemchr>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:282
#, no-wrap
msgid "B<wmemcmp>(3)"
msgstr "B<wmemcmp>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:283
#, no-wrap
msgid "B<wmemcpy>(3)"
msgstr "B<wmemcpy>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:284
#, no-wrap
msgid "B<wmemmove>(3)"
msgstr "B<wmemmove>(3)"

#. type: tbl table
#: build/C/man7/signal-safety.7:285
#, no-wrap
msgid "B<wmemset>(3)"
msgstr "B<wmemset>(3)"

#. type: Plain text
#: build/C/man7/signal-safety.7:290
msgid "Notes:"
msgstr "注意:"

#. type: Plain text
#: build/C/man7/signal-safety.7:297
msgid ""
"POSIX.1-2001 and POSIX.1-2001 TC2 required the functions B<fpathconf>(3), "
"B<pathconf>(3), and B<sysconf>(3)  to be async-signal-safe, but this "
"requirement was removed in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:305
msgid ""
"If a signal handler interrupts the execution of an unsafe function, and the "
"handler terminates via a call to B<longjmp>(3)  or B<siglongjmp>(3)  and the "
"program subsequently calls an unsafe function, then the behavior of the "
"program is undefined."
msgstr ""

#.  http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt
#. type: Plain text
#: build/C/man7/signal-safety.7:318
msgid ""
"POSIX.1-2001 TC1 clarified that if an application calls B<fork>(2)  from a "
"signal handler and any of the fork handlers registered by "
"B<pthread_atfork>(3)  calls a function that is not async-signal-safe, the "
"behavior is undefined.  A future revision of the standard is likely to "
"remove B<fork>(2)  from the list of async-signal-safe functions."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:324
msgid ""
"Asynchronous signal handlers that call functions which are cancellation "
"points and nest over regions of deferred cancellation may trigger "
"cancellation whose behavior is as if asynchronous cancellation had occurred "
"and may cause application state to become inconsistent."
msgstr ""

#. type: SS
#: build/C/man7/signal-safety.7:324
#, no-wrap
msgid "errno"
msgstr "errno"

#. type: Plain text
#: build/C/man7/signal-safety.7:331
msgid ""
"Fetching and setting the value of I<errno> is async-signal-safe provided "
"that the signal handler saves I<errno> on entry and restores its value "
"before returning."
msgstr ""

#. type: SS
#: build/C/man7/signal-safety.7:331
#, no-wrap
msgid "Deviations in the GNU C library"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:334
msgid ""
"The following known deviations from the standard occur in the GNU C library:"
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: build/C/man7/signal-safety.7:344
msgid ""
"Before glibc 2.24, B<execl>(3)  and B<execle>(3)  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe.  This was fixed in "
"glibc 2.24."
msgstr ""

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=13172
#. type: Plain text
#: build/C/man7/signal-safety.7:351
msgid ""
"The glibc implementation of B<aio_suspend>(3)  is not async-signal-safe "
"because it uses B<pthread_mutex_lock>(3)  internally."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:355
msgid "B<sigaction>(2), B<signal>(7), B<standards>(7)"
msgstr "B<sigaction>(2), B<signal>(7), B<standards>(7)"

#~ msgid "The per-process limit on open file descriptors has been reached."
#~ msgstr ""
#~ "オープン済みのファイルディスクリプターの数がプロセスあたりの上限に 達して"
#~ "いた。"

#~ msgid "decrements in real time, and delivers B<SIGALRM> upon expiration."
#~ msgstr "実時間 (real time) で減少し、満了すると B<SIGALRM> が送られる。"

#~ msgid ""
#~ "decrements only when the process is executing, and delivers B<SIGVTALRM> "
#~ "upon expiration."
#~ msgstr ""
#~ "プロセスが実行されている間のみ減少し、満了すると B<SIGVTALRM> が送られる。"

#~ msgid ""
#~ "decrements both when the process executes and when the system is "
#~ "executing on behalf of the process.  Coupled with B<ITIMER_VIRTUAL>, this "
#~ "timer is usually used to profile the time spent by the application in "
#~ "user and kernel space.  B<SIGPROF> is delivered upon expiration."
#~ msgstr ""
#~ "プロセスが実行されていて、 かつシステムがそのプロセスのために処理を行なっ"
#~ "ている間に減少する。 多くの場合、このタイマーは B<ITIMER_VIRTUAL> と組み合"
#~ "わされて、アプリケーションがカーネル空間とユーザー空間で どれだけの時間を"
#~ "過ごしたかをプロファイルするのに使用される。 満了すると B<SIGPROF> が送ら"
#~ "れる。"

#~ msgid ""
#~ "The function B<getitimer>()  fills the structure pointed to by "
#~ "I<curr_value> with the current value (i.e., the amount of time remaining "
#~ "until the next expiration)  of the timer specified by I<which> (one of "
#~ "B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>).  The subfields of "
#~ "the field I<it_value> are set to the amount of time remaining on the "
#~ "timer, or zero if the timer is disabled.  The I<it_interval> field is set "
#~ "to the timer interval (period); a value of zero returned in (both "
#~ "subfields of) this field indicates that this is a single-shot timer."
#~ msgstr ""
#~ "B<getitimer>()  関数は、 I<which> で指定されたタイマー (B<ITIMER_REAL>, "
#~ "B<ITIMER_VIRTUAL>, B<ITIMER_PROF> のどれか) の現在の値 (すなわち、次のタイ"
#~ "マー満了までの残り時間) を、 I<curr_value> で指定された構造体に格納する。 "
#~ "I<it_value> フィールドのサブフィールドにはタイマーの残り時間が設定され"
#~ "る。 タイマーが無効になっている場合は ゼロが設定される。 I<it_interval> "
#~ "フィールドにはタイマーのインターバル (期間) が設定される。 I<it_interval> "
#~ "(の両方のサブフィールド) で値 0 が返された場合は、 このタイマーが 1 回限り"
#~ "のタイマーであることを示している。"

#~ msgid ""
#~ "Timers decrement from I<it_value> to zero, generate a signal, and reset "
#~ "to I<it_interval>.  A timer which is set to zero (I<it_value> is zero or "
#~ "the timer expires and I<it_interval> is zero) stops."
#~ msgstr ""
#~ "タイマーは I<it_value> からゼロへ向けて減っていき、シグナルを生成し、 "
#~ "I<it_interval> に初期化される。 タイマーがゼロに設定された場合 "
#~ "(I<it_value> がゼロか、タイマーが満了した時に I<it_interval> がゼロの場"
#~ "合) は停止する。"

#~ msgid ""
#~ "Both I<tv_sec> and I<tv_usec> are significant in determining the duration "
#~ "of a timer."
#~ msgstr "タイマーの期間は I<tv_sec> と I<tv_usec> の両方により決定される。"

#~ msgid ""
#~ "For a process to have permission to send a signal it must either be "
#~ "privileged (under Linux: have the B<CAP_KILL> capability), or the real or "
#~ "effective user ID of the sending process must equal the real or saved set-"
#~ "user-ID of the target process.  In the case of B<SIGCONT> it suffices "
#~ "when the sending and receiving processes belong to the same session."
#~ msgstr ""
#~ "プロセスがシグナルを送信する許可を持つためには、 プロセスが特権 (Linux で"
#~ "は B<CAP_KILL> ケーパビリティ (capability)) を持つか、 送信元プロセスの実"
#~ "ユーザー ID または実効ユーザー ID が 送信先プロセスの実 set-user-ID または"
#~ "保存 set-user-ID と 等しくなければならない。 B<SIGCONT> の場合、送信プロセ"
#~ "スと受信プロセスが 同じセッションに属していれば十分である。"

#~ msgid ""
#~ "If I<arg2> is nonzero, set the \"child subreaper\" attribute of the "
#~ "calling process; if I<arg2> is zero, unset the attribute.  When a process "
#~ "is marked as a child subreaper, all of the children that it creates, and "
#~ "their descendants, will be marked as having a subreaper.  In effect, a "
#~ "subreaper fulfills the role of B<init>(1)  for its descendant processes.  "
#~ "Upon termination of a process that is orphaned (i.e., its immediate "
#~ "parent has already terminated)  and marked as having a subreaper, the "
#~ "nearest still living ancestor subreaper will receive a B<SIGCHLD> signal "
#~ "and be able to B<wait>(2)  on the process to discover its termination "
#~ "status."
#~ msgstr ""
#~ "I<arg2> が 0 以外の場合、 呼び出し元プロセスの \"child subreaper\" 属性を"
#~ "セットする。 I<arg2> が 0 の場合、 この属性をクリアする。 プロセスが "
#~ "child subreaper のマークが付いている場合、 このプロセスの子プロセスやその"
#~ "子孫にはすべて subreaper のマークが付与される。 subreaper は事実上その子孫"
#~ "のプロセスに対して B<init>(1) の役割を果たす。 孤児になったプロセス (直接"
#~ "の親プロセスがすでに終了しているプロセス) が終了した際、 そのプロセスに "
#~ "subreaper のマークが付いていると、 最も近い存在する先祖の subreaper プロセ"
#~ "スに B<SIGCHLD> シグナルが送られ、 そのプロセスの B<wait> を使って終了ス"
#~ "テータスを知ることができる。"

#~ msgid ""
#~ "Set the state of the thread's \"keep capabilities\" flag, which "
#~ "determines whether the threads's permitted capability set is cleared when "
#~ "a change is made to the threads's user IDs such that the threads's real "
#~ "UID, effective UID, and saved set-user-ID all become nonzero when at "
#~ "least one of them previously had the value 0.  By default, the permitted "
#~ "capability set is cleared when such a change is made; setting the \"keep "
#~ "capabilities\" flag prevents it from being cleared.  I<arg2> must be "
#~ "either 0 (permitted capabilities are cleared)  or 1 (permitted "
#~ "capabilities are kept).  (A thread's I<effective> capability set is "
#~ "always cleared when such a credential change is made, regardless of the "
#~ "setting of the \"keep capabilities\" flag.)  The \"keep capabilities\" "
#~ "value will be reset to 0 on subsequent calls to B<execve>(2)."
#~ msgstr ""
#~ "スレッドの「ケーパビリティ保持」フラグを設定する。 このフラグは、スレッド"
#~ "の実 UID、実効 UID、保存 set-user-ID のうち少なくとも一つが 0 であった状態"
#~ "から、これら全てが 0 以外に変更されたとき、 スレッドの許可ケーパビリティ集"
#~ "合がクリアされるかどうかを決定する。 デフォルトでは、このような変更が行わ"
#~ "れた場合、許可ケーパビリティセットはクリアされる。「ケーパビリティ保持」フ"
#~ "ラグを設定すると、許可ケーパビリティセットはクリアされなくなる。 I<arg2> "
#~ "は 0 (許可ケーパビリティをクリアする) か 1 (許可ケーパビリティを保持する) "
#~ "の どちらかでなければならない。 (このような ID の変更が行われた場合、"
#~ "「ケーパビリティ保持」フラグの設定に関わらず、スレッドのI<実効>ケーパビリ"
#~ "ティセットは常にクリアされる。) B<execve>(2) が呼び出されると、「ケーパビ"
#~ "リティ保持」フラグは 0 にリセットされる。"

#~ msgid ""
#~ "The second limitation is that such transitions can be done only once in a "
#~ "process life time.  Any further attempts will be rejected.  This should "
#~ "help system administrators monitor unusual symbolic-link transitions over "
#~ "all processes running on a system."
#~ msgstr ""
#~ "二つ目の制限は、このような変更はプロセスの生存期間で一度だけ行うことができ"
#~ "るという点である。 一度変更を行った後で変更を行おうとすると拒否される。 こ"
#~ "の動作は、 システム管理者が、 システムで動作するすべてのプロセスが行う、 "
#~ "普通でないシンボリックリンクの変更を監視するのを楽にする。"

#~ msgid ""
#~ "The array I<sys_siglist> holds the signal description strings indexed by "
#~ "signal number."
#~ msgstr ""
#~ "配列 I<sys_siglist> はシグナルを説明する文字列を保持しており、 配列へのア"
#~ "クセスにはシグナル番号を添え字として用いる事ができる。"

#~ msgid ""
#~ "I<sa_handler> specifies the action to be associated with I<signum> and "
#~ "may be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this "
#~ "signal, or a pointer to a signal handling function.  This function "
#~ "receives the signal number as its only argument."
#~ msgstr ""
#~ "I<sa_handler> は I<signum> に対応する動作を指定するもので、 デフォルトの動"
#~ "作を行う B<SIG_DFL>、 そのシグナルを無視する B<SIG_IGN>、 シグナルハンド"
#~ "ラー関数へのポインターが設定できる。 シグナルハンドラー関数の引数は一つ"
#~ "であり、シグナル番号が引数として 渡される。"

#~ msgid ""
#~ "If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> "
#~ "(instead of I<sa_handler>)  specifies the signal-handling function for "
#~ "I<signum>.  This function receives the signal number as its first "
#~ "argument, a pointer to a I<siginfo_t> as its second argument and a "
#~ "pointer to a I<ucontext_t> (cast to I<void\\ *>) as its third argument.  "
#~ "(Commonly, the handler function doesn't make any use of the third "
#~ "argument.  See B<getcontext>(3)  for further information about "
#~ "I<ucontext_t>.)"
#~ msgstr ""
#~ "I<sa_flags> に B<SA_SIGINFO> が指定された場合、 (I<sa_handler> ではなく) "
#~ "I<sa_sigaction> により I<signum> に対応するシグナルハンドラー関数が指定さ"
#~ "れる。指定される関数は、最初の引数としてシグナル番号を、二番目の引数と"
#~ "して I<siginfo_t> へのポインターを、三番目の引数として (I<void\\ *> に"
#~ "キャストした) I<ucontext_t> へのポインターを受けとる。 (一般的には、ハンド"
#~ "ラー関数の三番目の引数が使用されない。I<ucontext_t> についての詳しい情報"
#~ "は B<getcontext>(3) を参照。)"

#~ msgid ""
#~ "Do not prevent the signal from being received from within its own signal "
#~ "handler.  This flag is meaningful only when establishing a signal "
#~ "handler.  B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
#~ msgstr ""
#~ "それ自身のシグナルハンドラーの内部にいる時でも そのシグナルをマスクしない"
#~ "ようにする。 このフラグはシグナルハンドラーを設定する際にのみ意味を持つ。 "
#~ "B<SA_NOMASK> はこのフラグと同じ意味だが、廃止されており、非標準である。"

#~ msgid ""
#~ "A successful call to B<execve>(2)  removes any existing alternate signal "
#~ "stack.  A child process created via B<fork>(2)  inherits a copy of its "
#~ "parent's alternate signal stack settings."
#~ msgstr ""
#~ "B<execve>(2)  の呼び出しが成功すると、 既存の全ての代替シグナルスタックが"
#~ "削除される。 B<fork>(2)  経由で作成された子プロセスは、親プロセスの代替シ"
#~ "グナルスタックの 設定のコピーを継承する。"

#~ msgid "The following code segment demonstrates the use of B<sigaltstack>():"
#~ msgstr "以下のコードで B<sigaltstack>()  の使用法の一部を示す:"

#~ msgid ""
#~ "The B<siginterrupt>()  function uses a global variable that is not "
#~ "protected, so it is not thread-safe."
#~ msgstr ""
#~ "B<siginterrupt>() 関数は保護されていないグローバル変数を使用しているので、"
#~ "スレッドセーフではない。"

#~ msgid ""
#~ "On glibc 2 and later, if the B<_BSD_SOURCE> feature test macro is not "
#~ "defined, then B<signal>()  provides System\\ V semantics.  (The default "
#~ "implicit definition of B<_BSD_SOURCE> is not provided if one invokes "
#~ "B<gcc>(1)  in one of its standard modes (I<-std=xxx> or I<-ansi>)  or "
#~ "defines various other feature test macros such as B<_POSIX_SOURCE>, "
#~ "B<_XOPEN_SOURCE>, or B<_SVID_SOURCE>; see B<feature_test_macros>(7).)"
#~ msgstr ""
#~ "glibc 2 以降では、機能検査マクロ B<_BSD_SOURCE> が定義されていなければ、 "
#~ "B<signal>()  は System\\ V 方式となる。 (B<gcc>(1)  が標準指定モード (I<-"
#~ "std=xxx> or I<-ansi>)  で起動された場合、もしくは B<_POSIX_SOURCE>, "
#~ "B<_XOPEN_SOURCE>, B<_SVID_SOURCE> といった他の様々な機能検査マクロが定義さ"
#~ "れた場合、 デフォルトの B<_BSD_SOURCE> の暗黙の定義は行われない。 "
#~ "B<feature_test_macros>(7)  を参照のこと。)"

#~ msgid ""
#~ "A signal may be generated (and thus pending)  for a process as a whole (e."
#~ "g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
#~ "signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
#~ "executing a specific machine-language instruction are thread directed, as "
#~ "are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
#~ "process-directed signal may be delivered to any one of the threads that "
#~ "does not currently have the signal blocked.  If more than one of the "
#~ "threads has the signal unblocked, then the kernel chooses an arbitrary "
#~ "thread to which to deliver the signal."
#~ msgstr ""
#~ "生成されるシグナル (したがって処理待ちとなるシグナル) には、 プロセス全体"
#~ "宛てと特定のスレッド宛てがある。 例えば、プロセス全体宛てのシグナルは "
#~ "B<kill>(2)  を使って送信される。 特定のマシン語の命令の実行の結果として生"
#~ "成される、 B<SIGSEGV> や B<SIGFPE> などのシグナルは、スレッド宛てとなる。 "
#~ "また、 B<pthread_kill>(3)  を使って特定のスレッド宛てに生成されたシグナル"
#~ "も スレッド宛てとなる。 プロセス宛てのシグナルは、そのシグナルをブロックし"
#~ "ていないスレッドのうち いずれかの一つに配送することができる。そのシグナル"
#~ "をブロックしていない スレッドが複数ある場合、シグナルを配送するスレッドは"
#~ "カーネルが 無作為に選択する。"

#~ msgid ""
#~ "Linux supports the standard signals listed below.  Several signal numbers "
#~ "are architecture-dependent, as indicated in the \"Value\" column.  (Where "
#~ "three values are given, the first one is usually valid for alpha and "
#~ "sparc, the middle one for x86, arm, and most other architectures, and the "
#~ "last one for mips.  (Values for parisc are I<not> shown; see the Linux "
#~ "kernel source for signal numbering on that architecture.)  A - denotes "
#~ "that a signal is absent on the corresponding architecture.)"
#~ msgstr ""
#~ "Linux は以下に示す標準シグナルに対応している。シグナル番号の一部はアーキテ"
#~ "クチャー依存であり、\"値\" 欄に示す通りである。 (3つの値が書かれているもの"
#~ "は、 1つ目が alpha と sparc で通常有効な値、 真ん中が x86, arm や他のほと"
#~ "んどのアーキテクチャーでの有効な値、最後が mips での値である。 (parisc で"
#~ "の値は記載されてI<いない>。 parisc でのシグナル番号は Linux カーネルソース"
#~ "を参照してほしい)。 - はそのアーキテクチャーにおいて対応するシグナルがない"
#~ "ことを示す。)"

#~ msgid "First the signals described in the original POSIX.1-1990 standard."
#~ msgstr "最初に、POSIX.1-1990 に定義されているシグナルを示す。"

#~ msgid "readers"
#~ msgstr "読み手の無いパイプへの書き出し"

#~ msgid ""
#~ "Next the signals not in the POSIX.1-1990 standard but described in SUSv2 "
#~ "and POSIX.1-2001."
#~ msgstr ""
#~ "次に、 POSIX.1-1990 標準にはないが、 SUSv2 と POSIX.1-2001 に記述されてい"
#~ "るシグナルを示す。"

#~ msgid "Bad argument to routine (SVr4)"
#~ msgstr "ルーチンへの引数が不正 (SVr4)"

#~ msgid "Next various other signals."
#~ msgstr "次にその他の各種シグナルを示す。"

#~ msgid ""
#~ "A signal handler function must be very careful, since processing "
#~ "elsewhere may be interrupted at some arbitrary point in the execution of "
#~ "the program.  POSIX has the concept of \"safe function\".  If a signal "
#~ "interrupts the execution of an unsafe function, and I<handler> calls an "
#~ "unsafe function, then the behavior of the program is undefined."
#~ msgstr ""
#~ "シグナルハンドラー関数には非常に注意しなければならない。 他の場所の処理は"
#~ "プログラム実行の任意の箇所で中断される可能性があるためである。 POSIX には"
#~ "「安全な関数 (safe function)」という概念がある。 シグナルが安全でない関数"
#~ "の実行を中断し、かつ I<handler> が安全でない関数を呼び出した場合、プログラ"
#~ "ムの挙動は未定義である。"

#~ msgid ""
#~ "POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  "
#~ "requires an implementation to guarantee that the following functions can "
#~ "be safely called inside a signal handler:"
#~ msgstr ""
#~ "POSIX.1-2004 (POSIX.1-2001 Technical Corrigendum (正誤表) 2 とも言う) で"
#~ "は、 シグナルハンドラー内での安全な呼び出しを保証することが必須の関数とし"
#~ "て 以下が規定されている。"

#~ msgid ""
#~ "B<sigreturn>()  exists only to allow the implementation of signal "
#~ "handlers.  It should B<never> be called directly.  Details of the "
#~ "arguments (if any) passed to B<sigreturn>()  vary depending on the "
#~ "architecture."
#~ msgstr ""
#~ "B<sigreturn>() はシグナルハンドラーを実装するためだけに存在している。 これ"
#~ "らを直接呼び出すのはB<決して>行うべきではない。 B<sigreturn>() に渡される"
#~ "引数の詳細はアーキテクチャーにより異なる。"

#~ msgid ""
#~ "The raw B<sigtimedwait>()  system call has a fifth argument, I<size_t "
#~ "sigsetsize>, which specifies the size in bytes of the I<set> argument.  "
#~ "The glibc B<sigtimedwait>()  wrapper function specifies this argument as "
#~ "a fixed value (equal to I<sizeof(sigset_t)>)."
#~ msgstr ""
#~ "素の B<sigtimedwait>() システムコールは 5 番目の引数 I<size_t "
#~ "sigsetsize> を取る。 この引数は I<set> 引数のバイト単位のサイズを指定"
#~ "する。 glibc の B<sigtimedwait>() のラッパー関数はこの引数に固定値 "
#~ "(I<sizeof(sigset_t)> と同じ) を指定する。"

#~ msgid ""
#~ "B<timerfd_create>()  creates a new timer object, and returns a file "
#~ "descriptor that refers to that timer.  The I<clockid> argument specifies "
#~ "the clock that is used to mark the progress of the timer, and must be "
#~ "either B<CLOCK_REALTIME> or B<CLOCK_MONOTONIC>.  B<CLOCK_REALTIME> is a "
#~ "settable system-wide clock.  B<CLOCK_MONOTONIC> is a nonsettable clock "
#~ "that is not affected by discontinuous changes in the system clock (e.g., "
#~ "manual changes to system time).  The current value of each of these "
#~ "clocks can be retrieved using B<clock_gettime>(2)."
#~ msgstr ""
#~ "B<timerfd_create>()  は新規のタイマーオブジェクトを生成し、そのタイマーを"
#~ "参照するファイル ディスクリプターを返す。 I<clockid> 引数は、タイマーの"
#~ "進捗を管理するためのクロックを指定するもので、 B<CLOCK_REALTIME> か "
#~ "B<CLOCK_MONOTONIC> のいずれかでなければならない。 B<CLOCK_REALTIME> はシス"
#~ "テム全体で使用されるクロックで、このクロックは変更可能である。 "
#~ "B<CLOCK_MONOTONIC> は変更されることのないクロックで、(システム時刻の手動で"
#~ "の変更などの)  システムクロックの不連続な変化の影響を受けない。 これらのク"
#~ "ロックの現在の値は B<clock_gettime>(2)  を使って取得できる。"

#~ msgid ""
#~ "The I<flags> argument is either 0, to start a relative timer (I<new_value."
#~ "it_value> specifies a time relative to the current value of the clock "
#~ "specified by I<clockid>), or B<TFD_TIMER_ABSTIME>, to start an absolute "
#~ "timer (I<new_value.it_value> specifies an absolute time for the clock "
#~ "specified by I<clockid>; that is, the timer will expire when the value of "
#~ "that clock reaches the value specified in I<new_value.it_value>)."
#~ msgstr ""
#~ "I<flags> 引数には 0 か B<TFD_TIMER_ABSTIME> を指定する。 0 は相対時刻タ"
#~ "イマーを意味し、 I<new_value.it_value> では I<clockid> で指定されたクロッ"
#~ "クの現在の値からの相対的な時刻を指定する。 B<TFD_TIMER_ABSTIME> は絶対時刻"
#~ "タイマーを意味し、 I<new_value.it_interval> では I<clockid> で指定されたク"
#~ "ロックの絶対時刻を指定する。 つまり、クロックの値が I<new_value."
#~ "it_interval> で指定された時刻に達したら、タイマーが満了する。"

#~ msgid ""
#~ "The I<clockid> argument is neither B<CLOCK_MONOTONIC> nor "
#~ "B<CLOCK_REALTIME>;"
#~ msgstr ""
#~ "I<clockid> 引数が B<CLOCK_MONOTONIC> でも B<CLOCK_REALTIME> でもない。"

#~ msgid ""
#~ "Glibc does not provide wrappers for these system calls; call them using "
#~ "B<syscall>(2)."
#~ msgstr ""
#~ "glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
#~ "B<syscall>(2)  を使って呼び出すこと。"

#~ msgid "Wait for any child whose process group ID matches I<id>."
#~ msgstr "プロセスグループID が I<id> と一致する子プロセスを待つ。"
