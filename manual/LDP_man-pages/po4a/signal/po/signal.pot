# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsd_signal.3:25
#, no-wrap
msgid "BSD_SIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/bsd_signal.3:25 build/C/man2/sigsuspend.2:29
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man3/bsd_signal.3:25 build/C/man2/eventfd.2:22 build/C/man2/getitimer.2:13 build/C/man3/gsignal.3:27 build/C/man2/kill.2:44 build/C/man2/pause.2:30 build/C/man2/prctl.2:59 build/C/man3/profil.3:28 build/C/man3/psignal.3:30 build/C/man3/raise.3:29 build/C/man2/restart_syscall.2:33 build/C/man2/rt_sigqueueinfo.2:25 build/C/man2/s390_runtime_instr.2:25 build/C/man2/sgetmask.2:25 build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:26 build/C/man7/sigevent.7:26 build/C/man3/siginterrupt.3:31 build/C/man2/signal.2:36 build/C/man7/signal.7:45 build/C/man2/signalfd.2:20 build/C/man3/sigpause.3:25 build/C/man2/sigpending.2:29 build/C/man2/sigprocmask.2:29 build/C/man3/sigqueue.3:28 build/C/man2/sigreturn.2:30 build/C/man3/sigset.3:25 build/C/man3/sigsetops.3:31 build/C/man2/sigsuspend.2:29 build/C/man3/sigvec.3:25 build/C/man3/sigwait.3:26 build/C/man2/sigwaitinfo.2:25 build/C/man3/sysv_signal.3:25 build/C/man2/timer_create.2:26 build/C/man2/timer_delete.2:26 build/C/man2/timer_getoverrun.2:26 build/C/man2/timer_settime.2:26 build/C/man2/timerfd_create.2:19 build/C/man2/tkill.2:29 build/C/man2/wait.2:49 build/C/man2/wait4.2:33 build/C/man3/killpg.3:42 build/C/man7/signal-safety.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:26 build/C/man2/eventfd.2:23 build/C/man2/getitimer.2:14 build/C/man3/gsignal.3:28 build/C/man2/kill.2:45 build/C/man2/pause.2:31 build/C/man2/prctl.2:60 build/C/man3/profil.3:29 build/C/man3/psignal.3:31 build/C/man3/raise.3:30 build/C/man2/restart_syscall.2:34 build/C/man2/rt_sigqueueinfo.2:26 build/C/man2/s390_runtime_instr.2:26 build/C/man2/sgetmask.2:26 build/C/man2/sigaction.2:49 build/C/man2/sigaltstack.2:27 build/C/man7/sigevent.7:27 build/C/man3/siginterrupt.3:32 build/C/man2/signal.2:37 build/C/man7/signal.7:46 build/C/man2/signalfd.2:21 build/C/man3/sigpause.3:26 build/C/man2/sigpending.2:30 build/C/man2/sigprocmask.2:30 build/C/man3/sigqueue.3:29 build/C/man2/sigreturn.2:31 build/C/man3/sigset.3:26 build/C/man3/sigsetops.3:32 build/C/man2/sigsuspend.2:30 build/C/man3/sigvec.3:26 build/C/man3/sigwait.3:27 build/C/man2/sigwaitinfo.2:26 build/C/man3/sysv_signal.3:26 build/C/man2/timer_create.2:27 build/C/man2/timer_delete.2:27 build/C/man2/timer_getoverrun.2:27 build/C/man2/timer_settime.2:27 build/C/man2/timerfd_create.2:20 build/C/man2/tkill.2:30 build/C/man2/wait.2:50 build/C/man2/wait4.2:34 build/C/man3/killpg.3:43 build/C/man7/signal-safety.7:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:28
msgid "bsd_signal - signal handling with BSD semantics"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:28 build/C/man2/eventfd.2:25 build/C/man2/getitimer.2:16 build/C/man3/gsignal.3:30 build/C/man2/kill.2:47 build/C/man2/pause.2:33 build/C/man2/prctl.2:62 build/C/man3/profil.3:31 build/C/man3/psignal.3:33 build/C/man3/raise.3:32 build/C/man2/restart_syscall.2:36 build/C/man2/rt_sigqueueinfo.2:28 build/C/man2/s390_runtime_instr.2:28 build/C/man2/sgetmask.2:28 build/C/man2/sigaction.2:51 build/C/man2/sigaltstack.2:29 build/C/man7/sigevent.7:29 build/C/man3/siginterrupt.3:34 build/C/man2/signal.2:39 build/C/man2/signalfd.2:23 build/C/man3/sigpause.3:28 build/C/man2/sigpending.2:32 build/C/man2/sigprocmask.2:32 build/C/man3/sigqueue.3:31 build/C/man2/sigreturn.2:33 build/C/man3/sigset.3:28 build/C/man3/sigsetops.3:35 build/C/man2/sigsuspend.2:32 build/C/man3/sigvec.3:28 build/C/man3/sigwait.3:29 build/C/man2/sigwaitinfo.2:29 build/C/man3/sysv_signal.3:28 build/C/man2/timer_create.2:29 build/C/man2/timer_delete.2:29 build/C/man2/timer_getoverrun.2:29 build/C/man2/timer_settime.2:30 build/C/man2/timerfd_create.2:23 build/C/man2/tkill.2:32 build/C/man2/wait.2:52 build/C/man2/wait4.2:36 build/C/man3/killpg.3:45
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:30 build/C/man2/sigaltstack.2:31 build/C/man2/signal.2:41 build/C/man2/sigpending.2:34 build/C/man2/sigprocmask.2:34 build/C/man3/sigqueue.3:33 build/C/man3/sigset.3:30 build/C/man3/sigsetops.3:37 build/C/man2/sigsuspend.2:34 build/C/man3/sigvec.3:30 build/C/man3/sysv_signal.3:32 build/C/man3/killpg.3:47
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:32 build/C/man2/signal.2:43 build/C/man3/sigset.3:32 build/C/man3/sysv_signal.3:34
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:34
msgid "B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:38 build/C/man3/gsignal.3:44 build/C/man2/kill.2:58 build/C/man3/profil.3:42 build/C/man3/psignal.3:44 build/C/man2/sigaction.2:62 build/C/man2/sigaltstack.2:37 build/C/man3/siginterrupt.3:44 build/C/man2/sigpending.2:40 build/C/man2/sigprocmask.2:51 build/C/man3/sigqueue.3:39 build/C/man3/sigset.3:44 build/C/man3/sigsetops.3:51 build/C/man2/sigsuspend.2:40 build/C/man3/sigvec.3:44 build/C/man3/sigwait.3:39 build/C/man2/sigwaitinfo.2:42 build/C/man2/timer_create.2:43 build/C/man2/timer_delete.2:41 build/C/man2/timer_getoverrun.2:41 build/C/man2/timer_settime.2:45 build/C/man2/wait.2:69 build/C/man2/wait4.2:53 build/C/man3/killpg.3:53
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:42
msgid "B<bsd_signal>():"
msgstr ""

#.     || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/bsd_signal.3:47
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _XOPEN_SOURCE E<gt>= 500\n"
"        && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:50
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:52 build/C/man2/eventfd.2:29 build/C/man2/getitimer.2:24 build/C/man3/gsignal.3:52 build/C/man2/kill.2:64 build/C/man2/pause.2:37 build/C/man2/prctl.2:69 build/C/man3/profil.3:54 build/C/man3/psignal.3:54 build/C/man3/raise.3:38 build/C/man2/restart_syscall.2:41 build/C/man2/rt_sigqueueinfo.2:38 build/C/man2/s390_runtime_instr.2:34 build/C/man2/sgetmask.2:35 build/C/man2/sigaction.2:71 build/C/man2/sigaltstack.2:50 build/C/man7/sigevent.7:54 build/C/man3/siginterrupt.3:55 build/C/man2/signal.2:45 build/C/man7/signal.7:48 build/C/man2/signalfd.2:27 build/C/man3/sigpause.3:36 build/C/man2/sigpending.2:46 build/C/man2/sigprocmask.2:57 build/C/man3/sigqueue.3:43 build/C/man2/sigreturn.2:35 build/C/man3/sigset.3:57 build/C/man3/sigsetops.3:63 build/C/man2/sigsuspend.2:46 build/C/man3/sigvec.3:51 build/C/man3/sigwait.3:51 build/C/man2/sigwaitinfo.2:47 build/C/man3/sysv_signal.3:36 build/C/man2/timer_create.2:47 build/C/man2/timer_delete.2:45 build/C/man2/timer_getoverrun.2:45 build/C/man2/timer_settime.2:50 build/C/man2/timerfd_create.2:35 build/C/man2/tkill.2:43 build/C/man2/wait.2:87 build/C/man2/wait4.2:73 build/C/man3/killpg.3:62 build/C/man7/signal-safety.7:28
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:57
msgid ""
"The B<bsd_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:70
msgid ""
"The difference between the two is that B<bsd_signal>()  is guaranteed to "
"provide reliable signal semantics, that is: a) the disposition of the signal "
"is not reset to the default when the handler is invoked; b) delivery of "
"further instances of the signal is blocked while the signal handler is "
"executing; and c) if the handler interrupts a blocking system call, then the "
"system call is automatically restarted.  A portable application cannot rely "
"on B<signal>(2)  to provide these guarantees."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:70 build/C/man2/eventfd.2:226 build/C/man2/getitimer.2:133 build/C/man2/kill.2:99 build/C/man2/pause.2:42 build/C/man2/prctl.2:1909 build/C/man3/profil.3:76 build/C/man3/psignal.3:84 build/C/man3/raise.3:61 build/C/man2/restart_syscall.2:88 build/C/man2/rt_sigqueueinfo.2:138 build/C/man2/s390_runtime_instr.2:58 build/C/man2/sgetmask.2:58 build/C/man2/sigaction.2:847 build/C/man2/sigaltstack.2:189 build/C/man3/siginterrupt.3:73 build/C/man2/signal.2:98 build/C/man2/signalfd.2:291 build/C/man3/sigpause.3:48 build/C/man2/sigpending.2:52 build/C/man2/sigprocmask.2:108 build/C/man3/sigqueue.3:83 build/C/man2/sigreturn.2:67 build/C/man3/sigset.3:128 build/C/man3/sigsetops.3:107 build/C/man2/sigsuspend.2:70 build/C/man3/sigvec.3:203 build/C/man3/sigwait.3:75 build/C/man2/sigwaitinfo.2:106 build/C/man3/sysv_signal.3:51 build/C/man2/timer_create.2:202 build/C/man2/timer_delete.2:53 build/C/man2/timer_getoverrun.2:82 build/C/man2/timer_settime.2:173 build/C/man2/timerfd_create.2:407 build/C/man2/tkill.2:92 build/C/man2/wait.2:397 build/C/man2/wait4.2:146 build/C/man3/killpg.3:83
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:76
msgid ""
"The B<bsd_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:76 build/C/man2/eventfd.2:233 build/C/man2/getitimer.2:138 build/C/man2/kill.2:104 build/C/man2/pause.2:53 build/C/man2/prctl.2:1936 build/C/man2/restart_syscall.2:92 build/C/man2/rt_sigqueueinfo.2:143 build/C/man2/s390_runtime_instr.2:69 build/C/man2/sgetmask.2:63 build/C/man2/sigaction.2:852 build/C/man2/sigaltstack.2:193 build/C/man3/siginterrupt.3:83 build/C/man2/signal.2:106 build/C/man2/signalfd.2:305 build/C/man2/sigpending.2:58 build/C/man2/sigprocmask.2:114 build/C/man3/sigqueue.3:91 build/C/man3/sigset.3:153 build/C/man3/sigsetops.3:127 build/C/man2/sigsuspend.2:76 build/C/man3/sigvec.3:220 build/C/man3/sigwait.3:80 build/C/man2/sigwaitinfo.2:115 build/C/man3/sysv_signal.3:57 build/C/man2/timer_create.2:210 build/C/man2/timer_delete.2:60 build/C/man2/timer_getoverrun.2:90 build/C/man2/timer_settime.2:182 build/C/man2/timerfd_create.2:422 build/C/man2/tkill.2:96 build/C/man2/wait.2:427 build/C/man2/wait4.2:149 build/C/man3/killpg.3:88
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:79 build/C/man3/sysv_signal.3:60
msgid "As for B<signal>(2)."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:79 build/C/man2/eventfd.2:270 build/C/man3/gsignal.3:98 build/C/man3/profil.3:78 build/C/man3/psignal.3:94 build/C/man3/raise.3:64 build/C/man2/sigaltstack.2:213 build/C/man3/siginterrupt.3:87 build/C/man3/sigpause.3:56 build/C/man3/sigqueue.3:117 build/C/man3/sigset.3:172 build/C/man3/sigsetops.3:132 build/C/man3/sigvec.3:232 build/C/man3/sigwait.3:86 build/C/man3/sysv_signal.3:60
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:82 build/C/man2/eventfd.2:273 build/C/man3/gsignal.3:101 build/C/man3/profil.3:81 build/C/man3/psignal.3:97 build/C/man3/raise.3:67 build/C/man2/sigaltstack.2:216 build/C/man3/siginterrupt.3:90 build/C/man3/sigpause.3:59 build/C/man3/sigqueue.3:120 build/C/man3/sigset.3:175 build/C/man3/sigsetops.3:135 build/C/man3/sigvec.3:235 build/C/man3/sigwait.3:89 build/C/man3/sysv_signal.3:63
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277 build/C/man3/gsignal.3:105 build/C/man3/profil.3:85 build/C/man3/psignal.3:101 build/C/man3/raise.3:71 build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94 build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124 build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139 build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93 build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277 build/C/man3/gsignal.3:105 build/C/man3/profil.3:85 build/C/man3/psignal.3:101 build/C/man3/raise.3:71 build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94 build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124 build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139 build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93 build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:86 build/C/man2/eventfd.2:277 build/C/man3/gsignal.3:105 build/C/man3/profil.3:85 build/C/man3/psignal.3:101 build/C/man3/raise.3:71 build/C/man2/sigaltstack.2:220 build/C/man3/siginterrupt.3:94 build/C/man3/sigpause.3:63 build/C/man3/sigqueue.3:124 build/C/man3/sigset.3:179 build/C/man3/sigsetops.3:139 build/C/man3/sigvec.3:239 build/C/man3/sigwait.3:93 build/C/man3/sysv_signal.3:67
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:89
#, no-wrap
msgid "B<bsd_signal>()"
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:89 build/C/man2/eventfd.2:280 build/C/man3/gsignal.3:108 build/C/man3/gsignal.3:111 build/C/man3/profil.3:88 build/C/man3/psignal.3:105 build/C/man3/raise.3:74 build/C/man2/sigaltstack.2:223 build/C/man3/siginterrupt.3:97 build/C/man3/sigpause.3:66 build/C/man3/sigqueue.3:127 build/C/man3/sigset.3:186 build/C/man3/sigsetops.3:152 build/C/man3/sigvec.3:246 build/C/man3/sigwait.3:96 build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/bsd_signal.3:89 build/C/man2/eventfd.2:280 build/C/man3/gsignal.3:108 build/C/man3/raise.3:74 build/C/man2/sigaltstack.2:223 build/C/man3/sigpause.3:66 build/C/man3/sigqueue.3:127 build/C/man3/sigset.3:186 build/C/man3/sigsetops.3:152 build/C/man3/sigvec.3:246 build/C/man3/sigwait.3:96 build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:91 build/C/man2/eventfd.2:283 build/C/man2/getitimer.2:159 build/C/man3/gsignal.3:114 build/C/man2/kill.2:120 build/C/man2/pause.2:57 build/C/man2/prctl.2:2359 build/C/man3/profil.3:91 build/C/man3/psignal.3:108 build/C/man3/raise.3:76 build/C/man2/restart_syscall.2:100 build/C/man2/rt_sigqueueinfo.2:188 build/C/man2/s390_runtime_instr.2:92 build/C/man2/sgetmask.2:72 build/C/man2/sigaction.2:864 build/C/man2/sigaltstack.2:225 build/C/man3/siginterrupt.3:99 build/C/man2/signal.2:111 build/C/man7/signal.7:928 build/C/man2/signalfd.2:347 build/C/man3/sigpause.3:76 build/C/man2/sigpending.2:63 build/C/man2/sigprocmask.2:128 build/C/man3/sigqueue.3:129 build/C/man2/sigreturn.2:70 build/C/man3/sigset.3:188 build/C/man3/sigsetops.3:154 build/C/man2/sigsuspend.2:85 build/C/man3/sigvec.3:248 build/C/man3/sigwait.3:98 build/C/man2/sigwaitinfo.2:134 build/C/man3/sysv_signal.3:72 build/C/man2/timer_create.2:242 build/C/man2/timer_delete.2:67 build/C/man2/timer_getoverrun.2:97 build/C/man2/timer_settime.2:207 build/C/man2/timerfd_create.2:501 build/C/man2/tkill.2:129 build/C/man2/wait.2:465 build/C/man2/wait4.2:152 build/C/man3/killpg.3:107
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:98
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<bsd_signal>(), recommending the use of B<sigaction>(2)  instead."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:98 build/C/man2/eventfd.2:288 build/C/man2/getitimer.2:169 build/C/man2/kill.2:122 build/C/man3/raise.3:78 build/C/man2/restart_syscall.2:102 build/C/man2/rt_sigqueueinfo.2:190 build/C/man2/s390_runtime_instr.2:96 build/C/man2/sgetmask.2:74 build/C/man2/sigaction.2:867 build/C/man2/sigaltstack.2:231 build/C/man2/signal.2:113 build/C/man7/signal.7:930 build/C/man2/signalfd.2:352 build/C/man3/sigpause.3:81 build/C/man2/sigpending.2:65 build/C/man2/sigprocmask.2:130 build/C/man3/sigqueue.3:131 build/C/man2/sigreturn.2:76 build/C/man3/sigset.3:205 build/C/man3/sigsetops.3:156 build/C/man2/sigsuspend.2:87 build/C/man3/sigvec.3:254 build/C/man3/sigwait.3:100 build/C/man2/sigwaitinfo.2:136 build/C/man3/sysv_signal.3:74 build/C/man2/timer_create.2:244 build/C/man2/timer_getoverrun.2:99 build/C/man2/timerfd_create.2:503 build/C/man2/tkill.2:135 build/C/man2/wait.2:467 build/C/man2/wait4.2:161 build/C/man3/killpg.3:111
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:104
msgid "Use of B<bsd_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:115
msgid ""
"On modern Linux systems, B<bsd_signal>()  and B<signal>(2)  are equivalent.  "
"But on older systems, B<signal>(2)  provided unreliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:122 build/C/man3/sysv_signal.3:99
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is defined only if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:122 build/C/man2/eventfd.2:442 build/C/man2/getitimer.2:259 build/C/man3/gsignal.3:124 build/C/man2/kill.2:170 build/C/man2/pause.2:59 build/C/man2/prctl.2:2377 build/C/man3/profil.3:102 build/C/man3/psignal.3:122 build/C/man3/raise.3:89 build/C/man2/restart_syscall.2:135 build/C/man2/rt_sigqueueinfo.2:200 build/C/man2/s390_runtime_instr.2:115 build/C/man2/sgetmask.2:88 build/C/man2/sigaction.2:1052 build/C/man2/sigaltstack.2:370 build/C/man7/sigevent.7:132 build/C/man3/siginterrupt.3:108 build/C/man2/signal.2:275 build/C/man7/signal.7:986 build/C/man2/signalfd.2:520 build/C/man3/sigpause.3:133 build/C/man2/sigpending.2:118 build/C/man2/sigprocmask.2:221 build/C/man3/sigqueue.3:166 build/C/man2/sigreturn.2:157 build/C/man3/sigset.3:281 build/C/man3/sigsetops.3:203 build/C/man2/sigsuspend.2:136 build/C/man3/sigvec.3:279 build/C/man3/sigwait.3:115 build/C/man2/sigwaitinfo.2:238 build/C/man3/sysv_signal.3:99 build/C/man2/timer_create.2:487 build/C/man2/timer_delete.2:69 build/C/man2/timer_getoverrun.2:141 build/C/man2/timer_settime.2:212 build/C/man2/timerfd_create.2:716 build/C/man2/tkill.2:148 build/C/man2/wait.2:705 build/C/man2/wait4.2:179 build/C/man3/killpg.3:130 build/C/man7/signal-safety.7:351
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:127
msgid "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"
msgstr ""

#. type: SH
#: build/C/man3/bsd_signal.3:127 build/C/man2/eventfd.2:453 build/C/man2/getitimer.2:266 build/C/man3/gsignal.3:128 build/C/man2/kill.2:182 build/C/man2/pause.2:64 build/C/man2/prctl.2:2380 build/C/man3/profil.3:108 build/C/man3/psignal.3:127 build/C/man3/raise.3:96 build/C/man2/restart_syscall.2:144 build/C/man2/rt_sigqueueinfo.2:209 build/C/man2/s390_runtime_instr.2:118 build/C/man2/sgetmask.2:91 build/C/man2/sigaction.2:1075 build/C/man2/sigaltstack.2:377 build/C/man7/sigevent.7:142 build/C/man3/siginterrupt.3:110 build/C/man2/signal.2:294 build/C/man7/signal.7:1025 build/C/man2/signalfd.2:533 build/C/man3/sigpause.3:141 build/C/man2/sigpending.2:126 build/C/man2/sigprocmask.2:232 build/C/man3/sigqueue.3:174 build/C/man2/sigreturn.2:165 build/C/man3/sigset.3:291 build/C/man3/sigsetops.3:208 build/C/man2/sigsuspend.2:146 build/C/man3/sigvec.3:289 build/C/man3/sigwait.3:123 build/C/man2/sigwaitinfo.2:250 build/C/man3/sysv_signal.3:104 build/C/man2/timer_create.2:502 build/C/man2/timer_delete.2:75 build/C/man2/timer_getoverrun.2:151 build/C/man2/timer_settime.2:216 build/C/man2/timerfd_create.2:728 build/C/man2/tkill.2:153 build/C/man2/wait.2:718 build/C/man2/wait4.2:186 build/C/man3/killpg.3:136 build/C/man7/signal-safety.7:355
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/bsd_signal.3:135 build/C/man2/eventfd.2:461 build/C/man2/getitimer.2:274 build/C/man3/gsignal.3:136 build/C/man2/kill.2:190 build/C/man2/pause.2:72 build/C/man2/prctl.2:2388 build/C/man3/profil.3:116 build/C/man3/psignal.3:135 build/C/man3/raise.3:104 build/C/man2/restart_syscall.2:152 build/C/man2/rt_sigqueueinfo.2:217 build/C/man2/s390_runtime_instr.2:126 build/C/man2/sgetmask.2:99 build/C/man2/sigaction.2:1083 build/C/man2/sigaltstack.2:385 build/C/man7/sigevent.7:150 build/C/man3/siginterrupt.3:118 build/C/man2/signal.2:302 build/C/man7/signal.7:1033 build/C/man2/signalfd.2:541 build/C/man3/sigpause.3:149 build/C/man2/sigpending.2:134 build/C/man2/sigprocmask.2:240 build/C/man3/sigqueue.3:182 build/C/man2/sigreturn.2:173 build/C/man3/sigset.3:299 build/C/man3/sigsetops.3:216 build/C/man2/sigsuspend.2:154 build/C/man3/sigvec.3:297 build/C/man3/sigwait.3:131 build/C/man2/sigwaitinfo.2:258 build/C/man3/sysv_signal.3:112 build/C/man2/timer_create.2:510 build/C/man2/timer_delete.2:83 build/C/man2/timer_getoverrun.2:159 build/C/man2/timer_settime.2:224 build/C/man2/timerfd_create.2:736 build/C/man2/tkill.2:161 build/C/man2/wait.2:726 build/C/man2/wait4.2:194 build/C/man3/killpg.3:144 build/C/man7/signal-safety.7:363
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:22 build/C/man3/psignal.3:30 build/C/man7/sigevent.7:26 build/C/man2/signalfd.2:20 build/C/man2/timer_create.2:26 build/C/man2/wait.2:49
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man2/eventfd.2:22 build/C/man2/getitimer.2:13 build/C/man2/kill.2:44 build/C/man2/pause.2:30 build/C/man2/prctl.2:59 build/C/man3/profil.3:28 build/C/man2/restart_syscall.2:33 build/C/man2/rt_sigqueueinfo.2:25 build/C/man2/sgetmask.2:25 build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:26 build/C/man2/signal.2:36 build/C/man7/signal.7:45 build/C/man2/signalfd.2:20 build/C/man3/sigpause.3:25 build/C/man2/sigpending.2:29 build/C/man2/sigprocmask.2:29 build/C/man3/sigqueue.3:28 build/C/man2/sigreturn.2:30 build/C/man3/sigset.3:25 build/C/man3/sigsetops.3:31 build/C/man2/sigsuspend.2:29 build/C/man3/sigvec.3:25 build/C/man3/sigwait.3:26 build/C/man2/sigwaitinfo.2:25 build/C/man2/timer_create.2:26 build/C/man2/timer_delete.2:26 build/C/man2/timer_getoverrun.2:26 build/C/man2/timer_settime.2:26 build/C/man2/timerfd_create.2:19 build/C/man2/tkill.2:29 build/C/man2/wait.2:49 build/C/man2/wait4.2:33 build/C/man3/killpg.3:42 build/C/man7/signal-safety.7:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:44
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:49
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:49
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:59 build/C/man2/signalfd.2:97 build/C/man2/timerfd_create.2:140
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:59
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:69 build/C/man2/signalfd.2:87 build/C/man2/timerfd_create.2:130
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:69
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:73
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:77 build/C/man2/signalfd.2:101
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:80
msgid ""
"The following operations can be performed on the file descriptor returned by "
"B<eventfd>():"
msgstr ""

#. type: tbl table
#: build/C/man2/eventfd.2:80 build/C/man2/signalfd.2:104 build/C/man2/timerfd_create.2:273 build/C/man7/signal-safety.7:184
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:90
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  fails "
"with the error B<EINVAL> if the size of the supplied buffer is less than 8 "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:95
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:102
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""

#. type: IP
#: build/C/man2/eventfd.2:103 build/C/man2/eventfd.2:110 build/C/man2/eventfd.2:117 build/C/man2/eventfd.2:162 build/C/man2/eventfd.2:172 build/C/man2/eventfd.2:182 build/C/man2/prctl.2:278 build/C/man2/prctl.2:280 build/C/man2/prctl.2:283 build/C/man2/prctl.2:288 build/C/man2/prctl.2:2051 build/C/man2/prctl.2:2056 build/C/man2/prctl.2:2061 build/C/man2/prctl.2:2071 build/C/man3/psignal.3:114 build/C/man3/psignal.3:118 build/C/man2/rt_sigqueueinfo.2:88 build/C/man2/rt_sigqueueinfo.2:97 build/C/man2/sigaction.2:131 build/C/man2/sigaction.2:134 build/C/man2/sigaction.2:137 build/C/man2/sigaction.2:366 build/C/man2/sigaction.2:381 build/C/man2/sigaction.2:397 build/C/man2/sigaction.2:412 build/C/man2/sigaction.2:459 build/C/man2/sigaction.2:523 build/C/man2/sigaction.2:541 build/C/man2/sigaction.2:590 build/C/man2/sigaction.2:593 build/C/man2/sigaction.2:598 build/C/man2/signal.2:69 build/C/man2/signal.2:74 build/C/man2/signal.2:81 build/C/man2/signal.2:237 build/C/man2/signal.2:241 build/C/man7/signal.7:153 build/C/man7/signal.7:161 build/C/man7/signal.7:529 build/C/man7/signal.7:537 build/C/man7/signal.7:670 build/C/man7/signal.7:672 build/C/man7/signal.7:692 build/C/man7/signal.7:708 build/C/man7/signal.7:712 build/C/man7/signal.7:719 build/C/man7/signal.7:737 build/C/man7/signal.7:747 build/C/man7/signal.7:754 build/C/man7/signal.7:761 build/C/man7/signal.7:763 build/C/man7/signal.7:767 build/C/man7/signal.7:770 build/C/man7/signal.7:779 build/C/man7/signal.7:798 build/C/man7/signal.7:812 build/C/man7/signal.7:823 build/C/man7/signal.7:830 build/C/man7/signal.7:839 build/C/man7/signal.7:847 build/C/man7/signal.7:853 build/C/man7/signal.7:871 build/C/man7/signal.7:885 build/C/man7/signal.7:899 build/C/man7/signal.7:902 build/C/man7/signal.7:905 build/C/man7/signal.7:908 build/C/man7/signal.7:915 build/C/man7/signal.7:921 build/C/man7/signal.7:925 build/C/man3/sigpause.3:116 build/C/man3/sigpause.3:120 build/C/man3/sigwait.3:68 build/C/man3/sigwait.3:73 build/C/man2/timer_create.2:265 build/C/man2/timer_create.2:268 build/C/man2/timer_create.2:271 build/C/man2/timer_create.2:275 build/C/man2/timer_create.2:278 build/C/man2/timer_create.2:301 build/C/man2/timer_create.2:315 build/C/man2/timer_create.2:322 build/C/man7/signal-safety.7:290 build/C/man7/signal-safety.7:297 build/C/man7/signal-safety.7:305 build/C/man7/signal-safety.7:318 build/C/man7/signal-safety.7:334 build/C/man7/signal-safety.7:344
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:110
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:117
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:127
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""

#. type: tbl table
#: build/C/man2/eventfd.2:128 build/C/man7/signal-safety.7:286
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:145
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:152
msgid ""
"A B<write>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes, or if an attempt is made to write the value "
"0xffffffffffffffff."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:152 build/C/man2/signalfd.2:142 build/C/man2/timerfd_create.2:346
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:161
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:172
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:182
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:202
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:209
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""

#. type: tbl table
#: build/C/man2/eventfd.2:209 build/C/man2/signalfd.2:162 build/C/man2/timerfd_create.2:382 build/C/man7/signal-safety.7:112
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:214
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:226
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:233
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:234 build/C/man2/getitimer.2:146 build/C/man2/kill.2:105 build/C/man2/prctl.2:2002 build/C/man2/prctl.2:2008 build/C/man2/prctl.2:2020 build/C/man2/prctl.2:2025 build/C/man2/prctl.2:2034 build/C/man2/prctl.2:2044 build/C/man2/prctl.2:2084 build/C/man2/prctl.2:2094 build/C/man2/prctl.2:2102 build/C/man2/prctl.2:2113 build/C/man2/prctl.2:2122 build/C/man2/prctl.2:2136 build/C/man2/prctl.2:2148 build/C/man2/prctl.2:2159 build/C/man2/prctl.2:2171 build/C/man2/prctl.2:2196 build/C/man2/prctl.2:2214 build/C/man2/prctl.2:2224 build/C/man2/prctl.2:2230 build/C/man2/prctl.2:2239 build/C/man2/rt_sigqueueinfo.2:150 build/C/man2/s390_runtime_instr.2:70 build/C/man2/s390_runtime_instr.2:75 build/C/man2/sigaction.2:857 build/C/man2/sigaltstack.2:198 build/C/man3/siginterrupt.3:84 build/C/man2/signal.2:107 build/C/man2/signalfd.2:311 build/C/man2/signalfd.2:319 build/C/man2/sigprocmask.2:122 build/C/man3/sigqueue.3:98 build/C/man3/sigsetops.3:128 build/C/man3/sigwait.3:81 build/C/man2/sigwaitinfo.2:130 build/C/man2/timer_create.2:214 build/C/man2/timer_delete.2:61 build/C/man2/timer_getoverrun.2:91 build/C/man2/timer_settime.2:191 build/C/man2/timer_settime.2:199 build/C/man2/timerfd_create.2:425 build/C/man2/timerfd_create.2:430 build/C/man2/timerfd_create.2:476 build/C/man2/timerfd_create.2:486 build/C/man2/timerfd_create.2:492 build/C/man2/tkill.2:109 build/C/man2/wait.2:460 build/C/man3/killpg.3:89
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:238
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:238 build/C/man2/signalfd.2:326 build/C/man2/timerfd_create.2:437
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:329 build/C/man2/timerfd_create.2:440
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:329 build/C/man2/timerfd_create.2:440
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:245 build/C/man2/signalfd.2:333 build/C/man2/timerfd_create.2:444
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:245 build/C/man2/prctl.2:2248 build/C/man2/signalfd.2:333 build/C/man2/timerfd_create.2:444
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:253 build/C/man2/signalfd.2:336 build/C/man2/timerfd_create.2:447
msgid "Could not mount (internal) anonymous inode device."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:253 build/C/man2/s390_runtime_instr.2:84 build/C/man2/sigaltstack.2:202 build/C/man2/signalfd.2:336 build/C/man2/timer_create.2:222 build/C/man2/timerfd_create.2:447
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:257
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""

#. type: SH
#: build/C/man2/eventfd.2:257 build/C/man2/prctl.2:2354 build/C/man3/psignal.3:90 build/C/man2/restart_syscall.2:96 build/C/man2/rt_sigqueueinfo.2:181 build/C/man2/s390_runtime_instr.2:90 build/C/man2/sgetmask.2:65 build/C/man2/signalfd.2:339 build/C/man3/sigqueue.3:112 build/C/man3/sigvec.3:225 build/C/man2/timer_create.2:240 build/C/man2/timer_delete.2:65 build/C/man2/timer_getoverrun.2:95 build/C/man2/timer_settime.2:205 build/C/man2/timerfd_create.2:498 build/C/man2/tkill.2:120
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/eventfd.2:270
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""

#. type: tbl table
#: build/C/man2/eventfd.2:280
#, no-wrap
msgid "B<eventfd>()"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:288
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:296
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""

#.  or eventually syslets/threadlets
#. type: Plain text
#: build/C/man2/eventfd.2:302
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is "
"complete."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:319
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:328
msgid ""
"The current value of an eventfd counter can be viewed via the entry for the "
"corresponding file descriptor in the process's I</proc/[pid]/fdinfo> "
"directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:328 build/C/man2/sigaction.2:962 build/C/man2/signalfd.2:413 build/C/man2/sigpending.2:85 build/C/man2/sigprocmask.2:167 build/C/man3/sigqueue.3:139 build/C/man2/sigreturn.2:143 build/C/man2/sigsuspend.2:109 build/C/man2/sigwaitinfo.2:196 build/C/man2/timer_create.2:297 build/C/man2/wait.2:582 build/C/man2/wait4.2:173 build/C/man3/killpg.3:125
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:342
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:342
#, no-wrap
msgid "Additional glibc features"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:346
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:350
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:353
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:360
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""

#. type: SH
#: build/C/man2/eventfd.2:360 build/C/man2/sigaction.2:1049 build/C/man2/sigaltstack.2:334 build/C/man2/signalfd.2:447 build/C/man3/sigwait.3:112 build/C/man2/timer_create.2:338 build/C/man2/timer_getoverrun.2:138 build/C/man2/timer_settime.2:209 build/C/man2/timerfd_create.2:555 build/C/man2/wait.2:621
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:368
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:370
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:382
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""

#. type: SS
#: build/C/man2/eventfd.2:384 build/C/man2/signalfd.2:470 build/C/man2/timer_create.2:369 build/C/man2/timerfd_create.2:583 build/C/man2/wait.2:656
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:393
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>           /* Definition of PRIu64 & PRIx64 "
"*/\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:396 build/C/man2/signalfd.2:481
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:403
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:408
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:412
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:424
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (int j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:426
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:429
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:436
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %\"PRIu64\" (%#\"PRIx64\") from efd\\en\", u, "
"u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:441
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:453
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getitimer.2:13
#, no-wrap
msgid "GETITIMER"
msgstr ""

#. type: TH
#: build/C/man2/getitimer.2:13 build/C/man3/gsignal.3:27
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:16
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:19
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:31
msgid ""
"These system calls provide access to interval timers, that is, timers that "
"initially expire at some point in the future, and (optionally) at regular "
"intervals after that.  When a timer expires, a signal is generated for the "
"calling process, and the timer is reset to the specified interval (if the "
"interval is nonzero)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:37
msgid ""
"Three types of timers\\(emspecified via the I<which> argument\\(emare "
"provided, each of which counts against a different clock and generates a "
"different signal on timer expiration:"
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:37
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:43
msgid ""
"This timer counts down in real (i.e., wall clock) time.  At each expiration, "
"a B<SIGALRM> signal is generated."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:43
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:50
msgid ""
"This timer counts down against the user-mode CPU time consumed by the "
"process.  (The measurement includes CPU time consumed by all threads in the "
"process.)  At each expiration, a B<SIGVTALRM> signal is generated."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:50
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:58
msgid ""
"This timer counts down against the total (i.e., both user and system)  CPU "
"time consumed by the process.  (The measurement includes CPU time consumed "
"by all threads in the process.)  At each expiration, a B<SIGPROF> signal is "
"generated."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:63
msgid ""
"In conjunction with B<ITIMER_VIRTUAL>, this timer can be used to profile "
"user and system CPU time consumed by the process."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:65
msgid "A process has only one of each of the three types of timers."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:67
msgid "Timer values are defined by the following structures:"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:74
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: SS
#: build/C/man2/getitimer.2:82
#, no-wrap
msgid "getitimer()"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:89
msgid ""
"The function B<getitimer>()  places the current value of the timer specified "
"by I<which> in the buffer pointed to by I<curr_value>."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:100
msgid ""
"The I<it_value> substructure is populated with the amount of time remaining "
"until the next expiration of the specified timer.  This value changes as the "
"timer counts down, and will be reset to I<it_interval> when the timer "
"expires.  If both fields of I<it_value> are zero, then this timer is "
"currently disarmed (inactive)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:107
msgid ""
"The I<it_interval> substructure is populated with the timer interval.  If "
"both fields of I<it_interval> are zero, then this is a single-shot timer "
"(i.e., it expires just once)."
msgstr ""

#. type: SS
#: build/C/man2/getitimer.2:107
#, no-wrap
msgid "setitimer()"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:120
msgid ""
"The function B<setitimer>()  arms or disarms the timer specified by "
"I<which>, by setting the timer to the value specified by I<new_value>.  If "
"I<old_value> is non-NULL, the buffer it points to is used to return the "
"previous value of the timer (i.e., the same information that is returned by "
"B<getitimer>())."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:128
msgid ""
"If either field in I<new_value.it_value> is nonzero, then the timer is armed "
"to initially expire at the specified time.  If both fields in "
"I<new_value.it_value> are zero, then the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:133
msgid ""
"The I<new_value.it_interval> field specifies the new interval for the timer; "
"if both of its subfields are zero, the timer is single-shot."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:138 build/C/man2/tkill.2:96 build/C/man3/killpg.3:88
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getitimer.2:139 build/C/man2/prctl.2:1985 build/C/man2/prctl.2:1989 build/C/man2/sigaction.2:853 build/C/man2/sigaltstack.2:194 build/C/man2/sigpending.2:59 build/C/man2/sigprocmask.2:115 build/C/man2/sigsuspend.2:77 build/C/man2/timer_settime.2:184 build/C/man2/timerfd_create.2:469
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:146 build/C/man2/timerfd_create.2:476
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:159
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>; "
"or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:169
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:178
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  If the timer "
"expires while the process is active (always true for B<ITIMER_VIRTUAL>), the "
"signal will be delivered immediately when generated."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:184
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:194
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:196
msgid "The standards are silent on the meaning of the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:198
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:201
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:203
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:209
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr ""

#. type: SH
#: build/C/man2/getitimer.2:209 build/C/man2/kill.2:160 build/C/man3/profil.3:93 build/C/man3/psignal.3:110 build/C/man2/sigaction.2:1031 build/C/man2/sigaltstack.2:296 build/C/man7/signal.7:956 build/C/man2/signalfd.2:439 build/C/man2/sigpending.2:112 build/C/man3/sigset.3:247 build/C/man2/timer_getoverrun.2:116 build/C/man2/timerfd_create.2:549 build/C/man2/wait.2:606
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:218
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an "
"event will be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:233
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If "
"a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux "
"2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: build/C/man2/getitimer.2:240
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy "
"under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: build/C/man2/getitimer.2:259
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""

#. type: Plain text
#: build/C/man2/getitimer.2:266
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/gsignal.3:27
#, no-wrap
msgid "GSIGNAL"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:30
msgid "gsignal, ssignal - software signal facility"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:33 build/C/man3/psignal.3:36 build/C/man3/raise.3:35 build/C/man2/sigaction.2:54 build/C/man3/siginterrupt.3:37 build/C/man3/sigpause.3:31 build/C/man3/sigwait.3:32 build/C/man2/sigwaitinfo.2:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:35
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:37
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:39
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:52
#, no-wrap
msgid ""
"B<gsignal>(),\n"
"B<ssignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:60
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:98
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1\\(en15 or 1\\(en17)."
msgstr ""

#. type: tbl table
#: build/C/man3/gsignal.3:108
#, no-wrap
msgid "B<gsignal>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gsignal.3:111
#, no-wrap
msgid "B<ssignal>()"
msgstr ""

#. type: tbl table
#: build/C/man3/gsignal.3:111
#, no-wrap
msgid "MT-Safe sigintr"
msgstr ""

#.  Linux libc and
#. type: Plain text
#: build/C/man3/gsignal.3:124
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64.  "
"They are called obsolete under most of these systems, and are broken under "
"glibc.  Some systems also have B<gsignal_r>()  and B<ssignal_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/gsignal.3:128
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr ""

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "KILL"
msgstr ""

#. type: TH
#: build/C/man2/kill.2:44 build/C/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:47
msgid "kill - send signal to a process"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:53
#, no-wrap
msgid "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:63
msgid "B<kill>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:69
msgid ""
"The B<kill>()  system call can be used to send any signal to any process "
"group or process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:72
msgid ""
"If I<pid> is positive, then signal I<sig> is sent to the process with the ID "
"specified by I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:75
msgid ""
"If I<pid> equals 0, then I<sig> is sent to every process in the process "
"group of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:79
msgid ""
"If I<pid> equals -1, then I<sig> is sent to every process for which the "
"calling process has permission to send signals, except for process 1 "
"(I<init>), but see below."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:82
msgid ""
"If I<pid> is less than -1, then I<sig> is sent to every process in the "
"process group whose ID is I<-pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:87
msgid ""
"If I<sig> is 0, then no signal is sent, but existence and permission checks "
"are still performed; this can be used to check for the existence of a "
"process ID or process group ID that the caller is permitted to signal."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:99
msgid ""
"For a process to have permission to send a signal, it must either be "
"privileged (under Linux: have the B<CAP_KILL> capability in the user "
"namespace of the target process), or the real or effective user ID of the "
"sending process must equal the real or saved set-user-ID of the target "
"process.  In the case of B<SIGCONT>, it suffices when the sending and "
"receiving processes belong to the same session.  (Historically, the rules "
"were different; see NOTES.)"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:104
msgid ""
"On success (at least one signal was sent), zero is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:108
msgid "An invalid signal was specified."
msgstr ""

#. type: TP
#: build/C/man2/kill.2:108 build/C/man2/prctl.2:2280 build/C/man2/prctl.2:2292 build/C/man2/prctl.2:2300 build/C/man2/prctl.2:2310 build/C/man2/prctl.2:2318 build/C/man2/prctl.2:2326 build/C/man2/rt_sigqueueinfo.2:157 build/C/man2/rt_sigqueueinfo.2:162 build/C/man2/sigaltstack.2:208 build/C/man3/sigqueue.3:102 build/C/man2/timer_create.2:230 build/C/man2/timerfd_create.2:450 build/C/man2/tkill.2:112 build/C/man3/killpg.3:93
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:112
msgid ""
"The calling process does not have permission to send the signal to any of "
"the target processes."
msgstr ""

#. type: TP
#: build/C/man2/kill.2:112 build/C/man2/rt_sigqueueinfo.2:168 build/C/man3/sigqueue.3:108 build/C/man2/tkill.2:117 build/C/man3/killpg.3:99 build/C/man3/killpg.3:103
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:120
msgid ""
"The target process or process group does not exist.  Note that an existing "
"process might be a zombie, a process that has terminated execution, but has "
"not yet been B<wait>(2)ed for."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:122 build/C/man2/pause.2:59
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:130
msgid ""
"The only signals that can be sent to process ID 1, the I<init> process, are "
"those for which I<init> has explicitly installed signal handlers.  This is "
"done to assure the system is not brought down accidentally."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:136
msgid ""
"POSIX.1 requires that I<kill(-1,sig)> send I<sig> to all processes that the "
"calling process may send signals to, except possibly for some "
"implementation-defined system processes.  Linux allows a process to signal "
"itself, but on Linux the call I<kill(-1,sig)> does not signal the calling "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:146
msgid ""
"POSIX.1 requires that if a process sends a signal to itself, and the sending "
"thread does not have the signal blocked, and no other thread has it "
"unblocked or is waiting for it in B<sigwait>(3), at least one unblocked "
"signal must be delivered to the sending thread before the B<kill>()  "
"returns."
msgstr ""

#. type: SS
#: build/C/man2/kill.2:146 build/C/man3/sigpause.3:98 build/C/man2/wait.2:527
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  In the 0.* kernels things chopped and changed quite
#.  a bit - MTK, 24 Jul 02
#. type: Plain text
#: build/C/man2/kill.2:160
msgid ""
"Across different kernel versions, Linux has enforced different rules for the "
"permissions required for an unprivileged process to send a signal to another "
"process.  In kernels 1.0 to 1.2.2, a signal could be sent if the effective "
"user ID of the sender matched effective user ID of the target, or the real "
"user ID of the sender matched the real user ID of the target.  From kernel "
"1.2.3 until 1.3.77, a signal could be sent if the effective user ID of the "
"sender matched either the real or effective user ID of the target.  The "
"current rules, which conform to POSIX.1, were adopted in kernel 1.3.78."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:170
msgid ""
"In 2.6 kernels up to and including 2.6.7, there was a bug that meant that "
"when sending signals to a process group, B<kill>()  failed with the error "
"B<EPERM> if the caller did not have permission to send the signal to I<any> "
"(rather than I<all>) of the members of the process group.  Notwithstanding "
"this error return, the signal was still delivered to all of the processes "
"for which the caller had permission to signal."
msgstr ""

#. type: Plain text
#: build/C/man2/kill.2:182
msgid ""
"B<kill>(1), B<_exit>(2), B<pidfd_send_signal>(2), B<signal>(2), B<tkill>(2), "
"B<exit>(3), B<killpg>(3), B<sigqueue>(3), B<capabilities>(7), "
"B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr ""

#. type: TH
#: build/C/man2/pause.2:30 build/C/man3/raise.3:29 build/C/man2/timer_delete.2:26
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:33
msgid "pause - wait for signal"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: build/C/man2/pause.2:53
msgid ""
"B<pause>()  returns only when a signal was caught and the signal-catching "
"function returned.  In this case, B<pause>()  returns -1, and I<errno> is "
"set to B<EINTR>."
msgstr ""

#. type: TP
#: build/C/man2/pause.2:54 build/C/man2/sigsuspend.2:81 build/C/man2/sigwaitinfo.2:124 build/C/man2/wait.2:453
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr ""

#. type: Plain text
#: build/C/man2/pause.2:64
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: build/C/man2/prctl.2:59
#, no-wrap
msgid "PRCTL"
msgstr ""

#. type: TH
#: build/C/man2/prctl.2:59 build/C/man2/sgetmask.2:25 build/C/man3/sigset.3:25 build/C/man3/sigvec.3:25 build/C/man2/timerfd_create.2:19
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:62
msgid "prctl - operations on a process or thread"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:65
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:68
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long "
">I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:73
msgid ""
"B<prctl>()  manipulates various aspects of the behavior of the calling "
"thread or process."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:78
msgid ""
"Note that careless use of some B<prctl>()  operations can confuse the "
"user-space run-time environment, so these operations should be used with "
"care."
msgstr ""

#
#.  prctl PR_CAP_AMBIENT
#. type: Plain text
#: build/C/man2/prctl.2:86
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:86
#, no-wrap
msgid "B<PR_CAP_AMBIENT> (since Linux 4.3)"
msgstr ""

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: build/C/man2/prctl.2:93
msgid ""
"Reads or changes the ambient capability set of the calling thread, according "
"to the value of I<arg2>, which must be one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:95
#, no-wrap
msgid "B<PR_CAP_AMBIENT_RAISE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:105
msgid ""
"The capability specified in I<arg3> is added to the ambient set.  The "
"specified capability must already be present in both the permitted and the "
"inheritable sets of the process.  This operation is not permitted if the "
"B<SECBIT_NO_CAP_AMBIENT_RAISE> securebit is set."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:105
#, no-wrap
msgid "B<PR_CAP_AMBIENT_LOWER>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:110
msgid "The capability specified in I<arg3> is removed from the ambient set."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:110
#, no-wrap
msgid "B<PR_CAP_AMBIENT_IS_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:117
msgid ""
"The B<prctl>()  call returns 1 if the capability in I<arg3> is in the "
"ambient set and 0 if it is not."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:117
#, no-wrap
msgid "B<PR_CAP_AMBIENT_CLEAR_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:123
msgid ""
"All capabilities will be removed from the ambient set.  This operation "
"requires setting I<arg3> to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:130
msgid "In all of the above operations, I<arg4> and I<arg5> must be specified as 0."
msgstr ""

#.  prctl PR_CAPBSET_READ
#. type: Plain text
#: build/C/man2/prctl.2:140
msgid ""
"Higher-level interfaces layered on top of the above operations are provided "
"in the B<libcap>(3)  library in the form of B<cap_get_ambient>(3), "
"B<cap_set_ambient>(3), and B<cap_reset_ambient>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:140
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:152
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:157
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""

#.  prctl PR_CAPBSET_DROP
#. type: Plain text
#: build/C/man2/prctl.2:163
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_get_bound>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:163
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:172
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability within its user "
"namespace, then drop the capability specified by I<arg2> from the calling "
"thread's capability bounding set.  Any children of the calling thread will "
"inherit the newly reduced bounding set."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:184
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""

#.  prctl PR_SET_CHILD_SUBREAPER
#. type: Plain text
#: build/C/man2/prctl.2:190
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_drop_bound>(3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:190
#, no-wrap
msgid "B<PR_SET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr ""

#.  commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
#. type: Plain text
#: build/C/man2/prctl.2:200
msgid ""
"If I<arg2> is nonzero, set the \"child subreaper\" attribute of the calling "
"process; if I<arg2> is zero, unset the attribute."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:217
msgid ""
"A subreaper fulfills the role of B<init>(1)  for its descendant processes.  "
"When a process becomes orphaned (i.e., its immediate parent terminates), "
"then that process will be reparented to the nearest still living ancestor "
"subreaper.  Subsequently, calls to B<getppid>(2)  in the orphaned process "
"will now return the PID of the subreaper process, and when the orphan "
"terminates, it is the subreaper process that will receive a B<SIGCHLD> "
"signal and will be able to B<wait>(2)  on the process to discover its "
"termination status."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:225
msgid ""
"The setting of the \"child subreaper\" attribute is not inherited by "
"children created by B<fork>(2)  and B<clone>(2).  The setting is preserved "
"across B<execve>(2)."
msgstr ""

#.  prctl PR_GET_CHILD_SUBREAPER
#. type: Plain text
#: build/C/man2/prctl.2:237
msgid ""
"Establishing a subreaper process is useful in session management frameworks "
"where a hierarchical group of processes is managed by a subreaper process "
"that needs to be informed when one of the processes\\(emfor example, a "
"double-forked daemon\\(emterminates (perhaps so that it can restart that "
"process).  Some B<init>(1)  frameworks (e.g., B<systemd>(1))  employ a "
"subreaper process for similar reasons."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:237
#, no-wrap
msgid "B<PR_GET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr ""

#.  prctl PR_SET_DUMPABLE
#. type: Plain text
#: build/C/man2/prctl.2:243
msgid ""
"Return the \"child subreaper\" setting of the caller, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:243
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:248
msgid ""
"Set the state of the \"dumpable\" attribute, which determines whether core "
"dumps are produced for the calling process upon delivery of a signal whose "
"default behavior is to produce a core dump."
msgstr ""

#.  commit abf75a5033d4da7b8a7e92321d74021d1fcfb502
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: build/C/man2/prctl.2:270
msgid ""
"In kernels up to and including 2.6.12, I<arg2> must be either 0 "
"(B<SUID_DUMP_DISABLE>, process is not dumpable) or 1 (B<SUID_DUMP_USER>, "
"process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 was "
"also permitted, which caused any binary which normally would not be dumped "
"to be dumped readable by root only; for security reasons, this feature has "
"been removed.  (See also the description of I</proc/sys/fs/\\:suid_dumpable> "
"in B<proc>(5).)"
msgstr ""

#.  See kernel/cred.c::commit_creds() (Linux 3.18 sources)
#. type: Plain text
#: build/C/man2/prctl.2:277
msgid ""
"Normally, the \"dumpable\" attribute is set to 1.  However, it is reset to "
"the current value contained in the file I</proc/sys/fs/\\:suid_dumpable> "
"(which by default has the value 0), in the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:280
msgid "The process's effective user or group ID is changed."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:283
msgid ""
"The process's filesystem user or group ID is changed (see "
"B<credentials>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:288
msgid ""
"The process executes (B<execve>(2))  a set-user-ID or set-group-ID program, "
"resulting in a change of either the effective user ID or the effective group "
"ID."
msgstr ""

#.  See kernel/cred.c::commit_creds()
#.  Also certain namespace operations;
#. type: Plain text
#: build/C/man2/prctl.2:297
msgid ""
"The process executes (B<execve>(2))  a program that has file capabilities "
"(see B<capabilities>(7)), but only if the permitted capabilities gained "
"exceed those already permitted for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:305
msgid ""
"Processes that are not dumpable can not be attached via B<ptrace>(2)  "
"B<PTRACE_ATTACH>; see B<ptrace>(2)  for further details."
msgstr ""

#.  prctl PR_GET_DUMPABLE
#. type: Plain text
#: build/C/man2/prctl.2:312
msgid ""
"If a process is not dumpable, the ownership of files in the process's "
"I</proc/[pid]> directory is affected as described in B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:312
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#.  prctl PR_SET_ENDIAN
#. type: Plain text
#: build/C/man2/prctl.2:320
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable attribute."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:320
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#.  Respectively 0, 1, 2
#.  prctl PR_GET_ENDIAN
#. type: Plain text
#: build/C/man2/prctl.2:331
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:331
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#.  prctl PR_SET_FP_MODE
#. type: Plain text
#: build/C/man2/prctl.2:337
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:337
#, no-wrap
msgid "B<PR_SET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr ""

#.  commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
#. type: Plain text
#: build/C/man2/prctl.2:349
msgid ""
"On the MIPS architecture, user-space code can be built using an ABI which "
"permits linking with code that has more restrictive floating-point (FP) "
"requirements.  For example, user-space code may be built to target the O32 "
"FPXX ABI and linked with code built for either one of the more restrictive "
"FP32 or FP64 ABIs.  When more restrictive code is linked in, the overall "
"requirement for the process is to use the more restrictive floating-point "
"mode."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:357
msgid ""
"Because the kernel has no means of knowing in advance which mode the process "
"should be executed in, and because these restrictions can change over the "
"lifetime of the process, the B<PR_SET_FP_MODE> operation is provided to "
"allow control of the floating-point mode from user space."
msgstr ""

#.  https://dmz-portal.mips.com/wiki/MIPS_O32_ABI_-_FR0_and_FR1_Interlinking
#. type: Plain text
#: build/C/man2/prctl.2:362
msgid ""
"The I<(unsigned int) arg2> argument is a bit mask describing the "
"floating-point mode used:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:363
#, no-wrap
msgid "B<PR_FP_MODE_FR>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:374
msgid ""
"When this bit is I<unset> (so called B<FR=0> or B<FR0> mode), the 32 "
"floating-point registers are 32 bits wide, and 64-bit registers are "
"represented as a pair of registers (even- and odd- numbered, with the "
"even-numbered register containing the lower 32 bits, and the odd-numbered "
"register containing the higher 32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:384
msgid ""
"When this bit is I<set> (on supported hardware), the 32 floating-point "
"registers are 64 bits wide (so called B<FR=1> or B<FR1> mode).  Note that "
"modern MIPS implementations (MIPS R6 and newer) support B<FR=1> mode only."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:399
msgid ""
"Applications that use the O32 FP32 ABI can operate only when this bit is "
"I<unset> (B<FR=0>; or they can be used with FRE enabled, see below).  "
"Applications that use the O32 FP64 ABI (and the O32 FP64A ABI, which exists "
"to provide the ability to operate with existing FP32 code; see below)  can "
"operate only when this bit is I<set> (B<FR=1>).  Applications that use the "
"O32 FPXX ABI can operate with either B<FR=0> or B<FR=1>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:399
#, no-wrap
msgid "B<PR_FP_MODE_FRE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:420
msgid ""
"Enable emulation of 32-bit floating-point mode.  When this mode is enabled, "
"it emulates 32-bit floating-point operations by raising a "
"reserved-instruction exception on every instruction that uses 32-bit formats "
"and the kernel then handles the instruction in software.  (The problem lies "
"in the discrepancy of handling odd-numbered registers which are the high 32 "
"bits of 64-bit registers with even numbers in B<FR=0> mode and the lower "
"32-bit parts of odd-numbered 64-bit registers in B<FR=1> mode.)  Enabling "
"this bit is necessary when code with the O32 FP32 ABI should operate with "
"code with compatible the O32 FPXX or O32 FP64A ABIs (which require B<FR=1> "
"FPU mode) or when it is executed on newer hardware (MIPS R6 onwards)  which "
"lacks B<FR=0> mode support when a binary with the FP32 ABI is used."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:423
msgid ""
"Note that this mode makes sense only when the FPU is in 64-bit mode "
"(B<FR=1>)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:426
msgid ""
"Note that the use of emulation inherently has a significant performance hit "
"and should be avoided if possible."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:432
msgid ""
"In the N32/N64 ABI, 64-bit floating-point mode is always used, so FPU "
"emulation is not required and the FPU always operates in B<FR=1> mode."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:435
msgid "This option is mainly intended for use by the dynamic linker (B<ld.so>(8))."
msgstr ""

#.  prctl PR_GET_FP_MODE
#. type: Plain text
#: build/C/man2/prctl.2:443
msgid "The arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:443
#, no-wrap
msgid "B<PR_GET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:449
msgid ""
"Return (as the function result)  the current floating-point mode (see the "
"description of B<PR_SET_FP_MODE> for details)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:452
msgid ""
"On success, the call returns a bit mask which represents the current "
"floating-point mode."
msgstr ""

#.  prctl PR_SET_FPEMU
#. type: Plain text
#: build/C/man2/prctl.2:461
msgid "The arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:461
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#.  prctl PR_GET_FPEMU
#. type: Plain text
#: build/C/man2/prctl.2:472
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate floating-point operation accesses, "
"or B<PR_FPEMU_SIGFPE> to not emulate floating-point operations and send "
"B<SIGFPE> instead."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:472
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#.  prctl PR_SET_FPEXC
#. type: Plain text
#: build/C/man2/prctl.2:478
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:478
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#.  prctl PR_GET_FPEXC
#. type: Plain text
#: build/C/man2/prctl.2:492
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for "
"floating-point inexact result, B<PR_FP_EXC_INV> for floating-point invalid "
"operation, B<PR_FP_EXC_DISABLED> for FP exceptions disabled, "
"B<PR_FP_EXC_NONRECOV> for async nonrecoverable exception mode, "
"B<PR_FP_EXC_ASYNC> for async recoverable exception mode, "
"B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:492
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#.  prctl PR_SET_IO_FLUSHER
#. type: Plain text
#: build/C/man2/prctl.2:498
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:498
#, no-wrap
msgid "B<PR_SET_IO_FLUSHER> (since Linux 5.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:507
msgid ""
"If a user process is involved in the block layer or filesystem I/O path, and "
"can allocate memory while processing I/O requests it must set I<arg2> to 1.  "
"This will put the process in the IO_FLUSHER state, which allows it special "
"treatment to make progress when allocating memory.  If I<arg2> is 0, the "
"process will clear the IO_FLUSHER state, and the default behavior will be "
"used."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:511 build/C/man2/prctl.2:536
msgid "The calling process must have the B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:517
msgid "I<arg3>, I<arg4>, and I<arg5> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:522
msgid ""
"The IO_FLUSHER state is inherited by a child process created via B<fork>(2)  "
"and is preserved across B<execve>(2)."
msgstr ""

#.  prctl PR_GET_IO_FLUSHER
#. type: Plain text
#: build/C/man2/prctl.2:527
msgid ""
"Examples of IO_FLUSHER applications are FUSE daemons, SCSI device emulation "
"daemons, and daemons that perform error handling like multipath path "
"recovery applications."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:527
#, no-wrap
msgid "B<PR_GET_IO_FLUSHER (Since Linux 5.6)>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:532
msgid ""
"Return (as the function result) the IO_FLUSHER state of the caller.  A value "
"of 1 indicates that the caller is in the IO_FLUSHER state; 0 indicates that "
"the caller is not in the IO_FLUSHER state."
msgstr ""

#.  prctl PR_SET_KEEPCAPS
#. type: Plain text
#: build/C/man2/prctl.2:544
msgid "I<arg2>, I<arg3>, I<arg4>, and I<arg5> must be zero."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:544
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#.  prctl PR_GET_KEEPCAPS
#. type: Plain text
#: build/C/man2/prctl.2:555
msgid ""
"Set the state of the calling thread's \"keep capabilities\" flag.  The "
"effect of this flag is described in B<capabilities>(7).  I<arg2> must be "
"either 0 (clear the flag)  or 1 (set the flag).  The \"keep capabilities\" "
"value will be reset to 0 on subsequent calls to B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:555
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#.  prctl PR_MCE_KILL
#. type: Plain text
#: build/C/man2/prctl.2:563
msgid ""
"Return (as the function result) the current state of the calling thread's "
"\"keep capabilities\" flag.  See B<capabilities>(7)  for a description of "
"this flag."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:563
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr ""

#.  prctl PR_MCE_KILL_GET
#. type: Plain text
#: build/C/man2/prctl.2:604
msgid ""
"Set the machine check memory corruption kill policy for the calling thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the "
"system-wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the "
"thread receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is killed "
"only when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:604
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr ""

#.  prctl PR_SET_MM
#. type: Plain text
#: build/C/man2/prctl.2:612
msgid ""
"Return (as the function result)  the current per-process machine check kill "
"policy.  All unused B<prctl>()  arguments must be zero."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:612
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr ""

#.  commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
#. type: Plain text
#: build/C/man2/prctl.2:622
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see "
"B<ld.so>(8)  for more information) and a regular application should not use "
"this feature.  However, there are cases, such as self-modifying programs, "
"where a program might find it useful to change its own memory map."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:636
msgid ""
"The calling process must have the B<CAP_SYS_RESOURCE> capability.  The value "
"in I<arg2> is one of the options below, while I<arg3> provides a new value "
"for the option.  The I<arg4> and I<arg5> arguments must be zero if unused."
msgstr ""

#.  commit 52b3694157e3aa6df871e283115652ec6f2d31e0
#. type: Plain text
#: build/C/man2/prctl.2:642
msgid ""
"Before Linux 3.10, this feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:643
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:652
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:652
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:657
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:657
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:663
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:663
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:669
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:669
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:673
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:673
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:685
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)  "
"call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:685
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:693
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr ""

#.  commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
#. type: Plain text
#: build/C/man2/prctl.2:696
msgid "The following options are available since Linux 3.5."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:696
#, no-wrap
msgid "B<PR_SET_MM_ARG_START>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:699
msgid "Set the address above which the program command line is placed."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:699
#, no-wrap
msgid "B<PR_SET_MM_ARG_END>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:702
msgid "Set the address below which the program command line is placed."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:702
#, no-wrap
msgid "B<PR_SET_MM_ENV_START>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:705
msgid "Set the address above which the program environment is placed."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:705
#, no-wrap
msgid "B<PR_SET_MM_ENV_END>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:708
msgid "Set the address below which the program environment is placed."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:721
msgid ""
"The address passed with B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START>, and B<PR_SET_MM_ENV_END> should belong to a process "
"stack area.  Thus, the corresponding memory area must be readable, writable, "
"and (depending on the kernel configuration) have the B<MAP_GROWSDOWN> "
"attribute set (see B<mmap>(2))."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:721
#, no-wrap
msgid "B<PR_SET_MM_AUXV>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:730
msgid ""
"Set a new auxiliary vector.  The I<arg3> argument should provide the address "
"of the vector.  The I<arg4> is the size of the vector."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:730
#, no-wrap
msgid "B<PR_SET_MM_EXE_FILE>"
msgstr ""

#.  commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
#. type: Plain text
#: build/C/man2/prctl.2:742
msgid ""
"Supersede the I</proc/pid/exe> symbolic link with a new one pointing to a "
"new executable file identified by the file descriptor provided in I<arg3> "
"argument.  The file descriptor should be obtained with a regular B<open>(2)  "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:749
msgid ""
"To change the symbolic link, one needs to unmap all existing executable "
"memory areas, including those created by the kernel itself (for example the "
"kernel usually creates at least one executable memory area for the ELF "
"I<.text> section)."
msgstr ""

#.  commit 3fb4afd9a504c2386b8435028d43283216bf588e
#. type: Plain text
#: build/C/man2/prctl.2:760
msgid ""
"In Linux 4.9 and earlier, the B<PR_SET_MM_EXE_FILE> operation can be "
"performed only once in a process's lifetime; attempting to perform the "
"operation a second time results in the error B<EPERM>.  This restriction was "
"enforced for security reasons that were subsequently deemed specious, and "
"the restriction was removed in Linux 4.10 because some user-space "
"applications needed to perform this operation more than once."
msgstr ""

#.  commit f606b77f1a9e362451aca8f81d8f36a3a112139e
#. type: Plain text
#: build/C/man2/prctl.2:763
msgid "The following options are available since Linux 3.18."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:763
#, no-wrap
msgid "B<PR_SET_MM_MAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:771
msgid ""
"Provides one-shot access to all the addresses by passing in a I<struct "
"prctl_mm_map> (as defined in I<E<lt>linux/prctl.hE<gt>>).  The I<arg4> "
"argument should provide the size of the struct."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:775 build/C/man2/prctl.2:788
msgid ""
"This feature is available only if the kernel is built with the "
"B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:775
#, no-wrap
msgid "B<PR_SET_MM_MAP_SIZE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:784
msgid ""
"Returns the size of the I<struct prctl_mm_map> the kernel expects.  This "
"allows user space to find a compatible struct.  The I<arg4> argument should "
"be a pointer to an unsigned int."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:790
#, no-wrap
msgid ""
"B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (since Linux 3.19, "
"removed in Linux 5.4; only on x86)"
msgstr ""

#.  commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
#.  See also http://lwn.net/Articles/582712/
#.  See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
#.  commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
#. type: Plain text
#: build/C/man2/prctl.2:805
msgid ""
"Enable or disable kernel management of Memory Protection eXtensions (MPX)  "
"bounds tables.  The I<arg2>, I<arg3>, I<arg4>, and I<arg5> arguments must be "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:818
msgid ""
"MPX is a hardware-assisted mechanism for performing bounds checking on "
"pointers.  It consists of a set of registers storing bounds information and "
"a set of special instruction prefixes that tell the CPU on which "
"instructions it should do bounds enforcement.  There is a limited number of "
"these registers and when there are more pointers than registers, their "
"contents must be \"spilled\" into a set of tables.  These tables are called "
"\"bounds tables\" and the MPX B<prctl>()  operations control whether the "
"kernel manages their allocation and freeing."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:828
msgid ""
"When management is enabled, the kernel will take over allocation and freeing "
"of the bounds tables.  It does this by trapping the #BR exceptions that "
"result at first use of missing bounds tables and instead of delivering the "
"exception to user space, it allocates the table and populates the bounds "
"directory with the location of the new table.  For freeing, the kernel "
"checks to see if bounds tables are present for memory which is not "
"allocated, and frees them if so."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:835
msgid ""
"Before enabling MPX management using B<PR_MPX_ENABLE_MANAGEMENT>, the "
"application must first have allocated a user-space buffer for the bounds "
"directory and placed the location of that directory in the I<bndcfgu> "
"register."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:843
msgid ""
"These calls fail if the CPU or kernel does not support MPX.  Kernel support "
"for MPX is enabled via the B<CONFIG_X86_INTEL_MPX> configuration option.  "
"You can check whether the CPU supports MPX by looking for the I<mpx> CPUID "
"bit, like with the following command:"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:847
#, no-wrap
msgid "cat /proc/cpuinfo | grep \\(aq mpx \\(aq\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:852
msgid ""
"A thread may not switch in or out of long (64-bit) mode while MPX is "
"enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:854
msgid "All threads in a process are affected by these calls."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:863
msgid ""
"The child of a B<fork>(2)  inherits the state of MPX management.  During "
"B<execve>(2), MPX management is reset to a state as if "
"B<PR_MPX_DISABLE_MANAGEMENT> had been called."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:866
msgid ""
"For further information on Intel MPX, see the kernel source file "
"I<Documentation/x86/intel_mpx.txt>."
msgstr ""

#.  commit f240652b6032b48ad7fa35c5e701cc4c8d697c0b
#.  See also https://lkml.kernel.org/r/20190705175321.DB42F0AD@viggo.jf.intel.com
#.  prctl PR_SET_NAME
#. type: Plain text
#: build/C/man2/prctl.2:873
msgid ""
"Due to a lack of toolchain support, B<PR_MPX_ENABLE_MANAGEMENT> and "
"B<PR_MPX_DISABLE_MANAGEMENT> are not supported in Linux 5.4 and later."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:873
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr ""

#.  TASK_COMM_LEN in include/linux/sched.h
#.  prctl PR_GET_NAME
#. type: Plain text
#: build/C/man2/prctl.2:896
msgid ""
"Set the name of the calling thread, using the value in the location pointed "
"to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, including "
"the terminating null byte.  (If the length of the string, including the "
"terminating null byte, exceeds 16 bytes, the string is silently truncated.)  "
"This is the same attribute that can be set via B<pthread_setname_np>(3)  and "
"retrieved using B<pthread_getname_np>(3).  The attribute is likewise "
"accessible via I</proc/self/task/[tid]/comm> (see B<proc>(5)), where "
"I<[tid]> is the thread ID of the calling thread, as returned by "
"B<gettid>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:896
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr ""

#.  prctl PR_SET_NO_NEW_PRIVS
#. type: Plain text
#: build/C/man2/prctl.2:904
msgid ""
"Return the name of the calling thread, in the buffer pointed to by I<(char\\ "
"*) arg2>.  The buffer should allow space for up to 16 bytes; the returned "
"string will be null-terminated."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:904
#, no-wrap
msgid "B<PR_SET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:929
msgid ""
"Set the calling thread's I<no_new_privs> attribute to the value in I<arg2>.  "
"With I<no_new_privs> set to 1, B<execve>(2)  promises not to grant "
"privileges to do anything that could not have been done without the "
"B<execve>(2)  call (for example, rendering the set-user-ID and set-group-ID "
"mode bits, and file capabilities non-functional).  Once set, the "
"I<no_new_privs> attribute cannot be unset.  The setting of this attribute is "
"inherited by children created by B<fork>(2)  and B<clone>(2), and preserved "
"across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:938
msgid ""
"Since Linux 4.10, the value of a thread's I<no_new_privs> attribute can be "
"viewed via the I<NoNewPrivs> field in the I</proc/[pid]/status> file."
msgstr ""

#.  commit 40fde647ccb0ae8c11d256d271e24d385eed595b
#.  prctl PR_GET_NO_NEW_PRIVS
#. type: Plain text
#: build/C/man2/prctl.2:948
msgid ""
"For more information, see the kernel source file "
"I<Documentation/userspace-api/no_new_privs.rst> (or "
"I<Documentation/prctl/no_new_privs.txt> before Linux 4.13).  See also "
"B<seccomp>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:948
#, no-wrap
msgid "B<PR_GET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr ""

#.  prctl PR_PAC_RESET_KEYS
#.  commit ba830885656414101b2f8ca88786524d4bb5e8c1
#. type: Plain text
#: build/C/man2/prctl.2:961
msgid ""
"Return (as the function result) the value of the I<no_new_privs> attribute "
"for the calling thread.  A value of 0 indicates the regular B<execve>(2)  "
"behavior.  A value of 1 indicates B<execve>(2)  will operate in the "
"privilege-restricting mode described above."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:961
#, no-wrap
msgid "B<PR_PAC_RESET_KEYS> (since Linux 5.0, only on arm64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:965
msgid ""
"Securely reset the thread's pointer authentication keys to fresh random "
"values generated by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:969
msgid ""
"The set of keys to be reset is specified by I<arg2>, which must be a logical "
"OR of zero or more of the following:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:970
#, no-wrap
msgid "B<PR_PAC_APIAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:973
msgid "instruction authentication key A"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:973
#, no-wrap
msgid "B<PR_PAC_APIBKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:976
msgid "instruction authentication key B"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:976
#, no-wrap
msgid "B<PR_PAC_APDAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:979
msgid "data authentication key A"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:979
#, no-wrap
msgid "B<PR_PAC_APDBKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:982
msgid "data authentication key B"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:982
#, no-wrap
msgid "B<PR_PAC_APGAKEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:985
msgid "generic authentication \\(lqA\\(rq key."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:987
msgid "(Yes folks, there really is no generic B key.)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1002
msgid ""
"As a special case, if I<arg2> is zero, then all the keys are reset.  Since "
"new keys could be added in future, this is the recommended way to completely "
"wipe the existing keys when establishing a clean execution context.  Note "
"that there is no need to use B<PR_PAC_RESET_KEYS> in preparation for calling "
"B<execve>(2), since B<execve>(2)  resets all the pointer authentication "
"keys."
msgstr ""

#.  Enforcement added in
#.  commit 3e91ec89f527b9870fe42dcbdb74fd389d123a95
#. type: Plain text
#: build/C/man2/prctl.2:1006 build/C/man2/prctl.2:1564
msgid "The remaining arguments I<arg3>, I<arg4>, and I<arg5> must all be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1014
msgid ""
"If the arguments are invalid, and in particular if I<arg2> contains set bits "
"that are unrecognized or that correspond to a key not available on this "
"platform, then the call fails with error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1023
msgid ""
"B<Warning:> Because the compiler or run-time environment may be using some "
"or all of the keys, a successful B<PR_PAC_RESET_KEYS> may crash the calling "
"process.  The conditions for using it safely are complex and "
"system-dependent.  Don't use it unless you know what you are doing."
msgstr ""

#. commit b693d0b372afb39432e1c49ad7b3454855bc6bed
#.  prctl PR_SET_PDEATHSIG
#. type: Plain text
#: build/C/man2/prctl.2:1031
msgid ""
"For more information, see the kernel source file "
"I<Documentation/arm64/pointer-authentication.rst> (or "
"I<Documentation/arm64/pointer-authentication.txt> before Linux 5.3)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1031
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1040
msgid ""
"Set the parent-death signal of the calling process to I<arg2> (either a "
"signal value in the range 1..B<NSIG>-1B<,> or 0 to clear).  This is the "
"signal that the calling process will get when its parent dies."
msgstr ""

#.  https://bugzilla.kernel.org/show_bug.cgi?id=43300
#. type: Plain text
#: build/C/man2/prctl.2:1050
msgid ""
"I<Warning>: the \"parent\" in this case is considered to be the I<thread> "
"that created this process.  In other words, the signal will be sent when "
"that thread terminates (via, for example, B<pthread_exit>(3)), rather than "
"after all of the threads in the parent process terminate."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1060
msgid ""
"The parent-death signal is sent upon subsequent termination of the parent "
"thread and also upon termination of each subreaper process (see the "
"description of B<PR_SET_CHILD_SUBREAPER> above) to which the caller is "
"subsequently reparented.  If the parent thread and all ancestor subreapers "
"have already terminated by the time of the B<PR_SET_PDEATHSIG> operation, "
"then no parent-death signal is sent to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1071
msgid ""
"The parent-death signal is process-directed (see B<signal>(7))  and, if the "
"child installs a handler using the B<sigaction>(2)  B<SA_SIGINFO> flag, the "
"I<si_pid> field of the I<siginfo_t> argument of the handler contains the PID "
"of the terminating parent process."
msgstr ""

#.  commit d2d56c5f51028cb9f3d800882eb6f4cbd3f9099f
#.  FIXME capability changes can also trigger this; see
#.  kernel/cred.c::commit_creds in the Linux 5.6 source.
#.  prctl PR_GET_PDEATHSIG
#. type: Plain text
#: build/C/man2/prctl.2:1089
msgid ""
"The parent-death signal setting is cleared for the child of a B<fork>(2).  "
"It is also (since Linux 2.4.36 / 2.6.23)  cleared when executing a "
"set-user-ID or set-group-ID binary, or a binary that has associated "
"capabilities (see B<capabilities>(7)); otherwise, this value is preserved "
"across B<execve>(2).  The parent-death signal setting is also cleared upon "
"changes to any of the following thread credentials: effective user ID, "
"effective group ID, filesystem user ID, or filesystem group ID."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1089
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr ""

#.  prctl PR_SET_PTRACER
#. type: Plain text
#: build/C/man2/prctl.2:1095
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1095
#, no-wrap
msgid "B<PR_SET_PTRACER> (since Linux 3.4)"
msgstr ""

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#.  commit bf06189e4d14641c0148bea16e9dd24943862215
#. type: Plain text
#: build/C/man2/prctl.2:1120
msgid ""
"This is meaningful only when the Yama LSM is enabled and in mode 1 "
"(\"restricted ptrace\", visible via I</proc/sys/kernel/yama/ptrace_scope>).  "
"When a \"ptracer process ID\" is passed in I<arg2>, the caller is declaring "
"that the ptracer process can B<ptrace>(2)  the calling process as if it were "
"a direct process ancestor.  Each B<PR_SET_PTRACER> operation replaces the "
"previous \"ptracer process ID\".  Employing B<PR_SET_PTRACER> with I<arg2> "
"set to 0 clears the caller's \"ptracer process ID\".  If I<arg2> is "
"B<PR_SET_PTRACER_ANY>, the ptrace restrictions introduced by Yama are "
"effectively disabled for the calling process."
msgstr ""

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#.  prctl PR_SET_SECCOMP
#. type: Plain text
#: build/C/man2/prctl.2:1128
msgid ""
"For further information, see the kernel source file "
"I<Documentation/admin-guide/LSM/Yama.rst> (or "
"I<Documentation/security/Yama.txt> before Linux 4.13)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1128
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: build/C/man2/prctl.2:1139
msgid ""
"Set the secure computing (seccomp) mode for the calling thread, to limit the "
"available system calls.  The more recent B<seccomp>(2)  system call provides "
"a superset of the functionality of B<PR_SET_SECCOMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1144
msgid ""
"The seccomp mode is selected via I<arg2>.  (The seccomp constants are "
"defined in I<E<lt>linux/seccomp.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1167
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_STRICT>, the only system calls that the "
"thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2)  (but "
"not B<exit_group>(2)), and B<sigreturn>(2).  Other system calls result in "
"the delivery of a B<SIGKILL> signal.  Strict secure computing mode is useful "
"for number-crunching applications that may need to execute untrusted byte "
"code, perhaps obtained by reading from a pipe or socket.  This operation is "
"available only if the kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1182
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_FILTER> (since Linux 3.5), the system "
"calls allowed are defined by a pointer to a Berkeley Packet Filter passed in "
"I<arg3>.  This argument is a pointer to I<struct sock_fprog>; it can be "
"designed to filter arbitrary system calls and system call arguments.  This "
"mode is available only if the kernel is configured with "
"B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1197
msgid ""
"If B<SECCOMP_MODE_FILTER> filters permit B<fork>(2), then the seccomp mode "
"is inherited by children created by B<fork>(2); if B<execve>(2)  is "
"permitted, then the seccomp mode is preserved across B<execve>(2).  If the "
"filters permit B<prctl>()  calls, then additional filters can be added; they "
"are run in order until the first non-allow result is seen."
msgstr ""

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#.  prctl PR_GET_SECCOMP
#. type: Plain text
#: build/C/man2/prctl.2:1205
msgid ""
"For further information, see the kernel source file "
"I<Documentation/userspace-api/seccomp_filter.rst> (or "
"I<Documentation/prctl/seccomp_filter.txt> before Linux 4.13)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1205
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1223
msgid ""
"Return (as the function result)  the secure computing mode of the calling "
"thread.  If the caller is not in secure computing mode, this operation "
"returns 0; if the caller is in strict secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"If the caller is in filter mode, and this system call is allowed by the "
"seccomp filters, it returns 2; otherwise, the process is killed with a "
"B<SIGKILL> signal.  This operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP> enabled."
msgstr ""

#.  prctl PR_SET_SECUREBITS
#. type: Plain text
#: build/C/man2/prctl.2:1232
msgid ""
"Since Linux 3.8, the I<Seccomp> field of the I</proc/[pid]/status> file "
"provides a method of obtaining the same information, without the risk that "
"the process is killed; see B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1232
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#.  prctl PR_GET_SECUREBITS
#. type: Plain text
#: build/C/man2/prctl.2:1239
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1239
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#.  prctl PR_GET_SPECULATION_CTRL
#. type: Plain text
#: build/C/man2/prctl.2:1246
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1246
#, no-wrap
msgid "B<PR_GET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1255
msgid ""
"Return (as the function result)  the state of the speculation misfeature "
"specified in I<arg2>.  Currently, the only permitted value for this argument "
"is B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error "
"B<ENODEV>)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1257
msgid "The return value uses bits 0-3 with the following meaning:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1258
#, no-wrap
msgid "B<PR_SPEC_PRCTL>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1262
msgid "Mitigation can be controlled per thread by B<PR_SET_SPECULATION_CTRL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1262 build/C/man2/prctl.2:1331
#, no-wrap
msgid "B<PR_SPEC_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1265 build/C/man2/prctl.2:1334
msgid "The speculation feature is enabled, mitigation is disabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1265 build/C/man2/prctl.2:1334
#, no-wrap
msgid "B<PR_SPEC_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1268 build/C/man2/prctl.2:1337
msgid "The speculation feature is disabled, mitigation is enabled."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1268 build/C/man2/prctl.2:1337
#, no-wrap
msgid "B<PR_SPEC_FORCE_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1273
msgid "Same as B<PR_SPEC_DISABLE> but cannot be undone."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1273 build/C/man2/prctl.2:1351
#, no-wrap
msgid "B<PR_SPEC_DISABLE_NOEXEC> (since Linux 5.1)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1279
msgid "Same as B<PR_SPEC_DISABLE>, but the state will be cleared on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1283
msgid ""
"If all bits are 0, then the CPU is not affected by the speculation "
"misfeature."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1290
msgid ""
"If B<PR_SPEC_PRCTL> is set, then per-thread control of the mitigation is "
"available.  If not set, B<prctl>()  for the speculation misfeature will "
"fail."
msgstr ""

#.  prctl PR_SET_SPECULATION_CTRL
#. type: Plain text
#: build/C/man2/prctl.2:1299
msgid ""
"The I<arg3>, I<arg4>, and I<arg5> arguments must be specified as 0; "
"otherwise the call fails with the error B<EINVAL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1299
#, no-wrap
msgid "B<PR_SET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr ""

#.  commit b617cfc858161140d69cc0b5cc211996b557a1c7
#.  commit 356e4bfff2c5489e016fdb925adbf12a1e3950ee
#. type: Plain text
#: build/C/man2/prctl.2:1306
msgid ""
"Sets the state of the speculation misfeature specified in I<arg2>.  The "
"speculation-misfeature settings are per-thread attributes."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1310
msgid "Currently, I<arg2> must be one of:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1311
#, no-wrap
msgid "B<PR_SPEC_STORE_BYPASS>"
msgstr ""

#.  commit 9137bb27e60e554dab694eafa4cca241fa3a694f
#. type: Plain text
#: build/C/man2/prctl.2:1315
msgid "Set the state of the speculative store bypass misfeature."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1315
#, no-wrap
msgid "B<PR_SPEC_INDIRECT_BRANCH> (since Linux 4.20)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1318
msgid "Set the state of the indirect branch speculation misfeature."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1325
msgid ""
"If I<arg2> does not have one of the above values, then the call fails with "
"the error B<ENODEV>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1330
msgid ""
"The I<arg3> argument is used to hand in the control value, which is one of "
"the following:"
msgstr ""

#.  commit 71368af9027f18fe5d1c6f372cfdff7e4bde8b48
#. type: Plain text
#: build/C/man2/prctl.2:1351
msgid ""
"Same as B<PR_SPEC_DISABLE>, but cannot be undone.  A subsequent "
"B<prctl>(I<arg2>, B<PR_SPEC_ENABLE>)  with the same value for I<arg2> will "
"fail with the error B<EPERM>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1361
msgid ""
"Same as B<PR_SPEC_DISABLE>, but the state will be cleared on B<execve>(2).  "
"Currently only supported for I<arg2> equal to B<PR_SPEC_STORE_BYPASS.>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1367
msgid ""
"Any unsupported value in I<arg3> will result in the call failing with the "
"error B<ERANGE>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1374
msgid ""
"The I<arg4> and I<arg5> arguments must be specified as 0; otherwise the call "
"fails with the error B<EINVAL>."
msgstr ""

#.  prctl PR_SVE_SET_VL
#.  commit 2d2123bc7c7f843aa9db87720de159a049839862
#.  linux-5.6/Documentation/arm64/sve.rst
#. type: Plain text
#: build/C/man2/prctl.2:1387
msgid ""
"The speculation feature can also be controlled by the "
"B<spec_store_bypass_disable> boot parameter.  This parameter may enforce a "
"read-only policy which will result in the B<prctl>()  call failing with the "
"error B<ENXIO>.  For further details, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1387
#, no-wrap
msgid "B<PR_SVE_SET_VL> (since Linux 4.15, only on arm64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1395
msgid ""
"Configure the thread's SVE vector length, as specified by I<(int) arg2>.  "
"Arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1411
msgid ""
"The bits of I<arg2> corresponding to B<PR_SVE_VL_LEN_MASK> must be set to "
"the desired vector length in bytes.  This is interpreted as an upper bound: "
"the kernel will select the greatest available vector length that does not "
"exceed the value specified.  In particular, specifying B<SVE_VL_MAX> "
"(defined in I<E<lt>asm/sigcontext.hE<gt>)> for the B<PR_SVE_VL_LEN_MASK> "
"bits requests the maximum supported vector length."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1415
msgid ""
"In addition, the other bits of I<arg2> must be set to one of the following "
"combinations of flags:"
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1416 build/C/man2/prctl.2:1547
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1424
msgid ""
"Perform the change immediately.  At the next B<execve>(2)  in the thread, "
"the vector length will be reset to the value configured in "
"I</proc/sys/abi/sve_default_vector_length>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1424
#, no-wrap
msgid "B<PR_SVE_VL_INHERIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1430
msgid ""
"Perform the change immediately.  Subsequent B<execve>(2)  calls will "
"preserve the new vector length."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1430
#, no-wrap
msgid "B<PR_SVE_SET_VL_ONEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1439
msgid ""
"Defer the change, so that it is performed at the next B<execve>(2)  in the "
"thread.  Further B<execve>(2)  calls will reset the vector length to the "
"value configured in I</proc/sys/abi/sve_default_vector_length>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1439
#, no-wrap
msgid "B<PR_SVE_SET_VL_ONEXEC | PR_SVE_VL_INHERIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1447
msgid ""
"Defer the change, so that it is performed at the next B<execve>(2)  in the "
"thread.  Further B<execve>(2)  calls will preserve the new vector length."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1451
msgid "In all cases, any previously pending deferred change is canceled."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1463
msgid ""
"The call fails with error B<EINVAL> if SVE is not supported on the platform, "
"if I<arg2> is unrecognized or invalid, or the value in the bits of I<arg2> "
"corresponding to B<PR_SVE_VL_LEN_MASK> is outside the range "
"B<SVE_VL_MIN>..B<SVE_VL_MAX> or is not a multiple of 16."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1483
msgid ""
"On success, a nonnegative value is returned that describes the I<selected> "
"configuration.  If B<PR_SVE_SET_VL_ONEXEC> was included in I<arg2>, then the "
"configuration described by the return value will take effect at the next "
"B<execve>().  Otherwise, the configuration is already in effect when the "
"B<PR_SVE_SET_VL> call returns.  In either case, the value is encoded in the "
"same way as the return value of B<PR_SVE_GET_VL>.  Note that there is no "
"explicit flag in the return value corresponding to B<PR_SVE_SET_VL_ONEXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1489
msgid ""
"The configuration (including any pending deferred change)  is inherited "
"across B<fork>(2)  and B<clone>(2)."
msgstr ""

#. commit b693d0b372afb39432e1c49ad7b3454855bc6bed
#.  prctl PR_SET_TAGGED_ADDR_CTRL
#.  commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
#. type: Plain text
#: build/C/man2/prctl.2:1496 build/C/man2/prctl.2:1538
msgid ""
"For more information, see the kernel source file "
"I<Documentation/arm64/sve.rst> (or I<Documentation/arm64/sve.txt> before "
"Linux 5.3)."
msgstr ""

#.  prctl PR_SVE_GET_VL
#. type: Plain text
#: build/C/man2/prctl.2:1505
msgid ""
"B<Warning:> Because the compiler or run-time environment may be using SVE, "
"using this call without the B<PR_SVE_SET_VL_ONEXEC> flag may crash the "
"calling process.  The conditions for using it safely are complex and "
"system-dependent.  Don't use it unless you really know what you are doing."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1505
#, no-wrap
msgid "B<PR_SVE_GET_VL> (since Linux 4.15, only on arm64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1508
msgid "Get the thread's current SVE vector length configuration."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1512
msgid "Arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1526
msgid ""
"Provided that the kernel and platform support SVE, this operation always "
"succeeds, returning a nonnegative value that describes the I<current> "
"configuration.  The bits corresponding to B<PR_SVE_VL_LEN_MASK> contain the "
"currently configured vector length in bytes.  The bit corresponding to "
"B<PR_SVE_VL_INHERIT> indicates whether the vector length will be inherited "
"across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1529
msgid ""
"Note that there is no way to determine whether there is a pending vector "
"length change that has not yet taken effect."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1538
#, no-wrap
msgid "B<PR_SET_TAGGED_ADDR_CTRL> (since Linux 5.4, only on arm64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1542
msgid ""
"Controls support for passing tagged user-space addresses to the kernel "
"(i.e., addresses where bits 56\\(em63 are not all zero)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1546
msgid ""
"The level of support is selected by I<arg2>, which can be one of the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1552
msgid ""
"Addresses that are passed for the purpose of being dereferenced by the "
"kernel must be untagged."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1552
#, no-wrap
msgid "B<PR_TAGGED_ADDR_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1557
msgid ""
"Addresses that are passed for the purpose of being dereferenced by the "
"kernel may be tagged, with the exceptions summarized below."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1577
msgid ""
"On success, the mode specified in I<arg2> is set for the calling thread and "
"the return value is 0.  If the arguments are invalid, the mode specified in "
"I<arg2> is unrecognized, or if this feature is unsupported by the kernel or "
"disabled via I</proc/sys/abi/tagged_addr_disabled>, the call fails with the "
"error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1584
msgid ""
"In particular, if B<prctl>(B<PR_SET_TAGGED_ADDR_CTRL>, 0, 0, 0, 0)  fails "
"with B<EINVAL>, then all addresses passed to the kernel must be untagged."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1588
msgid ""
"Irrespective of which mode is set, addresses passed to certain interfaces "
"must always be untagged:"
msgstr ""

#. type: IP
#: build/C/man2/prctl.2:1589 build/C/man2/prctl.2:1602 build/C/man2/timerfd_create.2:532 build/C/man2/timerfd_create.2:541
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1598
msgid ""
"B<brk>(2), B<mmap>(2), B<shmat>(2), B<shmdt>(2), and the I<new_address> "
"argument of B<mremap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1602
msgid ""
"(Prior to Linux 5.6 these accepted tagged addresses, but the behaviour may "
"not be what you expect.  Don't rely on it.)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1614
msgid ""
"\\(oqpolymorphic\\(cq interfaces that accept pointers to arbitrary types "
"cast to a I<void *> or other generic type, specifically B<prctl>(), "
"B<ioctl>(2), and in general B<setsockopt>(2)  (only certain specific "
"B<setsockopt>(2)  options allow tagged addresses)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1623
msgid ""
"This list of exclusions may shrink when moving from one kernel version to a "
"later kernel version.  While the kernel may make some guarantees for "
"backwards compatibility reasons, for the purposes of new software the effect "
"of passing tagged addresses to these interfaces is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1632
msgid ""
"The mode set by this call is inherited across B<fork>(2)  and B<clone>(2).  "
"The mode is reset by B<execve>(2)  to 0 (i.e., tagged addresses not "
"permitted in the user/kernel ABI)."
msgstr ""

#
#.  prctl PR_TASK_PERF_EVENTS_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1635 build/C/man2/prctl.2:1680
msgid ""
"For more information, see the kernel source file "
"I<Documentation/arm64/tagged-address-abi.rst>."
msgstr ""

#.  prctl PR_GET_TAGGED_ADDR_CTRL
#.  commit 63f0c60379650d82250f22e4cf4137ef3dc4f43d
#. type: Plain text
#: build/C/man2/prctl.2:1645
msgid ""
"B<Warning:> This call is primarily intended for use by the run-time "
"environment.  A successful B<PR_SET_TAGGED_ADDR_CTRL> call elsewhere may "
"crash the calling process.  The conditions for using it safely are complex "
"and system-dependent.  Don't use it unless you know what you are doing."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1645
#, no-wrap
msgid "B<PR_GET_TAGGED_ADDR_CTRL> (since Linux 5.4, only on arm64)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1649
msgid "Returns the current tagged address mode for the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1653
msgid "Arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> must all be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1668
msgid ""
"If the arguments are invalid or this feature is disabled or unsupported by "
"the kernel, the call fails with B<EINVAL>.  In particular, if "
"B<prctl>(B<PR_GET_TAGGED_ADDR_CTRL>, 0, 0, 0, 0)  fails with B<EINVAL>, then "
"this feature is definitely either unsupported, or disabled via "
"I</proc/sys/abi/tagged_addr_disabled>.  In this case, all addresses passed "
"to the kernel must be untagged."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1675
msgid ""
"Otherwise, the call returns a nonnegative value describing the current "
"tagged address mode, encoded in the same way as the I<arg2> argument of "
"B<PR_SET_TAGGED_ADDR_CTRL>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1680
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1689
msgid ""
"Disable all performance counters attached to the calling process, regardless "
"of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the Linux "
"kernel source file I<tools/perf/design.txt>."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#
#.  prctl PR_TASK_PERF_EVENTS_ENABLE
#. type: Plain text
#: build/C/man2/prctl.2:1697
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (retaining the "
"same numerical value)  in Linux 2.6.32."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1697
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1702
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#
#.  prctl PR_SET_THP_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1711
msgid "Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1711
#, no-wrap
msgid "B<PR_SET_THP_DISABLE> (since Linux 3.15)"
msgstr ""

#.  commit a0715cc22601e8830ace98366c0c2bd8da52af52
#.  prctl PR_GET_THP_DISABLE
#. type: Plain text
#: build/C/man2/prctl.2:1728
msgid ""
"Set the state of the \"THP disable\" flag for the calling thread.  If "
"I<arg2> has a nonzero value, the flag is set, otherwise it is cleared.  "
"Setting this flag provides a method for disabling transparent huge pages for "
"jobs where the code cannot be modified, and using a malloc hook with "
"B<madvise>(2)  is not an option (i.e., statically allocated data).  The "
"setting of the \"THP disable\" flag is inherited by a child created via "
"B<fork>(2)  and is preserved across B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1728
#, no-wrap
msgid "B<PR_GET_THP_DISABLE> (since Linux 3.15)"
msgstr ""

#.  prctl PR_GET_TID_ADDRESS
#. type: Plain text
#: build/C/man2/prctl.2:1734
msgid ""
"Return (as the function result) the current setting of the \"THP disable\" "
"flag for the calling thread: either 1, if the flag is set, or 0, if it is "
"not."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1734
#, no-wrap
msgid "B<PR_GET_TID_ADDRESS> (since Linux 3.5)"
msgstr ""

#.  commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
#.  prctl PR_SET_TIMERSLACK
#. type: Plain text
#: build/C/man2/prctl.2:1756
msgid ""
"Return the I<clear_child_tid> address set by B<set_tid_address>(2)  and the "
"B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to by "
"I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled.  Note that since the "
"B<prctl>()  system call does not have a compat implementation for the AMD64 "
"x32 and MIPS n32 ABIs, and the kernel writes out a pointer using the "
"kernel's pointer size, this operation expects a user-space buffer of 8 (not "
"4) bytes on these ABIs."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1756
#, no-wrap
msgid "B<PR_SET_TIMERSLACK> (since Linux 2.6.28)"
msgstr ""

#.  See https://lwn.net/Articles/369549/
#.  commit 6976675d94042fbd446231d1bd8b7de71a980ada
#. type: Plain text
#: build/C/man2/prctl.2:1774
msgid ""
"Each thread has two associated timer slack values: a \"default\" value, and "
"a \"current\" value.  This operation sets the \"current\" timer slack value "
"for the calling thread.  I<arg2> is an unsigned long value, then maximum "
"\"current\" value is ULONG_MAX and the minimum \"current\" value is 1.  If "
"the nanosecond value supplied in I<arg2> is greater than zero, then the "
"\"current\" value is set to this value.  If I<arg2> is equal to zero, the "
"\"current\" timer slack is reset to the thread's \"default\" timer slack "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1781
msgid ""
"The \"current\" timer slack is used by the kernel to group timer expirations "
"for the calling thread that are close to one another; as a consequence, "
"timer expirations for the thread may be up to the specified number of "
"nanoseconds late (but will never expire early).  Grouping timer expirations "
"can help reduce system power consumption by minimizing CPU wake-ups."
msgstr ""

#.  List obtained by grepping for futex usage in glibc source
#. type: Plain text
#: build/C/man2/prctl.2:1801
msgid ""
"The timer expirations affected by timer slack are those set by B<select>(2), "
"B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), "
"B<clock_nanosleep>(2), B<nanosleep>(2), and B<futex>(2)  (and thus the "
"library functions implemented via futexes, including "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), and "
"B<sem_timedwait>(3))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1805
msgid ""
"Timer slack is not applied to threads that are scheduled under a real-time "
"scheduling policy (see B<sched_setscheduler>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1820
msgid ""
"When a new thread is created, the two timer slack values are made the same "
"as the \"current\" value of the creating thread.  Thereafter, a thread can "
"adjust its \"current\" timer slack value via B<PR_SET_TIMERSLACK>.  The "
"\"default\" value can't be changed.  The timer slack values of I<init> (PID "
"1), the ancestor of all processes, are 50,000 nanoseconds (50 "
"microseconds).  The timer slack value is inherited by a child created via "
"B<fork>(2), and is preserved across B<execve>(2)."
msgstr ""

#.  prctl PR_GET_TIMERSLACK
#. type: Plain text
#: build/C/man2/prctl.2:1827
msgid ""
"Since Linux 4.6, the \"current\" timer slack value of any process can be "
"examined and changed via the file I</proc/[pid]/timerslack_ns>.  See "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1827
#, no-wrap
msgid "B<PR_GET_TIMERSLACK> (since Linux 2.6.28)"
msgstr ""

#.  prctl PR_SET_TIMING
#. type: Plain text
#: build/C/man2/prctl.2:1832
msgid ""
"Return (as the function result)  the \"current\" timer slack value of the "
"calling thread."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1832
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test4
#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#.  prctl PR_GET_TIMING
#. type: Plain text
#: build/C/man2/prctl.2:1851
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1851
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test4
#.  prctl PR_SET_TSC
#. type: Plain text
#: build/C/man2/prctl.2:1857
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1857
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#.  prctl PR_GET_TSC
#. type: Plain text
#: build/C/man2/prctl.2:1871
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1871
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#.  prctl PR_SET_UNALIGN
#. type: Plain text
#: build/C/man2/prctl.2:1878
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1878
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr ""

#.  sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
#.  tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
#.  prctl PR_GET_UNALIGN
#. type: Plain text
#: build/C/man2/prctl.2:1902
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22; sh, since Linux 2.6.34; tile, "
"since Linux 3.12)  Set unaligned access control bits to I<arg2>.  Pass "
"B<PR_UNALIGN_NOPRINT> to silently fix up unaligned user accesses, or "
"B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned user access.  Alpha "
"also supports an additional flag with the value of 4 and no corresponding "
"named constant, which instructs kernel to not fix up unaligned accesses (it "
"is analogous to providing the B<UAC_NOFIX> flag in B<SSI_NVPAIRS> operation "
"of the B<setsysinfo>()  system call on Tru64)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1902
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1909
msgid ""
"(See B<PR_SET_UNALIGN> for information on versions and architectures.)  "
"Return unaligned access control bits, in the location pointed to by "
"I<(unsigned int\\ *) arg2>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1936
msgid ""
"On success, B<PR_CAP_AMBIENT>+B<PR_CAP_AMBIENT_IS_SET>, B<PR_CAPBSET_READ>, "
"B<PR_GET_DUMPABLE>, B<PR_GET_FP_MODE>, B<PR_GET_IO_FLUSHER>, "
"B<PR_GET_KEEPCAPS>, B<PR_MCE_KILL_GET>, B<PR_GET_NO_NEW_PRIVS>, "
"B<PR_GET_SECUREBITS>, B<PR_GET_SPECULATION_CTRL>, B<PR_SVE_GET_VL>, "
"B<PR_SVE_SET_VL>, B<PR_GET_TAGGED_ADDR_CTRL>, B<PR_GET_THP_DISABLE>, "
"B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, and (if it returns)  "
"B<PR_GET_SECCOMP> return the nonnegative values described above.  All other "
"I<option> values return 0 on success.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1937 build/C/man2/prctl.2:1953
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1953
msgid ""
"I<option> is B<PR_SET_SECCOMP> and I<arg2> is B<SECCOMP_MODE_FILTER>, but "
"the process does not have the B<CAP_SYS_ADMIN> capability or has not set the "
"I<no_new_privs> attribute (see the discussion of B<PR_SET_NO_NEW_PRIVS> "
"above)."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1963
msgid ""
"I<option> is B<PR_SET_MM>, and I<arg3> is B<PR_SET_MM_EXE_FILE>, the file is "
"not executable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1963 build/C/man2/signalfd.2:306 build/C/man2/timerfd_create.2:465
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1974
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and the file "
"descriptor passed in I<arg4> is not valid."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:1974
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1985
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and this the "
"second attempt to change the I</proc/pid/exe> symbolic link, which is "
"prohibited."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:1989
msgid "I<arg2> is an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2002
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, the "
"system was built with B<CONFIG_SECCOMP_FILTER>, and I<arg3> is an invalid "
"address."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2008
msgid "The value of I<option> is not recognized, or not supported on this system."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2020
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2025
msgid "I<arg2> is not valid value for this I<option>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2034
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_GET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2044
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, and the "
"kernel was not configured with B<CONFIG_SECCOMP_FILTER>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2050
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2056
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2061
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2071
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK>, "
"and the permissions of the corresponding memory area are not as required;"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2083
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would "
"cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2094
msgid ""
"I<option> is B<PR_SET_PTRACER> and I<arg2> is not 0, B<PR_SET_PTRACER_ANY>, "
"or the PID of an existing process."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2102
msgid "I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2113
msgid ""
"I<option> is B<PR_SET_DUMPABLE> and I<arg2> is neither B<SUID_DUMP_DISABLE> "
"nor B<SUID_DUMP_USER>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2122
msgid "I<option> is B<PR_SET_TIMING> and I<arg2> is not B<PR_TIMING_STATISTICAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2136
msgid ""
"I<option> is B<PR_SET_NO_NEW_PRIVS> and I<arg2> is not equal to 1 or "
"I<arg3>, I<arg4>, or I<arg5> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2148
msgid ""
"I<option> is B<PR_GET_NO_NEW_PRIVS> and I<arg2>, I<arg3>, I<arg4>, or "
"I<arg5> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2159
msgid ""
"I<option> is B<PR_SET_THP_DISABLE> and I<arg3>, I<arg4>, or I<arg5> is "
"nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2171
msgid ""
"I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or I<arg5> "
"is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2196
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and an unused argument (I<arg4>, I<arg5>, or, "
"in the case of B<PR_CAP_AMBIENT_CLEAR_ALL>, I<arg3>)  is nonzero; or I<arg2> "
"has an invalid value; or I<arg2> is B<PR_CAP_AMBIENT_LOWER>, "
"B<PR_CAP_AMBIENT_RAISE>, or B<PR_CAP_AMBIENT_IS_SET> and I<arg3> does not "
"specify a valid capability."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2214
msgid ""
"I<option> was B<PR_GET_SPECULATION_CTRL> or B<PR_SET_SPECULATION_CTRL> and "
"unused arguments to B<prctl>()  are not 0.  B<EINVAL> I<option> is "
"B<PR_PAC_RESET_KEYS> and the arguments are invalid or unsupported.  See the "
"description of B<PR_PAC_RESET_KEYS> above for details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2224
msgid ""
"I<option> is B<PR_SVE_SET_VL> and the arguments are invalid or unsupported, "
"or SVE is not available on this platform.  See the description of "
"B<PR_SVE_SET_VL> above for details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2230
msgid "I<option> is B<PR_SVE_GET_VL> and SVE is not available on this platform."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2239
msgid ""
"I<option> is B<PR_SET_TAGGED_ADDR_CTRL> and the arguments are invalid or "
"unsupported.  See the description of B<PR_SET_TAGGED_ADDR_CTRL> above for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2248
msgid ""
"I<option> is B<PR_GET_TAGGED_ADDR_CTRL> and the arguments are invalid or "
"unsupported.  See the description of B<PR_GET_TAGGED_ADDR_CTRL> above for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2254
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> the kernel or CPU does not support "
"the requested speculation misfeature."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2254 build/C/man2/prctl.2:2263
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2263
msgid ""
"I<option> was B<PR_MPX_ENABLE_MANAGEMENT> or B<PR_MPX_DISABLE_MANAGEMENT> "
"and the kernel or the CPU does not support MPX management.  Check that the "
"kernel and processor have MPX support."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2272
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> implies that the control of the "
"selected speculation misfeature is not possible.  See "
"B<PR_GET_SPECULATION_CTRL> for the bit fields to determine which option is "
"available."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2272 build/C/man2/s390_runtime_instr.2:87
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2280
msgid ""
"I<option> is B<PR_SET_FP_MODE> and I<arg2> has an invalid or unsupported "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2292
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2300
msgid ""
"I<option> is B<PR_SET_SPECULATION_CTRL> wherein the speculation was disabled "
"with B<PR_SPEC_FORCE_DISABLE> and caller tried to enable it again."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2310
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the caller's B<SECBIT_KEEP_CAPS_LOCKED> "
"flag is set (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2318
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2326
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2341
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and I<arg2> is B<PR_CAP_AMBIENT_RAISE>, but "
"either the capability specified in I<arg3> is not present in the process's "
"permitted and inheritable capability sets, or the B<PR_CAP_AMBIENT_LOWER> "
"securebit has been set."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:2341
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2354
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> and I<arg3> is not "
"B<PR_SPEC_ENABLE>, B<PR_SPEC_DISABLE>, B<PR_SPEC_FORCE_DISABLE>, nor "
"B<PR_SPEC_DISABLE_NOEXEC>."
msgstr ""

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: build/C/man2/prctl.2:2359
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2366
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2370
#, no-wrap
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2377
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:2380
msgid "B<signal>(2), B<core>(5)"
msgstr ""

#. type: TH
#: build/C/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr ""

#. type: TH
#: build/C/man3/profil.3:28 build/C/man2/restart_syscall.2:33 build/C/man2/sigaction.2:48 build/C/man2/sigaltstack.2:26 build/C/man7/signal.7:45 build/C/man3/sigsetops.3:31 build/C/man2/timer_getoverrun.2:26 build/C/man7/signal-safety.7:25
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:31
msgid "profil - execution time profile"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:34
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:37
#, no-wrap
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:45
msgid "B<profil>():"
msgstr ""

#.              commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: build/C/man3/profil.3:53
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:76
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined: "
"I<offset> is subtracted and the result is multiplied by I<scale> and divided "
"by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:78
msgid "Zero is always returned."
msgstr ""

#. type: tbl table
#: build/C/man3/profil.3:88
#, no-wrap
msgid "B<profil>()"
msgstr ""

#. type: tbl table
#: build/C/man3/profil.3:88
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:93
msgid "Similar to a call in SVr4 (but not POSIX.1)."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:99
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""

#.  Libc 4.4 contained a kernel patch providing a system call profil.
#. type: Plain text
#: build/C/man3/profil.3:102
msgid "True kernel profiling provides more accurate results."
msgstr ""

#. type: Plain text
#: build/C/man3/profil.3:108
msgid "B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr ""

#. type: TH
#: build/C/man3/psignal.3:30
#, no-wrap
msgid "PSIGNAL"
msgstr ""

#. type: TH
#: build/C/man3/psignal.3:30 build/C/man3/raise.3:29 build/C/man7/sigevent.7:26
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:33
msgid "psignal, psiginfo - print signal description"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:39
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:51
#, no-wrap
msgid ""
"B<psignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:54
msgid "B<psiginfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:63
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the "
"string I<s>, a colon, a space, a string describing the signal number I<sig>, "
"and a trailing newline.  If the string I<s> is NULL or empty, the colon and "
"space are omitted.  If I<sig> is invalid, the message displayed will "
"indicate an unknown signal."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:84
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, "
"B<psiginfo>()  displays information about the origin of the signal, and "
"other information relevant to the signal (e.g., the relevant memory address "
"for hardware-generated signals, the child process ID for B<SIGCHLD>, and the "
"user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:90
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:94
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr ""

#. type: tbl table
#: build/C/man3/psignal.3:105
#, no-wrap
msgid ""
"B<psignal>(),\n"
"B<psiginfo>()"
msgstr ""

#. type: tbl table
#: build/C/man3/psignal.3:105
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:110
msgid "POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:114
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:118
msgid "In some circumstances, a trailing newline is not printed."
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:122
msgid "Additional details are not displayed for real-time signals."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:127
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/raise.3:29
#, no-wrap
msgid "RAISE"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:32
msgid "raise - send a signal to the caller"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:37
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:43
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:47
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:51
msgid "In a multithreaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:55
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:61
msgid ""
"If the signal causes a handler to be called, B<raise>()  will return only "
"after the signal handler has returned."
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:64
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr ""

#. type: tbl table
#: build/C/man3/raise.3:74
#, no-wrap
msgid "B<raise>()"
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:78 build/C/man2/signal.2:113
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: build/C/man3/raise.3:89
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/raise.3:96
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:36
msgid "restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:38
msgid "B<long restart_syscall(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#.  Notable (as at Linux 3.17) is that poll() has such a "restart"
#.  function, but ppoll(), select(), and pselect() do not.
#.  This means that the latter system calls do not take account of the
#.  time spent in the stopped state when restarting.
#. type: Plain text
#: build/C/man2/restart_syscall.2:88
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since "
"Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduct the already elapsed "
"time when the process continued execution."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:92
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:96
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:100
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:102
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:106
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:128
msgid ""
"The kernel uses B<restart_syscall>()  to ensure that when a system call is "
"restarted after a process has been stopped by a signal and then resumed by "
"B<SIGCONT>, then the time that the process spent in the stopped state is "
"counted against the timeout interval specified in the original system call.  "
"In the case of system calls that take a timeout argument and automatically "
"restart after a stop signal plus B<SIGCONT>, but which do not have the "
"B<restart_syscall>()  mechanism built in, then, after the process resumes "
"execution, the time that the process spent in the stop state is I<not> "
"counted against the timeout value.  Notable examples of system calls that "
"suffer this problem are B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/restart_syscall.2:135
msgid ""
"From user space, the operation of B<restart_syscall>()  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""

#.  FIXME . ppoll(2), select(2), and pselect(2)
#.      should probably get the restart_syscall() treatment:
#.      If a select() call is suspended by stop-sig+SIGCONT, the time
#.      spent suspended is *not* deducted when the select() is restarted.
#.  FIXME . check whether recvmmsg() handles stop-sig+SIGCONT properly.
#. type: Plain text
#: build/C/man2/restart_syscall.2:144
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t "
"*>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:38 build/C/man2/sgetmask.2:35
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group "
"(i.e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<info> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:79 build/C/man7/sigevent.7:90 build/C/man2/wait.2:339
#, no-wrap
msgid "I<si_code>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:87
msgid ""
"This should be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>.  If the signal is being sent to any "
"process other than the caller itself, the following restrictions apply:"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:97
msgid ""
"The code can't be a value greater than or equal to zero.  In particular, it "
"can't be B<SI_USER>, which is used by the kernel to indicate a signal sent "
"by B<kill>(2), and nor can it be B<SI_KERNEL>, which is used to indicate a "
"signal generated by the kernel."
msgstr ""

#.  tkill(2) or
#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:103
msgid ""
"The code can't (since Linux 2.6.39) be B<SI_TKILL>, which is used by the "
"kernel to indicate a signal sent using B<tgkill>(2)."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:104 build/C/man2/wait.2:318
#, no-wrap
msgid "I<si_pid>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:108
msgid "This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:108 build/C/man2/wait.2:321
#, no-wrap
msgid "I<si_uid>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:112
msgid "This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:112 build/C/man7/sigevent.7:98
#, no-wrap
msgid "I<si_value>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:119
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:126
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:138
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:143
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:144 build/C/man3/sigqueue.3:92 build/C/man2/sigwaitinfo.2:116 build/C/man2/timer_create.2:211 build/C/man2/tkill.2:97 build/C/man2/tkill.2:104
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:150 build/C/man3/sigqueue.3:98
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:157
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:162
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:168
msgid ""
"I<tgid> specifies a process other than the caller and I<info-E<gt>si_code> "
"is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:174
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:181
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:188
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version "
"2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:190 build/C/man2/sgetmask.2:74 build/C/man2/timerfd_create.2:503
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:195
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:200
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:209
msgid ""
"B<kill>(2), B<pidfd_send_signal>(2), B<sigaction>(2), B<sigprocmask>(2), "
"B<tgkill>(2), B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "S390_RUNTIME_INSTR"
msgstr ""

#. type: TH
#: build/C/man2/s390_runtime_instr.2:25 build/C/man3/sigwait.3:26 build/C/man2/timer_settime.2:26 build/C/man2/wait4.2:33 build/C/man3/killpg.3:42
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:28
msgid "s390_runtime_instr - enable/disable s390 CPU run-time instrumentation"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:31
#, no-wrap
msgid "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:33
#, no-wrap
msgid "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:39
msgid ""
"The B<s390_runtime_instr>()  system call starts or stops CPU run-time "
"instrumentation for the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:47
msgid ""
"The I<command> argument controls whether run-time instrumentation is started "
"(B<S390_RUNTIME_INSTR_START>, 1) or stopped (B<S390_RUNTIME_INSTR_STOP>, 2) "
"for the calling thread."
msgstr ""

#.  commit b38feccd663b55ab07116208b68e1ffc7c3c7e78
#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:58
msgid ""
"The I<signum> argument specifies the number of a real-time signal.  This "
"argument was used to specify a signal number that should be delivered to the "
"thread if the run-time instrumentation buffer was full or if the "
"run-time-instrumentation-halted interrupt had occurred.  This feature was "
"never used, and in Linux 4.4 support for this feature was removed; thus, in "
"current kernels, this argument is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:69
msgid ""
"On success, B<s390_runtime_instr>()  returns 0 and enables the thread for "
"run-time instrumentation by assigning the thread a default run-time "
"instrumentation control block.  The caller can then read and modify the "
"control block and start the run-time instrumentation.  On error, -1 is "
"returned and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:75
msgid "The value specified in I<command> is not a valid command."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:84
msgid ""
"The value specified in I<signum> is not a real-time signal number.  From "
"Linux 4.4 onwards, the I<signum> argument has no effect, so that an invalid "
"signal number will not result in an error."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:87
msgid "Allocating memory for the run-time instrumentation control block failed."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:90
msgid "The run-time instrumentation facility is not available."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:92
msgid "This system call is available since Linux 3.7."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:96
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The run-time instrumentation facility is available beginning with System z "
"EC12."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:100
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""

#.  commit df2f815a7df7edb5335a3bdeee6a8f9f6f9c35c4
#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:106
msgid "The I<asm/runtime_instr.h> header file is available since Linux 4.16."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:115
msgid ""
"Starting with Linux 4.4, support for signalling was removed, as was the "
"check whether I<signum> is a valid real-time signal.  For backwards "
"compatibility with older kernels, it is recommended to pass a valid "
"real-time signal number in I<signum> and install a handler for that signal."
msgstr ""

#. type: Plain text
#: build/C/man2/s390_runtime_instr.2:118
msgid "B<syscall>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sgetmask.2:25
#, no-wrap
msgid "SGETMASK"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:28
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:30
msgid "B<long sgetmask(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:32
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:41
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:44
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:49
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:58
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:63
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:65
msgid "These system calls always succeed."
msgstr ""

#.  f6187769dae48234f3877df3c4d99294cc2254fa
#. type: Plain text
#: build/C/man2/sgetmask.2:72
msgid ""
"Since Linux 3.16, support for these system calls is optional, depending on "
"whether the kernel was built with the B<CONFIG_SGETMASK_SYSCALL> option."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:78
msgid ""
"Glibc does not provide wrappers for these obsolete system calls; in the "
"unlikely event that you want to call them, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:81
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., "
"real-time signals)."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:83
msgid "These system calls do not exist on x86-64."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:88
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr ""

#. type: Plain text
#: build/C/man2/sgetmask.2:91
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigaction.2:48
#, no-wrap
msgid "SIGACTION"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:51
msgid "sigaction, rt_sigaction - examine and change a signal action"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:57
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:67
msgid "B<sigaction>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:70
msgid "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:79
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:85
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:96
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in "
"I<oldact>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:100
msgid "The I<sigaction> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:110
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:117
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:126
msgid ""
"The I<sa_restorer> field is not intended for application use.  (POSIX does "
"not specify a I<sa_restorer> field.)  Some further details of the purpose of "
"this field can be found in B<sigreturn>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:131
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and is be "
"one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:134
msgid "B<SIG_DFL> for the default action."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:137
msgid "B<SIG_IGN> to ignore this signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:140
msgid ""
"A pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:152
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives three arguments, as described below."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:162
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is "
"used."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:166
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:166
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:183
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is meaningful only when establishing a handler for B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:183
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr ""

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: build/C/man2/sigaction.2:197
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is meaningful only when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:209
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:209
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:217
msgid ""
"Do not add the signal to the thread's signal mask while the handler is "
"executing, unless the signal is specified in I<act.sa_mask>.  Consequently, "
"a further instance of the signal may be delivered to the thread while it is "
"executing the handler.  This flag is meaningful only when establishing a "
"signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:220
msgid "B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:220
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:226
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is meaningful only when establishing a signal "
"handler."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:226
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:230
msgid ""
"Restore the signal action to the default upon entry to the signal handler.  "
"This flag is meaningful only when establishing a signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:233
msgid "B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:233
#, no-wrap
msgid "B<SA_RESTART>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:241
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is meaningful only when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:241
#, no-wrap
msgid "B<SA_RESTORER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:250
msgid ""
"I<Not intended for application use>.  This flag is used by C libraries to "
"indicate that the I<sa_restorer> field contains the address of a \"signal "
"trampoline\".  See B<sigreturn>(2)  for more details."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:250
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr ""

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: build/C/man2/sigaction.2:262
msgid ""
"The signal handler takes three arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is "
"meaningful only when establishing a signal handler."
msgstr ""

#. type: SS
#: build/C/man2/sigaction.2:262
#, no-wrap
msgid "The siginfo_t argument to a SA_SIGINFO handler"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:271
msgid ""
"When the B<SA_SIGINFO> flag is specified in I<act.sa_flags>, the signal "
"handler address is passed via the I<act.sa_sigaction> field.  This handler "
"takes three arguments, as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:279
#, no-wrap
msgid ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:283
msgid "These three arguments are as follows"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:283
#, no-wrap
msgid "I<sig>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:286
msgid "The number of the signal that caused invocation of the handler."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:286
#, no-wrap
msgid "I<info>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:292
msgid ""
"A pointer to a I<siginfo_t>, which is a structure containing further "
"information about the signal, as described below."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:292
#, no-wrap
msgid "I<ucontext>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:308
msgid ""
"This is a pointer to a I<ucontext_t> structure, cast to I<void\\ *>.  The "
"structure pointed to by this field contains signal context information that "
"was saved on the user-space stack by the kernel; for details, see "
"B<sigreturn>(2).  Further information about the I<ucontext_t> structure can "
"be found in B<getcontext>(3)  and B<signal>(7).  Commonly, the handler "
"function doesn't make any use of the third argument."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:312
msgid "The I<siginfo_t> data type is a structure with the following fields:"
msgstr ""

#.  FIXME
#.  The siginfo_t 'si_trapno' field seems to be used
#.  only on SPARC and Alpha; this page could use
#.  a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: build/C/man2/sigaction.2:357
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;     /* Signal number */\n"
"    int      si_errno;     /* An errno value */\n"
"    int      si_code;      /* Signal code */\n"
"    int      si_trapno;    /* Trap number that caused\n"
"                              hardware-generated signal\n"
"                              (unused on most architectures) */\n"
"    pid_t    si_pid;       /* Sending process ID */\n"
"    uid_t    si_uid;       /* Real user ID of sending process */\n"
"    int      si_status;    /* Exit value or signal */\n"
"    clock_t  si_utime;     /* User time consumed */\n"
"    clock_t  si_stime;     /* System time consumed */\n"
"    union sigval si_value; /* Signal value */\n"
"    int      si_int;       /* POSIX.1b signal */\n"
"    void    *si_ptr;       /* POSIX.1b signal */\n"
"    int      si_overrun;   /* Timer overrun count;\n"
"                              POSIX.1b timers */\n"
"    int      si_timerid;   /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;      /* Memory location which caused fault */\n"
"    long     si_band;      /* Band event (was I<int> in\n"
"                              glibc 2.3.2 and earlier) */\n"
"    int      si_fd;        /* File descriptor */\n"
"    short    si_addr_lsb;  /* Least significant bit of address\n"
"                              (since Linux 2.6.32) */\n"
"    void    *si_lower;     /* Lower bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    void    *si_upper;     /* Upper bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    int      si_pkey;      /* Protection key on PTE that caused\n"
"                              fault (since Linux 4.6) */\n"
"    void    *si_call_addr; /* Address of system call instruction\n"
"                              (since Linux 3.5) */\n"
"    int      si_syscall;   /* Number of attempted system call\n"
"                              (since Linux 3.5) */\n"
"    unsigned int si_arch;  /* Architecture of attempted system call\n"
"                              (since Linux 3.5) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:366
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should read only the fields that are meaningful for the "
"given signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:381
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:397
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:412
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: build/C/man2/sigaction.2:459
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<times>(2)).  In kernels "
"up to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:473
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> field."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:507
msgid ""
"Some suberrors of B<SIGBUS>, in particular B<BUS_MCEERR_AO> and "
"B<BUS_MCEERR_AR>, also fill in I<si_addr_lsb>.  This field indicates the "
"least significant bit of the reported address and therefore the extent of "
"the corruption.  For example, if a full page was corrupted, I<si_addr_lsb> "
"contains I<log2(sysconf(_SC_PAGESIZE))>.  When B<SIGTRAP> is delivered in "
"response to a B<ptrace>(2)  event (PTRACE_EVENT_foo), I<si_addr> is not "
"populated, but I<si_pid> and I<si_uid> are populated with the respective "
"process ID and user ID responsible for delivering the trap.  In the case of "
"B<seccomp>(2), the tracee will be shown as delivering the event.  "
"B<BUS_MCEERR_*> and I<si_addr_lsb> are Linux-specific extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:516
msgid ""
"The B<SEGV_BNDERR> suberror of B<SIGSEGV> populates I<si_lower> and "
"I<si_upper>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:523
msgid "The B<SEGV_PKUERR> suberror of B<SIGSEGV> populates I<si_pkey>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:541
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred; for further details, see the description of B<F_SETSIG> in "
"B<fcntl>(2)."
msgstr ""

#.  commit a0727e8ce513fe6890416da960181ceb10fbfae6
#. type: Plain text
#: build/C/man2/sigaction.2:555
msgid ""
"B<SIGSYS>, generated (since Linux 3.5)  when a seccomp filter returns "
"B<SECCOMP_RET_TRAP>, fills in I<si_call_addr>, I<si_syscall>, I<si_arch>, "
"I<si_errno>, and other fields as described in B<seccomp>(2)."
msgstr ""

#. type: SS
#: build/C/man2/sigaction.2:555
#, no-wrap
msgid "The si_code field"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:572
msgid ""
"The I<si_code> field inside the I<siginfo_t> argument that is passed to a "
"B<SA_SIGINFO> signal handler is a value (not a bit mask)  indicating why "
"this signal was sent.  For a B<ptrace>(2)  event, I<si_code> will contain "
"B<SIGTRAP> and have the ptrace event in the high byte:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:576
#, no-wrap
msgid "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:590
msgid ""
"For a non-B<ptrace>(2)  event, the values that can appear in I<si_code> are "
"described in the remainder of this section.  Since glibc 2.20, the "
"definitions of most of these symbols are obtained from I<E<lt>signal.hE<gt>> "
"by defining feature test macros (before including I<any> header file) as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:593
msgid "B<_XOPEN_SOURCE> with the value 500 or greater;"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:598
msgid "B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>; or"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:601
msgid "B<_POSIX_C_SOURCE> with the value 200809L or greater."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:606
msgid ""
"For the B<TRAP_*> constants, the symbol definitions are provided only in the "
"first two cases.  Before glibc 2.20, no feature test macros were required to "
"obtain these symbols."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:611
msgid ""
"For a regular signal, the following list shows the values which can be "
"placed in I<si_code> for any signal, along with the reason that the signal "
"was generated."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:612
#, no-wrap
msgid "B<SI_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:615
msgid "B<kill>(2)."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:615
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:618
msgid "Sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:618
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:621
msgid "B<sigqueue>(3)."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:621
#, no-wrap
msgid "B<SI_TIMER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:624
msgid "POSIX timer expired."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:624
#, no-wrap
msgid "B<SI_MESGQ> (since Linux 2.6.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:628
msgid "POSIX message queue state changed; see B<mq_notify>(3)."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:628
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:631
msgid "AIO completed."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:631
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:640
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:640
#, no-wrap
msgid "B<SI_TKILL> (since Linux 2.4.19)"
msgstr ""

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: build/C/man2/sigaction.2:648
msgid "B<tkill>(2)  or B<tgkill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:655
msgid "The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:656
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:659
msgid "Illegal opcode."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:659
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:662
msgid "Illegal operand."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:662
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:665
msgid "Illegal addressing mode."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:665
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:668
msgid "Illegal trap."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:668
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:671
msgid "Privileged opcode."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:671
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:674
msgid "Privileged register."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:674
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:677
msgid "Coprocessor error."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:677
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:680
msgid "Internal stack error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:687
msgid "The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:688
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:691
msgid "Integer divide by zero."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:691
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:694
msgid "Integer overflow."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:694
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:697
msgid "Floating-point divide by zero."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:697
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:700
msgid "Floating-point overflow."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:700
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:703
msgid "Floating-point underflow."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:703
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:706
msgid "Floating-point inexact result."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:706
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:709
msgid "Floating-point invalid operation."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:709
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:712
msgid "Subscript out of range."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:719
msgid "The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:720
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:723
msgid "Address not mapped to object."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:723
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:726
msgid "Invalid permissions for mapped object."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:726
#, no-wrap
msgid "B<SEGV_BNDERR> (since Linux 3.19)"
msgstr ""

#.  commit ee1b58d36aa1b5a79eaba11f5c3633c88231da83
#. type: Plain text
#: build/C/man2/sigaction.2:730
msgid "Failed address bound checks."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:730
#, no-wrap
msgid "B<SEGV_PKUERR> (since Linux 4.6)"
msgstr ""

#.  commit cd0ea35ff5511cde299a61c21a95889b4a71464e
#. type: Plain text
#: build/C/man2/sigaction.2:738
msgid ""
"Access was denied by memory protection keys.  See B<pkeys>(7).  The "
"protection key which applied to this access is available via I<si_pkey>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:745
msgid "The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:746
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:749
msgid "Invalid address alignment."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:749
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:752
msgid "Nonexistent physical address."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:752
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:755
msgid "Object-specific hardware error."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:755
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:758
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:758
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:761
msgid "Hardware memory error detected in process but not consumed; action optional."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:768
msgid "The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:769
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:772
msgid "Process breakpoint."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:772
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:775
msgid "Process trace trap."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:775
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4, IA64 only)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:778
msgid "Process taken branch trap."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:778
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4, IA64 only)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:781
msgid "Hardware breakpoint/watchpoint."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:788
msgid "The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:789
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:792
msgid "Child has exited."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:792
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:795
msgid "Child was killed."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:795
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:798
msgid "Child terminated abnormally."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:798
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:801
msgid "Traced child has trapped."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:801
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:804
msgid "Child has stopped."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:804
#, no-wrap
msgid "B<CLD_CONTINUED> (since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:807
msgid "Stopped child has continued."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:814
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:815
#, no-wrap
msgid "B<POLL_IN>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:818
msgid "Data input available."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:818
#, no-wrap
msgid "B<POLL_OUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:821
msgid "Output buffers available."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:821
#, no-wrap
msgid "B<POLL_MSG>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:824
msgid "Input message available."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:824
#, no-wrap
msgid "B<POLL_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:827
msgid "I/O error."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:827
#, no-wrap
msgid "B<POLL_PRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:830
msgid "High priority input available."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:830
#, no-wrap
msgid "B<POLL_HUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:833
msgid "Device disconnected."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:840
msgid "The following value can be placed in I<si_code> for a B<SIGSYS> signal:"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:841
#, no-wrap
msgid "B<SYS_SECCOMP> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:846
msgid "Triggered by a B<seccomp>(2)  filter rule."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:852
msgid ""
"B<sigaction>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:857
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:864
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""

#.  SVr4 does not document the EINTR condition.
#. type: Plain text
#: build/C/man2/sigaction.2:867
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:875 build/C/man7/signal.7:105
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:893 build/C/man2/signal.2:135
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:910
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 and later allow this possibility, so that ignoring B<SIGCHLD> "
"can be used to prevent the creation of zombies (see B<wait>(2)).  "
"Nevertheless, the historical BSD and System\\ V behaviors for ignoring "
"B<SIGCHLD> differ, so that the only completely portable method of ensuring "
"that terminated children do not become zombies is to catch the B<SIGCHLD> "
"signal and perform a B<wait>(2)  or similar."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:926
msgid ""
"POSIX.1-1990 specified only B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, "
"B<SA_RESETHAND>, B<SA_RESTART>, and B<SA_SIGINFO>.  Use of these latter "
"values in I<sa_flags> may be less portable in applications intended for "
"older UNIX implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:930
msgid "The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:940
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and later.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:946
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:952
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:956 build/C/man2/sigpending.2:69 build/C/man2/sigprocmask.2:160 build/C/man2/sigsuspend.2:109
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:962
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called inside from inside a signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:972
msgid ""
"The glibc wrapper function for B<sigaction>()  gives an error (B<EINVAL>)  "
"on attempts to change the disposition of the two real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:985
msgid ""
"On architectures where the signal trampoline resides in the C library, the "
"glibc wrapper function for B<sigaction>()  places the address of the "
"trampoline code in the I<act.sa_restorer> field and sets the B<SA_RESTORER> "
"flag in the I<act.sa_flags> field.  See B<sigreturn>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1014
msgid ""
"The original Linux system call was named B<sigaction>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigaction>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal sets in I<act.sa_mask> and I<oldact.sa_mask>.  This argument is "
"currently required to have the value I<sizeof(sigset_t)> (or the error "
"B<EINVAL> results).  The glibc B<sigaction>()  wrapper function hides these "
"details from us, transparently calling B<rt_sigaction>()  when the kernel "
"provides it."
msgstr ""

#. type: SS
#: build/C/man2/sigaction.2:1014
#, no-wrap
msgid "Undocumented"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1031
msgid ""
"Before the introduction of B<SA_SIGINFO>, it was also possible to get some "
"additional information about the signal.  This was done by providing an "
"I<sa_handler> signal handler with a second argument of type I<struct "
"sigcontext>, which is the same structure as the one that is passed in the "
"I<uc_mcontext> field of the I<ucontext> structure that is passed (via a "
"pointer) in the third argument of the I<sa_sigaction> handler.  See the "
"relevant Linux kernel sources for details.  This use is obsolete now."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1039
msgid ""
"When delivering a signal with a B<SA_SIGINFO> handler, the kernel does not "
"always provide meaningful values for all of the fields of the I<siginfo_t> "
"that are relevant for that signal."
msgstr ""

#.  commit 69be8f189653cd81aae5a74e26615b12871bb72e
#. type: Plain text
#: build/C/man2/sigaction.2:1049
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1052
msgid "See B<mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:1075
msgid ""
"B<kill>(1), B<kill>(2), B<pause>(2), B<pidfd_send_signal>(2), "
"B<restart_syscall>(2), B<seccomp>(2), B<sigaltstack>(2), B<signal>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), "
"B<sigsuspend>(2), B<wait>(2), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigaltstack.2:26
#, no-wrap
msgid "SIGALTSTACK"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:29
msgid "sigaltstack - set and/or get signal stack context"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:33
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:40
msgid "B<sigaltstack>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/sigaltstack.2:47 build/C/man3/siginterrupt.3:53
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:59
msgid ""
"B<sigaltstack>()  allows a thread to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:62
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:62 build/C/man7/signal.7:262 build/C/man7/signal.7:586 build/C/man7/signal-safety.7:62
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:66
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:66 build/C/man7/signal.7:312 build/C/man7/signal.7:590 build/C/man7/signal-safety.7:68
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:72
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""

#. type: IP
#: build/C/man2/sigaltstack.2:72 build/C/man7/signal.7:319 build/C/man7/signal.7:610
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:79
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:86
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<old_ss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks, then the other argument can be specified as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:90
msgid ""
"The I<stack_t> type used to type the arguments of this function is defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:98
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:103
msgid ""
"To establish a new alternate signal stack, the fields of this structure are "
"set as follows:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:103
#, no-wrap
msgid "I<ss.ss_flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:106
msgid "This field contains either 0, or the following flag:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:107
#, no-wrap
msgid "B<SS_AUTODISARM> (since Linux 4.7)"
msgstr ""

#.  commit 2a74213838104a41588d86fd5e8d344972891ace
#.  See tools/testing/selftests/sigaltstack/sas.c in kernel sources
#. type: Plain text
#: build/C/man2/sigaltstack.2:114
msgid ""
"Clear the alternate signal stack settings on entry to the signal handler.  "
"When the signal handler returns, the previous alternate signal stack "
"settings are restored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:125
msgid ""
"This flag was added in order make it safe to switch away from the signal "
"handler with B<swapcontext>(3).  Without this flag, a subsequently handled "
"signal will corrupt the state of the switched-away signal handler.  On "
"kernels where this flag is not supported, B<sigaltstack>()  fails with the "
"error B<EINVAL> when this flag is supplied."
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:126
#, no-wrap
msgid "I<ss.ss_sp>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:132
msgid ""
"This field specifies the starting address of the stack.  When a signal "
"handler is invoked on the alternate stack, the kernel automatically aligns "
"the address given in I<ss.ss_sp> to a suitable address boundary for the "
"underlying hardware architecture."
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:132
#, no-wrap
msgid "I<ss.ss_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:139
msgid ""
"This field specifies the size of the stack.  The constant B<SIGSTKSZ> is "
"defined to be large enough to cover the usual size requirements for an "
"alternate signal stack, and the constant B<MINSIGSTKSZ> defines the minimum "
"size required to execute a signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:146
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the kernel ignores any other flags in I<ss.ss_flags> and the "
"remaining fields in I<ss>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:154
msgid ""
"If I<old_ss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<old_ss.ss_sp> and I<old_ss.ss_size> fields return "
"the starting address and size of that stack.  The I<old_ss.ss_flags> may "
"return either of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:154
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:160
msgid ""
"The thread is currently executing on the alternate signal stack.  (Note that "
"it is not possible to change the alternate signal stack if the thread is "
"currently executing on it.)"
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:160
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:163
msgid "The alternate signal stack is currently disabled."
msgstr ""

#.  FIXME Was it intended that one can set up a different alternative
#.  signal stack in this scenario? (In passing, if one does this, the
#.  sigaltstack(NULL, &old_ss) now returns old_ss.ss_flags==SS_AUTODISARM
#.  rather than old_ss.ss_flags==SS_DISABLE. The API design here seems
#.  confusing...
#. type: Plain text
#: build/C/man2/sigaltstack.2:178
msgid ""
"Alternatively, this value is returned if the thread is currently executing "
"on an alternate signal stack that was established using the B<SS_AUTODISARM> "
"flag.  In this case, it is safe to switch away from the signal handler with "
"B<swapcontext>(3).  It is also possible to set up a different alternative "
"signal stack using a further call to B<sigaltstack>()."
msgstr ""

#. type: TP
#: build/C/man2/sigaltstack.2:178
#, no-wrap
msgid "B<SS_AUTODISARM>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:182
msgid ""
"The alternate signal stack has been marked to be autodisarmed as described "
"above."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:189
msgid ""
"By specifying I<ss> as NULL, and I<old_ss> as a non-NULL value, one can "
"obtain the current settings for the alternate signal stack without changing "
"them."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:193
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:198
msgid ""
"Either I<ss> or I<old_ss> is not NULL and points to an area outside of the "
"process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:202
msgid "I<ss> is not NULL and the I<ss_flags> field contains an invalid flag."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:208
msgid ""
"The specified size of the new alternate signal stack I<ss.ss_size> was less "
"than B<MINSIGSTKSZ>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:213
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the thread was already executing on the current alternate signal "
"stack)."
msgstr ""

#. type: tbl table
#: build/C/man2/sigaltstack.2:223
#, no-wrap
msgid "B<sigaltstack>()"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:227
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:231
msgid "The B<SS_AUTODISARM> flag is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:239
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the standard "
"stack is exhausted: in this case, a signal handler for B<SIGSEGV> cannot be "
"invoked on the standard stack; if we wish to handle it, we must use an "
"alternate signal stack."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:249
msgid ""
"Establishing an alternate signal stack is useful if a thread expects that it "
"may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the thread a B<SIGSEGV> "
"signal.  In these circumstances the only way to catch this signal is on an "
"alternate signal stack."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:255
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:264
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the thread is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:280
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings.  The same is also true for a child "
"process created using B<clone>(2), unless the clone flags include "
"B<CLONE_VM> and do not include B<CLONE_VFORK>, in which case any alternate "
"signal stack that was established in the parent is disabled in the child "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:289
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""

#. type: SS
#: build/C/man2/sigaltstack.2:289 build/C/man3/sigpause.3:82
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:296
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""

#.  Linux 2.3.40
#.  After quite a bit of web and mail archive searching,
#.  I could not find the patch on any mailing list, and I
#.  could find no place where the rationale for this change
#.  explained -- mtk
#.  See the source code of Illumos and FreeBSD, for example.
#. type: Plain text
#: build/C/man2/sigaltstack.2:334
msgid ""
"In Linux 2.2 and earlier, the only flag that could be specified in "
"I<ss.sa_flags> was B<SS_DISABLE>.  In the lead up to the release of the "
"Linux 2.4 kernel, a change was made to allow B<sigaltstack>()  to allow "
"I<ss.ss_flags==SS_ONSTACK> with the same meaning as I<ss.ss_flags==0> (i.e., "
"the inclusion of B<SS_ONSTACK> in I<ss.ss_flags> is a no-op).  On other "
"implementations, and according to POSIX.1, B<SS_ONSTACK> appears only as a "
"reported flag in I<old_ss.ss_flags>.  On Linux, there is no need ever to "
"specify B<SS_ONSTACK> in I<ss.ss_flags>, and indeed doing so should be "
"avoided on portability grounds: various other systems give an error if "
"B<SS_ONSTACK> is specified in I<ss.ss_flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:343
msgid ""
"The following code segment demonstrates the use of B<sigaltstack>()  (and "
"B<sigaction>(2))  to install an alternate signal stack that is employed by a "
"handler for the B<SIGSEGV> signal:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:347
#, no-wrap
msgid "stack_t ss;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:353
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:360
#, no-wrap
msgid ""
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1) {\n"
"    perror(\"sigaltstack\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:368
#, no-wrap
msgid ""
"sa.sa_flags = SA_ONSTACK;\n"
"sa.sa_handler = handler();      /* Address of a signal handler */\n"
"sigemptyset(&sa.sa_mask);\n"
"if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n"
"    perror(\"sigaction\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaltstack.2:377
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man7/sigevent.7:26
#, no-wrap
msgid "SIGEVENT"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:29
msgid "sigevent - structure for notification from asynchronous routines"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:32
#, no-wrap
msgid "#include E<lt>signal.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:37
#, no-wrap
msgid ""
"union sigval {            /* Data passed with notification */\n"
"    int     sival_int;    /* Integer value */\n"
"    void   *sival_ptr;    /* Pointer value */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:53
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int    sigev_notify;  /* Notification method */\n"
"    int    sigev_signo;   /* Notification signal */\n"
"    union sigval sigev_value;\n"
"                          /* Data passed with notification */\n"
"    void (*sigev_notify_function) (union sigval);\n"
"                          /* Function used for thread\n"
"                             notification (SIGEV_THREAD) */\n"
"    void  *sigev_notify_attributes;\n"
"                          /* Attributes for notification thread\n"
"                             (SIGEV_THREAD) */\n"
"    pid_t  sigev_notify_thread_id;\n"
"                          /* ID of thread to signal\n"
"                             (SIGEV_THREAD_ID); Linux-specific */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:62
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:70
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should employ only those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:75
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:75 build/C/man2/timer_create.2:142
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:78
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:78 build/C/man2/timer_create.2:147
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:82
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:89
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:94
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:94 build/C/man2/wait.2:325
#, no-wrap
msgid "I<si_signo>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:98
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:102
msgid "This field is set to the value specified in I<sigev_value>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:107
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:110
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:110 build/C/man2/timer_create.2:165
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:127
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities "
"here are that each timer notification could result in the creation of a new "
"thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:127 build/C/man2/timer_create.2:173
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr ""

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: build/C/man7/sigevent.7:132
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:142
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man3/siginterrupt.3:31
#, no-wrap
msgid "SIGINTERRUPT"
msgstr ""

#. type: TH
#: build/C/man3/siginterrupt.3:31
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:34
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:39
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:47
msgid "B<siginterrupt>():"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:64
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:69
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a "
"system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:73
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:83
msgid ""
"The B<siginterrupt>()  function returns 0 on success.  It returns -1 if the "
"signal number I<sig> is invalid, with I<errno> set to indicate the cause of "
"the error."
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:87
msgid "The specified signal number is invalid."
msgstr ""

#. type: tbl table
#: build/C/man3/siginterrupt.3:97
#, no-wrap
msgid "B<siginterrupt>()"
msgstr ""

#. type: tbl table
#: build/C/man3/siginterrupt.3:97
#, no-wrap
msgid "MT-Unsafe const:sigintr"
msgstr ""

#. type: Plain text
#: build/C/man3/siginterrupt.3:108
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag "
"instead."
msgstr ""

#. type: tbl table
#: build/C/man3/siginterrupt.3:110 build/C/man7/signal-safety.7:211
#, no-wrap
msgid "B<signal>(2)"
msgstr ""

#. type: TH
#: build/C/man2/signal.2:36 build/C/man7/signal.7:45
#, no-wrap
msgid "SIGNAL"
msgstr ""

#. type: TH
#: build/C/man2/signal.2:36 build/C/man3/sigpause.3:25 build/C/man2/sigpending.2:29 build/C/man2/sigprocmask.2:29 build/C/man3/sigqueue.3:28 build/C/man2/sigreturn.2:30 build/C/man2/sigwaitinfo.2:25 build/C/man3/sysv_signal.3:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:39
msgid "signal - ANSI C signal handling"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:45
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:55
#, no-wrap
msgid ""
"B<WARNING>:\n"
" the behavior of\n"
"B<signal>()\n"
"varies across UNIX versions,\n"
"and has also varied historically across different versions of Linux.\n"
"B<Avoid its use>: use\n"
"B<sigaction>(2)\n"
"instead.\n"
"See I<Portability> below.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:65
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a "
"programmer-defined function (a \"signal handler\")."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:69
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:74
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:81
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:92
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:98
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:106
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:111
msgid "I<signum> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:117
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:142
msgid ""
"See B<sigaction>(2)  for details on what happens when the disposition "
"B<SIGCHLD> is set to B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:147
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called from inside a signal handler."
msgstr ""

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: build/C/man2/signal.2:167
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> "
"(glibc 2.19 and earlier)  or B<_DEFAULT_SOURCE> (glibc 2.19 and later)  is "
"defined.  Without use of such a type, the declaration of B<signal>()  is the "
"somewhat harder to read:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:171
#, no-wrap
msgid ""
"B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) "
"(int);>\n"
msgstr ""

#. type: SS
#: build/C/man2/signal.2:173
#, no-wrap
msgid "Portability"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:185
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:191
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:201
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  This is equivalent to calling "
"B<sigaction>(2)  with the following flags:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:205
#, no-wrap
msgid "sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:214
msgid ""
"System\\ V also provides these semantics for B<signal>().  This was bad "
"because the signal might be delivered again before the handler had a chance "
"to reestablish itself.  Furthermore, rapid deliveries of the same signal "
"could result in recursive invocations of the handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:229
msgid ""
"BSD improved on this situation, but unfortunately also changed the semantics "
"of the existing B<signal>()  interface while doing so.  On BSD, when a "
"signal handler is invoked, the signal disposition is not reset, and further "
"instances of the signal are blocked from being delivered while the handler "
"is executing.  Furthermore, certain blocking system calls are automatically "
"restarted if interrupted by a signal handler (see B<signal>(7)).  The BSD "
"semantics are equivalent to calling B<sigaction>(2)  with the following "
"flags:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:233
#, no-wrap
msgid "sa.sa_flags = SA_RESTART;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:237
msgid "The situation on Linux is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:241
msgid "The kernel's B<signal>()  system call provides System\\ V semantics."
msgstr ""

#
#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#.  .IP *
#.  The
#.  .BR signal ()
#.  function in Linux libc4 and libc5 provide System\ V semantics.
#.  If one on a libc5 system includes
#.  .I <bsd/signal.h>
#.  instead of
#.  .IR <signal.h> ,
#.  then
#.  .BR signal ()
#.  provides BSD semantics.
#. type: Plain text
#: build/C/man2/signal.2:275
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as a suitable feature test macro is defined: B<_BSD_SOURCE> on glibc 2.19 "
"and earlier or B<_DEFAULT_SOURCE> in glibc 2.19 and later.  (By default, "
"these macros are defined; see B<feature_test_macros>(7)  for details.)  If "
"such a feature test macro is not defined, then B<signal>()  provides "
"System\\ V semantics."
msgstr ""

#. type: Plain text
#: build/C/man2/signal.2:294
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:48
msgid "signal - overview of signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:51
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard "
"signals\") and POSIX real-time signals."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:51
#, no-wrap
msgid "Signal dispositions"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:56
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:59
msgid ""
"The entries in the \"Action\" column of the table below specify the default "
"disposition for each signal, as follows:"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:59 build/C/man7/signal.7:378 build/C/man7/signal.7:383 build/C/man7/signal.7:385 build/C/man7/signal.7:389 build/C/man7/signal.7:390 build/C/man7/signal.7:392 build/C/man7/signal.7:393 build/C/man7/signal.7:394 build/C/man7/signal.7:396 build/C/man7/signal.7:398 build/C/man7/signal.7:399 build/C/man7/signal.7:402 build/C/man7/signal.7:407 build/C/man7/signal.7:413 build/C/man7/signal.7:414 build/C/man7/signal.7:415
#, no-wrap
msgid "Term"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:61
msgid "Default action is to terminate the process."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:61 build/C/man7/signal.7:380 build/C/man7/signal.7:381 build/C/man7/signal.7:412 build/C/man7/signal.7:420
#, no-wrap
msgid "Ign"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:63
msgid "Default action is to ignore the signal."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:63 build/C/man7/signal.7:377 build/C/man7/signal.7:379 build/C/man7/signal.7:384 build/C/man7/signal.7:387 build/C/man7/signal.7:391 build/C/man7/signal.7:400 build/C/man7/signal.7:401 build/C/man7/signal.7:405 build/C/man7/signal.7:408 build/C/man7/signal.7:411 build/C/man7/signal.7:416 build/C/man7/signal.7:418
#, no-wrap
msgid "Core"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:66
msgid "Default action is to terminate the process and dump core (see B<core>(5))."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:66 build/C/man7/signal.7:403 build/C/man7/signal.7:404 build/C/man7/signal.7:409 build/C/man7/signal.7:410
#, no-wrap
msgid "Stop"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:68
msgid "Default action is to stop the process."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:68 build/C/man7/signal.7:382
#, no-wrap
msgid "Cont"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:70
msgid "Default action is to continue the process if it is currently stopped."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:86
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:93
msgid ""
"By default, a signal handler is invoked on the normal process stack.  It is "
"possible to arrange that the signal handler uses an alternate stack; see "
"B<sigaltstack>(2)  for a discussion of how to do this and when it might be "
"useful."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:97
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:105
#, no-wrap
msgid "Sending a signal"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:108
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:108 build/C/man7/signal-safety.7:183
#, no-wrap
msgid "B<raise>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:111
msgid "Sends a signal to the calling thread."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:111 build/C/man7/signal-safety.7:152
#, no-wrap
msgid "B<kill>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:116
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:116
#, no-wrap
msgid "B<pidfd_send_signal>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:119
msgid "Sends a signal to a process identified by a PID file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:119
#, no-wrap
msgid "B<killpg>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:122
msgid "Sends a signal to all of the members of a specified process group."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:122 build/C/man7/signal-safety.7:180
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:126
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the "
"caller."
msgstr ""

#. type: TP
#: build/C/man7/signal.7:126
#, no-wrap
msgid "B<tgkill>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:131
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""

#. type: TP
#: build/C/man7/signal.7:131
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:134
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:134
#, no-wrap
msgid "Waiting for a signal to be caught"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:138
msgid ""
"The following system calls suspend execution of the calling thread until a "
"signal is caught (or an unhandled signal terminates the process):"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:138 build/C/man7/signal-safety.7:175
#, no-wrap
msgid "B<pause>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:141
msgid "Suspends execution until any signal is caught."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:141 build/C/man7/signal.7:663 build/C/man7/signal-safety.7:217
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:146
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:146
#, no-wrap
msgid "Synchronously accepting a signal"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:153
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:161
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:174
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each B<read>(2)  "
"from this file descriptor blocks until one of the signals in the set "
"specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:174
#, no-wrap
msgid "Signal mask and pending signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:181
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:190
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:196 build/C/man2/sigprocmask.2:142
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:219
msgid ""
"A signal may be process-directed or thread-directed.  A process-directed "
"signal is one that is targeted at (and thus pending for)  the process as a "
"whole.  A signal may be process-directed because it was generated by the "
"kernel for reasons other than a hardware exception, or because it was sent "
"using B<kill>(2)  or B<sigqueue>(3).  A thread-directed signal is one that "
"is targeted at a specific thread.  A signal may be thread-directed because "
"it was generated as a consequence of executing a specific machine-language "
"instruction that triggered a hardware exception (e.g., B<SIGSEGV> for an "
"invalid memory access, or B<SIGFPE> for a math error), or because it was "
"targeted at a specific thread using interfaces such as B<tgkill>(2)  or "
"B<pthread_kill>(3)."
msgstr ""

#.  Joseph C. Sible notes:
#.  On Linux, if the main thread has the signal unblocked, then the kernel
#.  will always deliver the signal there, citing this kernel code
#
#.      Per this comment in kernel/signal.c since time immemorial:
#
#.      /*
#.      * Now find a thread we can wake up to take the signal off the queue.
#.      *
#.      * If the main thread wants the signal, it gets first crack.
#.      * Probably the least surprising to the average bear.
#.      */
#
#.  But this does not mean the signal will be delivered only in the
#.  main thread, since if a handler is already executing in the main thread
#.  (and thus the signal is blocked in that thread), then a further
#.  might be delivered in a different thread.
#. type: Plain text
#: build/C/man7/signal.7:242
msgid ""
"A process-directed signal may be delivered to any one of the threads that "
"does not currently have the signal blocked.  If more than one of the threads "
"has the signal unblocked, then the kernel chooses an arbitrary thread to "
"which to deliver the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:249
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:256 build/C/man2/sigpending.2:85
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:256
#, no-wrap
msgid "Execution of signal handlers"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:262
msgid ""
"Whenever there is a transition from kernel-mode to user-mode execution "
"(e.g., on return from a system call or scheduling of a thread onto the CPU), "
"the kernel checks whether there is a pending unblocked signal for which the "
"process has established a signal handler.  If there is such a pending "
"signal, the following steps occur:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:265
msgid ""
"The kernel performs the necessary preparatory steps for execution of the "
"signal handler:"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:266
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:268
msgid "The signal is removed from the set of pending signals."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:268
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:276
msgid ""
"If the signal handler was installed by a call to B<sigaction>(2)  that "
"specified the B<SA_ONSTACK> flag and the thread has defined an alternate "
"signal stack (using B<sigaltstack>(2)), then that stack is installed."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:276
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:280
msgid ""
"Various pieces of signal-related context are saved into a special frame that "
"is created on the stack.  The saved information includes:"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:281 build/C/man7/signal.7:285 build/C/man7/signal.7:288 build/C/man7/signal.7:290
#, no-wrap
msgid "+"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:285
msgid ""
"the program counter register (i.e., the address of the next instruction in "
"the main program that should be executed when the signal handler returns);"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:288
msgid ""
"architecture-specific register state required for resuming the interrupted "
"program;"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:290
msgid "the thread's current signal mask;"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:292
msgid "the thread's alternate signal stack settings."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:300
msgid ""
"(If the signal handler was installed using the B<sigaction>(2)  "
"B<SA_SIGINFO> flag, then the above information is accessible via the "
"I<ucontext_t> object that is pointed to by the third argument of the signal "
"handler.)"
msgstr ""

#. type: IP
#: build/C/man7/signal.7:300
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:311
msgid ""
"Any signals specified in I<act-E<gt>sa_mask> when registering the handler "
"with B<sigprocmask>(2)  are added to the thread's signal mask.  The signal "
"being delivered is also added to the signal mask, unless B<SA_NODEFER> was "
"specified when registering the handler.  These signals are thus blocked "
"while the handler executes."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:319
msgid ""
"The kernel constructs a frame for the signal handler on the stack.  The "
"kernel sets the program counter for the thread to point to the first "
"instruction of the signal handler function, and configures the return "
"address for that function to point to a piece of user-space code known as "
"the signal trampoline (described in B<sigreturn>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:322
msgid ""
"The kernel passes control back to user-space, where execution commences at "
"the start of the signal handler function."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:322
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:324
msgid ""
"When the signal handler returns, control passes to the signal trampoline "
"code."
msgstr ""

#. type: IP
#: build/C/man7/signal.7:324
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:337
msgid ""
"The signal trampoline calls B<sigreturn>(2), a system call that uses the "
"information in the stack frame created in step 1 to restore the thread to "
"its state before the signal handler was called.  The thread's signal mask "
"and alternate signal stack settings are restored as part of this procedure.  "
"Upon completion of the call to B<sigreturn>(2), the kernel transfers control "
"back to user space, and the thread recommences execution at the point where "
"it was interrupted by the signal handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:355
msgid ""
"Note that if the signal handler does not return (e.g., control is "
"transferred out of the handler using B<siglongjmp>(3), or the handler "
"executes a new program with B<execve>(2)), then the final step is not "
"performed.  In particular, in such scenarios it is the programmer's "
"responsibility to restore the state of the signal mask (using "
"B<sigprocmask>(2)), if it is desired to unblock the signals that were "
"blocked on entry to the signal handler.  (Note that B<siglongjmp>(3)  may or "
"may not restore the signal mask, depending on the I<savesigs> value that was "
"specified in the corresponding call to B<sigsetjmp>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:366
msgid ""
"From the kernel's point of view, execution of the signal handler code is "
"exactly the same as the execution of any other user-space code.  That is to "
"say, the kernel does not record any special state information indicating "
"that the thread is currently excuting inside a signal handler.  All "
"necessary state information is maintained in user-space registers and the "
"user-space stack.  The depth to which nested signal handlers may be invoked "
"is thus limited only by the user-space stack (and sensible software "
"design!)."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:366
#, no-wrap
msgid "Standard signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:372
msgid ""
"Linux supports the standard signals listed below.  The second column of the "
"table indicates which standard (if any)  specified the signal: \"P1990\" "
"indicates that the signal is described in the original POSIX.1-1990 "
"standard; \"P2001\" indicates that the signal was added in SUSv2 and "
"POSIX.1-2001."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:376 build/C/man7/signal.7:486
#, no-wrap
msgid "Signal"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Standard"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Action"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:376
#, no-wrap
msgid "Comment"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:377 build/C/man7/signal.7:493
#, no-wrap
msgid "SIGABRT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:377 build/C/man7/signal.7:378 build/C/man7/signal.7:380 build/C/man7/signal.7:382 build/C/man7/signal.7:384 build/C/man7/signal.7:385 build/C/man7/signal.7:387 build/C/man7/signal.7:389 build/C/man7/signal.7:392 build/C/man7/signal.7:394 build/C/man7/signal.7:400 build/C/man7/signal.7:401 build/C/man7/signal.7:403 build/C/man7/signal.7:404 build/C/man7/signal.7:407 build/C/man7/signal.7:409 build/C/man7/signal.7:410 build/C/man7/signal.7:413 build/C/man7/signal.7:414
#, no-wrap
msgid "P1990"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:377
#, no-wrap
msgid "Abort signal from B<abort>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:378 build/C/man7/signal.7:503
#, no-wrap
msgid "SIGALRM"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:378
#, no-wrap
msgid "Timer signal from B<alarm>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:379 build/C/man7/signal.7:495
#, no-wrap
msgid "SIGBUS"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:379 build/C/man7/signal.7:396 build/C/man7/signal.7:398 build/C/man7/signal.7:405 build/C/man7/signal.7:408 build/C/man7/signal.7:412 build/C/man7/signal.7:415 build/C/man7/signal.7:416 build/C/man7/signal.7:418
#, no-wrap
msgid "P2001"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:379
#, no-wrap
msgid "Bus error (bad memory access)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:380 build/C/man7/signal.7:506
#, no-wrap
msgid "SIGCHLD"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:380
#, no-wrap
msgid "Child stopped or terminated"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:381 build/C/man7/signal.7:507
#, no-wrap
msgid "SIGCLD"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:381 build/C/man7/signal.7:383 build/C/man7/signal.7:388 build/C/man7/signal.7:390 build/C/man7/signal.7:391 build/C/man7/signal.7:393 build/C/man7/signal.7:399 build/C/man7/signal.7:402 build/C/man7/signal.7:411 build/C/man7/signal.7:420 build/C/man7/signal.7:496 build/C/man7/signal.7:505 build/C/man7/signal.7:507 build/C/man7/signal.7:522 build/C/man7/signal.7:523 build/C/man7/signal.7:525
#, no-wrap
msgid "-"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:381
#, no-wrap
msgid "A synonym for B<SIGCHLD>"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:382 build/C/man7/signal.7:508
#, no-wrap
msgid "SIGCONT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:382
#, no-wrap
msgid "Continue if stopped"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:383 build/C/man7/signal.7:496
#, no-wrap
msgid "SIGEMT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:383
#, no-wrap
msgid "Emulator trap"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:384 build/C/man7/signal.7:497
#, no-wrap
msgid "SIGFPE"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:384
#, no-wrap
msgid "Floating-point exception"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:385 build/C/man7/signal.7:488
#, no-wrap
msgid "SIGHUP"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:385
#, no-wrap
msgid "Hangup detected on controlling terminal"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:386
#, no-wrap
msgid "or death of controlling process"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:387 build/C/man7/signal.7:491
#, no-wrap
msgid "SIGILL"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:387
#, no-wrap
msgid "Illegal Instruction"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:388 build/C/man7/signal.7:522
#, no-wrap
msgid "SIGINFO"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:388
#, no-wrap
msgid "A synonym for B<SIGPWR>"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:389 build/C/man7/signal.7:489
#, no-wrap
msgid "SIGINT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:389
#, no-wrap
msgid "Interrupt from keyboard"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:390 build/C/man7/signal.7:519
#, no-wrap
msgid "SIGIO"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:390
#, no-wrap
msgid "I/O now possible (4.2BSD)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:391 build/C/man7/signal.7:494
#, no-wrap
msgid "SIGIOT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:391
#, no-wrap
msgid "IOT trap. A synonym for B<SIGABRT>"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:392 build/C/man7/signal.7:498
#, no-wrap
msgid "SIGKILL"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:392
#, no-wrap
msgid "Kill signal"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:393 build/C/man7/signal.7:523
#, no-wrap
msgid "SIGLOST"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:393
#, no-wrap
msgid "File lock lost (unused)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:394 build/C/man7/signal.7:502
#, no-wrap
msgid "SIGPIPE"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:394
#, no-wrap
msgid "Broken pipe: write to pipe with no"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:395
#, no-wrap
msgid "readers; see B<pipe>(7)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:396 build/C/man7/signal.7:520
#, no-wrap
msgid "SIGPOLL"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:396
#, no-wrap
msgid "Pollable event (Sys V);"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:397
#, no-wrap
msgid "synonym for B<SIGIO>"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:398 build/C/man7/signal.7:517
#, no-wrap
msgid "SIGPROF"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:398
#, no-wrap
msgid "Profiling timer expired"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:399 build/C/man7/signal.7:521
#, no-wrap
msgid "SIGPWR"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:399
#, no-wrap
msgid "Power failure (System V)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:400 build/C/man7/signal.7:490
#, no-wrap
msgid "SIGQUIT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:400
#, no-wrap
msgid "Quit from keyboard"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:401 build/C/man7/signal.7:500
#, no-wrap
msgid "SIGSEGV"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:401
#, no-wrap
msgid "Invalid memory reference"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:402 build/C/man7/signal.7:505
#, no-wrap
msgid "SIGSTKFLT"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:402
#, no-wrap
msgid "Stack fault on coprocessor (unused)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:403 build/C/man7/signal.7:509
#, no-wrap
msgid "SIGSTOP"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:403
#, no-wrap
msgid "Stop process"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:404 build/C/man7/signal.7:510
#, no-wrap
msgid "SIGTSTP"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:404
#, no-wrap
msgid "Stop typed at terminal"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:405 build/C/man7/signal.7:524
#, no-wrap
msgid "SIGSYS"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:405
#, no-wrap
msgid "Bad system call (SVr4);"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:406
#, no-wrap
msgid "see also B<seccomp>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:407 build/C/man7/signal.7:504
#, no-wrap
msgid "SIGTERM"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:407
#, no-wrap
msgid "Termination signal"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:408 build/C/man7/signal.7:492
#, no-wrap
msgid "SIGTRAP"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:408
#, no-wrap
msgid "Trace/breakpoint trap"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:409 build/C/man7/signal.7:511
#, no-wrap
msgid "SIGTTIN"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:409
#, no-wrap
msgid "Terminal input for background process"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:410 build/C/man7/signal.7:512
#, no-wrap
msgid "SIGTTOU"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:410
#, no-wrap
msgid "Terminal output for background process"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:411 build/C/man7/signal.7:525
#, no-wrap
msgid "SIGUNUSED"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:411
#, no-wrap
msgid "Synonymous with B<SIGSYS>"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:412 build/C/man7/signal.7:513
#, no-wrap
msgid "SIGURG"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:412
#, no-wrap
msgid "Urgent condition on socket (4.2BSD)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:413 build/C/man7/signal.7:499
#, no-wrap
msgid "SIGUSR1"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:413
#, no-wrap
msgid "User-defined signal 1"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:414 build/C/man7/signal.7:501
#, no-wrap
msgid "SIGUSR2"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:414
#, no-wrap
msgid "User-defined signal 2"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:415 build/C/man7/signal.7:516
#, no-wrap
msgid "SIGVTALRM"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:415
#, no-wrap
msgid "Virtual alarm clock (4.2BSD)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:416 build/C/man7/signal.7:514
#, no-wrap
msgid "SIGXCPU"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:416
#, no-wrap
msgid "CPU time limit exceeded (4.2BSD);"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:417 build/C/man7/signal.7:419
#, no-wrap
msgid "see B<setrlimit>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:418 build/C/man7/signal.7:515
#, no-wrap
msgid "SIGXFSZ"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:418
#, no-wrap
msgid "File size limit exceeded (4.2BSD);"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:420 build/C/man7/signal.7:518
#, no-wrap
msgid "SIGWINCH"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:420
#, no-wrap
msgid "Window resize signal (4.3BSD, Sun)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:428
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:439
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:445
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:449
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:454
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:454
#, no-wrap
msgid "Queueing and delivery semantics for standard signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:457
msgid ""
"If multiple standard signals are pending for a process, the order in which "
"the signals are delivered is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:472
msgid ""
"Standard signals do not queue.  If multiple instances of a standard signal "
"are generated while that signal is blocked, then only one instance of the "
"signal is marked as pending (and the signal will be delivered just once when "
"it is unblocked).  In the case where a standard signal is already pending, "
"the I<siginfo_t> structure (see B<sigaction>(2))  associated with that "
"signal is not overwritten on arrival of subsequent instances of the same "
"signal.  Thus, the process will receive the information associated with the "
"first instance of the signal."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:472
#, no-wrap
msgid "Signal numbering for standard signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:481
msgid ""
"The numeric value for each signal is given in the table below.  As shown in "
"the table, many signals have different numeric values on different "
"architectures.  The first numeric value in each table row shows the signal "
"number on x86, ARM, and most other architectures; the second value is for "
"Alpha and SPARC; the third is for MIPS; and the last is for PARISC.  A dash "
"(-) denotes that a signal is absent on the corresponding architecture."
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "x86/ARM"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "Alpha/"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "MIPS"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486
#, no-wrap
msgid "PARISC"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:486 build/C/man7/signal-safety.7:95
#, no-wrap
msgid "Notes"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:487
#, no-wrap
msgid "most others"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:487
#, no-wrap
msgid "SPARC"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:488
#, no-wrap
msgid "\\01"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:489
#, no-wrap
msgid "\\02"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:490
#, no-wrap
msgid "\\03"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:491
#, no-wrap
msgid "\\04"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:492
#, no-wrap
msgid "\\05"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:493 build/C/man7/signal.7:494
#, no-wrap
msgid "\\06"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:495 build/C/man7/signal.7:496 build/C/man7/signal.7:505
#, no-wrap
msgid "\\07"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:495 build/C/man7/signal.7:499
#, no-wrap
msgid "10"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:497
#, no-wrap
msgid "\\08"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:498
#, no-wrap
msgid "\\09"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:499 build/C/man7/signal.7:514 build/C/man7/signal.7:515 build/C/man7/signal.7:521
#, no-wrap
msgid "30"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:499 build/C/man7/signal.7:505 build/C/man7/signal.7:513
#, no-wrap
msgid "16"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:500
#, no-wrap
msgid "11"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:514 build/C/man7/signal.7:524
#, no-wrap
msgid "12"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:515 build/C/man7/signal.7:524 build/C/man7/signal.7:525
#, no-wrap
msgid "31"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:501 build/C/man7/signal.7:506 build/C/man7/signal.7:509
#, no-wrap
msgid "17"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:502
#, no-wrap
msgid "13"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:503
#, no-wrap
msgid "14"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:504
#, no-wrap
msgid "15"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:506 build/C/man7/signal.7:510 build/C/man7/signal.7:516 build/C/man7/signal.7:518
#, no-wrap
msgid "20"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:506 build/C/man7/signal.7:507 build/C/man7/signal.7:508 build/C/man7/signal.7:510
#, no-wrap
msgid "18"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:509 build/C/man7/signal.7:521
#, no-wrap
msgid "19"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:510 build/C/man7/signal.7:515
#, no-wrap
msgid "25"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:508 build/C/man7/signal.7:511 build/C/man7/signal.7:516
#, no-wrap
msgid "26"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:509 build/C/man7/signal.7:513 build/C/man7/signal.7:518 build/C/man7/signal.7:519
#, no-wrap
msgid "23"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:509 build/C/man7/signal.7:510 build/C/man7/signal.7:514
#, no-wrap
msgid "24"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:511 build/C/man7/signal.7:513 build/C/man7/signal.7:517
#, no-wrap
msgid "21"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:511 build/C/man7/signal.7:512 build/C/man7/signal.7:517
#, no-wrap
msgid "27"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:512 build/C/man7/signal.7:519
#, no-wrap
msgid "22"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:512 build/C/man7/signal.7:516 build/C/man7/signal.7:518
#, no-wrap
msgid "28"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:513 build/C/man7/signal.7:517 build/C/man7/signal.7:519
#, no-wrap
msgid "29"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:520
#, no-wrap
msgid "Same as SIGIO"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:521 build/C/man7/signal.7:522
#, no-wrap
msgid "29/-"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:523
#, no-wrap
msgid "-/29"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:529
msgid "Note the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:537
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS>.  Since glibc 2.26, "
"B<SIGUNUSED> is no longer defined on any architecture."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:544
msgid ""
"Signal 29 is B<SIGINFO>/B<SIGPWR> (synonyms for the same value) on Alpha but "
"B<SIGLOST> on SPARC."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:544
#, no-wrap
msgid "Real-time signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:555
msgid ""
"Starting with version 2.2, Linux supports real-time signals as originally "
"defined in the POSIX.1b real-time extensions (and now included in "
"POSIX.1-2001).  The range of supported real-time signals is defined by the "
"macros B<SIGRTMIN> and B<SIGRTMAX>.  POSIX.1-2001 requires that an "
"implementation support at least B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:577
msgid ""
"The Linux kernel supports a range of 33 different real-time signals, "
"numbered 32 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:581
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined "
"purposes."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:584
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:586
msgid "Real-time signals are distinguished by the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:590
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:610
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2), then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:619
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:624
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:647
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, "
"I</proc/sys/kernel/rtsig-nr>, can be used to find out how many real-time "
"signals are currently queued.  In Linux 2.6.8, these I</proc> interfaces "
"were replaced by the B<RLIMIT_SIGPENDING> resource limit, which specifies a "
"per-user limit for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:655
msgid ""
"The addition of real-time signals required the widening of the signal set "
"structure (I<sigset_t>)  from 32 to 64 bits.  Consequently, various system "
"calls were superseded by new system calls that supported the larger signal "
"sets.  The old and new system calls are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:658
#, no-wrap
msgid "Linux 2.0 and earlier"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:658
#, no-wrap
msgid "Linux 2.2 and later"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:659 build/C/man7/signal-safety.7:204
#, no-wrap
msgid "B<sigaction>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:659
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:660 build/C/man7/signal-safety.7:213
#, no-wrap
msgid "B<sigpending>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:660
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:661 build/C/man7/signal-safety.7:214
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:661
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:662
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:662
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:663
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:664
#, no-wrap
msgid "B<sigtimedwait>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal.7:664
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr ""

#. type: SS
#: build/C/man7/signal.7:667
#, no-wrap
msgid "Interruption of system calls and library functions by signal handlers"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:670
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:672
msgid "the call is automatically restarted after the signal handler returns; or"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:675
msgid "the call fails with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:683
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: build/C/man7/signal.7:692
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call is automatically restarted after the signal "
"handler returns if the B<SA_RESTART> flag was used; otherwise the call fails "
"with the error B<EINTR>:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:708
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  If an I/O "
"call on a slow device has already transferred some data by the time it is "
"interrupted by a signal handler, then the call will return a success status "
"(normally, the number of bytes transferred).  Note that a (local) disk is "
"not a slow device according to this definition; I/O operations on disk "
"devices are not interrupted by signals."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:712
msgid "B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:719
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr ""

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:737
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), "
"unless a timeout has been set on the socket (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:747
msgid ""
"File locking interfaces: B<flock>(2)  and the B<F_SETLKW> and "
"B<F_OFD_SETLKW> operations of B<fcntl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:754
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""

#.  commit 72c1bbf308c75a136803d2d76d0e18258be14c7a
#. type: Plain text
#: build/C/man7/signal.7:761
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:763
msgid "B<getrandom>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:767
msgid "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3), and related APIs."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:770
msgid "B<futex>(2)  B<FUTEX_WAIT_BITSET>."
msgstr ""

#.  as a consequence of the 2.6.22 changes in the futex() implementation
#. type: Plain text
#: build/C/man7/signal.7:779
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: build/C/man7/signal.7:788
msgid ""
"B<read>(2)  from an B<inotify>(7)  file descriptor (since Linux 3.8; "
"beforehand, always failed with B<EINTR>)."
msgstr ""

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: build/C/man7/signal.7:798
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:812 build/C/man7/signal.7:885
msgid ""
"\"Input\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<accept>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2)  (also with a non-NULL I<timeout> argument), "
"and B<recvmsg>(2)."
msgstr ""

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:823
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:830
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:839
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: build/C/man7/signal.7:847
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:853
msgid "Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:855
msgid "B<io_getevents>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:860
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""

#. type: SS
#: build/C/man7/signal.7:860
#, no-wrap
msgid "Interruption of system calls and library functions by stop signals"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:869
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:871
msgid "The Linux interfaces that display this behavior are:"
msgstr ""

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: build/C/man7/signal.7:899
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2), if a send timeout (B<SO_SNDTIMEO>)  has "
"been set."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:902
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:905
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:908
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr ""

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: build/C/man7/signal.7:915
msgid "Linux 3.7 and earlier: B<read>(2)  from an B<inotify>(7)  file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:921
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:925
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:928
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:930
msgid "POSIX.1, except as noted."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:933
msgid "For a discussion of async-signal-safe functions, see B<signal-safety>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:956
msgid ""
"The I</proc/[pid]/task/[tid]/status> file contains various fields that show "
"the signals that a thread is blocking (I<SigBlk>), catching (I<SigCgt>), or "
"ignoring (I<SigIgn>).  (The set of signals that are caught or ignored will "
"be the same across all threads in a process.)  Other fields show the set of "
"pending signals that are directed to the thread (I<SigPnd>)  as well as the "
"set of pending signals that are directed to the process as a whole "
"(I<ShdPnd>).  The corresponding fields in I</proc/[pid]/status> show the "
"information for the main thread.  See B<proc>(5)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:969
msgid ""
"There are six signals that can be delivered as a consequence of a hardware "
"exception: B<SIGBUS>, B<SIGEMT>, B<SIGFPE>, B<SIGILL>, B<SIGSEGV>, and "
"B<SIGTRAP>.  Which of these signals is delivered, for any given hardware "
"exception, is not documented and does not always make sense."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:975
msgid ""
"For example, an invalid memory access that causes delivery of B<SIGSEGV> on "
"one CPU architecture may cause delivery of B<SIGBUS> on another "
"architecture, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:986
msgid ""
"For another example, using the x86 I<int> instruction with a forbidden "
"argument (any number other than 3 or 128)  causes delivery of B<SIGSEGV>, "
"even though B<SIGILL> would make more sense, because of how the CPU reports "
"the forbidden operation to the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/signal.7:1025
msgid ""
"B<kill>(1), B<clone>(2), B<getrlimit>(2), B<kill>(2), "
"B<pidfd_send_signal>(2), B<restart_syscall>(2), B<rt_sigqueueinfo>(2), "
"B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), "
"B<abort>(3), B<bsd_signal>(3), B<killpg>(3), B<longjmp>(3), "
"B<pthread_sigqueue>(3), B<raise>(3), B<sigqueue>(3), B<sigset>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<swapcontext>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), "
"B<pthreads>(7), B<sigevent>(7)"
msgstr ""

#. type: TH
#: build/C/man2/signalfd.2:20
#, no-wrap
msgid "SIGNALFD"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:23
msgid "signalfd - create a file descriptor for accepting signals"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:25
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:27
msgid "B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:38
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:58
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:72
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that file descriptor.  "
"If I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:77
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<signalfd>():"
msgstr ""

#. type: TP
#: build/C/man2/signalfd.2:77
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr ""

#. type: TP
#: build/C/man2/signalfd.2:87
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:104
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:123
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:131
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:142
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:155
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:162
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:167
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:167
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:173
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""

#.  ssi_trapno is unused on most arches
#.  ssi_addr_lsb: commit b8aeec34175fc8fe8b0d40efea4846dfc1ba663e
#. type: Plain text
#: build/C/man2/signalfd.2:202
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* Signal number */\n"
"    int32_t  ssi_errno;    /* Error number (unused) */\n"
"    int32_t  ssi_code;     /* Signal code */\n"
"    uint32_t ssi_pid;      /* PID of sender */\n"
"    uint32_t ssi_uid;      /* Real UID of sender */\n"
"    int32_t  ssi_fd;       /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;     /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;   /* Trap number that caused signal */\n"
"    int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* System CPU time consumed\n"
"                              (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* Address that generated signal\n"
"                              (for hardware-generated signals) */\n"
"    uint16_t ssi_addr_lsb; /* Least significant bit of address\n"
"                              (SIGBUS; since Linux 2.6.37)\n"
"    uint8_t  pad[I<X>];       /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:225
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:225 build/C/man2/timerfd_create.2:389
#, no-wrap
msgid "fork(2) semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:233
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:233
#, no-wrap
msgid "Semantics of file descriptor passing"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:242
msgid ""
"As with other file descriptors, signalfd file descriptors can be passed to "
"another process via a UNIX domain socket (see B<unix>(7)).  In the receiving "
"process, a B<read>(2)  from the received file descriptor will return "
"information about signals queued to that process."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:242 build/C/man2/timerfd_create.2:401
#, no-wrap
msgid "execve(2) semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:254
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:254
#, no-wrap
msgid "Thread semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:265
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:265
#, no-wrap
msgid "epoll(7) semantics"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:291
msgid ""
"If a process adds (via B<epoll_ctl>(2))  a signalfd file descriptor to an "
"B<epoll>(7)  instance, then B<epoll_wait>(2)  returns events only for "
"signals sent to that process.  In particular, if the process then uses "
"B<fork>(2)  to create a child process, then the child will be able to "
"B<read>(2)  signals that are sent to it using the signalfd file descriptor, "
"but B<epoll_wait>(2)  will B<not> indicate that the signalfd file descriptor "
"is ready.  In this scenario, a possible workaround is that after the "
"B<fork>(2), the child process can close the signalfd file descriptor that it "
"inherited from the parent process and then create another signalfd file "
"descriptor and add it to the epoll instance.  Alternatively, the parent and "
"the child could delay creating their (separate) signalfd file descriptors "
"and adding them to the epoll instance until after the call to B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:305
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:311
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr ""

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: build/C/man2/signalfd.2:319
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:326 build/C/man2/timerfd_create.2:437
msgid "I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:339
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/signalfd.2:347
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:352
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:366
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different file descriptors ready.)  If a signal appears in the I<mask> of "
"more than one of the file descriptors, then occurrences of that signal can "
"be read (once) from any one of the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:374
msgid ""
"Attempts to include B<SIGKILL> and B<SIGSTOP> in I<mask> are silently "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:383
msgid ""
"The signal mask employed by a signalfd file descriptor can be viewed via the "
"entry for the corresponding file descriptor in the process's "
"I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/signalfd.2:383
#, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:392
msgid ""
"The signalfd mechanism can't be used to receive signals that are "
"synchronously generated, such as the B<SIGSEGV> signal that results from "
"accessing an invalid memory address or the B<SIGFPE> signal that results "
"from an arithmetic error.  Such signals can be caught only via signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:413
msgid ""
"As described above, in normal usage one blocks the signals that will be "
"accepted via B<signalfd>().  If spawning a child process to execute a helper "
"program (that does not need the signalfd file descriptor), then, after the "
"call to B<fork>(2), you will normally want to unblock those signals before "
"calling B<execve>(2), so that the helper program can see any signals that it "
"expects to see.  Be aware, however, that this won't be possible in the case "
"of a helper program spawned behind the scenes by any library function that "
"the program may call.  In such cases, one must fall back to using a "
"traditional signal handler that writes to a file descriptor monitored by "
"B<select>(2), B<poll>(2), or B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:423
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:439
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: build/C/man2/signalfd.2:447
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:457
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:468
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<\\(haC>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<\\(haC>\n"
"Got SIGINT\n"
"B<\\(ha\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:478
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:489
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:493
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:496
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:499
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:503
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:508
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(fdsi));\n"
"        if (s != sizeof(fdsi))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:519
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/signalfd.2:533
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigpause.3:25
#, no-wrap
msgid "SIGPAUSE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:28
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD (but see NOTES) */>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:35
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:41
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:48
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes "
"the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:56
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""

#. type: tbl table
#: build/C/man3/sigpause.3:66
#, no-wrap
msgid "B<sigpause>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:81
msgid ""
"The System V version of B<sigpause>()  is standardized in POSIX.1-2001.  It "
"is also specified in POSIX.1-2008, where it is marked obsolete."
msgstr ""

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: build/C/man3/sigpause.3:98
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the "
"B<\\%sigsuspend>(2)  function, that takes a I<sigset_t\\ *> argument "
"(instead of an I<int>)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:101
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""

#.  Libc4 and libc5 know only about the BSD version.
#. type: Plain text
#: build/C/man3/sigpause.3:116
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used, and feature test macros must be defined as follows to "
"obtain the declaration:"
msgstr ""

#.  || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man3/sigpause.3:120
msgid "Since glibc 2.26: _XOPEN_SOURCE E<gt>= 500"
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:122
msgid "Glibc 2.25 and earlier: _XOPEN_SOURCE"
msgstr ""

#
#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: build/C/man3/sigpause.3:133
msgid ""
"Since glibc 2.19, only the System V version is exposed by "
"I<E<lt>signal.hE<gt>>; applications that formerly used the BSD B<sigpause>()  "
"should be amended to use B<sigsuspend>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigpause.3:141
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigpending.2:29
#, no-wrap
msgid "SIGPENDING"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:32
msgid "sigpending, rt_sigpending - examine pending signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:36
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:45
msgid "B<sigpending>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:52
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:58
msgid ""
"B<sigpending>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:63
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:65 build/C/man2/sigprocmask.2:130 build/C/man3/sigqueue.3:131 build/C/man3/sigsetops.3:156 build/C/man2/sigsuspend.2:87 build/C/man3/sigwait.3:100 build/C/man2/sigwaitinfo.2:136 build/C/man2/timer_create.2:244 build/C/man2/timer_delete.2:69 build/C/man2/timer_getoverrun.2:99 build/C/man2/timer_settime.2:209
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:73
msgid ""
"If a signal is both blocked and has a disposition of \"ignored\", it is "
"I<not> added to the mask of pending signals when generated."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:78
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""

#.  This argument is currently required to be less than or equal to
#.  .IR sizeof(sigset_t)
#.  (or the error
#.  .B EINVAL
#.  results).
#. type: Plain text
#: build/C/man2/sigpending.2:112
msgid ""
"The original Linux system call was named B<sigpending>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> argument supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigpending>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  The glibc B<sigpending>()  wrapper function hides "
"these details from us, transparently calling B<rt_sigpending>()  when the "
"kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:118
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sigpending.2:126
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigprocmask.2:29
#, no-wrap
msgid "SIGPROCMASK"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:32
msgid "sigprocmask, rt_sigprocmask - examine and change blocked signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:38
#, no-wrap
msgid ""
"/* Prototype for the glibc wrapper function */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t "
"*>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:42
#, no-wrap
msgid ""
"/* Prototype for the underlying system call */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t "
">I<sigsetsize>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:46
#, no-wrap
msgid ""
"/* Prototype for the legacy system call (deprecated) */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:56
msgid "B<sigprocmask>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:65
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:69
msgid "The behavior of the call is dependent on the value of I<how>, as follows."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:69
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:74
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:74
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:80
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""

#. type: TP
#: build/C/man2/sigprocmask.2:80
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:84
msgid "The set of blocked signals is set to the argument I<set>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:89
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:98
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:103
msgid ""
"A set of functions for modifying and inspecting variables of type "
"I<sigset_t> (\"signal sets\") is described in B<sigsetops>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:108
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:114
msgid ""
"B<sigprocmask>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:122
msgid ""
"The I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:128
msgid ""
"Either the value specified in I<how> was invalid or the kernel does not "
"support the size passed in I<sigsetsize.>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:134
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:136
msgid "Each of the threads in a process has its own signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:156
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:167
msgid ""
"Note that it is permissible (although not very useful) to specify both "
"I<set> and I<oldset> as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:177
msgid ""
"The kernel's definition of I<sigset_t> differs in size from that used by the "
"C library.  In this manual page, the former is referred to as "
"I<kernel_sigset_t> (it is nevertheless named I<sigset_t> in the kernel "
"sources)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:185
msgid ""
"The glibc wrapper function for B<sigprocmask>()  silently ignores attempts "
"to block the two real-time signals that are used internally by the NPTL "
"threading implementation.  See B<nptl>(7)  for details."
msgstr ""

#.  sizeof(kernel_sigset_t) == _NSIG / 8,
#.  which equals to 8 on most architectures, but e.g. on MIPS it's 16.
#. type: Plain text
#: build/C/man2/sigprocmask.2:214
msgid ""
"The original Linux system call was named B<sigprocmask>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> (referred to as I<old_kernel_sigset_t> in this manual page)  "
"type supported by that system call was no longer fit for purpose.  "
"Consequently, a new system call, B<rt_sigprocmask>(), was added to support "
"an enlarged I<sigset_t> type (referred to as I<kernel_sigset_t> in this "
"manual page).  The new system call takes a fourth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the signal sets in I<set> "
"and I<oldset>.  This argument is currently required to have a fixed "
"architecture specific value (equal to I<sizeof(kernel_sigset_t)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:221
msgid ""
"The glibc B<sigprocmask>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigprocmask>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigprocmask.2:232
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigqueue.3:28
#, no-wrap
msgid "SIGQUEUE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:31
msgid "sigqueue - queue a signal and data to a process"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:35
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:43
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:55
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID "
"is given in I<pid>.  The permissions required to send a signal are the same "
"as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:60
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:67
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:83
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:91
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:102
msgid "I<sig> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:108
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:112
msgid "No process has a PID matching I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:117
msgid ""
"B<sigqueue>()  and the underlying B<rt_sigqueueinfo>()  system call first "
"appeared in Linux 2.2."
msgstr ""

#. type: tbl table
#: build/C/man3/sigqueue.3:127
#, no-wrap
msgid "B<sigqueue>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:139
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:156
msgid ""
"On Linux, B<sigqueue>()  is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:164
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* Argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* Argument supplied to sigqueue() */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigqueue.3:174
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigreturn.2:30
#, no-wrap
msgid "SIGRETURN"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:33
msgid "sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame"
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:35
msgid "B<int sigreturn(...);>"
msgstr ""

#.  See arch/x86/kernel/signal.c::__setup_frame() [in 3.17 source code]
#. type: Plain text
#: build/C/man2/sigreturn.2:45
msgid ""
"If the Linux kernel determines that an unblocked signal is pending for a "
"process, then, at the next transition back to user mode in that process "
"(e.g., upon return from a system call or when the process is rescheduled "
"onto the CPU), it creates a new frame on the user-space stack where it saves "
"various pieces of process context (processor status word, registers, signal "
"mask, and signal stack settings)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:52
msgid ""
"The kernel also arranges that, during the transition back to user mode, the "
"signal handler is called, and that, upon return from the handler, control "
"passes to a piece of user-space code commonly called the \"signal "
"trampoline\".  The signal trampoline code in turn calls B<sigreturn>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:67
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching signal stacks (see "
"B<sigaltstack>(2))\\(emin order to invoke the signal handler.  Using the "
"information that was earlier saved on the user-space stack B<sigreturn>()  "
"restores the process's signal mask, switches stacks, and restores the "
"process's context (processor flags and registers, including the stack "
"pointer and instruction pointer), so that the process resumes execution at "
"the point where it was interrupted by the signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:70
msgid "B<sigreturn>()  never returns."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:76
msgid ""
"Many UNIX-type systems have a B<sigreturn>()  system call or near "
"equivalent.  However, this call is not specified in POSIX, and details of "
"its behavior vary across systems."
msgstr ""

#.  See sysdeps/unix/sysv/linux/sigreturn.c and
#.  signal/sigreturn.c in the glibc source
#. type: Plain text
#: build/C/man2/sigreturn.2:98
msgid ""
"B<sigreturn>()  exists only to allow the implementation of signal handlers.  "
"It should B<never> be called directly.  (Indeed, a simple B<sigreturn>()  "
"wrapper in the GNU C library simply returns -1, with I<errno> set to "
"B<ENOSYS>.)  Details of the arguments (if any) passed to B<sigreturn>()  "
"vary depending on the architecture.  (On some architectures, such as x86-64, "
"B<sigreturn>()  takes no arguments, since all of the information that it "
"requires is available in the stack frame that was previously created by the "
"kernel on the user-space stack.)"
msgstr ""

#.  See, for example, sysdeps/unix/sysv/linux/i386/sigaction.c and
#.  sysdeps/unix/sysv/linux/x86_64/sigaction.c in the glibc (2.20) source.
#. type: Plain text
#: build/C/man2/sigreturn.2:123
msgid ""
"Once upon a time, UNIX systems placed the signal trampoline code onto the "
"user stack.  Nowadays, pages of the user stack are protected so as to "
"disallow code execution.  Thus, on contemporary Linux systems, depending on "
"the architecture, the signal trampoline code lives either in the B<vdso>(7)  "
"or in the C library.  In the latter case, the C library's B<sigaction>(2)  "
"wrapper function informs the kernel of the location of the trampoline code "
"by placing its address in the I<sa_restorer> field of the I<sigaction> "
"structure, and sets the B<SA_RESTORER> flag in the I<sa_flags> field."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:134
msgid ""
"The saved process context information is placed in a I<ucontext_t> structure "
"(see I<E<lt>sys/ucontext.hE<gt>>).  That structure is visible within the "
"signal handler as the third argument of a handler established via "
"B<sigaction>(2)  with the B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:143
msgid ""
"On some other UNIX systems, the operation of the signal trampoline differs a "
"little.  In particular, on some systems, upon transitioning back to user "
"mode, the kernel passes control to the trampoline (rather than the signal "
"handler), and the trampoline code calls the signal handler (and then calls "
"B<sigreturn>()  once the handler returns)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:157
msgid ""
"The original Linux system call was named B<sigreturn>().  However, with the "
"addition of real-time signals in Linux 2.2, a new system call, "
"B<rt_sigreturn>()  was added to support an enlarged I<sigset_t> type.  The "
"GNU C library hides these details from us, transparently employing "
"B<rt_sigreturn>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigreturn.2:165
msgid ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<getcontext>(3), B<signal>(7), B<vdso>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigset.3:25
#, no-wrap
msgid "SIGSET"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:28
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:34
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:36
msgid "B<int sighold(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:38
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:40
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:51
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/sigset.3:55
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:64
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:73
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one "
"of the following constants:"
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:73
#, no-wrap
msgid "B<SIG_DFL>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:78
msgid "Reset the disposition of I<sig> to the default."
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:78
#, no-wrap
msgid "B<SIG_IGN>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:82
msgid "Ignore I<sig>."
msgstr ""

#. type: TP
#: build/C/man3/sigset.3:82
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:89
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig> "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:95
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:103
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:109 build/C/man3/sigvec.3:89
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:115
msgid "The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:121
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:128
msgid "The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:144
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:153
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:160
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and "
"B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:167
msgid "For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:172
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/sigset.3:183
#, no-wrap
msgid ""
"B<sigset>(),\n"
"B<sighold>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigset.3:183 build/C/man3/sigsetops.3:143 build/C/man3/sigsetops.3:146 build/C/man3/sigsetops.3:149
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigset.3:186
#, no-wrap
msgid ""
"B<sigrelse>(),\n"
"B<sigignore>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:205
msgid ""
"SVr4, POSIX.1-2001, POSIX.1-2008.  These functions are obsolete: do not use "
"them in new programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), "
"B<sigpause>(3), B<sigrelse>(), and B<sigset>()  as obsolete, recommending "
"the use of B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and "
"B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:207
msgid "These functions appeared in glibc version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:213
msgid ""
"The I<sighandler_t> type is a GNU extension; it is used on this page only to "
"make the B<sigset>()  prototype more easily readable."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:221
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:239
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See "
"B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:247 build/C/man3/sigvec.3:279
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:256
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: build/C/man3/sigset.3:281
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""

#. type: Plain text
#: build/C/man3/sigset.3:291
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigsetops.3:31
#, no-wrap
msgid "SIGSETOPS"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:35
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:39
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:41
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:43
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:45
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:47
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:59
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:61
msgid "_POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:65
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:70
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:75
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:83
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:89
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:107
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>(), and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:114
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:123
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:127
msgid "On error, these functions set I<errno> to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:132
msgid "I<signum> is not a valid signal."
msgstr ""

#. type: tbl table
#: build/C/man3/sigsetops.3:143
#, no-wrap
msgid ""
"B<sigemptyset>(),\n"
"B<sigfillset>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigsetops.3:146
#, no-wrap
msgid ""
"B<sigaddset>(),\n"
"B<sigdelset>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigsetops.3:149
#, no-wrap
msgid ""
"B<sigismember>(),\n"
"B<sigisemptyset>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/sigsetops.3:152
#, no-wrap
msgid ""
"B<sigorset>(),\n"
"B<sigandset>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:165
msgid ""
"When creating a filled signal set, the glibc B<sigfillset>()  function does "
"not include the two real-time signals used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: SS
#: build/C/man3/sigsetops.3:165
#, no-wrap
msgid "Glibc extensions"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:171
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then "
"I<E<lt>signal.hE<gt>> exposes three other functions for manipulating signal "
"sets:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:178
#, no-wrap
msgid ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:184
msgid ""
"B<sigisemptyset>()  returns 1 if I<set> contains no signals, and 0 "
"otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:200
msgid ""
"B<sigorset>()  places the union of the sets I<left> and I<right> in "
"I<dest>.  B<sigandset>()  places the intersection of the sets I<left> and "
"I<right> in I<dest>.  Both functions return 0 on success, and -1 on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:203
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""

#. type: Plain text
#: build/C/man3/sigsetops.3:208
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sigsuspend.2:29
#, no-wrap
msgid "SIGSUSPEND"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:32
msgid "sigsuspend, rt_sigsuspend - wait for a signal"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:36
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:45
msgid "B<sigsuspend>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:53
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling thread "
"with the mask given by I<mask> and then suspends the thread until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:62
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:70
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the thread's signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:76
msgid ""
"B<sigsuspend>()  always returns -1, with I<errno> set to indicate the error "
"(normally, B<EINTR>)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:81
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:85
msgid "The call was interrupted by a signal; B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:104
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:136
msgid ""
"The original Linux system call was named B<sigsuspend>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigsuspend>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<mask>.  This argument is currently required to have the "
"value I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigsuspend>()  wrapper function hides these details from us, transparently "
"calling B<rt_sigsuspend>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigsuspend.2:146
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigvec.3:25
#, no-wrap
msgid "SIGVEC"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:28
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:32
msgid ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:34
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:36
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:38
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:40
msgid "B<int siggetmask(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:51
#, no-wrap
msgid ""
"All functions shown above:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:58
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:83
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-null pointer for I<ovec>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:93
msgid "The I<sigvec> structure has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:101
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* Signal disposition */\n"
"    int    sv_mask;          /* Signals to be blocked in handler */\n"
"    int    sv_flags;         /* Flags */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:112
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; B<SIG_DFL>, meaning the "
"default disposition applies for the signal; or B<SIG_IGN>, meaning that the "
"signal is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:126
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also "
"blocked.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:133
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:133
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:141
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call s not be restarted: instead it fails with "
"the error B<EINTR>.  If this flag is not specified, then system calls are "
"restarted by default."
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:141
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:150
msgid ""
"Reset the disposition of the signal to the default before calling the signal "
"handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man3/sigvec.3:150
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:157
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:167
msgid ""
"The B<sigmask>()  macro constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to "
"B<sigvec>()  using code such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:173
#, no-wrap
msgid ""
"vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"            /* Block SIGQUIT and SIGABRT during\n"
"               handler execution */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:189
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:197
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:203
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:209
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:215
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:220
msgid "The B<sigmask>()  macro returns the signal mask for I<signum>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:225
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:232
msgid ""
"Starting with version 2.21, the GNU C library no longer exports the "
"B<sigvec>()  function as part of the ABI.  (To ensure backward "
"compatibility, the glibc symbol versioning scheme continues to export the "
"interface to binaries linked against older versions of the library.)"
msgstr ""

#. type: tbl table
#: build/C/man3/sigvec.3:246
#, no-wrap
msgid ""
"B<sigvec>(),\n"
"B<sigmask>(),\n"
"B<sigblock>(),\n"
"B<sigsetmask>(),\n"
"B<siggetmask>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:254
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:271
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, "
"B<signal>()  provides unreliable semantics.  POSIX.1 leaves these aspects of "
"B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigvec.3:289
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sigwait.3:26
#, no-wrap
msgid "SIGWAIT"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:29
msgid "sigwait - wait for a signal"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:34
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:43
msgid "B<sigwait>():"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:46
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:49
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:62
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"one of the signals specified in the signal set I<set> becomes pending.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:68
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except "
"that:"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:73
msgid ""
"B<sigwait>()  returns only the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:75
msgid "The return values of the two functions are different."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:80
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""

#.  Does not occur for glibc.
#. type: Plain text
#: build/C/man3/sigwait.3:86
msgid "I<set> contains an invalid signal number."
msgstr ""

#. type: tbl table
#: build/C/man3/sigwait.3:96
#, no-wrap
msgid "B<sigwait>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:104
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:112
msgid ""
"The glibc implementation of B<sigwait>()  silently ignores attempts to wait "
"for the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:115
msgid "See B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/sigwait.3:123
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sigwaitinfo.2:25
#, no-wrap
msgid "SIGWAITINFO"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:29
msgid ""
"sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued "
"signals"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:34
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:37
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<,>\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:47
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:57
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is pending (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:69
msgid ""
"B<sigwaitinfo>()  removes the signal from the set of pending signals and "
"returns the signal number as its function result.  If the I<info> argument "
"is not NULL, then the buffer that it points to is used to return a structure "
"of type I<siginfo_t> (see B<sigaction>(2))  containing information about the "
"signal."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:77
msgid ""
"If multiple signals in I<set> are pending for the caller, the signal that is "
"retrieved by B<sigwaitinfo>()  is determined according to the usual ordering "
"rules; see B<signal>(7)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:89
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies the "
"interval for which the thread is suspended waiting for a signal.  (This "
"interval will be rounded up to the system clock granularity, and kernel "
"scheduling delays mean that the interval may overrun by a small amount.)  "
"This argument is of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:96
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:106
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:115
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:124
msgid ""
"No signal in I<set> was became pending within the I<timeout> period "
"specified to B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:130
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:134
msgid "I<timeout> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:154
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they become pending between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads, in order to prevent the signal being treated according to its "
"default disposition in a thread other than the one calling B<sigwaitinfo>()  "
"or B<sigtimedwait>())."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:159
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:165
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:174
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it becomes pending for the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:186
msgid ""
"B<sigwaitinfo>()  or B<sigtimedwait>(), can't be used to receive signals "
"that are synchronously generated, such as the B<SIGSEGV> signal that results "
"from accessing an invalid memory address or the B<SIGFPE> signal that "
"results from an arithmetic error.  Such signals can be caught only via "
"signal handler."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:196
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:201
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:211
msgid ""
"The glibc wrapper functions for B<sigwaitinfo>()  and B<sigtimedwait>()  "
"silently ignore attempts to wait for the two real-time signals that are used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:238
msgid ""
"The original Linux system call was named B<sigtimedwait>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigtimedwait>(), was added "
"to support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  This argument is currently required to have the value "
"I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigtimedwait>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigtimedwait>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:250
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sysv_signal.3:25
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:28
msgid "sysv_signal - signal handling with System V semantics"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:30
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:36
msgid "B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:41
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:51
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics, "
"that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:57
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: tbl table
#: build/C/man3/sysv_signal.3:70
#, no-wrap
msgid "B<sysv_signal>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:74
msgid "This function is nonstandard."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:80
msgid "Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:91
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were "
"equivalent.  But on newer systems, B<signal>(2)  provides reliable signal "
"semantics; see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/sysv_signal.3:104
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_create.2:26
#, no-wrap
msgid "TIMER_CREATE"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:29
msgid "timer_create - create a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:33
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:36
#, no-wrap
msgid ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:39 build/C/man2/timer_delete.2:37 build/C/man2/timer_getoverrun.2:37 build/C/man2/timer_settime.2:41
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:47
msgid "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:55
msgid ""
"B<timer_create>()  creates a new per-process interval timer.  The ID of the "
"new timer is returned in the buffer pointed to by I<timerid>, which must be "
"a non-null pointer.  This ID is unique within the process, until the timer "
"is deleted.  The new timer is initially disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:60
msgid ""
"The I<clockid> argument specifies the clock that the new timer uses to "
"measure time.  It can be specified as one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:60 build/C/man2/timerfd_create.2:67
#, no-wrap
msgid "B<CLOCK_REALTIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:63 build/C/man2/timerfd_create.2:70
msgid "A settable system-wide real-time clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:63 build/C/man2/timerfd_create.2:70
#, no-wrap
msgid "B<CLOCK_MONOTONIC>"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:70 build/C/man2/timerfd_create.2:75
msgid ""
"A nonsettable monotonically increasing clock that measures time from some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:70
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:74
msgid ""
"A clock that measures (user and system) CPU time consumed by (all of the "
"threads in) the calling process."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:74
#, no-wrap
msgid "B<CLOCK_THREAD_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#.  The CLOCK_MONOTONIC_RAW that was added in 2.6.28 can't be used
#.  to create a timer -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:80
msgid ""
"A clock that measures (user and system) CPU time consumed by the calling "
"thread."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:80
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 2.6.39)"
msgstr ""

#.     commit 4a2378a943f09907fb1ae35c15de917f60289c14
#. type: Plain text
#: build/C/man2/timer_create.2:95 build/C/man2/timerfd_create.2:90
msgid ""
"Like B<CLOCK_MONOTONIC>, this is a monotonically increasing clock.  However, "
"whereas the B<CLOCK_MONOTONIC> clock does not measure the time while a "
"system is suspended, the B<CLOCK_BOOTTIME> clock does include the time "
"during which the system is suspended.  This is useful for applications that "
"need to be suspend-aware.  B<CLOCK_REALTIME> is not suitable for such "
"applications, since that clock is affected by discontinuous changes to the "
"system clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:95
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.0)"
msgstr ""

#.  commit 11ffa9d6065f344a9bd769a2452f26f2f671e5f8
#. type: Plain text
#: build/C/man2/timer_create.2:104 build/C/man2/timerfd_create.2:99
msgid ""
"This clock is like B<CLOCK_REALTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:104
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.0)"
msgstr ""

#.  commit 11ffa9d6065f344a9bd769a2452f26f2f671e5f8
#. type: Plain text
#: build/C/man2/timer_create.2:113 build/C/man2/timerfd_create.2:108
msgid ""
"This clock is like B<CLOCK_BOOTTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:113
#, no-wrap
msgid "B<CLOCK_TAI> (since Linux 3.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:116
msgid "A system-wide clock derived from wall-clock time but ignoring leap seconds."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:120 build/C/man2/timerfd_create.2:112
msgid "See B<clock_getres>(2)  for some further details on the above clocks."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:129
msgid ""
"As well as the above values, I<clockid> can be specified as the I<clockid> "
"returned by a call to B<clock_getcpuclockid>(3)  or "
"B<pthread_getcpuclockid>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:138
msgid ""
"The I<sevp> argument points to a I<sigevent> structure that specifies how "
"the caller should be notified when the timer expires.  For the definition "
"and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:142
msgid "The I<sevp.sigev_notify> field can have the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:147
msgid ""
"Don't asynchronously notify when the timer expires.  Progress of the timer "
"can be monitored using B<timer_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:165
msgid ""
"Upon timer expiration, generate the signal I<sigev_signo> for the process.  "
"See B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_TIMER>.  At any point in time, at "
"most one signal is queued to the process for a given timer; see "
"B<timer_getoverrun>(2)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:173
msgid ""
"Upon timer expiration, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:187
msgid ""
"As for B<SIGEV_SIGNAL>, but the signal is targeted at the thread whose ID is "
"given in I<sigev_notify_thread_id>, which must be a thread in the same "
"process as the caller.  The I<sigev_notify_thread_id> field specifies a "
"kernel thread ID, that is, the value returned by B<clone>(2)  or "
"B<gettid>(2).  This flag is intended only for use by threading libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:202
msgid ""
"Specifying I<sevp> as NULL is equivalent to specifying a pointer to a "
"I<sigevent> structure in which I<sigev_notify> is B<SIGEV_SIGNAL>, "
"I<sigev_signo> is B<SIGALRM>, and I<sigev_value.sival_int> is the timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:210
msgid ""
"On success, B<timer_create>()  returns 0, and the ID of the new timer is "
"placed in I<*timerid>.  On failure, -1 is returned, and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:214
msgid "Temporary error during kernel allocation of timer structures."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:222
msgid ""
"Clock ID, I<sigev_notify>, I<sigev_signo>, or I<sigev_notify_thread_id> is "
"invalid."
msgstr ""

#.  glibc layer: malloc()
#. type: Plain text
#: build/C/man2/timer_create.2:226
msgid "Could not allocate memory."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:226
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:230
msgid "The kernel does not support creating a timer against this I<clockid>."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:240 build/C/man2/timerfd_create.2:460
msgid ""
"I<clockid> was B<CLOCK_REALTIME_ALARM> or B<CLOCK_BOOTTIME_ALARM> but the "
"caller did not have the B<CAP_WAKE_ALARM> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:242 build/C/man2/timer_delete.2:67 build/C/man2/timer_getoverrun.2:97
msgid "This system call is available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:247
msgid "A program may create multiple interval timers using B<timer_create>()."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:252
msgid ""
"Timers are not inherited by the child of a B<fork>(2), and are disarmed and "
"deleted during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:260
msgid ""
"The kernel preallocates a \"queued real-time signal\" for each timer created "
"using B<timer_create>().  Consequently, the number of timers is limited by "
"the B<RLIMIT_SIGPENDING> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:265
msgid ""
"The timers created by B<timer_create>()  are commonly known as \"POSIX "
"(interval) timers\".  The POSIX timers API consists of the following "
"interfaces:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:268
msgid "B<timer_create>(): Create a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:271
msgid "B<timer_settime>(2): Arm (start) or disarm (stop) a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:275
msgid ""
"B<timer_gettime>(2): Fetch the time remaining until the next expiration of a "
"timer, along with the interval setting of the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:278
msgid ""
"B<timer_getoverrun>(2): Return the overrun count for the last timer "
"expiration."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:281
msgid "B<timer_delete>(2): Disarm and delete a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:289
msgid ""
"Since Linux 3.10, the I</proc/[pid]/timers> file can be used to list the "
"POSIX timers for the process with PID I<pid>.  See B<proc>(5)  for further "
"information."
msgstr ""

#.  baa73d9e478ff32d62f3f9422822b59dd9a95a21
#. type: Plain text
#: build/C/man2/timer_create.2:297
msgid ""
"Since Linux 4.10, support for POSIX timers is a configurable option that is "
"enabled by default.  Kernel support can be disabled via the "
"B<CONFIG_POSIX_TIMERS> option."
msgstr ""

#.  See nptl/sysdeps/unix/sysv/linux/timer_create.c
#. type: Plain text
#: build/C/man2/timer_create.2:301
msgid ""
"Part of the implementation of the POSIX timers API is provided by glibc.  In "
"particular:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:315
msgid ""
"Much of the functionality for B<SIGEV_THREAD> is implemented within glibc, "
"rather than the kernel.  (This is necessarily so, since the thread involved "
"in handling the notification is one that must be managed by the C library "
"POSIX threads implementation.)  Although the notification delivered to the "
"process is via a thread, internally the NPTL implementation uses a "
"I<sigev_notify> value of B<SIGEV_THREAD_ID> along with a real-time signal "
"that is reserved by the implementation (see B<nptl>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:322
msgid ""
"The implementation of the default case where I<evp> is NULL is handled "
"inside glibc, which invokes the underlying system call with a suitably "
"populated I<sigevent> structure."
msgstr ""

#.  See the glibc source file kernel-posix-timers.h for the structure
#.  that glibc uses to map user-space timer IDs to kernel timer IDs
#.  The kernel-level timer ID is exposed via siginfo.si_tid.
#. type: Plain text
#: build/C/man2/timer_create.2:328
msgid ""
"The timer IDs presented at user level are maintained by glibc, which maps "
"these IDs to the timer IDs employed by the kernel."
msgstr ""

#.  glibc commit 93a78ac437ba44f493333d7e2a4b0249839ce460
#. type: Plain text
#: build/C/man2/timer_create.2:338
msgid ""
"The POSIX timers system calls first appeared in Linux 2.6.  Prior to this, "
"glibc provided an incomplete user-space implementation (B<CLOCK_REALTIME> "
"timers only) using POSIX threads, and in glibc versions before 2.17, the "
"implementation falls back to this technique on systems running pre-2.6 Linux "
"kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:350
msgid ""
"The program below takes two arguments: a sleep period in seconds, and a "
"timer frequency in nanoseconds.  The program establishes a handler for the "
"signal it uses for the timer, blocks that signal, creates and arms a timer "
"that expires with the given frequency, sleeps for the specified number of "
"seconds, and then unblocks the timer signal.  Assuming that the timer "
"expired at least once while the program slept, the signal handler will be "
"invoked, and the handler displays some information about the timer "
"notification.  The program terminates after one invocation of the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:355
msgid ""
"In the following example run, the program sleeps for 1 second, after "
"creating a timer that has a frequency of 100 nanoseconds.  By the time the "
"signal is unblocked and delivered, there have been around ten million "
"overruns."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:367
#, no-wrap
msgid ""
"$ B<./a.out 1 100>\n"
"Establishing handler for signal 34\n"
"Blocking signal 34\n"
"timer ID is 0x804c008\n"
"Sleeping for 1 seconds\n"
"Unblocking signal 34\n"
"Caught signal 34\n"
"    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008\n"
"    overrun count = 10004886\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:378
#, no-wrap
msgid ""
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:381
#, no-wrap
msgid ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:384
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:390
#, no-wrap
msgid ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:392
#, no-wrap
msgid "    tidp = si-E<gt>si_value.sival_ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:395
#, no-wrap
msgid ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = %#jx\\en\", (uintmax_t) *tidp);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:402
#, no-wrap
msgid ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:411
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:416
#, no-wrap
msgid ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:426
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:432
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> "
"E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:434
#, no-wrap
msgid "    /* Establish handler for timer signal */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:441
#, no-wrap
msgid ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:443
#, no-wrap
msgid "    /* Block timer signal temporarily */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:449
#, no-wrap
msgid ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:451
#, no-wrap
msgid "    /* Create the timer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:457
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:459
#, no-wrap
msgid "    printf(\"timer ID is %#jx\\en\", (uintmax_t) timerid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:461
#, no-wrap
msgid "    /* Start the timer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:467
#, no-wrap
msgid ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:470
#, no-wrap
msgid ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:473
#, no-wrap
msgid ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:476
#, no-wrap
msgid ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:479
#, no-wrap
msgid ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:483
#, no-wrap
msgid ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:486 build/C/man2/timerfd_create.2:715
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:502
msgid ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_settime>(2), B<timerfd_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_getcpuclockid>(3), B<pthreads>(7), "
"B<sigevent>(7), B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_delete.2:26
#, no-wrap
msgid "TIMER_DELETE"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:29
msgid "timer_delete - delete a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:32 build/C/man2/timer_getoverrun.2:32 build/C/man2/timer_settime.2:33
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:34
#, no-wrap
msgid "B<int timer_delete(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:45
msgid "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:53
msgid ""
"B<timer_delete>()  deletes the timer whose ID is given in I<timerid>.  If "
"the timer was armed at the time of this call, it is disarmed before being "
"deleted.  The treatment of any pending signal generated by the deleted timer "
"is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:60
msgid ""
"On success, B<timer_delete>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:65 build/C/man2/timer_getoverrun.2:95
msgid "I<timerid> is not a valid timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:75
msgid ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_getoverrun.2:26
#, no-wrap
msgid "TIMER_GETOVERRUN"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:29
msgid "timer_getoverrun - get overrun count for a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:34
#, no-wrap
msgid "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:45
msgid "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:56
msgid ""
"B<timer_getoverrun>()  returns the \"overrun count\" for the timer referred "
"to by I<timerid>.  An application can use the overrun count to accurately "
"calculate the number of timer expirations that would have occurred over a "
"given time interval.  Timer overruns can occur both when receiving "
"expiration notifications via signals (B<SIGEV_SIGNAL>), and via threads "
"(B<SIGEV_THREAD>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:76
msgid ""
"When expiration notifications are delivered via a signal, overruns can occur "
"as follows.  Regardless of whether or not a real-time signal is used for "
"timer notifications, the system queues at most one signal per timer.  (This "
"is the behavior specified by POSIX.1.  The alternative, queuing one signal "
"for each timer expiration, could easily result in overflowing the allowed "
"limits for queued signals on the system.)  Because of system scheduling "
"delays, or because the signal may be temporarily blocked, there can be a "
"delay between the time when the notification signal is generated and the "
"time when it is delivered (e.g., caught by a signal handler) or accepted "
"(e.g., using B<sigwaitinfo>(2)).  In this interval, further timer "
"expirations may occur.  The timer overrun count is the number of additional "
"timer expirations that occurred between the time when the signal was "
"generated and when it was delivered or accepted."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:82
msgid ""
"Timer overruns can also occur when expiration notifications are delivered "
"via invocation of a thread, since there may be an arbitrary delay between an "
"expiration of the timer and the invocation of the notification thread, and "
"in that delay interval, additional timer expirations may occur."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:90
msgid ""
"On success, B<timer_getoverrun>()  returns the overrun count of the "
"specified timer; this count may be 0 if no overruns have occurred.  On "
"failure, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:111
msgid ""
"When timer notifications are delivered via signals (B<SIGEV_SIGNAL>), on "
"Linux it is also possible to obtain the overrun count via the I<si_overrun> "
"field of the I<siginfo_t> structure (see B<sigaction>(2)).  This allows an "
"application to avoid the overhead of making a system call to obtain the "
"overrun count, but is a nonportable extension to POSIX.1."
msgstr ""

#.  FIXME . Austin bug filed, 11 Feb 09
#.  https://www.austingroupbugs.net/view.php?id=95
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:116
msgid ""
"POSIX.1 discusses timer overruns only in the context of timer notifications "
"using signals."
msgstr ""

#.  http://bugzilla.kernel.org/show_bug.cgi?id=12665
#.  commit 78c9c4dfbf8c04883941445a195276bb4bb92c76
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:138
msgid ""
"POSIX.1 specifies that if the timer overrun count is equal to or greater "
"than an implementation-defined maximum, B<DELAYTIMER_MAX>, then "
"B<timer_getoverrun>()  should return B<DELAYTIMER_MAX>.  However, before "
"Linux 4.19, if the timer overrun value exceeds the maximum representable "
"integer, the counter cycles, starting once more from low values.  Since "
"Linux 4.19, B<timer_getoverrun>()  returns B<DELAYTIMER_MAX> (defined as "
"B<INT_MAX> in I<E<lt>limits.hE<gt>>)  in this case (and the overrun value is "
"reset to 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:141 build/C/man2/timer_settime.2:212
msgid "See B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:151
msgid ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timer_settime.2:26
#, no-wrap
msgid "TIMER_SETTIME"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:30
msgid ""
"timer_settime, timer_gettime - arm/disarm and fetch state of POSIX "
"per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:38
#, no-wrap
msgid ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec *>I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec "
"*>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:50
msgid "B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:63
msgid ""
"B<timer_settime>()  arms or disarms the timer identified by I<timerid>.  The "
"I<new_value> argument is pointer to an I<itimerspec> structure that "
"specifies the new initial value and the new interval for the timer.  The "
"I<itimerspec> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:70 build/C/man2/timerfd_create.2:165
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:75
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:87
msgid ""
"Each of the substructures of the I<itimerspec> structure is a I<timespec> "
"structure that allows a time value to be specified in seconds and "
"nanoseconds.  These time values are measured according to the clock that was "
"specified when the timer was created by B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:101
msgid ""
"If I<new_value-E<gt>it_value> specifies a nonzero value (i.e., either "
"subfield is nonzero), then B<timer_settime>()  arms (starts) the timer, "
"setting it to initially expire at the given time.  (If the timer was already "
"armed, then the previous settings are overwritten.)  If "
"I<new_value-E<gt>it_value> specifies a zero value (i.e., both subfields are "
"zero), then the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:113
msgid ""
"The I<new_value-E<gt>it_interval> field specifies the period of the timer, "
"in seconds and nanoseconds.  If this field is nonzero, then each time that "
"an armed timer expires, the timer is reloaded from the value specified in "
"I<new_value-E<gt>it_interval>.  If I<new_value-E<gt>it_interval> specifies a "
"zero value, then the timer expires just once, at the time specified by "
"I<it_value>."
msgstr ""

#.  By experiment: the overrun count is set correctly, for CLOCK_REALTIME.
#. type: Plain text
#: build/C/man2/timer_settime.2:134
msgid ""
"By default, the initial expiration time specified in "
"I<new_value-E<gt>it_value> is interpreted relative to the current time on "
"the timer's clock at the time of the call.  This can be modified by "
"specifying B<TIMER_ABSTIME> in I<flags>, in which case "
"I<new_value-E<gt>it_value> is interpreted as an absolute value as measured "
"on the timer's clock; that is, the timer will expire when the clock value "
"reaches the value specified by I<new_value-E<gt>it_value>.  If the specified "
"absolute time has already passed, then the timer expires immediately, and "
"the overrun count (see B<timer_getoverrun>(2))  will be set correctly."
msgstr ""

#.  Similar remarks might apply with respect to process and thread CPU time
#.  clocks, but these clocks are not currently (2.6.28) settable on Linux.
#. type: Plain text
#: build/C/man2/timer_settime.2:144
msgid ""
"If the value of the B<CLOCK_REALTIME> clock is adjusted while an absolute "
"timer based on that clock is armed, then the expiration of the timer will be "
"appropriately adjusted.  Adjustments to the B<CLOCK_REALTIME> clock have no "
"effect on relative timers based on that clock."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:153
msgid ""
"If I<old_value> is not NULL, then it points to a buffer that is used to "
"return the previous interval of the timer (in I<old_value-E<gt>it_interval>)  "
"and the amount of time until the timer would previously have next expired "
"(in I<old_value-E<gt>it_value>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:173
msgid ""
"B<timer_gettime>()  returns the time until next expiration, and the "
"interval, for the timer specified by I<timerid>, in the buffer pointed to by "
"I<curr_value>.  The time remaining until the next timer expiration is "
"returned in I<curr_value-E<gt>it_value>; this is always a relative value, "
"regardless of whether the B<TIMER_ABSTIME> flag was used when arming the "
"timer.  If the value returned in I<curr_value-E<gt>it_value> is zero, then "
"the timer is currently disarmed.  The timer interval is returned in "
"I<curr_value-E<gt>it_interval>.  If the value returned in "
"I<curr_value-E<gt>it_interval> is zero, then this is a \"one-shot\" timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:182
msgid ""
"On success, B<timer_settime>()  and B<timer_gettime>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:184
msgid "These functions may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:191
msgid "I<new_value>, I<old_value>, or I<curr_value> is not a valid pointer."
msgstr ""

#.  FIXME . eventually: invalid value in flags
#. type: Plain text
#: build/C/man2/timer_settime.2:196
msgid "I<timerid> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:199
msgid "B<timer_settime>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:205
msgid ""
"I<new_value.it_value> is negative; or I<new_value.it_value.tv_nsec> is "
"negative or greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:207
msgid "These system calls are available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:216
msgid "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/timerfd_create.2:19
#, no-wrap
msgid "TIMERFD_CREATE"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:23
msgid ""
"timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via "
"file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:26
#, no-wrap
msgid "B<#include E<lt>sys/timerfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:28
#, no-wrap
msgid "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:32
#, no-wrap
msgid ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:34
#, no-wrap
msgid "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:47
msgid ""
"These system calls create and operate on a timer that delivers timer "
"expiration notifications via a file descriptor.  They provide an alternative "
"to the use of B<setitimer>(2)  or B<timer_create>(2), with the advantage "
"that the file descriptor may be monitored by B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:59
msgid ""
"The use of these three system calls is analogous to the use of "
"B<timer_create>(2), B<timer_settime>(2), and B<timer_gettime>(2).  (There is "
"no analog of B<timer_getoverrun>(2), since that functionality is provided by "
"B<read>(2), as described below.)"
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:59
#, no-wrap
msgid "timerfd_create()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:67
msgid ""
"B<timerfd_create>()  creates a new timer object, and returns a file "
"descriptor that refers to that timer.  The I<clockid> argument specifies the "
"clock that is used to mark the progress of the timer, and must be one of the "
"following:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:75
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 3.15)"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:90
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.11)"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:99
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:115
msgid ""
"The current value of each of these clocks can be retrieved using "
"B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:120
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<timerfd_create>():"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:120
#, no-wrap
msgid "B<TFD_NONBLOCK>"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:130
#, no-wrap
msgid "B<TFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:144
msgid ""
"In Linux versions up to and including 2.6.26, I<flags> must be specified as "
"zero."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:144
#, no-wrap
msgid "timerfd_settime()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:149
msgid ""
"B<timerfd_settime>()  arms (starts) or disarms (stops)  the timer referred "
"to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:158
msgid ""
"The I<new_value> argument specifies the initial expiration and interval for "
"the timer.  The I<itimerspec> structure used for this argument contains two "
"fields, each of which is in turn a structure of type I<timespec>:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:170
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:182
msgid ""
"I<new_value.it_value> specifies the initial expiration of the timer, in "
"seconds and nanoseconds.  Setting either field of I<new_value.it_value> to a "
"nonzero value arms the timer.  Setting both fields of I<new_value.it_value> "
"to zero disarms the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:191
msgid ""
"Setting one or both fields of I<new_value.it_interval> to nonzero values "
"specifies the period, in seconds and nanoseconds, for repeated timer "
"expirations after the initial expiration.  If both fields of "
"I<new_value.it_interval> are zero, the timer expires just once, at the time "
"specified by I<new_value.it_value>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:203
msgid ""
"By default, the initial expiration time specified in I<new_value> is "
"interpreted relative to the current time on the timer's clock at the time of "
"the call (i.e., I<new_value.it_value> specifies a time relative to the "
"current value of the clock specified by I<clockid>).  An absolute timeout "
"can be selected via the I<flags> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:207
msgid "The I<flags> argument is a bit mask that can include the following values:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:207
#, no-wrap
msgid "B<TFD_TIMER_ABSTIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:215
msgid ""
"Interpret I<new_value.it_value> as an absolute value on the timer's clock.  "
"The timer will expire when the value of the timer's clock reaches the value "
"specified in I<new_value.it_value>."
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:215
#, no-wrap
msgid "B<TFD_TIMER_CANCEL_ON_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:232
msgid ""
"If this flag is specified along with B<TFD_TIMER_ABSTIME> and the clock for "
"this timer is B<CLOCK_REALTIME> or B<CLOCK_REALTIME_ALARM>, then mark this "
"timer as cancelable if the real-time clock undergoes a discontinuous change "
"(B<settimeofday>(2), B<clock_settime>(2), or similar).  When such changes "
"occur, a current or future B<read>(2)  from the file descriptor will fail "
"with the error B<ECANCELED>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:243
msgid ""
"If the I<old_value> argument is not NULL, then the I<itimerspec> structure "
"that it points to is used to return the setting of the timer that was "
"current at the time of the call; see the description of B<timerfd_gettime>()  "
"following."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:243
#, no-wrap
msgid "timerfd_gettime()"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:252
msgid ""
"B<timerfd_gettime>()  returns, in I<curr_value>, an I<itimerspec> structure "
"that contains the current setting of the timer referred to by the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:262
msgid ""
"The I<it_value> field returns the amount of time until the timer will next "
"expire.  If both fields of this structure are zero, then the timer is "
"currently disarmed.  This field always contains a relative value, regardless "
"of whether the B<TFD_TIMER_ABSTIME> flag was specified when setting the "
"timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:269
msgid ""
"The I<it_interval> field returns the interval of the timer.  If both fields "
"of this structure are zero, then the timer is set to expire just once, at "
"the time specified by I<curr_value.it_value>."
msgstr ""

#. type: SS
#: build/C/man2/timerfd_create.2:269
#, no-wrap
msgid "Operating on a timer file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:273
msgid ""
"The file descriptor returned by B<timerfd_create>()  supports the following "
"additional operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:287
msgid ""
"If the timer has already expired one or more times since its settings were "
"last modified using B<timerfd_settime>(), or since the last successful "
"B<read>(2), then the buffer given to B<read>(2)  returns an unsigned 8-byte "
"integer (I<uint64_t>)  containing the number of expirations that have "
"occurred.  (The returned value is in host byte order\\(emthat is, the native "
"byte order for integers on the host machine.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:300
msgid ""
"If no timer expirations have occurred at the time of the B<read>(2), then "
"the call either blocks until the next timer expiration, or fails with the "
"error B<EAGAIN> if the file descriptor has been made nonblocking (via the "
"use of the B<fcntl>(2)  B<F_SETFL> operation to set the B<O_NONBLOCK> flag)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:306
msgid ""
"A B<read>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:324
msgid ""
"If the associated clock is either B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM>, the timer is absolute (B<TFD_TIMER_ABSTIME>), and "
"the flag B<TFD_TIMER_CANCEL_ON_SET> was specified when calling "
"B<timerfd_settime>(), then B<read>(2)  fails with the error B<ECANCELED> if "
"the real-time clock undergoes a discontinuous change.  (This allows the "
"reading application to discover such discontinuous changes to the clock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:346
msgid ""
"If the associated clock is either B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM>, the timer is absolute (B<TFD_TIMER_ABSTIME>), and "
"the flag B<TFD_TIMER_CANCEL_ON_SET> was I<not> specified when calling "
"B<timerfd_settime>(), then a discontinuous negative change to the clock "
"(e.g., B<clock_settime>(2))  may cause B<read>(2)  to unblock, but return a "
"value of 0 (i.e., no bytes read), if the clock change occurs after the time "
"expired, but before the B<read>(2)  on the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:357
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more timer expirations have occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:364
msgid ""
"The file descriptor also supports the other file-descriptor multiplexing "
"APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:364
#, no-wrap
msgid "B<ioctl>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:367
msgid "The following timerfd-specific command is supported:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:368
#, no-wrap
msgid "B<TFD_IOC_SET_TICKS> (since Linux 3.17)"
msgstr ""

#.  commit 5442e9fbd7c23172a1c9bc736629cd123a9923f0
#. type: Plain text
#: build/C/man2/timerfd_create.2:381
msgid ""
"Adjust the number of timer expirations that have occurred.  The argument is "
"a pointer to a nonzero 8-byte integer (I<uint64_t>*)  containing the new "
"number of expirations.  Once the number is set, any waiter on the timer is "
"woken up.  The only purpose of this command is to restore the expirations "
"for the purpose of checkpoint/restore.  This operation is available only if "
"the kernel was configured with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:389
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same timer object have been closed, "
"the timer is disarmed and its resources are freed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:401
msgid ""
"After a B<fork>(2), the child inherits a copy of the file descriptor created "
"by B<timerfd_create>().  The file descriptor refers to the same underlying "
"timer object as the corresponding file descriptor in the parent, and "
"B<read>(2)s in the child will return information about expirations of the "
"timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:407
msgid ""
"A file descriptor created by B<timerfd_create>()  is preserved across "
"B<execve>(2), and continues to generate timer expirations if the timer was "
"armed."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:414
msgid ""
"On success, B<timerfd_create>()  returns a new file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:422
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  return 0 on success; on "
"error they return -1, and set I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:425
msgid "B<timerfd_create>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:430
msgid "The I<clockid> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:450
msgid "There was insufficient kernel memory to create the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:465
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:469
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:480
msgid "I<fd> is not a valid timerfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:483
msgid "B<timerfd_settime>()  can also fail with the following errors:"
msgstr ""

#. type: TP
#: build/C/man2/timerfd_create.2:483
#, no-wrap
msgid "B<ECANCELED>"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:486
msgid "See NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:492
msgid ""
"I<new_value> is not properly initialized (one of the I<tv_nsec> falls "
"outside the range zero to 999,999,999)."
msgstr ""

#.  This case only checked since 2.6.29, and 2.2.2[78].some-stable-version.
#.  In older kernel versions, no check was made for invalid flags.
#. type: Plain text
#: build/C/man2/timerfd_create.2:498
msgid "I<flags> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:501
msgid ""
"These system calls are available on Linux since kernel 2.6.25.  Library "
"support is provided by glibc since version 2.8."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:510
msgid ""
"Suppose the following scenario for B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM> timer that was created with B<timerfd_create>():"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:510
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:518
msgid ""
"The timer has been started (B<timerfd_settime>())  with the "
"B<TFD_TIMER_ABSTIME> and B<TFD_TIMER_CANCEL_ON_SET> flags;"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:518
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:524
msgid ""
"A discontinuous change (e.g., B<settimeofday>(2))  is subsequently made to "
"the B<CLOCK_REALTIME> clock; and"
msgstr ""

#. type: IP
#: build/C/man2/timerfd_create.2:524
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:530
msgid ""
"the caller once more calls B<timerfd_settime>()  to rearm the timer (without "
"first doing a B<read>(2)  on the file descriptor)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:532
msgid "In this case the following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:541
msgid ""
"The B<timerfd_settime>()  returns -1 with I<errno> set to B<ECANCELED>.  "
"(This enables the caller to know that the previous timer was affected by a "
"discontinuous change to the clock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:549
msgid ""
"The timer I<is successfully rearmed> with the settings provided in the "
"second B<timerfd_settime>()  call.  (This was probably an implementation "
"accident, but won't be fixed now, in case there are applications that depend "
"on this behaviour.)"
msgstr ""

#.  2.6.29
#. type: Plain text
#: build/C/man2/timerfd_create.2:555
msgid ""
"Currently, B<timerfd_create>()  supports fewer types of clock IDs than "
"B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:564
msgid ""
"The following program creates a timer and then monitors its progress.  The "
"program accepts up to three command-line arguments.  The first argument "
"specifies the number of seconds for the initial expiration of the timer.  "
"The second argument specifies the interval for the timer, in seconds.  The "
"third argument specifies the number of times the program should allow the "
"timer to expire before terminating.  The second and third command-line "
"arguments are optional."
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:566 build/C/man2/wait.2:640
msgid "The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:581
#, no-wrap
msgid ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<\\(haZ >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<\\(haC >                 # type control-C to suspend the program\n"
msgstr ""

#.  The commented out code here is what we currently need until
#.  the required stuff is in glibc
#
#
#. /* Link with -lrt */
#. #define _GNU_SOURCE
#. #include <sys/syscall.h>
#. #include <unistd.h>
#. #include <time.h>
#. #if defined(__i386__)
#. #define __NR_timerfd_create 322
#. #define __NR_timerfd_settime 325
#. #define __NR_timerfd_gettime 326
#. #endif
#
#. static int
#. timerfd_create(int clockid, int flags)
#. {
#.     return syscall(__NR_timerfd_create, clockid, flags);
#. }
#
#. static int
#. timerfd_settime(int fd, int flags, struct itimerspec *new_value,
#.         struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_settime, fd, flags, new_value,
#.                    curr_value);
#. }
#
#. static int
#. timerfd_gettime(int fd, struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_gettime, fd, curr_value);
#. }
#
#. #define TFD_TIMER_ABSTIME (1 << 0)
#
#. ////////////////////////////////////////////////////////////
#. type: Plain text
#: build/C/man2/timerfd_create.2:631
#, no-wrap
msgid ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>      /* Definition of PRIu64 */\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:634
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:642
#, no-wrap
msgid ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:648
#, no-wrap
msgid ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:651
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:660
#, no-wrap
msgid ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:669
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:675
#, no-wrap
msgid ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:678
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:681
#, no-wrap
msgid ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:692
#, no-wrap
msgid ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:696
#, no-wrap
msgid ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:699
#, no-wrap
msgid ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:702
#, no-wrap
msgid ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:707
#, no-wrap
msgid ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:712
#, no-wrap
msgid ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %\" PRIu64 \"; total=%\" PRIu64 \"\\en\", exp, "
"tot_exp);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/timerfd_create.2:728
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<epoll>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "TKILL"
msgstr ""

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:32
msgid "tkill, tgkill - send a signal to a thread"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:35
#, no-wrap
msgid "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:37
#, no-wrap
msgid "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:43
msgid "I<Note>: There is no glibc wrapper for B<tkill>(); see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:56
msgid ""
"B<tgkill>()  sends the signal I<sig> to the thread with the thread ID I<tid> "
"in the thread group I<tgid>.  (By contrast, B<kill>(2)  can be used to send "
"a signal only to a process (i.e., thread group)  as a whole, and the signal "
"will be delivered to an arbitrary thread within that process.)"
msgstr ""

#.  FIXME Maybe say something about the following:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12889
#
#.  Quoting Rich Felker <bugdal@aerifal.cx>:
#
#.  There is a race condition in pthread_kill: it is possible that,
#.  between the time pthread_kill reads the pid/tid from the target
#.  thread descriptor and the time it makes the tgkill syscall,
#.  the target thread terminates and the same tid gets assigned
#.  to a new thread in the same process.
#
#.  (The tgkill syscall was designed to eliminate a similar race
#.  condition in tkill, but it only succeeded in eliminating races
#.  where the tid gets reused in a different process, and does not
#.  help if the same tid gets assigned to a new thread in the
#.  same process.)
#
#.  The only solution I can see is to introduce a mutex that ensures
#.  that a thread cannot exit while pthread_kill is being called on it.
#
#.  Note that in most real-world situations, like almost all race
#.  conditions, this one will be extremely rare. To make it
#.  measurable, one could exhaust all but 1-2 available pid values,
#.  possibly by lowering the max pid parameter in /proc, forcing
#.  the same tid to be reused rapidly.
#. type: Plain text
#: build/C/man2/tkill.2:89
msgid ""
"B<tkill>()  is an obsolete predecessor to B<tgkill>().  It allows only the "
"target thread ID to be specified, which may result in the wrong thread being "
"signaled if a thread terminates and its thread ID is recycled.  Avoid using "
"this system call."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:92
msgid ""
"These are the raw system call interfaces, meant for internal thread library "
"use."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:104
msgid ""
"The B<RLIMIT_SIGPENDING> resource limit was reached and I<sig> is a "
"real-time signal."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:109
msgid "Insufficient kernel memory was available and I<sig> is a real-time signal."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:112
msgid "An invalid thread ID, thread group ID, or signal was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:117
msgid "Permission denied.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:120
msgid "No process with the specified thread ID (and thread group ID) exists."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:125
msgid ""
"B<tkill>()  is supported since Linux 2.4.19 / 2.5.4.  B<tgkill>()  was added "
"in Linux 2.5.75."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:129
msgid "Library support for B<tgkill>()  was added to glibc in version 2.30."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:135
msgid ""
"B<tkill>()  and B<tgkill>()  are Linux-specific and should not be used in "
"programs that are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:141
msgid ""
"See the description of B<CLONE_THREAD> in B<clone>(2)  for an explanation of "
"thread groups."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:148
msgid ""
"Glibc does not provide a wrapper for B<tkill>(); call it using "
"B<syscall>(2).  Before glibc 2.30, there was also no wrapper function for "
"B<tgkill>()."
msgstr ""

#. type: Plain text
#: build/C/man2/tkill.2:153
msgid "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"
msgstr ""

#. type: TH
#: build/C/man2/wait.2:49
#, no-wrap
msgid "WAIT"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:52
msgid "wait, waitpid, waitid - wait for process to change state"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:54
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:56
msgid "B<#include E<lt>sys/wait.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:58
msgid "B<pid_t wait(int *>I<wstatus>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:60
msgid "B<pid_t waitpid(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:65
#, no-wrap
msgid ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, "
"int >I<options>B<);>\n"
"                /* This is the glibc and POSIX interface; see\n"
"                   NOTES for information on the raw system call. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:74
msgid "B<waitid>():"
msgstr ""

#.     (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: build/C/man2/wait.2:79
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"_XOPEN_SOURCE E<gt>= 500 ||\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:84
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:97
msgid ""
"All of these system calls are used to wait for state changes in a child of "
"the calling process, and obtain information about the child whose state has "
"changed.  A state change is considered to be: the child terminated; the "
"child was stopped by a signal; or the child was resumed by a signal.  In the "
"case of a terminated child, performing a wait allows the system to release "
"the resources associated with the child; if a wait is not performed, then "
"the terminated child remains in a \"zombie\" state (see NOTES below)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:109
msgid ""
"If a child has already changed state, then these calls return immediately.  "
"Otherwise, they block until either a child changes state or a signal handler "
"interrupts the call (assuming that system calls are not automatically "
"restarted using the B<SA_RESTART> flag of B<sigaction>(2)).  In the "
"remainder of this page, a child whose state has changed and which has not "
"yet been waited upon by one of these system calls is termed I<waitable>."
msgstr ""

#. type: SS
#: build/C/man2/wait.2:109
#, no-wrap
msgid "wait() and waitpid()"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:117
msgid ""
"The B<wait>()  system call suspends execution of the calling thread until "
"one of its children terminates.  The call I<wait(&wstatus)> is equivalent "
"to:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:121
#, no-wrap
msgid "waitpid(-1, &wstatus, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:136
msgid ""
"The B<waitpid>()  system call suspends execution of the calling thread until "
"a child specified by I<pid> argument has changed state.  By default, "
"B<waitpid>()  waits only for terminated children, but this behavior is "
"modifiable via the I<options> argument, as described below."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:140
msgid "The value of I<pid> can be:"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:140
#, no-wrap
msgid "E<lt> -1"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:144
msgid ""
"meaning wait for any child process whose process group ID is equal to the "
"absolute value of I<pid>."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:144
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:146
msgid "meaning wait for any child process."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:146
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:150
msgid ""
"meaning wait for any child process whose process group ID is equal to that "
"of the calling process at the time of the call to B<waitpid>()."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:150
#, no-wrap
msgid "E<gt> 0"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:154
msgid "meaning wait for the child whose process ID is equal to the value of I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:158
msgid "The value of I<options> is an OR of zero or more of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:158 build/C/man2/wait.2:303
#, no-wrap
msgid "B<WNOHANG>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:161
msgid "return immediately if no child has exited."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:161
#, no-wrap
msgid "B<WUNTRACED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:170
msgid ""
"also return if a child has stopped (but not traced via B<ptrace>(2)).  "
"Status for I<traced> children which have stopped is provided even if this "
"option is not specified."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:170
#, no-wrap
msgid "B<WCONTINUED> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:174
msgid "also return if a stopped child has been resumed by delivery of B<SIGCONT>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:176
msgid "(For Linux-only options, see below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:190
msgid ""
"If I<wstatus> is not NULL, B<wait>()  and B<waitpid>()  store status "
"information in the I<int> to which it points.  This integer can be inspected "
"with the following macros (which take the integer itself as an argument, not "
"a pointer to it, as is done in B<wait>()  and B<waitpid>()!):"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:190
#, no-wrap
msgid "B<WIFEXITED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:198
msgid ""
"returns true if the child terminated normally, that is, by calling "
"B<exit>(3)  or B<_exit>(2), or by returning from main()."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:198
#, no-wrap
msgid "B<WEXITSTATUS(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:211
msgid ""
"returns the exit status of the child.  This consists of the least "
"significant 8 bits of the I<status> argument that the child specified in a "
"call to B<exit>(3)  or B<_exit>(2)  or as the argument for a return "
"statement in main().  This macro should be employed only if B<WIFEXITED> "
"returned true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:211
#, no-wrap
msgid "B<WIFSIGNALED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:214
msgid "returns true if the child process was terminated by a signal."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:214
#, no-wrap
msgid "B<WTERMSIG(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:221
msgid ""
"returns the number of the signal that caused the child process to "
"terminate.  This macro should be employed only if B<WIFSIGNALED> returned "
"true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:221
#, no-wrap
msgid "B<WCOREDUMP(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:228
msgid ""
"returns true if the child produced a core dump (see B<core>(5)).  This macro "
"should be employed only if B<WIFSIGNALED> returned true."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:233
msgid ""
"This macro is not specified in POSIX.1-2001 and is not available on some "
"UNIX implementations (e.g., AIX, SunOS).  Therefore, enclose its use inside "
"I<#ifdef WCOREDUMP ... #endif>."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:233
#, no-wrap
msgid "B<WIFSTOPPED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:240
msgid ""
"returns true if the child process was stopped by delivery of a signal; this "
"is possible only if the call was done using B<WUNTRACED> or when the child "
"is being traced (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:240
#, no-wrap
msgid "B<WSTOPSIG(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:246
msgid ""
"returns the number of the signal which caused the child to stop.  This macro "
"should be employed only if B<WIFSTOPPED> returned true."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:246
#, no-wrap
msgid "B<WIFCONTINUED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:251
msgid ""
"(since Linux 2.6.10)  returns true if the child process was resumed by "
"delivery of B<SIGCONT>."
msgstr ""

#. type: SS
#: build/C/man2/wait.2:251
#, no-wrap
msgid "waitid()"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:256
msgid ""
"The B<waitid>()  system call (available since Linux 2.6.9) provides more "
"precise control over which child state changes to wait for."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:262
msgid ""
"The I<idtype> and I<id> arguments select the child(ren) to wait for, as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:262
#, no-wrap
msgid "I<idtype> == B<P_PID>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:265
msgid "Wait for the child whose process ID matches I<id>."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:265
#, no-wrap
msgid "I<idtype> == B<P_PIDFD> (since Linux 5.4)"
msgstr ""

#.  commit 3695eae5fee0605f316fbaad0b9e3de791d7dfaf
#. type: Plain text
#: build/C/man2/wait.2:272
msgid ""
"Wait for the child referred to by the PID file descriptor specified in "
"I<id>.  (See B<pidfd_open>(2)  for further information on PID file "
"descriptors.)"
msgstr ""

#. type: IP
#: build/C/man2/wait.2:272
#, no-wrap
msgid "I<idtype> == B<P_PGID>"
msgstr ""

#.  commit 821cc7b0b205c0df64cce59aacc330af251fa8f7
#. type: Plain text
#: build/C/man2/wait.2:281
msgid ""
"Wait for any child whose process group ID matches I<id>.  Since Linux 5.4, "
"if I<id> is zero, then wait for any child that is in the same process group "
"as the caller's process group at the time of the call."
msgstr ""

#. type: IP
#: build/C/man2/wait.2:281
#, no-wrap
msgid "I<idtype> == B<P_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:285
msgid "Wait for any child; I<id> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:289
msgid ""
"The child state changes to wait for are specified by ORing one or more of "
"the following flags in I<options>:"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:289
#, no-wrap
msgid "B<WEXITED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:292
msgid "Wait for children that have terminated."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:292
#, no-wrap
msgid "B<WSTOPPED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:295
msgid "Wait for children that have been stopped by delivery of a signal."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:295
#, no-wrap
msgid "B<WCONTINUED>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:300
msgid ""
"Wait for (previously stopped) children that have been resumed by delivery of "
"B<SIGCONT>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:303
msgid "The following flags may additionally be ORed in I<options>:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:307
msgid "As for B<waitpid>()."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:307
#, no-wrap
msgid "B<WNOWAIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:311
msgid ""
"Leave the child in a waitable state; a later wait call can be used to again "
"retrieve the child status information."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:318
msgid ""
"Upon successful return, B<waitid>()  fills in the following fields of the "
"I<siginfo_t> structure pointed to by I<infop>:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:321
msgid "The process ID of the child."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:325
msgid ""
"The real user ID of the child.  (This field is not set on most other "
"implementations.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:329
msgid "Always set to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:329
#, no-wrap
msgid "I<si_status>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:339
msgid ""
"Either the exit status of the child, as given to B<_exit>(2)  (or "
"B<exit>(3)), or the signal that caused the child to terminate, stop, or "
"continue.  The I<si_code> field can be used to determine how to interpret "
"this field."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:356
msgid ""
"Set to one of: B<CLD_EXITED> (child called B<_exit>(2)); B<CLD_KILLED> "
"(child killed by signal); B<CLD_DUMPED> (child killed by signal, and dumped "
"core); B<CLD_STOPPED> (child stopped by signal); B<CLD_TRAPPED> (traced "
"child has trapped); or B<CLD_CONTINUED> (child continued by B<SIGCONT>)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:374
msgid ""
"If B<WNOHANG> was specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  returns 0 immediately and the state of the "
"I<siginfo_t> structure pointed to by I<infop> depends on the "
"implementation.  To (portably) distinguish this case from that where a child "
"was in a waitable state, zero out the I<si_pid> field before the call and "
"check for a nonzero value in this field after the call returns."
msgstr ""

#.  POSIX.1-2001 leaves this possibility unspecified; most
#.  implementations (including Linux) zero out the structure
#.  in this case, but at least one implementation (AIX 5.1)
#.  does not -- MTK Nov 04
#. type: Plain text
#: build/C/man2/wait.2:397
msgid ""
"POSIX.1-2008 Technical Corrigendum 1 (2013) adds the requirement that when "
"B<WNOHANG> is specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  should zero out the I<si_pid> and "
"I<si_signo> fields of the structure.  On Linux and other implementations "
"that adhere to this requirement, it is not necessary to zero out the "
"I<si_pid> field before calling B<waitid>().  However, not all "
"implementations follow the POSIX.1 specification on this point."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:401
msgid ""
"B<wait>(): on success, returns the process ID of the terminated child; on "
"error, -1 is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:410
msgid ""
"B<waitpid>(): on success, returns the process ID of the child whose state "
"has changed; if B<WNOHANG> was specified and one or more child(ren) "
"specified by I<pid> exist, but have not yet changed state, then 0 is "
"returned.  On error, -1 is returned."
msgstr ""

#.  FIXME As reported by Vegard Nossum, if infop is NULL, then waitid()
#.  returns the PID of the child.  Either this is a bug, or it is intended
#.  behavior that needs to be documented.  See my Jan 2009 LKML mail
#.  "waitid() return value strangeness when infop is NULL".
#. type: Plain text
#: build/C/man2/wait.2:423
msgid ""
"B<waitid>(): returns 0 on success or if B<WNOHANG> was specified and no "
"child(ren) specified by I<id> has yet changed state; on error, -1 is "
"returned."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:427
msgid ""
"Each of these calls sets I<errno> to an appropriate value in the case of an "
"error."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:428 build/C/man2/wait.2:433
#, no-wrap
msgid "B<ECHILD>"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:433
msgid ""
"(for B<wait>())  The calling process does not have any unwaited-for "
"children."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:453
msgid ""
"(for B<waitpid>()  or B<waitid>())  The process specified by I<pid> "
"(B<waitpid>())  or I<idtype> and I<id> (B<waitid>())  does not exist or is "
"not a child of the calling process.  (This can happen for one's own child if "
"the action for B<SIGCHLD> is set to B<SIG_IGN>.  See also the I<Linux Notes> "
"section about threads.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:460
msgid ""
"B<WNOHANG> was not set and an unblocked signal or a B<SIGCHLD> was caught; "
"see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:465
msgid "The I<options> argument was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:467
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:485
msgid ""
"A child that terminates, but has not been waited for becomes a \"zombie\".  "
"The kernel maintains a minimal set of information about the zombie process "
"(PID, termination status, resource usage information)  in order to allow the "
"parent to later perform a wait to obtain information about the child.  As "
"long as a zombie is not removed from the system via a wait, it will consume "
"a slot in the kernel process table, and if this table fills, it will not be "
"possible to create further processes.  If a parent process terminates, then "
"its \"zombie\" children (if any)  are adopted by B<init>(1), (or by the "
"nearest \"subreaper\" process as defined through the use of the B<prctl>(2)  "
"B<PR_SET_CHILD_SUBREAPER> operation); B<init>(1)  automatically performs a "
"wait to remove the zombies."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:514
msgid ""
"POSIX.1-2001 specifies that if the disposition of B<SIGCHLD> is set to "
"B<SIG_IGN> or the B<SA_NOCLDWAIT> flag is set for B<SIGCHLD> (see "
"B<sigaction>(2)), then children that terminate do not become zombies and a "
"call to B<wait>()  or B<waitpid>()  will block until all children have "
"terminated, and then fail with I<errno> set to B<ECHILD>.  (The original "
"POSIX standard left the behavior of setting B<SIGCHLD> to B<SIG_IGN> "
"unspecified.  Note that even though the default disposition of B<SIGCHLD> is "
"\"ignore\", explicitly setting the disposition to B<SIG_IGN> results in "
"different treatment of zombie process children.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:527
msgid ""
"Linux 2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and "
"earlier) does not: if a B<wait>()  or B<waitpid>()  call is made while "
"B<SIGCHLD> is being ignored, the call behaves just as though B<SIGCHLD> were "
"not being ignored, that is, the call blocks until the next child terminates "
"and then returns the process ID and status of that child."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:543
msgid ""
"In the Linux kernel, a kernel-scheduled thread is not a distinct construct "
"from a process.  Instead, a thread is simply a process that is created using "
"the Linux-unique B<clone>(2)  system call; other routines such as the "
"portable B<pthread_create>(3)  call are implemented using B<clone>(2).  "
"Before Linux 2.4, a thread was just a special case of a process, and as a "
"consequence one thread could not wait on the children of another thread, "
"even when the latter belongs to the same thread group.  However, POSIX "
"prescribes such functionality, and since Linux 2.4 a thread can, and by "
"default will, wait on children of other threads in the same thread group."
msgstr ""

#.  commit 91c4e8ea8f05916df0c8a6f383508ac7c9e10dba
#. type: Plain text
#: build/C/man2/wait.2:552
msgid ""
"The following Linux-specific I<options> are for use with children created "
"using B<clone>(2); they can also, since Linux 4.7, be used with B<waitid>():"
msgstr ""

#. type: TP
#: build/C/man2/wait.2:552
#, no-wrap
msgid "B<__WCLONE>"
msgstr ""

#.  since 0.99pl10
#. type: Plain text
#: build/C/man2/wait.2:563
msgid ""
"Wait for \"clone\" children only.  If omitted, then wait for \"non-clone\" "
"children only.  (A \"clone\" child is one which delivers no signal, or a "
"signal other than B<SIGCHLD> to its parent upon termination.)  This option "
"is ignored if B<__WALL> is also specified."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:563
#, no-wrap
msgid "B<__WALL> (since Linux 2.4)"
msgstr ""

#.  since patch-2.3.48
#. type: Plain text
#: build/C/man2/wait.2:568
msgid "Wait for all children, regardless of type (\"clone\" or \"non-clone\")."
msgstr ""

#. type: TP
#: build/C/man2/wait.2:568
#, no-wrap
msgid "B<__WNOTHREAD> (since Linux 2.4)"
msgstr ""

#.  since patch-2.4.0-test8
#. type: Plain text
#: build/C/man2/wait.2:574
msgid ""
"Do not wait for children of other threads in the same thread group.  This "
"was the default before Linux 2.4."
msgstr ""

#.  commit bf959931ddb88c4e4366e96dd22e68fa0db9527c
#.  prevents cases where an unreapable zombie is created if
#.  /sbin/init doesn't use __WALL.
#. type: Plain text
#: build/C/man2/wait.2:582
msgid ""
"Since Linux 4.7, the B<__WALL> flag is automatically implied if the child is "
"being ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:586
msgid ""
"B<wait>()  is actually a library function that (in glibc) is implemented as "
"a call to B<wait4>(2)."
msgstr ""

#.  e.g., i386 has the system call, but not x86-64
#. type: Plain text
#: build/C/man2/wait.2:594
msgid ""
"On some architectures, there is no B<waitpid>()  system call; instead, this "
"interface is implemented via a C library wrapper function that calls "
"B<wait4>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:606
msgid ""
"The raw B<waitid>()  system call takes a fifth argument, of type I<struct "
"rusage\\ *>.  If this argument is non-NULL, then it is used to return "
"resource usage information about the child, in the same manner as "
"B<wait4>(2).  See B<getrusage>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:621
msgid ""
"According to POSIX.1-2008, an application calling B<waitid>()  must ensure "
"that I<infop> points to a I<siginfo_t> structure (i.e., that it is a "
"non-null pointer).  On Linux, if I<infop> is NULL, B<waitid>()  succeeds, "
"and returns the process ID of the waited-for child.  Applications should "
"avoid relying on this inconsistent, nonstandard, and unnecessary feature."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/wait.2:638
msgid ""
"The following program demonstrates the use of B<fork>(2)  and B<waitpid>().  "
"The program creates a child process.  If no command-line argument is "
"supplied to the program, then the child suspends its execution using "
"B<pause>(2), to allow the user to send signals to the child.  Otherwise, if "
"a command-line argument is supplied, then the child exits immediately, using "
"the integer supplied on the command line as the exit status.  The parent "
"process executes a loop that monitors the child using B<waitpid>(), and uses "
"the W*() macros described above to analyze the wait status value."
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:654
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:664
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:670
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int wstatus;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:676
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:682
#, no-wrap
msgid ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %jd\\en\", (intmax_t) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:690
#, no-wrap
msgid ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:704
#, no-wrap
msgid ""
"            if (WIFEXITED(wstatus)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(wstatus));\n"
"            } else if (WIFSIGNALED(wstatus)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(wstatus));\n"
"            } else if (WIFSTOPPED(wstatus)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(wstatus));\n"
"            } else if (WIFCONTINUED(wstatus)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait.2:718
msgid ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), "
"B<sigaction>(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), "
"B<core>(5), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/wait4.2:33
#, no-wrap
msgid "WAIT4"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:36
msgid "wait3, wait4 - wait for process to change state, BSD style"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:42
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:45
#, no-wrap
msgid ""
"B<pid_t wait3(int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:48
#, no-wrap
msgid ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#.           || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/wait4.2:66
#, no-wrap
msgid ""
"B<wait3>():\n"
"    Since glibc 2.26:\n"
"        _DEFAULT_SOURCE ||\n"
"        (_XOPEN_SOURCE\\ E<gt>=\\ 500 &&\n"
"                ! (_POSIX_C_SOURCE E<gt>= 200112L || _XOPEN_SOURCE E<gt>= "
"600))\n"
"    From glibc 2.19 to 2.25:\n"
"        _DEFAULT_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:72
#, no-wrap
msgid ""
"B<wait4>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:79
msgid ""
"These functions are nonstandard; in new programs, the use of B<waitpid>(2)  "
"or B<waitid>(2)  is preferable."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:89
msgid ""
"The B<wait3>()  and B<wait4>()  system calls are similar to B<waitpid>(2), "
"but additionally return resource usage information about the child in the "
"structure pointed to by I<rusage>."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:95
msgid ""
"Other than the use of the I<rusage> argument, the following B<wait3>()  "
"call:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:99
#, no-wrap
msgid "wait3(wstatus, options, rusage);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:103 build/C/man2/wait4.2:121
msgid "is equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:107
#, no-wrap
msgid "waitpid(-1, wstatus, options);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:113
msgid "Similarly, the following B<wait4>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:117
#, no-wrap
msgid "wait4(pid, wstatus, options, rusage);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:125
#, no-wrap
msgid "waitpid(pid, wstatus, options);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:136
msgid ""
"In other words, B<wait3>()  waits of any child, while B<wait4>()  can be "
"used to select a specific child, or children, on which to wait.  See "
"B<wait>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:146
msgid ""
"If I<rusage> is not NULL, the I<struct rusage> to which it points will be "
"filled with accounting information about the child.  See B<getrusage>(2)  "
"for details."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:149 build/C/man2/wait4.2:152
msgid "As for B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:154
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:161
msgid ""
"SUSv1 included a specification of B<wait3>(); SUSv2 included B<wait3>(), but "
"marked it LEGACY; SUSv3 removed it."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:173
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:179
msgid ""
"On Linux, B<wait3>()  is a library function implemented on top of the "
"B<wait4>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/wait4.2:186
msgid ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man3/killpg.3:42
#, no-wrap
msgid "KILLPG"
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:45
msgid "killpg - send signal to a process group"
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:49
msgid "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"
msgstr ""

#. type: TP
#: build/C/man3/killpg.3:55
#, no-wrap
msgid "B<killpg>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/killpg.3:61
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:71
msgid ""
"B<killpg>()  sends the signal I<sig> to the process group I<pgrp>.  See "
"B<signal>(7)  for a list of signals."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:80
msgid ""
"If I<pgrp> is 0, B<killpg>()  sends the signal to the calling process's "
"process group.  (POSIX says: if I<pgrp> is less than or equal to 1, the "
"behavior is undefined.)"
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:83
msgid ""
"For the permissions required to send a signal to another process, see "
"B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:93
msgid "I<sig> is not a valid signal number."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:99
msgid ""
"The process does not have permission to send the signal to any of the target "
"processes.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:103
msgid "No process can be found in the process group specified by I<pgrp>."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:107
msgid ""
"The process group was given as 0 but the sending process does not have a "
"process group."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:111
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<killpg>()  first appeared in "
"4BSD)."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:125
msgid ""
"There are various differences between the permission checking in BSD-type "
"systems and System\\ V-type systems.  See the POSIX rationale for "
"B<kill>(3p).  A difference not mentioned by POSIX concerns the return value "
"B<EPERM>: BSD documents that no signal is sent and B<EPERM> returned when "
"the permission check failed for at least one target process, while POSIX "
"documents B<EPERM> only when the permission check failed for all target "
"processes."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:130
msgid ""
"On Linux, B<killpg>()  is implemented as a library function that makes the "
"call I<kill(-pgrp,\\ sig)>."
msgstr ""

#. type: Plain text
#: build/C/man3/killpg.3:136
msgid ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<capabilities>(7), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: build/C/man7/signal-safety.7:25
#, no-wrap
msgid "SIGNAL-SAFETY"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:28
msgid "signal-safety - async-signal-safe functions"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:37
msgid ""
"An I<async-signal-safe> function is one that can be safely called from "
"within a signal handler.  Many functions are I<not> async-signal-safe.  In "
"particular, nonreentrant functions are generally unsafe to call from a "
"signal handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:43
msgid ""
"The kinds of issues that render a function unsafe can be quickly understood "
"when one considers the implementation of the I<stdio> library, all of whose "
"functions are not async-signal-safe."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:60
msgid ""
"When performing buffered I/O on a file, the I<stdio> functions must maintain "
"a statically allocated data buffer along with associated counters and "
"indexes (or pointers)  that record the amount of data and the current "
"position in the buffer.  Suppose that the main program is in the middle of a "
"call to a I<stdio> function such as B<printf>(3)  where the buffer and "
"associated variables have been partially updated.  If, at that moment, the "
"program is interrupted by a signal handler that also calls B<printf>(3), "
"then the second call to B<printf>(3)  will operate on inconsistent data, "
"with unpredictable results."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:62
msgid "To avoid problems with unsafe functions, there are two possible choices:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:68
msgid ""
"Ensure that (a) the signal handler calls only async-signal-safe functions, "
"and (b) the signal handler itself is reentrant with respect to global "
"variables in the main program."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:72
msgid ""
"Block signal delivery in the main program when calling functions that are "
"unsafe or operating on global data that is also accessed by the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:75
msgid ""
"Generally, the second choice is difficult in programs of any complexity, so "
"the first choice is taken."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:81
msgid ""
"POSIX.1 specifies a set of functions that an implementation must make "
"async-signal-safe.  (An implementation may provide safe implementations of "
"additional functions, but this is not required by the standard and other "
"implementations may not provide the same guarantees.)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:85
msgid ""
"In general, a function is async-signal-safe either because it is reentrant "
"or because it is atomic with respect to signals (i.e., its execution can't "
"be interrupted by a signal handler)."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:91
msgid ""
"The set of functions required to be async-signal-safe by POSIX.1 is shown in "
"the following table.  The functions not otherwise noted were required to be "
"async-signal-safe in POSIX.1-2001; the table details changes in the "
"subsequent standards."
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:95
#, no-wrap
msgid "Function"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:96
#, no-wrap
msgid "B<abort>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:96
#, no-wrap
msgid "Added in POSIX.1-2001 TC1"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:97
#, no-wrap
msgid "B<accept>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:98
#, no-wrap
msgid "B<access>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:99
#, no-wrap
msgid "B<aio_error>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:100
#, no-wrap
msgid "B<aio_return>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:101
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:101 build/C/man7/signal-safety.7:118 build/C/man7/signal-safety.7:133
#, no-wrap
msgid "See notes below"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:102
#, no-wrap
msgid "B<alarm>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:103
#, no-wrap
msgid "B<bind>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:104
#, no-wrap
msgid "B<cfgetispeed>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:105
#, no-wrap
msgid "B<cfgetospeed>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:106
#, no-wrap
msgid "B<cfsetispeed>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:107
#, no-wrap
msgid "B<cfsetospeed>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:108
#, no-wrap
msgid "B<chdir>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:109
#, no-wrap
msgid "B<chmod>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:110
#, no-wrap
msgid "B<chown>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:111
#, no-wrap
msgid "B<clock_gettime>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:113
#, no-wrap
msgid "B<connect>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:114
#, no-wrap
msgid "B<creat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:115
#, no-wrap
msgid "B<dup>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:116
#, no-wrap
msgid "B<dup2>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:117
#, no-wrap
msgid "B<execl>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:117
#, no-wrap
msgid "Added in POSIX.1-2008; see notes below"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:118
#, no-wrap
msgid "B<execle>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:119
#, no-wrap
msgid "B<execv>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:119 build/C/man7/signal-safety.7:123 build/C/man7/signal-safety.7:126 build/C/man7/signal-safety.7:128 build/C/man7/signal-safety.7:131 build/C/man7/signal-safety.7:135 build/C/man7/signal-safety.7:138 build/C/man7/signal-safety.7:154 build/C/man7/signal-safety.7:166 build/C/man7/signal-safety.7:168 build/C/man7/signal-safety.7:169 build/C/man7/signal-safety.7:170 build/C/man7/signal-safety.7:174 build/C/man7/signal-safety.7:186 build/C/man7/signal-safety.7:191 build/C/man7/signal-safety.7:241 build/C/man7/signal-safety.7:258 build/C/man7/signal-safety.7:260 build/C/man7/signal-safety.7:261
#, no-wrap
msgid "Added in POSIX.1-2008"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:120
#, no-wrap
msgid "B<execve>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:121
#, no-wrap
msgid "B<_exit>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:122
#, no-wrap
msgid "B<_Exit>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:123
#, no-wrap
msgid "B<faccessat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:124
#, no-wrap
msgid "B<fchdir>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:124 build/C/man7/signal-safety.7:180 build/C/man7/signal-safety.7:181 build/C/man7/signal-safety.7:182
#, no-wrap
msgid "Added in POSIX.1-2008 TC1"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:125
#, no-wrap
msgid "B<fchmod>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:126
#, no-wrap
msgid "B<fchmodat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:127
#, no-wrap
msgid "B<fchown>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:128
#, no-wrap
msgid "B<fchownat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:129
#, no-wrap
msgid "B<fcntl>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:130
#, no-wrap
msgid "B<fdatasync>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:131
#, no-wrap
msgid "B<fexecve>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:132
#, no-wrap
msgid "B<ffs>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:132 build/C/man7/signal-safety.7:150 build/C/man7/signal-safety.7:151 build/C/man7/signal-safety.7:159 build/C/man7/signal-safety.7:160 build/C/man7/signal-safety.7:161 build/C/man7/signal-safety.7:162 build/C/man7/signal-safety.7:163 build/C/man7/signal-safety.7:164 build/C/man7/signal-safety.7:171 build/C/man7/signal-safety.7:172 build/C/man7/signal-safety.7:223 build/C/man7/signal-safety.7:224 build/C/man7/signal-safety.7:225 build/C/man7/signal-safety.7:226 build/C/man7/signal-safety.7:227 build/C/man7/signal-safety.7:228 build/C/man7/signal-safety.7:229 build/C/man7/signal-safety.7:230 build/C/man7/signal-safety.7:231 build/C/man7/signal-safety.7:232 build/C/man7/signal-safety.7:233 build/C/man7/signal-safety.7:234 build/C/man7/signal-safety.7:235 build/C/man7/signal-safety.7:236 build/C/man7/signal-safety.7:237 build/C/man7/signal-safety.7:238 build/C/man7/signal-safety.7:239 build/C/man7/signal-safety.7:264 build/C/man7/signal-safety.7:265 build/C/man7/signal-safety.7:266 build/C/man7/signal-safety.7:267 build/C/man7/signal-safety.7:268 build/C/man7/signal-safety.7:269 build/C/man7/signal-safety.7:270 build/C/man7/signal-safety.7:271 build/C/man7/signal-safety.7:272 build/C/man7/signal-safety.7:273 build/C/man7/signal-safety.7:274 build/C/man7/signal-safety.7:275 build/C/man7/signal-safety.7:276 build/C/man7/signal-safety.7:277 build/C/man7/signal-safety.7:278 build/C/man7/signal-safety.7:279 build/C/man7/signal-safety.7:280 build/C/man7/signal-safety.7:281 build/C/man7/signal-safety.7:282 build/C/man7/signal-safety.7:283 build/C/man7/signal-safety.7:284 build/C/man7/signal-safety.7:285
#, no-wrap
msgid "Added in POSIX.1-2008 TC2"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:133
#, no-wrap
msgid "B<fork>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:134
#, no-wrap
msgid "B<fstat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:135
#, no-wrap
msgid "B<fstatat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:136
#, no-wrap
msgid "B<fsync>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:137
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:138
#, no-wrap
msgid "B<futimens>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:139
#, no-wrap
msgid "B<getegid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:140
#, no-wrap
msgid "B<geteuid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:141
#, no-wrap
msgid "B<getgid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:142
#, no-wrap
msgid "B<getgroups>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:143
#, no-wrap
msgid "B<getpeername>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:144
#, no-wrap
msgid "B<getpgrp>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:145
#, no-wrap
msgid "B<getpid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:146
#, no-wrap
msgid "B<getppid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:147
#, no-wrap
msgid "B<getsockname>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:148
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:149
#, no-wrap
msgid "B<getuid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:150
#, no-wrap
msgid "B<htonl>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:151
#, no-wrap
msgid "B<htons>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:153
#, no-wrap
msgid "B<link>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:154
#, no-wrap
msgid "B<linkat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:155
#, no-wrap
msgid "B<listen>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:156
#, no-wrap
msgid "B<longjmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:156 build/C/man7/signal-safety.7:210
#, no-wrap
msgid "Added in POSIX.1-2008 TC2; see notes below"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:157
#, no-wrap
msgid "B<lseek>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:158
#, no-wrap
msgid "B<lstat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:159
#, no-wrap
msgid "B<memccpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:160
#, no-wrap
msgid "B<memchr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:161
#, no-wrap
msgid "B<memcmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:162
#, no-wrap
msgid "B<memcpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:163
#, no-wrap
msgid "B<memmove>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:164
#, no-wrap
msgid "B<memset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:165
#, no-wrap
msgid "B<mkdir>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:166
#, no-wrap
msgid "B<mkdirat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:167
#, no-wrap
msgid "B<mkfifo>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:168
#, no-wrap
msgid "B<mkfifoat>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:169
#, no-wrap
msgid "B<mknod>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:170
#, no-wrap
msgid "B<mknodat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:171
#, no-wrap
msgid "B<ntohl>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:172
#, no-wrap
msgid "B<ntohs>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:173
#, no-wrap
msgid "B<open>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:174
#, no-wrap
msgid "B<openat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:176
#, no-wrap
msgid "B<pipe>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:177
#, no-wrap
msgid "B<poll>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:178
#, no-wrap
msgid "B<posix_trace_event>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:179
#, no-wrap
msgid "B<pselect>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:181
#, no-wrap
msgid "B<pthread_self>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:182
#, no-wrap
msgid "B<pthread_sigmask>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:185
#, no-wrap
msgid "B<readlink>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:186
#, no-wrap
msgid "B<readlinkat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:187
#, no-wrap
msgid "B<recv>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:188
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:189
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:190
#, no-wrap
msgid "B<rename>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:191
#, no-wrap
msgid "B<renameat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:192
#, no-wrap
msgid "B<rmdir>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:193
#, no-wrap
msgid "B<select>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:194
#, no-wrap
msgid "B<sem_post>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:195
#, no-wrap
msgid "B<send>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:196
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:197
#, no-wrap
msgid "B<sendto>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:198
#, no-wrap
msgid "B<setgid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:199
#, no-wrap
msgid "B<setpgid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:200
#, no-wrap
msgid "B<setsid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:201
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:202
#, no-wrap
msgid "B<setuid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:203
#, no-wrap
msgid "B<shutdown>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:205
#, no-wrap
msgid "B<sigaddset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:206
#, no-wrap
msgid "B<sigdelset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:207
#, no-wrap
msgid "B<sigemptyset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:208
#, no-wrap
msgid "B<sigfillset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:209
#, no-wrap
msgid "B<sigismember>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:210
#, no-wrap
msgid "B<siglongjmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:212
#, no-wrap
msgid "B<sigpause>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:215
#, no-wrap
msgid "B<sigqueue>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:216
#, no-wrap
msgid "B<sigset>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:218
#, no-wrap
msgid "B<sleep>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:219
#, no-wrap
msgid "B<sockatmark>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:219
#, no-wrap
msgid "Added in POSIX.1-2001 TC2"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:220
#, no-wrap
msgid "B<socket>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:221
#, no-wrap
msgid "B<socketpair>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:222
#, no-wrap
msgid "B<stat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:223
#, no-wrap
msgid "B<stpcpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:224
#, no-wrap
msgid "B<stpncpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:225
#, no-wrap
msgid "B<strcat>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:226
#, no-wrap
msgid "B<strchr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:227
#, no-wrap
msgid "B<strcmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:228
#, no-wrap
msgid "B<strcpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:229
#, no-wrap
msgid "B<strcspn>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:230
#, no-wrap
msgid "B<strlen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:231
#, no-wrap
msgid "B<strncat>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:232
#, no-wrap
msgid "B<strncmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:233
#, no-wrap
msgid "B<strncpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:234
#, no-wrap
msgid "B<strnlen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:235
#, no-wrap
msgid "B<strpbrk>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:236
#, no-wrap
msgid "B<strrchr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:237
#, no-wrap
msgid "B<strspn>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:238
#, no-wrap
msgid "B<strstr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:239
#, no-wrap
msgid "B<strtok_r>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:240
#, no-wrap
msgid "B<symlink>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:241
#, no-wrap
msgid "B<symlinkat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:242
#, no-wrap
msgid "B<tcdrain>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:243
#, no-wrap
msgid "B<tcflow>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:244
#, no-wrap
msgid "B<tcflush>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:245
#, no-wrap
msgid "B<tcgetattr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:246
#, no-wrap
msgid "B<tcgetpgrp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:247
#, no-wrap
msgid "B<tcsendbreak>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:248
#, no-wrap
msgid "B<tcsetattr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:249
#, no-wrap
msgid "B<tcsetpgrp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:250
#, no-wrap
msgid "B<time>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:251
#, no-wrap
msgid "B<timer_getoverrun>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:252
#, no-wrap
msgid "B<timer_gettime>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:253
#, no-wrap
msgid "B<timer_settime>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:254
#, no-wrap
msgid "B<times>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:255
#, no-wrap
msgid "B<umask>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:256
#, no-wrap
msgid "B<uname>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:257
#, no-wrap
msgid "B<unlink>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:258
#, no-wrap
msgid "B<unlinkat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:259
#, no-wrap
msgid "B<utime>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:260
#, no-wrap
msgid "B<utimensat>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:261
#, no-wrap
msgid "B<utimes>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:262
#, no-wrap
msgid "B<wait>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:263
#, no-wrap
msgid "B<waitpid>(2)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:264
#, no-wrap
msgid "B<wcpcpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:265
#, no-wrap
msgid "B<wcpncpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:266
#, no-wrap
msgid "B<wcscat>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:267
#, no-wrap
msgid "B<wcschr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:268
#, no-wrap
msgid "B<wcscmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:269
#, no-wrap
msgid "B<wcscpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:270
#, no-wrap
msgid "B<wcscspn>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:271
#, no-wrap
msgid "B<wcslen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:272
#, no-wrap
msgid "B<wcsncat>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:273
#, no-wrap
msgid "B<wcsncmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:274
#, no-wrap
msgid "B<wcsncpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:275
#, no-wrap
msgid "B<wcsnlen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:276
#, no-wrap
msgid "B<wcspbrk>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:277
#, no-wrap
msgid "B<wcsrchr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:278
#, no-wrap
msgid "B<wcsspn>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:279
#, no-wrap
msgid "B<wcsstr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:280
#, no-wrap
msgid "B<wcstok>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:281
#, no-wrap
msgid "B<wmemchr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:282
#, no-wrap
msgid "B<wmemcmp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:283
#, no-wrap
msgid "B<wmemcpy>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:284
#, no-wrap
msgid "B<wmemmove>(3)"
msgstr ""

#. type: tbl table
#: build/C/man7/signal-safety.7:285
#, no-wrap
msgid "B<wmemset>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:290
msgid "Notes:"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:297
msgid ""
"POSIX.1-2001 and POSIX.1-2001 TC2 required the functions B<fpathconf>(3), "
"B<pathconf>(3), and B<sysconf>(3)  to be async-signal-safe, but this "
"requirement was removed in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:305
msgid ""
"If a signal handler interrupts the execution of an unsafe function, and the "
"handler terminates via a call to B<longjmp>(3)  or B<siglongjmp>(3)  and the "
"program subsequently calls an unsafe function, then the behavior of the "
"program is undefined."
msgstr ""

#.  http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt
#. type: Plain text
#: build/C/man7/signal-safety.7:318
msgid ""
"POSIX.1-2001 TC1 clarified that if an application calls B<fork>(2)  from a "
"signal handler and any of the fork handlers registered by "
"B<pthread_atfork>(3)  calls a function that is not async-signal-safe, the "
"behavior is undefined.  A future revision of the standard is likely to "
"remove B<fork>(2)  from the list of async-signal-safe functions."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:324
msgid ""
"Asynchronous signal handlers that call functions which are cancellation "
"points and nest over regions of deferred cancellation may trigger "
"cancellation whose behavior is as if asynchronous cancellation had occurred "
"and may cause application state to become inconsistent."
msgstr ""

#. type: SS
#: build/C/man7/signal-safety.7:324
#, no-wrap
msgid "errno"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:331
msgid ""
"Fetching and setting the value of I<errno> is async-signal-safe provided "
"that the signal handler saves I<errno> on entry and restores its value "
"before returning."
msgstr ""

#. type: SS
#: build/C/man7/signal-safety.7:331
#, no-wrap
msgid "Deviations in the GNU C library"
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:334
msgid "The following known deviations from the standard occur in the GNU C library:"
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: build/C/man7/signal-safety.7:344
msgid ""
"Before glibc 2.24, B<execl>(3)  and B<execle>(3)  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe.  This was fixed in "
"glibc 2.24."
msgstr ""

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=13172
#. type: Plain text
#: build/C/man7/signal-safety.7:351
msgid ""
"The glibc implementation of B<aio_suspend>(3)  is not async-signal-safe "
"because it uses B<pthread_mutex_lock>(3)  internally."
msgstr ""

#. type: Plain text
#: build/C/man7/signal-safety.7:355
msgid "B<sigaction>(2), B<signal>(7), B<standards>(7)"
msgstr ""
