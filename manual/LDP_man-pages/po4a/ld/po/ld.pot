# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25
#, no-wrap
msgid "DL_ITERATE_PHDR"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dlinfo.3:25 build/C/man3/dlopen.3:35 build/C/man1/memusage.1:24 build/C/man1/pldd.1:25 build/C/man7/rtld-audit.7:28 build/C/man1/sprof.1:25
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/end.3:26 build/C/man8/ld.so.8:7 build/C/man8/ldconfig.8:22 build/C/man1/memusage.1:24 build/C/man1/memusagestat.1:23 build/C/man1/mtrace.1:23 build/C/man1/pldd.1:25 build/C/man8/sln.8:25
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dladdr.3:26 build/C/man3/dlerror.3:25 build/C/man3/dlinfo.3:25 build/C/man3/dlopen.3:35 build/C/man3/dlsym.3:25 build/C/man5/elf.5:35 build/C/man3/end.3:26 build/C/man8/ld.so.8:7 build/C/man8/ldconfig.8:22 build/C/man1/ldd.1:14 build/C/man7/rtld-audit.7:28 build/C/man8/sln.8:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:26 build/C/man3/dladdr.3:27 build/C/man3/dlerror.3:26 build/C/man3/dlinfo.3:26 build/C/man3/dlopen.3:36 build/C/man3/dlsym.3:26 build/C/man5/elf.5:36 build/C/man3/end.3:27 build/C/man8/ld.so.8:8 build/C/man8/ldconfig.8:23 build/C/man1/ldd.1:15 build/C/man1/memusage.1:25 build/C/man1/memusagestat.1:24 build/C/man1/mtrace.1:24 build/C/man1/pldd.1:26 build/C/man7/rtld-audit.7:29 build/C/man8/sln.8:26 build/C/man1/sprof.1:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:28
msgid "dl_iterate_phdr - walk through list of shared objects"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:28 build/C/man3/dladdr.3:29 build/C/man3/dlerror.3:28 build/C/man3/dlinfo.3:28 build/C/man3/dlopen.3:39 build/C/man3/dlsym.3:28 build/C/man5/elf.5:38 build/C/man3/end.3:29 build/C/man8/ld.so.8:10 build/C/man8/ldconfig.8:25 build/C/man1/ldd.1:17 build/C/man1/memusage.1:27 build/C/man1/memusagestat.1:26 build/C/man1/mtrace.1:26 build/C/man1/pldd.1:28 build/C/man7/rtld-audit.7:31 build/C/man8/sln.8:28 build/C/man1/sprof.1:28
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:37
#, no-wrap
msgid ""
"B<int dl_iterate_phdr(>\n"
"B<          int (*>I<callback>B<) (struct dl_phdr_info *>I<info>B<,>\n"
"B<                           size_t >I<size>B<, void *>I<data>B<),>\n"
"B<          void *>I<data>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:38 build/C/man3/dladdr.3:41 build/C/man3/dlerror.3:34 build/C/man3/dlinfo.3:38 build/C/man3/dlopen.3:53 build/C/man3/dlsym.3:40 build/C/man5/elf.5:43 build/C/man3/end.3:35 build/C/man8/ld.so.8:21 build/C/man8/ldconfig.8:40 build/C/man1/ldd.1:19 build/C/man1/memusage.1:29 build/C/man1/memusagestat.1:28 build/C/man1/mtrace.1:28 build/C/man1/pldd.1:33 build/C/man7/rtld-audit.7:36 build/C/man8/sln.8:32 build/C/man1/sprof.1:33
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:44
msgid ""
"The B<dl_iterate_phdr>()  function allows an application to inquire at run "
"time to find out which shared objects it has loaded, and the order in which "
"they were loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:54
msgid ""
"The B<dl_iterate_phdr>()  function walks through the list of an "
"application's shared objects and calls the function I<callback> once for "
"each object, until either all shared objects have been processed or "
"I<callback> returns a nonzero value."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:71
msgid ""
"Each call to I<callback> receives three arguments: I<info>, which is a "
"pointer to a structure containing information about the shared object; "
"I<size>, which is the size of the structure pointed to by I<info>; and "
"I<data>, which is a copy of whatever value was passed by the calling program "
"as the second argument (also named I<data>)  in the call to "
"B<dl_iterate_phdr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:75
msgid "The I<info> argument is a structure of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:86
#, no-wrap
msgid ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* Base address of object */\n"
"    const char       *dlpi_name;  /* (Null-terminated) name of\n"
"                                     object */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* Pointer to array of\n"
"                                     ELF program headers\n"
"                                     for this object */\n"
"    ElfW(Half)        dlpi_phnum; /* # of items in I<dlpi_phdr> */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:91
#, no-wrap
msgid ""
"    /* The following fields were added in glibc 2.4, after the first\n"
"       version of this structure was available.  Check the I<size>\n"
"       argument passed to the dl_iterate_phdr callback to determine\n"
"       whether or not each later member is available.  */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:107
#, no-wrap
msgid ""
"    unsigned long long dlpi_adds;\n"
"                    /* Incremented when a new object may\n"
"                       have been added */\n"
"    unsigned long long dlpi_subs;\n"
"                    /* Incremented when an object may\n"
"                       have been removed */\n"
"    size_t dlpi_tls_modid;\n"
"                    /* If there is a PT_TLS segment, its module\n"
"                       ID as used in TLS relocations, else zero */\n"
"    void  *dlpi_tls_data;\n"
"                    /* The address of the calling thread\\(aqs instance\n"
"                       of this module\\(aqs PT_TLS segment, if it has\n"
"                       one and it has been allocated in the calling\n"
"                       thread, otherwise a null pointer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:121
msgid ""
"(The I<ElfW>()  macro definition turns its argument into the name of an ELF "
"data type suitable for the hardware architecture.  For example, on a 32-bit "
"platform, I<ElfW(Addr)> yields the data type name I<Elf32_Addr>.  Further "
"information on these types can be found in the I<E<lt>elf.hE<gt>> and "
"I<E<lt>link.hE<gt>> header files.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:132
msgid ""
"The I<dlpi_addr> field indicates the base address of the shared object "
"(i.e., the difference between the virtual memory address of the shared "
"object and the offset of that object in the file from which it was loaded).  "
"The I<dlpi_name> field is a null-terminated string giving the pathname from "
"which the shared object was loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:147
msgid ""
"To understand the meaning of the I<dlpi_phdr> and I<dlpi_phnum> fields, we "
"need to be aware that an ELF shared object consists of a number of segments, "
"each of which has a corresponding program header describing the segment.  "
"The I<dlpi_phdr> field is a pointer to an array of the program headers for "
"this shared object.  The I<dlpi_phnum> field indicates the size of this "
"array."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:149
msgid "These program headers are structures of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* Segment type */\n"
"    Elf32_Off   p_offset;  /* Segment file offset */\n"
"    Elf32_Addr  p_vaddr;   /* Segment virtual address */\n"
"    Elf32_Addr  p_paddr;   /* Segment physical address */\n"
"    Elf32_Word  p_filesz;  /* Segment size in file */\n"
"    Elf32_Word  p_memsz;   /* Segment size in memory */\n"
"    Elf32_Word  p_flags;   /* Segment flags */\n"
"    Elf32_Word  p_align;   /* Segment alignment */\n"
"} Elf32_Phdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:168
msgid ""
"Note that we can calculate the location of a particular program header, "
"I<x>, in virtual memory using the formula:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:172
#, no-wrap
msgid "addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:180
msgid ""
"Possible values for I<p_type> include the following (see I<E<lt>elf.hE<gt>> "
"for further details):"
msgstr ""

#.  For PT_GNU_STACK, see http://www.airs.com/blog/archives/518
#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:194
#, no-wrap
msgid ""
"#define PT_LOAD         1    /* Loadable program segment */\n"
"#define PT_DYNAMIC      2    /* Dynamic linking information */\n"
"#define PT_INTERP       3    /* Program interpreter */\n"
"#define PT_NOTE         4    /* Auxiliary information */\n"
"#define PT_SHLIB        5    /* Reserved */\n"
"#define PT_PHDR         6    /* Entry for header table itself */\n"
"#define PT_TLS          7    /* Thread-local storage segment */\n"
"#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr segment */\n"
"#define PT_GNU_STACK  0x6474e551 /* Indicates stack executability */\n"
"#define PT_GNU_RELRO  0x6474e552 /* Read-only after relocation */\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:196 build/C/man3/dladdr.3:215 build/C/man3/dlinfo.3:214 build/C/man3/dlopen.3:348 build/C/man3/dlsym.3:113
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:201
msgid ""
"The B<dl_iterate_phdr>()  function returns whatever value was returned by "
"the last call to I<callback>."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:201 build/C/man3/dladdr.3:235 build/C/man3/dlerror.3:49 build/C/man3/dlinfo.3:220 build/C/man3/dlopen.3:365 build/C/man3/dlsym.3:120 build/C/man1/pldd.1:61
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:204
msgid "B<dl_iterate_phdr>()  has been supported in glibc since version 2.2.4."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:204 build/C/man3/dladdr.3:240 build/C/man3/dlerror.3:52 build/C/man3/dlinfo.3:223 build/C/man3/dlopen.3:372 build/C/man3/dlsym.3:125
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:207 build/C/man3/dladdr.3:243 build/C/man3/dlerror.3:55 build/C/man3/dlinfo.3:226 build/C/man3/dlopen.3:375 build/C/man3/dlsym.3:128
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:247 build/C/man3/dlerror.3:59 build/C/man3/dlinfo.3:230 build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:247 build/C/man3/dlerror.3:59 build/C/man3/dlinfo.3:230 build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:166 build/C/man3/dladdr.3:189 build/C/man3/dladdr.3:208 build/C/man3/dladdr.3:247 build/C/man3/dlerror.3:59 build/C/man3/dlinfo.3:230 build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214
#, no-wrap
msgid "B<dl_iterate_phdr>()"
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214 build/C/man3/dladdr.3:251 build/C/man3/dlerror.3:62 build/C/man3/dlinfo.3:233 build/C/man3/dlopen.3:384 build/C/man3/dlsym.3:136
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214 build/C/man3/dladdr.3:251 build/C/man3/dlerror.3:62 build/C/man3/dlinfo.3:233 build/C/man3/dlopen.3:384 build/C/man3/dlsym.3:136
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:217 build/C/man3/dladdr.3:253 build/C/man3/dlerror.3:64 build/C/man3/dlinfo.3:235 build/C/man3/dlopen.3:386 build/C/man3/dlsym.3:138 build/C/man3/end.3:50 build/C/man1/pldd.1:64 build/C/man7/rtld-audit.7:478 build/C/man1/sprof.1:75
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:232
msgid ""
"The B<dl_iterate_phdr>()  function is not specified in any standard.  "
"Various other systems provide a version of this function, although details "
"of the returned I<dl_phdr_info> structure differ.  On the BSDs and Solaris, "
"the structure includes the fields I<dlpi_addr>, I<dlpi_name>, I<dlpi_phdr>, "
"and I<dlpi_phnum> in addition to other implementation-specific fields."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:232 build/C/man3/dlerror.3:66 build/C/man3/dlinfo.3:237 build/C/man3/dlopen.3:402 build/C/man3/dlsym.3:144 build/C/man5/elf.5:2132 build/C/man3/end.3:53 build/C/man8/ld.so.8:779 build/C/man1/pldd.1:71 build/C/man7/rtld-audit.7:484
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:239
msgid ""
"Future versions of the C library may add further fields to the "
"I<dl_phdr_info> structure; in that event, the I<size> argument provides a "
"mechanism for the callback function to discover whether it is running on a "
"system with added fields."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:246
msgid ""
"The first object visited by I<callback> is the main program.  For the main "
"program, the I<dlpi_name> field will be an empty string."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:246 build/C/man3/dlerror.3:84 build/C/man3/dlinfo.3:242 build/C/man3/dlopen.3:550 build/C/man3/dlsym.3:168 build/C/man3/end.3:76 build/C/man1/memusage.1:204 build/C/man1/memusagestat.1:85 build/C/man1/pldd.1:106 build/C/man7/rtld-audit.7:519 build/C/man1/sprof.1:79
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:252
msgid ""
"The following program displays a list of pathnames of the shared objects it "
"has loaded.  For each shared object, the program lists some information "
"(virtual address, size, flags, and type)  for each of the objects ELF "
"segments."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:258
msgid ""
"The following shell session demonstrates the output produced by the program "
"on an x86-64 system.  The first shared object for which output is displayed "
"(where the name is an empty string)  is the main program."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:296
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Name: \"\" (9 segments)\n"
"     0: [      0x400040; memsz:    1f8] flags: 0x5; PT_PHDR\n"
"     1: [      0x400238; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [      0x400000; memsz:    ac4] flags: 0x5; PT_LOAD\n"
"     3: [      0x600e10; memsz:    240] flags: 0x6; PT_LOAD\n"
"     4: [      0x600e28; memsz:    1d0] flags: 0x6; PT_DYNAMIC\n"
"     5: [      0x400254; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [      0x400970; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     7: [         (nil); memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     8: [      0x600e10; memsz:    1f0] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"linux-vdso.so.1\" (4 segments)\n"
"     0: [0x7ffc6edd1000; memsz:    e89] flags: 0x5; PT_LOAD\n"
"     1: [0x7ffc6edd1360; memsz:    110] flags: 0x4; PT_DYNAMIC\n"
"     2: [0x7ffc6edd17b0; memsz:     3c] flags: 0x4; PT_NOTE\n"
"     3: [0x7ffc6edd17ec; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"Name: \"/lib64/libc.so.6\" (10 segments)\n"
"     0: [0x7f55712ce040; memsz:    230] flags: 0x5; PT_PHDR\n"
"     1: [0x7f557145b980; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [0x7f55712ce000; memsz: 1b6a5c] flags: 0x5; PT_LOAD\n"
"     3: [0x7f55716857a0; memsz:   9240] flags: 0x6; PT_LOAD\n"
"     4: [0x7f5571688b80; memsz:    1f0] flags: 0x6; PT_DYNAMIC\n"
"     5: [0x7f55712ce270; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [0x7f55716857a0; memsz:     78] flags: 0x4; PT_TLS\n"
"     7: [0x7f557145b99c; memsz:   544c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     8: [0x7f55712ce000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     9: [0x7f55716857a0; memsz:   3860] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"/lib64/ld-linux-x86-64.so.2\" (7 segments)\n"
"     0: [0x7f557168f000; memsz:  20828] flags: 0x5; PT_LOAD\n"
"     1: [0x7f55718afba0; memsz:   15a8] flags: 0x6; PT_LOAD\n"
"     2: [0x7f55718afe10; memsz:    190] flags: 0x6; PT_DYNAMIC\n"
"     3: [0x7f557168f1c8; memsz:     24] flags: 0x4; PT_NOTE\n"
"     4: [0x7f55716acec4; memsz:    604] flags: 0x4; PT_GNU_EH_FRAME\n"
"     5: [0x7f557168f000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     6: [0x7f55718afba0; memsz:    460] flags: 0x4; PT_GNU_RELRO\n"
msgstr ""

#. type: SS
#: build/C/man3/dl_iterate_phdr.3:298 build/C/man3/dlinfo.3:259 build/C/man3/dlopen.3:564 build/C/man3/end.3:88 build/C/man1/memusage.1:237
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:306
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:312
#, no-wrap
msgid ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    char *type;\n"
"    int p_type;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:315
#, no-wrap
msgid ""
"    printf(\"Name: \\e\"%s\\e\" (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"               info-E<gt>dlpi_phnum);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:328
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> info-E<gt>dlpi_phnum; j++) {\n"
"        p_type = info-E<gt>dlpi_phdr[j].p_type;\n"
"        type =  (p_type == PT_LOAD) ? \"PT_LOAD\" :\n"
"                (p_type == PT_DYNAMIC) ? \"PT_DYNAMIC\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_NOTE) ? \"PT_NOTE\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_PHDR) ? \"PT_PHDR\" :\n"
"                (p_type == PT_TLS) ? \"PT_TLS\" :\n"
"                (p_type == PT_GNU_EH_FRAME) ? \"PT_GNU_EH_FRAME\" :\n"
"                (p_type == PT_GNU_STACK) ? \"PT_GNU_STACK\" :\n"
"                (p_type == PT_GNU_RELRO) ? \"PT_GNU_RELRO\" : NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:338
#, no-wrap
msgid ""
"        printf(\"    %2d: [%14p; memsz:%7jx] flags: %#jx; \", j,\n"
"                (void *) (info-E<gt>dlpi_addr + "
"info-E<gt>dlpi_phdr[j].p_vaddr),\n"
"                (uintmax_t) info-E<gt>dlpi_phdr[j].p_memsz,\n"
"                (uintmax_t) info-E<gt>dlpi_phdr[j].p_flags);\n"
"        if (type != NULL)\n"
"            printf(\"%s\\en\", type);\n"
"        else\n"
"            printf(\"[other (%#x)]\\en\", p_type);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:341 build/C/man7/rtld-audit.7:579
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:346
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:349 build/C/man3/dlinfo.3:325 build/C/man3/end.3:107
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:350 build/C/man3/dladdr.3:284 build/C/man3/dlerror.3:87 build/C/man3/dlinfo.3:326 build/C/man3/dlopen.3:619 build/C/man3/dlsym.3:171 build/C/man5/elf.5:2159 build/C/man3/end.3:108 build/C/man8/ld.so.8:815 build/C/man8/ldconfig.8:215 build/C/man1/ldd.1:172 build/C/man1/memusage.1:274 build/C/man1/memusagestat.1:88 build/C/man1/mtrace.1:62 build/C/man1/pldd.1:119 build/C/man7/rtld-audit.7:620 build/C/man8/sln.8:60 build/C/man1/sprof.1:291
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:358
msgid ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dladdr>(3), B<dlopen>(3), "
"B<elf>(5), B<ld.so>(8)"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:361
msgid ""
"I<Executable and Linking Format Specification>, available at various "
"locations online."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:361 build/C/man3/dladdr.3:290 build/C/man3/dlerror.3:92 build/C/man3/dlinfo.3:333 build/C/man3/dlopen.3:633 build/C/man3/dlsym.3:178 build/C/man5/elf.5:2192 build/C/man3/end.3:113 build/C/man8/ld.so.8:833 build/C/man8/ldconfig.8:218 build/C/man1/ldd.1:177 build/C/man1/memusage.1:278 build/C/man1/memusagestat.1:91 build/C/man1/mtrace.1:65 build/C/man1/pldd.1:124 build/C/man7/rtld-audit.7:625 build/C/man8/sln.8:64 build/C/man1/sprof.1:295
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:369 build/C/man3/dladdr.3:298 build/C/man3/dlerror.3:100 build/C/man3/dlinfo.3:341 build/C/man3/dlopen.3:641 build/C/man3/dlsym.3:186 build/C/man5/elf.5:2200 build/C/man3/end.3:121 build/C/man8/ld.so.8:841 build/C/man8/ldconfig.8:226 build/C/man1/ldd.1:185 build/C/man1/memusage.1:286 build/C/man1/memusagestat.1:99 build/C/man1/mtrace.1:73 build/C/man1/pldd.1:132 build/C/man7/rtld-audit.7:633 build/C/man8/sln.8:72 build/C/man1/sprof.1:303
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/dladdr.3:26
#, no-wrap
msgid "DLADDR"
msgstr ""

#. type: TH
#: build/C/man3/dladdr.3:26 build/C/man8/ld.so.8:7
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man3/dladdr.3:26 build/C/man3/dlerror.3:25 build/C/man3/dlinfo.3:25 build/C/man3/dlopen.3:35 build/C/man3/dlsym.3:25 build/C/man5/elf.5:35 build/C/man7/rtld-audit.7:28 build/C/man1/sprof.1:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:29
msgid "dladdr, dladdr1 - translate address to symbolic information"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:35
#, no-wrap
msgid "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:38
#, no-wrap
msgid ""
"B<int dladdr1(void *>I<addr>B<, Dl_info *>I<info>B<, void "
"**>I<extra_info>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:40 build/C/man3/dlinfo.3:37
#, no-wrap
msgid "Link with I<-ldl>.\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:54
msgid ""
"The function B<dladdr>()  determines whether the address specified in "
"I<addr> is located in one of the shared objects loaded by the calling "
"application.  If it is, then B<dladdr>()  returns information about the "
"shared object and symbol that overlaps I<addr>.  This information is "
"returned in a I<Dl_info> structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:67
#, no-wrap
msgid ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Base address at which shared\n"
"                               object is loaded */\n"
"    const char *dli_sname;  /* Name of symbol whose definition\n"
"                               overlaps I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:77
msgid ""
"If no symbol matching I<addr> could be found, then I<dli_sname> and "
"I<dli_saddr> are set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:87
msgid ""
"The function B<dladdr1>()  is like B<dladdr>(), but returns additional "
"information via the argument I<extra_info>.  The information returned "
"depends on the value specified in I<flags>, which can have one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man3/dladdr.3:87
#, no-wrap
msgid "B<RTLD_DL_LINKMAP>"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:99
msgid ""
"Obtain a pointer to the link map for the matched file.  The I<extra_info> "
"argument points to a pointer to a I<link_map> structure (i.e., I<struct "
"link_map\\ **>), defined in I<E<lt>link.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:112 build/C/man3/dlinfo.3:93
#, no-wrap
msgid ""
"struct link_map {\n"
"    ElfW(Addr) l_addr;  /* Difference between the\n"
"                           address in the ELF file and\n"
"                           the address in memory */\n"
"    char      *l_name;  /* Absolute pathname where\n"
"                           object was found */\n"
"    ElfW(Dyn) *l_ld;    /* Dynamic section of the\n"
"                           shared object */\n"
"    struct link_map *l_next, *l_prev;\n"
"                        /* Chain of loaded objects */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:116 build/C/man3/dlinfo.3:97
#, no-wrap
msgid ""
"    /* Plus additional fields private to the\n"
"       implementation */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man3/dladdr.3:118
#, no-wrap
msgid "B<RTLD_DL_SYMENT>"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:136
msgid ""
"Obtain a pointer to the ELF symbol table entry of the matching symbol.  The "
"I<extra_info> argument is a pointer to a symbol pointer: I<const ElfW(Sym) "
"**>.  The I<ElfW>()  macro definition turns its argument into the name of an "
"ELF data type suitable for the hardware architecture.  For example, on a "
"64-bit platform, I<ElfW(Sym)> yields the data type name I<Elf64_Sym>, which "
"is defined in I<E<lt>elf.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:147
#, no-wrap
msgid ""
"typedef struct  {\n"
"    Elf64_Word    st_name;     /* Symbol name */\n"
"    unsigned char st_info;     /* Symbol type and binding */\n"
"    unsigned char st_other;    /* Symbol visibility */\n"
"    Elf64_Section st_shndx;    /* Section index */\n"
"    Elf64_Addr    st_value;    /* Symbol value */\n"
"    Elf64_Xword   st_size;     /* Symbol size */\n"
"} Elf64_Sym;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:153
msgid "The I<st_name> field is an index into the string table."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:162
msgid ""
"The I<st_info> field encodes the symbol's type and binding.  The type can be "
"extracted using the macro B<ELF64_ST_TYPE(st_info)> (or B<ELF32_ST_TYPE()> "
"on 32-bit platforms), which yields one of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:166 build/C/man3/dladdr.3:189 build/C/man3/dladdr.3:208
#, no-wrap
msgid "Description"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:167
#, no-wrap
msgid "STT_NOTYPE"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:167
#, no-wrap
msgid "Symbol type is unspecified"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:168
#, no-wrap
msgid "STT_OBJECT"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:168
#, no-wrap
msgid "Symbol is a data object"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:169
#, no-wrap
msgid "STT_FUNC"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:169
#, no-wrap
msgid "Symbol is a code object"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:170
#, no-wrap
msgid "STT_SECTION"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:170
#, no-wrap
msgid "Symbol associated with a section"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:171
#, no-wrap
msgid "STT_FILE"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:171
#, no-wrap
msgid "Symbol's name is filename"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:172
#, no-wrap
msgid "STT_COMMON"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:172
#, no-wrap
msgid "Symbol is a common data object"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:173
#, no-wrap
msgid "STT_TLS"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:173
#, no-wrap
msgid "Symbol is thread-local data object"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:174
#, no-wrap
msgid "STT_GNU_IFUNC"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:174
#, no-wrap
msgid "Symbol is indirect code object"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:185
msgid ""
"The symbol binding can be extracted from the I<st_info> field using the "
"macro B<ELF64_ST_BIND(st_info)> (or B<ELF32_ST_BIND()> on 32-bit platforms), "
"which yields one of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:190
#, no-wrap
msgid "STB_LOCAL"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:190
#, no-wrap
msgid "Local symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:191
#, no-wrap
msgid "STB_GLOBAL"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:191
#, no-wrap
msgid "Global symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:192
#, no-wrap
msgid "STB_WEAK"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:192
#, no-wrap
msgid "Weak symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:193
#, no-wrap
msgid "STB_GNU_UNIQUE"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:193
#, no-wrap
msgid "Unique symbol"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:204
msgid ""
"The I<st_other> field contains the symbol's visibility, which can be "
"extracted using the macro B<ELF64_ST_VISIBILITY(st_info)> (or "
"B<ELF32_ST_VISIBILITY()> on 32-bit platforms), which yields one of the "
"following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:209
#, no-wrap
msgid "STV_DEFAULT"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:209
#, no-wrap
msgid "Default symbol visibility rules"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:210
#, no-wrap
msgid "STV_INTERNAL"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:210
#, no-wrap
msgid "Processor-specific hidden class"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:211
#, no-wrap
msgid "STV_HIDDEN"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:211
#, no-wrap
msgid "Symbol unavailable in other modules"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:212
#, no-wrap
msgid "STV_PROTECTED"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:212
#, no-wrap
msgid "Not preemptible, not exported"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:225
msgid ""
"On success, these functions return a nonzero value.  If the address "
"specified in I<addr> could be matched to a shared object, but not to a "
"symbol in the shared object, then the I<info-E<gt>dli_sname> and "
"I<info-E<gt>dli_saddr> fields are set to NULL."
msgstr ""

#.  According to the FreeBSD man page, dladdr1() does signal an
#.  error via dlerror() for this case.
#. type: Plain text
#: build/C/man3/dladdr.3:235
msgid ""
"If the address specified in I<addr> could not be matched to a shared object, "
"then these functions return 0.  In this case, an error message is I<not> "
"available via B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:240
msgid ""
"B<dladdr>()  is present in glibc 2.0 and later.  B<dladdr1>()  first "
"appeared in glibc 2.3.3."
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:251
#, no-wrap
msgid ""
"B<dladdr>(),\n"
"B<dladdr1>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:256
msgid ""
"These functions are nonstandard GNU extensions that are also present on "
"Solaris."
msgstr ""

#. type: SH
#: build/C/man3/dladdr.3:256 build/C/man3/dlopen.3:534 build/C/man1/ldd.1:155 build/C/man1/memusage.1:200 build/C/man1/memusagestat.1:81 build/C/man1/mtrace.1:58 build/C/man1/pldd.1:99 build/C/man7/rtld-audit.7:509
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:268
msgid ""
"Sometimes, the function pointers you pass to B<dladdr>()  may surprise you.  "
"On some architectures (notably i386 and x86-64), I<dli_fname> and "
"I<dli_fbase> may end up pointing back at the object from which you called "
"B<dladdr>(), even if the function used as an argument should come from a "
"dynamically linked library."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:284
msgid ""
"The problem is that the function pointer will still be resolved at compile "
"time, but merely point to the I<plt> (Procedure Linkage Table)  section of "
"the original object (which dispatches the call after asking the dynamic "
"linker to resolve the symbol).  To work around this, you can try to compile "
"the code to be position-independent: then, the compiler cannot prepare the "
"pointer at compile time any more and B<gcc>(1)  will generate code that just "
"loads the final symbol address from the I<got> (Global Offset Table) at run "
"time before passing it to B<dladdr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:290
msgid "B<dl_iterate_phdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man3/dlerror.3:25
#, no-wrap
msgid "DLERROR"
msgstr ""

#. type: TH
#: build/C/man3/dlerror.3:25 build/C/man3/dlsym.3:25 build/C/man3/end.3:26 build/C/man8/ldconfig.8:22 build/C/man1/memusagestat.1:23
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:28
msgid "dlerror - obtain error diagnostic for functions in the dlopen API"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:30 build/C/man3/dlopen.3:41 build/C/man3/dlopen.3:49 build/C/man3/dlsym.3:30 build/C/man3/dlsym.3:36
msgid "B<#include E<lt>dlfcn.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:32
msgid "B<char *dlerror(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:34 build/C/man3/dlopen.3:53 build/C/man3/dlsym.3:40
msgid "Link with I<-ldl>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:45
msgid ""
"The B<dlerror>()  function returns a human-readable, null-terminated string "
"describing the most recent error that occurred from a call to one of the "
"functions in the dlopen API since the last call to B<dlerror>().  The "
"returned string does I<not> include a trailing newline."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:49
msgid ""
"B<dlerror>()  returns NULL if no errors have occurred since initialization "
"or since it was last called."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:52
msgid "B<dlerror>()  is present in glibc 2.0 and later."
msgstr ""

#. type: tbl table
#: build/C/man3/dlerror.3:62
#, no-wrap
msgid "B<dlerror>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:66
msgid "POSIX.1-2001."
msgstr ""

#.  .LP
#.  The string returned by
#.  .BR dlerror ()
#.  should not be modified.
#.  Some systems give the prototype as
#.  .sp
#.  .in +5
#.  .B "const char *dlerror(void);"
#.  .in
#. type: Plain text
#: build/C/man3/dlerror.3:82
msgid ""
"The message returned by B<dlerror>()  may reside in a statically allocated "
"buffer that is overwritten by subsequent B<dlerror>()  calls."
msgstr ""

#. type: SS
#: build/C/man3/dlerror.3:82 build/C/man3/dlopen.3:532 build/C/man3/dlsym.3:162
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:84
msgid "This function is part of the dlopen API, derived from SunOS."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:87 build/C/man3/dlsym.3:171
msgid "See B<dlopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:92
msgid "B<dladdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3)"
msgstr ""

#. type: TH
#: build/C/man3/dlinfo.3:25
#, no-wrap
msgid "DLINFO"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:28
msgid "dlinfo - obtain information about a dynamically loaded object"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>link.hE<gt>>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:35
#, no-wrap
msgid "B<int dlinfo(void *>handleB<, int >requestB<, void *>infoB<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:56
msgid ""
"The B<dlinfo>()  function obtains information about the dynamically loaded "
"object referred to by I<handle> (typically obtained by an earlier call to "
"B<dlopen>(3)  or B<dlmopen>(3)).  The I<request> argument specifies which "
"information is to be returned.  The I<info> argument is a pointer to a "
"buffer used to store information returned by the call; the type of this "
"argument depends on I<request>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:62
msgid ""
"The following values are supported for I<request> (with the corresponding "
"type for I<info> shown in parentheses):"
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:62
#, no-wrap
msgid "B<RTLD_DI_LMID> (I<Lmid_t *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:67
msgid "Obtain the ID of the link-map list (namespace) in which I<handle> is loaded."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:67
#, no-wrap
msgid "B<RTLD_DI_LINKMAP> (I<struct link_map **>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:80
msgid ""
"Obtain a pointer to the I<link_map> structure corresponding to I<handle>.  "
"The I<info> argument points to a pointer to a I<link_map> structure, defined "
"in I<E<lt>link.hE<gt>> as:"
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:99
#, no-wrap
msgid "B<RTLD_DI_ORIGIN> (I<char *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:105
msgid ""
"Copy the pathname of the origin of the shared object corresponding to "
"I<handle> to the location pointed to by I<info>."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:105
#, no-wrap
msgid "B<RTLD_DI_SERINFO> (I<Dl_serinfo *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:122
msgid ""
"Obtain the library search paths for the shared object referred to by "
"I<handle>.  The I<info> argument is a pointer to a I<Dl_serinfo> that "
"contains the search paths.  Because the number of search paths may vary, the "
"size of the structure pointed to by I<info> can vary.  The "
"B<RTLD_DI_SERINFOSIZE> request described below allows applications to size "
"the buffer suitably.  The caller must perform the following steps:"
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:123
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:133
msgid ""
"Use a B<RTLD_DI_SERINFOSIZE> request to populate a I<Dl_serinfo> structure "
"with the size (I<dls_size>)  of the structure needed for the subsequent "
"B<RTLD_DI_SERINFO> request."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:133
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:138
msgid "Allocate a I<Dl_serinfo> buffer of the correct size (I<dls_size>)."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:138
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:146
msgid ""
"Use a further B<RTLD_DI_SERINFOSIZE> request to populate the I<dls_size> and "
"I<dls_cnt> fields of the buffer allocated in the previous step."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:146
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:150
msgid "Use a B<RTLD_DI_SERINFO> to obtain the library search paths."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:155
msgid "The I<Dl_serinfo> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:166
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t dls_size;           /* Size in bytes of\n"
"                                  the whole buffer */\n"
"    unsigned int dls_cnt;      /* Number of elements\n"
"                                  in \\(aqdls_serpath\\(aq */\n"
"    Dl_serpath dls_serpath[1]; /* Actually longer,\n"
"                                  \\(aqdls_cnt\\(aq elements */\n"
"} Dl_serinfo;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:172
msgid ""
"Each of the I<dls_serpath> elements in the above structure is a structure of "
"the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:181
#, no-wrap
msgid ""
"typedef struct {\n"
"    char *dls_name;            /* Name of library search\n"
"                                  path directory */\n"
"    unsigned int dls_flags;    /* Indicates where this\n"
"                                  directory came from */\n"
"} Dl_serpath;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:187
msgid "The I<dls_flags> field is currently unused, and always contains zero."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:187
#, no-wrap
msgid "B<RTLD_DI_SERINFOSIZE> (I<Dl_serinfo *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:200
msgid ""
"Populate the I<dls_size> and I<dls_cnt> fields of the I<Dl_serinfo> "
"structure pointed to by I<info> with values suitable for allocating a buffer "
"for use in a subsequent B<RTLD_DI_SERINFO> request."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:200
#, no-wrap
msgid "B<RTLD_DI_TLS_MODID> (I<size_t *>, since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:206
msgid ""
"Obtain the module ID of this shared object's TLS (thread-local storage)  "
"segment, as used in TLS relocations.  If this object does not define a TLS "
"segment, zero is placed in I<*info>."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:206
#, no-wrap
msgid "B<RTLD_DI_TLS_DATA> (I<void **>, since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:214
msgid ""
"Obtain a pointer to the calling thread's TLS block corresponding to this "
"shared object's TLS segment.  If this object does not define a PT_TLS "
"segment, or if the calling thread has not allocated a block for it, NULL is "
"placed in I<*info>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:220
msgid ""
"On success, B<dlinfo>()  returns 0.  On failure, it returns -1; the cause of "
"the error can be diagnosed using B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:223
msgid "B<dlinfo>()  first appeared in glibc 2.3.3."
msgstr ""

#. type: tbl table
#: build/C/man3/dlinfo.3:233
#, no-wrap
msgid "B<dlinfo>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:237
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:242
msgid ""
"This function derives from the Solaris function of the same name and also "
"appears on some other systems.  The sets of requests supported by the "
"various implementations overlaps only partially."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:251
msgid ""
"The program below opens a shared objects using B<dlopen>(3)  and then uses "
"the B<RTLD_DI_SERINFOSIZE> and B<RTLD_DI_SERINFO> requests to obtain the "
"library search path list for the library.  Here is an example of what we "
"might see when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:257
#, no-wrap
msgid ""
"$ B<./a.out /lib64/libm.so.6>\n"
"dls_serpath[0].dls_name = /lib64\n"
"dls_serpath[1].dls_name = /usr/lib64\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:267
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    void *handle;\n"
"    Dl_serinfo serinfo;\n"
"    Dl_serinfo *sip;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:279
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>libpathE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:281
#, no-wrap
msgid "    /* Obtain a handle for shared object specified on command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:287
#, no-wrap
msgid ""
"    handle = dlopen(argv[1], RTLD_NOW);\n"
"    if (handle == NULL) {\n"
"        fprintf(stderr, \"dlopen() failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:290
#, no-wrap
msgid ""
"    /* Discover the size of the buffer that we must pass to\n"
"       RTLD_DI_SERINFO */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:295
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", "
"dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:297
#, no-wrap
msgid "    /* Allocate the buffer for use with RTLD_DI_SERINFO */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:303
#, no-wrap
msgid ""
"    sip = malloc(serinfo.dls_size);\n"
"    if (sip == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:306
#, no-wrap
msgid ""
"    /* Initialize the \\(aqdls_size\\(aq and \\(aqdls_cnt\\(aq fields in the "
"newly\n"
"       allocated buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:311
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", "
"dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:313
#, no-wrap
msgid "    /* Fetch and print library search list */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:318
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFO failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:322
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> serinfo.dls_cnt; j++)\n"
"        printf(\"dls_serpath[%d].dls_name = %s\\en\",\n"
"                j, sip-E<gt>dls_serpath[j].dls_name);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:333
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlopen>(3), "
"B<dlsym>(3), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "DLOPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:39
msgid "dlclose, dlopen, dlmopen - open and close a shared object"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:43
msgid "B<void *dlopen(const char *>I<filename>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:45
msgid "B<int dlclose(void *>I<handle>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:47 build/C/man3/dlsym.3:34
msgid "B<#define _GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:51
msgid ""
"B<void *dlmopen(Lmid_t >I<lmid>B<, const char *>I<filename>B<, int "
">I<flags>B<);>"
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:54
#, no-wrap
msgid "dlopen()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:68
msgid ""
"The function B<dlopen>()  loads the dynamic shared object (shared library)  "
"file named by the null-terminated string I<filename> and returns an opaque "
"\"handle\" for the loaded object.  This handle is employed with other "
"functions in the dlopen API, such as B<dlsym>(3), B<dladdr>(3), "
"B<dlinfo>(3), and B<dlclose>()."
msgstr ""

#.  FIXME On Solaris, when handle is NULL, we seem to get back
#.  a handle for (something like) the root of the namespace.
#.  The point here is that if we do a dlmopen(LM_ID_NEWLM), then
#.  the filename==NULL case returns a different handle than
#.  in the initial namespace. But, on glibc, the same handle is
#.  returned. This is probably a bug in glibc.
#. type: Plain text
#: build/C/man3/dlopen.3:87
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"If I<filename> contains a slash (\"/\"), then it is interpreted as a "
"(relative or absolute) pathname.  Otherwise, the dynamic linker searches for "
"the object as follows (see B<ld.so>(8)  for further details):"
msgstr ""

#. type: IP
#: build/C/man3/dlopen.3:87 build/C/man3/dlopen.3:94 build/C/man3/dlopen.3:101 build/C/man3/dlopen.3:105 build/C/man3/dlopen.3:112 build/C/man8/ld.so.8:60 build/C/man8/ld.so.8:65 build/C/man8/ld.so.8:70 build/C/man8/ld.so.8:80 build/C/man8/ld.so.8:90 build/C/man8/ld.so.8:105 build/C/man8/ld.so.8:111 build/C/man8/ld.so.8:120 build/C/man8/ld.so.8:129
#, no-wrap
msgid "o"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:94
msgid ""
"(ELF only) If the calling object (i.e., the shared library or executable "
"from which B<dlopen>()  is called)  contains a DT_RPATH tag, and does not "
"contain a DT_RUNPATH tag, then the directories listed in the DT_RPATH tag "
"are searched."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:101
msgid ""
"If, at the time that the program was started, the environment variable "
"B<LD_LIBRARY_PATH> was defined to contain a colon-separated list of "
"directories, then these are searched.  (As a security measure, this variable "
"is ignored for set-user-ID and set-group-ID programs.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:105
msgid ""
"(ELF only) If the calling object contains a DT_RUNPATH tag, then the "
"directories listed in that tag are searched."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:112
msgid ""
"The cache file I</etc/ld.so.cache> (maintained by B<ldconfig>(8))  is "
"checked to see whether it contains an entry for I<filename>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:118
msgid "The directories I</lib> and I</usr/lib> are searched (in that order)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:126
msgid ""
"If the object specified by I<filename> has dependencies on other shared "
"objects, then these are also automatically loaded by the dynamic linker "
"using the same rules.  (This process may occur recursively, if those objects "
"in turn have dependencies, and so on.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:129
msgid "One of the following two values must be included in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:129
#, no-wrap
msgid "B<RTLD_LAZY>"
msgstr ""

#.  commit 12b5b6b7f78ea111e89bbf638294a5413c791072
#. type: Plain text
#: build/C/man3/dlopen.3:142
msgid ""
"Perform lazy binding.  Resolve symbols only as the code that references them "
"is executed.  If the symbol is never referenced, then it is never resolved.  "
"(Lazy binding is performed only for function references; references to "
"variables are always immediately bound when the shared object is loaded.)  "
"Since glibc 2.1.1, this flag is overridden by the effect of the "
"B<LD_BIND_NOW> environment variable."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:142
#, no-wrap
msgid "B<RTLD_NOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:151
msgid ""
"If this value is specified, or the environment variable B<LD_BIND_NOW> is "
"set to a nonempty string, all undefined symbols in the shared object are "
"resolved before B<dlopen>()  returns.  If this cannot be done, an error is "
"returned."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:154
msgid "Zero or more of the following values may also be ORed in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:154
#, no-wrap
msgid "B<RTLD_GLOBAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:158
msgid ""
"The symbols defined by this shared object will be made available for symbol "
"resolution of subsequently loaded shared objects."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:158
#, no-wrap
msgid "B<RTLD_LOCAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:165
msgid ""
"This is the converse of B<RTLD_GLOBAL>, and the default if neither flag is "
"specified.  Symbols defined in this shared object are not made available to "
"resolve references in subsequently loaded shared objects."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:165
#, no-wrap
msgid "B<RTLD_NODELETE> (since glibc 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:173
msgid ""
"Do not unload the shared object during B<dlclose>().  Consequently, the "
"object's static and global variables are not reinitialized if the object is "
"reloaded with B<dlopen>()  at a later time."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:173
#, no-wrap
msgid "B<RTLD_NOLOAD> (since glibc 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:186
msgid ""
"Don't load the shared object.  This can be used to test if the object is "
"already resident (B<dlopen>()  returns NULL if it is not, or the object's "
"handle if it is resident).  This flag can also be used to promote the flags "
"on a shared object that is already loaded.  For example, a shared object "
"that was previously loaded with B<RTLD_LOCAL> can be reopened with "
"B<RTLD_NOLOAD\\ |\\ RTLD_GLOBAL>."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:186
#, no-wrap
msgid "B<RTLD_DEEPBIND> (since glibc 2.3.4)"
msgstr ""

#.  Inimitably described by UD in
#.  http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
#. type: Plain text
#: build/C/man3/dlopen.3:195
msgid ""
"Place the lookup scope of the symbols in this shared object ahead of the "
"global scope.  This means that a self-contained object will use its own "
"symbols in preference to global symbols with the same name contained in "
"objects that have already been loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:207
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"When given to B<dlsym>(3), this handle causes a search for a symbol in the "
"main program, followed by all shared objects loaded at program startup, and "
"then all shared objects loaded by B<dlopen>()  with the flag B<RTLD_GLOBAL>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:219
msgid ""
"Symbol references in the shared object are resolved using (in order): "
"symbols in the link map of objects loaded for the main program and its "
"dependencies; symbols in shared objects (and their dependencies)  that were "
"previously opened with B<dlopen>()  using the B<RTLD_GLOBAL> flag; and "
"definitions in the shared object itself (and any dependencies that were "
"loaded for that object)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:231
msgid ""
"Any global symbols in the executable that were placed into its dynamic "
"symbol table by B<ld>(1)  can also be used to resolve references in a "
"dynamically loaded shared object.  Symbols may be placed in the dynamic "
"symbol table either because the executable was linked with the flag "
"\"-rdynamic\" (or, synonymously, \"--export-dynamic\"), which causes all of "
"the executable's global symbols to be placed in the dynamic symbol table, or "
"because B<ld>(1)  noted a dependency on a symbol in another object during "
"static linking."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:244
msgid ""
"If the same shared object is opened again with B<dlopen>(), the same object "
"handle is returned.  The dynamic linker maintains reference counts for "
"object handles, so a dynamically loaded shared object is not deallocated "
"until B<dlclose>()  has been called on it as many times as B<dlopen>()  has "
"succeeded on it.  Constructors (see below) are called only when the object "
"is actually loaded into memory (i.e., when the reference count increases to "
"1)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:257
msgid ""
"A subsequent B<dlopen>()  call that loads the same shared object with "
"B<RTLD_NOW> may force symbol resolution for a shared object earlier loaded "
"with B<RTLD_LAZY>.  Similarly, an object that was previously opened with "
"B<RTLD_LOCAL> can be promoted to B<RTLD_GLOBAL> in a subsequent B<dlopen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:262
msgid "If B<dlopen>()  fails for any reason, it returns NULL."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:262
#, no-wrap
msgid "dlmopen()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:270
msgid ""
"This function performs the same task as B<dlopen>()\\(emthe I<filename> and "
"I<flags> arguments, as well as the return value, are the same, except for "
"the differences noted below."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:289
msgid ""
"The B<dlmopen>()  function differs from B<dlopen>()  primarily in that it "
"accepts an additional argument, I<lmid>, that specifies the link-map list "
"(also referred to as a I<namespace>)  in which the shared object should be "
"loaded.  (By comparison, B<dlopen>()  adds the dynamically loaded shared "
"object to the same namespace as the shared object from which the B<dlopen>()  "
"call is made.)  The I<Lmid_t> type is an opaque handle that refers to a "
"namespace."
msgstr ""

#.  FIXME: Is using dlinfo() RTLD_DI_LMID the right technique?
#. type: Plain text
#: build/C/man3/dlopen.3:298
msgid ""
"The I<lmid> argument is either the ID of an existing namespace (which can be "
"obtained using the B<dlinfo>(3)  B<RTLD_DI_LMID> request) or one of the "
"following special values:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:298 build/C/man7/rtld-audit.7:198
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:302
msgid ""
"Load the shared object in the initial namespace (i.e., the application's "
"namespace)."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:302 build/C/man7/rtld-audit.7:201
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:308
msgid ""
"Create a new namespace and load the shared object in that namespace.  The "
"object must have been correctly linked to reference all of the other shared "
"objects that it requires, since the new namespace is initially empty."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:315
msgid ""
"If I<filename> is NULL, then the only permitted value for I<lmid> is "
"B<LM_ID_BASE>."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:315
#, no-wrap
msgid "dlclose()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:321
msgid ""
"The function B<dlclose>()  decrements the reference count on the dynamically "
"loaded shared object referred to by I<handle>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:330
msgid ""
"If the object's reference count drops to zero and no symbols in this object "
"are required by other objects, then the object is unloaded after first "
"calling any destructors defined for the object.  (Symbols in this object "
"might be required in another object because this object was opened with the "
"B<RTLD_GLOBAL> flag and one of its symbols satisfied a relocation in another "
"object.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:336
msgid ""
"All shared objects that were automatically loaded when B<dlopen>()  was "
"invoked on the object referred to by I<handle> are recursively closed in the "
"same manner."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:348
msgid ""
"A successful return from B<dlclose>()  does not guarantee that the symbols "
"associated with I<handle> are removed from the caller's address space.  In "
"addition to references resulting from explicit B<dlopen>()  calls, a shared "
"object may have been implicitly loaded (and reference counted) because of "
"dependencies in other shared objects.  Only when all references have been "
"released can the shared object be removed from the address space."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:358
msgid ""
"On success, B<dlopen>()  and B<dlmopen>()  return a non-NULL handle for the "
"loaded object.  On error (file could not be found, was not readable, had the "
"wrong format, or caused errors during loading), these functions return NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:362
msgid "On success, B<dlclose>()  returns 0; on error, it returns a nonzero value."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:365
msgid "Errors from these functions can be diagnosed using B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:372
msgid ""
"B<dlopen>()  and B<dlclose>()  are present in glibc 2.0 and later.  "
"B<dlmopen>()  first appeared in glibc 2.3.4."
msgstr ""

#. type: tbl table
#: build/C/man3/dlopen.3:384
#, no-wrap
msgid ""
"B<dlopen>(),\n"
"B<dlmopen>(),\n"
"B<dlclose>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:394
msgid ""
"POSIX.1-2001 describes B<dlclose>()  and B<dlopen>().  The B<dlmopen>()  "
"function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:402
msgid ""
"The B<RTLD_NOLOAD>, B<RTLD_NODELETE>, and B<RTLD_DEEPBIND> flags are GNU "
"extensions; the first two of these flags are also present on Solaris."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:403
#, no-wrap
msgid "dlmopen() and namespaces"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:411
msgid ""
"A link-map list defines an isolated namespace for the resolution of symbols "
"by the dynamic linker.  Within a namespace, dependent shared objects are "
"implicitly loaded according to the usual rules, and symbol references are "
"likewise resolved according to the usual rules, but such resolution is "
"confined to the definitions provided by the objects that have been "
"(explicitly and implicitly) loaded into the namespace."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:431
msgid ""
"The B<dlmopen>()  function permits object-load isolation\\(emthe ability to "
"load a shared object in a new namespace without exposing the rest of the "
"application to the symbols made available by the new object.  Note that the "
"use of the B<RTLD_LOCAL> flag is not sufficient for this purpose, since it "
"prevents a shared object's symbols from being available to I<any> other "
"shared object.  In some cases, we may want to make the symbols provided by a "
"dynamically loaded shared object available to (a subset of) other shared "
"objects without exposing those symbols to the entire application.  This can "
"be achieved by using a separate namespace and the B<RTLD_GLOBAL> flag."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:447
msgid ""
"The B<dlmopen>()  function also can be used to provide better isolation than "
"the B<RTLD_LOCAL> flag.  In particular, shared objects loaded with "
"B<RTLD_LOCAL> may be promoted to B<RTLD_GLOBAL> if they are dependencies of "
"another shared object loaded with B<RTLD_GLOBAL>.  Thus, B<RTLD_LOCAL> is "
"insufficient to isolate a loaded shared object except in the (uncommon)  "
"case where one has explicit control over all shared object dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:462
msgid ""
"Possible uses of B<dlmopen>()  are plugins where the author of the "
"plugin-loading framework can't trust the plugin authors and does not wish "
"any undefined symbols from the plugin framework to be resolved to plugin "
"symbols.  Another use is to load the same object more than once.  Without "
"the use of B<dlmopen>(), this would require the creation of distinct copies "
"of the shared object file.  Using B<dlmopen>(), this can be achieved by "
"loading the same shared object file into different namespaces."
msgstr ""

#.  DL_NNS
#. type: Plain text
#: build/C/man3/dlopen.3:467
msgid "The glibc implementation supports a maximum of 16 namespaces."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:467
#, no-wrap
msgid "Initialization and finalization functions"
msgstr ""

#.  info gcc "C Extensions" "Function attributes"
#. type: Plain text
#: build/C/man3/dlopen.3:486
msgid ""
"Shared objects may export functions using the "
"B<__attribute__((constructor))> and B<__attribute__((destructor))> function "
"attributes.  Constructor functions are executed before B<dlopen>()  returns, "
"and destructor functions are executed before B<dlclose>()  returns.  A "
"shared object may export multiple constructors and destructors, and "
"priorities can be associated with each function to determine the order in "
"which they are executed.  See the B<gcc> info pages (under \"Function "
"attributes\")  for further information."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:506
msgid ""
"An older method of (partially) achieving the same result is via the use of "
"two special symbols recognized by the linker: B<_init> and B<_fini>.  If a "
"dynamically loaded shared object exports a routine named B<_init>(), then "
"that code is executed after loading a shared object, before B<dlopen>()  "
"returns.  If the shared object exports a routine named B<_fini>(), then that "
"routine is called just before the object is unloaded.  In this case, one "
"must avoid linking against the system startup files, which contain default "
"versions of these files; this can be done by using the B<gcc>(1)  "
"I<-nostartfiles> command-line option."
msgstr ""

#
#.  Using these routines, or the gcc
#.  .B \-nostartfiles
#.  or
#.  .B \-nostdlib
#.  options, is not recommended.
#.  Their use may result in undesired behavior,
#.  since the constructor/destructor routines will not be executed
#.  (unless special measures are taken).
#.  .\" void _init(void) __attribute__((constructor));
#.  .\" void _fini(void) __attribute__((destructor));
#. type: Plain text
#: build/C/man3/dlopen.3:527
msgid ""
"Use of B<_init> and B<_fini> is now deprecated in favor of the "
"aforementioned constructors and destructors, which among other advantages, "
"permit multiple initialization and finalization functions to be defined."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:532
msgid ""
"Since glibc 2.2.3, B<atexit>(3)  can be used to register an exit handler "
"that is automatically called when a shared object is unloaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:534
msgid "These functions are part of the dlopen API, derived from SunOS."
msgstr ""

#.  dlerror(): "invalid mode"
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=18684
#. type: Plain text
#: build/C/man3/dlopen.3:550
msgid ""
"As at glibc 2.24, specifying the B<RTLD_GLOBAL> flag when calling "
"B<dlmopen>()  generates an error.  Furthermore, specifying B<RTLD_GLOBAL> "
"when calling B<dlopen>()  results in a program crash (B<SIGSEGV>)  if the "
"call is made from any object loaded in a namespace other than the initial "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:556
msgid ""
"The program below loads the (glibc) math library, looks up the address of "
"the B<cos>(3)  function, and prints the cosine of 2.0.  The following is an "
"example of building and running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:562
#, no-wrap
msgid ""
"$ B<cc dlopen_demo.c -ldl>\n"
"$ B<./a.out>\n"
"-0.416147\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:578
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>gnu/lib-names.hE<gt>  /* Defines LIBM_SO (which will be a\n"
"                               string such as \"libm.so.6\") */\n"
"int\n"
"main(void)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:584
#, no-wrap
msgid ""
"    handle = dlopen(LIBM_SO, RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:586
#, no-wrap
msgid "    dlerror();    /* Clear any existing error */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:588
#, no-wrap
msgid "    cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:593
#, no-wrap
msgid ""
"    /* According to the ISO C standard, casting between function\n"
"       pointers and \\(aqvoid *\\(aq, as done above, produces undefined "
"results.\n"
"       POSIX.1-2001 and POSIX.1-2008 accepted this state of affairs and\n"
"       proposed the following workaround:\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:595
#, no-wrap
msgid "           *(void **) (&cosine) = dlsym(handle, \"cos\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:598
#, no-wrap
msgid ""
"       This (clumsy) cast conforms with the ISO C standard and will\n"
"       avoid any compiler warnings.\n"
msgstr ""

#.  http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html#tag_03_112_08
#.  http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html#tag_16_96_07
#.  http://austingroupbugs.net/view.php?id=74
#. type: Plain text
#: build/C/man3/dlopen.3:607
#, no-wrap
msgid ""
"       The 2013 Technical Corrigendum 1 to POSIX.1-2008 improved matters\n"
"       by requiring that conforming implementations support casting\n"
"       \\(aqvoid *\\(aq to a function pointer.  Nevertheless, some "
"compilers\n"
"       (e.g., gcc with the \\(aq-pedantic\\(aq option) may complain about "
"the\n"
"       cast used in this program. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:613
#, no-wrap
msgid ""
"    error = dlerror();\n"
"    if (error != NULL) {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:618
#, no-wrap
msgid ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:631
msgid ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<dl_iterate_phdr>(3), B<dladdr>(3), "
"B<dlerror>(3), B<dlinfo>(3), B<dlsym>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:633
msgid "gcc info pages, ld info pages"
msgstr ""

#. type: TH
#: build/C/man3/dlsym.3:25
#, no-wrap
msgid "DLSYM"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:28
msgid "dlsym, dlvsym - obtain address of a symbol in a shared object or executable"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:32
msgid "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:38
msgid ""
"B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char "
"*>I<version>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:57
msgid ""
"The function B<dlsym>()  takes a \"handle\" of a dynamic loaded shared "
"object returned by B<dlopen>(3)  along with a null-terminated symbol name, "
"and returns the address where that symbol is loaded into memory.  If the "
"symbol is not found, in the specified object or any of the shared objects "
"that were automatically loaded by B<dlopen>(3)  when that object was loaded, "
"B<dlsym>()  returns NULL.  (The search performed by B<dlsym>()  is breadth "
"first through the dependency tree of these shared objects.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:71
msgid ""
"In unusual cases (see NOTES) the value of the symbol could actually be "
"NULL.  Therefore, a NULL return from B<dlsym>()  need not indicate an "
"error.  The correct way to distinguish an error from a symbol whose value is "
"NULL is to call B<dlerror>(3)  to clear any old error conditions, then call "
"B<dlsym>(), and then call B<dlerror>(3)  again, saving its return value into "
"a variable, and check whether this saved value is not NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:74
msgid "There are two special pseudo-handles that may be specified in I<handle>:"
msgstr ""

#. type: TP
#: build/C/man3/dlsym.3:74
#, no-wrap
msgid "B<RTLD_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:83
msgid ""
"Find the first occurrence of the desired symbol using the default shared "
"object search order.  The search will include global symbols in the "
"executable and its dependencies, as well as symbols in shared objects that "
"were dynamically loaded with the B<RTLD_GLOBAL> flag."
msgstr ""

#. type: TP
#: build/C/man3/dlsym.3:83
#, no-wrap
msgid "B<RTLD_NEXT>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:97
msgid ""
"Find the next occurrence of the desired symbol in the search order after the "
"current object.  This allows one to provide a wrapper around a function in "
"another shared object, so that, for example, the definition of a function in "
"a preloaded shared object (see B<LD_PRELOAD> in B<ld.so>(8))  can find and "
"invoke the \"real\" function provided in another shared object (or for that "
"matter, the \"next\" definition of the function in cases where there are "
"multiple layers of preloading)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:107
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<RTLD_DEFAULT> and B<RTLD_NEXT> from I<E<lt>dlfcn.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:113
msgid ""
"The function B<dlvsym>()  does the same as B<dlsym>()  but takes a version "
"string as an additional argument."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:120
msgid ""
"On success, these functions return the address associated with I<symbol>.  "
"On failure, they return NULL; the cause of the error can be diagnosed using "
"B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:125
msgid ""
"B<dlsym>()  is present in glibc 2.0 and later.  B<dlvsym>()  first appeared "
"in glibc 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/dlsym.3:136
#, no-wrap
msgid ""
"B<dlsym>(),\n"
"B<dlvsym>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:144
msgid ""
"POSIX.1-2001 describes B<dlsym>().  The B<dlvsym>()  function is a GNU "
"extension."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:162
msgid ""
"There are several scenarios when the address of a global symbol is NULL.  "
"For example, a symbol can be placed at zero address by the linker, via a "
"linker script or with I<--defsym> command-line option. Undefined weak "
"symbols also have NULL value.  Finally, the symbol value may be the result "
"of a GNU indirect function (IFUNC) resolver function that returns NULL as "
"the resolved value. In the latter case, B<dlsym>()  also returns NULL "
"without error. However, in the former two cases, the behavior of GNU dynamic "
"linker is inconsistent: relocation processing succeeds and the symbol can be "
"observed to have NULL value, but B<dlsym>()  fails and B<dlerror>()  "
"indicates a lookup error."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:168
msgid ""
"The B<dlsym>()  function is part of the dlopen API, derived from SunOS.  "
"That system does not have B<dlvsym>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:178
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), "
"B<dlopen>(3), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man5/elf.5:35
#, no-wrap
msgid "ELF"
msgstr ""

#. type: TH
#: build/C/man5/elf.5:35
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:38
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr ""

#.  .B #include <elf_abi.h>
#. type: Plain text
#: build/C/man5/elf.5:42
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:50
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files, and shared objects."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:59
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the "
"file."
msgstr ""

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: build/C/man5/elf.5:87
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:87
#, no-wrap
msgid "Basic types"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:99
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: build/C/man5/elf.5:113
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:128
msgid ""
"(Note: the *BSD terminology is a bit different.  There, I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:136
msgid ""
"All data structures that the file format defines follow the \"natural\" size "
"and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, and so on."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:136
#, no-wrap
msgid "ELF header (Ehdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:141
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:145
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:167
msgid "The fields have the following meanings:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:169
#, no-wrap
msgid "I<e_ident>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:179
msgid ""
"This array of bytes specifies how to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is "
"named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:180
#, no-wrap
msgid "B<EI_MAG0>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:186
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0: "
"0x7f)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:186
#, no-wrap
msgid "B<EI_MAG1>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:192
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:192
#, no-wrap
msgid "B<EI_MAG2>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:198
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2: "
"\\(aqL\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:198
#, no-wrap
msgid "B<EI_MAG3>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:204
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:204
#, no-wrap
msgid "B<EI_CLASS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:207
msgid "The fifth byte identifies the architecture for this binary:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:212
msgid "This class is invalid."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:212
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:217
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:217
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:220
msgid "This defines the 64-bit architecture."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:222
#, no-wrap
msgid "B<EI_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:227
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in "
"the file.  Currently, these encodings are supported:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:228
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:232
msgid "Unknown data format."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:232
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:235
msgid "Two's complement, little-endian."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:235
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:238
msgid "Two's complement, big-endian."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:240
#, no-wrap
msgid "B<EI_VERSION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:243
msgid "The seventh byte is the version number of the ELF specification:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:246 build/C/man5/elf.5:492
#, no-wrap
msgid "B<EV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:249
msgid "Invalid version."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:249 build/C/man5/elf.5:496
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:252
msgid "Current version."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:255
#, no-wrap
msgid "B<EI_OSABI>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:263
msgid ""
"The eighth byte identifies the operating system and ABI to which the object "
"is targeted.  Some fields in other ELF structures have flags and values that "
"have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  For example:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: build/C/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr ""

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: build/C/man5/elf.5:274
msgid "UNIX System V ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr ""

#.  1
#. type: Plain text
#: build/C/man5/elf.5:278
msgid "HP-UX ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr ""

#.  2
#. type: Plain text
#: build/C/man5/elf.5:282
msgid "NetBSD ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr ""

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI
#.  5
#. type: Plain text
#: build/C/man5/elf.5:294
msgid "Linux ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr ""

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI
#.  Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: build/C/man5/elf.5:304
msgid "Solaris ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:304
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr ""

#.  8
#. type: Plain text
#: build/C/man5/elf.5:308
msgid "IRIX ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:308
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr ""

#.  9
#. type: Plain text
#: build/C/man5/elf.5:312
msgid "FreeBSD ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:312
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr ""

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: build/C/man5/elf.5:320
msgid "TRU64 UNIX ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:320
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr ""

#.  97
#. type: Plain text
#: build/C/man5/elf.5:324
msgid "ARM architecture ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:324
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr ""

#.  255
#. type: Plain text
#: build/C/man5/elf.5:328
msgid "Stand-alone (embedded) ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:340
msgid ""
"The ninth byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr ""

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: build/C/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which "
"read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:361
msgid "The size of the I<e_ident> array."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:362
#, no-wrap
msgid "I<e_type>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:365
msgid "This member of the structure identifies the object file type:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:366
#, no-wrap
msgid "B<ET_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:370
msgid "An unknown type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:370
#, no-wrap
msgid "B<ET_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:373
msgid "A relocatable file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:373
#, no-wrap
msgid "B<ET_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:376
msgid "An executable file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:376
#, no-wrap
msgid "B<ET_DYN>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:379
msgid "A shared object."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:379
#, no-wrap
msgid "B<ET_CORE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:382
msgid "A core file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:384
#, no-wrap
msgid "I<e_machine>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:388
msgid ""
"This member specifies the required architecture for an individual file.  For "
"example:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:389
#, no-wrap
msgid "B<EM_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: build/C/man5/elf.5:394
msgid "An unknown machine"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:394
#, no-wrap
msgid "B<EM_M32>"
msgstr ""

#.  1
#. type: Plain text
#: build/C/man5/elf.5:398
msgid "AT&T WE 32100"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:398
#, no-wrap
msgid "B<EM_SPARC>"
msgstr ""

#.  2
#. type: Plain text
#: build/C/man5/elf.5:402
msgid "Sun Microsystems SPARC"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:402
#, no-wrap
msgid "B<EM_386>"
msgstr ""

#.  3
#. type: Plain text
#: build/C/man5/elf.5:406
msgid "Intel 80386"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:406
#, no-wrap
msgid "B<EM_68K>"
msgstr ""

#.  4
#. type: Plain text
#: build/C/man5/elf.5:410
msgid "Motorola 68000"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:410
#, no-wrap
msgid "B<EM_88K>"
msgstr ""

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486
#.  6
#. type: Plain text
#: build/C/man5/elf.5:418
msgid "Motorola 88000"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:418
#, no-wrap
msgid "B<EM_860>"
msgstr ""

#.  7
#. type: Plain text
#: build/C/man5/elf.5:422
msgid "Intel 80860"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:422
#, no-wrap
msgid "B<EM_MIPS>"
msgstr ""

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: build/C/man5/elf.5:434
msgid "MIPS RS3000 (big-endian only)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:434
#, no-wrap
msgid "B<EM_PARISC>"
msgstr ""

#.  15
#. type: Plain text
#: build/C/man5/elf.5:438
msgid "HP/PA"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:438
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr ""

#.  18
#. type: Plain text
#: build/C/man5/elf.5:442
msgid "SPARC with enhanced instruction set"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:442
#, no-wrap
msgid "B<EM_PPC>"
msgstr ""

#.  20
#. type: Plain text
#: build/C/man5/elf.5:446
msgid "PowerPC"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC64>"
msgstr ""

#.  21
#. type: Plain text
#: build/C/man5/elf.5:450
msgid "PowerPC 64-bit"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:450
#, no-wrap
msgid "B<EM_S390>"
msgstr ""

#.  22
#. type: Plain text
#: build/C/man5/elf.5:454
msgid "IBM S/390"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:454
#, no-wrap
msgid "B<EM_ARM>"
msgstr ""

#.  40
#. type: Plain text
#: build/C/man5/elf.5:458
msgid "Advanced RISC Machines"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:458
#, no-wrap
msgid "B<EM_SH>"
msgstr ""

#.  42
#. type: Plain text
#: build/C/man5/elf.5:462
msgid "Renesas SuperH"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:462
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr ""

#.  43
#. type: Plain text
#: build/C/man5/elf.5:466
msgid "SPARC v9 64-bit"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:466
#, no-wrap
msgid "B<EM_IA_64>"
msgstr ""

#.  50
#. type: Plain text
#: build/C/man5/elf.5:470
msgid "Intel Itanium"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:470
#, no-wrap
msgid "B<EM_X86_64>"
msgstr ""

#.  62
#. type: Plain text
#: build/C/man5/elf.5:474
msgid "AMD x86-64"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:474
#, no-wrap
msgid "B<EM_VAX>"
msgstr ""

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set
#. type: Plain text
#: build/C/man5/elf.5:486
msgid "DEC Vax"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:488
#, no-wrap
msgid "I<e_version>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:491
msgid "This member identifies the file version:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:496
msgid "Invalid version"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:499
msgid "Current version"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:501
#, no-wrap
msgid "I<e_entry>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:507
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:507
#, no-wrap
msgid "I<e_phoff>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:512
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:512
#, no-wrap
msgid "I<e_shoff>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:517
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table, this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:517
#, no-wrap
msgid "I<e_flags>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:522
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently, no flags have been "
"defined."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:522
#, no-wrap
msgid "I<e_ehsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:525
msgid "This member holds the ELF header's size in bytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:525
#, no-wrap
msgid "I<e_phentsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:529
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:529
#, no-wrap
msgid "I<e_phnum>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:542
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""

#.  This is a Linux extension, added in Linux 2.6.34.
#. type: Plain text
#: build/C/man5/elf.5:556
msgid ""
"If the number of entries in the program header table is larger than or equal "
"to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:557
#, no-wrap
msgid "B<PN_XNUM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:562
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:564
#, no-wrap
msgid "I<e_shentsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:569
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:569
#, no-wrap
msgid "I<e_shnum>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:582
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:596
msgid ""
"If the number of entries in the section header table is larger than or equal "
"to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the "
"value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:596
#, no-wrap
msgid "I<e_shstrndx>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:603
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:617
msgid ""
"If the index of section name string table section is larger than or equal to "
"B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the "
"real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table.  Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:617
#, no-wrap
msgid "Program header (Phdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:636
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable "
"and shared object files.  A file specifies its own program header size with "
"the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:649
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:664
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:671
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in "
"the location of the I<p_flags> member in the total struct."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:671
#, no-wrap
msgid "I<p_type>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:675
msgid ""
"This member of the structure indicates what kind of segment this array "
"element describes or how to interpret the array element's information."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:676
#, no-wrap
msgid "B<PT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:680
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:680
#, no-wrap
msgid "B<PT_LOAD>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:701
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and "
"I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header "
"table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:701
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:704
msgid "The array element specifies dynamic linking information."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:704
#, no-wrap
msgid "B<PT_INTERP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:712
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:712
#, no-wrap
msgid "B<PT_NOTE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:715
msgid "The array element specifies the location of notes (ElfN_Nhdr)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:715
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:720
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:720
#, no-wrap
msgid "B<PT_PHDR>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:730
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the "
"program.  This segment type may not occur more than once in a file.  "
"Moreover, it may occur only if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable "
"segment entry."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:730
#, no-wrap
msgid "B<PT_LOPROC>, B<PT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:735
msgid ""
"Values in the inclusive range [B<PT_LOPROC>, B<PT_HIPROC>] are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:735
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:741
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:742
#, no-wrap
msgid "I<p_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:746
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:746
#, no-wrap
msgid "I<p_vaddr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:750
msgid ""
"This member holds the virtual address at which the first byte of the segment "
"resides in memory."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:750
#, no-wrap
msgid "I<p_paddr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:758
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:758
#, no-wrap
msgid "I<p_filesz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:762
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:762
#, no-wrap
msgid "I<p_memsz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:766
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:766
#, no-wrap
msgid "I<p_flags>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:769
msgid "This member holds a bit mask of flags relevant to the segment:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:770
#, no-wrap
msgid "B<PF_X>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:774
msgid "An executable segment."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:774
#, no-wrap
msgid "B<PF_W>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:777
msgid "A writable segment."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:777
#, no-wrap
msgid "B<PF_R>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:780
msgid "A readable segment."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:791
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_W> and B<PF_R>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:791
#, no-wrap
msgid "I<p_align>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:810
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:810
#, no-wrap
msgid "Section header (Shdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:827
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the "
"number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:843
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between "
"B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum>, and I<e_shstrndx>; in other cases, "
"each field in the initial entry is set to zero.  An object file does not "
"have sections for these special indices:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:843
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:847
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless "
"section reference."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:847
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:850
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:850
#, no-wrap
msgid "B<SHN_LOPROC>, B<SHN_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:855
msgid ""
"Values greater in the inclusive range [B<SHN_LOPROC>, B<SHN_HIPROC>] are "
"reserved for processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:855
#, no-wrap
msgid "B<SHN_ABS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:862
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:862
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:866
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN "
"COMMON or unallocated C external variables."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:866
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:877
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:879
msgid "The section header has the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:894
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:911
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:915
msgid "No real differences exist between the 32-bit and 64-bit section headers."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:915
#, no-wrap
msgid "I<sh_name>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:921
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a "
"null-terminated string."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:921
#, no-wrap
msgid "I<sh_type>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:924
msgid "This member categorizes the section's contents and semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:925
#, no-wrap
msgid "B<SHT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:932
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:932
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:936
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:936
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:949
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:949
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:954
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:954
#, no-wrap
msgid "B<SHT_RELA>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:962
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:962
#, no-wrap
msgid "B<SHT_HASH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:969
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:969
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:974
msgid ""
"This section holds information for dynamic linking.  An object file may have "
"only one dynamic section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:974
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:977
msgid "This section holds notes (ElfN_Nhdr)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:977
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:985
msgid ""
"A section of this type occupies no space in the file but otherwise resembles "
"B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset> "
"member contains the conceptual file offset."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:985
#, no-wrap
msgid "B<SHT_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:993
msgid ""
"This section holds relocation offsets without explicit addends, such as type "
"I<Elf32_Rel> for the 32-bit class of object files.  An object file may have "
"multiple relocation sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:993
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:996
msgid "This section is reserved but has unspecified semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:996
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1003
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file "
"can also contain a B<SHT_SYMTAB> section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1003
#, no-wrap
msgid "B<SHT_LOPROC>, B<SHT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1008
msgid ""
"Values in the inclusive range [B<SHT_LOPROC>, B<SHT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1008
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1012
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1012
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1022
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER> "
"may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1023
#, no-wrap
msgid "I<sh_flags>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1035
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a "
"flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes "
"are set to zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1036
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1040
msgid "This section contains data that should be writable during process execution."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1040
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1047
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1047
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1050
msgid "This section contains executable machine instructions."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1050
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1054
msgid ""
"All bits included in this mask are reserved for processor-specific "
"semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1055
#, no-wrap
msgid "I<sh_addr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1060
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the "
"member contains zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1060
#, no-wrap
msgid "I<sh_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1069
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no "
"space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1069
#, no-wrap
msgid "I<sh_size>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1081
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section "
"of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1081
#, no-wrap
msgid "I<sh_link>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1085
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1085
#, no-wrap
msgid "I<sh_info>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1089
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1089
#, no-wrap
msgid "I<sh_addralign>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1101
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo "
"the value of I<sh_addralign>.  Only zero and positive integral powers of two "
"are allowed.  The value 0 or 1 means that the section has no alignment "
"constraints."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1101
#, no-wrap
msgid "I<sh_entsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1107
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size "
"entries."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1109
msgid "Various sections hold program and control information:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1109
#, no-wrap
msgid "I<.bss>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1121
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The "
"attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1121
#, no-wrap
msgid "I<.comment>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1127
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1127
#, no-wrap
msgid "I<.ctors>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1136
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1136
#, no-wrap
msgid "I<.data>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1146 build/C/man5/elf.5:1156
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1146
#, no-wrap
msgid "I<.data1>"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1156
#, no-wrap
msgid "I<.debug>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1164
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1164
#, no-wrap
msgid "I<.dtors>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1173
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1173
#, no-wrap
msgid "I<.dynamic>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1186
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1186
#, no-wrap
msgid "I<.dynstr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1194
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This "
"section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1194
#, no-wrap
msgid "I<.dynsym>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1201
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1201
#, no-wrap
msgid "I<.fini>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1213
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>.  "
"The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1213
#, no-wrap
msgid "I<.gnu.version>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1222
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1222
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1231
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef> "
"structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1231
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1241
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The "
"attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1241
#, no-wrap
msgid "I<.got>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1247
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1247
#, no-wrap
msgid "I<.hash>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1254
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1254
#, no-wrap
msgid "I<.init>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1266
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1266
#, no-wrap
msgid "I<.interp>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1277
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a "
"loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1277
#, no-wrap
msgid "I<.line>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1286
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1286
#, no-wrap
msgid "I<.note>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1292
msgid ""
"This section holds various notes.  This section is of type B<SHT_NOTE>.  No "
"attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1292
#, no-wrap
msgid "I<.note.ABI-tag>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1300
msgid ""
"This section is used to declare the expected run-time ABI of the ELF image.  "
"It may include the operating system name and its run-time versions.  This "
"section is of type B<SHT_NOTE>.  The only attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1300
#, no-wrap
msgid "I<.note.gnu.build-id>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1313
msgid ""
"This section is used to hold an ID that uniquely identifies the contents of "
"the ELF image.  Different files with the same build ID should contain the "
"same executable content.  See the B<--build-id> option to the GNU linker "
"(B<ld> (1)) for more details.  This section is of type B<SHT_NOTE>.  The "
"only attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1313
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1322
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1322
#, no-wrap
msgid "I<.note.openbsd.ident>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1327
msgid ""
"OpenBSD native executables usually contain this section to identify "
"themselves so the kernel can bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1327
#, no-wrap
msgid "I<.plt>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1333
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1333
#, no-wrap
msgid "I<.relNAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1352
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1352
#, no-wrap
msgid "I<.relaNAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1371
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1371
#, no-wrap
msgid "I<.rodata>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1379 build/C/man5/elf.5:1387
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1379
#, no-wrap
msgid "I<.rodata1>"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1387
#, no-wrap
msgid "I<.shstrtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1393
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1393
#, no-wrap
msgid "I<.strtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1405
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section "
"is of type B<SHT_STRTAB>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1405
#, no-wrap
msgid "I<.symtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1416
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1416
#, no-wrap
msgid "I<.text>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1428
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:1428
#, no-wrap
msgid "String and symbol tables"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1439
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1444
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1455
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1468
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1473
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1473
#, no-wrap
msgid "I<st_name>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1481
msgid ""
"This member holds an index into the object file's symbol string table, which "
"holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol has no name."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1481
#, no-wrap
msgid "I<st_value>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1484
msgid "This member gives the value of the associated symbol."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1484
#, no-wrap
msgid "I<st_size>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1489
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1489
#, no-wrap
msgid "I<st_info>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1492
msgid "This member specifies the symbol's type and binding attributes:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1493
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1496
msgid "The symbol's type is not defined."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1496
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1499
msgid "The symbol is associated with a data object."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1499
#, no-wrap
msgid "B<STT_FUNC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1502
msgid "The symbol is associated with a function or other executable code."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1502
#, no-wrap
msgid "B<STT_SECTION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1509
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1509
#, no-wrap
msgid "B<STT_FILE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1520
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1520
#, no-wrap
msgid "B<STT_LOPROC>, B<STT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1525
msgid ""
"Values in the inclusive range [B<STT_LOPROC>, B<STT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1525
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1531
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1531
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1537
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1537
#, no-wrap
msgid "B<STB_WEAK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1541
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1541
#, no-wrap
msgid "B<STB_LOPROC>, B<STB_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1546
msgid ""
"Values in the inclusive range [B<STB_LOPROC>, B<STB_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1549
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1550
#, no-wrap
msgid "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1555
msgid "Extract a binding from an I<st_info> value."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1555
#, no-wrap
msgid "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1560
msgid "Extract a type from an I<st_info> value."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1560
#, no-wrap
msgid ""
"B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, "
">I<type>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1566
msgid "Convert a binding and a type into an I<st_info> value."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1567
#, no-wrap
msgid "I<st_other>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1570
msgid "This member defines the symbol visibility."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1571
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1578
msgid ""
"Default symbol visibility rules.  Global and weak symbols are available to "
"other modules; references in the local module can be interposed by "
"definitions in other modules."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1578
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1581
msgid "Processor-specific hidden class."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1581
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1586
msgid ""
"Symbol is unavailable to other modules; references in the local module "
"always resolve to the local symbol (i.e., the symbol can't be interposed by "
"definitions in other modules)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1586
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1590
msgid ""
"Symbol is available to other modules, but references in the local module "
"always resolve to the local symbol."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1593
msgid "There are macros for extracting the visibility type:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1597
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1598
#, no-wrap
msgid "I<st_shndx>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1606
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:1606
#, no-wrap
msgid "Relocation entries (Rel & Rela)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1614
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1616
msgid "Relocation structures that do not need an addend:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1623
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1632
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1636
msgid "Relocation structures that need an addend:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1644
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1654
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1656
#, no-wrap
msgid "I<r_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1664
msgid ""
"This member gives the location at which to apply the relocation action.  For "
"a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1664
#, no-wrap
msgid "I<r_info>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1679
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor-specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1679
#, no-wrap
msgid "I<r_addend>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1684
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:1684
#, no-wrap
msgid "Dynamic tags (Dyn)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1694
msgid ""
"The I<.dynamic> section contains a series of structures that hold relevant "
"dynamic linking information.  The I<d_tag> member controls the "
"interpretation of I<d_un>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1705
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1718
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1720
#, no-wrap
msgid "I<d_tag>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1723
msgid "This member may have any of the following values:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1724
#, no-wrap
msgid "B<DT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1727
msgid "Marks end of dynamic section"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1727
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1730
msgid "String table offset to name of a needed library"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1730
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1733
msgid "Size in bytes of PLT relocation entries"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1733
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1736
msgid "Address of PLT and/or GOT"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1736
#, no-wrap
msgid "B<DT_HASH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1739
msgid "Address of symbol hash table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1739
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1742
msgid "Address of string table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1742
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1745
msgid "Address of symbol table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1745
#, no-wrap
msgid "B<DT_RELA>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1748
msgid "Address of Rela relocation table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1748
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1751
msgid "Size in bytes of the Rela relocation table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1751
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1754
msgid "Size in bytes of a Rela relocation table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1754
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1757
msgid "Size in bytes of string table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1757
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1760
msgid "Size in bytes of a symbol table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1760
#, no-wrap
msgid "B<DT_INIT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1763
msgid "Address of the initialization function"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1763
#, no-wrap
msgid "B<DT_FINI>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1766
msgid "Address of the termination function"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1766
#, no-wrap
msgid "B<DT_SONAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1769
msgid "String table offset to name of shared object"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1769
#, no-wrap
msgid "B<DT_RPATH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1772
msgid "String table offset to library search path (deprecated)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1772
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1775
msgid "Alert linker to search this shared object before the executable for symbols"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1775
#, no-wrap
msgid "B<DT_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1778
msgid "Address of Rel relocation table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1778
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1781
msgid "Size in bytes of Rel relocation table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1781
#, no-wrap
msgid "B<DT_RELENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1784
msgid "Size in bytes of a Rel table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1784
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1787
msgid "Type of relocation entry to which the PLT refers (Rela or Rel)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1787
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1790
msgid "Undefined use for debugging"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1790
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1794
msgid ""
"Absence of this entry indicates that no relocation entries should apply to a "
"nonwritable segment"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1794
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1797
msgid "Address of relocation entries associated solely with the PLT"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1797
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1801
msgid ""
"Instruct dynamic linker to process all relocations before transferring "
"control to the executable"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1801
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1804
msgid "String table offset to library search path"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1804
#, no-wrap
msgid "B<DT_LOPROC>, B<DT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1809
msgid ""
"Values in the inclusive range [B<DT_LOPROC>, B<DT_HIPROC>] are reserved for "
"processor-specific semantics"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1810
#, no-wrap
msgid "I<d_val>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1813
msgid "This member represents integer values with various interpretations."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1813
#, no-wrap
msgid "I<d_ptr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1821
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1821
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr ""

#.  GABI ELF Reference for Note Sections:
#.  http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section
#
#.  Note that it implies the sizes and alignments of notes depend on the ELF
#.  size (e.g. 32-bit ELFs have three 4-byte words and use 4-byte alignment
#.  while 64-bit ELFs use 8-byte words & alignment), but that is not the case
#.  in the real world.  Notes always have three 4-byte words as can be seen
#.  in the source links below (remember that Elf64_Word is a 32-bit quantity).
#.  glibc:    https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;h=9e59b3275917549af0cebe1f2de9ded3b7b10bf2#l1173
#.  binutils: https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=binutils/readelf.c;h=274ddd17266aef6e4ad1f67af8a13a21500ff2af#l15943
#.  Linux:    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/elf.h?h=v4.8#n422
#.  Solaris:  https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html
#.  FreeBSD:  https://svnweb.freebsd.org/base/head/sys/sys/elf_common.h?revision=303677&view=markup#l33
#.  NetBSD:   https://www.netbsd.org/docs/kernel/elf-notes.html
#.  OpenBSD:  https://github.com/openbsd/src/blob/master/sys/sys/exec_elf.h#L533
#. type: Plain text
#: build/C/man5/elf.5:1843
msgid ""
"Array containing all the dynamic structures in the I<.dynamic> section.  "
"This is automatically populated by the linker."
msgstr ""

#. type: SS
#: build/C/man5/elf.5:1843
#, no-wrap
msgid "Notes (Nhdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1853
msgid ""
"ELF notes allow for appending arbitrary information for the system to use.  "
"They are largely used by core files (I<e_type> of B<ET_CORE>), but many "
"projects define their own set of extensions.  For example, the GNU tool "
"chain uses ELF notes to pass information from the linker to the C library."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1861
msgid ""
"Note sections contain a series of notes (see the I<struct> definitions "
"below).  Each note is followed by the name field (whose length is defined in "
"I<n_namesz>) and then by the descriptor field (whose length is defined in "
"I<n_descsz>) and whose starting address has a 4 byte alignment.  Neither "
"field is defined in the note struct due to their arbitrary lengths."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1864
msgid ""
"An example for parsing out two consecutive notes should clarify their layout "
"in memory:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1869
#, no-wrap
msgid ""
"void *memory, *name, *desc;\n"
"Elf64_Nhdr *note, *next_note;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1872
#, no-wrap
msgid ""
"/* The buffer is pointing to the start of the section/segment */\n"
"note = memory;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1875
#, no-wrap
msgid ""
"/* If the name is defined, it follows the note */\n"
"name = note-E<gt>n_namesz == 0 ? NULL : memory + sizeof(*note);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1878
#, no-wrap
msgid ""
"/* If the descriptor is defined, it follows the name\n"
"   (with alignment) */\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1881
#, no-wrap
msgid ""
"desc = note-E<gt>n_descsz == 0 ? NULL :\n"
"       memory + sizeof(*note) + ALIGN_UP(note-E<gt>n_namesz, 4);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1886
#, no-wrap
msgid ""
"/* The next note follows both (with alignment) */\n"
"next_note = memory + sizeof(*note) +\n"
"                     ALIGN_UP(note-E<gt>n_namesz, 4) +\n"
"                     ALIGN_UP(note-E<gt>n_descsz, 4);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1900
msgid ""
"Keep in mind that the interpretation of I<n_type> depends on the namespace "
"defined by the I<n_namesz> field.  If the I<n_namesz> field is not set "
"(e.g., is 0), then there are two sets of notes: one for core files and one "
"for all other ELF types.  If the namespace is unknown, then tools will "
"usually fallback to these sets of notes as well."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1908
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1918
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1920
#, no-wrap
msgid "I<n_namesz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1928
msgid ""
"The length of the name field in bytes.  The contents will immediately follow "
"this note in memory.  The name is null terminated.  For example, if the name "
"is \"GNU\", then I<n_namesz> will be set to 4."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1928
#, no-wrap
msgid "I<n_descsz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1932
msgid ""
"The length of the descriptor field in bytes.  The contents will immediately "
"follow the name field in memory."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1932
#, no-wrap
msgid "I<n_type>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1936
msgid ""
"Depending on the value of the name field, this member may have any of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1937
#, no-wrap
msgid "B<Core files (e_type = ET_CORE)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1945
msgid ""
"Notes used by all core files.  These are highly operating system or "
"architecture specific and often require close coordination with kernels, C "
"libraries, and debuggers.  These are used when the namespace is the default "
"(i.e., I<n_namesz> will be set to 0), or a fallback when the namespace is "
"unknown."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1946
#, no-wrap
msgid "B<NT_PRSTATUS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1950
msgid "prstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1950
#, no-wrap
msgid "B<NT_FPREGSET>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1953
msgid "fpregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1953
#, no-wrap
msgid "B<NT_PRPSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1956
msgid "prpsinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1956
#, no-wrap
msgid "B<NT_PRXREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1959
msgid "prxregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1959
#, no-wrap
msgid "B<NT_TASKSTRUCT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1962
msgid "task structure"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1962
#, no-wrap
msgid "B<NT_PLATFORM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1965
msgid "String from sysinfo(SI_PLATFORM)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1965
#, no-wrap
msgid "B<NT_AUXV>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1968
msgid "auxv array"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1968
#, no-wrap
msgid "B<NT_GWINDOWS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1971
msgid "gwindows struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1971
#, no-wrap
msgid "B<NT_ASRS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1974
msgid "asrset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1974
#, no-wrap
msgid "B<NT_PSTATUS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1977
msgid "pstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1977
#, no-wrap
msgid "B<NT_PSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1980
msgid "psinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1980
#, no-wrap
msgid "B<NT_PRCRED>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1983
msgid "prcred struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1983
#, no-wrap
msgid "B<NT_UTSNAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1986
msgid "utsname struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1986
#, no-wrap
msgid "B<NT_LWPSTATUS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1989
msgid "lwpstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1989
#, no-wrap
msgid "B<NT_LWPSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1992
msgid "lwpinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1992
#, no-wrap
msgid "B<NT_PRFPXREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1995
msgid "fprxregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1995
#, no-wrap
msgid "B<NT_SIGINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1998
msgid "siginfo_t (size might increase over time)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1998
#, no-wrap
msgid "B<NT_FILE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2001
msgid "Contains information about mapped files"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2001
#, no-wrap
msgid "B<NT_PRXFPREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2004
msgid "user_fxsr_struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2004
#, no-wrap
msgid "B<NT_PPC_VMX>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2007
msgid "PowerPC Altivec/VMX registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2007
#, no-wrap
msgid "B<NT_PPC_SPE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2010
msgid "PowerPC SPE/EVR registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2010
#, no-wrap
msgid "B<NT_PPC_VSX>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2013
msgid "PowerPC VSX registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2013
#, no-wrap
msgid "B<NT_386_TLS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2016
msgid "i386 TLS slots (struct user_desc)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2016
#, no-wrap
msgid "B<NT_386_IOPERM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2019
msgid "x86 io permission bitmap (1=deny)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2019
#, no-wrap
msgid "B<NT_X86_XSTATE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2022
msgid "x86 extended state using xsave"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2022
#, no-wrap
msgid "B<NT_S390_HIGH_GPRS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2025
msgid "s390 upper register halves"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2025
#, no-wrap
msgid "B<NT_S390_TIMER>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2028
msgid "s390 timer register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2028
#, no-wrap
msgid "B<NT_S390_TODCMP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2031
msgid "s390 time-of-day (TOD) clock comparator register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2031
#, no-wrap
msgid "B<NT_S390_TODPREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2034
msgid "s390 time-of-day (TOD) programmable register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2034
#, no-wrap
msgid "B<NT_S390_CTRS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2037
msgid "s390 control registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2037
#, no-wrap
msgid "B<NT_S390_PREFIX>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2040
msgid "s390 prefix register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2040
#, no-wrap
msgid "B<NT_S390_LAST_BREAK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2043
msgid "s390 breaking event address"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2043
#, no-wrap
msgid "B<NT_S390_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2046
msgid "s390 system call restart data"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2046
#, no-wrap
msgid "B<NT_S390_TDB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2049
msgid "s390 transaction diagnostic block"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2049
#, no-wrap
msgid "B<NT_ARM_VFP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2052
msgid "ARM VFP/NEON registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2052
#, no-wrap
msgid "B<NT_ARM_TLS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2055
msgid "ARM TLS register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2055
#, no-wrap
msgid "B<NT_ARM_HW_BREAK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2058
msgid "ARM hardware breakpoint registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2058
#, no-wrap
msgid "B<NT_ARM_HW_WATCH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2061
msgid "ARM hardware watchpoint registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2061
#, no-wrap
msgid "B<NT_ARM_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2064
msgid "ARM system call number"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2066
#, no-wrap
msgid "B<n_name = GNU>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2069
msgid "Extensions used by the GNU tool chain."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2070
#, no-wrap
msgid "B<NT_GNU_ABI_TAG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2074
msgid "Operating system (OS) ABI information.  The desc field will be 4 words:"
msgstr ""

#. type: IP
#: build/C/man5/elf.5:2077 build/C/man5/elf.5:2080 build/C/man5/elf.5:2082 build/C/man5/elf.5:2084 build/C/man5/elf.5:2095 build/C/man5/elf.5:2097
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2080
msgid "word 0: OS descriptor (B<ELF_NOTE_OS_LINUX>, B<ELF_NOTE_OS_GNU>, and so on)`"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2082
msgid "word 1: major version of the ABI"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2084
msgid "word 2: minor version of the ABI"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2086
msgid "word 3: subminor version of the ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2088
#, no-wrap
msgid "B<NT_GNU_HWCAP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2092
msgid "Synthetic hwcap information.  The desc field begins with two words:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2097
msgid "word 0: number of entries"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2099
msgid "word 1: bit mask of enabled entries"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2105
msgid ""
"Then follow variable-length entries, one byte followed by a null-terminated "
"hwcap name string.  The byte gives the bit number to test if enabled, (1U "
"E<lt>E<lt> bit) & bit mask."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2105
#, no-wrap
msgid "B<NT_GNU_BUILD_ID>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2112
msgid ""
"Unique build ID as generated by the GNU B<ld>(1)  B<--build-id> option.  The "
"desc consists of any nonzero number of bytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2112
#, no-wrap
msgid "B<NT_GNU_GOLD_VERSION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2115
msgid "The desc contains the GNU Gold linker version used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2116
#, no-wrap
msgid "B<Default/unknown namespace (e_type != ET_CORE)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2121
msgid ""
"These are used when the namespace is the default (i.e., I<n_namesz> will be "
"set to 0), or a fallback when the namespace is unknown."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2122
#, no-wrap
msgid "B<NT_VERSION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2126
msgid "A version string of some sort."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2126
#, no-wrap
msgid "B<NT_ARCH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2129
msgid "Architecture information."
msgstr ""

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: build/C/man5/elf.5:2141
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: build/C/man5/elf.5:2159
msgid ""
"The extensions for I<e_phnum>, I<e_shnum>, and I<e_shstrndx> respectively "
"are Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2176
msgid ""
"B<as>(1), B<elfedit>(1), B<gdb>(1), B<ld>(1), B<nm>(1), B<objcopy>(1), "
"B<objdump>(1), B<patchelf>(1), B<readelf>(1), B<size>(1), B<strings>(1), "
"B<strip>(1), B<execve>(2), B<dl_iterate_phdr>(3), B<core>(5), B<ld.so>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2179
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2182
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2186
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2189
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2192
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""

#. type: TH
#: build/C/man3/end.3:26
#, no-wrap
msgid "END"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:29
msgid "etext, edata, end - end of program segments"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:34
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:38
msgid "The addresses of these symbols indicate the end of various program segments:"
msgstr ""

#. type: TP
#: build/C/man3/end.3:38
#, no-wrap
msgid "I<etext>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:42
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr ""

#. type: TP
#: build/C/man3/end.3:42
#, no-wrap
msgid "I<edata>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:46
msgid "This is the first address past the end of the initialized data segment."
msgstr ""

#. type: TP
#: build/C/man3/end.3:46
#, no-wrap
msgid "I<end>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:50
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:53
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:56
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:64
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for "
"programs compiled on Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:76
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:78
msgid "When run, the program below produces output such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:86
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:93 build/C/man1/memusage.1:241
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:96
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:113
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr ""

#. type: TH
#: build/C/man8/ld.so.8:7
#, no-wrap
msgid "LD.SO"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:10
msgid "ld.so, ld-linux.so - dynamic linker/loader"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:18
msgid ""
"The dynamic linker can be run either indirectly by running some dynamically "
"linked program or shared object (in which case no command-line options to "
"the dynamic linker can be passed and, in the ELF case, the dynamic linker "
"which is stored in the B<.interp> section of the program is executed) or "
"directly by running:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:21
msgid "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:28
msgid ""
"The programs B<ld.so> and B<ld-linux.so*> find and load the shared objects "
"(shared libraries) needed by a program, prepare the program to run, and then "
"run it."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:35
msgid ""
"Linux binaries require dynamic linking (linking at run time)  unless the "
"B<-static> option was given to B<ld>(1)  during compilation."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:49
msgid ""
"The program B<ld.so> handles a.out binaries, a binary format used long ago.  "
"The program B<ld-linux.so*> (I</lib/ld-linux.so.1> for libc5, "
"I</lib/ld-linux.so.2> for glibc2)  handles binaries that are in the more "
"modern ELF format.  Both programs have the same behavior, and use the same "
"support files and programs (B<ldd>(1), B<ldconfig>(8), and "
"I</etc/ld.so.conf>)."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:57
msgid ""
"When resolving shared object dependencies, the dynamic linker first inspects "
"each dependency string to see if it contains a slash (this can occur if a "
"shared object pathname containing slashes was specified at link time).  If a "
"slash is found, then the dependency string is interpreted as a (relative or "
"absolute) pathname, and the shared object is loaded using that pathname."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:60
msgid ""
"If a shared object dependency does not contain a slash, then it is searched "
"for in the following order:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:65
msgid ""
"Using the directories specified in the DT_RPATH dynamic section attribute of "
"the binary if present and DT_RUNPATH attribute does not exist.  Use of "
"DT_RPATH is deprecated."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:70
msgid ""
"Using the environment variable B<LD_LIBRARY_PATH>, unless the executable is "
"being run in secure-execution mode (see below), in which case this variable "
"is ignored."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:80
msgid ""
"Using the directories specified in the DT_RUNPATH dynamic section attribute "
"of the binary if present.  Such directories are searched only to find those "
"objects required by DT_NEEDED (direct dependencies) entries and do not apply "
"to those objects' children, which must themselves have their own DT_RUNPATH "
"entries.  This is unlike DT_RPATH, which is applied to searches for all "
"children in the dependency tree."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:90
msgid ""
"From the cache file I</etc/ld.so.cache>, which contains a compiled list of "
"candidate shared objects previously found in the augmented library path.  "
"If, however, the binary was linked with the B<-z nodeflib> linker option, "
"shared objects in the default paths are skipped.  Shared objects installed "
"in hardware capability directories (see below)  are preferred to other "
"shared objects."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:102
msgid ""
"In the default path I</lib>, and then I</usr/lib>.  (On some 64-bit "
"architectures, the default paths for 64-bit shared objects are I</lib64>, "
"and then I</usr/lib64>.)  If the binary was linked with the B<-z nodeflib> "
"linker option, this step is skipped."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:102
#, no-wrap
msgid "Dynamic string tokens"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:105
msgid "In several places, the dynamic linker expands dynamic string tokens:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:111
msgid ""
"In the environment variables B<LD_LIBRARY_PATH>, B<LD_PRELOAD>, and "
"B<LD_AUDIT>,"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:120
msgid ""
"inside the values of the dynamic section tags B<DT_NEEDED>, B<DT_RPATH>, "
"B<DT_RUNPATH>, B<DT_AUDIT>, and B<DT_DEPAUDIT> of ELF binaries,"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:129
msgid ""
"in the arguments to the B<ld.so> command line options B<--audit>, "
"B<--library-path>, and B<--preload> (see below), and"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:135
msgid "in the filename arguments to the B<dlopen>(3)  and B<dlmopen>(3)  functions."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:137
msgid "The substituted tokens are as follows:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:137
#, no-wrap
msgid "I<$ORIGIN> (or equivalently I<${ORIGIN}>)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:144
msgid ""
"This expands to the directory containing the program or shared object.  "
"Thus, an application located in I<somedir/app> could be compiled with"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:148
#, no-wrap
msgid "gcc -Wl,-rpath,\\(aq$ORIGIN/../lib\\(aq\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:160
msgid ""
"so that it finds an associated shared object in I<somedir/lib> no matter "
"where I<somedir> is located in the directory hierarchy.  This facilitates "
"the creation of \"turn-key\" applications that do not need to be installed "
"into special directories, but can instead be unpacked into any directory and "
"still find their own shared objects."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:160
#, no-wrap
msgid "I<$LIB> (or equivalently I<${LIB}>)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:172
msgid ""
"This expands to I<lib> or I<lib64> depending on the architecture (e.g., on "
"x86-64, it expands to I<lib64> and on x86-32, it expands to I<lib>)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:172
#, no-wrap
msgid "I<$PLATFORM> (or equivalently I<${PLATFORM}>)"
msgstr ""

#.  To get an idea of the places that $PLATFORM would match,
#.  look at the output of the following:
#
#.      mkdir /tmp/d
#.      LD_LIBRARY_PATH=/tmp/d strace -e open /bin/date 2>&1 | grep /tmp/d
#
#.  ld.so lets names be abbreviated, so $O will work for $ORIGIN;
#.  Don't do this!!
#. type: Plain text
#: build/C/man8/ld.so.8:190
msgid ""
"This expands to a string corresponding to the processor type of the host "
"system (e.g., \"x86_64\").  On some architectures, the Linux kernel doesn't "
"provide a platform string to the dynamic linker.  The value of this string "
"is taken from the B<AT_PLATFORM> value in the auxiliary vector (see "
"B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:194
msgid ""
"Note that the dynamic string tokens have to be quoted properly when set from "
"a shell, to prevent their expansion as shell or environment variables."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:194 build/C/man8/ldconfig.8:120 build/C/man1/ldd.1:115 build/C/man1/memusage.1:134 build/C/man1/memusagestat.1:47 build/C/man1/mtrace.1:51 build/C/man1/pldd.1:40 build/C/man1/sprof.1:46
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:195
#, no-wrap
msgid "B<--audit>I< list>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:203
msgid ""
"Use objects named in I<list> as auditors.  The objects in I<list> are "
"delimited by colons."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:203
#, no-wrap
msgid "B<--inhibit-cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:207
msgid "Do not use I</etc/ld.so.cache>."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:207
#, no-wrap
msgid "B<--library-path>I< path>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:222
msgid ""
"Use I<path> instead of B<LD_LIBRARY_PATH> environment variable setting (see "
"below).  The names I<ORIGIN>, I<LIB>, and I<PLATFORM> are interpreted as for "
"the B<LD_LIBRARY_PATH> environment variable."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:222
#, no-wrap
msgid "B<--inhibit-rpath>I< list>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:230
msgid ""
"Ignore RPATH and RUNPATH information in object names in I<list>.  This "
"option is ignored when running in secure-execution mode (see below).  The "
"objects in I<list> are delimited by colons or spaces."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:230
#, no-wrap
msgid "B<--list>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:233
msgid "List all dependencies and how they are resolved."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:233
#, no-wrap
msgid "B<--preload> I<list> (since glibc 2.30)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:243
msgid ""
"Preload the objects specified in I<list>.  The objects in I<list> are "
"delimited by colons or spaces.  The objects are preloaded as explained in "
"the description of the B<LD_PRELOAD> environment variable below."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:251
msgid ""
"By contrast with B<LD_PRELOAD>, the B<--preload> option provides a way to "
"perform preloading for a single executable without affecting preloading "
"performed in any child process that executes a new program."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:251
#, no-wrap
msgid "B<--verify>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:255
msgid ""
"Verify that program is dynamically linked and this dynamic linker can handle "
"it."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:255
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:258
msgid "Various environment variables influence the operation of the dynamic linker."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:258
#, no-wrap
msgid "Secure-execution mode"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:281
msgid ""
"For security reasons, if the dynamic linker determines that a binary should "
"be run in secure-execution mode, the effects of some environment variables "
"are voided or modified, and furthermore those environment variables are "
"stripped from the environment, so that the program does not even see the "
"definitions.  Some of these environment variables affect the operation of "
"the dynamic linker itself, and are described below.  Other environment "
"variables treated in this way include: B<GCONV_PATH>, B<GETCONF_DIR>, "
"B<HOSTALIASES>, B<LOCALDOMAIN>, B<LOCPATH>, B<MALLOC_TRACE>, B<NIS_PATH>, "
"B<NLSPATH>, B<RESOLV_HOST_CONF>, B<RES_OPTIONS>, B<TMPDIR>, and B<TZDIR>."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:288
msgid ""
"A binary is executed in secure-execution mode if the B<AT_SECURE> entry in "
"the auxiliary vector (see B<getauxval>(3))  has a nonzero value.  This entry "
"may have a nonzero value for various reasons, including:"
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:288 build/C/man8/ld.so.8:293 build/C/man8/ld.so.8:296 build/C/man7/rtld-audit.7:487 build/C/man7/rtld-audit.7:491 build/C/man7/rtld-audit.7:499
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:293
msgid ""
"The process's real and effective user IDs differ, or the real and effective "
"group IDs differ.  This typically occurs as a result of executing a "
"set-user-ID or set-group-ID program."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:296
msgid ""
"A process with a non-root user ID executed a binary that conferred "
"capabilities to the process."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:299
msgid "A nonzero value may have been set by a Linux Security Module."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:299
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:301
msgid "Among the more important environment variables are the following:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:301
#, no-wrap
msgid "B<LD_ASSUME_KERNEL> (since glibc 2.2.3)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:313
msgid ""
"Each shared object can inform the dynamic linker of the minimum kernel ABI "
"version that it requires.  (This requirement is encoded in an ELF note "
"section that is viewable via I<readelf\\ -n> as a section labeled "
"B<NT_GNU_ABI_TAG>.)  At run time, the dynamic linker determines the ABI "
"version of the running kernel and will reject loading shared objects that "
"specify minimum ABI versions that exceed that ABI version."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:322
msgid ""
"B<LD_ASSUME_KERNEL> can be used to cause the dynamic linker to assume that "
"it is running on a system with a different kernel ABI version.  For example, "
"the following command line causes the dynamic linker to assume it is running "
"on Linux 2.2.5 when loading the shared objects required by I<myprog>:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:326
#, no-wrap
msgid "$ B<LD_ASSUME_KERNEL=2.2.5 ./myprog>\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:335
msgid ""
"On systems that provide multiple versions of a shared object (in different "
"directories in the search path) that have different minimum kernel ABI "
"version requirements, B<LD_ASSUME_KERNEL> can be used to select the version "
"of the object that is used (dependent on the directory search order)."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:344
msgid ""
"Historically, the most common use of the B<LD_ASSUME_KERNEL> feature was to "
"manually select the older LinuxThreads POSIX threads implementation on "
"systems that provided both LinuxThreads and NPTL (which latter was typically "
"the default on such systems); see B<pthreads>(7)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:344
#, no-wrap
msgid "B<LD_BIND_NOW> (since glibc 2.1.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:351
msgid ""
"If set to a nonempty string, causes the dynamic linker to resolve all "
"symbols at program startup instead of deferring function call resolution to "
"the point when they are first referenced.  This is useful when using a "
"debugger."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:351
#, no-wrap
msgid "B<LD_LIBRARY_PATH>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:358
msgid ""
"A list of directories in which to search for ELF libraries at execution "
"time.  The items in the list are separated by either colons or semicolons, "
"and there is no support for escaping either separator.  A zero-length "
"directory name indicates the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:360
msgid "This variable is ignored in secure-execution mode."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:377
msgid ""
"Within the pathnames specified in B<LD_LIBRARY_PATH>, the dynamic linker "
"expands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the versions "
"using curly braces around the names)  as described above in I<Dynamic string "
"tokens>.  Thus, for example, the following would cause a library to be "
"searched for in either the I<lib> or I<lib64> subdirectory below the "
"directory containing the program to be executed:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:381
#, no-wrap
msgid "$ B<LD_LIBRARY_PATH=\\(aq$ORIGIN/$LIB\\(aq prog>\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:389
msgid ""
"(Note the use of single quotes, which prevent expansion of I<$ORIGIN> and "
"I<$LIB> as shell variables!)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:389
#, no-wrap
msgid "B<LD_PRELOAD>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:395
msgid ""
"A list of additional, user-specified, ELF shared objects to be loaded before "
"all others.  This feature can be used to selectively override functions in "
"other shared objects."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:401
msgid ""
"The items of the list can be separated by spaces or colons, and there is no "
"support for escaping either separator.  The objects are searched for using "
"the rules given under DESCRIPTION.  Objects are searched for and added to "
"the link map in the left-to-right order specified in the list."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:407
msgid ""
"In secure-execution mode, preload pathnames containing slashes are ignored.  "
"Furthermore, shared objects are preloaded only from the standard search "
"directories and only if they have set-user-ID mode bit enabled (which is not "
"typical)."
msgstr ""

#.  Tested with the following:
#
#. 	LD_PRELOAD='$LIB/libmod.so' LD_LIBRARY_PATH=. ./prog
#
#.  which will preload the libmod.so in 'lib' or 'lib64', using it
#.  in preference to the version in '.'.
#. type: Plain text
#: build/C/man8/ld.so.8:426
msgid ""
"Within the names specified in the B<LD_PRELOAD> list, the dynamic linker "
"understands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the "
"versions using curly braces around the names)  as described above in "
"I<Dynamic string tokens>.  (See also the discussion of quoting under the "
"description of B<LD_LIBRARY_PATH>.)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:429
msgid ""
"There are various methods of specifying libraries to be preloaded, and these "
"are handled in the following order:"
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:430
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:434
msgid "The B<LD_PRELOAD> environment variable."
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:434
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:438
msgid ""
"The B<--preload> command-line option when invoking the dynamic linker "
"directly."
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:438
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:442
msgid "The I</etc/ld.so.preload> file (described below)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:443
#, no-wrap
msgid "B<LD_TRACE_LOADED_OBJECTS>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:449
msgid ""
"If set (to any value), causes the program to list its dynamic dependencies, "
"as if run by B<ldd>(1), instead of running normally."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:452
msgid ""
"Then there are lots of more or less obscure variables, many obsolete or only "
"for internal use."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:452
#, no-wrap
msgid "B<LD_AUDIT> (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:461
msgid ""
"A list of user-specified, ELF shared objects to be loaded before all others "
"in a separate linker namespace (i.e., one that does not intrude upon the "
"normal symbol bindings that would occur in the process)  These objects can "
"be used to audit the operation of the dynamic linker.  The items in the list "
"are colon-separated, and there is no support for escaping the separator."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:464
msgid "B<LD_AUDIT> is ignored in secure-execution mode."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:477
msgid ""
"The dynamic linker will notify the audit shared objects at so-called "
"auditing checkpoints\\(emfor example, loading a new shared object, resolving "
"a symbol, or calling a symbol from another shared object\\(emby calling an "
"appropriate function within the audit shared object.  For details, see "
"B<rtld-audit>(7).  The auditing interface is largely compatible with that "
"provided on Solaris, as described in its I<Linker and Libraries Guide>, in "
"the chapter I<Runtime Linker Auditing Interface>."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:490
msgid ""
"Within the names specified in the B<LD_AUDIT> list, the dynamic linker "
"understands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the "
"versions using curly braces around the names)  as described above in "
"I<Dynamic string tokens>.  (See also the discussion of quoting under the "
"description of B<LD_LIBRARY_PATH>.)"
msgstr ""

#.  commit 8e9f92e9d5d7737afdacf79b76d98c4c42980508
#. type: Plain text
#: build/C/man8/ld.so.8:497
msgid ""
"Since glibc 2.13, in secure-execution mode, names in the audit list that "
"contain slashes are ignored, and only shared objects in the standard search "
"directories that have the set-user-ID mode bit enabled are loaded."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:497
#, no-wrap
msgid "B<LD_BIND_NOT> (since glibc 2.1.95)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:509
msgid ""
"If this environment variable is set to a nonempty string, do not update the "
"GOT (global offset table) and PLT (procedure linkage table)  after resolving "
"a function symbol.  By combining the use of this variable with B<LD_DEBUG> "
"(with the categories I<bindings> and I<symbols>), one can observe all "
"run-time function bindings."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:509
#, no-wrap
msgid "B<LD_DEBUG> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:514
msgid ""
"Output verbose debugging information about operation of the dynamic linker.  "
"The content of this variable is one of more of the following categories, "
"separated by colons, commas, or (if the value is quoted) spaces:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:515
#, no-wrap
msgid "I<help>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:522
msgid ""
"Specifying I<help> in the value of this variable does not run the specified "
"program, and displays a help message about which categories can be specified "
"in this environment variable."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:522
#, no-wrap
msgid "I<all>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:529
msgid ""
"Print all debugging information (except I<statistics> and I<unused>; see "
"below)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:529
#, no-wrap
msgid "I<bindings>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:532
msgid "Display information about which definition each symbol is bound to."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:532
#, no-wrap
msgid "I<files>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:535
msgid "Display progress for input file."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:535
#, no-wrap
msgid "I<libs>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:538
msgid "Display library search paths."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:538
#, no-wrap
msgid "I<reloc>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:541
msgid "Display relocation processing."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:541
#, no-wrap
msgid "I<scopes>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:544
msgid "Display scope information."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:544
#, no-wrap
msgid "I<statistics>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:547
msgid "Display relocation statistics."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:547
#, no-wrap
msgid "I<symbols>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:550
msgid "Display search paths for each symbol look-up."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:550
#, no-wrap
msgid "I<unused>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:553
msgid "Determine unused DSOs."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:553
#, no-wrap
msgid "I<versions>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:556
msgid "Display version dependencies."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:563
msgid ""
"Since glibc 2.3.4, B<LD_DEBUG> is ignored in secure-execution mode, unless "
"the file I</etc/suid-debug> exists (the content of the file is irrelevant)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:563
#, no-wrap
msgid "B<LD_DEBUG_OUTPUT> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:572
msgid ""
"By default, B<LD_DEBUG> output is written to standard error.  If "
"B<LD_DEBUG_OUTPUT> is defined, then output is written to the pathname "
"specified by its value, with the suffix \".\" (dot) followed by the process "
"ID appended to the pathname."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:575
msgid "B<LD_DEBUG_OUTPUT> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:575
#, no-wrap
msgid "B<LD_DYNAMIC_WEAK> (since glibc 2.1.91)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:579
msgid ""
"By default, when searching shared libraries to resolve a symbol reference, "
"the dynamic linker will resolve to the first definition it finds."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:588
msgid ""
"Old glibc versions (before 2.2), provided a different behavior: if the "
"linker found a symbol that was weak, it would remember that symbol and keep "
"searching in the remaining shared libraries.  If it subsequently found a "
"strong definition of the same symbol, then it would instead use that "
"definition.  (If no further symbol was found, then the dynamic linker would "
"use the weak symbol that it initially found.)"
msgstr ""

#.  More precisely 2.1.92
#.  See weak handling
#.      https://www.sourceware.org/ml/libc-hacker/2000-06/msg00029.html
#.      To: GNU libc hacker <libc-hacker at sourceware dot cygnus dot com>
#.      Subject: weak handling
#.      From: Ulrich Drepper <drepper at redhat dot com>
#.      Date: 07 Jun 2000 20:08:12 -0700
#.      Reply-To: drepper at cygnus dot com (Ulrich Drepper)
#. type: Plain text
#: build/C/man8/ld.so.8:604
msgid ""
"The old glibc behavior was nonstandard.  (Standard practice is that the "
"distinction between weak and strong symbols should have effect only at "
"static link time.)  In glibc 2.2, the dynamic linker was modified to provide "
"the current behavior (which was the behavior that was provided by most other "
"implementations at that time)."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:614
msgid ""
"Defining the B<LD_DYNAMIC_WEAK> environment variable (with any value) "
"provides the old (nonstandard) glibc behavior, whereby a weak symbol in one "
"shared library may be overridden by a strong symbol subsequently discovered "
"in another shared library.  (Note that even when this variable is set, a "
"strong symbol in a shared library will not override a weak definition of the "
"same symbol in the main program.)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:618
msgid "Since glibc 2.3.4, B<LD_DYNAMIC_WEAK> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:618
#, no-wrap
msgid "B<LD_HWCAP_MASK> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:621
msgid "Mask for hardware capabilities."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:621
#, no-wrap
msgid "B<LD_ORIGIN_PATH> (since glibc 2.1)"
msgstr ""

#.  Used only if $ORIGIN can't be determined by normal means
#.  (from the origin path saved at load time, or from /proc/self/exe)?
#. type: Plain text
#: build/C/man8/ld.so.8:626
msgid "Path where the binary is found."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:630
msgid "Since glibc 2.4, B<LD_ORIGIN_PATH> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:630
#, no-wrap
msgid "B<LD_POINTER_GUARD> (glibc from 2.4 to 2.22)"
msgstr ""

#.  commit a014cecd82b71b70a6a843e250e06b541ad524f7
#. type: Plain text
#: build/C/man8/ld.so.8:646
msgid ""
"Set to 0 to disable pointer guarding.  Any other value enables pointer "
"guarding, which is also the default.  Pointer guarding is a security "
"mechanism whereby some pointers to code stored in writable program memory "
"(return addresses saved by B<setjmp>(3)  or function pointers used by "
"various glibc internals) are mangled semi-randomly to make it more difficult "
"for an attacker to hijack the pointers for use in the event of a buffer "
"overrun or stack-smashing attack.  Since glibc 2.23, B<LD_POINTER_GUARD> can "
"no longer be used to disable pointer guarding, which is now always enabled."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:646
#, no-wrap
msgid "B<LD_PROFILE> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:652
msgid ""
"The name of a (single) shared object to be profiled, specified either as a "
"pathname or a soname.  Profiling output is appended to the file whose name "
"is: \"I<$LD_PROFILE_OUTPUT>/I<$LD_PROFILE>.profile\"."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:656
msgid "Since glibc 2.2.5, B<LD_PROFILE> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:656
#, no-wrap
msgid "B<LD_PROFILE_OUTPUT> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:664
msgid ""
"Directory where B<LD_PROFILE> output should be written.  If this variable is "
"not defined, or is defined as an empty string, then the default is "
"I</var/tmp>."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:673
msgid ""
"B<LD_PROFILE_OUTPUT> is ignored in secure-execution mode; instead "
"I</var/profile> is always used.  (This detail is relevant only before glibc "
"2.2.5, since in later glibc versions, B<LD_PROFILE> is also ignored in "
"secure-execution mode.)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:673
#, no-wrap
msgid "B<LD_SHOW_AUXV> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:678
msgid ""
"If this environment variable is defined (with any value), show the auxiliary "
"array passed up from the kernel (see also B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:682
msgid "Since glibc 2.3.4, B<LD_SHOW_AUXV> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:682
#, no-wrap
msgid "B<LD_TRACE_PRELINKING> (since glibc 2.4)"
msgstr ""

#.  (This is what seems to happen, from experimenting)
#. type: Plain text
#: build/C/man8/ld.so.8:693
msgid ""
"If this environment variable is defined, trace prelinking of the object "
"whose name is assigned to this environment variable.  (Use B<ldd>(1)  to get "
"a list of the objects that might be traced.)  If the object name is not "
"recognized, then all prelinking activity is traced."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:693
#, no-wrap
msgid "B<LD_USE_LOAD_BIAS> (since glibc 2.3.3)"
msgstr ""

#.  http://sources.redhat.com/ml/libc-hacker/2003-11/msg00127.html
#.  Subject: [PATCH] Support LD_USE_LOAD_BIAS
#.  Jakub Jelinek
#. type: Plain text
#: build/C/man8/ld.so.8:711
msgid ""
"By default (i.e., if this variable is not defined), executables and "
"prelinked shared objects will honor base addresses of their dependent shared "
"objects and (nonprelinked) position-independent executables (PIEs)  and "
"other shared objects will not honor them.  If B<LD_USE_LOAD_BIAS> is defined "
"with the value 1, both executables and PIEs will honor the base addresses.  "
"If B<LD_USE_LOAD_BIAS> is defined with the value 0, neither executables nor "
"PIEs will honor the base addresses."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:713
msgid "Since glibc 2.3.3, this variable is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:713
#, no-wrap
msgid "B<LD_VERBOSE> (since glibc 2.1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:720
msgid ""
"If set to a nonempty string, output symbol versioning information about the "
"program if the B<LD_TRACE_LOADED_OBJECTS> environment variable has been set."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:720
#, no-wrap
msgid "B<LD_WARN> (since glibc 2.1.3)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:723
msgid "If set to a nonempty string, warn about unresolved symbols."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:723
#, no-wrap
msgid "B<LD_PREFER_MAP_32BIT_EXEC> (x86-64 only; since glibc 2.23)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:735
msgid ""
"According to the Intel Silvermont software optimization guide, for 64-bit "
"applications, branch prediction performance can be negatively impacted when "
"the target of a branch is more than 4\\ GB away from the branch.  If this "
"environment variable is set (to any value), the dynamic linker will first "
"try to map executable pages using the B<mmap>(2)  B<MAP_32BIT> flag, and "
"fall back to mapping without that flag if that attempt fails.  NB: MAP_32BIT "
"will map to the low 2\\ GB (not 4\\ GB) of the address space."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:742
msgid ""
"Because B<MAP_32BIT> reduces the address range available for address space "
"layout randomization (ASLR), B<LD_PREFER_MAP_32BIT_EXEC> is always disabled "
"in secure-execution mode."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:742 build/C/man8/ldconfig.8:196
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:743 build/C/man8/ldconfig.8:201
#, no-wrap
msgid "I</lib/ld.so>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:746
msgid "a.out dynamic linker/loader"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:746
#, no-wrap
msgid "I</lib/ld-linux.so.>{I<1>,I<2>}"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:749
msgid "ELF dynamic linker/loader"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:749 build/C/man8/ldconfig.8:208
#, no-wrap
msgid "I</etc/ld.so.cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:755
msgid ""
"File containing a compiled list of directories in which to search for shared "
"objects and an ordered list of candidate shared objects.  See "
"B<ldconfig>(8)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:755
#, no-wrap
msgid "I</etc/ld.so.preload>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:776
msgid ""
"File containing a whitespace-separated list of ELF shared objects to be "
"loaded before the program.  See the discussion of B<LD_PRELOAD> above.  If "
"both B<LD_PRELOAD> and I</etc/ld.so.preload> are employed, the libraries "
"specified by B<LD_PRELOAD> are preloaded first.  I</etc/ld.so.preload> has a "
"system-wide effect, causing the specified libraries to be preloaded for all "
"programs that are executed on the system.  (This is usually undesirable, and "
"is typically employed only as an emergency remedy, for example, as a "
"temporary workaround to a library misconfiguration issue.)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:776
#, no-wrap
msgid "I<lib*.so*>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:779
msgid "shared objects"
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:780
#, no-wrap
msgid "Hardware capabilities"
msgstr ""

#.  Presumably, this info comes from sysdeps/i386/dl-procinfo.c and
#.  similar files
#. type: Plain text
#: build/C/man8/ld.so.8:793
msgid ""
"Some shared objects are compiled using hardware-specific instructions which "
"do not exist on every CPU.  Such objects should be installed in directories "
"whose names define the required hardware capabilities, such as "
"I</usr/lib/sse2/>.  The dynamic linker checks these directories against the "
"hardware of the machine and selects the most suitable version of a given "
"shared object.  Hardware capability directories can be cascaded to combine "
"CPU features.  The list of supported hardware capability names depends on "
"the CPU.  The following names are currently recognized:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:793
#, no-wrap
msgid "B<Alpha>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:796
msgid "ev4, ev5, ev56, ev6, ev67"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:796
#, no-wrap
msgid "B<MIPS>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:799
msgid "loongson2e, loongson2f, octeon, octeon2"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:799
#, no-wrap
msgid "B<PowerPC>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:804
msgid ""
"4xxmac, altivec, arch_2_05, arch_2_06, booke, cellbe, dfp, efpdouble, "
"efpsingle, fpu, ic_snoop, mmu, notb, pa6t, power4, power5, power5+, power6x, "
"ppc32, ppc601, ppc64, smt, spe, ucache, vsx"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:804
#, no-wrap
msgid "B<SPARC>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:807
msgid "flush, muldiv, stbar, swap, ultra3, v9, v9v, v9v2"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:807
#, no-wrap
msgid "B<s390>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:811
msgid ""
"dfp, eimm, esan3, etf3enh, g5, highgprs, hpage, ldisp, msa, stfle, z900, "
"z990, z9-109, z10, zarch"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:811
#, no-wrap
msgid "B<x86 (32-bit only)>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:815
msgid ""
"acpi, apic, clflush, cmov, cx8, dts, fxsr, ht, i386, i486, i586, i686, mca, "
"mmx, mtrr, pat, pbe, pge, pn, pse36, sep, ss, sse, sse2, tm"
msgstr ""

#.  .SH AUTHORS
#.  ld.so: David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus
#.   Torvalds, Lars Wirzenius and Mitch D'Souza
#.  ld\-linux.so: Roland McGrath, Ulrich Drepper and others.
#
#.  In the above, (libc5) stands for David Engel's ld.so/ld\-linux.so.
#. type: Plain text
#: build/C/man8/ld.so.8:833
msgid ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<sprof>(1), B<dlopen>(3), B<getauxval>(3), "
"B<elf>(5), B<capabilities>(7), B<rtld-audit>(7), B<ldconfig>(8), B<sln>(8)"
msgstr ""

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "LDCONFIG"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:25
msgid "ldconfig - configure dynamic linker run-time bindings"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:28
msgid ""
"B</sbin/ldconfig> [B<-nNvXV>] [B<-f> I<conf>] [B<-C> I<cache>] [B<-r> "
"I<root>] I<directory>..."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:35
msgid "B</sbin/ldconfig> B<-l> [B<-v>] I<library>..."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:40
msgid "B</sbin/ldconfig> B<-p>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:59
msgid ""
"B<ldconfig> creates the necessary links and cache to the most recent shared "
"libraries found in the directories specified on the command line, in the "
"file I</etc/ld.so.conf>, and in the trusted directories, I</lib> and "
"I</usr/lib> (on some 64-bit architectures such as x86-64, I</lib> and "
"I</usr/lib> are the trusted directories for 32-bit libraries, while "
"I</lib64> and I</usr/lib64> are used for 64-bit libraries)."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:67
msgid ""
"The cache is used by the run-time linker, I<ld.so> or I<ld-linux.so>.  "
"B<ldconfig> checks the header and filenames of the libraries it encounters "
"when determining which versions should have their links updated."
msgstr ""

#.  The following sentence looks suspect
#.  (perhaps historical cruft) -- MTK, Jul 2005
#.  Therefore, when making dynamic libraries,
#.  it is wise to explicitly link against libc (use \-lc).
#. type: Plain text
#: build/C/man8/ldconfig.8:75
msgid ""
"B<ldconfig> will attempt to deduce the type of ELF libraries (i.e., libc5 or "
"libc6/glibc)  based on what C libraries, if any, the library was linked "
"against."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:96
msgid ""
"Some existing libraries do not contain enough information to allow the "
"deduction of their type.  Therefore, the I</etc/ld.so.conf> file format "
"allows the specification of an expected type.  This is used I<only> for "
"those ELF libraries which we can not work out.  The format is "
"\"dirname=TYPE\", where TYPE can be libc4, libc5, or libc6.  (This syntax "
"also works on the command line.)  Spaces are I<not> allowed.  Also see the "
"B<-p> option.  B<ldconfig> should normally be run by the superuser as it may "
"require write permission on some root owned directories and files."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:111
msgid ""
"Note that B<ldconfig> will only look at files that are named I<lib*.so*> "
"(for regular shared objects) or I<ld-*.so*> (for the dynamic loader "
"itself).  Other files will be ignored.  Also, B<ldconfig> expects a certain "
"pattern to how the symlinks are set up, like this example, where the middle "
"file (B<libfoo.so.1> here) is the SONAME for the library:"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:115
#, no-wrap
msgid "libfoo.so -E<gt> libfoo.so.1 -E<gt> libfoo.so.1.12\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:120
msgid ""
"Failure to follow this pattern may result in compatibility issues after an "
"upgrade."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:121
#, no-wrap
msgid "B<-c> I<fmt>, B<--format=>I<fmt>"
msgstr ""

#.  commit cad64f778aced84efdaa04ae64f8737b86f063ab
#. type: Plain text
#: build/C/man8/ldconfig.8:134
msgid ""
"(Since glibc 2.2)  Cache format to use: I<old>, I<new>, or I<compat>.  Since "
"glibc 2.32, the default is I<new>.  Before that, it was I<compat>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:134
#, no-wrap
msgid "B<-C >I<cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:140
msgid "Use I<cache> instead of I</etc/ld.so.cache>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:140
#, no-wrap
msgid "B<-f >I<conf>"
msgstr ""

#.  FIXME glibc 2.7 added -i
#. type: Plain text
#: build/C/man8/ldconfig.8:147
msgid "Use I<conf> instead of I</etc/ld.so.conf>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:147
#, no-wrap
msgid "B<-i>, B<--ignore-aux-cache>"
msgstr ""

#.              commit 27d9ffda17df4d2388687afd12897774fde39bcc
#. type: Plain text
#: build/C/man8/ldconfig.8:152
msgid "(Since glibc 2.7)  Ignore auxiliary cache file."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:152
#, no-wrap
msgid "B<-l>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:158
msgid ""
"(Since glibc 2.2)  Library mode.  Manually link individual libraries.  "
"Intended for use by experts only."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:158
#, no-wrap
msgid "B<-n>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:166
msgid ""
"Process only the directories specified on the command line.  Don't process "
"the trusted directories, nor those specified in I</etc/ld.so.conf>.  Implies "
"B<-N>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:166
#, no-wrap
msgid "B<-N>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:172
msgid ""
"Don't rebuild the cache.  Unless B<-X> is also specified, links are still "
"updated."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:172
#, no-wrap
msgid "B<-p>, B<--print-cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:176
msgid ""
"Print the lists of directories and candidate libraries stored in the current "
"cache."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:176
#, no-wrap
msgid "B<-r >I<root>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:181
msgid "Change to and use I<root> as the root directory."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:181 build/C/man1/ldd.1:120
#, no-wrap
msgid "B<-v>, B<--verbose>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:187
msgid ""
"Verbose mode.  Print current version number, the name of each directory as "
"it is scanned, and any links that are created.  Overrides quiet mode."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:187 build/C/man1/pldd.1:47 build/C/man1/sprof.1:72
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:190
msgid "Print program version."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:190
#, no-wrap
msgid "B<-X>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:196
msgid ""
"Don't update links.  Unless B<-N> is also specified, the cache is still "
"rebuilt."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:204
msgid "Run-time linker/loader."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:204
#, no-wrap
msgid "I</etc/ld.so.conf>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:208
msgid ""
"File containing a list of directories, one per line, in which to search for "
"libraries."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:214
msgid ""
"File containing an ordered list of libraries found in the directories "
"specified in I</etc/ld.so.conf>, as well as those found in the trusted "
"directories."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:218
msgid "B<ldd>(1), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man1/ldd.1:14
#, no-wrap
msgid "LDD"
msgstr ""

#. type: TH
#: build/C/man1/ldd.1:14
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:17
msgid "ldd - print shared object dependencies"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:19
msgid "B<ldd> [I<option>]... I<file>..."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:28
msgid ""
"B<ldd> prints the shared objects (shared libraries) required by each program "
"or shared object specified on the command line.  An example of its use and "
"output (using B<sed>(1)  to trim leading white space for readability in this "
"page)  is the following:"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:41
#, no-wrap
msgid ""
"$ B<ldd /bin/ls | sed \\(aqs/^ */    /\\(aq>\n"
"    linux-vdso.so.1 (0x00007ffcc3563000)\n"
"    libselinux.so.1 =E<gt> /lib64/libselinux.so.1 (0x00007f87e5459000)\n"
"    libcap.so.2 =E<gt> /lib64/libcap.so.2 (0x00007f87e5254000)\n"
"    libc.so.6 =E<gt> /lib64/libc.so.6 (0x00007f87e4e92000)\n"
"    libpcre.so.1 =E<gt> /lib64/libpcre.so.1 (0x00007f87e4c22000)\n"
"    libdl.so.2 =E<gt> /lib64/libdl.so.2 (0x00007f87e4a1e000)\n"
"    /lib64/ld-linux-x86-64.so.2 (0x00005574bf12e000)\n"
"    libattr.so.1 =E<gt> /lib64/libattr.so.1 (0x00007f87e4817000)\n"
"    libpthread.so.0 =E<gt> /lib64/libpthread.so.0 (0x00007f87e45fa000)\n"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:68
msgid ""
"In the usual case, B<ldd> invokes the standard dynamic linker (see "
"B<ld.so>(8))  with the B<LD_TRACE_LOADED_OBJECTS> environment variable set "
"to 1.  This causes the dynamic linker to inspect the program's dynamic "
"dependencies, and find (according to the rules described in B<ld.so>(8))  "
"and load the objects that satisfy those dependencies.  For each dependency, "
"B<ldd> displays the location of the matching object and the (hexadecimal) "
"address at which it is loaded.  (The I<linux-vdso> and I<ld-linux> shared "
"dependencies are special; see B<vdso>(7)  and B<ld.so>(8).)"
msgstr ""

#. type: SS
#: build/C/man1/ldd.1:68
#, no-wrap
msgid "Security"
msgstr ""

#.  The circumstances are where the program has an interpreter
#.  other than ld-linux.so. In this case, ldd tries to execute the
#.  program directly with LD_TRACE_LOADED_OBJECTS=1, with the
#.  result that the program interpreter gets control, and can do
#.  what it likes, or pass control to the program itself.
#.  Much more detail at
#.  http://www.catonmat.net/blog/ldd-arbitrary-code-execution/
#.  Mainline glibc's ldd allows this possibility (the line
#.       try_trace "$file"
#.  in glibc 2.15, for example), but many distro versions of
#.  ldd seem to remove that code path from the script.
#.  glibc commit eedca9772e99c72ab4c3c34e43cc764250aa3e3c
#. type: Plain text
#: build/C/man1/ldd.1:96
msgid ""
"Be aware that in some circumstances (e.g., where the program specifies an "
"ELF interpreter other than I<ld-linux.so>), some versions of B<ldd> may "
"attempt to obtain the dependency information by attempting to directly "
"execute the program, which may lead to the execution of whatever code is "
"defined in the program's ELF interpreter, and perhaps to execution of the "
"program itself.  (In glibc versions before 2.27, the upstream B<ldd> "
"implementation did this for example, although most distributions provided a "
"modified version that did not.)"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:104
msgid ""
"Thus, you should I<never> employ B<ldd> on an untrusted executable, since "
"this may result in the execution of arbitrary code.  A safer alternative "
"when dealing with untrusted executables is:"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:108
#, no-wrap
msgid "$ B<objdump -p /path/to/program | grep NEEDED>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:115
msgid ""
"Note, however, that this alternative shows only the direct dependencies of "
"the executable, while B<ldd> shows the entire dependency tree of the "
"executable."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:116 build/C/man1/mtrace.1:55
#, no-wrap
msgid "B<--version>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:120
msgid "Print the version number of B<ldd>."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:124
msgid ""
"Print all information, including, for example, symbol versioning "
"information."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:124
#, no-wrap
msgid "B<-u>, B<--unused>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:128
msgid "Print unused direct dependencies.  (Since glibc 2.3.4.)"
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:128
#, no-wrap
msgid "B<-d>, B<--data-relocs>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:131
msgid "Perform relocations and report any missing objects (ELF only)."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:131
#, no-wrap
msgid "B<-r>, B<--function-relocs>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:135
msgid ""
"Perform relocations for both data objects and functions, and report any "
"missing objects or functions (ELF only)."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:135 build/C/man1/mtrace.1:52
#, no-wrap
msgid "B<--help>"
msgstr ""

#.  .SH NOTES
#.  The standard version of
#.  .B ldd
#.  comes with glibc2.
#.  Libc5 came with an older version, still present
#.  on some systems.
#.  The long options are not supported by the libc5 version.
#.  On the other hand, the glibc2 version does not support
#.  .B \-V
#.  and only has the equivalent
#.  .BR \-\-version .
#.  .LP
#.  The libc5 version of this program will use the name of a library given
#.  on the command line as-is when it contains a \(aq/\(aq; otherwise it
#.  searches for the library in the standard locations.
#.  To run it
#.  on a shared library in the current directory, prefix the name with "./".
#. type: Plain text
#: build/C/man1/ldd.1:155
msgid "Usage information."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:158
msgid "B<ldd> does not work on a.out shared libraries."
msgstr ""

#.  .SH AUTHOR
#.  David Engel.
#.  Roland McGrath and Ulrich Drepper.
#. type: Plain text
#: build/C/man1/ldd.1:172
msgid ""
"B<ldd> does not work with some extremely old a.out programs which were built "
"before B<ldd> support was added to the compiler releases.  If you use B<ldd> "
"on one of these programs, the program will attempt to run with I<argc> = 0 "
"and the results will be unpredictable."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:177
msgid "B<pldd>(1), B<sprof>(1), B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man1/memusage.1:24
#, no-wrap
msgid "MEMUSAGE"
msgstr ""

#. type: TH
#: build/C/man1/memusage.1:24 build/C/man1/mtrace.1:23
#, no-wrap
msgid "Linux user manual"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:27
msgid "memusage - profile memory usage of a program"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:29
msgid "B<memusage> [I<option>]... I<program> [I<programoption>]..."
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:53
msgid ""
"B<memusage> is a bash script which profiles memory usage of the program, "
"I<program>.  It preloads the B<libmemusage.so> library into the caller's "
"environment (via the B<LD_PRELOAD> environment variable; see B<ld.so>(8)).  "
"The B<libmemusage.so> library traces memory allocation by intercepting calls "
"to B<malloc>(3), B<calloc>(3), B<free>(3), and B<realloc>(3); optionally, "
"calls to B<mmap>(2), B<mremap>(2), and B<munmap>(2)  can also be "
"intercepted."
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:62
msgid ""
"B<memusage> can output the collected data in textual form, or it can use "
"B<memusagestat>(1)  (see the B<-p> option, below)  to create a PNG file "
"containing graphical representation of the collected data."
msgstr ""

#. type: SS
#: build/C/man1/memusage.1:62
#, no-wrap
msgid "Memory usage summary"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:66
msgid ""
"The \"Memory usage summary\" line output by B<memusage> contains three "
"fields:"
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:67
#, no-wrap
msgid "B<heap total>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:84
msgid ""
"Sum of I<size> arguments of all B<malloc>(3)  calls, products of arguments "
"(I<nmemb>*I<size>) of all B<calloc>(3)  calls, and sum of I<length> "
"arguments of all B<mmap>(2)  calls.  In the case of B<realloc>(3)  and "
"B<mremap>(2), if the new size of an allocation is larger than the previous "
"size, the sum of all such differences (new size minus old size) is added."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:84
#, no-wrap
msgid "B<heap peak>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:98
msgid ""
"Maximum of all I<size> arguments of B<malloc>(3), all products of "
"I<nmemb>*I<size> of B<calloc>(3), all I<size> arguments of B<realloc>(3), "
"I<length> arguments of B<mmap>(2), and I<new_size> arguments of "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:98
#, no-wrap
msgid "B<stack peak>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:105
msgid ""
"Before the first call to any monitored function, the stack pointer address "
"(base stack pointer) is saved.  After each function call, the actual stack "
"pointer address is read and the difference from the base stack pointer "
"computed.  The maximum of these differences is then the stack peak."
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:122
msgid ""
"Immediately following this summary line, a table shows the number calls, "
"total memory allocated or deallocated, and number of failed calls for each "
"intercepted function.  For B<realloc>(3)  and B<mremap>(2), the additional "
"field \"nomove\" shows reallocations that changed the address of a block, "
"and the additional \"dec\" field shows reallocations that decreased the size "
"of the block.  For B<realloc>(3), the additional field \"free\" shows "
"reallocations that caused a block to be freed (i.e., the reallocated size "
"was 0)."
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:131
msgid ""
"The \"realloc/total memory\" of the table output by B<memusage> does not "
"reflect cases where B<realloc>(3)  is used to reallocate a block of memory "
"to have a smaller size than previously.  This can cause sum of all \"total "
"memory\" cells (excluding \"free\")  to be larger than the \"free/total "
"memory\" cell."
msgstr ""

#. type: SS
#: build/C/man1/memusage.1:131
#, no-wrap
msgid "Histogram for block sizes"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:134
msgid ""
"The \"Histogram for block sizes\" provides a breakdown of memory allocations "
"into various bucket sizes."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:135
#, no-wrap
msgid "B<-n\\ >I<name>,\\ B<--progname=>I<name>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:138
msgid "Name of the program file to profile."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:138
#, no-wrap
msgid "B<-p\\ >I<file>,\\ B<--png=>I<file>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:142
msgid "Generate PNG graphic and store it in I<file>."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:142
#, no-wrap
msgid "B<-d\\ >I<file>,\\ B<--data=>I<file>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:146
msgid "Generate binary data file and store it in I<file>."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:146
#, no-wrap
msgid "B<-u>,\\ B<--unbuffered>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:149
msgid "Do not buffer output."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:149
#, no-wrap
msgid "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:154
msgid "Collect I<size> entries before writing them out."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:154
#, no-wrap
msgid "B<--no-timer>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:159
msgid "Disable timer-based (B<SIGPROF>)  sampling of stack pointer value."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:159
#, no-wrap
msgid "B<-m>,\\ B<--mmap>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:166
msgid "Also trace B<mmap>(2), B<mremap>(2), and B<munmap>(2)."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:166 build/C/man1/memusagestat.1:72
#, no-wrap
msgid "B<-?>,\\ B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:169 build/C/man1/mtrace.1:55
msgid "Print help and exit."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:169 build/C/man1/memusagestat.1:75 build/C/man1/pldd.1:44 build/C/man1/sprof.1:69
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:172 build/C/man1/memusagestat.1:78
msgid "Print a short usage message and exit."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:172 build/C/man1/memusagestat.1:78
#, no-wrap
msgid "B<-V>,\\ B<--version>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:175 build/C/man1/memusagestat.1:81 build/C/man1/mtrace.1:58
msgid "Print version information and exit."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:175
#, no-wrap
msgid "The following options apply only when generating graphical output:"
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:177
#, no-wrap
msgid "B<-t>,\\ B<--time-based>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:180 build/C/man1/memusagestat.1:59
msgid "Use time (rather than number of function calls) as the scale for the X axis."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:180 build/C/man1/memusagestat.1:59
#, no-wrap
msgid "B<-T>,\\ B<--total>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:183
msgid "Also draw a graph of total memory use."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:183
#, no-wrap
msgid "B<--title=>I<name>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:188
msgid "Use I<name> as the title of the graph."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:188 build/C/man1/memusagestat.1:62
#, no-wrap
msgid "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:193
msgid "Make the graph I<size> pixels wide."
msgstr ""

#. type: TP
#: build/C/man1/memusage.1:193 build/C/man1/memusagestat.1:67
#, no-wrap
msgid "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:198
msgid "Make the graph I<size> pixels high."
msgstr ""

#. type: SH
#: build/C/man1/memusage.1:198 build/C/man1/pldd.1:50
#, no-wrap
msgid "EXIT STATUS"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:200
msgid "Exit status is equal to the exit status of profiled program."
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:204 build/C/man1/memusagestat.1:85
msgid "To report bugs, see E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:211
msgid ""
"Below is a simple program that reallocates a block of memory in cycles that "
"rise to a peak before then cyclically reallocating the memory in smaller "
"blocks that return to zero.  After compiling the program and running the "
"following commands, a graph of the memory usage of the program can be found "
"in the file I<memusage.png>:"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:235
#, no-wrap
msgid ""
"$ B<memusage --data=memusage.dat ./a.out>\n"
"\\&...\n"
"Memory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n"
"        total calls  total memory  failed calls\n"
" malloc|         1           400             0\n"
"realloc|        40         44800             0  (nomove:40, dec:19, "
"free:0)\n"
" calloc|         0             0             0\n"
"   free|         1           440\n"
"Histogram for block sizes:\n"
"  192-207             1   2% ================\n"
"\\&...\n"
" 2192-2207            1   2% ================\n"
" 2240-2255            2   4% =================================\n"
" 2832-2847            2   4% =================================\n"
" 3440-3455            2   4% =================================\n"
" 4032-4047            2   4% =================================\n"
" 4640-4655            2   4% =================================\n"
" 5232-5247            2   4% =================================\n"
" 5840-5855            2   4% =================================\n"
" 6432-6447            1   2% ================\n"
"$ B<memusagestat memusage.dat memusage.png>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:243
#, no-wrap
msgid "#define CYCLES 20\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, j;\n"
"    size_t size;\n"
"    int *p;\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:254
#, no-wrap
msgid ""
"    size = sizeof(*p) * 100;\n"
"    printf(\"malloc: %zu\\en\", size);\n"
"    p = malloc(size);\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:260
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> CYCLES; i++) {\n"
"        if (i E<lt> CYCLES / 2)\n"
"            j = i;\n"
"        else\n"
"            j--;\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:264
#, no-wrap
msgid ""
"        size = sizeof(*p) * (j * 50 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:269
#, no-wrap
msgid ""
"        size = sizeof(*p) * ((j + 1) * 150 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:273
#, no-wrap
msgid ""
"    free(p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/memusage.1:278
msgid "B<memusagestat>(1), B<mtrace>(1), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man1/memusagestat.1:23
#, no-wrap
msgid "MEMUSAGESTAT"
msgstr ""

#. type: TH
#: build/C/man1/memusagestat.1:23
#, no-wrap
msgid "Linux programmer's manual"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:26
msgid "memusagestat - generate graphic from memory profiling data"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:28
msgid "B<memusagestat> [I<option>]... I<datafile> [I<outfile>]"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:39
msgid ""
"B<memusagestat> creates a PNG file containing a graphical representation of "
"the memory profiling data in the file I<datafile>; that file is generated "
"via the I<-d> (or I<--data>)  option of B<memusage>(1)."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:47
msgid ""
"The red line in the graph shows the heap usage (allocated memory)  and the "
"green line shows the stack usage.  The x-scale is either the number of "
"memory-handling function calls or (if the I<-t> option is specified)  time."
msgstr ""

#. type: TP
#: build/C/man1/memusagestat.1:48
#, no-wrap
msgid "B<-o\\ >I<file>,\\ B<--output=>I<file>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:51
msgid "Name of the output file."
msgstr ""

#. type: TP
#: build/C/man1/memusagestat.1:51
#, no-wrap
msgid "B<-s\\ >I<string>,\\ B<--string=>I<string>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:56
msgid "Use I<string> as the title inside the output graph."
msgstr ""

#. type: TP
#: build/C/man1/memusagestat.1:56
#, no-wrap
msgid "B<-t>,\\ B<--time>"
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:62
msgid "Also draw a graph of total memory consumption."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:67
msgid "Make the output graph I<size> pixels wide."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:72
msgid "Make the output graph I<size> pixels high."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:75
msgid "Print a help message and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:88
msgid "See B<memusage>(1)."
msgstr ""

#. type: Plain text
#: build/C/man1/memusagestat.1:91
msgid "B<memusage>(1), B<mtrace>(1)"
msgstr ""

#. type: TH
#: build/C/man1/mtrace.1:23
#, no-wrap
msgid "MTRACE"
msgstr ""

#. type: TH
#: build/C/man1/mtrace.1:23 build/C/man8/sln.8:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:26
msgid "mtrace - interpret the malloc trace log"
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:28
msgid "B<mtrace> [I<option>]... [I<binary>] I<mtracedata>"
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:44
msgid ""
"B<mtrace> is a Perl script used to interpret and provide human readable "
"output of the trace log contained in the file I<mtracedata>, whose contents "
"were produced by B<mtrace>(3).  If I<binary> is provided, the output of "
"B<mtrace> also contains the source file name with line number information "
"for problem locations (assuming that I<binary> was compiled with debugging "
"information)."
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:51
msgid ""
"For more information about the B<mtrace>(3)  function and B<mtrace> script "
"usage, see B<mtrace>(3)."
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:62
msgid ""
"For bug reporting instructions, please see: E<.UR "
"http://www.gnu.org/software/libc/bugs.html> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man1/mtrace.1:65
msgid "B<memusage>(1), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man1/pldd.1:25
#, no-wrap
msgid "PLDD"
msgstr ""

#. type: TH
#: build/C/man1/pldd.1:25 build/C/man1/sprof.1:25
#, no-wrap
msgid "Linux User Manual"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:28
msgid "pldd - display dynamic shared objects linked into a process"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:32
#, no-wrap
msgid ""
"B<pldd >I<pid>\n"
"B<pldd>I< option>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:40
msgid ""
"The B<pldd> command displays a list of the dynamic shared objects (DSOs) "
"that are linked into the process with the specified process ID (PID).  The "
"list includes the libraries that have been dynamically loaded using "
"B<dlopen>(3)."
msgstr ""

#. type: TP
#: build/C/man1/pldd.1:41 build/C/man1/sprof.1:66
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:44
msgid "Display a help message and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:47 build/C/man1/sprof.1:72
msgid "Display a short usage message and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:50
msgid "Display program version information and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:61
msgid ""
"On success, B<pldd> exits with the status 0.  If the specified process does "
"not exist, the user does not have permission to access its dynamic shared "
"object list, or no command-line arguments are supplied, B<pldd> exists with "
"a status of 1.  If given an invalid option, it exits with the status 64."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:64
msgid "B<pldd> is available since glibc 2.15."
msgstr ""

#.  There are man pages on Solaris and HP-UX.
#. type: Plain text
#: build/C/man1/pldd.1:71
msgid ""
"The B<pldd> command is not specified by POSIX.1.  Some other systems have a "
"similar command."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:73
msgid "The command"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:77
#, no-wrap
msgid "lsof -p PID\n"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:82
msgid ""
"also shows output that includes the dynamic shared objects that are linked "
"into a process."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:92
msgid ""
"The B<gdb>(1)  I<info shared> command also shows the shared libraries being "
"used by a process, so that one can obtain similar output to B<pldd> using a "
"command such as the following (to monitor the process with the specified "
"I<pid>):"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:97
#, no-wrap
msgid ""
"$ B<gdb -ex \"set confirm off\" -ex \"set height 0\" -ex \"info shared\" "
"\\e>\n"
"        B<-ex \"quit\" -p $pid | grep \\(aq\\(ha0x.*0x\\(aq>\n"
msgstr ""

#.  glibc commit 1a4c27355e146b6d8cc6487b998462c7fdd1048f
#. type: Plain text
#: build/C/man1/pldd.1:106
msgid ""
"From glibc 2.19 to 2.29, B<pldd> was broken: it just hung when executed.  "
"This problem was fixed in glibc 2.30, and the fix has been backported to "
"earlier glibc versions in some distributions."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:118
#, no-wrap
msgid ""
"$ B<echo $$>               # Display PID of shell\n"
"1143\n"
"$ B<pldd $$>               # Display DSOs linked into the shell\n"
"1143:   /usr/bin/bash\n"
"linux-vdso.so.1\n"
"/lib64/libtinfo.so.5\n"
"/lib64/libdl.so.2\n"
"/lib64/libc.so.6\n"
"/lib64/ld-linux-x86-64.so.2\n"
"/lib64/libnss_files.so.2\n"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:124
msgid "B<ldd>(1), B<lsof>(1), B<dlopen>(3), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man7/rtld-audit.7:28
#, no-wrap
msgid "RTLD-AUDIT"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:31
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:44
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined "
"by including I<E<lt>link.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:51
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:59
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:59
#, no-wrap
msgid "la_version()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:63
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:73
msgid ""
"This is the only function that I<must> be defined by an auditing library: it "
"performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:84
msgid ""
"A typical implementation of this function simply returns the constant "
"B<LAV_CURRENT>, which indicates the version of I<E<lt>link.hE<gt>> that was "
"used to build the audit module.  If the dynamic linker does not support this "
"version of the audit interface, it will refuse to activate this audit "
"module.  If the function returns zero, the dynamic linker also does not "
"activate this audit module."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:100
msgid ""
"In order to enable backwards compatibility with older dynamic linkers, an "
"audit module can examine the I<version> argument and return an earlier "
"version than B<LAV_CURRENT>, assuming the module can adjust its "
"implementation to match the requirements of the previous version of the "
"audit interface.  The B<la_version> function should not return the value of "
"I<version> without further checks because it could correspond to an "
"interface that does not match the I<E<lt>link.hE<gt>> definitions used to "
"build the audit module."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:100
#, no-wrap
msgid "la_objsearch()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:105
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:116
msgid ""
"The dynamic linker invokes this function to inform the auditing library that "
"it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:116
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:125
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:125
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:130
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:130
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:138
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:138
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:145
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:145
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:149
msgid "I<name> was found via a search of one of the default directories."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:149
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:153
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:162
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then "
"this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:162
#, no-wrap
msgid "la_activity()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:166
#, no-wrap
msgid "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:175
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head "
"of the link map.  When the dynamic linker invokes this function, I<flag> is "
"set to one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:175
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:178
msgid "New objects are being added to the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:178
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:181
msgid "Objects are being removed from the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:181
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:184
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:184
#, no-wrap
msgid "la_objopen()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:189
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:198
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:201
msgid "Link map is part of the initial namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:205
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:213
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:220
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to "
"select the objects to be monitored by B<la_symbind*>():"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:220
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:223
msgid "Audit symbol bindings to this object."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:223
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:226
msgid "Audit symbol bindings from this object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:230
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:230
#, no-wrap
msgid "la_objclose()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:234
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:243
msgid ""
"The dynamic linker invokes this function after any finalization code for the "
"object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:247
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:247
#, no-wrap
msgid "la_preinit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:251
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:261
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:261
#, no-wrap
msgid "la_symbind*()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:270
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t "
"*>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char "
"*>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t "
"*>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char "
"*>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:282
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on "
"64-bit platforms."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:292
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:297
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the "
"bound shared object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:312
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:316
msgid "The I<symname> argument points a string containing the name of the symbol."
msgstr ""

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: build/C/man7/rtld-audit.7:324
msgid ""
"The I<flags> argument is a bit mask that both provides information about the "
"symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:324
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:328
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:328
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:333
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: build/C/man7/rtld-audit.7:347
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced.  "
"The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:347
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:352
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:352
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:357
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:368
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address "
"to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return "
"I<sym-E<gt>st_value>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:368
#, no-wrap
msgid "la_pltenter()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:374 build/C/man7/rtld-audit.7:434
msgid ""
"The precise name and argument types for this function depend on the hardware "
"platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)  "
"Here is the definition for x86-32:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:380
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int "
">I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long *>I<framesizep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:384
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:394 build/C/man7/rtld-audit.7:457
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:401
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)  "
"containing the values of registers to be used for the call to this PLT "
"entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:407
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""

#.  FIXME . Is the following correct?
#. type: Plain text
#: build/C/man7/rtld-audit.7:423
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used "
"to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltexit>()  "
"function is called only if this buffer is explicitly set to a suitable "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:428
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:428
#, no-wrap
msgid "la_pltexit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:440
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int "
">I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval "
"*>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:447
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:470
msgid ""
"The I<inregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing the values of registers used for the call "
"to this PLT entry.  The I<outregs> argument points to a structure (defined "
"in I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: build/C/man7/rtld-audit.7:478
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:484
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:487
msgid "Note the following differences from the Solaris dynamic linker auditing API:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:491
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:499
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide "
"a I<symname> argument."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:509
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""

#.  FIXME . Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: build/C/man7/rtld-audit.7:519
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:523
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:529
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): version = %u; LAV_CURRENT = %u\\en\",\n"
"            version, LAV_CURRENT);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:532
#, no-wrap
msgid ""
"    return LAV_CURRENT;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:545
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:548
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:558
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:568
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; "
"cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:571
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:576
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:585
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:594
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:597 build/C/man7/rtld-audit.7:609 build/C/man7/rtld-audit.7:619
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:606
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:616
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, "
"sym-E<gt>st_value);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:625
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man8/sln.8:25
#, no-wrap
msgid "SLN"
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:28
msgid "sln - create symbolic links"
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:30
msgid "B<sln>I< source dest>"
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:32
msgid "B<sln>I< filelist>"
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:42
msgid ""
"The B<sln> program creates symbolic links.  Unlike the B<ln>(1)  program, it "
"is statically linked.  This means that if for some reason the dynamic linker "
"is not working, B<sln> can be used to make symbolic links to dynamic "
"libraries."
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:48
msgid ""
"The command line has two forms.  In the first form, it creates I<dest> as a "
"new symbolic link to I<source>."
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:56
msgid ""
"In the second form, I<filelist> is a list of space-separated pathname pairs, "
"and the effect is as if B<sln> was executed once for each line of the file, "
"with the two pathnames as the arguments."
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:60
msgid "The B<sln> program supports no command-line options."
msgstr ""

#. type: Plain text
#: build/C/man8/sln.8:64
msgid "B<ln>(1), B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man1/sprof.1:25
#, no-wrap
msgid "SPROF"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:28
msgid "sprof - read and display shared object profiling data"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:32
#, no-wrap
msgid "B<sprof> [I<option>]... I<shared-object-path> [I<profile-data-path>]\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:46
msgid ""
"The B<sprof> command displays a profiling summary for the shared object "
"(shared library) specified as its first command-line argument.  The "
"profiling summary is created using previously generated profiling data in "
"the (optional) second command-line argument.  If the profiling data pathname "
"is omitted, then B<sprof> will attempt to deduce it using the soname of the "
"shared object, looking for a file with the name I<E<lt>sonameE<gt>.profile> "
"in the current directory."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:49
msgid ""
"The following command-line options specify the profile output to be "
"produced:"
msgstr ""

#. type: TP
#: build/C/man1/sprof.1:49
#, no-wrap
msgid "B<-c>, B<--call-pairs>"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:54
msgid ""
"Print a list of pairs of call paths for the interfaces exported by the "
"shared object, along with the number of times each path is used."
msgstr ""

#. type: TP
#: build/C/man1/sprof.1:54
#, no-wrap
msgid "B<-p>, B<--flat-profile>"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:58
msgid ""
"Generate a flat profile of all of the functions in the monitored object, "
"with counts and ticks."
msgstr ""

#. type: TP
#: build/C/man1/sprof.1:58
#, no-wrap
msgid "B<-q>, B<--graph>"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:61
msgid "Generate a call graph."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:64
msgid ""
"If none of the above options is specified, then the default behavior is to "
"display a flat profile and a call graph."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:66
msgid "The following additional command-line options are available:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:69
msgid "Display a summary of command-line options and arguments and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:75
msgid "Display the program version and exit."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:79
msgid "The B<sprof> command is a GNU extension, not present in POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:85
msgid ""
"The following example demonstrates the use of B<sprof>.  The example "
"consists of a main program that calls two functions in a shared object.  "
"First, the code of the main program:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:90
#, no-wrap
msgid ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:93
#, no-wrap
msgid ""
"void x1(void);\n"
"void x2(void);\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:101
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:110
msgid ""
"The functions I<x1>()  and I<x2>()  are defined in the following source file "
"that is used to construct the shared object:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:115
#, no-wrap
msgid ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:122
#, no-wrap
msgid ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:128
#, no-wrap
msgid ""
"void\n"
"x1(void) {\n"
"    for (int j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:135
#, no-wrap
msgid ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:142
#, no-wrap
msgid ""
"void\n"
"x2(void)\n"
"{\n"
"    for (int j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:149
msgid ""
"Now we construct the shared object with the real name I<libdemo.so.1.0.1>, "
"and the soname I<libdemo.so.1>:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:154
#, no-wrap
msgid ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:159
msgid ""
"Then we construct symbolic links for the library soname and the library "
"linker name:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:164
#, no-wrap
msgid ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:169
msgid ""
"Next, we compile the main program, linking it against the shared object, and "
"then list the dynamic dependencies of the program:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:178
#, no-wrap
msgid ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:185
msgid ""
"In order to get profiling information for the shared object, we define the "
"environment variable B<LD_PROFILE> with the soname of the library:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:189
#, no-wrap
msgid "$ B<export LD_PROFILE=libdemo.so.1>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:196
msgid ""
"We then define the environment variable B<LD_PROFILE_OUTPUT> with the "
"pathname of the directory where profile output should be written, and create "
"that directory if it does not exist already:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:201
#, no-wrap
msgid ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:209
msgid ""
"B<LD_PROFILE> causes profiling output to be I<appended> to the output file "
"if it already exists, so we ensure that there is no preexisting profiling "
"data:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:213
#, no-wrap
msgid "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:219
msgid ""
"We then run the program to produce the profiling output, which is written to "
"a file in the directory specified in B<LD_PROFILE_OUTPUT>:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:225
#, no-wrap
msgid ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:231
msgid ""
"We then use the B<sprof -p> option to generate a flat profile with counts "
"and ticks:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:236
#, no-wrap
msgid ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Flat profile:\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:244
#, no-wrap
msgid ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:250
msgid "The B<sprof -q> option generates a call graph:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:254
#, no-wrap
msgid "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:256
#, no-wrap
msgid "index % time    self  children    called     name\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:271
#, no-wrap
msgid ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:277
msgid ""
"Above and below, the \"E<lt>UNKNOWNE<gt>\" strings represent identifiers "
"that are outside of the profiled object (in this example, these are "
"instances of I<main()>)."
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:281
msgid ""
"The B<sprof -c> option generates a list of call pairs and the number of "
"their occurrences:"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:289
#, no-wrap
msgid ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"
msgstr ""

#. type: Plain text
#: build/C/man1/sprof.1:295
msgid "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"
msgstr ""
