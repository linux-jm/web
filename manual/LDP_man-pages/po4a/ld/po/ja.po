# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:25+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25
#, no-wrap
msgid "DL_ITERATE_PHDR"
msgstr "DL_ITERATE_PHDR"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dlinfo.3:25
#: build/C/man3/dlopen.3:35 build/C/man1/memusage.1:24 build/C/man1/pldd.1:25
#: build/C/man7/rtld-audit.7:28 build/C/man1/sprof.1:25
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/end.3:26
#: build/C/man8/ld.so.8:7 build/C/man8/ldconfig.8:22 build/C/man1/memusage.1:24
#: build/C/man1/memusagestat.1:23 build/C/man1/mtrace.1:23
#: build/C/man1/pldd.1:25 build/C/man8/sln.8:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dladdr.3:26
#: build/C/man3/dlerror.3:25 build/C/man3/dlinfo.3:25 build/C/man3/dlopen.3:35
#: build/C/man3/dlsym.3:25 build/C/man5/elf.5:35 build/C/man3/end.3:26
#: build/C/man8/ld.so.8:7 build/C/man8/ldconfig.8:22 build/C/man1/ldd.1:14
#: build/C/man7/rtld-audit.7:28 build/C/man8/sln.8:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:26 build/C/man3/dladdr.3:27
#: build/C/man3/dlerror.3:26 build/C/man3/dlinfo.3:26 build/C/man3/dlopen.3:36
#: build/C/man3/dlsym.3:26 build/C/man5/elf.5:36 build/C/man3/end.3:27
#: build/C/man8/ld.so.8:8 build/C/man8/ldconfig.8:23 build/C/man1/ldd.1:15
#: build/C/man1/memusage.1:25 build/C/man1/memusagestat.1:24
#: build/C/man1/mtrace.1:24 build/C/man1/pldd.1:26 build/C/man7/rtld-audit.7:29
#: build/C/man8/sln.8:26 build/C/man1/sprof.1:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:28
msgid "dl_iterate_phdr - walk through list of shared objects"
msgstr "dl_iterate_phdr - 共有オブジェクトのリストを辿る"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:28 build/C/man3/dladdr.3:29
#: build/C/man3/dlerror.3:28 build/C/man3/dlinfo.3:28 build/C/man3/dlopen.3:39
#: build/C/man3/dlsym.3:28 build/C/man5/elf.5:38 build/C/man3/end.3:29
#: build/C/man8/ld.so.8:10 build/C/man8/ldconfig.8:25 build/C/man1/ldd.1:17
#: build/C/man1/memusage.1:27 build/C/man1/memusagestat.1:26
#: build/C/man1/mtrace.1:26 build/C/man1/pldd.1:28 build/C/man7/rtld-audit.7:31
#: build/C/man8/sln.8:28 build/C/man1/sprof.1:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>link.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:37
#, no-wrap
msgid ""
"B<int dl_iterate_phdr(>\n"
"B<          int (*>I<callback>B<) (struct dl_phdr_info *>I<info>B<,>\n"
"B<                           size_t >I<size>B<, void *>I<data>B<),>\n"
"B<          void *>I<data>B<);>\n"
msgstr ""
"B<int dl_iterate_phdr(>\n"
"B<          int (*>I<callback>B<) (struct dl_phdr_info *>I<info>B<,>\n"
"B<                           size_t >I<size>B<, void *>I<data>B<),>\n"
"B<          void *>I<data>B<);>\n"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:38 build/C/man3/dladdr.3:41
#: build/C/man3/dlerror.3:34 build/C/man3/dlinfo.3:38 build/C/man3/dlopen.3:53
#: build/C/man3/dlsym.3:40 build/C/man5/elf.5:43 build/C/man3/end.3:35
#: build/C/man8/ld.so.8:21 build/C/man8/ldconfig.8:40 build/C/man1/ldd.1:19
#: build/C/man1/memusage.1:29 build/C/man1/memusagestat.1:28
#: build/C/man1/mtrace.1:28 build/C/man1/pldd.1:33 build/C/man7/rtld-audit.7:36
#: build/C/man8/sln.8:32 build/C/man1/sprof.1:33
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:44
msgid ""
"The B<dl_iterate_phdr>()  function allows an application to inquire at run "
"time to find out which shared objects it has loaded, and the order in which "
"they were loaded."
msgstr "B<dl_iterate_phdr>() 関数を使うと、アプリケーションは実行時に どの共有オブジェクトをロードしたかと、それらがロードされた順番を問い合わせることができる。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:54
msgid ""
"The B<dl_iterate_phdr>()  function walks through the list of an "
"application's shared objects and calls the function I<callback> once for "
"each object, until either all shared objects have been processed or "
"I<callback> returns a nonzero value."
msgstr ""
"B<dl_iterate_phdr>()  関数はアプリケーションの共有オブジェクトのリストを辿"
"り、 各オブジェクトに対して関数 I<callback> を 1 回ずつ呼び出す。 これは全て"
"の共有オブジェクトが処理されるか、 I<callback> が 0 以外の値を返すまで行われ"
"る。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:71
msgid ""
"Each call to I<callback> receives three arguments: I<info>, which is a "
"pointer to a structure containing information about the shared object; "
"I<size>, which is the size of the structure pointed to by I<info>; and "
"I<data>, which is a copy of whatever value was passed by the calling program "
"as the second argument (also named I<data>)  in the call to "
"B<dl_iterate_phdr>()."
msgstr ""
"各々の I<callback> 呼び出しは 3 つの引数を受け取る: I<info> は共有オブジェ"
"クトの情報を保持する構造体へのポインターである。 I<size> は I<info> で指され"
"る構造体のサイズである。 I<data> は呼び出し元プログラムから "
"B<dl_iterate_phdr>()  の呼び出しの (同じく I<data> という名前の) 第 2 引数"
"として渡される値のコピーである。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:75
msgid "The I<info> argument is a structure of the following type:"
msgstr "I<info> 引数は、以下のような型の構造体である。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:86
#, no-wrap
msgid ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* Base address of object */\n"
"    const char       *dlpi_name;  /* (Null-terminated) name of\n"
"                                     object */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* Pointer to array of\n"
"                                     ELF program headers\n"
"                                     for this object */\n"
"    ElfW(Half)        dlpi_phnum; /* # of items in I<dlpi_phdr> */\n"
msgstr ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* オブジェクトのベースアドレス */\n"
"    const char       *dlpi_name;  /* (ヌル文字で終端された)\n"
"                                     オブジェクト名 */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* このオブジェクトの\n"
"                                     ELF プログラムヘッダーの\n"
"                                     配列へのポインター */\n"
"    ElfW(Half)        dlpi_phnum; /* I<dlpi_phdr> のアイテム数 */\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:91
#, no-wrap
msgid ""
"    /* The following fields were added in glibc 2.4, after the first\n"
"       version of this structure was available.  Check the I<size>\n"
"       argument passed to the dl_iterate_phdr callback to determine\n"
"       whether or not each later member is available.  */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:107
#, no-wrap
msgid ""
"    unsigned long long dlpi_adds;\n"
"                    /* Incremented when a new object may\n"
"                       have been added */\n"
"    unsigned long long dlpi_subs;\n"
"                    /* Incremented when an object may\n"
"                       have been removed */\n"
"    size_t dlpi_tls_modid;\n"
"                    /* If there is a PT_TLS segment, its module\n"
"                       ID as used in TLS relocations, else zero */\n"
"    void  *dlpi_tls_data;\n"
"                    /* The address of the calling thread\\(aqs instance\n"
"                       of this module\\(aqs PT_TLS segment, if it has\n"
"                       one and it has been allocated in the calling\n"
"                       thread, otherwise a null pointer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:121
msgid ""
"(The I<ElfW>()  macro definition turns its argument into the name of an ELF "
"data type suitable for the hardware architecture.  For example, on a 32-bit "
"platform, I<ElfW(Addr)> yields the data type name I<Elf32_Addr>.  Further "
"information on these types can be found in the I<E<lt>elf.hE<gt>> and "
"I<E<lt>link.hE<gt>> header files.)"
msgstr "(I<ElfW>()  マクロ定義は引数をハードウェアアーキテクチャーに適した ELF データ型の名前に変換する。 たとえば、32 ビットプラットフォームでは I<ElfW(Addr)> はデータ型名 I<Elf32_Addr> を生成する。 これらの型についての更に詳細な情報は、ヘッダーファイル I<E<lt>elf.hE<gt>> と I<E<lt>link.hE<gt>> にある。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:132
msgid ""
"The I<dlpi_addr> field indicates the base address of the shared object (i."
"e., the difference between the virtual memory address of the shared object "
"and the offset of that object in the file from which it was loaded).  The "
"I<dlpi_name> field is a null-terminated string giving the pathname from "
"which the shared object was loaded."
msgstr ""
"I<dlpi_addr> フィールドは共有オブジェクトのベースアドレス (つまり、共有オブ"
"ジェクトの仮想メモリーアドレスと、 ファイル (このファイルから共有オブジェクト"
"がロードされる) における 共有オブジェクトのオフセットとの差分) を表す。 "
"I<dlpi_name> はヌル文字で終端された文字列であり、 このパス名のファイルから共"
"有オブジェクトがロードされる。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:147
msgid ""
"To understand the meaning of the I<dlpi_phdr> and I<dlpi_phnum> fields, we "
"need to be aware that an ELF shared object consists of a number of segments, "
"each of which has a corresponding program header describing the segment.  "
"The I<dlpi_phdr> field is a pointer to an array of the program headers for "
"this shared object.  The I<dlpi_phnum> field indicates the size of this "
"array."
msgstr ""
"I<dlpi_phdr> と I<dlpi_phnum> フィールドの意味を理解するには、 ELF 共有オブ"
"ジェクトが幾つかのセグメントから構成されていることと、 各セグメントがそれに対"
"応するプログラムヘッダー (そのセグメントを説明する) を持っていることを知って"
"いる必要がある。 I<dlpi_phdr> フィールドは、この共有オブジェクトのプログラム"
"ヘッダーの配列へのポインターである。 I<dlpi_phnum> は、この配列のサイズを表"
"す。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:149
msgid "These program headers are structures of the following form:"
msgstr "これらのプログラムヘッダーは以下のような形式の構造体である:"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* Segment type */\n"
"    Elf32_Off   p_offset;  /* Segment file offset */\n"
"    Elf32_Addr  p_vaddr;   /* Segment virtual address */\n"
"    Elf32_Addr  p_paddr;   /* Segment physical address */\n"
"    Elf32_Word  p_filesz;  /* Segment size in file */\n"
"    Elf32_Word  p_memsz;   /* Segment size in memory */\n"
"    Elf32_Word  p_flags;   /* Segment flags */\n"
"    Elf32_Word  p_align;   /* Segment alignment */\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct\n"
"{\n"
"    Elf32_Word  p_type;    /* セグメントの型 */\n"
"    Elf32_Off   p_offset;  /* セグメントのファイルオフセット */\n"
"    Elf32_Addr  p_vaddr;   /* セグメントの仮想アドレス */\n"
"    Elf32_Addr  p_paddr;   /* セグメントの物理アドレス */\n"
"    Elf32_Word  p_filesz;  /* ファイルにおけるセグメントサイズ */\n"
"    Elf32_Word  p_memsz;   /* メモリーにおけるセグメントサイズ */\n"
"    Elf32_Word  p_flags;   /* セグメントフラグ */\n"
"    Elf32_Word  p_align;   /* セグメントの配置 (alignment) */\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:168
msgid ""
"Note that we can calculate the location of a particular program header, "
"I<x>, in virtual memory using the formula:"
msgstr ""
"特定のプログラムヘッダー I<x> の仮想メモリーにおける位置は、以下の式で計算で"
"きる点に注意すること:"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:172
#, no-wrap
msgid "addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"
msgstr "addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:180
msgid ""
"Possible values for I<p_type> include the following (see I<E<lt>elf.hE<gt>> "
"for further details):"
msgstr ""

#.  For PT_GNU_STACK, see http://www.airs.com/blog/archives/518
#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:194
#, no-wrap
msgid ""
"#define PT_LOAD         1    /* Loadable program segment */\n"
"#define PT_DYNAMIC      2    /* Dynamic linking information */\n"
"#define PT_INTERP       3    /* Program interpreter */\n"
"#define PT_NOTE         4    /* Auxiliary information */\n"
"#define PT_SHLIB        5    /* Reserved */\n"
"#define PT_PHDR         6    /* Entry for header table itself */\n"
"#define PT_TLS          7    /* Thread-local storage segment */\n"
"#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr segment */\n"
"#define PT_GNU_STACK  0x6474e551 /* Indicates stack executability */\n"
"#define PT_GNU_RELRO  0x6474e552 /* Read-only after relocation */\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:196 build/C/man3/dladdr.3:215
#: build/C/man3/dlinfo.3:214 build/C/man3/dlopen.3:348 build/C/man3/dlsym.3:113
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:201
msgid ""
"The B<dl_iterate_phdr>()  function returns whatever value was returned by "
"the last call to I<callback>."
msgstr ""
"B<dl_iterate_phdr>()  関数は最後の I<callback> の呼び出しで返された値を返す。"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:201 build/C/man3/dladdr.3:235
#: build/C/man3/dlerror.3:49 build/C/man3/dlinfo.3:220
#: build/C/man3/dlopen.3:365 build/C/man3/dlsym.3:120 build/C/man1/pldd.1:61
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:204
msgid "B<dl_iterate_phdr>()  has been supported in glibc since version 2.2.4."
msgstr ""
"B<dl_iterate_phdr>()  は glibc のバージョン 2.2.4 以降でサポートされている。"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:204 build/C/man3/dladdr.3:240
#: build/C/man3/dlerror.3:52 build/C/man3/dlinfo.3:223
#: build/C/man3/dlopen.3:372 build/C/man3/dlsym.3:125
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:207 build/C/man3/dladdr.3:243
#: build/C/man3/dlerror.3:55 build/C/man3/dlinfo.3:226
#: build/C/man3/dlopen.3:375 build/C/man3/dlsym.3:128
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:247
#: build/C/man3/dlerror.3:59 build/C/man3/dlinfo.3:230
#: build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:247
#: build/C/man3/dlerror.3:59 build/C/man3/dlinfo.3:230
#: build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:211 build/C/man3/dladdr.3:166
#: build/C/man3/dladdr.3:189 build/C/man3/dladdr.3:208
#: build/C/man3/dladdr.3:247 build/C/man3/dlerror.3:59
#: build/C/man3/dlinfo.3:230 build/C/man3/dlopen.3:379 build/C/man3/dlsym.3:132
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214
#, no-wrap
msgid "B<dl_iterate_phdr>()"
msgstr "B<dl_iterate_phdr>()"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214 build/C/man3/dladdr.3:251
#: build/C/man3/dlerror.3:62 build/C/man3/dlinfo.3:233
#: build/C/man3/dlopen.3:384 build/C/man3/dlsym.3:136
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/dl_iterate_phdr.3:214 build/C/man3/dladdr.3:251
#: build/C/man3/dlerror.3:62 build/C/man3/dlinfo.3:233
#: build/C/man3/dlopen.3:384 build/C/man3/dlsym.3:136
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:217 build/C/man3/dladdr.3:253
#: build/C/man3/dlerror.3:64 build/C/man3/dlinfo.3:235
#: build/C/man3/dlopen.3:386 build/C/man3/dlsym.3:138 build/C/man3/end.3:50
#: build/C/man1/pldd.1:64 build/C/man7/rtld-audit.7:478 build/C/man1/sprof.1:75
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:232
msgid ""
"The B<dl_iterate_phdr>()  function is not specified in any standard.  "
"Various other systems provide a version of this function, although details "
"of the returned I<dl_phdr_info> structure differ.  On the BSDs and Solaris, "
"the structure includes the fields I<dlpi_addr>, I<dlpi_name>, I<dlpi_phdr>, "
"and I<dlpi_phnum> in addition to other implementation-specific fields."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:232 build/C/man3/dlerror.3:66
#: build/C/man3/dlinfo.3:237 build/C/man3/dlopen.3:402 build/C/man3/dlsym.3:144
#: build/C/man5/elf.5:2132 build/C/man3/end.3:53 build/C/man8/ld.so.8:779
#: build/C/man1/pldd.1:71 build/C/man7/rtld-audit.7:484
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:239
msgid ""
"Future versions of the C library may add further fields to the "
"I<dl_phdr_info> structure; in that event, the I<size> argument provides a "
"mechanism for the callback function to discover whether it is running on a "
"system with added fields."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:246
msgid ""
"The first object visited by I<callback> is the main program.  For the main "
"program, the I<dlpi_name> field will be an empty string."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:246 build/C/man3/dlerror.3:84
#: build/C/man3/dlinfo.3:242 build/C/man3/dlopen.3:550 build/C/man3/dlsym.3:168
#: build/C/man3/end.3:76 build/C/man1/memusage.1:204
#: build/C/man1/memusagestat.1:85 build/C/man1/pldd.1:106
#: build/C/man7/rtld-audit.7:519 build/C/man1/sprof.1:79
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:252
#, fuzzy
#| msgid ""
#| "The following program displays a list of pathnames of the shared objects "
#| "it has loaded.  For each shared object, the program lists the virtual "
#| "addresses at which the object's ELF segments are loaded."
msgid ""
"The following program displays a list of pathnames of the shared objects it "
"has loaded.  For each shared object, the program lists some information "
"(virtual address, size, flags, and type)  for each of the objects ELF "
"segments."
msgstr ""
"以下のプログラムは、共有オブジェクトがロードされた パス名の一覧を表示する。 "
"各共有オブジェクトについて、このプログラムは オブジェクトの ELF セグメントが"
"ロードされた 仮想アドレスの一覧を表示する。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:258
msgid ""
"The following shell session demonstrates the output produced by the program "
"on an x86-64 system.  The first shared object for which output is displayed "
"(where the name is an empty string)  is the main program."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:296
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Name: \"\" (9 segments)\n"
"     0: [      0x400040; memsz:    1f8] flags: 0x5; PT_PHDR\n"
"     1: [      0x400238; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [      0x400000; memsz:    ac4] flags: 0x5; PT_LOAD\n"
"     3: [      0x600e10; memsz:    240] flags: 0x6; PT_LOAD\n"
"     4: [      0x600e28; memsz:    1d0] flags: 0x6; PT_DYNAMIC\n"
"     5: [      0x400254; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [      0x400970; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     7: [         (nil); memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     8: [      0x600e10; memsz:    1f0] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"linux-vdso.so.1\" (4 segments)\n"
"     0: [0x7ffc6edd1000; memsz:    e89] flags: 0x5; PT_LOAD\n"
"     1: [0x7ffc6edd1360; memsz:    110] flags: 0x4; PT_DYNAMIC\n"
"     2: [0x7ffc6edd17b0; memsz:     3c] flags: 0x4; PT_NOTE\n"
"     3: [0x7ffc6edd17ec; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"Name: \"/lib64/libc.so.6\" (10 segments)\n"
"     0: [0x7f55712ce040; memsz:    230] flags: 0x5; PT_PHDR\n"
"     1: [0x7f557145b980; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [0x7f55712ce000; memsz: 1b6a5c] flags: 0x5; PT_LOAD\n"
"     3: [0x7f55716857a0; memsz:   9240] flags: 0x6; PT_LOAD\n"
"     4: [0x7f5571688b80; memsz:    1f0] flags: 0x6; PT_DYNAMIC\n"
"     5: [0x7f55712ce270; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [0x7f55716857a0; memsz:     78] flags: 0x4; PT_TLS\n"
"     7: [0x7f557145b99c; memsz:   544c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     8: [0x7f55712ce000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     9: [0x7f55716857a0; memsz:   3860] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"/lib64/ld-linux-x86-64.so.2\" (7 segments)\n"
"     0: [0x7f557168f000; memsz:  20828] flags: 0x5; PT_LOAD\n"
"     1: [0x7f55718afba0; memsz:   15a8] flags: 0x6; PT_LOAD\n"
"     2: [0x7f55718afe10; memsz:    190] flags: 0x6; PT_DYNAMIC\n"
"     3: [0x7f557168f1c8; memsz:     24] flags: 0x4; PT_NOTE\n"
"     4: [0x7f55716acec4; memsz:    604] flags: 0x4; PT_GNU_EH_FRAME\n"
"     5: [0x7f557168f000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     6: [0x7f55718afba0; memsz:    460] flags: 0x4; PT_GNU_RELRO\n"
msgstr ""

#. type: SS
#: build/C/man3/dl_iterate_phdr.3:298 build/C/man3/dlinfo.3:259
#: build/C/man3/dlopen.3:564 build/C/man3/end.3:88 build/C/man1/memusage.1:237
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:306
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:312
#, no-wrap
msgid ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    char *type;\n"
"    int p_type;\n"
msgstr ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    char *type;\n"
"    int p_type;\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:315
#, no-wrap
msgid ""
"    printf(\"Name: \\e\"%s\\e\" (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"               info-E<gt>dlpi_phnum);\n"
msgstr ""
"    printf(\"Name: \\e\"%s\\e\" (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"               info-E<gt>dlpi_phnum);\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:328
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> info-E<gt>dlpi_phnum; j++) {\n"
"        p_type = info-E<gt>dlpi_phdr[j].p_type;\n"
"        type =  (p_type == PT_LOAD) ? \"PT_LOAD\" :\n"
"                (p_type == PT_DYNAMIC) ? \"PT_DYNAMIC\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_NOTE) ? \"PT_NOTE\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_PHDR) ? \"PT_PHDR\" :\n"
"                (p_type == PT_TLS) ? \"PT_TLS\" :\n"
"                (p_type == PT_GNU_EH_FRAME) ? \"PT_GNU_EH_FRAME\" :\n"
"                (p_type == PT_GNU_STACK) ? \"PT_GNU_STACK\" :\n"
"                (p_type == PT_GNU_RELRO) ? \"PT_GNU_RELRO\" : NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:338
#, no-wrap
msgid ""
"        printf(\"    %2d: [%14p; memsz:%7jx] flags: %#jx; \", j,\n"
"                (void *) (info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[j].p_vaddr),\n"
"                (uintmax_t) info-E<gt>dlpi_phdr[j].p_memsz,\n"
"                (uintmax_t) info-E<gt>dlpi_phdr[j].p_flags);\n"
"        if (type != NULL)\n"
"            printf(\"%s\\en\", type);\n"
"        else\n"
"            printf(\"[other (%#x)]\\en\", p_type);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:341 build/C/man7/rtld-audit.7:579
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:346
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:349 build/C/man3/dlinfo.3:325
#: build/C/man3/end.3:107
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:350 build/C/man3/dladdr.3:284
#: build/C/man3/dlerror.3:87 build/C/man3/dlinfo.3:326
#: build/C/man3/dlopen.3:619 build/C/man3/dlsym.3:171 build/C/man5/elf.5:2159
#: build/C/man3/end.3:108 build/C/man8/ld.so.8:815 build/C/man8/ldconfig.8:215
#: build/C/man1/ldd.1:172 build/C/man1/memusage.1:274
#: build/C/man1/memusagestat.1:88 build/C/man1/mtrace.1:62
#: build/C/man1/pldd.1:119 build/C/man7/rtld-audit.7:620 build/C/man8/sln.8:60
#: build/C/man1/sprof.1:291
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:358
msgid ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dladdr>(3), B<dlopen>(3), "
"B<elf>(5), B<ld.so>(8)"
msgstr "B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dladdr>(3), B<dlopen>(3), B<elf>(5), B<ld.so>(8)"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:361
msgid ""
"I<Executable and Linking Format Specification>, available at various "
"locations online."
msgstr ""
"オンラインのいろいろな場所で入手できる I<Executable and Linking Format "
"Specification>"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:361 build/C/man3/dladdr.3:290
#: build/C/man3/dlerror.3:92 build/C/man3/dlinfo.3:333
#: build/C/man3/dlopen.3:633 build/C/man3/dlsym.3:178 build/C/man5/elf.5:2192
#: build/C/man3/end.3:113 build/C/man8/ld.so.8:833 build/C/man8/ldconfig.8:218
#: build/C/man1/ldd.1:177 build/C/man1/memusage.1:278
#: build/C/man1/memusagestat.1:91 build/C/man1/mtrace.1:65
#: build/C/man1/pldd.1:124 build/C/man7/rtld-audit.7:625 build/C/man8/sln.8:64
#: build/C/man1/sprof.1:295
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:369 build/C/man3/dladdr.3:298
#: build/C/man3/dlerror.3:100 build/C/man3/dlinfo.3:341
#: build/C/man3/dlopen.3:641 build/C/man3/dlsym.3:186 build/C/man5/elf.5:2200
#: build/C/man3/end.3:121 build/C/man8/ld.so.8:841 build/C/man8/ldconfig.8:226
#: build/C/man1/ldd.1:185 build/C/man1/memusage.1:286
#: build/C/man1/memusagestat.1:99 build/C/man1/mtrace.1:73
#: build/C/man1/pldd.1:132 build/C/man7/rtld-audit.7:633 build/C/man8/sln.8:72
#: build/C/man1/sprof.1:303
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/dladdr.3:26
#, no-wrap
msgid "DLADDR"
msgstr ""

#. type: TH
#: build/C/man3/dladdr.3:26 build/C/man8/ld.so.8:7
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man3/dladdr.3:26 build/C/man3/dlerror.3:25 build/C/man3/dlinfo.3:25
#: build/C/man3/dlopen.3:35 build/C/man3/dlsym.3:25 build/C/man5/elf.5:35
#: build/C/man7/rtld-audit.7:28 build/C/man1/sprof.1:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/dladdr.3:29
msgid "dladdr, dladdr1 - translate address to symbolic information"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dladdr.3:35
#, no-wrap
msgid "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"
msgstr "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man3/dladdr.3:38
#, no-wrap
msgid "B<int dladdr1(void *>I<addr>B<, Dl_info *>I<info>B<, void **>I<extra_info>B<, int >I<flags>B<);>\n"
msgstr "B<int dladdr1(void *>I<addr>B<, Dl_info *>I<info>B<, void **>I<extra_info>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/dladdr.3:40 build/C/man3/dlinfo.3:37
#, no-wrap
msgid "Link with I<-ldl>.\n"
msgstr "I<-ldl> でリンクする。\n"

#. type: Plain text
#: build/C/man3/dladdr.3:54
msgid ""
"The function B<dladdr>()  determines whether the address specified in "
"I<addr> is located in one of the shared objects loaded by the calling "
"application.  If it is, then B<dladdr>()  returns information about the "
"shared object and symbol that overlaps I<addr>.  This information is "
"returned in a I<Dl_info> structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:67
#, no-wrap
msgid ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Base address at which shared\n"
"                               object is loaded */\n"
"    const char *dli_sname;  /* Name of symbol whose definition\n"
"                               overlaps I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"
msgstr ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Base address at which shared\n"
"                               object is loaded */\n"
"    const char *dli_sname;  /* Name of symbol whose definition\n"
"                               overlaps I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"

#. type: Plain text
#: build/C/man3/dladdr.3:77
msgid ""
"If no symbol matching I<addr> could be found, then I<dli_sname> and "
"I<dli_saddr> are set to NULL."
msgstr ""
"I<addr> にマッチするシンボルが見つからなかった場合、 I<dli_sname> と "
"I<dli_saddr> は NULL にセットされる。"

#. type: Plain text
#: build/C/man3/dladdr.3:87
msgid ""
"The function B<dladdr1>()  is like B<dladdr>(), but returns additional "
"information via the argument I<extra_info>.  The information returned "
"depends on the value specified in I<flags>, which can have one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man3/dladdr.3:87
#, no-wrap
msgid "B<RTLD_DL_LINKMAP>"
msgstr "B<RTLD_DL_LINKMAP>"

#. type: Plain text
#: build/C/man3/dladdr.3:99
msgid ""
"Obtain a pointer to the link map for the matched file.  The I<extra_info> "
"argument points to a pointer to a I<link_map> structure (i.e., I<struct "
"link_map\\ **>), defined in I<E<lt>link.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:112 build/C/man3/dlinfo.3:93
#, no-wrap
msgid ""
"struct link_map {\n"
"    ElfW(Addr) l_addr;  /* Difference between the\n"
"                           address in the ELF file and\n"
"                           the address in memory */\n"
"    char      *l_name;  /* Absolute pathname where\n"
"                           object was found */\n"
"    ElfW(Dyn) *l_ld;    /* Dynamic section of the\n"
"                           shared object */\n"
"    struct link_map *l_next, *l_prev;\n"
"                        /* Chain of loaded objects */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:116 build/C/man3/dlinfo.3:97
#, no-wrap
msgid ""
"    /* Plus additional fields private to the\n"
"       implementation */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man3/dladdr.3:118
#, no-wrap
msgid "B<RTLD_DL_SYMENT>"
msgstr "B<RTLD_DL_SYMENT>"

#. type: Plain text
#: build/C/man3/dladdr.3:136
#, fuzzy
#| msgid ""
#| "(The I<ElfW>()  macro definition turns its argument into the name of an "
#| "ELF data type suitable for the hardware architecture.  For example, on a "
#| "32-bit platform, ElfW(Addr) yields the data type name Elf32_Addr.  "
#| "Further information on these types can be found in the I<E<lt>elf.hE<gt>> "
#| "and I<E<lt>link.hE<gt>> header files.)"
msgid ""
"Obtain a pointer to the ELF symbol table entry of the matching symbol.  The "
"I<extra_info> argument is a pointer to a symbol pointer: I<const ElfW(Sym) "
"**>.  The I<ElfW>()  macro definition turns its argument into the name of an "
"ELF data type suitable for the hardware architecture.  For example, on a 64-"
"bit platform, I<ElfW(Sym)> yields the data type name I<Elf64_Sym>, which is "
"defined in I<E<lt>elf.hE<gt>> as:"
msgstr ""
"(I<ElfW>()  マクロ定義は引数をハードウェアアーキテクチャーに適した ELF デー"
"タ型の名前に変換する。 たとえば、32 ビットプラットフォームでは ElfW(Addr) は"
"データ型名 Elf32_Addr を生成する。 これらの型についての更に詳細な情報は、ヘッ"
"ダーファイル I<E<lt>elf.hE<gt>> と I<E<lt>link.hE<gt>> にある。"

#. type: Plain text
#: build/C/man3/dladdr.3:147
#, no-wrap
msgid ""
"typedef struct  {\n"
"    Elf64_Word    st_name;     /* Symbol name */\n"
"    unsigned char st_info;     /* Symbol type and binding */\n"
"    unsigned char st_other;    /* Symbol visibility */\n"
"    Elf64_Section st_shndx;    /* Section index */\n"
"    Elf64_Addr    st_value;    /* Symbol value */\n"
"    Elf64_Xword   st_size;     /* Symbol size */\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct  {\n"
"    Elf64_Word    st_name;     /* Symbol name */\n"
"    unsigned char st_info;     /* Symbol type and binding */\n"
"    unsigned char st_other;    /* Symbol visibility */\n"
"    Elf64_Section st_shndx;    /* Section index */\n"
"    Elf64_Addr    st_value;    /* Symbol value */\n"
"    Elf64_Xword   st_size;     /* Symbol size */\n"
"} Elf64_Sym;\n"

#. type: Plain text
#: build/C/man3/dladdr.3:153
msgid "The I<st_name> field is an index into the string table."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:162
msgid ""
"The I<st_info> field encodes the symbol's type and binding.  The type can be "
"extracted using the macro B<ELF64_ST_TYPE(st_info)> (or B<ELF32_ST_TYPE()> "
"on 32-bit platforms), which yields one of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:166 build/C/man3/dladdr.3:189
#: build/C/man3/dladdr.3:208
#, no-wrap
msgid "Description"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:167
#, no-wrap
msgid "STT_NOTYPE"
msgstr "STT_NOTYPE"

#. type: tbl table
#: build/C/man3/dladdr.3:167
#, no-wrap
msgid "Symbol type is unspecified"
msgstr "シンボル種別が指定されていない"

#. type: tbl table
#: build/C/man3/dladdr.3:168
#, no-wrap
msgid "STT_OBJECT"
msgstr "STT_OBJECT"

#. type: tbl table
#: build/C/man3/dladdr.3:168
#, no-wrap
msgid "Symbol is a data object"
msgstr "シンボルがデータオブジェクトである"

#. type: tbl table
#: build/C/man3/dladdr.3:169
#, no-wrap
msgid "STT_FUNC"
msgstr "STT_FUNC"

#. type: tbl table
#: build/C/man3/dladdr.3:169
#, no-wrap
msgid "Symbol is a code object"
msgstr "シンボルがコードオブジェクトである"

#. type: tbl table
#: build/C/man3/dladdr.3:170
#, no-wrap
msgid "STT_SECTION"
msgstr "STT_SECTION"

#. type: tbl table
#: build/C/man3/dladdr.3:170
#, no-wrap
msgid "Symbol associated with a section"
msgstr "セクションに関連付けられたシンボル"

#. type: tbl table
#: build/C/man3/dladdr.3:171
#, no-wrap
msgid "STT_FILE"
msgstr "STT_FILE"

#. type: tbl table
#: build/C/man3/dladdr.3:171
#, no-wrap
msgid "Symbol's name is filename"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:172
#, no-wrap
msgid "STT_COMMON"
msgstr "STT_COMMON"

#. type: tbl table
#: build/C/man3/dladdr.3:172
#, no-wrap
msgid "Symbol is a common data object"
msgstr "シンボルは共通データオブジェクト"

#. type: tbl table
#: build/C/man3/dladdr.3:173
#, no-wrap
msgid "STT_TLS"
msgstr "STT_TLS"

#. type: tbl table
#: build/C/man3/dladdr.3:173
#, no-wrap
msgid "Symbol is thread-local data object"
msgstr "シンボルはスレッドローカルのデータオブジェクト"

#. type: tbl table
#: build/C/man3/dladdr.3:174
#, no-wrap
msgid "STT_GNU_IFUNC"
msgstr "STT_GNU_IFUNC"

#. type: tbl table
#: build/C/man3/dladdr.3:174
#, no-wrap
msgid "Symbol is indirect code object"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:185
msgid ""
"The symbol binding can be extracted from the I<st_info> field using the "
"macro B<ELF64_ST_BIND(st_info)> (or B<ELF32_ST_BIND()> on 32-bit platforms), "
"which yields one of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:190
#, no-wrap
msgid "STB_LOCAL"
msgstr "STB_LOCAL"

#. type: tbl table
#: build/C/man3/dladdr.3:190
#, no-wrap
msgid "Local symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:191
#, no-wrap
msgid "STB_GLOBAL"
msgstr "STB_GLOBAL"

#. type: tbl table
#: build/C/man3/dladdr.3:191
#, no-wrap
msgid "Global symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:192
#, no-wrap
msgid "STB_WEAK"
msgstr "STB_WEAK"

#. type: tbl table
#: build/C/man3/dladdr.3:192
#, no-wrap
msgid "Weak symbol"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:193
#, no-wrap
msgid "STB_GNU_UNIQUE"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:193
#, no-wrap
msgid "Unique symbol"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:204
msgid ""
"The I<st_other> field contains the symbol's visibility, which can be "
"extracted using the macro B<ELF64_ST_VISIBILITY(st_info)> (or "
"B<ELF32_ST_VISIBILITY()> on 32-bit platforms), which yields one of the "
"following values:"
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:209
#, no-wrap
msgid "STV_DEFAULT"
msgstr "STV_DEFAULT"

#. type: tbl table
#: build/C/man3/dladdr.3:209
#, no-wrap
msgid "Default symbol visibility rules"
msgstr "デフォルトのシンボル visibility ルール"

#. type: tbl table
#: build/C/man3/dladdr.3:210
#, no-wrap
msgid "STV_INTERNAL"
msgstr "STV_INTERNAL"

#. type: tbl table
#: build/C/man3/dladdr.3:210
#, no-wrap
msgid "Processor-specific hidden class"
msgstr "プロセッサ固有の隠しクラス"

#. type: tbl table
#: build/C/man3/dladdr.3:211
#, no-wrap
msgid "STV_HIDDEN"
msgstr "STV_HIDDEN"

#. type: tbl table
#: build/C/man3/dladdr.3:211
#, no-wrap
msgid "Symbol unavailable in other modules"
msgstr "シンボルは他のモジュールからは利用できない"

#. type: tbl table
#: build/C/man3/dladdr.3:212
#, no-wrap
msgid "STV_PROTECTED"
msgstr "STV_PROTECTED"

#. type: tbl table
#: build/C/man3/dladdr.3:212
#, no-wrap
msgid "Not preemptible, not exported"
msgstr "横取りできず (not preemptible)、公開されれいない"

#. type: Plain text
#: build/C/man3/dladdr.3:225
msgid ""
"On success, these functions return a nonzero value.  If the address "
"specified in I<addr> could be matched to a shared object, but not to a "
"symbol in the shared object, then the I<info-E<gt>dli_sname> and I<info-"
"E<gt>dli_saddr> fields are set to NULL."
msgstr ""

#.  According to the FreeBSD man page, dladdr1() does signal an
#.  error via dlerror() for this case.
#. type: Plain text
#: build/C/man3/dladdr.3:235
msgid ""
"If the address specified in I<addr> could not be matched to a shared object, "
"then these functions return 0.  In this case, an error message is I<not> "
"available via B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:240
msgid ""
"B<dladdr>()  is present in glibc 2.0 and later.  B<dladdr1>()  first "
"appeared in glibc 2.3.3."
msgstr ""

#. type: tbl table
#: build/C/man3/dladdr.3:251
#, no-wrap
msgid ""
"B<dladdr>(),\n"
"B<dladdr1>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dladdr.3:256
msgid ""
"These functions are nonstandard GNU extensions that are also present on "
"Solaris."
msgstr ""

#. type: SH
#: build/C/man3/dladdr.3:256 build/C/man3/dlopen.3:534 build/C/man1/ldd.1:155
#: build/C/man1/memusage.1:200 build/C/man1/memusagestat.1:81
#: build/C/man1/mtrace.1:58 build/C/man1/pldd.1:99
#: build/C/man7/rtld-audit.7:509
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/dladdr.3:268
msgid ""
"Sometimes, the function pointers you pass to B<dladdr>()  may surprise you.  "
"On some architectures (notably i386 and x86-64), I<dli_fname> and "
"I<dli_fbase> may end up pointing back at the object from which you called "
"B<dladdr>(), even if the function used as an argument should come from a "
"dynamically linked library."
msgstr "時として、 B<dladdr>()  に渡した関数ポインターは驚くような値になることがある。 いくつかのアーキテクチャー (特に i386 と x86-64) では、 引数として使用した関数が動的リンクライブラリで定義されるもので あったとしても、 I<dli_fname> と I<dli_fbase> が B<dladdr>()  を呼び出したオブジェクトを参照した状態で終わっていることがある。"

#. type: Plain text
#: build/C/man3/dladdr.3:284
msgid ""
"The problem is that the function pointer will still be resolved at compile "
"time, but merely point to the I<plt> (Procedure Linkage Table)  section of "
"the original object (which dispatches the call after asking the dynamic "
"linker to resolve the symbol).  To work around this, you can try to compile "
"the code to be position-independent: then, the compiler cannot prepare the "
"pointer at compile time any more and B<gcc>(1)  will generate code that just "
"loads the final symbol address from the I<got> (Global Offset Table) at run "
"time before passing it to B<dladdr>()."
msgstr "問題は、関数ポインターの解決は今なおコンパイル時に行われるが、 そのポインターは元のオブジェクトの I<plt> (Procedure Linkage Table) セクションを指しているだけだという点にある (オブジェクト自体は、ダイナミックリンカーによってシンボルの解決が行われた後に、 関数の呼び出しを行う)。 これに対処する方法としては、 コードを position-independent でコンパイルするという方法がある。 そうすると、コンパイラはコンパイル時にポインターを用意することができず、 B<gcc>(1)  では、実行時に B<dladdr>()  に関数ポインターを渡す前に、 I<got> (Global Offset Table) から最終的なシンボルのアドレスをロードするだけの コードが生成される。"

#. type: Plain text
#: build/C/man3/dladdr.3:290
msgid ""
"B<dl_iterate_phdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"
msgstr "B<dl_iterate_phdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"

#. type: TH
#: build/C/man3/dlerror.3:25
#, no-wrap
msgid "DLERROR"
msgstr ""

#. type: TH
#: build/C/man3/dlerror.3:25 build/C/man3/dlsym.3:25 build/C/man3/end.3:26
#: build/C/man8/ldconfig.8:22 build/C/man1/memusagestat.1:23
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/dlerror.3:28
msgid "dlerror - obtain error diagnostic for functions in the dlopen API"
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:30 build/C/man3/dlopen.3:41 build/C/man3/dlopen.3:49
#: build/C/man3/dlsym.3:30 build/C/man3/dlsym.3:36
msgid "B<#include E<lt>dlfcn.hE<gt>>"
msgstr "B<#include E<lt>dlfcn.hE<gt>>"

#. type: Plain text
#: build/C/man3/dlerror.3:32
msgid "B<char *dlerror(void);>"
msgstr "B<char *dlerror(void);>"

#. type: Plain text
#: build/C/man3/dlerror.3:34 build/C/man3/dlopen.3:53 build/C/man3/dlsym.3:40
msgid "Link with I<-ldl>."
msgstr "I<-ldl> でリンクする。"

#. type: Plain text
#: build/C/man3/dlerror.3:45
#, fuzzy
#| msgid ""
#| "The function B<dlerror>()  returns a human-readable string describing the "
#| "most recent error that occurred from B<dlopen>(), B<dlsym>()  or "
#| "B<dlclose>()  since the last call to B<dlerror>().  It returns NULL if no "
#| "errors have occurred since initialization or since it was last called."
msgid ""
"The B<dlerror>()  function returns a human-readable, null-terminated string "
"describing the most recent error that occurred from a call to one of the "
"functions in the dlopen API since the last call to B<dlerror>().  The "
"returned string does I<not> include a trailing newline."
msgstr ""
"関数 B<dlerror>()  は、前回 B<dlerror>()  が呼び出された後に、 B<dlopen>(), "
"B<dlsym>(), B<dlclose>()  のいずれかで最後に発生したエラーについての説明メッ"
"セージを返す。 初期化後または前回呼び出された後で、エラーが発生していなけれ"
"ば NULL を返す。"

#. type: Plain text
#: build/C/man3/dlerror.3:49
msgid ""
"B<dlerror>()  returns NULL if no errors have occurred since initialization "
"or since it was last called."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:52
msgid "B<dlerror>()  is present in glibc 2.0 and later."
msgstr ""

#. type: tbl table
#: build/C/man3/dlerror.3:62
#, no-wrap
msgid "B<dlerror>()"
msgstr "B<dlerror>()"

#. type: Plain text
#: build/C/man3/dlerror.3:66
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#.  .LP
#.  The string returned by
#.  .BR dlerror ()
#.  should not be modified.
#.  Some systems give the prototype as
#.  .sp
#.  .in +5
#.  .B "const char *dlerror(void);"
#.  .in
#. type: Plain text
#: build/C/man3/dlerror.3:82
msgid ""
"The message returned by B<dlerror>()  may reside in a statically allocated "
"buffer that is overwritten by subsequent B<dlerror>()  calls."
msgstr ""

#. type: SS
#: build/C/man3/dlerror.3:82 build/C/man3/dlopen.3:532 build/C/man3/dlsym.3:162
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man3/dlerror.3:84
msgid "This function is part of the dlopen API, derived from SunOS."
msgstr ""

#. type: Plain text
#: build/C/man3/dlerror.3:87 build/C/man3/dlsym.3:171
msgid "See B<dlopen>(3)."
msgstr "B<dlopen>(3) 参照。"

#. type: Plain text
#: build/C/man3/dlerror.3:92
msgid "B<dladdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3)"
msgstr "B<dladdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3)"

#. type: TH
#: build/C/man3/dlinfo.3:25
#, no-wrap
msgid "DLINFO"
msgstr "DLINFO"

#. type: Plain text
#: build/C/man3/dlinfo.3:28
msgid "dlinfo - obtain information about a dynamically loaded object"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>link.hE<gt>>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>link.hE<gt>>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:35
#, no-wrap
msgid "B<int dlinfo(void *>handleB<, int >requestB<, void *>infoB<);>\n"
msgstr "B<int dlinfo(void *>handleB<, int >requestB<, void *>infoB<);>\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:56
msgid ""
"The B<dlinfo>()  function obtains information about the dynamically loaded "
"object referred to by I<handle> (typically obtained by an earlier call to "
"B<dlopen>(3)  or B<dlmopen>(3)).  The I<request> argument specifies which "
"information is to be returned.  The I<info> argument is a pointer to a "
"buffer used to store information returned by the call; the type of this "
"argument depends on I<request>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:62
msgid ""
"The following values are supported for I<request> (with the corresponding "
"type for I<info> shown in parentheses):"
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:62
#, no-wrap
msgid "B<RTLD_DI_LMID> (I<Lmid_t *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:67
msgid ""
"Obtain the ID of the link-map list (namespace) in which I<handle> is loaded."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:67
#, no-wrap
msgid "B<RTLD_DI_LINKMAP> (I<struct link_map **>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:80
msgid ""
"Obtain a pointer to the I<link_map> structure corresponding to I<handle>.  "
"The I<info> argument points to a pointer to a I<link_map> structure, defined "
"in I<E<lt>link.hE<gt>> as:"
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:99
#, no-wrap
msgid "B<RTLD_DI_ORIGIN> (I<char *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:105
msgid ""
"Copy the pathname of the origin of the shared object corresponding to "
"I<handle> to the location pointed to by I<info>."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:105
#, no-wrap
msgid "B<RTLD_DI_SERINFO> (I<Dl_serinfo *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:122
msgid ""
"Obtain the library search paths for the shared object referred to by "
"I<handle>.  The I<info> argument is a pointer to a I<Dl_serinfo> that "
"contains the search paths.  Because the number of search paths may vary, the "
"size of the structure pointed to by I<info> can vary.  The "
"B<RTLD_DI_SERINFOSIZE> request described below allows applications to size "
"the buffer suitably.  The caller must perform the following steps:"
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:123
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:133
msgid ""
"Use a B<RTLD_DI_SERINFOSIZE> request to populate a I<Dl_serinfo> structure "
"with the size (I<dls_size>)  of the structure needed for the subsequent "
"B<RTLD_DI_SERINFO> request."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:133
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:138
msgid "Allocate a I<Dl_serinfo> buffer of the correct size (I<dls_size>)."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:138
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:146
msgid ""
"Use a further B<RTLD_DI_SERINFOSIZE> request to populate the I<dls_size> and "
"I<dls_cnt> fields of the buffer allocated in the previous step."
msgstr ""

#. type: IP
#: build/C/man3/dlinfo.3:146
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:150
msgid "Use a B<RTLD_DI_SERINFO> to obtain the library search paths."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:155
msgid "The I<Dl_serinfo> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:166
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t dls_size;           /* Size in bytes of\n"
"                                  the whole buffer */\n"
"    unsigned int dls_cnt;      /* Number of elements\n"
"                                  in \\(aqdls_serpath\\(aq */\n"
"    Dl_serpath dls_serpath[1]; /* Actually longer,\n"
"                                  \\(aqdls_cnt\\(aq elements */\n"
"} Dl_serinfo;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:172
msgid ""
"Each of the I<dls_serpath> elements in the above structure is a structure of "
"the following form:"
msgstr "上記の構造体の I<dls_serpath> の各要素は、以下のような形式の構造体である。"

#. type: Plain text
#: build/C/man3/dlinfo.3:181
#, no-wrap
msgid ""
"typedef struct {\n"
"    char *dls_name;            /* Name of library search\n"
"                                  path directory */\n"
"    unsigned int dls_flags;    /* Indicates where this\n"
"                                  directory came from */\n"
"} Dl_serpath;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:187
msgid "The I<dls_flags> field is currently unused, and always contains zero."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:187
#, no-wrap
msgid "B<RTLD_DI_SERINFOSIZE> (I<Dl_serinfo *>)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:200
msgid ""
"Populate the I<dls_size> and I<dls_cnt> fields of the I<Dl_serinfo> "
"structure pointed to by I<info> with values suitable for allocating a buffer "
"for use in a subsequent B<RTLD_DI_SERINFO> request."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:200
#, no-wrap
msgid "B<RTLD_DI_TLS_MODID> (I<size_t *>, since glibc 2.4)"
msgstr "B<RTLD_DI_TLS_MODID> (I<size_t *>, glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/dlinfo.3:206
msgid ""
"Obtain the module ID of this shared object's TLS (thread-local storage)  "
"segment, as used in TLS relocations.  If this object does not define a TLS "
"segment, zero is placed in I<*info>."
msgstr ""

#. type: TP
#: build/C/man3/dlinfo.3:206
#, no-wrap
msgid "B<RTLD_DI_TLS_DATA> (I<void **>, since glibc 2.4)"
msgstr "B<RTLD_DI_TLS_DATA> (I<void **>, glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/dlinfo.3:214
msgid ""
"Obtain a pointer to the calling thread's TLS block corresponding to this "
"shared object's TLS segment.  If this object does not define a PT_TLS "
"segment, or if the calling thread has not allocated a block for it, NULL is "
"placed in I<*info>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:220
msgid ""
"On success, B<dlinfo>()  returns 0.  On failure, it returns -1; the cause of "
"the error can be diagnosed using B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:223
msgid "B<dlinfo>()  first appeared in glibc 2.3.3."
msgstr ""

#. type: tbl table
#: build/C/man3/dlinfo.3:233
#, no-wrap
msgid "B<dlinfo>()"
msgstr "B<dlinfo>()"

#. type: Plain text
#: build/C/man3/dlinfo.3:237
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:242
msgid ""
"This function derives from the Solaris function of the same name and also "
"appears on some other systems.  The sets of requests supported by the "
"various implementations overlaps only partially."
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:251
msgid ""
"The program below opens a shared objects using B<dlopen>(3)  and then uses "
"the B<RTLD_DI_SERINFOSIZE> and B<RTLD_DI_SERINFO> requests to obtain the "
"library search path list for the library.  Here is an example of what we "
"might see when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:257
#, no-wrap
msgid ""
"$ B<./a.out /lib64/libm.so.6>\n"
"dls_serpath[0].dls_name = /lib64\n"
"dls_serpath[1].dls_name = /usr/lib64\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:267
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    void *handle;\n"
"    Dl_serinfo serinfo;\n"
"    Dl_serinfo *sip;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    void *handle;\n"
"    Dl_serinfo serinfo;\n"
"    Dl_serinfo *sip;\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:279
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>libpathE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>libpathE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:281
#, no-wrap
msgid "    /* Obtain a handle for shared object specified on command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:287
#, no-wrap
msgid ""
"    handle = dlopen(argv[1], RTLD_NOW);\n"
"    if (handle == NULL) {\n"
"        fprintf(stderr, \"dlopen() failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    handle = dlopen(argv[1], RTLD_NOW);\n"
"    if (handle == NULL) {\n"
"        fprintf(stderr, \"dlopen() failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:290
#, no-wrap
msgid ""
"    /* Discover the size of the buffer that we must pass to\n"
"       RTLD_DI_SERINFO */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:295
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:297
#, no-wrap
msgid "    /* Allocate the buffer for use with RTLD_DI_SERINFO */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:303
#, no-wrap
msgid ""
"    sip = malloc(serinfo.dls_size);\n"
"    if (sip == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sip = malloc(serinfo.dls_size);\n"
"    if (sip == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:306
#, no-wrap
msgid ""
"    /* Initialize the \\(aqdls_size\\(aq and \\(aqdls_cnt\\(aq fields in the newly\n"
"       allocated buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:311
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:313
#, no-wrap
msgid "    /* Fetch and print library search list */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlinfo.3:318
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFO failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFO failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:322
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> serinfo.dls_cnt; j++)\n"
"        printf(\"dls_serpath[%d].dls_name = %s\\en\",\n"
"                j, sip-E<gt>dls_serpath[j].dls_name);\n"
msgstr ""
"    for (int j = 0; j E<lt> serinfo.dls_cnt; j++)\n"
"        printf(\"dls_serpath[%d].dls_name = %s\\en\",\n"
"                j, sip-E<gt>dls_serpath[j].dls_name);\n"

#. type: Plain text
#: build/C/man3/dlinfo.3:333
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlopen>(3), "
"B<dlsym>(3), B<ld.so>(8)"
msgstr "B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "DLOPEN"
msgstr "DLOPEN"

#. type: Plain text
#: build/C/man3/dlopen.3:39
msgid "dlclose, dlopen, dlmopen - open and close a shared object"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:43
msgid "B<void *dlopen(const char *>I<filename>B<, int >I<flags>B<);>"
msgstr "B<void *dlopen(const char *>I<filename>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man3/dlopen.3:45
msgid "B<int dlclose(void *>I<handle>B<);>"
msgstr "B<int dlclose(void *>I<handle>B<);>"

#. type: Plain text
#: build/C/man3/dlopen.3:47 build/C/man3/dlsym.3:34
msgid "B<#define _GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:51
msgid ""
"B<void *dlmopen(Lmid_t >I<lmid>B<, const char *>I<filename>B<, int "
">I<flags>B<);>"
msgstr "B<void *dlmopen(Lmid_t >I<lmid>B<, const char *>I<filename>B<, int >I<flags>B<);>"

#. type: SS
#: build/C/man3/dlopen.3:54
#, no-wrap
msgid "dlopen()"
msgstr "dlopen()"

#. type: Plain text
#: build/C/man3/dlopen.3:68
msgid ""
"The function B<dlopen>()  loads the dynamic shared object (shared library)  "
"file named by the null-terminated string I<filename> and returns an opaque "
"\"handle\" for the loaded object.  This handle is employed with other "
"functions in the dlopen API, such as B<dlsym>(3), B<dladdr>(3), "
"B<dlinfo>(3), and B<dlclose>()."
msgstr ""

#.  FIXME On Solaris, when handle is NULL, we seem to get back
#.  a handle for (something like) the root of the namespace.
#.  The point here is that if we do a dlmopen(LM_ID_NEWLM), then
#.  the filename==NULL case returns a different handle than
#.  in the initial namespace. But, on glibc, the same handle is
#.  returned. This is probably a bug in glibc.
#. type: Plain text
#: build/C/man3/dlopen.3:87
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"If I<filename> contains a slash (\"/\"), then it is interpreted as a "
"(relative or absolute) pathname.  Otherwise, the dynamic linker searches for "
"the object as follows (see B<ld.so>(8)  for further details):"
msgstr "I<filename> が NULL の場合、メインプログラムへのハンドルが返される。 I<filename> がスラッシュ (\"/\") を含む場合、(相対か絶対かの)パス名として解釈される。 それ以外の場合、動的リンカーは以下の手順でオブジェクトを検索する (詳細は B<ld.so>(8)  を参照):"

#. type: IP
#: build/C/man3/dlopen.3:87 build/C/man3/dlopen.3:94 build/C/man3/dlopen.3:101
#: build/C/man3/dlopen.3:105 build/C/man3/dlopen.3:112 build/C/man8/ld.so.8:60
#: build/C/man8/ld.so.8:65 build/C/man8/ld.so.8:70 build/C/man8/ld.so.8:80
#: build/C/man8/ld.so.8:90 build/C/man8/ld.so.8:105 build/C/man8/ld.so.8:111
#: build/C/man8/ld.so.8:120 build/C/man8/ld.so.8:129
#, no-wrap
msgid "o"
msgstr "o"

#. type: Plain text
#: build/C/man3/dlopen.3:94
#, fuzzy
#| msgid ""
#| "(ELF only) If the executable file for the calling program contains a "
#| "DT_RPATH tag, and does not contain a DT_RUNPATH tag, then the directories "
#| "listed in the DT_RPATH tag are searched."
msgid ""
"(ELF only) If the calling object (i.e., the shared library or executable "
"from which B<dlopen>()  is called)  contains a DT_RPATH tag, and does not "
"contain a DT_RUNPATH tag, then the directories listed in the DT_RPATH tag "
"are searched."
msgstr ""
"(ELF のみ) 呼び出し元プログラムの実行ファイルに DT_RPATH タグが含まれてお"
"り、 DT_RUNPATH タグが含まれていない場合、DT_RPATH タグに書かれている ディレ"
"クトリリストを検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:101
msgid ""
"If, at the time that the program was started, the environment variable "
"B<LD_LIBRARY_PATH> was defined to contain a colon-separated list of "
"directories, then these are searched.  (As a security measure, this variable "
"is ignored for set-user-ID and set-group-ID programs.)"
msgstr ""
"プログラムの開始時に環境変数 B<LD_LIBRARY_PATH> にコロン区切りのディレクトリ"
"のリストが定義されていれば、 この環境変数に定義されたディレクトリが検索され"
"る (セキュリティ上の理由で、この変数は set-UID や set-GID された プログラムの"
"場合は無視される)。"

#. type: Plain text
#: build/C/man3/dlopen.3:105
#, fuzzy
#| msgid ""
#| "(ELF only) If the executable file for the calling program contains a "
#| "DT_RUNPATH tag, then the directories listed in that tag are searched."
msgid ""
"(ELF only) If the calling object contains a DT_RUNPATH tag, then the "
"directories listed in that tag are searched."
msgstr ""
"(ELF のみ) 呼び出し元プログラムの実行ファイルに DT_RUNPATH タグが含まれて い"
"る場合、そのタグに書かれているディレクトリリストを検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:112
msgid ""
"The cache file I</etc/ld.so.cache> (maintained by B<ldconfig>(8))  is "
"checked to see whether it contains an entry for I<filename>."
msgstr ""
"キャッシュファイル I</etc/ld.so.cache> の中に I<filename> のエントリーが入っ"
"ているかをチェックする (B</etc/ld.so.cache> は B<ldconfig>(8)  によって管理さ"
"れている)。"

#. type: Plain text
#: build/C/man3/dlopen.3:118
msgid "The directories I</lib> and I</usr/lib> are searched (in that order)."
msgstr "ディレクトリ I</lib> と I</usr/lib> をこの順番で検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:126
msgid ""
"If the object specified by I<filename> has dependencies on other shared "
"objects, then these are also automatically loaded by the dynamic linker "
"using the same rules.  (This process may occur recursively, if those objects "
"in turn have dependencies, and so on.)"
msgstr "I<filename> で指定されたオブジェクトが他の共有オブジェクトに依存している場合は、 依存しているオブジェクトも動的リンカーが同じ検索ルールに基づいて 自動的にロードする (それらのオブジェクトにさらに依存関係がある場合などは この処理は再帰的に行われる)。"

#. type: Plain text
#: build/C/man3/dlopen.3:129
msgid "One of the following two values must be included in I<flags>:"
msgstr "I<flags> には以下の 2 つの値のいずれかを含めなければならない:"

#. type: TP
#: build/C/man3/dlopen.3:129
#, no-wrap
msgid "B<RTLD_LAZY>"
msgstr "B<RTLD_LAZY>"

#.  commit 12b5b6b7f78ea111e89bbf638294a5413c791072
#. type: Plain text
#: build/C/man3/dlopen.3:142
#, fuzzy
#| msgid ""
#| "Perform lazy binding.  Only resolve symbols as the code that references "
#| "them is executed.  If the symbol is never referenced, then it is never "
#| "resolved.  (Lazy binding is performed only for function references; "
#| "references to variables are always immediately bound when the library is "
#| "loaded.)"
msgid ""
"Perform lazy binding.  Resolve symbols only as the code that references them "
"is executed.  If the symbol is never referenced, then it is never resolved.  "
"(Lazy binding is performed only for function references; references to "
"variables are always immediately bound when the shared object is loaded.)  "
"Since glibc 2.1.1, this flag is overridden by the effect of the "
"B<LD_BIND_NOW> environment variable."
msgstr ""
"lazy binding (手抜きなシンボルの結び付け) が行う。 シンボルの解決はそのシンボ"
"ルを参照するコードが実行されるときにのみ 行われる。シンボルが一度も参照されな"
"かった場合には、そのシンボルは 解決されないままとなる。 (lazy binding は関数"
"参照についてのみ実施される; 変数への参照は常に ライブラリがロードされた時点で"
"直ちに解決される。)"

#. type: TP
#: build/C/man3/dlopen.3:142
#, no-wrap
msgid "B<RTLD_NOW>"
msgstr "B<RTLD_NOW>"

#. type: Plain text
#: build/C/man3/dlopen.3:151
msgid ""
"If this value is specified, or the environment variable B<LD_BIND_NOW> is "
"set to a nonempty string, all undefined symbols in the shared object are "
"resolved before B<dlopen>()  returns.  If this cannot be done, an error is "
"returned."
msgstr "この値が指定されるか、環境変数 B<LD_BIND_NOW> に空でない文字列が設定された場合、 共有オブジェクト中の未定義のシンボルを全て解決してから B<dlopen>()  は復帰する。解決できなかったときにはエラーが返される。"

#. type: Plain text
#: build/C/man3/dlopen.3:154
msgid "Zero or more of the following values may also be ORed in I<flags>:"
msgstr "以下の値のうち 0 個以上を論理和 (OR) の形で I<flags> に追加することもできる:"

#. type: TP
#: build/C/man3/dlopen.3:154
#, no-wrap
msgid "B<RTLD_GLOBAL>"
msgstr "B<RTLD_GLOBAL>"

#. type: Plain text
#: build/C/man3/dlopen.3:158
#, fuzzy
#| msgid ""
#| "The symbols defined by this library will be made available for symbol "
#| "resolution of subsequently loaded libraries."
msgid ""
"The symbols defined by this shared object will be made available for symbol "
"resolution of subsequently loaded shared objects."
msgstr ""
"このライブラリで定義されているシンボルが、これより後でロードされる ライブラリ"
"のシンボル解決で利用できるようになる。"

#. type: TP
#: build/C/man3/dlopen.3:158
#, no-wrap
msgid "B<RTLD_LOCAL>"
msgstr "B<RTLD_LOCAL>"

#. type: Plain text
#: build/C/man3/dlopen.3:165
#, fuzzy
#| msgid ""
#| "This is the converse of B<RTLD_GLOBAL>, and the default if neither flag "
#| "is specified.  Symbols defined in this library are not made available to "
#| "resolve references in subsequently loaded libraries."
msgid ""
"This is the converse of B<RTLD_GLOBAL>, and the default if neither flag is "
"specified.  Symbols defined in this shared object are not made available to "
"resolve references in subsequently loaded shared objects."
msgstr ""
"このフラグは B<RTLD_GLOBAL> の反対の意味であり、どちらのフラグも指定されな"
"かった場合は こちらがデフォルトとなる。 このライブラリで定義されているシンボ"
"ルは、これより後でロードされる ライブラリでのシンボル参照で利用できない。"

#. type: TP
#: build/C/man3/dlopen.3:165
#, no-wrap
msgid "B<RTLD_NODELETE> (since glibc 2.2)"
msgstr "B<RTLD_NODELETE> (glibc 2.2 以降)"

#. type: Plain text
#: build/C/man3/dlopen.3:173
#, fuzzy
#| msgid ""
#| "Do not unload the library during B<dlclose>().  Consequently, the "
#| "library's static variables are not reinitialized if the library is "
#| "reloaded with B<dlopen>()  at a later time.  This flag is not specified "
#| "in POSIX.1-2001."
msgid ""
"Do not unload the shared object during B<dlclose>().  Consequently, the "
"object's static and global variables are not reinitialized if the object is "
"reloaded with B<dlopen>()  at a later time."
msgstr ""
"B<dlclose>()  中にそのライブラリをアンロードしない。 そのため、同じライブラリ"
"をこれ以降に B<dlopen>()  で再度ロードした場合に、ライブラリ内の静的変数は再"
"初期化されない。 このフラグは POSIX.1-2001 では規定されていない。"

#. type: TP
#: build/C/man3/dlopen.3:173
#, no-wrap
msgid "B<RTLD_NOLOAD> (since glibc 2.2)"
msgstr "B<RTLD_NOLOAD> (glibc 2.2 以降)"

#. type: Plain text
#: build/C/man3/dlopen.3:186
#, fuzzy
#| msgid ""
#| "Don't load the library.  This can be used to test if the library is "
#| "already resident (B<dlopen>()  returns NULL if it is not, or the "
#| "library's handle if it is resident).  This flag can also be used to "
#| "promote the flags on a library that is already loaded.  For example, a "
#| "library that was previously loaded with B<RTLD_LOCAL> can be reopened "
#| "with B<RTLD_NOLOAD\\ |\\ RTLD_GLOBAL>.  This flag is not specified in "
#| "POSIX.1-2001."
msgid ""
"Don't load the shared object.  This can be used to test if the object is "
"already resident (B<dlopen>()  returns NULL if it is not, or the object's "
"handle if it is resident).  This flag can also be used to promote the flags "
"on a shared object that is already loaded.  For example, a shared object "
"that was previously loaded with B<RTLD_LOCAL> can be reopened with "
"B<RTLD_NOLOAD\\ |\\ RTLD_GLOBAL>."
msgstr ""
"そのライブラリをロードしない。 このフラグはそのライブラリがすでに組み込まれて"
"いるかを検査するのに 利用できる (B<dlopen>()  は、ライブラリが組み込まれてい"
"なければ NULL を返し、 すでに組み込まれていればそのライブラリのハンドルを返"
"す)。 また、すでにロードされているライブラリのフラグを昇格させるのにも 利用で"
"きる。例えば、過去に B<RTLD_LOCAL> でロードしたライブラリを B<RTLD_NOLOAD\\ |"
"\\ RTLD_GLOBAL> で再オープンすることができる。 このフラグは POSIX.1-2001 では"
"規定されていない。"

#. type: TP
#: build/C/man3/dlopen.3:186
#, no-wrap
msgid "B<RTLD_DEEPBIND> (since glibc 2.3.4)"
msgstr "B<RTLD_DEEPBIND> (glibc 2.3.4 以降)"

#.  Inimitably described by UD in
#.  http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
#. type: Plain text
#: build/C/man3/dlopen.3:195
#, fuzzy
#| msgid ""
#| "Place the lookup scope of the symbols in this library ahead of the global "
#| "scope.  This means that a self-contained library will use its own symbols "
#| "in preference to global symbols with the same name contained in libraries "
#| "that have already been loaded.  This flag is not specified in "
#| "POSIX.1-2001."
msgid ""
"Place the lookup scope of the symbols in this shared object ahead of the "
"global scope.  This means that a self-contained object will use its own "
"symbols in preference to global symbols with the same name contained in "
"objects that have already been loaded."
msgstr ""
"このライブラリ内のシンボルの参照領域をグローバル領域よりも前に配置する。 つま"
"り、内蔵型のライブラリでは、すでにロードされたライブラリに含まれる 同じ名前の"
"グローバルなシンボルよりも自ライブラリ内のシンボルが優先して 使われる。 この"
"フラグは POSIX.1-2001 では規定されていない。"

#. type: Plain text
#: build/C/man3/dlopen.3:207
#, fuzzy
#| msgid ""
#| "If I<filename> is NULL, then the returned handle is for the main "
#| "program.  When given to B<dlsym>(), this handle causes a search for a "
#| "symbol in the main program, followed by all shared libraries loaded at "
#| "program startup, and then all shared libraries loaded by B<dlopen>()  "
#| "with the flag B<RTLD_GLOBAL>."
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"When given to B<dlsym>(3), this handle causes a search for a symbol in the "
"main program, followed by all shared objects loaded at program startup, and "
"then all shared objects loaded by B<dlopen>()  with the flag B<RTLD_GLOBAL>."
msgstr ""
"I<filename> が NULL である場合は、 返されるハンドルはメインプログラムのものに"
"なる。 このハンドルが B<dlsym>()  に渡されると、シンボルの検索は、メインプロ"
"グラム内、 プログラムの起動時にロードされる全ての共有ライブラリ、 "
"B<dlopen>()  によって B<RTLD_GLOBAL> フラグ付きでロードされた全ての共有ライブ"
"ラリ、の順序で行われる。"

#. type: Plain text
#: build/C/man3/dlopen.3:219
msgid ""
"Symbol references in the shared object are resolved using (in order): "
"symbols in the link map of objects loaded for the main program and its "
"dependencies; symbols in shared objects (and their dependencies)  that were "
"previously opened with B<dlopen>()  using the B<RTLD_GLOBAL> flag; and "
"definitions in the shared object itself (and any dependencies that were "
"loaded for that object)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:231
msgid ""
"Any global symbols in the executable that were placed into its dynamic "
"symbol table by B<ld>(1)  can also be used to resolve references in a "
"dynamically loaded shared object.  Symbols may be placed in the dynamic "
"symbol table either because the executable was linked with the flag \"-"
"rdynamic\" (or, synonymously, \"--export-dynamic\"), which causes all of the "
"executable's global symbols to be placed in the dynamic symbol table, or "
"because B<ld>(1)  noted a dependency on a symbol in another object during "
"static linking."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:244
#, fuzzy
#| msgid ""
#| "If the same library is loaded again with B<dlopen>(), the same library "
#| "handle is returned.  The dl library maintains reference counts for "
#| "library handles, so a dynamic library is not deallocated until "
#| "B<dlclose>()  has been called on it as many times as B<dlopen>()  has "
#| "succeeded on it.  The B<_init>()  routine, if present, is called only "
#| "once.  But a subsequent call with B<RTLD_NOW> may force symbol resolution "
#| "for a library earlier loaded with B<RTLD_LAZY>."
msgid ""
"If the same shared object is opened again with B<dlopen>(), the same object "
"handle is returned.  The dynamic linker maintains reference counts for "
"object handles, so a dynamically loaded shared object is not deallocated "
"until B<dlclose>()  has been called on it as many times as B<dlopen>()  has "
"succeeded on it.  Constructors (see below) are called only when the object "
"is actually loaded into memory (i.e., when the reference count increases to "
"1)."
msgstr ""
"同じライブラリが B<dlopen>()  によって再度ロードされた場合には、同じライブラ"
"リハンドルが返される。 dl ライブラリはライブラリハンドルのリンク数を管理して"
"いる。 したがって動的ライブラリは B<dlclose>()  が B<dlopen>()  と同じ回数だ"
"け呼び出されない限りアンロードされない。 B<_init>()  ルーチンは一度だけ呼び出"
"される (B<_init>()  が存在する場合のみ)。 B<RTLD_NOW> が指定されて "
"B<dlopen>()  が呼び出された場合、 B<RTLD_LAZY> で以前にロードされたライブラリ"
"のシンボル解決が実行されることがある。"

#. type: Plain text
#: build/C/man3/dlopen.3:257
msgid ""
"A subsequent B<dlopen>()  call that loads the same shared object with "
"B<RTLD_NOW> may force symbol resolution for a shared object earlier loaded "
"with B<RTLD_LAZY>.  Similarly, an object that was previously opened with "
"B<RTLD_LOCAL> can be promoted to B<RTLD_GLOBAL> in a subsequent B<dlopen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:262
msgid "If B<dlopen>()  fails for any reason, it returns NULL."
msgstr "B<dlopen>()  は、何らかの理由で失敗すると NULL を返す。"

#. type: SS
#: build/C/man3/dlopen.3:262
#, no-wrap
msgid "dlmopen()"
msgstr "dlmopen()"

#. type: Plain text
#: build/C/man3/dlopen.3:270
msgid ""
"This function performs the same task as B<dlopen>()\\(emthe I<filename> and "
"I<flags> arguments, as well as the return value, are the same, except for "
"the differences noted below."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:289
msgid ""
"The B<dlmopen>()  function differs from B<dlopen>()  primarily in that it "
"accepts an additional argument, I<lmid>, that specifies the link-map list "
"(also referred to as a I<namespace>)  in which the shared object should be "
"loaded.  (By comparison, B<dlopen>()  adds the dynamically loaded shared "
"object to the same namespace as the shared object from which the "
"B<dlopen>()  call is made.)  The I<Lmid_t> type is an opaque handle that "
"refers to a namespace."
msgstr ""

#.  FIXME: Is using dlinfo() RTLD_DI_LMID the right technique?
#. type: Plain text
#: build/C/man3/dlopen.3:298
msgid ""
"The I<lmid> argument is either the ID of an existing namespace (which can be "
"obtained using the B<dlinfo>(3)  B<RTLD_DI_LMID> request) or one of the "
"following special values:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:298 build/C/man7/rtld-audit.7:198
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr "B<LM_ID_BASE>"

#. type: Plain text
#: build/C/man3/dlopen.3:302
msgid ""
"Load the shared object in the initial namespace (i.e., the application's "
"namespace)."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:302 build/C/man7/rtld-audit.7:201
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr "B<LM_ID_NEWLM>"

#. type: Plain text
#: build/C/man3/dlopen.3:308
msgid ""
"Create a new namespace and load the shared object in that namespace.  The "
"object must have been correctly linked to reference all of the other shared "
"objects that it requires, since the new namespace is initially empty."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:315
msgid ""
"If I<filename> is NULL, then the only permitted value for I<lmid> is "
"B<LM_ID_BASE>."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:315
#, no-wrap
msgid "dlclose()"
msgstr "dlclose()"

#. type: Plain text
#: build/C/man3/dlopen.3:321
#, fuzzy
#| msgid ""
#| "The function B<dlclose>()  decrements the reference count on the dynamic "
#| "library handle I<handle>.  If the reference count drops to zero and no "
#| "other loaded libraries use symbols in it, then the dynamic library is "
#| "unloaded."
msgid ""
"The function B<dlclose>()  decrements the reference count on the dynamically "
"loaded shared object referred to by I<handle>."
msgstr ""
"関数 B<dlclose>()  は動的ライブラリのハンドル I<handle> の参照カウントを 1 減"
"らす。参照カウントが 0 になり、ロードされている 他のライブラリからそのライブ"
"ラリ内のシンボルが使われていなければ、 その動的ライブラリをアンロードする。"

#. type: Plain text
#: build/C/man3/dlopen.3:330
msgid ""
"If the object's reference count drops to zero and no symbols in this object "
"are required by other objects, then the object is unloaded after first "
"calling any destructors defined for the object.  (Symbols in this object "
"might be required in another object because this object was opened with the "
"B<RTLD_GLOBAL> flag and one of its symbols satisfied a relocation in another "
"object.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:336
msgid ""
"All shared objects that were automatically loaded when B<dlopen>()  was "
"invoked on the object referred to by I<handle> are recursively closed in the "
"same manner."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:348
msgid ""
"A successful return from B<dlclose>()  does not guarantee that the symbols "
"associated with I<handle> are removed from the caller's address space.  In "
"addition to references resulting from explicit B<dlopen>()  calls, a shared "
"object may have been implicitly loaded (and reference counted) because of "
"dependencies in other shared objects.  Only when all references have been "
"released can the shared object be removed from the address space."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:358
msgid ""
"On success, B<dlopen>()  and B<dlmopen>()  return a non-NULL handle for the "
"loaded object.  On error (file could not be found, was not readable, had the "
"wrong format, or caused errors during loading), these functions return NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:362
#, fuzzy
#| msgid "B<dladdr>()  returns 0 on error, and nonzero on success."
msgid ""
"On success, B<dlclose>()  returns 0; on error, it returns a nonzero value."
msgstr "B<dladdr>()  は、エラー時には 0 を返し、成功した場合は 0 以外を返す。"

#. type: Plain text
#: build/C/man3/dlopen.3:365
msgid "Errors from these functions can be diagnosed using B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:372
msgid ""
"B<dlopen>()  and B<dlclose>()  are present in glibc 2.0 and later.  "
"B<dlmopen>()  first appeared in glibc 2.3.4."
msgstr ""

#. type: tbl table
#: build/C/man3/dlopen.3:384
#, no-wrap
msgid ""
"B<dlopen>(),\n"
"B<dlmopen>(),\n"
"B<dlclose>()"
msgstr ""
"B<dlopen>(),\n"
"B<dlmopen>(),\n"
"B<dlclose>()"

#. type: Plain text
#: build/C/man3/dlopen.3:394
#, fuzzy
#| msgid ""
#| "POSIX.1-2001 describes B<dlclose>(), B<dlerror>(), B<dlopen>(), and "
#| "B<dlsym>()."
msgid ""
"POSIX.1-2001 describes B<dlclose>()  and B<dlopen>().  The B<dlmopen>()  "
"function is a GNU extension."
msgstr ""
"POSIX.1-2003 には B<dlclose>(), B<dlerror>(), B<dlopen>(), B<dlsym>().  の記"
"載がある。"

#. type: Plain text
#: build/C/man3/dlopen.3:402
msgid ""
"The B<RTLD_NOLOAD>, B<RTLD_NODELETE>, and B<RTLD_DEEPBIND> flags are GNU "
"extensions; the first two of these flags are also present on Solaris."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:403
#, no-wrap
msgid "dlmopen() and namespaces"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:411
msgid ""
"A link-map list defines an isolated namespace for the resolution of symbols "
"by the dynamic linker.  Within a namespace, dependent shared objects are "
"implicitly loaded according to the usual rules, and symbol references are "
"likewise resolved according to the usual rules, but such resolution is "
"confined to the definitions provided by the objects that have been "
"(explicitly and implicitly) loaded into the namespace."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:431
msgid ""
"The B<dlmopen>()  function permits object-load isolation\\(emthe ability to "
"load a shared object in a new namespace without exposing the rest of the "
"application to the symbols made available by the new object.  Note that the "
"use of the B<RTLD_LOCAL> flag is not sufficient for this purpose, since it "
"prevents a shared object's symbols from being available to I<any> other "
"shared object.  In some cases, we may want to make the symbols provided by a "
"dynamically loaded shared object available to (a subset of) other shared "
"objects without exposing those symbols to the entire application.  This can "
"be achieved by using a separate namespace and the B<RTLD_GLOBAL> flag."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:447
msgid ""
"The B<dlmopen>()  function also can be used to provide better isolation than "
"the B<RTLD_LOCAL> flag.  In particular, shared objects loaded with "
"B<RTLD_LOCAL> may be promoted to B<RTLD_GLOBAL> if they are dependencies of "
"another shared object loaded with B<RTLD_GLOBAL>.  Thus, B<RTLD_LOCAL> is "
"insufficient to isolate a loaded shared object except in the (uncommon)  "
"case where one has explicit control over all shared object dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:462
msgid ""
"Possible uses of B<dlmopen>()  are plugins where the author of the plugin-"
"loading framework can't trust the plugin authors and does not wish any "
"undefined symbols from the plugin framework to be resolved to plugin "
"symbols.  Another use is to load the same object more than once.  Without "
"the use of B<dlmopen>(), this would require the creation of distinct copies "
"of the shared object file.  Using B<dlmopen>(), this can be achieved by "
"loading the same shared object file into different namespaces."
msgstr ""

#.  DL_NNS
#. type: Plain text
#: build/C/man3/dlopen.3:467
msgid "The glibc implementation supports a maximum of 16 namespaces."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:467
#, no-wrap
msgid "Initialization and finalization functions"
msgstr ""

#.  info gcc "C Extensions" "Function attributes"
#. type: Plain text
#: build/C/man3/dlopen.3:486
msgid ""
"Shared objects may export functions using the "
"B<__attribute__((constructor))> and B<__attribute__((destructor))> function "
"attributes.  Constructor functions are executed before B<dlopen>()  returns, "
"and destructor functions are executed before B<dlclose>()  returns.  A "
"shared object may export multiple constructors and destructors, and "
"priorities can be associated with each function to determine the order in "
"which they are executed.  See the B<gcc> info pages (under \"Function "
"attributes\")  for further information."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:506
#, fuzzy
#| msgid ""
#| "The linker recognizes special symbols B<_init> and B<_fini>.  If a "
#| "dynamic library exports a routine named B<_init>(), then that code is "
#| "executed after the loading, before B<dlopen>()  returns.  If the dynamic "
#| "library exports a routine named B<_fini>(), then that routine is called "
#| "just before the library is unloaded.  In case you need to avoid linking "
#| "against the system startup files, this can be done by using the "
#| "B<gcc>(1)  I<-nostartfiles> command-line option."
msgid ""
"An older method of (partially) achieving the same result is via the use of "
"two special symbols recognized by the linker: B<_init> and B<_fini>.  If a "
"dynamically loaded shared object exports a routine named B<_init>(), then "
"that code is executed after loading a shared object, before B<dlopen>()  "
"returns.  If the shared object exports a routine named B<_fini>(), then that "
"routine is called just before the object is unloaded.  In this case, one "
"must avoid linking against the system startup files, which contain default "
"versions of these files; this can be done by using the B<gcc>(1)  I<-"
"nostartfiles> command-line option."
msgstr ""
"リンカーは B<_init> と B<_fini> を特別なシンボルと解釈する。 ある動的ライブラ"
"リで B<_init>()  という名前のルーチンがエクスポートされていれば、 そのコード"
"は、ライブラリのロード後、かつ B<dlopen>()  が復帰する前に実行される。 その動"
"的ライブラリで B<_fini>()  という名前のルーチンがエクスポートされていれば、 "
"ライブラリがアンロードされる直前にそのルーチンが呼び出される。 システムの起動"
"ファイルに対するリンクを避ける必要がある場合、 B<gcc>(1)  のコマンドラインに "
"I<-nostartfiles> オプションを指定すればよい。"

#
#.  Using these routines, or the gcc
#.  .B \-nostartfiles
#.  or
#.  .B \-nostdlib
#.  options, is not recommended.
#.  Their use may result in undesired behavior,
#.  since the constructor/destructor routines will not be executed
#.  (unless special measures are taken).
#.  .\" void _init(void) __attribute__((constructor));
#.  .\" void _fini(void) __attribute__((destructor));
#. type: Plain text
#: build/C/man3/dlopen.3:527
msgid ""
"Use of B<_init> and B<_fini> is now deprecated in favor of the "
"aforementioned constructors and destructors, which among other advantages, "
"permit multiple initialization and finalization functions to be defined."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:532
msgid ""
"Since glibc 2.2.3, B<atexit>(3)  can be used to register an exit handler "
"that is automatically called when a shared object is unloaded."
msgstr "glibc 2.2.3 以降では、 B<atexit>(3)  を使って、共有オブジェクトがアンロードされる際に自動的に呼び出される 終了ハンドラー (exit handler) を登録することができる。"

#. type: Plain text
#: build/C/man3/dlopen.3:534
msgid "These functions are part of the dlopen API, derived from SunOS."
msgstr ""

#.  dlerror(): "invalid mode"
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=18684
#. type: Plain text
#: build/C/man3/dlopen.3:550
msgid ""
"As at glibc 2.24, specifying the B<RTLD_GLOBAL> flag when calling "
"B<dlmopen>()  generates an error.  Furthermore, specifying B<RTLD_GLOBAL> "
"when calling B<dlopen>()  results in a program crash (B<SIGSEGV>)  if the "
"call is made from any object loaded in a namespace other than the initial "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:556
msgid ""
"The program below loads the (glibc) math library, looks up the address of "
"the B<cos>(3)  function, and prints the cosine of 2.0.  The following is an "
"example of building and running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:562
#, no-wrap
msgid ""
"$ B<cc dlopen_demo.c -ldl>\n"
"$ B<./a.out>\n"
"-0.416147\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:578
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>gnu/lib-names.hE<gt>  /* Defines LIBM_SO (which will be a\n"
"                               string such as \"libm.so.6\") */\n"
"int\n"
"main(void)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:584
#, no-wrap
msgid ""
"    handle = dlopen(LIBM_SO, RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    handle = dlopen(LIBM_SO, RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlopen.3:586
#, no-wrap
msgid "    dlerror();    /* Clear any existing error */\n"
msgstr "    dlerror();    /* Clear any existing error */\n"

#. type: Plain text
#: build/C/man3/dlopen.3:588
#, no-wrap
msgid "    cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
msgstr "    cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"

#. type: Plain text
#: build/C/man3/dlopen.3:593
#, no-wrap
msgid ""
"    /* According to the ISO C standard, casting between function\n"
"       pointers and \\(aqvoid *\\(aq, as done above, produces undefined results.\n"
"       POSIX.1-2001 and POSIX.1-2008 accepted this state of affairs and\n"
"       proposed the following workaround:\n"
msgstr ""
"    /* ISO の C 標準によれば、上のような、関数ポインターと \\(aqvoid *\\(aq 間の\n"
"       キャストを行った場合に得られる結果は不定である。\n"
"       POSIX.1-2001 と POSIX.1-2008 では、この状況は認められており、\n"
"       以下のようなワークアラウンドが提案されている。\n"

#. type: Plain text
#: build/C/man3/dlopen.3:595
#, no-wrap
msgid "           *(void **) (&cosine) = dlsym(handle, \"cos\");\n"
msgstr "           *(void **) (&cosine) = dlsym(handle, \"cos\");\n"

#. type: Plain text
#: build/C/man3/dlopen.3:598
#, no-wrap
msgid ""
"       This (clumsy) cast conforms with the ISO C standard and will\n"
"       avoid any compiler warnings.\n"
msgstr ""
"       この (ぶかっこうな) キャストは ISO の C 標準に従っており、\n"
"       コンパイラの警告を避けることができる。\n"

#.  http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html#tag_03_112_08
#.  http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html#tag_16_96_07
#.  http://austingroupbugs.net/view.php?id=74
#. type: Plain text
#: build/C/man3/dlopen.3:607
#, no-wrap
msgid ""
"       The 2013 Technical Corrigendum 1 to POSIX.1-2008 improved matters\n"
"       by requiring that conforming implementations support casting\n"
"       \\(aqvoid *\\(aq to a function pointer.  Nevertheless, some compilers\n"
"       (e.g., gcc with the \\(aq-pedantic\\(aq option) may complain about the\n"
"       cast used in this program. */\n"
msgstr ""
"       POSIX.1-2008 の 2013 Technical Corrigendum 1 では、\n"
"       POSIX に準拠する実装では \\(aqvoid *\\(aq から関数ポインターへの\n"
"       キャストをサポートすることが要求されるようになり、状況が改善\n"
"       された。にもかかわらず、(\\(aq-pedantic\\(aq オプションを指定した\n"
"       gcc などの) いくつかのコンパイラは、このプログラムで使用されている\n"
"       キャストについて文句を言うのだ。\n"

#. type: Plain text
#: build/C/man3/dlopen.3:613
#, no-wrap
msgid ""
"    error = dlerror();\n"
"    if (error != NULL) {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    error = dlerror();\n"
"    if (error != NULL) {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlopen.3:618
#, no-wrap
msgid ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/dlopen.3:631
msgid ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<dl_iterate_phdr>(3), B<dladdr>(3), "
"B<dlerror>(3), B<dlinfo>(3), B<dlsym>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8)"
msgstr "B<ld>(1), B<ldd>(1), B<pldd>(1), B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), B<dlsym>(3), B<rtld-audit>(7), B<ld.so>(8), B<ldconfig>(8)"

#. type: Plain text
#: build/C/man3/dlopen.3:633
msgid "gcc info pages, ld info pages"
msgstr "gcc info pages, ld info pages"

#. type: TH
#: build/C/man3/dlsym.3:25
#, no-wrap
msgid "DLSYM"
msgstr "DLSYM"

#. type: Plain text
#: build/C/man3/dlsym.3:28
msgid ""
"dlsym, dlvsym - obtain address of a symbol in a shared object or executable"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:32
msgid "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"
msgstr "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"

#. type: Plain text
#: build/C/man3/dlsym.3:38
msgid ""
"B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>"
msgstr "B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>"

#. type: Plain text
#: build/C/man3/dlsym.3:57
#, fuzzy
#| msgid ""
#| "The function B<dlsym>()  takes a \"handle\" of a dynamic library returned "
#| "by B<dlopen>()  and the null-terminated symbol name, returning the "
#| "address where that symbol is loaded into memory.  If the symbol is not "
#| "found, in the specified library or any of the libraries that were "
#| "automatically loaded by B<dlopen>()  when that library was loaded, "
#| "B<dlsym>()  returns NULL.  (The search performed by B<dlsym>()  is "
#| "breadth first through the dependency tree of these libraries.)  Since the "
#| "value of the symbol could actually be NULL (so that a NULL return from "
#| "B<dlsym>()  need not indicate an error), the correct way to test for an "
#| "error is to call B<dlerror>()  to clear any old error conditions, then "
#| "call B<dlsym>(), and then call B<dlerror>()  again, saving its return "
#| "value into a variable, and check whether this saved value is not NULL."
msgid ""
"The function B<dlsym>()  takes a \"handle\" of a dynamic loaded shared "
"object returned by B<dlopen>(3)  along with a null-terminated symbol name, "
"and returns the address where that symbol is loaded into memory.  If the "
"symbol is not found, in the specified object or any of the shared objects "
"that were automatically loaded by B<dlopen>(3)  when that object was loaded, "
"B<dlsym>()  returns NULL.  (The search performed by B<dlsym>()  is breadth "
"first through the dependency tree of these shared objects.)"
msgstr ""
"関数 B<dlsym>()  は、 B<dlopen>()  が返した動的ライブラリの「ハンドル」と、 "
"NULL 終端されたシンボル名の文字列を引数に取り、 そのシンボルがロードされた"
"メモリーのアドレスを返す。 シンボルが、指定されたライブラリと、指定されたライ"
"ブラリがロードされる際に B<dlopen>()  が自動的にロードしてライブラリのいずれ"
"にも見つからない場合には、 B<dlsym>()  は NULL を返す (B<dlsym>()  による検索"
"は、これらのライブラリの依存関係のツリーを先頭から 辿って行われる)。 実際には"
"シンボルの値自体が NULL になることもある (そのため、 B<dlsym>()  の返り値が "
"NULL であったとしても必ずしもエラーという訳ではない)。 エラーかどうかを確認す"
"る正しい方法は以下の通りである: B<dlerror>()  を呼び出して以前のエラー状態を"
"クリアしてから、 B<dlsym>()  を呼び出す。その後でもう一度 B<dlerror>()  を呼"
"び出して、 B<dlerror>()  の返り値を変数に保存し、保存した値が NULL であるか判"
"定する。"

#. type: Plain text
#: build/C/man3/dlsym.3:71
msgid ""
"In unusual cases (see NOTES) the value of the symbol could actually be "
"NULL.  Therefore, a NULL return from B<dlsym>()  need not indicate an "
"error.  The correct way to distinguish an error from a symbol whose value is "
"NULL is to call B<dlerror>(3)  to clear any old error conditions, then call "
"B<dlsym>(), and then call B<dlerror>(3)  again, saving its return value into "
"a variable, and check whether this saved value is not NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:74
msgid ""
"There are two special pseudo-handles that may be specified in I<handle>:"
msgstr ""

#. type: TP
#: build/C/man3/dlsym.3:74
#, no-wrap
msgid "B<RTLD_DEFAULT>"
msgstr "B<RTLD_DEFAULT>"

#. type: Plain text
#: build/C/man3/dlsym.3:83
msgid ""
"Find the first occurrence of the desired symbol using the default shared "
"object search order.  The search will include global symbols in the "
"executable and its dependencies, as well as symbols in shared objects that "
"were dynamically loaded with the B<RTLD_GLOBAL> flag."
msgstr ""

#. type: TP
#: build/C/man3/dlsym.3:83
#, no-wrap
msgid "B<RTLD_NEXT>"
msgstr "B<RTLD_NEXT>"

#. type: Plain text
#: build/C/man3/dlsym.3:97
msgid ""
"Find the next occurrence of the desired symbol in the search order after the "
"current object.  This allows one to provide a wrapper around a function in "
"another shared object, so that, for example, the definition of a function in "
"a preloaded shared object (see B<LD_PRELOAD> in B<ld.so>(8))  can find and "
"invoke the \"real\" function provided in another shared object (or for that "
"matter, the \"next\" definition of the function in cases where there are "
"multiple layers of preloading)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:107
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<RTLD_DEFAULT> and B<RTLD_NEXT> from I<E<lt>dlfcn.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:113
msgid ""
"The function B<dlvsym>()  does the same as B<dlsym>()  but takes a version "
"string as an additional argument."
msgstr "関数 B<dlvsym>() は B<dlsym>() と同じ動作をするが、バージョンの文字列を渡す引数が 追加されている点が異なる。"

#. type: Plain text
#: build/C/man3/dlsym.3:120
msgid ""
"On success, these functions return the address associated with I<symbol>.  "
"On failure, they return NULL; the cause of the error can be diagnosed using "
"B<dlerror>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:125
msgid ""
"B<dlsym>()  is present in glibc 2.0 and later.  B<dlvsym>()  first appeared "
"in glibc 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/dlsym.3:136
#, no-wrap
msgid ""
"B<dlsym>(),\n"
"B<dlvsym>()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:144
msgid ""
"POSIX.1-2001 describes B<dlsym>().  The B<dlvsym>()  function is a GNU "
"extension."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:162
msgid ""
"There are several scenarios when the address of a global symbol is NULL.  "
"For example, a symbol can be placed at zero address by the linker, via a "
"linker script or with I<--defsym> command-line option. Undefined weak "
"symbols also have NULL value.  Finally, the symbol value may be the result "
"of a GNU indirect function (IFUNC) resolver function that returns NULL as "
"the resolved value. In the latter case, B<dlsym>()  also returns NULL "
"without error. However, in the former two cases, the behavior of GNU dynamic "
"linker is inconsistent: relocation processing succeeds and the symbol can be "
"observed to have NULL value, but B<dlsym>()  fails and B<dlerror>()  "
"indicates a lookup error."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:168
msgid ""
"The B<dlsym>()  function is part of the dlopen API, derived from SunOS.  "
"That system does not have B<dlvsym>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dlsym.3:178
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), "
"B<dlopen>(3), B<ld.so>(8)"
msgstr "B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), B<dlopen>(3), B<ld.so>(8)"

#. type: TH
#: build/C/man5/elf.5:35
#, no-wrap
msgid "ELF"
msgstr "ELF"

#. type: TH
#: build/C/man5/elf.5:35
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man5/elf.5:38
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr "elf - 実行可能リンクフォーマット (ELF) ファイルのフォーマット"

#.  .B #include <elf_abi.h>
#. type: Plain text
#: build/C/man5/elf.5:42
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr "B<#include E<lt>elf.hE<gt>>\n"

#. type: Plain text
#: build/C/man5/elf.5:50
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files, and shared objects."
msgstr "ヘッダーファイル I<E<lt>elf.hE<gt>> は ELF 実行可能バイナリファイルのフォーマットを定義する。 これらのファイルとしては、通常の実行可能ファイル、再配置可能オブジェクトファイル、コアファイル、共有オブジェクトがある。"

#. type: Plain text
#: build/C/man5/elf.5:59
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the file."
msgstr ""
"ELF ファイルフォーマットを使う実行可能ファイルは、 ELF ヘッダーの後にプログラ"
"ムヘッダーテーブルまたは セクションヘッダーテーブル (またはその両方) が続く構"
"成である。 ELF ヘッダーは常にファイルのオフセット 0 にある。 プログラムヘッ"
"ダーテーブルとセクションヘッダーテーブルの ファイル内でのオフセットは、ELF "
"ヘッダーに定義されている。 この 2 つのテーブルはファイルの残りの部分の詳細を"
"記述する。"

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: build/C/man5/elf.5:87
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""
"このヘッダーファイルは上記のヘッダーを C 言語の構造体で記述し、 また動的セク"
"ション・再配置可能セクション・シンボルテーブルの構造体も 含んでいる。"

#. type: SS
#: build/C/man5/elf.5:87
#, no-wrap
msgid "Basic types"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:99
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""
"以下の型は N ビットアーキテクチャーで使われる (N=32,64 であり I<ElfN> は "
"I<Elf32> または I<Elf64> を表し、 I<uintN_t> は I<uint32_t> または "
"I<uint64_t> を表す):"

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: build/C/man5/elf.5:113
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""
"ElfN_Addr       符号なしのプログラムアドレス, uintN_t\n"
"ElfN_Off        符号なしのファイルオフセット, uintN_t\n"
"ElfN_Section    符号なしのセクションインデックス, uint16_t\n"
"ElfN_Versym     符号なしのバージョンシンボル情報, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"

#. type: Plain text
#: build/C/man5/elf.5:128
msgid ""
"(Note: the *BSD terminology is a bit different.  There, I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""
"(注意: *BSD での用語は少し異なる。 I<Elf64_Half> は I<Elf32_Half> の 2 倍であ"
"り、 I<Elf64Quarter> が I<uint16_t> に用いられる。 混乱を避けるため、以下で"
"は、これらの型はサイズが自明な型に置き換えてある。)"

#. type: Plain text
#: build/C/man5/elf.5:136
msgid ""
"All data structures that the file format defines follow the \"natural\" size "
"and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, and so on."
msgstr ""
"このファイルフォーマットが定義する全てのデータ構造体は、 関連するクラスの "
"\"自然な\" サイズと配置の指針に従う。 必要な場合、データ構造体では明示的なパ"
"ディング (padding, 詰め込み)  が行なわれる。これは 4 バイトオブジェクトに対す"
"る 4 バイト配置を保証するためや、 構造体のサイズを 4 の倍数にするためなどであ"
"る。"

#. type: SS
#: build/C/man5/elf.5:136
#, no-wrap
msgid "ELF header (Ehdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:141
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr "ELF ヘッダーは型 I<Elf32_Ehdr> または I<Elf64_Ehdr> で記述される:"

#. type: Plain text
#: build/C/man5/elf.5:145
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr "#define EI_NIDENT 16\n"

#. type: Plain text
#: build/C/man5/elf.5:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:167
msgid "The fields have the following meanings:"
msgstr "フィールドは以下の意味を持つ:"

#. type: TP
#: build/C/man5/elf.5:169
#, no-wrap
msgid "I<e_ident>"
msgstr "I<e_ident>"

#. type: Plain text
#: build/C/man5/elf.5:179
msgid ""
"This array of bytes specifies how to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is "
"named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr "このバイト配列は、プロセッサやファイルの他の部分には依存せずに、どのようにファイルを解釈 (interpret) するかを指定する。 この配列内のすべてのものは、接頭辞 B<EI_> で始まるマクロの名前が付き、接頭辞 B<ELF> で始まる値を持つ。 以下のマクロが定義されている:"

#. type: TP
#: build/C/man5/elf.5:180
#, no-wrap
msgid "B<EI_MAG0>"
msgstr "B<EI_MAG0>"

#. type: Plain text
#: build/C/man5/elf.5:186
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0: "
"0x7f)"
msgstr ""
"マジックナンバーの第 1 バイト。 B<ELFMAG0> で埋めなければならない。 (0: 0x7f)"

#. type: TP
#: build/C/man5/elf.5:186
#, no-wrap
msgid "B<EI_MAG1>"
msgstr "B<EI_MAG1>"

#. type: Plain text
#: build/C/man5/elf.5:192
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""
"マジックナンバーの第 2 バイト。 B<ELFMAG1> で埋めなければならない。 (1: "
"\\(aqE\\(aq)"

#. type: TP
#: build/C/man5/elf.5:192
#, no-wrap
msgid "B<EI_MAG2>"
msgstr "B<EI_MAG2>"

#. type: Plain text
#: build/C/man5/elf.5:198
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2: "
"\\(aqL\\(aq)"
msgstr ""
"マジックナンバーの第 3 バイト。 B<ELFMAG2> で埋めなければならない。 (2: "
"\\(aqL\\(aq)"

#. type: TP
#: build/C/man5/elf.5:198
#, no-wrap
msgid "B<EI_MAG3>"
msgstr "B<EI_MAG3>"

#. type: Plain text
#: build/C/man5/elf.5:204
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""
"マジックナンバーの第 4 バイト。 B<ELFMAG3> で埋めなければならない。 (3: "
"\\(aqF\\(aq)"

#. type: TP
#: build/C/man5/elf.5:204
#, no-wrap
msgid "B<EI_CLASS>"
msgstr "B<EI_CLASS>"

#. type: Plain text
#: build/C/man5/elf.5:207
msgid "The fifth byte identifies the architecture for this binary:"
msgstr "第 5 バイトは、このバイナリのアーキテクチャーを示す:"

#. type: TP
#: build/C/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr "B<ELFCLASSNONE>"

#. type: Plain text
#: build/C/man5/elf.5:212
msgid "This class is invalid."
msgstr "このクラスは不正である。"

#. type: TP
#: build/C/man5/elf.5:212
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr "B<ELFCLASS32>"

#. type: Plain text
#: build/C/man5/elf.5:217
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""
"32 ビットアーキテクチャーを定義する。 ファイルと仮想アドレス空間が 4 ギガバイ"
"トまでのマシンをサポートする。"

#. type: TP
#: build/C/man5/elf.5:217
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr "B<ELFCLASS64>"

#. type: Plain text
#: build/C/man5/elf.5:220
msgid "This defines the 64-bit architecture."
msgstr "64 ビットアーキテクチャーを定義する。"

#. type: TP
#: build/C/man5/elf.5:222
#, no-wrap
msgid "B<EI_DATA>"
msgstr "B<EI_DATA>"

#. type: Plain text
#: build/C/man5/elf.5:227
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in "
"the file.  Currently, these encodings are supported:"
msgstr ""
"第 6 バイトはファイル内のプロセッサ固有データの データエンコーディングを指定"
"する。 現在のところ以下のエンコーディングがサポートされている:"

#. type: TP
#: build/C/man5/elf.5:228
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr "B<ELFDATANONE>"

#. type: Plain text
#: build/C/man5/elf.5:232
msgid "Unknown data format."
msgstr "不明なデータフォーマット。"

#. type: TP
#: build/C/man5/elf.5:232
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr "B<ELFDATA2LSB>"

#. type: Plain text
#: build/C/man5/elf.5:235
msgid "Two's complement, little-endian."
msgstr "2 の補数、リトルエンディアン。"

#. type: TP
#: build/C/man5/elf.5:235
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr "B<ELFDATA2MSB>"

#. type: Plain text
#: build/C/man5/elf.5:238
msgid "Two's complement, big-endian."
msgstr "2 の補数、ビッグエンディアン。"

#. type: TP
#: build/C/man5/elf.5:240
#, no-wrap
msgid "B<EI_VERSION>"
msgstr "B<EI_VERSION>"

#. type: Plain text
#: build/C/man5/elf.5:243
msgid "The seventh byte is the version number of the ELF specification:"
msgstr "第 7 バイトは ELF 仕様のバージョン番号である:"

#. type: TP
#: build/C/man5/elf.5:246 build/C/man5/elf.5:492
#, no-wrap
msgid "B<EV_NONE>"
msgstr "B<EV_NONE>"

#. type: Plain text
#: build/C/man5/elf.5:249
msgid "Invalid version."
msgstr "不正なバージョン。"

#. type: TP
#: build/C/man5/elf.5:249 build/C/man5/elf.5:496
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr "B<EV_CURRENT>"

#. type: Plain text
#: build/C/man5/elf.5:252
msgid "Current version."
msgstr "現在のバージョン。"

#. type: TP
#: build/C/man5/elf.5:255
#, no-wrap
msgid "B<EI_OSABI>"
msgstr "B<EI_OSABI>"

#. type: Plain text
#: build/C/man5/elf.5:263
msgid ""
"The eighth byte identifies the operating system and ABI to which the object "
"is targeted.  Some fields in other ELF structures have flags and values that "
"have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  For example:"
msgstr ""
"第 8 バイトはオブジェクトのターゲットとなるオペレーティングシステムと ABI を"
"示す。他の ELF 構造体のフィールドには、プラットフォーム固有の意味を持つフラグ"
"や値を持つものもある。これらのフィールドの解釈は、このバイトの値によって決定"
"される。以下に例を挙げる。"

#. type: TP
#: build/C/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr "B<ELFOSABI_NONE>"

#.  0
#. type: Plain text
#: build/C/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr "ELFOSABI_SYSV と同じ。"

#. type: TP
#: build/C/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr "B<ELFOSABI_SYSV>"

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: build/C/man5/elf.5:274
msgid "UNIX System V ABI"
msgstr "UNIX System V ABI"

#. type: TP
#: build/C/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr "B<ELFOSABI_HPUX>"

#.  1
#. type: Plain text
#: build/C/man5/elf.5:278
msgid "HP-UX ABI"
msgstr "HP-UX ABI"

#. type: TP
#: build/C/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr "B<ELFOSABI_NETBSD>"

#.  2
#. type: Plain text
#: build/C/man5/elf.5:282
msgid "NetBSD ABI"
msgstr "NetBSD ABI"

#. type: TP
#: build/C/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr "B<ELFOSABI_LINUX>"

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI
#.  5
#. type: Plain text
#: build/C/man5/elf.5:294
msgid "Linux ABI"
msgstr "Linux ABI"

#. type: TP
#: build/C/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr "B<ELFOSABI_SOLARIS>"

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI
#.  Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: build/C/man5/elf.5:304
msgid "Solaris ABI"
msgstr "Solaris ABI"

#. type: TP
#: build/C/man5/elf.5:304
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr "B<ELFOSABI_IRIX>"

#.  8
#. type: Plain text
#: build/C/man5/elf.5:308
msgid "IRIX ABI"
msgstr "IRIX ABI"

#. type: TP
#: build/C/man5/elf.5:308
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr "B<ELFOSABI_FREEBSD>"

#.  9
#. type: Plain text
#: build/C/man5/elf.5:312
msgid "FreeBSD ABI"
msgstr "FreeBSD ABI"

#. type: TP
#: build/C/man5/elf.5:312
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr "B<ELFOSABI_TRU64>"

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: build/C/man5/elf.5:320
msgid "TRU64 UNIX ABI"
msgstr "TRU64 UNIX ABI"

#. type: TP
#: build/C/man5/elf.5:320
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr "B<ELFOSABI_ARM>"

#.  97
#. type: Plain text
#: build/C/man5/elf.5:324
msgid "ARM architecture ABI"
msgstr "ARM アーキテクチャー ABI"

#. type: TP
#: build/C/man5/elf.5:324
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr "B<ELFOSABI_STANDALONE>"

#.  255
#. type: Plain text
#: build/C/man5/elf.5:328
msgid "Stand-alone (embedded) ABI"
msgstr "スタンドアロン (組み込み) ABI"

#. type: TP
#: build/C/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr "B<EI_ABIVERSION>"

#. type: Plain text
#: build/C/man5/elf.5:340
msgid ""
"The ninth byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""
"第 9 バイトはオブジェクトがターゲットとしている ABI のバージョンを示す。 この"
"フィールドは互換性のない ABI のバージョンを区別するために使われる。 このバー"
"ジョン番号の解釈は、 B<EI_OSABI> フィールドで識別される ABI に依存する。 この"
"仕様に準拠するアプリケーションでは、値 0 を使う。"

#. type: TP
#: build/C/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr "B<EI_PAD>"

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: build/C/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which "
"read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""
"パディングの開始。 これらのバイトは予約されており、0 に設定されている。 これ"
"らを読み込むプログラムは、これらのバイトを無視すべきである。 現在使われていな"
"いバイトに意味が与えられる場合、 B<EI_PAD> の値は将来変更されるかもしれない。"

#. type: TP
#: build/C/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr "B<EI_NIDENT>"

#. type: Plain text
#: build/C/man5/elf.5:361
msgid "The size of the I<e_ident> array."
msgstr "I<e_ident> 配列のサイズ。"

#. type: TP
#: build/C/man5/elf.5:362
#, no-wrap
msgid "I<e_type>"
msgstr "I<e_type>"

#. type: Plain text
#: build/C/man5/elf.5:365
msgid "This member of the structure identifies the object file type:"
msgstr "この構造体のメンバはオブジェクトファイルタイプを示す:"

#. type: TP
#: build/C/man5/elf.5:366
#, no-wrap
msgid "B<ET_NONE>"
msgstr "B<ET_NONE>"

#. type: Plain text
#: build/C/man5/elf.5:370
msgid "An unknown type."
msgstr "不明なタイプ。"

#. type: TP
#: build/C/man5/elf.5:370
#, no-wrap
msgid "B<ET_REL>"
msgstr "B<ET_REL>"

#. type: Plain text
#: build/C/man5/elf.5:373
msgid "A relocatable file."
msgstr "再配置可能ファイル。"

#. type: TP
#: build/C/man5/elf.5:373
#, no-wrap
msgid "B<ET_EXEC>"
msgstr "B<ET_EXEC>"

#. type: Plain text
#: build/C/man5/elf.5:376
msgid "An executable file."
msgstr "実行可能ファイル。"

#. type: TP
#: build/C/man5/elf.5:376
#, no-wrap
msgid "B<ET_DYN>"
msgstr "B<ET_DYN>"

#. type: Plain text
#: build/C/man5/elf.5:379
msgid "A shared object."
msgstr "共有オブジェクト。"

#. type: TP
#: build/C/man5/elf.5:379
#, no-wrap
msgid "B<ET_CORE>"
msgstr "B<ET_CORE>"

#. type: Plain text
#: build/C/man5/elf.5:382
msgid "A core file."
msgstr "コアファイル。"

#. type: TP
#: build/C/man5/elf.5:384
#, no-wrap
msgid "I<e_machine>"
msgstr "I<e_machine>"

#. type: Plain text
#: build/C/man5/elf.5:388
msgid ""
"This member specifies the required architecture for an individual file.  For "
"example:"
msgstr ""
"このメンバは個々のファイルに必要とされるアーキテクチャーを指定する。 例:"

#. type: TP
#: build/C/man5/elf.5:389
#, no-wrap
msgid "B<EM_NONE>"
msgstr "B<EM_NONE>"

#.  0
#. type: Plain text
#: build/C/man5/elf.5:394
msgid "An unknown machine"
msgstr "不明なマシン"

#. type: TP
#: build/C/man5/elf.5:394
#, no-wrap
msgid "B<EM_M32>"
msgstr "B<EM_M32>"

#.  1
#. type: Plain text
#: build/C/man5/elf.5:398
msgid "AT&T WE 32100"
msgstr "AT&T WE 32100"

#. type: TP
#: build/C/man5/elf.5:398
#, no-wrap
msgid "B<EM_SPARC>"
msgstr "B<EM_SPARC>"

#.  2
#. type: Plain text
#: build/C/man5/elf.5:402
msgid "Sun Microsystems SPARC"
msgstr "Sun Microsystems SPARC"

#. type: TP
#: build/C/man5/elf.5:402
#, no-wrap
msgid "B<EM_386>"
msgstr "B<EM_386>"

#.  3
#. type: Plain text
#: build/C/man5/elf.5:406
msgid "Intel 80386"
msgstr "Intel 80386"

#. type: TP
#: build/C/man5/elf.5:406
#, no-wrap
msgid "B<EM_68K>"
msgstr "B<EM_68K>"

#.  4
#. type: Plain text
#: build/C/man5/elf.5:410
msgid "Motorola 68000"
msgstr "Motorola 68000"

#. type: TP
#: build/C/man5/elf.5:410
#, no-wrap
msgid "B<EM_88K>"
msgstr "B<EM_88K>"

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486
#.  6
#. type: Plain text
#: build/C/man5/elf.5:418
msgid "Motorola 88000"
msgstr "Motorola 88000"

#. type: TP
#: build/C/man5/elf.5:418
#, no-wrap
msgid "B<EM_860>"
msgstr "B<EM_860>"

#.  7
#. type: Plain text
#: build/C/man5/elf.5:422
msgid "Intel 80860"
msgstr "Intel 80860"

#. type: TP
#: build/C/man5/elf.5:422
#, no-wrap
msgid "B<EM_MIPS>"
msgstr "B<EM_MIPS>"

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: build/C/man5/elf.5:434
msgid "MIPS RS3000 (big-endian only)"
msgstr "MIPS RS3000 (ビッグエンディアンのみ)"

#. type: TP
#: build/C/man5/elf.5:434
#, no-wrap
msgid "B<EM_PARISC>"
msgstr "B<EM_PARISC>"

#.  15
#. type: Plain text
#: build/C/man5/elf.5:438
msgid "HP/PA"
msgstr "HP/PA"

#. type: TP
#: build/C/man5/elf.5:438
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr "B<EM_SPARC32PLUS>"

#.  18
#. type: Plain text
#: build/C/man5/elf.5:442
msgid "SPARC with enhanced instruction set"
msgstr "拡張命令セット付き SPARC"

#. type: TP
#: build/C/man5/elf.5:442
#, no-wrap
msgid "B<EM_PPC>"
msgstr "B<EM_PPC>"

#.  20
#. type: Plain text
#: build/C/man5/elf.5:446
msgid "PowerPC"
msgstr "PowerPC"

#. type: TP
#: build/C/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC64>"
msgstr "B<EM_PPC64>"

#.  21
#. type: Plain text
#: build/C/man5/elf.5:450
msgid "PowerPC 64-bit"
msgstr "PowerPC 64-bit"

#. type: TP
#: build/C/man5/elf.5:450
#, no-wrap
msgid "B<EM_S390>"
msgstr "B<EM_S390>"

#.  22
#. type: Plain text
#: build/C/man5/elf.5:454
msgid "IBM S/390"
msgstr "IBM S/390"

#. type: TP
#: build/C/man5/elf.5:454
#, no-wrap
msgid "B<EM_ARM>"
msgstr "B<EM_ARM>"

#.  40
#. type: Plain text
#: build/C/man5/elf.5:458
msgid "Advanced RISC Machines"
msgstr "Advanced RISC Machines"

#. type: TP
#: build/C/man5/elf.5:458
#, no-wrap
msgid "B<EM_SH>"
msgstr "B<EM_SH>"

#.  42
#. type: Plain text
#: build/C/man5/elf.5:462
msgid "Renesas SuperH"
msgstr "Renesas SuperH"

#. type: TP
#: build/C/man5/elf.5:462
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr "B<EM_SPARCV9>"

#.  43
#. type: Plain text
#: build/C/man5/elf.5:466
msgid "SPARC v9 64-bit"
msgstr "SPARC v9 64-bit"

#. type: TP
#: build/C/man5/elf.5:466
#, no-wrap
msgid "B<EM_IA_64>"
msgstr "B<EM_IA_64>"

#.  50
#. type: Plain text
#: build/C/man5/elf.5:470
msgid "Intel Itanium"
msgstr "Intel Itanium"

#. type: TP
#: build/C/man5/elf.5:470
#, no-wrap
msgid "B<EM_X86_64>"
msgstr "B<EM_X86_64>"

#.  62
#. type: Plain text
#: build/C/man5/elf.5:474
msgid "AMD x86-64"
msgstr "AMD x86-64"

#. type: TP
#: build/C/man5/elf.5:474
#, no-wrap
msgid "B<EM_VAX>"
msgstr "B<EM_VAX>"

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set
#. type: Plain text
#: build/C/man5/elf.5:486
msgid "DEC Vax"
msgstr "DEC Vax"

#. type: TP
#: build/C/man5/elf.5:488
#, no-wrap
msgid "I<e_version>"
msgstr "I<e_version>"

#. type: Plain text
#: build/C/man5/elf.5:491
msgid "This member identifies the file version:"
msgstr "このメンバはファイルバージョンを示す:"

#. type: Plain text
#: build/C/man5/elf.5:496
msgid "Invalid version"
msgstr "不正なバージョン"

#. type: Plain text
#: build/C/man5/elf.5:499
msgid "Current version"
msgstr "現在のバージョン"

#. type: TP
#: build/C/man5/elf.5:501
#, no-wrap
msgid "I<e_entry>"
msgstr "I<e_entry>"

#. type: Plain text
#: build/C/man5/elf.5:507
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""
"このメンバは、システムが最初に制御を渡す、 つまりプロセスを開始する仮想アドレ"
"スを指定する。 ファイルにエントリーポイントが関連付けられていない場合、 この"
"メンバには 0 が入る。"

#. type: TP
#: build/C/man5/elf.5:507
#, no-wrap
msgid "I<e_phoff>"
msgstr "I<e_phoff>"

#. type: Plain text
#: build/C/man5/elf.5:512
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""
"このメンバはプログラムヘッダーテーブルの ファイルオフセット (バイト単位) を保"
"持する。 ファイルにプログラムヘッダーテーブルがない場合、 このメンバには 0 が"
"入る。"

#. type: TP
#: build/C/man5/elf.5:512
#, no-wrap
msgid "I<e_shoff>"
msgstr "I<e_shoff>"

#. type: Plain text
#: build/C/man5/elf.5:517
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table, this member holds zero."
msgstr ""
"このメンバはセクションヘッダーテーブルの ファイルオフセット (バイト単位) を保"
"持する。 ファイルにセクションヘッダーテーブルがない場合、 このメンバには 0 が"
"入る。"

#. type: TP
#: build/C/man5/elf.5:517
#, no-wrap
msgid "I<e_flags>"
msgstr "I<e_flags>"

#. type: Plain text
#: build/C/man5/elf.5:522
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently, no flags have been "
"defined."
msgstr ""
"このメンバはファイルに関連付けられたプロセッサ固有のフラグを保持する。 フラグ"
"の名前は EF_`machine_flag' という形式である。 現在のところフラグは定義されて"
"いない。"

#. type: TP
#: build/C/man5/elf.5:522
#, no-wrap
msgid "I<e_ehsize>"
msgstr "I<e_ehsize>"

#. type: Plain text
#: build/C/man5/elf.5:525
msgid "This member holds the ELF header's size in bytes."
msgstr "このメンバは ELF ヘッダーサイズ (バイト単位) を保持する。"

#. type: TP
#: build/C/man5/elf.5:525
#, no-wrap
msgid "I<e_phentsize>"
msgstr "I<e_phentsize>"

#. type: Plain text
#: build/C/man5/elf.5:529
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""
"このメンバはこのファイルのプログラムヘッダーテーブルの 1 エントリーあたりのサ"
"イズ (バイト単位) を保持する; 全てのエントリーは同じサイズである。"

#. type: TP
#: build/C/man5/elf.5:529
#, no-wrap
msgid "I<e_phnum>"
msgstr "I<e_phnum>"

#. type: Plain text
#: build/C/man5/elf.5:542
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""
"このメンバはプログラムヘッダーテーブルにあるエントリーの数を保持する。 よっ"
"て I<e_phentsize> と I<e_phnum> の積がテーブルサイズ (バイト単位) になる。 "
"ファイルにプログラムヘッダーがない場合、 I<e_phnum> は値 0 を保持する。"

#.  This is a Linux extension, added in Linux 2.6.34.
#. type: Plain text
#: build/C/man5/elf.5:556
msgid ""
"If the number of entries in the program header table is larger than or equal "
"to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""
"プログラムヘッダーテーブルのエントリー数が B<PN_XNUM> (0xffff) 以上の場合、\n"
"このメンバは B<PN_XNUM> (0xffff) になり、プログラムヘッダーテーブルの\n"
"エントリーの実際の数は、セクションヘッダーテーブルの最初のエントリーの \n"
"I<sh_info> メンバに格納される。それ以外の場合、セクションヘッダーテーブルの\n"
"最初のエントリーの I<sh_info> メンバには値 0 が格納される。"

#. type: TP
#: build/C/man5/elf.5:557
#, no-wrap
msgid "B<PN_XNUM>"
msgstr "B<PN_XNUM>"

#. type: Plain text
#: build/C/man5/elf.5:562
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""
"I<e_phnum> が保持できる最大値を表し、 0xffff に定義されている。 I<e_phnum> \n"
"はプログラムヘッダーの実際の数がどこに割り当てられているかを示す。"

#. type: TP
#: build/C/man5/elf.5:564
#, no-wrap
msgid "I<e_shentsize>"
msgstr "I<e_shentsize>"

#. type: Plain text
#: build/C/man5/elf.5:569
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""
"このメンバはセクションヘッダーのサイズ (バイト単位) を保持する。 セクション"
"ヘッダーはセクションヘッダーテーブルの 1 つのエントリーである; 全てのエント"
"リーは同じサイズである。"

#. type: TP
#: build/C/man5/elf.5:569
#, no-wrap
msgid "I<e_shnum>"
msgstr "I<e_shnum>"

#. type: Plain text
#: build/C/man5/elf.5:582
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""
"このメンバはセクションヘッダーテーブルにあるエントリーの数を保持する。 よっ"
"て I<e_shentsize> と I<e_shnum> の積はセクションヘッダーテーブルのサイズ (バ"
"イト単位) になる。 ファイルにセクションヘッダーテーブルがない場合、 "
"I<e_shnum> は値 0 を保持する。"

#. type: Plain text
#: build/C/man5/elf.5:596
msgid ""
"If the number of entries in the section header table is larger than or equal "
"to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the "
"value zero."
msgstr ""
"セクションヘッダーテーブルのエントリー数が B<SHN_LORESERVE> (0xff00) 以上の場"
"合、\n"
"I<e_shnum> には値 0 が入り、セクションヘッダーテーブルのエントリーの実際の数"
"は\n"
"セクションヘッダーテーブルの最初のエントリーの I<sh_size> メンバに格納され"
"る。\n"
"それ以外の場合、セクションヘッダーテーブルの最初のエントリーの I<sh_info> メ"
"ンバ\n"
"には値 0 が格納される。"

#. type: TP
#: build/C/man5/elf.5:596
#, no-wrap
msgid "I<e_shstrndx>"
msgstr "I<e_shstrndx>"

#. type: Plain text
#: build/C/man5/elf.5:603
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""
"このメンバはセクション名文字列テーブルに関連付けられたエントリーの セクション"
"ヘッダーテーブルインデックスを保持する。 ファイルにセクション名文字列テーブル"
"がない場合、 このメンバは値 B<SHN_UNDEF> を保持する。 B<SHN_UNDEF>."

#. type: Plain text
#: build/C/man5/elf.5:617
msgid ""
"If the index of section name string table section is larger than or equal to "
"B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the "
"real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table.  Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""
"セクション名前文字列テーブルのインデックスが B<SHN_LORESERVE> (0xff00) 以上"
"の\n"
"場合、このメンバには B<SHN_XINDEX> (0xffff) が入り、セクション名前文字列\n"
"テーブルの実際のインデックスはセクションヘッダーテーブルの最初のエントリー"
"の\n"
"I<sh_link> メンバに格納される。それ以外の場合、セクションヘッダーテーブルの\n"
"最初のエントリーの I<sh_link> メンバには値 0 が格納される。"

#. type: SS
#: build/C/man5/elf.5:617
#, no-wrap
msgid "Program header (Phdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:636
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable "
"and shared object files.  A file specifies its own program header size with "
"the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""
"実行可能ファイルまたは共有オブジェクトファイルのプログラムヘッダーテーブル"
"は、 システムによるプログラム実行準備に必要な、 セグメント等の情報を記述する"
"構造体の配列である。 オブジェクトファイルの I<セグメント> には 1 つ以上の I<"
"セクション> が含まれる。 プログラムヘッダーは実行可能ファイルと共有オブジェク"
"トファイルでのみ意味を持つ。 ファイルは自身のプログラムヘッダーサイズを ELF "
"ヘッダーの I<e_phentsize> メンバと I<e_phnum> メンバで指定する。 ELF プログラ"
"ムヘッダーは I<Elf32_Phdr> 型または I<Elf64_Phdr> 型で記述される (どちらにな"
"るかはアーキテクチャー依存):"

#. type: Plain text
#: build/C/man5/elf.5:649
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:664
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:671
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in "
"the location of the I<p_flags> member in the total struct."
msgstr ""
"32 ビットと 64 ビットのプログラムヘッダーの主な違いは、構造体における "
"I<p_flags> メンバの位置にある。"

#. type: TP
#: build/C/man5/elf.5:671
#, no-wrap
msgid "I<p_type>"
msgstr "I<p_type>"

#. type: Plain text
#: build/C/man5/elf.5:675
msgid ""
"This member of the structure indicates what kind of segment this array "
"element describes or how to interpret the array element's information."
msgstr "構造体のこのメンバは、 この配列要素がどのような種類のセグメントを記述しているか、 またはこの配列要素の情報をどのように解釈するか、を表す。"

#. type: TP
#: build/C/man5/elf.5:676
#, no-wrap
msgid "B<PT_NULL>"
msgstr "B<PT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:680
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""
"この配列要素は使用されておらず、その他のメンバの値は未定義である。 これによ"
"り、このプログラムヘッダーのエントリーは無視される。"

#. type: TP
#: build/C/man5/elf.5:680
#, no-wrap
msgid "B<PT_LOAD>"
msgstr "B<PT_LOAD>"

#. type: Plain text
#: build/C/man5/elf.5:701
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and "
"I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header "
"table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""
"この配列要素は I<p_filesz> と I<p_memsz> で記述されるロード可能セグメントを指"
"定する。 このファイルからのバイトデータが、このメモリーセグメントの先頭から"
"マップされる。 セグメントのメモリーサイズ I<Sy>p_memsz がファイルサイズ "
"I<Sy>p_filesz より大きい場合、 「余った」バイトは値 0 となり、 そのセグメント"
"初期化データの後ろに置かれると定められている。 ファイルサイズはメモリーサイズ"
"より大きくてはいけない。 プログラムヘッダーテーブルのロード可能セグメントエン"
"トリーは、 I<p_vaddr> メンバの昇順にソートされて出現する。"

#. type: TP
#: build/C/man5/elf.5:701
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr "B<PT_DYNAMIC>"

#. type: Plain text
#: build/C/man5/elf.5:704
msgid "The array element specifies dynamic linking information."
msgstr "この配列要素は動的リンク情報を指定する。"

#. type: TP
#: build/C/man5/elf.5:704
#, no-wrap
msgid "B<PT_INTERP>"
msgstr "B<PT_INTERP>"

#. type: Plain text
#: build/C/man5/elf.5:712
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""
"この配列要素は、インタープリターとして起動されるパス名 (ヌル文字終端)  の位置"
"とサイズを指定する。 このセグメント型は (共有オブジェクトにもあるかも知れない"
"が)  実行可能ファイルでのみ意味を持つ。 ただし、このセグメント型は 1 つのファ"
"イルに 2 回以上出現してはならない。 もし存在する場合、このセグメント型は 全て"
"のロード可能セグメントエントリーより前になければならない。"

#. type: TP
#: build/C/man5/elf.5:712
#, no-wrap
msgid "B<PT_NOTE>"
msgstr "B<PT_NOTE>"

#. type: Plain text
#: build/C/man5/elf.5:715
#, fuzzy
#| msgid ""
#| "The array element specifies the location and size for auxiliary "
#| "information."
msgid "The array element specifies the location of notes (ElfN_Nhdr)."
msgstr ""
"この配列要素は補足情報 (auxiliary information) の位置とサイズを指定する。"

#. type: TP
#: build/C/man5/elf.5:715
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr "B<PT_SHLIB>"

#. type: Plain text
#: build/C/man5/elf.5:720
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""
"このセグメント型は予約されているが、意味は指定されていない。 この型の配列要素"
"を保持するプログラムは ABI に準拠しない。"

#. type: TP
#: build/C/man5/elf.5:720
#, no-wrap
msgid "B<PT_PHDR>"
msgstr "B<PT_PHDR>"

#. type: Plain text
#: build/C/man5/elf.5:730
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the "
"program.  This segment type may not occur more than once in a file.  "
"Moreover, it may occur only if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable "
"segment entry."
msgstr ""
"この配列要素は、もし存在しているならば、 ファイルおよびプログラムのメモリーイ"
"メージ双方における プログラムヘッダーテーブル自身の位置とサイズを指定する。 "
"このセグメント型は 1 つのファイルに 2 回以上出現してはならない。 さらに、この"
"セグメント型が存在してもよいのは、プログラムヘッダーテーブルが プログラムのメ"
"モリーイメージの一部である場合のみである。 もし存在する場合、これは全てのロー"
"ド可能セグメントエントリーより 前になければならない。"

#. type: TP
#: build/C/man5/elf.5:730
#, no-wrap
msgid "B<PT_LOPROC>, B<PT_HIPROC>"
msgstr "B<PT_LOPROC>, B<PT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:735
#, fuzzy
#| msgid ""
#| "Values less than or equal to B<PT_LOPROC> are reserved for processor-"
#| "specific semantics."
msgid ""
"Values in the inclusive range [B<PT_LOPROC>, B<PT_HIPROC>] are reserved for "
"processor-specific semantics."
msgstr ""
"この値以下で B<PT_LOPROC> 以上の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:735
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr "B<PT_GNU_STACK>"

#. type: Plain text
#: build/C/man5/elf.5:741
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""
"GNU 拡張であり、Linux カーネルが I<p_flags> のメンバーにセットされたフラグ経"
"由でスタックの状態を制御するために使用する。"

#. type: TP
#: build/C/man5/elf.5:742
#, no-wrap
msgid "I<p_offset>"
msgstr "I<p_offset>"

#. type: Plain text
#: build/C/man5/elf.5:746
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""
"このメンバは、セグメントの先頭バイトがある (ファイル先頭からの) オフセットを"
"保持する。"

#. type: TP
#: build/C/man5/elf.5:746
#, no-wrap
msgid "I<p_vaddr>"
msgstr "I<p_vaddr>"

#. type: Plain text
#: build/C/man5/elf.5:750
msgid ""
"This member holds the virtual address at which the first byte of the segment "
"resides in memory."
msgstr ""
"このメンバは、セグメントの先頭バイトがある メモリーの仮想アドレスを保持する。"

#. type: TP
#: build/C/man5/elf.5:750
#, no-wrap
msgid "I<p_paddr>"
msgstr "I<p_paddr>"

#. type: Plain text
#: build/C/man5/elf.5:758
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""
"物理アドレスが意味をもつシステムでは、 このメンバはセグメントの物理アドレスと"
"して予約されている。 BSD ではこのメンバは使用されない。0 でなければならない。"

#. type: TP
#: build/C/man5/elf.5:758
#, no-wrap
msgid "I<p_filesz>"
msgstr "I<p_filesz>"

#. type: Plain text
#: build/C/man5/elf.5:762
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""
"このメンバはセグメントのファイルイメージのバイト数を保持する。 これは 0 でも"
"よい。"

#. type: TP
#: build/C/man5/elf.5:762
#, no-wrap
msgid "I<p_memsz>"
msgstr "I<p_memsz>"

#. type: Plain text
#: build/C/man5/elf.5:766
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""
"このメンバはセグメントのメモリーイメージのバイト数を保持する。 これは 0 でも"
"よい。"

#. type: TP
#: build/C/man5/elf.5:766
#, no-wrap
msgid "I<p_flags>"
msgstr "I<p_flags>"

#. type: Plain text
#: build/C/man5/elf.5:769
msgid "This member holds a bit mask of flags relevant to the segment:"
msgstr "このメンバはセグメントに関連するフラグのビットマスクを保持する:"

#. type: TP
#: build/C/man5/elf.5:770
#, no-wrap
msgid "B<PF_X>"
msgstr "B<PF_X>"

#. type: Plain text
#: build/C/man5/elf.5:774
msgid "An executable segment."
msgstr "実行可能セグメント。"

#. type: TP
#: build/C/man5/elf.5:774
#, no-wrap
msgid "B<PF_W>"
msgstr "B<PF_W>"

#. type: Plain text
#: build/C/man5/elf.5:777
msgid "A writable segment."
msgstr "書き込み可能セグメント."

#. type: TP
#: build/C/man5/elf.5:777
#, no-wrap
msgid "B<PF_R>"
msgstr "B<PF_R>"

#. type: Plain text
#: build/C/man5/elf.5:780
msgid "A readable segment."
msgstr "読み込み可能セグメント。"

#. type: Plain text
#: build/C/man5/elf.5:791
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_W> and B<PF_R>."
msgstr "テキストセグメントは一般にフラグ B<PF_X> と B<PF_R> を持つ。 データセグメントは一般に B<PF_W>, B<PF_R> を持つ。"

#. type: TP
#: build/C/man5/elf.5:791
#, no-wrap
msgid "I<p_align>"
msgstr "I<p_align>"

#. type: Plain text
#: build/C/man5/elf.5:810
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""
"このメンバは、セグメントがメモリーおよびファイルにおいて配置 (align)  される"
"値を保持する。 ロード可能プロセスセグメントは、ページサイズを法として "
"I<p_vaddr> と I<p_offset> と合同でなければならない (訳注:「p_vaddr mod ページ"
"サイズ = p_offset mod ページサイズ」 でなければならない)。。 0 と 1 という値"
"は配置が必要ないことを意味する。 それ以外の場合、 I<p_align> は正で 2 の整数"
"乗でなければならず、 I<p_vaddr> は I<p_align> を法として I<p_offset> と合同で"
"なければならない (訳注:「p_vaddr mod p_align = p_offset mod p_align」でなけれ"
"ばならない)。"

#. type: SS
#: build/C/man5/elf.5:810
#, no-wrap
msgid "Section header (Shdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:827
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the "
"number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""
"ファイルのセクションヘッダーテーブルには、 全てのファイルセクションの場所が記"
"述されている。 セクションヘッダーテーブルは I<Elf32_Shdr> 構造体または "
"I<Elf64_Shdr> 構造体の配列である。 ELF ヘッダーの I<e_shoff> メンバはファイル"
"の先頭から セクションヘッダーテーブルへのバイトオフセットである。 I<e_shnum> "
"はセクションヘッダーテーブルに含まれるエントリーの数を保持する。 "
"I<e_shentsize> は各エントリーのサイズ (バイト単位) を保持する。"

#. type: Plain text
#: build/C/man5/elf.5:843
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between "
"B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum>, and I<e_shstrndx>; in other cases, "
"each field in the initial entry is set to zero.  An object file does not "
"have sections for these special indices:"
msgstr "セクションヘッダーテーブルインデックスは、この配列の添字である。いくつかのセクションヘッダーテーブルインデックスは予約されている。予約されているのは、最初のエントリーと、B<SHN_LORESERVE> と B<SHN_HIRESERVE> の間のインデックスである。最初のエントリーは、ELF 拡張で I<e_phnum>, I<e_shnum>, I<e_shstrndx> に使用される。それ以外の場合、最初のエントリーの各フィールドには 0 が設定される。オブジェクトファイルにはこれらの特別なインデックスに対応するセクションはない。"

#. type: TP
#: build/C/man5/elf.5:843
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr "B<SHN_UNDEF>"

#. type: Plain text
#: build/C/man5/elf.5:847
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless "
"section reference."
msgstr ""
"この値は、未定義 (undefined)、不足 (missing)、無関係 (irrelevant)、その他無意"
"味なセクション参照を示す。"

#. type: TP
#: build/C/man5/elf.5:847
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr "B<SHN_LORESERVE>"

#. type: Plain text
#: build/C/man5/elf.5:850
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr "この値は予約済みのインデックス領域の下限を指定する。"

#. type: TP
#: build/C/man5/elf.5:850
#, no-wrap
msgid "B<SHN_LOPROC>, B<SHN_HIPROC>"
msgstr "B<SHN_LOPROC>, B<SHN_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:855
#, fuzzy
#| msgid ""
#| "Values greater than or equal to B<SHN_HIPROC> are reserved for processor-"
#| "specific semantics."
msgid ""
"Values greater in the inclusive range [B<SHN_LOPROC>, B<SHN_HIPROC>] are "
"reserved for processor-specific semantics."
msgstr ""
"この値以上で B<SHN_HIPROC> 以下の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:855
#, no-wrap
msgid "B<SHN_ABS>"
msgstr "B<SHN_ABS>"

#. type: Plain text
#: build/C/man5/elf.5:862
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""
"この値は対応する参照の絶対値を指定する。 例えば、セクション番号 B<SHN_ABS> に"
"関連して定義されているシンボルは、 絶対値を保持しているので、再配置に影響され"
"ない。"

#. type: TP
#: build/C/man5/elf.5:862
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr "B<SHN_COMMON>"

#. type: Plain text
#: build/C/man5/elf.5:866
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN "
"COMMON or unallocated C external variables."
msgstr ""
"このセクションに関連して定義されているシンボルは、 FORTRAN の COMMON や C の"
"未割り当て外部変数のような共通シンボルである。"

#. type: TP
#: build/C/man5/elf.5:866
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr "B<SHN_HIRESERVE>"

#. type: Plain text
#: build/C/man5/elf.5:877
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""
"この値は予約済みのインデックス領域の上限を指定する。 システムは "
"B<SHN_LORESERVE> と B<SHN_HIRESERVE> を含む範囲を予約する。 セクションヘッ"
"ダーテーブルは予約されたインデックスに対応するエントリーを持たない。"

#. type: Plain text
#: build/C/man5/elf.5:879
msgid "The section header has the following structure:"
msgstr "セクションヘッダーは以下の構造体を持つ:"

#. type: Plain text
#: build/C/man5/elf.5:894
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:911
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:915
msgid ""
"No real differences exist between the 32-bit and 64-bit section headers."
msgstr "32 ビットと 64 ビットのセクションヘッダーには実際の違いはない。"

#. type: TP
#: build/C/man5/elf.5:915
#, no-wrap
msgid "I<sh_name>"
msgstr "I<sh_name>"

#. type: Plain text
#: build/C/man5/elf.5:921
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a null-"
"terminated string."
msgstr ""
"このメンバはセクション名を定める。 この値はセクションヘッダー文字列テーブルセ"
"クションのインデックスであり、 ヌル文字で終端された文字列の場所を示す。"

#. type: TP
#: build/C/man5/elf.5:921
#, no-wrap
msgid "I<sh_type>"
msgstr "I<sh_type>"

#. type: Plain text
#: build/C/man5/elf.5:924
msgid "This member categorizes the section's contents and semantics."
msgstr "このメンバはセクションの内容と意味が含まれるカテゴリーを示す。"

#. type: TP
#: build/C/man5/elf.5:925
#, no-wrap
msgid "B<SHT_NULL>"
msgstr "B<SHT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:932
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""
"この値はセクションヘッダーが不活性であることを示す。 これは関連するセクション"
"を持たない。 このセクションヘッダーの他のメンバは、未定義の値を持つ。"

#. type: TP
#: build/C/man5/elf.5:932
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr "B<SHT_PROGBITS>"

#. type: Plain text
#: build/C/man5/elf.5:936
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""
"このセクションはプログラムにより定義される情報を保持する。 この情報の形式と意"
"味は、ひとえにプログラムによって決定される。"

#. type: TP
#: build/C/man5/elf.5:936
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr "B<SHT_SYMTAB>"

#. type: Plain text
#: build/C/man5/elf.5:949
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""
"このセクションはシンボルテーブルを保持する。 一般には B<SHT_SYMTAB> はリンク"
"編集のためのシンボルを提供するが、 動的リンクにも使われる。 完全なシンボル"
"テーブルとして、動的リンクには不要な 多くのシンボルを保持できる。 オブジェク"
"トファイルも B<SHT_DYNSYM> セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:949
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr "B<SHT_STRTAB>"

#. type: Plain text
#: build/C/man5/elf.5:954
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""
"このセクションは文字列テーブルを保持する。 オブジェクトファイルは複数の文字列"
"テーブルセクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:954
#, no-wrap
msgid "B<SHT_RELA>"
msgstr "B<SHT_RELA>"

#. type: Plain text
#: build/C/man5/elf.5:962
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""
"このセクションは明示的な加数 (addend) を持つ再配置エントリーを保持する。 再配"
"置エントリーの型は、オブジェクトファイルの 32 ビットクラスでは I<Elf32_Rela> "
"である。 オブジェクトファイルは複数の再配置セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:962
#, no-wrap
msgid "B<SHT_HASH>"
msgstr "B<SHT_HASH>"

#. type: Plain text
#: build/C/man5/elf.5:969
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""
"このセクションはシンボルハッシュテーブルを保持する。 動的リンクされるオブジェ"
"クトは、 シンボルハッシュテーブルを含んでいなければならない。 オブジェクト"
"ファイルは 1 つのハッシュテーブルのみを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:969
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr "B<SHT_DYNAMIC>"

#. type: Plain text
#: build/C/man5/elf.5:974
msgid ""
"This section holds information for dynamic linking.  An object file may have "
"only one dynamic section."
msgstr ""
"このセクションは動的リンクの情報を保持する。 オブジェクトファイルは 1 つの動"
"的セクションのみを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:974
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr "B<SHT_NOTE>"

#. type: Plain text
#: build/C/man5/elf.5:977
msgid "This section holds notes (ElfN_Nhdr)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:977
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr "B<SHT_NOBITS>"

#. type: Plain text
#: build/C/man5/elf.5:985
msgid ""
"A section of this type occupies no space in the file but otherwise resembles "
"B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset> "
"member contains the conceptual file offset."
msgstr ""
"このタイプのセクションはファイルの領域を使わないという以外は、 "
"B<SHT_PROGBITS> と似ている。 このセクションは 1 バイトも含まないが、 "
"I<sh_offset> メンバは概念的なファイルオフセットを持つ。"

#. type: TP
#: build/C/man5/elf.5:985
#, no-wrap
msgid "B<SHT_REL>"
msgstr "B<SHT_REL>"

#. type: Plain text
#: build/C/man5/elf.5:993
msgid ""
"This section holds relocation offsets without explicit addends, such as type "
"I<Elf32_Rel> for the 32-bit class of object files.  An object file may have "
"multiple relocation sections."
msgstr ""
"このセクションは明示的な加数を持たない再配置オフセットを保持する。 再配置オフ"
"セットの型は、オブジェクトファイルの 32 ビットクラスでは I<Elf32_Rel> であ"
"る。 オブジェクトファイルは複数の再配置セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:993
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr "B<SHT_SHLIB>"

#. type: Plain text
#: build/C/man5/elf.5:996
msgid "This section is reserved but has unspecified semantics."
msgstr "このセクションは予約されているが、意味は指定されていない。"

#. type: TP
#: build/C/man5/elf.5:996
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr "B<SHT_DYNSYM>"

#. type: Plain text
#: build/C/man5/elf.5:1003
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file "
"can also contain a B<SHT_SYMTAB> section."
msgstr ""
"このセクションは動的リンクシンボルの最小セットを保持する。 オブジェクトファイ"
"ルは B<SHT_SYMTAB> セクションも含むことができる。"

#. type: TP
#: build/C/man5/elf.5:1003
#, no-wrap
msgid "B<SHT_LOPROC>, B<SHT_HIPROC>"
msgstr "B<SHT_LOPROC>, B<SHT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1008
#, fuzzy
#| msgid ""
#| "Values less than or equal to B<SHN_LOPROC> are reserved for processor-"
#| "specific semantics."
msgid ""
"Values in the inclusive range [B<SHT_LOPROC>, B<SHT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"この値以下で B<SHN_HIPROC> 以上の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1008
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr "B<SHT_LOUSER>"

#. type: Plain text
#: build/C/man5/elf.5:1012
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""
"この値はアプリケーションプログラムのために予約される インデックス範囲の下限を"
"指定する。"

#. type: TP
#: build/C/man5/elf.5:1012
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr "B<SHT_HIUSER>"

#. type: Plain text
#: build/C/man5/elf.5:1022
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER> "
"may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""
"この値はアプリケーションプログラムのために予約される インデックス範囲の上限を"
"指定する。 B<SHT_LOUSER> から B<SHT_HIUSER> の間のセクションタイプは、 現在ま"
"たは将来のシステム定義セクションタイプと衝突することなく、 アプリケーションで"
"使用することができる。"

#. type: TP
#: build/C/man5/elf.5:1023
#, no-wrap
msgid "I<sh_flags>"
msgstr "I<sh_flags>"

#. type: Plain text
#: build/C/man5/elf.5:1035
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a "
"flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes "
"are set to zero."
msgstr ""
"様々な属性を記述するための 1 ビットのフラグをサポートするセクション。 フラグ"
"ビットが I<sh_flags> に設定された場合、そのセクションについての属性は \"オン"
"\" になる。 それ以外の場合、属性が \"オフ\" であるか属性が適用されない。 未定"
"義の属性は 0 に設定される。"

#. type: TP
#: build/C/man5/elf.5:1036
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr "B<SHF_WRITE>"

#. type: Plain text
#: build/C/man5/elf.5:1040
msgid ""
"This section contains data that should be writable during process execution."
msgstr "このセクションはプロセス実行中に書き込み可能なデータを含む。"

#. type: TP
#: build/C/man5/elf.5:1040
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr "B<SHF_ALLOC>"

#. type: Plain text
#: build/C/man5/elf.5:1047
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""
"このセクションはプロセス実行中にメモリーを使用する。 制御セクションの中には、"
"オブジェクトファイルのメモリーイメージには 存在しないものもある。 そうしたセ"
"クションの場合、この属性はオフである。"

#. type: TP
#: build/C/man5/elf.5:1047
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr "B<SHF_EXECINSTR>"

#. type: Plain text
#: build/C/man5/elf.5:1050
msgid "This section contains executable machine instructions."
msgstr "このセクションは実行可能なマシン命令を含む。"

#. type: TP
#: build/C/man5/elf.5:1050
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr "B<SHF_MASKPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1054
msgid ""
"All bits included in this mask are reserved for processor-specific semantics."
msgstr ""
"このマスクに含まれる全てのビットはプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1055
#, no-wrap
msgid "I<sh_addr>"
msgstr "I<sh_addr>"

#. type: Plain text
#: build/C/man5/elf.5:1060
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the "
"member contains zero."
msgstr ""
"このセクションがプロセスのメモリーイメージにある場合、 このメンバはセクション"
"の最初のバイトが存在するアドレスを保持する。 それ以外の場合、このメンバは 0 "
"である。"

#. type: TP
#: build/C/man5/elf.5:1060
#, no-wrap
msgid "I<sh_offset>"
msgstr "I<sh_offset>"

#. type: Plain text
#: build/C/man5/elf.5:1069
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no "
"space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""
"このメンバの値は、ファイルの先頭からセクションの最初のバイトへの バイトオフ"
"セットを保持する。 セクションタイプ B<SHT_NOBITS> はファイルの領域を全く使用"
"せず、このタイプの I<sh_offset> メンバはファイルの概念的な位置を示す。"

#. type: TP
#: build/C/man5/elf.5:1069
#, no-wrap
msgid "I<sh_size>"
msgstr "I<sh_size>"

#. type: Plain text
#: build/C/man5/elf.5:1081
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section "
"of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""
"このメンバはセクションのサイズ (バイト単位) を保持する。 セクションタイプが "
"B<SHT_NOBITS> でない限り、そのセクションはファイル中の I<sh_size> バイトを使"
"用する。 タイプが B<SHT_NOBITS> のセクションはサイズが 0 でないが、ファイルの"
"領域を使用しない。"

#. type: TP
#: build/C/man5/elf.5:1081
#, no-wrap
msgid "I<sh_link>"
msgstr "I<sh_link>"

#. type: Plain text
#: build/C/man5/elf.5:1085
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""
"このメンバは、セクションヘッダーテーブルインデックスリンクを保持する。 この解"
"釈はセクションタイプに依存する。"

#. type: TP
#: build/C/man5/elf.5:1085
#, no-wrap
msgid "I<sh_info>"
msgstr "I<sh_info>"

#. type: Plain text
#: build/C/man5/elf.5:1089
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""
"このメンバは追加情報を保持する。 この解釈はセクションタイプに依存する。"

#. type: TP
#: build/C/man5/elf.5:1089
#, no-wrap
msgid "I<sh_addralign>"
msgstr "I<sh_addralign>"

#. type: Plain text
#: build/C/man5/elf.5:1101
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo "
"the value of I<sh_addralign>.  Only zero and positive integral powers of two "
"are allowed.  The value 0 or 1 means that the section has no alignment "
"constraints."
msgstr "アドレス配置に制約があるセクションもある。 セクションが倍長語 (doubleword) を保持する場合、 システムは全てのセクションについて倍長語の配置を保証しなければならない。 つまり、 I<sh_addr> の値は I<sh_addralign> の値を法として 0 と合同でなければならない (訳注:「sh_addr mod sh_addralign = 0 でなければならない)。 2 の 0 乗と正の整数乗のみが許可される。値 0 または 1 はセクションの配置に制約がないことを意味する。"

#. type: TP
#: build/C/man5/elf.5:1101
#, no-wrap
msgid "I<sh_entsize>"
msgstr "I<sh_entsize>"

#. type: Plain text
#: build/C/man5/elf.5:1107
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size "
"entries."
msgstr ""
"シンボルテーブルのような固定サイズエントリーのテーブルを保持する セクションも"
"ある。 このようなセクションでは、 このメンバは各エントリーのサイズ (バイト単"
"位) を表す。 このメンバが 0 の場合、 そのセクションは固定サイズエントリーの"
"テーブルを保持しない。"

#. type: Plain text
#: build/C/man5/elf.5:1109
msgid "Various sections hold program and control information:"
msgstr "さまざまなセクションにプログラム情報・制御情報が保持される:"

#. type: TP
#: build/C/man5/elf.5:1109
#, no-wrap
msgid "I<.bss>"
msgstr "I<.bss>"

#. type: Plain text
#: build/C/man5/elf.5:1121
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The "
"attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションはプログラムのメモリーイメージに配置される 非初期化データを保持"
"する。 定義上、システムはプログラムの実行開始時に、データを 0 で初期化する。 "
"このセクションのタイプは B<SHT_NOBITS> である。 属性タイプは B<SHF_ALLOC> と "
"B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1121
#, no-wrap
msgid "I<.comment>"
msgstr "I<.comment>"

#. type: Plain text
#: build/C/man5/elf.5:1127
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"このセクションはバージョン制御情報を保持する。 このセクションのタイプは "
"B<SHT_PROGBITS> である。 属性タイプは使用されない。"

#. type: TP
#: build/C/man5/elf.5:1127
#, no-wrap
msgid "I<.ctors>"
msgstr "I<.ctors>"

#. type: Plain text
#: build/C/man5/elf.5:1136
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションは C++ コンストラクター関数への初期化されたポインターを保持す"
"る。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは "
"B<SHF_ALLOC> と B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1136
#, no-wrap
msgid "I<.data>"
msgstr "I<.data>"

#. type: Plain text
#: build/C/man5/elf.5:1146 build/C/man5/elf.5:1156
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションはプログラムのメモリーイメージに配置される 初期化済みデータを保"
"持する。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは "
"B<SHF_ALLOC> と B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1146
#, no-wrap
msgid "I<.data1>"
msgstr "I<.data1>"

#. type: TP
#: build/C/man5/elf.5:1156
#, no-wrap
msgid "I<.debug>"
msgstr "I<.debug>"

#. type: Plain text
#: build/C/man5/elf.5:1164
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""
"このセクションはシンボリックデバッグ用の情報を保持する。 その内容は指定されて"
"いない。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは使用さ"
"れない。"

#. type: TP
#: build/C/man5/elf.5:1164
#, no-wrap
msgid "I<.dtors>"
msgstr "I<.dtors>"

#. type: Plain text
#: build/C/man5/elf.5:1173
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションは C++ デストラクタ関数への初期化されたポインターを保持する。 "
"このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは B<SHF_ALLOC> "
"と B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1173
#, no-wrap
msgid "I<.dynamic>"
msgstr "I<.dynamic>"

#. type: Plain text
#: build/C/man5/elf.5:1186
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""
"このセクションは動的リンク情報を保持する。 このセクションの属性は "
"B<SHF_ALLOC> ビットを含む。 B<SHF_WRITE> ビットが設定されるか否かはプロセッサ"
"による。 このセクションのタイプは B<SHT_DYNAMIC> である。 上記の属性を参照す"
"ること。"

#. type: TP
#: build/C/man5/elf.5:1186
#, no-wrap
msgid "I<.dynstr>"
msgstr "I<.dynstr>"

#. type: Plain text
#: build/C/man5/elf.5:1194
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This "
"section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""
"このセクションは動的リンクに必要な文字列を保持する。 最も一般的には、この文字"
"列はシンボルテーブルエントリーと 関連づけられた名前を表す。 このセクションの"
"タイプは B<SHT_STRTAB> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1194
#, no-wrap
msgid "I<.dynsym>"
msgstr "I<.dynsym>"

#. type: Plain text
#: build/C/man5/elf.5:1201
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションは動的リンクシンボルテーブルを保持する。 このセクションのタイプ"
"は B<SHT_DYNSYM> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1201
#, no-wrap
msgid "I<.fini>"
msgstr "I<.fini>"

#. type: Plain text
#: build/C/man5/elf.5:1213
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>.  "
"The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプロセス終了コードに置かれる実行可能命令を保持する。 プロセス"
"が正常に終了した場合、システムはこのセクションにある コードを配置して実行す"
"る。 このセクションのタイプは B<SHT_PROGBITS> である。 使用される属性タイプ"
"は B<SHF_ALLOC> と B<SHF_EXECINSTR> である。"

#. type: TP
#: build/C/man5/elf.5:1213
#, no-wrap
msgid "I<.gnu.version>"
msgstr "I<.gnu.version>"

#. type: Plain text
#: build/C/man5/elf.5:1222
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョンシンボルテーブルを保持する。 その内容は "
"I<ElfN_Half> 要素の配列である。 このセクションのタイプは B<SHT_GNU_versym> で"
"ある。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1222
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr "I<.gnu.version_d>"

#. type: Plain text
#: build/C/man5/elf.5:1231
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef> "
"structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョンシンボルの定義を保持する。 その内容は "
"I<ElfN_Verdef> 構造体のテーブルである。 このセクションのタイプは "
"B<SHT_GNU_verdef> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1231
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr "I<.gnu.version_r>"

#. type: Plain text
#: build/C/man5/elf.5:1241
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The "
"attribute type used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョンシンボルが必要とする要素を保持する。 その内容は "
"I<ElfN_Verneed> 構造体のテーブルである。 このセクションのタイプは "
"B<SHT_GNU_versym> である。 使用される属性タイプは B<shf_alloc> である。"

#. type: TP
#: build/C/man5/elf.5:1241
#, no-wrap
msgid "I<.got>"
msgstr "I<.got>"

#. type: Plain text
#: build/C/man5/elf.5:1247
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"このセクションはグローバルオフセットテーブルを保持する。 このセクションのタイ"
"プは B<SHT_PROGBITS> である。 属性はプロセッサ毎に異なる。"

#. type: TP
#: build/C/man5/elf.5:1247
#, no-wrap
msgid "I<.hash>"
msgstr "I<.hash>"

#. type: Plain text
#: build/C/man5/elf.5:1254
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションはシンボルハッシュテーブルを保持する。 セクションのタイプは "
"B<SHT_HASH> である。 使用される属性は B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1254
#, no-wrap
msgid "I<.init>"
msgstr "I<.init>"

#. type: Plain text
#: build/C/man5/elf.5:1266
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプロセス初期化コードに配置される実行可能命令を保持する。 プロ"
"グラムが実行を開始すると、 システムはメインプログラムエントリーポイントを呼び"
"出す前に、 このセクションにあるコードを配置して実行する。 このセクションはの"
"タイプは B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> と "
"B<SHF_EXECINSTR> である。"

#. type: TP
#: build/C/man5/elf.5:1266
#, no-wrap
msgid "I<.interp>"
msgstr "I<.interp>"

#. type: Plain text
#: build/C/man5/elf.5:1277
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a "
"loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""
"このセクションはプログラムインタープリターのパス名を保持する。 ファイルにこの"
"セクションを含むロード可能セグメントがある場合、 そのセクションの属性には "
"B<SHF_ALLOC> ビットが含まれる。 それ以外の場合このビットはオフになる。 このセ"
"クションのタイプは B<SHT_PROGBITS> である。"

#. type: TP
#: build/C/man5/elf.5:1277
#, no-wrap
msgid "I<.line>"
msgstr "I<.line>"

#. type: Plain text
#: build/C/man5/elf.5:1286
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"このセクションはシンボリックデバッグのための行番号情報を保持する。 ここにはプ"
"ログラムソースコードとマシンコードの対応関係が記述される。 内容は指定されてい"
"ない。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは使用され"
"ない。"

#. type: TP
#: build/C/man5/elf.5:1286
#, no-wrap
msgid "I<.note>"
msgstr "I<.note>"

#. type: Plain text
#: build/C/man5/elf.5:1292
#, fuzzy
#| msgid ""
#| "This section holds section names.  This section is of type "
#| "B<SHT_STRTAB>.  No attribute types are used."
msgid ""
"This section holds various notes.  This section is of type B<SHT_NOTE>.  No "
"attribute types are used."
msgstr ""
"このセクションはセクション名を保持する。 このセクションのタイプは "
"B<SHT_STRTAB> である。 属性タイプは使用されない。"

#. type: TP
#: build/C/man5/elf.5:1292
#, no-wrap
msgid "I<.note.ABI-tag>"
msgstr "I<.note.ABI-tag>"

#. type: Plain text
#: build/C/man5/elf.5:1300
#, fuzzy
#| msgid ""
#| "This section holds read-only data that typically contributes to a "
#| "nonwritable segment in the process image.  This section is of type "
#| "B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgid ""
"This section is used to declare the expected run-time ABI of the ELF image.  "
"It may include the operating system name and its run-time versions.  This "
"section is of type B<SHT_NOTE>.  The only attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションはリードオンリーのデータを保持する。 このデータはプロセスイメー"
"ジにおける書き込み不可能なセグメントに置かれる。 このセクションのタイプは "
"B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1300
#, no-wrap
msgid "I<.note.gnu.build-id>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1313
msgid ""
"This section is used to hold an ID that uniquely identifies the contents of "
"the ELF image.  Different files with the same build ID should contain the "
"same executable content.  See the B<--build-id> option to the GNU linker "
"(B<ld> (1)) for more details.  This section is of type B<SHT_NOTE>.  The "
"only attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1313
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr "I<.note.GNU-stack>"

#. type: Plain text
#: build/C/man5/elf.5:1322
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""
"このセクションは Linux のオブジェクトファイルで スタック属性を宣言するのに使"
"用される。 セクションのタイプは B<SHT_PROGBITS> である。使用される属性は "
"B<SHF_EXECINSTR> だけである。この属性は GNU リンカーに対して オブジェクトファ"
"イルが実行可能なスタック (executable stack) を必要とする 示すものである。"

#. type: TP
#: build/C/man5/elf.5:1322
#, no-wrap
msgid "I<.note.openbsd.ident>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1327
#, fuzzy
#| msgid ""
#| "This section holds information in the \"Note Section\" format.  This "
#| "section is of type B<SHT_NOTE>.  No attribute types are used.  OpenBSD "
#| "native executables usually contain a I<.note.openbsd.ident> section to "
#| "identify themselves, for the kernel to bypass any compatibility ELF "
#| "binary emulation tests when loading the file."
msgid ""
"OpenBSD native executables usually contain this section to identify "
"themselves so the kernel can bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""
"このセクションは \"Note Section\" 形式で情報を保持する。このセクションのタイ"
"プ\n"
"は B<SHT_NOTE> である。属性タイプは使用されない。通常 OpenBSD ネイティブ実"
"行\n"
"可能ファイルは自身を識別するために I<.note.openbsd.ident> セクションを持"
"つ。\n"
"これによりカーネルは、ファイルをロードする際に 互換 ELF バイナリエミュレー"
"ショ\n"
"ンテストを回避できる。"

#. type: TP
#: build/C/man5/elf.5:1327
#, no-wrap
msgid "I<.plt>"
msgstr "I<.plt>"

#. type: Plain text
#: build/C/man5/elf.5:1333
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"このセクションは手続き (procedure) リンクテーブルを保持する。 このセクション"
"のタイプは B<SHT_PROGBITS> である。 属性はプロセッサ毎に異なる。"

#. type: TP
#: build/C/man5/elf.5:1333
#, no-wrap
msgid "I<.relNAME>"
msgstr "I<.relNAME>"

#. type: Plain text
#: build/C/man5/elf.5:1352
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""
"このセクションは以下に記述される再配置情報を保持する。 ファイルが再配置を含む"
"ロード可能セグメントを持っている場合、 このセクションの属性は B<SHF_ALLOC> "
"ビットを含む。 それ以外の場合、そのビットはオフである。 慣例として、 \"NAME"
"\" は再配置が適用されるセクションが指定される。 よって B<.text> についての再"
"配置セクションは、通常は B<.rel.text> という名前を持つ。 このセクションのタイ"
"プは B<SHT_REL> である。"

#. type: TP
#: build/C/man5/elf.5:1352
#, no-wrap
msgid "I<.relaNAME>"
msgstr "I<.relaNAME>"

#. type: Plain text
#: build/C/man5/elf.5:1371
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""
"このセクションは以下に記述される再配置情報を保持する。 ファイルが再配置を含む"
"ロード可能セグメントを持っている場合、 このセクションの属性は B<SHF_ALLOC> "
"ビットを含む。 それ以外の場合、そのビットはオフである。 慣例として、 \"NAME"
"\" は再配置が適用されるセクションが指定される。 よって B<.text> についての再"
"配置セクションは、通常は B<.rela.text> という名前を持つ。 このセクションのタ"
"イプは B<SHT_RELA> である。"

#. type: TP
#: build/C/man5/elf.5:1371
#, no-wrap
msgid "I<.rodata>"
msgstr "I<.rodata>"

#. type: Plain text
#: build/C/man5/elf.5:1379 build/C/man5/elf.5:1387
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションはリードオンリーのデータを保持する。 このデータはプロセスイメー"
"ジにおける書き込み不可能なセグメントに置かれる。 このセクションのタイプは "
"B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1379
#, no-wrap
msgid "I<.rodata1>"
msgstr "I<.rodata1>"

#. type: TP
#: build/C/man5/elf.5:1387
#, no-wrap
msgid "I<.shstrtab>"
msgstr "I<.shstrtab>"

#. type: Plain text
#: build/C/man5/elf.5:1393
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""
"このセクションはセクション名を保持する。 このセクションのタイプは "
"B<SHT_STRTAB> である。 属性タイプは使用されない。"

#. type: TP
#: build/C/man5/elf.5:1393
#, no-wrap
msgid "I<.strtab>"
msgstr "I<.strtab>"

#. type: Plain text
#: build/C/man5/elf.5:1405
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section "
"is of type B<SHT_STRTAB>."
msgstr ""
"このセクションは文字列を保持する。 最も一般的なのは、シンボルテーブルエント"
"リーに関連づけられた 名前を表す文字列である。 ファイルがシンボル文字列テーブ"
"ルを含むロード可能セグメントを持つ場合、 セクションの属性は B<SHF_ALLOC> ビッ"
"トを含む。 それ以外の場合、そのビットはオフである。 このセクションのタイプは "
"B<SHT_STRTAB> である。"

#. type: TP
#: build/C/man5/elf.5:1405
#, no-wrap
msgid "I<.symtab>"
msgstr "I<.symtab>"

#. type: Plain text
#: build/C/man5/elf.5:1416
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""
"このセクションはシンボルテーブルを保持する。 ファイルがシンボルテーブルを含む"
"ロード可能セグメントを持つ場合、 セクションの属性は B<SHF_ALLOC> ビットを含"
"む。 それ以外の場合、ビットはオフである。 このセクションのタイプは "
"B<SHT_SYMTAB> である。"

#. type: TP
#: build/C/man5/elf.5:1416
#, no-wrap
msgid "I<.text>"
msgstr "I<.text>"

#. type: Plain text
#: build/C/man5/elf.5:1428
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプログラムの \"テキスト\" または実行可能命令を保持する。 セク"
"ションのタイプは B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> と "
"B<SHF_EXECINSTR> である。"

#. type: SS
#: build/C/man5/elf.5:1428
#, fuzzy, no-wrap
#| msgid "Address of symbol table"
msgid "String and symbol tables"
msgstr "シンボルテーブルのアドレス"

#. type: Plain text
#: build/C/man5/elf.5:1439
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""
"文字列テーブルセクションはヌル文字で終端されたキャラクター配列 (通常文字列と"
"呼ばれるもの) を保持する。 オブジェクトファイルはこれらの文字列を シンボル名"
"とセクション名を表すために使う。 文字列は、文字列テーブルセクションへのイン"
"デックスとして参照される。 インデックス 0 の最初のバイトは、ヌルバイト (\\(aq"
"\\e0\\(aq) を 保持すると定義されている。 同様に文字列テーブルの最後のバイトも"
"ヌル文字を保持すると定義されている。 これは全ての文字列がヌルバイトで終端され"
"ていることを保証するためである。"

#. type: Plain text
#: build/C/man5/elf.5:1444
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""
"オブジェクトファイルのシンボルテーブルは、 プログラムのシンボル定義と参照を配"
"置または再配置するのに 必要な情報を保持する。"

#. type: Plain text
#: build/C/man5/elf.5:1455
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"

#. type: Plain text
#: build/C/man5/elf.5:1468
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"

#. type: Plain text
#: build/C/man5/elf.5:1473
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""
"32 ビット版と 64 ビット版は同じメンバを持ち、単に順番が異なるだけである。"

#. type: TP
#: build/C/man5/elf.5:1473
#, no-wrap
msgid "I<st_name>"
msgstr "I<st_name>"

#. type: Plain text
#: build/C/man5/elf.5:1481
msgid ""
"This member holds an index into the object file's symbol string table, which "
"holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol has no name."
msgstr "このメンバはオブジェクトファイルのシンボル文字列テーブルの インデックスを保持する。 シンボル文字列テーブルはシンボル名の文字表現を保持する。 この値が 0 でない場合、シンボル名を得るための文字テーブルインデックスを表す。 それ以外の場合、シンボルは名前を持たない。"

#. type: TP
#: build/C/man5/elf.5:1481
#, no-wrap
msgid "I<st_value>"
msgstr "I<st_value>"

#. type: Plain text
#: build/C/man5/elf.5:1484
msgid "This member gives the value of the associated symbol."
msgstr "このメンバは関連づけられたシンボルの値を表す。"

#. type: TP
#: build/C/man5/elf.5:1484
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: build/C/man5/elf.5:1489
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""
"多くのシンボルにはそれに関連づけられたサイズがある。 シンボルがサイズを持たな"
"い場合、またはサイズが不明な場合、 このメンバは 0 である。"

#. type: TP
#: build/C/man5/elf.5:1489
#, no-wrap
msgid "I<st_info>"
msgstr "I<st_info>"

#. type: Plain text
#: build/C/man5/elf.5:1492
msgid "This member specifies the symbol's type and binding attributes:"
msgstr "このメンバはシンボルのタイプとバインディング (binding) 属性を指定する:"

#. type: TP
#: build/C/man5/elf.5:1493
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr "B<STT_NOTYPE>"

#. type: Plain text
#: build/C/man5/elf.5:1496
msgid "The symbol's type is not defined."
msgstr "シンボルのタイプが定義されていない。"

#. type: TP
#: build/C/man5/elf.5:1496
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr "B<STT_OBJECT>"

#. type: Plain text
#: build/C/man5/elf.5:1499
msgid "The symbol is associated with a data object."
msgstr "シンボルはデータオブジェクトに関連づけられている。"

#. type: TP
#: build/C/man5/elf.5:1499
#, no-wrap
msgid "B<STT_FUNC>"
msgstr "B<STT_FUNC>"

#. type: Plain text
#: build/C/man5/elf.5:1502
msgid "The symbol is associated with a function or other executable code."
msgstr "シンボルは関数またはその他の実行コードに関連づけられている。"

#. type: TP
#: build/C/man5/elf.5:1502
#, no-wrap
msgid "B<STT_SECTION>"
msgstr "B<STT_SECTION>"

#. type: Plain text
#: build/C/man5/elf.5:1509
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""
"シンボルはセクションに関連づけられている。 このタイプのシンボルテーブルエント"
"リーは、 主として再配置のために存在し、通常は B<STB_LOCAL> バインディングを持"
"つ。"

#. type: TP
#: build/C/man5/elf.5:1509
#, no-wrap
msgid "B<STT_FILE>"
msgstr "B<STT_FILE>"

#. type: Plain text
#: build/C/man5/elf.5:1520
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""
"慣例として、シンボルの名前は オブジェクトファイルに関連づけられたソースファイ"
"ルの名前を指定する。 ファイルシンボルは B<STB_LOCAL> バインディングを持ち、そ"
"のセクションインデックスは B<SHN_ABS> である。 ファイルシンボルは、ファイルに"
"他の B<STB_LOCAL> シンボルがある場合は、それよりも先に来る。"

#. type: TP
#: build/C/man5/elf.5:1520
#, no-wrap
msgid "B<STT_LOPROC>, B<STT_HIPROC>"
msgstr "B<STT_LOPROC>, B<STT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1525
#, fuzzy
#| msgid ""
#| "This value down to and including B<STT_LOPROC> is reserved for processor-"
#| "specific semantics."
msgid ""
"Values in the inclusive range [B<STT_LOPROC>, B<STT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"この値以下で B<STT_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1525
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr "B<STB_LOCAL>"

#. type: Plain text
#: build/C/man5/elf.5:1531
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""
"局所的シンボルはその定義を含むオブジェクトファイルの外からは見えない。 同じ名"
"前の局所的シンボルは、お互いに影響を受けることなく、 複数のファイルに存在でき"
"る。"

#. type: TP
#: build/C/man5/elf.5:1531
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr "B<STB_GLOBAL>"

#. type: Plain text
#: build/C/man5/elf.5:1537
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""
"大域的シンボルは結びつけられている全てのオブジェクトファイルから見える。 1 つ"
"のファイルで大域的シンボルが定義されていたら、 他のファイルでは同じシンボルへ"
"の参照は未定義でなければならない。"

#. type: TP
#: build/C/man5/elf.5:1537
#, no-wrap
msgid "B<STB_WEAK>"
msgstr "B<STB_WEAK>"

#. type: Plain text
#: build/C/man5/elf.5:1541
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr "弱シンボルは大域的シンボルに似ているが、その定義は優先度が低い。"

#. type: TP
#: build/C/man5/elf.5:1541
#, no-wrap
msgid "B<STB_LOPROC>, B<STB_HIPROC>"
msgstr "B<STB_LOPROC>, B<STB_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1546
#, fuzzy
#| msgid ""
#| "This value down to and including B<STB_LOPROC> is reserved for processor-"
#| "specific semantics."
msgid ""
"Values in the inclusive range [B<STB_LOPROC>, B<STB_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"この値以下で B<STB_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されている。"

#. type: Plain text
#: build/C/man5/elf.5:1549
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr ""
"バインディングとタイプフィールドを パックしたりアンパックしたりするマクロがあ"
"る:"

#. type: TP
#: build/C/man5/elf.5:1550
#, no-wrap
msgid "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"
msgstr "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"

#. type: Plain text
#: build/C/man5/elf.5:1555
msgid "Extract a binding from an I<st_info> value."
msgstr "I<st_info> の値からバインディングを取り出す。"

#. type: TP
#: build/C/man5/elf.5:1555
#, no-wrap
msgid "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"
msgstr "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"

#. type: Plain text
#: build/C/man5/elf.5:1560
msgid "Extract a type from an I<st_info> value."
msgstr "I<st_info> の値からタイプを取り出す。"

#. type: TP
#: build/C/man5/elf.5:1560
#, no-wrap
msgid "B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, >I<type>B<)>"
msgstr "B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, >I<type>B<)>"

#. type: Plain text
#: build/C/man5/elf.5:1566
msgid "Convert a binding and a type into an I<st_info> value."
msgstr "バインディングとタイプを I<st_info> の値に変換する。"

#. type: TP
#: build/C/man5/elf.5:1567
#, no-wrap
msgid "I<st_other>"
msgstr "I<st_other>"

#. type: Plain text
#: build/C/man5/elf.5:1570
msgid "This member defines the symbol visibility."
msgstr "このメンバはシンボルの visibility (見える範囲) を規定する。"

#. type: TP
#: build/C/man5/elf.5:1571
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr "B<STV_DEFAULT>"

#. type: Plain text
#: build/C/man5/elf.5:1578
msgid ""
"Default symbol visibility rules.  Global and weak symbols are available to "
"other modules; references in the local module can be interposed by "
"definitions in other modules."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1578
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr "B<STV_INTERNAL>"

#. type: Plain text
#: build/C/man5/elf.5:1581
msgid "Processor-specific hidden class."
msgstr "プロセッサ固有の隠しクラス。"

#. type: TP
#: build/C/man5/elf.5:1581
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr "B<STV_HIDDEN>"

#. type: Plain text
#: build/C/man5/elf.5:1586
msgid ""
"Symbol is unavailable to other modules; references in the local module "
"always resolve to the local symbol (i.e., the symbol can't be interposed by "
"definitions in other modules)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1586
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr "B<STV_PROTECTED>"

#. type: Plain text
#: build/C/man5/elf.5:1590
msgid ""
"Symbol is available to other modules, but references in the local module "
"always resolve to the local symbol."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1593
msgid "There are macros for extracting the visibility type:"
msgstr "visibility 種別を抽出するためのマクロがある。"

#. type: Plain text
#: build/C/man5/elf.5:1597
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr "B<ELF32_ST_VISIBILITY>(other)  または B<ELF64_ST_VISIBILITY>(other)"

#. type: TP
#: build/C/man5/elf.5:1598
#, no-wrap
msgid "I<st_shndx>"
msgstr "I<st_shndx>"

#. type: Plain text
#: build/C/man5/elf.5:1606
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""
"各シンボルテーブルエントリーは、いくつかのセクションに関連して \"定義されてい"
"る\"。 このメンバは関連するセクションヘッダーテーブルインデックスを保持する。"

#. type: SS
#: build/C/man5/elf.5:1606
#, no-wrap
msgid "Relocation entries (Rel & Rela)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1614
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""
"再配置はシンボル参照とシンボル定義を結合するプロセスである。 再配置可能ファイ"
"ルはセクションの内容をどのように修正するかに関する 情報を持たなければならな"
"い。 これにより、実行可能ファイルと共有オブジェクトファイルは プロセスのプロ"
"グラムイメージについての正しい情報を持つことができる。 再配置エントリーは以下"
"のようなデータである。"

#. type: Plain text
#: build/C/man5/elf.5:1616
msgid "Relocation structures that do not need an addend:"
msgstr "加数を必要としない再配置構造体。"

#. type: Plain text
#: build/C/man5/elf.5:1623
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"

#. type: Plain text
#: build/C/man5/elf.5:1632
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"

#. type: Plain text
#: build/C/man5/elf.5:1636
msgid "Relocation structures that need an addend:"
msgstr "加数を必要とする再配置構造体。"

#. type: Plain text
#: build/C/man5/elf.5:1644
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"

#. type: Plain text
#: build/C/man5/elf.5:1654
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"

#. type: TP
#: build/C/man5/elf.5:1656
#, no-wrap
msgid "I<r_offset>"
msgstr "I<r_offset>"

#. type: Plain text
#: build/C/man5/elf.5:1664
msgid ""
"This member gives the location at which to apply the relocation action.  For "
"a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""
"このメンバは再配置動作が適用される位置を与える。 再配置可能ファイルの場合、こ"
"の値はセクションの先頭から 再配置で影響を受ける格納単位 (storage unit) までの"
"バイトオフセットである。 実行可能ファイルまたは共有オブジェクトの場合、 この"
"値は再配置で影響を受ける格納単位の仮想アドレスである。"

#. type: TP
#: build/C/man5/elf.5:1664
#, no-wrap
msgid "I<r_info>"
msgstr "I<r_info>"

#. type: Plain text
#: build/C/man5/elf.5:1679
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor-specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""
"このメンバは、再配置が行われなければならないシンボルテーブルインデックスと、 "
"適用される再配置のタイプの両方を与える。 再配置タイプはプロセッサ毎に異な"
"る。 テキストが再配置エントリーの再配置タイプ またはシンボルテーブルインデッ"
"クスを参照している場合、 それぞれエントリーの I<r_info> メンバに対して、それ"
"ぞれ B<ELF[32|64]_R_TYPE> と B<ELF[32|64]_R_SYM> を適用した結果を意味する。"

#. type: TP
#: build/C/man5/elf.5:1679
#, no-wrap
msgid "I<r_addend>"
msgstr "I<r_addend>"

#. type: Plain text
#: build/C/man5/elf.5:1684
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""
"このメンバは定数の加数を指定する。 この加数は再配置可能フィールドに格納される"
"値を計算するために使われる。"

#. type: SS
#: build/C/man5/elf.5:1684
#, no-wrap
msgid "Dynamic tags (Dyn)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1694
msgid ""
"The I<.dynamic> section contains a series of structures that hold relevant "
"dynamic linking information.  The I<d_tag> member controls the "
"interpretation of I<d_un>."
msgstr "I<.dynamic> セクションは、関連する動的リンク情報を保持している 一連の構造体を保持する。 I<d_tag> メンバは I<d_un> の解釈を制御する。"

#. type: Plain text
#: build/C/man5/elf.5:1705
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"

#. type: Plain text
#: build/C/man5/elf.5:1718
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"

#. type: TP
#: build/C/man5/elf.5:1720
#, no-wrap
msgid "I<d_tag>"
msgstr "I<d_tag>"

#. type: Plain text
#: build/C/man5/elf.5:1723
msgid "This member may have any of the following values:"
msgstr "このメンバは以下の値を持つことができる:"

#. type: TP
#: build/C/man5/elf.5:1724
#, no-wrap
msgid "B<DT_NULL>"
msgstr "B<DT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:1727
msgid "Marks end of dynamic section"
msgstr "動的セクションの終りのマーク"

#. type: TP
#: build/C/man5/elf.5:1727
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr "B<DT_NEEDED>"

#. type: Plain text
#: build/C/man5/elf.5:1730
msgid "String table offset to name of a needed library"
msgstr "必要なライブラリの名前への文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1730
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr "B<DT_PLTRELSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1733
msgid "Size in bytes of PLT relocation entries"
msgstr "PLT 再配置 (relocation) エントリーのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1733
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr "B<DT_PLTGOT>"

#. type: Plain text
#: build/C/man5/elf.5:1736
msgid "Address of PLT and/or GOT"
msgstr "PLT と GOT (または何れか一方) のアドレス"

#. type: TP
#: build/C/man5/elf.5:1736
#, no-wrap
msgid "B<DT_HASH>"
msgstr "B<DT_HASH>"

#. type: Plain text
#: build/C/man5/elf.5:1739
msgid "Address of symbol hash table"
msgstr "シンボルハッシュテーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1739
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr "B<DT_STRTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1742
msgid "Address of string table"
msgstr "文字列テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1742
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr "B<DT_SYMTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1745
msgid "Address of symbol table"
msgstr "シンボルテーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1745
#, no-wrap
msgid "B<DT_RELA>"
msgstr "B<DT_RELA>"

#. type: Plain text
#: build/C/man5/elf.5:1748
msgid "Address of Rela relocation table"
msgstr "Rela 再配置テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1748
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr "B<DT_RELASZ>"

#. type: Plain text
#: build/C/man5/elf.5:1751
msgid "Size in bytes of the Rela relocation table"
msgstr "Rela 再配置テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1751
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr "B<DT_RELAENT>"

#. type: Plain text
#: build/C/man5/elf.5:1754
msgid "Size in bytes of a Rela relocation table entry"
msgstr "Rela 再配置テーブルエントリーのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1754
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr "B<DT_STRSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1757
msgid "Size in bytes of string table"
msgstr "文字列テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1757
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr "B<DT_SYMENT>"

#. type: Plain text
#: build/C/man5/elf.5:1760
msgid "Size in bytes of a symbol table entry"
msgstr "シンボルテーブルエントリーのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1760
#, no-wrap
msgid "B<DT_INIT>"
msgstr "B<DT_INIT>"

#. type: Plain text
#: build/C/man5/elf.5:1763
msgid "Address of the initialization function"
msgstr "初期化関数のアドレス"

#. type: TP
#: build/C/man5/elf.5:1763
#, no-wrap
msgid "B<DT_FINI>"
msgstr "B<DT_FINI>"

#. type: Plain text
#: build/C/man5/elf.5:1766
msgid "Address of the termination function"
msgstr "終了関数のアドレス"

#. type: TP
#: build/C/man5/elf.5:1766
#, no-wrap
msgid "B<DT_SONAME>"
msgstr "B<DT_SONAME>"

#. type: Plain text
#: build/C/man5/elf.5:1769
msgid "String table offset to name of shared object"
msgstr "共有オブジェクトの名前への文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1769
#, no-wrap
msgid "B<DT_RPATH>"
msgstr "B<DT_RPATH>"

#. type: Plain text
#: build/C/man5/elf.5:1772
msgid "String table offset to library search path (deprecated)"
msgstr "ライブラリ検索パスへの文字列テーブルオフセット (推奨されない)"

#. type: TP
#: build/C/man5/elf.5:1772
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr "B<DT_SYMBOLIC>"

#. type: Plain text
#: build/C/man5/elf.5:1775
msgid ""
"Alert linker to search this shared object before the executable for symbols"
msgstr ""
"リンカーがシンボルの実行可能ファイルより前に この共有オブジェクトを検索した場"
"合は、警告を出す。"

#. type: TP
#: build/C/man5/elf.5:1775
#, no-wrap
msgid "B<DT_REL>"
msgstr "B<DT_REL>"

#. type: Plain text
#: build/C/man5/elf.5:1778
msgid "Address of Rel relocation table"
msgstr "Rel 再配置テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1778
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr "B<DT_RELSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1781
msgid "Size in bytes of Rel relocation table"
msgstr "Rela 再配置テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1781
#, no-wrap
msgid "B<DT_RELENT>"
msgstr "B<DT_RELENT>"

#. type: Plain text
#: build/C/man5/elf.5:1784
msgid "Size in bytes of a Rel table entry"
msgstr "Rel テーブルエントリーのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1784
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr "B<DT_PLTREL>"

#. type: Plain text
#: build/C/man5/elf.5:1787
msgid "Type of relocation entry to which the PLT refers (Rela or Rel)"
msgstr "PLT が参照する再配置エントリーのタイプ (Rela または Rel)"

#. type: TP
#: build/C/man5/elf.5:1787
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr "B<DT_DEBUG>"

#. type: Plain text
#: build/C/man5/elf.5:1790
msgid "Undefined use for debugging"
msgstr "デバッグのために使用されている。内容は定義されていない。"

#. type: TP
#: build/C/man5/elf.5:1790
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr "B<DT_TEXTREL>"

#. type: Plain text
#: build/C/man5/elf.5:1794
msgid ""
"Absence of this entry indicates that no relocation entries should apply to a "
"nonwritable segment"
msgstr "このエントリーが指定されていない場合、 書き込み不可のセグメントには再配置エントリーは適用されない。"

#. type: TP
#: build/C/man5/elf.5:1794
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr "B<DT_JMPREL>"

#. type: Plain text
#: build/C/man5/elf.5:1797
msgid "Address of relocation entries associated solely with the PLT"
msgstr "PLT とだけ関連付けられる再配置エントリーのアドレス"

#. type: TP
#: build/C/man5/elf.5:1797
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr "B<DT_BIND_NOW>"

#. type: Plain text
#: build/C/man5/elf.5:1801
msgid ""
"Instruct dynamic linker to process all relocations before transferring "
"control to the executable"
msgstr ""
"実行可能ファイルに制御を譲る前に、 全ての再配置を処理するように動的リンカーに"
"指示する。"

#. type: TP
#: build/C/man5/elf.5:1801
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr "B<DT_RUNPATH>"

#. type: Plain text
#: build/C/man5/elf.5:1804
msgid "String table offset to library search path"
msgstr "ライブラリ検索パスへの文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1804
#, no-wrap
msgid "B<DT_LOPROC>, B<DT_HIPROC>"
msgstr "B<DT_LOPROC>, B<DT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1809
#, fuzzy
#| msgid ""
#| "Values less than or equal to B<PT_LOPROC> are reserved for processor-"
#| "specific semantics."
msgid ""
"Values in the inclusive range [B<DT_LOPROC>, B<DT_HIPROC>] are reserved for "
"processor-specific semantics"
msgstr ""
"この値以下で B<PT_LOPROC> 以上の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1810
#, no-wrap
msgid "I<d_val>"
msgstr "I<d_val>"

#. type: Plain text
#: build/C/man5/elf.5:1813
msgid "This member represents integer values with various interpretations."
msgstr "このメンバは様々な意味に解釈される整数値である。"

#. type: TP
#: build/C/man5/elf.5:1813
#, no-wrap
msgid "I<d_ptr>"
msgstr "I<d_ptr>"

#. type: Plain text
#: build/C/man5/elf.5:1821
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""
"このメンバはプログラムの仮想アドレスを表す。 これらのアドレスを解釈する際"
"に、 実際のアドレスは元々のファイルの値と メモリーの基底アドレスから計算され"
"る。 ファイルにはこれらのアドレスを修正するための 再配置エントリーを含めては"
"ならない。"

#. type: TP
#: build/C/man5/elf.5:1821
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr "I<_DYNAMIC>"

#.  GABI ELF Reference for Note Sections:
#.  http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section
#.  Note that it implies the sizes and alignments of notes depend on the ELF
#.  size (e.g. 32-bit ELFs have three 4-byte words and use 4-byte alignment
#.  while 64-bit ELFs use 8-byte words & alignment), but that is not the case
#.  in the real world.  Notes always have three 4-byte words as can be seen
#.  in the source links below (remember that Elf64_Word is a 32-bit quantity).
#.  glibc:    https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;h=9e59b3275917549af0cebe1f2de9ded3b7b10bf2#l1173
#.  binutils: https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=binutils/readelf.c;h=274ddd17266aef6e4ad1f67af8a13a21500ff2af#l15943
#.  Linux:    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/elf.h?h=v4.8#n422
#.  Solaris:  https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html
#.  FreeBSD:  https://svnweb.freebsd.org/base/head/sys/sys/elf_common.h?revision=303677&view=markup#l33
#.  NetBSD:   https://www.netbsd.org/docs/kernel/elf-notes.html
#.  OpenBSD:  https://github.com/openbsd/src/blob/master/sys/sys/exec_elf.h#L533
#. type: Plain text
#: build/C/man5/elf.5:1843
msgid ""
"Array containing all the dynamic structures in the I<.dynamic> section.  "
"This is automatically populated by the linker."
msgstr "I<.dynamic> セクションにある全ての動的構造体を含む配列。 これは自動的にリンカーに渡される。"

#. type: SS
#: build/C/man5/elf.5:1843
#, no-wrap
msgid "Notes (Nhdr)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1853
msgid ""
"ELF notes allow for appending arbitrary information for the system to use.  "
"They are largely used by core files (I<e_type> of B<ET_CORE>), but many "
"projects define their own set of extensions.  For example, the GNU tool "
"chain uses ELF notes to pass information from the linker to the C library."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1861
msgid ""
"Note sections contain a series of notes (see the I<struct> definitions "
"below).  Each note is followed by the name field (whose length is defined in "
"I<n_namesz>) and then by the descriptor field (whose length is defined in "
"I<n_descsz>) and whose starting address has a 4 byte alignment.  Neither "
"field is defined in the note struct due to their arbitrary lengths."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1864
msgid ""
"An example for parsing out two consecutive notes should clarify their layout "
"in memory:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1869
#, no-wrap
msgid ""
"void *memory, *name, *desc;\n"
"Elf64_Nhdr *note, *next_note;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1872
#, no-wrap
msgid ""
"/* The buffer is pointing to the start of the section/segment */\n"
"note = memory;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1875
#, no-wrap
msgid ""
"/* If the name is defined, it follows the note */\n"
"name = note-E<gt>n_namesz == 0 ? NULL : memory + sizeof(*note);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1878
#, no-wrap
msgid ""
"/* If the descriptor is defined, it follows the name\n"
"   (with alignment) */\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1881
#, no-wrap
msgid ""
"desc = note-E<gt>n_descsz == 0 ? NULL :\n"
"       memory + sizeof(*note) + ALIGN_UP(note-E<gt>n_namesz, 4);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1886
#, no-wrap
msgid ""
"/* The next note follows both (with alignment) */\n"
"next_note = memory + sizeof(*note) +\n"
"                     ALIGN_UP(note-E<gt>n_namesz, 4) +\n"
"                     ALIGN_UP(note-E<gt>n_descsz, 4);\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1900
msgid ""
"Keep in mind that the interpretation of I<n_type> depends on the namespace "
"defined by the I<n_namesz> field.  If the I<n_namesz> field is not set (e."
"g., is 0), then there are two sets of notes: one for core files and one for "
"all other ELF types.  If the namespace is unknown, then tools will usually "
"fallback to these sets of notes as well."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1908
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:1918
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"

#. type: TP
#: build/C/man5/elf.5:1920
#, no-wrap
msgid "I<n_namesz>"
msgstr "I<n_namesz>"

#. type: Plain text
#: build/C/man5/elf.5:1928
msgid ""
"The length of the name field in bytes.  The contents will immediately follow "
"this note in memory.  The name is null terminated.  For example, if the name "
"is \"GNU\", then I<n_namesz> will be set to 4."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1928
#, no-wrap
msgid "I<n_descsz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1932
msgid ""
"The length of the descriptor field in bytes.  The contents will immediately "
"follow the name field in memory."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1932
#, no-wrap
msgid "I<n_type>"
msgstr "I<n_type>"

#. type: Plain text
#: build/C/man5/elf.5:1936
#, fuzzy
#| msgid "This member may have any of the following values:"
msgid ""
"Depending on the value of the name field, this member may have any of the "
"following values:"
msgstr "このメンバは以下の値を持つことができる:"

#. type: TP
#: build/C/man5/elf.5:1937
#, no-wrap
msgid "B<Core files (e_type = ET_CORE)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1945
msgid ""
"Notes used by all core files.  These are highly operating system or "
"architecture specific and often require close coordination with kernels, C "
"libraries, and debuggers.  These are used when the namespace is the default "
"(i.e., I<n_namesz> will be set to 0), or a fallback when the namespace is "
"unknown."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1946
#, no-wrap
msgid "B<NT_PRSTATUS>"
msgstr "B<NT_PRSTATUS>"

#. type: Plain text
#: build/C/man5/elf.5:1950
msgid "prstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1950
#, no-wrap
msgid "B<NT_FPREGSET>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1953
msgid "fpregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1953
#, no-wrap
msgid "B<NT_PRPSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1956
msgid "prpsinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1956
#, no-wrap
msgid "B<NT_PRXREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1959
msgid "prxregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1959
#, no-wrap
msgid "B<NT_TASKSTRUCT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1962
msgid "task structure"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1962
#, no-wrap
msgid "B<NT_PLATFORM>"
msgstr "B<NT_PLATFORM>"

#. type: Plain text
#: build/C/man5/elf.5:1965
msgid "String from sysinfo(SI_PLATFORM)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1965
#, no-wrap
msgid "B<NT_AUXV>"
msgstr "B<NT_AUXV>"

#. type: Plain text
#: build/C/man5/elf.5:1968
msgid "auxv array"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1968
#, no-wrap
msgid "B<NT_GWINDOWS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1971
msgid "gwindows struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1971
#, no-wrap
msgid "B<NT_ASRS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1974
msgid "asrset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1974
#, no-wrap
msgid "B<NT_PSTATUS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1977
msgid "pstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1977
#, no-wrap
msgid "B<NT_PSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1980
msgid "psinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1980
#, no-wrap
msgid "B<NT_PRCRED>"
msgstr "B<NT_PRCRED>"

#. type: Plain text
#: build/C/man5/elf.5:1983
msgid "prcred struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1983
#, no-wrap
msgid "B<NT_UTSNAME>"
msgstr "B<NT_UTSNAME>"

#. type: Plain text
#: build/C/man5/elf.5:1986
msgid "utsname struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1986
#, no-wrap
msgid "B<NT_LWPSTATUS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1989
msgid "lwpstatus struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1989
#, no-wrap
msgid "B<NT_LWPSINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1992
msgid "lwpinfo struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1992
#, no-wrap
msgid "B<NT_PRFPXREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1995
msgid "fprxregset struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1995
#, no-wrap
msgid "B<NT_SIGINFO>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1998
msgid "siginfo_t (size might increase over time)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1998
#, no-wrap
msgid "B<NT_FILE>"
msgstr "B<NT_FILE>"

#. type: Plain text
#: build/C/man5/elf.5:2001
msgid "Contains information about mapped files"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2001
#, no-wrap
msgid "B<NT_PRXFPREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2004
msgid "user_fxsr_struct"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2004
#, no-wrap
msgid "B<NT_PPC_VMX>"
msgstr "B<NT_PPC_VMX>"

#. type: Plain text
#: build/C/man5/elf.5:2007
msgid "PowerPC Altivec/VMX registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2007
#, no-wrap
msgid "B<NT_PPC_SPE>"
msgstr "B<NT_PPC_SPE>"

#. type: Plain text
#: build/C/man5/elf.5:2010
msgid "PowerPC SPE/EVR registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2010
#, no-wrap
msgid "B<NT_PPC_VSX>"
msgstr "B<NT_PPC_VSX>"

#. type: Plain text
#: build/C/man5/elf.5:2013
msgid "PowerPC VSX registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2013
#, no-wrap
msgid "B<NT_386_TLS>"
msgstr "B<NT_386_TLS>"

#. type: Plain text
#: build/C/man5/elf.5:2016
msgid "i386 TLS slots (struct user_desc)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2016
#, no-wrap
msgid "B<NT_386_IOPERM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2019
msgid "x86 io permission bitmap (1=deny)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2019
#, no-wrap
msgid "B<NT_X86_XSTATE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2022
msgid "x86 extended state using xsave"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2022
#, no-wrap
msgid "B<NT_S390_HIGH_GPRS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2025
msgid "s390 upper register halves"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2025
#, no-wrap
msgid "B<NT_S390_TIMER>"
msgstr "B<NT_S390_TIMER>"

#. type: Plain text
#: build/C/man5/elf.5:2028
msgid "s390 timer register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2028
#, no-wrap
msgid "B<NT_S390_TODCMP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2031
msgid "s390 time-of-day (TOD) clock comparator register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2031
#, no-wrap
msgid "B<NT_S390_TODPREG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2034
msgid "s390 time-of-day (TOD) programmable register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2034
#, no-wrap
msgid "B<NT_S390_CTRS>"
msgstr "B<NT_S390_CTRS>"

#. type: Plain text
#: build/C/man5/elf.5:2037
msgid "s390 control registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2037
#, no-wrap
msgid "B<NT_S390_PREFIX>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2040
msgid "s390 prefix register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2040
#, no-wrap
msgid "B<NT_S390_LAST_BREAK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2043
msgid "s390 breaking event address"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2043
#, no-wrap
msgid "B<NT_S390_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2046
msgid "s390 system call restart data"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2046
#, no-wrap
msgid "B<NT_S390_TDB>"
msgstr "B<NT_S390_TDB>"

#. type: Plain text
#: build/C/man5/elf.5:2049
msgid "s390 transaction diagnostic block"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2049
#, no-wrap
msgid "B<NT_ARM_VFP>"
msgstr "B<NT_ARM_VFP>"

#. type: Plain text
#: build/C/man5/elf.5:2052
msgid "ARM VFP/NEON registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2052
#, no-wrap
msgid "B<NT_ARM_TLS>"
msgstr "B<NT_ARM_TLS>"

#. type: Plain text
#: build/C/man5/elf.5:2055
msgid "ARM TLS register"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2055
#, no-wrap
msgid "B<NT_ARM_HW_BREAK>"
msgstr "B<NT_ARM_HW_BREAK>"

#. type: Plain text
#: build/C/man5/elf.5:2058
msgid "ARM hardware breakpoint registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2058
#, no-wrap
msgid "B<NT_ARM_HW_WATCH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2061
msgid "ARM hardware watchpoint registers"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2061
#, no-wrap
msgid "B<NT_ARM_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2064
msgid "ARM system call number"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2066
#, no-wrap
msgid "B<n_name = GNU>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2069
msgid "Extensions used by the GNU tool chain."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2070
#, no-wrap
msgid "B<NT_GNU_ABI_TAG>"
msgstr "B<NT_GNU_ABI_TAG>"

#. type: Plain text
#: build/C/man5/elf.5:2074
msgid "Operating system (OS) ABI information.  The desc field will be 4 words:"
msgstr ""

#. type: IP
#: build/C/man5/elf.5:2077 build/C/man5/elf.5:2080 build/C/man5/elf.5:2082
#: build/C/man5/elf.5:2084 build/C/man5/elf.5:2095 build/C/man5/elf.5:2097
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2080
msgid ""
"word 0: OS descriptor (B<ELF_NOTE_OS_LINUX>, B<ELF_NOTE_OS_GNU>, and so on)`"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2082
msgid "word 1: major version of the ABI"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2084
msgid "word 2: minor version of the ABI"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2086
msgid "word 3: subminor version of the ABI"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2088
#, no-wrap
msgid "B<NT_GNU_HWCAP>"
msgstr "B<NT_GNU_HWCAP>"

#. type: Plain text
#: build/C/man5/elf.5:2092
msgid "Synthetic hwcap information.  The desc field begins with two words:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2097
msgid "word 0: number of entries"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2099
msgid "word 1: bit mask of enabled entries"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2105
msgid ""
"Then follow variable-length entries, one byte followed by a null-terminated "
"hwcap name string.  The byte gives the bit number to test if enabled, (1U "
"E<lt>E<lt> bit) & bit mask."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2105
#, no-wrap
msgid "B<NT_GNU_BUILD_ID>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2112
msgid ""
"Unique build ID as generated by the GNU B<ld>(1)  B<--build-id> option.  The "
"desc consists of any nonzero number of bytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2112
#, no-wrap
msgid "B<NT_GNU_GOLD_VERSION>"
msgstr "B<NT_GNU_GOLD_VERSION>"

#. type: Plain text
#: build/C/man5/elf.5:2115
msgid "The desc contains the GNU Gold linker version used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2116
#, no-wrap
msgid "B<Default/unknown namespace (e_type != ET_CORE)>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2121
msgid ""
"These are used when the namespace is the default (i.e., I<n_namesz> will be "
"set to 0), or a fallback when the namespace is unknown."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2122
#, no-wrap
msgid "B<NT_VERSION>"
msgstr "B<NT_VERSION>"

#. type: Plain text
#: build/C/man5/elf.5:2126
msgid "A version string of some sort."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:2126
#, no-wrap
msgid "B<NT_ARCH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2129
msgid "Architecture information."
msgstr "アーキテクチャー情報。"

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: build/C/man5/elf.5:2141
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""
"ELF は System V で初めて登場した。 ELF 自体は System V で初めて登場した。 "
"ELF フォーマットは採択された標準である。"

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: build/C/man5/elf.5:2159
msgid ""
"The extensions for I<e_phnum>, I<e_shnum>, and I<e_shstrndx> respectively "
"are Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""
"I<e_phnum>, I<e_shnum>, I<e_shstrndx> に対する拡張は、いずれも Linux での拡張で\n"
"ある。Sun, BSD, AMD64 もこれに対応している。詳しい情報は、関連項目を参照。"

#. type: Plain text
#: build/C/man5/elf.5:2176
msgid ""
"B<as>(1), B<elfedit>(1), B<gdb>(1), B<ld>(1), B<nm>(1), B<objcopy>(1), "
"B<objdump>(1), B<patchelf>(1), B<readelf>(1), B<size>(1), B<strings>(1), "
"B<strip>(1), B<execve>(2), B<dl_iterate_phdr>(3), B<core>(5), B<ld.so>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:2179
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr "Hewlett-Packard, I<Elf-64 Object File Format>."

#. type: Plain text
#: build/C/man5/elf.5:2182
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr "Santa Cruz Operation, I<System V Application Binary Interface>."

#. type: Plain text
#: build/C/man5/elf.5:2186
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."

#. type: Plain text
#: build/C/man5/elf.5:2189
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr "Sun Microsystems, I<Linker and Libraries Guide>."

#. type: Plain text
#: build/C/man5/elf.5:2192
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture\n"
"Processor Supplement>."

#. type: TH
#: build/C/man3/end.3:26
#, no-wrap
msgid "END"
msgstr "END"

#. type: Plain text
#: build/C/man3/end.3:29
msgid "etext, edata, end - end of program segments"
msgstr "etext, edata, end - プログラムセグメントの終わり"

#. type: Plain text
#: build/C/man3/end.3:34
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"

#. type: Plain text
#: build/C/man3/end.3:38
msgid ""
"The addresses of these symbols indicate the end of various program segments:"
msgstr "これらのシンボルのアドレスは各種のプログラムセグメントの終わりを示す。"

#. type: TP
#: build/C/man3/end.3:38
#, no-wrap
msgid "I<etext>"
msgstr "I<etext>"

#. type: Plain text
#: build/C/man3/end.3:42
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr "テキストセグメント (プログラムのコード) の末尾の次のアドレス。"

#. type: TP
#: build/C/man3/end.3:42
#, no-wrap
msgid "I<edata>"
msgstr "I<edata>"

#. type: Plain text
#: build/C/man3/end.3:46
msgid "This is the first address past the end of the initialized data segment."
msgstr "初期化されたデータのセグメントの末尾の次のアドレス。"

#. type: TP
#: build/C/man3/end.3:46
#, no-wrap
msgid "I<end>"
msgstr "I<end>"

#. type: Plain text
#: build/C/man3/end.3:50
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""
"初期化されていないデータのセグメント (BSS セグメントとも言われる)  の末尾の次"
"のアドレス。"

#. type: Plain text
#: build/C/man3/end.3:53
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""
"これらのシンボルは長年ほとんどの UNIX システムで提供されているが、 標準化され"
"てはいない。注意して使うこと。"

#. type: Plain text
#: build/C/man3/end.3:56
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""
"プログラムではこれらのシンボルは明示的に宣言しなければならない。 これらはどの"
"ヘッダーファイルでも定義されていない。"

#. type: Plain text
#: build/C/man3/end.3:64
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for "
"programs compiled on Linux."
msgstr ""
"いくつかのシステムでは、これらのシンボルの名前は前にアンダースコアが 付いてい"
"て、 I<_etext>, I<_edata>, I<_end> となっている。 Linux でコンパイルされたプ"
"ログラムでは、 これらのシンボルでも定義される。"

#. type: Plain text
#: build/C/man3/end.3:76
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""
"プログラムの実行開始時に、プログラムブレークは I<&end> の近くのどこか (おそら"
"く次のページの先頭) になる。 しかしながら、 B<brk>(2)  や B<malloc>(3)  でメ"
"モリーが割り当てられるに連れて、プログラムブレークは変化していく。 引数に "
"0 を指定して B<sbrk>(2)  を呼び出すことで、プログラムブレークの現在値を知るこ"
"とができる。"

#. type: Plain text
#: build/C/man3/end.3:78
msgid "When run, the program below produces output such as the following:"
msgstr "下記のプログラムを実行すると、次のような出力が得られる。"

#. type: Plain text
#: build/C/man3/end.3:86
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"

#. type: Plain text
#: build/C/man3/end.3:93 build/C/man1/memusage.1:241
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/end.3:96
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"

#. type: Plain text
#: build/C/man3/end.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"

#. type: Plain text
#: build/C/man3/end.3:113
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"

#. type: TH
#: build/C/man8/ld.so.8:7
#, no-wrap
msgid "LD.SO"
msgstr "LD.SO"

#. type: Plain text
#: build/C/man8/ld.so.8:10
msgid "ld.so, ld-linux.so - dynamic linker/loader"
msgstr "ld.so, ld-linux.so - 動的なリンカー/ローダー"

#. type: Plain text
#: build/C/man8/ld.so.8:18
msgid ""
"The dynamic linker can be run either indirectly by running some dynamically "
"linked program or shared object (in which case no command-line options to "
"the dynamic linker can be passed and, in the ELF case, the dynamic linker "
"which is stored in the B<.interp> section of the program is executed) or "
"directly by running:"
msgstr "動的リンカーは、動的にリンクされたプログラムや共有オブジェクトの実行によって 間接的に実行することができる (ELF の場合、動的リンカーにコマンドラインオプションを渡すことはできず、 プログラムの B<.interp> セクションに入っている動的リンカーが実行される)。 また以下のように直接実行することもできる"

#. type: Plain text
#: build/C/man8/ld.so.8:21
msgid "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"
msgstr "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"

#. type: Plain text
#: build/C/man8/ld.so.8:28
msgid ""
"The programs B<ld.so> and B<ld-linux.so*> find and load the shared objects "
"(shared libraries) needed by a program, prepare the program to run, and then "
"run it."
msgstr "プログラム B<ld.so> と B<ld-linux.so*> はプログラムに必要な共有オブジェクト (共有ライブラリ) を見つけてロードし、 プログラムの実行を準備してから起動させる。"

#. type: Plain text
#: build/C/man8/ld.so.8:35
msgid ""
"Linux binaries require dynamic linking (linking at run time)  unless the B<-"
"static> option was given to B<ld>(1)  during compilation."
msgstr ""
"Linux のバイナリは、コンパイルの時に B<ld>(1)  に対して B<-static> オプション"
"が指定されていない限り、動的リンク (実行時リンク) が必要となる。"

#. type: Plain text
#: build/C/man8/ld.so.8:49
#, fuzzy
#| msgid ""
#| "The program B<ld.so> handles a.out binaries, a format used long ago; B<ld-"
#| "linux.so*> handles ELF (I</lib/ld-linux.so.1> for libc5, I</lib/ld-linux."
#| "so.2> for glibc2), which everybody has been using for years now.  "
#| "Otherwise, both have the same behavior, and use the same support files "
#| "and programs B<ldd>(1), B<ldconfig>(8), and I</etc/ld.so.conf>."
msgid ""
"The program B<ld.so> handles a.out binaries, a binary format used long ago.  "
"The program B<ld-linux.so*> (I</lib/ld-linux.so.1> for libc5, I</lib/ld-"
"linux.so.2> for glibc2)  handles binaries that are in the more modern ELF "
"format.  Both programs have the same behavior, and use the same support "
"files and programs (B<ldd>(1), B<ldconfig>(8), and I</etc/ld.so.conf>)."
msgstr ""
"プログラム B<ld.so> は a.out バイナリを扱う。 これはずっと昔に使われていた"
"フォーマットである。 B<ld-linux.so*> (libc5 では I</lib/ld-linux.so.1>, "
"glibc2 では I</lib/ld-linux.so.2>)  は ELF バイナリを扱う。 このフォーマット"
"は多くの人が最近何年も使っている。 それ以外の点では両方とも同じように動作"
"し、 同じサポートファイルとプログラム B<ldd>(1), B<ldconfig>(8), I</etc/ld."
"so.conf> を使用する。"

#. type: Plain text
#: build/C/man8/ld.so.8:57
msgid ""
"When resolving shared object dependencies, the dynamic linker first inspects "
"each dependency string to see if it contains a slash (this can occur if a "
"shared object pathname containing slashes was specified at link time).  If a "
"slash is found, then the dependency string is interpreted as a (relative or "
"absolute) pathname, and the shared object is loaded using that pathname."
msgstr "共有オブジェクトの依存関係を解決する際、動的リンカーは、最初に、依存関係の各文字列がスラッシュを含んでいるかをチェックする (この状況になるのは、リンク時にスラッシュを含む共有オブジェクトのパス名が指定された場合である)。スラッシュが見つかった場合、その依存関係の文字列はパス名 (相対パス、絶対パスのどちらも可) として解釈され、そのパス名を使ってその共有オブジェクトはロードされる。"

#. type: Plain text
#: build/C/man8/ld.so.8:60
msgid ""
"If a shared object dependency does not contain a slash, then it is searched "
"for in the following order:"
msgstr "共有オブジェクトの依存関係にスラッシュが含まれない場合、以下の順序で検索される。"

#. type: Plain text
#: build/C/man8/ld.so.8:65
msgid ""
"Using the directories specified in the DT_RPATH dynamic section attribute of "
"the binary if present and DT_RUNPATH attribute does not exist.  Use of "
"DT_RPATH is deprecated."
msgstr "バイナリの動的セクション属性 DT_RPATH が存在し、 DT_RUNPATH 属性が存在しない場合は、 DT_RPATH で指定されたディレクトリを使用する。 DT_RPATH の使用は推奨されない。"

#. type: Plain text
#: build/C/man8/ld.so.8:70
#, fuzzy
#| msgid ""
#| "Using the environment variable B<LD_LIBRARY_PATH>.  Except if the "
#| "executable is a set-user-ID/set-group-ID binary, in which case it is "
#| "ignored."
msgid ""
"Using the environment variable B<LD_LIBRARY_PATH>, unless the executable is "
"being run in secure-execution mode (see below), in which case this variable "
"is ignored."
msgstr ""
"環境変数 B<LD_LIBRARY_PATH> を用いる。 ただし実行ファイルが set-user-ID/set-"
"group-ID バイナリの場合、 これは無視される。"

#. type: Plain text
#: build/C/man8/ld.so.8:80
msgid ""
"Using the directories specified in the DT_RUNPATH dynamic section attribute "
"of the binary if present.  Such directories are searched only to find those "
"objects required by DT_NEEDED (direct dependencies) entries and do not apply "
"to those objects' children, which must themselves have their own DT_RUNPATH "
"entries.  This is unlike DT_RPATH, which is applied to searches for all "
"children in the dependency tree."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:90
#, fuzzy
#| msgid ""
#| "From the cache file I</etc/ld.so.cache>, which contains a compiled list "
#| "of candidate libraries previously found in the augmented library path.  "
#| "If, however, the binary was linked with the B<-z nodeflib> linker option, "
#| "libraries in the default library paths are skipped.  Libraries installed "
#| "in hardware capability directories (see below)  are preferred to other "
#| "libraries."
msgid ""
"From the cache file I</etc/ld.so.cache>, which contains a compiled list of "
"candidate shared objects previously found in the augmented library path.  "
"If, however, the binary was linked with the B<-z nodeflib> linker option, "
"shared objects in the default paths are skipped.  Shared objects installed "
"in hardware capability directories (see below)  are preferred to other "
"shared objects."
msgstr ""
"キャッシュファイル I</etc/ld.so.cache> を探す。このファイルは、 (ld.so.conf "
"で追加指定されたものも含めた) ライブラリ検索パスから見つかったライブラリファ"
"イルの情報を集めたものである。ただし、バイナリがリンカーオプション B<-z "
"nodeflib> でリンクされている場合は、デフォルトのライブラリパスにある ライブラ"
"リはスキップされる。ハードウェア機能ディレクトリ (下記参照) にインストールさ"
"れたライブラリは、他のライブラリよりも優先される。"

#. type: Plain text
#: build/C/man8/ld.so.8:102
#, fuzzy
#| msgid ""
#| "In the default path I</lib>, and then I</usr/lib>.  If the binary was "
#| "linked with the B<-z nodeflib> linker option, this step is skipped."
msgid ""
"In the default path I</lib>, and then I</usr/lib>.  (On some 64-bit "
"architectures, the default paths for 64-bit shared objects are I</lib64>, "
"and then I</usr/lib64>.)  If the binary was linked with the B<-z nodeflib> "
"linker option, this step is skipped."
msgstr ""
"デフォルトパスである I</lib>、 次いで I</usr/lib> を用いる。 バイナリがリン"
"カーオプション B<-z nodeflib> でリンクされている場合、このステップはスキップ"
"される。"

#. type: SS
#: build/C/man8/ld.so.8:102
#, no-wrap
msgid "Dynamic string tokens"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:105
msgid "In several places, the dynamic linker expands dynamic string tokens:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:111
msgid ""
"In the environment variables B<LD_LIBRARY_PATH>, B<LD_PRELOAD>, and "
"B<LD_AUDIT>,"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:120
msgid ""
"inside the values of the dynamic section tags B<DT_NEEDED>, B<DT_RPATH>, "
"B<DT_RUNPATH>, B<DT_AUDIT>, and B<DT_DEPAUDIT> of ELF binaries,"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:129
msgid ""
"in the arguments to the B<ld.so> command line options B<--audit>, B<--"
"library-path>, and B<--preload> (see below), and"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:135
msgid ""
"in the filename arguments to the B<dlopen>(3)  and B<dlmopen>(3)  functions."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:137
msgid "The substituted tokens are as follows:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:137
#, no-wrap
msgid "I<$ORIGIN> (or equivalently I<${ORIGIN}>)"
msgstr "I<$ORIGIN> (I<${ORIGIN}> も同じ)"

#. type: Plain text
#: build/C/man8/ld.so.8:144
#, fuzzy
msgid ""
"This expands to the directory containing the program or shared object.  "
"Thus, an application located in I<somedir/app> could be compiled with"
msgstr "プログラムや共有オブジェクトが入っているディレクトリに展開される。 したがって、 I<somedir/app> に置かれたアプリケーションを"

#. type: Plain text
#: build/C/man8/ld.so.8:148
#, no-wrap
msgid "gcc -Wl,-rpath,\\(aq$ORIGIN/../lib\\(aq\n"
msgstr "gcc -Wl,-rpath,\\(aq$ORIGIN/../lib\\(aq\n"

#. type: Plain text
#: build/C/man8/ld.so.8:160
msgid ""
"so that it finds an associated shared object in I<somedir/lib> no matter "
"where I<somedir> is located in the directory hierarchy.  This facilitates "
"the creation of \"turn-key\" applications that do not need to be installed "
"into special directories, but can instead be unpacked into any directory and "
"still find their own shared objects."
msgstr "でコンパイルすることで、 I<somedir> がディレクトリ階層のどこにあっても、 B<ld.so> は I<somedir/lib> にある対応する共有オブジェクトを見つけることができる。 この機能を使うと、 特別なディレクトリではなく任意のディレクトリにインストールしても「ややこしい設定なしで」独自の共有オブジェクトを使えるアプリケーションを作成することができる。"

#. type: TP
#: build/C/man8/ld.so.8:160
#, no-wrap
msgid "I<$LIB> (or equivalently I<${LIB}>)"
msgstr "I<$LIB> (I<${LIB}> も同じ)"

#. type: Plain text
#: build/C/man8/ld.so.8:172
msgid ""
"This expands to I<lib> or I<lib64> depending on the architecture (e.g., on "
"x86-64, it expands to I<lib64> and on x86-32, it expands to I<lib>)."
msgstr ""
"アーキテクチャーに応じて I<lib> か I<lib64> に展開される (例えば、 x86-64 で"
"は I<lib64> に、 x86-32 では I<lib> に展開される)。"

#. type: TP
#: build/C/man8/ld.so.8:172
#, no-wrap
msgid "I<$PLATFORM> (or equivalently I<${PLATFORM}>)"
msgstr "I<$PLATFORM> (I<${PLATFORM}> も同じ)"

#
#
#.  To get an idea of the places that $PLATFORM would match,
#.  look at the output of the following:
#.      mkdir /tmp/d
#.      LD_LIBRARY_PATH=/tmp/d strace -e open /bin/date 2>&1 | grep /tmp/d
#.  ld.so lets names be abbreviated, so $O will work for $ORIGIN;
#.  Don't do this!!
#. type: Plain text
#: build/C/man8/ld.so.8:190
msgid ""
"This expands to a string corresponding to the processor type of the host "
"system (e.g., \"x86_64\").  On some architectures, the Linux kernel doesn't "
"provide a platform string to the dynamic linker.  The value of this string "
"is taken from the B<AT_PLATFORM> value in the auxiliary vector (see "
"B<getauxval>(3))."
msgstr ""
"ホストシステムのプロセッサ種別に対応する文字列に展開される (例えば "
"\"x86_64\")。\n"
"いくつかのアーキテクチャーでは、 Linux カーネルから動的リンカーにプラット"
"フォームを表す文字列が提供されない。 この文字列の値は補助ベクトルの "
"B<AT_PLATFORM> 値から取得される (B<getauxval>(3) 参照)。"

#. type: Plain text
#: build/C/man8/ld.so.8:194
msgid ""
"Note that the dynamic string tokens have to be quoted properly when set from "
"a shell, to prevent their expansion as shell or environment variables."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:194 build/C/man8/ldconfig.8:120 build/C/man1/ldd.1:115
#: build/C/man1/memusage.1:134 build/C/man1/memusagestat.1:47
#: build/C/man1/mtrace.1:51 build/C/man1/pldd.1:40 build/C/man1/sprof.1:46
#, no-wrap
msgid "OPTIONS"
msgstr "オプション"

#. type: TP
#: build/C/man8/ld.so.8:195
#, no-wrap
msgid "B<--audit>I< list>"
msgstr "B<--audit>I< list>"

#. type: Plain text
#: build/C/man8/ld.so.8:203
msgid ""
"Use objects named in I<list> as auditors.  The objects in I<list> are "
"delimited by colons."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:203
#, no-wrap
msgid "B<--inhibit-cache>"
msgstr "B<--inhibit-cache>"

#. type: Plain text
#: build/C/man8/ld.so.8:207
msgid "Do not use I</etc/ld.so.cache>."
msgstr "I</etc/ld.so.cache> を使用しない。"

#. type: TP
#: build/C/man8/ld.so.8:207
#, no-wrap
msgid "B<--library-path>I< path>"
msgstr "B<--library-path>I< path>"

#. type: Plain text
#: build/C/man8/ld.so.8:222
msgid ""
"Use I<path> instead of B<LD_LIBRARY_PATH> environment variable setting (see "
"below).  The names I<ORIGIN>, I<LIB>, and I<PLATFORM> are interpreted as for "
"the B<LD_LIBRARY_PATH> environment variable."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:222
#, no-wrap
msgid "B<--inhibit-rpath>I< list>"
msgstr "B<--inhibit-rpath>I< list>"

#. type: Plain text
#: build/C/man8/ld.so.8:230
#, fuzzy
#| msgid ""
#| "Ignore RPATH and RUNPATH information in object names in LIST.  This "
#| "option is ignored if B<ld.so> is set-user-ID or set-group-ID."
msgid ""
"Ignore RPATH and RUNPATH information in object names in I<list>.  This "
"option is ignored when running in secure-execution mode (see below).  The "
"objects in I<list> are delimited by colons or spaces."
msgstr ""
"LIST にあるオブジェクト名の RPATH と RUNPATH の情報を無視する。 B<ld.so> が "
"set-user-ID か set-group-ID されている場合、 このオプションは無視される。"

#. type: TP
#: build/C/man8/ld.so.8:230
#, no-wrap
msgid "B<--list>"
msgstr "B<--list>"

#. type: Plain text
#: build/C/man8/ld.so.8:233
msgid "List all dependencies and how they are resolved."
msgstr "全ての依存関係とその解決法をリストする。"

#. type: TP
#: build/C/man8/ld.so.8:233
#, no-wrap
msgid "B<--preload> I<list> (since glibc 2.30)"
msgstr "B<--preload> I<list> (glibc 2.30 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:243
msgid ""
"Preload the objects specified in I<list>.  The objects in I<list> are "
"delimited by colons or spaces.  The objects are preloaded as explained in "
"the description of the B<LD_PRELOAD> environment variable below."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:251
msgid ""
"By contrast with B<LD_PRELOAD>, the B<--preload> option provides a way to "
"perform preloading for a single executable without affecting preloading "
"performed in any child process that executes a new program."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:251
#, no-wrap
msgid "B<--verify>"
msgstr "B<--verify>"

#. type: Plain text
#: build/C/man8/ld.so.8:255
msgid ""
"Verify that program is dynamically linked and this dynamic linker can handle "
"it."
msgstr ""
"プログラムが動的にリンクされているかと、 動的リンカーがそのプログラムを扱える"
"かを検証する。"

#. type: SH
#: build/C/man8/ld.so.8:255
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man8/ld.so.8:258
msgid ""
"Various environment variables influence the operation of the dynamic linker."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:258
#, no-wrap
msgid "Secure-execution mode"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:281
msgid ""
"For security reasons, if the dynamic linker determines that a binary should "
"be run in secure-execution mode, the effects of some environment variables "
"are voided or modified, and furthermore those environment variables are "
"stripped from the environment, so that the program does not even see the "
"definitions.  Some of these environment variables affect the operation of "
"the dynamic linker itself, and are described below.  Other environment "
"variables treated in this way include: B<GCONV_PATH>, B<GETCONF_DIR>, "
"B<HOSTALIASES>, B<LOCALDOMAIN>, B<LOCPATH>, B<MALLOC_TRACE>, B<NIS_PATH>, "
"B<NLSPATH>, B<RESOLV_HOST_CONF>, B<RES_OPTIONS>, B<TMPDIR>, and B<TZDIR>."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:288
msgid ""
"A binary is executed in secure-execution mode if the B<AT_SECURE> entry in "
"the auxiliary vector (see B<getauxval>(3))  has a nonzero value.  This entry "
"may have a nonzero value for various reasons, including:"
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:288 build/C/man8/ld.so.8:293 build/C/man8/ld.so.8:296
#: build/C/man7/rtld-audit.7:487 build/C/man7/rtld-audit.7:491
#: build/C/man7/rtld-audit.7:499
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man8/ld.so.8:293
msgid ""
"The process's real and effective user IDs differ, or the real and effective "
"group IDs differ.  This typically occurs as a result of executing a set-user-"
"ID or set-group-ID program."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:296
msgid ""
"A process with a non-root user ID executed a binary that conferred "
"capabilities to the process."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:299
msgid "A nonzero value may have been set by a Linux Security Module."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:299
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:301
msgid "Among the more important environment variables are the following:"
msgstr "重要な環境変数には以下のものがある。"

#. type: TP
#: build/C/man8/ld.so.8:301
#, no-wrap
msgid "B<LD_ASSUME_KERNEL> (since glibc 2.2.3)"
msgstr "B<LD_ASSUME_KERNEL> (glibc 2.2.3 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:313
msgid ""
"Each shared object can inform the dynamic linker of the minimum kernel ABI "
"version that it requires.  (This requirement is encoded in an ELF note "
"section that is viewable via I<readelf\\ -n> as a section labeled "
"B<NT_GNU_ABI_TAG>.)  At run time, the dynamic linker determines the ABI "
"version of the running kernel and will reject loading shared objects that "
"specify minimum ABI versions that exceed that ABI version."
msgstr "各共有オブジェクトは動的リンカーに必要なカーネル ABI の最小バージョンを通知することができる (必要なバージョンは ELF の note section に格納され、 I<readelf\\ -n> で B<NT_GNU_ABI_TAG> のラベルが付いたセクションとして見ることができる)。 実行時に、 動的リンカーは実行中のカーネルの ABI バージョンを判定し、 カーネルの ABI バージョンよりも大きな ABI の最小バージョンが指定された共有オブジェクトのロードを行わない。"

#. type: Plain text
#: build/C/man8/ld.so.8:322
msgid ""
"B<LD_ASSUME_KERNEL> can be used to cause the dynamic linker to assume that "
"it is running on a system with a different kernel ABI version.  For example, "
"the following command line causes the dynamic linker to assume it is running "
"on Linux 2.2.5 when loading the shared objects required by I<myprog>:"
msgstr "B<LD_ASSUME_KERNEL> を使うことで、 動的リンカーに、 異なるカーネル ABI バージョンのシステムで実行されているかのように見せることができる。 例えば、 以下のコマンドラインを実行すると、 動的リンカーは I<myprog> が必要とする共有オブジェクトをロードする際に Linux 2.2.5 上で動作していると仮定する。"

#. type: Plain text
#: build/C/man8/ld.so.8:326
#, no-wrap
msgid "$ B<LD_ASSUME_KERNEL=2.2.5 ./myprog>\n"
msgstr "$ B<LD_ASSUME_KERNEL=2.2.5 ./myprog>\n"

#. type: Plain text
#: build/C/man8/ld.so.8:335
msgid ""
"On systems that provide multiple versions of a shared object (in different "
"directories in the search path) that have different minimum kernel ABI "
"version requirements, B<LD_ASSUME_KERNEL> can be used to select the version "
"of the object that is used (dependent on the directory search order)."
msgstr "必要なカーネル ABI の最低バージョンが異なる複数の共有オブジェクトが (検索パス中の異なるディレクトリに) あるシステムでは、 B<LD_ASSUME_KERNEL> を使って (ディレクトリ検索順序に基づき) 使用するオブジェクトのバージョンを選択することができる。"

#. type: Plain text
#: build/C/man8/ld.so.8:344
msgid ""
"Historically, the most common use of the B<LD_ASSUME_KERNEL> feature was to "
"manually select the older LinuxThreads POSIX threads implementation on "
"systems that provided both LinuxThreads and NPTL (which latter was typically "
"the default on such systems); see B<pthreads>(7)."
msgstr "歴史的に見ると、 B<LD_ASSUME_KERNEL> の最も一般的な使い道は、 LinuxThreads と NPTL の両方を提供しているシステムで、 古い LinuxThreads の POSIX スレッド実装を手動で選択するためであった (そのようなシステムでは、通常は NPTL がデフォルトであった)。 B<pthreads>(7) を参照。"

#. type: TP
#: build/C/man8/ld.so.8:344
#, no-wrap
msgid "B<LD_BIND_NOW> (since glibc 2.1.1)"
msgstr "B<LD_BIND_NOW> (glibc 2.1.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:351
msgid ""
"If set to a nonempty string, causes the dynamic linker to resolve all "
"symbols at program startup instead of deferring function call resolution to "
"the point when they are first referenced.  This is useful when using a "
"debugger."
msgstr "空文字列でない場合、 動的リンカーはプログラムの開始時に全てのシンボルを解決する。 空文字列の場合、解決しなければならない関数呼び出しが 最初に参照された時点で解決する。 デバッガを使っているときに役立つ。"

#. type: TP
#: build/C/man8/ld.so.8:351
#, no-wrap
msgid "B<LD_LIBRARY_PATH>"
msgstr "B<LD_LIBRARY_PATH>"

#. type: Plain text
#: build/C/man8/ld.so.8:358
msgid ""
"A list of directories in which to search for ELF libraries at execution "
"time.  The items in the list are separated by either colons or semicolons, "
"and there is no support for escaping either separator.  A zero-length "
"directory name indicates the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:360
msgid "This variable is ignored in secure-execution mode."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:377
msgid ""
"Within the pathnames specified in B<LD_LIBRARY_PATH>, the dynamic linker "
"expands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the versions "
"using curly braces around the names)  as described above in I<Dynamic string "
"tokens>.  Thus, for example, the following would cause a library to be "
"searched for in either the I<lib> or I<lib64> subdirectory below the "
"directory containing the program to be executed:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:381
#, no-wrap
msgid "$ B<LD_LIBRARY_PATH=\\(aq$ORIGIN/$LIB\\(aq prog>\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:389
msgid ""
"(Note the use of single quotes, which prevent expansion of I<$ORIGIN> and I<"
"$LIB> as shell variables!)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:389
#, no-wrap
msgid "B<LD_PRELOAD>"
msgstr "B<LD_PRELOAD>"

#. type: Plain text
#: build/C/man8/ld.so.8:395
msgid ""
"A list of additional, user-specified, ELF shared objects to be loaded before "
"all others.  This feature can be used to selectively override functions in "
"other shared objects."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:401
msgid ""
"The items of the list can be separated by spaces or colons, and there is no "
"support for escaping either separator.  The objects are searched for using "
"the rules given under DESCRIPTION.  Objects are searched for and added to "
"the link map in the left-to-right order specified in the list."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:407
msgid ""
"In secure-execution mode, preload pathnames containing slashes are ignored.  "
"Furthermore, shared objects are preloaded only from the standard search "
"directories and only if they have set-user-ID mode bit enabled (which is not "
"typical)."
msgstr ""

#
#
#.  Tested with the following:
#. 	LD_PRELOAD='$LIB/libmod.so' LD_LIBRARY_PATH=. ./prog
#.  which will preload the libmod.so in 'lib' or 'lib64', using it
#.  in preference to the version in '.'.
#. type: Plain text
#: build/C/man8/ld.so.8:426
msgid ""
"Within the names specified in the B<LD_PRELOAD> list, the dynamic linker "
"understands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the "
"versions using curly braces around the names)  as described above in "
"I<Dynamic string tokens>.  (See also the discussion of quoting under the "
"description of B<LD_LIBRARY_PATH>.)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:429
msgid ""
"There are various methods of specifying libraries to be preloaded, and these "
"are handled in the following order:"
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:430
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:434
msgid "The B<LD_PRELOAD> environment variable."
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:434
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:438
msgid ""
"The B<--preload> command-line option when invoking the dynamic linker "
"directly."
msgstr ""

#. type: IP
#: build/C/man8/ld.so.8:438
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:442
#, fuzzy
#| msgid "I</etc/ld.so.preload>"
msgid "The I</etc/ld.so.preload> file (described below)."
msgstr "I</etc/ld.so.preload>"

#. type: TP
#: build/C/man8/ld.so.8:443
#, no-wrap
msgid "B<LD_TRACE_LOADED_OBJECTS>"
msgstr "B<LD_TRACE_LOADED_OBJECTS>"

#. type: Plain text
#: build/C/man8/ld.so.8:449
#, fuzzy
#| msgid ""
#| "(ELF only)  If set to a nonempty string, causes the program to list its "
#| "dynamic library dependencies, as if run by B<ldd>(1), instead of running "
#| "normally."
msgid ""
"If set (to any value), causes the program to list its dynamic dependencies, "
"as if run by B<ldd>(1), instead of running normally."
msgstr ""
"(ELF のみ)  空文字列でない場合、 プログラムを普通に実行するのではなく、 "
"B<ldd>(1)  を実行したときのように動的ライブラリの依存関係をリスト表示させる。"

#. type: Plain text
#: build/C/man8/ld.so.8:452
msgid ""
"Then there are lots of more or less obscure variables, many obsolete or only "
"for internal use."
msgstr ""
"そして、それほど知られていない環境変数もある。 多くは廃れてしまったものか内部"
"でのみ使用される環境変数である。"

#. type: TP
#: build/C/man8/ld.so.8:452
#, no-wrap
msgid "B<LD_AUDIT> (since glibc 2.4)"
msgstr "B<LD_AUDIT> (glibc 2.4 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:461
#, fuzzy
#| msgid ""
#| "(glibc since 2.4)  A colon-separated list of user-specified, ELF shared "
#| "objects to be loaded before all others in a separate linker namespace (i."
#| "e., one that does not intrude upon the normal symbol bindings that would "
#| "occur in the process).  These libraries can be used to audit the "
#| "operation of the dynamic linker.  B<LD_AUDIT> is ignored for set-user-ID/"
#| "set-group-ID binaries."
msgid ""
"A list of user-specified, ELF shared objects to be loaded before all others "
"in a separate linker namespace (i.e., one that does not intrude upon the "
"normal symbol bindings that would occur in the process)  These objects can "
"be used to audit the operation of the dynamic linker.  The items in the list "
"are colon-separated, and there is no support for escaping the separator."
msgstr ""
"(glibc 2.4 以降)  他のオブジェクトよりも前に、別のリンカー名前空間 (そのプロ"
"セスで行われる 通常のシンボル結合 (symbol bindigns) には関与しない名前空間) "
"で ロードされる、ユーザー指定の ELF 共有オブジェクトのコロン区切りのリスト。 "
"これらのライブラリを使って、動的リンカーの動作を監査することができる。 set-"
"user-ID/set-group-ID されたバイナリでは、 B<LD_AUDIT> は無視される。"

#. type: Plain text
#: build/C/man8/ld.so.8:464
msgid "B<LD_AUDIT> is ignored in secure-execution mode."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:477
#, fuzzy
#| msgid ""
#| "The dynamic linker will notify the audit libraries at so-called auditing "
#| "checkpoints\\(emfor example, loading a new library, resolving a symbol, "
#| "or calling a symbol from another shared object\\(emby calling an "
#| "appropriate function within the audit library.  For details, see B<rtld-"
#| "audit>(7).  The auditing interface is largely compatible with that "
#| "provided on Solaris, as described in its I<Linker and Libraries Guide>, "
#| "in the chapter I<Runtime Linker Auditing Interface>."
msgid ""
"The dynamic linker will notify the audit shared objects at so-called "
"auditing checkpoints\\(emfor example, loading a new shared object, resolving "
"a symbol, or calling a symbol from another shared object\\(emby calling an "
"appropriate function within the audit shared object.  For details, see "
"B<rtld-audit>(7).  The auditing interface is largely compatible with that "
"provided on Solaris, as described in its I<Linker and Libraries Guide>, in "
"the chapter I<Runtime Linker Auditing Interface>."
msgstr ""
"動的リンカーは、いわゆる監査チェックポイント (auditing checkpoints)  におい"
"て、監査 (audit) ライブラリの適切な関数を呼び出すことで、 監査ライブラリへの"
"通知を行う。監査チェックポイントの例としては、 新たなライブラリのロード、シン"
"ボルの解決、別の共有オブジェクト からのシンボルの呼び出し、などがある。 詳細"
"は B<rtld-audit>(7)  を参照してほしい。 audit インターフェースは、Solaris で"
"提供されているものと 大部分は互換性がある。Solaris の audit インターフェース"
"については、 I<Linker and Libraries Guide> の I<Runtime Linker Auditing "
"Interface> の章に説明がある。"

#. type: Plain text
#: build/C/man8/ld.so.8:490
msgid ""
"Within the names specified in the B<LD_AUDIT> list, the dynamic linker "
"understands the tokens I<$ORIGIN>, I<$LIB>, and I<$PLATFORM> (or the "
"versions using curly braces around the names)  as described above in "
"I<Dynamic string tokens>.  (See also the discussion of quoting under the "
"description of B<LD_LIBRARY_PATH>.)"
msgstr ""

#.  commit 8e9f92e9d5d7737afdacf79b76d98c4c42980508
#. type: Plain text
#: build/C/man8/ld.so.8:497
msgid ""
"Since glibc 2.13, in secure-execution mode, names in the audit list that "
"contain slashes are ignored, and only shared objects in the standard search "
"directories that have the set-user-ID mode bit enabled are loaded."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:497
#, no-wrap
msgid "B<LD_BIND_NOT> (since glibc 2.1.95)"
msgstr "B<LD_BIND_NOT> (glibc 2.1.95 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:509
msgid ""
"If this environment variable is set to a nonempty string, do not update the "
"GOT (global offset table) and PLT (procedure linkage table)  after resolving "
"a function symbol.  By combining the use of this variable with B<LD_DEBUG> "
"(with the categories I<bindings> and I<symbols>), one can observe all run-"
"time function bindings."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:509
#, no-wrap
msgid "B<LD_DEBUG> (since glibc 2.1)"
msgstr "B<LD_DEBUG> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:514
msgid ""
"Output verbose debugging information about operation of the dynamic linker.  "
"The content of this variable is one of more of the following categories, "
"separated by colons, commas, or (if the value is quoted) spaces:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:515
#, no-wrap
msgid "I<help>"
msgstr "I<help>"

#. type: Plain text
#: build/C/man8/ld.so.8:522
msgid ""
"Specifying I<help> in the value of this variable does not run the specified "
"program, and displays a help message about which categories can be specified "
"in this environment variable."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:522
#, no-wrap
msgid "I<all>"
msgstr "I<all>"

#. type: Plain text
#: build/C/man8/ld.so.8:529
msgid ""
"Print all debugging information (except I<statistics> and I<unused>; see "
"below)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:529
#, no-wrap
msgid "I<bindings>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:532
msgid "Display information about which definition each symbol is bound to."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:532
#, no-wrap
msgid "I<files>"
msgstr "I<files>"

#. type: Plain text
#: build/C/man8/ld.so.8:535
msgid "Display progress for input file."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:535
#, no-wrap
msgid "I<libs>"
msgstr "I<libs>"

#. type: Plain text
#: build/C/man8/ld.so.8:538
msgid "Display library search paths."
msgstr "ライブラリ検索パスを表示する。"

#. type: TP
#: build/C/man8/ld.so.8:538
#, no-wrap
msgid "I<reloc>"
msgstr "I<reloc>"

#. type: Plain text
#: build/C/man8/ld.so.8:541
msgid "Display relocation processing."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:541
#, no-wrap
msgid "I<scopes>"
msgstr "I<scopes>"

#. type: Plain text
#: build/C/man8/ld.so.8:544
msgid "Display scope information."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:544
#, no-wrap
msgid "I<statistics>"
msgstr "I<statistics>"

#. type: Plain text
#: build/C/man8/ld.so.8:547
msgid "Display relocation statistics."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:547
#, no-wrap
msgid "I<symbols>"
msgstr "I<symbols>"

#. type: Plain text
#: build/C/man8/ld.so.8:550
msgid "Display search paths for each symbol look-up."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:550
#, no-wrap
msgid "I<unused>"
msgstr "I<unused>"

#. type: Plain text
#: build/C/man8/ld.so.8:553
msgid "Determine unused DSOs."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:553
#, no-wrap
msgid "I<versions>"
msgstr "I<versions>"

#. type: Plain text
#: build/C/man8/ld.so.8:556
msgid "Display version dependencies."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:563
msgid ""
"Since glibc 2.3.4, B<LD_DEBUG> is ignored in secure-execution mode, unless "
"the file I</etc/suid-debug> exists (the content of the file is irrelevant)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:563
#, no-wrap
msgid "B<LD_DEBUG_OUTPUT> (since glibc 2.1)"
msgstr "B<LD_DEBUG_OUTPUT> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:572
msgid ""
"By default, B<LD_DEBUG> output is written to standard error.  If "
"B<LD_DEBUG_OUTPUT> is defined, then output is written to the pathname "
"specified by its value, with the suffix \".\" (dot) followed by the process "
"ID appended to the pathname."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:575
msgid "B<LD_DEBUG_OUTPUT> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:575
#, no-wrap
msgid "B<LD_DYNAMIC_WEAK> (since glibc 2.1.91)"
msgstr "B<LD_DYNAMIC_WEAK> (glibc 2.1.91 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:579
msgid ""
"By default, when searching shared libraries to resolve a symbol reference, "
"the dynamic linker will resolve to the first definition it finds."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:588
msgid ""
"Old glibc versions (before 2.2), provided a different behavior: if the "
"linker found a symbol that was weak, it would remember that symbol and keep "
"searching in the remaining shared libraries.  If it subsequently found a "
"strong definition of the same symbol, then it would instead use that "
"definition.  (If no further symbol was found, then the dynamic linker would "
"use the weak symbol that it initially found.)"
msgstr ""

#.  More precisely 2.1.92
#.  See weak handling
#.      https://www.sourceware.org/ml/libc-hacker/2000-06/msg00029.html
#.      To: GNU libc hacker <libc-hacker at sourceware dot cygnus dot com>
#.      Subject: weak handling
#.      From: Ulrich Drepper <drepper at redhat dot com>
#.      Date: 07 Jun 2000 20:08:12 -0700
#.      Reply-To: drepper at cygnus dot com (Ulrich Drepper)
#. type: Plain text
#: build/C/man8/ld.so.8:604
msgid ""
"The old glibc behavior was nonstandard.  (Standard practice is that the "
"distinction between weak and strong symbols should have effect only at "
"static link time.)  In glibc 2.2, the dynamic linker was modified to provide "
"the current behavior (which was the behavior that was provided by most other "
"implementations at that time)."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:614
msgid ""
"Defining the B<LD_DYNAMIC_WEAK> environment variable (with any value) "
"provides the old (nonstandard) glibc behavior, whereby a weak symbol in one "
"shared library may be overridden by a strong symbol subsequently discovered "
"in another shared library.  (Note that even when this variable is set, a "
"strong symbol in a shared library will not override a weak definition of the "
"same symbol in the main program.)"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:618
msgid ""
"Since glibc 2.3.4, B<LD_DYNAMIC_WEAK> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:618
#, no-wrap
msgid "B<LD_HWCAP_MASK> (since glibc 2.1)"
msgstr "B<LD_HWCAP_MASK> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:621
msgid "Mask for hardware capabilities."
msgstr "ハードウェア機能のマスク。"

#. type: TP
#: build/C/man8/ld.so.8:621
#, no-wrap
msgid "B<LD_ORIGIN_PATH> (since glibc 2.1)"
msgstr "B<LD_ORIGIN_PATH> (glibc 2.1 以降)"

#.  Used only if $ORIGIN can't be determined by normal means
#.  (from the origin path saved at load time, or from /proc/self/exe)?
#. type: Plain text
#: build/C/man8/ld.so.8:626
msgid "Path where the binary is found."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:630
msgid "Since glibc 2.4, B<LD_ORIGIN_PATH> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:630
#, no-wrap
msgid "B<LD_POINTER_GUARD> (glibc from 2.4 to 2.22)"
msgstr "B<LD_POINTER_GUARD> (glibc 2.4 から 2.22 まで)"

#.  commit a014cecd82b71b70a6a843e250e06b541ad524f7
#. type: Plain text
#: build/C/man8/ld.so.8:646
msgid ""
"Set to 0 to disable pointer guarding.  Any other value enables pointer "
"guarding, which is also the default.  Pointer guarding is a security "
"mechanism whereby some pointers to code stored in writable program memory "
"(return addresses saved by B<setjmp>(3)  or function pointers used by "
"various glibc internals) are mangled semi-randomly to make it more difficult "
"for an attacker to hijack the pointers for use in the event of a buffer "
"overrun or stack-smashing attack.  Since glibc 2.23, B<LD_POINTER_GUARD> can "
"no longer be used to disable pointer guarding, which is now always enabled."
msgstr "0 に設定すると、ポインター保護 (pointer guarding) が無効になる。 それ以外の値の場合はポインター保護が有効になる。 デフォルトはポインター保護有効である。 ポインター保護はセキュリティ機構の一つで、書き込み可能なプログラムメモリー に格納されたコードへのポインターをほぼランダム化することで、 攻撃者がバッファーオーバーランやスタック破壊 (stack-smashing) 攻撃の際に ポインターを乗っ取ることを困難にするものである。 (glibc 2.23 以降では、ポインター保護を無効化するために B<LD_POINTER_GUARD> が使用されることはなくなり、ポインター保護は常に有効である。)"

#. type: TP
#: build/C/man8/ld.so.8:646
#, no-wrap
msgid "B<LD_PROFILE> (since glibc 2.1)"
msgstr "B<LD_PROFILE> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:652
msgid ""
"The name of a (single) shared object to be profiled, specified either as a "
"pathname or a soname.  Profiling output is appended to the file whose name "
"is: \"I<$LD_PROFILE_OUTPUT>/I<$LD_PROFILE>.profile\"."
msgstr "プロファイルを行う共有オブジェクトの名前。 パス名か共有オブジェクト名 (soname) で指定される。 プロフィールの出力は \"I<$LD_PROFILE_OUTPUT>/I<$LD_PROFILE>.profile\" という名前の ファイルに追記される。"

#. type: Plain text
#: build/C/man8/ld.so.8:656
msgid "Since glibc 2.2.5, B<LD_PROFILE> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:656
#, no-wrap
msgid "B<LD_PROFILE_OUTPUT> (since glibc 2.1)"
msgstr "B<LD_PROFILE_OUTPUT> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:664
msgid ""
"Directory where B<LD_PROFILE> output should be written.  If this variable is "
"not defined, or is defined as an empty string, then the default is I</var/"
"tmp>."
msgstr "B<LD_PROFILE> の出力が書き込まれるディレクトリ。 この変数が定義されていないか、空の文字列が定義されている場合、 デフォルト値は I</var/tmp> となる。"

#. type: Plain text
#: build/C/man8/ld.so.8:673
msgid ""
"B<LD_PROFILE_OUTPUT> is ignored in secure-execution mode; instead I</var/"
"profile> is always used.  (This detail is relevant only before glibc 2.2.5, "
"since in later glibc versions, B<LD_PROFILE> is also ignored in secure-"
"execution mode.)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:673
#, no-wrap
msgid "B<LD_SHOW_AUXV> (since glibc 2.1)"
msgstr "B<LD_SHOW_AUXV> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:678
msgid ""
"If this environment variable is defined (with any value), show the auxiliary "
"array passed up from the kernel (see also B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:682
msgid "Since glibc 2.3.4, B<LD_SHOW_AUXV> is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:682
#, no-wrap
msgid "B<LD_TRACE_PRELINKING> (since glibc 2.4)"
msgstr "B<LD_TRACE_PRELINKING> (glibc 2.4 以降)"

#.  (This is what seems to happen, from experimenting)
#. type: Plain text
#: build/C/man8/ld.so.8:693
msgid ""
"If this environment variable is defined, trace prelinking of the object "
"whose name is assigned to this environment variable.  (Use B<ldd>(1)  to get "
"a list of the objects that might be traced.)  If the object name is not "
"recognized, then all prelinking activity is traced."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:693
#, no-wrap
msgid "B<LD_USE_LOAD_BIAS> (since glibc 2.3.3)"
msgstr "B<LD_USE_LOAD_BIAS> (glibc 2.3.3 以降)"

#.  http://sources.redhat.com/ml/libc-hacker/2003-11/msg00127.html
#.  Subject: [PATCH] Support LD_USE_LOAD_BIAS
#.  Jakub Jelinek
#. type: Plain text
#: build/C/man8/ld.so.8:711
msgid ""
"By default (i.e., if this variable is not defined), executables and "
"prelinked shared objects will honor base addresses of their dependent shared "
"objects and (nonprelinked) position-independent executables (PIEs)  and "
"other shared objects will not honor them.  If B<LD_USE_LOAD_BIAS> is defined "
"with the value 1, both executables and PIEs will honor the base addresses.  "
"If B<LD_USE_LOAD_BIAS> is defined with the value 0, neither executables nor "
"PIEs will honor the base addresses."
msgstr "デフォルトでは (つまり、この変数が定義されていない場合)、 実行ファイルと prelink された共有オブジェクトでは、それらが依存する共有オブジェクトのベースアドレスが尊重される一方、 (prelink されていない) position-independent executables (PIEs) と 他の共有オブジェクトでは依存するライブラリのベースアドレスは 尊重されない。 B<LD_USE_LOAD_BIAS> が値 1 で定義された場合、実行ファイルと PIE のどちらでも ベースアドレスが尊重される。 B<LD_USE_LOAD_BIAS> が値 0 で定義された場合、実行ファイルと PIE のどちらでも ベースアドレスは尊重されない。"

#. type: Plain text
#: build/C/man8/ld.so.8:713
msgid "Since glibc 2.3.3, this variable is ignored in secure-execution mode."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:713
#, no-wrap
msgid "B<LD_VERBOSE> (since glibc 2.1)"
msgstr "B<LD_VERBOSE> (glibc 2.1 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:720
msgid ""
"If set to a nonempty string, output symbol versioning information about the "
"program if the B<LD_TRACE_LOADED_OBJECTS> environment variable has been set."
msgstr "空文字列でない場合に、B<LD_TRACE_LOADED_OBJECTS> 環境変数が設定されていれば、プログラムのシンボルバージョン情報を出力する。"

#. type: TP
#: build/C/man8/ld.so.8:720
#, no-wrap
msgid "B<LD_WARN> (since glibc 2.1.3)"
msgstr "B<LD_WARN> (glibc 2.1.3 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:723
msgid "If set to a nonempty string, warn about unresolved symbols."
msgstr "空文字列でない場合、解決されていないシンボルがあれば警告を出す。"

#. type: TP
#: build/C/man8/ld.so.8:723
#, no-wrap
msgid "B<LD_PREFER_MAP_32BIT_EXEC> (x86-64 only; since glibc 2.23)"
msgstr "B<LD_PREFER_MAP_32BIT_EXEC> (x86-64 のみ; glibc 2.23 以降)"

#. type: Plain text
#: build/C/man8/ld.so.8:735
msgid ""
"According to the Intel Silvermont software optimization guide, for 64-bit "
"applications, branch prediction performance can be negatively impacted when "
"the target of a branch is more than 4\\ GB away from the branch.  If this "
"environment variable is set (to any value), the dynamic linker will first "
"try to map executable pages using the B<mmap>(2)  B<MAP_32BIT> flag, and "
"fall back to mapping without that flag if that attempt fails.  NB: MAP_32BIT "
"will map to the low 2\\ GB (not 4\\ GB) of the address space."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:742
msgid ""
"Because B<MAP_32BIT> reduces the address range available for address space "
"layout randomization (ASLR), B<LD_PREFER_MAP_32BIT_EXEC> is always disabled "
"in secure-execution mode."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:742 build/C/man8/ldconfig.8:196
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: TP
#: build/C/man8/ld.so.8:743 build/C/man8/ldconfig.8:201
#, no-wrap
msgid "I</lib/ld.so>"
msgstr "I</lib/ld.so>"

#. type: Plain text
#: build/C/man8/ld.so.8:746
msgid "a.out dynamic linker/loader"
msgstr "a.out の動的リンカー/ローダー"

#. type: TP
#: build/C/man8/ld.so.8:746
#, no-wrap
msgid "I</lib/ld-linux.so.>{I<1>,I<2>}"
msgstr "I</lib/ld-linux.so.>{I<1>,I<2>}"

#. type: Plain text
#: build/C/man8/ld.so.8:749
msgid "ELF dynamic linker/loader"
msgstr "ELF の動的リンカー/ローダー"

#. type: TP
#: build/C/man8/ld.so.8:749 build/C/man8/ldconfig.8:208
#, no-wrap
msgid "I</etc/ld.so.cache>"
msgstr "I</etc/ld.so.cache>"

#. type: Plain text
#: build/C/man8/ld.so.8:755
msgid ""
"File containing a compiled list of directories in which to search for shared "
"objects and an ordered list of candidate shared objects.  See B<ldconfig>(8)."
msgstr "共有オブジェクトを検索するディレクトリを集めたリストと、 共有オブジェクトの候補の整列リストを含むファイル。 B<ldconfig>(8) 参照。"

#. type: TP
#: build/C/man8/ld.so.8:755
#, no-wrap
msgid "I</etc/ld.so.preload>"
msgstr "I</etc/ld.so.preload>"

#. type: Plain text
#: build/C/man8/ld.so.8:776
msgid ""
"File containing a whitespace-separated list of ELF shared objects to be "
"loaded before the program.  See the discussion of B<LD_PRELOAD> above.  If "
"both B<LD_PRELOAD> and I</etc/ld.so.preload> are employed, the libraries "
"specified by B<LD_PRELOAD> are preloaded first.  I</etc/ld.so.preload> has a "
"system-wide effect, causing the specified libraries to be preloaded for all "
"programs that are executed on the system.  (This is usually undesirable, and "
"is typically employed only as an emergency remedy, for example, as a "
"temporary workaround to a library misconfiguration issue.)"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:776
#, no-wrap
msgid "I<lib*.so*>"
msgstr "I<lib*.so*>"

#. type: Plain text
#: build/C/man8/ld.so.8:779
msgid "shared objects"
msgstr "共有オブジェクト"

#. type: SS
#: build/C/man8/ld.so.8:780
#, no-wrap
msgid "Hardware capabilities"
msgstr ""

#.  Presumably, this info comes from sysdeps/i386/dl-procinfo.c and
#.  similar files
#. type: Plain text
#: build/C/man8/ld.so.8:793
msgid ""
"Some shared objects are compiled using hardware-specific instructions which "
"do not exist on every CPU.  Such objects should be installed in directories "
"whose names define the required hardware capabilities, such as I</usr/lib/"
"sse2/>.  The dynamic linker checks these directories against the hardware of "
"the machine and selects the most suitable version of a given shared object.  "
"Hardware capability directories can be cascaded to combine CPU features.  "
"The list of supported hardware capability names depends on the CPU.  The "
"following names are currently recognized:"
msgstr "いくつかの共有オブジェクトは、(すべての CPU に存在するわけではない)ハードウェア固有の命令を使ってコンパイルされている。そのような共有オブジェクトは、 I</usr/lib/sse2/> のような、必要なハードウェア機能 (hardware capability) を規定する名前のディレクトリにインストールすべきである。動的リンカーは、マシンのハードウェアに基づいてこれらのディレクトリを確認し、指定された共有オブジェクトに最も適したバージョンを選択する。ハードウェア機能ディレクトリはつなげることができ、複数の CPU 機能を組み合わることができる。対応しているハードウェア機能名のリストは CPU に依存する。現在のところ、以下の名前が認識される。"

#. type: TP
#: build/C/man8/ld.so.8:793
#, no-wrap
msgid "B<Alpha>"
msgstr "B<Alpha>"

#. type: Plain text
#: build/C/man8/ld.so.8:796
msgid "ev4, ev5, ev56, ev6, ev67"
msgstr "ev4, ev5, ev56, ev6, ev67"

#. type: TP
#: build/C/man8/ld.so.8:796
#, no-wrap
msgid "B<MIPS>"
msgstr "B<MIPS>"

#. type: Plain text
#: build/C/man8/ld.so.8:799
msgid "loongson2e, loongson2f, octeon, octeon2"
msgstr "loongson2e, loongson2f, octeon, octeon2"

#. type: TP
#: build/C/man8/ld.so.8:799
#, no-wrap
msgid "B<PowerPC>"
msgstr "B<PowerPC>"

#. type: Plain text
#: build/C/man8/ld.so.8:804
msgid ""
"4xxmac, altivec, arch_2_05, arch_2_06, booke, cellbe, dfp, efpdouble, "
"efpsingle, fpu, ic_snoop, mmu, notb, pa6t, power4, power5, power5+, power6x, "
"ppc32, ppc601, ppc64, smt, spe, ucache, vsx"
msgstr ""
"4xxmac, altivec, arch_2_05, arch_2_06, booke, cellbe, dfp, efpdouble, "
"efpsingle, fpu, ic_snoop, mmu, notb, pa6t, power4, power5, power5+, power6x, "
"ppc32, ppc601, ppc64, smt, spe, ucache, vsx"

#. type: TP
#: build/C/man8/ld.so.8:804
#, no-wrap
msgid "B<SPARC>"
msgstr "B<SPARC>"

#. type: Plain text
#: build/C/man8/ld.so.8:807
msgid "flush, muldiv, stbar, swap, ultra3, v9, v9v, v9v2"
msgstr "flush, muldiv, stbar, swap, ultra3, v9, v9v, v9v2"

#. type: TP
#: build/C/man8/ld.so.8:807
#, no-wrap
msgid "B<s390>"
msgstr "B<s390>"

#. type: Plain text
#: build/C/man8/ld.so.8:811
msgid ""
"dfp, eimm, esan3, etf3enh, g5, highgprs, hpage, ldisp, msa, stfle, z900, "
"z990, z9-109, z10, zarch"
msgstr ""
"dfp, eimm, esan3, etf3enh, g5, highgprs, hpage, ldisp, msa, stfle, z900, "
"z990, z9-109, z10, zarch"

#. type: TP
#: build/C/man8/ld.so.8:811
#, no-wrap
msgid "B<x86 (32-bit only)>"
msgstr "B<x86 (32-bit のみ)>"

#. type: Plain text
#: build/C/man8/ld.so.8:815
msgid ""
"acpi, apic, clflush, cmov, cx8, dts, fxsr, ht, i386, i486, i586, i686, mca, "
"mmx, mtrr, pat, pbe, pge, pn, pse36, sep, ss, sse, sse2, tm"
msgstr ""
"acpi, apic, clflush, cmov, cx8, dts, fxsr, ht, i386, i486, i586, i686, mca, "
"mmx, mtrr, pat, pbe, pge, pn, pse36, sep, ss, sse, sse2, tm"

#.  .SH AUTHORS
#.  ld.so: David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus
#.   Torvalds, Lars Wirzenius and Mitch D'Souza
#.  ld\-linux.so: Roland McGrath, Ulrich Drepper and others.
#.  In the above, (libc5) stands for David Engel's ld.so/ld\-linux.so.
#. type: Plain text
#: build/C/man8/ld.so.8:833
msgid ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<sprof>(1), B<dlopen>(3), B<getauxval>(3), "
"B<elf>(5), B<capabilities>(7), B<rtld-audit>(7), B<ldconfig>(8), B<sln>(8)"
msgstr "B<ld>(1), B<ldd>(1), B<pldd>(1), B<sprof>(1), B<dlopen>(3), B<getauxval>(3), B<elf>(5), B<capabilities>(7), B<rtld-audit>(7), B<ldconfig>(8), B<sln>(8)"

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "LDCONFIG"
msgstr "LDCONFIG"

#. type: Plain text
#: build/C/man8/ldconfig.8:25
msgid "ldconfig - configure dynamic linker run-time bindings"
msgstr "ldconfig - 動的リンカーによる実行時の結合関係を設定する"

#. type: Plain text
#: build/C/man8/ldconfig.8:28
msgid ""
"B</sbin/ldconfig> [B<-nNvXV>] [B<-f> I<conf>] [B<-C> I<cache>] [B<-r> "
"I<root>] I<directory>..."
msgstr "B</sbin/ldconfig> [B<-nNvXV>] [B<-f> I<conf>] [B<-C> I<cache>] [B<-r> I<root>] I<directory>..."

#. type: Plain text
#: build/C/man8/ldconfig.8:35
msgid "B</sbin/ldconfig> B<-l> [B<-v>] I<library>..."
msgstr "B</sbin/ldconfig> B<-l> [B<-v>] I<library>..."

#. type: Plain text
#: build/C/man8/ldconfig.8:40
msgid "B</sbin/ldconfig> B<-p>"
msgstr "B</sbin/ldconfig> B<-p>"

#. type: Plain text
#: build/C/man8/ldconfig.8:59
#, fuzzy
#| msgid ""
#| "B<ldconfig> creates the necessary links and cache to the most recent "
#| "shared libraries found in the directories specified on the command line, "
#| "in the file I</etc/ld.so.conf>, and in the trusted directories (I</lib> "
#| "and I</usr/lib>).  The cache is used by the run-time linker, I<ld.so> or "
#| "I<ld-linux.so>.  B<ldconfig> checks the header and filenames of the "
#| "libraries it encounters when determining which versions should have their "
#| "links updated."
msgid ""
"B<ldconfig> creates the necessary links and cache to the most recent shared "
"libraries found in the directories specified on the command line, in the "
"file I</etc/ld.so.conf>, and in the trusted directories, I</lib> and I</usr/"
"lib> (on some 64-bit architectures such as x86-64, I</lib> and I</usr/lib> "
"are the trusted directories for 32-bit libraries, while I</lib64> and I</usr/"
"lib64> are used for 64-bit libraries)."
msgstr ""
"B<ldcofig> は最新の共有ライブラリに対して必要なリンクを作成したり、 ライブラ"
"リをキャッシュしたりする。 ライブラリは、コマンドラインや I</etc/ld.so.conf> "
"ファイルで指定されたディレクトリや、共有ライブラリが 通常置かれるディレクト"
"リ (I</lib> と I</usr/lib>)  から検索される。 キャッシュは実行時リンカー "
"I<ld.so> または I<ld-linux.so> によって使われる。 B<ldconfig> は処理するライ"
"ブラリのヘッダー部分とファイル名をチェックし、 どのバージョンに対してリンクを"
"更新すべきかを判断する。"

#. type: Plain text
#: build/C/man8/ldconfig.8:67
msgid ""
"The cache is used by the run-time linker, I<ld.so> or I<ld-linux.so>.  "
"B<ldconfig> checks the header and filenames of the libraries it encounters "
"when determining which versions should have their links updated."
msgstr "キャッシュは実行時リンカー I<ld.so> または I<ld-linux.so> によって使われる。 B<ldconfig> は処理するライブラリのヘッダー部分とファイル名をチェックし、 どのバージョンに対してリンクを更新すべきかを判断する。"

#.  The following sentence looks suspect
#.  (perhaps historical cruft) -- MTK, Jul 2005
#.  Therefore, when making dynamic libraries,
#.  it is wise to explicitly link against libc (use \-lc).
#. type: Plain text
#: build/C/man8/ldconfig.8:75
msgid ""
"B<ldconfig> will attempt to deduce the type of ELF libraries (i.e., libc5 or "
"libc6/glibc)  based on what C libraries, if any, the library was linked "
"against."
msgstr ""
"B<ldconfig> は ELF ライブラリの種類 (libc5 か libc6/glibc か) を判断すると"
"き、 そのライブラリがリンクしている C ライブラリを参考にする。"

#. type: Plain text
#: build/C/man8/ldconfig.8:96
msgid ""
"Some existing libraries do not contain enough information to allow the "
"deduction of their type.  Therefore, the I</etc/ld.so.conf> file format "
"allows the specification of an expected type.  This is used I<only> for "
"those ELF libraries which we can not work out.  The format is \"dirname=TYPE"
"\", where TYPE can be libc4, libc5, or libc6.  (This syntax also works on "
"the command line.)  Spaces are I<not> allowed.  Also see the B<-p> option.  "
"B<ldconfig> should normally be run by the superuser as it may require write "
"permission on some root owned directories and files."
msgstr ""
"すでに存在しているライブラリの中には、種類を区別するために充分な 情報が含まれ"
"ていないものもある。 このため I</etc/ld.so.conf> ファイルでライブラリの形式を"
"指定することができるようになっている。 これは区別不能な ELF ライブラリ「だ"
"け」に用いるものである。 フォーマットは \"dirname=TYPE\" とする。 ここで "
"TYPE は libc4, libc5, libc6 のいずれかである (この書式はコマンドラインでも使"
"える)。 「スペースを入れてはならない」。 B<-p> オプションも見ておくこと。 "
"B<ldconfig> は通常スーパーユーザー権限で実行しなければならない。 root が所有"
"しているディレクトリやファイルへの書き込み権限が 必要になるからである。"

#. type: Plain text
#: build/C/man8/ldconfig.8:111
msgid ""
"Note that B<ldconfig> will only look at files that are named I<lib*.so*> "
"(for regular shared objects) or I<ld-*.so*> (for the dynamic loader "
"itself).  Other files will be ignored.  Also, B<ldconfig> expects a certain "
"pattern to how the symlinks are set up, like this example, where the middle "
"file (B<libfoo.so.1> here) is the SONAME for the library:"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:115
#, no-wrap
msgid "libfoo.so -E<gt> libfoo.so.1 -E<gt> libfoo.so.1.12\n"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:120
msgid ""
"Failure to follow this pattern may result in compatibility issues after an "
"upgrade."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:121
#, no-wrap
msgid "B<-c> I<fmt>, B<--format=>I<fmt>"
msgstr "B<-c> I<fmt>, B<--format=>I<fmt>"

#.  commit cad64f778aced84efdaa04ae64f8737b86f063ab
#. type: Plain text
#: build/C/man8/ldconfig.8:134
msgid ""
"(Since glibc 2.2)  Cache format to use: I<old>, I<new>, or I<compat>.  Since "
"glibc 2.32, the default is I<new>.  Before that, it was I<compat>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:134
#, no-wrap
msgid "B<-C >I<cache>"
msgstr "B<-C >I<cache>"

#. type: Plain text
#: build/C/man8/ldconfig.8:140
msgid "Use I<cache> instead of I</etc/ld.so.cache>."
msgstr "I<cache> を I</etc/ld.so.cache> の代わりに用いる。"

#. type: TP
#: build/C/man8/ldconfig.8:140
#, no-wrap
msgid "B<-f >I<conf>"
msgstr "B<-f >I<conf>"

#.  FIXME glibc 2.7 added -i
#. type: Plain text
#: build/C/man8/ldconfig.8:147
msgid "Use I<conf> instead of I</etc/ld.so.conf>."
msgstr "I<conf> を I</etc/ld.so.conf> の代わりに用いる。"

#. type: TP
#: build/C/man8/ldconfig.8:147
#, no-wrap
msgid "B<-i>, B<--ignore-aux-cache>"
msgstr "B<-i>, B<--ignore-aux-cache>"

#.              commit 27d9ffda17df4d2388687afd12897774fde39bcc
#. type: Plain text
#: build/C/man8/ldconfig.8:152
msgid "(Since glibc 2.7)  Ignore auxiliary cache file."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:152
#, no-wrap
msgid "B<-l>"
msgstr "B<-l>"

#. type: Plain text
#: build/C/man8/ldconfig.8:158
msgid ""
"(Since glibc 2.2)  Library mode.  Manually link individual libraries.  "
"Intended for use by experts only."
msgstr "(glibc 2.2 以降) ライブラリモード。それぞれのライブラリを手動でリンクする。 熟練者のみが用いるべきである。"

#. type: TP
#: build/C/man8/ldconfig.8:158
#, no-wrap
msgid "B<-n>"
msgstr "B<-n>"

#. type: Plain text
#: build/C/man8/ldconfig.8:166
msgid ""
"Process only the directories specified on the command line.  Don't process "
"the trusted directories, nor those specified in I</etc/ld.so.conf>.  Implies "
"B<-N>."
msgstr "コマンドラインで指定されたディレクトリのみを処理する。 通常共有ライブラリが置かれるディレクトリや I</etc/ld.so.conf> で指定されたディレクトリは処理しない。 暗黙のうちに B<-N> が指定される。"

#. type: TP
#: build/C/man8/ldconfig.8:166
#, no-wrap
msgid "B<-N>"
msgstr "B<-N>"

#. type: Plain text
#: build/C/man8/ldconfig.8:172
msgid ""
"Don't rebuild the cache.  Unless B<-X> is also specified, links are still "
"updated."
msgstr ""
"キャッシュを再構成しない。 同時に B<-X> が同時に指定されなければ、リンクのほ"
"うは更新される。"

#. type: TP
#: build/C/man8/ldconfig.8:172
#, no-wrap
msgid "B<-p>, B<--print-cache>"
msgstr "B<-p>, B<--print-cache>"

#. type: Plain text
#: build/C/man8/ldconfig.8:176
msgid ""
"Print the lists of directories and candidate libraries stored in the current "
"cache."
msgstr ""
"現在のキャッシュに保存されているディレクトリのリストと、 ライブラリの候補を表"
"示する。"

#. type: TP
#: build/C/man8/ldconfig.8:176
#, no-wrap
msgid "B<-r >I<root>"
msgstr "B<-r >I<root>"

#. type: Plain text
#: build/C/man8/ldconfig.8:181
msgid "Change to and use I<root> as the root directory."
msgstr ""
"I<root> にカレントディレクトリを変更し、ここをルートディレクトリとして用い"
"る。"

#. type: TP
#: build/C/man8/ldconfig.8:181 build/C/man1/ldd.1:120
#, no-wrap
msgid "B<-v>, B<--verbose>"
msgstr "B<-v>, B<--verbose>"

#. type: Plain text
#: build/C/man8/ldconfig.8:187
msgid ""
"Verbose mode.  Print current version number, the name of each directory as "
"it is scanned, and any links that are created.  Overrides quiet mode."
msgstr ""
"詳細表示モード。 現在のバージョン番号を表示する。 またそれぞれのディレクトリ"
"をスキャンし、 新しいリンクを生成するたびに、その内容を表示する。 メッセージ"
"抑制モードを上書きする。"

#. type: TP
#: build/C/man8/ldconfig.8:187 build/C/man1/pldd.1:47 build/C/man1/sprof.1:72
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr "B<-V>, B<--version>"

#. type: Plain text
#: build/C/man8/ldconfig.8:190
msgid "Print program version."
msgstr "プログラムのバージョンを表示する。"

#. type: TP
#: build/C/man8/ldconfig.8:190
#, no-wrap
msgid "B<-X>"
msgstr "B<-X>"

#. type: Plain text
#: build/C/man8/ldconfig.8:196
msgid ""
"Don't update links.  Unless B<-N> is also specified, the cache is still "
"rebuilt."
msgstr ""
"リンクを更新しない。 B<-N> が同時に指定されなければ、キャッシュのほうは再構成"
"される。"

#. type: Plain text
#: build/C/man8/ldconfig.8:204
msgid "Run-time linker/loader."
msgstr "実行時リンカー/ローダー。"

#. type: TP
#: build/C/man8/ldconfig.8:204
#, no-wrap
msgid "I</etc/ld.so.conf>"
msgstr "I</etc/ld.so.conf>"

#. type: Plain text
#: build/C/man8/ldconfig.8:208
msgid ""
"File containing a list of directories, one per line, in which to search for "
"libraries."
msgstr "ディレクトリのリストが入ったファイル。 1 行に 1 エントリー。それぞれのディレクトリでライブラリが検索される。"

#. type: Plain text
#: build/C/man8/ldconfig.8:214
msgid ""
"File containing an ordered list of libraries found in the directories "
"specified in I</etc/ld.so.conf>, as well as those found in the trusted "
"directories."
msgstr "I</etc/ld.so.conf> で指定されたディレクトリにあるライブラリ、および信頼されたディレクトリにあるライブラリの順序付きリスト。"

#. type: Plain text
#: build/C/man8/ldconfig.8:218
msgid "B<ldd>(1), B<ld.so>(8)"
msgstr "B<ldd>(1), B<ld.so>(8)"

#. type: TH
#: build/C/man1/ldd.1:14
#, no-wrap
msgid "LDD"
msgstr "LDD"

#. type: TH
#: build/C/man1/ldd.1:14
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:17
msgid "ldd - print shared object dependencies"
msgstr "ldd - 共有オブジェクトへの依存関係を表示する"

#. type: Plain text
#: build/C/man1/ldd.1:19
msgid "B<ldd> [I<option>]... I<file>..."
msgstr "B<ldd> [I<option>]... I<file>..."

#. type: Plain text
#: build/C/man1/ldd.1:28
msgid ""
"B<ldd> prints the shared objects (shared libraries) required by each program "
"or shared object specified on the command line.  An example of its use and "
"output (using B<sed>(1)  to trim leading white space for readability in this "
"page)  is the following:"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:41
#, no-wrap
msgid ""
"$ B<ldd /bin/ls | sed \\(aqs/^ */    /\\(aq>\n"
"    linux-vdso.so.1 (0x00007ffcc3563000)\n"
"    libselinux.so.1 =E<gt> /lib64/libselinux.so.1 (0x00007f87e5459000)\n"
"    libcap.so.2 =E<gt> /lib64/libcap.so.2 (0x00007f87e5254000)\n"
"    libc.so.6 =E<gt> /lib64/libc.so.6 (0x00007f87e4e92000)\n"
"    libpcre.so.1 =E<gt> /lib64/libpcre.so.1 (0x00007f87e4c22000)\n"
"    libdl.so.2 =E<gt> /lib64/libdl.so.2 (0x00007f87e4a1e000)\n"
"    /lib64/ld-linux-x86-64.so.2 (0x00005574bf12e000)\n"
"    libattr.so.1 =E<gt> /lib64/libattr.so.1 (0x00007f87e4817000)\n"
"    libpthread.so.0 =E<gt> /lib64/libpthread.so.0 (0x00007f87e45fa000)\n"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:68
#, fuzzy
#| msgid ""
#| "In the usual case, B<ldd> invokes the standard dynamic linker (see B<ld."
#| "so>(8))  with the B<LD_TRACE_LOADED_OBJECTS> environment variable set to "
#| "1, which causes the linker to display the library dependencies.  Be "
#| "aware, however, that in some circumstances, some versions of B<ldd> may "
#| "attempt to obtain the dependency information by directly executing the "
#| "program.  Thus, you should I<never> employ B<ldd> on an untrusted "
#| "executable, since this may result in the execution of arbitrary code.  A "
#| "safer alternative when dealing with untrusted executables is:"
msgid ""
"In the usual case, B<ldd> invokes the standard dynamic linker (see B<ld."
"so>(8))  with the B<LD_TRACE_LOADED_OBJECTS> environment variable set to 1.  "
"This causes the dynamic linker to inspect the program's dynamic "
"dependencies, and find (according to the rules described in B<ld.so>(8))  "
"and load the objects that satisfy those dependencies.  For each dependency, "
"B<ldd> displays the location of the matching object and the (hexadecimal) "
"address at which it is loaded.  (The I<linux-vdso> and I<ld-linux> shared "
"dependencies are special; see B<vdso>(7)  and B<ld.so>(8).)"
msgstr ""
"通常の場合、 B<ldd> は標準の動的リンカー (B<ld.so>(8) 参照) を "
"B<LD_TRACE_LOADED_OBJECTS> 環境変数に 1 をセットして起動する。 "
"B<LD_TRACE_LOADED_OBJECTS> に 1 をセットすると、リンカーはライブラリの依存関"
"係を表示する。但し、状況次第では、依存関係の情報を得るのにプログラムを直接実"
"行するバージョンの B<ldd> が存在する。したがって、信頼できない実行ファイルに"
"対しては「決して」 B<ldd> を使っては「ならない」。任意のコードを実行すること"
"につながるからである。信頼できない実行ファイルを扱う、より安全な別の方法とし"
"ては次のようにするとよい。"

#. type: SS
#: build/C/man1/ldd.1:68
#, no-wrap
msgid "Security"
msgstr "セキュリティ"

#.  The circumstances are where the program has an interpreter
#.  other than ld-linux.so. In this case, ldd tries to execute the
#.  program directly with LD_TRACE_LOADED_OBJECTS=1, with the
#.  result that the program interpreter gets control, and can do
#.  what it likes, or pass control to the program itself.
#.  Much more detail at
#.  http://www.catonmat.net/blog/ldd-arbitrary-code-execution/
#.  Mainline glibc's ldd allows this possibility (the line
#.       try_trace "$file"
#.  in glibc 2.15, for example), but many distro versions of
#.  ldd seem to remove that code path from the script.
#.  glibc commit eedca9772e99c72ab4c3c34e43cc764250aa3e3c
#. type: Plain text
#: build/C/man1/ldd.1:96
msgid ""
"Be aware that in some circumstances (e.g., where the program specifies an "
"ELF interpreter other than I<ld-linux.so>), some versions of B<ldd> may "
"attempt to obtain the dependency information by attempting to directly "
"execute the program, which may lead to the execution of whatever code is "
"defined in the program's ELF interpreter, and perhaps to execution of the "
"program itself.  (In glibc versions before 2.27, the upstream B<ldd> "
"implementation did this for example, although most distributions provided a "
"modified version that did not.)"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:104
msgid ""
"Thus, you should I<never> employ B<ldd> on an untrusted executable, since "
"this may result in the execution of arbitrary code.  A safer alternative "
"when dealing with untrusted executables is:"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:108
#, no-wrap
msgid "$ B<objdump -p /path/to/program | grep NEEDED>\n"
msgstr "$ B<objdump -p /path/to/program | grep NEEDED>\n"

#. type: Plain text
#: build/C/man1/ldd.1:115
msgid ""
"Note, however, that this alternative shows only the direct dependencies of "
"the executable, while B<ldd> shows the entire dependency tree of the "
"executable."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:116 build/C/man1/mtrace.1:55
#, no-wrap
msgid "B<--version>"
msgstr "B<--version>"

#. type: Plain text
#: build/C/man1/ldd.1:120
msgid "Print the version number of B<ldd>."
msgstr "B<ldd> のバージョン番号を表示する。"

#. type: Plain text
#: build/C/man1/ldd.1:124
msgid ""
"Print all information, including, for example, symbol versioning information."
msgstr "シンボルのバージョン情報などを含めた全ての情報を表示する。"

#. type: TP
#: build/C/man1/ldd.1:124
#, no-wrap
msgid "B<-u>, B<--unused>"
msgstr "B<-u>, B<--unused>"

#. type: Plain text
#: build/C/man1/ldd.1:128
msgid "Print unused direct dependencies.  (Since glibc 2.3.4.)"
msgstr "使用されていない直接の依存関係を表示する (glibc 2.3.4 以降)。"

#. type: TP
#: build/C/man1/ldd.1:128
#, no-wrap
msgid "B<-d>, B<--data-relocs>"
msgstr "B<-d>, B<--data-relocs>"

#. type: Plain text
#: build/C/man1/ldd.1:131
msgid "Perform relocations and report any missing objects (ELF only)."
msgstr ""
"リロケーションを実行し、足りないオブジェクトについてレポートする (ELF のみ)。"

#. type: TP
#: build/C/man1/ldd.1:131
#, no-wrap
msgid "B<-r>, B<--function-relocs>"
msgstr "B<-r>, B<--function-relocs>"

#. type: Plain text
#: build/C/man1/ldd.1:135
msgid ""
"Perform relocations for both data objects and functions, and report any "
"missing objects or functions (ELF only)."
msgstr "足りないオブジェクトや関数についてレポートする (ELF のみ)。"

#. type: TP
#: build/C/man1/ldd.1:135 build/C/man1/mtrace.1:52
#, no-wrap
msgid "B<--help>"
msgstr "B<--help>"

#.  .SH NOTES
#.  The standard version of
#.  .B ldd
#.  comes with glibc2.
#.  Libc5 came with an older version, still present
#.  on some systems.
#.  The long options are not supported by the libc5 version.
#.  On the other hand, the glibc2 version does not support
#.  .B \-V
#.  and only has the equivalent
#.  .BR \-\-version .
#.  .LP
#.  The libc5 version of this program will use the name of a library given
#.  on the command line as-is when it contains a \(aq/\(aq; otherwise it
#.  searches for the library in the standard locations.
#.  To run it
#.  on a shared library in the current directory, prefix the name with "./".
#. type: Plain text
#: build/C/man1/ldd.1:155
msgid "Usage information."
msgstr "使用法を表示する。"

#. type: Plain text
#: build/C/man1/ldd.1:158
msgid "B<ldd> does not work on a.out shared libraries."
msgstr "B<ldd> は a.out 共有ライブラリでは動作しない。"

#.  .SH AUTHOR
#.  David Engel.
#.  Roland McGrath and Ulrich Drepper.
#. type: Plain text
#: build/C/man1/ldd.1:172
msgid ""
"B<ldd> does not work with some extremely old a.out programs which were built "
"before B<ldd> support was added to the compiler releases.  If you use B<ldd> "
"on one of these programs, the program will attempt to run with I<argc> = 0 "
"and the results will be unpredictable."
msgstr ""
"B<ldd> は非常に古い a.out プログラム (B<ldd> のサポートがコンパイラに追加され"
"る以前にビルドされたようなプログラム)  では動作しない。 このようなプログラム"
"に対して B<ldd> を用いると、プログラムは I<argc> = 0 で実行される。結果は予想"
"不可能である。"

#. type: Plain text
#: build/C/man1/ldd.1:177
msgid "B<pldd>(1), B<sprof>(1), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<pldd>(1), B<sprof>(1), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: build/C/man1/memusage.1:24
#, no-wrap
msgid "MEMUSAGE"
msgstr "MEMUSAGE"

#. type: TH
#: build/C/man1/memusage.1:24 build/C/man1/mtrace.1:23
#, no-wrap
msgid "Linux user manual"
msgstr "Linux user manual"

#. type: Plain text
#: build/C/man1/memusage.1:27
msgid "memusage - profile memory usage of a program"
msgstr "memusage - プログラムのメモリー使用量のプロファイルを行う"

#. type: Plain text
#: build/C/man1/memusage.1:29
msgid "B<memusage> [I<option>]... I<program> [I<programoption>]..."
msgstr "B<memusage> [I<option>]... I<program> [I<programoption>]..."

#. type: Plain text
#: build/C/man1/memusage.1:53
msgid ""
"B<memusage> is a bash script which profiles memory usage of the program, "
"I<program>.  It preloads the B<libmemusage.so> library into the caller's "
"environment (via the B<LD_PRELOAD> environment variable; see B<ld.so>(8)).  "
"The B<libmemusage.so> library traces memory allocation by intercepting calls "
"to B<malloc>(3), B<calloc>(3), B<free>(3), and B<realloc>(3); optionally, "
"calls to B<mmap>(2), B<mremap>(2), and B<munmap>(2)  can also be intercepted."
msgstr ""
"B<memusage> は、 プログラム I<program> のメモリー使用量のプロファイルを行う "
"bash スクリプトである。 呼び出し元の環境に (B<LD_PRELOAD> 環境変数を使って) "
"B<libmemusage.so> ライブラリをプレロードする。 B<ld.so>(8) を参照。 "
"B<libmemusage.so> ライブラリは、 B<malloc>(3), B<calloc>(3), B<free>(3), "
"B<realloc>(3) の呼び出しを横取りし、 メモリー割り当て状況の追跡を行う。 追加"
"で、 B<mmap>(2), B<mremap>(2), B<munmap>(2) を追跡することもできる。"

#. type: Plain text
#: build/C/man1/memusage.1:62
msgid ""
"B<memusage> can output the collected data in textual form, or it can use "
"B<memusagestat>(1)  (see the B<-p> option, below)  to create a PNG file "
"containing graphical representation of the collected data."
msgstr ""
"B<memusage> は収集したデータをテキスト形式で出力することもできるし、 "
"B<memusagestat>(1) を使って収集したデータをグラフにした PNG ファイルを作成す"
"ることもできる (以下の B<-p> オプションを参照)。"

#. type: SS
#: build/C/man1/memusage.1:62
#, no-wrap
msgid "Memory usage summary"
msgstr "メモリー使用量概要"

#. type: Plain text
#: build/C/man1/memusage.1:66
msgid ""
"The \"Memory usage summary\" line output by B<memusage> contains three "
"fields:"
msgstr ""
"B<memusage> が出力する \"Memory usage summary\" (メモリー使用量概要) の行には"
"以下のフィールドが含まれる。"

#. type: TP
#: build/C/man1/memusage.1:67
#, no-wrap
msgid "B<heap total>"
msgstr "B<heap total>"

#. type: Plain text
#: build/C/man1/memusage.1:84
msgid ""
"Sum of I<size> arguments of all B<malloc>(3)  calls, products of arguments "
"(I<nmemb>*I<size>) of all B<calloc>(3)  calls, and sum of I<length> "
"arguments of all B<mmap>(2)  calls.  In the case of B<realloc>(3)  and "
"B<mremap>(2), if the new size of an allocation is larger than the previous "
"size, the sum of all such differences (new size minus old size) is added."
msgstr ""
"B<malloc>(3) のすべての呼び出しの I<size> 引数の合計、 B<calloc>(3) のすべ"
"ての呼び出しの引数の積 (I<nmemb>*I<size>)、 B<mmap>(2) のすべての呼び出し"
"の I<length> 引数の合計。 B<realloc>(3) と B<mremap>(2) の場合、 割り当ての"
"新しいサイズが以前のサイズよりも大きい場合、 差分 (新しいサイズから古いサイズ"
"を引いた値) の合計が加算される。"

#. type: TP
#: build/C/man1/memusage.1:84
#, no-wrap
msgid "B<heap peak>"
msgstr "B<heap peak>"

#. type: Plain text
#: build/C/man1/memusage.1:98
msgid ""
"Maximum of all I<size> arguments of B<malloc>(3), all products of "
"I<nmemb>*I<size> of B<calloc>(3), all I<size> arguments of B<realloc>(3), "
"I<length> arguments of B<mmap>(2), and I<new_size> arguments of B<mremap>(2)."
msgstr ""
"B<malloc>(3) の I<size> 引数、 B<calloc>(3) の I<nmemb>*I<size> の積、 "
"B<realloc>(3) の I<size> 引数、 B<mmap>(2) の I<length> 引数、 "
"B<mremap>(2) の I<new_size> 引数、 の中の最大値。"

#. type: TP
#: build/C/man1/memusage.1:98
#, no-wrap
msgid "B<stack peak>"
msgstr "B<stack peak>"

#. type: Plain text
#: build/C/man1/memusage.1:105
msgid ""
"Before the first call to any monitored function, the stack pointer address "
"(base stack pointer) is saved.  After each function call, the actual stack "
"pointer address is read and the difference from the base stack pointer "
"computed.  The maximum of these differences is then the stack peak."
msgstr ""
"監視される関数の最初の呼び出しが行われる前に、 スタックポインターアドレス "
"(ベーススタックポインター) が保存される。 関数のそれぞれの呼び出し後には、 実"
"際のスタックポインターアドレスを読み込み、 ベースポインターアドレスを元に差分"
"を計算する。これらの差分の最大値がスタックのピーク値となる。"

#. type: Plain text
#: build/C/man1/memusage.1:122
msgid ""
"Immediately following this summary line, a table shows the number calls, "
"total memory allocated or deallocated, and number of failed calls for each "
"intercepted function.  For B<realloc>(3)  and B<mremap>(2), the additional "
"field \"nomove\" shows reallocations that changed the address of a block, "
"and the additional \"dec\" field shows reallocations that decreased the size "
"of the block.  For B<realloc>(3), the additional field \"free\" shows "
"reallocations that caused a block to be freed (i.e., the reallocated size "
"was 0)."
msgstr ""
"この概要行の直後には、 監視対象の各関数の呼び出し回数、 割り当て・割り当て解"
"除された全メモリー量、 失敗した回数がテーブルで表示される。 B<realloc>(3) と "
"B<mremap>(2) の場合には、 フィールド \"nomove\" でブロックアドレスを変更した"
"再割り当て数を、 フィールド \"dec\" でブロックサイズが減少した再割り当て数が"
"追加で表示される。 B<realloc>(3) の場合、 フィールド \"free\" でブロックの解"
"放が行われた再割り当て (サイズが 0 の再割り当て) の数も追加で表示される。"

#. type: Plain text
#: build/C/man1/memusage.1:131
msgid ""
"The \"realloc/total memory\" of the table output by B<memusage> does not "
"reflect cases where B<realloc>(3)  is used to reallocate a block of memory "
"to have a smaller size than previously.  This can cause sum of all \"total "
"memory\" cells (excluding \"free\")  to be larger than the \"free/total "
"memory\" cell."
msgstr ""
"B<memusage> が出力するテーブルの \"realloc/total memory\" (再割り当てメモ"
"リー/全メモリー) には、 B<realloc>(3) を使ってメモリーブロックをその前よりも"
"小さいサイズに再割り当てされた場合は含まれない。 このため、 (\"free\" 以外"
"の) すべての「総メモリー」のセルは \"free/total memory\" セルよりも大きくなる"
"ことがある。"

#. type: SS
#: build/C/man1/memusage.1:131
#, no-wrap
msgid "Histogram for block sizes"
msgstr "ブロックサイズのヒストグラム"

#. type: Plain text
#: build/C/man1/memusage.1:134
msgid ""
"The \"Histogram for block sizes\" provides a breakdown of memory allocations "
"into various bucket sizes."
msgstr ""
"\"Histogram for block sizes\" (ブロックサイズのヒストグラム) は、 メモリー割"
"り当てをバケットサイズ単位に分割した情報である。"

#. type: TP
#: build/C/man1/memusage.1:135
#, no-wrap
msgid "B<-n\\ >I<name>,\\ B<--progname=>I<name>"
msgstr "B<-n\\ >I<name>,\\ B<--progname=>I<name>"

#. type: Plain text
#: build/C/man1/memusage.1:138
msgid "Name of the program file to profile."
msgstr "プロファイル対象のプログラムファイル名。"

#. type: TP
#: build/C/man1/memusage.1:138
#, no-wrap
msgid "B<-p\\ >I<file>,\\ B<--png=>I<file>"
msgstr "B<-p\\ >I<file>,\\ B<--png=>I<file>"

#. type: Plain text
#: build/C/man1/memusage.1:142
msgid "Generate PNG graphic and store it in I<file>."
msgstr "PNG 画像を生成し、 I<file> に格納する。"

#. type: TP
#: build/C/man1/memusage.1:142
#, no-wrap
msgid "B<-d\\ >I<file>,\\ B<--data=>I<file>"
msgstr "B<-d\\ >I<file>,\\ B<--data=>I<file>"

#. type: Plain text
#: build/C/man1/memusage.1:146
msgid "Generate binary data file and store it in I<file>."
msgstr "バイナリーデータファイルを生成し、 I<file> に格納する。"

#. type: TP
#: build/C/man1/memusage.1:146
#, no-wrap
msgid "B<-u>,\\ B<--unbuffered>"
msgstr "B<-u>,\\ B<--unbuffered>"

#. type: Plain text
#: build/C/man1/memusage.1:149
msgid "Do not buffer output."
msgstr "出力バッファーリングを行わない。"

#. type: TP
#: build/C/man1/memusage.1:149
#, no-wrap
msgid "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"
msgstr "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"

#. type: Plain text
#: build/C/man1/memusage.1:154
msgid "Collect I<size> entries before writing them out."
msgstr "出力する前に I<size> 個のエントリーの収集を行う。"

#. type: TP
#: build/C/man1/memusage.1:154
#, no-wrap
msgid "B<--no-timer>"
msgstr "B<--no-timer>"

#. type: Plain text
#: build/C/man1/memusage.1:159
msgid "Disable timer-based (B<SIGPROF>)  sampling of stack pointer value."
msgstr ""
"スタックポインター値の時間ベースのサンプリング (B<SIGPROF>) を無効にする。"

#. type: TP
#: build/C/man1/memusage.1:159
#, no-wrap
msgid "B<-m>,\\ B<--mmap>"
msgstr "B<-m>,\\ B<--mmap>"

#. type: Plain text
#: build/C/man1/memusage.1:166
msgid "Also trace B<mmap>(2), B<mremap>(2), and B<munmap>(2)."
msgstr "B<mmap>(2), B<mremap>(2), B<munmap>(2) も追跡対象とする。"

#. type: TP
#: build/C/man1/memusage.1:166 build/C/man1/memusagestat.1:72
#, no-wrap
msgid "B<-?>,\\ B<--help>"
msgstr "B<-?>,\\ B<--help>"

#. type: Plain text
#: build/C/man1/memusage.1:169 build/C/man1/mtrace.1:55
msgid "Print help and exit."
msgstr "ヘルプを表示し、終了する。"

#. type: TP
#: build/C/man1/memusage.1:169 build/C/man1/memusagestat.1:75
#: build/C/man1/pldd.1:44 build/C/man1/sprof.1:69
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: build/C/man1/memusage.1:172 build/C/man1/memusagestat.1:78
msgid "Print a short usage message and exit."
msgstr "簡潔な使用方法を表示して終了する。"

#. type: TP
#: build/C/man1/memusage.1:172 build/C/man1/memusagestat.1:78
#, no-wrap
msgid "B<-V>,\\ B<--version>"
msgstr "B<-V>,\\ B<--version>"

#. type: Plain text
#: build/C/man1/memusage.1:175 build/C/man1/memusagestat.1:81
#: build/C/man1/mtrace.1:58
msgid "Print version information and exit."
msgstr "バージョン情報を表示して終了する。"

#. type: TP
#: build/C/man1/memusage.1:175
#, no-wrap
msgid "The following options apply only when generating graphical output:"
msgstr "以下のオプションは画像出力を行う場合にのみ適用される。"

#. type: TP
#: build/C/man1/memusage.1:177
#, no-wrap
msgid "B<-t>,\\ B<--time-based>"
msgstr "B<-t>,\\ B<--time-based>"

#. type: Plain text
#: build/C/man1/memusage.1:180 build/C/man1/memusagestat.1:59
msgid ""
"Use time (rather than number of function calls) as the scale for the X axis."
msgstr "X 軸の目盛として (関数呼び出し数ではなく) 時間を使用する。"

#. type: TP
#: build/C/man1/memusage.1:180 build/C/man1/memusagestat.1:59
#, no-wrap
msgid "B<-T>,\\ B<--total>"
msgstr "B<-T>,\\ B<--total>"

#. type: Plain text
#: build/C/man1/memusage.1:183
msgid "Also draw a graph of total memory use."
msgstr "メモリーの全使用量のグラフも生成する。"

#. type: TP
#: build/C/man1/memusage.1:183
#, no-wrap
msgid "B<--title=>I<name>"
msgstr "B<--title=>I<name>"

#. type: Plain text
#: build/C/man1/memusage.1:188
msgid "Use I<name> as the title of the graph."
msgstr "グラフのタイトルとして I<name> を使用する。"

#. type: TP
#: build/C/man1/memusage.1:188 build/C/man1/memusagestat.1:62
#, no-wrap
msgid "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"
msgstr "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"

#. type: Plain text
#: build/C/man1/memusage.1:193
msgid "Make the graph I<size> pixels wide."
msgstr "グラフの幅を I<size> ピクセルにする。"

#. type: TP
#: build/C/man1/memusage.1:193 build/C/man1/memusagestat.1:67
#, no-wrap
msgid "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"
msgstr "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"

#. type: Plain text
#: build/C/man1/memusage.1:198
msgid "Make the graph I<size> pixels high."
msgstr "グラフの高さを I<size> ピクセルにする。"

#. type: SH
#: build/C/man1/memusage.1:198 build/C/man1/pldd.1:50
#, no-wrap
msgid "EXIT STATUS"
msgstr "終了ステータス"

#. type: Plain text
#: build/C/man1/memusage.1:200
msgid "Exit status is equal to the exit status of profiled program."
msgstr ""
"終了ステータスはプロファイルしたプログラムの終了ステータスと同じになる。"

#. type: Plain text
#: build/C/man1/memusage.1:204 build/C/man1/memusagestat.1:85
msgid ""
"To report bugs, see E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE>"
msgstr ""
"バグ報告については E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE> "
"を参照のこと。"

#. type: Plain text
#: build/C/man1/memusage.1:211
msgid ""
"Below is a simple program that reallocates a block of memory in cycles that "
"rise to a peak before then cyclically reallocating the memory in smaller "
"blocks that return to zero.  After compiling the program and running the "
"following commands, a graph of the memory usage of the program can be found "
"in the file I<memusage.png>:"
msgstr ""
"以下の簡単なプログラムは、 ピークに達するまで繰り返しメモリーブロックの再割り"
"当てを行い、 その後ブロックサイズが 0 になるまで繰り返し順に小さなブロックに"
"再割り当てを行う。 このプログラムをコンパイルして以下のコマンドを実行する"
"と、 このプログラムのメモリー使用量がファイル I<memusage.png> に出力される。"

#. type: Plain text
#: build/C/man1/memusage.1:235
#, no-wrap
msgid ""
"$ B<memusage --data=memusage.dat ./a.out>\n"
"\\&...\n"
"Memory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n"
"        total calls  total memory  failed calls\n"
" malloc|         1           400             0\n"
"realloc|        40         44800             0  (nomove:40, dec:19, free:0)\n"
" calloc|         0             0             0\n"
"   free|         1           440\n"
"Histogram for block sizes:\n"
"  192-207             1   2% ================\n"
"\\&...\n"
" 2192-2207            1   2% ================\n"
" 2240-2255            2   4% =================================\n"
" 2832-2847            2   4% =================================\n"
" 3440-3455            2   4% =================================\n"
" 4032-4047            2   4% =================================\n"
" 4640-4655            2   4% =================================\n"
" 5232-5247            2   4% =================================\n"
" 5840-5855            2   4% =================================\n"
" 6432-6447            1   2% ================\n"
"$ B<memusagestat memusage.dat memusage.png>\n"
msgstr ""
"$ B<memusage --data=memusage.dat ./a.out>\n"
"\\&...\n"
"Memory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n"
"        total calls  total memory  failed calls\n"
" malloc|         1           400             0\n"
"realloc|        40         44800             0  (nomove:40, dec:19, free:0)\n"
" calloc|         0             0             0\n"
"   free|         1           440\n"
"Histogram for block sizes:\n"
"  192-207             1   2% ================\n"
"\\&...\n"
" 2192-2207            1   2% ================\n"
" 2240-2255            2   4% =================================\n"
" 2832-2847            2   4% =================================\n"
" 3440-3455            2   4% =================================\n"
" 4032-4047            2   4% =================================\n"
" 4640-4655            2   4% =================================\n"
" 5232-5247            2   4% =================================\n"
" 5840-5855            2   4% =================================\n"
" 6432-6447            1   2% ================\n"
"$ B<memusagestat memusage.dat memusage.png>\n"

#. type: Plain text
#: build/C/man1/memusage.1:243
#, no-wrap
msgid "#define CYCLES 20\n"
msgstr "#define CYCLES 20\n"

#. type: Plain text
#: build/C/man1/memusage.1:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, j;\n"
"    size_t size;\n"
"    int *p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, j;\n"
"    size_t size;\n"
"    int *p;\n"

#. type: Plain text
#: build/C/man1/memusage.1:254
#, no-wrap
msgid ""
"    size = sizeof(*p) * 100;\n"
"    printf(\"malloc: %zu\\en\", size);\n"
"    p = malloc(size);\n"
msgstr ""
"    size = sizeof(*p) * 100;\n"
"    printf(\"malloc: %zu\\en\", size);\n"
"    p = malloc(size);\n"

#. type: Plain text
#: build/C/man1/memusage.1:260
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> CYCLES; i++) {\n"
"        if (i E<lt> CYCLES / 2)\n"
"            j = i;\n"
"        else\n"
"            j--;\n"
msgstr ""
"    for (i = 0; i E<lt> CYCLES; i++) {\n"
"        if (i E<lt> CYCLES / 2)\n"
"            j = i;\n"
"        else\n"
"            j--;\n"

#. type: Plain text
#: build/C/man1/memusage.1:264
#, no-wrap
msgid ""
"        size = sizeof(*p) * (j * 50 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"
msgstr ""
"        size = sizeof(*p) * (j * 50 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"

#. type: Plain text
#: build/C/man1/memusage.1:269
#, no-wrap
msgid ""
"        size = sizeof(*p) * ((j + 1) * 150 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"
"    }\n"
msgstr ""
"        size = sizeof(*p) * ((j + 1) * 150 + 110);\n"
"        printf(\"realloc: %zu\\en\", size);\n"
"        p = realloc(p, size);\n"
"    }\n"

#. type: Plain text
#: build/C/man1/memusage.1:273
#, no-wrap
msgid ""
"    free(p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man1/memusage.1:278
msgid "B<memusagestat>(1), B<mtrace>(1), B<ld.so>(8)"
msgstr "B<memusagestat>(1), B<mtrace>(1), B<ld.so>(8)"

#. type: TH
#: build/C/man1/memusagestat.1:23
#, no-wrap
msgid "MEMUSAGESTAT"
msgstr "MEMUSAGESTAT"

#. type: TH
#: build/C/man1/memusagestat.1:23
#, no-wrap
msgid "Linux programmer's manual"
msgstr "Linux programmer's manual"

#. type: Plain text
#: build/C/man1/memusagestat.1:26
msgid "memusagestat - generate graphic from memory profiling data"
msgstr "memusagestat - メモリーのプロファイリングデータからグラフを出力する"

#. type: Plain text
#: build/C/man1/memusagestat.1:28
msgid "B<memusagestat> [I<option>]... I<datafile> [I<outfile>]"
msgstr "B<memusagestat> [I<option>]... I<datafile> [I<outfile>]"

#. type: Plain text
#: build/C/man1/memusagestat.1:39
msgid ""
"B<memusagestat> creates a PNG file containing a graphical representation of "
"the memory profiling data in the file I<datafile>; that file is generated "
"via the I<-d> (or I<--data>)  option of B<memusage>(1)."
msgstr ""
"B<memusagestat> は、 ファイル I<datafile> に格納されたメモリーのプロファイリ"
"ングデータをグラフとして表現した PNG ファイルを作成する。 I<datafile> は "
"B<memusage>(1) の I<-d> (I<--data>) オプションで生成される。"

#. type: Plain text
#: build/C/man1/memusagestat.1:47
msgid ""
"The red line in the graph shows the heap usage (allocated memory)  and the "
"green line shows the stack usage.  The x-scale is either the number of "
"memory-handling function calls or (if the I<-t> option is specified)  time."
msgstr ""
"グラフの赤色の線はヒープ使用量 (割り当てられたメモリー) を示し、 緑色の線はス"
"タック使用量を示す。 X 軸はメモリー処理関数の呼び出し数 (I<-t> オプションが指"
"定された場合は時間) である。"

#. type: TP
#: build/C/man1/memusagestat.1:48
#, no-wrap
msgid "B<-o\\ >I<file>,\\ B<--output=>I<file>"
msgstr "B<-o\\ >I<file>,\\ B<--output=>I<file>"

#. type: Plain text
#: build/C/man1/memusagestat.1:51
msgid "Name of the output file."
msgstr "出力ファイルの名前。"

#. type: TP
#: build/C/man1/memusagestat.1:51
#, no-wrap
msgid "B<-s\\ >I<string>,\\ B<--string=>I<string>"
msgstr "B<-s\\ >I<string>,\\ B<--string=>I<string>"

#. type: Plain text
#: build/C/man1/memusagestat.1:56
msgid "Use I<string> as the title inside the output graph."
msgstr "出力グラフに表示するタイトルとして I<string> を使用する。"

#. type: TP
#: build/C/man1/memusagestat.1:56
#, no-wrap
msgid "B<-t>,\\ B<--time>"
msgstr "B<-t>,\\ B<--time>"

#. type: Plain text
#: build/C/man1/memusagestat.1:62
msgid "Also draw a graph of total memory consumption."
msgstr "全メモリー消費量のグラフも出力する。"

#. type: Plain text
#: build/C/man1/memusagestat.1:67
msgid "Make the output graph I<size> pixels wide."
msgstr "出力グラフの幅を I<size> ピクセルにする。"

#. type: Plain text
#: build/C/man1/memusagestat.1:72
msgid "Make the output graph I<size> pixels high."
msgstr "出力グラフの高さを I<size> ピクセルにする。"

#. type: Plain text
#: build/C/man1/memusagestat.1:75
msgid "Print a help message and exit."
msgstr "ヘルプメッセージを表示して終了する。"

#. type: Plain text
#: build/C/man1/memusagestat.1:88
msgid "See B<memusage>(1)."
msgstr "B<memusage>(1) を参照。"

#. type: Plain text
#: build/C/man1/memusagestat.1:91
msgid "B<memusage>(1), B<mtrace>(1)"
msgstr "B<memusage>(1), B<mtrace>(1)"

#. type: TH
#: build/C/man1/mtrace.1:23
#, no-wrap
msgid "MTRACE"
msgstr "MTRACE"

#. type: TH
#: build/C/man1/mtrace.1:23 build/C/man8/sln.8:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man1/mtrace.1:26
msgid "mtrace - interpret the malloc trace log"
msgstr "mtrace - malloc のトレースログを解釈する"

#. type: Plain text
#: build/C/man1/mtrace.1:28
msgid "B<mtrace> [I<option>]... [I<binary>] I<mtracedata>"
msgstr "B<mtrace> [I<option>]... [I<binary>] I<mtracedata>"

#. type: Plain text
#: build/C/man1/mtrace.1:44
msgid ""
"B<mtrace> is a Perl script used to interpret and provide human readable "
"output of the trace log contained in the file I<mtracedata>, whose contents "
"were produced by B<mtrace>(3).  If I<binary> is provided, the output of "
"B<mtrace> also contains the source file name with line number information "
"for problem locations (assuming that I<binary> was compiled with debugging "
"information)."
msgstr ""
"B<mtrace> は B<mtrace>(3) の出力内容が入ったファイル I<mtracedata> のトレース"
"ログを解釈し人間が読みやすい出力に変換する Perl スクリプトである。 I<binary> "
"が渡されると、 B<mtrace> の出力に問題箇所にソースファイル名と行番号も出力され"
"る (I<binary> はデバッグ情報付きでコンパイルされているものとする)。"

#. type: Plain text
#: build/C/man1/mtrace.1:51
msgid ""
"For more information about the B<mtrace>(3)  function and B<mtrace> script "
"usage, see B<mtrace>(3)."
msgstr ""
"B<mtrace>(3) 関数と B<mtrace> スクリプトの使用方法の詳細は B<mtrace>(3) を参"
"照。"

#. type: Plain text
#: build/C/man1/mtrace.1:62
msgid ""
"For bug reporting instructions, please see: E<.UR http://www.gnu.org/"
"software/libc/bugs.html> E<.UE .>"
msgstr "バグ報告の方法については E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE> を参照。"

#. type: Plain text
#: build/C/man1/mtrace.1:65
msgid "B<memusage>(1), B<mtrace>(3)"
msgstr "B<memusage>(1), B<mtrace>(3)"

#. type: TH
#: build/C/man1/pldd.1:25
#, no-wrap
msgid "PLDD"
msgstr "PLDD"

#. type: TH
#: build/C/man1/pldd.1:25 build/C/man1/sprof.1:25
#, no-wrap
msgid "Linux User Manual"
msgstr "Linux User Manual"

#. type: Plain text
#: build/C/man1/pldd.1:28
msgid "pldd - display dynamic shared objects linked into a process"
msgstr "pldd - プロセスにリンクされている動的共有オブジェクトを表示する"

#. type: Plain text
#: build/C/man1/pldd.1:32
#, no-wrap
msgid ""
"B<pldd >I<pid>\n"
"B<pldd>I< option>\n"
msgstr ""
"B<pldd >I<pid>\n"
"B<pldd>I< option>\n"

#. type: Plain text
#: build/C/man1/pldd.1:40
msgid ""
"The B<pldd> command displays a list of the dynamic shared objects (DSOs) "
"that are linked into the process with the specified process ID (PID).  The "
"list includes the libraries that have been dynamically loaded using "
"B<dlopen>(3)."
msgstr "B<pldd> コマンドは、 指定されたプロセス ID (PID) のプロセスにリンクされている動的共有オブジェクト (DSO; dynamic shared objects) のリストを表示する。 このリストには B<dlopen>(3) を使って動的にロードされたライブラリーも含まれる。"

#. type: TP
#: build/C/man1/pldd.1:41 build/C/man1/sprof.1:66
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr "B<-?>, B<--help>"

#. type: Plain text
#: build/C/man1/pldd.1:44
msgid "Display a help message and exit."
msgstr "ヘルプメッセージを表示し終了する。"

#. type: Plain text
#: build/C/man1/pldd.1:47 build/C/man1/sprof.1:72
msgid "Display a short usage message and exit."
msgstr "使用方法の簡潔な概要を表示し終了する。"

#. type: Plain text
#: build/C/man1/pldd.1:50
msgid "Display program version information and exit."
msgstr "プログラムのバージョン情報を表示し終了する。"

#. type: Plain text
#: build/C/man1/pldd.1:61
msgid ""
"On success, B<pldd> exits with the status 0.  If the specified process does "
"not exist, the user does not have permission to access its dynamic shared "
"object list, or no command-line arguments are supplied, B<pldd> exists with "
"a status of 1.  If given an invalid option, it exits with the status 64."
msgstr ""
"成功すると B<pldd> はステータス 0 を返す。 指定されたプロセスが存在しない場"
"合、 ユーザーが自身の動的共有オブジェクトのリストにアクセスする許可を持ってい"
"ない場合、 もしくはコマンドライン引数が指定されていない場合、 B<pldd> はス"
"テータス 1 で終了する。 無効なオプションが指定された場合、 ステータス 64 で終"
"了する。"

#. type: Plain text
#: build/C/man1/pldd.1:64
msgid "B<pldd> is available since glibc 2.15."
msgstr "B<pldd> は glibc 2.15 以降で利用可能である。"

#.  There are man pages on Solaris and HP-UX.
#. type: Plain text
#: build/C/man1/pldd.1:71
msgid ""
"The B<pldd> command is not specified by POSIX.1.  Some other systems have a "
"similar command."
msgstr ""
"B<pldd> コマンドは POSIX.1 では規定されていない。 他のいくつかのシステムにも"
"同様のコマンドがある。"

#. type: Plain text
#: build/C/man1/pldd.1:73
msgid "The command"
msgstr "コマンド"

#. type: Plain text
#: build/C/man1/pldd.1:77
#, no-wrap
msgid "lsof -p PID\n"
msgstr "lsof -p PID\n"

#. type: Plain text
#: build/C/man1/pldd.1:82
msgid ""
"also shows output that includes the dynamic shared objects that are linked "
"into a process."
msgstr "は、 プロセスにリンクされた動的共有オブジェクトも出力する。"

#. type: Plain text
#: build/C/man1/pldd.1:92
msgid ""
"The B<gdb>(1)  I<info shared> command also shows the shared libraries being "
"used by a process, so that one can obtain similar output to B<pldd> using a "
"command such as the following (to monitor the process with the specified "
"I<pid>):"
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:97
#, no-wrap
msgid ""
"$ B<gdb -ex \"set confirm off\" -ex \"set height 0\" -ex \"info shared\" \\e>\n"
"        B<-ex \"quit\" -p $pid | grep \\(aq\\(ha0x.*0x\\(aq>\n"
msgstr ""
"$ B<gdb -ex \"set confirm off\" -ex \"set height 0\" -ex \"info shared\" \\e>\n"
"        B<-ex \"quit\" -p $pid | grep \\(aq\\(ha0x.*0x\\(aq>\n"

#.  glibc commit 1a4c27355e146b6d8cc6487b998462c7fdd1048f
#. type: Plain text
#: build/C/man1/pldd.1:106
msgid ""
"From glibc 2.19 to 2.29, B<pldd> was broken: it just hung when executed.  "
"This problem was fixed in glibc 2.30, and the fix has been backported to "
"earlier glibc versions in some distributions."
msgstr ""

#. type: Plain text
#: build/C/man1/pldd.1:118
#, no-wrap
msgid ""
"$ B<echo $$>               # Display PID of shell\n"
"1143\n"
"$ B<pldd $$>               # Display DSOs linked into the shell\n"
"1143:   /usr/bin/bash\n"
"linux-vdso.so.1\n"
"/lib64/libtinfo.so.5\n"
"/lib64/libdl.so.2\n"
"/lib64/libc.so.6\n"
"/lib64/ld-linux-x86-64.so.2\n"
"/lib64/libnss_files.so.2\n"
msgstr ""
"$ B<echo $$>               # シェルの PID を表示する\n"
"1143\n"
"$ B<pldd $$>               # このシェルにリンクされている動的共有オブジェクトを表示\n"
"1143:    /usr/bin/bash\n"
"linux-vdso.so.1\n"
"/lib64/libtinfo.so.5\n"
"/lib64/libdl.so.2\n"
"/lib64/libc.so.6\n"
"/lib64/ld-linux-x86-64.so.2\n"
"/lib64/libnss_files.so.2\n"

#. type: Plain text
#: build/C/man1/pldd.1:124
msgid "B<ldd>(1), B<lsof>(1), B<dlopen>(3), B<ld.so>(8)"
msgstr "B<ldd>(1), B<lsof>(1), B<dlopen>(3), B<ld.so>(8)"

#. type: TH
#: build/C/man7/rtld-audit.7:28
#, no-wrap
msgid "RTLD-AUDIT"
msgstr "RTLD-AUDIT"

#. type: Plain text
#: build/C/man7/rtld-audit.7:31
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>link.hE<gt>>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:44
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined "
"by including I<E<lt>link.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:51
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:59
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:59
#, no-wrap
msgid "la_version()"
msgstr "la_version()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:63
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr "B<unsigned int la_version(unsigned int >I<version>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:73
msgid ""
"This is the only function that I<must> be defined by an auditing library: it "
"performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:84
msgid ""
"A typical implementation of this function simply returns the constant "
"B<LAV_CURRENT>, which indicates the version of I<E<lt>link.hE<gt>> that was "
"used to build the audit module.  If the dynamic linker does not support this "
"version of the audit interface, it will refuse to activate this audit "
"module.  If the function returns zero, the dynamic linker also does not "
"activate this audit module."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:100
msgid ""
"In order to enable backwards compatibility with older dynamic linkers, an "
"audit module can examine the I<version> argument and return an earlier "
"version than B<LAV_CURRENT>, assuming the module can adjust its "
"implementation to match the requirements of the previous version of the "
"audit interface.  The B<la_version> function should not return the value of "
"I<version> without further checks because it could correspond to an "
"interface that does not match the I<E<lt>link.hE<gt>> definitions used to "
"build the audit module."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:100
#, no-wrap
msgid "la_objsearch()"
msgstr "la_objsearch()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:105
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:116
msgid ""
"The dynamic linker invokes this function to inform the auditing library that "
"it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:116
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr "B<LA_SER_ORIG>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:125
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:125
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr "B<LA_SER_LIBPATH>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:130
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:130
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr "B<LA_SER_RUNPATH>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:138
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:138
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr "B<LA_SER_CONFIG>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:145
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:145
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr "B<LA_SER_DEFAULT>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:149
msgid "I<name> was found via a search of one of the default directories."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:149
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr "B<LA_SER_SECURE>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:153
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:162
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then "
"this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:162
#, no-wrap
msgid "la_activity()"
msgstr "la_activity()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:166
#, no-wrap
msgid "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:175
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head "
"of the link map.  When the dynamic linker invokes this function, I<flag> is "
"set to one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:175
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr "B<LA_ACT_ADD>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:178
msgid "New objects are being added to the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:178
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr "B<LA_ACT_DELETE>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:181
msgid "Objects are being removed from the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:181
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr "B<LA_ACT_CONSISTENT>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:184
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:184
#, no-wrap
msgid "la_objopen()"
msgstr "la_objopen()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:189
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:198
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:201
msgid "Link map is part of the initial namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:205
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:213
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:220
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to "
"select the objects to be monitored by B<la_symbind*>():"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:220
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr "B<LA_FLG_BINDTO>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:223
msgid "Audit symbol bindings to this object."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:223
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr "B<LA_FLG_BINDFROM>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:226
msgid "Audit symbol bindings from this object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:230
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:230
#, no-wrap
msgid "la_objclose()"
msgstr "la_objclose()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:234
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:243
msgid ""
"The dynamic linker invokes this function after any finalization code for the "
"object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:247
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:247
#, no-wrap
msgid "la_preinit()"
msgstr "la_preinit()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:251
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:261
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:261
#, no-wrap
msgid "la_symbind*()"
msgstr "la_symbind*()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:270
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
msgstr ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:282
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on "
"64-bit platforms."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:292
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:297
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the "
"bound shared object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:312
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:316
msgid ""
"The I<symname> argument points a string containing the name of the symbol."
msgstr ""

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: build/C/man7/rtld-audit.7:324
msgid ""
"The I<flags> argument is a bit mask that both provides information about the "
"symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:324
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr "B<LA_SYMB_DLSYM>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:328
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:328
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr "B<LA_SYMB_ALTVALUE>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:333
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: build/C/man7/rtld-audit.7:347
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced.  "
"The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:347
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr "B<LA_SYMB_NOPLTENTER>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:352
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:352
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr "B<LA_SYMB_NOPLTEXIT>"

#. type: Plain text
#: build/C/man7/rtld-audit.7:357
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:368
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address "
"to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return "
"I<sym-E<gt>st_value>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:368
#, no-wrap
msgid "la_pltenter()"
msgstr "la_pltenter()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:374 build/C/man7/rtld-audit.7:434
msgid ""
"The precise name and argument types for this function depend on the hardware "
"platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)  "
"Here is the definition for x86-32:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:380
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long *>I<framesizep>B<);>\n"
msgstr ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long *>I<framesizep>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:384
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:394 build/C/man7/rtld-audit.7:457
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:401
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)  "
"containing the values of registers to be used for the call to this PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:407
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""

#.  FIXME . Is the following correct?
#. type: Plain text
#: build/C/man7/rtld-audit.7:423
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used "
"to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltexit>()  "
"function is called only if this buffer is explicitly set to a suitable value."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:428
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:428
#, no-wrap
msgid "la_pltexit()"
msgstr "la_pltexit()"

#. type: Plain text
#: build/C/man7/rtld-audit.7:440
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:447
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:470
msgid ""
"The I<inregs> argument points to a structure (defined in I<E<lt>link."
"hE<gt>>)  containing the values of registers used for the call to this PLT "
"entry.  The I<outregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: build/C/man7/rtld-audit.7:478
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:484
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:487
msgid ""
"Note the following differences from the Solaris dynamic linker auditing API:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:491
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:499
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide "
"a I<symname> argument."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:509
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""

#.  FIXME . Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: build/C/man7/rtld-audit.7:519
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:523
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:529
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): version = %u; LAV_CURRENT = %u\\en\",\n"
"            version, LAV_CURRENT);\n"
msgstr ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): version = %u; LAV_CURRENT = %u\\en\",\n"
"            version, LAV_CURRENT);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:532
#, no-wrap
msgid ""
"    return LAV_CURRENT;\n"
"}\n"
msgstr ""
"    return LAV_CURRENT;\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:545
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:548
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""
"    return name;\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:558
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:568
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:571
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:576
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"
msgstr ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:585
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"
msgstr ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:594
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:597 build/C/man7/rtld-audit.7:609
#: build/C/man7/rtld-audit.7:619
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""
"    return sym-E<gt>st_value;\n"
"}\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:606
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %u; flags = %#x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:616
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"
msgstr ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"

#. type: Plain text
#: build/C/man7/rtld-audit.7:625
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: build/C/man8/sln.8:25
#, no-wrap
msgid "SLN"
msgstr "SLN"

#. type: Plain text
#: build/C/man8/sln.8:28
msgid "sln - create symbolic links"
msgstr "sln - シンボリックリンクを作成する"

#. type: Plain text
#: build/C/man8/sln.8:30
msgid "B<sln>I< source dest>"
msgstr "B<sln>I< source dest>"

#. type: Plain text
#: build/C/man8/sln.8:32
msgid "B<sln>I< filelist>"
msgstr "B<sln>I< filelist>"

#. type: Plain text
#: build/C/man8/sln.8:42
msgid ""
"The B<sln> program creates symbolic links.  Unlike the B<ln>(1)  program, it "
"is statically linked.  This means that if for some reason the dynamic linker "
"is not working, B<sln> can be used to make symbolic links to dynamic "
"libraries."
msgstr ""
"B<sln> プログラムはシンボリックリンクの作成を行う。 B<ln>(1) プログラムと異な"
"り、 このプログラムは静的にリンクされている。 つまり、 何らかの理由で動的リン"
"カーが動作しない場合に、 B<sln> を使って、 動的ライブラリへのシンボリックリン"
"クを作成することができる。"

#. type: Plain text
#: build/C/man8/sln.8:48
msgid ""
"The command line has two forms.  In the first form, it creates I<dest> as a "
"new symbolic link to I<source>."
msgstr ""
"コマンドラインには二つの形がある。 一つ目の形では、 I<source> へのシンボリッ"
"クリンクとして I<dest> を作成する。"

#. type: Plain text
#: build/C/man8/sln.8:56
msgid ""
"In the second form, I<filelist> is a list of space-separated pathname pairs, "
"and the effect is as if B<sln> was executed once for each line of the file, "
"with the two pathnames as the arguments."
msgstr ""
"二つ目の形式では、 I<filelist> はスペース区切りのパス名の組のリストで、 この"
"ファイルの各行について、二つのパス名を引数として 1 回ずつ B<sln> を実行した"
"のと同じ結果となる。"

#. type: Plain text
#: build/C/man8/sln.8:60
msgid "The B<sln> program supports no command-line options."
msgstr "B<sln> プログラムには、 コマンドラインオプションはない。"

#. type: Plain text
#: build/C/man8/sln.8:64
msgid "B<ln>(1), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ln>(1), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: build/C/man1/sprof.1:25
#, no-wrap
msgid "SPROF"
msgstr "SPROF"

#. type: Plain text
#: build/C/man1/sprof.1:28
msgid "sprof - read and display shared object profiling data"
msgstr "sprof - 共有オブジェクトのプロファイルデータを読み出して表示する"

#. type: Plain text
#: build/C/man1/sprof.1:32
#, no-wrap
msgid "B<sprof> [I<option>]... I<shared-object-path> [I<profile-data-path>]\n"
msgstr "B<sprof> [I<option>]... I<shared-object-path> [I<profile-data-path>]\n"

#. type: Plain text
#: build/C/man1/sprof.1:46
msgid ""
"The B<sprof> command displays a profiling summary for the shared object "
"(shared library) specified as its first command-line argument.  The "
"profiling summary is created using previously generated profiling data in "
"the (optional) second command-line argument.  If the profiling data pathname "
"is omitted, then B<sprof> will attempt to deduce it using the soname of the "
"shared object, looking for a file with the name I<E<lt>sonameE<gt>.profile> "
"in the current directory."
msgstr "B<sprof> コマンドは、 最初のコマンドライン引数で指定された共有オブジェクト (共有ライブラリ) のプロファイルの概要を表示する。 2 番目のコマンドライン引数 (省略可能) で指定された生成済みのプロファイルデータを使って、 プロファイルの概要が生成される。 プロファイルデータのパス名が省略された場合、 B<sprof> は、 共有オブジェクトの soname を使ってパス名を元に、 カレントディレクトリに I<E<lt>sonameE<gt>.profile> という名前のファイルを探して、 プロファイルデータを特定しようとする。"

#. type: Plain text
#: build/C/man1/sprof.1:49
msgid ""
"The following command-line options specify the profile output to be produced:"
msgstr ""
"以下のコマンドラインオプションは生成されるプロファイリング出力を指定する。"

#. type: TP
#: build/C/man1/sprof.1:49
#, no-wrap
msgid "B<-c>, B<--call-pairs>"
msgstr "B<-c>, B<--call-pairs>"

#. type: Plain text
#: build/C/man1/sprof.1:54
msgid ""
"Print a list of pairs of call paths for the interfaces exported by the "
"shared object, along with the number of times each path is used."
msgstr ""
"共有オブジェクトで公開されているインターフェースに対して呼び出し経路のペアの"
"リストを表示する。 各経路が使用された回数も表示される。"

#. type: TP
#: build/C/man1/sprof.1:54
#, no-wrap
msgid "B<-p>, B<--flat-profile>"
msgstr "B<-p>, B<--flat-profile>"

#. type: Plain text
#: build/C/man1/sprof.1:58
msgid ""
"Generate a flat profile of all of the functions in the monitored object, "
"with counts and ticks."
msgstr ""
"監視対象のオブジェクトの全関数の、 回数と tick が入った flat profile を生成す"
"る。"

#. type: TP
#: build/C/man1/sprof.1:58
#, no-wrap
msgid "B<-q>, B<--graph>"
msgstr "B<-q>, B<--graph>"

#. type: Plain text
#: build/C/man1/sprof.1:61
msgid "Generate a call graph."
msgstr "コールグラフを生成する。"

#. type: Plain text
#: build/C/man1/sprof.1:64
msgid ""
"If none of the above options is specified, then the default behavior is to "
"display a flat profile and a call graph."
msgstr ""
"上記のオプションがどれも指定されなかった場合のデフォルトの動作は、 flat "
"profile とコールグラフが表示される。"

#. type: Plain text
#: build/C/man1/sprof.1:66
msgid "The following additional command-line options are available:"
msgstr "以下のコマンドラインオプションも使用できる。"

#. type: Plain text
#: build/C/man1/sprof.1:69
msgid "Display a summary of command-line options and arguments and exit."
msgstr "コマンドラインオプションと引数の概要を表示し終了する。"

#. type: Plain text
#: build/C/man1/sprof.1:75
msgid "Display the program version and exit."
msgstr "プログラムのバージョンを表示し終了する。"

#. type: Plain text
#: build/C/man1/sprof.1:79
msgid "The B<sprof> command is a GNU extension, not present in POSIX.1."
msgstr "B<sprof> コマンドは GNU 拡張であり、 POSIX.1 には存在しない。"

#. type: Plain text
#: build/C/man1/sprof.1:85
msgid ""
"The following example demonstrates the use of B<sprof>.  The example "
"consists of a main program that calls two functions in a shared object.  "
"First, the code of the main program:"
msgstr "以下は B<sprof> の使用例を示したものである。 この例では、メインプログラムで共有オブジェクト内の 2 つの関数を呼び出している。 最初に、 メインプログラムのコードは以下の通りである。"

#. type: Plain text
#: build/C/man1/sprof.1:90
#, no-wrap
msgid ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man1/sprof.1:93
#, no-wrap
msgid ""
"void x1(void);\n"
"void x2(void);\n"
msgstr ""
"void x1(void);\n"
"void x2(void);\n"

#. type: Plain text
#: build/C/man1/sprof.1:101
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man1/sprof.1:110
msgid ""
"The functions I<x1>()  and I<x2>()  are defined in the following source file "
"that is used to construct the shared object:"
msgstr "関数 I<x1>() と I<x2>() は以下のソースファイルで定義されており、 このファイルから共有オブジェクトが構成される。"

#. type: Plain text
#: build/C/man1/sprof.1:115
#, no-wrap
msgid ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man1/sprof.1:122
#, no-wrap
msgid ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"

#. type: Plain text
#: build/C/man1/sprof.1:128
#, no-wrap
msgid ""
"void\n"
"x1(void) {\n"
"    for (int j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"
msgstr ""
"void\n"
"x1(void) {\n"
"    for (int j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"

#. type: Plain text
#: build/C/man1/sprof.1:135
#, no-wrap
msgid ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    for (int j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"

#. type: Plain text
#: build/C/man1/sprof.1:142
#, no-wrap
msgid ""
"void\n"
"x2(void)\n"
"{\n"
"    for (int j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"
msgstr ""
"void\n"
"x2(void)\n"
"{\n"
"    for (int j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"

#. type: Plain text
#: build/C/man1/sprof.1:149
msgid ""
"Now we construct the shared object with the real name I<libdemo.so.1.0.1>, "
"and the soname I<libdemo.so.1>:"
msgstr "ここで、 実際の名前は I<libdemo.so.1.0.1> で soname は I<libdemo.so.1> で共有オブジェクトを構成する。"

#. type: Plain text
#: build/C/man1/sprof.1:154
#, no-wrap
msgid ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"
msgstr ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"

#. type: Plain text
#: build/C/man1/sprof.1:159
msgid ""
"Then we construct symbolic links for the library soname and the library "
"linker name:"
msgstr ""
"次に、 ライブラリ soname とライブラリのリンカー名へのシンボリックリンクを作成"
"する。"

#. type: Plain text
#: build/C/man1/sprof.1:164
#, no-wrap
msgid ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"
msgstr ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"

#. type: Plain text
#: build/C/man1/sprof.1:169
msgid ""
"Next, we compile the main program, linking it against the shared object, and "
"then list the dynamic dependencies of the program:"
msgstr "続けて、 共有オブジェクトとリンクしてメインプログラムをコンパイルし、 プログラムの動的な依存の一覧を表示する。"

#. type: Plain text
#: build/C/man1/sprof.1:178
#, no-wrap
msgid ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"
msgstr ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"

#. type: Plain text
#: build/C/man1/sprof.1:185
msgid ""
"In order to get profiling information for the shared object, we define the "
"environment variable B<LD_PROFILE> with the soname of the library:"
msgstr "共有オブジェクトのプロファイル情報を取得するために、 環境変数 B<LD_PROFILE> にこのライブラリの soname を設定する。"

#. type: Plain text
#: build/C/man1/sprof.1:189
#, no-wrap
msgid "$ B<export LD_PROFILE=libdemo.so.1>\n"
msgstr "$ B<export LD_PROFILE=libdemo.so.1>\n"

#. type: Plain text
#: build/C/man1/sprof.1:196
msgid ""
"We then define the environment variable B<LD_PROFILE_OUTPUT> with the "
"pathname of the directory where profile output should be written, and create "
"that directory if it does not exist already:"
msgstr ""
"環境変数 B<LD_PROFILE_OUTPUT> にプロファイル情報を出力するディレクトリのパス"
"名を設定し、 このディレクトリが存在しない場合は作成する。"

#. type: Plain text
#: build/C/man1/sprof.1:201
#, no-wrap
msgid ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"
msgstr ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"

#. type: Plain text
#: build/C/man1/sprof.1:209
msgid ""
"B<LD_PROFILE> causes profiling output to be I<appended> to the output file "
"if it already exists, so we ensure that there is no preexisting profiling "
"data:"
msgstr ""
"B<LD_PROFILE> を設定すると、 プロファイルの出力は出力ファイルがすでに存在する"
"場合は「追記」されるので、 既存のプロファイルデータが存在しないようにしてお"
"く。"

#. type: Plain text
#: build/C/man1/sprof.1:213
#, no-wrap
msgid "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"
msgstr "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"

#. type: Plain text
#: build/C/man1/sprof.1:219
msgid ""
"We then run the program to produce the profiling output, which is written to "
"a file in the directory specified in B<LD_PROFILE_OUTPUT>:"
msgstr ""
"次にプログラムを実行し、 プロファイリング出力を生成させる。 プロファイリング"
"出力は B<LD_PROFILE_OUTPUT> で指定されたディレクトリにファイルが書き込まれ"
"る。"

#. type: Plain text
#: build/C/man1/sprof.1:225
#, no-wrap
msgid ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"
msgstr ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"

#. type: Plain text
#: build/C/man1/sprof.1:231
msgid ""
"We then use the B<sprof -p> option to generate a flat profile with counts "
"and ticks:"
msgstr ""
"B<sprof -p> オプションを使って、 呼び出し回数と tick 数が含まれる flat プロ"
"ファイルを生成する。"

#. type: Plain text
#: build/C/man1/sprof.1:236
#, no-wrap
msgid ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Flat profile:\n"
msgstr ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Flat profile:\n"

#. type: Plain text
#: build/C/man1/sprof.1:244
#, no-wrap
msgid ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"
msgstr ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"

#. type: Plain text
#: build/C/man1/sprof.1:250
msgid "The B<sprof -q> option generates a call graph:"
msgstr "B<sprof -q> オプションを使うと、 コールグラフが生成される。"

#. type: Plain text
#: build/C/man1/sprof.1:254
#, no-wrap
msgid "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
msgstr "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"

#. type: Plain text
#: build/C/man1/sprof.1:256
#, no-wrap
msgid "index % time    self  children    called     name\n"
msgstr "index % time    self  children    called     name\n"

#. type: Plain text
#: build/C/man1/sprof.1:271
#, no-wrap
msgid ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"
msgstr ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"

#. type: Plain text
#: build/C/man1/sprof.1:277
msgid ""
"Above and below, the \"E<lt>UNKNOWNE<gt>\" strings represent identifiers "
"that are outside of the profiled object (in this example, these are "
"instances of I<main()>)."
msgstr ""
"上記や以下の例で、 \"E<lt>UNKNOWNE<gt>\" の文字列は、 識別子がプロファイルさ"
"れたオブジェクトの外部にあることを表している (この例では \"E<lt>UNKNOWNE<gt>"
"\" になっているのは I<main()> 内のオブジェクトである)。"

#. type: Plain text
#: build/C/man1/sprof.1:281
msgid ""
"The B<sprof -c> option generates a list of call pairs and the number of "
"their occurrences:"
msgstr ""
"B<sprof -c> オプションを使うと、 呼び出しの組とその発生回数のリストが生成され"
"る。"

#. type: Plain text
#: build/C/man1/sprof.1:289
#, no-wrap
msgid ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"
msgstr ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"

#. type: Plain text
#: build/C/man1/sprof.1:295
msgid "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"
msgstr "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"

#~ msgid ""
#~ "The B<dl_iterate_phdr>()  function is Linux-specific and should be "
#~ "avoided in portable applications."
#~ msgstr ""
#~ "B<dl_iterate_phdr>()  関数は Linux 固有であり、移植を考えたアプリケーショ"
#~ "ンでは避けるべきである。"

#~ msgid ""
#~ "dladdr, dlclose, dlerror, dlopen, dlsym, dlvsym - programming interface "
#~ "to dynamic linking loader"
#~ msgstr ""
#~ "dlclose, dlerror, dlopen, dlsym - 動的リンクを行うローダーへの プログラミ"
#~ "ングインターフェース"

#~ msgid ""
#~ "The four functions B<dlopen>(), B<dlsym>(), B<dlclose>(), B<dlerror>()  "
#~ "implement the interface to the dynamic linking loader."
#~ msgstr ""
#~ "B<dlopen>(), B<dlsym>(), B<dlclose>(), B<dlerror>()  の 4つの関数は、動的"
#~ "リンク (dynamic linking) を行うローダーへの インターフェースを実装したもの"
#~ "である。"

#~ msgid ""
#~ "External references in the library are resolved using the libraries in "
#~ "that library's dependency list and any other libraries previously opened "
#~ "with the B<RTLD_GLOBAL> flag.  If the executable was linked with the flag "
#~ "\"-rdynamic\" (or, synonymously, \"--export-dynamic\"), then the global "
#~ "symbols in the executable will also be used to resolve references in a "
#~ "dynamically loaded library."
#~ msgstr ""
#~ "オープンされたライブラリ中での外部参照は、 そのライブラリの依存リストにあ"
#~ "るライブラリか、 B<RTLD_GLOBAL> フラグ付きで既にオープンされているライブラ"
#~ "リを使って解決される。 実行ファイルが \"-rdynamic\" フラグ (\"--export-"
#~ "dynamic\" も同義)  付きでリンクされている場合は、実行ファイル中のグローバ"
#~ "ルシンボルも、 動的にロードされるライブラリ内の参照解決に用いられる。"

#~ msgid ""
#~ "There are two special pseudo-handles, B<RTLD_DEFAULT> and B<RTLD_NEXT>.  "
#~ "The former will find the first occurrence of the desired symbol using the "
#~ "default library search order.  The latter will find the next occurrence "
#~ "of a function in the search order after the current library.  This allows "
#~ "one to provide a wrapper around a function in another shared library."
#~ msgstr ""
#~ "B<RTLD_DEFAULT> と B<RTLD_NEXT> という二つの特別な擬似ハンドルがある。 "
#~ "B<RTLD_DEFAULT> は、デフォルトのライブラリ検索順序にしたがって、 検索対象"
#~ "のシンボルが最初に現れるところを探す。 B<RTLD_NEXT> は、ライブラリ検索順序"
#~ "の中で現在のライブラリ以降で最初に 関数が現れるところを探す。この機能を使"
#~ "うことで、別の共有ライブラリの 関数へのラッパーを提供することができる。"

#~ msgid ""
#~ "The function B<dlclose>()  returns 0 on success, and nonzero on error."
#~ msgstr ""
#~ "関数 B<dlclose>()  は、成功した場合は 0 を返し、エラーの場合 0 以外を返"
#~ "す。"

#~ msgid "The obsolete symbols _init() and _fini()"
#~ msgstr "廃止されたシンボル _init() と _fini()"

#~ msgid ""
#~ "Using these routines, or the gcc B<-nostartfiles> or B<-nostdlib> "
#~ "options, is not recommended.  Their use may result in undesired behavior, "
#~ "since the constructor/destructor routines will not be executed (unless "
#~ "special measures are taken)."
#~ msgstr ""
#~ "このルーチンや、gcc のオプション B<-nostartfiles> や B<-nostdlib> は使用し"
#~ "ないことを推奨する。 これらを使うと、望ましくない動作をすることがある。 な"
#~ "ぜなら、(特別な措置が行われない限り) これらの constructor/destructor ルー"
#~ "チンは実行されないからである。"

#~ msgid ""
#~ "Instead, libraries should export routines using the "
#~ "B<__attribute__((constructor))> and B<__attribute__((destructor))> "
#~ "function attributes.  See the gcc info pages for information on these.  "
#~ "Constructor routines are executed before B<dlopen>()  returns, and "
#~ "destructor routines are executed before B<dlclose>()  returns."
#~ msgstr ""
#~ "代わりに、ライブラリは B<__attribute__((constructor))> や "
#~ "B<__attribute__((destructor))> の関数属性を使って必要なルーチンをエクス"
#~ "ポートするのがよい。 これらについては gcc の info ページを参照のこと。 "
#~ "constructor ルーチンは B<dlopen>()  が復帰する前に実行され、 destructor "
#~ "ルーチンは B<dlclose>()  が復帰する前に実行される。"

#~ msgid "Glibc extensions: dladdr() and dlvsym()"
#~ msgstr "GNU での拡張: dladdr() と dlvsym()"

#~ msgid "Glibc adds two functions not described by POSIX, with prototypes"
#~ msgstr ""
#~ "glibc では POSIX には記載されていない関数が 2つ追加されている。 プロトタイ"
#~ "プは以下の通りである。"

#~ msgid ""
#~ "The function B<dladdr>()  takes a function pointer and tries to resolve "
#~ "name and file where it is located.  Information is stored in the "
#~ "I<Dl_info> structure:"
#~ msgstr ""
#~ "関数 B<dladdr>()  は、関数のポインターを引数にとり、関数の名前と関数が定"
#~ "義されている ファイルの解決を試みる。情報は I<Dl_info> 構造体に格納され"
#~ "る。"

#~ msgid ""
#~ "The symbols B<RTLD_DEFAULT> and B<RTLD_NEXT> are defined by I<E<lt>dlfcn."
#~ "hE<gt>> only when B<_GNU_SOURCE> was defined before including it."
#~ msgstr ""
#~ "シンボル B<RTLD_DEFAULT> と B<RTLD_NEXT> は I<E<lt>dlfcn.hE<gt>> で定義さ"
#~ "れており、 I<E<lt>dlfcn.hE<gt>> のインクルード前に B<_GNU_SOURCE> が定義さ"
#~ "れている場合のみ有効となる。"

#~ msgid ""
#~ "The dlopen interface standard comes from SunOS.  That system also has "
#~ "B<dladdr>(), but not B<dlvsym>()."
#~ msgstr ""
#~ "dlopen インターフェースの標準は SunOS をもとにしている。 SunOS には "
#~ "B<dladdr>()  もあったが、 B<dlvsym>()  はなかった。"

#~ msgid "Load the math library, and print the cosine of 2.0:"
#~ msgstr "math ライブラリをロードし、2.0 の余弦を表示する"

#~ msgid ""
#~ "If this program were in a file named \"foo.c\", you would build the "
#~ "program with the following command:"
#~ msgstr ""
#~ "このプログラムを \"foo.c\" に書いたとすると、以下のコマンドでプログラムを "
#~ "ビルドできる。"

#~ msgid ""
#~ "Libraries exporting B<_init>()  and B<_fini>()  will want to be compiled "
#~ "as follows, using I<bar.c> as the example name:"
#~ msgstr ""
#~ "B<_init>()  と B<_fini>()  をエクスポートするライブラリの場合は 以下のよう"
#~ "にしてコンパイルする必要がある。 例として I<bar.c> をコンパイルする場合:"

#~ msgid ""
#~ "This value marks an undefined, missing, irrelevant, or otherwise "
#~ "meaningless section reference.  For example, a symbol \"defined\" "
#~ "relative to section number B<SHN_UNDEF> is an undefined symbol."
#~ msgstr ""
#~ "この値は未定義・存在しない・無関係その他、 意味のないセクションの参照であ"
#~ "ることを表す。 例えば、セクション番号 B<SHN_UNDEF> に関連づけて「定義」さ"
#~ "れたシンボルは、「未定義」なシンボルである。"

#~ msgid ""
#~ "This value specifies absolute values for the corresponding reference.  "
#~ "For example, symbols defined relative to section number B<SHN_ABS> have "
#~ "absolute values and are not affected by relocation."
#~ msgstr ""
#~ "この値は対応する参照の絶対値を指定する。 例えば、セクション番号 "
#~ "B<SHN_ABS> に関連づけられたシンボルは絶対値を保持し、再配置に影響されな"
#~ "い。"

#~ msgid ""
#~ "Symbols defined relative to this section are common symbols, such as "
#~ "Fortran COMMON or unallocated C external variables."
#~ msgstr ""
#~ "このセクションに関連して定義されたシンボルは、 Fortran の COMMON や C の未"
#~ "割り当て external 変数のような、 共通シンボルである。"

#~ msgid ""
#~ "This value specifies the upper bound of the range of reserved indices "
#~ "between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, inclusive; the values do "
#~ "not reference the section header table.  That is, the section header "
#~ "table does I<not> contain entries for the reserved indices."
#~ msgstr ""
#~ "この値は予約されたインデックスの範囲の上限を指定する。 B<SHN_LORESERVE> "
#~ "と B<SHN_HIRESERVE> は含まれる。 この値はセクションヘッダーテーブルを参照"
#~ "しない。 つまり、セクションヘッダーテーブルは 予約されたインデックスのエン"
#~ "トリーを I<含まない 。>"

#~ msgid ""
#~ "Values greater than or equal to B<PT_HIPROC> are reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以上で B<PT_HIPROC> 以下の値はプロセッサ固有の意味に予約されている。"

#~ msgid "This section holds information that marks the file in some way."
#~ msgstr "このセクションはファイルに何らかの印を付ける情報を保持する。"

#~ msgid ""
#~ "This value up to and including B<SHT_HIPROC> is reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以上で B<SHT_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されてい"
#~ "る。"

#~ msgid ""
#~ "This value down to and including B<SHT_LOPROC> is reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以下で B<SHT_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されてい"
#~ "る。"

#~ msgid ""
#~ "This value up to and including B<STT_HIPROC> is reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以上で B<STT_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されてい"
#~ "る。"

#~ msgid ""
#~ "This value up to and including B<STB_HIPROC> is reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以上で B<STB_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されてい"
#~ "る。"

#~ msgid ""
#~ "B<ELF32_ST_BIND>(info)  or B<ELF64_ST_BIND>(info)  extract a binding from "
#~ "an I<st_info> value."
#~ msgstr ""
#~ "B<ELF32_ST_BIND>(info)  または B<ELF64_ST_BIND>(info)  I<st_info> の値から"
#~ "バインディングを取り出す。"

#~ msgid "Size in bytes of Rel table"
#~ msgstr "Rel テーブルのサイズ (バイト単位)"

#~ msgid "Start of processor-specific semantics"
#~ msgstr "プロセッサ固有の意味の開始"

#~ msgid "End of processor-specific semantics"
#~ msgstr "プロセッサ固有の意味の終了"

#~ msgid ""
#~ "(ELF only) Using the directories specified in the DT_RUNPATH dynamic "
#~ "section attribute of the binary if present."
#~ msgstr ""
#~ "(ELF のみ)  バイナリの動的セクション属性 DT_RUNPATH が存在すれば、 "
#~ "DT_RUNPATH で指定されたディレクトリを使用する。"

#~ msgid "Rpath token expansion"
#~ msgstr "rpath トークンの展開"

#~ msgid ""
#~ "B<ld.so> understands certain strings in an rpath specification (DT_RPATH "
#~ "or DT_RUNPATH); those strings are substituted as follows"
#~ msgstr ""
#~ "B<ld.so> では rpath 指定 (DT_RPATH や DT_RUNPATH) 中にいくつかの特定の文字"
#~ "列を使うことができる。 それらの文字列は以下のように置き換えられる。"

#~ msgid ""
#~ "Use PATH instead of B<LD_LIBRARY_PATH> environment variable setting (see "
#~ "below)."
#~ msgstr ""
#~ "B<LD_LIBRARY_PATH> 環境変数の設定ではなく、\n"
#~ "指定した PATH を使用する (下記参照)。"

#~ msgid "Use objects named in LIST as auditors."
#~ msgstr "LIST で指定された名前のオブジェクトを監査者として使用する。"

#~ msgid "HARDWARE CAPABILITIES"
#~ msgstr "ハードウェア機能"

#~ msgid ""
#~ "(glibc since 2.2)  Don't update the Global Offset Table (GOT) and "
#~ "Procedure Linkage Table (PLT)  when resolving a symbol."
#~ msgstr ""
#~ "(glibc 2.2 以降) シンボルを解決した際、Global Offset Table (GOT) と "
#~ "Procedure Linkage Table (PLT) を更新しない。"

#~ msgid ""
#~ "A colon-separated list of directories in which to search for ELF "
#~ "libraries at execution-time.  Similar to the B<PATH> environment "
#~ "variable.  Ignored in set-user-ID and set-group-ID programs."
#~ msgstr ""
#~ "コロン区切りのディレクトリのリスト。実行時に ELF ライブラリを検索するディ"
#~ "レクトリを指定する。 B<PATH> 環境変数と同じように指定する。 set-user-ID/"
#~ "set-group-ID されたプログラムでは無視される。"

#~ msgid ""
#~ "A list of additional, user-specified, ELF shared libraries to be loaded "
#~ "before all others.  The items of the list can be separated by spaces or "
#~ "colons.  This can be used to selectively override functions in other "
#~ "shared libraries.  The libraries are searched for using the rules given "
#~ "under DESCRIPTION.  For set-user-ID/set-group-ID ELF binaries, preload "
#~ "pathnames containing slashes are ignored, and libraries in the standard "
#~ "search directories are loaded only if the set-user-ID permission bit is "
#~ "enabled on the library file."
#~ msgstr ""
#~ "追加でユーザーが指定する ELF 共有ライブラリのリスト。指定されたライブラリ"
#~ "は、すべてのライブラリより前にロードされる。リストの区切りはスペースとコロ"
#~ "ンである。他の共有ライブラリにある関数を選択的に置き換えるために用いること"
#~ "ができる。指定されたライブラリは「説明」の節で述べたルールを基いて検索され"
#~ "る。 set-user-ID/set-group-ID された ELF バイナリでは、スラッシュを含んだ"
#~ "パス名のライブラリは無視され、標準の検索ディレクトリのライブラリはそのライ"
#~ "ブラリファイルの set-user-ID 許可ビットが有効になっている場合のみロードさ"
#~ "れる。"

#~ msgid ""
#~ "(libc5)  Version of B<LD_LIBRARY_PATH> for a.out binaries only.  Old "
#~ "versions of ld-linux.so.1 also supported B<LD_ELF_LIBRARY_PATH>."
#~ msgstr ""
#~ "(libc5)  a.out バイナリにのみ使われる環境変数で、 B<LD_LIBRARY_PATH> と同"
#~ "じ役割をする。 ld-linux.so.1 の古いバージョンでは B<LD_ELF_LIBRARY_PATH> "
#~ "もサポートしていた。"

#~ msgid ""
#~ "(libc5)  Version of B<LD_PRELOAD> for a.out binaries only.  Old versions "
#~ "of ld-linux.so.1 also supported B<LD_ELF_PRELOAD>."
#~ msgstr ""
#~ "(libc5)  a.out バイナリにのみ使われる環境変数で、 B<LD_PRELOAD> と同じ役割"
#~ "をする。 ld-linux.so.1 の古いバージョンでは B<LD_ELF_PRELOAD> もサポートし"
#~ "ていた。"

#~ msgid ""
#~ "(glibc since 2.1.95)  Do not update the GOT (global offset table) and PLT "
#~ "(procedure linkage table)  after resolving a symbol."
#~ msgstr ""
#~ "(glibc 2.1.95 以降)  シンボルを解決した後、GOT (global offset table) と "
#~ "PLT (procedure linkage table) を更新しない。"

#~ msgid ""
#~ "(glibc since 2.1)  Output verbose debugging information about the dynamic "
#~ "linker.  If set to B<all> prints all debugging information it has, if set "
#~ "to B<help> prints a help message about which categories can be specified "
#~ "in this environment variable.  Since glibc 2.3.4, B<LD_DEBUG> is ignored "
#~ "for set-user-ID/set-group-ID binaries."
#~ msgstr ""
#~ "(glibc 2.1 以降)  動的リンカーの詳細なデバッグ情報を出力する。 B<all> に設"
#~ "定した場合、全ての動的リンカーが持つデバッグ情報を表示する。 B<help> に設"
#~ "定した場合、この環境変数で指定されるカテゴリーのヘルプ情報を表示する。 "
#~ "glibc 2.3.4 以降、 set-user-ID/set-group-ID されたバイナリでは "
#~ "B<LD_DEBUG> は無視される。"

#~ msgid ""
#~ "(glibc since 2.1)  File in which B<LD_DEBUG> output should be written.  "
#~ "The default is standard error.  B<LD_DEBUG_OUTPUT> is ignored for set-"
#~ "user-ID/set-group-ID binaries."
#~ msgstr ""
#~ "(glibc 2.1 以降)  B<LD_DEBUG> の出力を書き込むファイル。 デフォルトは標準"
#~ "エラーである。 set-user-ID/set-group-ID されたバイナリでは、 "
#~ "B<LD_DEBUG_OUTPUT> は無視される。"

#~ msgid ""
#~ "(glibc since 2.1.91)  Allow weak symbols to be overridden (reverting to "
#~ "old glibc behavior).  For security reasons, since glibc 2.3.4, "
#~ "B<LD_DYNAMIC_WEAK> is ignored for set-user-ID/set-group-ID binaries."
#~ msgstr ""
#~ "(glibc 2.1.19 以降)  上書きされる弱いシンボル (昔の glibc の挙動を逆にす"
#~ "る)。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-group-"
#~ "ID されたバイナリでは B<LD_DYNAMIC_WEAK> は無視される。"

#~ msgid ""
#~ "(a.out only)(libc5)  Don't ignore the directory in the names of a.out "
#~ "libraries to be loaded.  Use of this option is strongly discouraged."
#~ msgstr ""
#~ "(a.out のみ)(libc5)  ロードする a.out ライブラリの名前において、ディレクト"
#~ "リを無視しない。 このオプションは用いるべきではない。"

#~ msgid ""
#~ "(a.out only)(libc5)  Suppress warnings about a.out libraries with "
#~ "incompatible minor version numbers."
#~ msgstr ""
#~ "(a.out のみ)(libc5)  a.out ライブラリにおけるマイナーバージョン番号の非互"
#~ "換に 対する警告メッセージを抑制する。"

#~ msgid ""
#~ "(glibc since 2.1)  Path where the binary is found (for non-set-user-ID "
#~ "programs).  For security reasons, since glibc 2.4, B<LD_ORIGIN_PATH> is "
#~ "ignored for set-user-ID/set-group-ID binaries."
#~ msgstr ""
#~ "(glibc 2.1 以降)  バイナリへのパス (set-user-ID されていないプログラムにつ"
#~ "いて)。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-"
#~ "group-ID されたバイナリでは B<LD_ORIGIN_PATH> は無視される。"

#~ msgid ""
#~ "(glibc since 2.1)  Show auxiliary array passed up from the kernel.  For "
#~ "security reasons, since glibc 2.3.5, B<LD_SHOW_AUXV> is ignored for set-"
#~ "user-ID/set-group-ID binaries."
#~ msgstr ""
#~ "(glibc 2.1 以降)  カーネルから渡される補助的な (パラメーターの) 配列を表示"
#~ "する。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-group-"
#~ "ID されたバイナリでは B<LD_SHOW_AUXV> は無視される。"

#~ msgid "(libc5)  I<argv>[0] to be used by B<ldd>(1)  when none is present."
#~ msgstr ""
#~ "(libc5)  B<ldd>(1)  の引数がない場合に、 I<argv>[0] として使われる値。"

#~ msgid ""
#~ "File containing a whitespace-separated list of ELF shared libraries to be "
#~ "loaded before the program."
#~ msgstr ""
#~ "プログラムの前にロードすべき ELF 共有ライブラリを スペースで区切ったリスト"
#~ "が書かれているファイル。"

#~ msgid "shared libraries"
#~ msgstr "共有ライブラリ"

#~ msgid ""
#~ "The B<ld.so> functionality is available for executables compiled using "
#~ "libc version 4.4.3 or greater.  ELF functionality is available since "
#~ "Linux 1.1.52 and libc5."
#~ msgstr ""
#~ "B<ld.so> の機能は libc のバージョン 4.4.3 以上を用いてコンパイルされた 実"
#~ "行ファイルで使用可能である。 ELF の機能は Linux 1.1.52 以降と libc5 以降で"
#~ "使用可能である。"

#~ msgid ""
#~ "B<ldd> prints the shared libraries required by each program or shared "
#~ "library specified on the command line."
#~ msgstr ""
#~ "B<ldd> はコマンドラインで指定したプログラムや共有ライブラリについて、 それ"
#~ "ぞれで必要とされる共有ライブラリを表示する。"

#~ msgid "Display program help message."
#~ msgstr "プログラムのヘルプメッセージを表示する。"

#~ msgid "Display a short usage message."
#~ msgstr "簡潔な使用方法を表示する。"
