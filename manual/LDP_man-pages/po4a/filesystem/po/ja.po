# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:22+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr "FILESYSTEMS"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man2/mount.2:40
#: build/C/man2/spu_create.2:25 build/C/man7/spufs.7:27
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:36
#: build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:25
#: build/C/man2/listxattr.2:26 build/C/man2/mount.2:40
#: build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25
#: build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25
#: build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:39
#: build/C/man2/statfs.2:28 build/C/man2/statx.2:30 build/C/man3/statvfs.3:30
#: build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30
#: build/C/man5/sysfs.5:25 build/C/man5/tmpfs.5:25 build/C/man4/fuse.4:26
#: build/C/man4/loop.4:26 build/C/man7/inode.7:25 build/C/man7/xattr.7:28
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:36
#: build/C/man3/getfsent.3:27 build/C/man3/getmntent.3:32
#: build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:25
#: build/C/man2/listxattr.2:26 build/C/man2/mount.2:40
#: build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25
#: build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25
#: build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:39
#: build/C/man2/statfs.2:28 build/C/man2/statx.2:30 build/C/man3/statvfs.3:30
#: build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30
#: build/C/man5/sysfs.5:25 build/C/man5/tmpfs.5:25 build/C/man4/fuse.4:26
#: build/C/man4/loop.4:26 build/C/man7/inode.7:25 build/C/man7/xattr.7:28
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man5/filesystems.5:28 build/C/man3/fts.3:41 build/C/man3/ftw.3:37
#: build/C/man3/getfsent.3:28 build/C/man3/getmntent.3:33
#: build/C/man2/getxattr.2:26 build/C/man3/isfdtype.3:26
#: build/C/man2/listxattr.2:27 build/C/man2/mount.2:41
#: build/C/man7/path_resolution.7:26 build/C/man2/removexattr.2:26
#: build/C/man2/setxattr.2:26 build/C/man2/spu_create.2:26
#: build/C/man2/spu_run.2:27 build/C/man7/spufs.7:28 build/C/man2/stat.2:40
#: build/C/man2/statfs.2:29 build/C/man2/statx.2:31 build/C/man3/statvfs.3:31
#: build/C/man2/sysfs.2:28 build/C/man2/umount.2:31 build/C/man2/ustat.2:31
#: build/C/man5/sysfs.5:26 build/C/man5/tmpfs.5:26 build/C/man4/fuse.4:27
#: build/C/man4/loop.4:27 build/C/man7/inode.7:26 build/C/man7/xattr.7:29
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, "
"JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, umsdos, vfat, "
"XFS, xiafs"
msgstr "filesystems - Linux のファイルシステム種別: ext, ext2, ext3, ext4, hpfs, iso9660, JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, umsdos, vfat, XFS, xiafs"

#. type: SH
#: build/C/man5/filesystems.5:32 build/C/man3/fts.3:61 build/C/man3/ftw.3:63
#: build/C/man3/getfsent.3:42 build/C/man3/getmntent.3:68
#: build/C/man2/getxattr.2:42 build/C/man3/isfdtype.3:54
#: build/C/man2/listxattr.2:42 build/C/man2/mount.2:51
#: build/C/man7/path_resolution.7:28 build/C/man2/removexattr.2:39
#: build/C/man2/setxattr.2:42 build/C/man2/spu_create.2:39
#: build/C/man2/spu_run.2:39 build/C/man7/spufs.7:30 build/C/man2/stat.2:88
#: build/C/man2/statfs.2:37 build/C/man2/statx.2:43 build/C/man3/statvfs.3:39
#: build/C/man2/sysfs.2:36 build/C/man2/umount.2:41 build/C/man2/ustat.2:41
#: build/C/man5/sysfs.5:28 build/C/man5/tmpfs.5:28 build/C/man4/fuse.4:33
#: build/C/man4/loop.4:31 build/C/man7/inode.7:28 build/C/man7/xattr.7:31
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#.  commit: 6af9f7bf3c399e0ab1eee048e13572c6d4e15fe9
#. type: Plain text
#: build/C/man5/filesystems.5:53
#, fuzzy
#| msgid ""
#| "When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
#| "can find in the file I</proc/filesystems> which filesystems your kernel "
#| "currently supports; see B<proc>(5)  for more details.  If you need a "
#| "currently unsupported filesystem, insert the corresponding module or "
#| "recompile the kernel."
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  There is also a "
"legacy B<sysfs>(2)  system call (whose availability is controlled by the "
"B<CONFIG_SYSFS_SYSCALL> kernel build configuration option since Linux 3.15)  "
"that enables enumeration of the currently available filesystem types "
"regardless of I</proc> availability and/or sanity."
msgstr ""
"B<proc> ファイルシステムが慣習どおりに I</proc> にマウントされている場合、 現"
"在のカーネルがどのファイルシステムをサポートしているか 知るためにはファイル "
"I</proc/filesystems> を見ればよい。 詳細は B<proc>(5) 参照。 必要なファイルシ"
"ステムが現在のカーネルにサポートされて いない場合、適切なモジュールを組み込む"
"か、それもだめならば カーネルを再コンパイルすること。"

#. type: Plain text
#: build/C/man5/filesystems.5:56
msgid ""
"If you need a currently unsupported filesystem, insert the corresponding "
"kernel module or recompile the kernel."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:63
msgid ""
"In order to use a filesystem, you have to I<mount> it; see B<mount>(2)  and "
"B<mount>(8)."
msgstr "ファイルシステムを使うためには、 I<マウント> する必要がある。 B<mount>(2) と B<mount>(8) を参照のこと。"

#. type: Plain text
#: build/C/man5/filesystems.5:69
msgid ""
"The following list provides a short description of the available or "
"historically available filesystems in the Linux kernel.  See the kernel "
"documentation for a comprehensive description of all options and limitations."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:69
#, no-wrap
msgid "B<ext>"
msgstr "B<ext>"

#. type: Plain text
#: build/C/man5/filesystems.5:78
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""
"B<minix> ファイルシステムの手の込んだ拡張である。これは第二拡張ファイルシステ"
"ム (second extended filesystem : B<ext2>)  に完全にとって代わられ、カーネル "
"2.1.21 で取り除かれた。"

#. type: TP
#: build/C/man5/filesystems.5:78
#, no-wrap
msgid "B<ext2>"
msgstr "B<ext2>"

#. type: Plain text
#: build/C/man5/filesystems.5:87
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  See B<ext2>(5)."
msgstr "Linux の高性能なファイルシステムである。これは固定ディスクだけではなく リムーバブルディスクにもよく使われる。 拡張ファイルシステム (B<ext>)  の発展として第二拡張ファイルシステム (B<ext2>)  が設計された。 B<ext2> を参照のこと。"

#. type: TP
#: build/C/man5/filesystems.5:87
#, no-wrap
msgid "B<ext3>"
msgstr "B<ext3>"

#. type: Plain text
#: build/C/man5/filesystems.5:99
msgid ""
"is a journaling version of the B<ext2> filesystem.  It is easy to switch "
"back and forth between B<ext2> and B<ext3>.  See B<ext3>(5)."
msgstr "B<ext2> ファイルシステムにジャーナル機能をつけたものである。 B<ext2> と B<ext3> は簡単に行きつ戻りつできる。 B<ext3>(5) を参照のこと。"

#. type: TP
#: build/C/man5/filesystems.5:99
#, no-wrap
msgid "B<ext4>"
msgstr "B<ext4>"

#. type: Plain text
#: build/C/man5/filesystems.5:108
msgid ""
"is a set of upgrades to B<ext3> including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits.  See B<ext4>(5)."
msgstr "B<ext3> の改良版であり、性能と信頼性のかなりの改善と、ボリューム、ファイル、ディレクトリのサイズの上限の大幅な拡張が行われている。 B<ext4>(5) を参照のこと。"

#. type: TP
#: build/C/man5/filesystems.5:108
#, no-wrap
msgid "B<hpfs>"
msgstr "B<hpfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:113
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is read-"
"only under Linux due to the lack of available documentation."
msgstr ""
"は OS/2 で使われる高性能ファイルシステム(High Performance Filesystem)であ"
"る。 このファイルシステムはドキュメントが入手できないため、 Linux では読み込"
"み専用 (Read-only) でしか使用できない。"

#. type: TP
#: build/C/man5/filesystems.5:113
#, no-wrap
msgid "B<iso9660>"
msgstr "B<iso9660>"

#. type: Plain text
#: build/C/man5/filesystems.5:116
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr "は ISO 9660 標準に沿った CD-ROM のファイルシステムである。"

#. type: TP
#: build/C/man5/filesystems.5:117
#, no-wrap
msgid "B<High Sierra>"
msgstr "B<High Sierra>"

#. type: Plain text
#: build/C/man5/filesystems.5:124
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for CD-"
"ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""
"Linux はハイシェラ (High Sierra) をサポートしている。これは ISO 9660 標準が "
"決まるより前に使われていた CD-ROM ファイルシステムである。Linux の "
"B<iso9660> ファイルシステムサポートがハイシェラファイルシステムを自動で 認識"
"することができる。"

#. type: TP
#: build/C/man5/filesystems.5:124
#, no-wrap
msgid "B<Rock Ridge>"
msgstr "B<Rock Ridge>"

#. type: Plain text
#: build/C/man5/filesystems.5:135
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the "
"Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""
"Linux はロックリッジ (Rock Ridge) 変換プロトコルで規定された システム使用\n"
"共有プロトコルもサポートしている。これは UNIX ホ ストのファイルを "
"B<iso9660> \n"
"ファイルシステムでより詳しく記述するために使用され、長いファイル名や UID/"
"GID、\n"
"POSIX 形式のパーミッション、デバイスファイル などの情報を提供する。Linux の\n"
"B<iso9660> ファイルシステムサポートがロックリッジファイルシステムを自動で\n"
"認識することができる。"

#. type: TP
#: build/C/man5/filesystems.5:136
#, no-wrap
msgid "B<JFS>"
msgstr "B<JFS>"

#. type: Plain text
#: build/C/man5/filesystems.5:140
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux "
"in kernel 2.4.24."
msgstr ""
"IBM により開発されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.24 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:140
#, no-wrap
msgid "B<minix>"
msgstr "B<minix>"

#. type: Plain text
#: build/C/man5/filesystems.5:147
msgid ""
"is the filesystem used in the Minix operating system, the first to run under "
"Linux.  It has a number of shortcomings, including a 64\\ MB partition size "
"limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr "Minix オペレーティングシステムのファイルシステム。 Linux で動いた最初のファイルシステムでもある。これには多くの欠点がある。 パーティションのサイズが最大 64\\ MB であること、短いファイル名しか使えない、タイムスタンプが一つだけである、などなど。 フロッピーや RAM ディスクに便利なのでまだ残っている。"

#. type: TP
#: build/C/man5/filesystems.5:147
#, no-wrap
msgid "B<msdos>"
msgstr "B<msdos>"

#. type: Plain text
#: build/C/man5/filesystems.5:153
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period "
"and 3 character extension."
msgstr ""
"は DOS や Windows、いくらかの OS/2 コンピュータが使っているファイル システム"
"である。 この B<msdos> ファイルシステムでは「8 文字の名前＋ピリオド＋3 文字の"
"拡張子」より 長いファイル名はつけることができない。"

#. type: TP
#: build/C/man5/filesystems.5:153
#, no-wrap
msgid "B<ncpfs>"
msgstr "B<ncpfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:158
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare.  It was was removed from the kernel in 4.17."
msgstr "は NCP プロトコルをサポートしたファイルシステムである。Novell NetWare が 使っている。 バージョン 4.17 でカーネルから削除された。"

#. type: Plain text
#: build/C/man5/filesystems.5:164
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://ftp.gwdg.de\\:/pub\\:/linux\\:/misc\\:/ncpfs> E<.UE .>"
msgstr "B<ncpfs> を使うためには E<.UR ftp://ftp.gwdg.de\\:/pub\\:/linux\\:/misc\\:/ncpfs> E<.UE> にある特殊なプログラムが必要である。"

#. type: TP
#: build/C/man5/filesystems.5:164
#, no-wrap
msgid "B<nfs>"
msgstr "B<nfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:167
msgid ""
"is the network filesystem used to access disks located on remote computers."
msgstr ""
"はネットワークファイルシステムである。 離れたコンピュータのディスクを使うこと"
"ができる。"

#. type: TP
#: build/C/man5/filesystems.5:167
#, no-wrap
msgid "B<ntfs>"
msgstr "B<ntfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:171
msgid ""
"is the filesystem native to Microsoft Windows NT, supporting features like "
"ACLs, journaling, encryption, and so on."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:171
#, no-wrap
msgid "B<proc>"
msgstr "B<proc>"

#. type: Plain text
#: build/C/man5/filesystems.5:179
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""
"はカーネルデータ構造へのインターフェイスとなる疑似ファイルシステムである。 こ"
"れは I</dev/kmem> を読んで解釈することの代わりとして使うことができる。 この"
"ファイルシステムのファイルはディスクスペースを使用しない。 B<proc>(5)  を参照"
"のこと。"

#. type: TP
#: build/C/man5/filesystems.5:179
#, no-wrap
msgid "B<Reiserfs>"
msgstr "B<Reiserfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:183
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""
"Hans Reiser によって設計されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.1 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:183
#, no-wrap
msgid "B<smb>"
msgstr "B<smb>"

#. type: Plain text
#: build/C/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager.  See E<.UR https://www.samba.org\\:/"
"samba\\:/smbfs/> E<.UE .>"
msgstr "は SMB プロトコルをサポートしたネットワークファイルシステムである。 Windows for Workgroups, Windows NT, Lan Manager が使っている。 E<.UR https://www.samba.org\\:/samba\\:/smbfs/> E<.UE> 参照。"

#. type: TP
#: build/C/man5/filesystems.5:190
#, no-wrap
msgid "B<sysv>"
msgstr "B<sysv>"

#. type: Plain text
#: build/C/man5/filesystems.5:194
msgid ""
"is an implementation of the System V/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, System V/386 FS, and Coherent FS."
msgstr "は System V/Coherent ファイルシステムの Linux での実装である。 Xenix, System V/386, Coherent 各ファイルシステムを使うことができる。"

#. type: TP
#: build/C/man5/filesystems.5:194
#, no-wrap
msgid "B<umsdos>"
msgstr "B<umsdos>"

#. type: Plain text
#: build/C/man5/filesystems.5:201
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.) under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""
"は DOS ファイルシステムを拡張した Linux のファイルシステムである。 これは "
"DOS ファイルシステムのもとで、長いファイル名や UID/GID、POSIX 形式の パーミッ"
"ション、(デバイスファイルや名前付きパイプなどの) 特殊ファイルを 使えるように"
"したものである。DOS との互換性がある。"

#. type: TP
#: build/C/man5/filesystems.5:201
#, no-wrap
msgid "B<tmpfs>"
msgstr "B<tmpfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:208
msgid ""
"is a filesystem whose contents reside in virtual memory.  Since the files on "
"such filesystems typically reside in RAM, file access is extremely fast.  "
"See B<tmpfs>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:208
#, no-wrap
msgid "B<vfat>"
msgstr "B<vfat>"

#. type: Plain text
#: build/C/man5/filesystems.5:213
msgid ""
"is an extended FAT filesystem used by Microsoft Windows95 and Windows NT.  "
"B<vfat> adds the capability to use long filenames under the MSDOS filesystem."
msgstr "は Microsoft Windows95 と Windows NT が使う FAT ファイルシステムの拡張である。 B<vfat> では、長いファイル名が使えるようになっている。"

#. type: TP
#: build/C/man5/filesystems.5:213
#, no-wrap
msgid "B<XFS>"
msgstr "B<XFS>"

#. type: Plain text
#: build/C/man5/filesystems.5:217
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux "
"in kernel 2.4.20."
msgstr ""
"SGI により開発されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.20 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:217
#, no-wrap
msgid "B<xiafs>"
msgstr "B<xiafs>"

#. type: Plain text
#: build/C/man5/filesystems.5:227
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xiafs> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr "は Minix ファイルシステムの拡張で、より安定し安全なファイルシステムとして 設計、実装された。これは、いらない複雑さは避けつつ必要な基本的機能を 備えている。 B<xiafs> ファイルシステムは、もはや開発もメンテナンスも行われていない。 カーネル 2.1.21 で取り除かれた。"

#. type: SH
#: build/C/man5/filesystems.5:227 build/C/man3/fts.3:834 build/C/man3/ftw.3:507
#: build/C/man3/getfsent.3:160 build/C/man3/getmntent.3:257
#: build/C/man2/getxattr.2:154 build/C/man3/isfdtype.3:101
#: build/C/man2/listxattr.2:330 build/C/man2/mount.2:952
#: build/C/man7/path_resolution.7:275 build/C/man2/removexattr.2:110
#: build/C/man2/setxattr.2:170 build/C/man2/spu_create.2:285
#: build/C/man2/spu_run.2:266 build/C/man7/spufs.7:766 build/C/man2/stat.2:708
#: build/C/man2/statfs.2:394 build/C/man2/statx.2:565
#: build/C/man3/statvfs.3:257 build/C/man2/sysfs.2:113
#: build/C/man2/umount.2:223 build/C/man2/ustat.2:118 build/C/man5/sysfs.5:285
#: build/C/man5/tmpfs.5:275 build/C/man4/fuse.4:553 build/C/man4/loop.4:375
#: build/C/man7/inode.7:476 build/C/man7/xattr.7:188
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man5/filesystems.5:241
msgid ""
"B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), "
"B<proc>(5), B<sysfs>(5), B<tmpfs>(5), B<xfs>(5), B<fsck>(8), B<mkfs>(8), "
"B<mount>(8)"
msgstr "B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), B<proc>(5), B<sysfs>(5), B<tmpfs>(5), B<xfs>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"

#. type: SH
#: build/C/man5/filesystems.5:241 build/C/man3/fts.3:840 build/C/man3/ftw.3:511
#: build/C/man3/getfsent.3:163 build/C/man3/getmntent.3:261
#: build/C/man2/getxattr.2:164 build/C/man3/isfdtype.3:103
#: build/C/man2/listxattr.2:340 build/C/man2/mount.2:964
#: build/C/man7/path_resolution.7:280 build/C/man2/removexattr.2:120
#: build/C/man2/setxattr.2:180 build/C/man2/spu_create.2:290
#: build/C/man2/spu_run.2:271 build/C/man7/spufs.7:773 build/C/man2/stat.2:720
#: build/C/man2/statfs.2:398 build/C/man2/statx.2:577
#: build/C/man3/statvfs.3:259 build/C/man2/sysfs.2:116
#: build/C/man2/umount.2:229 build/C/man2/ustat.2:121 build/C/man5/sysfs.5:300
#: build/C/man5/tmpfs.5:288 build/C/man4/fuse.4:556 build/C/man4/loop.4:378
#: build/C/man7/inode.7:481 build/C/man7/xattr.7:200
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man5/filesystems.5:249 build/C/man3/fts.3:848 build/C/man3/ftw.3:519
#: build/C/man3/getfsent.3:171 build/C/man3/getmntent.3:269
#: build/C/man2/getxattr.2:172 build/C/man3/isfdtype.3:111
#: build/C/man2/listxattr.2:348 build/C/man2/mount.2:972
#: build/C/man7/path_resolution.7:288 build/C/man2/removexattr.2:128
#: build/C/man2/setxattr.2:188 build/C/man2/spu_create.2:298
#: build/C/man2/spu_run.2:279 build/C/man7/spufs.7:781 build/C/man2/stat.2:728
#: build/C/man2/statfs.2:406 build/C/man2/statx.2:585
#: build/C/man3/statvfs.3:267 build/C/man2/sysfs.2:124
#: build/C/man2/umount.2:237 build/C/man2/ustat.2:129 build/C/man5/sysfs.5:308
#: build/C/man5/tmpfs.5:296 build/C/man4/fuse.4:564 build/C/man4/loop.4:386
#: build/C/man7/inode.7:489 build/C/man7/xattr.7:208
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr "FTS"

#. type: TH
#: build/C/man3/fts.3:40 build/C/man7/path_resolution.7:25
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - ファイル階層をた"
"どる"

#. type: SH
#: build/C/man3/fts.3:44 build/C/man3/ftw.3:39 build/C/man3/getfsent.3:30
#: build/C/man3/getmntent.3:36 build/C/man2/getxattr.2:28
#: build/C/man3/isfdtype.3:28 build/C/man2/listxattr.2:29
#: build/C/man2/mount.2:43 build/C/man2/removexattr.2:28
#: build/C/man2/setxattr.2:28 build/C/man2/spu_create.2:28
#: build/C/man2/spu_run.2:29 build/C/man2/stat.2:42 build/C/man2/statfs.2:31
#: build/C/man2/statx.2:33 build/C/man3/statvfs.3:33 build/C/man2/sysfs.2:30
#: build/C/man2/umount.2:33 build/C/man2/ustat.2:33 build/C/man4/fuse.4:29
#: build/C/man4/loop.4:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<,>\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<,>\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"

#. type: Plain text
#: build/C/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"
msgstr "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"
msgstr "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr "B<int fts_close(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:80
#, fuzzy
#| msgid ""
#| "The fts functions are provided for traversing file hierarchies.  A simple "
#| "overview is that the B<fts_open>()  function returns a \"handle\" on a "
#| "file hierarchy, which is then supplied to the other fts functions.  The "
#| "function B<fts_read>()  returns a pointer to a structure describing one "
#| "of the files in the file hierarchy.  The function B<fts_children>()  "
#| "returns a pointer to a linked list of structures, each of which describes "
#| "one of the files contained in a directory in the hierarchy.  In general, "
#| "directories are visited two distinguishable times; in preorder (before "
#| "any of their descendants are visited) and in postorder (after all of "
#| "their descendants have been visited).  Files are visited once.  It is "
#| "possible to walk the hierarchy \"logically\" (visiting the files that "
#| "symbolic links point to)  or physically (visiting the symbolic links "
#| "themselves), order the walk of the hierarchy or prune and/or revisit "
#| "portions of the hierarchy."
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" (of type "
"I<FTS\\ *>)  that refers to a file hierarchy \"stream\".  This handle is "
"then supplied to the other fts functions.  The function B<fts_read>()  "
"returns a pointer to a structure describing one of the files in the file "
"hierarchy.  The function B<fts_children>()  returns a pointer to a linked "
"list of structures, each of which describes one of the files contained in a "
"directory in the hierarchy."
msgstr ""
"fts 関数群は、ファイル階層をたどるために提供されている。 簡単に概略すると次の"
"ようになる。 B<fts_open>()  関数は、他の fts 関数群に渡すための、ファイル階層"
"の「ハンドル」を返す。 B<fts_read>()  関数は、ファイル階層中にある 1 つのファ"
"イルを記述する構造体へのポインターを返す。 B<fts_children>()  関数は、階層中"
"のディレクトリにあるファイルを記述する構造体の リンクリストへのポインターを返"
"す。 一般にディレクトリは、 preorder (正方向：下の階層のディレクトリをたどる"
"前) と postorder (逆方向：下の階層のディレクトリをすべてたどった後) という、 "
"異なる方向で 2 回たどられる。ファイルは 1 回たどられる。 ディレクトリ階層を"
"「論理的に」(シンボリックリングが指すファイルを見て) 辿ることも、 物理的に "
"(シンボリックリンク自身を見て) 辿ることも可能である。 また、階層中の移動の道"
"筋を指示すること・ 余分なものを取り除くこと・階層の一部を再びたどることが可能"
"である。"

#. type: Plain text
#: build/C/man3/fts.3:90
#, fuzzy
#| msgid ""
#| "The fts functions are provided for traversing file hierarchies.  A simple "
#| "overview is that the B<fts_open>()  function returns a \"handle\" on a "
#| "file hierarchy, which is then supplied to the other fts functions.  The "
#| "function B<fts_read>()  returns a pointer to a structure describing one "
#| "of the files in the file hierarchy.  The function B<fts_children>()  "
#| "returns a pointer to a linked list of structures, each of which describes "
#| "one of the files contained in a directory in the hierarchy.  In general, "
#| "directories are visited two distinguishable times; in preorder (before "
#| "any of their descendants are visited) and in postorder (after all of "
#| "their descendants have been visited).  Files are visited once.  It is "
#| "possible to walk the hierarchy \"logically\" (visiting the files that "
#| "symbolic links point to)  or physically (visiting the symbolic links "
#| "themselves), order the walk of the hierarchy or prune and/or revisit "
#| "portions of the hierarchy."
msgid ""
"In general, directories are visited two distinguishable times; in preorder "
"(before any of their descendants are visited) and in postorder (after all of "
"their descendants have been visited).  Files are visited once.  It is "
"possible to walk the hierarchy \"logically\" (visiting the files that "
"symbolic links point to)  or physically (visiting the symbolic links "
"themselves), order the walk of the hierarchy or prune and/or revisit "
"portions of the hierarchy."
msgstr ""
"fts 関数群は、ファイル階層をたどるために提供されている。 簡単に概略すると次の"
"ようになる。 B<fts_open>()  関数は、他の fts 関数群に渡すための、ファイル階層"
"の「ハンドル」を返す。 B<fts_read>()  関数は、ファイル階層中にある 1 つのファ"
"イルを記述する構造体へのポインターを返す。 B<fts_children>()  関数は、階層中"
"のディレクトリにあるファイルを記述する構造体の リンクリストへのポインターを返"
"す。 一般にディレクトリは、 preorder (正方向：下の階層のディレクトリをたどる"
"前) と postorder (逆方向：下の階層のディレクトリをすべてたどった後) という、 "
"異なる方向で 2 回たどられる。ファイルは 1 回たどられる。 ディレクトリ階層を"
"「論理的に」(シンボリックリングが指すファイルを見て) 辿ることも、 物理的に "
"(シンボリックリンク自身を見て) 辿ることも可能である。 また、階層中の移動の道"
"筋を指示すること・ 余分なものを取り除くこと・階層の一部を再びたどることが可能"
"である。"

#. type: Plain text
#: build/C/man3/fts.3:107
#, fuzzy
#| msgid ""
#| "Two structures are defined (and typedef'd) in the include file I<E<lt>fts."
#| "hE<gt>>.  The first is I<FTS>, the structure that represents the file "
#| "hierarchy itself.  The second is I<FTSENT>, the structure that represents "
#| "a file in the file hierarchy.  Normally, an I<FTSENT> structure is "
#| "returned for every file in the file hierarchy.  In this manual page, "
#| "\"file\" and \"FTSENT structure\" are generally interchangeable.  The "
#| "I<FTSENT> structure contains at least the following fields, which are "
#| "described in greater detail below:"
msgid ""
"Two structures (and associated types) are defined in the include file "
"I<E<lt>fts.hE<gt>>.  The first type is I<FTS>, the structure that represents "
"the file hierarchy itself.  The second type is I<FTSENT>, the structure that "
"represents a file in the file hierarchy.  Normally, an I<FTSENT> structure "
"is returned for every file in the file hierarchy.  In this manual page, "
"\"file\" and \"FTSENT structure\" are generally interchangeable."
msgstr ""
"2 つの構造体がインクルードファイル I<E<lt>fts.hE<gt>> で定義されている (さら"
"に typedef されている)。 1 つ目は、ファイル階層そのものを表現する I<FTS> 構造"
"体である。 2 つ目は、ファイル階層中のファイルを表現する I<FTSENT> 構造体であ"
"る。 I<FTSENT> 構造体は通常、ファイル階層中のすべてのファイルに対して返され"
"る。 この man ページでは、「ファイル」と 「I<FTSENT> 構造体」を一般に読み変え"
"ることができる。 I<FTSENT> 構造体は、少なくとも次のようなフィールドを持ってお"
"り、 以下でより詳しく説明されている。"

#. type: Plain text
#: build/C/man3/fts.3:114
msgid ""
"The I<FTSENT> structure contains fields describing a file.  The structure "
"contains at least the following fields (there are additional fields that "
"should be considered private to the implementation):"
msgstr ""

#.  Also:
#.      ino_t fts_ino;                  /* inode (only for directories)*/
#.      dev_t fts_dev;                  /* device (only for directories)*/
#.      nlink_t fts_nlink;              /* link count (only for directories)*/
#.      u_short fts_flags;              /* private flags for FTSENT structure */
#.      u_short fts_instr;              /* fts_set() instructions */
#. type: Plain text
#: build/C/man3/fts.3:140
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* flags for FTSENT structure */\n"
"    char           *fts_accpath;  /* access path */\n"
"    char           *fts_path;     /* root path */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* filename */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* depth (-1 to N) */\n"
"    int             fts_errno;    /* file errno */\n"
"    long            fts_number;   /* local numeric value */\n"
"    void           *fts_pointer;  /* local address value */\n"
"    struct _ftsent *fts_parent;   /* parent directory */\n"
"    struct _ftsent *fts_link;     /* next file structure */\n"
"    struct _ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat    *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* FTSENT 構造体のためのフラグ */\n"
"    char           *fts_accpath;  /* アクセスパス */\n"
"    char           *fts_path;     /* ルートパス */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* ファイル名 */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* 深さ (-1 〜 N) */\n"
"    int             fts_errno;    /* ファイルのエラー番号 */\n"
"    long            fts_number;   /* ローカルな番号 */\n"
"    void            *fts_pointer;  /* ローカルなアドレス番号 */\n"
"    struct _ftsent *fts_parent;   /* 親ディレクトリ */\n"
"    struct _ftsent *fts_link;     /* 次のファイル構造体 */\n"
"    struct _ftsent *fts_cycle;    /* 循環している構造体 */\n"
"    struct stat    *fts_statp;    /* stat(2) の情報 */\n"
"} FTSENT;\n"

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: build/C/man3/fts.3:145
msgid "These fields are defined as follows:"
msgstr "これらのフィールドは、次のように定義されている。"

#. type: TP
#: build/C/man3/fts.3:145
#, no-wrap
msgid "I<fts_info>"
msgstr "I<fts_info>"

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: build/C/man3/fts.3:157
#, fuzzy
#| msgid ""
#| "One of the following flags describing the returned I<FTSENT> structure "
#| "and the file it represents.  With the exception of directories without "
#| "errors (B<FTS_D>), all of these entries are terminal, that is, they will "
#| "not be revisited, nor will any of their descendants be visited."
msgid ""
"One of the following values describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""
"このフィールドは、返された I<FTSENT> 構造体とファイルを説明する以下のフラグの"
"いずれかを表している。 エラーのないディレクトリ (B<FTS_D>), の場合は例外とし"
"て、それ以外のすべてのエントリーは終端である。 つまり、エントリーは再びたどら"
"れることもなく、 それより下の階層がたどられることもない。"

#. type: TP
#: build/C/man3/fts.3:158
#, no-wrap
msgid "B<FTS_D>"
msgstr "B<FTS_D>"

#. type: Plain text
#: build/C/man3/fts.3:161
msgid "A directory being visited in preorder."
msgstr "preorder でたどられるディレクトリ。"

#. type: TP
#: build/C/man3/fts.3:161
#, no-wrap
msgid "B<FTS_DC>"
msgstr "B<FTS_DC>"

#. type: Plain text
#: build/C/man3/fts.3:169
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the "
"I<FTSENT> structure will be filled in as well.)"
msgstr ""
"ツリーの中で循環しているディレクトリ。 (I<FTSENT> 構造体の I<fts_cycle> "
"フィールドも同様に埋められる。)"

#. type: TP
#: build/C/man3/fts.3:169
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr "B<FTS_DEFAULT>"

#. type: Plain text
#: build/C/man3/fts.3:177
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described "
"by one of the other I<fts_info> values."
msgstr ""
"ファイルタイプを表現する I<FTSENT> 構造体が、 I<fts_info> の他のいずれかの値"
"で明示的に説明されていない。"

#. type: TP
#: build/C/man3/fts.3:177
#, no-wrap
msgid "B<FTS_DNR>"
msgstr "B<FTS_DNR>"

#. type: Plain text
#: build/C/man3/fts.3:183
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"読み込みができないディレクトリ。 これはエラーの場合の返り値であり、 何がエ"
"ラーを起こしたかを示すために I<fts_errno> フィールドが設定される。"

#. type: TP
#: build/C/man3/fts.3:183
#, no-wrap
msgid "B<FTS_DOT>"
msgstr "B<FTS_DOT>"

#. type: Plain text
#: build/C/man3/fts.3:193
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""
"B<fts_open>()  へのファイル名として指定されなかった \".\" または \"..\" とい"
"う名前のファイル (B<FTS_SEEDOT> を参照すること)。"

#. type: TP
#: build/C/man3/fts.3:193
#, no-wrap
msgid "B<FTS_DP>"
msgstr "B<FTS_DP>"

#. type: Plain text
#: build/C/man3/fts.3:203
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""
"postorder でたどられるディレクトリ。 I<FTSENT> 構造体の内容は、preorder のと"
"きに返された状態 (つまり、 I<fts_info> フィールドが B<FTS_D> に設定されている"
"状態) から変更されない。"

#. type: TP
#: build/C/man3/fts.3:203
#, no-wrap
msgid "B<FTS_ERR>"
msgstr "B<FTS_ERR>"

#. type: Plain text
#: build/C/man3/fts.3:208
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""
"これはエラーの場合の返り値であり、 I<fts_errno> フィールドは、何がエラーを起"
"こしたかを示す値に設定される。"

#. type: TP
#: build/C/man3/fts.3:208
#, no-wrap
msgid "B<FTS_F>"
msgstr "B<FTS_F>"

#. type: Plain text
#: build/C/man3/fts.3:211
msgid "A regular file."
msgstr "通常のファイル。"

#. type: TP
#: build/C/man3/fts.3:211
#, no-wrap
msgid "B<FTS_NS>"
msgstr "B<FTS_NS>"

#. type: Plain text
#: build/C/man3/fts.3:222
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"B<stat>(2)  情報が得られなかったファイル。 I<fts_statp> フィールドの内容は定"
"義されない。 これはエラーの場合の返り値であり、 I<fts_errno> フィールドは、何"
"がエラーを起こしたかを示す値に設定される。"

#. type: TP
#: build/C/man3/fts.3:222
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr "B<FTS_NSOK>"

#. type: Plain text
#: build/C/man3/fts.3:230
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""
"B<stat>(2)  情報が要求されなかったファイル。 I<fts_statp> フィールドの内容は"
"定義されない。"

#. type: TP
#: build/C/man3/fts.3:230
#, no-wrap
msgid "B<FTS_SL>"
msgstr "B<FTS_SL>"

#. type: Plain text
#: build/C/man3/fts.3:233
msgid "A symbolic link."
msgstr "シンボリックリンク。"

#. type: TP
#: build/C/man3/fts.3:233
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr "B<FTS_SLNONE>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:241
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp> "
"field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""
"リンク先の存在しないシンボリックリンク。 I<fts_statp> フィールドの内容は、シ"
"ンボリックリンクそのもののファイル特性情報を参照する。"

#. type: TP
#: build/C/man3/fts.3:242
#, no-wrap
msgid "I<fts_accpath>"
msgstr "I<fts_accpath>"

#. type: Plain text
#: build/C/man3/fts.3:245
msgid "A path for accessing the file from the current directory."
msgstr "現在のディレクトリからファイルにアクセスするためのパス。"

#. type: TP
#: build/C/man3/fts.3:245
#, no-wrap
msgid "I<fts_path>"
msgstr "I<fts_path>"

#. type: Plain text
#: build/C/man3/fts.3:251
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""
"階層をたどるときのルートからみたファイルの相対的なパス。 このパスには、 "
"B<fts_open>()  に指定したパスがプレフィックスとして含まれる。"

#. type: TP
#: build/C/man3/fts.3:251
#, no-wrap
msgid "I<fts_pathlen>"
msgstr "I<fts_pathlen>"

#. type: Plain text
#: build/C/man3/fts.3:257
#, fuzzy
#| msgid "The length of the string referenced by I<fts_name>."
msgid ""
"The sum of the lengths of the strings referenced by I<fts_path> and "
"I<fts_name>."
msgstr "I<fts_name> で参照される文字列の長さ。"

#. type: TP
#: build/C/man3/fts.3:257
#, no-wrap
msgid "I<fts_name>"
msgstr "I<fts_name>"

#. type: Plain text
#: build/C/man3/fts.3:260
msgid "The name of the file."
msgstr "ファイルの名前。"

#. type: TP
#: build/C/man3/fts.3:260
#, no-wrap
msgid "I<fts_namelen>"
msgstr "I<fts_namelen>"

#. type: Plain text
#: build/C/man3/fts.3:264
msgid "The length of the string referenced by I<fts_name>."
msgstr "I<fts_name> で参照される文字列の長さ。"

#. type: TP
#: build/C/man3/fts.3:264
#, no-wrap
msgid "I<fts_level>"
msgstr "I<fts_level>"

#. type: Plain text
#: build/C/man3/fts.3:275
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""
"階層をたどって、このファイルがみつかった深さ。 -1 〜 N の数値で表される。 階"
"層をたどるときの出発点 (ルート) の親ディレクトリを表す I<FTSENT> 構造体では "
"-1 となる。 また、ルート自身の I<FTSENT> 構造体では 0 になる。"

#. type: TP
#: build/C/man3/fts.3:275
#, no-wrap
msgid "I<fts_errno>"
msgstr "I<fts_errno>"

#. type: Plain text
#: build/C/man3/fts.3:299
#, fuzzy
#| msgid ""
#| "Upon return of a I<FTSENT> structure from the B<fts_children>()  or "
#| "B<fts_read>()  functions, with its I<fts_info> field set to B<FTS_DNR>, "
#| "B<FTS_ERR> or B<FTS_NS>, the I<fts_errno> field contains the value of the "
#| "external variable I<errno> specifying the cause of the error.  Otherwise, "
#| "the contents of the I<fts_errno> field are undefined."
msgid ""
"If B<fts_children>()  or B<fts_read>()  returns an I<FTSENT> structure whose "
"I<fts_info> field is set to B<FTS_DNR>, B<FTS_ERR>, or B<FTS_NS>, the "
"I<fts_errno> field contains the error number (i.e., the I<errno> value)  "
"specifying the cause of the error.  Otherwise, the contents of the "
"I<fts_errno> field are undefined."
msgstr ""
"関数 B<fts_children>()  と B<fts_read>()  から返される I<FTSENT> 構造体の "
"I<fts_info> フィールドが B<FTS_DNR>, B<FTS_ERR>, B<FTS_NS> に設定されている場"
"合、 I<fts_errno> フィールドにはエラーの原因を示す外部変数 I<errno> の値が入"
"る。 それ以外の場合、 I<fts_errno> フィールドの内容は定義されない。"

#. type: TP
#: build/C/man3/fts.3:299
#, no-wrap
msgid "I<fts_number>"
msgstr "I<fts_number>"

#. type: Plain text
#: build/C/man3/fts.3:305
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""
"このフィールドは、アプリケーションプログラムから使用するために提供され、 fts "
"関数群では変更されない。 このフィールドは 0 で初期化される。"

#. type: TP
#: build/C/man3/fts.3:305
#, no-wrap
msgid "I<fts_pointer>"
msgstr "I<fts_pointer>"

#. type: Plain text
#: build/C/man3/fts.3:312
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""
"このフィールドは、アプリケーションプログラムから使用するために提供され、 fts "
"関数群では変更されない。 このフィールドは B<NULL> で初期化される。"

#. type: TP
#: build/C/man3/fts.3:312
#, no-wrap
msgid "I<fts_parent>"
msgstr "I<fts_parent>"

#. type: Plain text
#: build/C/man3/fts.3:326
#, fuzzy
#| msgid ""
#| "A pointer to the I<FTSENT> structure referencing the file in the "
#| "hierarchy immediately above the current file, that is, the directory of "
#| "which this file is a member.  A parent structure for the initial entry "
#| "point is provided as well, however, only the I<fts_level>, I<fts_number> "
#| "and I<fts_pointer> fields are guaranteed to be initialized."
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number>, and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""
"現在のファイルのすぐ上の階層にあるファイル (つまり、現在のファイルがメンバー"
"になっているディレクトリ) を参照する I<FTSENT> 構造体へのポインター。 最初の"
"出発点に対しても、親となる構造体は与えられる。 しかし、 I<fts_level>, "
"I<fts_number>, I<fts_pointer> フィールドのみの初期化しか保証されない。"

#. type: TP
#: build/C/man3/fts.3:326
#, no-wrap
msgid "I<fts_link>"
msgstr "I<fts_link>"

#. type: Plain text
#: build/C/man3/fts.3:337
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory "
"members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""
"B<fts_children>()  から返される場合、 I<fts_link> フィールドはディレクトリメ"
"ンバーのヌル終端されたリンクリストの形式で、 次の構造体を指し示す。 それ以外"
"の場合、 I<fts_link> フィールドは定義されない。"

#. type: TP
#: build/C/man3/fts.3:337
#, no-wrap
msgid "I<fts_cycle>"
msgstr "I<fts_cycle>"

#. type: Plain text
#: build/C/man3/fts.3:353
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""
"2 つのディレクトリにハードリンクが張られているため、 または、シンボリックリン"
"クがあるディレクトリを指しているために、 ディレクトリが循環する階層構造を作っ"
"ている場合 (B<FTS_DC> を参照)、 構造体の I<fts_cycle> フィールドは、階層中で"
"現在の I<FTSENT> 構造体と同じファイルを参照している I<FTSENT> 構造体を指し示"
"す。 それ以外の場合、 I<fts_cycle> フィールドは定義されない。"

#. type: TP
#: build/C/man3/fts.3:353
#, no-wrap
msgid "I<fts_statp>"
msgstr "I<fts_statp>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:359
msgid "A pointer to B<stat>(2)  information for the file."
msgstr "このファイルの B<stat>(2)  情報へのポインター。"

#. type: Plain text
#: build/C/man3/fts.3:386
msgid ""
"A single buffer is used for all of the paths of all of the files in the file "
"hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned "
"by B<fts_read>().  To use these fields to reference any files represented by "
"other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen> "
"field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always null-"
"terminated."
msgstr ""
"ファイル階層中のすべてのファイルのパスに対して、 ただ 1 つのバッファーが使わ"
"れる。 したがって、 I<fts_path> と I<fts_accpath> フィールドは、 "
"B<fts_read>()  によって返された最も新しいファイルに対して「のみ」ヌル終端され"
"ることが保証される。 これらのフィールドを、他の I<FTSENT> 構造体で表現される"
"ファイルを参照するために使うには、 I<FTSENT> 構造体の I<fts_pathlen> フィール"
"ドにある情報を使ってパスのバッファーを修正する必要がある。 これらの修正は、さ"
"らに B<fts_read>()  を呼び出そうとする場合には、元に戻しておかなければならな"
"い。 I<fts_name> フィールドは、常に B<NUL> 終端される。"

#. type: SS
#: build/C/man3/fts.3:386
#, no-wrap
msgid "fts_open()"
msgstr "fts_open()"

#. type: Plain text
#: build/C/man3/fts.3:393
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""
"B<fts_open>()  関数は、文字列ポインターの配列へのポインターを引数に取る。 "
"この文字列ポインターは、論理ファイル階層をつくる 1 つ以上のパスの名前にな"
"る。 配列は、 null ポインターで終端されなければならない。"

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: build/C/man3/fts.3:403
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""
"多くのオプションがあり、少なくとも 1 つ (B<FTS_LOGICAL> または "
"B<FTS_PHYSICAL>)  が指定されなければならない。 オプションは以下の値の論理和を"
"とって選択する。"

#. type: TP
#: build/C/man3/fts.3:403
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr "B<FTS_COMFOLLOW>"

#. type: Plain text
#: build/C/man3/fts.3:409
msgid ""
"This option causes any symbolic link specified as a root path to be followed "
"immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""
"このオプションは、 B<FTS_LOGICAL> の指定にかかわらず、 ルートパスに指定された"
"シンボリックリンクをすぐにたどらせる。"

#. type: TP
#: build/C/man3/fts.3:409
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr "B<FTS_LOGICAL>"

#. type: Plain text
#: build/C/man3/fts.3:428
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this "
"option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either "
"B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  "
"function."
msgstr ""
"このオプションは、 fts ルーチンにシンボリックリンクそのものではなく、 シンボ"
"リックリンクが指しているファイルの I<FTSENT> 構造体を返させる。 このオプショ"
"ンが設定された場合、 I<FTSENT> 構造体がアプリケーションに返されるような シン"
"ボリックリンクのみが、存在しないファイルを参照している。 B<FTS_LOGICAL> また"
"は B<FTS_PHYSICAL> のどちらかを、 B<fts_open>()  関数に与えなければ「ならな"
"い」。"

#. type: TP
#: build/C/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr "B<FTS_NOCHDIR>"

#. type: Plain text
#: build/C/man3/fts.3:444
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""
"パフォーマンスの最適化のため、 fts 関数群はファイル階層をたどるときディレクト"
"リを変える。 これには、階層をたどっている間は アプリケーションがある特定の"
"ディレクトリにいるということに 依存できない、という副作用がある。 "
"B<FTS_NOCHDIR> オプションで最適化を無効にすると、 fts 関数群は現在のディレク"
"トリを変更しない。 B<FTS_NOCHDIR> が指定され、かつ B<fts_open>()  の引数と"
"して絶対パス名が与えられたとき以外、アプリケーションは、 自らカレントディレク"
"トリを変更したり、 ファイルにアクセスしたりすべきではない、という点に注意する"
"こと。"

#. type: TP
#: build/C/man3/fts.3:444
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr "B<FTS_NOSTAT>"

#. type: Plain text
#: build/C/man3/fts.3:460
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes "
"that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""
"デフォルトでは、返された I<FTSENT> 構造体は、たどられた各ファイルについての"
"ファイル特徴情報 I<( statp> フィールド) を参照する。 このオプションは、 fts "
"関数群が I<fts_info> フィールドを B<FTS_NSOK> に設定し I<statp> の内容を定義"
"されないままにすることを許すことにより、 パフォーマンスの最適化に必要なものを"
"緩和する。"

#. type: TP
#: build/C/man3/fts.3:460
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr "B<FTS_PHYSICAL>"

#. type: Plain text
#: build/C/man3/fts.3:479
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""
"このオプションは、 fts ルーチンにシンボリックリンクが指しているファイルではな"
"く、 シンボリックリンク自身の I<FTSENT> 構造体を返させる。 このオプションが設"
"定されると、階層中のすべてのシンボリックリンクの I<FTSENT> 構造体がアプリケー"
"ションに返される。 B<FTS_LOGICAL> または B<FTS_PHYSICAL> のどちらかを "
"B<fts_open>()  関数に与えなければ「ならない」。"

#. type: TP
#: build/C/man3/fts.3:479
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr "B<FTS_SEEDOT>"

#. type: Plain text
#: build/C/man3/fts.3:492
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures "
"for them."
msgstr ""
"デフォルトでは、 B<fts_open>()  のパス引数として指定されない限り、ファイル"
"階層中にある \".\" または \"..\" という名前のファイルは無視される。 このオプ"
"ションは、 fts ルーチンにこれらのファイルの I<FTSENT> 構造体を返させる。"

#. type: TP
#: build/C/man3/fts.3:492
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr "B<FTS_XDEV>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:498
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""
"このオプションは、 fts が下り始めのファイルとは異なるデバイス番号を持ってい"
"る ディレクトリに下りるのを阻止する。"

#. type: Plain text
#: build/C/man3/fts.3:537
#, fuzzy
#| msgid ""
#| "The argument B<compar>()  specifies a user-defined function which may be "
#| "used to order the traversal of the hierarchy.  It takes two pointers to "
#| "pointers to I<FTSENT> structures as arguments and should return a "
#| "negative value, zero, or a positive value to indicate if the file "
#| "referenced by its first argument comes before, in any order with respect "
#| "to, or after, the file referenced by its second argument.  The "
#| "I<fts_accpath>, I<fts_path> and I<fts_pathlen> fields of the I<FTSENT> "
#| "structures may I<never> be used in this comparison.  If the I<fts_info> "
#| "field is set to B<FTS_NS> or B<FTS_NSOK>, the I<fts_statp> field may not "
#| "either.  If the B<compar>()  argument is NULL, the directory traversal "
#| "order is in the order listed in I<path_argv> for the root paths, and in "
#| "the order listed in the directory for everything else."
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path>, "
"and I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used "
"in this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""
"引数 B<compar>()  は、階層をたどる順番を決めるのに使われるユーザー定義関数"
"を指定する。 この関数は、引数として I<FTSENT> 構造体のポインターのポイン"
"ターを 2 つとり、 1 番目の引数で参照されているファイルが 2 番目の引数で参"
"照されているファイルより 前にある場合は負の値・同じ場合はゼロ・後にある場合は"
"正の値を 返さなければならない。 I<FTSENT> 構造体の I<fts_accpath>, "
"I<fts_path>, I<fts_pathlen> フィールドは、この比較に「絶対」使ってはいけな"
"い。 I<fts_info> フィールドが B<FTS_NS> または B<FTS_NSOK> に設定される場"
"合、 I<fts_statp> フィールドはこれらのどちらでもない。 B<compar>()  引数が "
"B<NULL> の場合、ディレクトリをたどる順番は、ルートパスについては "
"I<path_argv> のなかでリストされた順番で、 その他のファイルについてはディレク"
"トリ内でリストされた順番となる。"

#. type: SS
#: build/C/man3/fts.3:537
#, no-wrap
msgid "fts_read()"
msgstr "fts_read()"

#. type: Plain text
#: build/C/man3/fts.3:550
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may "
"cause files to be visited more than once, or directories more than twice.)"
msgstr ""
"B<fts_read>()  関数は、階層中のファイルを記述する I<FTSENT> 構造体へのポイン"
"ターを返す。 (読み込み可能で、循環していない) ディレクトリは、 1 回は "
"preorder で、もう 1 回は postorder で、少なくとも 2 回たどられる。 他のファイ"
"ルは、少なくとも 1 回たどられる。 (ディレクトリ間のハードリンクによって 循環"
"やシンボリックリンクへのシンボリックリンクが起こらない場合、 ファイルは 2 回"
"以上、ディレクトリは 3 回以上たどられる。)"

#. type: Plain text
#: build/C/man3/fts.3:571
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and "
"sets I<errno> appropriately.  If an error related to a returned file occurs, "
"a pointer to an I<FTSENT> structure is returned, and I<errno> may or may not "
"have been set (see I<fts_info>)."
msgstr ""
"階層中のすべてのメンバーが返された場合、 B<fts_read>()  は B<NULL> を返し、外"
"部変数 I<errno> を 0 にする。 階層中のファイルに関係しないエラーが起こった場"
"合、 B<fts_read>()  は B<NULL> を返し、 I<errno> をエラーに対応した値にす"
"る。 階層中のファイルに関係したエラーが起こった場合、 I<FTSENT> 構造体へのポ"
"インターが返され、 I<errno> は設定される場合と設定されない場合がある "
"(I<fts_info> を参照すること)。"

#. type: Plain text
#: build/C/man3/fts.3:588
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after "
"a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""
"B<fts_read>()  によって返される I<FTSENT> 構造体は、同じファイル階層ストリー"
"ムへの B<fts_close>()  の呼出しの後に上書きされる。 また、同じファイル階層ス"
"トリームへの B<fts_read>()  の呼出しの後でも、構造体がディレクトリを表現して"
"いない限り上書きされる。 この場合、 B<fts_read>()  関数によって postorder で "
"I<FTSENT> 構造体が返された後、 B<fts_read>()  の呼出しがあるまで、 これらの構"
"造体は上書きされない。"

#. type: SS
#: build/C/man3/fts.3:588
#, no-wrap
msgid "fts_children()"
msgstr "fts_children()"

#. type: Plain text
#: build/C/man3/fts.3:606
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""
"B<fts_children>()  関数は、 I<FTSENT> 構造体へのポインターを返す。 この構造体"
"は、( B<fts_read>()  で最も新しく返された I<FTSENT> 構造体で表現されるディレ"
"クトリにあるファイルの) ヌル終端されたリンクリストの最初のエントリーを記述す"
"る。 このリストは、 I<FTSENT> 構造体の I<fts_link> フィールドを使ってリンクさ"
"れ、 ユーザー指定の比較関数がある場合は、それで順序づけられる。 "
"B<fts_children>()  の呼出しを繰り返すことで、 このリンクリストは再生成され"
"る。"

#. type: Plain text
#: build/C/man3/fts.3:634
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""
"特別な場合として、 B<fts_read>()  がファイル階層について呼ばれていない場合、 "
"B<fts_children>()  は B<fts_open>()  に指定された論理ディレクトリ (つまり、 "
"B<fts_open>()  に指定された引数) の中にあるファイルへのポインターを返す。 "
"それ以外の場合で、 B<fts_read>()  によって最も新しく返された I<FTSENT> 構造体"
"が preorder でたどられたディレクトリでない場合や 何も含んでいないディレクトリ"
"の場合は、 B<fts_children>()  は B<NULL> を返し、 I<errno> を 0 にする。 エ"
"ラーが起こった場合、 B<fts_children>()  は B<NULL> を返し、 I<errno> をエラー"
"に対応した値にする。"

#. type: Plain text
#: build/C/man3/fts.3:645
#, fuzzy
#| msgid ""
#| "The I<FTSENT> structures returned by B<fts_children>()  may be "
#| "overwritten after a call to B<fts_children>(), B<fts_close>()  or "
#| "B<fts_read>()  on the same file hierarchy stream."
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>(), or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""
"B<fts_children>()  によって返される I<FTSENT> 構造体は、同じファイル階層スト"
"リームへの B<fts_children>(), B<fts_close>(), B<fts_read>()  の呼出しの後に上"
"書きされる場合がある。"

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: build/C/man3/fts.3:650
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid "The I<instr> argument is either zero or the following value:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man3/fts.3:650
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr "B<FTS_NAMEONLY>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:660
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""
"ファイル名のみが必要とされている。 返された構造体のリンクリストの "
"I<fts_name>, I<fts_namelen> フィールド以外の すべてのフィールドの内容は定義さ"
"れない。"

#. type: SS
#: build/C/man3/fts.3:660
#, no-wrap
msgid "fts_set()"
msgstr "fts_set()"

#. type: Plain text
#: build/C/man3/fts.3:672
#, fuzzy
#| msgid ""
#| "The function B<fts_set>()  allows the user application to determine "
#| "further processing for the file I<f> of the stream I<ftsp>.  The "
#| "B<fts_set>()  function returns 0 on success, and -1 if an error occurs.  "
#| "I<Option> must be set to one of the following values:"
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs."
msgstr ""
"関数 B<fts_set>()  は、ユーザーアプリケーションが ストリーム I<ftsp> のファイ"
"ル I<f> について更なる処理を決定すること許す。 B<fts_set>()  関数は、成功した"
"場合は 0 を、エラーが起こった場合は -1 を返す。 I<option> は、次の値のいずれ"
"か 1 つに設定されなければならない。"

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: build/C/man3/fts.3:677
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid ""
"The I<instr> argument is either 0 (meaning \"do nothing\") or one of the "
"following values:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man3/fts.3:677
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr "B<FTS_AGAIN>"

#. type: Plain text
#: build/C/man3/fts.3:695
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""
"ファイルを再びたどる。すべてのファイルタイプが再びたどられる。 次の "
"B<fts_read>()  の呼出しにより、参照されているファイルが返される。 構造体の "
"I<fts_stat>, I<fts_info> フィールドはこの時に初期化されるが、他のフィールドは"
"変更されない。 このオプションは、 B<fts_read>()  によって最も新しく返された"
"ファイルについてのみ意味を持つ。 通常は、postorder でディレクトリをたどる場合"
"に使用し、 その下の階層と同様に、 ディレクトリを (preorder と postorder の両"
"方で) 再びたどらせる。"

#. type: TP
#: build/C/man3/fts.3:695
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr "B<FTS_FOLLOW>"

#. type: Plain text
#: build/C/man3/fts.3:723
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()  "
"returns the file with the I<fts_info> and I<fts_statp> fields reinitialized "
"to reflect the target of the symbolic link instead of the symbolic link "
"itself.  If the file is one of those most recently returned by "
"B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the structure, "
"when returned by B<fts_read>(), will reflect the target of the symbolic link "
"instead of the symbolic link itself.  In either case, if the target of the "
"symbolic link does not exist, the fields of the returned structure will be "
"unchanged and the I<fts_info> field will be set to B<FTS_SLNONE>."
msgstr ""
"参照されてるファイルは、シンボリックリンクでなければならない。 参照されている"
"ファイルが B<fts_read>()  によって最も新しく返されたものである場合、次の "
"B<fts_read>()  の呼出しでは、シンボリックリンクそのものではなく、 シンボリッ"
"クリンクが指している先を反映するように I<fts_info>, I<fts_statp> を再び初期化"
"したファイルが返される。 ファイルが B<fts_children>()  によって最も新しく返さ"
"れたものの 1 つである場合、 B<fts_read>()  によって返されたとき、構造体の "
"I<fts_info>, I<fts_statp> フィールドは、シンボリックリンクそのものではなく、 "
"シンボリックリンクが指している先を反映する。 どちらの場合でも、シンボリックリ"
"ンクが指している先がないときは、 返された構造体のフィールドは変更されず、 "
"I<fts_info> フィールドが B<FTS_SLNONE> に設定される。"

#. type: Plain text
#: build/C/man3/fts.3:727
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""
"リンク先がディレクトリの場合、 ファイルが preorder で返された後、下の階層のす"
"べてファイルが返され、 その後で postorder で返される。"

#. type: TP
#: build/C/man3/fts.3:727
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr "B<FTS_SKIP>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:735
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""
"このファイルの下の階層はたどられない。 このファイルは、 B<fts_children>()  ま"
"たは B<fts_read>()  のどちらかによって最も新しく返されたものの 1 つである。"

#. type: SS
#: build/C/man3/fts.3:735
#, no-wrap
msgid "fts_close()"
msgstr "fts_close()"

#. type: Plain text
#: build/C/man3/fts.3:748
#, fuzzy
#| msgid ""
#| "The B<fts_close>()  function closes a file hierarchy stream I<ftsp> and "
#| "restores the current directory to the directory from which B<fts_open>()  "
#| "was called to open I<ftsp>.  The B<fts_close>()  function returns 0 on "
#| "success, and -1 if an error occurs."
msgid ""
"The B<fts_close>()  function closes the file hierarchy stream referred to by "
"I<ftsp> and restores the current directory to the directory from which "
"B<fts_open>()  was called to open I<ftsp>.  The B<fts_close>()  function "
"returns 0 on success, and -1 if an error occurs."
msgstr ""
"B<fts_close>()  関数は、ファイル階層ストリーム I<ftsp> を閉じる。そして、現在"
"のディレクトリを I<ftsp> を開くために B<fts_open>()  が呼ばれたディレクトリに"
"復元する。 B<fts_close>()  関数は、成功した場合は 0 を、エラーが起こった場合"
"は -1 を返す。"

#. type: SH
#: build/C/man3/fts.3:748 build/C/man2/getxattr.2:110
#: build/C/man3/isfdtype.3:82 build/C/man2/listxattr.2:132
#: build/C/man2/mount.2:631 build/C/man2/removexattr.2:83
#: build/C/man2/setxattr.2:114 build/C/man2/spu_create.2:179
#: build/C/man2/spu_run.2:155 build/C/man2/stat.2:379 build/C/man2/statfs.2:229
#: build/C/man2/statx.2:500 build/C/man3/statvfs.3:133 build/C/man2/sysfs.2:88
#: build/C/man2/umount.2:118 build/C/man2/ustat.2:77 build/C/man4/fuse.4:465
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/fts.3:757
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""
"関数 B<fts_open>()  が失敗した場合、 I<errno> は、ライブラリ関数 B<open>(2)  "
"と B<malloc>(3)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:766
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors "
"specified for B<chdir>(2)  and B<close>(2)."
msgstr ""
"関数 B<fts_close>()  が失敗した場合、 I<errno> は、ライブラリ関数 "
"B<chdir>(2)  と B<close>(2)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:780
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), and B<stat>(2)."
msgstr ""
"関数 B<fts_read>()  と B<fts_children>()  が失敗した場合、 I<errno> は、ライ"
"ブラリ関数 B<chdir>(2), B<malloc>(3), B<opendir>(3), B<readdir>(3), "
"B<stat>(2)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:789
msgid ""
"In addition, B<fts_children>(), B<fts_open>(), and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""
"更に、 B<fts_children>(), B<fts_open>(), B<fts_set>()  が失敗した場合、 "
"I<errno> が次の値にされる。"

#. type: TP
#: build/C/man3/fts.3:789 build/C/man2/mount.2:685 build/C/man2/mount.2:689
#: build/C/man2/mount.2:697 build/C/man2/mount.2:707 build/C/man2/mount.2:715
#: build/C/man2/mount.2:722 build/C/man2/mount.2:738 build/C/man2/mount.2:747
#: build/C/man2/mount.2:760 build/C/man2/mount.2:763
#: build/C/man2/spu_create.2:193 build/C/man2/spu_run.2:176
#: build/C/man2/stat.2:447 build/C/man2/statx.2:519 build/C/man2/statx.2:523
#: build/C/man2/sysfs.2:93 build/C/man2/umount.2:139 build/C/man2/umount.2:143
#: build/C/man2/ustat.2:82 build/C/man4/fuse.4:473
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/fts.3:795
#, fuzzy
#| msgid "The options were invalid."
msgid "I<options> or I<instr> was invalid."
msgstr "オプションが無効であった。"

#. type: SH
#: build/C/man3/fts.3:795 build/C/man3/ftw.3:367 build/C/man2/getxattr.2:140
#: build/C/man2/listxattr.2:154 build/C/man2/mount.2:827
#: build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:159
#: build/C/man2/spu_create.2:253 build/C/man2/spu_run.2:190
#: build/C/man2/stat.2:457 build/C/man2/statx.2:559 build/C/man2/umount.2:170
#: build/C/man2/ustat.2:92 build/C/man5/sysfs.5:274 build/C/man5/tmpfs.5:214
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/fts.3:797
msgid "These functions are available in Linux since glibc2."
msgstr "これらの関数は、Linux では glibc2 から使用可能である。"

#. type: SH
#: build/C/man3/fts.3:797 build/C/man3/ftw.3:370 build/C/man3/getfsent.3:115
#: build/C/man3/getmntent.3:213 build/C/man3/statvfs.3:190
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/fts.3:800 build/C/man3/ftw.3:373 build/C/man3/getfsent.3:118
#: build/C/man3/getmntent.3:216 build/C/man3/statvfs.3:193
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122
#: build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122
#: build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122
#: build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/fts.3:809
#, no-wrap
msgid ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"
msgstr ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"

#. type: tbl table
#: build/C/man3/fts.3:809 build/C/man3/fts.3:813 build/C/man3/ftw.3:380
#: build/C/man3/ftw.3:383 build/C/man3/getfsent.3:127
#: build/C/man3/getfsent.3:134 build/C/man3/getmntent.3:226
#: build/C/man3/getmntent.3:229 build/C/man3/getmntent.3:232
#: build/C/man3/getmntent.3:235 build/C/man3/statvfs.3:201
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/fts.3:809 build/C/man3/ftw.3:383 build/C/man3/getmntent.3:226
#: build/C/man3/statvfs.3:201
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: tbl table
#: build/C/man3/fts.3:813
#, no-wrap
msgid ""
"B<fts_read>(),\n"
"B<fts_children>()"
msgstr ""
"B<fts_read>(),\n"
"B<fts_children>()"

#. type: tbl table
#: build/C/man3/fts.3:813
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: SH
#: build/C/man3/fts.3:816 build/C/man3/ftw.3:386 build/C/man3/getfsent.3:136
#: build/C/man3/getmntent.3:238 build/C/man2/getxattr.2:143
#: build/C/man3/isfdtype.3:87 build/C/man2/listxattr.2:157
#: build/C/man2/mount.2:841 build/C/man2/removexattr.2:102
#: build/C/man2/setxattr.2:162 build/C/man2/spu_create.2:257
#: build/C/man2/spu_run.2:194 build/C/man2/stat.2:461 build/C/man2/statfs.2:286
#: build/C/man2/statx.2:562 build/C/man3/statvfs.3:203 build/C/man2/sysfs.2:101
#: build/C/man2/umount.2:176 build/C/man2/ustat.2:94 build/C/man5/sysfs.5:278
#: build/C/man4/fuse.4:513 build/C/man7/inode.7:415 build/C/man7/xattr.7:172
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/fts.3:818
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: SH
#: build/C/man3/fts.3:818 build/C/man3/ftw.3:419 build/C/man2/listxattr.2:165
#: build/C/man2/statfs.2:385 build/C/man2/sysfs.2:110
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  Fixed by commit 8b7b7f75d91f7bac323dd6a370aeb3e9c5c4a7d5
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: build/C/man3/fts.3:834
#, fuzzy
#| msgid ""
#| "All of the APIs described in this man page are not safe when compiling a "
#| "program using the LFS APIs (e.g., when compiling with I<-"
#| "D_FILE_OFFSET_BITS=64>)."
msgid ""
"In versions of glibc before 2.23, all of the APIs described in this man page "
"are not safe when compiling a program using the LFS APIs (e.g., when "
"compiling with I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""
"このマニュアルページで説明した API はいずれも、 LFS API を使うプログラムをコ"
"ンパイルする場合 (例えば、I<-D_FILE_OFFSET_BITS=64> でコンパイルする場合な"
"ど)、安全ではない。"

#. type: Plain text
#: build/C/man3/fts.3:840
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"

#. type: TH
#: build/C/man3/ftw.3:36
#, no-wrap
msgid "FTW"
msgstr "FTW"

#. type: TH
#: build/C/man3/ftw.3:36 build/C/man2/getxattr.2:25 build/C/man2/listxattr.2:26
#: build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man7/xattr.7:28
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/ftw.3:39
msgid "ftw, nftw - file tree walk"
msgstr "ftw, nftw - ファイルツリーを歩きまわる"

#. type: Plain text
#: build/C/man3/ftw.3:42 build/C/man3/ftw.3:49
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr "B<#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ftw.3:47
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"

#. type: Plain text
#: build/C/man3/ftw.3:59 build/C/man3/getmntent.3:61 build/C/man3/isfdtype.3:39
#: build/C/man2/stat.2:63
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/ftw.3:63
msgid "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"
msgstr "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"

#. type: Plain text
#: build/C/man3/ftw.3:70
#, fuzzy
#| msgid ""
#| "B<ftw>()  walks through the directory tree that is located under the "
#| "directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  "
#| "By default, directories are handled before the files and subdirectories "
#| "they contain (preorder traversal)."
msgid ""
"B<nftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By "
"default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""
"B<ftw>()  は、 I<dirpath> で指定されたディレクトリ以下のディレクトリツリー全"
"体を歩きまわり、 ツリー中でエントリーが見付かるごとに、 I<fn>()  を呼び出"
"す。 デフォルトでは、ディレクトリそのものが、そのディレクトリにあるファイル"
"や サブディレクトリよりも先に処理される (行きがけ順探索; preorder "
"traversal)。"

#. type: Plain text
#: build/C/man3/ftw.3:83
#, fuzzy
#| msgid ""
#| "To avoid using up all of the calling process's file descriptors, "
#| "I<nopenfd> specifies the maximum number of directories that B<ftw>()  "
#| "will hold open simultaneously.  When the search depth exceeds this, "
#| "B<ftw>()  will become slower because directories have to be closed and "
#| "reopened.  B<ftw>()  uses at most one file descriptor for each level in "
#| "the directory tree."
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<nftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<nftw>()  will become "
"slower because directories have to be closed and reopened.  B<nftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""
"呼び出し元プロセスが利用可能なファイルディスクリプターを使い切って しまわない"
"ようにするため、 B<ftw>()  が同時にオープンするディレクトリの最大数を "
"I<nopenfd> で指定することができる。 探索の深さがこの値を越えると、 一つのディ"
"レクトリを閉じてから他のディレクトリをオープンし直すこと になるので、 "
"B<ftw>()  の動作は遅くなる。 B<ftw>()  は、ディレクトリツリーの階層 1 レベル"
"につき、 最大でも一つのファイルディスクリプターしか使用しない。"

#. type: Plain text
#: build/C/man3/ftw.3:111
#, fuzzy
#| msgid ""
#| "For each entry found in the tree, B<ftw>()  calls I<fn>() with three "
#| "arguments: I<fpath>, I<sb>, and I<typeflag>.  I<fpath> is the pathname of "
#| "the entry, and is expressed either as a pathname relative to the calling "
#| "process's current working directory at the time of the call to B<ftw>(), "
#| "if I<dirpath> was expressed as a relative pathname, or as an absolute "
#| "pathname, if I<dirpath> was expressed as an absolute pathname.  I<sb> is "
#| "a pointer to the I<stat> structure returned by a call to B<stat>(2)  for "
#| "I<fpath>.  I<typeflag> is an integer that has one of the following values:"
msgid ""
"For each entry found in the tree, B<nftw>()  calls I<fn>() with four "
"arguments: I<fpath>, I<sb>, I<typeflag>, and I<ftwbuf>.  I<fpath> is the "
"pathname of the entry, and is expressed either as a pathname relative to the "
"calling process's current working directory at the time of the call to "
"B<nftw>(), if I<dirpath> was expressed as a relative pathname, or as an "
"absolute pathname, if I<dirpath> was expressed as an absolute pathname.  "
"I<sb> is a pointer to the I<stat> structure returned by a call to "
"B<stat>(2)  for I<fpath>."
msgstr ""
"ディレクトリツリーで見つかったエントリー毎に、 B<ftw>()  は I<fpath>, I<sb>, "
"I<typeflag> の 3つを引数として I<fn>()  を呼び出す。 I<fpath> はエントリー"
"のパス名である。 I<dirpath> が相対パス名で指定された場合には、 I<fpath> は "
"B<ftw>()  が呼び出された時点の呼び出し元プロセスのカレントワーキングディレク"
"トリ からの相対パス名となる。 I<dirpath> が絶対パス名で指定された場合には、 "
"I<fpath> は絶対パス名となる。 I<sb> は I<fpath> に対する B<stat>(2)  の呼び出"
"しで返される I<stat> 構造体へのポインターである。 I<typeflag> は整数で、以下"
"の値のいずれか一つである:"

#. type: Plain text
#: build/C/man3/ftw.3:117
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid ""
"The I<typeflag> argument passed to I<fn>()  is an integer that has one of "
"the following values:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man3/ftw.3:117
#, no-wrap
msgid "B<FTW_F>"
msgstr "B<FTW_F>"

#. type: Plain text
#: build/C/man3/ftw.3:121
msgid "I<fpath> is a regular file."
msgstr "I<fpath> が通常のファイルである"

#. type: TP
#: build/C/man3/ftw.3:121
#, no-wrap
msgid "B<FTW_D>"
msgstr "B<FTW_D>"

#. type: Plain text
#: build/C/man3/ftw.3:125
msgid "I<fpath> is a directory."
msgstr "I<fpath> がディレクトリである"

#. type: TP
#: build/C/man3/ftw.3:125
#, no-wrap
msgid "B<FTW_DNR>"
msgstr "B<FTW_DNR>"

#. type: Plain text
#: build/C/man3/ftw.3:129
msgid "I<fpath> is a directory which can't be read."
msgstr "I<fpath> が読み込みできないディレクトリである"

#. type: TP
#: build/C/man3/ftw.3:129
#, no-wrap
msgid "B<FTW_DP>"
msgstr "B<FTW_DP>"

#. type: Plain text
#: build/C/man3/ftw.3:143
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""
"I<fpath> がディレクトリで、かつ I<flags> で B<FTW_DEPTH> が指定されていた "
"(B<FTW_DEPTH> が I<flags> に指定されていなかった場合、 ディレクトリに対しては"
"常に I<typeflag> が B<FTW_D> で I<fn>() が呼び出される)。 I<fpath> 配下のファ"
"イルとサブディレクトリは全て処理が終わっている。"

#. type: TP
#: build/C/man3/ftw.3:143
#, no-wrap
msgid "B<FTW_NS>"
msgstr "B<FTW_NS>"

#. type: Plain text
#: build/C/man3/ftw.3:160
#, fuzzy
#| msgid ""
#| "The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  "
#| "The probable cause for this is that the caller had read permission on the "
#| "parent directory, so that the filename I<fpath> could be seen, but did "
#| "not have execute permission, so that the file could not be reached for "
#| "B<stat>(2)."
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent "
"directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2).  "
"The contents of the buffer pointed to by I<sb> are undefined."
msgstr ""
"B<stat>(2) の呼び出しがシンボリックリンクでない I<fpath> で失敗した。 これの"
"よくある原因は、呼び出し元が親ディレクトリに対する読み込み許可を持っており、 "
"ファイル名 I<fpath> を見ることができたが、実行許可は持っておらず、 そのため "
"B<stat>(2) ではそのファイルに到達できなかった、というものである。"

#. type: TP
#: build/C/man3/ftw.3:160
#, no-wrap
msgid "B<FTW_SL>"
msgstr "B<FTW_SL>"

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: build/C/man3/ftw.3:171
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""
"I<fpath> がシンボリックリンクで、かつ B<FTW_PHYS> が I<flags> に セットされて"
"いた。"

#. type: TP
#: build/C/man3/ftw.3:171
#, no-wrap
msgid "B<FTW_SLN>"
msgstr "B<FTW_SLN>"

#. type: Plain text
#: build/C/man3/ftw.3:184
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)  In this case the I<sb> argument passed to "
"I<fn>()  contains information returned by performing B<lstat>(2)  on the "
"\"dangling\" symbolic link.  (But see BUGS.)"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:192
#, fuzzy
#| msgid ""
#| "The fourth argument that B<nftw>()  supplies when calling I<fn>()  is a "
#| "structure of type I<FTW>:"
msgid ""
"The fourth argument (I<ftwbuf>)  that B<nftw>()  supplies when calling "
"I<fn>()  is a pointer to a structure of type I<FTW>:"
msgstr ""
"B<nftw>()  が I<fn>()  を呼び出す際に渡す 4つめの引数は I<FTW> 型の構造体で"
"ある。"

#. type: Plain text
#: build/C/man3/ftw.3:199
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"

#. type: Plain text
#: build/C/man3/ftw.3:212
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""
"I<base> は、ファイル名 (basename 要素) の、 I<fpath> で渡されるパス名の中での"
"オフセットである。 I<level> はディレクトリツリーでの I<fpath> の深さを示す。"
"深さはディレクトリツリーのトップ (root) からの 相対値である (I<dirpath> は深"
"さ 0 である)。"

#. type: Plain text
#: build/C/man3/ftw.3:223
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<nftw>().  As long as I<fn>() returns 0, "
"B<nftw>()  will continue either until it has traversed the entire tree, in "
"which case it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr "ツリーの探索を止めたい場合は、 I<fn>()  が 0 以外の値を返せば良い (この値は B<nftw>()  自身の戻り値となる)。 それ以外の場合は B<nftw>()  はツリー全体の探索を続け、すべてのツリーを探索し終えたところで 0 を返す。探索中に (B<malloc>(3)  の失敗などの) エラーが起こると -1 を返す。"

#. type: Plain text
#: build/C/man3/ftw.3:233
msgid ""
"Because B<nftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler "
"set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr "B<nftw>()  は動的なデータ構造を用いるので、ツリー探索を安全に中断する唯一の方法は 0 以外の値を I<fn>()  の返り値とすることである。割り込みを扱うには、 例えば発生した割り込みをマークしておいて、 0 以外の値を返すようにする シグナルによりメモリーリークを起こさずに探索を終了できるようにするには、 シグナルハンドラーで I<fn>()  がチェックするグローバルなフラグをセットするようにすればよい。 プログラムを終了させる場合以外は、 B<longjmp>(3)  を使用しないこと。"

#. type: Plain text
#: build/C/man3/ftw.3:238
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid ""
"The I<flags> argument of B<nftw>()  is formed by ORing zero or more of the "
"following flags:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man3/ftw.3:238
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr "B<FTW_ACTIONRETVAL> (glibc 2.3.3 以降)"

#. type: Plain text
#: build/C/man3/ftw.3:247
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value "
"from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""
"このフラグは glibc 固有である。 このフラグをセットすると、 B<nftw>()  の "
"I<fn>()  の返り値の扱いが変わる。 I<fn>()  は以下の値のいずれか一つを返す必要"
"がある。"

#. type: TP
#: build/C/man3/ftw.3:248
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr "B<FTW_CONTINUE>"

#. type: Plain text
#: build/C/man3/ftw.3:253
msgid "Instructs B<nftw>()  to continue normally."
msgstr "B<nftw>()  は通常通り処理を続ける。"

#. type: TP
#: build/C/man3/ftw.3:253
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr "B<FTW_SKIP_SIBLINGS>"

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: build/C/man3/ftw.3:261
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""
"I<fn>()  がこの値を返した場合、処理中のエントリーの兄弟 (同じ階層のエント"
"リー)  の処理はスキップされ、親ディレクトリで続きの処理が行われる。"

#. type: TP
#: build/C/man3/ftw.3:261
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr "B<FTW_SKIP_SUBTREE>"

#. type: Plain text
#: build/C/man3/ftw.3:269
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from "
"being passed as arguments to I<fn>().  B<nftw>()  continues processing with "
"the next sibling of the directory."
msgstr ""
"I<fn>()  が呼び出されたエントリーがディレクトリ (I<typeflag> が B<FTW_D>)  の"
"場合に、この値を返すと I<fn>()  の引数として渡されたディレクトリ内のエント"
"リーの処理が行われなくなる。 B<nftw>()  は処理中のディレクトリの兄弟 (同じ階"
"層のエントリー) から処理を続ける。"

#. type: TP
#: build/C/man3/ftw.3:269
#, no-wrap
msgid "B<FTW_STOP>"
msgstr "B<FTW_STOP>"

#. type: Plain text
#: build/C/man3/ftw.3:275
msgid ""
"Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr "B<nftw ()> は、返り値 B<FTW_STOP> ですぐに復帰する。"

#. type: Plain text
#: build/C/man3/ftw.3:278
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""
"他の返り値は将来新しい動作に対応付けられる可能性がある。 I<fn>()  は上記のリ"
"ストにある値以外を返さないようにすべきである。"

#. type: Plain text
#: build/C/man3/ftw.3:287
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""
"I<E<lt>ftw.hE<gt>> で B<FTW_ACTIONRETVAL> の定義が有効にするためには、 (「ど"
"の」ヘッダーファイルをインクルードするよりも前に)  機能検査マクロ "
"B<_GNU_SOURCE> を定義しなければならない。"

#. type: TP
#: build/C/man3/ftw.3:288
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr "B<FTW_CHDIR>"

#. type: Plain text
#: build/C/man3/ftw.3:299
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides.  (Specifying this flag has no effect on the "
"pathname that is passed in the I<fpath> argument of I<fn>.)"
msgstr ""
"セットされると、ディレクトリの内容を処理する前に そのディレクトリに "
"B<chdir>(2)  する。このフラグは、 I<fpath> が属すディレクトリで何らかの動作を"
"実行する必要がある場合に 便利である。\n"
"(このフラグを指定しても I<fn> の I<fpath> 引数で渡されるパス名には影響しな"
"い。)"

#. type: TP
#: build/C/man3/ftw.3:299
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr "B<FTW_DEPTH>"

#. type: Plain text
#: build/C/man3/ftw.3:305
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""
"セットされると、帰りがけ順探索 (post-order traversal) を行う。 つまり、ディレ"
"クトリそのものを引数とした I<fn>()  呼出しは、そのディレクトリに含まれる"
"ファイルとサブディレクトリに 対する処理の「後で」行われる (デフォルトでは、"
"ディレクトリ自身の処理はディレクトリ内のエントリー より「前に」行なわれる)。"

#. type: TP
#: build/C/man3/ftw.3:305
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr "B<FTW_MOUNT>"

#. type: Plain text
#: build/C/man3/ftw.3:309
msgid ""
"If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""
"セットされると、同じファイルシステムの中だけを探索対象とする (つまり、マウン"
"トポイントをまたぐことはない)。"

#. type: TP
#: build/C/man3/ftw.3:309
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr "B<FTW_PHYS>"

#. type: Plain text
#: build/C/man3/ftw.3:314
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set, "
"symbolic links are followed, but no file is reported twice."
msgstr ""
"セットされると、シンボリックリンクを辿らない (おそらくこちらが 通常望ましい動"
"作だろう)。セットされていないとシンボリックリンクを 辿るが、同じファイルが二"
"回報告されることはない。"

#. type: Plain text
#: build/C/man3/ftw.3:319
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""
"B<FTW_PHYS> がセットされずに B<FTW_DEPTH> がセットされると、自分自身に対する"
"シンボリックリンクを配下に持つ ディレクトリに対して I<fn>()  が呼び出されるこ"
"とは決してない。"

#. type: SS
#: build/C/man3/ftw.3:319
#, no-wrap
msgid "ftw()"
msgstr "ftw()"

#. type: Plain text
#: build/C/man3/ftw.3:324
msgid ""
"B<ftw>()  is an older function that offers a subset of the functionality of "
"B<nftw>().  The notable differences are as follows:"
msgstr ""

#. type: IP
#: build/C/man3/ftw.3:324 build/C/man3/ftw.3:334 build/C/man3/ftw.3:338
#: build/C/man2/mount.2:92 build/C/man2/mount.2:97 build/C/man2/mount.2:102
#: build/C/man2/mount.2:111 build/C/man2/mount.2:116 build/C/man2/mount.2:303
#: build/C/man2/mount.2:307 build/C/man2/mount.2:312 build/C/man5/tmpfs.5:50
#: build/C/man5/tmpfs.5:53 build/C/man5/tmpfs.5:56 build/C/man4/fuse.4:494
#: build/C/man4/fuse.4:498 build/C/man4/loop.4:220 build/C/man4/loop.4:223
#: build/C/man4/loop.4:229
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/ftw.3:334
msgid ""
"B<ftw>()  has no I<flags> argument.  It behaves the same as when B<nftw>()  "
"is called with I<flags> specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:338
msgid "The callback function, I<fn>(), is not supplied with a fourth argument."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:350
msgid ""
"The range of values that is passed via the I<typeflag> argument supplied to "
"I<fn>()  is smaller: just B<FTW_F>, B<FTW_D>, B<FTW_DNR>, B<FTW_NS>, and "
"(possibly)  B<FTW_SL>."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:350 build/C/man3/getfsent.3:99
#: build/C/man3/getmntent.3:184 build/C/man2/getxattr.2:104
#: build/C/man3/isfdtype.3:71 build/C/man2/listxattr.2:126
#: build/C/man2/mount.2:626 build/C/man2/removexattr.2:78
#: build/C/man2/setxattr.2:109 build/C/man2/spu_create.2:172
#: build/C/man2/spu_run.2:104 build/C/man2/stat.2:374 build/C/man2/statfs.2:224
#: build/C/man2/statx.2:495 build/C/man3/statvfs.3:128 build/C/man2/sysfs.2:76
#: build/C/man2/umount.2:113 build/C/man2/ustat.2:68
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/ftw.3:352
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr "これらの関数は、成功すると 0 を、エラーが発生すると -1 を返す。"

#. type: Plain text
#: build/C/man3/ftw.3:359
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""
"I<fn>()  が 0 以外を返した場合、ディレクトリツリーの探索を終了し、 I<fn>()  "
"が返した値を B<ftw>()  や B<nftw>()  の結果として返す。"

#. type: Plain text
#: build/C/man3/ftw.3:367
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""
"B<nftw>()  が B<FTW_ACTIONRETVAL> フラグ付きで呼ばれた場合、ツリーの探索を終"
"了させるために I<fn>()  が使用できる、非 0 の値は B<FTW_STOP> だけであり、 こ"
"の値は B<nftw>()  の返り値として返される。"

#. type: Plain text
#: build/C/man3/ftw.3:370
msgid "B<nftw>()  is available under glibc since version 2.1."
msgstr "B<nftw>() は バージョン 2.1 以降の glibc で利用できる。"

#. type: tbl table
#: build/C/man3/ftw.3:380
#, no-wrap
msgid "B<nftw>()"
msgstr "B<nftw>()"

#. type: tbl table
#: build/C/man3/ftw.3:380
#, no-wrap
msgid "MT-Safe cwd"
msgstr "MT-Safe cwd"

#. type: tbl table
#: build/C/man3/ftw.3:383
#, no-wrap
msgid "B<ftw>()"
msgstr "B<ftw>()"

#. type: Plain text
#: build/C/man3/ftw.3:391
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as "
"obsolete."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1.  POSIX.1-2008 は B<ftw>() を廃止予定としている。"

#. type: SH
#: build/C/man3/ftw.3:391 build/C/man3/getfsent.3:148
#: build/C/man3/getmntent.3:245 build/C/man3/isfdtype.3:97
#: build/C/man2/mount.2:844 build/C/man2/spu_create.2:261
#: build/C/man2/spu_run.2:198 build/C/man2/stat.2:500 build/C/man2/statfs.2:292
#: build/C/man3/statvfs.3:215 build/C/man2/sysfs.2:103
#: build/C/man2/umount.2:179 build/C/man2/ustat.2:98 build/C/man5/sysfs.5:282
#: build/C/man5/tmpfs.5:221 build/C/man4/fuse.4:515 build/C/man7/inode.7:463
#: build/C/man7/xattr.7:175
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/ftw.3:395
#, fuzzy
#| msgid ""
#| "POSIX.1-2001 note that the results are unspecified if I<fn> does not "
#| "preserve the current working directory."
msgid ""
"POSIX.1-2008 notes that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""
"POSIX.1-2001 の注記によると、 I<fn> がカレントワーキングディレクトリを保持し"
"なかった場合の 結果は規定されていないとされている。"

#. type: Plain text
#: build/C/man3/ftw.3:401
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""
"B<nftw>()  関数と、 B<ftw>()  における B<FTW_SL> は、SUSv1 で導入された。"

#. type: Plain text
#: build/C/man3/ftw.3:419
#, fuzzy
#| msgid ""
#| "On some systems B<ftw>()  will never use B<FTW_SL>, on other systems "
#| "B<FTW_SL> occurs only for symbolic links that do not point to an existing "
#| "file, and again on other systems B<ftw>()  will use B<FTW_SL> for each "
#| "symbolic link.  For predictable control, use B<nftw>()."
msgid ""
"In some implementations (e.g., glibc), B<ftw>()  will never use B<FTW_SL>, "
"on other systems B<FTW_SL> occurs only for symbolic links that do not point "
"to an existing file, and again on other systems B<ftw>()  will use B<FTW_SL> "
"for each symbolic link.  If I<fpath> is a symbolic link and B<stat>(2)  "
"failed, POSIX.1-2008 states that it is undefined whether B<FTW_NS> or "
"B<FTW_SL> is passed in I<typeflag>.  For predictable results, use B<nftw>()."
msgstr ""
"B<ftw>()  で B<FTW_SL> を一切使わないシステムや、 存在しないファイルを指して"
"いるシンボリックリンクの場合にのみ B<FTW_SL> を使うシステム、また B<ftw>()  "
"が全てのシンボリックリンクに対して B<FTW_SL> を使うシステムもある。 予測可能"
"な動作をさせるためには、 B<nftw>()  を使うこと。"

#.  https://bugzilla.redhat.com/show_bug.cgi?id=1422736
#.  http://austingroupbugs.net/view.php?id=1121
#.  glibc commit 6ba205b2c35e3e024c8c12d2ee1b73363e84da87
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=23501
#. type: Plain text
#: build/C/man3/ftw.3:447
msgid ""
"According to POSIX.1-2008, when the I<typeflag> argument passed to I<fn>()  "
"contains B<FTW_SLN>, the buffer pointed to by I<sb> should contain "
"information about the dangling symbolic link (obtained by calling "
"B<lstat>(2)  on the link).  Early glibc versions correctly followed the "
"POSIX specification on this point.  However, as a result of a regression "
"introduced in glibc 2.4, the contents of the buffer pointed to by I<sb> were "
"undefined when B<FTW_SLN> is passed in I<typeflag>.  (More precisely, the "
"contents of the buffer were left unchanged in this case.)  This regression "
"was eventually fixed in glibc 2.30, so that the glibc implementation (once "
"more) follows the POSIX specification."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:447 build/C/man2/getxattr.2:151
#: build/C/man2/listxattr.2:174 build/C/man2/spu_create.2:280
#: build/C/man2/spu_run.2:209 build/C/man7/spufs.7:759 build/C/man2/stat.2:637
#: build/C/man4/loop.4:307
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/ftw.3:456
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The "
"second command-line argument can be used to specify characters that control "
"the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""
"以下のプログラムは、一つ目のコマンドライン引数を名前に持つパス以下の ディレ"
"クトリツリーを探索する。引数が指定されなかった場合は、 カレントディレクトリ"
"以下を探索する。 各々のファイルについて様々の情報が表示される。 二番目のコマ"
"ンドライン引数に文字を指定することで、 B<nftw>()  を呼び出す際に I<flags> "
"引数に渡す値を制御することができる。"

#. type: SS
#: build/C/man3/ftw.3:456 build/C/man4/loop.4:325
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/ftw.3:465
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"

#. type: Plain text
#: build/C/man3/ftw.3:476
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"
msgstr ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"

#. type: Plain text
#: build/C/man3/ftw.3:481
#, no-wrap
msgid ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"
msgstr ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"

#. type: Plain text
#: build/C/man3/ftw.3:484
#, no-wrap
msgid ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
msgstr ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"

#. type: Plain text
#: build/C/man3/ftw.3:487
#, no-wrap
msgid ""
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"

#. type: Plain text
#: build/C/man3/ftw.3:492
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"

#. type: Plain text
#: build/C/man3/ftw.3:497
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"

#. type: Plain text
#: build/C/man3/ftw.3:503
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/ftw.3:506 build/C/man2/spu_run.2:263 build/C/man2/stat.2:707
#: build/C/man4/loop.4:374
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/ftw.3:511
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr "B<stat>(2), B<fts>(3), B<readdir>(3)"

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr "GETFSENT"

#. type: TH
#: build/C/man3/getfsent.3:27 build/C/man3/statvfs.3:30
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GNU"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/getfsent.3:30
msgid ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - fstab エントリーの処理"

#. type: Plain text
#: build/C/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr "B<#include E<lt>fstab.hE<gt>>"

#. type: Plain text
#: build/C/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr "B<void endfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr "B<struct fstab *getfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"

#. type: Plain text
#: build/C/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"

#. type: Plain text
#: build/C/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr "B<int setfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr ""
"これらの関数は I</etc/fstab> ファイルから情報を読み込む。I<fstab> 構造体は次"
"のように定義されている。"

#. type: Plain text
#: build/C/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""
"*BSD システムの場合、 I<fs_type> フィールドには、5 つの文字列 \"rw\", \"rq"
"\", \"ro\", \"sw\", \"xx\" のいずれかが入る (それぞれ read-write, quota 付き "
"read-write, read-only, swap, ignore)。"

#. type: Plain text
#: build/C/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at "
"the first line."
msgstr ""
"関数 B<setfsent>()  は呼び出されると fstab ファイルをオープンし、 最初の行に"
"移動する。"

#. type: Plain text
#: build/C/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""
"関数 B<getfsent>()  は fstab ファイルから次の行をパースする (必要な場合はファ"
"イルをオープンする)。"

#. type: Plain text
#: build/C/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr "関数 B<endfsent>()  は呼び出されると fstab ファイルをクローズする。"

#. type: Plain text
#: build/C/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""
"関数 B<getfsspec>()  は fstab ファイルを先頭から検索し、 I<fs_spec> フィール"
"ドが I<special_file> 引数にマッチするエントリーが見つかったら、その最初のもの"
"を返す。"

#. type: Plain text
#: build/C/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""
"関数 B<getfsfile>()  は fstab ファイルを先頭から検索し、 I<fs_file> フィール"
"ドが I<mount_point> 引数にマッチするエントリーが見つかったら、その最初のもの"
"を返す。"

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: build/C/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr ""
"成功すると、 B<getfsent>(), B<getfsfile>(), B<getfsspec>()  の各関数は "
"I<fstab> 構造体へのポインターを返し、 B<setfsent>()  関数は 1 を返す。 失敗す"
"るとこれらの関数は NULL を返し、 end-of-file になったら 0 を返す。"

#. type: tbl table
#: build/C/man3/getfsent.3:125
#, no-wrap
msgid "B<endfsent>(),\n"
msgstr "B<endfsent>(),\n"

#. type: tbl table
#: build/C/man3/getfsent.3:125 build/C/man3/getfsent.3:130
#: build/C/man3/getfsent.3:132
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/getfsent.3:127
#, no-wrap
msgid "B<setfsent>()"
msgstr "B<setfsent>()"

#. type: tbl table
#: build/C/man3/getfsent.3:127
#, no-wrap
msgid "MT-Unsafe race:fsent"
msgstr "MT-Unsafe race:fsent"

#. type: tbl table
#: build/C/man3/getfsent.3:130
#, no-wrap
msgid "B<getfsent>(),\n"
msgstr "B<getfsent>(),\n"

#. type: tbl table
#: build/C/man3/getfsent.3:132
#, no-wrap
msgid "B<getfsspec>(),\n"
msgstr "B<getfsspec>(),\n"

#. type: tbl table
#: build/C/man3/getfsent.3:134
#, no-wrap
msgid "B<getfsfile>()"
msgstr "B<getfsfile>()"

#. type: tbl table
#: build/C/man3/getfsent.3:134
#, no-wrap
msgid "MT-Unsafe race:fsent locale"
msgstr "MT-Unsafe race:fsent locale"

#. type: Plain text
#: build/C/man3/getfsent.3:148
#, fuzzy
#| msgid ""
#| "These functions are not in POSIX.1-2001.  Several operating systems have "
#| "them, for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
#| "B<getfstype>()).  HP-UX has functions of the same names, that however use "
#| "a I<struct checklist> instead of a I<struct fstab>, and calls these "
#| "functions obsolete, superseded by B<getmntent>(3)."
msgid ""
"These functions are not in POSIX.1.  Several operating systems have them, "
"for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr ""
"POSIX.1-2001 にはこれらの関数は存在しない。 これらの関数をもつ OS はいくつか"
"あり、 例えば *BSD, SunOS, Digital UNIX, AIX 等である (AIX には "
"B<getfstype>()  もある)。 HP-UX にも同名の関数群があるが、 HP-UX のものは "
"I<fstab> 構造体ではなく I<checklist> 構造体を用いる。 またこれらの関数の呼び"
"出しは obsolete で、 B<getmntent>(3)  に取って代わられている。"

#. type: Plain text
#: build/C/man3/getfsent.3:150
msgid "These functions are not thread-safe."
msgstr "これらの関数はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/getfsent.3:160
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""
"Linux ではブロックスペシャルデバイスを複数の場所にマウントでき、 また複数のデ"
"バイスが同じマウントポイントを共有できる (この場合はそのマウントポイントに最"
"後にマウントされたデバイスが意味を持つ)  が、 B<getfsfile>()  と "
"B<getfsspec>()  はマッチした最初のエントリーしか返さないので、 これらの 2 つ"
"の関数は Linux での利用には適していない。"

#. type: Plain text
#: build/C/man3/getfsent.3:163
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr "B<getmntent>(3), B<fstab>(5)"

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr "GETMNTENT"

#. type: TH
#: build/C/man3/getmntent.3:32 build/C/man2/removexattr.2:25
#: build/C/man2/ustat.2:30 build/C/man5/tmpfs.5:25
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: build/C/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - ファイル"
"システム記述ファイルのエントリーを取得する"

#. type: Plain text
#: build/C/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:42
#, no-wrap
msgid "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"
msgstr "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<streamp>B<);>\n"
msgstr "B<int endmntent(FILE *>I<streamp>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:50
#, no-wrap
msgid "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""
"/* GNU による拡張 */\n"
"B<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:68
#, no-wrap
msgid ""
"B<getmntent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:73
msgid ""
"These routines are used to access the filesystem description file I</etc/"
"fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr ""
"これらのルーチンは、ファイルシステムを記述したファイル I</etc/fstab> と、マウ"
"ントされているファイルシステムを記述したファイル I</etc/mtab> にアクセスする"
"ために用いられる。"

#. type: Plain text
#: build/C/man3/getmntent.3:91
#, fuzzy
#| msgid ""
#| "The B<setmntent>()  function opens the filesystem description file "
#| "I<filename> and returns a file pointer which can be used by "
#| "B<getmntent>().  The argument I<type> is the type of access required and "
#| "can take the same values as the I<mode> argument of B<fopen>(3)."
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>().  "
"The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3).  The returned stream should "
"be closed using B<endmntent>()  rather than B<fclose>(3)."
msgstr ""
"B<setmntent>()  関数は、ファイルシステムの記述ファイル I<filename> をオープン"
"して、 そのファイルポインターを返す。このファイルポインターは "
"B<getmntent>()  によって用いられる。引数 I<type> は要求するアクセス形式"
"で、 B<fopen>(3)  の I<mode> 引数と同じ値を取ることができる。"

#. type: Plain text
#: build/C/man3/getmntent.3:103
msgid ""
"The B<getmntent>()  function reads the next line of the filesystem "
"description file from I<stream> and returns a pointer to a structure "
"containing the broken out fields from a line in the file.  The pointer "
"points to a static area of memory which is overwritten by subsequent calls "
"to B<getmntent>()."
msgstr ""
"B<getmntent>() 関数は I<stream> からファイルシステムの記述ファイルの次の行を"
"読み込み、 読み込んだ行をフィールドに分割した内容を収めた構造体へのポインター"
"を返す。 ポインターはメモリーの静的な領域を指しており、この領域は "
"B<getmntent>() を次に呼び出したときに上書きされてしまう。"

#. type: Plain text
#: build/C/man3/getmntent.3:113
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open I<stream>."
msgstr ""
"B<addmntent>()  関数は I<mntent> 構造体 I<mnt> の内容を、オープンされている "
"I<stream> の最後に追加する。"

#. type: Plain text
#: build/C/man3/getmntent.3:119
msgid ""
"The B<endmntent>()  function closes the I<stream> associated with the "
"filesystem description file."
msgstr ""
"B<endmntent>() 関数はファイルシステムの記述ファイルに関連付けられている "
"I<stream> を閉じる。"

#. type: Plain text
#: build/C/man3/getmntent.3:136
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the "
"I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""
"B<hasmntopt>()  関数は I<mntent> 構造体 I<mnt> の I<mnt_opts> フィールド (下"
"記 参照) をスキャンし、 I<opt> に一致する部分文字列があるかを調べる。 有効な"
"マウントオプションについては I<E<lt>mntent.hE<gt>> と B<mount>(8)  を参照のこ"
"と。"

#. type: Plain text
#: build/C/man3/getmntent.3:150
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings "
"pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""
"リエントラントな関数 B<getmntent_r>()  は B<getmntent>()  と同じだが、 ユー"
"ザーが用意した I<*mntbuf> に I<struct mount> を格納し、その構造体の各エント"
"リーが指し示す文字列を ユーザーが用意した大きさ I<buflen> の配列 I<buf> に書"
"き込む。"

#. type: Plain text
#: build/C/man3/getmntent.3:156
msgid "The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""
"I<mntent> 構造体は I<E<lt>mntent.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getmntent.3:167
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted file system */\n"
"    char *mnt_dir;      /* file system path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getmntent.3:184
#, fuzzy
#| msgid ""
#| "Since fields in the mtab and fstab files are separated by whitespace, "
#| "octal escapes are used to represent the four characters space (\\e040), "
#| "tab (\\e011), newline (\\e012) and backslash (\\e134) in those files when "
#| "they occur in one of the four strings in a I<mntent> structure.  The "
#| "routines B<addmntent>()  and B<getmntent>()  will convert from string "
#| "representation to escaped representation and back."
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the characters space (\\e040), tab (\\e011), "
"newline (\\e012), and backslash (\\e\\e) in those files when they occur in "
"one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back.  When converting from escaped "
"representation, the sequence \\e134 is also converted to a backslash."
msgstr ""
"mtab や fstab ファイルでは、各フィールドは空白で区切られているので、 スペー"
"ス、タブ、改行、バックスラッシュの 4文字をこれらのファイルで 使いたい場合で、"
"かつ I<mntent> 構造体の 4つの文字列メンバーのいずれかに対応するフィールド内"
"で 使いたい場合には、8進のエスケープ表記を使って表現する: スペース (\\e040), "
"タブ (\\e011), 改行 (\\e012), バックスラッシュ (\\e134)。 B<addmntent>()  と "
"B<getmntent>()  は、文字列表現から エスケープ表現への変換、およびその逆を行"
"う。"

#. type: Plain text
#: build/C/man3/getmntent.3:193
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""
"B<getmntent>()  と B<getmntent_r>()  は I<mntent> 構造体へのポインターを返"
"す。 失敗した場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:197
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr "B<addmntent>()  関数は成功したら 0 を返し、失敗したら 1 を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:201
msgid "The B<endmntent>()  function always returns 1."
msgstr "B<endmntent>()  関数はつねに 1 を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:206
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match "
"is found and NULL otherwise."
msgstr ""
"B<hasmntopt>()  関数は、マッチした場合は部分文字列へのアドレスを返し、 マッチ"
"しなければ NULL を返す。"

#. type: SH
#: build/C/man3/getmntent.3:206 build/C/man2/spu_create.2:247
#: build/C/man4/loop.4:303
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: TP
#: build/C/man3/getmntent.3:207
#, no-wrap
msgid "I</etc/fstab>"
msgstr "I</etc/fstab>"

#. type: Plain text
#: build/C/man3/getmntent.3:210
msgid "filesystem description file"
msgstr ""

#. type: TP
#: build/C/man3/getmntent.3:210
#, no-wrap
msgid "I</etc/mtab>"
msgstr "I</etc/mtab>"

#. type: Plain text
#: build/C/man3/getmntent.3:213
#, fuzzy
#| msgid "Mount filesystem read-only."
msgid "mounted filesystem description file"
msgstr "ファイルシステムを読み込み専用でマウントする。"

#. type: tbl table
#: build/C/man3/getmntent.3:226
#, no-wrap
msgid ""
"B<setmntent>(),\n"
"B<endmntent>(),\n"
"B<hasmntopt>()"
msgstr ""
"B<setmntent>(),\n"
"B<endmntent>(),\n"
"B<hasmntopt>()"

#. type: tbl table
#: build/C/man3/getmntent.3:229
#, no-wrap
msgid "B<getmntent>()"
msgstr "B<getmntent>()"

#. type: tbl table
#: build/C/man3/getmntent.3:229
#, no-wrap
msgid "MT-Unsafe race:mntentbuf locale"
msgstr "MT-Unsafe race:mntentbuf locale"

#. type: tbl table
#: build/C/man3/getmntent.3:232
#, no-wrap
msgid "B<addmntent>()"
msgstr "B<addmntent>()"

#. type: tbl table
#: build/C/man3/getmntent.3:232
#, no-wrap
msgid "MT-Safe race:stream locale"
msgstr "MT-Safe race:stream locale"

#. type: tbl table
#: build/C/man3/getmntent.3:235
#, no-wrap
msgid "B<getmntent_r>()"
msgstr "B<getmntent_r>()"

#. type: tbl table
#: build/C/man3/getmntent.3:235
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: build/C/man3/getmntent.3:245
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine "
"B<getmntent_r>()  was introduced in HP-UX 10, but it returns an I<int>.  The "
"prototype shown above is glibc-only."
msgstr "リエントラントでない関数は SunOS 4.1.3 由来のものである。 B<getmntent_r>()  関数は HPUX 10 で導入されたが、このバージョンでは I<int> を返す。 上記に示したプロトタイプは glibc 独自のものである。"

#. type: Plain text
#: build/C/man3/getmntent.3:257
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V I</etc/"
"mnttab> is used.  4.4BSD and Digital UNIX have a routine B<getmntinfo>(), a "
"wrapper around the system call B<getfsstat>()."
msgstr ""
"System V にも B<getmntent>()  関数はあるが、 呼び出し手順が異なり、返される構"
"造体も異なる。 System V では I</etc/mnttab> が用いられる。 4.4BSD と Digital "
"UNIX には B<getmntinfo>()  があるが、 システムコール B<getfsstat>()  のラッ"
"パー関数である。"

#. type: Plain text
#: build/C/man3/getmntent.3:261
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr "B<fopen>(3), B<fstab>(5), B<mount>(8)"

#. type: TH
#: build/C/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr "GETXATTR"

#. type: Plain text
#: build/C/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr "getxattr, lgetxattr, fgetxattr - 拡張属性の値を取得する"

#. type: Plain text
#: build/C/man2/getxattr.2:33 build/C/man2/listxattr.2:34
#: build/C/man2/removexattr.2:33 build/C/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/getxattr.2:53 build/C/man2/listxattr.2:52
#: build/C/man2/removexattr.2:49 build/C/man2/setxattr.2:53
#, fuzzy
#| msgid ""
#| "Extended attributes are I<name>:I<value> pairs associated with inodes "
#| "(files, directories, symbolic links, etc.).  They are extensions to the "
#| "normal attributes which are associated with all inodes in the system (i."
#| "e., the B<stat>(2)  data).  A complete overview of extended attributes "
#| "concepts can be found in B<attr>(5)."
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""
"拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付け"
"られた I<name>:I<value> の対である。 これらは、システム上のすべての inode に"
"関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するものである。 拡"
"張属性のコンセプトは B<attr>(5)  に書かれている。"

#. type: Plain text
#: build/C/man2/getxattr.2:66
#, fuzzy
#| msgid ""
#| "B<getxattr>()  retrieves the I<value> of the extended attribute "
#| "identified by I<name> and associated with the given I<path> in the "
#| "filesystem.  The length of the attribute I<value> is returned."
msgid ""
"B<getxattr>()  retrieves the value of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"attribute value is placed in the buffer pointed to by I<value>; I<size> "
"specifies the size of that buffer.  The return value of the call is the "
"number of bytes placed in I<value>."
msgstr ""
"B<getxattr>()  は、ファイルシステム内の指定された I<path> に対応する、名前 "
"I<name> の拡張属性の I<value> (値) を取得する。 属性 I<value> の長さが返され"
"る。"

#. type: Plain text
#: build/C/man2/getxattr.2:72
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""
"B<lgetxattr>()  は B<getxattr>()  と同じだが、シンボリックリンクの場合に、リ"
"ンクが参照しているファイル ではなく、リンクそのものの情報を取得する点だけが異"
"なる。"

#. type: Plain text
#: build/C/man2/getxattr.2:82
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of I<path>."
msgstr ""
"B<fgetxattr>()  は B<getxattr>()  と同じだが、 I<path> の代わりに I<fd> で参"
"照されたオープン済みファイルの情報だけを取得する点が異なる (I<fd> は "
"B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/getxattr.2:91
#, fuzzy
#| msgid ""
#| "An extended attribute I<name> is a simple null-terminated string.  The "
#| "name includes a namespace prefix; there may be several, disjoint "
#| "namespaces associated with an individual inode.  The value of an extended "
#| "attribute is a chunk of arbitrary textual or binary data of specified "
#| "length."
msgid ""
"An extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data that was assigned using "
"B<setxattr>(2)."
msgstr ""
"拡張属性の名前 I<name> は普通のヌル終端された文字列である。 名前には、名前空"
"間を表す接頭辞 (prefix) が含まれる; 個々の inode に対して、互いに独立な名前空"
"間が複数あってもよい。 拡張属性の値は、ある一定の長さの任意のテキストデータま"
"たは バイナリデータの集合である。"

#. type: Plain text
#: build/C/man2/getxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"named extended attribute (and leave I<value> unchanged).  This can be used "
"to determine the size of the buffer that should be supplied in a subsequent "
"call.  (But, bear in mind that there is a possibility that the attribute "
"value may change between the two calls, so that it is still necessary to "
"check the return status from the second call.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:110
#, fuzzy
#| msgid ""
#| "On success, a nonnegative number is returned indicating the size of the "
#| "extended attribute value.  On failure, -1 is returned and I<errno> is set "
#| "appropriately."
msgid ""
"On success, these calls return a nonnegative value which is the size (in "
"bytes) of the extended attribute value.  On failure, -1 is returned and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、拡張属性の値の長さを表す非負の数が返される。 失敗した場合、 -1 "
"が返され、 I<errno> に適切な値がセットされる。"

#. type: TP
#: build/C/man2/getxattr.2:111 build/C/man2/listxattr.2:133
#: build/C/man4/fuse.4:466
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/getxattr.2:117
msgid ""
"The size of the attribute value is larger than the maximum size allowed; the "
"attribute cannot be retrieved.  This can happen on filesystems that support "
"very large attribute values such as NFSv4, for example."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:117 build/C/man2/removexattr.2:84
#: build/C/man2/setxattr.2:123
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/getxattr.2:126
#, fuzzy
#| msgid ""
#| "The named attribute does not exist, or the process has no access to this "
#| "attribute.  (B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
#| "I<E<lt>attr/xattr.hE<gt>>.)"
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute."
msgstr ""
"指定された名前の属性が存在しない、またはプロセスがその属性にアクセスする権限"
"がない (B<ENOATTR> は I<E<lt>attr/xattr.hE<gt>> で B<ENODATA> の同義語として"
"定義されている)。"

#. type: TP
#: build/C/man2/getxattr.2:126 build/C/man2/listxattr.2:140
#: build/C/man2/removexattr.2:92 build/C/man2/setxattr.2:135
#: build/C/man2/setxattr.2:140
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man2/getxattr.2:129 build/C/man2/listxattr.2:143
#: build/C/man2/removexattr.2:95
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""
"拡張属性がそのファイルシステムでサポートされていない、 もしくは無効になってい"
"る。"

#. type: TP
#: build/C/man2/getxattr.2:129 build/C/man2/listxattr.2:143
#: build/C/man2/setxattr.2:152
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/getxattr.2:136
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""
"I<value> バッファーの大きさ I<size> が結果を保持するのに十分な大きさでなかっ"
"た。"

#. type: Plain text
#: build/C/man2/getxattr.2:140 build/C/man2/listxattr.2:154
#: build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:152
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "上記に加えて、 B<stat>(2) に書かれているエラーが発生する場合もある。"

#. type: Plain text
#: build/C/man2/getxattr.2:143 build/C/man2/listxattr.2:157
#: build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:162
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""
"これらのシステムコールはカーネル 2.4 以降の Linux で利用できる。 glibc でのサ"
"ポートはバージョン 2.3 以降で行われている。"

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: build/C/man2/getxattr.2:151 build/C/man2/listxattr.2:165
#: build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:170
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/getxattr.2:154
msgid "See B<listxattr>(2)."
msgstr "B<listxattr>(2) を参照。"

#. type: Plain text
#: build/C/man2/getxattr.2:164
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: build/C/man3/isfdtype.3:25
#, no-wrap
msgid "ISFDTYPE"
msgstr "ISFDTYPE"

#. type: TH
#: build/C/man3/isfdtype.3:25 build/C/man2/stat.2:39 build/C/man2/statx.2:30
#: build/C/man7/inode.7:25
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man3/isfdtype.3:28
msgid "isfdtype - test file type of a file descriptor"
msgstr "isfdtype - ファイルディスクリプターのファイル種別を検査する"

#. type: Plain text
#: build/C/man3/isfdtype.3:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/isfdtype.3:34
#, no-wrap
msgid "B<int isfdtype(int >I<fd>B<, int >I<fdtype>B<);>\n"
msgstr "B<int isfdtype(int >I<fd>B<, int >I<fdtype>B<);>\n"

#. type: Plain text
#: build/C/man3/isfdtype.3:42
msgid "B<isfdtype>():"
msgstr "B<isfdtype>():"

#. type: TP
#: build/C/man3/isfdtype.3:45
#, no-wrap
msgid "Since glibc 2.20:"
msgstr "glibc 2.20 以降:"

#. type: Plain text
#: build/C/man3/isfdtype.3:48
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: build/C/man3/isfdtype.3:48
#, no-wrap
msgid "Before glibc 2.20:"
msgstr "glibc 2.20 より前:"

#. type: Plain text
#: build/C/man3/isfdtype.3:51
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/isfdtype.3:71
msgid ""
"The B<isfdtype>()  function tests whether the file descriptor I<fd> refers "
"to a file of type I<fdtype>.  The I<fdtype> argument specifies one of the "
"B<S_IF*> constants defined in I<E<lt>sys/stat.hE<gt>> and documented in "
"B<stat>(2)  (e.g., B<S_IFREG>)."
msgstr ""
"B<isfdtype>() 関数はファイルディスクリプター I<fd> がタイプが I<fdtype> の"
"ファイルを参照しているかを検査する。 I<fdtype> 引数には、I<E<lt>sys/stat."
"hE<gt>> で定義されている B<S_IF*> 定数のひとつ (B<S_IFREG> など) を指定す"
"る。 B<S_IF*> 定数の説明は B<stat>(2) にある。"

#. type: Plain text
#: build/C/man3/isfdtype.3:82
msgid ""
"The B<isfdtype>()  function returns 1 if the file descriptor I<fd> is of "
"type I<fdtype> and 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the cause."
msgstr ""
"B<isfdtype>() 関数は、ファイルディスクリプター I<fd> がタイプ I<fdtype> で"
"あった場合に 1 を返し、そうでない場合に 0 を返す。 エラーの場合、 -1 を返し、"
"I<errno> に原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/isfdtype.3:87
msgid ""
"The B<isfdtype>()  function can fail with any of the same errors as "
"B<fstat>(3)."
msgstr "B<isfdtype>() 関数は B<fstat>(3) と同じエラーで失敗する。"

#. type: Plain text
#: build/C/man3/isfdtype.3:97
msgid ""
"The B<isfdtype>()  function is not specified in any standard, but did appear "
"in the draft POSIX.1g standard.  It is present on OpenBSD and Tru64 UNIX "
"(where the required header file in both cases is just I<E<lt>sys/stat."
"hE<gt>>, as shown in the POSIX.1g draft), and possibly other systems."
msgstr ""
"B<isfdtype>() 関数はどの標準でも規定されていないが、 POSIX.1g 標準のドラフト"
"に登場したことはある。 OpenBSD と Tru64 UNIX に存在し、おそらく他のシステムに"
"も存在する (OpenBSD と Tru64 UNIX のどちらの場合でも必要なヘッダーファイルは "
"I<E<lt>sys/stat.hE<gt>> だけであり、POSIX.1g ドラフトに書かれていたのと同じで"
"ある)。"

#. type: Plain text
#: build/C/man3/isfdtype.3:101
msgid "Portable applications should use B<fstat>(3)  instead."
msgstr ""
"移植性が求められるアプリケーションでは B<fstat>(3) を使用すべきである。"

#. type: Plain text
#: build/C/man3/isfdtype.3:103
msgid "B<fstat>(3)"
msgstr "B<fstat>(3)"

#. type: TH
#: build/C/man2/listxattr.2:26
#, no-wrap
msgid "LISTXATTR"
msgstr "LISTXATTR"

#. type: Plain text
#: build/C/man2/listxattr.2:29
msgid "listxattr, llistxattr, flistxattr - list extended attribute names"
msgstr "listxattr, llistxattr, flistxattr - 拡張属性の名前リストを得る"

#. type: Plain text
#: build/C/man2/listxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
msgstr ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/listxattr.2:68
msgid ""
"B<listxattr>()  retrieves the list of extended attribute names associated "
"with the given I<path> in the filesystem.  The retrieved list is placed in "
"I<list>, a caller-allocated buffer whose size (in bytes) is specified in the "
"argument I<size>.  The list is the set of (null-terminated) names, one after "
"the other.  Names of extended attributes to which the calling process does "
"not have access may be omitted from the list.  The length of the attribute "
"name I<list> is returned."
msgstr ""
"B<listxattr>()  は、ファイルシステム内の指定された I<path> に対応する拡張属性"
"の名前リストを取得する。取得したリストは I<list> に格納される。 I<list> は呼"
"び出し側で確保するバッファーで、引数 I<size> でバッファーのサイズを (バイト"
"単位で) 指定する。リストは名前の集合で、ヌル終端された文字列が連続して並んで"
"いる。呼び出したプロセスがアクセスする権限のない拡張属性の名前は、リストに含"
"まれない。拡張属性の名前の I<list> の長さが返される。"

#. type: Plain text
#: build/C/man2/listxattr.2:75
msgid ""
"B<llistxattr>()  is identical to B<listxattr>(), except in the case of a "
"symbolic link, where the list of names of extended attributes associated "
"with the link itself is retrieved, not the file that it refers to."
msgstr ""
"B<llistxattr>()  は B<listxattr>()  と同じだが、シンボリックリンクの場合に、"
"リンクが参照しているファイル ではなく、リンクそのものの拡張属性の名前リストを"
"取得する点だけが異なる。"

#. type: Plain text
#: build/C/man2/listxattr.2:85
msgid ""
"B<flistxattr>()  is identical to B<listxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of I<path>."
msgstr ""
"B<flistxattr>()  は B<listxattr>()  と同じだが、 I<path> の代わりに I<fd> で"
"参照されたオープン済みファイルの情報だけを取得する点が異なる (I<filedes> は "
"B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/listxattr.2:91
#, fuzzy
#| msgid ""
#| "A single extended attribute I<name> is a simple null-terminated string.  "
#| "The name includes a namespace prefix; there may be several, disjoint "
#| "namespaces associated with an individual inode."
msgid ""
"A single extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"個々の拡張属性の I<name> は普通のヌル終端された文字列である。 名前には、名前"
"空間を表す接頭辞 (prefix) が含まれる; 個々の inode に対して、互いに独立な名前"
"空間が複数あってもよい。"

#. type: Plain text
#: build/C/man2/listxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"list of extended attribute names (and leave I<list> unchanged).  This can be "
"used to determine the size of the buffer that should be supplied in a "
"subsequent call.  (But, bear in mind that there is a possibility that the "
"set of extended attributes may change between the two calls, so that it is "
"still necessary to check the return status from the second call.)"
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:104
#, no-wrap
msgid "Example"
msgstr "Example"

#. type: Plain text
#: build/C/man2/listxattr.2:109
msgid ""
"The I<list> of names is returned as an unordered array of null-terminated "
"character strings (attribute names are separated by null bytes (\\(aq"
"\\e0\\(aq)), like this:"
msgstr ""
"返される名前の I<list> は、ヌル終端された文字列の配列 (属性名はヌルバイト "
"(\\(aq\\e0\\(aq)  で区切られている) で、各要素は整列されている訳ではない。 以"
"下に例を示す:"

#. type: Plain text
#: build/C/man2/listxattr.2:113
#, no-wrap
msgid "user.name1\\e0system.name1\\e0user.name2\\e0\n"
msgstr "user.name1\\e0system.name1\\e0user.name2\\e0\n"

#. type: Plain text
#: build/C/man2/listxattr.2:120
#, fuzzy
#| msgid ""
#| "Filesystems like ext2, ext3 and XFS which implement POSIX ACLs using "
#| "extended attributes, might return a I<list> like this:"
msgid ""
"Filesystems that implement POSIX ACLs using extended attributes might return "
"a I<list> like this:"
msgstr ""
"拡張属性を使って POSIX ACL を実装している ext2、ext3、XFS のようなファイル シ"
"ステムでは、返される I<list> は以下のようになることだろう:"

#. type: Plain text
#: build/C/man2/listxattr.2:124
#, no-wrap
msgid "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"
msgstr "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"

#. type: Plain text
#: build/C/man2/listxattr.2:132
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute name list.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"成功した場合、拡張属性の名前リストの長さを表す非負の数が返される。 失敗した場"
"合、 -1 が返され、 I<errno> に適切な値がセットされる。"

#. type: Plain text
#: build/C/man2/listxattr.2:140
msgid ""
"The size of the list of extended attribute names is larger than the maximum "
"size allowed; the list cannot be retrieved.  This can happen on filesystems "
"that support an unlimited number of extended attributes per file such as "
"XFS, for example.  See BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:150
msgid "The I<size> of the I<list> buffer is too small to hold the result."
msgstr ""
"I<list> バッファーの大きさ I<size> が結果を保持するのに十分な大きさでなかっ"
"た。"

#.  The xattr(7) page refers to this text:
#. type: Plain text
#: build/C/man2/listxattr.2:174
msgid ""
"As noted in B<xattr>(7), the VFS imposes a limit of 64\\ kB on the size of "
"the extended attribute name list returned by B<listxattr>(7).  If the total "
"size of attribute names attached to a file exceeds this limit, it is no "
"longer possible to retrieve the list of attribute names."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:181
msgid ""
"The following program demonstrates the usage of B<listxattr>()  and "
"B<getxattr>(2).  For the file whose pathname is provided as a command-line "
"argument, it lists all extended file attributes and their values."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:198
msgid ""
"To keep the code simple, the program assumes that attribute keys and values "
"are constant during the execution of the program.  A production program "
"should expect and handle changes during execution of the program.  For "
"example, the number of bytes required for attribute keys might increase "
"between the two calls to B<listxattr>().  An application could handle this "
"possibility using a loop that retries the call (perhaps up to a "
"predetermined maximum number of attempts)  with a larger buffer each time it "
"fails with the error B<ERANGE>.  Calls to B<getxattr>(2)  could be handled "
"similarly."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:202
msgid ""
"The following output was recorded by first creating a file, setting some "
"extended file attributes, and then listing the attributes with the example "
"program."
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:202
#, fuzzy, no-wrap
#| msgid "Example"
msgid "Example output"
msgstr "Example"

#. type: Plain text
#: build/C/man2/listxattr.2:213
#, no-wrap
msgid ""
"$ B<touch /tmp/foo>\n"
"$ B<setfattr -n user.fred -v chocolate /tmp/foo>\n"
"$ B<setfattr -n user.frieda -v bar /tmp/foo>\n"
"$ B<setfattr -n user.empty /tmp/foo>\n"
"$ B<./listxattr /tmp/foo>\n"
"user.fred: chocolate\n"
"user.frieda: bar\n"
"user.empty: E<lt>no valueE<gt>\n"
msgstr ""
"$ B<touch /tmp/foo>\n"
"$ B<setfattr -n user.fred -v chocolate /tmp/foo>\n"
"$ B<setfattr -n user.frieda -v bar /tmp/foo>\n"
"$ B<setfattr -n user.empty /tmp/foo>\n"
"$ B<./listxattr /tmp/foo>\n"
"user.fred: chocolate\n"
"user.frieda: bar\n"
"user.empty: E<lt>no valueE<gt>\n"

#. type: SS
#: build/C/man2/listxattr.2:215
#, fuzzy, no-wrap
#| msgid "Program source"
msgid "Program source (listxattr.c)"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/listxattr.2:223
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/xattr.hE<gt>\n"
msgstr ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/xattr.hE<gt>\n"

#. type: Plain text
#: build/C/man2/listxattr.2:229
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t buflen, keylen, vallen;\n"
"    char *buf, *key, *val;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t buflen, keylen, vallen;\n"
"    char *buf, *key, *val;\n"

#. type: Plain text
#: build/C/man2/listxattr.2:234
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/listxattr.2:247
#, no-wrap
msgid ""
"    /*\n"
"     * Determine the length of the buffer needed.\n"
"     */\n"
"    buflen = listxattr(argv[1], NULL, 0);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (buflen == 0) {\n"
"        printf(\"%s has no attributes.\\en\", argv[1]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:256
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate the buffer.\n"
"     */\n"
"    buf = malloc(buflen);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    /*\n"
"     * Allocate the buffer.\n"
"     */\n"
"    buf = malloc(buflen);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/listxattr.2:265
#, no-wrap
msgid ""
"    /*\n"
"     * Copy the list of attribute keys to the buffer.\n"
"     */\n"
"    buflen = listxattr(argv[1], buf, buflen);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    /*\n"
"     * Copy the list of attribute keys to the buffer.\n"
"     */\n"
"    buflen = listxattr(argv[1], buf, buflen);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/listxattr.2:273
#, no-wrap
msgid ""
"    /*\n"
"     * Loop over the list of zero terminated strings with the\n"
"     * attribute keys. Use the remaining buffer length to determine\n"
"     * the end of the list.\n"
"     */\n"
"    key = buf;\n"
"    while (buflen E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:278
#, no-wrap
msgid ""
"        /*\n"
"         * Output attribute key.\n"
"         */\n"
"        printf(\"%s: \", key);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:285
#, no-wrap
msgid ""
"        /*\n"
"         * Determine length of the value.\n"
"         */\n"
"        vallen = getxattr(argv[1], key, NULL, 0);\n"
"        if (vallen == -1)\n"
"            perror(\"getxattr\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:287
#, no-wrap
msgid "        if (vallen E<gt> 0) {\n"
msgstr "        if (vallen E<gt> 0) {\n"

#. type: Plain text
#: build/C/man2/listxattr.2:297
#, no-wrap
msgid ""
"            /*\n"
"             * Allocate value buffer.\n"
"             * One extra byte is needed to append 0x00.\n"
"             */\n"
"            val = malloc(vallen + 1);\n"
"            if (val == NULL) {\n"
"                perror(\"malloc\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:311
#, no-wrap
msgid ""
"            /*\n"
"             * Copy value to buffer.\n"
"             */\n"
"            vallen = getxattr(argv[1], key, val, vallen);\n"
"            if (vallen == -1)\n"
"                perror(\"getxattr\");\n"
"            else {\n"
"                /*\n"
"                 * Output attribute value.\n"
"                 */\n"
"                val[vallen] = 0;\n"
"                printf(\"%s\", val);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:315
#, no-wrap
msgid ""
"            free(val);\n"
"        } else if (vallen == 0)\n"
"            printf(\"E<lt>no valueE<gt>\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:317
#, no-wrap
msgid "        printf(\"\\en\");\n"
msgstr "        printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man2/listxattr.2:325
#, no-wrap
msgid ""
"        /*\n"
"         * Forward to next attribute key.\n"
"         */\n"
"        keylen = strlen(key) + 1;\n"
"        buflen -= keylen;\n"
"        key += keylen;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:329
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/listxattr.2:340
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr "MOUNT"

#. type: Plain text
#: build/C/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr "mount - ファイルシステムをマウント/アンマウントする"

#. type: Plain text
#: build/C/man2/mount.2:46 build/C/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mount.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man2/mount.2:60
#, fuzzy
#| msgid ""
#| "B<mount>()  attaches the filesystem specified by I<source> (which is "
#| "often a device name, but can also be a directory name or a dummy) to the "
#| "directory specified by I<target>."
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a "
"pathname referring to a device, but can also be the pathname of a directory "
"or file, or a dummy string) to the location (a directory or file)  specified "
"by the pathname in I<target>."
msgstr ""
"B<mount>()  は I<source> で指定されたファイルシステム (デバイス名であることが"
"多いが、 ディレクトリ名やダミーの場合もある) を I<target> で指定されたディレ"
"クトリに結びつける。"

#. type: Plain text
#: build/C/man2/mount.2:64
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr ""
"ファイルシステムのマウントを行うには、 適切な権限 (Linux では "
"B<CAP_SYS_ADMIN> ケーパビリティ) が必要である。"

#. type: Plain text
#: build/C/man2/mount.2:73
#, fuzzy
#| msgid ""
#| "Values for the I<filesystemtype> argument supported by the kernel are "
#| "listed in I</proc/filesystems> (e.g., \"minix\", \"ext2\", \"ext3\", \"jfs"
#| "\", \"xfs\", \"reiserfs\", \"msdos\", \"proc\", \"nfs\", \"iso9660\").  "
#| "Further types may become available when the appropriate modules are "
#| "loaded."
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed "
"in I</proc/filesystems> (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\", \"vfat"
"\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", \"cifs"
"\", \"iso9660\").  Further types may become available when the appropriate "
"modules are loaded."
msgstr ""
"引数 I<filesystemtype> としてカーネルが対応している値は、 I</proc/"
"filesystems> で参照できる (例えば \"minix\", \"ext2\", \"ext3\", \"jfs\", "
"\"xfs\", \"reiserfs\", \"msdos\", \"proc\", \"nfs\", \"iso9660\" 等)。 適切な"
"モジュールが読み込まれると、さらに別の値が利用可能になるかもしれない。"

#. type: Plain text
#: build/C/man2/mount.2:82
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically "
"it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr ""
"引数 I<data> がどのように解釈されるかは、ファイルシステムによって異なる。 "
"たいていは、指定されたファイルシステムで利用可能なオプションが コンマ区切りで"
"並べられた文字列である。 各ファイルシステムに対して指定可能なオプションの詳細"
"については B<mount>(8)  を参照のこと。"

#. type: Plain text
#: build/C/man2/mount.2:92
msgid ""
"A call to B<mount>()  performs one of a number of general types of "
"operation, depending on the bits specified in I<mountflags>.  The choice of "
"which operation to perform is determined by testing the bits set in "
"I<mountflags>, with the tests being conducted in the order listed here:"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:97
msgid "Remount an existing mount: I<mountflags> includes B<MS_REMOUNT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:102
msgid "Create a bind mount: I<mountflags> includes B<MS_BIND>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:111
msgid ""
"Change the propagation type of an existing mount: I<mountflags> includes one "
"of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:116
msgid ""
"Move an existing mount to a new location: I<mountflags> includes B<MS_MOVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:120
msgid "Create a new mount: I<mountflags> includes none of the above flags."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:128
msgid ""
"Each of these operations is detailed later in this page.  Further flags may "
"be specified in I<mountflags> to modify the behavior of B<mount>(), as "
"described below."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:128
#, no-wrap
msgid "Additional mount flags"
msgstr ""

#
#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#.  commit 7a224228ed79d587ece2304869000aad1b8e97dd
#.  (This is a per-superblock flag)
#. type: Plain text
#: build/C/man2/mount.2:138
msgid ""
"The list below describes the additional flags that can be specified in "
"I<mountflags>.  Note that some operation types ignore some or all of these "
"flags, as described later in this page."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:138
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr "B<MS_DIRSYNC> (Linux 2.5.19 以降)"

#. type: Plain text
#: build/C/man2/mount.2:144
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""
"このファイルシステムへのディレクトリ変更を同期的に行う。 (この特性は個々の"
"ディレクトリ、または B<chattr>(1)  を使った部分木毎に設定できる。)"

#. type: TP
#: build/C/man2/mount.2:144
#, no-wrap
msgid "B<MS_LAZYTIME> (since Linux 4.0)"
msgstr "B<MS_LAZYTIME> (Linux 4.0 以降)"

#.  commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
#.  commit fe032c422c5ba562ba9c2d316f55e258e03259c6
#.  commit a26f49926da938f47561f386be56a83dd37a496d
#. type: Plain text
#: build/C/man2/mount.2:152
msgid ""
"Reduce on-disk updates of inode timestamps (atime, mtime, ctime)  by "
"maintaining these changes only in memory.  The on-disk timestamps are "
"updated only when:"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:153
#, no-wrap
msgid "(a)"
msgstr "(a)"

#. type: Plain text
#: build/C/man2/mount.2:155
msgid ""
"the inode needs to be updated for some change unrelated to file timestamps;"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:155
#, no-wrap
msgid "(b)"
msgstr "(b)"

#. type: Plain text
#: build/C/man2/mount.2:161
msgid "the application employs B<fsync>(2), B<syncfs>(2), or B<sync>(2);"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:161
#, no-wrap
msgid "(c)"
msgstr "(c)"

#. type: Plain text
#: build/C/man2/mount.2:163
msgid "an undeleted inode is evicted from memory; or"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:163
#, no-wrap
msgid "(d)"
msgstr "(d)"

#. type: Plain text
#: build/C/man2/mount.2:165
msgid "more than 24 hours have passed since the inode was written to disk."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:171
msgid ""
"This mount option significantly reduces writes needed to update the inode's "
"timestamps, especially mtime and atime.  However, in the event of a system "
"crash, the atime and mtime fields on disk might be out of date by up to 24 "
"hours."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:185
msgid ""
"Examples of workloads where this option could be of significant benefit "
"include frequent random writes to preallocated files, as well as cases where "
"the B<MS_STRICTATIME> mount option is also enabled.  (The advantage of "
"combining B<MS_STRICTATIME> and B<MS_LAZYTIME> is that B<stat>(2)  will "
"return the correctly updated atime, but the atime updates will be flushed to "
"disk only in the cases listed above.)"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:185
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr "B<MS_MANDLOCK>"

#.  commit 95ace75414f312f9a7b93d873f386987b92a5301
#. type: Plain text
#: build/C/man2/mount.2:198
#, fuzzy
#| msgid ""
#| "Permit mandatory locking on files in this filesystem.  (Mandatory locking "
#| "must still be enabled on a per-file basis, as described in B<fcntl>(2).)"
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)  "
"Since Linux 4.5, this mount option requires the B<CAP_SYS_ADMIN> capability "
"and a kernel configured with the B<CONFIG_MANDATORY_FILE_LOCKING> option."
msgstr ""
"このファイルシステムのファイルに対して強制ロックを認める。 (強制ロックを有効"
"にするには、 B<fcntl>(2)  で述べられている方法でファイル単位で許可をしなけれ"
"ばならない)"

#. type: TP
#: build/C/man2/mount.2:198
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr "B<MS_NOATIME>"

#. type: Plain text
#: build/C/man2/mount.2:201
msgid "Do not update access times for (all types of) files on this filesystem."
msgstr ""
"このファイルシステムの (全ての種類の) ファイルのアクセス時刻を更新しない。"

#. type: TP
#: build/C/man2/mount.2:201
#, no-wrap
msgid "B<MS_NODEV>"
msgstr "B<MS_NODEV>"

#. type: Plain text
#: build/C/man2/mount.2:204
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr ""
"このファイルシステムのデバイス (スペシャルファイル) へのアクセスを許可しな"
"い。"

#. type: TP
#: build/C/man2/mount.2:204
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr "B<MS_NODIRATIME>"

#. type: Plain text
#: build/C/man2/mount.2:213
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""
"このファイルシステムのディレクトリのアクセス時刻を更新しない。 このフラグは "
"B<MS_NOATIME> で提供される機能のサブセットを提供する。つまり、 B<MS_NOATIME> "
"では B<MS_NODIRATIME> が暗黙のうち設定される。"

#. type: TP
#: build/C/man2/mount.2:213
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr "B<MS_NOEXEC>"

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: build/C/man2/mount.2:219
msgid "Do not allow programs to be executed from this filesystem."
msgstr "このファイルシステムにあるプログラムの実行を許可しない。"

#. type: TP
#: build/C/man2/mount.2:219
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr "B<MS_NOSUID>"

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: build/C/man2/mount.2:225
#, fuzzy
#| msgid ""
#| "Do not honor set-user-ID and set-group-ID bits when executing programs "
#| "from this filesystem."
msgid ""
"Do not honor set-user-ID and set-group-ID bits or file capabilities when "
"executing programs from this filesystem."
msgstr ""
"このファイルシステムのプログラムを実行するときに、 set-user-ID ビットと set-"
"group-ID ビットを無視する。"

#. type: TP
#: build/C/man2/mount.2:225
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr "B<MS_RDONLY>"

#. type: Plain text
#: build/C/man2/mount.2:228
msgid "Mount filesystem read-only."
msgstr "ファイルシステムを読み込み専用でマウントする。"

#. type: TP
#: build/C/man2/mount.2:228
#, fuzzy, no-wrap
#| msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgid "B<MS_REC> (since Linux 2.4.11)"
msgstr "B<MNT_DETACH> (2.4.11 以降)"

#. type: Plain text
#: build/C/man2/mount.2:236
msgid ""
"Used in conjunction with B<MS_BIND> to create a recursive bind mount, and in "
"conjunction with the propagation type flags to recursively change the "
"propagation type of all of the mounts in a subtree.  See below for further "
"details."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:236
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr "B<MS_RELATIME> (Linux 2.6.20 以降)"

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: build/C/man2/mount.2:257
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the "
"file's last modification time (mtime)  or last status change time (ctime).  "
"This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""
"このファイルシステム上のファイルがアクセスされた際、 そのファイルの最終アクセ"
"ス時刻 (atime) の現在値が 最終修正時刻 (mtime) や最終状態変更時刻 (ctime) と "
"等しいか小さい場合にのみ、atime を更新する。 このオプションは、 B<mutt>(1)  "
"のように、最後の内容修正以降にファイルがいつ読み出されたかを知る 必要があるプ"
"ログラムで有用である。 Linux 2.6.30 以降では、 B<MS_NOATIME> が指定されていな"
"い場合には、このフラグの動作が カーネルのデフォルト動作となっており、 Linux "
"2.6.30 より前の動作をさせるためには B<MS_STRICTATIME> フラグを指定する必要が"
"ある。 これに加えて、Linux 2.6.30 以降では、 ファイルの最終アクセス時刻が 1 "
"日以上前の場合、 ファイルの最終アクセス時刻は常に更新される。"

#. type: TP
#: build/C/man2/mount.2:257
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr "B<MS_SILENT> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man2/mount.2:265
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""
"カーネルのログ内のある種の (I<printk>())  警告メッセージの表示を抑制する。 こ"
"のフラグは、名前が不適切で廃止された B<MS_VERBOSE> フラグ (Linux 2.4.12 以降"
"で利用可能) を置き換えるもので、同じ意味を持つ。"

#. type: TP
#: build/C/man2/mount.2:265
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr "B<MS_STRICTATIME> (Linux 2.6.30 以降)"

#. type: Plain text
#: build/C/man2/mount.2:275
msgid ""
"Always update the last access time (atime) when files on this filesystem are "
"accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying "
"this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""
"このファイルシステムがアクセスされた際に最終アクセス時刻 (atime)  を常に更新"
"する (Linux 2.6.30 より前では、これがデフォルトの動作 であった)。 このフラグ"
"を指定することで、 B<MS_NOATIME> と B<MS_RELATIME> の両フラグを設定した際の影"
"響を上書きすることができる。"

#. type: TP
#: build/C/man2/mount.2:275
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr "B<MS_SYNCHRONOUS>"

#. type: Plain text
#: build/C/man2/mount.2:283
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr ""
"ファイルシステムに対して同期的に書き込みを行う。 (このファイルシステムの全て"
"のオープンされたファイルに対して、 B<open>(2)  のフラグに B<O_SYNC> を指定し"
"たような動作となる)"

#. type: TP
#: build/C/man2/mount.2:283
#, fuzzy, no-wrap
#| msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgid "B<MS_NOSYMFOLLOW> (since Linux 5.10)"
msgstr "B<UMOUNT_NOFOLLOW> (Linux 2.6.34 以降)"

#.  dab741e0e02bd3c4f5e2e97be74b39df2523fc6e
#. type: Plain text
#: build/C/man2/mount.2:295
msgid ""
"Do not follow symbolic links when resolving paths.  Symbolic links can still "
"be created, and B<readlink>(1), B<readlink>(2), B<realpath>(1), and "
"B<realpath>(3)  all still work properly."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:301
msgid ""
"From Linux 2.4 onward, some of the above flags are settable on a per-mount "
"basis, while others apply to the superblock of the mounted filesystem, "
"meaning that all mounts of the same filesystem share those flags.  "
"(Previously, all of the flags were per-superblock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:303
#, fuzzy
#| msgid "These fields are defined as follows:"
msgid "The per-mount-point flags are as follows:"
msgstr "これらのフィールドは、次のように定義されている。"

#. type: Plain text
#: build/C/man2/mount.2:307
msgid ""
"Since Linux 2.4: B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags are "
"settable on a per-mount-point basis."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:312
msgid "Additionally, since Linux 2.6.16: B<MS_NOATIME> and B<MS_NODIRATIME>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:315
msgid "Additionally, since Linux 2.6.20: B<MS_RELATIME>."
msgstr ""

#.  And MS_I_VERSION?
#. type: Plain text
#: build/C/man2/mount.2:331
msgid ""
"The following flags are per-superblock: B<MS_DIRSYNC>, B<MS_LAZYTIME>, "
"B<MS_MANDLOCK>, B<MS_SILENT>, and B<MS_SYNCHRONOUS>.  The initial settings "
"of these flags are determined on the first mount of the filesystem, and will "
"be shared by all subsequent mounts of the same filesystem.  Subsequently, "
"the settings of the flags can be changed via a remount operation (see "
"below).  Such changes will be visible via all mount points associated with "
"the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:339
msgid ""
"Since Linux 2.6.16, B<MS_RDONLY> can be set or cleared on a per-mount-point "
"basis as well as on the underlying filesystem superblock.  The mounted "
"filesystem will be writable only if neither the filesystem nor the "
"mountpoint are flagged as read-only."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:339
#, no-wrap
msgid "Remounting an existing mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:353
#, fuzzy
#| msgid ""
#| "Remount an existing mount.  This allows you to change the I<mountflags> "
#| "and I<data> of an existing mount without having to unmount and remount "
#| "the filesystem.  I<target> should be the same value specified in the "
#| "initial B<mount>()  call; I<source> and I<filesystemtype> are ignored.  "
#| "The I<mountflags> and I<data> arguments should match the values used in "
#| "the original B<mount>()  call, except for those parameters that are being "
#| "deliberately changed."
msgid ""
"An existing mount may be remounted by specifying B<MS_REMOUNT> in "
"I<mountflags>.  This allows you to change the I<mountflags> and I<data> of "
"an existing mount without having to unmount and remount the filesystem.  "
"I<target> should be the same value specified in the initial B<mount>()  call."
msgstr ""
"すでに存在するマウントを再マウントする。これにより、すでに存在するマウントの "
"I<mountflags> と I<data> を、一度アンマウントしてから再マウントするという作業"
"をせずに 変更できる。 I<target> は最初の B<mount>() 呼び出しと同じ値を指定す"
"る必要がある。 I<source> と I<filesystemtype> は無視される。 引数 "
"I<mountflags> と I<data> は、意図的に変更するもの以外は、 元の B<mount>() の"
"呼び出しで使用した値と一致するようにすべきである。"

#. type: Plain text
#: build/C/man2/mount.2:359
msgid "The I<source> and I<filesystemtype> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:367
msgid ""
"The I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr ""

#
#.  FIXME
#.  MS_LAZYTIME seems to be available only on a few filesystems,
#.  and on ext4, it seems (from experiment that this flag
#.  can only be enabled (but not disabled) on a remount.
#.  The following code in ext4_remount() (kernel 4.17) seems to
#.  confirm this:
#.         if (*flags & SB_LAZYTIME)
#.                 sb->s_flags |= SB_LAZYTIME;
#.  See the definition of MS_RMT_MASK in include/uapi/linux/fs.h,
#.  which excludes MS_DIRSYNC and MS_SILENT, although SB_DIRSYNC
#.  and SB_SILENT are split out as per-superblock flags in do_mount()
#.  (Linux 4.17 source code)
#. type: Plain text
#: build/C/man2/mount.2:409
msgid ""
"The following I<mountflags> can be changed: B<MS_LAZYTIME>, B<MS_MANDLOCK>, "
"B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, "
"B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (whose effect is to clear "
"the B<MS_NOATIME> and B<MS_RELATIME> flags), and B<MS_SYNCHRONOUS>.  "
"Attempts to change the setting of the B<MS_DIRSYNC> and B<MS_SILENT> flags "
"during a remount are silently ignored.  Note that changes to per-superblock "
"flags are visible via all mount points of the associated filesystem (because "
"the per-superblock flags are shared by all mount points)."
msgstr ""

#.  commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
#. type: Plain text
#: build/C/man2/mount.2:423
msgid ""
"Since Linux 3.17, if none of B<MS_NOATIME>, B<MS_NODIRATIME>, "
"B<MS_RELATIME>, or B<MS_STRICTATIME> is specified in I<mountflags>, then the "
"remount operation preserves the existing values of these flags (rather than "
"defaulting to B<MS_RELATIME>)."
msgstr ""

#.  See https://lwn.net/Articles/281157/
#. type: Plain text
#: build/C/man2/mount.2:435
msgid ""
"Since Linux 2.6.26, the B<MS_REMOUNT> flag can be used with B<MS_BIND> to "
"modify only the per-mount-point flags.  This is particularly useful for "
"setting or clearing the \"read-only\" flag on a mount point without changing "
"the underlying filesystem.  Specifying I<mountflags> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:439
#, no-wrap
msgid "MS_REMOUNT | MS_BIND | MS_RDONLY\n"
msgstr "MS_REMOUNT | MS_BIND | MS_RDONLY\n"

#. type: Plain text
#: build/C/man2/mount.2:445
msgid ""
"will make access through this mountpoint read-only, without affecting other "
"mount points."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:445
#, no-wrap
msgid "Creating a bind mount"
msgstr ""

#.  since 2.4.0-test9
#. type: Plain text
#: build/C/man2/mount.2:458
msgid ""
"If I<mountflags> includes B<MS_BIND> (available since Linux 2.4), then "
"perform a bind mount.  A bind mount makes a file or a directory subtree "
"visible at another point within the single directory hierarchy.  Bind mounts "
"may cross filesystem boundaries and span B<chroot>(2)  jails."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:464
#, fuzzy
#| msgid "I<filesystemtype> not configured in the kernel."
msgid "The I<filesystemtype> and I<data> arguments are ignored."
msgstr "I<filesystemtype> がカーネル中で定義 (config) されていない。"

#. type: Plain text
#: build/C/man2/mount.2:474
msgid ""
"The remaining bits (other than B<MS_REC>, described below) in the "
"I<mountflags> argument are also ignored.  (The bind mount has the same mount "
"options as the underlying mount point.)  However, see the discussion of "
"remounting above, for a method of making an existing bind mount read-only."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:489
msgid ""
"By default, when a directory is bind mounted, only that directory is "
"mounted; if there are any submounts under the directory tree, they are not "
"bind mounted.  If the B<MS_REC> flag is also specified, then a recursive "
"bind mount operation is performed: all submounts under the I<source> subtree "
"(other than unbindable mounts)  are also bind mounted at the corresponding "
"location in the I<target> subtree."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:489
#, no-wrap
msgid "Changing the propagation type of an existing mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:501
msgid ""
"If I<mountflags> includes one of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, "
"or B<MS_UNBINDABLE> (all available since Linux 2.6.15), then the propagation "
"type of an existing mount is changed.  If more than one of these flags is "
"specified, an error results."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:508
msgid ""
"The only other flags that can be specified while changing the propagation "
"type are B<MS_REC> (described below) and B<MS_SILENT> (which is ignored)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:515
msgid "The I<source>, I<filesystemtype>, and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:517
msgid "The meanings of the propagation type flags are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:517
#, no-wrap
msgid "B<MS_SHARED>"
msgstr "B<MS_SHARED>"

#. type: Plain text
#: build/C/man2/mount.2:526
msgid ""
"Make this mount point shared.  Mount and unmount events immediately under "
"this mount point will propagate to the other mount points that are members "
"of this mount's peer group.  Propagation here means that the same mount or "
"unmount will automatically occur under all of the other mount points in the "
"peer group.  Conversely, mount and unmount events that take place under peer "
"mount points will propagate to this mount point."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:526
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr "B<MS_PRIVATE>"

#. type: Plain text
#: build/C/man2/mount.2:530
msgid ""
"Make this mount point private.  Mount and unmount events do not propagate "
"into or out of this mount point."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:530
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr "B<MS_SLAVE>"

#. type: Plain text
#: build/C/man2/mount.2:537
msgid ""
"If this is a shared mount point that is a member of a peer group that "
"contains other members, convert it to a slave mount.  If this is a shared "
"mount point that is a member of a peer group that contains no other members, "
"convert it to a private mount.  Otherwise, the propagation type of the mount "
"point is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:542
msgid ""
"When a mount point is a slave, mount and unmount events propagate into this "
"mount point from the (master) shared peer group of which it was formerly a "
"member.  Mount and unmount events under this mount point do not propagate to "
"any peer."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:546
msgid ""
"A mount point can be the slave of another peer group while at the same time "
"sharing mount and unmount events with a peer group of which it is a member."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:546
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr "B<MS_UNBINDABLE>"

#. type: Plain text
#: build/C/man2/mount.2:561
msgid ""
"Make this mount unbindable.  This is like a private mount, and in addition "
"this mount can't be bind mounted.  When a recursive bind mount (B<mount>()  "
"with the B<MS_BIND> and B<MS_REC> flags) is performed on a directory "
"subtree, any unbindable mounts within the subtree are automatically pruned "
"(i.e., not replicated)  when replicating that subtree to produce the target "
"subtree."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:572
msgid ""
"By default, changing the propagation type affects only the I<target> mount "
"point.  If the B<MS_REC> flag is also specified in I<mountflags>, then the "
"propagation type of all mount points under I<target> is also changed."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:577
msgid ""
"For further details regarding mount propagation types (including the default "
"propagation type assigned to new mounts), see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:577
#, no-wrap
msgid "Moving a mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:589
#, fuzzy
#| msgid ""
#| "Move a subtree.  I<source> specifies an existing mount point and "
#| "I<target> specifies the new location.  The move is atomic: at no point is "
#| "the subtree unmounted.  The I<filesystemtype>, I<mountflags>, and I<data> "
#| "arguments are ignored."
msgid ""
"If I<mountflags> contains the flag B<MS_MOVE> (available since Linux "
"2.4.18), then move a subtree: I<source> specifies an existing mount point "
"and I<target> specifies the new location to which that mount point is to be "
"relocated.  The move is atomic: at no point is the subtree unmounted."
msgstr ""
"部分木を移動する。 I<source> にはすでに存在するマウントポイントを指定し、 "
"I<target> には新しい場所を指定する。 移動はアトミックである。 操作の実行中、"
"部分ツリーがアンマウントされることはない。 I<filesystemtype>, I<mountflags>, "
"I<data> 引数は無視される。"

#. type: Plain text
#: build/C/man2/mount.2:598
msgid ""
"The remaining bits in the I<mountflags> argument are ignored, as are the "
"I<filesystemtype> and I<data> arguments."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:598
#, fuzzy, no-wrap
#| msgid "I<target> is not a mount point."
msgid "Creating a new mount point"
msgstr "I<target> がマウントポイントではない。"

#. type: Plain text
#: build/C/man2/mount.2:617
msgid ""
"If none of B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, "
"B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE> is specified in "
"I<mountflags>, then B<mount>()  performs its default action: creating a new "
"mount point.  I<source> specifies the source for the new mount point, and "
"I<target> specifies the directory at which to create the mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:626
msgid ""
"The I<filesystemtype> and I<data> arguments are employed, and further bits "
"may be specified in I<mountflags> to modify the behavior of the call."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:631 build/C/man2/stat.2:379 build/C/man2/statfs.2:229
#: build/C/man2/statx.2:500 build/C/man3/statvfs.3:133
#: build/C/man2/umount.2:118
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。 失敗した場合、 -1 が返され、 I<errno> に適切な値"
"がセットされる。"

#. type: Plain text
#: build/C/man2/mount.2:637 build/C/man2/umount.2:124
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each filesystem type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""
"以下に示すエラーは、ファイルシステムに依存しないものである。 それぞれのファイ"
"ルシステムタイプには固有のエラーが存在する場合があり、 独自の動作をすることも"
"ある。詳しくは Linux カーネルのソースを見て欲しい。"

#. type: TP
#: build/C/man2/mount.2:637 build/C/man2/mount.2:642 build/C/man2/mount.2:660
#: build/C/man2/spu_create.2:180 build/C/man2/stat.2:380
#: build/C/man2/statfs.2:230 build/C/man2/statx.2:501
#: build/C/man3/statvfs.3:134
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/mount.2:642
#, fuzzy
#| msgid ""
#| "(B<statfs>())  Search permission is denied for a component of the path "
#| "prefix of I<path>.  (See also B<path_resolution>(7).)"
msgid ""
"A component of a path was not searchable.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statfs>()  の場合)  I<path> のディレクトリ部分に検索許可が与えられていな"
"い (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/mount.2:647
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:656
msgid ""
"The filesystem may be read-only for various reasons, including: it resides "
"on a read-only optical disk; it is resides on a device with a physical "
"switch that has been set to mark the device read-only; the filesystem "
"implementation was compiled with read-only support; or errors were detected "
"when initially mounting the filesystem, so that it was marked read-only and "
"can't be remounted as read-write (until the errors are fixed)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:660
msgid ""
"Some filesystems instead return the error B<EROFS> on an attempt to mount a "
"read-only filesystem."
msgstr ""

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: build/C/man2/mount.2:669
msgid ""
"The block device I<source> is located on a filesystem mounted with the "
"B<MS_NODEV> option."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:669 build/C/man2/mount.2:677 build/C/man2/umount.2:131
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/mount.2:677
msgid ""
"An attempt was made to stack a new mount directly on top of an existing "
"mount point that was created in this mount namespace with the same I<source> "
"and I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:682
msgid ""
"I<source> cannot be remounted read-only, because it still holds files open "
"for writing."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:682 build/C/man2/spu_create.2:188
#: build/C/man2/spu_run.2:160 build/C/man2/stat.2:391 build/C/man2/statfs.2:242
#: build/C/man2/statx.2:512 build/C/man3/statvfs.3:146 build/C/man2/sysfs.2:89
#: build/C/man2/umount.2:135 build/C/man2/ustat.2:78
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/mount.2:685
msgid "One of the pointer arguments points outside the user address space."
msgstr "場所を示す引数のひとつがユーザーのアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/mount.2:689
msgid "I<source> had an invalid superblock."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:697
msgid ""
"A remount operation (B<MS_REMOUNT>)  was attempted, but I<source> was not "
"already mounted on I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:707
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the mount tree under "
"I<source> includes unbindable mounts and I<target> is a mount point that has "
"propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:715
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the parent mount of "
"I<source> mount has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:722
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but I<source> was not a mount "
"point, or was \\(aq/\\(aq."
msgstr ""

#.  See commit 8823c079ba7136dc1948d6f6dcb5f8022bde438e
#. type: Plain text
#: build/C/man2/mount.2:738
msgid ""
"A bind operation (B<MS_BIND>)  was requested where I<source> referred a "
"mount namespace magic link (i.e., a I</proc/[pid]/ns/mnt> magic link or a "
"bind mount to such a link)  and the propagation type of the parent mount of "
"I<target> was B<MS_SHARED>, but propagation of the requested bind mount "
"could lead to a circular dependency that might prevent the mount namespace "
"from ever being freed."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:747
msgid ""
"I<mountflags> includes more than one of B<MS_SHARED>, B<MS_PRIVATE>, "
"B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:760
msgid ""
"I<mountflags> includes B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or "
"B<MS_UNBINDABLE> and also includes a flag other than B<MS_REC> or "
"B<MS_SILENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:763
msgid "An attempt was made to bind mount an unbindable mount."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:774
msgid ""
"In an unprivileged mount namespace (i.e., a mount namespace owned by a user "
"namespace that was created by an unprivileged user), a bind mount operation "
"(B<MS_BIND>)  was attempted without specifying (B<MS_REC>), which would have "
"revealed the filesystem tree underneath one of the submounts of the "
"directory being bound."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:774 build/C/man2/mount.2:777
#: build/C/man2/spu_create.2:199 build/C/man2/stat.2:394
#: build/C/man2/statfs.2:255 build/C/man2/statx.2:530
#: build/C/man3/statvfs.3:159
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/mount.2:777
#, fuzzy
#| msgid "Too many symbolic links encountered while traversing the path."
msgid "Too many links encountered during pathname resolution."
msgstr "パスを辿る際に解決すべきシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/mount.2:783
#, fuzzy
#| msgid ""
#| "Too many links encountered during pathname resolution.  Or, a move was "
#| "attempted, while I<target> is a descendant of I<source>."
msgid ""
"A move operation was attempted, and I<target> is a descendant of I<source>."
msgstr ""
"パス名の解決中に登場したリンクが多すぎた。 または、 I<target> が I<source> の"
"子孫なのに移動が要求された。"

#. type: TP
#: build/C/man2/mount.2:783 build/C/man2/spu_create.2:203
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/mount.2:787
msgid "(In case no block device is required:)  Table of dummy devices is full."
msgstr ""
"(ブロックデバイスが必要でない場合)  ダミーデバイスのテーブルが一杯になった。"

#. type: TP
#: build/C/man2/mount.2:787 build/C/man2/spu_create.2:206
#: build/C/man2/stat.2:397 build/C/man2/statfs.2:260 build/C/man2/statx.2:533
#: build/C/man3/statvfs.3:164 build/C/man2/umount.2:157
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/mount.2:791 build/C/man2/umount.2:161
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr "パス名の長さが B<MAXPATHLEN> より長かった。"

#. type: TP
#: build/C/man2/mount.2:791 build/C/man2/spu_create.2:213
#: build/C/man4/fuse.4:501
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/mount.2:795
msgid "I<filesystemtype> not configured in the kernel."
msgstr "I<filesystemtype> がカーネル中で定義 (config) されていない。"

#. type: TP
#: build/C/man2/mount.2:795 build/C/man2/spu_create.2:217
#: build/C/man2/stat.2:401 build/C/man2/stat.2:406 build/C/man2/statfs.2:265
#: build/C/man2/statx.2:537 build/C/man3/statvfs.3:169
#: build/C/man2/umount.2:161
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/mount.2:798 build/C/man2/umount.2:164
msgid "A pathname was empty or had a nonexistent component."
msgstr "パス名が空である。もしくは指定されたパスが存在しない。"

#. type: TP
#: build/C/man2/mount.2:798 build/C/man2/spu_create.2:222
#: build/C/man2/spu_run.2:181 build/C/man2/stat.2:413 build/C/man2/statfs.2:271
#: build/C/man2/statx.2:547 build/C/man3/statvfs.3:175
#: build/C/man2/umount.2:164
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mount.2:801 build/C/man2/umount.2:167
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr ""
"カーネルがファイル名やデータをコピーするための空きページを確保できなかった。"

#. type: TP
#: build/C/man2/mount.2:801
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: build/C/man2/mount.2:805
msgid "I<source> is not a block device (and a device was required)."
msgstr "(ブロックデバイスが必要だが)  I<source> がブロックデバイスではない。"

#. type: TP
#: build/C/man2/mount.2:805 build/C/man2/spu_create.2:235
#: build/C/man2/stat.2:416 build/C/man2/stat.2:451 build/C/man2/statfs.2:277
#: build/C/man2/statx.2:550 build/C/man3/statvfs.3:181
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/mount.2:811
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr "I<target> か、 I<source> のプレフィックスがディレクトリではない。"

#. type: TP
#: build/C/man2/mount.2:811
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man2/mount.2:816
msgid "The major number of the block device I<source> is out of range."
msgstr "ブロックデバイス I<source> のメジャー番号が範囲外である。"

#. type: TP
#: build/C/man2/mount.2:816 build/C/man2/setxattr.2:143
#: build/C/man2/spu_create.2:240 build/C/man2/umount.2:167
#: build/C/man4/fuse.4:508
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/mount.2:819 build/C/man2/umount.2:170
msgid "The caller does not have the required privileges."
msgstr "呼び出し元が必要な権限を持っていない。"

#. type: TP
#: build/C/man2/mount.2:819
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/mount.2:827
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  See B<EACCES>, above."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:841
#, fuzzy
#| msgid ""
#| "The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_REC>, B<MS_RELATIME>, "
#| "and B<MS_STRICTATIME> were added to glibc headers in version 2.12."
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, "
"B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME>, and "
"B<MS_UNBINDABLE> were added to glibc headers in version 2.12."
msgstr ""
"B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_REC>, B<MS_RELATIME>, B<MS_STRICTATIME> の定"
"義が glibc のヘッダーに追加されたのは バージョン 2.12 においてである。"

#. type: Plain text
#: build/C/man2/mount.2:844
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 固有の関数であり、移植を考慮したプログラムでは 使用すべきで"
"ない。"

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: build/C/man2/mount.2:849
#, fuzzy
#| msgid ""
#| "Since Linux 2.4 a single filesystem can be visible at multiple mount "
#| "points, and multiple mounts can be stacked on the same mount point."
msgid ""
"Since Linux 2.4 a single filesystem can be mounted at multiple mount points, "
"and multiple mounts can be stacked on the same mount point."
msgstr ""
"Linux 2.4 以降、ひとつのファイルシステムを複数のマウントポイントに 結びつける"
"ことができ、同じマウントポイントに複数のマウントをスタック させることもでき"
"る。"

#. type: Plain text
#: build/C/man2/mount.2:861
#, fuzzy
#| msgid ""
#| "The I<mountflags> argument may have the magic number 0xC0ED "
#| "(B<MS_MGC_VAL>)  in the top 16 bits (this was required in kernel versions "
#| "prior to 2.4, but is no longer required and ignored if specified), and "
#| "various mount flags in the low order 16 bits:"
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)  "
"in the top 16 bits.  (All of the other flags discussed in DESCRIPTION occupy "
"the low order 16 bits of I<mountflags>.)  Specifying B<MS_MGC_VAL> was "
"required in kernel versions prior to 2.4, but since Linux 2.4 is no longer "
"required and is ignored if specified."
msgstr ""
"引数 I<mountflags> の上位 16 ビットには、マジックナンバー 0xC0ED\n"
"(B<MS_MGC_VAL>) を指定することができる (マジックナンバーは、\n"
"カーネルバージョン 2.4 より前では必須であったが、\n"
"現在は必要なく、指定されても無視される)。\n"
"I<mountflags> の下位 16 ビットにマウントフラグを指定する。"

#. type: Plain text
#: build/C/man2/mount.2:870
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""
"元の B<MS_SYNC> フラグは、別の B<MS_SYNC> が I<E<lt>mman.hE<gt>> に追加された"
"ので 1.1.69 から B<MS_SYNCHRONOUS> に名前が変わった。"

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: build/C/man2/mount.2:880
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program "
"on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in "
"this case."
msgstr ""
"Linux 2.4 より前のバージョンでは、 B<MS_NOSUID> オプション付きでマウントされ"
"たファイルシステム上の set-UID や set-GID のプログラムを実行しようとすると、 "
"B<EPERM> エラーとなった。 Linux 2.4 以降では、このような場合は set-UID ビット"
"や set-GID ビットが 無視されるだけである。"

#. type: SS
#: build/C/man2/mount.2:880
#, fuzzy, no-wrap
#| msgid "Per-process namespaces"
msgid "Mount namespaces"
msgstr "プロセス単位の名前空間"

#. type: Plain text
#: build/C/man2/mount.2:890
#, fuzzy
#| msgid ""
#| "Starting with kernel 2.4.19, Linux provides per-process mount "
#| "namespaces.  A mount namespace is the set of filesystem mounts that are "
#| "visible to a process.  Mount-point namespaces can be (and usually are)  "
#| "shared between multiple processes, and changes to the namespace (i.e., "
#| "mounts and unmounts) by one process are visible to all other processes "
#| "sharing the same namespace.  (The pre-2.4.19 Linux situation can be "
#| "considered as one in which a single namespace was shared by every process "
#| "on the system.)"
msgid ""
"Starting with kernel 2.4.19, Linux provides mount namespaces.  A mount "
"namespace is the set of filesystem mounts that are visible to a process.  "
"Mount namespaces can be (and usually are)  shared between multiple "
"processes, and changes to the namespace (i.e., mounts and unmounts) by one "
"process are visible to all other processes sharing the same namespace.  (The "
"pre-2.4.19 Linux situation can be considered as one in which a single "
"namespace was shared by every process on the system.)"
msgstr ""
"カーネル 2.4.19 以降の Linux では、プロセス単位のマウント名前空間 (mount "
"namespace) が提供されている。マウント名前空間とは、 あるプロセスに見えている"
"ファイルシステムのマウントの集合である。 マウントポイントの名前空間は複数のプ"
"ロセスで共有することができ、 普通は共有されている。 一つのプロセスによる名前"
"空間の変更 (すなわち、マウントやアンマウント) は 同じ名前空間を共有する他の全"
"てのプロセスにも見える。 (2.4.19 より前の Linux は、一つの名前空間がシステム"
"上の全プロセスで 共有される状況とみなすことができる。)"

#. type: Plain text
#: build/C/man2/mount.2:896
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスは親プロセスのマウント名前空間を共有す"
"る。 B<execve>(2)  の前後でマウント名前空間は保持される。"

#. type: Plain text
#: build/C/man2/mount.2:916
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice versa."
msgstr ""
"プロセスは自分用 (private) のマウント名前空間を持つことができる。 自分用の名"
"前空間を持つことができるのは、 そのプロセスが B<clone>(2)  B<CLONE_NEWNS> フ"
"ラグを使って作成された場合と、 そのプロセスが B<CLONE_NEWNS> フラグ付きで "
"B<unshare>(2)  を呼び出した場合である。 前者の場合、作成されたプロセスの新し"
"い名前空間は B<clone>(2)  を呼び出したプロセスの名前空間の「コピー」で初期化"
"される。 後者の場合、 B<unshare>(2)  を呼び出すと、呼び出し元のプロセスのマウ"
"ント名前空間が、 それまでは他のプロセスと共有していた名前空間の自分用のコピー"
"となる。 これにより、呼び出し元のプロセスがこれ以後に行うマウント/アンマウン"
"トは 他のプロセスから見えなくなる (ただし、呼び出し元のプロセスが "
"B<unshare>(2)  の呼び出し以降に作成した子プロセスには見える)。 また、その逆"
"の、他のプロセスが行ったマウント/アンマウントも呼び出し元のプロセスには 見え"
"なくなる。"

#. type: Plain text
#: build/C/man2/mount.2:920
msgid "For further details on mount namespaces, see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:920
#, no-wrap
msgid "Parental relationship between mount points"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:924
msgid ""
"Each mount point has a parent mount point.  The overall parental "
"relationship of all mount points defines the single directory hierarchy seen "
"by the processes within a mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:932
msgid ""
"The parent of a new mount point is defined when the mount point is created.  "
"In the usual case, the parent of a new mount is the mount point of the "
"filesystem containing the directory or file at which the new mount is "
"attached.  In the case where a new mount is stacked on top of an existing "
"mount, the parent of the new mount is the previous mount that was stacked at "
"that location."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:937
msgid ""
"The parental relationship between mount points can be discovered via the I</"
"proc/[pid]/mountinfo> file (see below)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:937
#, no-wrap
msgid "/proc/[pid]/mounts and /proc/[pid]/mountinfo"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:952
msgid ""
"The Linux-specific I</proc/[pid]/mounts> file exposes the list of mount "
"points in the mount namespace of the process with the specified ID.  The I</"
"proc/[pid]/mountinfo> file exposes even more information about mount points, "
"including the propagation type and mount ID information that makes it "
"possible to discover the parental relationship between mount points.  See "
"B<proc>(5)  and B<mount_namespaces>(7)  for details of this file."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:964
msgid ""
"B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), "
"B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), "
"B<lsblk>(8), B<mount>(8), B<umount>(8)"
msgstr "B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), B<lsblk>(8), B<mount>(8), B<umount>(8)"

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr "PATH_RESOLUTION"

#. type: Plain text
#: build/C/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr "path_resolution - ファイルのパス名の解決方法"

#. type: Plain text
#: build/C/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr ""
"いくつかの UNIX/Linux システムコールは、 1 つ以上のファイル名を引数として持"
"つ。 ファイル名 (またはパス名) は以下のようにして解決される。"

#. type: SS
#: build/C/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr "ステップ 1: 解決過程を開始する"

#. type: Plain text
#: build/C/man7/path_resolution.7:43
#, fuzzy
#| msgid ""
#| "If the pathname starts with the \\(aq/\\(aq character, the starting "
#| "lookup directory is the root directory of the calling process.  (A "
#| "process inherits its root directory from its parent.  Usually this will "
#| "be the root directory of the file hierarchy.  A process may get a "
#| "different root directory by use of the B<chroot>(2)  system call.  A "
#| "process may get an entirely private mount namespace in case it\\(emor one "
#| "of its ancestors\\(emwas started by an invocation of the B<clone>(2)  "
#| "system call that had the B<CLONE_NEWNS> flag set.)  This handles the "
#| "\\(aq/\\(aq part of the pathname."
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  A process inherits "
"its root directory from its parent.  Usually this will be the root directory "
"of the file hierarchy.  A process may get a different root directory by use "
"of the B<chroot>(2)  system call, or may temporarily use a different root "
"directory by using B<openat2>(2)  with the B<RESOLVE_IN_ROOT> flag set."
msgstr ""
"パス名が \\(aq/\\(aq 文字で始まっている場合、 ディレクトリ検索の開始点は呼び"
"出し元のプロセスのルートディレクトリになる。 (プロセスはルートディレクトリを"
"親プロセスから継承する。 通常は、これがファイル階層のルートディレクトリにな"
"る。 プロセスは B<chroot>(2)  システムコールを使って別のルートディレクトリを"
"取得することもできる。 この場合、そのプロセスと B<CLONE_NEWNS> フラグを設定し"
"て B<clone>(2)  を呼び出すことによって開始されたそのプロセスの子孫は、 完全に"
"プライベートなマウント名前空間を取得できる。)  パス名の \\(aq/\\(aq の部分"
"は、このようにして扱われる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:51
msgid ""
"A process may get an entirely private mount namespace in case it\\(emor one "
"of its ancestors\\(emwas started by an invocation of the B<clone>(2)  system "
"call that had the B<CLONE_NEWNS> flag set.  This handles the \\(aq/\\(aq "
"part of the pathname."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:67
#, fuzzy
#| msgid ""
#| "If the pathname does not start with the \\(aq/\\(aq character, the "
#| "starting lookup directory of the resolution process is the current "
#| "working directory of the process.  (This is also inherited from the "
#| "parent.  It can be changed by use of the B<chdir>(2)  system call.)"
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process \\(em or in the case of B<openat>(2)-style system calls, the "
"I<dfd> argument (or the current working directory if B<AT_FDCWD> is passed "
"as the I<dfd> argument).  The current working directory is inherited from "
"the parent, and can be changed by use of the B<chdir>(2)  system call.)"
msgstr ""
"パス名が \\(aq/\\(aq 文字で始まっていない場合、 解決過程におけるディレクトリ"
"検索の開始点は、 プロセスの現在の作業 (working) ディレクトリとなる。 (これも"
"親プロセスから継承される。 これは B<chdir>(2)  システムコールを使うことで変更"
"できる。)"

#. type: Plain text
#: build/C/man7/path_resolution.7:70
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr ""
"\\(aq/\\(aq 文字で始まるパス名は絶対パス名と呼ばれ、 \\(aq/\\(aq 文字で始まら"
"ないパス名は相対パス名と呼ばれる。"

#. type: SS
#: build/C/man7/path_resolution.7:70
#, no-wrap
msgid "Step 2: walk along the path"
msgstr "ステップ 2: パスを辿る"

#. type: Plain text
#: build/C/man7/path_resolution.7:75
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for "
"each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr ""
"現在の検索ディレクトリをディレクトリ検索の開始点とする。 そして、パス名の最後"
"の構成要素 (component) でない各構成要素について、 現在の検索ディレクトリで検"
"索を行う。 ここで構成要素は \\(aq/\\(aq で区切られた部分文字列である。"

#. type: Plain text
#: build/C/man7/path_resolution.7:81
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr ""
"プロセスが現在の検索ディレクトリの検索許可を持たない場合、 B<EACCES> エラーが"
"返される (\"Permission denied\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:86
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr ""
"構成要素が見つからない場合、 B<ENOENT> エラーが返される (\"No such file or "
"directory\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:91
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr ""
"構成要素は見つかったが、ディレクトリでもシンボリックリンクでもない場合、 "
"B<ENOTDIR> エラーが返される (\"Not a directory\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:95
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr ""
"構成要素が見つかって、かつディレクトリである場合、 現在の検索ディレクトリをそ"
"のディレクトリに設定し、 次の構成要素に移動する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:118
#, fuzzy
#| msgid ""
#| "If the component is found and is a symbolic link (symlink), we first "
#| "resolve this symbolic link (with the current lookup directory as starting "
#| "lookup directory).  Upon error, that error is returned.  If the result is "
#| "not a directory, an B<ENOTDIR> error is returned.  If the resolution of "
#| "the symlink is successful and returns a directory, we set the current "
#| "lookup directory to that directory, and go to the next component.  Note "
#| "that the resolution process here involves recursion.  In order to protect "
#| "the kernel against stack overflow, and also to protect against denial of "
#| "service, there are limits on the maximum recursion depth, and on the "
#| "maximum number of symbolic links followed.  An B<ELOOP> error is returned "
#| "when the maximum is exceeded (\"Too many levels of symbolic links\")."
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve "
"this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symbolic link is successful and returns a directory, we set the current "
"lookup directory to that directory, and go to the next component.  Note that "
"the resolution process here can involve recursion if the prefix ('dirname') "
"component of a pathname contains a filename that is a symbolic link that "
"resolves to a directory (where the prefix component of that directory may "
"contain a symbolic link, and so on).  In order to protect the kernel against "
"stack overflow, and also to protect against denial of service, there are "
"limits on the maximum recursion depth, and on the maximum number of symbolic "
"links followed.  An B<ELOOP> error is returned when the maximum is exceeded "
"(\"Too many levels of symbolic links\")."
msgstr ""
"構成要素が見つかって、かつシンボリックリンク (symlink) である場合、 (現在の検"
"索ディレクトリをディレクトリ検索の開始点として)  最初にそのシンボリックリンク"
"を解決する。 結果がディレクトリでない場合、 B<ENOTDIR> エラーが返される。 シ"
"ンボリックリンクの解決が成功してディレクトリが返された場合、 そのディレクトリ"
"を現在の検索ディレクトリとして設定し、 次の構成要素に移動する。 解決過程に再"
"帰が含まれる点に注意すること。 カーネルをスタックオーバーフローや サービス拒"
"否 (denial of service) から守るため、 再帰の最大の深さとシンボリックリンクを"
"辿る最大回数に制限がある。 最大値を超えた場合 B<ELOOP> エラーが返される "
"(\"Too many levels of symbolic links\")。"

#
#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#.  MAXSYMLINKS is 40
#.  MAX_NESTED_LINKS
#.  commit 894bc8c4662ba9daceafe943a5ba0dd407da5cd3
#. type: Plain text
#: build/C/man7/path_resolution.7:136
msgid ""
"As currently implemented on Linux, the maximum number of symbolic links that "
"will be followed while resolving a pathname is 40.  In kernels before "
"2.6.18, the limit on the recursion depth was 5.  Starting with Linux 2.6.18, "
"this limit was raised to 8.  In Linux 4.2, the kernel's pathname-resolution "
"code was reworked to eliminate the use of recursion, so that the only limit "
"that remains is the maximum of 40 resolutions for the entire pathname."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:142
msgid ""
"The resolution of symbolic links during this stage can be blocked by using "
"B<openat2>(2), with the B<RESOLVE_NO_SYMLINKS> flag set."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:142
#, no-wrap
msgid "Step 3: find the final entry"
msgstr "ステップ 3: 最後のエントリーを見つける"

#. type: Plain text
#: build/C/man7/path_resolution.7:154
msgid ""
"The lookup of the final component of the pathname goes just like that of all "
"other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path "
"resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr ""
"パス名の最後の構成要素の検索は、前のステップで説明した 他の全ての構成要素と同"
"じように実行されるが、2 つの違いがある。 (i) 最後の構成要素はディレクトリであ"
"る必要がない (パス解決過程に関する限りはどちらでも構わない \\(em 特定のシステ"
"ムコールが要求するものによって、 ディレクトリでなければならない場合もある"
"し、 ディレクトリ以外でなければならない場合もある)。 (ii) 構成要素が見つから"
"ない場合にエラーにする必要はない \\(em その構成要素を作成するだけでよい場合も"
"ある。 最後のエントリーの詳細な扱いは、 特定のシステムコールの man ページで説"
"明されている。"

#. type: SS
#: build/C/man7/path_resolution.7:154
#, no-wrap
msgid ". and .."
msgstr ". と .."

#. type: Plain text
#: build/C/man7/path_resolution.7:158
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer "
"to the directory itself and to its parent directory, respectively."
msgstr ""
"慣習として、全てのディレクトリはエントリー \".\" と \"..\" を持つ。 これらは"
"それぞれ、そのディレクトリ自身とその親ディレクトリを参照する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:162
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical filesystem."
msgstr ""
"パス解決過程では、これらのエントリーが物理的なファイルシステムに 実際に存在す"
"るか否かに関わらず、慣習的な意味を持つと仮定する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:164
msgid "One cannot walk up past the root: \"/..\" is the same as \"/\"."
msgstr "ルートより上に辿ることはできない: \"/..\" は \"/\" と同じである。"

#. type: SS
#: build/C/man7/path_resolution.7:164
#, no-wrap
msgid "Mount points"
msgstr "マウント位置"

#. type: Plain text
#: build/C/man7/path_resolution.7:168
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root "
"of the filesystem hierarchy on the device \"dev\", and no longer to whatever "
"it referred to earlier."
msgstr ""
"\"mount dev path\" コマンドを実行した後、 パス名 \"path\" はデバイス \"dev\" "
"上のファイルシステム階層の ルートディレクトリを参照するようになり、以前の位置"
"を参照しない。"

#. type: Plain text
#: build/C/man7/path_resolution.7:172
msgid ""
"One can walk out of a mounted filesystem: \"path/..\" refers to the parent "
"directory of \"path\", outside of the filesystem hierarchy on \"dev\"."
msgstr ""
"マウントされたファイルシステムの外に出ることができる: \"path/..\" は \"dev\" "
"上のファイルシステム階層の外である \"path\" の親ディレクトリを参照する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:178
msgid ""
"Traversal of mount points can be blocked by using B<openat2>(2), with the "
"B<RESOLVE_NO_XDEV> flag set (though note that this also restricts bind mount "
"traversal)."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:178
#, no-wrap
msgid "Trailing slashes"
msgstr "末尾のスラッシュ"

#. type: Plain text
#: build/C/man7/path_resolution.7:184
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding "
"component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise, a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname "
"with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr ""
"パス名が \\(aq/\\(aq で終わっている場合、 ステップ 2 において、その前にある構"
"成要素の解決法を次のように強制する: その構成要素が存在しなければならず、ディ"
"レクトリとして解決される。 存在しない場合は、末尾の \\(aq/\\(aq が無視され"
"る。 (また同様に、末尾に \\(aq/\\(aq があるパス名は、 \\(aq.\\(aq を末尾に加"
"えて得られるパス名と等しい。)"

#. type: SS
#: build/C/man7/path_resolution.7:184
#, no-wrap
msgid "Final symlink"
msgstr "最後がシンボリックリンクのとき"

#. type: Plain text
#: build/C/man7/path_resolution.7:193
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call "
"B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the "
"file pointed to by the symlink."
msgstr ""
"パス名の最後の構成要素がシンボリックリンクである場合、 参照されるファイルをシ"
"ンボリックリンクとするか、 その内容についてパスを解決した結果とするかは、 シ"
"ステムコールに依存する。 たとえば、システムコール B<lstat>(2)  はシンボリック"
"リンクに作用する。 一方、 B<stat>(2)  はシンボリックリンクで指されたファイル"
"に作用する。"

#. type: SS
#: build/C/man7/path_resolution.7:193
#, no-wrap
msgid "Length limit"
msgstr "長さの制限"

#. type: Plain text
#: build/C/man7/path_resolution.7:200
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long, "
"an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr ""
"パス名には最大長がある。 パス名 (またはシンボリックリンクを解決するときに得ら"
"れる中間パス名) が 長すぎる場合、 B<ENAMETOOLONG> エラーが返される "
"(\"Filename too long\")。"

#. type: SS
#: build/C/man7/path_resolution.7:200
#, no-wrap
msgid "Empty pathname"
msgstr "空のパス名"

#. type: Plain text
#: build/C/man7/path_resolution.7:207
msgid ""
"In the original UNIX, the empty pathname referred to the current directory.  "
"Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr ""
"元々の UNIX では、空のパス名は現在のディレクトリを参照していた。 最近、POSIX "
"では空のパス名を解決するべきではないという決定がなされた。 この場合、Linux "
"は B<ENOENT> を返す。"

#. type: SS
#: build/C/man7/path_resolution.7:207
#, no-wrap
msgid "Permissions"
msgstr "許可"

#. type: Plain text
#: build/C/man7/path_resolution.7:220
#, fuzzy
#| msgid ""
#| "The permission bits of a file consist of three groups of three bits, cf."
#| "\\& B<chmod>(1)  and B<stat>(2).  The first group of three is used when "
#| "the effective user ID of the calling process equals the owner ID of the "
#| "file.  The second group of three is used when the group ID of the file "
#| "either equals the effective group ID of the calling process, or is one of "
#| "the supplementary group IDs of the calling process (as set by "
#| "B<setgroups>(2)).  When neither holds, the third group is used."
msgid ""
"The permission bits of a file consist of three groups of three bits; see "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2)).  "
"When neither holds, the third group is used."
msgstr ""
"ファイルの許可ビットは、3 組の 3 ビットから構成される。 B<chmod>(1)  と "
"B<stat>(2)  を参照すること。 呼び出し元のプロセスの実効ユーザー ID がファイル"
"の所有者 ID と等しい場合、 3 つのうち最初のグループが使われる。 ファイルのグ"
"ループ ID が呼び出し元のプロセスの実効グループ ID または (B<setgroups>(2)  で"
"設定される) 呼び出し元のプロセスの補助 (supplementary) グループ ID と 等しい"
"場合、3 つのうち 2 番目のグループが使われる。 どちらにも当てはまらない場合、"
"3 番目のグループが使われる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:224
msgid ""
"Of the three bits used, the first bit determines read permission, the second "
"write permission, and the last execute permission in case of ordinary files, "
"or search permission in case of directories."
msgstr ""
"3 ビットが使われる場合、最初のビットは読み込み許可を決定し、 2 番目のビットは"
"書き込み許可を決定する。 また 3 番目のビットは、通常のファイルの場合は実行許"
"可を表し、 ディレクトリの場合は検索許可を表す。"

#. type: Plain text
#: build/C/man7/path_resolution.7:229
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks.  "
"Ordinarily the fsuid will equal the effective user ID, but the fsuid can be "
"changed by the system call B<setfsuid>(2)."
msgstr ""
"Linux は、許可のチェックにおいて、実効ユーザー ID ではなく fsuid を使う。 通"
"常は fsuid は実効ユーザー ID と等しいが、fsuid はシステムコール "
"B<setfsuid>(2)  で変更することができる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:237
msgid ""
"(Here \"fsuid\" stands for something like \"filesystem user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective "
"user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""
"(ここで \"fsuid\" は \"file system user ID\" を表している。 この概念は「プロ"
"セスが同じ実効ユーザー ID を持つプロセスに 同時にシグナルを送ることができる」"
"というユーザー空間 NFS サーバを 実装する際に必要であった。 これは今では廃れて"
"しまった。 B<setfsuid>(2)  を使うべきではない。"

#.  FIXME . say something about filesystem mounted read-only ?
#. type: Plain text
#: build/C/man7/path_resolution.7:243
msgid ""
"Similarly, Linux uses the fsgid (\"filesystem group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""
"同様に、Linux では実効グループ ID の代わりに fsgid (\"ファイルシステムグルー"
"プID\") を使う。 B<setfsgid>(2)  を参照すること。"

#. type: SS
#: build/C/man7/path_resolution.7:243
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr "許可の確認をスキップする: スーパーユーザーとケーパビリティ"

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: build/C/man7/path_resolution.7:254
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is all-"
"powerful, and bypasses all permissions restrictions when accessing files."
msgstr ""
"伝統的な UNIX システムでは、スーパーユーザー (I<root>, ユーザー ID 0) は非常"
"に強力であり、ファイルアクセス時の 許可による制限を全てスキップする。"

#. type: Plain text
#: build/C/man7/path_resolution.7:262
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""
"Linux では、スーパーユーザー権限が複数のケーパビリティに分割されている "
"(B<capabilities>(7)  参照)。ファイルの許可の確認には、 B<CAP_DAC_OVERRIDE> "
"と B<CAP_DAC_READ_SEARCH> の 2つのケーパビリティが関係する (プロセスの fsuid "
"が 0 の場合、そのプロセスはこれらのケーパビリティを持つ)。"

#. type: Plain text
#: build/C/man7/path_resolution.7:268
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute "
"permission bits is set."
msgstr ""
"B<CAP_DAC_OVERRIDE> ケーパビリティは全ての許可チェックを上書きする。 実際に"
"は、対象となるファイルの 3 つの実行許可ビットのうちの 少なくとも 1 つが設定さ"
"れている場合のみ、実行を許可する。"

#.  FIXME . say something about immutable files
#.  FIXME . say something about ACLs
#. type: Plain text
#: build/C/man7/path_resolution.7:275
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""
"B<CAP_DAC_READ_SEARCH> ケーパビリティは、ディレクトリに対して読み込みと検索を"
"許可し、 通常のファイルに対して読み込みを許可する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:280
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr "REMOVEXATTR"

#. type: Plain text
#: build/C/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr "removexattr, lremovexattr, fremovexattr - 拡張属性を削除する"

#. type: Plain text
#: build/C/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""
"B<removexattr>()  は、ファイルシステム内の指定された I<path> に対応する、名"
"前 I<name> の拡張属性を削除する。"

#. type: Plain text
#: build/C/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""
"B<lremovexattr>()  は B<removexattr>()  と同じだが、シンボリックリンクの場合"
"に、リンクが参照しているファイル ではなく、リンクそのものの情報を削除する点だ"
"けが異なる。"

#. type: Plain text
#: build/C/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""
"B<fremovexattr>()  は B<removexattr>()  と同じだが、 I<path> の代わりに "
"I<fd> で参照されたオープン済みファイルから拡張属性を削除するだけである点が異"
"なる (I<fd> は B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/removexattr.2:78
#, fuzzy
#| msgid ""
#| "An extended attribute name is a simple null-terminated string.  The "
#| "I<name> includes a namespace prefix; there may be several, disjoint "
#| "namespaces associated with an individual inode."
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"拡張属性の名前は、普通のヌル終端された文字列である。 I<name> には、名前空間を"
"表す接頭辞 (prefix) が含まれる。 個々の inode に対し、互いに独立な名前空間が"
"複数あってもよい。"

#. type: Plain text
#: build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:114
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"成功した場合、0 が返される。 失敗した場合、 -1 が返され、 I<errno> に適切な値"
"がセットされる。"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/removexattr.2:92
msgid "The named attribute does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:120
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr "SETXATTR"

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr "setxattr, lsetxattr, fsetxattr - 拡張属性の値を設定する"

#. type: Plain text
#: build/C/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/setxattr.2:67
#, fuzzy
#| msgid ""
#| "B<setxattr>()  sets the I<value> of the extended attribute identified by "
#| "I<name> and associated with the given I<path> in the filesystem.  The "
#| "I<size> of the I<value> must be specified."
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> argument specifies the size (in bytes) of I<value>; a zero-length "
"value is permitted."
msgstr ""
"B<setxattr>()  は、ファイルシステム内の指定された I<path> に対応する、名前 "
"I<name> の拡張属性の値 I<value> を設定する。 I<value> の I<size> は必ず指定し"
"なければならない。"

#. type: Plain text
#: build/C/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""
"B<lsetxattr>()  は B<setxattr>()  と同じだが、シンボリックリンクの場合に、リ"
"ンクが参照しているファイル ではなく、リンクそのものの拡張属性を設定する点だけ"
"が異なる。"

#. type: Plain text
#: build/C/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""
"B<fsetxattr>()  は B<setxattr>()  と同じだが、 I<path> の代わりに I<fd> で参"
"照されたオープン済みファイルの情報だけを設定する点が異なる (I<filedes> は "
"B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/setxattr.2:93
#, fuzzy
#| msgid ""
#| "An extended attribute name is a simple null-terminated string.  The "
#| "I<name> includes a namespace prefix; there may be several, disjoint "
#| "namespaces associated with an individual inode.  The I<value> of an "
#| "extended attribute is a chunk of arbitrary textual or binary data of "
#| "specified length."
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""
"拡張属性の名前 は普通のヌル終端された文字列である。 I<name> には、名前空間を"
"表す接頭辞 (prefix) が含まれる。 個々の inode に対して、互いに独立な名前空間"
"が複数あってもよい。 拡張属性の値 I<value> は、ある一定の長さの任意のテキスト"
"データまたは バイナリデータの集合である。"

#. type: Plain text
#: build/C/man2/setxattr.2:102
msgid ""
"By default (i.e., I<flags> is zero), the extended attribute will be created "
"if it does not exist, or the value will be replaced if the attribute already "
"exists.  To modify these semantics, one of the following values can be "
"specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:102
#, no-wrap
msgid "B<XATTR_CREATE>"
msgstr "B<XATTR_CREATE>"

#. type: Plain text
#: build/C/man2/setxattr.2:105
msgid ""
"Perform a pure create, which fails if the named attribute exists already."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:105
#, no-wrap
msgid "B<XATTR_REPLACE>"
msgstr "B<XATTR_REPLACE>"

#. type: Plain text
#: build/C/man2/setxattr.2:109
msgid ""
"Perform a pure replace operation, which fails if the named attribute does "
"not already exist."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:115
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/setxattr.2:119
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""
"ディスクのクォータ上限に達した。拡張属性を格納できるだけの空き領域がないこと"
"を意味する。"

#. type: TP
#: build/C/man2/setxattr.2:119 build/C/man2/spu_create.2:185
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/setxattr.2:123
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr "B<XATTR_CREATE> が指定されたが、その属性はすでに存在している。"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/setxattr.2:132
#, fuzzy
#| msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgid "B<XATTR_REPLACE> was specified, and the attribute does not exist."
msgstr "B<XATTR_CREATE> が指定されたが、その属性はすでに存在している。"

#. type: TP
#: build/C/man2/setxattr.2:132 build/C/man2/spu_create.2:225
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/setxattr.2:135
msgid "There is insufficient space remaining to store the extended attribute."
msgstr "拡張属性を記憶するのに十分なスペースが残っていない。"

#. type: Plain text
#: build/C/man2/setxattr.2:140
#, fuzzy
#| msgid "A component of the path prefix of I<pathname> is not a directory."
msgid "The namespace prefix of I<name> is not valid."
msgstr "I<pathname> の前半部分 (prefix) の構成要素がディレクトリではない。"

#. type: Plain text
#: build/C/man2/setxattr.2:143
#, fuzzy
#| msgid ""
#| "Extended attributes are not supported by the filesystem, or are disabled."
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled,"
msgstr ""
"拡張属性がそのファイルシステムでサポートされていない、 もしくは無効になってい"
"る。"

#. type: Plain text
#: build/C/man2/setxattr.2:148
msgid "The file is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:159
msgid "The size of I<name> or I<value> exceeds a filesystem-specific limit."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:180
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: build/C/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr "SPU_CREATE"

#. type: Plain text
#: build/C/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr "spu_create - 新しい SPU コンテキストを生成する"

#. type: Plain text
#: build/C/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/spu_create.2:35
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"

#. type: Plain text
#: build/C/man2/spu_create.2:39 build/C/man2/spu_run.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/spu_create.2:58
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""
"B<spu_create>() システムコールは、Cell Broadband Engine アーキテクチャーを実"
"装した PowerPC マシンにおいて、Synergistic Processor Unit (SPU) にアクセスす"
"るために使用される。 このシステムコールは、 SPU に対する新しい論理コンテキス"
"トを I<pathname> に生成し、 そのコンテキストに関連付けられたファイルディスク"
"リプターを返す。 I<pathname> は SPU ファイルシステム (B<spufs>) のマウントポ"
"イント内の存在しないディレクトリを指していなければならない。 B<spu_create>() "
"が成功すると、 I<pathname> にディレクトリが生成され、 そのディレクトリに "
"B<spufs>(7) で説明されているファイル群が配置される。"

#. type: Plain text
#: build/C/man2/spu_create.2:77
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""
"コンテキストを作成した際、返されたファイルディスクリプターは、 B<spu_run>(2) "
"に渡すか、 B<*at> 系のシステムコール (B<openat>(2) など) の I<dirfd> 引数と"
"して使用するか、 クローズするか、しかできない。 他の操作は定義されていない。 "
"そのコンテキストへの最後の参照がなくなった際に、 論理 SPU コンテキストは破棄"
"される (そのコンテキストの I<pathname> ディレクトリに作成されたファイルもすべ"
"て破棄される)。 通常は B<spu_create>() が返したファイルディスクリプターがク"
"ローズされた際に発生する。"

#. type: Plain text
#: build/C/man2/spu_create.2:89
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""
"I<mode> 引数 (からプロセスの B<umask>(2) でセットされたビットを除いたもの) "
"により、 B<spufs> に作られる新しいディレクトリで使用されるアクセス許可が決ま"
"る。 利用できる I<mode> 値の完全なリストについては B<stat>(2) を参照。"

#. type: Plain text
#: build/C/man2/spu_create.2:95
msgid ""
"The I<neighbor_fd> is used only when the B<SPU_CREATE_AFFINITY_SPU> flag is "
"specified; see below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:100
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""
"I<flags> 引数には 0 か以下の定数の組み合わせ (ビット単位の論理和) を指定で"
"きる。"

#. type: TP
#: build/C/man2/spu_create.2:100
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr "B<SPU_CREATE_EVENTS_ENABLED>"

#. type: Plain text
#: build/C/man2/spu_create.2:106
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""
"DMA エラーを通知するのにシグナルを使うのではなく、 B<spu_run>(2) の I<event> "
"引数を使用する。"

#. type: TP
#: build/C/man2/spu_create.2:106
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr "B<SPU_CREATE_GANG>"

#. type: Plain text
#: build/C/man2/spu_create.2:114
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""
"コンテキストの代わりに SPU gang を作成する。 (gang は、機能的に互いに関係して"
"いて、スケジューリングパラメーター (優先度とポリシー) を共有する SPU コンテキ"
"ストのグループである。 将来、 グループ全体が一つの単位としてスイッチイン/ス"
"イッチアウトされる gang スケジューリングが実装されるかもしれない。)"

#. type: Plain text
#: build/C/man2/spu_create.2:121
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr ""
"I<pathname> 引数で指定された場所に新しいディレクトリが作成される。 この "
"gang を使って他の SPU コンテキストを保持することができる。 それには、それ以降"
"の B<spu_create>() に gang ディレクトリ内のパス名を渡す。"

#. type: TP
#: build/C/man2/spu_create.2:121
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr "B<SPU_CREATE_NOSCHED>"

#. type: Plain text
#: build/C/man2/spu_create.2:127
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""
"SPU スケジューラーの影響を受けないコンテキストを作成する。 一度実行される"
"と、 呼び出したプロセスが破棄されるまでこのコンテキストがスケジューリングで追"
"い出されることはない。"

#. type: Plain text
#: build/C/man2/spu_create.2:138
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""
"このコンテキストは SPU から削除されることはないので、 B<SPU_CREATE_NOSCHED> "
"コンテキストではいくつかの機能は無効にされる。 B<spufs> のこのコンテキストの"
"ディレクトリでは一部のファイルだけができる。 また、 B<SPU_CREATE_NOSCHED> コ"
"ンテキストはクラッシュした際にコアファイルをダンプできない。"

#. type: Plain text
#: build/C/man2/spu_create.2:144
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""
"B<SPU_CREATE_NOSCHED> コンテキストを作成するには B<CAP_SYS_NICE> ケーパビリ"
"ティが必要である。"

#. type: TP
#: build/C/man2/spu_create.2:144
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr "B<SPU_CREATE_ISOLATE>"

#. type: Plain text
#: build/C/man2/spu_create.2:151
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""
"隔離された SPU コンテキストを作成する。 隔離されたコンテキストはいくつかの "
"PPE (PowerPC Processing Element) 命令から保護される。 SPU ローカルストアや "
"NPC レジスターへのアクセスなどである。"

#. type: Plain text
#: build/C/man2/spu_create.2:157
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""
"B<SPU_CREATE_ISOLATE> コンテキストを作成するには B<SPU_CREATE_NOSCHED> フラグ"
"も指定する必要がある。"

#. type: TP
#: build/C/man2/spu_create.2:157
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU> (since Linux 2.6.23)"
msgstr "B<SPU_CREATE_AFFINITY_SPU> (Linux 2.6.23 以降)"

#.  commit 8e68e2f248332a9c3fd4f08258f488c209bd3e0c
#. type: Plain text
#: build/C/man2/spu_create.2:166
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""
"別の SPU コンテキストと affinity (親和性) を持ったコンテキストを作成する。 こ"
"の affinity 情報は SPU スケジューリングアルゴリズムで使用される。 このフラグ"
"を使う際には、 他の SPU コンテキストを指すファイルディスクリプターを "
"I<neighbor_fd> 引数を渡す必要がある。"

#. type: TP
#: build/C/man2/spu_create.2:166
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM> (since Linux 2.6.23)"
msgstr "B<SPU_CREATE_AFFINITY_MEM> (Linux 2.6.23 以降)"

#.  commit 8e68e2f248332a9c3fd4f08258f488c209bd3e0c
#. type: Plain text
#: build/C/man2/spu_create.2:172
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""
"システムメモリーと affinity (親和性) を持ったコンテキストを作成する。 この "
"affinity 情報は SPU スケジューリングアルゴリズムで使用される。"

#. type: Plain text
#: build/C/man2/spu_create.2:179
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""
"成功すると、 B<spu_create>() は新しいファイルディスクリプターを返す。 エラー"
"の場合、-1 を返し、 I<errno> に以下のリストに記載のエラーコードのいずれかを設"
"定する。"

#. type: Plain text
#: build/C/man2/spu_create.2:185
msgid ""
"The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""
"現在のユーザーが B<spufs>(7) のマウントポイントへの書き込み許可を持って\n"
"いない。"

#. type: Plain text
#: build/C/man2/spu_create.2:188
msgid "An SPU context already exists at the given pathname."
msgstr "指定されたパス名で SPU コンテキストがすでに生成されている。"

#. type: Plain text
#: build/C/man2/spu_create.2:193
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""
"I<pathname> が呼び出し元のプロセスのアドレス空間で有効な文字列ポインターでは"
"ない。"

#. type: Plain text
#: build/C/man2/spu_create.2:199
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""
"I<pathname> が SPUFS マウントポイント内のディレクトリではない。 または、無効"
"なフラグが指定された。"

#. type: Plain text
#: build/C/man2/spu_create.2:203
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr "I<pathname> を解決するまでに辿ったシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/spu_create.2:206
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:210 build/C/man2/stat.2:401
#: build/C/man2/statx.2:537
msgid "I<pathname> is too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/spu_create.2:210
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/spu_create.2:213
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:217
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""
"隔離されたコンテキストが要求されたが、 ハードウェアが SPU アイソレーションを"
"サポートしていない。"

#. type: Plain text
#: build/C/man2/spu_create.2:222
msgid "Part of I<pathname> could not be resolved."
msgstr "I<pathname> の一部が解決できなかった。"

#. type: Plain text
#: build/C/man2/spu_create.2:225
msgid "The kernel could not allocate all resources required."
msgstr "カーネルが必要なリソースの全てを割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/spu_create.2:230
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""
"新しいコンテキストを生成するのに十分な SPU リソースがなかった、 または SPU コ"
"ンテキスト数がそのユーザーの特定の上限に達していた。"

#. type: TP
#: build/C/man2/spu_create.2:230 build/C/man2/spu_run.2:185
#: build/C/man2/statfs.2:274 build/C/man3/statvfs.3:178 build/C/man2/ustat.2:86
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/spu_create.2:235 build/C/man2/spu_run.2:190
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""
"機能が動作中のシステムで提供されていない。理由は、 ハードウェアで SPU が提供"
"されていないか、 spufs モジュールがロードされていないか、のどちらかである。"

#. type: Plain text
#: build/C/man2/spu_create.2:240
msgid "A part of I<pathname> is not a directory."
msgstr "I<pathname> の一部がディレクトリではない。"

#. type: Plain text
#: build/C/man2/spu_create.2:247
msgid ""
"The B<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr "B<SPU_CREATE_NOSCHED> フラグが指定されたが、ユーザーが B<CAP_SYS_NICE> ケーパビリティを持っていない。"

#. type: Plain text
#: build/C/man2/spu_create.2:253
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""
"I<pathname> は B<spufs> のマウントポイントの配下の場所を指して\n"
"いなければならない。 慣例では I</spu> にマウントされる。"

#. type: Plain text
#: build/C/man2/spu_create.2:257
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""
"B<spu_create>() システムコールはカーネル 2.6.16 で Linux に追加された。"

#. type: Plain text
#: build/C/man2/spu_create.2:261
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"このシステムコールは Linux 固有であり、 PowerPC アーキテクチャーでのみ実装さ"
"れている。 このシステムコールを使ったプログラムは移植性がない。"

#. type: Plain text
#: build/C/man2/spu_create.2:272
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使うこと。ただし、 B<spu_create>()  は より抽象度の高い SPU "
"へのインターフェースを実装するライブラリから 利用されることを意図したものであ"
"り、通常のアプリケーションから 使用は意図されていない。推奨のライブラリについ"
"ては E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> "
"E<.UE> を参照のこと。"

#. type: Plain text
#: build/C/man2/spu_create.2:280
msgid ""
"Prior to the addition of the B<SPU_CREATE_AFFINITY_SPU> flag in Linux "
"2.6.23, the B<spu_create>()  system call took only three arguments (i.e., "
"there was no I<neighbor_fd> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:285
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr "B<spu_create>() の利用例については B<spu_run>(2) を参照。"

#. type: Plain text
#: build/C/man2/spu_create.2:290
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: build/C/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr "SPU_RUN"

#. type: TH
#: build/C/man2/spu_run.2:26 build/C/man4/loop.4:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr "spu_run - SPU コンテキストを実行する"

#. type: Plain text
#: build/C/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr "B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:35
#, no-wrap
msgid "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"
msgstr "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""
"B<spu_run>()  システムコールは、Cell Broadband Engine アーキテクチャーを実装"
"した PowerPC マシンで Synergistic Processor Units (SPU) にアクセスするために "
"使用される。 I<fd> 引数は、 B<spu_create>(2)  が返すファイルディスクリプ"
"ターで、 特定の SPU コンテキストを参照する。 そのコンテキストが物理 SPU に割"
"り当てられると、 I<npc> で渡された命令ポインター (instruction pointer) から実"
"行が開始される。"

#. type: Plain text
#: build/C/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using B<pthread_create>(3))."
msgstr ""
"SPU コードの実行は同期的 (synchronously) に行われる、つまり SPU が実行中は "
"B<spu_run>()  は停止 (block) する。 SPU コードの実行をメイン CPU や他の SPU "
"と並行して行う必要がある場合は、 最初に、その SPU コードを実行する新しいス"
"レッドを、(例えば B<pthread_create>(3)  などを使って) 生成しなければならな"
"い。"

#. type: Plain text
#: build/C/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""
"B<spu_run>()  が返るときには、SPU のプログラムカウンターの現在値が I<npc> に"
"書き込まれる。 これにより、連続する B<spu_run>()  の呼び出しで同じ I<npc> ポ"
"インターを使うことができる。"

#. type: Plain text
#: build/C/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""
"I<event> 引数には、拡張ステータスコード用のバッファーを指定する。 "
"B<SPU_CREATE_EVENTS_ENABLED> フラグ付きで SPU コンテキストが作成されると、 "
"B<spu_run>()  が返る前に Linux カーネルによりこのバッファーに 拡張ステータス"
"コードが格納される。"

#. type: Plain text
#: build/C/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr "ステータスコードには以下の定数が一つ以上入る。"

#. type: TP
#: build/C/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr "B<SPE_EVENT_DMA_ALIGNMENT>"

#. type: Plain text
#: build/C/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr "DMA (direct memory access) のアライメントエラーが発生した。"

#. type: TP
#: build/C/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr "B<SPE_EVENT_INVALID_DMA>"

#.  SPE_EVENT_SPE_DATA_SEGMENT is defined, but does not seem to be generated
#.  at any point (in Linux 5.9 sources).
#. type: Plain text
#: build/C/man2/spu_run.2:92
msgid "An invalid MFC DMA command was attempted."
msgstr "無効な MFC (Memory Flow Controller) DMA コマンドを行おうとした。"

#. type: TP
#: build/C/man2/spu_run.2:92
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr "B<SPE_EVENT_SPE_DATA_STORAGE>"

#. type: Plain text
#: build/C/man2/spu_run.2:95
msgid "A DMA storage error occurred."
msgstr "DMA ストレージエラーが発生した。"

#. type: TP
#: build/C/man2/spu_run.2:95
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr "B<SPE_EVENT_SPE_ERROR>"

#. type: Plain text
#: build/C/man2/spu_run.2:98
msgid "An illegal instruction was executed."
msgstr "不正な命令が実行された。"

#. type: Plain text
#: build/C/man2/spu_run.2:104
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""
"NULL は I<event> 引数として有効な値である。 この場合、イベントは呼び出し元"
"のプロセスに報告されない。"

#. type: Plain text
#: build/C/man2/spu_run.2:113
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""
"成功すると、 B<spu_run>()  は I<spu_status> レジスターの値を返す。 エラーの場"
"合、-1 を返し、 I<errno> を下記のエラーコードのいずれかに設定する。"

#. type: Plain text
#: build/C/man2/spu_run.2:122
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""
"I<spu_status> レジスターの値は、ステータスコードと SPU の B<stop-and-signal> "
"命令が返す 14 ビットのコードの ビットマスクで構成される。 後者の 14 ビットの"
"コードはオプションである。 ステータスコードのビットマスクは下記の通りである。"

#. type: TP
#: build/C/man2/spu_run.2:122
#, no-wrap
msgid "B<0x02>"
msgstr "B<0x02>"

#. type: Plain text
#: build/C/man2/spu_run.2:127
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr "SPU が B<stop-and-signal> 命令で停止した。"

#. type: TP
#: build/C/man2/spu_run.2:127
#, no-wrap
msgid "B<0x04>"
msgstr "B<0x04>"

#. type: Plain text
#: build/C/man2/spu_run.2:132
msgid "SPU was stopped by a B<halt> instruction."
msgstr "SPU が B<halt (停止)> 命令で止まった。"

#. type: TP
#: build/C/man2/spu_run.2:132
#, no-wrap
msgid "B<0x08>"
msgstr "B<0x08>"

#. type: Plain text
#: build/C/man2/spu_run.2:135
msgid "SPU is waiting for a channel."
msgstr "SPU はチャンネルのウェイト中である。"

#. type: TP
#: build/C/man2/spu_run.2:135
#, no-wrap
msgid "B<0x10>"
msgstr "B<0x10>"

#. type: Plain text
#: build/C/man2/spu_run.2:138
msgid "SPU is in single-step mode."
msgstr "SPU はシングルステップモードであった。"

#. type: TP
#: build/C/man2/spu_run.2:138
#, no-wrap
msgid "B<0x20>"
msgstr "B<0x20>"

#. type: Plain text
#: build/C/man2/spu_run.2:141
msgid "SPU has tried to execute an invalid instruction."
msgstr "SPU が不正な命令を実行しようとした。"

#. type: TP
#: build/C/man2/spu_run.2:141
#, no-wrap
msgid "B<0x40>"
msgstr "B<0x40>"

#. type: Plain text
#: build/C/man2/spu_run.2:144
msgid "SPU has tried to access an invalid channel."
msgstr "SPU が不正なチャンネルにアクセスしようとした。"

#. type: TP
#: build/C/man2/spu_run.2:144
#, no-wrap
msgid "B<0x3fff0000>"
msgstr "B<0x3fff0000>"

#. type: Plain text
#: build/C/man2/spu_run.2:150
msgid ""
"The bits masked with this value contain the code returned from a B<stop-and-"
"signal> instruction.  These bits are valid only if the 0x02 bit is set."
msgstr ""
"この値のマスクを適用して得られたビット値には、 stop-and-signal 命令から返され"
"たコードが入っている。 これらのビットは 0x02 ビットがセットされている場合にの"
"み有効である。"

#. type: Plain text
#: build/C/man2/spu_run.2:155
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""
"B<spu_run>()  がエラーを返さなかった場合、下位 8 ビットのうち 1 つ以上は 常に"
"セットされる。"

#. type: TP
#: build/C/man2/spu_run.2:156 build/C/man2/stat.2:387 build/C/man2/stat.2:443
#: build/C/man2/statfs.2:237 build/C/man2/statx.2:508
#: build/C/man3/statvfs.3:141
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/spu_run.2:160
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/spu_run.2:166
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""
"I<npc> が有効なポインターでない。または I<event> が NULL 以外で、しかも無効な"
"ポインターである。"

#. type: TP
#: build/C/man2/spu_run.2:166 build/C/man2/statfs.2:248
#: build/C/man3/statvfs.3:152
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/spu_run.2:176
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""
"B<spu_run>()  の実行中にシグナルが発生した。 B<signal>(7)  参照。 必要であれ"
"ば、 I<npc> の値は新しいプログラムカウンターの値に更新される。"

#. type: Plain text
#: build/C/man2/spu_run.2:181
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""
"I<fd> が B<spu_create>(2)  が返した有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/spu_run.2:185
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""
"Memory Flow Controller (MFC) DMA により発生したページフォールトを 処理するの"
"に必要なメモリーがなかった。"

#. type: Plain text
#: build/C/man2/spu_run.2:194
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr "B<spu_run>()  システムコールはカーネル 2.6.16 で Linux に追加された。"

#. type: Plain text
#: build/C/man2/spu_run.2:198
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"このシステムコールは Linux 固有であり、 PowerPC アーキテクチャーでのみ実装さ"
"れている。 このシステムコールを使ったプログラムは移植性がない。"

#. type: Plain text
#: build/C/man2/spu_run.2:209
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使うこと。ただし、 B<spu_run>()  は より抽象度の高い SPU へ"
"のインターフェースを実装するライブラリから 利用されることを意図したものであ"
"り、通常のアプリケーションから 使用は意図されていない。推奨のライブラリについ"
"ては E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> "
"E<.UE> を参照のこと。"

#. type: Plain text
#: build/C/man2/spu_run.2:214
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""
"以下は、簡単な 1 命令の SPU プログラムを B<spu_run>()  システムコールを使って"
"実行させる例である。"

#. type: Plain text
#: build/C/man2/spu_run.2:222
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:225
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/spu_run.2:230
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:234
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"

#. type: Plain text
#: build/C/man2/spu_run.2:239
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:244
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"

#. type: Plain text
#: build/C/man2/spu_run.2:250
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:254
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#: build/C/man2/spu_run.2:260
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: %#08x\\en\", spu_status);\n"
msgstr ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: %#08x\\en\", spu_status);\n"

#. type: Plain text
#: build/C/man2/spu_run.2:271
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr "SPUFS"

#. type: Plain text
#: build/C/man7/spufs.7:30
msgid "spufs - SPU filesystem"
msgstr "spufs - SPU ファイルシステム"

#. type: Plain text
#: build/C/man7/spufs.7:34
msgid ""
"The SPU filesystem is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units "
"(SPUs)."
msgstr ""
"SPU ファイルシステムは、Cell Broadband Engine アーキテクチャーを実装した "
"PowerPC マシンにおいて、Synergistic Processor Unit (SPU) にアクセスする ため"
"に使用される。"

#. type: Plain text
#: build/C/man7/spufs.7:43
msgid ""
"The filesystem provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the filesystem can use "
"B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""
"このファイルシステムでは、POSIX 共有メモリーやメッセージキューに似た名前\n"
"空間が提供される。 ファイルシステムに書き込み許可を持つユーザーは\n"
"B<spu_create>(2) を使って B<spufs> のルートディレクトリに SPU コンテキ\n"
"ストを作成できる。"

#. type: Plain text
#: build/C/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical "
"SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""
"各 SPU コンテキストは、あらかじめ定義されたファイル群を含むディレクトリ\n"
"として表現される。 これらのファイルを使って、論理 SPU の状態を操作でき\n"
"る。ユーザーはこれらのファイルのアクセス許可を変更することはできるが、\n"
"ファイルの追加・削除を行うことはできない。"

#. type: SS
#: build/C/man7/spufs.7:50 build/C/man5/tmpfs.5:66
#, no-wrap
msgid "Mount options"
msgstr "マウントオプション"

#. type: TP
#: build/C/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr "B<uid=E<lt>uidE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""
"マウントポイントを所有するユーザーを設定する。 デフォルトは 0 (root) である。"

#. type: TP
#: build/C/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr "B<gid=E<lt>gidE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr ""
"マウントポイントを所有するグループを設定する。 デフォルトは 0 (root) である。"

#. type: TP
#: build/C/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr "B<mode=E<lt>modeE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr "Files"

#. type: Plain text
#: build/C/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system "
"calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular filesystems.  This list details the "
"supported operations and the deviations from the standard behavior described "
"in the respective man pages."
msgstr ""
"B<spufs> のファイルは、ほとんどの場合 B<read>(2) や B<write>(2) と\n"
"いった通常のシステムコールに対する標準的な振る舞いを示すが、多くの場合\n"
"通常のファイルシステムでサポートされている操作の一部分だけがサポート\n"
"されている。以下のリストでは、サポートされている操作とそれぞれのマニュ\n"
"アルページに書かれている標準的な振る舞いとの違いについて説明する。"

#. type: Plain text
#: build/C/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support "
"B<writev>(2).  All files support the B<access>(2)  and B<stat>(2)  family of "
"operations, but for the latter call, the only fields of the returned I<stat> "
"structure that contain reliable information are I<st_mode>, I<st_nlink>, "
"I<st_uid>, and I<st_gid>."
msgstr ""
"B<read>(2) 操作をサポートしている全てのファイルは B<readv>(2) を\n"
"サポートしており、B<write>(2) 操作をサポートしている全てのファイルは\n"
"B<writev>(2) をサポートしている。\n"
"全てのファイルは、 B<access>(2) と B<stat>(2) 系の操作に対応しているが、\n"
"B<stat>(2) では、呼び出した際に返される I<stat> 構造体のフィールドのう\n"
"ち信頼できる情報が入っているのは I<st_mode>, I<st_nlink>, I<st_uid>,\n"
"I<st_gid> だけである。"

#. type: Plain text
#: build/C/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/"
"B<fchown>(2)  operations, but will not be able to grant permissions that "
"contradict the possible operations (e.g., read access on the I<wbox> file)."
msgstr ""
"全てのファイルは B<chmod>(2)/B<fchmod>(2)  と B<chown>(2)/B<fchown>(2)  の操"
"作に対応しているが、 そのファイルが対応している操作と矛盾するアクセス許可を "
"付与することはできない (例えば、 I<wbox> ファイルに対する読み出しアクセスな"
"ど)。"

#. type: Plain text
#: build/C/man7/spufs.7:108
msgid "The current set of files is:"
msgstr "現時点でのファイルは以下の通りである。"

#. type: TP
#: build/C/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr "I</capabilities>"

#. type: Plain text
#: build/C/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr "B<sched>"

#. type: Plain text
#: build/C/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr "B<step>"

#. type: Plain text
#: build/C/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr "I</mem>"

#. type: Plain text
#: build/C/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""
"SPU のローカルストレージの内容。 このファイルは通常の共有メモリーファイルと同"
"様にアクセスでき、 SPU のアドレス空間にはコードとデータの両方を格納できる。 "
"オープンされた I<mem> ファイルに可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""
"これらは通常通り動作するが、 ファイル末尾を越えての B<lseek>(2), "
"B<write>(2), B<pwrite>(2)  に対応していない点だけが異なる。 ファイルサイズは "
"SPU のローカルストレージのサイズであり、 通常は 256 キロバイトである。"

#. type: TP
#: build/C/man7/spufs.7:144 build/C/man7/spufs.7:706 build/C/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings "
"are allowed."
msgstr ""
"I<mem> をプロセスのアドレス空間にマッピングすると、プロセスのアドレス\n"
"空間の一部として SPU のローカルストレージにアクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr "I</regs>"

#. type: Plain text
#: build/C/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr "I</mbox>"

#. type: Plain text
#: build/C/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""
"SPU から CPU への通信用の 1 つ目のメールボックス。このファイルは読み出\n"
"し専用で、読み出しは 4 バイト単位で行う。このファイルは非停止\n"
"(non-blocking) モードでのみ使用でき、 B<poll>(2) であってもこの\n"
"ファイルで停止 (block) することはできない。オープンされた I<mbox> \n"
"ファイルに可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:182 build/C/man7/spufs.7:222 build/C/man7/spufs.7:317
#: build/C/man7/spufs.7:381 build/C/man7/spufs.7:418 build/C/man7/spufs.7:463
#: build/C/man7/spufs.7:517 build/C/man7/spufs.7:632 build/C/man7/spufs.7:676
#: build/C/man7/spufs.7:754
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2) は -1 を返し、 I<errno> を\n"
"B<EINVAL> に設定する。 メールボックスにデータがない場合 (すなわち SPU\n"
"がメールボックスメッセージを送信していない場合)、-1 が返り、 I<errno>\n"
"が B<EAGAIN> に設定される。データの読み出しに成功した場合、 4 バイトが\n"
"データバッファーに格納され、返り値として 4 が返される。"

#. type: TP
#: build/C/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr "I</ibox>"

#. type: Plain text
#: build/C/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""
"SPU から CPU への通信用の 2 つ目のメールボックスである。このファイルは\n"
"1 つ目のメールボックスファイルと似ているが、停止 (blocking) I/O モード\n"
"での読み出しが可能である。したがって、オープンされた I<ibox> ファイルに\n"
"対して B<read>(2) を呼び出すと、(ファイルが B<O_NONBLOCK> (下記参照) で\n"
"オープンされていない場合は) SPU がデータを割り込みメールボックスチャネ\n"
"ル (interrupt mailbox channel) に書き込むまでその呼び出しは停止\n"
"(block) する。また、 B<poll>(2) や同様のシステムコールを使って、メール\n"
"ボックスにデータがあるかをを監視することができる。オープンされた\n"
"I<ibox> ファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr "オープンされた I<ibox> ファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 メールボックスにデータがない場合、ファイルディスクリプ"
"ターが B<O_NONBLOCK> でオープンされていれば、返り値は -1 となり、 I<errno> "
"は B<EAGAIN> に設定される。"

#. type: Plain text
#: build/C/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""
"メールボックスにデータがない場合で、ファイルディスクリプターが B<O_NONBLOCK> "
"なしでオープンされていれば、 SPU が自分の割り込みメールボックスチャネル "
"(interrupt mailbox channel)  に書き込みを行うまで B<read>(2)  は停止 (block) "
"する。 データの読み出しに成功した場合、 4 バイトがデータバッファーに格納さ"
"れ、返り値として 4 が返される。"

#. type: TP
#: build/C/man7/spufs.7:247 build/C/man7/spufs.7:295 build/C/man7/spufs.7:685
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""
"I<ibox> ファイルに対する B<poll>(2)  は、読み出しデータが利用可能になる度に "
"I<(POLLIN | POLLRDNORM)> を返す。"

#. type: TP
#: build/C/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr "I</wbox>"

#. type: Plain text
#: build/C/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""
"CPU から SPU への通信用のメールボックス。このファイルは書き込み専用で、\n"
"書き込みは 4 バイト単位で行う。メールボックスが一杯の場合、\n"
"B<write>(2) は停止 (block) する。 B<poll>(2) を使ってメールボックスに\n"
"再度書き込み可能になるまで待つことができる。\n"
"オープンされた I<wbox> ファイルに対して可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:268 build/C/man7/spufs.7:392 build/C/man7/spufs.7:432
#: build/C/man7/spufs.7:476 build/C/man7/spufs.7:527 build/C/man7/spufs.7:638
#: build/C/man7/spufs.7:652 build/C/man7/spufs.7:749
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 メールボックスに空き領域がない場合、ファイルディスクリ"
"プターが B<O_NONBLOCK> でオープンされていれば、返り値は -1 となり、 I<errno> "
"は B<EAGAIN> に設定される。"

#. type: Plain text
#: build/C/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""
"メールボックスに空き領域がない場合で、ファイルディスクリプターが\n"
"B<O_NONBLOCK> なしでオープンされていれば、 SPU が自分の PPE (PowerPC\n"
"Processing Element) メールボックスチャネルから読み出しを行うまで\n"
"B<write>(2) は停止 (block) する。 データの書き込みに成功した場合、\n"
"返り値として 4 が返される。"

#. type: Plain text
#: build/C/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""
"I<wbox> ファイルに対する B<poll>(2)  は、書き込み用の空間が利用可能になる度"
"に I<(POLLOUT | POLLWRNORM)> を返す。"

#. type: TP
#: build/C/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"

#. type: Plain text
#: build/C/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox\\(emthat is, how many words can be read from I<mbox> or I<ibox> "
"or how many words can be written to I<wbox> without blocking.  The files can "
"be read only in four-byte units and return a big-endian binary integer "
"number.  The only possible operation on an open I<*box_stat> file is:"
msgstr ""
"これらのファイルは読み出し専用で、各メールボックスの現在のキュー長を保持す"
"る。 すなわち、停止 (blocking) せずに、 I<mbox> や I<ibox> から何ワードを読み"
"出すことができ、 I<wbox> に何ワードを書き込むことができるか、ということであ"
"る。これらのファイルは 4 バイト単位でのみ読み出しが可能で、ビッグエンディアン"
"の整数値を返す。オープンされた I<*box_stat> ファイルに対して可能な操作は以下"
"だけである。"

#. type: Plain text
#: build/C/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat> "
"and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox "
"without blocking or returning an B<EAGAIN> error."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファーに 4 バイトの値が書き"
"込まれる。 この値は、各メールボックスにおいて停止せずに、または B<EAGAIN> エ"
"ラーなしで、読み出し可能なエレメント数 (I<mbox_stat> や I<ibox_stat> の場"
"合)、書き込み可能なエレメント数 (I<wbox_stat> の場合) である。"

#. type: TP
#: build/C/man7/spufs.7:338
#, no-wrap
msgid "I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, I</event_status>, I</srr0>, I</lslr>"
msgstr ""
"I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>,\n"
"I</event_status>, I</srr0>, I</lslr>"

#. type: Plain text
#: build/C/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr "これらのファイルの内容は以下の通り。"

#. type: TP
#: build/C/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr "I<npc>"

#. type: Plain text
#: build/C/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr "I<decr>"

#. type: Plain text
#: build/C/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr "SPU Decrementer"

#. type: TP
#: build/C/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr "I<decr_status>"

#. type: Plain text
#: build/C/man7/spufs.7:362
msgid "Decrementer Status"
msgstr "Decrementer の状態"

#. type: TP
#: build/C/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr "I<spu_tag_mask>"

#. type: Plain text
#: build/C/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr "SPU の DMA 用の MFA タグマスク"

#. type: TP
#: build/C/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr "I<event_mask>"

#. type: Plain text
#: build/C/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr "SPU の割り込みのイベントマスク"

#. type: TP
#: build/C/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr "I<event_status>"

#. type: Plain text
#: build/C/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr "I<srr0>"

#. type: Plain text
#: build/C/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr "割り込みリターンアドレスレジスター"

#. type: TP
#: build/C/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr "これらのファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue "
"reading from the same buffer, until the end of the buffer is reached."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:402 build/C/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in "
"the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""
"このファイルへの B<write>(2)  操作はレジスター値を文字列で指定された値に設定"
"する。 文字列の解釈は先頭から開始され、数字以外の文字が初めて登場するか、 "
"バッファーの末尾に達するまで行われる。 同じファイルディスクリプターへ続けて "
"write を行うと、 後の write により前の設定が上書きされる。"

#. type: Plain text
#: build/C/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr "I</fpcr>"

#. type: Plain text
#: build/C/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""
"このファイルにより Floating Point Status and Control Register (fcpr) に\n"
"アクセスできる。このファイルはバイナリで、大きさは 4 バイトである。 \n"
"I<fpcr> ファイルに可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファーに 4 バイトの値が書き"
"込まれる。 書き込まれる値は I<fpcr> レジスターの現在の値である。"

#. type: Plain text
#: build/C/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、 4 バイトの値がデータバッファーからコ"
"ピーされ、 I<fpcr> レジスターの値が更新される。"

#. type: TP
#: build/C/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr "I</signal1>, I</signal2>"

#. type: Plain text
#: build/C/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU.  "
"These are read-write files that operate on four-byte words.  Writing to one "
"of these files triggers an interrupt on the SPU.  The value written to the "
"signal files can be read from the SPU through a channel read or from host "
"user space through the file.  After the value has been read by the SPU, it "
"is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""
"これらのファイルにより SPU の二つのシグナル通知チャネル (signal\n"
"notification channel) に アクセスできる。これらは 4 バイトワード単位の\n"
"読み書きができる。これらのファイルの一つに書き込みを行うと、その SPU の\n"
"割り込みが 発生するトリガーとなる。シグナルファイルへ書き込まれた値は、\n"
"チャネル経由で SPU で読み出したり、このファイル経由でホストのユーザー空間\n"
"で読み出したりできる。 SPU が値を読み出した後では、値は 0 にリセット\n"
"される。オープンされた I<signal1> や I<signal2> ファイルに可能な操作は\n"
"以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファーに 4 バイトの値が書き"
"込まれる。 書き込まれる値は、指定されたシグナル通知レジスターの現在の値であ"
"る。"

#. type: Plain text
#: build/C/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、 4 バイトの値がデータバッファーからコ"
"ピーされ、 指定されたシグナル通知レジスターの値が更新される。 シグナル通知レ"
"ジスターの更新には、レジスター値を入力データで置き換えるモードと 以前の値と入"
"力データのビット単位の OR をとった値に更新するモードがある。 どちらのモードに"
"なるかは、それぞれ I<signal1_type>, I<signal2_type> ファイルの内容によって決"
"まる。"

#. type: TP
#: build/C/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr "I</signal1_type>, I</signal2_type>"

#. type: Plain text
#: build/C/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode "
"1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""
"これらのファイルは、シグナル通知ファイル I<signal1> と I<signal2> の動作を変"
"更する。 これらのファイルは数値を表すアスキー文字列を保持し、 読み出すと "
"\"1\" か \"0\" のどちらかが得られる。 モード 0 (上書きモード) では、ハード"
"ウェアはシグナルチャネルの内容を シグナルチャネルに書き込まれたデータで置き換"
"える。 モード 1 (論理 OR モード) では、ハードウェアはシグナルチャネルに 書き"
"込まれたビットを積算していく。 オープンされた I<signal1_type> や "
"I<signal2_type> ファイルに可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required "
"length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""
"B<read>(2) に渡された I<count> がレジスターの数値 (と改行 (newline) 文字\n"
"1 個) を格納するのに必要な長さより 短い場合、同じファイルディスクリプター\n"
"を続けて read することで、文字列全体を読み出すことができる。文字列全体\n"
"が読み出されると、それ以降の read 操作では 0 バイトが返され、新しい値を\n"
"読み出すには新しいファイルディスクリプターをオープンする必要がある。"

#. type: TP
#: build/C/man7/spufs.7:538
#, no-wrap
msgid "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"

#. type: Plain text
#: build/C/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to "
"these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat>, and I<wbox_stat> files contain the available "
"message count."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which "
"have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"

#. type: Plain text
#: build/C/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"

#. type: Plain text
#: build/C/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead.  "
"The file is in the following format:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"

#. type: Plain text
#: build/C/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr "I</cntl>"

#. type: Plain text
#: build/C/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:643
msgid ""
"Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr "I</mfc>"

#. type: Plain text
#: build/C/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"

#. type: Plain text
#: build/C/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in "
"size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of "
"the SPU."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:706 build/C/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""
"I<mss> をプロセスのアドレス空間にマッピングすると、プロセスのアドレス空\n"
"間の一部として SPU の MSS 領域にアクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr "I</psmap>"

#. type: Plain text
#: build/C/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications "
"can use this area to interface to the SPU, rather than writing to individual "
"register files in B<spufs>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state "
"area.  Only B<MAP_SHARED> mappings are supported."
msgstr ""
"I<psmap> をプロセスのアドレス空間にマッピングすると、\n"
"SPU の problem state 領域に直接アクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr "I</phys-id>"

#. type: Plain text
#: build/C/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr "I</object-id>"

#. type: Plain text
#: build/C/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr "I</etc/fstab>  entry"

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: build/C/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr "none \t/spu \tspufs \tgid=spu \t0\t0"

#. type: Plain text
#: build/C/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"

#. type: Plain text
#: build/C/man7/spufs.7:773
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr ""

#. type: TH
#: build/C/man2/stat.2:39
#, no-wrap
msgid "STAT"
msgstr "STAT"

#. type: Plain text
#: build/C/man2/stat.2:42
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr "stat, fstat, lstat, fstatat - ファイルの状態を取得する"

#. type: Plain text
#: build/C/man2/stat.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/stat.2:51
#, no-wrap
msgid ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
msgstr ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"

#. type: Plain text
#: build/C/man2/stat.2:54
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/stat.2:58
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/stat.2:67
msgid "B<lstat>():"
msgstr "B<lstat>():"

#.    _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/stat.2:73
#, no-wrap
msgid ""
"/* glibc 2.19 and earlier */ _BSD_SOURCE\n"
"    || /* Since glibc 2.20 */ _DEFAULT_SOURCE\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:76
msgid "B<fstatat>():"
msgstr "B<fstatat>():"

#. type: TP
#: build/C/man2/stat.2:79
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man2/stat.2:82
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man2/stat.2:82
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man2/stat.2:85
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: build/C/man2/stat.2:99
#, fuzzy
#| msgid ""
#| "These functions return information about a file, in the buffer pointed to "
#| "by I<stat>.  No permissions are required on the file itself, but\\(emin "
#| "the case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
#| "permission is required on all of the directories in I<pathname> that lead "
#| "to the file."
msgid ""
"These functions return information about a file, in the buffer pointed to by "
"I<statbuf>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to "
"the file."
msgstr ""
"これらの関数は、ファイルについての情報を I<stat> が指すバッファーに格納して返"
"す。 ファイルそのものに対するアクセス許可は必要としないが、 \\(emB<stat>(), "
"B<fstatat>(), B<lstat>() の場合には \\(emそのファイルへ至る I<pathname> を構"
"成する全てのディレクトリに対する実行 (検索) 許可が必要である。"

#. type: Plain text
#: build/C/man2/stat.2:108
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr ""
"B<stat>() と B<fstatat>() は I<pathname> が指すファイルに関する情報を取得す"
"る。 B<fstatat>() の違いについては後で説明する。"

#. type: Plain text
#: build/C/man2/stat.2:116
#, fuzzy
#| msgid ""
#| "B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
#| "symbolic link, then it returns information about the link itself, not the "
#| "file that it refers to."
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that the link refers to."
msgstr ""
"B<lstat>()  は B<stat>()  と同じであるが、 I<pathnames> がシンボリックリンク"
"の場合、リンクが参照しているファイルではなく、 リンク自身の状態を返す点が異な"
"る。"

#. type: Plain text
#: build/C/man2/stat.2:124
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr ""
"B<fstat>()  は B<stat>()  と同じだが、 状態を取得するファイルをファイルディス"
"クリプター I<fd> で指定する点が異なる。"

#. type: SS
#: build/C/man2/stat.2:124
#, no-wrap
msgid "The stat structure"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:128
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""
"これらのシステムコールはいずれも、結果を I<stat> 構造体に入れて返す。 "
"I<stat> 構造体には以下のフィールドが含まれている:"

#. type: Plain text
#: build/C/man2/stat.2:142
#, fuzzy, no-wrap
#| msgid ""
#| "struct stat {\n"
#| "    dev_t     st_dev;         /* ID of device containing file */\n"
#| "    ino_t     st_ino;         /* inode number */\n"
#| "    mode_t    st_mode;        /* protection */\n"
#| "    nlink_t   st_nlink;       /* number of hard links */\n"
#| "    uid_t     st_uid;         /* user ID of owner */\n"
#| "    gid_t     st_gid;         /* group ID of owner */\n"
#| "    dev_t     st_rdev;        /* device ID (if special file) */\n"
#| "    off_t     st_size;        /* total size, in bytes */\n"
#| "    blksize_t st_blksize;     /* blocksize for filesystem I/O */\n"
#| "    blkcnt_t  st_blocks;      /* number of 512B blocks allocated */\n"
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* Inode number */\n"
"    mode_t    st_mode;        /* File type and mode */\n"
"    nlink_t   st_nlink;       /* Number of hard links */\n"
"    uid_t     st_uid;         /* User ID of owner */\n"
"    gid_t     st_gid;         /* Group ID of owner */\n"
"    dev_t     st_rdev;        /* Device ID (if special file) */\n"
"    off_t     st_size;        /* Total size, in bytes */\n"
"    blksize_t st_blksize;     /* Block size for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */\n"
msgstr ""
"struct stat {\n"
"    dev_t     st_dev;     /* ファイルがあるデバイスの ID */\n"
"    ino_t     st_ino;     /* inode 番号 */\n"
"    mode_t    st_mode;    /* アクセス保護 */\n"
"    nlink_t   st_nlink;   /* ハードリンクの数 */\n"
"    uid_t     st_uid;     /* 所有者のユーザー ID */\n"
"    gid_t     st_gid;     /* 所有者のグループ ID */\n"
"    dev_t     st_rdev;    /* デバイス ID (特殊ファイルの場合) */\n"
"    off_t     st_size;    /* 全体のサイズ (バイト単位) */\n"
"    blksize_t st_blksize; /* ファイルシステム I/O での\n"
"                             ブロックサイズ */\n"
"    blkcnt_t  st_blocks;  /* 割り当てられた 512B のブロック数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/stat.2:146
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr ""
"    /* Linux 2.6 以降では、カーネルは以下のタイムスタンプ\n"
"       フィールドでナノ秒の精度をサポートしている。\n"
"       Linux 2.6 より前のバージョンでの詳細は\n"
"       下記の「注意」を参照。 */\n"

#. type: Plain text
#: build/C/man2/stat.2:150
#, fuzzy, no-wrap
#| msgid ""
#| "    struct timespec st_atim;  /* time of last access */\n"
#| "    struct timespec st_mtim;  /* time of last modification */\n"
#| "    struct timespec st_ctim;  /* time of last status change */\n"
msgid ""
"    struct timespec st_atim;  /* Time of last access */\n"
"    struct timespec st_mtim;  /* Time of last modification */\n"
"    struct timespec st_ctim;  /* Time of last status change */\n"
msgstr ""
"    struct timespec st_atim;  /* 最終アクセス時刻 */\n"
"    struct timespec st_mtim;  /* 最終修正時刻 */\n"
"    struct timespec st_ctim;  /* 最終状態変更時刻 */\n"

#. type: Plain text
#: build/C/man2/stat.2:155
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr ""
"#define st_atime st_atim.tv_sec      /* 後方互換性 */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"

#. type: Plain text
#: build/C/man2/stat.2:168
#, fuzzy
#| msgid ""
#| "I<Note:> the order of fields in the I<stat> structure varies somewhat "
#| "across architectures.  In addition, the definition above does not show "
#| "the padding bytes that may be present between some fields on various "
#| "architectures.  Consult the the glibc and kernel source code if you need "
#| "to know the details."
msgid ""
"I<Note>: the order of fields in the I<stat> structure varies somewhat across "
"architectures.  In addition, the definition above does not show the padding "
"bytes that may be present between some fields on various architectures.  "
"Consult the glibc and kernel source code if you need to know the details."
msgstr ""
"I<注意:> I<stat> 構造体のフィールドの順序はアーキテクチャーにより様々であ"
"る。 また、上記の定義では、フィールド間に存在することがあるパディングバイトは"
"書かれていない。このパディングバイトはアーキテクチャーによっても異なる。詳細"
"を知る必要がある場合は glibc とカーネルのソースを調べてほしい。"

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: build/C/man2/stat.2:193
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<stat> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<st_mode> or "
"I<st_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<st_mode> together with the "
"new I<st_uid>, or the old I<st_uid> together with the new I<st_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:197
#, fuzzy
#| msgid "These fields are defined as follows:"
msgid "The fields in the I<stat> structure are as follows:"
msgstr "これらのフィールドは、次のように定義されている。"

#. type: TP
#: build/C/man2/stat.2:197
#, no-wrap
msgid "I<st_dev>"
msgstr "I<st_dev>"

#. type: Plain text
#: build/C/man2/stat.2:205
#, fuzzy
#| msgid ""
#| "The I<st_dev> field describes the device on which this file resides.  "
#| "(The B<major>(3)  and B<minor>(3)  macros may be useful to decompose the "
#| "device ID in this field.)"
msgid ""
"This field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""
"I<st_dev> フィールドは、このファイルが存在するデバイスを示す (マクロ "
"B<major>(3), B<minor>(3)  は、このフィールドのデバイス ID を分解するのに役立"
"つだろう)。"

#. type: TP
#: build/C/man2/stat.2:205
#, no-wrap
msgid "I<st_ino>"
msgstr "I<st_ino>"

#. type: Plain text
#: build/C/man2/stat.2:208
msgid "This field contains the file's inode number."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:208
#, no-wrap
msgid "I<st_mode>"
msgstr "I<st_mode>"

#. type: Plain text
#: build/C/man2/stat.2:214
msgid ""
"This field contains the file type and mode.  See B<inode>(7)  for further "
"information."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:214
#, no-wrap
msgid "I<st_nlink>"
msgstr "I<st_nlink>"

#. type: Plain text
#: build/C/man2/stat.2:217
msgid "This field contains the number of hard links to the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:217
#, no-wrap
msgid "I<st_uid>"
msgstr "I<st_uid>"

#. type: Plain text
#: build/C/man2/stat.2:220 build/C/man2/statx.2:366
msgid "This field contains the user ID of the owner of the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:220
#, no-wrap
msgid "I<st_gid>"
msgstr "I<st_gid>"

#. type: Plain text
#: build/C/man2/stat.2:223 build/C/man2/statx.2:369
msgid "This field contains the ID of the group owner of the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:223
#, no-wrap
msgid "I<st_rdev>"
msgstr "I<st_rdev>"

#. type: Plain text
#: build/C/man2/stat.2:226
#, fuzzy
#| msgid ""
#| "The I<st_rdev> field describes the device that this file (inode) "
#| "represents."
msgid "This field describes the device that this file (inode) represents."
msgstr "I<st_rdev> フィールドは、このファイル (inode) が表すデバイスを示す。"

#. type: TP
#: build/C/man2/stat.2:226
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: build/C/man2/stat.2:232 build/C/man7/inode.7:112
#, fuzzy
#| msgid ""
#| "The I<st_size> field gives the size of the file (if it is a regular file "
#| "or a symbolic link) in bytes.  The size of a symbolic link is the length "
#| "of the pathname it contains, without a terminating null byte."
msgid ""
"This field gives the size of the file (if it is a regular file or a symbolic "
"link) in bytes.  The size of a symbolic link is the length of the pathname "
"it contains, without a terminating null byte."
msgstr ""
"I<st_size> フィールドは、(通常のファイルかシンボリックリンクの場合に)\n"
"ファイルの大きさをバイト単位で示す。 シンボリックリンクの大きさは、\n"
"シンボリックリンクに含まれている パス名の長さ (終端のヌルバイトは含まない)\n"
"である。"

#. type: TP
#: build/C/man2/stat.2:232
#, no-wrap
msgid "I<st_blksize>"
msgstr "I<st_blksize>"

#. type: Plain text
#: build/C/man2/stat.2:235
msgid ""
"This field gives the \"preferred\" block size for efficient filesystem I/O."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:235
#, no-wrap
msgid "I<st_blocks>"
msgstr "I<st_blocks>"

#. type: Plain text
#: build/C/man2/stat.2:242
#, fuzzy
#| msgid ""
#| "The I<st_blocks> field indicates the number of blocks allocated to the "
#| "file, 512-byte units.  (This may be smaller than I<st_size>/512 when the "
#| "file has holes.)"
msgid ""
"This field indicates the number of blocks allocated to the file, in 512-byte "
"units.  (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""
"I<st_blocks> フィールドは、ファイルの大きさを 512 バイトのブロックサイズ単位"
"で示す フィールドは、ファイルに割り当てされたブロック数を 512 バイト単位で示"
"す。 (ファイルに穴があるような場合、この値は I<st_size>/512 より小さくなるこ"
"ともある)。"

#. type: TP
#: build/C/man2/stat.2:242
#, no-wrap
msgid "I<st_atime>"
msgstr "I<st_atime>"

#. type: Plain text
#: build/C/man2/stat.2:245
msgid "This is the time of the last access of file data."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:245
#, no-wrap
msgid "I<st_mtime>"
msgstr "I<st_mtime>"

#. type: Plain text
#: build/C/man2/stat.2:248
msgid "This is the time of last modification of file data."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:248
#, no-wrap
msgid "I<st_ctime>"
msgstr "I<st_ctime>"

#. type: Plain text
#: build/C/man2/stat.2:252
msgid ""
"This is the file's last status change timestamp (time of last change to the "
"inode)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:256 build/C/man2/statx.2:417
msgid "For further information on the above fields, see B<inode>(7)."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:256
#, no-wrap
msgid "fstatat()"
msgstr "fstatat()"

#. type: Plain text
#: build/C/man2/stat.2:265
msgid ""
"The B<fstatat>()  system call is a more general interface for accessing file "
"information which can still provide exactly the behavior of each of "
"B<stat>(), B<lstat>(), and B<fstat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:277
#, fuzzy
#| msgid ""
#| "If the pathname given in I<pathname> is relative, then it is interpreted "
#| "relative to the directory referred to by the file descriptor I<dirfd> "
#| "(rather than relative to the current working directory of the calling "
#| "process, as is done by B<stat>()  for a relative pathname)."
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  and B<lstat>()  for a relative pathname)."
msgstr ""
"指定された I<pathname> が相対パスの場合、 ファイルディスクリプター I<dirfd> "
"が参照するディレクトリに対する相対パスと解釈される (B<stat>() に相対パスを渡"
"した場合のように、呼び出したプロセスのカレントワーキングディレクトリに対する"
"相対パスではない)。"

#. type: Plain text
#: build/C/man2/stat.2:291
#, fuzzy
#| msgid ""
#| "If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
#| "then I<pathname> is interpreted relative to the current working directory "
#| "of the calling process (like B<stat>())."
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<stat>()  and B<lstat>())."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> の場合、 "
"(B<stat>(2) と同様に) I<pathname> は呼び出したプロセスのカレントワーキング"
"ディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/stat.2:297
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""
"I<pathname> で指定されたパス名が絶対パスの場合、 I<dirfd> は無視される。"

#. type: Plain text
#: build/C/man2/stat.2:300
msgid ""
"I<flags> can either be 0, or include one or more of the following flags ORed:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man2/stat.2:300
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (Linux 2.6.39 以降)"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:327
#, fuzzy
#| msgid ""
#| "If I<pathname> is an empty string, operate on the file referred to by "
#| "I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
#| "flag).  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
#| "working directory.  In this case, I<dirfd> can refer to any type of file, "
#| "not just a directory.  This flag is Linux-specific; define B<_GNU_SOURCE> "
#| "to obtain its definition."
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory, and the behavior of B<fstatat>()  is similar to that of "
"B<fstat>().  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""
"I<pathname> が空文字列の場合、 I<dirfd> が参照するファイルに対して操作を行う "
"(I<dirfd> は B<open>(2) の B<O_PATH> フラグを使って取得できる)。 B<dirfd> が "
"B<AT_FDCWD> の場合、呼び出しはカレントワーキングディレクトリに対して操作を行"
"う。 この場合、 I<dirfd> は、ディレクトリだけでなく、任意のタイプのファイルを"
"参照することができる。 このフラグは Linux 固有であり、その定義を得るには "
"B<_GNU_SOURCE> を定義すること。"

#. type: TP
#: build/C/man2/stat.2:327
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr "B<AT_NO_AUTOMOUNT> (Linux 2.6.38 以降)"

#.  commit 42f46148217865a545e129612075f3d828a2c4e4
#. type: Plain text
#: build/C/man2/stat.2:340
#, fuzzy
#| msgid ""
#| "Don't automount the terminal (\"basename\") component of I<pathname> if "
#| "it is a directory that is an automount point.  This allows the caller to "
#| "gather attributes of an automount point (rather than the location it "
#| "would mount).  This flag can be used in tools that scan directories to "
#| "prevent mass-automounting of a directory of automount points.  The "
#| "B<AT_NO_AUTOMOUNT> flag has no effect if the mount point has already been "
#| "mounted over.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
#| "obtain its definition."
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand "
"directory such as used for automounter indirect maps.  This flag has no "
"effect if the mount point has already been mounted over."
msgstr ""
"I<pathname> がオートマウントポイントとなっているディレクトリの場合、 "
"I<pathname> の最終 (\"basename\") 要素のオートマウントを行わない。 これによ"
"り (マウントされるはずの場所ではなく) オートマウントポイントの属性を取得する"
"ことができる。 このフラグを使うと、 ディレクトリをスキャンするツールがオート"
"マウントポイントのディレクトリを大量にオートマウントしてしまうのを防ぐことが"
"できる。 マウントポイントがすでにマウントされている場合 B<AT_NO_AUTOMOUNT> フ"
"ラグは何の効果もない。 このフラグは Linux 固有であり、その定義を得るには "
"B<_GNU_SOURCE> を定義すること。"

#. type: Plain text
#: build/C/man2/stat.2:348
msgid ""
"Both B<stat>()  and B<lstat>()  act as though B<AT_NO_AUTOMOUNT> was set."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:353
msgid ""
"The B<AT_NO_AUTOMOUNT> can be used in tools that scan directories to prevent "
"mass-automounting of a directory of automount points."
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:358 build/C/man2/statx.2:189
msgid ""
"This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:358 build/C/man2/statx.2:205
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: build/C/man2/stat.2:369
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr ""
"(B<lstat>() 同様) I<pathname> がシンボリックリンクの場合リンクの展開を行わ"
"ず、 リンク自身の情報を返す (デフォルトでは、 B<fstatat>() は、 B<stat>() と"
"同様に、シンボリックリンクの展開を行う)。"

#. type: Plain text
#: build/C/man2/stat.2:374
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr "B<fstatat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/stat.2:387 build/C/man2/statx.2:508
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<pathname>.  (See also B<path_resolution>(7).)"
msgstr ""
"I<pathname> が所属するディレクトリとその上位のディレクトリのいずれかに 対する"
"検索許可がなかった (B<path_resolution>(7)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/stat.2:391
#, fuzzy
#| msgid "I<fd> is not a valid file descriptor."
msgid "I<fd> is not a valid open file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/stat.2:394
msgid "Bad address."
msgstr "アドレスが間違っている。"

#. type: Plain text
#: build/C/man2/stat.2:397
msgid "Too many symbolic links encountered while traversing the path."
msgstr "パスを辿る際に解決すべきシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/stat.2:406
#, fuzzy
#| msgid ""
#| "A component of I<pathname> does not exist, or I<pathname> is an empty "
#| "string."
msgid ""
"A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr "I<pathname> の構成要素が存在しないか、 I<pathname> が空文字列である。"

#. type: Plain text
#: build/C/man2/stat.2:413
#, fuzzy
#| msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgid ""
"I<pathname> is an empty string and B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""
"I<fpath> がシンボリックリンクで、かつ B<FTW_PHYS> が I<flags> に セットされて"
"いた。"

#. type: Plain text
#: build/C/man2/stat.2:416 build/C/man2/statx.2:550
msgid "Out of memory (i.e., kernel memory)."
msgstr "カーネルのメモリーが足りない。"

#. type: Plain text
#: build/C/man2/stat.2:421
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr "I<pathname> の前半部分 (prefix) の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/stat.2:421 build/C/man2/statfs.2:283 build/C/man3/statvfs.3:187
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man2/stat.2:440
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls "
"B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""
"I<pathname> または I<fd> が、ファイルサイズ、inode 番号、ブロック数が\n"
"それぞれ I<off_t> 型、 I<ino_t> 型、 I<blkcnt_t> 型で表現できないファイルを\n"
"参照している。このエラーが起こるのは、例えば、32 ビットプラットフォーム上で\n"
"I<-D_FILE_OFFSET_BITS=64> を指定せずにコンパイルされたアプリケーションが、\n"
"ファイルサイズが I<(1E<lt>E<lt>31)-1> バイトを超えるファイルに対して\n"
"B<stat>() を呼び出した場合である。"

#. type: Plain text
#: build/C/man2/stat.2:443
msgid "The following additional errors can occur for B<fstatat>():"
msgstr "B<fstatat>() では以下のエラーも発生することがある。"

#. type: Plain text
#: build/C/man2/stat.2:447
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/stat.2:451 build/C/man2/statx.2:523
msgid "Invalid flag specified in I<flags>."
msgstr "I<flags> に無効なフラグが指定された。"

#. type: Plain text
#: build/C/man2/stat.2:457
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/stat.2:461
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<fstatat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: build/C/man2/stat.2:474
msgid ""
"B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr ""
"B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."

#. type: Plain text
#: build/C/man2/stat.2:477
msgid "B<fstatat>(): POSIX.1-2008."
msgstr "B<fstatat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/stat.2:491
#, fuzzy
#| msgid ""
#| "According to POSIX.1-2001, B<lstat>()  on a symbolic link need return "
#| "valid information only in the I<st_size> field and the file-type "
#| "component of the I<st_mode> field of the I<stat> structure.  POSIX.1-2008 "
#| "tightens the specification, requiring B<lstat>()  to return valid "
#| "information in all fields except the permission bits in I<st_mode>."
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file type of the I<st_mode> "
"field of the I<stat> structure.  POSIX.1-2008 tightens the specification, "
"requiring B<lstat>()  to return valid information in all fields except the "
"mode bits in I<st_mode>."
msgstr ""
"POSIX.1-2001 では、シンボリックリンクに対する B<lstat>() で\n"
"有効な情報を返すように求められていたのは、 I<stat> 構造体の I<st_size>\n"
"と I<st_mode> のファイル種別要素だけであった。\n"
"POSIX.1-2008 では規定が厳しくなり、 B<lstat>() は I<st_mode> の\n"
"アクセス許可ビット以外の全てのフィールドに有効な情報を返すことが\n"
"求められるようになっている。"

#. type: Plain text
#: build/C/man2/stat.2:500
#, fuzzy
#| msgid ""
#| "Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
#| "(They were introduced in BSD.  The interpretation differs between "
#| "systems, and possibly on a single system when NFS mounts are involved.)  "
#| "If you need to obtain the definition of the I<blkcnt_t> or I<blksize_t> "
#| "types from I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the "
#| "value 500 or greater (before including I<any> header files)."
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)"
msgstr ""
"I<st_blocks> と I<st_blksize> フィールドの使用はあまり移植性がない\n"
"(これらのフィールドは BSD によって導入された。 システムごとに解釈が\n"
"異なっており、 NFS マウントの場合には同じシステムでも異なる可能性がある)。\n"
"I<E<lt>sys/stat.hE<gt>> から I<blkcnt_t> の I<blksize_t> 型定義を\n"
"読み込みたい場合は、(I<どの>ヘッダーファイルをインクルードするよりも前に)\n"
"B<_XOPEN_SOURCE> を 500 以上の値で定義すること。"

#. type: SS
#: build/C/man2/stat.2:501
#, no-wrap
msgid "Timestamp fields"
msgstr "タイムスタンプフィールド"

#. type: Plain text
#: build/C/man2/stat.2:512
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps "
"with one-second precision."
msgstr ""
"古いカーネルや古い標準では、ナノ秒精度のタイムスタンプフィールドはサポートさ"
"れていなかった。 代わりに 3 つの I<time_t> 型のタイムスタンプフィールド "
"I<st_atime>, I<st_mtime>, and I<st_ctime> があった。これらのフィールドには 1 "
"秒単位のタイムスタンプが記録されていた。"

#. type: Plain text
#: build/C/man2/stat.2:537
#, fuzzy
#| msgid ""
#| "Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
#| "for the three file timestamp fields.  The nanosecond components of each "
#| "timestamp are available via names of the form I<st_atim.tv_nsec> if the "
#| "B<_BSD_SOURCE> or B<_SVID_SOURCE> feature test macro is defined.  "
#| "Nanosecond timestamps are nowadays standardized, starting with "
#| "POSIX.1-2008, and, starting with version 2.12, glibc also exposes the "
#| "nanosecond component names if B<_POSIX_C_SOURCE> is defined with the "
#| "value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value "
#| "700 or greater.  If none of the aforementioned macros are defined, then "
#| "the nanosecond values are exposed with names of the form I<st_atimensec>."
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec>, if "
"suitable feature test macros are defined.  Nanosecond timestamps were "
"standardized in POSIX.1-2008, and, starting with version 2.12, glibc exposes "
"the nanosecond component names if B<_POSIX_C_SOURCE> is defined with the "
"value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value 700 "
"or greater.  Up to and including glibc 2.19, the definitions of the "
"nanoseconds components are also defined if B<_BSD_SOURCE> or B<_SVID_SOURCE> "
"is defined.  If none of the aforementioned macros are defined, then the "
"nanosecond values are exposed with names of the form I<st_atimensec>."
msgstr ""
"カーネル 2.5.48 以降では、 I<stat> 構造体は 3 つのファイルのタイムスタンプ関"
"連のフィールドでナノ秒単位の精度に対応している。 機能検査マクロ "
"B<_BSD_SOURCE> か B<_SVID_SOURCE> が定義された場合に、各タイムスタンプのナノ"
"秒の情報は I<st_atim.tv_nsec> という形式の名前で参照できる。 ナノ秒のタイムス"
"タンプは現在では標準化されており、 POSIX.1-2008 からである。 バージョン 2.12 "
"以降の glibc では、 B<_POSIX_C_SOURCE> が 200809L 以上の値で定義されるか、 "
"B<_XOPEN_SOURCE> が 700 以上の値で定義された場合にも、 このナノ秒のタイムスタ"
"ンプが公開される。 上記のマクロのいずれも定義されていない場合、ナノ秒の値は "
"I<st_atimensec> という形式の名前で公開される。"

#. type: SS
#: build/C/man2/stat.2:537
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  See include/asm-i386/stat.h in the Linux 2.4 source code for the
#.  various versions of the structure definitions
#. type: Plain text
#: build/C/man2/stat.2:562
#, fuzzy
#| msgid ""
#| "Over time, increases in the size of the I<stat> structure have led to "
#| "three successive versions of B<stat>(): I<sys_stat>()  (slot "
#| "I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
#| "I<sys_stat64()> (new in kernel 2.4; slot I<__NR_stat64>).  The glibc "
#| "B<stat>()  wrapper function hides these details from applications, "
#| "invoking the most recent version of the system call provided by the "
#| "kernel, and repacking the returned information if required for old "
#| "binaries.  Similar remarks apply for B<fstat>()  and B<lstat>()."
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (slot "
"I<__NR_stat64>)  on 32-bit platforms such as i386.  The first two versions "
"were already present in Linux 1.0 (albeit with different names); the last "
"was added in Linux 2.4.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""
"時間の経過とともに、 I<stat> 構造体のサイズが大きくなり、この影響で "
"B<stat>()  には 3つのバージョンが存在する: I<sys_stat>()  (スロットは "
"I<__NR_oldstat>)、 I<sys_newstat>()  (スロットは I<__NR_stat>)、 "
"I<sys_stat64>()  (カーネル 2.4 で導入; スロットは I<__NR_stat64>).  glibc の "
"B<stat>()  ラッパー関数はこれらの詳細をアプリケーションから隠蔽してくれる。 "
"具体的には、カーネルが提供しているシステムコールのうち最新のバージョンを 起動"
"し、古いバイナリの場合には必要に応じて返された情報を再構成 (repack) する。 "
"B<fstat>()  と B<lstat>()  についても同様である。"

#. type: Plain text
#: build/C/man2/stat.2:566
msgid ""
"The kernel-internal versions of the I<stat> structure dealt with by the "
"different versions are, respectively:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:566
#, no-wrap
msgid "I<__old_kernel_stat>"
msgstr "I<__old_kernel_stat>"

#. type: Plain text
#: build/C/man2/stat.2:569
msgid "The original structure, with rather narrow fields, and no padding."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:569
#, no-wrap
msgid "I<stat>"
msgstr "I<stat>"

#. type: Plain text
#: build/C/man2/stat.2:575
msgid ""
"Larger I<st_ino> field and padding added to various parts of the structure "
"to allow for future expansion."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:575
#, no-wrap
msgid "I<stat64>"
msgstr "I<stat64>"

#. type: Plain text
#: build/C/man2/stat.2:589
msgid ""
"Even larger I<st_ino> field, larger I<st_uid> and I<st_gid> fields to "
"accommodate the Linux-2.4 expansion of UIDs and GIDs to 32 bits, and various "
"other enlarged fields and further padding in the structure.  (Various "
"padding bytes were eventually consumed in Linux 2.6, with the advent of 32-"
"bit device IDs and nanosecond components for the timestamp fields.)"
msgstr ""

#
#
#
#
#
#
#.  A note from Andries Brouwer, July 2007
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: build/C/man2/stat.2:623
msgid ""
"The glibc B<stat>()  wrapper function hides these details from applications, "
"invoking the most recent version of the system call provided by the kernel, "
"and repacking the returned information if required for old binaries."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:629
msgid ""
"On modern 64-bit systems, life is simpler: there is a single B<stat>()  "
"system call and the kernel deals with a I<stat> structure that contains "
"fields of a sufficient size."
msgstr ""

#.  strace(1) shows the name "newfstatat" on x86-64
#. type: Plain text
#: build/C/man2/stat.2:637
#, fuzzy
#| msgid ""
#| "The underlying system call employed by the glibc B<fstatat>()  wrapper "
#| "function is actually called B<fstatat64>()."
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()  or, on some architectures, "
"B<newfstatat>()."
msgstr ""
"glibc の B<fstatat>() ラッパー関数が内部で利用するシステムコールは、実際には "
"B<fstatat64>() である。"

#. type: Plain text
#: build/C/man2/stat.2:643
msgid ""
"The following program calls B<lstat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr "以下のプログラムは B<lstat>()  を呼び出し、返ってきた I<stat> 構造体のフィールドのいくつかを表示する。"

#. type: Plain text
#: build/C/man2/stat.2:652
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"

#. type: Plain text
#: build/C/man2/stat.2:657
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"

#. type: Plain text
#: build/C/man2/stat.2:662
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:667
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:671
#, no-wrap
msgid ""
"    printf(\"ID of containing device:  [%jx,%jx]\\en\",\n"
"            (uintmax_t) major(sb.st_dev),\n"
"            (uintmax_t) minor(sb.st_dev));\n"
msgstr ""
"    printf(\"ID of containing device:  [%jx,%jx]\\en\",\n"
"            (uintmax_t) major(sb.st_dev),\n"
"            (uintmax_t) minor(sb.st_dev));\n"

#. type: Plain text
#: build/C/man2/stat.2:673
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr "    printf(\"File type:                \");\n"

#. type: Plain text
#: build/C/man2/stat.2:684
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:686
#, fuzzy, no-wrap
#| msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgid "    printf(\"I-node number:            %ju\\en\", (uintmax_t) sb.st_ino);\n"
msgstr "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"

#. type: Plain text
#: build/C/man2/stat.2:689
#, fuzzy, no-wrap
#| msgid ""
#| "    printf(\"Mode:                     %lo (octal)\\en\",\n"
#| "            (unsigned long) sb.st_mode);\n"
msgid ""
"    printf(\"Mode:                     %jo (octal)\\en\",\n"
"            (uintmax_t) sb.st_mode);\n"
msgstr ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"

#. type: Plain text
#: build/C/man2/stat.2:693
#, fuzzy, no-wrap
#| msgid ""
#| "    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
#| "    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
#| "            (long) sb.st_uid, (long) sb.st_gid);\n"
msgid ""
"    printf(\"Link count:               %ju\\en\", (uintmax_t) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ju   GID=%ju\\en\",\n"
"            (uintmax_t) sb.st_uid, (uintmax_t) sb.st_gid);\n"
msgstr ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"

#. type: Plain text
#: build/C/man2/stat.2:700
#, fuzzy, no-wrap
#| msgid ""
#| "    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
#| "            (long) sb.st_blksize);\n"
#| "    printf(\"File size:                %lld bytes\\en\",\n"
#| "            (long long) sb.st_size);\n"
#| "    printf(\"Blocks allocated:         %lld\\en\",\n"
#| "            (long long) sb.st_blocks);\n"
msgid ""
"    printf(\"Preferred I/O block size: %jd bytes\\en\",\n"
"            (intmax_t) sb.st_blksize);\n"
"    printf(\"File size:                %jd bytes\\en\",\n"
"            (intmax_t) sb.st_size);\n"
"    printf(\"Blocks allocated:         %jd\\en\",\n"
"            (intmax_t) sb.st_blocks);\n"
msgstr ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"

#. type: Plain text
#: build/C/man2/stat.2:704
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"

#. type: Plain text
#: build/C/man2/stat.2:720
#, fuzzy
#| msgid ""
#| "B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
#| "B<readlink>(2), B<utime>(2), B<capabilities>(7), B<symlink>(7)"
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<statx>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<utime>(2), B<capabilities>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr "STATFS"

#. type: Plain text
#: build/C/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr "statfs, fstatfs - ファイルシステムの統計を取得する"

#. type: Plain text
#: build/C/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr "B<#include E<lt>sys/vfs.hE<gt> >/* または E<lt>sys/statfs.hE<gt> */"

#. type: Plain text
#: build/C/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/statfs.2:47
#, fuzzy
#| msgid ""
#| "The function B<statfs>()  returns information about a mounted "
#| "filesystem.  I<path> is the pathname of any file within the mounted "
#| "filesystem.  I<buf> is a pointer to a I<statfs> structure defined "
#| "approximately as follows:"
msgid ""
"The B<statfs>()  system call returns information about a mounted "
"filesystem.  I<path> is the pathname of any file within the mounted "
"filesystem.  I<buf> is a pointer to a I<statfs> structure defined "
"approximately as follows:"
msgstr ""
"関数 B<statfs>()  はマウントされたファイルシステムについての情報を返す。 "
"I<path> はマウントされたファイルシステムにあるファイルのパス名である。 "
"I<buf> は I<statfs> 構造体へのポインターで、およそ以下のように定義される:"

#. type: Plain text
#: build/C/man2/statfs.2:67
#, fuzzy, no-wrap
#| msgid ""
#| "struct statfs {\n"
#| "    __SWORD_TYPE f_type;    /* type of filesystem (see below) */\n"
#| "    __SWORD_TYPE f_bsize;   /* optimal transfer block size */\n"
#| "    fsblkcnt_t   f_blocks;  /* total data blocks in filesystem */\n"
#| "    fsblkcnt_t   f_bfree;   /* free blocks in fs */\n"
#| "    fsblkcnt_t   f_bavail;  /* free blocks available to\n"
#| "                               unprivileged user */\n"
#| "    fsfilcnt_t   f_files;   /* total file nodes in filesystem */\n"
#| "    fsfilcnt_t   f_ffree;   /* free file nodes in fs */\n"
#| "    fsid_t       f_fsid;    /* filesystem id */\n"
#| "    __SWORD_TYPE f_namelen; /* maximum length of filenames */\n"
#| "    __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */\n"
#| "    __SWORD_TYPE f_spare[5];\n"
#| "};\n"
msgid ""
"struct statfs {\n"
"    __fsword_t f_type;    /* Type of filesystem (see below) */\n"
"    __fsword_t f_bsize;   /* Optimal transfer block size */\n"
"    fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */\n"
"    fsblkcnt_t f_bfree;   /* Free blocks in filesystem */\n"
"    fsblkcnt_t f_bavail;  /* Free blocks available to\n"
"                             unprivileged user */\n"
"    fsfilcnt_t f_files;   /* Total inodes in filesystem */\n"
"    fsfilcnt_t f_ffree;   /* Free inodes in filesystem */\n"
"    fsid_t     f_fsid;    /* Filesystem ID */\n"
"    __fsword_t f_namelen; /* Maximum length of filenames */\n"
"    __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */\n"
"    __fsword_t f_flags;   /* Mount flags of filesystem\n"
"                             (since Linux 2.6.36) */\n"
"    __fsword_t f_spare[xxx];\n"
"                    /* Padding bytes reserved for future use */\n"
"};\n"
msgstr ""
"struct statfs {\n"
"    __SWORD_TYPE f_type;    /* ファイルシステムの種別 (下記参照) */\n"
"    __SWORD_TYPE f_bsize;   /* 最適な転送ブロックサイズ */\n"
"    fsblkcnt_t   f_blocks;  /* ファイルシステムの総データブロック数 */\n"
"    fsblkcnt_t   f_bfree;   /* ファイルシステムの空きブロック数 */\n"
"    fsblkcnt_t   f_bavail;  /* 非特権ユーザーが利用可能な空きブロック数 */\n"
"    fsfilcnt_t   f_files;   /* ファイルシステムの総ファイルノード数 */\n"
"    fsfilcnt_t   f_ffree;   /* ファイルシステムの空きファイルノード数 */\n"
"    fsid_t       f_fsid;    /* ファイルシステムの ID */\n"
"    __SWORD_TYPE f_namelen; /* ファイル名の最大長 */\n"
"    __SWORD_TYPE f_frsize;  /* フラグメントサイズ (Linux 2.6 以降) */\n"
"    __SWORD_TYPE f_spare[5];\n"
"};\n"

#. type: Plain text
#: build/C/man2/statfs.2:72
msgid "The following filesystem types may appear in I<f_type>:"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:161
#, fuzzy, no-wrap
#| msgid ""
#| "   ADFS_SUPER_MAGIC      0xadf5\n"
#| "   AFFS_SUPER_MAGIC      0xADFF\n"
#| "   BDEVFS_MAGIC          0x62646576\n"
#| "   BEFS_SUPER_MAGIC      0x42465331\n"
#| "   BFS_MAGIC             0x1BADFACE\n"
#| "   BINFMTFS_MAGIC        0x42494e4d\n"
#| "   BTRFS_SUPER_MAGIC     0x9123683E\n"
#| "   CGROUP_SUPER_MAGIC    0x27e0eb\n"
#| "   CIFS_MAGIC_NUMBER     0xFF534D42\n"
#| "   CODA_SUPER_MAGIC      0x73757245\n"
#| "   COH_SUPER_MAGIC       0x012FF7B7\n"
#| "   CRAMFS_MAGIC          0x28cd3d45\n"
#| "   DEBUGFS_MAGIC         0x64626720\n"
#| "   DEVFS_SUPER_MAGIC     0x1373\n"
#| "   DEVPTS_SUPER_MAGIC    0x1cd1\n"
#| "   EFIVARFS_MAGIC        0xde5e81e4\n"
#| "   EFS_SUPER_MAGIC       0x00414A53\n"
#| "   EXT_SUPER_MAGIC       0x137D\n"
#| "   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
#| "   EXT2_SUPER_MAGIC      0xEF53\n"
#| "   EXT3_SUPER_MAGIC      0xEF53\n"
#| "   EXT4_SUPER_MAGIC      0xEF53\n"
#| "   FUSE_SUPER_MAGIC      0x65735546\n"
#| "   FUTEXFS_SUPER_MAGIC   0xBAD1DEA\n"
#| "   HFS_SUPER_MAGIC       0x4244\n"
#| "   HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
#| "   HPFS_SUPER_MAGIC      0xF995E849\n"
#| "   HUGETLBFS_MAGIC       0x958458f6\n"
#| "   ISOFS_SUPER_MAGIC     0x9660\n"
#| "   JFFS2_SUPER_MAGIC     0x72b6\n"
#| "   JFS_SUPER_MAGIC       0x3153464a\n"
#| "   MINIX_SUPER_MAGIC     0x137F /* orig. minix */\n"
#| "   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */\n"
#| "   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
#| "   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */\n"
#| "   MINIX3_SUPER_MAGIC    0x4d5a /* minix V3 fs, 60 char names */\n"
#| "   MQUEUE_MAGIC          0x19800202\n"
#| "   MSDOS_SUPER_MAGIC     0x4d44\n"
#| "   NCP_SUPER_MAGIC       0x564c\n"
#| "   NFS_SUPER_MAGIC       0x6969\n"
#| "   NILFS_SUPER_MAGIC     0x3434\n"
#| "   NTFS_SB_MAGIC         0x5346544e\n"
#| "   OPENPROM_SUPER_MAGIC  0x9fa1\n"
#| "   PIPEFS_MAGIC          0x50495045\n"
#| "   PROC_SUPER_MAGIC      0x9fa0\n"
#| "   PSTOREFS_MAGIC        0x6165676C\n"
#| "   QNX4_SUPER_MAGIC      0x002f\n"
#| "   QNX6_SUPER_MAGIC      0x68191122\n"
#| "   RAMFS_MAGIC           0x858458f6\n"
#| "   REISERFS_SUPER_MAGIC  0x52654973\n"
#| "   ROMFS_MAGIC           0x7275\n"
#| "   SELINUX_MAGIC         0xf97cff8c\n"
#| "   SMACK_MAGIC           0x43415d53\n"
#| "   SMB_SUPER_MAGIC       0x517B\n"
#| "   SOCKFS_MAGIC          0x534F434B\n"
#| "   SQUASHFS_MAGIC        0x73717368\n"
#| "   SYSFS_MAGIC           0x62656572\n"
#| "   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
#| "   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
#| "   TMPFS_MAGIC           0x01021994\n"
#| "   UDF_SUPER_MAGIC       0x15013346\n"
#| "   UFS_MAGIC             0x00011954\n"
#| "   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
#| "   V9FS_MAGIC            0x01021997\n"
#| "   VXFS_SUPER_MAGIC      0xa501FCF5\n"
#| "   XENFS_SUPER_MAGIC     0xabba1974\n"
#| "   XENIX_SUPER_MAGIC     0x012FF7B4\n"
#| "   XFS_SUPER_MAGIC       0x58465342\n"
#| "   _XIAFS_SUPER_MAGIC    0x012FD16D\n"
msgid ""
"ADFS_SUPER_MAGIC      0xadf5\n"
"AFFS_SUPER_MAGIC      0xadff\n"
"AFS_SUPER_MAGIC       0x5346414f\n"
"ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for\n"
"                                    pseudofiles that have no name;\n"
"                                    e.g., epoll, signalfd, bpf) */\n"
"AUTOFS_SUPER_MAGIC    0x0187\n"
"BDEVFS_MAGIC          0x62646576\n"
"BEFS_SUPER_MAGIC      0x42465331\n"
"BFS_MAGIC             0x1badface\n"
"BINFMTFS_MAGIC        0x42494e4d\n"
"BPF_FS_MAGIC          0xcafe4a11\n"
"BTRFS_SUPER_MAGIC     0x9123683e\n"
"BTRFS_TEST_MAGIC      0x73727279\n"
"CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */\n"
"CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */\n"
"CIFS_MAGIC_NUMBER     0xff534d42\n"
"CODA_SUPER_MAGIC      0x73757245\n"
"COH_SUPER_MAGIC       0x012ff7b7\n"
"CRAMFS_MAGIC          0x28cd3d45\n"
"DEBUGFS_MAGIC         0x64626720\n"
"DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */\n"
"DEVPTS_SUPER_MAGIC    0x1cd1\n"
"ECRYPTFS_SUPER_MAGIC  0xf15f\n"
"EFIVARFS_MAGIC        0xde5e81e4\n"
"EFS_SUPER_MAGIC       0x00414a53\n"
"EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */\n"
"EXT2_OLD_SUPER_MAGIC  0xef51\n"
"EXT2_SUPER_MAGIC      0xef53\n"
"EXT3_SUPER_MAGIC      0xef53\n"
"EXT4_SUPER_MAGIC      0xef53\n"
"F2FS_SUPER_MAGIC      0xf2f52010\n"
"FUSE_SUPER_MAGIC      0x65735546\n"
"FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */\n"
"HFS_SUPER_MAGIC       0x4244\n"
"HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"HPFS_SUPER_MAGIC      0xf995e849\n"
"HUGETLBFS_MAGIC       0x958458f6\n"
"ISOFS_SUPER_MAGIC     0x9660\n"
"JFFS2_SUPER_MAGIC     0x72b6\n"
"JFS_SUPER_MAGIC       0x3153464a\n"
"MINIX_SUPER_MAGIC     0x137f     /* original minix FS */\n"
"MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */\n"
"MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */\n"
"MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */\n"
"MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */\n"
"MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */\n"
"MSDOS_SUPER_MAGIC     0x4d44\n"
"MTD_INODE_FS_MAGIC    0x11307854\n"
"NCP_SUPER_MAGIC       0x564c\n"
"NFS_SUPER_MAGIC       0x6969\n"
"NILFS_SUPER_MAGIC     0x3434\n"
"NSFS_MAGIC            0x6e736673\n"
"NTFS_SB_MAGIC         0x5346544e\n"
"OCFS2_SUPER_MAGIC     0x7461636f\n"
"OPENPROM_SUPER_MAGIC  0x9fa1\n"
"OVERLAYFS_SUPER_MAGIC 0x794c7630\n"
"PIPEFS_MAGIC          0x50495045\n"
"PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */\n"
"PSTOREFS_MAGIC        0x6165676c\n"
"QNX4_SUPER_MAGIC      0x002f\n"
"QNX6_SUPER_MAGIC      0x68191122\n"
"RAMFS_MAGIC           0x858458f6\n"
"REISERFS_SUPER_MAGIC  0x52654973\n"
"ROMFS_MAGIC           0x7275\n"
"SECURITYFS_MAGIC      0x73636673\n"
"SELINUX_MAGIC         0xf97cff8c\n"
"SMACK_MAGIC           0x43415d53\n"
"SMB_SUPER_MAGIC       0x517b\n"
"SMB2_MAGIC_NUMBER     0xfe534d42\n"
"SOCKFS_MAGIC          0x534f434b\n"
"SQUASHFS_MAGIC        0x73717368\n"
"SYSFS_MAGIC           0x62656572\n"
"SYSV2_SUPER_MAGIC     0x012ff7b6\n"
"SYSV4_SUPER_MAGIC     0x012ff7b5\n"
"TMPFS_MAGIC           0x01021994\n"
"TRACEFS_MAGIC         0x74726163\n"
"UDF_SUPER_MAGIC       0x15013346\n"
"UFS_MAGIC             0x00011954\n"
"USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"V9FS_MAGIC            0x01021997\n"
"VXFS_SUPER_MAGIC      0xa501fcf5\n"
"XENFS_SUPER_MAGIC     0xabba1974\n"
"XENIX_SUPER_MAGIC     0x012ff7b4\n"
"XFS_SUPER_MAGIC       0x58465342\n"
"_XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */\n"
msgstr ""
"   ADFS_SUPER_MAGIC      0xadf5\n"
"   AFFS_SUPER_MAGIC      0xADFF\n"
"   BDEVFS_MAGIC          0x62646576\n"
"   BEFS_SUPER_MAGIC      0x42465331\n"
"   BFS_MAGIC             0x1BADFACE\n"
"   BINFMTFS_MAGIC        0x42494e4d\n"
"   BTRFS_SUPER_MAGIC     0x9123683E\n"
"   CGROUP_SUPER_MAGIC    0x27e0eb\n"
"   CIFS_MAGIC_NUMBER     0xFF534D42\n"
"   CODA_SUPER_MAGIC      0x73757245\n"
"   COH_SUPER_MAGIC       0x012FF7B7\n"
"   CRAMFS_MAGIC          0x28cd3d45\n"
"   DEBUGFS_MAGIC         0x64626720\n"
"   DEVFS_SUPER_MAGIC     0x1373\n"
"   DEVPTS_SUPER_MAGIC    0x1cd1\n"
"   EFIVARFS_MAGIC        0xde5e81e4\n"
"   EFS_SUPER_MAGIC       0x00414A53\n"
"   EXT_SUPER_MAGIC       0x137D\n"
"   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
"   EXT2_SUPER_MAGIC      0xEF53\n"
"   EXT3_SUPER_MAGIC      0xEF53\n"
"   EXT4_SUPER_MAGIC      0xEF53\n"
"   FUSE_SUPER_MAGIC      0x65735546\n"
"   FUTEXFS_SUPER_MAGIC   0xBAD1DEA\n"
"   HFS_SUPER_MAGIC       0x4244\n"
"   HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"   HPFS_SUPER_MAGIC      0xF995E849\n"
"   HUGETLBFS_MAGIC       0x958458f6\n"
"   ISOFS_SUPER_MAGIC     0x9660\n"
"   JFFS2_SUPER_MAGIC     0x72b6\n"
"   JFS_SUPER_MAGIC       0x3153464a\n"
"   MINIX_SUPER_MAGIC     0x137F /* オリジナルの minix */\n"
"   MINIX_SUPER_MAGIC2    0x138F /* 30 文字ファイル名の minix */\n"
"   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
"   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 文字ファイル名 */\n"
"   MINIX3_SUPER_MAGIC    0x4d5a /* minix V3 ファイルシステム, 60 文字ファイル名 */\n"
"   MQUEUE_MAGIC          0x19800202\n"
"   MSDOS_SUPER_MAGIC     0x4d44\n"
"   NCP_SUPER_MAGIC       0x564c\n"
"   NFS_SUPER_MAGIC       0x6969\n"
"   NILFS_SUPER_MAGIC     0x3434\n"
"   NTFS_SB_MAGIC         0x5346544e\n"
"   OPENPROM_SUPER_MAGIC  0x9fa1\n"
"   PIPEFS_MAGIC          0x50495045\n"
"   PROC_SUPER_MAGIC      0x9fa0\n"
"   PSTOREFS_MAGIC        0x6165676C\n"
"   QNX4_SUPER_MAGIC      0x002f\n"
"   QNX6_SUPER_MAGIC      0x68191122\n"
"   RAMFS_MAGIC           0x858458f6\n"
"   REISERFS_SUPER_MAGIC  0x52654973\n"
"   ROMFS_MAGIC           0x7275\n"
"   SELINUX_MAGIC         0xf97cff8c\n"
"   SMACK_MAGIC           0x43415d53\n"
"   SMB_SUPER_MAGIC       0x517B\n"
"   SOCKFS_MAGIC          0x534F434B\n"
"   SQUASHFS_MAGIC        0x73717368\n"
"   SYSFS_MAGIC           0x62656572\n"
"   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
"   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
"   TMPFS_MAGIC           0x01021994\n"
"   UDF_SUPER_MAGIC       0x15013346\n"
"   UFS_MAGIC             0x00011954\n"
"   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"   V9FS_MAGIC            0x01021997\n"
"   VXFS_SUPER_MAGIC      0xa501FCF5\n"
"   XENFS_SUPER_MAGIC     0xabba1974\n"
"   XENIX_SUPER_MAGIC     0x012FF7B4\n"
"   XFS_SUPER_MAGIC       0x58465342\n"
"   _XIAFS_SUPER_MAGIC    0x012FD16D\n"

#. type: Plain text
#: build/C/man2/statfs.2:167
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h>, "
"and some are hardcoded in kernel sources."
msgstr ""
"これらの MAGIC 定数のほとんどは I</usr/include/linux/magic.h> で定義されてお"
"り、いくつかはカーネルソースで直接書かれている。"

#.  XXX Keep this list in sync with statvfs(3)
#. type: Plain text
#: build/C/man2/statfs.2:173
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid ""
"The I<f_flags> field is a bit mask indicating mount options for the "
"filesystem.  It contains zero or more of the following bits:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man2/statfs.2:173 build/C/man3/statvfs.3:85
#, no-wrap
msgid "B<ST_MANDLOCK>"
msgstr "B<ST_MANDLOCK>"

#. type: Plain text
#: build/C/man2/statfs.2:177 build/C/man3/statvfs.3:89
msgid "Mandatory locking is permitted on the filesystem (see B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:177 build/C/man3/statvfs.3:89
#, no-wrap
msgid "B<ST_NOATIME>"
msgstr "B<ST_NOATIME>"

#. type: Plain text
#: build/C/man2/statfs.2:181 build/C/man3/statvfs.3:93
msgid "Do not update access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:181 build/C/man3/statvfs.3:93
#, no-wrap
msgid "B<ST_NODEV>"
msgstr "B<ST_NODEV>"

#. type: Plain text
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:96
#, fuzzy
#| msgid "Do not allow access to devices (special files) on this filesystem."
msgid "Disallow access to device special files on this filesystem."
msgstr ""
"このファイルシステムのデバイス (スペシャルファイル) へのアクセスを許可しな"
"い。"

#. type: TP
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:96
#, no-wrap
msgid "B<ST_NODIRATIME>"
msgstr "B<ST_NODIRATIME>"

#. type: Plain text
#: build/C/man2/statfs.2:188 build/C/man3/statvfs.3:100
msgid "Do not update directory access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:188 build/C/man3/statvfs.3:100
#, no-wrap
msgid "B<ST_NOEXEC>"
msgstr "B<ST_NOEXEC>"

#. type: Plain text
#: build/C/man2/statfs.2:191 build/C/man3/statvfs.3:103
#, fuzzy
#| msgid "Do not allow programs to be executed from this filesystem."
msgid "Execution of programs is disallowed on this filesystem."
msgstr "このファイルシステムにあるプログラムの実行を許可しない。"

#. type: TP
#: build/C/man2/statfs.2:191 build/C/man3/statvfs.3:103
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr "B<ST_NOSUID>"

#. type: Plain text
#: build/C/man2/statfs.2:196 build/C/man3/statvfs.3:108
#, fuzzy
#| msgid ""
#| "Do not honor set-user-ID and set-group-ID bits when executing programs "
#| "from this filesystem."
msgid ""
"The set-user-ID and set-group-ID bits are ignored by B<exec>(3)  for "
"executable files on this filesystem"
msgstr ""
"このファイルシステムのプログラムを実行するときに、 set-user-ID ビットと set-"
"group-ID ビットを無視する。"

#. type: TP
#: build/C/man2/statfs.2:196 build/C/man3/statvfs.3:108
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr "B<ST_RDONLY>"

#. type: Plain text
#: build/C/man2/statfs.2:199 build/C/man3/statvfs.3:111
#, fuzzy
#| msgid "Mount filesystem read-only."
msgid "This filesystem is mounted read-only."
msgstr "ファイルシステムを読み込み専用でマウントする。"

#. type: TP
#: build/C/man2/statfs.2:199 build/C/man3/statvfs.3:111
#, no-wrap
msgid "B<ST_RELATIME>"
msgstr "B<ST_RELATIME>"

#. type: Plain text
#: build/C/man2/statfs.2:203 build/C/man3/statvfs.3:115
msgid "Update atime relative to mtime/ctime; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:203 build/C/man3/statvfs.3:115
#, no-wrap
msgid "B<ST_SYNCHRONOUS>"
msgstr "B<ST_SYNCHRONOUS>"

#. type: Plain text
#: build/C/man2/statfs.2:209 build/C/man3/statvfs.3:121
msgid ""
"Writes are synched to the filesystem immediately (see the description of "
"B<O_SYNC> in B<open>(2))."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:209
#, no-wrap
msgid "B<ST_NOSYMFOLLOW> (since Linux 5.10)"
msgstr "B<ST_NOSYMFOLLOW> (Linux 5.10 以降)"

#.  dab741e0e02bd3c4f5e2e97be74b39df2523fc6e
#. type: Plain text
#: build/C/man2/statfs.2:214
#, fuzzy
#| msgid "Too many symbolic links were found while resolving I<pathname>."
msgid "Symbolic links are not followed when resolving paths; see B<mount>(2)."
msgstr "I<pathname> を解決するまでに辿ったシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/statfs.2:218
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr ""
"I<f_fsid> にどんな値が入るべきなのかは誰も知らない (但し、下記を参照)。"

#. type: Plain text
#: build/C/man2/statfs.2:220
msgid "Fields that are undefined for a particular filesystem are set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:224
msgid ""
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr "B<fstatfs>()  は、ディスクリプター I<fd> で参照されるオープンされたファイルについて、同じ情報を返す。"

#. type: Plain text
#: build/C/man2/statfs.2:237
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statfs>()  の場合)  I<path> のディレクトリ部分に検索許可が与えられていな"
"い (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/statfs.2:242
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatfs>()  の場合)  I<fd> は有効なオープンされたファイルディスクリプター"
"ではない。"

#. type: Plain text
#: build/C/man2/statfs.2:248
msgid "I<buf> or I<path> points to an invalid address."
msgstr "I<buf> または I<path> が不正なアドレスを指している。"

#. type: Plain text
#: build/C/man2/statfs.2:252
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr "呼び出しがシグナルで中断された。 B<signal>(7) 参照。"

#. type: TP
#: build/C/man2/statfs.2:252 build/C/man3/statvfs.3:156 build/C/man4/fuse.4:482
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/statfs.2:255 build/C/man3/statvfs.3:159
msgid "An I/O error occurred while reading from the filesystem."
msgstr "ファイルシステムからの読み込みの間に I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/statfs.2:260
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""
"(B<statfs>()  の場合)  I<path> を解決するのに辿るべきシンボリックリンクが多す"
"ぎる。"

#. type: Plain text
#: build/C/man2/statfs.2:265
msgid "(B<statfs>())  I<path> is too long."
msgstr "(B<statfs>()  の場合)  I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man2/statfs.2:271
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr ""
"(B<statfs>()  の場合)  I<path> によって参照されるファイルが存在しない。"

#. type: Plain text
#: build/C/man2/statfs.2:274 build/C/man3/statvfs.3:178
msgid "Insufficient kernel memory was available."
msgstr "十分なカーネルメモリーがない。"

#. type: Plain text
#: build/C/man2/statfs.2:277 build/C/man3/statvfs.3:181
msgid "The filesystem does not support this call."
msgstr "ファイルシステムがこの呼び出しをサポートしていない。"

#. type: Plain text
#: build/C/man2/statfs.2:283
msgid ""
"(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""
"(B<statfs>()  の場合)  I<path> のディレクトリ部分がディレクトリでない。"

#. type: Plain text
#: build/C/man2/statfs.2:286 build/C/man3/statvfs.3:190
msgid "Some values were too large to be represented in the returned struct."
msgstr "いくつかの値が大き過ぎて、返り値の構造体で表現できない。"

#. type: Plain text
#: build/C/man2/statfs.2:292
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""
"Linux 固有である。 Linux の B<statfs>()  は 4.4BSD のものに影響を受けてい"
"る。 (しかし同じ構造体を使用しているわけではない)"

#. type: Plain text
#: build/C/man2/statfs.2:304
msgid ""
"The I<__fsword_t> type used for various fields in the I<statfs> structure "
"definition is a glibc internal type, not intended for public use.  This "
"leaves the programmer in a bit of a conundrum when trying to copy or compare "
"these fields to local variables in a program.  Using I<unsigned\\ int> for "
"such variables suffices on most systems."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:326
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""
"元々の Linux の B<statfs>() と B<fstatfs>() システムコールは\n"
"非常に大きなファイルサイズを念頭に入れて設計されていなかった。\n"
"その後、Linux 2.6 で、新しい構造体 I<statfs64> を使用する\n"
"新しいシステムコール B<statfs64>() と B<fstatfs64>() が追加された。\n"
"新しい構造体は元の I<statfs> 構造体と同じフィールドを持つが、\n"
"いろいろなフィールドのサイズが大きなファイルサイズに対応できるように\n"
"増やされている。 glibc の B<statfs>() と B<fstatfs>() のラッパー関数は\n"
"カーネルによるこれらの違いを吸収している。"

#. type: Plain text
#: build/C/man2/statfs.2:331
msgid ""
"Some systems have only I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""
"I<E<lt>sys/vfs.hE<gt>> しか持たないシステムもあり、 I<E<lt>sys/statfs."
"hE<gt>> も持っているシステムもある。 前者は後者をインクルードするので、 前者"
"をインクルードするのが良いと考えられる。"

#. type: Plain text
#: build/C/man2/statfs.2:341
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""
"LSB ではライブラリコール B<statfs>(), B<fstatfs>()  を非推奨として、代わりに "
"B<statvfs>(2), B<fstatvfs>(2)  を使うように指示している。"

#. type: SS
#: build/C/man2/statfs.2:341
#, no-wrap
msgid "The f_fsid field"
msgstr "f_fsid フィールド"

#. type: Plain text
#: build/C/man2/statfs.2:366
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in I<E<lt>sys/vfs."
"hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> is defined as "
"I<struct { int val[2]; }>.  The same holds for FreeBSD, except that it uses "
"the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""
"Solaris, Irix, POSIX にはシステムコール B<statvfs>(2)  があり、 I<struct "
"statvfs> を返す (I<E<lt>sys/statvfs.hE<gt>> で定義されている)。 この構造体に"
"は、 I<unsigned long> I<f_fsid> が含まれている。 Linux, SunOS, HP-UX, 4.4BSD "
"にはシステムコール B<statfs>()  があり、 I<struct statfs> を返す (I<E<lt>sys/"
"vfs.hE<gt>> で定義されている)。 この構造体には I<fsid_t> I<f_fsid>, が含まれ"
"ており、 I<fsid_t> は I<struct { int val[2]; }> と定義されている。 FreeBSD で"
"も同じであるが、インクルードファイル I<E<lt>sys/mount.hE<gt>> を使う。"

#. type: Plain text
#: build/C/man2/statfs.2:379
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when NFS-"
"exported, and giving it out is a security concern."
msgstr ""
"I<f_fsid> はあるランダムな値を持ち、 (I<f_fsid>,I<ino>)  という 1 組の値で"
"ファイルを一意に決定できるようにする、 というのが基本的な考え方である。 いく"
"つかの OS では、デバイス番号 (の変種) を使ったり、 デバイス番号とファイルシス"
"テムタイプを組み合わせて使ったりしている。 OS の中には I<f_fsid> フィールドの"
"取得をスーパーユーザーに限定しているものもある (非特権ユーザーが取得すると 0 "
"となる)。 NFS でエクスポートされる場合、 このフィールドがファイルシステムの"
"ファイルハンドルで使われており、 この値を提供するとセキュリティ上の問題があ"
"る。"

#. type: Plain text
#: build/C/man2/statfs.2:385
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument "
"to the B<sysfs>(2)  system call."
msgstr ""
"いくつかの OS では、 I<fsid> を B<sysfs>(2)  システムコールの第 2 引数とし"
"て使用できる。"

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: build/C/man2/statfs.2:394
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""
"Linux 2.6.38 から Linux 3.1 までは (3.1 を含む)、 B<fstatfs>() は B<pipe>(2) "
"で作成されたファイルディスクリプターに対してはエラー B<ENOSYS> で失敗してい"
"た。"

#. type: Plain text
#: build/C/man2/statfs.2:398
msgid "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"
msgstr "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"

#. type: TH
#: build/C/man2/statx.2:30
#, no-wrap
msgid "STATX"
msgstr "STATX"

#. type: Plain text
#: build/C/man2/statx.2:33
#, fuzzy
#| msgid "ustat - get filesystem statistics"
msgid "statx - get file status (extended)"
msgstr "ustat - ファイルシステム (file system) の統計を得る"

#. type: Plain text
#: build/C/man2/statx.2:39
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"

#. type: Plain text
#: build/C/man2/statx.2:42
#, no-wrap
msgid ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"
msgstr ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"

#. type: Plain text
#: build/C/man2/statx.2:48
msgid ""
"This function returns information about a file, storing it in the buffer "
"pointed to by I<statxbuf>.  The returned buffer is a structure of the "
"following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:66
#, fuzzy, no-wrap
#| msgid ""
#| "struct stat {\n"
#| "    dev_t     st_dev;         /* ID of device containing file */\n"
#| "    ino_t     st_ino;         /* inode number */\n"
#| "    mode_t    st_mode;        /* protection */\n"
#| "    nlink_t   st_nlink;       /* number of hard links */\n"
#| "    uid_t     st_uid;         /* user ID of owner */\n"
#| "    gid_t     st_gid;         /* group ID of owner */\n"
#| "    dev_t     st_rdev;        /* device ID (if special file) */\n"
#| "    off_t     st_size;        /* total size, in bytes */\n"
#| "    blksize_t st_blksize;     /* blocksize for filesystem I/O */\n"
#| "    blkcnt_t  st_blocks;      /* number of 512B blocks allocated */\n"
msgid ""
"struct statx {\n"
"    __u32 stx_mask;        /* Mask of bits indicating\n"
"                              filled fields */\n"
"    __u32 stx_blksize;     /* Block size for filesystem I/O */\n"
"    __u64 stx_attributes;  /* Extra file attribute indicators */\n"
"    __u32 stx_nlink;       /* Number of hard links */\n"
"    __u32 stx_uid;         /* User ID of owner */\n"
"    __u32 stx_gid;         /* Group ID of owner */\n"
"    __u16 stx_mode;        /* File type and mode */\n"
"    __u64 stx_ino;         /* Inode number */\n"
"    __u64 stx_size;        /* Total size in bytes */\n"
"    __u64 stx_blocks;      /* Number of 512B blocks allocated */\n"
"    __u64 stx_attributes_mask;\n"
"                           /* Mask to show what\\(aqs supported\n"
"                              in stx_attributes */\n"
msgstr ""
"struct stat {\n"
"    dev_t     st_dev;     /* ファイルがあるデバイスの ID */\n"
"    ino_t     st_ino;     /* inode 番号 */\n"
"    mode_t    st_mode;    /* アクセス保護 */\n"
"    nlink_t   st_nlink;   /* ハードリンクの数 */\n"
"    uid_t     st_uid;     /* 所有者のユーザー ID */\n"
"    gid_t     st_gid;     /* 所有者のグループ ID */\n"
"    dev_t     st_rdev;    /* デバイス ID (特殊ファイルの場合) */\n"
"    off_t     st_size;    /* 全体のサイズ (バイト単位) */\n"
"    blksize_t st_blksize; /* ファイルシステム I/O での\n"
"                             ブロックサイズ */\n"
"    blkcnt_t  st_blocks;  /* 割り当てられた 512B のブロック数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/statx.2:72
#, no-wrap
msgid ""
"    /* The following fields are file timestamps */\n"
"    struct statx_timestamp stx_atime;  /* Last access */\n"
"    struct statx_timestamp stx_btime;  /* Creation */\n"
"    struct statx_timestamp stx_ctime;  /* Last status change */\n"
"    struct statx_timestamp stx_mtime;  /* Last modification */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:77
#, no-wrap
msgid ""
"    /* If this file represents a device, then the next two\n"
"       fields contain the ID of the device */\n"
"    __u32 stx_rdev_major;  /* Major ID */\n"
"    __u32 stx_rdev_minor;  /* Minor ID */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:83
#, no-wrap
msgid ""
"    /* The next two fields contain the ID of the device\n"
"       containing the filesystem where the file resides */\n"
"    __u32 stx_dev_major;   /* Major ID */\n"
"    __u32 stx_dev_minor;   /* Minor ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:87
msgid "The file timestamps are structures of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:94
#, no-wrap
msgid ""
"struct statx_timestamp {\n"
"    __s64 tv_sec;    /* Seconds since the Epoch (UNIX time) */\n"
"    __u32 tv_nsec;   /* Nanoseconds since tv_sec */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:98
msgid "(Note that reserved space and padding is omitted.)"
msgstr ""

#. type: SS
#: build/C/man2/statx.2:98
#, no-wrap
msgid "Invoking statxR<():>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:107
#, fuzzy
#| msgid ""
#| "These functions return information about a file, in the buffer pointed to "
#| "by I<stat>.  No permissions are required on the file itself, but\\(emin "
#| "the case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
#| "permission is required on all of the directories in I<pathname> that lead "
#| "to the file."
msgid ""
"To access a file's status, no permissions are required on the file itself, "
"but in the case of B<statx>()  with a pathname, execute (search) permission "
"is required on all of the directories in I<pathname> that lead to the file."
msgstr ""
"これらの関数は、ファイルについての情報を I<stat> が指すバッファーに格納して返"
"す。 ファイルそのものに対するアクセス許可は必要としないが、 \\(emB<stat>(), "
"B<fstatat>(), B<lstat>() の場合には \\(emそのファイルへ至る I<pathname> を構"
"成する全てのディレクトリに対する実行 (検索) 許可が必要である。"

#. type: Plain text
#: build/C/man2/statx.2:115
msgid ""
"B<statx>()  uses I<pathname>, I<dirfd>, and I<flags> to identify the target "
"file in one of the following ways:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:115
#, no-wrap
msgid "An absolute pathname"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:124
msgid ""
"If I<pathname> begins with a slash, then it is an absolute pathname that "
"identifies the target file.  In this case, I<dirfd> is ignored."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:124
#, fuzzy, no-wrap
#| msgid "Empty pathname"
msgid "A relative pathname"
msgstr "空のパス名"

#. type: Plain text
#: build/C/man2/statx.2:136
#, fuzzy
#| msgid ""
#| "If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
#| "then I<pathname> is interpreted relative to the current working directory "
#| "of the calling process (like B<stat>())."
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is B<AT_FDCWD>, then I<pathname> is a relative pathname that is "
"interpreted relative to the process's current working directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> の場合、 "
"(B<stat>(2) と同様に) I<pathname> は呼び出したプロセスのカレントワーキング"
"ディレクトリに対する相対パスと解釈される。"

#. type: TP
#: build/C/man2/statx.2:136
#, no-wrap
msgid "A directory-relative pathname"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:147
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is a file descriptor that refers to a directory, then "
"I<pathname> is a relative pathname that is interpreted relative to the "
"directory referred to by I<dirfd>."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:147
#, fuzzy, no-wrap
#| msgid "description"
msgid "By file descriptor"
msgstr "説明"

#. type: Plain text
#: build/C/man2/statx.2:158
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is specified "
"in I<flags> (see below), then the target file is the one referred to by the "
"file descriptor I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:164
msgid ""
"I<flags> can be used to influence a pathname-based lookup.  A value for "
"I<flags> is constructed by ORing together zero or more of the following "
"constants:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:164
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr "B<AT_EMPTY_PATH>"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: build/C/man2/statx.2:178
#, fuzzy
#| msgid ""
#| "If I<pathname> is an empty string, operate on the file referred to by "
#| "I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
#| "flag).  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
#| "working directory.  In this case, I<dirfd> can refer to any type of file, "
#| "not just a directory.  This flag is Linux-specific; define B<_GNU_SOURCE> "
#| "to obtain its definition."
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory."
msgstr ""
"I<pathname> が空文字列の場合、 I<dirfd> が参照するファイルに対して操作を行う "
"(I<dirfd> は B<open>(2) の B<O_PATH> フラグを使って取得できる)。 B<dirfd> が "
"B<AT_FDCWD> の場合、呼び出しはカレントワーキングディレクトリに対して操作を行"
"う。 この場合、 I<dirfd> は、ディレクトリだけでなく、任意のタイプのファイルを"
"参照することができる。 このフラグは Linux 固有であり、その定義を得るには "
"B<_GNU_SOURCE> を定義すること。"

#. type: Plain text
#: build/C/man2/statx.2:184
msgid ""
"If I<dirfd> is B<AT_FDCWD>, the call operates on the current working "
"directory."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:189
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT>"
msgstr "B<AT_NO_AUTOMOUNT>"

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/statx.2:205
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"This flag can be used in tools that scan directories to prevent mass-"
"automounting of a directory of automount points.  The B<AT_NO_AUTOMOUNT> "
"flag has no effect if the mount point has already been mounted over.  This "
"flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""
"I<pathname> がオートマウントポイントとなっているディレクトリの場合、 "
"I<pathname> の最終 (\"basename\") 要素のオートマウントを行わない。 これによ"
"り (マウントされるはずの場所ではなく) オートマウントポイントの属性を取得する"
"ことができる。 このフラグを使うと、 ディレクトリをスキャンするツールがオート"
"マウントポイントのディレクトリを大量にオートマウントしてしまうのを防ぐことが"
"できる。 マウントポイントがすでにマウントされている場合 B<AT_NO_AUTOMOUNT> フ"
"ラグは何の効果もない。 このフラグは Linux 固有であり、その定義を得るには "
"B<_GNU_SOURCE> を定義すること。"

#. type: Plain text
#: build/C/man2/statx.2:212
#, fuzzy
#| msgid ""
#| "If I<pathname> is a symbolic link, do not dereference it: instead return "
#| "information about the link itself, like B<lstat>().  (By default, "
#| "B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>(2)."
msgstr ""
"(B<lstat>() 同様) I<pathname> がシンボリックリンクの場合リンクの展開を行わ"
"ず、 リンク自身の情報を返す (デフォルトでは、 B<fstatat>() は、 B<stat>() と"
"同様に、シンボリックリンクの展開を行う)。"

#. type: Plain text
#: build/C/man2/statx.2:217
msgid ""
"I<flags> can also be used to control what sort of synchronization the kernel "
"will do when querying a file on a remote filesystem.  This is done by ORing "
"in one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:217
#, no-wrap
msgid "B<AT_STATX_SYNC_AS_STAT>"
msgstr "B<AT_STATX_SYNC_AS_STAT>"

#. type: Plain text
#: build/C/man2/statx.2:223
msgid ""
"Do whatever B<stat>(2)  does.  This is the default and is very much "
"filesystem-specific."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:223
#, no-wrap
msgid "B<AT_STATX_FORCE_SYNC>"
msgstr "B<AT_STATX_FORCE_SYNC>"

#. type: Plain text
#: build/C/man2/statx.2:228
msgid ""
"Force the attributes to be synchronized with the server.  This may require "
"that a network filesystem perform a data writeback to get the timestamps "
"correct."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:228
#, no-wrap
msgid "B<AT_STATX_DONT_SYNC>"
msgstr "B<AT_STATX_DONT_SYNC>"

#. type: Plain text
#: build/C/man2/statx.2:235
msgid ""
"Don't synchronize anything, but rather just take whatever the system has "
"cached if possible.  This may mean that the information returned is "
"approximate, but, on a network filesystem, it may not involve a round trip "
"to the server - even if no lease is held."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:243
#, fuzzy
#| msgid ""
#| "The I<flags> argument can be zero or any bitwise OR-ed combination of the "
#| "following constants:"
msgid ""
"The I<mask> argument to B<statx>()  is used to tell the kernel which fields "
"the caller is interested in.  I<mask> is an ORed combination of the "
"following constants:"
msgstr ""
"I<flags> 引数には 0 か以下の定数の組み合わせ (ビット単位の論理和) を指定で"
"きる。"

#. type: tbl table
#: build/C/man2/statx.2:247
#, no-wrap
msgid "STATX_TYPE"
msgstr "STATX_TYPE"

#. type: tbl table
#: build/C/man2/statx.2:247
#, no-wrap
msgid "Want stx_mode & S_IFMT"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:248
#, no-wrap
msgid "STATX_MODE"
msgstr "STATX_MODE"

#. type: tbl table
#: build/C/man2/statx.2:248
#, no-wrap
msgid "Want stx_mode & \\(tiS_IFMT"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:249
#, no-wrap
msgid "STATX_NLINK"
msgstr "STATX_NLINK"

#. type: tbl table
#: build/C/man2/statx.2:249
#, no-wrap
msgid "Want stx_nlink"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:250
#, no-wrap
msgid "STATX_UID"
msgstr "STATX_UID"

#. type: tbl table
#: build/C/man2/statx.2:250
#, no-wrap
msgid "Want stx_uid"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:251
#, no-wrap
msgid "STATX_GID"
msgstr "STATX_GID"

#. type: tbl table
#: build/C/man2/statx.2:251
#, no-wrap
msgid "Want stx_gid"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:252
#, no-wrap
msgid "STATX_ATIME"
msgstr "STATX_ATIME"

#. type: tbl table
#: build/C/man2/statx.2:252
#, no-wrap
msgid "Want stx_atime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:253
#, no-wrap
msgid "STATX_MTIME"
msgstr "STATX_MTIME"

#. type: tbl table
#: build/C/man2/statx.2:253
#, no-wrap
msgid "Want stx_mtime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:254
#, no-wrap
msgid "STATX_CTIME"
msgstr "STATX_CTIME"

#. type: tbl table
#: build/C/man2/statx.2:254
#, no-wrap
msgid "Want stx_ctime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:255
#, no-wrap
msgid "STATX_INO"
msgstr "STATX_INO"

#. type: tbl table
#: build/C/man2/statx.2:255
#, no-wrap
msgid "Want stx_ino"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:256
#, no-wrap
msgid "STATX_SIZE"
msgstr "STATX_SIZE"

#. type: tbl table
#: build/C/man2/statx.2:256
#, no-wrap
msgid "Want stx_size"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:257
#, no-wrap
msgid "STATX_BLOCKS"
msgstr "STATX_BLOCKS"

#. type: tbl table
#: build/C/man2/statx.2:257
#, no-wrap
msgid "Want stx_blocks"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:258
#, no-wrap
msgid "STATX_BASIC_STATS"
msgstr "STATX_BASIC_STATS"

#. type: tbl table
#: build/C/man2/statx.2:258
#, no-wrap
msgid "[All of the above]"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:259
#, no-wrap
msgid "STATX_BTIME"
msgstr "STATX_BTIME"

#. type: tbl table
#: build/C/man2/statx.2:259
#, no-wrap
msgid "Want stx_btime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:260
#, no-wrap
msgid "STATX_ALL"
msgstr "STATX_ALL"

#. type: tbl table
#: build/C/man2/statx.2:260
#, no-wrap
msgid "[All currently available fields]"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:285
msgid ""
"Note that, in general, the kernel does I<not> reject values in I<mask> other "
"than the above.  (For an exception, see B<EINVAL> in errors.)  Instead, it "
"simply informs the caller which values are supported by this kernel and "
"filesystem via the I<statx.stx_mask> field.  Therefore, I<do not> simply set "
"I<mask> to B<UINT_MAX> (all bits set), as one or more bits may, in the "
"future, be used to specify an extension to the buffer."
msgstr ""

#. type: SS
#: build/C/man2/statx.2:285
#, no-wrap
msgid "The returned information"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:299
msgid ""
"The status information for the target file is returned in the I<statx> "
"structure pointed to by I<statxbuf>.  Included in this is I<stx_mask> which "
"indicates what other information has been returned.  I<stx_mask> has the "
"same format as the I<mask> argument and bits are set in it to indicate which "
"fields have been filled in."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:308
msgid ""
"It should be noted that the kernel may return fields that weren't requested "
"and may fail to return fields that were requested, depending on what the "
"backing filesystem supports.  (Fields that are given values despite being "
"unrequested can just be ignored.)  In either case, I<stx_mask> will not be "
"equal I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:316
msgid ""
"If a filesystem does not support a field or if it has an unrepresentable "
"value (for instance, a file with an exotic type), then the mask bit "
"corresponding to that field will be cleared in I<stx_mask> even if the user "
"asked for it and a dummy value will be filled in for compatibility purposes "
"if one is available (e.g., a dummy UID and GID may be specified to mount "
"under some circumstances)."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:321
msgid ""
"A filesystem may also fill in fields that the caller didn't ask for if it "
"has values for them available and the information is available at no extra "
"cost.  If this happens, the corresponding bits will be set in I<stx_mask>."
msgstr ""

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: build/C/man2/statx.2:346
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<statx> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<stx_mode> or "
"I<stx_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<stx_mode> together with the "
"new I<stx_uid>, or the old I<stx_uid> together with the new I<stx_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:352
msgid ""
"Apart from I<stx_mask> (which is described above), the fields in the "
"I<statx> structure are:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:352
#, no-wrap
msgid "I<stx_blksize>"
msgstr "I<stx_blksize>"

#. type: Plain text
#: build/C/man2/statx.2:357
#, fuzzy
#| msgid ""
#| "The I<st_blksize> field gives the \"preferred\" blocksize for efficient "
#| "filesystem I/O.  (Writing to a file in smaller chunks may cause an "
#| "inefficient read-modify-rewrite.)"
msgid ""
"The \"preferred\" block size for efficient filesystem I/O.  (Writing to a "
"file in smaller chunks may cause an inefficient read-modify-rewrite.)"
msgstr ""
"I<st_blksize> フィールドは、効率的にファイルシステム I/O ができる「好まし"
"い」 ブロックサイズを示す (もっと小さい単位でファイルに書き込みを行うと、 読"
"み出し--修正--再書き込みといった非効率な動作になってしまうかもしれない)。"

#. type: TP
#: build/C/man2/statx.2:357
#, no-wrap
msgid "I<stx_attributes>"
msgstr "I<stx_attributes>"

#. type: Plain text
#: build/C/man2/statx.2:360
msgid ""
"Further status information about the file (see below for more information)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:360
#, no-wrap
msgid "I<stx_nlink>"
msgstr "I<stx_nlink>"

#. type: Plain text
#: build/C/man2/statx.2:363
msgid "The number of hard links on a file."
msgstr "ファイルのハードリンク数。"

#. type: TP
#: build/C/man2/statx.2:363
#, no-wrap
msgid "I<stx_uid>"
msgstr "I<stx_uid>"

#. type: TP
#: build/C/man2/statx.2:366
#, no-wrap
msgid "I<stx_gid>"
msgstr "I<stx_gid>"

#. type: TP
#: build/C/man2/statx.2:369
#, no-wrap
msgid "I<stx_mode>"
msgstr "I<stx_mode>"

#. type: Plain text
#: build/C/man2/statx.2:375
msgid "The file type and mode.  See B<inode>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:375
#, no-wrap
msgid "I<stx_ino>"
msgstr "I<stx_ino>"

#. type: Plain text
#: build/C/man2/statx.2:378
msgid "The inode number of the file."
msgstr "ファイルの inode 番号。"

#. type: TP
#: build/C/man2/statx.2:378
#, no-wrap
msgid "I<stx_size>"
msgstr "I<stx_size>"

#. type: Plain text
#: build/C/man2/statx.2:383
#, fuzzy
#| msgid ""
#| "The I<st_size> field gives the size of the file (if it is a regular file "
#| "or a symbolic link) in bytes.  The size of a symbolic link is the length "
#| "of the pathname it contains, without a terminating null byte."
msgid ""
"The size of the file (if it is a regular file or a symbolic link) in bytes.  "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""
"I<st_size> フィールドは、(通常のファイルかシンボリックリンクの場合に)\n"
"ファイルの大きさをバイト単位で示す。 シンボリックリンクの大きさは、\n"
"シンボリックリンクに含まれている パス名の長さ (終端のヌルバイトは含まない)\n"
"である。"

#. type: TP
#: build/C/man2/statx.2:383
#, no-wrap
msgid "I<stx_blocks>"
msgstr "I<stx_blocks>"

#. type: Plain text
#: build/C/man2/statx.2:389
#, fuzzy
#| msgid ""
#| "The I<st_blocks> field indicates the number of blocks allocated to the "
#| "file, 512-byte units.  (This may be smaller than I<st_size>/512 when the "
#| "file has holes.)"
msgid ""
"The number of blocks allocated to the file on the medium, in 512-byte "
"units.  (This may be smaller than I<stx_size>/512 when the file has holes.)"
msgstr ""
"I<st_blocks> フィールドは、ファイルの大きさを 512 バイトのブロックサイズ単位"
"で示す フィールドは、ファイルに割り当てされたブロック数を 512 バイト単位で示"
"す。 (ファイルに穴があるような場合、この値は I<st_size>/512 より小さくなるこ"
"ともある)。"

#. type: TP
#: build/C/man2/statx.2:389
#, no-wrap
msgid "I<stx_attributes_mask>"
msgstr "I<stx_attributes_mask>"

#. type: Plain text
#: build/C/man2/statx.2:394
msgid ""
"A mask indicating which bits in I<stx_attributes> are supported by the VFS "
"and the filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:394
#, no-wrap
msgid "I<stx_atime>"
msgstr "I<stx_atime>"

#. type: Plain text
#: build/C/man2/statx.2:397
msgid "The file's last access timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:397
#, no-wrap
msgid "I<stx_btime>"
msgstr "I<stx_btime>"

#. type: Plain text
#: build/C/man2/statx.2:400
msgid "The file's creation timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:400
#, no-wrap
msgid "I<stx_ctime>"
msgstr "I<stx_ctime>"

#. type: Plain text
#: build/C/man2/statx.2:403
msgid "The file's last status change timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:403
#, no-wrap
msgid "I<stx_mtime>"
msgstr "I<stx_mtime>"

#. type: Plain text
#: build/C/man2/statx.2:406
msgid "The file's last modification timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:406
#, no-wrap
msgid "I<stx_dev_major> and I<stx_dev_minor>"
msgstr "I<stx_dev_major> と I<stx_dev_minor>"

#. type: Plain text
#: build/C/man2/statx.2:409
#, fuzzy
#| msgid ""
#| "The I<st_rdev> field describes the device that this file (inode) "
#| "represents."
msgid "The device on which this file (inode) resides."
msgstr "I<st_rdev> フィールドは、このファイル (inode) が表すデバイスを示す。"

#. type: TP
#: build/C/man2/statx.2:409
#, no-wrap
msgid "I<stx_rdev_major> and I<stx_rdev_minor>"
msgstr "I<stx_rdev_major> と I<stx_rdev_minor>"

#. type: Plain text
#: build/C/man2/statx.2:413
msgid ""
"The device that this file (inode) represents if the file is of block or "
"character device type."
msgstr ""

#. type: SS
#: build/C/man2/statx.2:417
#, no-wrap
msgid "File attributes"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:429
msgid ""
"The I<stx_attributes> field contains a set of ORed flags that indicate "
"additional attributes of the file.  Note that any attribute that is not "
"indicated as supported by I<stx_attributes_mask> has no usable value here.  "
"The bits in I<stx_attributes_mask> correspond bit-by-bit to "
"I<stx_attributes>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:431
#, fuzzy
#| msgid "These fields are defined as follows:"
msgid "The flags are as follows:"
msgstr "これらのフィールドは、次のように定義されている。"

#. type: TP
#: build/C/man2/statx.2:431
#, no-wrap
msgid "B<STATX_ATTR_COMPRESSED>"
msgstr "B<STATX_ATTR_COMPRESSED>"

#. type: Plain text
#: build/C/man2/statx.2:435
msgid ""
"The file is compressed by the filesystem and may take extra resources to "
"access."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:435
#, no-wrap
msgid "B<STATX_ATTR_IMMUTABLE>"
msgstr "B<STATX_ATTR_IMMUTABLE>"

#. type: Plain text
#: build/C/man2/statx.2:441
msgid ""
"The file cannot be modified: it cannot be deleted or renamed, no hard links "
"can be created to this file and no data can be written to it.  See "
"B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:441
#, no-wrap
msgid "B<STATX_ATTR_APPEND>"
msgstr "B<STATX_ATTR_APPEND>"

#. type: Plain text
#: build/C/man2/statx.2:448
msgid ""
"The file can only be opened in append mode for writing.  Random access "
"writing is not permitted.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:448
#, no-wrap
msgid "B<STATX_ATTR_NODUMP>"
msgstr "B<STATX_ATTR_NODUMP>"

#. type: Plain text
#: build/C/man2/statx.2:455
msgid ""
"File is not a candidate for backup when a backup program such as B<dump>(8)  "
"is run.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:455
#, no-wrap
msgid "B<STATX_ATTR_ENCRYPTED>"
msgstr "B<STATX_ATTR_ENCRYPTED>"

#. type: Plain text
#: build/C/man2/statx.2:458
msgid "A key is required for the file to be encrypted by the filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:458
#, no-wrap
msgid "B<STATX_ATTR_VERITY> (since Linux 5.5)"
msgstr "B<STATX_ATTR_VERITY> (Linux 5.5 以降)"

#.  commit 3ad2522c64cff1f5aebb987b00683268f0cc7c29
#. type: Plain text
#: build/C/man2/statx.2:465
msgid ""
"The file has fs-verity enabled.  It cannot be written to, and all reads from "
"it will be verified against a cryptographic hash that covers the entire file "
"(e.g., via a Merkle tree)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:465
#, no-wrap
msgid "B<STATX_ATTR_DAX> (since Linux 5.8)"
msgstr "B<STATX_ATTR_DAX> (Linux 5.8 以降)"

#. type: Plain text
#: build/C/man2/statx.2:471
msgid ""
"The file is in the DAX (cpu direct access) state.  DAX state attempts to "
"minimize software cache effects for both I/O and memory mappings of this "
"file.  It requires a file system which has been configured to support DAX."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:475
msgid ""
"DAX generally assumes all accesses are via CPU load / store instructions "
"which can minimize overhead for small accesses, but may adversely affect CPU "
"utilization for large transfers."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:478
msgid ""
"File I/O is done directly to/from user-space buffers and memory mapped I/O "
"may be performed with direct memory mappings that bypass the kernel page "
"cache."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:485
msgid ""
"While the DAX property tends to result in data being transferred "
"synchronously, it does not give the same guarantees as the B<O_SYNC> flag "
"(see B<open>(2)), where data and the necessary metadata are transferred "
"together."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:495
msgid ""
"A DAX file may support being mapped with the B<MAP_SYNC> flag, which enables "
"a program to use CPU cache flush instructions to persist CPU store "
"operations without an explicit B<fsync>(2).  See B<mmap>(2)  for more "
"information."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:512
#, fuzzy
#| msgid "I<dirfd> is not a valid file descriptor."
msgid "I<dirfd> is not a valid open file descriptor."
msgstr "I<dirfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/statx.2:519
#, fuzzy
#| msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgid ""
"I<pathname> or I<statxbuf> is NULL or points to a location outside the "
"process's accessible address space."
msgstr "fsnameI< と >buf のどちらかがアクセス可能なアドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/statx.2:530
msgid ""
"Reserved flag specified in I<mask>.  (Currently, there is one such flag, "
"designated by the constant B<STATX__RESERVED>, with the value 0x80000000U.)"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:533
#, fuzzy
#| msgid "Too many symbolic links encountered while traversing the path."
msgid "Too many symbolic links encountered while traversing the pathname."
msgstr "パスを辿る際に解決すべきシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/statx.2:547
#, fuzzy
#| msgid ""
#| "A component of I<pathname> does not exist, or I<pathname> is an empty "
#| "string."
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty string "
"and B<AT_EMPTY_PATH> was not specified in I<flags>."
msgstr "I<pathname> の構成要素が存在しないか、 I<pathname> が空文字列である。"

#. type: Plain text
#: build/C/man2/statx.2:559
#, fuzzy
#| msgid ""
#| "I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
#| "file other than a directory."
msgid ""
"A component of the path prefix of I<pathname> is not a directory or "
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/statx.2:562
#, fuzzy
#| msgid ""
#| "B<fstatat>()  was added to Linux in kernel 2.6.16; library support was "
#| "added to glibc in version 2.4."
msgid ""
"B<statx>()  was added to Linux in kernel 4.11; library support was added in "
"glibc 2.28."
msgstr ""
"B<fstatat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#. type: Plain text
#: build/C/man2/statx.2:565
msgid "B<statx>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:577
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr "B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), B<symlink>(7)"

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr "STATVFS"

#. type: Plain text
#: build/C/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get filesystem statistics"
msgstr "statvfs, fstatvfs - ファイルシステムの統計を取得する"

#. type: Plain text
#: build/C/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr "B<#include E<lt>sys/statvfs.hE<gt>>"

#. type: Plain text
#: build/C/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr ""
"関数 B<statvfs>()  はマウントされたファイルシステムについての情報を返す。 "
"I<path> はマウントされたファイルシステム中の任意のファイルのパス名である。 "
"I<buf> は、だいたい以下のように定義されている I<statvfs> 構造体へのポインター"
"である:"

#. type: Plain text
#: build/C/man3/statvfs.3:67
#, fuzzy, no-wrap
#| msgid ""
#| "struct statvfs {\n"
#| "    unsigned long  f_bsize;    /* filesystem block size */\n"
#| "    unsigned long  f_frsize;   /* fragment size */\n"
#| "    fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */\n"
#| "    fsblkcnt_t     f_bfree;    /* # free blocks */\n"
#| "    fsblkcnt_t     f_bavail;   /* # free blocks for unprivileged users */\n"
#| "    fsfilcnt_t     f_files;    /* # inodes */\n"
#| "    fsfilcnt_t     f_ffree;    /* # free inodes */\n"
#| "    fsfilcnt_t     f_favail;   /* # free inodes for unprivileged users */\n"
#| "    unsigned long  f_fsid;     /* filesystem ID */\n"
#| "    unsigned long  f_flag;     /* mount flags */\n"
#| "    unsigned long  f_namemax;  /* maximum filename length */\n"
#| "};\n"
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* Filesystem block size */\n"
"    unsigned long  f_frsize;   /* Fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* Size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* Number of free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* Number of free blocks for\n"
"                                  unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* Number of inodes */\n"
"    fsfilcnt_t     f_ffree;    /* Number of free inodes */\n"
"    fsfilcnt_t     f_favail;   /* Number of free inodes for\n"
"                                  unprivileged users */\n"
"    unsigned long  f_fsid;     /* Filesystem ID */\n"
"    unsigned long  f_flag;     /* Mount flags */\n"
"    unsigned long  f_namemax;  /* Maximum filename length */\n"
"};\n"
msgstr ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* ファイルシステムのブロックサイズ */\n"
"    unsigned long  f_frsize;   /* フラグメントサイズ */\n"
"    fsblkcnt_t     f_blocks;   /* ファイルシステムのサイズ (f_frsize 単位) */\n"
"    fsblkcnt_t     f_bfree;    /* 解放されているブロック数 */\n"
"    fsblkcnt_t     f_bafvail;   /* 非特権ユーザー用に解放されているブロック数 */\n"
"    fsfilcnt_t     f_files;    /* inode 数 */\n"
"    fsfilcnt_t     f_ffree;    /* 解放されている inode の数 */\n"
"    fsfilcnt_t     f_favail;   /* 非特権ユーザー用に解放されている inode の数 */\n"
"    unsigned long  f_fsid;     /* ファイルシステム ID */\n"
"    unsigned long  f_flag;     /* マウントフラグ */\n"
"    unsigned long  f_namemax;  /* ファイル名の長さの最大値 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/statvfs.3:78
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in I<E<lt>sys/"
"types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr ""
"ここで、型 I<fsblkcnt_t> と I<fsfilcnt_t> は I<E<lt>sys/types.hE<gt>> で定義"
"されている。 かつて、これらは共に I<unsigned long> であった。"

#.  XXX Keep this list in sync with statfs(2)
#. type: Plain text
#: build/C/man3/statvfs.3:85
msgid ""
"The field I<f_flag> is a bit mask indicating various options that were "
"employed when mounting this filesystem.  It contains zero or more of the "
"following flags:"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:124
msgid ""
"It is unspecified whether all members of the returned struct have meaningful "
"values on all filesystems."
msgstr ""
"返された構造体の全てのメンバが全てのファイルシステムで 意味のある値であるか否"
"かは、指定されていない。"

#. type: Plain text
#: build/C/man3/statvfs.3:128
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""
"B<fstatvfs>()  は、ディスクリプター I<fd> で参照されるオープンされたファイル"
"について、同じ情報を返す。"

#. type: Plain text
#: build/C/man3/statvfs.3:141
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statvfs>()  の場合)  I<path> のディレクトリ部分に検索許可が与えられていな"
"い (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man3/statvfs.3:146
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatvfs>()  の場合)  I<fd> が有効なオープンファイルディスクリプターではな"
"い。"

#. type: Plain text
#: build/C/man3/statvfs.3:152
msgid "I<Buf> or I<path> points to an invalid address."
msgstr "I<buf> または I<path> が無効なアドレスを指している。"

#. type: Plain text
#: build/C/man3/statvfs.3:156
msgid "This call was interrupted by a signal; see B<signal>(7)."
msgstr "この呼び出しがシグナルで中断された。 B<signal>(7) 参照。"

#. type: Plain text
#: build/C/man3/statvfs.3:164
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr "(B<statvfs>()  の場合)  I<path> にシンボリックリンクが多すぎる。"

#. type: Plain text
#: build/C/man3/statvfs.3:169
msgid "(B<statvfs>())  I<path> is too long."
msgstr "(B<statvfs>()  の場合)  I<path> が長すぎる。"

#. type: Plain text
#: build/C/man3/statvfs.3:175
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statvfs>()  の場合)  I<path> で参照されるファイルが存在しない。"

#. type: Plain text
#: build/C/man3/statvfs.3:187
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""
"(B<statvfs>()  の場合)  I<path> のディレクトリ部分がディレクトリでない。"

#. type: tbl table
#: build/C/man3/statvfs.3:201
#, no-wrap
msgid ""
"B<statvfs>(),\n"
"B<fstatvfs>()"
msgstr ""
"B<statvfs>(),\n"
"B<fstatvfs>()"

#. type: Plain text
#: build/C/man3/statvfs.3:205
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/statvfs.3:215
msgid ""
"Only the B<ST_NOSUID> and B<ST_RDONLY> flags of the I<f_flag> field are "
"specified in POSIX.1.  To obtain definitions of the remaining flags, one "
"must define B<_GNU_SOURCE>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:221
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr ""
"Linux カーネルには、このライブラリコールをサポートするために、 B<statfs>(2), "
"B<fstatfs>(2)  システムコールがある。"

#.  glibc commit 3cdaa6adb113a088fdfb87aa6d7747557eccc58d
#. type: Plain text
#: build/C/man3/statvfs.3:237
msgid ""
"In glibc versions before 2.13, B<statvfs>()  populated the bits of the "
"I<f_flag> field by scanning the mount options shown in I</proc/mounts>.  "
"However, starting with Linux 2.6.36, the underlying B<statfs>(2)  system "
"call provides the necessary information via the I<f_flags> field, and since "
"glibc version 2.13, the B<statvfs>()  function will use information from "
"that field rather than scanning I</proc/mounts>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:239
#, fuzzy
#| msgid "The current glibc implementations of"
msgid "The glibc implementations of"
msgstr "現在の glibc の実装において、"

#. type: Plain text
#: build/C/man3/statvfs.3:245
#, no-wrap
msgid ""
"pathconf(path, _PC_REC_XFER_ALIGN);\n"
"pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr ""
"pathconf(path, _PC_REC_XFER_ALIGN);\n"
"pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"

#. type: Plain text
#: build/C/man3/statvfs.3:257
#, fuzzy
#| msgid ""
#| "respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields of "
#| "the return value of I<statvfs(path,buf)>."
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields "
"returned by a call to B<statvfs>()  with the argument I<path>."
msgstr ""
"は、それぞれ I<statvfs(path,buf)> の返り値の I<f_frsize>, I<f_frsize>, "
"I<f_bsize> フィールドを使う。"

#. type: Plain text
#: build/C/man3/statvfs.3:259
msgid "B<statfs>(2)"
msgstr "B<statfs>(2)"

#. type: TH
#: build/C/man2/sysfs.2:27 build/C/man5/sysfs.5:25
#, no-wrap
msgid "SYSFS"
msgstr "SYSFS"

#. type: Plain text
#: build/C/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr "sysfs - ファイルシステム (file system) の情報を取得する"

#. type: Plain text
#: build/C/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"
msgstr ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr "B<int sysfs(int >I<option>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:44
msgid ""
"B<Note>: if you are looking for information about the B<sysfs> filesystem "
"that is normally mounted at I</sys>, see B<sysfs>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:54
msgid ""
"The (obsolete)  B<sysfs>()  system call returns information about the "
"filesystem types currently present in the kernel.  The specific form of the "
"B<sysfs>()  call and the information returned depends on the I<option> in "
"effect:"
msgstr "(廃止予定の) B<sysfs>() システムコールは、現在カーネル (kernel) に存在しているファイルシステムの型 (type) 情報を返す。 それぞれの B<sysfs>()  コールの形式と返される情報は I<option> に依存しており、それは:"

#. type: TP
#: build/C/man2/sysfs.2:54
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: build/C/man2/sysfs.2:59
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr ""
"ファイルシステム識別文字列 (identifier string)  I<fsname> をファイルシステム"
"の型インデックス (type index) に翻訳する。"

#. type: TP
#: build/C/man2/sysfs.2:59
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: build/C/man2/sysfs.2:70
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr ""
"ファイルシステムの型インデックス I<fs_index> をヌル終端されたファイルシステム"
"識別文字列に翻訳する。 この文字列は I<buf> で指定されたバッファーへ書き込まれ"
"る。 I<buf> に文字列を入れるだけの十分な容量があることを確かめること。"

#. type: TP
#: build/C/man2/sysfs.2:70
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man2/sysfs.2:74
msgid ""
"Return the total number of filesystem types currently present in the kernel."
msgstr "現在カーネルに存在するファイルシステム型の数の合計を返す。"

#. type: Plain text
#: build/C/man2/sysfs.2:76
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr "ファイルシステムの型インデックスの数はゼロから始まる。"

#. type: Plain text
#: build/C/man2/sysfs.2:88
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 B<sysfs>()  は、 オプション B<1> では ファイルシステムのインデッ"
"クスを返す。 オプション B<2> ではゼロを返す。 オプション B<3> は現在設定され"
"ているファイルシステムの数を返す。 エラーの場合は、-1 が返され、 I<errno> が"
"適切に設定される。"

#. type: Plain text
#: build/C/man2/sysfs.2:93
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr "fsnameI< と >buf のどちらかがアクセス可能なアドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/sysfs.2:101
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is out-of-"
"bounds; I<option> is invalid."
msgstr ""
"I<fsname> が正しいファイルシステムの型識別子ではない; I<fs_index> が範囲の外"
"にある; I<option> が正しくない。"

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: build/C/man2/sysfs.2:103 build/C/man2/ustat.2:98
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: build/C/man2/sysfs.2:110
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via I</proc>; use that "
"interface instead."
msgstr "この System-V 由来のシステムコールは廃止予定 (obsolete) であり、 使用しないこと。 I</proc> が利用できるシステムでは、同じ情報が I</proc> 経由で取得でき、このインターフェースを使用すること。"

#. type: Plain text
#: build/C/man2/sysfs.2:113
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""
"libc または glibc のサポートは存在しない。 I<buf> の大きさがどれだけ必要かを"
"推測する方法がない。"

#. type: Plain text
#: build/C/man2/sysfs.2:116
msgid "B<proc>(5), B<sysfs>(5)"
msgstr "B<proc>(5), B<sysfs>(5)"

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr "UMOUNT"

#. type: Plain text
#: build/C/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr "umount, umount2 - ファイルシステムをアンマウントする"

#. type: Plain text
#: build/C/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr "B<int umount(const char *>I<target>B<);>\n"

#. type: Plain text
#: build/C/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: build/C/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""
"B<umount>()  と B<umount2>()  は I<target> にマウントされている (最上位の) "
"ファイルシステムを外す。"

#. type: Plain text
#: build/C/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""
"ファイルシステムのアンマウントを行うには、 適切な権限 (Linux では "
"B<CAP_SYS_ADMIN> ケーパビリティ) が必要である。"

#. type: Plain text
#: build/C/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""
"Linux 2.1.116 から、 B<umount2>()  システムコールが追加された。これは "
"B<umount>()  と同様に I<target> をアンマウントするが、 I<flags> が追加されて"
"おり、操作時の振る舞いを制御できる。"

#. type: TP
#: build/C/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr "B<MNT_FORCE> (2.1.116 以降)"

#. type: Plain text
#: build/C/man2/umount.2:80
msgid ""
"Ask the filesystem to abort pending requests before attempting the unmount.  "
"This may allow the unmount to complete without waiting for an inaccessible "
"server, but could cause data loss.  If, after aborting requests, some "
"processes still have active references to the filesystem, the unmount will "
"still fail.  As at Linux 4.12, B<MNT_FORCE> is supported only on the "
"following filesystems: 9p (since Linux 2.6.16), ceph (since Linux 2.6.34), "
"cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre (since Linux "
"3.11), and NFS (since Linux 2.1.116)."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:80
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr "B<MNT_DETACH> (2.4.11 以降)"

#. type: Plain text
#: build/C/man2/umount.2:86
#, fuzzy
#| msgid ""
#| "Perform a lazy unmount: make the mount point unavailable for new "
#| "accesses, and actually perform the unmount when the mount point ceases to "
#| "be busy."
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"immediately disconnect the filesystem and all filesystems mounted below it "
"from each other and from the mount table, and actually perform the unmount "
"when the mount point ceases to be busy."
msgstr ""
"遅延アンマウントを行う。マウントポイントに対する新規のアクセスは 不可能とな"
"り、実際のアンマウントはマウントポイントがビジーで なくなった時点で行う。"

#. type: TP
#: build/C/man2/umount.2:86
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr "B<MNT_EXPIRE> (Linux 2.6.8 以降)"

#. type: Plain text
#: build/C/man2/umount.2:105
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""
"マウントポイントに期限切れの印をつける。 マウントポイントが現在使用中でない場"
"合、このフラグをつけて B<umount2>()  を初めて呼び出すと B<EAGAIN> エラーで失"
"敗するが、マウントポイントには期限切れ (expire)  の印がつけられる。 そのマウ"
"ントポイントはいずれかのプロセスがアクセスしない限り 期限切れの印がついたまま"
"となる。 もう一度 B<MNT_EXPIRE> をつけて B<umount2>()  を呼び出すと、期限切れ"
"の印のついたマウントポイントが アンマウントされる。 このフラグを "
"B<MNT_FORCE> もしくは B<MNT_DETACH> と同時に指定することはできない。"

#. type: TP
#: build/C/man2/umount.2:105
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr "B<UMOUNT_NOFOLLOW> (Linux 2.6.34 以降)"

#.  Later added to 2.6.33-stable
#. type: Plain text
#: build/C/man2/umount.2:113
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""
"I<target> がシンボリックリンクの場合に、シンボリックリンクの展開を行わな"
"い。\n"
"このフラグを使うと、 I<root> に set-user-ID されたプログラムにおいて、\n"
"非特権ユーザーがファイルシステムのアンマウントをできてしまうという\n"
"セキュリティ問題を回避することができる。"

#. type: TP
#: build/C/man2/umount.2:124
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/umount.2:131
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""
"B<MNT_EXPIRE> を指定した B<umount2>()  の呼び出しで、正常に未使用のファイルシ"
"ステムに期限切れの印を つけることができた。"

#. type: Plain text
#: build/C/man2/umount.2:135
msgid "I<target> could not be unmounted because it is busy."
msgstr "使用中 (busy) のため、 I<target> をアンマウントできなかった。"

#. type: Plain text
#: build/C/man2/umount.2:139
msgid "I<target> points outside the user address space."
msgstr "I<target> がユーザーアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/umount.2:143
msgid "I<target> is not a mount point."
msgstr "I<target> がマウントポイントではない。"

#. type: Plain text
#: build/C/man2/umount.2:152
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""
"B<MNT_EXPIRE> が指定された B<umount2>() で、 B<MNT_DETACH> か B<MNT_FORCE> が"
"同時に指定された。"

#. type: TP
#: build/C/man2/umount.2:152
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr "B<EINVAL> (Linux 2.6.34 以降)"

#. type: Plain text
#: build/C/man2/umount.2:157
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr "I<flags> に無効なフラグが指定されて B<umount2>() が呼び出された。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: build/C/man2/umount.2:176
msgid ""
"B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""
"B<MNT_DETACH> と B<MNT_EXPIRE> はバージョン 2.11 以降の glibc で利用できる。"

#. type: Plain text
#: build/C/man2/umount.2:179
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"この関数は Linux 固有の関数であり、移植を考慮したプログラムでは 使用すべきで"
"ない。"

#. type: SS
#: build/C/man2/umount.2:180
#, no-wrap
msgid "umount() and shared mount points"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:189
msgid ""
"Shared mount points cause any mount activity on a mount point, including "
"B<umount>()  operations, to be forwarded to every shared mount point in the "
"peer group and every slave mount of that peer group.  This means that "
"B<umount>()  of any peer in a set of shared mounts will cause all of its "
"peers to be unmounted and all of their slaves to be unmounted as well."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:197
msgid ""
"This propagation of unmount activity can be particularly surprising on "
"systems where every mount point is shared by default.  On such systems, "
"recursively bind mounting the root directory of the filesystem onto a "
"subdirectory and then later unmounting that subdirectory with B<MNT_DETACH> "
"will cause every mount in the mount namespace to be lazily unmounted."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:212
msgid ""
"To ensure B<umount>()  does not propagate in this fashion, the mount point "
"may be remounted using a B<mount>(2)  call with a I<mount_flags> argument "
"that includes both B<MS_REC> and B<MS_PRIVATE> prior to B<umount>()  being "
"called."
msgstr ""

#. type: SS
#: build/C/man2/umount.2:212
#, no-wrap
msgid "Historical details"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:223
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4, a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""
"元々の B<umount>()  関数は I<umount(device)> の形で呼び出され、 ブロックデバ"
"イス以外を指定して呼び出すと B<ENOTBLK> を返した。 Linux 0.98p4 で、無名デバ"
"イス (anonymous device) に対応するために I<umount(dir)> の形での呼び出しが加"
"えられた。 Linux 2.3.99-pre7 で、I<umount(device)> は削除され、 "
"I<umount(dir)> だけが残された (一つのデバイスを複数の位置にマウント出来るよう"
"になったため、 デバイスを指定しただけでは不十分だからである)。"

#. type: Plain text
#: build/C/man2/umount.2:229
msgid ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"
msgstr "B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), B<umount>(8)"

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr "USTAT"

#. type: Plain text
#: build/C/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr "ustat - ファイルシステム (file system) の統計を得る"

#. type: Plain text
#: build/C/man2/ustat.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"

#. type: Plain text
#: build/C/man2/ustat.2:40
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"

#. type: Plain text
#: build/C/man2/ustat.2:52
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf> "
"is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""
"B<ustat>()  はマウント (mount) されたファイルシステムの情報を返す。 I<dev> は"
"調べるファイルシステムを含んでいるデバイス (device) の デバイス番号。 "
"I<ubuf> は以下のメンバーを含む ustat 構造体へのポインター:"

#. type: Plain text
#: build/C/man2/ustat.2:59
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"

#. type: Plain text
#: build/C/man2/ustat.2:68
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""
"後の二つのフィールド I<f_fname> と I<f_fpack> は実装されておらず、常にヌルバ"
"イト (\\(aq\\e0\\(aq) で埋められる。"

#. type: Plain text
#: build/C/man2/ustat.2:77
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合にはゼロが返され、 I<ubuf> が指す I<ustat> 構造体が埋められる。 "
"エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/ustat.2:82
msgid "I<ubuf> points outside of your accessible address space."
msgstr "I<ubuf> がアクセス可能な空間の外側を指している。"

#. type: Plain text
#: build/C/man2/ustat.2:86
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""
"I<dev> がマウントされたファイルシステムを含むデバイスを参照していない。"

#. type: Plain text
#: build/C/man2/ustat.2:92
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation, "
"or any version of Linux before 1.3.16."
msgstr ""
"I<dev> で参照されるマウントされたファイルシステムがこの操作 (operation) を サ"
"ポートしていないか、Linux のバージョンが 1.3.16 以前である。"

#. type: Plain text
#: build/C/man2/ustat.2:94
msgid ""
"Since version 2.28, glibc no longer provides a wrapper for this system call."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""
"B<ustat>()  は推奨されず、互換性のためだけに提供される。 新しいプログラムは全"
"てこれの代りに B<statfs>(2)  を使用するべきである。"

#. type: SS
#: build/C/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr "HP-UX における注意"

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: build/C/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems, "
"the number of free inodes does not change.  Such filesystems will return -1 "
"in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""
"HP-UX 版の構造体 I<ustat> には、その他にフィールド I<f_blksize> が存在する"
"が、他では見かけない。 HP-UX は次のように警告している: ファイルシステムの中に"
"は、解放されている inode の数を変更しないものもある。 このようなファイルシス"
"テムは、フィールド I<f_tinode> に -1 を返す。 ファイルシステムの中には、"
"inode を動的に確保するものもある。 このようなファイルシステムは、現在解放され"
"ている inode の数を返す。"

#. type: Plain text
#: build/C/man2/ustat.2:121
msgid "B<stat>(2), B<statfs>(2)"
msgstr "B<stat>(2), B<statfs>(2)"

#. type: TH
#: build/C/man5/sysfs.5:25
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: build/C/man5/sysfs.5:28
msgid "sysfs - a filesystem for exporting kernel objects"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:42
msgid ""
"The B<sysfs> filesystem is a pseudo-filesystem which provides an interface "
"to kernel data structures.  (More precisely, the files and directories in "
"B<sysfs> provide a view of the I<kobject> structures defined internally "
"within the kernel.)  The files under B<sysfs> provide information about "
"devices, kernel modules, filesystems, and other kernel components."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:49
msgid ""
"The B<sysfs> filesystem is commonly mounted at I</sys>.  Typically, it is "
"mounted automatically by the system, but it can also be mounted manually "
"using a command such as:"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:53
#, no-wrap
msgid "mount -t sysfs sysfs /sys\n"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:63
msgid ""
"Many of the files in the B<sysfs> filesystem are read-only, but some files "
"are writable, allowing kernel variables to be changed.  To avoid redundancy, "
"symbolic links are heavily used to connect entries across the filesystem "
"tree."
msgstr ""

#. type: SS
#: build/C/man5/sysfs.5:63
#, no-wrap
msgid "Files and directories"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:67
msgid ""
"The following list describes some of the files and directories under the I</"
"sys> hierarchy."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:67
#, no-wrap
msgid "I</sys/block>"
msgstr "I</sys/block>"

#. type: Plain text
#: build/C/man5/sysfs.5:73
msgid ""
"This subdirectory contains one symbolic link for each block device that has "
"been discovered on the system.  The symbolic links point to corresponding "
"directories under I</sys/devices>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:73
#, no-wrap
msgid "I</sys/bus>"
msgstr "I</sys/bus>"

#. type: Plain text
#: build/C/man5/sysfs.5:78
msgid ""
"This directory contains one subdirectory for each of the bus types in the "
"kernel.  Inside each of these directories are two subdirectories:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:79
#, no-wrap
msgid "I<devices>"
msgstr "I<devices>"

#. type: Plain text
#: build/C/man5/sysfs.5:84
msgid ""
"This subdirectory contains symbolic links to entries in I</sys/devices> that "
"correspond to the devices discovered on this bus."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:84 build/C/man5/sysfs.5:249
#, no-wrap
msgid "I<drivers>"
msgstr "I<drivers>"

#. type: Plain text
#: build/C/man5/sysfs.5:88
msgid ""
"This subdirectory contains one subdirectory for each device driver that is "
"loaded on this bus."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:89
#, no-wrap
msgid "I</sys/class>"
msgstr "I</sys/class>"

#. type: Plain text
#: build/C/man5/sysfs.5:100
msgid ""
"This subdirectory contains a single layer of further subdirectories for each "
"of the device classes that have been registered on the system (e.g., "
"terminals, network devices, block devices, graphics devices, sound devices, "
"and so on).  Inside each of these subdirectories are symbolic links for each "
"of the devices in this class.  These symbolic links refer to entries in the "
"I</sys/devices> directory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:100
#, no-wrap
msgid "I</sys/class/net>"
msgstr "I</sys/class/net>"

#. type: Plain text
#: build/C/man5/sysfs.5:109
msgid ""
"Each of the entries in this directory is a symbolic link representing one of "
"the real or virtual networking devices that are visible in the network "
"namespace of the process that is accessing the directory.  Each of these "
"symbolic links refers to entries in the I</sys/devices> directory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:109
#, no-wrap
msgid "I</sys/dev>"
msgstr "I</sys/dev>"

#. type: Plain text
#: build/C/man5/sysfs.5:130
msgid ""
"This directory contains two subdirectories I<block>/ and I<char/>, "
"corresponding, respectively, to the block and character devices on the "
"system.  Inside each of these subdirectories are symbolic links with names "
"of the form I<major-ID>:I<minor-ID>, where the ID values correspond to the "
"major and minor ID of a specific device.  Each symbolic link points to the "
"B<sysfs> directory for a device.  The symbolic links inside I</sys/dev> thus "
"provide an easy way to look up the B<sysfs> interface using the device IDs "
"returned by a call to B<stat>(2)  (or similar)."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:133
msgid "The following shell session shows an example from I</sys/dev>:"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:147
#, no-wrap
msgid ""
"$ B<stat -c \"%t %T\" /dev/null>\n"
"1 3\n"
"$ B<readlink /sys/dev/char/1\\e:3>\n"
"\\&../../devices/virtual/mem/null\n"
"$ B<ls -Fd /sys/devices/virtual/mem/null>\n"
"/sys/devices/virtual/mem/null/\n"
"$ B<ls -d1 /sys/devices/virtual/mem/null/*>\n"
"/sys/devices/virtual/mem/null/dev\n"
"/sys/devices/virtual/mem/null/power/\n"
"/sys/devices/virtual/mem/null/subsystem@\n"
"/sys/devices/virtual/mem/null/uevent\n"
msgstr ""
"$ B<stat -c \"%t %T\" /dev/null>\n"
"1 3\n"
"$ B<readlink /sys/dev/char/1\\e:3>\n"
"\\&../../devices/virtual/mem/null\n"
"$ B<ls -Fd /sys/devices/virtual/mem/null>\n"
"/sys/devices/virtual/mem/null/\n"
"$ B<ls -d1 /sys/devices/virtual/mem/null/*>\n"
"/sys/devices/virtual/mem/null/dev\n"
"/sys/devices/virtual/mem/null/power/\n"
"/sys/devices/virtual/mem/null/subsystem@\n"
"/sys/devices/virtual/mem/null/uevent\n"

#. type: TP
#: build/C/man5/sysfs.5:149
#, no-wrap
msgid "I</sys/devices>"
msgstr "I</sys/devices>"

#. type: Plain text
#: build/C/man5/sysfs.5:156
msgid ""
"This is a directory that contains a filesystem representation of the kernel "
"device tree, which is a hierarchy of I<device> structures within the kernel."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:156
#, no-wrap
msgid "I</sys/firmware>"
msgstr "I</sys/firmware>"

#. type: Plain text
#: build/C/man5/sysfs.5:160
msgid ""
"This subdirectory contains interfaces for viewing and manipulating firmware-"
"specific objects and attributes."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:160
#, no-wrap
msgid "I</sys/fs>"
msgstr "I</sys/fs>"

#. type: Plain text
#: build/C/man5/sysfs.5:165
msgid ""
"This directory contains subdirectories for some filesystems.  A filesystem "
"will have a subdirectory here only if it chose to explicitly create the "
"subdirectory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:165
#, no-wrap
msgid "I</sys/fs/cgroup>"
msgstr "I</sys/fs/cgroup>"

#. type: Plain text
#: build/C/man5/sysfs.5:172
msgid ""
"This directory conventionally is used as a mount point for a B<tmpfs>(5)  "
"filesystem containing mount points for B<cgroups>(7)  filesystems."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:172
#, no-wrap
msgid "I</sys/fs/smackfs>"
msgstr "I</sys/fs/smackfs>"

#. type: Plain text
#: build/C/man5/sysfs.5:177
msgid ""
"The directory contains configuration files for the SMACK LSM.  See the "
"kernel source file I<Documentation/admin-guide/LSM/Smack.rst>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:177
#, no-wrap
msgid "I</sys/hypervisor>"
msgstr "I</sys/hypervisor>"

#. type: Plain text
#: build/C/man5/sysfs.5:180 build/C/man5/sysfs.5:252 build/C/man5/sysfs.5:255
#: build/C/man5/sysfs.5:258 build/C/man5/sysfs.5:274
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:180
#, no-wrap
msgid "I</sys/kernel>"
msgstr "I</sys/kernel>"

#. type: Plain text
#: build/C/man5/sysfs.5:184
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the running kernel."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:184
#, no-wrap
msgid "I</sys/kernel/cgroup/>"
msgstr "I</sys/kernel/cgroup/>"

#. type: Plain text
#: build/C/man5/sysfs.5:188
msgid "For information about the files in this directory, see B<cgroups>(7)."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:188
#, no-wrap
msgid "I</sys/kernel/debug/tracing>"
msgstr "I</sys/kernel/debug/tracing>"

#. type: Plain text
#: build/C/man5/sysfs.5:199
msgid ""
"Mount point for the I<tracefs> filesystem used by the kernel's I<ftrace> "
"facility.  (For information on I<ftrace>, see the kernel source file "
"I<Documentation/trace/ftrace.txt>.)"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:199
#, no-wrap
msgid "I</sys/kernel/mm>"
msgstr "I</sys/kernel/mm>"

#. type: Plain text
#: build/C/man5/sysfs.5:203
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the kernel's memory management subsystem."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:203
#, no-wrap
msgid "I</sys/kernel/mm/hugepages>"
msgstr "I</sys/kernel/mm/hugepages>"

#. type: Plain text
#: build/C/man5/sysfs.5:214
msgid ""
"This subdirectory contains one subdirectory for each of the huge page sizes "
"that the system supports.  The subdirectory name indicates the huge page "
"size (e.g., I<hugepages-2048kB>).  Within each of these subdirectories is a "
"set of files that can be used to view and (in some cases) change settings "
"associated with that huge page size.  For further information, see the "
"kernel source file I<Documentation/admin-guide/mm/hugetlbpage.rst>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:214
#, no-wrap
msgid "I</sys/module>"
msgstr "I</sys/module>"

#. type: Plain text
#: build/C/man5/sysfs.5:220
msgid ""
"This subdirectory contains one subdirectory for each module that is loaded "
"into the kernel.  The name of each directory is the name of the module.  In "
"each of the subdirectories, there may be following files:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:221
#, no-wrap
msgid "I<coresize>"
msgstr "I<coresize>"

#. type: Plain text
#: build/C/man5/sysfs.5:224 build/C/man5/sysfs.5:227 build/C/man5/sysfs.5:230
#: build/C/man5/sysfs.5:233 build/C/man5/sysfs.5:236 build/C/man5/sysfs.5:239
#: build/C/man5/sysfs.5:242 build/C/man5/sysfs.5:245
msgid "[to be documented]"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:224
#, no-wrap
msgid "I<initsize>"
msgstr "I<initsize>"

#. type: TP
#: build/C/man5/sysfs.5:227
#, no-wrap
msgid "I<initstate>"
msgstr "I<initstate>"

#. type: TP
#: build/C/man5/sysfs.5:230
#, no-wrap
msgid "I<refcnt>"
msgstr "I<refcnt>"

#. type: TP
#: build/C/man5/sysfs.5:233
#, no-wrap
msgid "I<srcversion>"
msgstr "I<srcversion>"

#. type: TP
#: build/C/man5/sysfs.5:236
#, no-wrap
msgid "I<taint>"
msgstr "I<taint>"

#. type: TP
#: build/C/man5/sysfs.5:239
#, no-wrap
msgid "I<uevent>"
msgstr "I<uevent>"

#. type: TP
#: build/C/man5/sysfs.5:242
#, no-wrap
msgid "I<version>"
msgstr "I<version>"

#. type: Plain text
#: build/C/man5/sysfs.5:248
msgid "In each of the subdirectories, there may be following subdirectories:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:252
#, no-wrap
msgid "I<holders>"
msgstr "I<holders>"

#. type: TP
#: build/C/man5/sysfs.5:255
#, no-wrap
msgid "I<notes>"
msgstr "I<notes>"

#. type: TP
#: build/C/man5/sysfs.5:258
#, no-wrap
msgid "I<parameters>"
msgstr "I<parameters>"

#. type: Plain text
#: build/C/man5/sysfs.5:263
msgid ""
"This directory contains one file for each module parameter, with each file "
"containing the value of the corresponding parameter.  Some of these files "
"are writable, allowing the"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:263
#, no-wrap
msgid "I<sections>"
msgstr "I<sections>"

#. type: Plain text
#: build/C/man5/sysfs.5:267
msgid ""
"This subdirectories contains files with information about module sections.  "
"This information is mainly used for debugging."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:267
#, no-wrap
msgid "I<[To be documented]>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:271
#, no-wrap
msgid "I</sys/power>"
msgstr "I</sys/power>"

#. type: Plain text
#: build/C/man5/sysfs.5:278
msgid "The B<sysfs> filesystem first appeared in Linux 2.6.0."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:282
#, fuzzy
#| msgid "These system calls are Linux-specific."
msgid "The B<sysfs> filesystem is Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man5/sysfs.5:285
msgid ""
"This manual page is incomplete, possibly inaccurate, and is the kind of "
"thing that needs to be updated very often."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:288
msgid "B<proc>(5), B<udev>(7)"
msgstr "B<proc>(5), B<udev>(7)"

#.  https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf
#. type: Plain text
#: build/C/man5/sysfs.5:293
msgid ""
"P.\\& Mochel. (2005).  I<The sysfs filesystem>.  Proceedings of the 2005 "
"Ottawa Linux Symposium."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:300
msgid ""
"The kernel source file I<Documentation/filesystems/sysfs.txt> and various "
"other files in I<Documentation/ABI> and I<Documentation/*/sysfs.txt>"
msgstr ""

#. type: TH
#: build/C/man5/tmpfs.5:25
#, no-wrap
msgid "TMPFS"
msgstr "TMPFS"

#. type: Plain text
#: build/C/man5/tmpfs.5:28
msgid "tmpfs - a virtual memory filesystem"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:35
msgid ""
"The B<tmpfs> facility allows the creation of filesystems whose contents "
"reside in virtual memory.  Since the files on such filesystems typically "
"reside in RAM, file access is extremely fast."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:40
msgid ""
"The filesystem is automatically created when mounting a filesystem with the "
"type B<tmpfs> via a command such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:44
#, no-wrap
msgid "$ sudo mount -t tmpfs -o size=10M tmpfs /mnt/mytmpfs\n"
msgstr "$ sudo mount -t tmpfs -o size=10M tmpfs /mnt/mytmpfs\n"

#. type: Plain text
#: build/C/man5/tmpfs.5:50
msgid "A B<tmpfs> filesystem has the following properties:"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:53
msgid ""
"The filesystem can employ swap space when physical memory pressure demands "
"it."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:56
msgid ""
"The filesystem consumes only as much physical memory and swap space as is "
"required to store the current contents of the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:61
msgid ""
"During a remount operation (I<mount\\ -o\\ remount>), the filesystem size "
"can be changed (without losing the existing contents of the filesystem)."
msgstr ""

#.  See mm/shmem.c:shmem_parse_options for options it supports.
#. type: Plain text
#: build/C/man5/tmpfs.5:66
msgid ""
"If a B<tmpfs> filesystem is unmounted, its contents are discarded (lost)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:70
msgid "The B<tmpfs> filesystem supports the following mount options:"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:70
#, no-wrap
msgid "B<size>=I<bytes>"
msgstr "B<size>=I<bytes>"

#. type: Plain text
#: build/C/man5/tmpfs.5:74
msgid ""
"Specify an upper limit on the size of the filesystem.  The size is given in "
"bytes, and rounded up to entire pages."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:82
msgid ""
"The size may have a B<k>, B<m>, or B<g> suffix for Ki, Mi, Gi (binary kilo "
"(kibi), binary mega (mebi) and binary giga (gibi))."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:85
msgid ""
"The size may also have a % suffix to limit this instance to a percentage of "
"physical RAM."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:92
msgid ""
"The default, when neither B<size> nor B<nr_blocks> is specified, is "
"I<size=50%>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:92
#, no-wrap
msgid "B<nr_blocks>=I<blocks>"
msgstr "B<nr_blocks>=I<blocks>"

#. type: Plain text
#: build/C/man5/tmpfs.5:98
msgid "The same as B<size>, but in blocks of B<PAGE_CACHE_SIZE>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:107
msgid ""
"Blocks may be specified with B<k>, B<m>, or B<g> suffixes like B<size>, but "
"not a % suffix."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:107
#, no-wrap
msgid "B<nr_inodes>=I<inodes>"
msgstr "B<nr_inodes>=I<inodes>"

#. type: Plain text
#: build/C/man5/tmpfs.5:112
msgid ""
"The maximum number of inodes for this instance.  The default is half of the "
"number of your physical RAM pages, or (on a machine with highmem) the number "
"of lowmem RAM pages, whichever is smaller."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:121
msgid ""
"Inodes may be specified with B<k>, B<m>, or B<g> suffixes like B<size>, but "
"not a % suffix."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:121
#, no-wrap
msgid "B<mode>=I<mode>"
msgstr "B<mode>=I<mode>"

#. type: Plain text
#: build/C/man5/tmpfs.5:124
msgid "Set initial permissions of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:124
#, no-wrap
msgid "B<gid>=I<gid> (since Linux 2.5.7)"
msgstr "B<gid>=I<gid> (Linux 2.5.7 以降)"

#.  Technically this is also in some version of Linux 2.4.
#.  commit 099445b489625b80b1d6687c9b6072dbeaca4096
#. type: Plain text
#: build/C/man5/tmpfs.5:129
msgid "Set the initial group ID of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:129
#, no-wrap
msgid "B<uid>=I<uid> (since Linux 2.5.7)"
msgstr "B<uid>=I<uid> (Linux 2.5.7 以降)"

#.  Technically this is also in some version of Linux 2.4.
#.  commit 099445b489625b80b1d6687c9b6072dbeaca4096
#. type: Plain text
#: build/C/man5/tmpfs.5:134
msgid "Set the initial user ID of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:134
#, no-wrap
msgid "B<huge>=I<huge_option> (since Linux 4.7.0)"
msgstr "B<huge>=I<huge_option> (Linux 4.7.0 以降)"

#.  commit 5a6e75f8110c97e2a5488894d4e922187e6cb343
#. type: Plain text
#: build/C/man5/tmpfs.5:140
msgid ""
"Set the huge table memory allocation policy for all files in this instance "
"(if B<CONFIG_TRANSPARENT_HUGE_PAGECACHE> is enabled)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:144
#, fuzzy
#| msgid "I<Option> may be set to the following value:"
msgid "The I<huge_option> value is one of the following:"
msgstr "I<option> は、次の値に設定できる。"

#. type: TP
#: build/C/man5/tmpfs.5:145
#, no-wrap
msgid "B<never>"
msgstr "B<never>"

#. type: Plain text
#: build/C/man5/tmpfs.5:149
msgid "Do not allocate huge pages.  This is the default."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:149
#, no-wrap
msgid "B<always>"
msgstr "B<always>"

#. type: Plain text
#: build/C/man5/tmpfs.5:152
msgid "Attempt to allocate huge pages every time a new page is needed."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:152
#, no-wrap
msgid "B<within_size>"
msgstr "B<within_size>"

#. type: Plain text
#: build/C/man5/tmpfs.5:159
msgid ""
"Only allocate huge page if it will be fully within I<i_size>.  Also respect "
"B<fadvise>(2)/B<madvise>(2)  hints"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:159
#, no-wrap
msgid "B<advise>"
msgstr "B<advise>"

#. type: Plain text
#: build/C/man5/tmpfs.5:163
msgid "Only allocate huge pages if requested with B<fadvise>(2)/B<madvise>(2)."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:163
#, no-wrap
msgid "B<deny>"
msgstr "B<deny>"

#. type: Plain text
#: build/C/man5/tmpfs.5:166
msgid "For use in emergencies, to force the huge option off from all mounts."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:166
#, no-wrap
msgid "B<force>"
msgstr "B<force>"

#. type: Plain text
#: build/C/man5/tmpfs.5:169
msgid "Force the huge option on for all mounts; useful for testing."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:170
#, no-wrap
msgid "B<mpol>=I<mpol_option> (since Linux 2.6.15)"
msgstr "B<mpol>=I<mpol_option> (Linux 2.6.15 以降)"

#.  commit 7339ff8302fd70aabf5f1ae26e0c4905fa74a495
#. type: Plain text
#: build/C/man5/tmpfs.5:176
msgid ""
"Set the NUMA memory allocation policy for all files in this instance (if "
"B<CONFIG_NUMA> is enabled)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:180
#, fuzzy
#| msgid "I<Option> may be set to the following value:"
msgid "The I<mpol_option> value is one of the following:"
msgstr "I<option> は、次の値に設定できる。"

#. type: TP
#: build/C/man5/tmpfs.5:181
#, no-wrap
msgid "B<default>"
msgstr "B<default>"

#. type: Plain text
#: build/C/man5/tmpfs.5:185
msgid "Use the process allocation policy (see B<set_mempolicy>(2))."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:185
#, no-wrap
msgid "B<prefer>:I<node>"
msgstr "B<prefer>:I<node>"

#. type: Plain text
#: build/C/man5/tmpfs.5:189
msgid "Preferably allocate memory from the given I<node>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:189
#, no-wrap
msgid "B<bind>:I<nodelist>"
msgstr "B<bind>:I<nodelist>"

#. type: Plain text
#: build/C/man5/tmpfs.5:193
msgid "Allocate memory only from nodes in I<nodelist>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:193
#, no-wrap
msgid "B<interleave>"
msgstr "B<interleave>"

#. type: Plain text
#: build/C/man5/tmpfs.5:196
msgid "Allocate from each node in turn."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:196
#, no-wrap
msgid "B<interleave>:I<nodelist>"
msgstr "B<interleave>:I<nodelist>"

#. type: Plain text
#: build/C/man5/tmpfs.5:201
msgid "Allocate from each node of I<in> turn."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:201
#, no-wrap
msgid "B<local>"
msgstr "B<local>"

#. type: Plain text
#: build/C/man5/tmpfs.5:204
msgid "Preferably allocate memory from the local node."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:214
msgid ""
"In the above, I<nodelist> is a comma-separated list of decimal numbers and "
"ranges that specify NUMA nodes.  A range is a pair of hyphen-separated "
"decimal numbers, the smallest and largest node numbers in the range.  For "
"example, I<mpol=bind:0-3,5,7,9-15>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:221
msgid ""
"The B<tmpfs> facility was added in Linux 2.4, as a successor to the older "
"B<ramfs> facility, which did not provide limit checking or allow for the use "
"of swap space."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:227
msgid ""
"In order for user-space tools and applications to create B<tmpfs> "
"filesystems, the kernel must be configured with the B<CONFIG_TMPFS> option."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:235
msgid ""
"The B<tmpfs> filesystem supports extended attributes (see B<xattr>(7)), but "
"I<user> extended attributes are not permitted."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:250
msgid ""
"An internal shared memory filesystem is used for System V shared memory "
"(B<shmget>(2))  and shared anonymous mappings (B<mmap>(2)  with the "
"B<MAP_SHARED> and B<MAP_ANONYMOUS> flags).  This filesystem is available "
"regardless of whether the kernel was configured with the B<CONFIG_TMPFS> "
"option."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:259
msgid ""
"A B<tmpfs> filesystem mounted at I</dev/shm> is used for the implementation "
"of POSIX shared memory (B<shm_overview>(7))  and POSIX semaphores "
"(B<sem_overview>(7))."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:270
msgid ""
"The amount of memory consumed by all B<tmpfs> filesystems is shown in the "
"I<Shmem> field of I</proc/meminfo> and in the I<shared> field displayed by "
"B<free>(1)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:275
msgid "The B<tmpfs> facility was formerly called B<shmfs>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:283
msgid ""
"B<df>(1), B<du>(1), B<memfd_create>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shm_open>(3), B<mount>(8)"
msgstr "B<df>(1), B<du>(1), B<memfd_create>(2), B<mmap>(2), B<set_mempolicy>(2), B<shm_open>(3), B<mount>(8)"

#. type: Plain text
#: build/C/man5/tmpfs.5:288
msgid ""
"The kernel source files I<Documentation/filesystems/tmpfs.txt> and "
"I<Documentation/admin-guide/mm/transhuge.rst>."
msgstr ""

#. type: TH
#: build/C/man4/fuse.4:26
#, no-wrap
msgid "FUSE"
msgstr "FUSE"

#. type: TH
#: build/C/man4/fuse.4:26
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: build/C/man4/fuse.4:29
msgid "fuse - Filesystem in Userspace (FUSE) device"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:32
#, no-wrap
msgid "B<#include E<lt>linux/fuse.hE<gt>>\n"
msgstr "B<#include E<lt>linux/fuse.hE<gt>>\n"

#. type: Plain text
#: build/C/man4/fuse.4:44
msgid ""
"This device is the primary interface between the FUSE filesystem driver and "
"a user-space process wishing to provide the filesystem (referred to in the "
"rest of this manual page as the I<filesystem daemon>).  This manual page is "
"intended for those interested in understanding the kernel interface itself.  "
"Those implementing a FUSE filesystem may wish to make use of a user-space "
"library such as I<libfuse> that abstracts away the low-level interface."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:58
msgid ""
"At its core, FUSE is a simple client-server protocol, in which the Linux "
"kernel is the client and the daemon is the server.  After obtaining a file "
"descriptor for this device, the daemon may B<read>(2)  requests from that "
"file descriptor and is expected to B<write>(2)  back its replies.  It is "
"important to note that a file descriptor is associated with a unique FUSE "
"filesystem.  In particular, opening a second copy of this device, will not "
"allow access to resources created through the first file descriptor (and "
"vice versa)."
msgstr ""

#. type: SS
#: build/C/man4/fuse.4:58
#, no-wrap
msgid "The basic protocol"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:61
msgid ""
"Every message that is read by the daemon begins with a header described by "
"the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:76
#, no-wrap
msgid ""
"struct fuse_in_header {\n"
"    uint32_t len;       /* Total length of the data,\n"
"                           including this header */\n"
"    uint32_t opcode;    /* The kind of operation (see below) */\n"
"    uint64_t unique;    /* A unique identifier for this request */\n"
"    uint64_t nodeid;    /* ID of the filesystem object\n"
"                           being operated on */\n"
"    uint32_t uid;       /* UID of the requesting process */\n"
"    uint32_t gid;       /* GID of the requesting process */\n"
"    uint32_t pid;       /* PID of the requesting process */\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:83
msgid ""
"The header is followed by a variable-length data portion (which may be "
"empty) specific to the requested operation (the requested operation is "
"indicated by I<opcode>)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:90
msgid ""
"The daemon should then process the request and if applicable send a reply "
"(almost all operations require a reply; if they do not, this is documented "
"below), by performing a B<write>(2)  to the file descriptor.  All replies "
"must start with the following header:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:100
#, no-wrap
msgid ""
"struct fuse_out_header {\n"
"    uint32_t len;       /* Total length of data written to\n"
"                           the file descriptor */\n"
"    int32_t  error;     /* Any error that occurred (0 if none) */\n"
"    uint64_t unique;    /* The value from the\n"
"                           corresponding request */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:110
msgid ""
"This header is also followed by (potentially empty) variable-sized data "
"depending on the executed request.  However, if the reply is an error reply "
"(i.e., I<error> is set), then no further payload data should be sent, "
"independent of the request."
msgstr ""

#. type: SS
#: build/C/man4/fuse.4:110
#, no-wrap
msgid "Exchanged messages"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:117
msgid ""
"This section should contain documentation for each of the messages in the "
"protocol.  This manual page is currently incomplete, so not all messages are "
"documented.  For each message, first the struct sent by the kernel is given, "
"followed by a description of the semantics of the message."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:117
#, no-wrap
msgid "B<FUSE_INIT>"
msgstr "B<FUSE_INIT>"

#. type: Plain text
#: build/C/man4/fuse.4:128
#, no-wrap
msgid ""
"struct fuse_init_in {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead; /* Since protocol v7.6 */\n"
"    uint32_t flags;         /* Since protocol v7.6 */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:140
msgid ""
"This is the first request sent by the kernel to the daemon.  It is used to "
"negotiate the protocol version and other filesystem parameters.  Note that "
"the protocol version may affect the layout of any structure in the protocol "
"(including this structure).  The daemon must thus remember the negotiated "
"version and flags for each session.  As of the writing of this man page, the "
"highest supported kernel protocol version is I<7.26>."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:143
msgid ""
"Users should be aware that the descriptions in this manual page may be "
"incomplete or incorrect for older or more recent protocol versions."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:145
msgid "The reply for this request has the following format:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:160
#, no-wrap
msgid ""
"struct fuse_init_out {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead;   /* Since v7.6 */\n"
"    uint32_t flags;           /* Since v7.6; some flags bits\n"
"                                 were introduced later */\n"
"    uint16_t max_background;  /* Since v7.13 */\n"
"    uint16_t congestion_threshold;  /* Since v7.13 */\n"
"    uint32_t max_write;       /* Since v7.5 */\n"
"    uint32_t time_gran;       /* Since v7.6 */\n"
"    uint32_t unused[9];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:173
msgid ""
"If the major version supported by the kernel is larger than that supported "
"by the daemon, the reply shall consist of only I<uint32_t major> (following "
"the usual header), indicating the largest major version supported by the "
"daemon.  The kernel will then issue a new B<FUSE_INIT> request conforming to "
"the older version.  In the reverse case, the daemon should quietly fall back "
"to the kernel's major version."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:177
msgid ""
"The negotiated minor version is considered to be the minimum of the minor "
"versions provided by the daemon and the kernel and both parties should use "
"the protocol corresponding to said minor version."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:177
#, no-wrap
msgid "B<FUSE_GETATTR>"
msgstr "B<FUSE_GETATTR>"

#. type: Plain text
#: build/C/man4/fuse.4:188
#, no-wrap
msgid ""
"struct fuse_getattr_in {\n"
"    uint32_t getattr_flags;\n"
"    uint32_t dummy;\n"
"    uint64_t fh;      /* Set only if\n"
"                         (getattr_flags & FUSE_GETATTR_FH)\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:204
msgid ""
"The requested operation is to compute the attributes to be returned by "
"B<stat>(2)  and similar operations for the given filesystem object.  The "
"object for which the attributes should be computed is indicated either by "
"I<header-E<gt>nodeid> or, if the B<FUSE_GETATTR_FH> flag is set, by the file "
"handle I<fh>.  The latter case of operation is analogous to B<fstat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:211
msgid ""
"For performance reasons, these attributes may be cached in the kernel for a "
"specified duration of time.  While the cache timeout has not been exceeded, "
"the attributes will be served from the cache and will not cause additional "
"B<FUSE_GETATTR> requests."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:214
msgid ""
"The computed attributes and the requested cache timeout should then be "
"returned in the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:241
#, no-wrap
msgid ""
"struct fuse_attr_out {\n"
"    /* Attribute cache duration (seconds + nanoseconds) */\n"
"    uint64_t attr_valid;\n"
"    uint32_t attr_valid_nsec;\n"
"    uint32_t dummy;\n"
"    struct fuse_attr {\n"
"        uint64_t ino;\n"
"        uint64_t size;\n"
"        uint64_t blocks;\n"
"        uint64_t atime;\n"
"        uint64_t mtime;\n"
"        uint64_t ctime;\n"
"        uint32_t atimensec;\n"
"        uint32_t mtimensec;\n"
"        uint32_t ctimensec;\n"
"        uint32_t mode;\n"
"        uint32_t nlink;\n"
"        uint32_t uid;\n"
"        uint32_t gid;\n"
"        uint32_t rdev;\n"
"        uint32_t blksize;\n"
"        uint32_t padding;\n"
"    } attr;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:243
#, no-wrap
msgid "B<FUSE_ACCESS>"
msgstr "B<FUSE_ACCESS>"

#. type: Plain text
#: build/C/man4/fuse.4:252
#, no-wrap
msgid ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"

#. type: Plain text
#: build/C/man4/fuse.4:264
msgid ""
"If the I<default_permissions> mount options is not used, this request may be "
"used for permissions checking.  No reply data is expected, but errors may be "
"indicated as usual by setting the I<error> field in the reply header (in "
"particular, access denied errors may be indicated by returning B<-EACCES>)."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:264
#, no-wrap
msgid "B<FUSE_OPEN> and B<FUSE_OPENDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:273
#, no-wrap
msgid ""
"struct fuse_open_in {\n"
"    uint32_t flags;     /* The flags that were passed\n"
"                           to the open(2) */\n"
"    uint32_t unused;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:285
msgid ""
"The requested operation is to open the node indicated by I<header-"
"E<gt>nodeid>.  The exact semantics of what this means will depend on the "
"filesystem being implemented.  However, at the very least the filesystem "
"should validate that the requested I<flags> are valid for the indicated "
"resource and then send a reply with the following format:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:293
#, no-wrap
msgid ""
"struct fuse_open_out {\n"
"    uint64_t fh;\n"
"    uint32_t open_flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:304
msgid ""
"The I<fh> field is an opaque identifier that the kernel will use to refer to "
"this resource The I<open_flags> field is a bit mask of any number of the "
"flags that indicate properties of this file handle to the kernel:"
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:305
#, no-wrap
msgid "B<FOPEN_DIRECT_IO>"
msgstr "B<FOPEN_DIRECT_IO>"

#. type: Plain text
#: build/C/man4/fuse.4:308
msgid "Bypass page cache for this open file."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:308
#, no-wrap
msgid "B<FOPEN_KEEP_CACHE>"
msgstr "B<FOPEN_KEEP_CACHE>"

#. type: Plain text
#: build/C/man4/fuse.4:311
msgid "Don't invalidate the data cache on open."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:311
#, no-wrap
msgid "B<FOPEN_NONSEEKABLE>"
msgstr "B<FOPEN_NONSEEKABLE>"

#. type: Plain text
#: build/C/man4/fuse.4:314
msgid "The file is not seekable."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:315
#, no-wrap
msgid "B<FUSE_READ> and B<FUSE_READDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:329
#, no-wrap
msgid ""
"struct fuse_read_in {\n"
"    uint64_t fh;\n"
"    uint64_t offset;\n"
"    uint32_t size;\n"
"    uint32_t read_flags;\n"
"    uint64_t lock_owner;\n"
"    uint32_t flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:337
msgid ""
"The requested action is to read up to I<size> bytes of the file or "
"directory, starting at I<offset>.  The bytes should be returned directly "
"following the usual reply header."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:337
#, no-wrap
msgid "B<FUSE_INTERRUPT>"
msgstr "B<FUSE_INTERRUPT>"

#. type: Plain text
#: build/C/man4/fuse.4:344
#, no-wrap
msgid ""
"struct fuse_interrupt_in {\n"
"    uint64_t unique;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:360
msgid ""
"The requested action is to cancel the pending operation indicated by "
"I<unique>.  This request requires no response.  However, receipt of this "
"message does not by itself cancel the indicated operation.  The kernel will "
"still expect a reply to said operation (e.g., an I<EINTR> error or a short "
"read).  At most one B<FUSE_INTERRUPT> request will be issued for a given "
"operation.  After issuing said operation, the kernel will wait "
"uninterruptibly for completion of the indicated request."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:360
#, no-wrap
msgid "B<FUSE_LOOKUP>"
msgstr "B<FUSE_LOOKUP>"

#. type: Plain text
#: build/C/man4/fuse.4:366
msgid ""
"Directly following the header is a filename to be looked up in the directory "
"indicated by I<header-E<gt>nodeid>.  The expected reply is of the form:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:378
#, no-wrap
msgid ""
"struct fuse_entry_out {\n"
"    uint64_t nodeid;            /* Inode ID */\n"
"    uint64_t generation;        /* Inode generation */\n"
"    uint64_t entry_valid;\n"
"    uint64_t attr_valid;\n"
"    uint32_t entry_valid_nsec;\n"
"    uint32_t attr_valid_nsec;\n"
"    struct fuse_attr attr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:386
msgid ""
"The combination of I<nodeid> and I<generation> must be unique for the "
"filesystem's lifetime."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:391
msgid "The interpretation of timeouts and I<attr> is as for B<FUSE_GETATTR>."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:391
#, no-wrap
msgid "B<FUSE_FLUSH>"
msgstr "B<FUSE_FLUSH>"

#. type: Plain text
#: build/C/man4/fuse.4:401
#, no-wrap
msgid ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"

#. type: Plain text
#: build/C/man4/fuse.4:409
msgid ""
"The requested action is to flush any pending changes to the indicated file "
"handle.  No reply data is expected.  However, an empty reply message still "
"needs to be issued once the flush operation is complete."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:409
#, no-wrap
msgid "B<FUSE_RELEASE> and B<FUSE_RELEASEDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:419
#, no-wrap
msgid ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"

#. type: Plain text
#: build/C/man4/fuse.4:434
msgid ""
"These are the converse of B<FUSE_OPEN> and B<FUSE_OPENDIR> respectively.  "
"The daemon may now free any resources associated with the file handle I<fh> "
"as the kernel will no longer refer to it.  There is no reply data associated "
"with this request, but a reply still needs to be issued once the request has "
"been completely processed."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:434
#, no-wrap
msgid "B<FUSE_STATFS>"
msgstr "B<FUSE_STATFS>"

#. type: Plain text
#: build/C/man4/fuse.4:441
msgid ""
"This operation implements B<statfs>(2)  for this filesystem.  There is no "
"input data associated with this request.  The expected reply data has the "
"following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:456
#, no-wrap
msgid ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"
msgstr ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"

#. type: Plain text
#: build/C/man4/fuse.4:460
#, no-wrap
msgid ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"
msgstr ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"

#. type: Plain text
#: build/C/man4/fuse.4:465
msgid "For the interpretation of these fields, see B<statfs>(2)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:473
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer and the request was B<FUSE_SETXATTR>."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:482
msgid ""
"Returned from B<write>(2)  if validation of the reply failed.  Not all "
"mistakes in replies will be caught by this validation.  However, basic "
"mistakes, such as short replies or an incorrect I<unique> value, are "
"detected."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:487
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:493
msgid ""
"I<Note>: There are various ways in which incorrect use of these interfaces "
"can cause operations on the provided filesystem's files and directories to "
"fail with B<EIO>.  Among the possible incorrect uses are:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:498
msgid ""
"changing I<mode & S_IFMT> for an inode that has previously been reported to "
"the kernel; or"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:500
msgid ""
"giving replies to the kernel that are shorter than what the kernel expected."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:508
msgid ""
"Returned from B<read>(2)  and B<write>(2)  if the FUSE filesystem was "
"unmounted."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:513
msgid ""
"Returned from operations on a I</dev/fuse> file descriptor that has not been "
"mounted."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:515
msgid "The FUSE filesystem is Linux-specific."
msgstr "FUSE ファイルシステムは Linux 独自である。"

#. type: Plain text
#: build/C/man4/fuse.4:517
msgid "The following messages are not yet documented in this manual page:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:551
#, no-wrap
msgid ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"
msgstr ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"

#. type: Plain text
#: build/C/man4/fuse.4:556
msgid "B<fusermount>(1), B<mount.fuse>(8)"
msgstr "B<fusermount>(1), B<mount.fuse>(8)"

#. type: TH
#: build/C/man4/loop.4:26
#, no-wrap
msgid "LOOP"
msgstr "LOOP"

#. type: Plain text
#: build/C/man4/loop.4:29
msgid "loop, loop-control - loop devices"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:31
msgid "#include E<lt>linux/loop.hE<gt>"
msgstr "#include E<lt>linux/loop.hE<gt>"

#. type: Plain text
#: build/C/man4/loop.4:41
msgid ""
"The loop device is a block device that maps its data blocks not to a "
"physical device such as a hard disk or optical disk drive, but to the blocks "
"of a regular file in a filesystem or to another block device.  This can be "
"useful for example to provide a block device for a filesystem image stored "
"in a file, so that it can be mounted with the B<mount>(8)  command.  You "
"could do"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:49
#, no-wrap
msgid ""
"$ B<dd if=/dev/zero of=file.img bs=1MiB count=10>\n"
"$ B<sudo losetup /dev/loop4 file.img>\n"
"$ B<sudo mkfs -t ext4 /dev/loop4>\n"
"$ B<sudo mkdir /myloopdev>\n"
"$ B<sudo mount /dev/loop4 /myloopdev>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:55
msgid "See B<losetup>(8)  for another example."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:58
msgid ""
"A transfer function can be specified for each loop device for encryption and "
"decryption purposes."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:62
msgid ""
"The following B<ioctl>(2)  operations are provided by the loop block device:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:62
#, no-wrap
msgid "B<LOOP_SET_FD>"
msgstr "B<LOOP_SET_FD>"

#. type: Plain text
#: build/C/man4/loop.4:68
msgid ""
"Associate the loop device with the open file whose file descriptor is passed "
"as the (third)  B<ioctl>(2)  argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:68
#, no-wrap
msgid "B<LOOP_CLR_FD>"
msgstr "B<LOOP_CLR_FD>"

#. type: Plain text
#: build/C/man4/loop.4:71
#, fuzzy
#| msgid "isfdtype - test file type of a file descriptor"
msgid "Disassociate the loop device from any file descriptor."
msgstr "isfdtype - ファイルディスクリプターのファイル種別を検査する"

#. type: TP
#: build/C/man4/loop.4:71
#, no-wrap
msgid "B<LOOP_SET_STATUS>"
msgstr "B<LOOP_SET_STATUS>"

#. type: Plain text
#: build/C/man4/loop.4:81
msgid ""
"Set the status of the loop device using the (third)  B<ioctl>(2)  argument.  "
"This argument is a pointer to a I<loop_info> structure, defined in "
"I<E<lt>linux/loop.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:100
#, no-wrap
msgid ""
"struct loop_info {\n"
"    int           lo_number;      /* ioctl r/o */\n"
"    dev_t         lo_device;      /* ioctl r/o */\n"
"    unsigned long lo_inode;       /* ioctl r/o */\n"
"    dev_t         lo_rdevice;     /* ioctl r/o */\n"
"    int           lo_offset;\n"
"    int           lo_encrypt_type;\n"
"    int           lo_encrypt_key_size;  /* ioctl w/o */\n"
"    int           lo_flags;       /* ioctl r/w (r/o before\n"
"                                     Linux 2.6.25) */\n"
"    char          lo_name[LO_NAME_SIZE];\n"
"    unsigned char lo_encrypt_key[LO_KEY_SIZE];\n"
"                                  /* ioctl w/o */\n"
"    unsigned long lo_init[2];\n"
"    char          reserved[4];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:117
msgid ""
"The encryption type (I<lo_encrypt_type>)  should be one of B<LO_CRYPT_NONE>, "
"B<LO_CRYPT_XOR>, B<LO_CRYPT_DES>, B<LO_CRYPT_FISH2>, B<LO_CRYPT_BLOW>, "
"B<LO_CRYPT_CAST128>, B<LO_CRYPT_IDEA>, B<LO_CRYPT_DUMMY>, "
"B<LO_CRYPT_SKIPJACK>, or (since Linux 2.6.0)  B<LO_CRYPT_CRYPTOAPI>."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:121
#, fuzzy
#| msgid ""
#| "This I<flags> argument is formed by ORing zero or more of the following "
#| "flags:"
msgid ""
"The I<lo_flags> field is a bit mask that can include zero or more of the "
"following:"
msgstr ""
"この I<flags> 引数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man4/loop.4:122
#, no-wrap
msgid "B<LO_FLAGS_READ_ONLY>"
msgstr "B<LO_FLAGS_READ_ONLY>"

#. type: Plain text
#: build/C/man4/loop.4:125
msgid "The loopback device is read-only."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:125
#, no-wrap
msgid "B<LO_FLAGS_AUTOCLEAR> (since Linux 2.6.25)"
msgstr "B<LO_FLAGS_AUTOCLEAR> (Linux 2.6.25 以降)"

#.  commit 96c5865559cee0f9cbc5173f3c949f6ce3525581
#. type: Plain text
#: build/C/man4/loop.4:129
msgid "The loopback device will autodestruct on last close."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:129
#, no-wrap
msgid "B<LO_FLAGS_PARTSCAN> (since Linux 3.2)"
msgstr "B<LO_FLAGS_PARTSCAN> (Linux 3.2 以降)"

#.  commit e03c8dd14915fabc101aa495828d58598dc5af98
#. type: Plain text
#: build/C/man4/loop.4:133
msgid "Allow automatic partition scanning."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:133
#, no-wrap
msgid "B<LO_FLAGS_DIRECT_IO> (since Linux 4.10)"
msgstr "B<LO_FLAGS_DIRECT_IO> (Linux 4.10 以降)"

#.  commit 2e5ab5f379f96a6207c45be40c357ebb1beb8ef3
#. type: Plain text
#: build/C/man4/loop.4:137
msgid "Use direct I/O mode to access the backing file."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:147
msgid ""
"The only I<lo_flags> that can be modified by B<LOOP_SET_STATUS> are "
"B<LO_FLAGS_AUTOCLEAR> and B<LO_FLAGS_PARTSCAN>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:147
#, no-wrap
msgid "B<LOOP_GET_STATUS>"
msgstr "B<LOOP_GET_STATUS>"

#. type: Plain text
#: build/C/man4/loop.4:154
msgid ""
"Get the status of the loop device.  The (third)  B<ioctl>(2)  argument must "
"be a pointer to a I<struct loop_info>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:154
#, no-wrap
msgid "B<LOOP_CHANGE_FD> (since Linux 2.6.5)"
msgstr "B<LOOP_CHANGE_FD> (Linux 2.6.5 以降)"

#. type: Plain text
#: build/C/man4/loop.4:162
msgid ""
"Switch the backing store of the loop device to the new file identified file "
"descriptor specified in the (third)  B<ioctl>(2)  argument, which is an "
"integer.  This operation is possible only if the loop device is read-only "
"and the new backing store is the same size and type as the old backing store."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:162
#, no-wrap
msgid "B<LOOP_SET_CAPACITY> (since Linux 2.6.30)"
msgstr "B<LOOP_SET_CAPACITY> (Linux 2.6.30 以降)"

#.  commit 53d6660836f233df66490707365ab177e5fb2bb4
#. type: Plain text
#: build/C/man4/loop.4:169
msgid ""
"Resize a live loop device.  One can change the size of the underlying "
"backing store and then use this operation so that the loop driver learns "
"about the new size.  This operation takes no argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:169
#, no-wrap
msgid "B<LOOP_SET_DIRECT_IO> (since Linux 4.10)"
msgstr "B<LOOP_SET_DIRECT_IO> (Linux 4.10 以降)"

#.  commit ab1cb278bc7027663adbfb0b81404f8398437e11
#. type: Plain text
#: build/C/man4/loop.4:178
msgid ""
"Set DIRECT I/O mode on the loop device, so that it can be used to open "
"backing file.  The (third)  B<ioctl>(2)  argument is an unsigned long "
"value.  A nonzero represents direct I/O mode."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:178
#, no-wrap
msgid "B<LOOP_SET_BLOCK_SIZE> (since Linux 4.14)"
msgstr "B<LOOP_SET_BLOCK_SIZE> (Linux 4.14 以降)"

#.  commit 89e4fdecb51cf5535867026274bc97de9480ade5
#. type: Plain text
#: build/C/man4/loop.4:190
msgid ""
"Set the block size of the loop device.  The (third)  B<ioctl>(2)  argument "
"is an unsigned long value.  This value must be a power of two in the range "
"[512,pagesize]; otherwise, an B<EINVAL> error results."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:190
#, no-wrap
msgid "B<LOOP_CONFIGURE> (since Linux 5.8)"
msgstr "B<LOOP_CONFIGURE> (Linux 5.8 以降)"

#.  commit 3448914e8cc550ba792d4ccc74471d1ca4293aae
#. type: Plain text
#: build/C/man4/loop.4:202
msgid ""
"Setup and configure all loop device parameters in a single step using the "
"(third)  B<ioctl>(2)  argument.  This argument is a pointer to a "
"I<loop_config> structure, defined in I<E<lt>linux/loop.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:211
#, no-wrap
msgid ""
"struct loop_config {\n"
"    __u32               fd;\n"
"    __u32               block_size;\n"
"    struct loop_info64  info;\n"
"    __u64               __reserved[8];\n"
"};\n"
msgstr ""
"struct loop_config {\n"
"    __u32               fd;\n"
"    __u32               block_size;\n"
"    struct loop_info64  info;\n"
"    __u64               __reserved[8];\n"
"};\n"

#. type: Plain text
#: build/C/man4/loop.4:219
msgid ""
"In addition to doing what B<LOOP_SET_STATUS> can do, B<LOOP_CONFIGURE> can "
"also be used to do the following:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:223
msgid ""
"set the correct block size immediately by setting I<loop_config.block_size>;"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:229
msgid ""
"explicitly request direct I/O mode by setting B<LO_FLAGS_DIRECT_IO> in "
"I<loop_config.info.lo_flags>; and"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:234
msgid ""
"explicitly request read-only mode by setting B<LO_FLAGS_READ_ONLY> in "
"I<loop_config.info.lo_flags>."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:239
msgid "Since Linux 2.6, there are two new B<ioctl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:239
#, no-wrap
msgid "B<LOOP_SET_STATUS64>, B<LOOP_GET_STATUS64>"
msgstr "B<LOOP_SET_STATUS64>, B<LOOP_GET_STATUS64>"

#. type: Plain text
#: build/C/man4/loop.4:247
msgid ""
"These are similar to B<LOOP_SET_STATUS> and B<LOOP_GET_STATUS> described "
"above but use the I<loop_info64> structure, which has some additional fields "
"and a larger range for some other fields:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:266
#, no-wrap
msgid ""
"struct loop_info64 {\n"
"    uint64_t lo_device;           /* ioctl r/o */\n"
"    uint64_t lo_inode;            /* ioctl r/o */\n"
"    uint64_t lo_rdevice;          /* ioctl r/o */\n"
"    uint64_t lo_offset;\n"
"    uint64_t lo_sizelimit;  /* bytes, 0 == max available */\n"
"    uint32_t lo_number;           /* ioctl r/o */\n"
"    uint32_t lo_encrypt_type;\n"
"    uint32_t lo_encrypt_key_size; /* ioctl w/o */\n"
"    uint32_t lo_flags; i          /* ioctl r/w (r/o before\n"
"                                     Linux 2.6.25) */\n"
"    uint8_t  lo_file_name[LO_NAME_SIZE];\n"
"    uint8_t  lo_crypt_name[LO_NAME_SIZE];\n"
"    uint8_t  lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */\n"
"    uint64_t lo_init[2];\n"
"};\n"
msgstr ""

#. type: SS
#: build/C/man4/loop.4:268
#, no-wrap
msgid "/dev/loop-control"
msgstr "/dev/loop-control"

#.  commit 770fe30a46a12b6fb6b63fbe1737654d28e84844
#. type: Plain text
#: build/C/man4/loop.4:280
msgid ""
"Since Linux 3.1, the kernel provides the I</dev/loop-control> device, which "
"permits an application to dynamically find a free device, and to add and "
"remove loop devices from the system.  To perform these operations, one first "
"opens I</dev/loop-control> and then employs one of the following "
"B<ioctl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:280
#, no-wrap
msgid "B<LOOP_CTL_GET_FREE>"
msgstr "B<LOOP_CTL_GET_FREE>"

#. type: Plain text
#: build/C/man4/loop.4:285
msgid ""
"Allocate or find a free loop device for use.  On success, the device number "
"is returned as the result of the call.  This operation takes no argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:285
#, no-wrap
msgid "B<LOOP_CTL_ADD>"
msgstr "B<LOOP_CTL_ADD>"

#. type: Plain text
#: build/C/man4/loop.4:294
msgid ""
"Add the new loop device whose device number is specified as a long integer "
"in the third B<ioctl>(2)  argument.  On success, the device index is "
"returned as the result of the call.  If the device is already allocated, the "
"call fails with the error B<EEXIST>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:294
#, no-wrap
msgid "B<LOOP_CTL_REMOVE>"
msgstr "B<LOOP_CTL_REMOVE>"

#. type: Plain text
#: build/C/man4/loop.4:303
msgid ""
"Remove the loop device whose device number is specified as a long integer in "
"the third B<ioctl>(2)  argument.  On success, the device number is returned "
"as the result of the call.  If the device is in use, the call fails with the "
"error B<EBUSY>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:304
#, no-wrap
msgid "I</dev/loop*>"
msgstr "I</dev/loop*>"

#. type: Plain text
#: build/C/man4/loop.4:307
msgid "The loop block special device files."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:314
msgid ""
"The program below uses the I</dev/loop-control> device to find a free loop "
"device, opens the loop device, opens a file to be used as the underlying "
"storage for the device, and then associates the loop device with the backing "
"store.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:323
#, no-wrap
msgid ""
"$ B<dd if=/dev/zero of=file.img bs=1MiB count=10>\n"
"10+0 records in\n"
"10+0 records out\n"
"10485760 bytes (10 MB) copied, 0.00609385 s, 1.7 GB/s\n"
"$ B<sudo ./mnt_loop file.img>\n"
"loopname = /dev/loop5\n"
msgstr ""
"$ B<dd if=/dev/zero of=file.img bs=1MiB count=10>\n"
"10+0 records in\n"
"10+0 records out\n"
"10485760 bytes (10 MB) copied, 0.00609385 s, 1.7 GB/s\n"
"$ B<sudo ./mnt_loop file.img>\n"
"loopname = /dev/loop5\n"

#. type: Plain text
#: build/C/man4/loop.4:334
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/loop.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/loop.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man4/loop.4:337
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man4/loop.4:344
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int loopctlfd, loopfd, backingfile;\n"
"    long devnr;\n"
"    char loopname[4096];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int loopctlfd, loopfd, backingfile;\n"
"    long devnr;\n"
"    char loopname[4096];\n"

#. type: Plain text
#: build/C/man4/loop.4:349
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s backing-file\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s backing-file\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man4/loop.4:353
#, no-wrap
msgid ""
"    loopctlfd = open(\"/dev/loop-control\", O_RDWR);\n"
"    if (loopctlfd == -1)\n"
"        errExit(\"open: /dev/loop-control\");\n"
msgstr ""
"    loopctlfd = open(\"/dev/loop-control\", O_RDWR);\n"
"    if (loopctlfd == -1)\n"
"        errExit(\"open: /dev/loop-control\");\n"

#. type: Plain text
#: build/C/man4/loop.4:357
#, no-wrap
msgid ""
"    devnr = ioctl(loopctlfd, LOOP_CTL_GET_FREE);\n"
"    if (devnr == -1)\n"
"        errExit(\"ioctl-LOOP_CTL_GET_FREE\");\n"
msgstr ""
"    devnr = ioctl(loopctlfd, LOOP_CTL_GET_FREE);\n"
"    if (devnr == -1)\n"
"        errExit(\"ioctl-LOOP_CTL_GET_FREE\");\n"

#. type: Plain text
#: build/C/man4/loop.4:360
#, no-wrap
msgid ""
"    sprintf(loopname, \"/dev/loop%ld\", devnr);\n"
"    printf(\"loopname = %s\\en\", loopname);\n"
msgstr ""
"    sprintf(loopname, \"/dev/loop%ld\", devnr);\n"
"    printf(\"loopname = %s\\en\", loopname);\n"

#. type: Plain text
#: build/C/man4/loop.4:364
#, no-wrap
msgid ""
"    loopfd = open(loopname, O_RDWR);\n"
"    if (loopfd == -1)\n"
"        errExit(\"open: loopname\");\n"
msgstr ""
"    loopfd = open(loopname, O_RDWR);\n"
"    if (loopfd == -1)\n"
"        errExit(\"open: loopname\");\n"

#. type: Plain text
#: build/C/man4/loop.4:368
#, no-wrap
msgid ""
"    backingfile = open(argv[1], O_RDWR);\n"
"    if (backingfile == -1)\n"
"        errExit(\"open: backing-file\");\n"
msgstr ""
"    backingfile = open(argv[1], O_RDWR);\n"
"    if (backingfile == -1)\n"
"        errExit(\"open: backing-file\");\n"

#. type: Plain text
#: build/C/man4/loop.4:371
#, no-wrap
msgid ""
"    if (ioctl(loopfd, LOOP_SET_FD, backingfile) == -1)\n"
"        errExit(\"ioctl-LOOP_SET_FD\");\n"
msgstr ""
"    if (ioctl(loopfd, LOOP_SET_FD, backingfile) == -1)\n"
"        errExit(\"ioctl-LOOP_SET_FD\");\n"

#. type: Plain text
#: build/C/man4/loop.4:378
msgid "B<losetup>(8), B<mount>(8)"
msgstr "B<losetup>(8), B<mount>(8)"

#. type: TH
#: build/C/man7/inode.7:25
#, no-wrap
msgid "INODE"
msgstr "INODE"

#. type: Plain text
#: build/C/man7/inode.7:28
msgid "inode - file inode information"
msgstr "inode - ファイルの inode 情報"

#. type: Plain text
#: build/C/man7/inode.7:39
msgid ""
"Each file has an inode containing metadata about the file.  An application "
"can retrieve this metadata using B<stat>(2)  (or related calls), which "
"returns a I<stat> structure, or B<statx>(2), which returns a I<statx> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:46
msgid ""
"The following is a list of the information typically found in, or associated "
"with, the file inode, with the names of the corresponding structure fields "
"returned by B<stat>(2)  and B<statx>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:46
#, no-wrap
msgid "Device where inode resides"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:49
msgid "I<stat.st_dev>; I<statx.stx_dev_minor> and I<statx.stx_dev_major>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:55
msgid ""
"Each inode (as well as the associated file) resides in a filesystem that is "
"hosted on a device.  That device is identified by the combination of its "
"major ID (which identifies the general class of device)  and minor ID (which "
"identifies a specific instance in the general class)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:55
#, no-wrap
msgid "Inode number"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:58
msgid "I<stat.st_ino>; I<statx.stx_ino>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:64
msgid ""
"Each file in a filesystem has a unique inode number.  Inode numbers are "
"guaranteed to be unique only within a filesystem (i.e., the same inode "
"numbers may be used by different filesystems, which is the reason that hard "
"links may not cross filesystem boundaries).  This field contains the file's "
"inode number."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:64
#, no-wrap
msgid "File type and mode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:67
msgid "I<stat.st_mode>; I<statx.stx_mode>"
msgstr "I<stat.st_mode>; I<statx.stx_mode>"

#. type: Plain text
#: build/C/man7/inode.7:69
msgid "See the discussion of file type and mode, below."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:69
#, no-wrap
msgid "Link count"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:72
msgid "I<stat.st_nlink>; I<statx.stx_nlink>"
msgstr "I<stat.st_nlink>; I<statx.stx_nlink>"

#. type: Plain text
#: build/C/man7/inode.7:76
msgid ""
"This field contains the number of hard links to the file.  Additional links "
"to an existing file are created using B<link>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:76
#, no-wrap
msgid "User ID"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:80
msgid "I<st_uid> I<stat.st_uid>; I<statx.stx_uid>"
msgstr "I<st_uid> I<stat.st_uid>; I<statx.stx_uid>"

#. type: Plain text
#: build/C/man7/inode.7:86
msgid ""
"This field records the user ID of the owner of the file.  For newly created "
"files, the file user ID is the effective user ID of the creating process.  "
"The user ID of a file can be changed using B<chown>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:86
#, no-wrap
msgid "Group ID"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:89
msgid "I<stat.st_gid>; I<statx.stx_gid>"
msgstr "I<stat.st_gid>; I<statx.stx_gid>"

#. type: Plain text
#: build/C/man7/inode.7:98
msgid ""
"The inode records the ID of the group owner of the file.  For newly created "
"files, the file group ID is either the group ID of the parent directory or "
"the effective group ID of the creating process, depending on whether or not "
"the set-group-ID bit is set on the parent directory (see below).  The group "
"ID of a file can be changed using B<chown>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:98
#, no-wrap
msgid "Device represented by this inode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:101
msgid "I<stat.st_rdev>; I<statx.stx_rdev_minor> and I<statx.stx_rdev_major>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:104
msgid ""
"If this file (inode) represents a device, then the inode records the major "
"and minor ID of that device."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:104
#, no-wrap
msgid "File size"
msgstr "ファイルサイズ"

#. type: Plain text
#: build/C/man7/inode.7:107
msgid "I<stat.st_size>; I<statx.stx_size>"
msgstr "I<stat.st_size>; I<statx.stx_size>"

#. type: TP
#: build/C/man7/inode.7:112
#, no-wrap
msgid "Preferred block size for I/O"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:115
msgid "I<stat.st_blksize>; I<statx.stx_blksize>"
msgstr "I<stat.st_blksize>; I<statx.stx_blksize>"

#. type: Plain text
#: build/C/man7/inode.7:119
#, fuzzy
#| msgid ""
#| "The I<st_blksize> field gives the \"preferred\" blocksize for efficient "
#| "filesystem I/O.  (Writing to a file in smaller chunks may cause an "
#| "inefficient read-modify-rewrite.)"
msgid ""
"This field gives the \"preferred\" blocksize for efficient filesystem I/O.  "
"(Writing to a file in smaller chunks may cause an inefficient read-modify-"
"rewrite.)"
msgstr ""
"I<st_blksize> フィールドは、効率的にファイルシステム I/O ができる「好まし"
"い」 ブロックサイズを示す (もっと小さい単位でファイルに書き込みを行うと、 読"
"み出し--修正--再書き込みといった非効率な動作になってしまうかもしれない)。"

#. type: TP
#: build/C/man7/inode.7:119
#, no-wrap
msgid "Number of blocks allocated to the file"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:122
msgid "I<stat.st_blocks>; I<statx.stx_size>"
msgstr "I<stat.st_blocks>; I<statx.stx_size>"

#. type: Plain text
#: build/C/man7/inode.7:128
#, fuzzy
#| msgid ""
#| "The I<st_blocks> field indicates the number of blocks allocated to the "
#| "file, 512-byte units.  (This may be smaller than I<st_size>/512 when the "
#| "file has holes.)"
msgid ""
"This field indicates the number of blocks allocated to the file, 512-byte "
"units, (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""
"I<st_blocks> フィールドは、ファイルの大きさを 512 バイトのブロックサイズ単位"
"で示す フィールドは、ファイルに割り当てされたブロック数を 512 バイト単位で示"
"す。 (ファイルに穴があるような場合、この値は I<st_size>/512 より小さくなるこ"
"ともある)。"

#.  Rationale for sys/stat.h in POSIX.1-2008
#. type: Plain text
#: build/C/man7/inode.7:139
msgid ""
"The POSIX.1 standard notes that the unit for the I<st_blocks> member of the "
"I<stat> structure is not defined by the standard.  On many implementations "
"it is 512 bytes; on a few systems, a different unit is used, such as 1024.  "
"Furthermore, the unit may differ on a per-filesystem basis."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:139
#, no-wrap
msgid "Last access timestamp (atime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:142
msgid "I<stat.st_atime>; I<statx.stx_atime>"
msgstr "I<stat.st_atime>; I<statx.stx_atime>"

#. type: Plain text
#: build/C/man7/inode.7:155
#, fuzzy
#| msgid ""
#| "The field I<st_atime> is changed by file accesses, for example, by "
#| "B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2), and B<read>(2)  (of "
#| "more than zero bytes).  Other routines, like B<mmap>(2), may or may not "
#| "update I<st_atime>."
msgid ""
"This is the file's last access timestamp.  It is changed by file accesses, "
"for example, by B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2), and "
"B<read>(2)  (of more than zero bytes).  Other interfaces, such as "
"B<mmap>(2), may or may not update the atime timestamp"
msgstr ""
"I<st_atime> フィールドはファイルアクセスがあった場合に変更される (例えば、 "
"B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2)  を使用した場合や "
"B<read>(2)  で 1 バイト以上読み込んだ場合など)。 B<mmap>(2)  などの他のルーチ"
"ンでは、 I<st_atime> は更新されることもあれば、そうでない場合もある。"

#. type: Plain text
#: build/C/man7/inode.7:172
#, fuzzy
#| msgid ""
#| "Not all of the Linux filesystems implement all of the time fields.  Some "
#| "filesystem types allow mounting in such a way that file and/or directory "
#| "accesses do not cause an update of the I<st_atime> field.  (See "
#| "I<noatime>, I<nodiratime>, and I<relatime> in B<mount>(8), and related "
#| "information in B<mount>(2).)  In addition, I<st_atime> is not updated if "
#| "a file is opened with the B<O_NOATIME>; see B<open>(2)."
msgid ""
"Some filesystem types allow mounting in such a way that file and/or "
"directory accesses do not cause an update of the atime timestamp.  (See "
"I<noatime>, I<nodiratime>, and I<relatime> in B<mount>(8), and related "
"information in B<mount>(2).)  In addition, the atime timestamp is not "
"updated if a file is opened with the B<O_NOATIME> flag; see B<open>(2)."
msgstr ""
"全ての Linux のファイルシステムが全ての時間フィールドを 実装しているわけでは"
"ない。 ファイルやディレクトリのアクセスが I<st_atime> フィールドを更新しない"
"ようなかたちでマウントできるファイルシステムもある。 (B<mount>(8)  の "
"I<noatime>, I<nodiratime>, I<relatime> や B<mount>(2)  の関連する情報を参"
"照)。 また、ファイルが B<O_NOATIME> 付きでオープンされている場合には "
"I<st_atime> は更新されない。 B<open>(2)  参照。"

#. type: TP
#: build/C/man7/inode.7:172
#, no-wrap
msgid "File creation (birth) timestamp (btime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:175
msgid "(not returned in the I<stat> structure); I<statx.stx_btime>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:178
msgid ""
"The file's creation timestamp.  This is set on file creation and not changed "
"subsequently."
msgstr ""

#.  FIXME Is it supported on ext4 and XFS?
#. type: Plain text
#: build/C/man7/inode.7:182
msgid ""
"The btime timestamp was not historically present on UNIX systems and is not "
"currently supported by most Linux filesystems."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:182
#, no-wrap
msgid "Last modification timestamp (mtime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:185
msgid "I<stat.st_mtime>; I<statx.stx_mtime>"
msgstr "I<stat.st_mtime>; I<statx.stx_mtime>"

#. type: Plain text
#: build/C/man7/inode.7:200
#, fuzzy
#| msgid ""
#| "The field I<st_mtime> is changed by file modifications, for example, by "
#| "B<mknod>(2), B<truncate>(2), B<utime>(2), and B<write>(2)  (of more than "
#| "zero bytes).  Moreover, I<st_mtime> of a directory is changed by the "
#| "creation or deletion of files in that directory.  The I<st_mtime> field "
#| "is I<not> changed for changes in owner, group, hard link count, or mode."
msgid ""
"This is the file's last modification timestamp.  It is changed by file "
"modifications, for example, by B<mknod>(2), B<truncate>(2), B<utime>(2), and "
"B<write>(2)  (of more than zero bytes).  Moreover, the mtime timestamp of a "
"directory is changed by the creation or deletion of files in that "
"directory.  The mtime timestamp is I<not> changed for changes in owner, "
"group, hard link count, or mode."
msgstr ""
"I<st_mtime> フィールドは、ファイルが修正された場合に変更される (例えば、 "
"B<mknod>(2), B<truncate>(2), B<utime>(2)  を使用した場合や B<write>(2)  で 1 "
"バイト以上書き込みをした場合など)。 さらに、ディレクトリの I<st_mtime> は、そ"
"のディレクトリで ファイルが作成されたり削除されたりすると変更される。 "
"I<st_mtime> フィールドは 所有者やグループやハードリンク数やモードの変更では変"
"更 I<されない。>"

#. type: TP
#: build/C/man7/inode.7:200
#, no-wrap
msgid "Last status change timestamp (ctime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:203
msgid "I<stat.st_ctime>; I<statx.stx_ctime>"
msgstr "I<stat.st_ctime>; I<statx.stx_ctime>"

#. type: Plain text
#: build/C/man7/inode.7:207
#, fuzzy
#| msgid ""
#| "The field I<st_ctime> is changed by writing or by setting inode "
#| "information (i.e., owner, group, link count, mode, etc.)."
msgid ""
"This is the file's last status change timestamp.  It is changed by writing "
"or by setting inode information (i.e., owner, group, link count, mode, etc.)."
msgstr ""
"I<st_ctime> フィールドは書き込みや inode 情報 (所有者、グループ、リンク数、"
"モードなど) の 設定によって変更される。"

#. type: Plain text
#: build/C/man7/inode.7:212
msgid ""
"The timestamp fields report time measured with a zero point at the I<Epoch>, "
"1970-01-02 00:00:00 +0000, UTC (see B<time>(7))."
msgstr ""

#.  commit ef7f38359ea8b3e9c7f2cae9a4d4935f55ca9e80
#. type: Plain text
#: build/C/man7/inode.7:235
#, fuzzy
#| msgid ""
#| "Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since "
#| "Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, "
#| "and Reiserfs.  On filesystems that do not support subsecond timestamps, "
#| "the nanosecond fields are returned with the value 0."
msgid ""
"Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since "
"Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, and "
"Reiserfs.  In order to return timestamps with nanosecond precision, the "
"timestamp fields in the I<stat> and I<statx> structures are defined as "
"structures that include a nanosecond component.  See B<stat>(2)  and "
"B<statx>(2)  for details.  On filesystems that do not support subsecond "
"timestamps, the nanosecond fields in the I<stat> and I<statx> structures are "
"returned with the value 0."
msgstr ""
"ナノ秒のタイムスタンプは XFS, JFS, Btrfs, ext4 でサポートされている (Linux "
"2.6.23 以降)。 ナノ秒のタイムスタンプは ext2, ext3, Reiserfs ではサポートされ"
"ていない。 サブ秒のタイムスタンプをサポートしていないファイルシステムでは、 "
"ナノ秒のフィールドには値 0 が入る。"

#. type: SS
#: build/C/man7/inode.7:235
#, no-wrap
msgid "The file type and mode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:243
msgid ""
"The I<stat.st_mode> field (for B<statx>(2), the I<statx.stx_mode> field) "
"contains the file type and mode."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:254
msgid ""
"POSIX refers to the I<stat.st_mode> bits corresponding to the mask B<S_IFMT> "
"(see below) as the I<file type>, the 12 bits corresponding to the mask 07777 "
"as the I<file mode bits> and the least significant 9 bits (0777) as the "
"I<file permission bits>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:256
#, fuzzy
#| msgid ""
#| "The following mask values are defined for the file type component of the "
#| "I<st_mode> field:"
msgid "The following mask values are defined for the file type:"
msgstr ""
"以下のマスク値が I<st_mode> フィールドのファイル種別の検査用に定義されてい"
"る。"

#. type: tbl table
#: build/C/man7/inode.7:259
#, no-wrap
msgid "S_IFMT"
msgstr "S_IFMT"

#. type: tbl table
#: build/C/man7/inode.7:259
#, no-wrap
msgid "0170000"
msgstr "0170000"

#. type: tbl table
#: build/C/man7/inode.7:259
#, fuzzy, no-wrap
#| msgid "bit mask for the file type bit fields"
msgid "bit mask for the file type bit field"
msgstr "ファイル種別を示すビット領域を表すビットマスク"

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "S_IFSOCK"
msgstr "S_IFSOCK"

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "0140000"
msgstr "0140000"

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "socket"
msgstr "ソケット"

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "S_IFLNK"
msgstr "S_IFLNK"

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "0120000"
msgstr "0120000"

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "symbolic link"
msgstr "シンボリックリンク"

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "S_IFREG"
msgstr "S_IFREG"

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "0100000"
msgstr "0100000"

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "regular file"
msgstr "通常のファイル"

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "S_IFBLK"
msgstr "S_IFBLK"

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "0060000"
msgstr "0060000"

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "block device"
msgstr "ブロックデバイス"

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "S_IFDIR"
msgstr "S_IFDIR"

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "0040000"
msgstr "0040000"

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "directory"
msgstr "ディレクトリ"

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "S_IFCHR"
msgstr "S_IFCHR"

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "0020000"
msgstr "0020000"

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "character device"
msgstr "キャラクターデバイス"

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "S_IFIFO"
msgstr "S_IFIFO"

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "0010000"
msgstr "0010000"

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "FIFO"
msgstr "FIFO"

#. type: Plain text
#: build/C/man7/inode.7:272
msgid "Thus, to test for a regular file (for example), one could write:"
msgstr ""
"したがって、(例えば) 通常のファイルかどうかを検査するには、以下のようにすれば"
"よい。"

#. type: Plain text
#: build/C/man7/inode.7:279
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if ((sb.st_mode & S_IFMT) == S_IFREG) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""
"stat(pathname, &sb);\n"
"if ((sb.st_mode & S_IFMT) == S_IFREG) {\n"
"    /* Handle regular file */\n"
"}\n"

#. type: Plain text
#: build/C/man7/inode.7:286
msgid ""
"Because tests of the above form are common, additional macros are defined by "
"POSIX to allow the test of the file type in I<st_mode> to be written more "
"concisely:"
msgstr ""
"上記の形の検査はよくあるので、 POSIX では以下のマクロが定義されており、 "
"I<st_mode> のファイル種別の検査をより簡単に書けるようになっている。"

#. type: TP
#: build/C/man7/inode.7:287
#, no-wrap
msgid "B<S_ISREG>(m)"
msgstr "B<S_ISREG>(m)"

#. type: Plain text
#: build/C/man7/inode.7:290
msgid "is it a regular file?"
msgstr "通常のファイルか?"

#. type: TP
#: build/C/man7/inode.7:290
#, no-wrap
msgid "B<S_ISDIR>(m)"
msgstr "B<S_ISDIR>(m)"

#. type: Plain text
#: build/C/man7/inode.7:293
msgid "directory?"
msgstr "ディレクトリか?"

#. type: TP
#: build/C/man7/inode.7:293
#, no-wrap
msgid "B<S_ISCHR>(m)"
msgstr "B<S_ISCHR>(m)"

#. type: Plain text
#: build/C/man7/inode.7:296
msgid "character device?"
msgstr "キャラクターデバイスか?"

#. type: TP
#: build/C/man7/inode.7:296
#, no-wrap
msgid "B<S_ISBLK>(m)"
msgstr "B<S_ISBLK>(m)"

#. type: Plain text
#: build/C/man7/inode.7:299
msgid "block device?"
msgstr "ブロックデバイスか?"

#. type: TP
#: build/C/man7/inode.7:299
#, no-wrap
msgid "B<S_ISFIFO>(m)"
msgstr "B<S_ISFIFO>(m)"

#. type: Plain text
#: build/C/man7/inode.7:302
msgid "FIFO (named pipe)?"
msgstr "FIFO (名前付きパイプ) か?"

#. type: TP
#: build/C/man7/inode.7:302
#, no-wrap
msgid "B<S_ISLNK>(m)"
msgstr "B<S_ISLNK>(m)"

#. type: Plain text
#: build/C/man7/inode.7:305
msgid "symbolic link? (Not in POSIX.1-1996.)"
msgstr "シンボリックリンクか? (POSIX.1-1996 にはない)"

#. type: TP
#: build/C/man7/inode.7:305
#, no-wrap
msgid "B<S_ISSOCK>(m)"
msgstr "B<S_ISSOCK>(m)"

#. type: Plain text
#: build/C/man7/inode.7:308
msgid "socket? (Not in POSIX.1-1996.)"
msgstr "ソケットか? (POSIX.1-1996 にはない)"

#. type: Plain text
#: build/C/man7/inode.7:311
msgid "The preceding code snippet could thus be rewritten as:"
msgstr "上で挙げたコードは以下のように書き換えることができる。"

#. type: Plain text
#: build/C/man7/inode.7:318
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if (S_ISREG(sb.st_mode)) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""
"stat(pathname, &sb);\n"
"if (S_ISREG(sb.st_mode)) {\n"
"    /* Handle regular file */\n"
"}\n"

#. type: Plain text
#: build/C/man7/inode.7:337
#, fuzzy
#| msgid ""
#| "The definitions of most of the above file type test macros are provided "
#| "if any of the following feature test macros is defined: B<_BSD_SOURCE> "
#| "(in glibc 2.19 and earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), "
#| "or B<_DEFAULT_SOURCE> (in glibc 2.20 and later).  In addition, "
#| "definitions of all of the above macros except B<S_IFSOCK> and "
#| "B<S_ISSOCK>()  are provided if B<_XOPEN_SOURCE> is defined.  The "
#| "definition of B<S_IFSOCK> can also be exposed by defining "
#| "B<_XOPEN_SOURCE> with a value of 500 or greater."
msgid ""
"The definitions of most of the above file type test macros are provided if "
"any of the following feature test macros is defined: B<_BSD_SOURCE> (in "
"glibc 2.19 and earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), or "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later).  In addition, definitions of "
"all of the above macros except B<S_IFSOCK> and B<S_ISSOCK>()  are provided "
"if B<_XOPEN_SOURCE> is defined."
msgstr ""
"上記のほとんどのファイル種別検査マクロの定義は、 機能検査マクロ "
"B<_BSD_SOURCE> (glibc 2.19 以前の場合)、 B<_SVID_SOURCE> (glibc 2.19 以前の場"
"合)、 B<_DEFAULT_SOURCE> (glibc 2.20 以降の場合) のいずれかが定義されている場"
"合に公開される。 さらに、 B<S_IFSOCK> と B<S_ISSOCK> 以外の上記のすべてのマク"
"ロの定義は B<_XOPEN_SOURCE> が定義されている場合にも公開される。 B<S_IFSOCK> "
"の定義は B<_XOPEN_SOURCE> が値 500 以上で定義された場合にも公開される。"

#. type: Plain text
#: build/C/man7/inode.7:346
msgid ""
"The definition of B<S_IFSOCK> can also be exposed either by defining "
"B<_XOPEN_SOURCE> with a value of 500 or greater or (since glibc 2.24) by "
"defining both B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:361
#, fuzzy
#| msgid ""
#| "The definition of B<S_ISSOCK>()  is exposed if any of the following "
#| "feature test macros is defined: B<_BSD_SOURCE> (in glibc 2.19 and "
#| "earlier), B<_DEFAULT_SOURCE> (in glibc 2.20 and later), B<_XOPEN_SOURCE> "
#| "with a value of 500 or greater, or B<_POSIX_C_SOURCE> with a value of "
#| "200112L or greater."
msgid ""
"The definition of B<S_ISSOCK>()  is exposed if any of the following feature "
"test macros is defined: B<_BSD_SOURCE> (in glibc 2.19 and earlier), "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later), B<_XOPEN_SOURCE> with a value "
"of 500 or greater, B<_POSIX_C_SOURCE> with a value of 200112L or greater, or "
"(since glibc 2.24) by defining both B<_XOPEN_SOURCE> and "
"B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""
"B<S_ISSOCK>() の定義が公開されるのは以下の機能検査マクロが定義されている場合"
"である: B<_BSD_SOURCE> (glibc 2.19 以前の場合)、 B<_DEFAULT_SOURCE> (glibc "
"2.20 以降の場合)、 値 500 以上の B<_XOPEN_SOURCE>、 値が 200112L 以上の "
"B<_POSIX_C_SOURCE>。"

#. type: Plain text
#: build/C/man7/inode.7:366
#, fuzzy
#| msgid ""
#| "The following mask values are defined for the file type component of the "
#| "I<st_mode> field:"
msgid ""
"The following mask values are defined for the file mode component of the "
"I<st_mode> field:"
msgstr ""
"以下のマスク値が I<st_mode> フィールドのファイル種別の検査用に定義されてい"
"る。"

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "S_ISUID"
msgstr "S_ISUID"

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "  04000"
msgstr "  04000"

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "set-user-ID bit (see B<execve>(2))"
msgstr "set-user-ID bit (B<execve>(2) 参照)"

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "S_ISGID"
msgstr "S_ISGID"

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "  02000"
msgstr "  02000"

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "set-group-ID bit (see below)"
msgstr "set-group-ID bit (下記参照)"

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "S_ISVTX"
msgstr "S_ISVTX"

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "  01000"
msgstr "  01000"

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "sticky bit (see below)"
msgstr "スティッキービット (下記参照)"

#. type: tbl table
#: build/C/man7/inode.7:373
#, no-wrap
msgid "S_IRWXU"
msgstr "S_IRWXU"

#. type: tbl table
#: build/C/man7/inode.7:373
#, no-wrap
msgid "  00700"
msgstr "  00700"

#. type: tbl table
#: build/C/man7/inode.7:373
#, fuzzy, no-wrap
#| msgid "owner has execute permission"
msgid "owner has read, write, and execute permission"
msgstr "所有者の実行許可"

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "S_IRUSR"
msgstr "S_IRUSR"

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "  00400"
msgstr "  00400"

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "owner has read permission"
msgstr "所有者の読み込み許可"

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "S_IWUSR"
msgstr "S_IWUSR"

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "  00200"
msgstr "  00200"

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "owner has write permission"
msgstr "所有者の書き込み許可"

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "S_IXUSR"
msgstr "S_IXUSR"

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "  00100"
msgstr "  00100"

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "owner has execute permission"
msgstr "所有者の実行許可"

#. type: tbl table
#: build/C/man7/inode.7:378
#, no-wrap
msgid "S_IRWXG"
msgstr "S_IRWXG"

#. type: tbl table
#: build/C/man7/inode.7:378
#, no-wrap
msgid "  00070"
msgstr "  00070"

#. type: tbl table
#: build/C/man7/inode.7:378
#, fuzzy, no-wrap
#| msgid "group has execute permission"
msgid "group has read, write, and execute permission"
msgstr "グループの実行許可"

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "S_IRGRP"
msgstr "S_IRGRP"

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "  00040"
msgstr "  00040"

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "group has read permission"
msgstr "グループの読み込み許可"

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "S_IWGRP"
msgstr "S_IWGRP"

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "  00020"
msgstr "  00020"

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "group has write permission"
msgstr "グループの書き込み許可"

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "S_IXGRP"
msgstr "S_IXGRP"

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "  00010"
msgstr "  00010"

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "group has execute permission"
msgstr "グループの実行許可"

#. type: tbl table
#: build/C/man7/inode.7:383
#, no-wrap
msgid "S_IRWXO"
msgstr "S_IRWXO"

#. type: tbl table
#: build/C/man7/inode.7:383
#, no-wrap
msgid "  00007"
msgstr "  00007"

#. type: tbl table
#: build/C/man7/inode.7:385
#, fuzzy, no-wrap
#| msgid "others have execute permission"
msgid "others (not in group) have read, write, and execute permission"
msgstr "他人の実行許可"

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "S_IROTH"
msgstr "S_IROTH"

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "  00004"
msgstr "  00004"

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "others have read permission"
msgstr "他人の読み込み許可"

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "S_IWOTH"
msgstr "S_IWOTH"

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "  00002"
msgstr "  00002"

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "others have write permission"
msgstr "他人の書き込み許可"

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "S_IXOTH"
msgstr "S_IXOTH"

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "  00001"
msgstr "  00001"

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "others have execute permission"
msgstr "他人の実行許可"

#. type: Plain text
#: build/C/man7/inode.7:408
#, fuzzy
#| msgid ""
#| "The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
#| "directory, it indicates that BSD semantics is to be used for that "
#| "directory: files created there inherit their group ID from the directory, "
#| "not from the effective group ID of the creating process, and directories "
#| "created there will also get the B<S_ISGID> bit set.  For a file that does "
#| "not have the group execution bit (B<S_IXGRP>)  set, the set-group-ID bit "
#| "indicates mandatory file/record locking."
msgid ""
"The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
"directory, it indicates that BSD semantics are to be used for that "
"directory: files created there inherit their group ID from the directory, "
"not from the effective group ID of the creating process, and directories "
"created there will also get the B<S_ISGID> bit set.  For an executable file, "
"the set-group-ID bit causes the effective group ID of a process that "
"executes the file to change as described in B<execve>(2).  For a file that "
"does not have the group execution bit (B<S_IXGRP>)  set, the set-group-ID "
"bit indicates mandatory file/record locking."
msgstr ""
"set-group-ID bit (B<S_ISGID>)  にはいくつかの特殊な使用法がある: ディレクトリ"
"に設定した場合には、そのディレクトリが BSD 方式で使用される ことを示す。つま"
"り、そのディレクトリに作成されたファイルのグループID は 作成したプロセスの実"
"効 (effective) グループID ではなく、ディレクトリの グループID を継承する。ま"
"た、そのディレクトリに作成されたディレクトリにも B<S_ISGID> ビットが設定され"
"る。グループ実行ビット (B<S_IXGRP>)  が設定されていないファイルに設定された場"
"合は、 set-group-ID ビットはファイル/レコードの 強制的な (mandatory) ロックを"
"表す。"

#. type: Plain text
#: build/C/man7/inode.7:415
msgid ""
"The sticky bit (B<S_ISVTX>)  on a directory means that a file in that "
"directory can be renamed or deleted only by the owner of the file, by the "
"owner of the directory, and by a privileged process."
msgstr ""
"ディレクトリにスティッキービット (S_ISVTX) が設定された場合は、 そのディレク"
"トリのファイルの名前を変更したり、削除したりできるのは、 そのファイルの所有者"
"か、そのディレクトリの所有者か、特権プロセス だけとなる。"

#. type: Plain text
#: build/C/man7/inode.7:427
#, fuzzy
#| msgid ""
#| "Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
#| "(They were introduced in BSD.  The interpretation differs between "
#| "systems, and possibly on a single system when NFS mounts are involved.)  "
#| "If you need to obtain the definition of the I<blkcnt_t> or I<blksize_t> "
#| "types from I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the "
#| "value 500 or greater (before including I<any> header files)."
msgid ""
"If you need to obtain the definition of the I<blkcnt_t> or I<blksize_t> "
"types from I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the "
"value 500 or greater (before including I<any> header files)."
msgstr ""
"I<st_blocks> と I<st_blksize> フィールドの使用はあまり移植性がない\n"
"(これらのフィールドは BSD によって導入された。 システムごとに解釈が\n"
"異なっており、 NFS マウントの場合には同じシステムでも異なる可能性がある)。\n"
"I<E<lt>sys/stat.hE<gt>> から I<blkcnt_t> の I<blksize_t> 型定義を\n"
"読み込みたい場合は、(I<どの>ヘッダーファイルをインクルードするよりも前に)\n"
"B<_XOPEN_SOURCE> を 500 以上の値で定義すること。"

#. type: Plain text
#: build/C/man7/inode.7:445
msgid ""
"POSIX.1-1990 did not describe the B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, "
"B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> "
"constants, but instead specified the use of the macros B<S_ISDIR>(), and so "
"on.  The B<S_IF*> constants are present in POSIX.1-2001 and later."
msgstr "POSIX.1-1990 には B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> 定数に関する記述はなかったが、代わりに B<S_ISDIR>() のようなマクロの使用を規定していた。 B<S_IF*> 定数は POSIX.1-2001 以降には存在する。"

#. type: Plain text
#: build/C/man7/inode.7:453
msgid ""
"The B<S_ISLNK>()  and B<S_ISSOCK>()  macros were not in POSIX.1-1996, but "
"both are present in POSIX.1-2001; the former is from SVID 4, the latter from "
"SUSv2."
msgstr "マクロ B<S_ISLNK>() と B<S_ISSOCK>() は POSIX.1-1996 にはなかったが、 POSIX.1-2001 には両方とも存在する。 前者は SVID 4 に、後者は SUSv2 に由来している。"

#. type: Plain text
#: build/C/man7/inode.7:463
msgid ""
"UNIX\\ V7 (and later systems) had B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, where "
"POSIX prescribes the synonyms B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."
msgstr ""
"UNIX\\ V7 (とその後のシステム) は B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC> を持っ"
"ており、\n"
"POSIX はその同義語として B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR> を規定している。"

#. type: Plain text
#: build/C/man7/inode.7:476
msgid ""
"For pseudofiles that are autogenerated by the kernel, the file size (I<stat."
"st_size>; I<statx.stx_size>)  reported by the kernel is not accurate.  For "
"example, the value 0 is returned for many files under the I</proc> "
"directory, while various files under I</sys> report a size of 4096 bytes, "
"even though the file content is smaller.  For such files, one should simply "
"try to read as many bytes as possible (and append \\(aq\\e0\\(aq to the "
"returned buffer if it is to be interpreted as a string)."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:481
msgid "B<stat>(1), B<stat>(2), B<statx>(2), B<symlink>(7)"
msgstr "B<stat>(1), B<stat>(2), B<statx>(2), B<symlink>(7)"

#. type: TH
#: build/C/man7/xattr.7:28
#, no-wrap
msgid "XATTR"
msgstr "XATTR"

#. type: Plain text
#: build/C/man7/xattr.7:31
msgid "xattr - Extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:37
msgid ""
"Extended attributes are name:value pairs associated permanently with files "
"and directories, similar to the environment strings associated with a "
"process.  An attribute may be defined or undefined.  If it is defined, its "
"value may be empty or non-empty."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:45
msgid ""
"Extended attributes are extensions to the normal attributes which are "
"associated with all inodes in the system (i.e., the B<stat>(2)  data).  They "
"are often used to provide additional functionality to a filesystem\\(emfor "
"example, additional security features such as Access Control Lists (ACLs) "
"may be implemented using extended attributes."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:49
msgid ""
"Users with search access to a file or directory may use B<listxattr>(2)  to "
"retrieve a list of attribute names defined for that file or directory."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:57
msgid ""
"Extended attributes are accessed as atomic objects.  Reading "
"(B<getxattr>(2))  retrieves the whole value of an attribute and stores it in "
"a buffer.  Writing (B<setxattr>(2))  replaces any previous value with the "
"new value."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:60
msgid ""
"Space consumed for extended attributes may be counted towards the disk "
"quotas of the file owner and file group."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:60
#, no-wrap
msgid "Extended attribute namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:70
msgid ""
"Attribute names are null-terminated strings.  The attribute name is always "
"specified in the fully qualified I<namespace.attribute> form, for example, "
"I<user.mime_type>, I<trusted.md5sum>, I<system.posix_acl_access>, or "
"I<security.selinux>."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:77
msgid ""
"The namespace mechanism is used to define different classes of extended "
"attributes.  These different classes exist for several reasons; for example, "
"the permissions and capabilities required for manipulating extended "
"attributes of one namespace may differ to another."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:86
msgid ""
"Currently, the I<security>, I<system>, I<trusted>, and I<user> extended "
"attribute classes are defined as described below.  Additional classes may be "
"added in the future."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:86
#, no-wrap
msgid "Extended security attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:97
msgid ""
"The security attribute namespace is used by kernel security modules, such as "
"Security Enhanced Linux, and also to implement file capabilities (see "
"B<capabilities>(7)).  Read and write access permissions to security "
"attributes depend on the policy implemented for each security attribute by "
"the security module.  When no security module is loaded, all processes have "
"read access to extended security attributes, and write access is limited to "
"processes that have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:97
#, no-wrap
msgid "System extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:103
msgid ""
"System extended attributes are used by the kernel to store system objects "
"such as Access Control Lists.  Read and write access permissions to system "
"attributes depend on the policy implemented for each system attribute "
"implemented by filesystems in the kernel."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:103
#, no-wrap
msgid "Trusted extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:111
msgid ""
"Trusted extended attributes are visible and accessible only to processes "
"that have the B<CAP_SYS_ADMIN> capability.  Attributes in this class are "
"used to implement mechanisms in user space (i.e., outside the kernel) which "
"keep information in extended attributes to which ordinary processes should "
"not have access."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:111
#, no-wrap
msgid "User extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:119
msgid ""
"User extended attributes may be assigned to files and directories for "
"storing arbitrary additional information such as the mime type, character "
"set or encoding of a file.  The access permissions for user attributes are "
"defined by the file permission bits: read permission is required to retrieve "
"the attribute value, and writer permission is required to change it."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:130
msgid ""
"The file permission bits of regular files and directories are interpreted "
"differently from the file permission bits of special files and symbolic "
"links.  For regular files and directories the file permission bits define "
"access to the file's contents, while for device special files they define "
"access to the device described by the special file.  The file permissions of "
"symbolic links are not used in access checks.  These differences would allow "
"users to consume filesystem resources in a way not controllable by disk "
"quotas for group or world writable special files and directories."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:138
msgid ""
"For this reason, user extended attributes are allowed only for regular files "
"and directories, and access to user extended attributes is restricted to the "
"owner and to users with appropriate capabilities for directories with the "
"sticky bit set (see the B<chmod>(1)  manual page for an explanation of the "
"sticky bit)."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:138
#, fuzzy, no-wrap
#| msgid "Filesystem types:\n"
msgid "Filesystem differences"
msgstr "ファイルシステムの型:\n"

#. type: Plain text
#: build/C/man7/xattr.7:147
msgid ""
"The kernel and the filesystem may place limits on the maximum number and "
"size of extended attributes that can be associated with a file.  The VFS "
"imposes limitations that an attribute names is limited to 255 bytes and an "
"attribute value is limited to 64\\ kB.  The list of attribute names that can "
"be returned is also limited to 64\\ kB (see BUGS in B<listxattr>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:152
msgid ""
"Some filesystems, such as Reiserfs (and, historically, ext2 and ext3), "
"require the filesystem to be mounted with the B<user_xattr> mount option in "
"order for user extended attributes to be used."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:158
msgid ""
"In the current ext2, ext3, and ext4 filesystem implementations, the total "
"bytes used by the names and values of all of a file's extended attributes "
"must fit in a single filesystem block (1024, 2048 or 4096 bytes, depending "
"on the block size specified when the filesystem was created)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:163
msgid ""
"In the Btrfs, XFS, and Reiserfs filesystem implementations, there is no "
"practical limit on the number of extended attributes associated with a file, "
"and the algorithms used to store extended attribute information on disk are "
"scalable."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:166
msgid ""
"In the JFS, XFS, and Reiserfs filesystem implementations, the limit on bytes "
"used in an EA value is the ceiling imposed by the VFS."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:172
msgid ""
"In the Btrfs filesystem implementation, the total bytes used for the name, "
"value, and implementation overhead bytes is limited to the filesystem "
"I<nodesize> value (16\\ kB by default)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:175
msgid ""
"Extended attributes are not specified in POSIX.1, but some other systems (e."
"g., the BSDs and Solaris) provide a similar feature."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:180
msgid ""
"Since the filesystems on which extended attributes are stored might also be "
"used on architectures with a different byte order and machine word size, "
"care should be taken to store attribute values in an architecture-"
"independent format."
msgstr ""

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@bestbits.at >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#. type: Plain text
#: build/C/man7/xattr.7:188
msgid "This page was formerly named B<attr>(5)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:200
msgid ""
"B<attr>(1), B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), "
"B<ioctl_iflags>(2), B<listxattr>(2), B<removexattr>(2), B<setxattr>(2), "
"B<acl>(5), B<capabilities>(7), B<selinux>(8)"
msgstr "B<attr>(1), B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<ioctl_iflags>(2), B<listxattr>(2), B<removexattr>(2), B<setxattr>(2), B<acl>(5), B<capabilities>(7), B<selinux>(8)"

#~ msgid "Below a short description of a few of the available filesystems."
#~ msgstr ""
#~ "以下は利用可能なファイルシステムのうち、いくつかの簡単な説明である。"

#~ msgid ""
#~ "replaces Microsoft Window's FAT filesystems (VFAT, FAT32).  It has "
#~ "reliability, performance, and space-utilization enhancements plus "
#~ "features like ACLs, journaling, encryption, and so on."
#~ msgstr ""
#~ "Microsoft Windows の FAT ファイルシステム (VFAT, FAT32) を置き換えるもので"
#~ "ある。\n"
#~ "信頼性、性能、容量効率の向上に加えて、ACL、ジャーナリング、暗号化などの機"
#~ "能が\n"
#~ "追加されている。"

#~ msgid ""
#~ "To use B<smb> fs, you need a special mount program, which can be found in "
#~ "the ksmbfs package, found at E<.UR ftp://sunsite.unc.edu\\:/pub\\:/Linux"
#~ "\\:/system\\:/Filesystems\\:/smbfs> E<.UE .>"
#~ msgstr ""
#~ "B<smb> ファイルシステムを使うためには ksmbfs パッケージに含まれる 特殊なマ"
#~ "ウントプログラムが必要である。 ksmbfs は E<.UR ftp://sunsite.unc.edu\\:/"
#~ "pub\\:/Linux\\:/system\\:/Filesystems\\:/smbfs> E<.UE> にある。"

#~ msgid "The length of the string referenced by I<fts_path>."
#~ msgstr "I<fts_path> で参照される文字列の長さ。"

#~ msgid ""
#~ "If I<fpath> is a symbolic link and B<stat>(2)  failed, POSIX.1-2001 "
#~ "states that it is undefined whether B<FTW_NS> or B<FTW_SL> (see below)  "
#~ "is passed in I<typeflag>."
#~ msgstr ""
#~ "I<fpath> がシンボリックリンクで、かつ B<stat>(2)  が失敗した場合、 "
#~ "B<FTW_NS> と B<FTW_SL> (後述) のどちらが I<typeflag> に渡されるかは未定義"
#~ "であると、POSIX.1-2001 には書かれている。"

#~ msgid ""
#~ "The function B<nftw>()  is the same as B<ftw>(), except that it has one "
#~ "additional argument, I<flags>, and calls I<fn>() with one more argument, "
#~ "I<ftwbuf>."
#~ msgstr ""
#~ "関数 B<nftw>()  は B<ftw>()  と同じだが、引数 I<flags> が追加される点"
#~ "と、 I<fn>()  の引数に I<ftwbuf> が追加される点が異なる。"

#~ msgid ""
#~ "For each entry in the directory tree, B<nftw>()  calls I<fn>()  with four "
#~ "arguments.  I<fpath> and I<sb> are as for B<ftw>().  I<typeflag> may "
#~ "receive any of the same values as with B<ftw>(), or any of the following "
#~ "values:"
#~ msgstr ""
#~ "ディレクトリツリーのエントリー毎に、 B<nftw>()  は 4つの引数で I<fn>()  "
#~ "を呼び出す。 I<fpath> と I<sb> は B<ftw>()  と同じである。 I<typeflag> に"
#~ "は、 B<ftw>()  で取り得る値のいずれか、または以下の値のいずれかが渡される:"

#~ msgid ""
#~ "I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
#~ "only if B<FTW_PHYS> is not set.)"
#~ msgstr ""
#~ "I<fpath> がシンボリックリンクで、存在しないファイルを指している (これが"
#~ "セットされるのは B<FTW_PHYS> がセットされていない場合だけである)。"

#~ msgid ""
#~ "B<FTW_F> is returned for all objects (files, symbolic links, FIFOs, "
#~ "etc.)  that can be stat'ed but are not a directory."
#~ msgstr ""
#~ "「stat できるがディレクトリではないオブジェクト」 (ファイル, シンボリック"
#~ "リンク, fifo 等)  に対しては、すべて B<FTW_F> が返される。"

#~ msgid "B<FTW_ACTIONRETVAL> is glibc-specific."
#~ msgstr "B<FTW_ACTIONRETVAL> は glibc 固有である。"

#~ msgid ""
#~ "/etc/fstab          filesystem description file\n"
#~ "/etc/mtab           mounted filesystem description file\n"
#~ msgstr ""
#~ "/etc/fstab          ファイルシステム記述ファイル\n"
#~ "/etc/mtab           マウントされたファイルシステムの記述ファイル\n"

#~ msgid ""
#~ "An empty buffer of I<size> zero can be passed into these calls to return "
#~ "the current size of the named extended attribute, which can be used to "
#~ "estimate the size of a buffer which is sufficiently large to hold the "
#~ "value associated with the extended attribute."
#~ msgstr ""
#~ "I<size> に 0 を指定して空のバッファーをこれらのシステムコールに渡すことが"
#~ "でき、 この場合には指定された名前の拡張属性の現在のサイズが返される。 この"
#~ "方法は、拡張属性の値を保持するのに十分な大きさのバッファーサイズを 見積も"
#~ "るのに使うことができる、"

#~ msgid ""
#~ "The interface is designed to allow guessing of initial buffer sizes, and "
#~ "to enlarge buffers when the return value indicates that the buffer "
#~ "provided was too small."
#~ msgstr ""
#~ "このシステムコールインターフェースは、初期バッファーのサイズの推測をした"
#~ "り、 与えられたバッファーが小さすぎたことを返り値で知らせることでバッ"
#~ "ファーを大きく したりできるように設計されている。"

#~ msgid ""
#~ "Extended attributes are name:value pairs associated with inodes (files, "
#~ "directories, symbolic links, etc.).  They are extensions to the normal "
#~ "attributes which are associated with all inodes in the system (i.e., the "
#~ "B<stat>(2)  data).  A complete overview of extended attributes concepts "
#~ "can be found in B<attr>(5)."
#~ msgstr ""
#~ "拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付"
#~ "けられた I<name>:I<value> の対である。 これらは、システム上のすべての "
#~ "inode に関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するもの"
#~ "である。 拡張属性のコンセプトは B<attr>(5)  に書かれている。"

#~ msgid ""
#~ "An empty buffer of I<size> zero can be passed into these calls to return "
#~ "the current size of the list of extended attribute names, which can be "
#~ "used to estimate the size of a buffer which is sufficiently large to hold "
#~ "the list of names."
#~ msgstr ""
#~ "I<size> に 0 を指定して空のバッファーをこれらのシステムコールに渡すことが"
#~ "でき、 この場合には拡張属性の名前リストの現在のサイズが返される。 この方法"
#~ "は名前リストを保持するのに十分な大きさのバッファーサイズを 見積もるのに使"
#~ "うことができる、"

#~ msgid ""
#~ "Perform a bind mount, making a file or a directory subtree visible at "
#~ "another point within a filesystem.  Bind mounts may cross filesystem "
#~ "boundaries and span B<chroot>(2)  jails.  The I<filesystemtype> and "
#~ "I<data> arguments are ignored.  Up until Linux 2.6.26, I<mountflags> was "
#~ "also ignored (the bind mount has the same mount options as the underlying "
#~ "mount point)."
#~ msgstr ""
#~ "バインドマウントを行う。これはファイルやディレクトリの部分木を ファイルシ"
#~ "ス\n"
#~ "テム内部の別の場所で見えるようにするものである。 バインドマウントを使う"
#~ "と、\n"
#~ "ファイルシステムをまたいで B<chroot>(2) jail を構成することが可能にな"
#~ "る。\n"
#~ "引数 I<filesystemtype> と I<data> は無視される。 Linux 2.6.26 より前で"
#~ "は\n"
#~ "I<mountflags> も無視されていた (バインドマウントでは、マウントポイントとな"
#~ "る\n"
#~ "ファイルシステムと同じマウントオプションが使用される)。"

#~ msgid ""
#~ "The following I<mountflags> can be changed: B<MS_RDONLY>, "
#~ "B<MS_SYNCHRONOUS>, B<MS_MANDLOCK>; before kernel 2.6.16, the following "
#~ "could also be changed: B<MS_NOATIME> and B<MS_NODIRATIME>; and, "
#~ "additionally, before kernel 2.4.10, the following could also be changed: "
#~ "B<MS_NOSUID>, B<MS_NODEV>, B<MS_NOEXEC>."
#~ msgstr ""
#~ "I<mountflags> のうち B<MS_RDONLY>, B<MS_SYNCHRONOUS>, B<MS_MANDLOCK> は変"
#~ "更可能である。 カーネル 2.6.16 より前では、 B<MS_NOATIME>, "
#~ "B<MS_NODIRATIME> も変更可能であった。 カーネル 2.4.10 より前では、上記に加"
#~ "えて、 B<MS_NOSUID>, B<MS_NODEV>, B<MS_NOEXEC> も変更可能であった。"

#~ msgid ""
#~ "From Linux 2.4 onward, the B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> "
#~ "flags are settable on a per-mount-point basis.  From kernel 2.6.16 "
#~ "onward, B<MS_NOATIME> and B<MS_NODIRATIME> are also settable on a per-"
#~ "mount-point basis.  The B<MS_RELATIME> flag is also settable on a per-"
#~ "mount-point basis."
#~ msgstr ""
#~ "Linux 2.4 以降では、 B<MS_NODEV>, B<MS_NOEXEC>, B<MS_NOSUID> はマウントポ"
#~ "イント単位で指定できる。 カーネル 2.6.16 以降では、 B<MS_NOATIME> と "
#~ "B<MS_NODIRATIME> もマウントポイント単位で指定できる。 また、 "
#~ "B<MS_RELATIME> フラグもマウントポイント単位で設定できる。"

#~ msgid ""
#~ "A component of a path was not searchable.  (See also "
#~ "B<path_resolution>(7).)  Or, mounting a read-only filesystem was "
#~ "attempted without giving the B<MS_RDONLY> flag.  Or, the block device "
#~ "I<source> is located on a filesystem mounted with the B<MS_NODEV> option."
#~ msgstr ""
#~ "パスに含まれるディレクトリに検索 (実行) 許可がない "
#~ "(B<path_resolution>(7)  も参照)。 または、 B<MS_RONLY> フラグを指定せずに"
#~ "読み込み専用のファイルシステムを マウントしようとした。 または、ブロックデ"
#~ "バイス I<source> が B<MS_NODEV> オプションでマウントされたファイルシステム"
#~ "上にある。"

#~ msgid ""
#~ "I<source> is already mounted.  Or, it cannot be remounted read-only, "
#~ "because it still holds files open for writing.  Or, it cannot be mounted "
#~ "on I<target> because I<target> is still busy (it is the working directory "
#~ "of some thread, the mount point of another device, has open files, etc.)."
#~ msgstr ""
#~ "I<source> は既にマウントされている。 または、書き込み用にオープンされた"
#~ "ファイルがあり、 読み込み専用で再マウントすることができない。 または、 "
#~ "I<target> が使用中 (busy) のため、 I<target> にマウントできない。 "
#~ "I<target> が使用中の例としては、あるスレッドの動作ディレクトリ (working "
#~ "directory) であるとか、別のデバイスのマウントポイントであるとか、 オープン"
#~ "されたファイルが存在する、などがある。"

#~ msgid ""
#~ "I<source> had an invalid superblock.  Or, a remount (B<MS_REMOUNT>)  was "
#~ "attempted, but I<source> was not already mounted on I<target>.  Or, a "
#~ "move (B<MS_MOVE>)  was attempted, but I<source> was not a mount point, or "
#~ "was \\(aq/\\(aq."
#~ msgstr ""
#~ "I<source> に不正なスーパーブロックがある。 または、 I<source> が "
#~ "I<target> にマウントされていないのに、再マウント (B<MS_REMOUNT>)  が要求さ"
#~ "れた。 または、 I<source> がマウントポイントではないか、\\(aq/\\(aq なの"
#~ "に、移動 (B<MS_MOVE>)  が要求された。"

#~ msgid ""
#~ "The Linux-specific I</proc/PID/mounts> file exposes the list of mount "
#~ "points in the mount namespace of the process with the specified ID; see "
#~ "B<proc>(5)  for details."
#~ msgstr ""
#~ "Linux 独自のファイル I</proc/PID/mounts> では、指定された ID を持つプロセ"
#~ "スのマウント名前空間における マウントポイントのリストが公開されている。詳"
#~ "細は B<proc>(5)  を参照のこと。"

#~ msgid ""
#~ "Extended attributes are I<name>:value pairs associated with inodes "
#~ "(files, directories, symbolic links, etc.).  They are extensions to the "
#~ "normal attributes which are associated with all inodes in the system (i."
#~ "e., the B<stat>(2)  data).  A complete overview of extended attributes "
#~ "concepts can be found in B<attr>(5)."
#~ msgstr ""
#~ "拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付"
#~ "けられた I<name>:I<value> の対である。 これらは、システム上のすべての "
#~ "inode に関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するもの"
#~ "である。 拡張属性のコンセプトは B<attr>(5)  に書かれている。"

#~ msgid ""
#~ "The named attribute does not exist.  (B<ENOATTR> is defined to be a "
#~ "synonym for B<ENODATA> in I<E<lt>attr/xattr.hE<gt>>.)"
#~ msgstr ""
#~ "指定された属性が存在しない。(B<ENOATTR> は I<E<lt>attr/xattr.hE<gt>> で "
#~ "B<ENODATA> の同義語として定義されている。)"

#~ msgid ""
#~ "The I<flags> argument can be used to refine the semantics of the "
#~ "operation.  B<XATTR_CREATE> specifies a pure create, which fails if the "
#~ "named attribute exists already.  B<XATTR_REPLACE> specifies a pure "
#~ "replace operation, which fails if the named attribute does not already "
#~ "exist.  By default (no flags), the extended attribute will be created if "
#~ "need be, or will simply replace the value if the attribute exists."
#~ msgstr ""
#~ "操作の意味を明確にするために I<flags> 引数を使用することができる。 "
#~ "B<XATTR_CREATE> は属性の作成だけを行うことを指定する。 指定された名前の属"
#~ "性がすでに存在する場合は失敗する。 B<XATTR_REPLACE> は属性の置換だけを行う"
#~ "ことを指定する。 指定された名前の属性がまだ存在しない場合は失敗する。 デ"
#~ "フォルトでは (フラグを指定しない場合)、拡張属性は必要な場合は作成され、 属"
#~ "性がすでに存在する場合は属性値の置換を行う。"

#~ msgid ""
#~ "B<XATTR_REPLACE> was specified, and the attribute does not exist.  "
#~ "(B<ENOATTR> is defined to be a synonym for B<ENODATA> in I<E<lt>attr/"
#~ "xattr.hE<gt>>.)"
#~ msgstr ""
#~ "B<XATTR_REPLACE> が指定されたが、その属性が存在しない。(B<ENOATTR> は "
#~ "I<E<lt>attr/xattr.hE<gt>> で B<ENODATA> の同義語として定義されている。)"

#~ msgid ""
#~ "Extended attributes are not supported by the filesystem, or are disabled, "
#~ "I<errno> is set to B<ENOTSUP>."
#~ msgstr ""
#~ "拡張属性がそのファイルシステムでサポートされていない、もしくは無効になって"
#~ "いる。\n"
#~ "I<errno> に B<ENOTSUP> がセットされる。"

#~ msgid "The process has reached its maximum open files limit."
#~ msgstr "そのプロセスがオープンできるファイル数の上限に達していた。"

#~ msgid "The system has reached the global open files limit."
#~ msgstr "システム全体でオープンできるファイル数の上限に達していた。"

#~ msgid ""
#~ "The following mask values are defined for the file permissions component "
#~ "of the I<st_mode> field:"
#~ msgstr ""
#~ "以下のマスク値が I<st_mode> フィールドのファイルのアクセス許可の検査用に定"
#~ "義されている。"

#~ msgid "mask for file owner permissions"
#~ msgstr "ファイル所有者のアクセス許可用のビットマスク"

#~ msgid "mask for group permissions"
#~ msgstr "グループのアクセス許可用のビットマスク"

#~ msgid "mask for permissions for others (not in group)"
#~ msgstr "他人 (others) のアクセス許可用のビットマスク"

#~ msgid ""
#~ "The B<fstatat>()  system call operates in exactly the same way as "
#~ "B<stat>(), except for the differences described here."
#~ msgstr ""
#~ "B<fstatat>() システムコールは B<stat>() と全く同様に動作するが、以下で説明"
#~ "する点が異なる。"

#~ msgid "I<fd> is bad."
#~ msgstr "I<fd> が不正である。"

#~ msgid "Other systems"
#~ msgstr "他のシステム"

#~ msgid "Values that have been (or are) in use on various systems:"
#~ msgstr "各種システムで使用されていた(いる)値:"

#~ msgid "mask for file type"
#~ msgstr "ファイル種別フィールドのビットマスク"

#~ msgid ""
#~ "SCO out-of-service inode; BSD unknown type; SVID-v2 and XPG2\n"
#~ "have both 0 and 0100000 for ordinary file"
#~ msgstr ""
#~ "SCO では 使用不能 inode; BSD では不明なファイル種別;\n"
#~ "SVID-v2 と XPG2 では 0 と 0100000 の両方が通常のファイル"

#~ msgid "FIFO (named pipe)"
#~ msgstr "FIFO (名前付きパイプ)"

#~ msgid "character special (V7)"
#~ msgstr "キャラクター特殊ファイル (V7)"

#~ msgid "multiplexed character special (V7)"
#~ msgstr "多重化されたキャラクター特殊ファイル (V7)"

#~ msgid "directory (V7)"
#~ msgstr "ディレクトリ (V7)"

#~ msgid ""
#~ "XENIX named special file with two subtypes, distinguished by\n"
#~ "I<st_rdev> values 1, 2"
#~ msgstr ""
#~ "XENIX の二つの副型を持つ名前付きの特殊ファイル;\n"
#~ "副型は I<st_rdev> の値 1, 2 で区別される"

#~ msgid "XENIX semaphore subtype of IFNAM"
#~ msgstr "XENIX の IFNAM セマフォ副型"

#~ msgid "XENIX shared data subtype of IFNAM"
#~ msgstr "XENIX の IFNAM 共有データ副型"

#~ msgid "block special (V7)"
#~ msgstr "ブロック特殊ファイル (V7)"

#~ msgid "multiplexed block special (V7)"
#~ msgstr "多重化されたブロック特殊ファイル (V7)"

#~ msgid "regular (V7)"
#~ msgstr "通常ファイル (V7)"

#~ msgid "VxFS compressed"
#~ msgstr "VxFS 圧縮ファイル"

#~ msgid "network special (HP-UX)"
#~ msgstr "ネットワーク特殊ファイル (HP-UX)"

#~ msgid "symbolic link (BSD)"
#~ msgstr "シンボリックリンク (BSD)"

#~ msgid "Solaris shadow inode for ACL (not seen by user space)"
#~ msgstr "Solaris の ACL 用の隠し inode (ユーザー空間からは見えない)"

#~ msgid "socket (BSD; also \"S_IFSOC\" on VxFS)"
#~ msgstr "ソケット (BSD; VxFS の \"S_IFSOC\")"

#~ msgid "Solaris door"
#~ msgstr "Solaris の door ファイル"

#~ msgid "BSD whiteout (not used for inode)"
#~ msgstr "BSD の空白ファイル (inode を使用しない)"

#~ msgid "sticky bit: save swapped text even after use (V7)\n"
#~ msgstr "スティッキービット: 使用後もスワップに残す (V7)\n"

#~ msgid "reserved (SVID-v2)\n"
#~ msgstr "予約 (SVID-v2)\n"

#~ msgid "On nondirectories: don't cache this file (SunOS)\n"
#~ msgstr "ディレクトリ以外: ファイルをキャッシュしない (SunOS)\n"

#~ msgid "On directories: restricted deletion flag (SVID-v4.2)"
#~ msgstr "ディレクトリの場合: 削除制限フラグ (SVID-v4.2)"

#~ msgid "set-group-ID on execution (V7)\n"
#~ msgstr "実行時の set-group-ID (V7)\n"

#~ msgid "for directories: use BSD semantics for propagation of GID"
#~ msgstr "ディレクトリの場合: GID の伝搬に BSD 方式を使用する"

#~ msgid "System V file locking enforcement (shared with S_ISGID)"
#~ msgstr "System V ファイルロックを強制する (S_ISGID と共有)"

#~ msgid "set-user-ID on execution (V7)"
#~ msgstr "実行時の set-user-ID (V7)"

#~ msgid "directory is a context dependent file (HP-UX)"
#~ msgstr "ディレクトリがコンテキスト依存ファイル (HP-UX)"

#~ msgid "A sticky command appeared in Version 32V AT&T UNIX."
#~ msgstr "スティッキー コマンドは Version 32V AT&T UNIX で登場した。"

#~ msgid ""
#~ "On Linux, B<lstat>()  will generally not trigger automounter action, "
#~ "whereas B<stat>()  will (but see B<fstatat>(2))."
#~ msgstr ""
#~ "Linux では、 B<lstat>() は一般には自動マウント動作 (automounter action) "
#~ "の\n"
#~ "きっかけとならないが、 B<stat>() はきっかけとなる (B<fstatat>(2) を参照)。"

#~ msgid ""
#~ "For most files under the I</proc> directory, B<stat>()  does not return "
#~ "the file size in the I<st_size> field; instead the field is returned with "
#~ "the value 0."
#~ msgstr ""
#~ "I</proc> ディレクトリ以下にあるファイルのほとんどでは、 B<stat>()  を呼び"
#~ "出した際に、 I<st_size> フィールドにファイルサイズが返されない。 代わりに "
#~ "I<st_size> フィールドには 0 が返される。"

#~ msgid "Underlying kernel interface"
#~ msgstr "背後のカーネルインターフェース"

#~ msgid ""
#~ "#if __WORDSIZE == 32\t\t/* System word size */\n"
#~ "# define __SWORD_TYPE           int\n"
#~ "#else /* __WORDSIZE == 64 */\n"
#~ "# define __SWORD_TYPE\t\tlong int\n"
#~ "#endif\n"
#~ msgstr ""
#~ "#if __WORDSIZE == 32\t\t/* システムのワードサイズ */\n"
#~ "# define __SWORD_TYPE           int\n"
#~ "#else /* __WORDSIZE == 64 */\n"
#~ "# define __SWORD_TYPE\t\tlong int\n"
#~ "#endif\n"

#~ msgid ""
#~ "Fields that are undefined for a particular filesystem are set to 0.  "
#~ "B<fstatfs>()  returns the same information about an open file referenced "
#~ "by descriptor I<fd>."
#~ msgstr ""
#~ "それぞれのファイルシステムにおいて未定義のフィールドには 0 が 設定され"
#~ "る。 B<fstatfs>()  はディスクリプター I<fd> によって参照されるオープンされ"
#~ "たファイルについて、同じ情報を返す。"

#~ msgid ""
#~ "The field I<f_flag> is a bit mask (of mount flags, see B<mount>(8)).  "
#~ "Bits defined by POSIX are"
#~ msgstr ""
#~ "フィールド I<f_flag> は (マウントフラグの) ビットマスクである (マウントフ"
#~ "ラグについては、 B<mount>(8)  を参照すること)。 POSIX で定義されているビッ"
#~ "トは以下の通り:"

#~ msgid "Read-only filesystem."
#~ msgstr "読み込み専用のファイルシステム。"

#~ msgid "Set-user-ID/set-group-ID bits are ignored by B<exec>(3)."
#~ msgstr "B<exec>(3)  に無視される set-user-id/set-group-ID ビット。"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid "The B<statvfs>()  and B<fstatvfs>()  functions are thread-safe."
#~ msgstr "関数 B<statvfs>() と B<fstatvfs>()はスレッドセーフである。"

#~ msgid ""
#~ "Force unmount even if busy.  This can cause data loss.  (Only for NFS "
#~ "mounts.)"
#~ msgstr ""
#~ "使用中 (busy) でも強制的にアンマウントを実行する。 これを行うとデータを失"
#~ "う可能性がある。 (NFS マウント専用)"

#~ msgid ""
#~ "The returned file handler can only be passed to B<spu_run>(2)  or closed; "
#~ "other operations are not defined on it.  A logical SPU context is "
#~ "destroyed when its file descriptor is closed as well as all the file "
#~ "descriptors pointing to files inside it.  When an SPU context is "
#~ "destroyed all its directory entries in the SPUFS are removed."
#~ msgstr ""
#~ "返されたファイルハンドラーは、 B<spu_run>(2)  に渡すか、クローズするかしか"
#~ "できない。 他の操作は定義されていない。 論理 SPU コンテキストが破棄される"
#~ "のは、 コンテキスト自身へのファイルディスクリプターがクローズされ、 その中"
#~ "のファイルへのファイルディスクリプターが全てクローズされたときである。 "
#~ "SPU コンテキストが破棄されると、SPUFS 内のそのディレクトリの全てのエント"
#~ "リー が削除される。"

#~ msgid ""
#~ "Allow mapping of some of the hardware registers of the SPU into user "
#~ "space.  This flag requires the B<CAP_SYS_RAWIO> capability."
#~ msgstr ""
#~ "SPU のハードウェアレジスターのいくつかをユーザー空間にマッピングすること"
#~ "を 許可する。このフラグを指定するには B<CAP_SYS_RAWIO> ケーパビリティが必"
#~ "要である。"

#~ msgid ""
#~ "The new directory and files are created in the SPUFS with the permissions "
#~ "set by the I<mode> argument minus those set in the process's "
#~ "B<umask>(2).  The actual permissions set for each file also depend on "
#~ "whether the file supports read and/or write accesses."
#~ msgstr ""
#~ "SPUFS 内に新しく生成されたディレクトリとファイルのアクセス許可は、 "
#~ "I<mode> 引数からそのプロセスの B<umask>(2)  を引いた値に設定される。 各"
#~ "ファイルの実際のアクセス許可は、そのファイルが読み出しアクセスや 書き込み"
#~ "アクセスをサポートしているかも考慮して決まる。"

#~ msgid ""
#~ "These files expose internal registers of the SPU.  The values are "
#~ "represented as ASCII strings containing the numeric value of each "
#~ "register.  These can be used in read/write mode for debugging, but normal "
#~ "operation of programs should not rely on these files because accesses to "
#~ "any of them except I<npc> require an SPU context save, which is very "
#~ "inefficient."
#~ msgstr ""
#~ "これらのファイルは SPU の内部レジスターを公開するものである。 値は、各レジ"
#~ "スターの数値を含むアスキー文字列で表現される。 これらのファイルはデバッグ"
#~ "用として読み出し/書き込みの両モードで利用できるが、 プログラムの通常の操作"
#~ "はこれらのファイルに依存すべきではない。 なぜなら、これらのファイルのうち "
#~ "I<npc> 以外へのアクセスでは SPU コンテキストの保存が必須であり、 SPU コン"
#~ "テキストの保存は非常に効率が悪いからである。"
