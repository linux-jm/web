# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man2/mount.2:40 build/C/man2/spu_create.2:25 build/C/man7/spufs.7:27 build/C/man2/statfs.2:28
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:36 build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:25 build/C/man2/listxattr.2:26 build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:39 build/C/man2/statfs.2:28 build/C/man2/statx.2:30 build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30 build/C/man5/sysfs.5:25 build/C/man5/tmpfs.5:25 build/C/man4/fuse.4:26 build/C/man4/loop.4:26 build/C/man7/inode.7:25 build/C/man7/xattr.7:28
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:36 build/C/man3/getfsent.3:27 build/C/man3/getmntent.3:32 build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:25 build/C/man2/listxattr.2:26 build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:39 build/C/man2/statfs.2:28 build/C/man2/statx.2:30 build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30 build/C/man5/sysfs.5:25 build/C/man5/tmpfs.5:25 build/C/man4/fuse.4:26 build/C/man4/loop.4:26 build/C/man7/inode.7:25 build/C/man7/xattr.7:28
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:28 build/C/man3/fts.3:41 build/C/man3/ftw.3:37 build/C/man3/getfsent.3:28 build/C/man3/getmntent.3:33 build/C/man2/getxattr.2:26 build/C/man3/isfdtype.3:26 build/C/man2/listxattr.2:27 build/C/man2/mount.2:41 build/C/man7/path_resolution.7:26 build/C/man2/removexattr.2:26 build/C/man2/setxattr.2:26 build/C/man2/spu_create.2:26 build/C/man2/spu_run.2:27 build/C/man7/spufs.7:28 build/C/man2/stat.2:40 build/C/man2/statfs.2:29 build/C/man2/statx.2:31 build/C/man3/statvfs.3:31 build/C/man2/sysfs.2:28 build/C/man2/umount.2:31 build/C/man2/ustat.2:31 build/C/man5/sysfs.5:26 build/C/man5/tmpfs.5:26 build/C/man4/fuse.4:27 build/C/man4/loop.4:27 build/C/man7/inode.7:26 build/C/man7/xattr.7:29
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, "
"JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, umsdos, vfat, "
"XFS, xiafs"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:32 build/C/man3/fts.3:61 build/C/man3/ftw.3:63 build/C/man3/getfsent.3:42 build/C/man3/getmntent.3:68 build/C/man2/getxattr.2:42 build/C/man3/isfdtype.3:54 build/C/man2/listxattr.2:42 build/C/man2/mount.2:51 build/C/man7/path_resolution.7:28 build/C/man2/removexattr.2:39 build/C/man2/setxattr.2:42 build/C/man2/spu_create.2:39 build/C/man2/spu_run.2:39 build/C/man7/spufs.7:30 build/C/man2/stat.2:88 build/C/man2/statfs.2:37 build/C/man2/statx.2:43 build/C/man3/statvfs.3:39 build/C/man2/sysfs.2:36 build/C/man2/umount.2:41 build/C/man2/ustat.2:41 build/C/man5/sysfs.5:28 build/C/man5/tmpfs.5:28 build/C/man4/fuse.4:33 build/C/man4/loop.4:31 build/C/man7/inode.7:28 build/C/man7/xattr.7:31
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#.  commit: 6af9f7bf3c399e0ab1eee048e13572c6d4e15fe9
#. type: Plain text
#: build/C/man5/filesystems.5:53
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  There is also a "
"legacy B<sysfs>(2)  system call (whose availability is controlled by the "
"B<CONFIG_SYSFS_SYSCALL> kernel build configuration option since Linux 3.15)  "
"that enables enumeration of the currently available filesystem types "
"regardless of I</proc> availability and/or sanity."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:56
msgid ""
"If you need a currently unsupported filesystem, insert the corresponding "
"kernel module or recompile the kernel."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:63
msgid ""
"In order to use a filesystem, you have to I<mount> it; see B<mount>(2)  and "
"B<mount>(8)."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:69
msgid ""
"The following list provides a short description of the available or "
"historically available filesystems in the Linux kernel.  See the kernel "
"documentation for a comprehensive description of all options and "
"limitations."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:69
#, no-wrap
msgid "B<ext>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:78
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:78
#, no-wrap
msgid "B<ext2>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:87
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  See B<ext2>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:87
#, no-wrap
msgid "B<ext3>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:99
msgid ""
"is a journaling version of the B<ext2> filesystem.  It is easy to switch "
"back and forth between B<ext2> and B<ext3>.  See B<ext3>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:99
#, no-wrap
msgid "B<ext4>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:108
msgid ""
"is a set of upgrades to B<ext3> including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits.  See B<ext4>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:108
#, no-wrap
msgid "B<hpfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:113
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is "
"read-only under Linux due to the lack of available documentation."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:113
#, no-wrap
msgid "B<iso9660>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:116
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:117
#, no-wrap
msgid "B<High Sierra>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:124
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for "
"CD-ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:124
#, no-wrap
msgid "B<Rock Ridge>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:135
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the "
"Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:136
#, no-wrap
msgid "B<JFS>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:140
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux "
"in kernel 2.4.24."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:140
#, no-wrap
msgid "B<minix>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:147
msgid ""
"is the filesystem used in the Minix operating system, the first to run under "
"Linux.  It has a number of shortcomings, including a 64\\ MB partition size "
"limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:147
#, no-wrap
msgid "B<msdos>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:153
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period "
"and 3 character extension."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:153
#, no-wrap
msgid "B<ncpfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:158
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare.  It was was removed from the kernel in 4.17."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:164
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://ftp.gwdg.de\\:/pub\\:/linux\\:/misc\\:/ncpfs> E<.UE .>"
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:164
#, no-wrap
msgid "B<nfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:167
msgid "is the network filesystem used to access disks located on remote computers."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:167
#, no-wrap
msgid "B<ntfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:171
msgid ""
"is the filesystem native to Microsoft Windows NT, supporting features like "
"ACLs, journaling, encryption, and so on."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:171
#, no-wrap
msgid "B<proc>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:179
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:179
#, no-wrap
msgid "B<Reiserfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:183
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:183
#, no-wrap
msgid "B<smb>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager.  See E<.UR "
"https://www.samba.org\\:/samba\\:/smbfs/> E<.UE .>"
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:190
#, no-wrap
msgid "B<sysv>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:194
msgid ""
"is an implementation of the System V/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, System V/386 FS, and Coherent FS."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:194
#, no-wrap
msgid "B<umsdos>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:201
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.) under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:201
#, no-wrap
msgid "B<tmpfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:208
msgid ""
"is a filesystem whose contents reside in virtual memory.  Since the files on "
"such filesystems typically reside in RAM, file access is extremely fast.  "
"See B<tmpfs>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:208
#, no-wrap
msgid "B<vfat>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:213
msgid ""
"is an extended FAT filesystem used by Microsoft Windows95 and Windows NT.  "
"B<vfat> adds the capability to use long filenames under the MSDOS "
"filesystem."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:213
#, no-wrap
msgid "B<XFS>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:217
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux "
"in kernel 2.4.20."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:217
#, no-wrap
msgid "B<xiafs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:227
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xiafs> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:227 build/C/man3/fts.3:834 build/C/man3/ftw.3:507 build/C/man3/getfsent.3:160 build/C/man3/getmntent.3:257 build/C/man2/getxattr.2:154 build/C/man3/isfdtype.3:101 build/C/man2/listxattr.2:330 build/C/man2/mount.2:952 build/C/man7/path_resolution.7:275 build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:170 build/C/man2/spu_create.2:285 build/C/man2/spu_run.2:266 build/C/man7/spufs.7:766 build/C/man2/stat.2:708 build/C/man2/statfs.2:394 build/C/man2/statx.2:565 build/C/man3/statvfs.3:257 build/C/man2/sysfs.2:113 build/C/man2/umount.2:223 build/C/man2/ustat.2:118 build/C/man5/sysfs.5:285 build/C/man5/tmpfs.5:275 build/C/man4/fuse.4:553 build/C/man4/loop.4:375 build/C/man7/inode.7:476 build/C/man7/xattr.7:188
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:241
msgid ""
"B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), "
"B<proc>(5), B<sysfs>(5), B<tmpfs>(5), B<xfs>(5), B<fsck>(8), B<mkfs>(8), "
"B<mount>(8)"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:241 build/C/man3/fts.3:840 build/C/man3/ftw.3:511 build/C/man3/getfsent.3:163 build/C/man3/getmntent.3:261 build/C/man2/getxattr.2:164 build/C/man3/isfdtype.3:103 build/C/man2/listxattr.2:340 build/C/man2/mount.2:964 build/C/man7/path_resolution.7:280 build/C/man2/removexattr.2:120 build/C/man2/setxattr.2:180 build/C/man2/spu_create.2:290 build/C/man2/spu_run.2:271 build/C/man7/spufs.7:773 build/C/man2/stat.2:720 build/C/man2/statfs.2:398 build/C/man2/statx.2:577 build/C/man3/statvfs.3:259 build/C/man2/sysfs.2:116 build/C/man2/umount.2:229 build/C/man2/ustat.2:121 build/C/man5/sysfs.5:300 build/C/man5/tmpfs.5:288 build/C/man4/fuse.4:556 build/C/man4/loop.4:378 build/C/man7/inode.7:481 build/C/man7/xattr.7:200
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:249 build/C/man3/fts.3:848 build/C/man3/ftw.3:519 build/C/man3/getfsent.3:171 build/C/man3/getmntent.3:269 build/C/man2/getxattr.2:172 build/C/man3/isfdtype.3:111 build/C/man2/listxattr.2:348 build/C/man2/mount.2:972 build/C/man7/path_resolution.7:288 build/C/man2/removexattr.2:128 build/C/man2/setxattr.2:188 build/C/man2/spu_create.2:298 build/C/man2/spu_run.2:279 build/C/man7/spufs.7:781 build/C/man2/stat.2:728 build/C/man2/statfs.2:406 build/C/man2/statx.2:585 build/C/man3/statvfs.3:267 build/C/man2/sysfs.2:124 build/C/man2/umount.2:237 build/C/man2/ustat.2:129 build/C/man5/sysfs.5:308 build/C/man5/tmpfs.5:296 build/C/man4/fuse.4:564 build/C/man4/loop.4:386 build/C/man7/inode.7:489 build/C/man7/xattr.7:208
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr ""

#. type: TH
#: build/C/man3/fts.3:40 build/C/man7/path_resolution.7:25
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""

#. type: SH
#: build/C/man3/fts.3:44 build/C/man3/ftw.3:39 build/C/man3/getfsent.3:30 build/C/man3/getmntent.3:36 build/C/man2/getxattr.2:28 build/C/man3/isfdtype.3:28 build/C/man2/listxattr.2:29 build/C/man2/mount.2:43 build/C/man2/removexattr.2:28 build/C/man2/setxattr.2:28 build/C/man2/spu_create.2:28 build/C/man2/spu_run.2:29 build/C/man2/stat.2:42 build/C/man2/statfs.2:31 build/C/man2/statx.2:33 build/C/man3/statvfs.3:33 build/C/man2/sysfs.2:30 build/C/man2/umount.2:33 build/C/man2/ustat.2:33 build/C/man4/fuse.4:29 build/C/man4/loop.4:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<,>\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:80
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" (of type "
"I<FTS\\ *>)  that refers to a file hierarchy \"stream\".  This handle is "
"then supplied to the other fts functions.  The function B<fts_read>()  "
"returns a pointer to a structure describing one of the files in the file "
"hierarchy.  The function B<fts_children>()  returns a pointer to a linked "
"list of structures, each of which describes one of the files contained in a "
"directory in the hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:90
msgid ""
"In general, directories are visited two distinguishable times; in preorder "
"(before any of their descendants are visited) and in postorder (after all of "
"their descendants have been visited).  Files are visited once.  It is "
"possible to walk the hierarchy \"logically\" (visiting the files that "
"symbolic links point to)  or physically (visiting the symbolic links "
"themselves), order the walk of the hierarchy or prune and/or revisit "
"portions of the hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:107
msgid ""
"Two structures (and associated types) are defined in the include file "
"I<E<lt>fts.hE<gt>>.  The first type is I<FTS>, the structure that represents "
"the file hierarchy itself.  The second type is I<FTSENT>, the structure that "
"represents a file in the file hierarchy.  Normally, an I<FTSENT> structure "
"is returned for every file in the file hierarchy.  In this manual page, "
"\"file\" and \"FTSENT structure\" are generally interchangeable."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:114
msgid ""
"The I<FTSENT> structure contains fields describing a file.  The structure "
"contains at least the following fields (there are additional fields that "
"should be considered private to the implementation):"
msgstr ""

#.  Also:
#.      ino_t fts_ino;                  /* inode (only for directories)*/
#.      dev_t fts_dev;                  /* device (only for directories)*/
#.      nlink_t fts_nlink;              /* link count (only for directories)*/
#.      u_short fts_flags;              /* private flags for FTSENT structure */
#.      u_short fts_instr;              /* fts_set() instructions */
#. type: Plain text
#: build/C/man3/fts.3:140
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* flags for FTSENT structure */\n"
"    char           *fts_accpath;  /* access path */\n"
"    char           *fts_path;     /* root path */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* filename */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* depth (-1 to N) */\n"
"    int             fts_errno;    /* file errno */\n"
"    long            fts_number;   /* local numeric value */\n"
"    void           *fts_pointer;  /* local address value */\n"
"    struct _ftsent *fts_parent;   /* parent directory */\n"
"    struct _ftsent *fts_link;     /* next file structure */\n"
"    struct _ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat    *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: build/C/man3/fts.3:145
msgid "These fields are defined as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:145
#, no-wrap
msgid "I<fts_info>"
msgstr ""

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: build/C/man3/fts.3:157
msgid ""
"One of the following values describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:158
#, no-wrap
msgid "B<FTS_D>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:161
msgid "A directory being visited in preorder."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:161
#, no-wrap
msgid "B<FTS_DC>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:169
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the "
"I<FTSENT> structure will be filled in as well.)"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:169
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:177
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described "
"by one of the other I<fts_info> values."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:177
#, no-wrap
msgid "B<FTS_DNR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:183
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:183
#, no-wrap
msgid "B<FTS_DOT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:193
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:193
#, no-wrap
msgid "B<FTS_DP>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:203
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:203
#, no-wrap
msgid "B<FTS_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:208
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:208
#, no-wrap
msgid "B<FTS_F>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:211
msgid "A regular file."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:211
#, no-wrap
msgid "B<FTS_NS>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:222
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:222
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:230
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:230
#, no-wrap
msgid "B<FTS_SL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:233
msgid "A symbolic link."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:233
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:241
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp> "
"field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:242
#, no-wrap
msgid "I<fts_accpath>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:245
msgid "A path for accessing the file from the current directory."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:245
#, no-wrap
msgid "I<fts_path>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:251
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:251
#, no-wrap
msgid "I<fts_pathlen>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:257
msgid ""
"The sum of the lengths of the strings referenced by I<fts_path> and "
"I<fts_name>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:257
#, no-wrap
msgid "I<fts_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:260
msgid "The name of the file."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:260
#, no-wrap
msgid "I<fts_namelen>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:264
msgid "The length of the string referenced by I<fts_name>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:264
#, no-wrap
msgid "I<fts_level>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:275
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:275
#, no-wrap
msgid "I<fts_errno>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:299
msgid ""
"If B<fts_children>()  or B<fts_read>()  returns an I<FTSENT> structure whose "
"I<fts_info> field is set to B<FTS_DNR>, B<FTS_ERR>, or B<FTS_NS>, the "
"I<fts_errno> field contains the error number (i.e., the I<errno> value)  "
"specifying the cause of the error.  Otherwise, the contents of the "
"I<fts_errno> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:299
#, no-wrap
msgid "I<fts_number>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:305
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:305
#, no-wrap
msgid "I<fts_pointer>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:312
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:312
#, no-wrap
msgid "I<fts_parent>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:326
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number>, and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:326
#, no-wrap
msgid "I<fts_link>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:337
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory "
"members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:337
#, no-wrap
msgid "I<fts_cycle>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:353
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:353
#, no-wrap
msgid "I<fts_statp>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:359
msgid "A pointer to B<stat>(2)  information for the file."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:386
msgid ""
"A single buffer is used for all of the paths of all of the files in the file "
"hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned "
"by B<fts_read>().  To use these fields to reference any files represented by "
"other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen> "
"field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always "
"null-terminated."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:386
#, no-wrap
msgid "fts_open()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:393
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: build/C/man3/fts.3:403
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:403
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:409
msgid ""
"This option causes any symbolic link specified as a root path to be followed "
"immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:409
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:428
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this "
"option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either "
"B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  "
"function."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:444
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:444
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:460
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes "
"that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:460
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:479
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:479
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:492
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures "
"for them."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:492
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:498
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:537
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path>, "
"and I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used "
"in this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:537
#, no-wrap
msgid "fts_read()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:550
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may "
"cause files to be visited more than once, or directories more than twice.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:571
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and "
"sets I<errno> appropriately.  If an error related to a returned file occurs, "
"a pointer to an I<FTSENT> structure is returned, and I<errno> may or may not "
"have been set (see I<fts_info>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:588
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after "
"a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:588
#, no-wrap
msgid "fts_children()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:606
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:634
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:645
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>(), or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: build/C/man3/fts.3:650
msgid "The I<instr> argument is either zero or the following value:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:650
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:660
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:660
#, no-wrap
msgid "fts_set()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:672
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs."
msgstr ""

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: build/C/man3/fts.3:677
msgid ""
"The I<instr> argument is either 0 (meaning \"do nothing\") or one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:677
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:695
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:695
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:723
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()  "
"returns the file with the I<fts_info> and I<fts_statp> fields reinitialized "
"to reflect the target of the symbolic link instead of the symbolic link "
"itself.  If the file is one of those most recently returned by "
"B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the structure, "
"when returned by B<fts_read>(), will reflect the target of the symbolic link "
"instead of the symbolic link itself.  In either case, if the target of the "
"symbolic link does not exist, the fields of the returned structure will be "
"unchanged and the I<fts_info> field will be set to B<FTS_SLNONE>."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:727
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:727
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:735
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:735
#, no-wrap
msgid "fts_close()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:748
msgid ""
"The B<fts_close>()  function closes the file hierarchy stream referred to by "
"I<ftsp> and restores the current directory to the directory from which "
"B<fts_open>()  was called to open I<ftsp>.  The B<fts_close>()  function "
"returns 0 on success, and -1 if an error occurs."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:748 build/C/man2/getxattr.2:110 build/C/man3/isfdtype.3:82 build/C/man2/listxattr.2:132 build/C/man2/mount.2:631 build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:114 build/C/man2/spu_create.2:179 build/C/man2/spu_run.2:155 build/C/man2/stat.2:379 build/C/man2/statfs.2:229 build/C/man2/statx.2:500 build/C/man3/statvfs.3:133 build/C/man2/sysfs.2:88 build/C/man2/umount.2:118 build/C/man2/ustat.2:77 build/C/man4/fuse.4:465
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:757
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:766
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors "
"specified for B<chdir>(2)  and B<close>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:780
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), and B<stat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:789
msgid ""
"In addition, B<fts_children>(), B<fts_open>(), and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:789 build/C/man2/mount.2:685 build/C/man2/mount.2:689 build/C/man2/mount.2:697 build/C/man2/mount.2:707 build/C/man2/mount.2:715 build/C/man2/mount.2:722 build/C/man2/mount.2:738 build/C/man2/mount.2:747 build/C/man2/mount.2:760 build/C/man2/mount.2:763 build/C/man2/spu_create.2:193 build/C/man2/spu_run.2:176 build/C/man2/stat.2:447 build/C/man2/statx.2:519 build/C/man2/statx.2:523 build/C/man2/sysfs.2:93 build/C/man2/umount.2:139 build/C/man2/umount.2:143 build/C/man2/ustat.2:82 build/C/man4/fuse.4:473
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:795
msgid "I<options> or I<instr> was invalid."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:795 build/C/man3/ftw.3:367 build/C/man2/getxattr.2:140 build/C/man2/listxattr.2:154 build/C/man2/mount.2:827 build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:159 build/C/man2/spu_create.2:253 build/C/man2/spu_run.2:190 build/C/man2/stat.2:457 build/C/man2/statx.2:559 build/C/man2/umount.2:170 build/C/man2/ustat.2:92 build/C/man5/sysfs.5:274 build/C/man5/tmpfs.5:214
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:797
msgid "These functions are available in Linux since glibc2."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:797 build/C/man3/ftw.3:370 build/C/man3/getfsent.3:115 build/C/man3/getmntent.3:213 build/C/man3/statvfs.3:190
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:800 build/C/man3/ftw.3:373 build/C/man3/getfsent.3:118 build/C/man3/getmntent.3:216 build/C/man3/statvfs.3:193
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122 build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122 build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:804 build/C/man3/ftw.3:377 build/C/man3/getfsent.3:122 build/C/man3/getmntent.3:221 build/C/man3/statvfs.3:197
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:809
#, no-wrap
msgid ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:809 build/C/man3/fts.3:813 build/C/man3/ftw.3:380 build/C/man3/ftw.3:383 build/C/man3/getfsent.3:127 build/C/man3/getfsent.3:134 build/C/man3/getmntent.3:226 build/C/man3/getmntent.3:229 build/C/man3/getmntent.3:232 build/C/man3/getmntent.3:235 build/C/man3/statvfs.3:201
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:809 build/C/man3/ftw.3:383 build/C/man3/getmntent.3:226 build/C/man3/statvfs.3:201
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:813
#, no-wrap
msgid ""
"B<fts_read>(),\n"
"B<fts_children>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fts.3:813
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: SH
#: build/C/man3/fts.3:816 build/C/man3/ftw.3:386 build/C/man3/getfsent.3:136 build/C/man3/getmntent.3:238 build/C/man2/getxattr.2:143 build/C/man3/isfdtype.3:87 build/C/man2/listxattr.2:157 build/C/man2/mount.2:841 build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:162 build/C/man2/spu_create.2:257 build/C/man2/spu_run.2:194 build/C/man2/stat.2:461 build/C/man2/statfs.2:286 build/C/man2/statx.2:562 build/C/man3/statvfs.3:203 build/C/man2/sysfs.2:101 build/C/man2/umount.2:176 build/C/man2/ustat.2:94 build/C/man5/sysfs.5:278 build/C/man4/fuse.4:513 build/C/man7/inode.7:415 build/C/man7/xattr.7:172
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:818
msgid "4.4BSD."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:818 build/C/man3/ftw.3:419 build/C/man2/listxattr.2:165 build/C/man2/statfs.2:385 build/C/man2/sysfs.2:110
#, no-wrap
msgid "BUGS"
msgstr ""

#.  Fixed by commit 8b7b7f75d91f7bac323dd6a370aeb3e9c5c4a7d5
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: build/C/man3/fts.3:834
msgid ""
"In versions of glibc before 2.23, all of the APIs described in this man page "
"are not safe when compiling a program using the LFS APIs (e.g., when "
"compiling with I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:840
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ftw.3:36
#, no-wrap
msgid "FTW"
msgstr ""

#. type: TH
#: build/C/man3/ftw.3:36 build/C/man2/getxattr.2:25 build/C/man2/listxattr.2:26 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man7/xattr.7:28
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:39
msgid "ftw, nftw - file tree walk"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:42 build/C/man3/ftw.3:49
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:47
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat "
"*>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat "
"*>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:59 build/C/man3/getmntent.3:61 build/C/man3/isfdtype.3:39 build/C/man2/stat.2:63
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:63
msgid "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:70
msgid ""
"B<nftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By "
"default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:83
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<nftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<nftw>()  will become "
"slower because directories have to be closed and reopened.  B<nftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:111
msgid ""
"For each entry found in the tree, B<nftw>()  calls I<fn>() with four "
"arguments: I<fpath>, I<sb>, I<typeflag>, and I<ftwbuf>.  I<fpath> is the "
"pathname of the entry, and is expressed either as a pathname relative to the "
"calling process's current working directory at the time of the call to "
"B<nftw>(), if I<dirpath> was expressed as a relative pathname, or as an "
"absolute pathname, if I<dirpath> was expressed as an absolute pathname.  "
"I<sb> is a pointer to the I<stat> structure returned by a call to B<stat>(2)  "
"for I<fpath>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:117
msgid ""
"The I<typeflag> argument passed to I<fn>()  is an integer that has one of "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:117
#, no-wrap
msgid "B<FTW_F>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:121
msgid "I<fpath> is a regular file."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:121
#, no-wrap
msgid "B<FTW_D>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:125
msgid "I<fpath> is a directory."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:125
#, no-wrap
msgid "B<FTW_DNR>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:129
msgid "I<fpath> is a directory which can't be read."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:129
#, no-wrap
msgid "B<FTW_DP>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:143
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:143
#, no-wrap
msgid "B<FTW_NS>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:160
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent "
"directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2).  "
"The contents of the buffer pointed to by I<sb> are undefined."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:160
#, no-wrap
msgid "B<FTW_SL>"
msgstr ""

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: build/C/man3/ftw.3:171
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:171
#, no-wrap
msgid "B<FTW_SLN>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:184
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)  In this case the I<sb> argument passed to "
"I<fn>()  contains information returned by performing B<lstat>(2)  on the "
"\"dangling\" symbolic link.  (But see BUGS.)"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:192
msgid ""
"The fourth argument (I<ftwbuf>)  that B<nftw>()  supplies when calling "
"I<fn>()  is a pointer to a structure of type I<FTW>:"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:199
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:212
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:223
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<nftw>().  As long as I<fn>() returns 0, "
"B<nftw>()  will continue either until it has traversed the entire tree, in "
"which case it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:233
msgid ""
"Because B<nftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler "
"set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:238
msgid ""
"The I<flags> argument of B<nftw>()  is formed by ORing zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:238
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:247
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value "
"from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:248
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:253
msgid "Instructs B<nftw>()  to continue normally."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:253
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr ""

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: build/C/man3/ftw.3:261
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:261
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:269
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from "
"being passed as arguments to I<fn>().  B<nftw>()  continues processing with "
"the next sibling of the directory."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:269
#, no-wrap
msgid "B<FTW_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:275
msgid "Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:278
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:287
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:288
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:299
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides.  (Specifying this flag has no effect on the "
"pathname that is passed in the I<fpath> argument of I<fn>.)"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:299
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:305
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:305
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:309
msgid "If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:309
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:314
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set, "
"symbolic links are followed, but no file is reported twice."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:319
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""

#. type: SS
#: build/C/man3/ftw.3:319
#, no-wrap
msgid "ftw()"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:324
msgid ""
"B<ftw>()  is an older function that offers a subset of the functionality of "
"B<nftw>().  The notable differences are as follows:"
msgstr ""

#. type: IP
#: build/C/man3/ftw.3:324 build/C/man3/ftw.3:334 build/C/man3/ftw.3:338 build/C/man2/mount.2:92 build/C/man2/mount.2:97 build/C/man2/mount.2:102 build/C/man2/mount.2:111 build/C/man2/mount.2:116 build/C/man2/mount.2:303 build/C/man2/mount.2:307 build/C/man2/mount.2:312 build/C/man5/tmpfs.5:50 build/C/man5/tmpfs.5:53 build/C/man5/tmpfs.5:56 build/C/man4/fuse.4:494 build/C/man4/fuse.4:498 build/C/man4/loop.4:220 build/C/man4/loop.4:223 build/C/man4/loop.4:229
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:334
msgid ""
"B<ftw>()  has no I<flags> argument.  It behaves the same as when B<nftw>()  "
"is called with I<flags> specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:338
msgid "The callback function, I<fn>(), is not supplied with a fourth argument."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:350
msgid ""
"The range of values that is passed via the I<typeflag> argument supplied to "
"I<fn>()  is smaller: just B<FTW_F>, B<FTW_D>, B<FTW_DNR>, B<FTW_NS>, and "
"(possibly)  B<FTW_SL>."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:350 build/C/man3/getfsent.3:99 build/C/man3/getmntent.3:184 build/C/man2/getxattr.2:104 build/C/man3/isfdtype.3:71 build/C/man2/listxattr.2:126 build/C/man2/mount.2:626 build/C/man2/removexattr.2:78 build/C/man2/setxattr.2:109 build/C/man2/spu_create.2:172 build/C/man2/spu_run.2:104 build/C/man2/stat.2:374 build/C/man2/statfs.2:224 build/C/man2/statx.2:495 build/C/man3/statvfs.3:128 build/C/man2/sysfs.2:76 build/C/man2/umount.2:113 build/C/man2/ustat.2:68
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:352
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:359
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:367
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:370
msgid "B<nftw>()  is available under glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/ftw.3:380
#, no-wrap
msgid "B<nftw>()"
msgstr ""

#. type: tbl table
#: build/C/man3/ftw.3:380
#, no-wrap
msgid "MT-Safe cwd"
msgstr ""

#. type: tbl table
#: build/C/man3/ftw.3:383
#, no-wrap
msgid "B<ftw>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:391
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as "
"obsolete."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:391 build/C/man3/getfsent.3:148 build/C/man3/getmntent.3:245 build/C/man3/isfdtype.3:97 build/C/man2/mount.2:844 build/C/man2/spu_create.2:261 build/C/man2/spu_run.2:198 build/C/man2/stat.2:500 build/C/man2/statfs.2:292 build/C/man3/statvfs.3:215 build/C/man2/sysfs.2:103 build/C/man2/umount.2:179 build/C/man2/ustat.2:98 build/C/man5/sysfs.5:282 build/C/man5/tmpfs.5:221 build/C/man4/fuse.4:515 build/C/man7/inode.7:463 build/C/man7/xattr.7:175
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:395
msgid ""
"POSIX.1-2008 notes that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:401
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:419
msgid ""
"In some implementations (e.g., glibc), B<ftw>()  will never use B<FTW_SL>, "
"on other systems B<FTW_SL> occurs only for symbolic links that do not point "
"to an existing file, and again on other systems B<ftw>()  will use B<FTW_SL> "
"for each symbolic link.  If I<fpath> is a symbolic link and B<stat>(2)  "
"failed, POSIX.1-2008 states that it is undefined whether B<FTW_NS> or "
"B<FTW_SL> is passed in I<typeflag>.  For predictable results, use B<nftw>()."
msgstr ""

#.  https://bugzilla.redhat.com/show_bug.cgi?id=1422736
#.  http://austingroupbugs.net/view.php?id=1121
#.  glibc commit 6ba205b2c35e3e024c8c12d2ee1b73363e84da87
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=23501
#. type: Plain text
#: build/C/man3/ftw.3:447
msgid ""
"According to POSIX.1-2008, when the I<typeflag> argument passed to I<fn>()  "
"contains B<FTW_SLN>, the buffer pointed to by I<sb> should contain "
"information about the dangling symbolic link (obtained by calling "
"B<lstat>(2)  on the link).  Early glibc versions correctly followed the "
"POSIX specification on this point.  However, as a result of a regression "
"introduced in glibc 2.4, the contents of the buffer pointed to by I<sb> were "
"undefined when B<FTW_SLN> is passed in I<typeflag>.  (More precisely, the "
"contents of the buffer were left unchanged in this case.)  This regression "
"was eventually fixed in glibc 2.30, so that the glibc implementation (once "
"more) follows the POSIX specification."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:447 build/C/man2/getxattr.2:151 build/C/man2/listxattr.2:174 build/C/man2/spu_create.2:280 build/C/man2/spu_run.2:209 build/C/man7/spufs.7:759 build/C/man2/stat.2:637 build/C/man4/loop.4:307
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:456
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The "
"second command-line argument can be used to specify characters that control "
"the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""

#. type: SS
#: build/C/man3/ftw.3:456 build/C/man4/loop.4:325
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:465
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:476
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:481
#, no-wrap
msgid ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:484
#, no-wrap
msgid ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:487
#, no-wrap
msgid ""
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:492
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:497
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:503
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:506 build/C/man2/spu_run.2:263 build/C/man2/stat.2:707 build/C/man4/loop.4:374
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:511
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27 build/C/man3/statvfs.3:30
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:30
msgid "getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at "
"the first line."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: build/C/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:125
#, no-wrap
msgid "B<endfsent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:125 build/C/man3/getfsent.3:130 build/C/man3/getfsent.3:132
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:127
#, no-wrap
msgid "B<setfsent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:127
#, no-wrap
msgid "MT-Unsafe race:fsent"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:130
#, no-wrap
msgid "B<getfsent>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:132
#, no-wrap
msgid "B<getfsspec>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:134
#, no-wrap
msgid "B<getfsfile>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getfsent.3:134
#, no-wrap
msgid "MT-Unsafe race:fsent locale"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:148
msgid ""
"These functions are not in POSIX.1.  Several operating systems have them, "
"for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:150
msgid "These functions are not thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:160
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:163
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr ""

#. type: TH
#: build/C/man3/getmntent.3:32 build/C/man2/removexattr.2:25 build/C/man2/ustat.2:30 build/C/man5/tmpfs.5:25
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:42
#, no-wrap
msgid "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<streamp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:50
#, no-wrap
msgid "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent "
"*>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:68
#, no-wrap
msgid ""
"B<getmntent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:73
msgid ""
"These routines are used to access the filesystem description file "
"I</etc/fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:91
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>().  "
"The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3).  The returned stream should "
"be closed using B<endmntent>()  rather than B<fclose>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:103
msgid ""
"The B<getmntent>()  function reads the next line of the filesystem "
"description file from I<stream> and returns a pointer to a structure "
"containing the broken out fields from a line in the file.  The pointer "
"points to a static area of memory which is overwritten by subsequent calls "
"to B<getmntent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:113
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:119
msgid ""
"The B<endmntent>()  function closes the I<stream> associated with the "
"filesystem description file."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:136
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the "
"I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:150
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings "
"pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:156
msgid "The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:167
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:184
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the characters space (\\e040), tab (\\e011), "
"newline (\\e012), and backslash (\\e\\e) in those files when they occur in "
"one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back.  When converting from escaped "
"representation, the sequence \\e134 is also converted to a backslash."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:193
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:197
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:201
msgid "The B<endmntent>()  function always returns 1."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:206
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match "
"is found and NULL otherwise."
msgstr ""

#. type: SH
#: build/C/man3/getmntent.3:206 build/C/man2/spu_create.2:247 build/C/man4/loop.4:303
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: build/C/man3/getmntent.3:207
#, no-wrap
msgid "I</etc/fstab>"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:210
msgid "filesystem description file"
msgstr ""

#. type: TP
#: build/C/man3/getmntent.3:210
#, no-wrap
msgid "I</etc/mtab>"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:213
msgid "mounted filesystem description file"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:226
#, no-wrap
msgid ""
"B<setmntent>(),\n"
"B<endmntent>(),\n"
"B<hasmntopt>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:229
#, no-wrap
msgid "B<getmntent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:229
#, no-wrap
msgid "MT-Unsafe race:mntentbuf locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:232
#, no-wrap
msgid "B<addmntent>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:232
#, no-wrap
msgid "MT-Safe race:stream locale"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:235
#, no-wrap
msgid "B<getmntent_r>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getmntent.3:235
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:245
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>()  "
"was introduced in HP-UX 10, but it returns an I<int>.  The prototype shown "
"above is glibc-only."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:257
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V "
"I</etc/mnttab> is used.  4.4BSD and Digital UNIX have a routine "
"B<getmntinfo>(), a wrapper around the system call B<getfsstat>()."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:261
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:33 build/C/man2/listxattr.2:34 build/C/man2/removexattr.2:33 build/C/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:53 build/C/man2/listxattr.2:52 build/C/man2/removexattr.2:49 build/C/man2/setxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:66
msgid ""
"B<getxattr>()  retrieves the value of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"attribute value is placed in the buffer pointed to by I<value>; I<size> "
"specifies the size of that buffer.  The return value of the call is the "
"number of bytes placed in I<value>."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:72
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:82
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:91
msgid ""
"An extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data that was assigned using "
"B<setxattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"named extended attribute (and leave I<value> unchanged).  This can be used "
"to determine the size of the buffer that should be supplied in a subsequent "
"call.  (But, bear in mind that there is a possibility that the attribute "
"value may change between the two calls, so that it is still necessary to "
"check the return status from the second call.)"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:110
msgid ""
"On success, these calls return a nonnegative value which is the size (in "
"bytes) of the extended attribute value.  On failure, -1 is returned and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:111 build/C/man2/listxattr.2:133 build/C/man4/fuse.4:466
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:117
msgid ""
"The size of the attribute value is larger than the maximum size allowed; the "
"attribute cannot be retrieved.  This can happen on filesystems that support "
"very large attribute values such as NFSv4, for example."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:117 build/C/man2/removexattr.2:84 build/C/man2/setxattr.2:123
#, no-wrap
msgid "B<ENODATA>"
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/getxattr.2:126
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:126 build/C/man2/listxattr.2:140 build/C/man2/removexattr.2:92 build/C/man2/setxattr.2:135 build/C/man2/setxattr.2:140
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:129 build/C/man2/listxattr.2:143 build/C/man2/removexattr.2:95
msgid "Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:129 build/C/man2/listxattr.2:143 build/C/man2/setxattr.2:152
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:136
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:140 build/C/man2/listxattr.2:154 build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:152
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:143 build/C/man2/listxattr.2:157 build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:162
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: build/C/man2/getxattr.2:151 build/C/man2/listxattr.2:165 build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:170
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:154
msgid "See B<listxattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:164
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: build/C/man3/isfdtype.3:25
#, no-wrap
msgid "ISFDTYPE"
msgstr ""

#. type: TH
#: build/C/man3/isfdtype.3:25 build/C/man2/stat.2:39 build/C/man2/statx.2:30 build/C/man7/inode.7:25
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:28
msgid "isfdtype - test file type of a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:34
#, no-wrap
msgid "B<int isfdtype(int >I<fd>B<, int >I<fdtype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:42
msgid "B<isfdtype>():"
msgstr ""

#. type: TP
#: build/C/man3/isfdtype.3:45
#, no-wrap
msgid "Since glibc 2.20:"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:48
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/isfdtype.3:48
#, no-wrap
msgid "Before glibc 2.20:"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:51
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:71
msgid ""
"The B<isfdtype>()  function tests whether the file descriptor I<fd> refers "
"to a file of type I<fdtype>.  The I<fdtype> argument specifies one of the "
"B<S_IF*> constants defined in I<E<lt>sys/stat.hE<gt>> and documented in "
"B<stat>(2)  (e.g., B<S_IFREG>)."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:82
msgid ""
"The B<isfdtype>()  function returns 1 if the file descriptor I<fd> is of "
"type I<fdtype> and 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:87
msgid ""
"The B<isfdtype>()  function can fail with any of the same errors as "
"B<fstat>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:97
msgid ""
"The B<isfdtype>()  function is not specified in any standard, but did appear "
"in the draft POSIX.1g standard.  It is present on OpenBSD and Tru64 UNIX "
"(where the required header file in both cases is just "
"I<E<lt>sys/stat.hE<gt>>, as shown in the POSIX.1g draft), and possibly other "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:101
msgid "Portable applications should use B<fstat>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:103
msgid "B<fstat>(3)"
msgstr ""

#. type: TH
#: build/C/man2/listxattr.2:26
#, no-wrap
msgid "LISTXATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:29
msgid "listxattr, llistxattr, flistxattr - list extended attribute names"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:68
msgid ""
"B<listxattr>()  retrieves the list of extended attribute names associated "
"with the given I<path> in the filesystem.  The retrieved list is placed in "
"I<list>, a caller-allocated buffer whose size (in bytes) is specified in the "
"argument I<size>.  The list is the set of (null-terminated) names, one after "
"the other.  Names of extended attributes to which the calling process does "
"not have access may be omitted from the list.  The length of the attribute "
"name I<list> is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:75
msgid ""
"B<llistxattr>()  is identical to B<listxattr>(), except in the case of a "
"symbolic link, where the list of names of extended attributes associated "
"with the link itself is retrieved, not the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:85
msgid ""
"B<flistxattr>()  is identical to B<listxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:91
msgid ""
"A single extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"list of extended attribute names (and leave I<list> unchanged).  This can be "
"used to determine the size of the buffer that should be supplied in a "
"subsequent call.  (But, bear in mind that there is a possibility that the "
"set of extended attributes may change between the two calls, so that it is "
"still necessary to check the return status from the second call.)"
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:104
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:109
msgid ""
"The I<list> of names is returned as an unordered array of null-terminated "
"character strings (attribute names are separated by null bytes "
"(\\(aq\\e0\\(aq)), like this:"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:113
#, no-wrap
msgid "user.name1\\e0system.name1\\e0user.name2\\e0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:120
msgid ""
"Filesystems that implement POSIX ACLs using extended attributes might return "
"a I<list> like this:"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:124
#, no-wrap
msgid "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:132
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute name list.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:140
msgid ""
"The size of the list of extended attribute names is larger than the maximum "
"size allowed; the list cannot be retrieved.  This can happen on filesystems "
"that support an unlimited number of extended attributes per file such as "
"XFS, for example.  See BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:150
msgid "The I<size> of the I<list> buffer is too small to hold the result."
msgstr ""

#.  The xattr(7) page refers to this text:
#. type: Plain text
#: build/C/man2/listxattr.2:174
msgid ""
"As noted in B<xattr>(7), the VFS imposes a limit of 64\\ kB on the size of "
"the extended attribute name list returned by B<listxattr>(7).  If the total "
"size of attribute names attached to a file exceeds this limit, it is no "
"longer possible to retrieve the list of attribute names."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:181
msgid ""
"The following program demonstrates the usage of B<listxattr>()  and "
"B<getxattr>(2).  For the file whose pathname is provided as a command-line "
"argument, it lists all extended file attributes and their values."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:198
msgid ""
"To keep the code simple, the program assumes that attribute keys and values "
"are constant during the execution of the program.  A production program "
"should expect and handle changes during execution of the program.  For "
"example, the number of bytes required for attribute keys might increase "
"between the two calls to B<listxattr>().  An application could handle this "
"possibility using a loop that retries the call (perhaps up to a "
"predetermined maximum number of attempts)  with a larger buffer each time it "
"fails with the error B<ERANGE>.  Calls to B<getxattr>(2)  could be handled "
"similarly."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:202
msgid ""
"The following output was recorded by first creating a file, setting some "
"extended file attributes, and then listing the attributes with the example "
"program."
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:202
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:213
#, no-wrap
msgid ""
"$ B<touch /tmp/foo>\n"
"$ B<setfattr -n user.fred -v chocolate /tmp/foo>\n"
"$ B<setfattr -n user.frieda -v bar /tmp/foo>\n"
"$ B<setfattr -n user.empty /tmp/foo>\n"
"$ B<./listxattr /tmp/foo>\n"
"user.fred: chocolate\n"
"user.frieda: bar\n"
"user.empty: E<lt>no valueE<gt>\n"
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:215
#, no-wrap
msgid "Program source (listxattr.c)"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:223
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/xattr.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:229
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t buflen, keylen, vallen;\n"
"    char *buf, *key, *val;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:234
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:247
#, no-wrap
msgid ""
"    /*\n"
"     * Determine the length of the buffer needed.\n"
"     */\n"
"    buflen = listxattr(argv[1], NULL, 0);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (buflen == 0) {\n"
"        printf(\"%s has no attributes.\\en\", argv[1]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:256
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate the buffer.\n"
"     */\n"
"    buf = malloc(buflen);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:265
#, no-wrap
msgid ""
"    /*\n"
"     * Copy the list of attribute keys to the buffer.\n"
"     */\n"
"    buflen = listxattr(argv[1], buf, buflen);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:273
#, no-wrap
msgid ""
"    /*\n"
"     * Loop over the list of zero terminated strings with the\n"
"     * attribute keys. Use the remaining buffer length to determine\n"
"     * the end of the list.\n"
"     */\n"
"    key = buf;\n"
"    while (buflen E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:278
#, no-wrap
msgid ""
"        /*\n"
"         * Output attribute key.\n"
"         */\n"
"        printf(\"%s: \", key);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:285
#, no-wrap
msgid ""
"        /*\n"
"         * Determine length of the value.\n"
"         */\n"
"        vallen = getxattr(argv[1], key, NULL, 0);\n"
"        if (vallen == -1)\n"
"            perror(\"getxattr\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:287
#, no-wrap
msgid "        if (vallen E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:297
#, no-wrap
msgid ""
"            /*\n"
"             * Allocate value buffer.\n"
"             * One extra byte is needed to append 0x00.\n"
"             */\n"
"            val = malloc(vallen + 1);\n"
"            if (val == NULL) {\n"
"                perror(\"malloc\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:311
#, no-wrap
msgid ""
"            /*\n"
"             * Copy value to buffer.\n"
"             */\n"
"            vallen = getxattr(argv[1], key, val, vallen);\n"
"            if (vallen == -1)\n"
"                perror(\"getxattr\");\n"
"            else {\n"
"                /*\n"
"                 * Output attribute value.\n"
"                 */\n"
"                val[vallen] = 0;\n"
"                printf(\"%s\", val);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:315
#, no-wrap
msgid ""
"            free(val);\n"
"        } else if (vallen == 0)\n"
"            printf(\"E<lt>no valueE<gt>\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:317
#, no-wrap
msgid "        printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:325
#, no-wrap
msgid ""
"        /*\n"
"         * Forward to next attribute key.\n"
"         */\n"
"        keylen = strlen(key) + 1;\n"
"        buflen -= keylen;\n"
"        key += keylen;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:329
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:340
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:46 build/C/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long "
">I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:60
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a "
"pathname referring to a device, but can also be the pathname of a directory "
"or file, or a dummy string) to the location (a directory or file)  specified "
"by the pathname in I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:64
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:73
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed "
"in I</proc/filesystems> (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\", "
"\"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", "
"\"cifs\", \"iso9660\").  Further types may become available when the "
"appropriate modules are loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:82
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically "
"it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:92
msgid ""
"A call to B<mount>()  performs one of a number of general types of "
"operation, depending on the bits specified in I<mountflags>.  The choice of "
"which operation to perform is determined by testing the bits set in "
"I<mountflags>, with the tests being conducted in the order listed here:"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:97
msgid "Remount an existing mount: I<mountflags> includes B<MS_REMOUNT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:102
msgid "Create a bind mount: I<mountflags> includes B<MS_BIND>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:111
msgid ""
"Change the propagation type of an existing mount: I<mountflags> includes one "
"of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:116
msgid "Move an existing mount to a new location: I<mountflags> includes B<MS_MOVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:120
msgid "Create a new mount: I<mountflags> includes none of the above flags."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:128
msgid ""
"Each of these operations is detailed later in this page.  Further flags may "
"be specified in I<mountflags> to modify the behavior of B<mount>(), as "
"described below."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:128
#, no-wrap
msgid "Additional mount flags"
msgstr ""

#
#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#.  commit 7a224228ed79d587ece2304869000aad1b8e97dd
#.  (This is a per-superblock flag)
#. type: Plain text
#: build/C/man2/mount.2:138
msgid ""
"The list below describes the additional flags that can be specified in "
"I<mountflags>.  Note that some operation types ignore some or all of these "
"flags, as described later in this page."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:138
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:144
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:144
#, no-wrap
msgid "B<MS_LAZYTIME> (since Linux 4.0)"
msgstr ""

#.  commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
#.  commit fe032c422c5ba562ba9c2d316f55e258e03259c6
#.  commit a26f49926da938f47561f386be56a83dd37a496d
#. type: Plain text
#: build/C/man2/mount.2:152
msgid ""
"Reduce on-disk updates of inode timestamps (atime, mtime, ctime)  by "
"maintaining these changes only in memory.  The on-disk timestamps are "
"updated only when:"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:153
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:155
msgid "the inode needs to be updated for some change unrelated to file timestamps;"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:155
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:161
msgid "the application employs B<fsync>(2), B<syncfs>(2), or B<sync>(2);"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:161
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:163
msgid "an undeleted inode is evicted from memory; or"
msgstr ""

#. type: IP
#: build/C/man2/mount.2:163
#, no-wrap
msgid "(d)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:165
msgid "more than 24 hours have passed since the inode was written to disk."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:171
msgid ""
"This mount option significantly reduces writes needed to update the inode's "
"timestamps, especially mtime and atime.  However, in the event of a system "
"crash, the atime and mtime fields on disk might be out of date by up to 24 "
"hours."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:185
msgid ""
"Examples of workloads where this option could be of significant benefit "
"include frequent random writes to preallocated files, as well as cases where "
"the B<MS_STRICTATIME> mount option is also enabled.  (The advantage of "
"combining B<MS_STRICTATIME> and B<MS_LAZYTIME> is that B<stat>(2)  will "
"return the correctly updated atime, but the atime updates will be flushed to "
"disk only in the cases listed above.)"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:185
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr ""

#.  commit 95ace75414f312f9a7b93d873f386987b92a5301
#. type: Plain text
#: build/C/man2/mount.2:198
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)  "
"Since Linux 4.5, this mount option requires the B<CAP_SYS_ADMIN> capability "
"and a kernel configured with the B<CONFIG_MANDATORY_FILE_LOCKING> option."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:198
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:201
msgid "Do not update access times for (all types of) files on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:201
#, no-wrap
msgid "B<MS_NODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:204
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:204
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:213
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:213
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr ""

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: build/C/man2/mount.2:219
msgid "Do not allow programs to be executed from this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:219
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr ""

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: build/C/man2/mount.2:225
msgid ""
"Do not honor set-user-ID and set-group-ID bits or file capabilities when "
"executing programs from this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:225
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:228
msgid "Mount filesystem read-only."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:228
#, no-wrap
msgid "B<MS_REC> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:236
msgid ""
"Used in conjunction with B<MS_BIND> to create a recursive bind mount, and in "
"conjunction with the propagation type flags to recursively change the "
"propagation type of all of the mounts in a subtree.  See below for further "
"details."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:236
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr ""

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: build/C/man2/mount.2:257
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the "
"file's last modification time (mtime)  or last status change time (ctime).  "
"This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:257
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:265
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:265
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:275
msgid ""
"Always update the last access time (atime) when files on this filesystem are "
"accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying "
"this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:275
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:283
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:283
#, no-wrap
msgid "B<MS_NOSYMFOLLOW> (since Linux 5.10)"
msgstr ""

#.  dab741e0e02bd3c4f5e2e97be74b39df2523fc6e
#. type: Plain text
#: build/C/man2/mount.2:295
msgid ""
"Do not follow symbolic links when resolving paths.  Symbolic links can still "
"be created, and B<readlink>(1), B<readlink>(2), B<realpath>(1), and "
"B<realpath>(3)  all still work properly."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:301
msgid ""
"From Linux 2.4 onward, some of the above flags are settable on a per-mount "
"basis, while others apply to the superblock of the mounted filesystem, "
"meaning that all mounts of the same filesystem share those flags.  "
"(Previously, all of the flags were per-superblock.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:303
msgid "The per-mount-point flags are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:307
msgid ""
"Since Linux 2.4: B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags are "
"settable on a per-mount-point basis."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:312
msgid "Additionally, since Linux 2.6.16: B<MS_NOATIME> and B<MS_NODIRATIME>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:315
msgid "Additionally, since Linux 2.6.20: B<MS_RELATIME>."
msgstr ""

#.  And MS_I_VERSION?
#. type: Plain text
#: build/C/man2/mount.2:331
msgid ""
"The following flags are per-superblock: B<MS_DIRSYNC>, B<MS_LAZYTIME>, "
"B<MS_MANDLOCK>, B<MS_SILENT>, and B<MS_SYNCHRONOUS>.  The initial settings "
"of these flags are determined on the first mount of the filesystem, and will "
"be shared by all subsequent mounts of the same filesystem.  Subsequently, "
"the settings of the flags can be changed via a remount operation (see "
"below).  Such changes will be visible via all mount points associated with "
"the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:339
msgid ""
"Since Linux 2.6.16, B<MS_RDONLY> can be set or cleared on a per-mount-point "
"basis as well as on the underlying filesystem superblock.  The mounted "
"filesystem will be writable only if neither the filesystem nor the "
"mountpoint are flagged as read-only."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:339
#, no-wrap
msgid "Remounting an existing mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:353
msgid ""
"An existing mount may be remounted by specifying B<MS_REMOUNT> in "
"I<mountflags>.  This allows you to change the I<mountflags> and I<data> of "
"an existing mount without having to unmount and remount the filesystem.  "
"I<target> should be the same value specified in the initial B<mount>()  "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:359
msgid "The I<source> and I<filesystemtype> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:367
msgid ""
"The I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr ""

#.  FIXME
#.  MS_LAZYTIME seems to be available only on a few filesystems,
#.  and on ext4, it seems (from experiment that this flag
#.  can only be enabled (but not disabled) on a remount.
#.  The following code in ext4_remount() (kernel 4.17) seems to
#.  confirm this:
#
#.         if (*flags & SB_LAZYTIME)
#.                 sb->s_flags |= SB_LAZYTIME;
#.  See the definition of MS_RMT_MASK in include/uapi/linux/fs.h,
#.  which excludes MS_DIRSYNC and MS_SILENT, although SB_DIRSYNC
#.  and SB_SILENT are split out as per-superblock flags in do_mount()
#.  (Linux 4.17 source code)
#. type: Plain text
#: build/C/man2/mount.2:409
msgid ""
"The following I<mountflags> can be changed: B<MS_LAZYTIME>, B<MS_MANDLOCK>, "
"B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, "
"B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (whose effect is to clear "
"the B<MS_NOATIME> and B<MS_RELATIME> flags), and B<MS_SYNCHRONOUS>.  "
"Attempts to change the setting of the B<MS_DIRSYNC> and B<MS_SILENT> flags "
"during a remount are silently ignored.  Note that changes to per-superblock "
"flags are visible via all mount points of the associated filesystem (because "
"the per-superblock flags are shared by all mount points)."
msgstr ""

#.  commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
#. type: Plain text
#: build/C/man2/mount.2:423
msgid ""
"Since Linux 3.17, if none of B<MS_NOATIME>, B<MS_NODIRATIME>, "
"B<MS_RELATIME>, or B<MS_STRICTATIME> is specified in I<mountflags>, then the "
"remount operation preserves the existing values of these flags (rather than "
"defaulting to B<MS_RELATIME>)."
msgstr ""

#.  See https://lwn.net/Articles/281157/
#. type: Plain text
#: build/C/man2/mount.2:435
msgid ""
"Since Linux 2.6.26, the B<MS_REMOUNT> flag can be used with B<MS_BIND> to "
"modify only the per-mount-point flags.  This is particularly useful for "
"setting or clearing the \"read-only\" flag on a mount point without changing "
"the underlying filesystem.  Specifying I<mountflags> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:439
#, no-wrap
msgid "MS_REMOUNT | MS_BIND | MS_RDONLY\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:445
msgid ""
"will make access through this mountpoint read-only, without affecting other "
"mount points."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:445
#, no-wrap
msgid "Creating a bind mount"
msgstr ""

#.  since 2.4.0-test9
#. type: Plain text
#: build/C/man2/mount.2:458
msgid ""
"If I<mountflags> includes B<MS_BIND> (available since Linux 2.4), then "
"perform a bind mount.  A bind mount makes a file or a directory subtree "
"visible at another point within the single directory hierarchy.  Bind mounts "
"may cross filesystem boundaries and span B<chroot>(2)  jails."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:464
msgid "The I<filesystemtype> and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:474
msgid ""
"The remaining bits (other than B<MS_REC>, described below) in the "
"I<mountflags> argument are also ignored.  (The bind mount has the same mount "
"options as the underlying mount point.)  However, see the discussion of "
"remounting above, for a method of making an existing bind mount read-only."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:489
msgid ""
"By default, when a directory is bind mounted, only that directory is "
"mounted; if there are any submounts under the directory tree, they are not "
"bind mounted.  If the B<MS_REC> flag is also specified, then a recursive "
"bind mount operation is performed: all submounts under the I<source> subtree "
"(other than unbindable mounts)  are also bind mounted at the corresponding "
"location in the I<target> subtree."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:489
#, no-wrap
msgid "Changing the propagation type of an existing mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:501
msgid ""
"If I<mountflags> includes one of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, "
"or B<MS_UNBINDABLE> (all available since Linux 2.6.15), then the propagation "
"type of an existing mount is changed.  If more than one of these flags is "
"specified, an error results."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:508
msgid ""
"The only other flags that can be specified while changing the propagation "
"type are B<MS_REC> (described below) and B<MS_SILENT> (which is ignored)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:515
msgid "The I<source>, I<filesystemtype>, and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:517
msgid "The meanings of the propagation type flags are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:517
#, no-wrap
msgid "B<MS_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:526
msgid ""
"Make this mount point shared.  Mount and unmount events immediately under "
"this mount point will propagate to the other mount points that are members "
"of this mount's peer group.  Propagation here means that the same mount or "
"unmount will automatically occur under all of the other mount points in the "
"peer group.  Conversely, mount and unmount events that take place under peer "
"mount points will propagate to this mount point."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:526
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:530
msgid ""
"Make this mount point private.  Mount and unmount events do not propagate "
"into or out of this mount point."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:530
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:537
msgid ""
"If this is a shared mount point that is a member of a peer group that "
"contains other members, convert it to a slave mount.  If this is a shared "
"mount point that is a member of a peer group that contains no other members, "
"convert it to a private mount.  Otherwise, the propagation type of the mount "
"point is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:542
msgid ""
"When a mount point is a slave, mount and unmount events propagate into this "
"mount point from the (master) shared peer group of which it was formerly a "
"member.  Mount and unmount events under this mount point do not propagate to "
"any peer."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:546
msgid ""
"A mount point can be the slave of another peer group while at the same time "
"sharing mount and unmount events with a peer group of which it is a member."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:546
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:561
msgid ""
"Make this mount unbindable.  This is like a private mount, and in addition "
"this mount can't be bind mounted.  When a recursive bind mount (B<mount>()  "
"with the B<MS_BIND> and B<MS_REC> flags) is performed on a directory "
"subtree, any unbindable mounts within the subtree are automatically pruned "
"(i.e., not replicated)  when replicating that subtree to produce the target "
"subtree."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:572
msgid ""
"By default, changing the propagation type affects only the I<target> mount "
"point.  If the B<MS_REC> flag is also specified in I<mountflags>, then the "
"propagation type of all mount points under I<target> is also changed."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:577
msgid ""
"For further details regarding mount propagation types (including the default "
"propagation type assigned to new mounts), see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:577
#, no-wrap
msgid "Moving a mount"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:589
msgid ""
"If I<mountflags> contains the flag B<MS_MOVE> (available since Linux "
"2.4.18), then move a subtree: I<source> specifies an existing mount point "
"and I<target> specifies the new location to which that mount point is to be "
"relocated.  The move is atomic: at no point is the subtree unmounted."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:598
msgid ""
"The remaining bits in the I<mountflags> argument are ignored, as are the "
"I<filesystemtype> and I<data> arguments."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:598
#, no-wrap
msgid "Creating a new mount point"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:617
msgid ""
"If none of B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, "
"B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE> is specified in "
"I<mountflags>, then B<mount>()  performs its default action: creating a new "
"mount point.  I<source> specifies the source for the new mount point, and "
"I<target> specifies the directory at which to create the mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:626
msgid ""
"The I<filesystemtype> and I<data> arguments are employed, and further bits "
"may be specified in I<mountflags> to modify the behavior of the call."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:631 build/C/man2/stat.2:379 build/C/man2/statfs.2:229 build/C/man2/statx.2:500 build/C/man3/statvfs.3:133 build/C/man2/umount.2:118
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:637 build/C/man2/umount.2:124
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each filesystem type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:637 build/C/man2/mount.2:642 build/C/man2/mount.2:660 build/C/man2/spu_create.2:180 build/C/man2/stat.2:380 build/C/man2/statfs.2:230 build/C/man2/statx.2:501 build/C/man3/statvfs.3:134
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:642
msgid "A component of a path was not searchable.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:647
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:656
msgid ""
"The filesystem may be read-only for various reasons, including: it resides "
"on a read-only optical disk; it is resides on a device with a physical "
"switch that has been set to mark the device read-only; the filesystem "
"implementation was compiled with read-only support; or errors were detected "
"when initially mounting the filesystem, so that it was marked read-only and "
"can't be remounted as read-write (until the errors are fixed)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:660
msgid ""
"Some filesystems instead return the error B<EROFS> on an attempt to mount a "
"read-only filesystem."
msgstr ""

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: build/C/man2/mount.2:669
msgid ""
"The block device I<source> is located on a filesystem mounted with the "
"B<MS_NODEV> option."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:669 build/C/man2/mount.2:677 build/C/man2/umount.2:131
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:677
msgid ""
"An attempt was made to stack a new mount directly on top of an existing "
"mount point that was created in this mount namespace with the same I<source> "
"and I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:682
msgid ""
"I<source> cannot be remounted read-only, because it still holds files open "
"for writing."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:682 build/C/man2/spu_create.2:188 build/C/man2/spu_run.2:160 build/C/man2/stat.2:391 build/C/man2/statfs.2:242 build/C/man2/statx.2:512 build/C/man3/statvfs.3:146 build/C/man2/sysfs.2:89 build/C/man2/umount.2:135 build/C/man2/ustat.2:78
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:685
msgid "One of the pointer arguments points outside the user address space."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:689
msgid "I<source> had an invalid superblock."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:697
msgid ""
"A remount operation (B<MS_REMOUNT>)  was attempted, but I<source> was not "
"already mounted on I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:707
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the mount tree under "
"I<source> includes unbindable mounts and I<target> is a mount point that has "
"propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:715
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the parent mount of "
"I<source> mount has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:722
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but I<source> was not a mount "
"point, or was \\(aq/\\(aq."
msgstr ""

#.  See commit 8823c079ba7136dc1948d6f6dcb5f8022bde438e
#. type: Plain text
#: build/C/man2/mount.2:738
msgid ""
"A bind operation (B<MS_BIND>)  was requested where I<source> referred a "
"mount namespace magic link (i.e., a I</proc/[pid]/ns/mnt> magic link or a "
"bind mount to such a link)  and the propagation type of the parent mount of "
"I<target> was B<MS_SHARED>, but propagation of the requested bind mount "
"could lead to a circular dependency that might prevent the mount namespace "
"from ever being freed."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:747
msgid ""
"I<mountflags> includes more than one of B<MS_SHARED>, B<MS_PRIVATE>, "
"B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:760
msgid ""
"I<mountflags> includes B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or "
"B<MS_UNBINDABLE> and also includes a flag other than B<MS_REC> or "
"B<MS_SILENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:763
msgid "An attempt was made to bind mount an unbindable mount."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:774
msgid ""
"In an unprivileged mount namespace (i.e., a mount namespace owned by a user "
"namespace that was created by an unprivileged user), a bind mount operation "
"(B<MS_BIND>)  was attempted without specifying (B<MS_REC>), which would have "
"revealed the filesystem tree underneath one of the submounts of the "
"directory being bound."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:774 build/C/man2/mount.2:777 build/C/man2/spu_create.2:199 build/C/man2/stat.2:394 build/C/man2/statfs.2:255 build/C/man2/statx.2:530 build/C/man3/statvfs.3:159
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:777
msgid "Too many links encountered during pathname resolution."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:783
msgid "A move operation was attempted, and I<target> is a descendant of I<source>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:783 build/C/man2/spu_create.2:203
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:787
msgid "(In case no block device is required:)  Table of dummy devices is full."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:787 build/C/man2/spu_create.2:206 build/C/man2/stat.2:397 build/C/man2/statfs.2:260 build/C/man2/statx.2:533 build/C/man3/statvfs.3:164 build/C/man2/umount.2:157
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:791 build/C/man2/umount.2:161
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:791 build/C/man2/spu_create.2:213 build/C/man4/fuse.4:501
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:795
msgid "I<filesystemtype> not configured in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:795 build/C/man2/spu_create.2:217 build/C/man2/stat.2:401 build/C/man2/stat.2:406 build/C/man2/statfs.2:265 build/C/man2/statx.2:537 build/C/man3/statvfs.3:169 build/C/man2/umount.2:161
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:798 build/C/man2/umount.2:164
msgid "A pathname was empty or had a nonexistent component."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:798 build/C/man2/spu_create.2:222 build/C/man2/spu_run.2:181 build/C/man2/stat.2:413 build/C/man2/statfs.2:271 build/C/man2/statx.2:547 build/C/man3/statvfs.3:175 build/C/man2/umount.2:164
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:801 build/C/man2/umount.2:167
msgid "The kernel could not allocate a free page to copy filenames or data into."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:801
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:805
msgid "I<source> is not a block device (and a device was required)."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:805 build/C/man2/spu_create.2:235 build/C/man2/stat.2:416 build/C/man2/stat.2:451 build/C/man2/statfs.2:277 build/C/man2/statx.2:550 build/C/man3/statvfs.3:181
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:811
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:811
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:816
msgid "The major number of the block device I<source> is out of range."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:816 build/C/man2/setxattr.2:143 build/C/man2/spu_create.2:240 build/C/man2/umount.2:167 build/C/man4/fuse.4:508
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:819 build/C/man2/umount.2:170
msgid "The caller does not have the required privileges."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:819
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:827
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  See B<EACCES>, above."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:841
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, "
"B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME>, and "
"B<MS_UNBINDABLE> were added to glibc headers in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:844
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: build/C/man2/mount.2:849
msgid ""
"Since Linux 2.4 a single filesystem can be mounted at multiple mount points, "
"and multiple mounts can be stacked on the same mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:861
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)  "
"in the top 16 bits.  (All of the other flags discussed in DESCRIPTION occupy "
"the low order 16 bits of I<mountflags>.)  Specifying B<MS_MGC_VAL> was "
"required in kernel versions prior to 2.4, but since Linux 2.4 is no longer "
"required and is ignored if specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:870
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: build/C/man2/mount.2:880
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program "
"on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in "
"this case."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:880
#, no-wrap
msgid "Mount namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:890
msgid ""
"Starting with kernel 2.4.19, Linux provides mount namespaces.  A mount "
"namespace is the set of filesystem mounts that are visible to a process.  "
"Mount namespaces can be (and usually are)  shared between multiple "
"processes, and changes to the namespace (i.e., mounts and unmounts) by one "
"process are visible to all other processes sharing the same namespace.  (The "
"pre-2.4.19 Linux situation can be considered as one in which a single "
"namespace was shared by every process on the system.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:896
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:916
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice "
"versa."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:920
msgid "For further details on mount namespaces, see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:920
#, no-wrap
msgid "Parental relationship between mount points"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:924
msgid ""
"Each mount point has a parent mount point.  The overall parental "
"relationship of all mount points defines the single directory hierarchy seen "
"by the processes within a mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:932
msgid ""
"The parent of a new mount point is defined when the mount point is created.  "
"In the usual case, the parent of a new mount is the mount point of the "
"filesystem containing the directory or file at which the new mount is "
"attached.  In the case where a new mount is stacked on top of an existing "
"mount, the parent of the new mount is the previous mount that was stacked at "
"that location."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:937
msgid ""
"The parental relationship between mount points can be discovered via the "
"I</proc/[pid]/mountinfo> file (see below)."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:937
#, no-wrap
msgid "/proc/[pid]/mounts and /proc/[pid]/mountinfo"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:952
msgid ""
"The Linux-specific I</proc/[pid]/mounts> file exposes the list of mount "
"points in the mount namespace of the process with the specified ID.  The "
"I</proc/[pid]/mountinfo> file exposes even more information about mount "
"points, including the propagation type and mount ID information that makes "
"it possible to discover the parental relationship between mount points.  See "
"B<proc>(5)  and B<mount_namespaces>(7)  for details of this file."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:964
msgid ""
"B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), "
"B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), "
"B<lsblk>(8), B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:43
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  A process inherits "
"its root directory from its parent.  Usually this will be the root directory "
"of the file hierarchy.  A process may get a different root directory by use "
"of the B<chroot>(2)  system call, or may temporarily use a different root "
"directory by using B<openat2>(2)  with the B<RESOLVE_IN_ROOT> flag set."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:51
msgid ""
"A process may get an entirely private mount namespace in case it\\(emor one "
"of its ancestors\\(emwas started by an invocation of the B<clone>(2)  system "
"call that had the B<CLONE_NEWNS> flag set.  This handles the \\(aq/\\(aq "
"part of the pathname."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:67
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process \\(em or in the case of B<openat>(2)-style system calls, the "
"I<dfd> argument (or the current working directory if B<AT_FDCWD> is passed "
"as the I<dfd> argument).  The current working directory is inherited from "
"the parent, and can be changed by use of the B<chdir>(2)  system call.)"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:70
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:70
#, no-wrap
msgid "Step 2: walk along the path"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:75
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for "
"each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:81
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:86
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:91
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:95
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:118
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve "
"this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symbolic link is successful and returns a directory, we set the current "
"lookup directory to that directory, and go to the next component.  Note that "
"the resolution process here can involve recursion if the prefix ('dirname') "
"component of a pathname contains a filename that is a symbolic link that "
"resolves to a directory (where the prefix component of that directory may "
"contain a symbolic link, and so on).  In order to protect the kernel against "
"stack overflow, and also to protect against denial of service, there are "
"limits on the maximum recursion depth, and on the maximum number of symbolic "
"links followed.  An B<ELOOP> error is returned when the maximum is exceeded "
"(\"Too many levels of symbolic links\")."
msgstr ""

#
#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#.  MAXSYMLINKS is 40
#.  MAX_NESTED_LINKS
#.  commit 894bc8c4662ba9daceafe943a5ba0dd407da5cd3
#. type: Plain text
#: build/C/man7/path_resolution.7:136
msgid ""
"As currently implemented on Linux, the maximum number of symbolic links that "
"will be followed while resolving a pathname is 40.  In kernels before "
"2.6.18, the limit on the recursion depth was 5.  Starting with Linux 2.6.18, "
"this limit was raised to 8.  In Linux 4.2, the kernel's pathname-resolution "
"code was reworked to eliminate the use of recursion, so that the only limit "
"that remains is the maximum of 40 resolutions for the entire pathname."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:142
msgid ""
"The resolution of symbolic links during this stage can be blocked by using "
"B<openat2>(2), with the B<RESOLVE_NO_SYMLINKS> flag set."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:142
#, no-wrap
msgid "Step 3: find the final entry"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:154
msgid ""
"The lookup of the final component of the pathname goes just like that of all "
"other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path "
"resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:154
#, no-wrap
msgid ". and .."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:158
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer "
"to the directory itself and to its parent directory, respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:162
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:164
msgid "One cannot walk up past the root: \"/..\" is the same as \"/\"."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:164
#, no-wrap
msgid "Mount points"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:168
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root "
"of the filesystem hierarchy on the device \"dev\", and no longer to whatever "
"it referred to earlier."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:172
msgid ""
"One can walk out of a mounted filesystem: \"path/..\" refers to the parent "
"directory of \"path\", outside of the filesystem hierarchy on \"dev\"."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:178
msgid ""
"Traversal of mount points can be blocked by using B<openat2>(2), with the "
"B<RESOLVE_NO_XDEV> flag set (though note that this also restricts bind mount "
"traversal)."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:178
#, no-wrap
msgid "Trailing slashes"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:184
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding "
"component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise, a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname "
"with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:184
#, no-wrap
msgid "Final symlink"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:193
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call "
"B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the "
"file pointed to by the symlink."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:193
#, no-wrap
msgid "Length limit"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:200
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long, "
"an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:200
#, no-wrap
msgid "Empty pathname"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:207
msgid ""
"In the original UNIX, the empty pathname referred to the current directory.  "
"Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:207
#, no-wrap
msgid "Permissions"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:220
msgid ""
"The permission bits of a file consist of three groups of three bits; see "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2)).  "
"When neither holds, the third group is used."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:224
msgid ""
"Of the three bits used, the first bit determines read permission, the second "
"write permission, and the last execute permission in case of ordinary files, "
"or search permission in case of directories."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:229
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks.  "
"Ordinarily the fsuid will equal the effective user ID, but the fsuid can be "
"changed by the system call B<setfsuid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:237
msgid ""
"(Here \"fsuid\" stands for something like \"filesystem user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective "
"user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""

#.  FIXME . say something about filesystem mounted read-only ?
#. type: Plain text
#: build/C/man7/path_resolution.7:243
msgid ""
"Similarly, Linux uses the fsgid (\"filesystem group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:243
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr ""

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: build/C/man7/path_resolution.7:254
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is "
"all-powerful, and bypasses all permissions restrictions when accessing "
"files."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:262
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:268
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute "
"permission bits is set."
msgstr ""

#.  FIXME . say something about immutable files
#.  FIXME . say something about ACLs
#. type: Plain text
#: build/C/man7/path_resolution.7:275
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:280
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:78
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:114
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/removexattr.2:92
msgid "The named attribute does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:120
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr ""

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> argument specifies the size (in bytes) of I<value>; a zero-length "
"value is permitted."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:93
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:102
msgid ""
"By default (i.e., I<flags> is zero), the extended attribute will be created "
"if it does not exist, or the value will be replaced if the attribute already "
"exists.  To modify these semantics, one of the following values can be "
"specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:102
#, no-wrap
msgid "B<XATTR_CREATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:105
msgid "Perform a pure create, which fails if the named attribute exists already."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:105
#, no-wrap
msgid "B<XATTR_REPLACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:109
msgid ""
"Perform a pure replace operation, which fails if the named attribute does "
"not already exist."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:115
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:119
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:119 build/C/man2/spu_create.2:185
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:123
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: build/C/man2/setxattr.2:132
msgid "B<XATTR_REPLACE> was specified, and the attribute does not exist."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:132 build/C/man2/spu_create.2:225
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:135
msgid "There is insufficient space remaining to store the extended attribute."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:140
msgid "The namespace prefix of I<name> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:143
msgid "Extended attributes are not supported by the filesystem, or are disabled,"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:148
msgid "The file is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:159
msgid "The size of I<name> or I<value> exceeds a filesystem-specific limit."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:180
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: build/C/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:35
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:39 build/C/man2/spu_run.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:58
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:77
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:89
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:95
msgid ""
"The I<neighbor_fd> is used only when the B<SPU_CREATE_AFFINITY_SPU> flag is "
"specified; see below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:100
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:100
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:106
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:106
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:114
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:121
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:121
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:127
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:138
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:144
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:144
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:151
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:157
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:157
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU> (since Linux 2.6.23)"
msgstr ""

#.  commit 8e68e2f248332a9c3fd4f08258f488c209bd3e0c
#. type: Plain text
#: build/C/man2/spu_create.2:166
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:166
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM> (since Linux 2.6.23)"
msgstr ""

#.  commit 8e68e2f248332a9c3fd4f08258f488c209bd3e0c
#. type: Plain text
#: build/C/man2/spu_create.2:172
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:179
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:185
msgid "The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:188
msgid "An SPU context already exists at the given pathname."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:193
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:199
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:203
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:206
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:210 build/C/man2/stat.2:401 build/C/man2/statx.2:537
msgid "I<pathname> is too long."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:210
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:213
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:217
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:222
msgid "Part of I<pathname> could not be resolved."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:225
msgid "The kernel could not allocate all resources required."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:230
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:230 build/C/man2/spu_run.2:185 build/C/man2/statfs.2:274 build/C/man3/statvfs.3:178 build/C/man2/ustat.2:86
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:235 build/C/man2/spu_run.2:190
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:240
msgid "A part of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:247
msgid ""
"The B<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:253
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:257
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:261
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:272
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:280
msgid ""
"Prior to the addition of the B<SPU_CREATE_AFFINITY_SPU> flag in Linux "
"2.6.23, the B<spu_create>()  system call took only three arguments (i.e., "
"there was no I<neighbor_fd> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:285
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:290
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: build/C/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr ""

#. type: TH
#: build/C/man2/spu_run.2:26 build/C/man4/loop.4:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:35
#, no-wrap
msgid ""
"B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int "
"*>I<event>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using "
"B<pthread_create>(3))."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr ""

#.  SPE_EVENT_SPE_DATA_SEGMENT is defined, but does not seem to be generated
#.  at any point (in Linux 5.9 sources).
#. type: Plain text
#: build/C/man2/spu_run.2:92
msgid "An invalid MFC DMA command was attempted."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:92
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:95
msgid "A DMA storage error occurred."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:95
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:98
msgid "An illegal instruction was executed."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:104
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:113
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:122
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:122
#, no-wrap
msgid "B<0x02>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:127
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:127
#, no-wrap
msgid "B<0x04>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:132
msgid "SPU was stopped by a B<halt> instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:132
#, no-wrap
msgid "B<0x08>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:135
msgid "SPU is waiting for a channel."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:135
#, no-wrap
msgid "B<0x10>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:138
msgid "SPU is in single-step mode."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:138
#, no-wrap
msgid "B<0x20>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:141
msgid "SPU has tried to execute an invalid instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:141
#, no-wrap
msgid "B<0x40>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:144
msgid "SPU has tried to access an invalid channel."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:144
#, no-wrap
msgid "B<0x3fff0000>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:150
msgid ""
"The bits masked with this value contain the code returned from a "
"B<stop-and-signal> instruction.  These bits are valid only if the 0x02 bit "
"is set."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:155
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:156 build/C/man2/stat.2:387 build/C/man2/stat.2:443 build/C/man2/statfs.2:237 build/C/man2/statx.2:508 build/C/man3/statvfs.3:141
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:160
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:166
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:166 build/C/man2/statfs.2:248 build/C/man3/statvfs.3:152
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:176
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:181
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:185
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:194
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:198
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:209
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:214
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:222
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:225
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:230
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:234
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:239
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:244
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:250
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:254
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:260
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: %#08x\\en\", spu_status);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:271
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:30
msgid "spufs - SPU filesystem"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:34
msgid ""
"The SPU filesystem is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units "
"(SPUs)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:43
msgid ""
"The filesystem provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the filesystem can use "
"B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical "
"SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:50 build/C/man5/tmpfs.5:66
#, no-wrap
msgid "Mount options"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system "
"calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular filesystems.  This list details the "
"supported operations and the deviations from the standard behavior described "
"in the respective man pages."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support "
"B<writev>(2).  All files support the B<access>(2)  and B<stat>(2)  family of "
"operations, but for the latter call, the only fields of the returned I<stat> "
"structure that contain reliable information are I<st_mode>, I<st_nlink>, "
"I<st_uid>, and I<st_gid>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/B<fchown>(2)  "
"operations, but will not be able to grant permissions that contradict the "
"possible operations (e.g., read access on the I<wbox> file)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:108
msgid "The current set of files is:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:144 build/C/man7/spufs.7:706 build/C/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings "
"are allowed."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:182 build/C/man7/spufs.7:222 build/C/man7/spufs.7:317 build/C/man7/spufs.7:381 build/C/man7/spufs.7:418 build/C/man7/spufs.7:463 build/C/man7/spufs.7:517 build/C/man7/spufs.7:632 build/C/man7/spufs.7:676 build/C/man7/spufs.7:754
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:247 build/C/man7/spufs.7:295 build/C/man7/spufs.7:685
#, no-wrap
msgid "B<poll>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:268 build/C/man7/spufs.7:392 build/C/man7/spufs.7:432 build/C/man7/spufs.7:476 build/C/man7/spufs.7:527 build/C/man7/spufs.7:638 build/C/man7/spufs.7:652 build/C/man7/spufs.7:749
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox\\(emthat is, how many words can be read from I<mbox> or I<ibox> "
"or how many words can be written to I<wbox> without blocking.  The files can "
"be read only in four-byte units and return a big-endian binary integer "
"number.  The only possible operation on an open I<*box_stat> file is:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat> "
"and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox "
"without blocking or returning an B<EAGAIN> error."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:338
#, no-wrap
msgid ""
"I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, "
"I</event_status>, I</srr0>, I</lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:362
msgid "Decrementer Status"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue "
"reading from the same buffer, until the end of the buffer is reached."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:402 build/C/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in "
"the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU.  "
"These are read-write files that operate on four-byte words.  Writing to one "
"of these files triggers an interrupt on the SPU.  The value written to the "
"signal files can be read from the SPU through a channel read or from host "
"user space through the file.  After the value has been read by the SPU, it "
"is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode "
"1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required "
"length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:538
#, no-wrap
msgid "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to "
"these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat>, and I<wbox_stat> files contain the available "
"message count."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which "
"have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead.  "
"The file is in the following format:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:643
msgid "Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in "
"size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of "
"the SPU."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:706 build/C/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications "
"can use this area to interface to the SPU, rather than writing to individual "
"register files in B<spufs>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state "
"area.  Only B<MAP_SHARED> mappings are supported."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr ""

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: build/C/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:773
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr ""

#. type: TH
#: build/C/man2/stat.2:39
#, no-wrap
msgid "STAT"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:42
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:51
#, no-wrap
msgid ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:54
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:58
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat "
"*>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:67
msgid "B<lstat>():"
msgstr ""

#.    _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/stat.2:73
#, no-wrap
msgid ""
"/* glibc 2.19 and earlier */ _BSD_SOURCE\n"
"    || /* Since glibc 2.20 */ _DEFAULT_SOURCE\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:76
msgid "B<fstatat>():"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:79
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:82
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:82
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:85
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:99
msgid ""
"These functions return information about a file, in the buffer pointed to by "
"I<statbuf>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to "
"the file."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:108
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:116
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that the link refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:124
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:124
#, no-wrap
msgid "The stat structure"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:128
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:142
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* Inode number */\n"
"    mode_t    st_mode;        /* File type and mode */\n"
"    nlink_t   st_nlink;       /* Number of hard links */\n"
"    uid_t     st_uid;         /* User ID of owner */\n"
"    gid_t     st_gid;         /* Group ID of owner */\n"
"    dev_t     st_rdev;        /* Device ID (if special file) */\n"
"    off_t     st_size;        /* Total size, in bytes */\n"
"    blksize_t st_blksize;     /* Block size for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:146
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:150
#, no-wrap
msgid ""
"    struct timespec st_atim;  /* Time of last access */\n"
"    struct timespec st_mtim;  /* Time of last modification */\n"
"    struct timespec st_ctim;  /* Time of last status change */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:155
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:168
msgid ""
"I<Note>: the order of fields in the I<stat> structure varies somewhat across "
"architectures.  In addition, the definition above does not show the padding "
"bytes that may be present between some fields on various architectures.  "
"Consult the glibc and kernel source code if you need to know the details."
msgstr ""

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: build/C/man2/stat.2:193
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<stat> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<st_mode> or "
"I<st_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<st_mode> together with the "
"new I<st_uid>, or the old I<st_uid> together with the new I<st_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:197
msgid "The fields in the I<stat> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:197
#, no-wrap
msgid "I<st_dev>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:205
msgid ""
"This field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:205
#, no-wrap
msgid "I<st_ino>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:208
msgid "This field contains the file's inode number."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:208
#, no-wrap
msgid "I<st_mode>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:214
msgid ""
"This field contains the file type and mode.  See B<inode>(7)  for further "
"information."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:214
#, no-wrap
msgid "I<st_nlink>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:217
msgid "This field contains the number of hard links to the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:217
#, no-wrap
msgid "I<st_uid>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:220 build/C/man2/statx.2:366
msgid "This field contains the user ID of the owner of the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:220
#, no-wrap
msgid "I<st_gid>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:223 build/C/man2/statx.2:369
msgid "This field contains the ID of the group owner of the file."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:223
#, no-wrap
msgid "I<st_rdev>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:226
msgid "This field describes the device that this file (inode) represents."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:226
#, no-wrap
msgid "I<st_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:232 build/C/man7/inode.7:112
msgid ""
"This field gives the size of the file (if it is a regular file or a symbolic "
"link) in bytes.  The size of a symbolic link is the length of the pathname "
"it contains, without a terminating null byte."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:232
#, no-wrap
msgid "I<st_blksize>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:235
msgid "This field gives the \"preferred\" block size for efficient filesystem I/O."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:235
#, no-wrap
msgid "I<st_blocks>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:242
msgid ""
"This field indicates the number of blocks allocated to the file, in 512-byte "
"units.  (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:242
#, no-wrap
msgid "I<st_atime>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:245
msgid "This is the time of the last access of file data."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:245
#, no-wrap
msgid "I<st_mtime>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:248
msgid "This is the time of last modification of file data."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:248
#, no-wrap
msgid "I<st_ctime>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:252
msgid ""
"This is the file's last status change timestamp (time of last change to the "
"inode)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:256 build/C/man2/statx.2:417
msgid "For further information on the above fields, see B<inode>(7)."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:256
#, no-wrap
msgid "fstatat()"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:265
msgid ""
"The B<fstatat>()  system call is a more general interface for accessing file "
"information which can still provide exactly the behavior of each of "
"B<stat>(), B<lstat>(), and B<fstat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:277
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  and B<lstat>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:291
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<stat>()  and B<lstat>())."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:297
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:300
msgid ""
"I<flags> can either be 0, or include one or more of the following flags "
"ORed:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:300
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:327
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory, and the behavior of B<fstatat>()  is similar to that of "
"B<fstat>().  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:327
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr ""

#.  commit 42f46148217865a545e129612075f3d828a2c4e4
#. type: Plain text
#: build/C/man2/stat.2:340
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand "
"directory such as used for automounter indirect maps.  This flag has no "
"effect if the mount point has already been mounted over."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:348
msgid "Both B<stat>()  and B<lstat>()  act as though B<AT_NO_AUTOMOUNT> was set."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:353
msgid ""
"The B<AT_NO_AUTOMOUNT> can be used in tools that scan directories to prevent "
"mass-automounting of a directory of automount points."
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:358 build/C/man2/statx.2:189
msgid "This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:358 build/C/man2/statx.2:205
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:369
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:374
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:387 build/C/man2/statx.2:508
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<pathname>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:391
msgid "I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:394
msgid "Bad address."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:397
msgid "Too many symbolic links encountered while traversing the path."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:406
msgid "A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:413
msgid ""
"I<pathname> is an empty string and B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:416 build/C/man2/statx.2:550
msgid "Out of memory (i.e., kernel memory)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:421
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:421 build/C/man2/statfs.2:283 build/C/man3/statvfs.3:187
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:440
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls "
"B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:443
msgid "The following additional errors can occur for B<fstatat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:447
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:451 build/C/man2/statx.2:523
msgid "Invalid flag specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:457
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:461
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: build/C/man2/stat.2:474
msgid "B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:477
msgid "B<fstatat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:491
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file type of the I<st_mode> "
"field of the I<stat> structure.  POSIX.1-2008 tightens the specification, "
"requiring B<lstat>()  to return valid information in all fields except the "
"mode bits in I<st_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:500
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)"
msgstr ""

#. type: SS
#: build/C/man2/stat.2:501
#, no-wrap
msgid "Timestamp fields"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:512
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps "
"with one-second precision."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:537
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec>, if "
"suitable feature test macros are defined.  Nanosecond timestamps were "
"standardized in POSIX.1-2008, and, starting with version 2.12, glibc exposes "
"the nanosecond component names if B<_POSIX_C_SOURCE> is defined with the "
"value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value 700 "
"or greater.  Up to and including glibc 2.19, the definitions of the "
"nanoseconds components are also defined if B<_BSD_SOURCE> or B<_SVID_SOURCE> "
"is defined.  If none of the aforementioned macros are defined, then the "
"nanosecond values are exposed with names of the form I<st_atimensec>."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:537
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  See include/asm-i386/stat.h in the Linux 2.4 source code for the
#.  various versions of the structure definitions
#. type: Plain text
#: build/C/man2/stat.2:562
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (slot "
"I<__NR_stat64>)  on 32-bit platforms such as i386.  The first two versions "
"were already present in Linux 1.0 (albeit with different names); the last "
"was added in Linux 2.4.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:566
msgid ""
"The kernel-internal versions of the I<stat> structure dealt with by the "
"different versions are, respectively:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:566
#, no-wrap
msgid "I<__old_kernel_stat>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:569
msgid "The original structure, with rather narrow fields, and no padding."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:569
#, no-wrap
msgid "I<stat>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:575
msgid ""
"Larger I<st_ino> field and padding added to various parts of the structure "
"to allow for future expansion."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:575
#, no-wrap
msgid "I<stat64>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:589
msgid ""
"Even larger I<st_ino> field, larger I<st_uid> and I<st_gid> fields to "
"accommodate the Linux-2.4 expansion of UIDs and GIDs to 32 bits, and various "
"other enlarged fields and further padding in the structure.  (Various "
"padding bytes were eventually consumed in Linux 2.6, with the advent of "
"32-bit device IDs and nanosecond components for the timestamp fields.)"
msgstr ""

#
#.  A note from Andries Brouwer, July 2007
#
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: build/C/man2/stat.2:623
msgid ""
"The glibc B<stat>()  wrapper function hides these details from applications, "
"invoking the most recent version of the system call provided by the kernel, "
"and repacking the returned information if required for old binaries."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:629
msgid ""
"On modern 64-bit systems, life is simpler: there is a single B<stat>()  "
"system call and the kernel deals with a I<stat> structure that contains "
"fields of a sufficient size."
msgstr ""

#.  strace(1) shows the name "newfstatat" on x86-64
#. type: Plain text
#: build/C/man2/stat.2:637
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()  or, on some architectures, "
"B<newfstatat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:643
msgid ""
"The following program calls B<lstat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:652
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:657
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:662
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:667
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:671
#, no-wrap
msgid ""
"    printf(\"ID of containing device:  [%jx,%jx]\\en\",\n"
"            (uintmax_t) major(sb.st_dev),\n"
"            (uintmax_t) minor(sb.st_dev));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:673
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:684
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:686
#, no-wrap
msgid "    printf(\"I-node number:            %ju\\en\", (uintmax_t) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:689
#, no-wrap
msgid ""
"    printf(\"Mode:                     %jo (octal)\\en\",\n"
"            (uintmax_t) sb.st_mode);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:693
#, no-wrap
msgid ""
"    printf(\"Link count:               %ju\\en\", (uintmax_t) "
"sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ju   GID=%ju\\en\",\n"
"            (uintmax_t) sb.st_uid, (uintmax_t) sb.st_gid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:700
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %jd bytes\\en\",\n"
"            (intmax_t) sb.st_blksize);\n"
"    printf(\"File size:                %jd bytes\\en\",\n"
"            (intmax_t) sb.st_size);\n"
"    printf(\"Blocks allocated:         %jd\\en\",\n"
"            (intmax_t) sb.st_blocks);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:704
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:720
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<statx>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:47
msgid ""
"The B<statfs>()  system call returns information about a mounted "
"filesystem.  I<path> is the pathname of any file within the mounted "
"filesystem.  I<buf> is a pointer to a I<statfs> structure defined "
"approximately as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:67
#, no-wrap
msgid ""
"struct statfs {\n"
"    __fsword_t f_type;    /* Type of filesystem (see below) */\n"
"    __fsword_t f_bsize;   /* Optimal transfer block size */\n"
"    fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */\n"
"    fsblkcnt_t f_bfree;   /* Free blocks in filesystem */\n"
"    fsblkcnt_t f_bavail;  /* Free blocks available to\n"
"                             unprivileged user */\n"
"    fsfilcnt_t f_files;   /* Total inodes in filesystem */\n"
"    fsfilcnt_t f_ffree;   /* Free inodes in filesystem */\n"
"    fsid_t     f_fsid;    /* Filesystem ID */\n"
"    __fsword_t f_namelen; /* Maximum length of filenames */\n"
"    __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */\n"
"    __fsword_t f_flags;   /* Mount flags of filesystem\n"
"                             (since Linux 2.6.36) */\n"
"    __fsword_t f_spare[xxx];\n"
"                    /* Padding bytes reserved for future use */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:72
msgid "The following filesystem types may appear in I<f_type>:"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:161
#, no-wrap
msgid ""
"ADFS_SUPER_MAGIC      0xadf5\n"
"AFFS_SUPER_MAGIC      0xadff\n"
"AFS_SUPER_MAGIC       0x5346414f\n"
"ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for\n"
"                                    pseudofiles that have no name;\n"
"                                    e.g., epoll, signalfd, bpf) */\n"
"AUTOFS_SUPER_MAGIC    0x0187\n"
"BDEVFS_MAGIC          0x62646576\n"
"BEFS_SUPER_MAGIC      0x42465331\n"
"BFS_MAGIC             0x1badface\n"
"BINFMTFS_MAGIC        0x42494e4d\n"
"BPF_FS_MAGIC          0xcafe4a11\n"
"BTRFS_SUPER_MAGIC     0x9123683e\n"
"BTRFS_TEST_MAGIC      0x73727279\n"
"CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */\n"
"CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */\n"
"CIFS_MAGIC_NUMBER     0xff534d42\n"
"CODA_SUPER_MAGIC      0x73757245\n"
"COH_SUPER_MAGIC       0x012ff7b7\n"
"CRAMFS_MAGIC          0x28cd3d45\n"
"DEBUGFS_MAGIC         0x64626720\n"
"DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */\n"
"DEVPTS_SUPER_MAGIC    0x1cd1\n"
"ECRYPTFS_SUPER_MAGIC  0xf15f\n"
"EFIVARFS_MAGIC        0xde5e81e4\n"
"EFS_SUPER_MAGIC       0x00414a53\n"
"EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */\n"
"EXT2_OLD_SUPER_MAGIC  0xef51\n"
"EXT2_SUPER_MAGIC      0xef53\n"
"EXT3_SUPER_MAGIC      0xef53\n"
"EXT4_SUPER_MAGIC      0xef53\n"
"F2FS_SUPER_MAGIC      0xf2f52010\n"
"FUSE_SUPER_MAGIC      0x65735546\n"
"FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */\n"
"HFS_SUPER_MAGIC       0x4244\n"
"HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"HPFS_SUPER_MAGIC      0xf995e849\n"
"HUGETLBFS_MAGIC       0x958458f6\n"
"ISOFS_SUPER_MAGIC     0x9660\n"
"JFFS2_SUPER_MAGIC     0x72b6\n"
"JFS_SUPER_MAGIC       0x3153464a\n"
"MINIX_SUPER_MAGIC     0x137f     /* original minix FS */\n"
"MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */\n"
"MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */\n"
"MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */\n"
"MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */\n"
"MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */\n"
"MSDOS_SUPER_MAGIC     0x4d44\n"
"MTD_INODE_FS_MAGIC    0x11307854\n"
"NCP_SUPER_MAGIC       0x564c\n"
"NFS_SUPER_MAGIC       0x6969\n"
"NILFS_SUPER_MAGIC     0x3434\n"
"NSFS_MAGIC            0x6e736673\n"
"NTFS_SB_MAGIC         0x5346544e\n"
"OCFS2_SUPER_MAGIC     0x7461636f\n"
"OPENPROM_SUPER_MAGIC  0x9fa1\n"
"OVERLAYFS_SUPER_MAGIC 0x794c7630\n"
"PIPEFS_MAGIC          0x50495045\n"
"PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */\n"
"PSTOREFS_MAGIC        0x6165676c\n"
"QNX4_SUPER_MAGIC      0x002f\n"
"QNX6_SUPER_MAGIC      0x68191122\n"
"RAMFS_MAGIC           0x858458f6\n"
"REISERFS_SUPER_MAGIC  0x52654973\n"
"ROMFS_MAGIC           0x7275\n"
"SECURITYFS_MAGIC      0x73636673\n"
"SELINUX_MAGIC         0xf97cff8c\n"
"SMACK_MAGIC           0x43415d53\n"
"SMB_SUPER_MAGIC       0x517b\n"
"SMB2_MAGIC_NUMBER     0xfe534d42\n"
"SOCKFS_MAGIC          0x534f434b\n"
"SQUASHFS_MAGIC        0x73717368\n"
"SYSFS_MAGIC           0x62656572\n"
"SYSV2_SUPER_MAGIC     0x012ff7b6\n"
"SYSV4_SUPER_MAGIC     0x012ff7b5\n"
"TMPFS_MAGIC           0x01021994\n"
"TRACEFS_MAGIC         0x74726163\n"
"UDF_SUPER_MAGIC       0x15013346\n"
"UFS_MAGIC             0x00011954\n"
"USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"V9FS_MAGIC            0x01021997\n"
"VXFS_SUPER_MAGIC      0xa501fcf5\n"
"XENFS_SUPER_MAGIC     0xabba1974\n"
"XENIX_SUPER_MAGIC     0x012ff7b4\n"
"XFS_SUPER_MAGIC       0x58465342\n"
"_XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:167
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h>, "
"and some are hardcoded in kernel sources."
msgstr ""

#.  XXX Keep this list in sync with statvfs(3)
#. type: Plain text
#: build/C/man2/statfs.2:173
msgid ""
"The I<f_flags> field is a bit mask indicating mount options for the "
"filesystem.  It contains zero or more of the following bits:"
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:173 build/C/man3/statvfs.3:85
#, no-wrap
msgid "B<ST_MANDLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:177 build/C/man3/statvfs.3:89
msgid "Mandatory locking is permitted on the filesystem (see B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:177 build/C/man3/statvfs.3:89
#, no-wrap
msgid "B<ST_NOATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:181 build/C/man3/statvfs.3:93
msgid "Do not update access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:181 build/C/man3/statvfs.3:93
#, no-wrap
msgid "B<ST_NODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:96
msgid "Disallow access to device special files on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:96
#, no-wrap
msgid "B<ST_NODIRATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:188 build/C/man3/statvfs.3:100
msgid "Do not update directory access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:188 build/C/man3/statvfs.3:100
#, no-wrap
msgid "B<ST_NOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:191 build/C/man3/statvfs.3:103
msgid "Execution of programs is disallowed on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:191 build/C/man3/statvfs.3:103
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:196 build/C/man3/statvfs.3:108
msgid ""
"The set-user-ID and set-group-ID bits are ignored by B<exec>(3)  for "
"executable files on this filesystem"
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:196 build/C/man3/statvfs.3:108
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:199 build/C/man3/statvfs.3:111
msgid "This filesystem is mounted read-only."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:199 build/C/man3/statvfs.3:111
#, no-wrap
msgid "B<ST_RELATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:203 build/C/man3/statvfs.3:115
msgid "Update atime relative to mtime/ctime; see B<mount>(2)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:203 build/C/man3/statvfs.3:115
#, no-wrap
msgid "B<ST_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:209 build/C/man3/statvfs.3:121
msgid ""
"Writes are synched to the filesystem immediately (see the description of "
"B<O_SYNC> in B<open>(2))."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:209
#, no-wrap
msgid "B<ST_NOSYMFOLLOW> (since Linux 5.10)"
msgstr ""

#.  dab741e0e02bd3c4f5e2e97be74b39df2523fc6e
#. type: Plain text
#: build/C/man2/statfs.2:214
msgid "Symbolic links are not followed when resolving paths; see B<mount>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:218
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:220
msgid "Fields that are undefined for a particular filesystem are set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:224
msgid ""
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:237
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:242
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:248
msgid "I<buf> or I<path> points to an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:252
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:252 build/C/man3/statvfs.3:156 build/C/man4/fuse.4:482
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:255 build/C/man3/statvfs.3:159
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:260
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:265
msgid "(B<statfs>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:271
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:274 build/C/man3/statvfs.3:178
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:277 build/C/man3/statvfs.3:181
msgid "The filesystem does not support this call."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:283
msgid "(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:286 build/C/man3/statvfs.3:190
msgid "Some values were too large to be represented in the returned struct."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:292
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:304
msgid ""
"The I<__fsword_t> type used for various fields in the I<statfs> structure "
"definition is a glibc internal type, not intended for public use.  This "
"leaves the programmer in a bit of a conundrum when trying to copy or compare "
"these fields to local variables in a program.  Using I<unsigned\\ int> for "
"such variables suffices on most systems."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:326
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:331
msgid ""
"Some systems have only I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:341
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""

#. type: SS
#: build/C/man2/statfs.2:341
#, no-wrap
msgid "The f_fsid field"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:366
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in "
"I<E<lt>sys/vfs.hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> "
"is defined as I<struct { int val[2]; }>.  The same holds for FreeBSD, except "
"that it uses the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:379
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when "
"NFS-exported, and giving it out is a security concern."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:385
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument "
"to the B<sysfs>(2)  system call."
msgstr ""

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: build/C/man2/statfs.2:394
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:398
msgid "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man2/statx.2:30
#, no-wrap
msgid "STATX"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:33
msgid "statx - get file status (extended)"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:39
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:42
#, no-wrap
msgid ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:48
msgid ""
"This function returns information about a file, storing it in the buffer "
"pointed to by I<statxbuf>.  The returned buffer is a structure of the "
"following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:66
#, no-wrap
msgid ""
"struct statx {\n"
"    __u32 stx_mask;        /* Mask of bits indicating\n"
"                              filled fields */\n"
"    __u32 stx_blksize;     /* Block size for filesystem I/O */\n"
"    __u64 stx_attributes;  /* Extra file attribute indicators */\n"
"    __u32 stx_nlink;       /* Number of hard links */\n"
"    __u32 stx_uid;         /* User ID of owner */\n"
"    __u32 stx_gid;         /* Group ID of owner */\n"
"    __u16 stx_mode;        /* File type and mode */\n"
"    __u64 stx_ino;         /* Inode number */\n"
"    __u64 stx_size;        /* Total size in bytes */\n"
"    __u64 stx_blocks;      /* Number of 512B blocks allocated */\n"
"    __u64 stx_attributes_mask;\n"
"                           /* Mask to show what\\(aqs supported\n"
"                              in stx_attributes */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:72
#, no-wrap
msgid ""
"    /* The following fields are file timestamps */\n"
"    struct statx_timestamp stx_atime;  /* Last access */\n"
"    struct statx_timestamp stx_btime;  /* Creation */\n"
"    struct statx_timestamp stx_ctime;  /* Last status change */\n"
"    struct statx_timestamp stx_mtime;  /* Last modification */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:77
#, no-wrap
msgid ""
"    /* If this file represents a device, then the next two\n"
"       fields contain the ID of the device */\n"
"    __u32 stx_rdev_major;  /* Major ID */\n"
"    __u32 stx_rdev_minor;  /* Minor ID */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:83
#, no-wrap
msgid ""
"    /* The next two fields contain the ID of the device\n"
"       containing the filesystem where the file resides */\n"
"    __u32 stx_dev_major;   /* Major ID */\n"
"    __u32 stx_dev_minor;   /* Minor ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:87
msgid "The file timestamps are structures of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:94
#, no-wrap
msgid ""
"struct statx_timestamp {\n"
"    __s64 tv_sec;    /* Seconds since the Epoch (UNIX time) */\n"
"    __u32 tv_nsec;   /* Nanoseconds since tv_sec */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:98
msgid "(Note that reserved space and padding is omitted.)"
msgstr ""

#. type: SS
#: build/C/man2/statx.2:98
#, no-wrap
msgid "Invoking statxR<():>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:107
msgid ""
"To access a file's status, no permissions are required on the file itself, "
"but in the case of B<statx>()  with a pathname, execute (search) permission "
"is required on all of the directories in I<pathname> that lead to the file."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:115
msgid ""
"B<statx>()  uses I<pathname>, I<dirfd>, and I<flags> to identify the target "
"file in one of the following ways:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:115
#, no-wrap
msgid "An absolute pathname"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:124
msgid ""
"If I<pathname> begins with a slash, then it is an absolute pathname that "
"identifies the target file.  In this case, I<dirfd> is ignored."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:124
#, no-wrap
msgid "A relative pathname"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:136
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is B<AT_FDCWD>, then I<pathname> is a relative pathname that is "
"interpreted relative to the process's current working directory."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:136
#, no-wrap
msgid "A directory-relative pathname"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:147
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is a file descriptor that refers to a directory, then "
"I<pathname> is a relative pathname that is interpreted relative to the "
"directory referred to by I<dirfd>."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:147
#, no-wrap
msgid "By file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:158
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is specified "
"in I<flags> (see below), then the target file is the one referred to by the "
"file descriptor I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:164
msgid ""
"I<flags> can be used to influence a pathname-based lookup.  A value for "
"I<flags> is constructed by ORing together zero or more of the following "
"constants:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:164
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: build/C/man2/statx.2:178
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:184
msgid ""
"If I<dirfd> is B<AT_FDCWD>, the call operates on the current working "
"directory."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:189
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT>"
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/statx.2:205
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"This flag can be used in tools that scan directories to prevent "
"mass-automounting of a directory of automount points.  The "
"B<AT_NO_AUTOMOUNT> flag has no effect if the mount point has already been "
"mounted over.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain "
"its definition."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:212
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:217
msgid ""
"I<flags> can also be used to control what sort of synchronization the kernel "
"will do when querying a file on a remote filesystem.  This is done by ORing "
"in one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:217
#, no-wrap
msgid "B<AT_STATX_SYNC_AS_STAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:223
msgid ""
"Do whatever B<stat>(2)  does.  This is the default and is very much "
"filesystem-specific."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:223
#, no-wrap
msgid "B<AT_STATX_FORCE_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:228
msgid ""
"Force the attributes to be synchronized with the server.  This may require "
"that a network filesystem perform a data writeback to get the timestamps "
"correct."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:228
#, no-wrap
msgid "B<AT_STATX_DONT_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:235
msgid ""
"Don't synchronize anything, but rather just take whatever the system has "
"cached if possible.  This may mean that the information returned is "
"approximate, but, on a network filesystem, it may not involve a round trip "
"to the server - even if no lease is held."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:243
msgid ""
"The I<mask> argument to B<statx>()  is used to tell the kernel which fields "
"the caller is interested in.  I<mask> is an ORed combination of the "
"following constants:"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:247
#, no-wrap
msgid "STATX_TYPE"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:247
#, no-wrap
msgid "Want stx_mode & S_IFMT"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:248
#, no-wrap
msgid "STATX_MODE"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:248
#, no-wrap
msgid "Want stx_mode & \\(tiS_IFMT"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:249
#, no-wrap
msgid "STATX_NLINK"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:249
#, no-wrap
msgid "Want stx_nlink"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:250
#, no-wrap
msgid "STATX_UID"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:250
#, no-wrap
msgid "Want stx_uid"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:251
#, no-wrap
msgid "STATX_GID"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:251
#, no-wrap
msgid "Want stx_gid"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:252
#, no-wrap
msgid "STATX_ATIME"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:252
#, no-wrap
msgid "Want stx_atime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:253
#, no-wrap
msgid "STATX_MTIME"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:253
#, no-wrap
msgid "Want stx_mtime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:254
#, no-wrap
msgid "STATX_CTIME"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:254
#, no-wrap
msgid "Want stx_ctime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:255
#, no-wrap
msgid "STATX_INO"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:255
#, no-wrap
msgid "Want stx_ino"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:256
#, no-wrap
msgid "STATX_SIZE"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:256
#, no-wrap
msgid "Want stx_size"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:257
#, no-wrap
msgid "STATX_BLOCKS"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:257
#, no-wrap
msgid "Want stx_blocks"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:258
#, no-wrap
msgid "STATX_BASIC_STATS"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:258
#, no-wrap
msgid "[All of the above]"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:259
#, no-wrap
msgid "STATX_BTIME"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:259
#, no-wrap
msgid "Want stx_btime"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:260
#, no-wrap
msgid "STATX_ALL"
msgstr ""

#. type: tbl table
#: build/C/man2/statx.2:260
#, no-wrap
msgid "[All currently available fields]"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:285
msgid ""
"Note that, in general, the kernel does I<not> reject values in I<mask> other "
"than the above.  (For an exception, see B<EINVAL> in errors.)  Instead, it "
"simply informs the caller which values are supported by this kernel and "
"filesystem via the I<statx.stx_mask> field.  Therefore, I<do not> simply set "
"I<mask> to B<UINT_MAX> (all bits set), as one or more bits may, in the "
"future, be used to specify an extension to the buffer."
msgstr ""

#. type: SS
#: build/C/man2/statx.2:285
#, no-wrap
msgid "The returned information"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:299
msgid ""
"The status information for the target file is returned in the I<statx> "
"structure pointed to by I<statxbuf>.  Included in this is I<stx_mask> which "
"indicates what other information has been returned.  I<stx_mask> has the "
"same format as the I<mask> argument and bits are set in it to indicate which "
"fields have been filled in."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:308
msgid ""
"It should be noted that the kernel may return fields that weren't requested "
"and may fail to return fields that were requested, depending on what the "
"backing filesystem supports.  (Fields that are given values despite being "
"unrequested can just be ignored.)  In either case, I<stx_mask> will not be "
"equal I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:316
msgid ""
"If a filesystem does not support a field or if it has an unrepresentable "
"value (for instance, a file with an exotic type), then the mask bit "
"corresponding to that field will be cleared in I<stx_mask> even if the user "
"asked for it and a dummy value will be filled in for compatibility purposes "
"if one is available (e.g., a dummy UID and GID may be specified to mount "
"under some circumstances)."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:321
msgid ""
"A filesystem may also fill in fields that the caller didn't ask for if it "
"has values for them available and the information is available at no extra "
"cost.  If this happens, the corresponding bits will be set in I<stx_mask>."
msgstr ""

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: build/C/man2/statx.2:346
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<statx> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<stx_mode> or "
"I<stx_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<stx_mode> together with the "
"new I<stx_uid>, or the old I<stx_uid> together with the new I<stx_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:352
msgid ""
"Apart from I<stx_mask> (which is described above), the fields in the "
"I<statx> structure are:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:352
#, no-wrap
msgid "I<stx_blksize>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:357
msgid ""
"The \"preferred\" block size for efficient filesystem I/O.  (Writing to a "
"file in smaller chunks may cause an inefficient read-modify-rewrite.)"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:357
#, no-wrap
msgid "I<stx_attributes>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:360
msgid "Further status information about the file (see below for more information)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:360
#, no-wrap
msgid "I<stx_nlink>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:363
msgid "The number of hard links on a file."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:363
#, no-wrap
msgid "I<stx_uid>"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:366
#, no-wrap
msgid "I<stx_gid>"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:369
#, no-wrap
msgid "I<stx_mode>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:375
msgid "The file type and mode.  See B<inode>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:375
#, no-wrap
msgid "I<stx_ino>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:378
msgid "The inode number of the file."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:378
#, no-wrap
msgid "I<stx_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:383
msgid ""
"The size of the file (if it is a regular file or a symbolic link) in bytes.  "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:383
#, no-wrap
msgid "I<stx_blocks>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:389
msgid ""
"The number of blocks allocated to the file on the medium, in 512-byte "
"units.  (This may be smaller than I<stx_size>/512 when the file has holes.)"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:389
#, no-wrap
msgid "I<stx_attributes_mask>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:394
msgid ""
"A mask indicating which bits in I<stx_attributes> are supported by the VFS "
"and the filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:394
#, no-wrap
msgid "I<stx_atime>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:397
msgid "The file's last access timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:397
#, no-wrap
msgid "I<stx_btime>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:400
msgid "The file's creation timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:400
#, no-wrap
msgid "I<stx_ctime>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:403
msgid "The file's last status change timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:403
#, no-wrap
msgid "I<stx_mtime>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:406
msgid "The file's last modification timestamp."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:406
#, no-wrap
msgid "I<stx_dev_major> and I<stx_dev_minor>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:409
msgid "The device on which this file (inode) resides."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:409
#, no-wrap
msgid "I<stx_rdev_major> and I<stx_rdev_minor>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:413
msgid ""
"The device that this file (inode) represents if the file is of block or "
"character device type."
msgstr ""

#. type: SS
#: build/C/man2/statx.2:417
#, no-wrap
msgid "File attributes"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:429
msgid ""
"The I<stx_attributes> field contains a set of ORed flags that indicate "
"additional attributes of the file.  Note that any attribute that is not "
"indicated as supported by I<stx_attributes_mask> has no usable value here.  "
"The bits in I<stx_attributes_mask> correspond bit-by-bit to "
"I<stx_attributes>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:431
msgid "The flags are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/statx.2:431
#, no-wrap
msgid "B<STATX_ATTR_COMPRESSED>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:435
msgid ""
"The file is compressed by the filesystem and may take extra resources to "
"access."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:435
#, no-wrap
msgid "B<STATX_ATTR_IMMUTABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:441
msgid ""
"The file cannot be modified: it cannot be deleted or renamed, no hard links "
"can be created to this file and no data can be written to it.  See "
"B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:441
#, no-wrap
msgid "B<STATX_ATTR_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:448
msgid ""
"The file can only be opened in append mode for writing.  Random access "
"writing is not permitted.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:448
#, no-wrap
msgid "B<STATX_ATTR_NODUMP>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:455
msgid ""
"File is not a candidate for backup when a backup program such as B<dump>(8)  "
"is run.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:455
#, no-wrap
msgid "B<STATX_ATTR_ENCRYPTED>"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:458
msgid "A key is required for the file to be encrypted by the filesystem."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:458
#, no-wrap
msgid "B<STATX_ATTR_VERITY> (since Linux 5.5)"
msgstr ""

#.  commit 3ad2522c64cff1f5aebb987b00683268f0cc7c29
#. type: Plain text
#: build/C/man2/statx.2:465
msgid ""
"The file has fs-verity enabled.  It cannot be written to, and all reads from "
"it will be verified against a cryptographic hash that covers the entire file "
"(e.g., via a Merkle tree)."
msgstr ""

#. type: TP
#: build/C/man2/statx.2:465
#, no-wrap
msgid "B<STATX_ATTR_DAX> (since Linux 5.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:471
msgid ""
"The file is in the DAX (cpu direct access) state.  DAX state attempts to "
"minimize software cache effects for both I/O and memory mappings of this "
"file.  It requires a file system which has been configured to support DAX."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:475
msgid ""
"DAX generally assumes all accesses are via CPU load / store instructions "
"which can minimize overhead for small accesses, but may adversely affect CPU "
"utilization for large transfers."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:478
msgid ""
"File I/O is done directly to/from user-space buffers and memory mapped I/O "
"may be performed with direct memory mappings that bypass the kernel page "
"cache."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:485
msgid ""
"While the DAX property tends to result in data being transferred "
"synchronously, it does not give the same guarantees as the B<O_SYNC> flag "
"(see B<open>(2)), where data and the necessary metadata are transferred "
"together."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:495
msgid ""
"A DAX file may support being mapped with the B<MAP_SYNC> flag, which enables "
"a program to use CPU cache flush instructions to persist CPU store "
"operations without an explicit B<fsync>(2).  See B<mmap>(2)  for more "
"information."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:512
msgid "I<dirfd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:519
msgid ""
"I<pathname> or I<statxbuf> is NULL or points to a location outside the "
"process's accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:530
msgid ""
"Reserved flag specified in I<mask>.  (Currently, there is one such flag, "
"designated by the constant B<STATX__RESERVED>, with the value 0x80000000U.)"
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:533
msgid "Too many symbolic links encountered while traversing the pathname."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:547
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty string "
"and B<AT_EMPTY_PATH> was not specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:559
msgid ""
"A component of the path prefix of I<pathname> is not a directory or "
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:562
msgid ""
"B<statx>()  was added to Linux in kernel 4.11; library support was added in "
"glibc 2.28."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:565
msgid "B<statx>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/statx.2:577
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:67
#, no-wrap
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* Filesystem block size */\n"
"    unsigned long  f_frsize;   /* Fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* Size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* Number of free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* Number of free blocks for\n"
"                                  unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* Number of inodes */\n"
"    fsfilcnt_t     f_ffree;    /* Number of free inodes */\n"
"    fsfilcnt_t     f_favail;   /* Number of free inodes for\n"
"                                  unprivileged users */\n"
"    unsigned long  f_fsid;     /* Filesystem ID */\n"
"    unsigned long  f_flag;     /* Mount flags */\n"
"    unsigned long  f_namemax;  /* Maximum filename length */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:78
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in "
"I<E<lt>sys/types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr ""

#.  XXX Keep this list in sync with statfs(2)
#. type: Plain text
#: build/C/man3/statvfs.3:85
msgid ""
"The field I<f_flag> is a bit mask indicating various options that were "
"employed when mounting this filesystem.  It contains zero or more of the "
"following flags:"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:124
msgid ""
"It is unspecified whether all members of the returned struct have meaningful "
"values on all filesystems."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:128
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:141
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:146
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:152
msgid "I<Buf> or I<path> points to an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:156
msgid "This call was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:164
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:169
msgid "(B<statvfs>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:175
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:187
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a "
"directory."
msgstr ""

#. type: tbl table
#: build/C/man3/statvfs.3:201
#, no-wrap
msgid ""
"B<statvfs>(),\n"
"B<fstatvfs>()"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:205
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:215
msgid ""
"Only the B<ST_NOSUID> and B<ST_RDONLY> flags of the I<f_flag> field are "
"specified in POSIX.1.  To obtain definitions of the remaining flags, one "
"must define B<_GNU_SOURCE>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:221
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr ""

#.  glibc commit 3cdaa6adb113a088fdfb87aa6d7747557eccc58d
#. type: Plain text
#: build/C/man3/statvfs.3:237
msgid ""
"In glibc versions before 2.13, B<statvfs>()  populated the bits of the "
"I<f_flag> field by scanning the mount options shown in I</proc/mounts>.  "
"However, starting with Linux 2.6.36, the underlying B<statfs>(2)  system "
"call provides the necessary information via the I<f_flags> field, and since "
"glibc version 2.13, the B<statvfs>()  function will use information from "
"that field rather than scanning I</proc/mounts>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:239
msgid "The glibc implementations of"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:245
#, no-wrap
msgid ""
"pathconf(path, _PC_REC_XFER_ALIGN);\n"
"pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:257
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields "
"returned by a call to B<statvfs>()  with the argument I<path>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:259
msgid "B<statfs>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sysfs.2:27 build/C/man5/sysfs.5:25
#, no-wrap
msgid "SYSFS"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char "
"*>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:44
msgid ""
"B<Note>: if you are looking for information about the B<sysfs> filesystem "
"that is normally mounted at I</sys>, see B<sysfs>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:54
msgid ""
"The (obsolete)  B<sysfs>()  system call returns information about the "
"filesystem types currently present in the kernel.  The specific form of the "
"B<sysfs>()  call and the information returned depends on the I<option> in "
"effect:"
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:54
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:59
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:59
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:70
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:70
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:74
msgid "Return the total number of filesystem types currently present in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:76
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:88
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:93
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:101
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is "
"out-of-bounds; I<option> is invalid."
msgstr ""

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: build/C/man2/sysfs.2:103 build/C/man2/ustat.2:98
msgid "SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:110
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via I</proc>; use that "
"interface instead."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:113
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:116
msgid "B<proc>(5), B<sysfs>(5)"
msgstr ""

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr ""

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: build/C/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""

#. type: TP
#: build/C/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:80
msgid ""
"Ask the filesystem to abort pending requests before attempting the unmount.  "
"This may allow the unmount to complete without waiting for an inaccessible "
"server, but could cause data loss.  If, after aborting requests, some "
"processes still have active references to the filesystem, the unmount will "
"still fail.  As at Linux 4.12, B<MNT_FORCE> is supported only on the "
"following filesystems: 9p (since Linux 2.6.16), ceph (since Linux 2.6.34), "
"cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre (since Linux "
"3.11), and NFS (since Linux 2.1.116)."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:80
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:86
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"immediately disconnect the filesystem and all filesystems mounted below it "
"from each other and from the mount table, and actually perform the unmount "
"when the mount point ceases to be busy."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:86
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:105
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:105
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr ""

#.  Later added to 2.6.33-stable
#. type: Plain text
#: build/C/man2/umount.2:113
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:124
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:131
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:135
msgid "I<target> could not be unmounted because it is busy."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:139
msgid "I<target> points outside the user address space."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:143
msgid "I<target> is not a mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:152
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:152
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:157
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: build/C/man2/umount.2:176
msgid "B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:179
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: SS
#: build/C/man2/umount.2:180
#, no-wrap
msgid "umount() and shared mount points"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:189
msgid ""
"Shared mount points cause any mount activity on a mount point, including "
"B<umount>()  operations, to be forwarded to every shared mount point in the "
"peer group and every slave mount of that peer group.  This means that "
"B<umount>()  of any peer in a set of shared mounts will cause all of its "
"peers to be unmounted and all of their slaves to be unmounted as well."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:197
msgid ""
"This propagation of unmount activity can be particularly surprising on "
"systems where every mount point is shared by default.  On such systems, "
"recursively bind mounting the root directory of the filesystem onto a "
"subdirectory and then later unmounting that subdirectory with B<MNT_DETACH> "
"will cause every mount in the mount namespace to be lazily unmounted."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:212
msgid ""
"To ensure B<umount>()  does not propagate in this fashion, the mount point "
"may be remounted using a B<mount>(2)  call with a I<mount_flags> argument "
"that includes both B<MS_REC> and B<MS_PRIVATE> prior to B<umount>()  being "
"called."
msgstr ""

#. type: SS
#: build/C/man2/umount.2:212
#, no-wrap
msgid "Historical details"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:223
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4, a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:229
msgid ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"
msgstr ""

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:40
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:52
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf> "
"is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:59
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:68
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:77
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:82
msgid "I<ubuf> points outside of your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:86
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:92
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation, "
"or any version of Linux before 1.3.16."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:94
msgid "Since version 2.28, glibc no longer provides a wrapper for this system call."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""

#. type: SS
#: build/C/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr ""

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: build/C/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems, "
"the number of free inodes does not change.  Such filesystems will return -1 "
"in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:121
msgid "B<stat>(2), B<statfs>(2)"
msgstr ""

#. type: TH
#: build/C/man5/sysfs.5:25
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:28
msgid "sysfs - a filesystem for exporting kernel objects"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:42
msgid ""
"The B<sysfs> filesystem is a pseudo-filesystem which provides an interface "
"to kernel data structures.  (More precisely, the files and directories in "
"B<sysfs> provide a view of the I<kobject> structures defined internally "
"within the kernel.)  The files under B<sysfs> provide information about "
"devices, kernel modules, filesystems, and other kernel components."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:49
msgid ""
"The B<sysfs> filesystem is commonly mounted at I</sys>.  Typically, it is "
"mounted automatically by the system, but it can also be mounted manually "
"using a command such as:"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:53
#, no-wrap
msgid "mount -t sysfs sysfs /sys\n"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:63
msgid ""
"Many of the files in the B<sysfs> filesystem are read-only, but some files "
"are writable, allowing kernel variables to be changed.  To avoid redundancy, "
"symbolic links are heavily used to connect entries across the filesystem "
"tree."
msgstr ""

#. type: SS
#: build/C/man5/sysfs.5:63
#, no-wrap
msgid "Files and directories"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:67
msgid ""
"The following list describes some of the files and directories under the "
"I</sys> hierarchy."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:67
#, no-wrap
msgid "I</sys/block>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:73
msgid ""
"This subdirectory contains one symbolic link for each block device that has "
"been discovered on the system.  The symbolic links point to corresponding "
"directories under I</sys/devices>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:73
#, no-wrap
msgid "I</sys/bus>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:78
msgid ""
"This directory contains one subdirectory for each of the bus types in the "
"kernel.  Inside each of these directories are two subdirectories:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:79
#, no-wrap
msgid "I<devices>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:84
msgid ""
"This subdirectory contains symbolic links to entries in I</sys/devices> that "
"correspond to the devices discovered on this bus."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:84 build/C/man5/sysfs.5:249
#, no-wrap
msgid "I<drivers>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:88
msgid ""
"This subdirectory contains one subdirectory for each device driver that is "
"loaded on this bus."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:89
#, no-wrap
msgid "I</sys/class>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:100
msgid ""
"This subdirectory contains a single layer of further subdirectories for each "
"of the device classes that have been registered on the system (e.g., "
"terminals, network devices, block devices, graphics devices, sound devices, "
"and so on).  Inside each of these subdirectories are symbolic links for each "
"of the devices in this class.  These symbolic links refer to entries in the "
"I</sys/devices> directory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:100
#, no-wrap
msgid "I</sys/class/net>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:109
msgid ""
"Each of the entries in this directory is a symbolic link representing one of "
"the real or virtual networking devices that are visible in the network "
"namespace of the process that is accessing the directory.  Each of these "
"symbolic links refers to entries in the I</sys/devices> directory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:109
#, no-wrap
msgid "I</sys/dev>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:130
msgid ""
"This directory contains two subdirectories I<block>/ and I<char/>, "
"corresponding, respectively, to the block and character devices on the "
"system.  Inside each of these subdirectories are symbolic links with names "
"of the form I<major-ID>:I<minor-ID>, where the ID values correspond to the "
"major and minor ID of a specific device.  Each symbolic link points to the "
"B<sysfs> directory for a device.  The symbolic links inside I</sys/dev> thus "
"provide an easy way to look up the B<sysfs> interface using the device IDs "
"returned by a call to B<stat>(2)  (or similar)."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:133
msgid "The following shell session shows an example from I</sys/dev>:"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:147
#, no-wrap
msgid ""
"$ B<stat -c \"%t %T\" /dev/null>\n"
"1 3\n"
"$ B<readlink /sys/dev/char/1\\e:3>\n"
"\\&../../devices/virtual/mem/null\n"
"$ B<ls -Fd /sys/devices/virtual/mem/null>\n"
"/sys/devices/virtual/mem/null/\n"
"$ B<ls -d1 /sys/devices/virtual/mem/null/*>\n"
"/sys/devices/virtual/mem/null/dev\n"
"/sys/devices/virtual/mem/null/power/\n"
"/sys/devices/virtual/mem/null/subsystem@\n"
"/sys/devices/virtual/mem/null/uevent\n"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:149
#, no-wrap
msgid "I</sys/devices>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:156
msgid ""
"This is a directory that contains a filesystem representation of the kernel "
"device tree, which is a hierarchy of I<device> structures within the kernel."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:156
#, no-wrap
msgid "I</sys/firmware>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:160
msgid ""
"This subdirectory contains interfaces for viewing and manipulating "
"firmware-specific objects and attributes."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:160
#, no-wrap
msgid "I</sys/fs>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:165
msgid ""
"This directory contains subdirectories for some filesystems.  A filesystem "
"will have a subdirectory here only if it chose to explicitly create the "
"subdirectory."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:165
#, no-wrap
msgid "I</sys/fs/cgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:172
msgid ""
"This directory conventionally is used as a mount point for a B<tmpfs>(5)  "
"filesystem containing mount points for B<cgroups>(7)  filesystems."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:172
#, no-wrap
msgid "I</sys/fs/smackfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:177
msgid ""
"The directory contains configuration files for the SMACK LSM.  See the "
"kernel source file I<Documentation/admin-guide/LSM/Smack.rst>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:177
#, no-wrap
msgid "I</sys/hypervisor>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:180 build/C/man5/sysfs.5:252 build/C/man5/sysfs.5:255 build/C/man5/sysfs.5:258 build/C/man5/sysfs.5:274
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:180
#, no-wrap
msgid "I</sys/kernel>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:184
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the running kernel."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:184
#, no-wrap
msgid "I</sys/kernel/cgroup/>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:188
msgid "For information about the files in this directory, see B<cgroups>(7)."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:188
#, no-wrap
msgid "I</sys/kernel/debug/tracing>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:199
msgid ""
"Mount point for the I<tracefs> filesystem used by the kernel's I<ftrace> "
"facility.  (For information on I<ftrace>, see the kernel source file "
"I<Documentation/trace/ftrace.txt>.)"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:199
#, no-wrap
msgid "I</sys/kernel/mm>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:203
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the kernel's memory management subsystem."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:203
#, no-wrap
msgid "I</sys/kernel/mm/hugepages>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:214
msgid ""
"This subdirectory contains one subdirectory for each of the huge page sizes "
"that the system supports.  The subdirectory name indicates the huge page "
"size (e.g., I<hugepages-2048kB>).  Within each of these subdirectories is a "
"set of files that can be used to view and (in some cases) change settings "
"associated with that huge page size.  For further information, see the "
"kernel source file I<Documentation/admin-guide/mm/hugetlbpage.rst>."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:214
#, no-wrap
msgid "I</sys/module>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:220
msgid ""
"This subdirectory contains one subdirectory for each module that is loaded "
"into the kernel.  The name of each directory is the name of the module.  In "
"each of the subdirectories, there may be following files:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:221
#, no-wrap
msgid "I<coresize>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:224 build/C/man5/sysfs.5:227 build/C/man5/sysfs.5:230 build/C/man5/sysfs.5:233 build/C/man5/sysfs.5:236 build/C/man5/sysfs.5:239 build/C/man5/sysfs.5:242 build/C/man5/sysfs.5:245
msgid "[to be documented]"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:224
#, no-wrap
msgid "I<initsize>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:227
#, no-wrap
msgid "I<initstate>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:230
#, no-wrap
msgid "I<refcnt>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:233
#, no-wrap
msgid "I<srcversion>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:236
#, no-wrap
msgid "I<taint>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:239
#, no-wrap
msgid "I<uevent>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:242
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:248
msgid "In each of the subdirectories, there may be following subdirectories:"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:252
#, no-wrap
msgid "I<holders>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:255
#, no-wrap
msgid "I<notes>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:258
#, no-wrap
msgid "I<parameters>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:263
msgid ""
"This directory contains one file for each module parameter, with each file "
"containing the value of the corresponding parameter.  Some of these files "
"are writable, allowing the"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:263
#, no-wrap
msgid "I<sections>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:267
msgid ""
"This subdirectories contains files with information about module sections.  "
"This information is mainly used for debugging."
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:267
#, no-wrap
msgid "I<[To be documented]>"
msgstr ""

#. type: TP
#: build/C/man5/sysfs.5:271
#, no-wrap
msgid "I</sys/power>"
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:278
msgid "The B<sysfs> filesystem first appeared in Linux 2.6.0."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:282
msgid "The B<sysfs> filesystem is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:285
msgid ""
"This manual page is incomplete, possibly inaccurate, and is the kind of "
"thing that needs to be updated very often."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:288
msgid "B<proc>(5), B<udev>(7)"
msgstr ""

#.  https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf
#. type: Plain text
#: build/C/man5/sysfs.5:293
msgid ""
"P.\\& Mochel. (2005).  I<The sysfs filesystem>.  Proceedings of the 2005 "
"Ottawa Linux Symposium."
msgstr ""

#. type: Plain text
#: build/C/man5/sysfs.5:300
msgid ""
"The kernel source file I<Documentation/filesystems/sysfs.txt> and various "
"other files in I<Documentation/ABI> and I<Documentation/*/sysfs.txt>"
msgstr ""

#. type: TH
#: build/C/man5/tmpfs.5:25
#, no-wrap
msgid "TMPFS"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:28
msgid "tmpfs - a virtual memory filesystem"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:35
msgid ""
"The B<tmpfs> facility allows the creation of filesystems whose contents "
"reside in virtual memory.  Since the files on such filesystems typically "
"reside in RAM, file access is extremely fast."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:40
msgid ""
"The filesystem is automatically created when mounting a filesystem with the "
"type B<tmpfs> via a command such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:44
#, no-wrap
msgid "$ sudo mount -t tmpfs -o size=10M tmpfs /mnt/mytmpfs\n"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:50
msgid "A B<tmpfs> filesystem has the following properties:"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:53
msgid ""
"The filesystem can employ swap space when physical memory pressure demands "
"it."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:56
msgid ""
"The filesystem consumes only as much physical memory and swap space as is "
"required to store the current contents of the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:61
msgid ""
"During a remount operation (I<mount\\ -o\\ remount>), the filesystem size "
"can be changed (without losing the existing contents of the filesystem)."
msgstr ""

#.  See mm/shmem.c:shmem_parse_options for options it supports.
#. type: Plain text
#: build/C/man5/tmpfs.5:66
msgid "If a B<tmpfs> filesystem is unmounted, its contents are discarded (lost)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:70
msgid "The B<tmpfs> filesystem supports the following mount options:"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:70
#, no-wrap
msgid "B<size>=I<bytes>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:74
msgid ""
"Specify an upper limit on the size of the filesystem.  The size is given in "
"bytes, and rounded up to entire pages."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:82
msgid ""
"The size may have a B<k>, B<m>, or B<g> suffix for Ki, Mi, Gi (binary kilo "
"(kibi), binary mega (mebi) and binary giga (gibi))."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:85
msgid ""
"The size may also have a % suffix to limit this instance to a percentage of "
"physical RAM."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:92
msgid ""
"The default, when neither B<size> nor B<nr_blocks> is specified, is "
"I<size=50%>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:92
#, no-wrap
msgid "B<nr_blocks>=I<blocks>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:98
msgid "The same as B<size>, but in blocks of B<PAGE_CACHE_SIZE>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:107
msgid ""
"Blocks may be specified with B<k>, B<m>, or B<g> suffixes like B<size>, but "
"not a % suffix."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:107
#, no-wrap
msgid "B<nr_inodes>=I<inodes>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:112
msgid ""
"The maximum number of inodes for this instance.  The default is half of the "
"number of your physical RAM pages, or (on a machine with highmem) the number "
"of lowmem RAM pages, whichever is smaller."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:121
msgid ""
"Inodes may be specified with B<k>, B<m>, or B<g> suffixes like B<size>, but "
"not a % suffix."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:121
#, no-wrap
msgid "B<mode>=I<mode>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:124
msgid "Set initial permissions of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:124
#, no-wrap
msgid "B<gid>=I<gid> (since Linux 2.5.7)"
msgstr ""

#.  Technically this is also in some version of Linux 2.4.
#.  commit 099445b489625b80b1d6687c9b6072dbeaca4096
#. type: Plain text
#: build/C/man5/tmpfs.5:129
msgid "Set the initial group ID of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:129
#, no-wrap
msgid "B<uid>=I<uid> (since Linux 2.5.7)"
msgstr ""

#.  Technically this is also in some version of Linux 2.4.
#.  commit 099445b489625b80b1d6687c9b6072dbeaca4096
#. type: Plain text
#: build/C/man5/tmpfs.5:134
msgid "Set the initial user ID of the root directory."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:134
#, no-wrap
msgid "B<huge>=I<huge_option> (since Linux 4.7.0)"
msgstr ""

#.  commit 5a6e75f8110c97e2a5488894d4e922187e6cb343
#. type: Plain text
#: build/C/man5/tmpfs.5:140
msgid ""
"Set the huge table memory allocation policy for all files in this instance "
"(if B<CONFIG_TRANSPARENT_HUGE_PAGECACHE> is enabled)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:144
msgid "The I<huge_option> value is one of the following:"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:145
#, no-wrap
msgid "B<never>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:149
msgid "Do not allocate huge pages.  This is the default."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:149
#, no-wrap
msgid "B<always>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:152
msgid "Attempt to allocate huge pages every time a new page is needed."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:152
#, no-wrap
msgid "B<within_size>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:159
msgid ""
"Only allocate huge page if it will be fully within I<i_size>.  Also respect "
"B<fadvise>(2)/B<madvise>(2)  hints"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:159
#, no-wrap
msgid "B<advise>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:163
msgid "Only allocate huge pages if requested with B<fadvise>(2)/B<madvise>(2)."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:163
#, no-wrap
msgid "B<deny>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:166
msgid "For use in emergencies, to force the huge option off from all mounts."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:166
#, no-wrap
msgid "B<force>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:169
msgid "Force the huge option on for all mounts; useful for testing."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:170
#, no-wrap
msgid "B<mpol>=I<mpol_option> (since Linux 2.6.15)"
msgstr ""

#.  commit 7339ff8302fd70aabf5f1ae26e0c4905fa74a495
#. type: Plain text
#: build/C/man5/tmpfs.5:176
msgid ""
"Set the NUMA memory allocation policy for all files in this instance (if "
"B<CONFIG_NUMA> is enabled)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:180
msgid "The I<mpol_option> value is one of the following:"
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:181
#, no-wrap
msgid "B<default>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:185
msgid "Use the process allocation policy (see B<set_mempolicy>(2))."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:185
#, no-wrap
msgid "B<prefer>:I<node>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:189
msgid "Preferably allocate memory from the given I<node>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:189
#, no-wrap
msgid "B<bind>:I<nodelist>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:193
msgid "Allocate memory only from nodes in I<nodelist>."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:193
#, no-wrap
msgid "B<interleave>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:196
msgid "Allocate from each node in turn."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:196
#, no-wrap
msgid "B<interleave>:I<nodelist>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:201
msgid "Allocate from each node of I<in> turn."
msgstr ""

#. type: TP
#: build/C/man5/tmpfs.5:201
#, no-wrap
msgid "B<local>"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:204
msgid "Preferably allocate memory from the local node."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:214
msgid ""
"In the above, I<nodelist> is a comma-separated list of decimal numbers and "
"ranges that specify NUMA nodes.  A range is a pair of hyphen-separated "
"decimal numbers, the smallest and largest node numbers in the range.  For "
"example, I<mpol=bind:0-3,5,7,9-15>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:221
msgid ""
"The B<tmpfs> facility was added in Linux 2.4, as a successor to the older "
"B<ramfs> facility, which did not provide limit checking or allow for the use "
"of swap space."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:227
msgid ""
"In order for user-space tools and applications to create B<tmpfs> "
"filesystems, the kernel must be configured with the B<CONFIG_TMPFS> option."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:235
msgid ""
"The B<tmpfs> filesystem supports extended attributes (see B<xattr>(7)), but "
"I<user> extended attributes are not permitted."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:250
msgid ""
"An internal shared memory filesystem is used for System V shared memory "
"(B<shmget>(2))  and shared anonymous mappings (B<mmap>(2)  with the "
"B<MAP_SHARED> and B<MAP_ANONYMOUS> flags).  This filesystem is available "
"regardless of whether the kernel was configured with the B<CONFIG_TMPFS> "
"option."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:259
msgid ""
"A B<tmpfs> filesystem mounted at I</dev/shm> is used for the implementation "
"of POSIX shared memory (B<shm_overview>(7))  and POSIX semaphores "
"(B<sem_overview>(7))."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:270
msgid ""
"The amount of memory consumed by all B<tmpfs> filesystems is shown in the "
"I<Shmem> field of I</proc/meminfo> and in the I<shared> field displayed by "
"B<free>(1)."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:275
msgid "The B<tmpfs> facility was formerly called B<shmfs>."
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:283
msgid ""
"B<df>(1), B<du>(1), B<memfd_create>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shm_open>(3), B<mount>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/tmpfs.5:288
msgid ""
"The kernel source files I<Documentation/filesystems/tmpfs.txt> and "
"I<Documentation/admin-guide/mm/transhuge.rst>."
msgstr ""

#. type: TH
#: build/C/man4/fuse.4:26
#, no-wrap
msgid "FUSE"
msgstr ""

#. type: TH
#: build/C/man4/fuse.4:26
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:29
msgid "fuse - Filesystem in Userspace (FUSE) device"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:32
#, no-wrap
msgid "B<#include E<lt>linux/fuse.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:44
msgid ""
"This device is the primary interface between the FUSE filesystem driver and "
"a user-space process wishing to provide the filesystem (referred to in the "
"rest of this manual page as the I<filesystem daemon>).  This manual page is "
"intended for those interested in understanding the kernel interface itself.  "
"Those implementing a FUSE filesystem may wish to make use of a user-space "
"library such as I<libfuse> that abstracts away the low-level interface."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:58
msgid ""
"At its core, FUSE is a simple client-server protocol, in which the Linux "
"kernel is the client and the daemon is the server.  After obtaining a file "
"descriptor for this device, the daemon may B<read>(2)  requests from that "
"file descriptor and is expected to B<write>(2)  back its replies.  It is "
"important to note that a file descriptor is associated with a unique FUSE "
"filesystem.  In particular, opening a second copy of this device, will not "
"allow access to resources created through the first file descriptor (and "
"vice versa)."
msgstr ""

#. type: SS
#: build/C/man4/fuse.4:58
#, no-wrap
msgid "The basic protocol"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:61
msgid ""
"Every message that is read by the daemon begins with a header described by "
"the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:76
#, no-wrap
msgid ""
"struct fuse_in_header {\n"
"    uint32_t len;       /* Total length of the data,\n"
"                           including this header */\n"
"    uint32_t opcode;    /* The kind of operation (see below) */\n"
"    uint64_t unique;    /* A unique identifier for this request */\n"
"    uint64_t nodeid;    /* ID of the filesystem object\n"
"                           being operated on */\n"
"    uint32_t uid;       /* UID of the requesting process */\n"
"    uint32_t gid;       /* GID of the requesting process */\n"
"    uint32_t pid;       /* PID of the requesting process */\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:83
msgid ""
"The header is followed by a variable-length data portion (which may be "
"empty) specific to the requested operation (the requested operation is "
"indicated by I<opcode>)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:90
msgid ""
"The daemon should then process the request and if applicable send a reply "
"(almost all operations require a reply; if they do not, this is documented "
"below), by performing a B<write>(2)  to the file descriptor.  All replies "
"must start with the following header:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:100
#, no-wrap
msgid ""
"struct fuse_out_header {\n"
"    uint32_t len;       /* Total length of data written to\n"
"                           the file descriptor */\n"
"    int32_t  error;     /* Any error that occurred (0 if none) */\n"
"    uint64_t unique;    /* The value from the\n"
"                           corresponding request */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:110
msgid ""
"This header is also followed by (potentially empty) variable-sized data "
"depending on the executed request.  However, if the reply is an error reply "
"(i.e., I<error> is set), then no further payload data should be sent, "
"independent of the request."
msgstr ""

#. type: SS
#: build/C/man4/fuse.4:110
#, no-wrap
msgid "Exchanged messages"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:117
msgid ""
"This section should contain documentation for each of the messages in the "
"protocol.  This manual page is currently incomplete, so not all messages are "
"documented.  For each message, first the struct sent by the kernel is given, "
"followed by a description of the semantics of the message."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:117
#, no-wrap
msgid "B<FUSE_INIT>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:128
#, no-wrap
msgid ""
"struct fuse_init_in {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead; /* Since protocol v7.6 */\n"
"    uint32_t flags;         /* Since protocol v7.6 */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:140
msgid ""
"This is the first request sent by the kernel to the daemon.  It is used to "
"negotiate the protocol version and other filesystem parameters.  Note that "
"the protocol version may affect the layout of any structure in the protocol "
"(including this structure).  The daemon must thus remember the negotiated "
"version and flags for each session.  As of the writing of this man page, the "
"highest supported kernel protocol version is I<7.26>."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:143
msgid ""
"Users should be aware that the descriptions in this manual page may be "
"incomplete or incorrect for older or more recent protocol versions."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:145
msgid "The reply for this request has the following format:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:160
#, no-wrap
msgid ""
"struct fuse_init_out {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead;   /* Since v7.6 */\n"
"    uint32_t flags;           /* Since v7.6; some flags bits\n"
"                                 were introduced later */\n"
"    uint16_t max_background;  /* Since v7.13 */\n"
"    uint16_t congestion_threshold;  /* Since v7.13 */\n"
"    uint32_t max_write;       /* Since v7.5 */\n"
"    uint32_t time_gran;       /* Since v7.6 */\n"
"    uint32_t unused[9];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:173
msgid ""
"If the major version supported by the kernel is larger than that supported "
"by the daemon, the reply shall consist of only I<uint32_t major> (following "
"the usual header), indicating the largest major version supported by the "
"daemon.  The kernel will then issue a new B<FUSE_INIT> request conforming to "
"the older version.  In the reverse case, the daemon should quietly fall back "
"to the kernel's major version."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:177
msgid ""
"The negotiated minor version is considered to be the minimum of the minor "
"versions provided by the daemon and the kernel and both parties should use "
"the protocol corresponding to said minor version."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:177
#, no-wrap
msgid "B<FUSE_GETATTR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:188
#, no-wrap
msgid ""
"struct fuse_getattr_in {\n"
"    uint32_t getattr_flags;\n"
"    uint32_t dummy;\n"
"    uint64_t fh;      /* Set only if\n"
"                         (getattr_flags & FUSE_GETATTR_FH)\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:204
msgid ""
"The requested operation is to compute the attributes to be returned by "
"B<stat>(2)  and similar operations for the given filesystem object.  The "
"object for which the attributes should be computed is indicated either by "
"I<header-E<gt>nodeid> or, if the B<FUSE_GETATTR_FH> flag is set, by the file "
"handle I<fh>.  The latter case of operation is analogous to B<fstat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:211
msgid ""
"For performance reasons, these attributes may be cached in the kernel for a "
"specified duration of time.  While the cache timeout has not been exceeded, "
"the attributes will be served from the cache and will not cause additional "
"B<FUSE_GETATTR> requests."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:214
msgid ""
"The computed attributes and the requested cache timeout should then be "
"returned in the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:241
#, no-wrap
msgid ""
"struct fuse_attr_out {\n"
"    /* Attribute cache duration (seconds + nanoseconds) */\n"
"    uint64_t attr_valid;\n"
"    uint32_t attr_valid_nsec;\n"
"    uint32_t dummy;\n"
"    struct fuse_attr {\n"
"        uint64_t ino;\n"
"        uint64_t size;\n"
"        uint64_t blocks;\n"
"        uint64_t atime;\n"
"        uint64_t mtime;\n"
"        uint64_t ctime;\n"
"        uint32_t atimensec;\n"
"        uint32_t mtimensec;\n"
"        uint32_t ctimensec;\n"
"        uint32_t mode;\n"
"        uint32_t nlink;\n"
"        uint32_t uid;\n"
"        uint32_t gid;\n"
"        uint32_t rdev;\n"
"        uint32_t blksize;\n"
"        uint32_t padding;\n"
"    } attr;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:243
#, no-wrap
msgid "B<FUSE_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:252
#, no-wrap
msgid ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:264
msgid ""
"If the I<default_permissions> mount options is not used, this request may be "
"used for permissions checking.  No reply data is expected, but errors may be "
"indicated as usual by setting the I<error> field in the reply header (in "
"particular, access denied errors may be indicated by returning B<-EACCES>)."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:264
#, no-wrap
msgid "B<FUSE_OPEN> and B<FUSE_OPENDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:273
#, no-wrap
msgid ""
"struct fuse_open_in {\n"
"    uint32_t flags;     /* The flags that were passed\n"
"                           to the open(2) */\n"
"    uint32_t unused;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:285
msgid ""
"The requested operation is to open the node indicated by "
"I<header-E<gt>nodeid>.  The exact semantics of what this means will depend "
"on the filesystem being implemented.  However, at the very least the "
"filesystem should validate that the requested I<flags> are valid for the "
"indicated resource and then send a reply with the following format:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:293
#, no-wrap
msgid ""
"struct fuse_open_out {\n"
"    uint64_t fh;\n"
"    uint32_t open_flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:304
msgid ""
"The I<fh> field is an opaque identifier that the kernel will use to refer to "
"this resource The I<open_flags> field is a bit mask of any number of the "
"flags that indicate properties of this file handle to the kernel:"
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:305
#, no-wrap
msgid "B<FOPEN_DIRECT_IO>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:308
msgid "Bypass page cache for this open file."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:308
#, no-wrap
msgid "B<FOPEN_KEEP_CACHE>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:311
msgid "Don't invalidate the data cache on open."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:311
#, no-wrap
msgid "B<FOPEN_NONSEEKABLE>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:314
msgid "The file is not seekable."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:315
#, no-wrap
msgid "B<FUSE_READ> and B<FUSE_READDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:329
#, no-wrap
msgid ""
"struct fuse_read_in {\n"
"    uint64_t fh;\n"
"    uint64_t offset;\n"
"    uint32_t size;\n"
"    uint32_t read_flags;\n"
"    uint64_t lock_owner;\n"
"    uint32_t flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:337
msgid ""
"The requested action is to read up to I<size> bytes of the file or "
"directory, starting at I<offset>.  The bytes should be returned directly "
"following the usual reply header."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:337
#, no-wrap
msgid "B<FUSE_INTERRUPT>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:344
#, no-wrap
msgid ""
"struct fuse_interrupt_in {\n"
"    uint64_t unique;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:360
msgid ""
"The requested action is to cancel the pending operation indicated by "
"I<unique>.  This request requires no response.  However, receipt of this "
"message does not by itself cancel the indicated operation.  The kernel will "
"still expect a reply to said operation (e.g., an I<EINTR> error or a short "
"read).  At most one B<FUSE_INTERRUPT> request will be issued for a given "
"operation.  After issuing said operation, the kernel will wait "
"uninterruptibly for completion of the indicated request."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:360
#, no-wrap
msgid "B<FUSE_LOOKUP>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:366
msgid ""
"Directly following the header is a filename to be looked up in the directory "
"indicated by I<header-E<gt>nodeid>.  The expected reply is of the form:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:378
#, no-wrap
msgid ""
"struct fuse_entry_out {\n"
"    uint64_t nodeid;            /* Inode ID */\n"
"    uint64_t generation;        /* Inode generation */\n"
"    uint64_t entry_valid;\n"
"    uint64_t attr_valid;\n"
"    uint32_t entry_valid_nsec;\n"
"    uint32_t attr_valid_nsec;\n"
"    struct fuse_attr attr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:386
msgid ""
"The combination of I<nodeid> and I<generation> must be unique for the "
"filesystem's lifetime."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:391
msgid "The interpretation of timeouts and I<attr> is as for B<FUSE_GETATTR>."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:391
#, no-wrap
msgid "B<FUSE_FLUSH>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:401
#, no-wrap
msgid ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:409
msgid ""
"The requested action is to flush any pending changes to the indicated file "
"handle.  No reply data is expected.  However, an empty reply message still "
"needs to be issued once the flush operation is complete."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:409
#, no-wrap
msgid "B<FUSE_RELEASE> and B<FUSE_RELEASEDIR>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:419
#, no-wrap
msgid ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:434
msgid ""
"These are the converse of B<FUSE_OPEN> and B<FUSE_OPENDIR> respectively.  "
"The daemon may now free any resources associated with the file handle I<fh> "
"as the kernel will no longer refer to it.  There is no reply data associated "
"with this request, but a reply still needs to be issued once the request has "
"been completely processed."
msgstr ""

#. type: TP
#: build/C/man4/fuse.4:434
#, no-wrap
msgid "B<FUSE_STATFS>"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:441
msgid ""
"This operation implements B<statfs>(2)  for this filesystem.  There is no "
"input data associated with this request.  The expected reply data has the "
"following structure:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:456
#, no-wrap
msgid ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:460
#, no-wrap
msgid ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:465
msgid "For the interpretation of these fields, see B<statfs>(2)."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:473
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer and the request was B<FUSE_SETXATTR>."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:482
msgid ""
"Returned from B<write>(2)  if validation of the reply failed.  Not all "
"mistakes in replies will be caught by this validation.  However, basic "
"mistakes, such as short replies or an incorrect I<unique> value, are "
"detected."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:487
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:493
msgid ""
"I<Note>: There are various ways in which incorrect use of these interfaces "
"can cause operations on the provided filesystem's files and directories to "
"fail with B<EIO>.  Among the possible incorrect uses are:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:498
msgid ""
"changing I<mode & S_IFMT> for an inode that has previously been reported to "
"the kernel; or"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:500
msgid "giving replies to the kernel that are shorter than what the kernel expected."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:508
msgid ""
"Returned from B<read>(2)  and B<write>(2)  if the FUSE filesystem was "
"unmounted."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:513
msgid ""
"Returned from operations on a I</dev/fuse> file descriptor that has not been "
"mounted."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:515
msgid "The FUSE filesystem is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:517
msgid "The following messages are not yet documented in this manual page:"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:551
#, no-wrap
msgid ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/fuse.4:556
msgid "B<fusermount>(1), B<mount.fuse>(8)"
msgstr ""

#. type: TH
#: build/C/man4/loop.4:26
#, no-wrap
msgid "LOOP"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:29
msgid "loop, loop-control - loop devices"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:31
msgid "#include E<lt>linux/loop.hE<gt>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:41
msgid ""
"The loop device is a block device that maps its data blocks not to a "
"physical device such as a hard disk or optical disk drive, but to the blocks "
"of a regular file in a filesystem or to another block device.  This can be "
"useful for example to provide a block device for a filesystem image stored "
"in a file, so that it can be mounted with the B<mount>(8)  command.  You "
"could do"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:49
#, no-wrap
msgid ""
"$ B<dd if=/dev/zero of=file.img bs=1MiB count=10>\n"
"$ B<sudo losetup /dev/loop4 file.img>\n"
"$ B<sudo mkfs -t ext4 /dev/loop4>\n"
"$ B<sudo mkdir /myloopdev>\n"
"$ B<sudo mount /dev/loop4 /myloopdev>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:55
msgid "See B<losetup>(8)  for another example."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:58
msgid ""
"A transfer function can be specified for each loop device for encryption and "
"decryption purposes."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:62
msgid "The following B<ioctl>(2)  operations are provided by the loop block device:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:62
#, no-wrap
msgid "B<LOOP_SET_FD>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:68
msgid ""
"Associate the loop device with the open file whose file descriptor is passed "
"as the (third)  B<ioctl>(2)  argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:68
#, no-wrap
msgid "B<LOOP_CLR_FD>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:71
msgid "Disassociate the loop device from any file descriptor."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:71
#, no-wrap
msgid "B<LOOP_SET_STATUS>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:81
msgid ""
"Set the status of the loop device using the (third)  B<ioctl>(2)  argument.  "
"This argument is a pointer to a I<loop_info> structure, defined in "
"I<E<lt>linux/loop.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:100
#, no-wrap
msgid ""
"struct loop_info {\n"
"    int           lo_number;      /* ioctl r/o */\n"
"    dev_t         lo_device;      /* ioctl r/o */\n"
"    unsigned long lo_inode;       /* ioctl r/o */\n"
"    dev_t         lo_rdevice;     /* ioctl r/o */\n"
"    int           lo_offset;\n"
"    int           lo_encrypt_type;\n"
"    int           lo_encrypt_key_size;  /* ioctl w/o */\n"
"    int           lo_flags;       /* ioctl r/w (r/o before\n"
"                                     Linux 2.6.25) */\n"
"    char          lo_name[LO_NAME_SIZE];\n"
"    unsigned char lo_encrypt_key[LO_KEY_SIZE];\n"
"                                  /* ioctl w/o */\n"
"    unsigned long lo_init[2];\n"
"    char          reserved[4];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:117
msgid ""
"The encryption type (I<lo_encrypt_type>)  should be one of B<LO_CRYPT_NONE>, "
"B<LO_CRYPT_XOR>, B<LO_CRYPT_DES>, B<LO_CRYPT_FISH2>, B<LO_CRYPT_BLOW>, "
"B<LO_CRYPT_CAST128>, B<LO_CRYPT_IDEA>, B<LO_CRYPT_DUMMY>, "
"B<LO_CRYPT_SKIPJACK>, or (since Linux 2.6.0)  B<LO_CRYPT_CRYPTOAPI>."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:121
msgid ""
"The I<lo_flags> field is a bit mask that can include zero or more of the "
"following:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:122
#, no-wrap
msgid "B<LO_FLAGS_READ_ONLY>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:125
msgid "The loopback device is read-only."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:125
#, no-wrap
msgid "B<LO_FLAGS_AUTOCLEAR> (since Linux 2.6.25)"
msgstr ""

#.  commit 96c5865559cee0f9cbc5173f3c949f6ce3525581
#. type: Plain text
#: build/C/man4/loop.4:129
msgid "The loopback device will autodestruct on last close."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:129
#, no-wrap
msgid "B<LO_FLAGS_PARTSCAN> (since Linux 3.2)"
msgstr ""

#.  commit e03c8dd14915fabc101aa495828d58598dc5af98
#. type: Plain text
#: build/C/man4/loop.4:133
msgid "Allow automatic partition scanning."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:133
#, no-wrap
msgid "B<LO_FLAGS_DIRECT_IO> (since Linux 4.10)"
msgstr ""

#.  commit 2e5ab5f379f96a6207c45be40c357ebb1beb8ef3
#. type: Plain text
#: build/C/man4/loop.4:137
msgid "Use direct I/O mode to access the backing file."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:147
msgid ""
"The only I<lo_flags> that can be modified by B<LOOP_SET_STATUS> are "
"B<LO_FLAGS_AUTOCLEAR> and B<LO_FLAGS_PARTSCAN>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:147
#, no-wrap
msgid "B<LOOP_GET_STATUS>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:154
msgid ""
"Get the status of the loop device.  The (third)  B<ioctl>(2)  argument must "
"be a pointer to a I<struct loop_info>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:154
#, no-wrap
msgid "B<LOOP_CHANGE_FD> (since Linux 2.6.5)"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:162
msgid ""
"Switch the backing store of the loop device to the new file identified file "
"descriptor specified in the (third)  B<ioctl>(2)  argument, which is an "
"integer.  This operation is possible only if the loop device is read-only "
"and the new backing store is the same size and type as the old backing "
"store."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:162
#, no-wrap
msgid "B<LOOP_SET_CAPACITY> (since Linux 2.6.30)"
msgstr ""

#.  commit 53d6660836f233df66490707365ab177e5fb2bb4
#. type: Plain text
#: build/C/man4/loop.4:169
msgid ""
"Resize a live loop device.  One can change the size of the underlying "
"backing store and then use this operation so that the loop driver learns "
"about the new size.  This operation takes no argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:169
#, no-wrap
msgid "B<LOOP_SET_DIRECT_IO> (since Linux 4.10)"
msgstr ""

#.  commit ab1cb278bc7027663adbfb0b81404f8398437e11
#. type: Plain text
#: build/C/man4/loop.4:178
msgid ""
"Set DIRECT I/O mode on the loop device, so that it can be used to open "
"backing file.  The (third)  B<ioctl>(2)  argument is an unsigned long "
"value.  A nonzero represents direct I/O mode."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:178
#, no-wrap
msgid "B<LOOP_SET_BLOCK_SIZE> (since Linux 4.14)"
msgstr ""

#.  commit 89e4fdecb51cf5535867026274bc97de9480ade5
#. type: Plain text
#: build/C/man4/loop.4:190
msgid ""
"Set the block size of the loop device.  The (third)  B<ioctl>(2)  argument "
"is an unsigned long value.  This value must be a power of two in the range "
"[512,pagesize]; otherwise, an B<EINVAL> error results."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:190
#, no-wrap
msgid "B<LOOP_CONFIGURE> (since Linux 5.8)"
msgstr ""

#.  commit 3448914e8cc550ba792d4ccc74471d1ca4293aae
#. type: Plain text
#: build/C/man4/loop.4:202
msgid ""
"Setup and configure all loop device parameters in a single step using the "
"(third)  B<ioctl>(2)  argument.  This argument is a pointer to a "
"I<loop_config> structure, defined in I<E<lt>linux/loop.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:211
#, no-wrap
msgid ""
"struct loop_config {\n"
"    __u32               fd;\n"
"    __u32               block_size;\n"
"    struct loop_info64  info;\n"
"    __u64               __reserved[8];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:219
msgid ""
"In addition to doing what B<LOOP_SET_STATUS> can do, B<LOOP_CONFIGURE> can "
"also be used to do the following:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:223
msgid "set the correct block size immediately by setting I<loop_config.block_size>;"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:229
msgid ""
"explicitly request direct I/O mode by setting B<LO_FLAGS_DIRECT_IO> in "
"I<loop_config.info.lo_flags>; and"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:234
msgid ""
"explicitly request read-only mode by setting B<LO_FLAGS_READ_ONLY> in "
"I<loop_config.info.lo_flags>."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:239
msgid "Since Linux 2.6, there are two new B<ioctl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:239
#, no-wrap
msgid "B<LOOP_SET_STATUS64>, B<LOOP_GET_STATUS64>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:247
msgid ""
"These are similar to B<LOOP_SET_STATUS> and B<LOOP_GET_STATUS> described "
"above but use the I<loop_info64> structure, which has some additional fields "
"and a larger range for some other fields:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:266
#, no-wrap
msgid ""
"struct loop_info64 {\n"
"    uint64_t lo_device;           /* ioctl r/o */\n"
"    uint64_t lo_inode;            /* ioctl r/o */\n"
"    uint64_t lo_rdevice;          /* ioctl r/o */\n"
"    uint64_t lo_offset;\n"
"    uint64_t lo_sizelimit;  /* bytes, 0 == max available */\n"
"    uint32_t lo_number;           /* ioctl r/o */\n"
"    uint32_t lo_encrypt_type;\n"
"    uint32_t lo_encrypt_key_size; /* ioctl w/o */\n"
"    uint32_t lo_flags; i          /* ioctl r/w (r/o before\n"
"                                     Linux 2.6.25) */\n"
"    uint8_t  lo_file_name[LO_NAME_SIZE];\n"
"    uint8_t  lo_crypt_name[LO_NAME_SIZE];\n"
"    uint8_t  lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */\n"
"    uint64_t lo_init[2];\n"
"};\n"
msgstr ""

#. type: SS
#: build/C/man4/loop.4:268
#, no-wrap
msgid "/dev/loop-control"
msgstr ""

#.  commit 770fe30a46a12b6fb6b63fbe1737654d28e84844
#. type: Plain text
#: build/C/man4/loop.4:280
msgid ""
"Since Linux 3.1, the kernel provides the I</dev/loop-control> device, which "
"permits an application to dynamically find a free device, and to add and "
"remove loop devices from the system.  To perform these operations, one first "
"opens I</dev/loop-control> and then employs one of the following B<ioctl>(2)  "
"operations:"
msgstr ""

#. type: TP
#: build/C/man4/loop.4:280
#, no-wrap
msgid "B<LOOP_CTL_GET_FREE>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:285
msgid ""
"Allocate or find a free loop device for use.  On success, the device number "
"is returned as the result of the call.  This operation takes no argument."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:285
#, no-wrap
msgid "B<LOOP_CTL_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:294
msgid ""
"Add the new loop device whose device number is specified as a long integer "
"in the third B<ioctl>(2)  argument.  On success, the device index is "
"returned as the result of the call.  If the device is already allocated, the "
"call fails with the error B<EEXIST>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:294
#, no-wrap
msgid "B<LOOP_CTL_REMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:303
msgid ""
"Remove the loop device whose device number is specified as a long integer in "
"the third B<ioctl>(2)  argument.  On success, the device number is returned "
"as the result of the call.  If the device is in use, the call fails with the "
"error B<EBUSY>."
msgstr ""

#. type: TP
#: build/C/man4/loop.4:304
#, no-wrap
msgid "I</dev/loop*>"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:307
msgid "The loop block special device files."
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:314
msgid ""
"The program below uses the I</dev/loop-control> device to find a free loop "
"device, opens the loop device, opens a file to be used as the underlying "
"storage for the device, and then associates the loop device with the backing "
"store.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:323
#, no-wrap
msgid ""
"$ B<dd if=/dev/zero of=file.img bs=1MiB count=10>\n"
"10+0 records in\n"
"10+0 records out\n"
"10485760 bytes (10 MB) copied, 0.00609385 s, 1.7 GB/s\n"
"$ B<sudo ./mnt_loop file.img>\n"
"loopname = /dev/loop5\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:334
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/loop.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:337
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:344
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int loopctlfd, loopfd, backingfile;\n"
"    long devnr;\n"
"    char loopname[4096];\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:349
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s backing-file\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:353
#, no-wrap
msgid ""
"    loopctlfd = open(\"/dev/loop-control\", O_RDWR);\n"
"    if (loopctlfd == -1)\n"
"        errExit(\"open: /dev/loop-control\");\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:357
#, no-wrap
msgid ""
"    devnr = ioctl(loopctlfd, LOOP_CTL_GET_FREE);\n"
"    if (devnr == -1)\n"
"        errExit(\"ioctl-LOOP_CTL_GET_FREE\");\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:360
#, no-wrap
msgid ""
"    sprintf(loopname, \"/dev/loop%ld\", devnr);\n"
"    printf(\"loopname = %s\\en\", loopname);\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:364
#, no-wrap
msgid ""
"    loopfd = open(loopname, O_RDWR);\n"
"    if (loopfd == -1)\n"
"        errExit(\"open: loopname\");\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:368
#, no-wrap
msgid ""
"    backingfile = open(argv[1], O_RDWR);\n"
"    if (backingfile == -1)\n"
"        errExit(\"open: backing-file\");\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:371
#, no-wrap
msgid ""
"    if (ioctl(loopfd, LOOP_SET_FD, backingfile) == -1)\n"
"        errExit(\"ioctl-LOOP_SET_FD\");\n"
msgstr ""

#. type: Plain text
#: build/C/man4/loop.4:378
msgid "B<losetup>(8), B<mount>(8)"
msgstr ""

#. type: TH
#: build/C/man7/inode.7:25
#, no-wrap
msgid "INODE"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:28
msgid "inode - file inode information"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:39
msgid ""
"Each file has an inode containing metadata about the file.  An application "
"can retrieve this metadata using B<stat>(2)  (or related calls), which "
"returns a I<stat> structure, or B<statx>(2), which returns a I<statx> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:46
msgid ""
"The following is a list of the information typically found in, or associated "
"with, the file inode, with the names of the corresponding structure fields "
"returned by B<stat>(2)  and B<statx>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:46
#, no-wrap
msgid "Device where inode resides"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:49
msgid "I<stat.st_dev>; I<statx.stx_dev_minor> and I<statx.stx_dev_major>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:55
msgid ""
"Each inode (as well as the associated file) resides in a filesystem that is "
"hosted on a device.  That device is identified by the combination of its "
"major ID (which identifies the general class of device)  and minor ID (which "
"identifies a specific instance in the general class)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:55
#, no-wrap
msgid "Inode number"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:58
msgid "I<stat.st_ino>; I<statx.stx_ino>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:64
msgid ""
"Each file in a filesystem has a unique inode number.  Inode numbers are "
"guaranteed to be unique only within a filesystem (i.e., the same inode "
"numbers may be used by different filesystems, which is the reason that hard "
"links may not cross filesystem boundaries).  This field contains the file's "
"inode number."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:64
#, no-wrap
msgid "File type and mode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:67
msgid "I<stat.st_mode>; I<statx.stx_mode>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:69
msgid "See the discussion of file type and mode, below."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:69
#, no-wrap
msgid "Link count"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:72
msgid "I<stat.st_nlink>; I<statx.stx_nlink>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:76
msgid ""
"This field contains the number of hard links to the file.  Additional links "
"to an existing file are created using B<link>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:76
#, no-wrap
msgid "User ID"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:80
msgid "I<st_uid> I<stat.st_uid>; I<statx.stx_uid>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:86
msgid ""
"This field records the user ID of the owner of the file.  For newly created "
"files, the file user ID is the effective user ID of the creating process.  "
"The user ID of a file can be changed using B<chown>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:86
#, no-wrap
msgid "Group ID"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:89
msgid "I<stat.st_gid>; I<statx.stx_gid>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:98
msgid ""
"The inode records the ID of the group owner of the file.  For newly created "
"files, the file group ID is either the group ID of the parent directory or "
"the effective group ID of the creating process, depending on whether or not "
"the set-group-ID bit is set on the parent directory (see below).  The group "
"ID of a file can be changed using B<chown>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:98
#, no-wrap
msgid "Device represented by this inode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:101
msgid "I<stat.st_rdev>; I<statx.stx_rdev_minor> and I<statx.stx_rdev_major>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:104
msgid ""
"If this file (inode) represents a device, then the inode records the major "
"and minor ID of that device."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:104
#, no-wrap
msgid "File size"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:107
msgid "I<stat.st_size>; I<statx.stx_size>"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:112
#, no-wrap
msgid "Preferred block size for I/O"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:115
msgid "I<stat.st_blksize>; I<statx.stx_blksize>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:119
msgid ""
"This field gives the \"preferred\" blocksize for efficient filesystem I/O.  "
"(Writing to a file in smaller chunks may cause an inefficient "
"read-modify-rewrite.)"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:119
#, no-wrap
msgid "Number of blocks allocated to the file"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:122
msgid "I<stat.st_blocks>; I<statx.stx_size>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:128
msgid ""
"This field indicates the number of blocks allocated to the file, 512-byte "
"units, (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""

#.  Rationale for sys/stat.h in POSIX.1-2008
#. type: Plain text
#: build/C/man7/inode.7:139
msgid ""
"The POSIX.1 standard notes that the unit for the I<st_blocks> member of the "
"I<stat> structure is not defined by the standard.  On many implementations "
"it is 512 bytes; on a few systems, a different unit is used, such as 1024.  "
"Furthermore, the unit may differ on a per-filesystem basis."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:139
#, no-wrap
msgid "Last access timestamp (atime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:142
msgid "I<stat.st_atime>; I<statx.stx_atime>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:155
msgid ""
"This is the file's last access timestamp.  It is changed by file accesses, "
"for example, by B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2), and "
"B<read>(2)  (of more than zero bytes).  Other interfaces, such as "
"B<mmap>(2), may or may not update the atime timestamp"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:172
msgid ""
"Some filesystem types allow mounting in such a way that file and/or "
"directory accesses do not cause an update of the atime timestamp.  (See "
"I<noatime>, I<nodiratime>, and I<relatime> in B<mount>(8), and related "
"information in B<mount>(2).)  In addition, the atime timestamp is not "
"updated if a file is opened with the B<O_NOATIME> flag; see B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:172
#, no-wrap
msgid "File creation (birth) timestamp (btime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:175
msgid "(not returned in the I<stat> structure); I<statx.stx_btime>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:178
msgid ""
"The file's creation timestamp.  This is set on file creation and not changed "
"subsequently."
msgstr ""

#.  FIXME Is it supported on ext4 and XFS?
#. type: Plain text
#: build/C/man7/inode.7:182
msgid ""
"The btime timestamp was not historically present on UNIX systems and is not "
"currently supported by most Linux filesystems."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:182
#, no-wrap
msgid "Last modification timestamp (mtime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:185
msgid "I<stat.st_mtime>; I<statx.stx_mtime>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:200
msgid ""
"This is the file's last modification timestamp.  It is changed by file "
"modifications, for example, by B<mknod>(2), B<truncate>(2), B<utime>(2), and "
"B<write>(2)  (of more than zero bytes).  Moreover, the mtime timestamp of a "
"directory is changed by the creation or deletion of files in that "
"directory.  The mtime timestamp is I<not> changed for changes in owner, "
"group, hard link count, or mode."
msgstr ""

#. type: TP
#: build/C/man7/inode.7:200
#, no-wrap
msgid "Last status change timestamp (ctime)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:203
msgid "I<stat.st_ctime>; I<statx.stx_ctime>"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:207
msgid ""
"This is the file's last status change timestamp.  It is changed by writing "
"or by setting inode information (i.e., owner, group, link count, mode, "
"etc.)."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:212
msgid ""
"The timestamp fields report time measured with a zero point at the I<Epoch>, "
"1970-01-02 00:00:00 +0000, UTC (see B<time>(7))."
msgstr ""

#.  commit ef7f38359ea8b3e9c7f2cae9a4d4935f55ca9e80
#. type: Plain text
#: build/C/man7/inode.7:235
msgid ""
"Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since "
"Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, and "
"Reiserfs.  In order to return timestamps with nanosecond precision, the "
"timestamp fields in the I<stat> and I<statx> structures are defined as "
"structures that include a nanosecond component.  See B<stat>(2)  and "
"B<statx>(2)  for details.  On filesystems that do not support subsecond "
"timestamps, the nanosecond fields in the I<stat> and I<statx> structures are "
"returned with the value 0."
msgstr ""

#. type: SS
#: build/C/man7/inode.7:235
#, no-wrap
msgid "The file type and mode"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:243
msgid ""
"The I<stat.st_mode> field (for B<statx>(2), the I<statx.stx_mode> field) "
"contains the file type and mode."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:254
msgid ""
"POSIX refers to the I<stat.st_mode> bits corresponding to the mask B<S_IFMT> "
"(see below) as the I<file type>, the 12 bits corresponding to the mask 07777 "
"as the I<file mode bits> and the least significant 9 bits (0777) as the "
"I<file permission bits>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:256
msgid "The following mask values are defined for the file type:"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:259
#, no-wrap
msgid "S_IFMT"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:259
#, no-wrap
msgid "0170000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:259
#, no-wrap
msgid "bit mask for the file type bit field"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "S_IFSOCK"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "0140000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:261
#, no-wrap
msgid "socket"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "S_IFLNK"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "0120000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:262
#, no-wrap
msgid "symbolic link"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "S_IFREG"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "0100000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:263
#, no-wrap
msgid "regular file"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "S_IFBLK"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "0060000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:264
#, no-wrap
msgid "block device"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "S_IFDIR"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "0040000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:265
#, no-wrap
msgid "directory"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "S_IFCHR"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "0020000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:266
#, no-wrap
msgid "character device"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "S_IFIFO"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "0010000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:267
#, no-wrap
msgid "FIFO"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:272
msgid "Thus, to test for a regular file (for example), one could write:"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:279
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if ((sb.st_mode & S_IFMT) == S_IFREG) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:286
msgid ""
"Because tests of the above form are common, additional macros are defined by "
"POSIX to allow the test of the file type in I<st_mode> to be written more "
"concisely:"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:287
#, no-wrap
msgid "B<S_ISREG>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:290
msgid "is it a regular file?"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:290
#, no-wrap
msgid "B<S_ISDIR>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:293
msgid "directory?"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:293
#, no-wrap
msgid "B<S_ISCHR>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:296
msgid "character device?"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:296
#, no-wrap
msgid "B<S_ISBLK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:299
msgid "block device?"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:299
#, no-wrap
msgid "B<S_ISFIFO>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:302
msgid "FIFO (named pipe)?"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:302
#, no-wrap
msgid "B<S_ISLNK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:305
msgid "symbolic link? (Not in POSIX.1-1996.)"
msgstr ""

#. type: TP
#: build/C/man7/inode.7:305
#, no-wrap
msgid "B<S_ISSOCK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:308
msgid "socket? (Not in POSIX.1-1996.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:311
msgid "The preceding code snippet could thus be rewritten as:"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:318
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if (S_ISREG(sb.st_mode)) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:337
msgid ""
"The definitions of most of the above file type test macros are provided if "
"any of the following feature test macros is defined: B<_BSD_SOURCE> (in "
"glibc 2.19 and earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), or "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later).  In addition, definitions of "
"all of the above macros except B<S_IFSOCK> and B<S_ISSOCK>()  are provided "
"if B<_XOPEN_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:346
msgid ""
"The definition of B<S_IFSOCK> can also be exposed either by defining "
"B<_XOPEN_SOURCE> with a value of 500 or greater or (since glibc 2.24) by "
"defining both B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:361
msgid ""
"The definition of B<S_ISSOCK>()  is exposed if any of the following feature "
"test macros is defined: B<_BSD_SOURCE> (in glibc 2.19 and earlier), "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later), B<_XOPEN_SOURCE> with a value "
"of 500 or greater, B<_POSIX_C_SOURCE> with a value of 200112L or greater, or "
"(since glibc 2.24) by defining both B<_XOPEN_SOURCE> and "
"B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:366
msgid ""
"The following mask values are defined for the file mode component of the "
"I<st_mode> field:"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "S_ISUID"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "  04000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:369
#, no-wrap
msgid "set-user-ID bit (see B<execve>(2))"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "S_ISGID"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "  02000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:370
#, no-wrap
msgid "set-group-ID bit (see below)"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "S_ISVTX"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "  01000"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:371
#, no-wrap
msgid "sticky bit (see below)"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:373
#, no-wrap
msgid "S_IRWXU"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:373
#, no-wrap
msgid "  00700"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:373
#, no-wrap
msgid "owner has read, write, and execute permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "S_IRUSR"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "  00400"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:374
#, no-wrap
msgid "owner has read permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "S_IWUSR"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "  00200"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:375
#, no-wrap
msgid "owner has write permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "S_IXUSR"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "  00100"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:376
#, no-wrap
msgid "owner has execute permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:378
#, no-wrap
msgid "S_IRWXG"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:378
#, no-wrap
msgid "  00070"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:378
#, no-wrap
msgid "group has read, write, and execute permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "S_IRGRP"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "  00040"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:379
#, no-wrap
msgid "group has read permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "S_IWGRP"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "  00020"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:380
#, no-wrap
msgid "group has write permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "S_IXGRP"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "  00010"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:381
#, no-wrap
msgid "group has execute permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:383
#, no-wrap
msgid "S_IRWXO"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:383
#, no-wrap
msgid "  00007"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:385
#, no-wrap
msgid "others (not in group) have read, write, and execute permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "S_IROTH"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "  00004"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:386
#, no-wrap
msgid "others have read permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "S_IWOTH"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "  00002"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:387
#, no-wrap
msgid "others have write permission"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "S_IXOTH"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "  00001"
msgstr ""

#. type: tbl table
#: build/C/man7/inode.7:388
#, no-wrap
msgid "others have execute permission"
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:408
msgid ""
"The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
"directory, it indicates that BSD semantics are to be used for that "
"directory: files created there inherit their group ID from the directory, "
"not from the effective group ID of the creating process, and directories "
"created there will also get the B<S_ISGID> bit set.  For an executable file, "
"the set-group-ID bit causes the effective group ID of a process that "
"executes the file to change as described in B<execve>(2).  For a file that "
"does not have the group execution bit (B<S_IXGRP>)  set, the set-group-ID "
"bit indicates mandatory file/record locking."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:415
msgid ""
"The sticky bit (B<S_ISVTX>)  on a directory means that a file in that "
"directory can be renamed or deleted only by the owner of the file, by the "
"owner of the directory, and by a privileged process."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:427
msgid ""
"If you need to obtain the definition of the I<blkcnt_t> or I<blksize_t> "
"types from I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the "
"value 500 or greater (before including I<any> header files)."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:445
msgid ""
"POSIX.1-1990 did not describe the B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, "
"B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> "
"constants, but instead specified the use of the macros B<S_ISDIR>(), and so "
"on.  The B<S_IF*> constants are present in POSIX.1-2001 and later."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:453
msgid ""
"The B<S_ISLNK>()  and B<S_ISSOCK>()  macros were not in POSIX.1-1996, but "
"both are present in POSIX.1-2001; the former is from SVID 4, the latter from "
"SUSv2."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:463
msgid ""
"UNIX\\ V7 (and later systems) had B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, where "
"POSIX prescribes the synonyms B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:476
msgid ""
"For pseudofiles that are autogenerated by the kernel, the file size "
"(I<stat.st_size>; I<statx.stx_size>)  reported by the kernel is not "
"accurate.  For example, the value 0 is returned for many files under the "
"I</proc> directory, while various files under I</sys> report a size of 4096 "
"bytes, even though the file content is smaller.  For such files, one should "
"simply try to read as many bytes as possible (and append \\(aq\\e0\\(aq to "
"the returned buffer if it is to be interpreted as a string)."
msgstr ""

#. type: Plain text
#: build/C/man7/inode.7:481
msgid "B<stat>(1), B<stat>(2), B<statx>(2), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man7/xattr.7:28
#, no-wrap
msgid "XATTR"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:31
msgid "xattr - Extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:37
msgid ""
"Extended attributes are name:value pairs associated permanently with files "
"and directories, similar to the environment strings associated with a "
"process.  An attribute may be defined or undefined.  If it is defined, its "
"value may be empty or non-empty."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:45
msgid ""
"Extended attributes are extensions to the normal attributes which are "
"associated with all inodes in the system (i.e., the B<stat>(2)  data).  They "
"are often used to provide additional functionality to a filesystem\\(emfor "
"example, additional security features such as Access Control Lists (ACLs) "
"may be implemented using extended attributes."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:49
msgid ""
"Users with search access to a file or directory may use B<listxattr>(2)  to "
"retrieve a list of attribute names defined for that file or directory."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:57
msgid ""
"Extended attributes are accessed as atomic objects.  Reading "
"(B<getxattr>(2))  retrieves the whole value of an attribute and stores it in "
"a buffer.  Writing (B<setxattr>(2))  replaces any previous value with the "
"new value."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:60
msgid ""
"Space consumed for extended attributes may be counted towards the disk "
"quotas of the file owner and file group."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:60
#, no-wrap
msgid "Extended attribute namespaces"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:70
msgid ""
"Attribute names are null-terminated strings.  The attribute name is always "
"specified in the fully qualified I<namespace.attribute> form, for example, "
"I<user.mime_type>, I<trusted.md5sum>, I<system.posix_acl_access>, or "
"I<security.selinux>."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:77
msgid ""
"The namespace mechanism is used to define different classes of extended "
"attributes.  These different classes exist for several reasons; for example, "
"the permissions and capabilities required for manipulating extended "
"attributes of one namespace may differ to another."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:86
msgid ""
"Currently, the I<security>, I<system>, I<trusted>, and I<user> extended "
"attribute classes are defined as described below.  Additional classes may be "
"added in the future."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:86
#, no-wrap
msgid "Extended security attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:97
msgid ""
"The security attribute namespace is used by kernel security modules, such as "
"Security Enhanced Linux, and also to implement file capabilities (see "
"B<capabilities>(7)).  Read and write access permissions to security "
"attributes depend on the policy implemented for each security attribute by "
"the security module.  When no security module is loaded, all processes have "
"read access to extended security attributes, and write access is limited to "
"processes that have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:97
#, no-wrap
msgid "System extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:103
msgid ""
"System extended attributes are used by the kernel to store system objects "
"such as Access Control Lists.  Read and write access permissions to system "
"attributes depend on the policy implemented for each system attribute "
"implemented by filesystems in the kernel."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:103
#, no-wrap
msgid "Trusted extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:111
msgid ""
"Trusted extended attributes are visible and accessible only to processes "
"that have the B<CAP_SYS_ADMIN> capability.  Attributes in this class are "
"used to implement mechanisms in user space (i.e., outside the kernel) which "
"keep information in extended attributes to which ordinary processes should "
"not have access."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:111
#, no-wrap
msgid "User extended attributes"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:119
msgid ""
"User extended attributes may be assigned to files and directories for "
"storing arbitrary additional information such as the mime type, character "
"set or encoding of a file.  The access permissions for user attributes are "
"defined by the file permission bits: read permission is required to retrieve "
"the attribute value, and writer permission is required to change it."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:130
msgid ""
"The file permission bits of regular files and directories are interpreted "
"differently from the file permission bits of special files and symbolic "
"links.  For regular files and directories the file permission bits define "
"access to the file's contents, while for device special files they define "
"access to the device described by the special file.  The file permissions of "
"symbolic links are not used in access checks.  These differences would allow "
"users to consume filesystem resources in a way not controllable by disk "
"quotas for group or world writable special files and directories."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:138
msgid ""
"For this reason, user extended attributes are allowed only for regular files "
"and directories, and access to user extended attributes is restricted to the "
"owner and to users with appropriate capabilities for directories with the "
"sticky bit set (see the B<chmod>(1)  manual page for an explanation of the "
"sticky bit)."
msgstr ""

#. type: SS
#: build/C/man7/xattr.7:138
#, no-wrap
msgid "Filesystem differences"
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:147
msgid ""
"The kernel and the filesystem may place limits on the maximum number and "
"size of extended attributes that can be associated with a file.  The VFS "
"imposes limitations that an attribute names is limited to 255 bytes and an "
"attribute value is limited to 64\\ kB.  The list of attribute names that can "
"be returned is also limited to 64\\ kB (see BUGS in B<listxattr>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:152
msgid ""
"Some filesystems, such as Reiserfs (and, historically, ext2 and ext3), "
"require the filesystem to be mounted with the B<user_xattr> mount option in "
"order for user extended attributes to be used."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:158
msgid ""
"In the current ext2, ext3, and ext4 filesystem implementations, the total "
"bytes used by the names and values of all of a file's extended attributes "
"must fit in a single filesystem block (1024, 2048 or 4096 bytes, depending "
"on the block size specified when the filesystem was created)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:163
msgid ""
"In the Btrfs, XFS, and Reiserfs filesystem implementations, there is no "
"practical limit on the number of extended attributes associated with a file, "
"and the algorithms used to store extended attribute information on disk are "
"scalable."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:166
msgid ""
"In the JFS, XFS, and Reiserfs filesystem implementations, the limit on bytes "
"used in an EA value is the ceiling imposed by the VFS."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:172
msgid ""
"In the Btrfs filesystem implementation, the total bytes used for the name, "
"value, and implementation overhead bytes is limited to the filesystem "
"I<nodesize> value (16\\ kB by default)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:175
msgid ""
"Extended attributes are not specified in POSIX.1, but some other systems "
"(e.g., the BSDs and Solaris) provide a similar feature."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:180
msgid ""
"Since the filesystems on which extended attributes are stored might also be "
"used on architectures with a different byte order and machine word size, "
"care should be taken to store attribute values in an "
"architecture-independent format."
msgstr ""

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@bestbits.at >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#. type: Plain text
#: build/C/man7/xattr.7:188
msgid "This page was formerly named B<attr>(5)."
msgstr ""

#. type: Plain text
#: build/C/man7/xattr.7:200
msgid ""
"B<attr>(1), B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), "
"B<ioctl_iflags>(2), B<listxattr>(2), B<removexattr>(2), B<setxattr>(2), "
"B<acl>(5), B<capabilities>(7), B<selinux>(8)"
msgstr ""
