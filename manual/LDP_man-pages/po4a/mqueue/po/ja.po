# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:30+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/mq_close.3:25
#, no-wrap
msgid "MQ_CLOSE"
msgstr "MQ_CLOSE"

#. type: TH
#: build/C/man3/mq_close.3:25 build/C/man2/mq_getsetattr.2:25
#: build/C/man3/mq_open.3:25 build/C/man3/mq_receive.3:25
#: build/C/man3/mq_send.3:25 build/C/man3/mq_unlink.3:25
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: TH
#: build/C/man3/mq_close.3:25 build/C/man3/mq_getattr.3:25
#: build/C/man2/mq_getsetattr.2:25 build/C/man3/mq_notify.3:25
#: build/C/man3/mq_open.3:25 build/C/man7/mq_overview.7:25
#: build/C/man3/mq_receive.3:25 build/C/man3/mq_send.3:25
#: build/C/man3/mq_unlink.3:25 build/C/man2/msgctl.2:38
#: build/C/man2/msgget.2:35 build/C/man2/msgop.2:40
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/mq_close.3:25 build/C/man3/mq_getattr.3:25
#: build/C/man2/mq_getsetattr.2:25 build/C/man3/mq_notify.3:25
#: build/C/man3/mq_open.3:25 build/C/man7/mq_overview.7:25
#: build/C/man3/mq_receive.3:25 build/C/man3/mq_send.3:25
#: build/C/man3/mq_unlink.3:25 build/C/man2/msgctl.2:38
#: build/C/man2/msgget.2:35 build/C/man2/msgop.2:40
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/mq_close.3:26 build/C/man3/mq_getattr.3:26
#: build/C/man2/mq_getsetattr.2:26 build/C/man3/mq_notify.3:26
#: build/C/man3/mq_open.3:26 build/C/man7/mq_overview.7:26
#: build/C/man3/mq_receive.3:26 build/C/man3/mq_send.3:26
#: build/C/man3/mq_unlink.3:26 build/C/man2/msgctl.2:39
#: build/C/man2/msgget.2:36 build/C/man2/msgop.2:41
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/mq_close.3:28
msgid "mq_close - close a message queue descriptor"
msgstr "mq_close - メッセージキュー記述子をクローズする"

#. type: SH
#: build/C/man3/mq_close.3:28 build/C/man3/mq_getattr.3:28
#: build/C/man2/mq_getsetattr.2:28 build/C/man3/mq_notify.3:28
#: build/C/man3/mq_open.3:28 build/C/man3/mq_receive.3:28
#: build/C/man3/mq_send.3:28 build/C/man3/mq_unlink.3:28
#: build/C/man2/msgctl.2:41 build/C/man2/msgget.2:38 build/C/man2/msgop.2:43
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/mq_close.3:31 build/C/man3/mq_getattr.3:31
#: build/C/man3/mq_notify.3:31 build/C/man3/mq_receive.3:31
#: build/C/man3/mq_send.3:31 build/C/man3/mq_unlink.3:31
#, no-wrap
msgid "B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_close.3:33
#, no-wrap
msgid "B<int mq_close(mqd_t >I<mqdes>B<);>\n"
msgstr "B<int mq_close(mqd_t >I<mqdes>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_close.3:36 build/C/man3/mq_getattr.3:39
#: build/C/man3/mq_notify.3:36 build/C/man3/mq_open.3:40
#: build/C/man3/mq_receive.3:44 build/C/man3/mq_send.3:44
#: build/C/man3/mq_unlink.3:36
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: SH
#: build/C/man3/mq_close.3:36 build/C/man3/mq_getattr.3:39
#: build/C/man2/mq_getsetattr.2:39 build/C/man3/mq_notify.3:36
#: build/C/man3/mq_open.3:40 build/C/man7/mq_overview.7:28
#: build/C/man3/mq_receive.3:56 build/C/man3/mq_send.3:56
#: build/C/man3/mq_unlink.3:36 build/C/man2/msgctl.2:49
#: build/C/man2/msgget.2:46 build/C/man2/msgop.2:56
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/mq_close.3:40
msgid "B<mq_close>()  closes the message queue descriptor I<mqdes>."
msgstr ""
"B<mq_close>()  はメッセージキュー記述子 (message queue descriptor)  I<mqdes> "
"をクローズする。"

#. type: Plain text
#: build/C/man3/mq_close.3:47
msgid ""
"If the calling process has attached a notification request (see "
"(B<mq_notify>(3))  to this message queue via I<mqdes>, then this request is "
"removed, and another process can now attach a notification request."
msgstr "呼び出し元のプロセスが I<mqdes> 経由でこのメッセージキューに通知要求 (notification request; B<mq_notify>(3) 参照) を設定している場合、通知要求は削除され、他のプロセスがそのキューに 対して通知要求を設定できるようになる。"

#. type: SH
#: build/C/man3/mq_close.3:47 build/C/man3/mq_getattr.3:117
#: build/C/man3/mq_notify.3:133 build/C/man3/mq_open.3:157
#: build/C/man3/mq_receive.3:111 build/C/man3/mq_send.3:120
#: build/C/man3/mq_unlink.3:43 build/C/man2/msgctl.2:308
#: build/C/man2/msgget.2:146 build/C/man2/msgop.2:338
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/mq_close.3:53
msgid ""
"On success B<mq_close>()  returns 0; on error, -1 is returned, with I<errno> "
"set to indicate the error."
msgstr ""
"成功すると、 B<mq_close>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: SH
#: build/C/man3/mq_close.3:53 build/C/man3/mq_getattr.3:125
#: build/C/man3/mq_notify.3:139 build/C/man3/mq_open.3:169
#: build/C/man3/mq_receive.3:120 build/C/man3/mq_send.3:128
#: build/C/man3/mq_unlink.3:49 build/C/man2/msgctl.2:337
#: build/C/man2/msgget.2:152 build/C/man2/msgop.2:351
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/mq_close.3:54 build/C/man3/mq_getattr.3:126
#: build/C/man3/mq_notify.3:140 build/C/man3/mq_receive.3:127
#: build/C/man3/mq_send.3:135
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man3/mq_close.3:59 build/C/man3/mq_getattr.3:131
#: build/C/man3/mq_notify.3:145
msgid "The message queue descriptor specified in I<mqdes> is invalid."
msgstr "I<mqdes> に指定されたメッセージキュー記述子が不正である。"

#. type: SH
#: build/C/man3/mq_close.3:59 build/C/man3/mq_getattr.3:136
#: build/C/man3/mq_notify.3:173 build/C/man3/mq_open.3:269
#: build/C/man3/mq_receive.3:154 build/C/man3/mq_send.3:162
#: build/C/man3/mq_unlink.3:61
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/mq_close.3:62 build/C/man3/mq_getattr.3:139
#: build/C/man3/mq_notify.3:176 build/C/man3/mq_open.3:272
#: build/C/man3/mq_receive.3:157 build/C/man3/mq_send.3:165
#: build/C/man3/mq_unlink.3:64
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/mq_close.3:66 build/C/man3/mq_getattr.3:143
#: build/C/man3/mq_notify.3:180 build/C/man3/mq_open.3:276
#: build/C/man3/mq_receive.3:161 build/C/man3/mq_send.3:169
#: build/C/man3/mq_unlink.3:68
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/mq_close.3:66 build/C/man3/mq_getattr.3:143
#: build/C/man3/mq_notify.3:180 build/C/man3/mq_open.3:276
#: build/C/man3/mq_receive.3:161 build/C/man3/mq_send.3:169
#: build/C/man3/mq_unlink.3:68
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/mq_close.3:66 build/C/man3/mq_getattr.3:143
#: build/C/man3/mq_notify.3:180 build/C/man3/mq_open.3:276
#: build/C/man3/mq_receive.3:161 build/C/man3/mq_send.3:169
#: build/C/man3/mq_unlink.3:68
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/mq_close.3:69
#, no-wrap
msgid "B<mq_close>()"
msgstr "B<mq_close>()"

#. type: tbl table
#: build/C/man3/mq_close.3:69 build/C/man3/mq_getattr.3:147
#: build/C/man3/mq_notify.3:183 build/C/man3/mq_open.3:279
#: build/C/man3/mq_receive.3:165 build/C/man3/mq_send.3:173
#: build/C/man3/mq_unlink.3:71
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/mq_close.3:69 build/C/man3/mq_getattr.3:147
#: build/C/man3/mq_notify.3:183 build/C/man3/mq_open.3:279
#: build/C/man3/mq_receive.3:165 build/C/man3/mq_send.3:173
#: build/C/man3/mq_unlink.3:71
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/mq_close.3:71 build/C/man3/mq_getattr.3:149
#: build/C/man2/mq_getsetattr.2:49 build/C/man3/mq_notify.3:186
#: build/C/man3/mq_open.3:281 build/C/man3/mq_receive.3:167
#: build/C/man3/mq_send.3:175 build/C/man3/mq_unlink.3:73
#: build/C/man2/msgctl.2:408 build/C/man2/msgget.2:191 build/C/man2/msgop.2:478
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/mq_close.3:73 build/C/man3/mq_getattr.3:151
#: build/C/man3/mq_open.3:283 build/C/man3/mq_receive.3:169
#: build/C/man3/mq_send.3:177 build/C/man3/mq_unlink.3:75
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: SH
#: build/C/man3/mq_close.3:73 build/C/man3/mq_getattr.3:151
#: build/C/man2/mq_getsetattr.2:51 build/C/man3/mq_notify.3:188
#: build/C/man3/mq_open.3:283 build/C/man7/mq_overview.7:356
#: build/C/man3/mq_receive.3:169 build/C/man3/mq_send.3:177
#: build/C/man2/msgctl.2:411 build/C/man2/msgget.2:193 build/C/man2/msgop.2:490
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/mq_close.3:77
msgid ""
"All open message queues are automatically closed on process termination, or "
"upon B<execve>(2)."
msgstr ""
"プロセス終了時、もしくは B<execve>(2)  実行時に、全てのオープンされたメッセー"
"ジキューは自動的にクローズされる。"

#. type: SH
#: build/C/man3/mq_close.3:77 build/C/man3/mq_getattr.3:235
#: build/C/man2/mq_getsetattr.2:55 build/C/man3/mq_notify.3:277
#: build/C/man3/mq_open.3:305 build/C/man7/mq_overview.7:395
#: build/C/man3/mq_receive.3:175 build/C/man3/mq_send.3:183
#: build/C/man3/mq_unlink.3:75 build/C/man2/msgctl.2:450
#: build/C/man2/msgget.2:242 build/C/man2/msgop.2:714
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/mq_close.3:85
msgid ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: SH
#: build/C/man3/mq_close.3:85 build/C/man3/mq_getattr.3:243
#: build/C/man2/mq_getsetattr.2:58 build/C/man3/mq_notify.3:286
#: build/C/man3/mq_open.3:313 build/C/man7/mq_overview.7:409
#: build/C/man3/mq_receive.3:184 build/C/man3/mq_send.3:192
#: build/C/man3/mq_unlink.3:83 build/C/man2/msgctl.2:457
#: build/C/man2/msgget.2:250 build/C/man2/msgop.2:720
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/mq_close.3:93 build/C/man3/mq_getattr.3:251
#: build/C/man2/mq_getsetattr.2:66 build/C/man3/mq_notify.3:294
#: build/C/man3/mq_open.3:321 build/C/man7/mq_overview.7:417
#: build/C/man3/mq_receive.3:192 build/C/man3/mq_send.3:200
#: build/C/man3/mq_unlink.3:91 build/C/man2/msgctl.2:465
#: build/C/man2/msgget.2:258 build/C/man2/msgop.2:728
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/mq_getattr.3:25
#, no-wrap
msgid "MQ_GETATTR"
msgstr "MQ_GETATTR"

#. type: TH
#: build/C/man3/mq_getattr.3:25 build/C/man3/mq_notify.3:25
#: build/C/man7/mq_overview.7:25
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/mq_getattr.3:28
msgid "mq_getattr, mq_setattr - get/set message queue attributes"
msgstr "mq_getattr, mq_setattr - メッセージキューの属性を設定/取得する"

#. type: Plain text
#: build/C/man3/mq_getattr.3:33
#, no-wrap
msgid "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"
msgstr "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:36
#, no-wrap
msgid ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:46
msgid ""
"B<mq_getattr>()  and B<mq_setattr>()  respectively retrieve and modify "
"attributes of the message queue referred to by the message queue descriptor "
"I<mqdes>."
msgstr "B<mq_getattr>()  と B<mq_setattr>()  は、メッセージキュー記述子 I<mqdes> で参照されるメッセージキューの属性の取得と変更をそれぞれ行う。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:53
msgid ""
"B<mq_getattr>()  returns an I<mq_attr> structure in the buffer pointed by "
"I<attr>.  This structure is defined as:"
msgstr ""
"B<mq_getattr>()  は、 I<attr> が指すバッファーに I<mq_attr> 構造体を格納して"
"返す。この構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/mq_getattr.3:62
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags: 0 or O_NONBLOCK */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue */\n"
"};\n"
msgstr ""
"struct mq_attr {\n"
"    long mq_flags;       /* フラグ: 0 か O_NONBLOCK */\n"
"    long mq_maxmsg;      /* キューの最大メッセージ数 */\n"
"    long mq_msgsize;     /* 最大メッセージサイズ (バイト単位) */\n"
"    long mq_curmsgs;     /* キューに現在入っているメッセージ数 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:72
msgid ""
"The I<mq_flags> field contains flags associated with the open message queue "
"description.  This field is initialized when the queue is created by "
"B<mq_open>(3).  The only flag that can appear in this field is B<O_NONBLOCK>."
msgstr ""
"I<mq_flags> フィールドには、オープンメッセージキュー記述 (open message queue "
"description) に関連付けられているフラグが格納される。 このフィールドは "
"B<mq_open>(3)  でキューが作成される際に初期化される。 このフィールドに現れる"
"フラグは B<O_NONBLOCK> だけである。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:93
msgid ""
"The I<mq_maxmsg> and I<mq_msgsize> fields are set when the message queue is "
"created by B<mq_open>(3).  The I<mq_maxmsg> field is an upper limit on the "
"number of messages that may be placed on the queue using B<mq_send>(3).  The "
"I<mq_msgsize> field is an upper limit on the size of messages that may be "
"placed on the queue.  Both of these fields must have a value greater than "
"zero.  Two I</proc> files that place ceilings on the values for these fields "
"are described in B<mq_overview>(7)."
msgstr ""
"I<mq_maxmsg> と I<mq_msgsize> フィールドは B<mq_open>(3)  でメッセージキュー"
"が作成される際にセットされる。 I<mq_maxmsg> フィールドは、 B<mq_send>(3)  を"
"使ってキューに入れることができるメッセージ数の上限である。 I<mq_msgsize> "
"フィールドは、キューに入れることができるメッセージの 上限サイズである。 これ"
"らのフィールドはどちらも 0 より大きな値でなければならない。 これらのフィール"
"ドに設定できる値の上限は I</proc> ファイルにより決まる。 I</proc> ファイルの"
"詳細は B<mq_overview>(7)  に説明されている。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:97
msgid ""
"The I<mq_curmsgs> field returns the number of messages currently held in the "
"queue."
msgstr ""
"I<mq_curmsgs> フィールドはキューに現在格納されているメッセージ数を返す。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:117
msgid ""
"B<mq_setattr>()  sets message queue attributes using information supplied in "
"the I<mq_attr> structure pointed to by I<newattr>.  The only attribute that "
"can be modified is the setting of the B<O_NONBLOCK> flag in I<mq_flags>.  "
"The other fields in I<newattr> are ignored.  If the I<oldattr> field is not "
"NULL, then the buffer that it points to is used to return an I<mq_attr> "
"structure that contains the same information that is returned by "
"B<mq_getattr>()."
msgstr ""
"B<mq_setattr>()  は、 I<newattr> が指す I<mq_attr> 構造体で与えられた情報を"
"使って、メッセージキューの属性を設定する。 変更することができる属性は、 "
"I<mq_flags> の B<O_NONBLOCK> フラグの設定だけである。 I<newattr> の他のフィー"
"ルドは無視される。 I<oldattr> フィールドが NULL 以外の場合、 "
"B<mq_getattr>()  が返すのと同じ情報を格納した I<mq_attr> 構造体を I<oldattr> "
"が指すバッファーに入れて返す。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:125
msgid ""
"On success B<mq_getattr>()  and B<mq_setattr>()  return 0; on error, -1 is "
"returned, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 I<mq_getattr ()> と I<mq_setattr ()> は 0 を返す。エラーの場"
"合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/mq_getattr.3:131 build/C/man3/mq_notify.3:149
#: build/C/man3/mq_open.3:190 build/C/man3/mq_open.3:197
#: build/C/man3/mq_receive.3:136 build/C/man3/mq_send.3:144
#: build/C/man2/msgctl.2:368 build/C/man2/msgop.2:382 build/C/man2/msgop.2:432
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/mq_getattr.3:136
msgid "I<newattr-E<gt>mq_flags> contained set bits other than B<O_NONBLOCK>."
msgstr ""
"I<newattr-E<gt>mq_flags> に B<O_NONBLOCK> 以外のビットがセットされていた。"

#. type: tbl table
#: build/C/man3/mq_getattr.3:147
#, no-wrap
msgid ""
"B<mq_getattr>(),\n"
"B<mq_setattr>()"
msgstr ""
"B<mq_getattr>(),\n"
"B<mq_setattr>()"

#. type: Plain text
#: build/C/man3/mq_getattr.3:159
msgid ""
"On Linux, B<mq_getattr>()  and B<mq_setattr>()  are library functions "
"layered on top of the B<mq_getsetattr>(2)  system call."
msgstr ""
"Linux では、 B<mq_getattr>()  と B<mq_setattr>()  はライブラリ関数であり、 "
"B<mq_getsetattr>(2)  システムコールを用いて実装されている。"

#. type: SH
#: build/C/man3/mq_getattr.3:159 build/C/man3/mq_notify.3:210
#: build/C/man7/mq_overview.7:392 build/C/man2/msgop.2:577
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/mq_getattr.3:170
msgid ""
"The program below can be used to show the default I<mq_maxmsg> and "
"I<mq_msgsize> values that are assigned to a message queue that is created "
"with a call to B<mq_open>(3)  in which the I<attr> argument is NULL.  Here "
"is an example run of the program:"
msgstr ""
"下記のプログラムを使うと、 I<attr> 引数に NULL を指定して B<mq_open>(3) を"
"呼び出した際に作成されるメッセージキューに割り当てられるデフォルトの "
"I<mq_maxmsg> と I<mq_msgsize> の値を表示できる。 このプログラムの実行例を以下"
"に示す。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:176
#, no-wrap
msgid ""
"$ B<./a.out /testq>\n"
"Maximum # of messages on queue:   10\n"
"Maximum message size:             8192\n"
msgstr ""
"$ B<./a.out /testq>\n"
"Maximum # of messages on queue:   10\n"
"Maximum message size:             8192\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:184
msgid ""
"Since Linux 3.5, the following I</proc> files (described in "
"B<mq_overview>(7))  can be used to control the defaults:"
msgstr ""
"Linux 3.5 以降では、 (B<mq_overview>(7) に説明がある) 以下の I</proc> ファイ"
"ルを使ってデフォルト値を制御できる。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:193
#, no-wrap
msgid ""
"$ B<uname -sr>\n"
"Linux 3.8.0\n"
"$ B<cat /proc/sys/fs/mqueue/msg_default>\n"
"10\n"
"$ B<cat /proc/sys/fs/mqueue/msgsize_default>\n"
"8192\n"
msgstr ""
"$ B<uname -sr>\n"
"Linux 3.8.0\n"
"$ B<cat /proc/sys/fs/mqueue/msg_default>\n"
"10\n"
"$ B<cat /proc/sys/fs/mqueue/msgsize_default>\n"
"8192\n"

#. type: SS
#: build/C/man3/mq_getattr.3:195 build/C/man3/mq_notify.3:216
#: build/C/man2/msgop.2:598
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/mq_getattr.3:204
#, no-wrap
msgid ""
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:207
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:213
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqd;\n"
"    struct mq_attr attr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqd;\n"
"    struct mq_attr attr;\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:218
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s mq-name\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s mq-name\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:222
#, no-wrap
msgid ""
"    mqd = mq_open(argv[1], O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL);\n"
"    if (mqd == (mqd_t) -1)\n"
"        errExit(\"mq_open\");\n"
msgstr ""
"    mqd = mq_open(argv[1], O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL);\n"
"    if (mqd == (mqd_t) -1)\n"
"        errExit(\"mq_open\");\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:225
#, no-wrap
msgid ""
"    if (mq_getattr(mqd, &attr) == -1)\n"
"        errExit(\"mq_getattr\");\n"
msgstr ""
"    if (mq_getattr(mqd, &attr) == -1)\n"
"        errExit(\"mq_getattr\");\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:228
#, no-wrap
msgid ""
"    printf(\"Maximum # of messages on queue:   %ld\\en\", attr.mq_maxmsg);\n"
"    printf(\"Maximum message size:             %ld\\en\", attr.mq_msgsize);\n"
msgstr ""
"    printf(\"Maximum # of messages on queue:   %ld\\en\", attr.mq_maxmsg);\n"
"    printf(\"Maximum message size:             %ld\\en\", attr.mq_msgsize);\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:231
#, no-wrap
msgid ""
"    if (mq_unlink(argv[1]) == -1)\n"
"        errExit(\"mq_unlink\");\n"
msgstr ""
"    if (mq_unlink(argv[1]) == -1)\n"
"        errExit(\"mq_unlink\");\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:234 build/C/man2/msgop.2:713
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:243
msgid ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man2/mq_getsetattr.2:25
#, no-wrap
msgid "MQ_GETSETATTR"
msgstr "MQ_GETSETATTR"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:28
msgid "mq_getsetattr - get/set message queue attributes"
msgstr "mq_getsetattr - メッセージキューの属性を設定/取得する"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:35
#, no-wrap
msgid ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:41
msgid "Do not use this system call."
msgstr "このシステムコールを使用しないこと。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:49
msgid ""
"This is the low-level system call used to implement B<mq_getattr>(3)  and "
"B<mq_setattr>(3).  For an explanation of how this system call operates, see "
"the description of B<mq_setattr>(3)."
msgstr ""
"B<mq_getattr>(3)  と B<mq_setattr>(3)  の実装に使用される低レベルのシステム"
"コールである。 このシステムコールがどのように動作するかは B<mq_setattr>(3)  "
"の説明を参照のこと。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:51
msgid "This interface is nonstandard; avoid its use."
msgstr "このインターフェースは非標準である。使用を避けること。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:55
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  (Actually, never call it unless you are writing a C library!)"
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。 (実のところ、C ライブラリを書いているの"
"でない限り、 決してこのシステムコールを呼び出さないこと!)"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:58
msgid "B<mq_getattr>(3), B<mq_overview>(7)"
msgstr "B<mq_getattr>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man3/mq_notify.3:25
#, no-wrap
msgid "MQ_NOTIFY"
msgstr "MQ_NOTIFY"

#. type: Plain text
#: build/C/man3/mq_notify.3:28
msgid "mq_notify - register for notification when a message is available"
msgstr "mq_notify - メッセージ到着時に通知を行うよう登録する"

#. type: Plain text
#: build/C/man3/mq_notify.3:33
#, no-wrap
msgid "B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<sevp>B<);>\n"
msgstr "B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<notification>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:42
msgid ""
"B<mq_notify>()  allows the calling process to register or unregister for "
"delivery of an asynchronous notification when a new message arrives on the "
"empty message queue referred to by the message queue descriptor I<mqdes>."
msgstr "B<mq_notify>()  を使うと、メッセージキューディスクリプター I<mqdes> で参照される空のメッセージキューに新しくメッセージが到着した時に 非同期の通知 (notification) の配送が行われるように登録したり、 その解除を行ったりできる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:50
msgid ""
"The I<sevp> argument is a pointer to a I<sigevent> structure.  For the "
"definition and general details of this structure, see B<sigevent>(7)."
msgstr ""
"I<sevp> 引数は I<sigevent> 構造体へのポインターである。 この構造体の定義と"
"一般的な詳細については B<sigevent>(7)  を参照。"

#. type: Plain text
#: build/C/man3/mq_notify.3:64
msgid ""
"If I<sevp> is a non-null pointer, then B<mq_notify>()  registers the calling "
"process to receive message notification.  The I<sigev_notify> field of the "
"I<sigevent> structure to which I<sevp> points specifies how notification is "
"to be performed.  This field has one of the following values:"
msgstr ""
"I<sevp> が NULL でないポインターであれば、 B<mq_notify>()  はメッセージ通知を"
"受け取るように呼び出し元のプロセスを登録する。 I<sevp> が指す I<sigevent> 構"
"造体の I<sigev_notify> フィールドは、どのような通知を行うのかを指定する。 こ"
"のフィールドは以下の値のいずれかを持つ。"

#. type: TP
#: build/C/man3/mq_notify.3:64
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#.  When is SIGEV_NONE useful?
#. type: Plain text
#: build/C/man3/mq_notify.3:69
msgid ""
"A \"null\" notification: the calling process is registered as the target for "
"notification, but when a message arrives, no notification is sent."
msgstr ""
"「空の (null)」の通知: 呼び出し元のプロセスを通知の宛先として登録するが、 実"
"際にはメッセージが到着した時に通知は送られない。"

#. type: TP
#: build/C/man3/mq_notify.3:69
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  I don't know of other implementations that set
#.  si_pid and si_uid -- MTK
#. type: Plain text
#: build/C/man3/mq_notify.3:89
msgid ""
"Notify the process by sending the signal specified in I<sigev_signo>.  See "
"B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_MESGQ>.  In addition, I<si_pid> "
"will be set to the PID of the process that sent the message, and I<si_uid> "
"will be set to the real user ID of the sending process."
msgstr ""
"I<sigev_signo> で指定されたシグナルを送って、プロセスに通知する。 一般的な詳"
"細については B<sigevent>(7)  を参照。 I<siginfo_t> 構造体の I<si_code> フィー"
"ルドには B<SI_MESGQ> が設定される。 さらに、 I<si_pid> にはメッセージを送信し"
"たプロセスの PID が、 I<si_uid> には送信プロセスの実ユーザー ID が設定され"
"る。"

#. type: TP
#: build/C/man3/mq_notify.3:89
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man3/mq_notify.3:97
msgid ""
"Upon message delivery, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""
"メッセージの配送時には、 I<sigev_notify_function> があたかも新しいスレッドの"
"開始関数であるかのように起動される。 詳細は B<sigevent>(7)  を参照。"

#. type: Plain text
#: build/C/man3/mq_notify.3:100
msgid ""
"Only one process can be registered to receive notification from a message "
"queue."
msgstr ""
"一つのメッセージキューから通知を受信するように登録できるプロセスは 一つだけで"
"ある。"

#. type: Plain text
#: build/C/man3/mq_notify.3:107
msgid ""
"If I<sevp> is NULL, and the calling process is currently registered to "
"receive notifications for this message queue, then the registration is "
"removed; another process can then register to receive a message notification "
"for this queue."
msgstr ""
"I<sevp> が NULL で、かつ呼び出し元のプロセスがこのメッセージキューからの 通知"
"を受信するに現在登録している場合、登録を削除する。 これ以降、別のプロセスがこ"
"のメッセージキューから通知を受信するように 登録できるようになる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:114
msgid ""
"Message notification occurs only when a new message arrives and the queue "
"was previously empty.  If the queue was not empty at the time "
"B<mq_notify>()  was called, then a notification will occur only after the "
"queue is emptied and a new message arrives."
msgstr ""
"メッセージ通知は、それまで空のキューに新しいメッセージが到着した 場合にのみ行"
"われる。 B<mq_notify>()  が呼び出された時にそのキューが空でない場合、 その"
"キューが空になり、その後新しいメッセージが到着した時に 初めて通知が行われるこ"
"とになる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:122
msgid ""
"If another process or thread is waiting to read a message from an empty "
"queue using B<mq_receive>(3), then any message notification registration is "
"ignored: the message is delivered to the process or thread calling "
"B<mq_receive>(3), and the message notification registration remains in "
"effect."
msgstr ""
"別のプロセスやスレッドが B<mq_receive>(3)  を使って、空のキューからメッセージ"
"の読み出しを待っている場合、 メッセージ通知の登録は全て無視される。 メッセー"
"ジは B<mq_receive>(3)  を呼び出しているプロセスやスレッドに配送され、 メッ"
"セージ通知の登録は効力を持ったままとなる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:133
msgid ""
"Notification occurs once: after a notification is delivered, the "
"notification registration is removed, and another process can register for "
"message notification.  If the notified process wishes to receive the next "
"notification, it can use B<mq_notify>()  to request a further notification.  "
"This should be done before emptying all unread messages from the queue.  "
"(Placing the queue in nonblocking mode is useful for emptying the queue of "
"messages without blocking once it is empty.)"
msgstr ""
"通知は一度だけ行われる。通知が送られた後は、通知要求の登録は削除され、 別のプ"
"ロセスがメッセージ通知を受信するように登録できるようになる。 通知を受けたプロ"
"セスが次の通知も受信したい場合は、 B<mq_notify>()  を使ってその後の通知も受け"
"るように要求することができる。 B<mq_notify>()  を再度呼び出すのは、読み出して"
"いないメッセージを全部読み出して キューが空になる前にすべきである (キューから"
"のメッセージ読み出しをキューが空になった時に 停止 (block) せずに行うには、"
"キューを非停止モード (non-blocking mode)  に設定しておくとよい)。"

#. type: Plain text
#: build/C/man3/mq_notify.3:139
msgid ""
"On success B<mq_notify>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_notify>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"をエラーを示す値に設定する。"

#. type: TP
#: build/C/man3/mq_notify.3:145
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man3/mq_notify.3:149
msgid ""
"Another process has already registered to receive notification for this "
"message queue."
msgstr ""
"別のプロセスがすでに このメッセージキューに対する通知を受信するように登録して"
"いる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:159
msgid ""
"I<sevp-E<gt>sigev_notify> is not one of the permitted values; or I<sevp-"
"E<gt>sigev_notify> is B<SIGEV_SIGNAL> and I<sevp-E<gt>sigev_signo> is not a "
"valid signal number."
msgstr ""
"I<sevp-E<gt>sigev_notify> が許可された値のいずれでもない。もしくは I<sevp-"
"E<gt>sigev_notify> が B<SIGEV_SIGNAL> だが I<sevp-E<gt>sigev_signo> が有効な"
"シグナル番号ではない。"

#. type: TP
#: build/C/man3/mq_notify.3:159 build/C/man3/mq_open.3:259
#: build/C/man2/msgget.2:181 build/C/man2/msgop.2:393
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/mq_notify.3:162 build/C/man3/mq_open.3:262
msgid "Insufficient memory."
msgstr "十分なメモリーがない。"

#.  Linux does not do this
#. type: Plain text
#: build/C/man3/mq_notify.3:173
msgid ""
"POSIX.1-2008 says that an implementation I<may> generate an B<EINVAL> error "
"if I<sevp> is NULL, and the caller is not currently registered to receive "
"notifications for the queue I<mqdes>."
msgstr ""
"POSIX.1-2008 では、 I<sevp> が NULL で、呼び出し元のプロセスがキュー "
"I<mqdes> に関する通知を受信するように登録されていない場合、エラー B<EINVAL> "
"を生成するような実装を行っても「よい」ことになっている。"

#. type: tbl table
#: build/C/man3/mq_notify.3:183
#, no-wrap
msgid "B<mq_notify>()"
msgstr "B<mq_notify>()"

#. type: Plain text
#: build/C/man3/mq_notify.3:188
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: SS
#: build/C/man3/mq_notify.3:190 build/C/man3/mq_open.3:284
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man3/mq_notify.3:210
msgid ""
"In the glibc implementation, the B<mq_notify>()  library function is "
"implemented on top of the system call of the same name.  When I<sevp> is "
"NULL, or specifies a notification mechanism other than B<SIGEV_THREAD>, the "
"library function directly invokes the system call.  For B<SIGEV_THREAD>, "
"much of the implementation resides within the library, rather than the "
"kernel.  (This is necessarily so, since the thread involved in handling the "
"notification is one that must be managed by the C library POSIX threads "
"implementation.)  The implementation involves the use of a raw "
"B<netlink>(7)  socket and creates a new thread for each notification that is "
"delivered to the process."
msgstr ""

#. type: Plain text
#: build/C/man3/mq_notify.3:216
msgid ""
"The following program registers a notification request for the message queue "
"named in its command-line argument.  Notification is performed by creating a "
"thread.  The thread executes a function which reads one message from the "
"queue and then terminates the process."
msgstr ""
"以下のプログラムは、 コマンドライン引数で指定された名前のメッセージキューへ"
"の 通知要求を登録し、通知はスレッドの作成によって行われる。 そのスレッドは、"
"そのキューからメッセージを一つ読み出してから、 プロセスを終了する関数を実行す"
"る。"

#. type: Plain text
#: build/C/man3/mq_notify.3:223
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:226
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:234
#, no-wrap
msgid ""
"static void                     /* Thread start function */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"
msgstr ""
"static void                     /* スレッド開始関数 */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:236
#, no-wrap
msgid "    /* Determine max. msg size; allocate buffer to receive msg */\n"
msgstr ""
"    /* 最大メッセージサイズを決定し、\n"
"       メッセージ受信用のバッファーを確保する */\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:242
#, no-wrap
msgid ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"
msgstr ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:246
#, no-wrap
msgid ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"
msgstr ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:251
#, no-wrap
msgid ""
"    printf(\"Read %zd bytes from MQ\\en\", nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* Terminate the process */\n"
"}\n"
msgstr ""
"    printf(\"Read %zd bytes from MQ\\en\", nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* プロセスを終了する */\n"
"}\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:257
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:262
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:266
#, no-wrap
msgid ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"
msgstr ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:273
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"
msgstr ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* スレッド関数に渡す引数 */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:276
#, no-wrap
msgid ""
"    pause();    /* Process will be terminated by thread function */\n"
"}\n"
msgstr ""
"    pause();    /* プロセスはスレッド関数により終了される */\n"
"}\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:286
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"

#. type: TH
#: build/C/man3/mq_open.3:25
#, no-wrap
msgid "MQ_OPEN"
msgstr "MQ_OPEN"

#. type: Plain text
#: build/C/man3/mq_open.3:28
msgid "mq_open - open a message queue"
msgstr "mq_open - メッセージキューをオープンする"

#. type: Plain text
#: build/C/man3/mq_open.3:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_open.3:37
#, no-wrap
msgid ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"
msgstr ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_open.3:49
msgid ""
"B<mq_open>()  creates a new POSIX message queue or opens an existing queue.  "
"The queue is identified by I<name>.  For details of the construction of "
"I<name>, see B<mq_overview>(7)."
msgstr ""
"B<mq_open>()  は、新しい POSIX メッセージキューを作成するか、既存のキューを "
"オープンする。キューは I<name> で識別される。 I<name> の構成の詳細については "
"B<mq_overview (7)> を参照。"

#. type: Plain text
#: build/C/man3/mq_open.3:57
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  Exactly one of the following must be specified in "
"I<oflag>:"
msgstr ""
"I<oflag> 引数には、関数呼び出しの操作を制御するフラグを指定する (oflag の値"
"の定義は I<E<lt>fcntl.hE<gt>> のインクルードにより得られる)。 I<oflag> には、"
"以下のうちいずれか一つを必ず指定しなければならない。"

#. type: TP
#: build/C/man3/mq_open.3:57
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: build/C/man3/mq_open.3:60
msgid "Open the queue to receive messages only."
msgstr "メッセージの受信専用としてキューをオープンする。"

#. type: TP
#: build/C/man3/mq_open.3:60
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: build/C/man3/mq_open.3:63
msgid "Open the queue to send messages only."
msgstr "メッセージの送信専用としてキューをオープンする。"

#. type: TP
#: build/C/man3/mq_open.3:63
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: build/C/man3/mq_open.3:66
msgid "Open the queue to both send and receive messages."
msgstr "メッセージの送受信両用としてキューをオープンする。"

#. type: Plain text
#: build/C/man3/mq_open.3:71
msgid ""
"Zero or more of the following flags can additionally be I<OR>ed in I<oflag>:"
msgstr ""
"0 個以上の下記のフラグを、ビット単位の OR (論理和) で I<oflag> に追加で指定で"
"きる。"

#. type: TP
#: build/C/man3/mq_open.3:71
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.26)"
msgstr "B<O_CLOEXEC> (Linux 2.6.26 以降)"

#.  commit 269f21344b23e552c21c9e2d7ca258479dcd7a0a
#. type: Plain text
#: build/C/man3/mq_open.3:78
msgid ""
"Set the close-on-exec flag for the message queue descriptor.  See "
"B<open>(2)  for a discussion of why this flag is useful."
msgstr ""
"メッセージキュー記述子に close-on-exec フラグをセットする。 なぜこのフラグが"
"有用かについての議論は B<open>(2) を参照。"

#. type: TP
#: build/C/man3/mq_open.3:78
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: build/C/man3/mq_open.3:86
msgid ""
"Create the message queue if it does not exist.  The owner (user ID) of the "
"message queue is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process."
msgstr ""
"存在しない場合、メッセージキューを作成する。 メッセージキューの所有者 (ユー"
"ザー ID) とグループ所有権 (グループ ID) は、 それぞれ呼び出し元プロセスの実効"
"ユーザー ID と実効グループ ID に設定される。"

#. type: TP
#: build/C/man3/mq_open.3:86
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man3/mq_open.3:96
msgid ""
"If B<O_CREAT> was specified in I<oflag>, and a queue with the given I<name> "
"already exists, then fail with the error B<EEXIST>."
msgstr ""
"B<O_CREAT> が I<oflag> に指定され、かつ指定された名前 I<name> を持つキューが"
"すでに存在する場合、エラー B<EEXIST> で失敗する。"

#. type: TP
#: build/C/man3/mq_open.3:96
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: build/C/man3/mq_open.3:105
msgid ""
"Open the queue in nonblocking mode.  In circumstances where "
"B<mq_receive>(3)  and B<mq_send>(3)  would normally block, these functions "
"instead fail with the error B<EAGAIN>."
msgstr ""
"非停止 (nonblocking) モードでキューをオープンする。 B<mq_receive>(3)  と "
"B<mq_send>(3)  は、通常は停止 (block) する状況において、エラー B<EAGAIN> で失"
"敗するようになる。"

#. type: Plain text
#: build/C/man3/mq_open.3:119
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on "
"the new queue, as for B<open>(2).  (Symbolic definitions for the permissions "
"bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The permissions "
"settings are masked against the process umask."
msgstr ""
"I<oflag> に B<O_CREAT> を指定する場合、追加で 2つの引数を与える必要があ"
"る。 I<mode> 引数は、新しいキューに適用される許可設定 (permission) を、 "
"B<open>(2)  と同じように指定する (許可ビットのシンボル定義は I<E<lt>sys/stat."
"hE<gt>> のインクルードにより得られる)。 許可設定はプロセスの umask でマスクさ"
"れる。"

#. type: Plain text
#: build/C/man3/mq_open.3:127
msgid ""
"The fields of the I<struct mq_attr> pointed to I<attr> specify the maximum "
"number of messages and the maximum size of messages that the queue will "
"allow.  This structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/mq_open.3:137
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags (ignored for mq_open()) */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue\n"
"                            (ignored for mq_open()) */\n"
"};\n"
msgstr ""
"struct mq_attr {\n"
"    long mq_flags;       /* フラグ (mq_open() では無視される) */\n"
"    long mq_maxmsg;      /* キューの最大メッセージ数 */\n"
"    long mq_msgsize;     /* 最大メッセージサイズ (バイト単位) */\n"
"    long mq_curmsgs;     /* キューに現在入っているメッセージ数\n"
"                            (mq_open() では無視される) */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mq_open.3:147
msgid ""
"Only the I<mq_maxmsg> and I<mq_msgsize> fields are employed when calling "
"B<mq_open>(); the values in the remaining fields are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mq_open.3:157
msgid ""
"If I<attr> is NULL, then the queue is created with implementation-defined "
"default attributes.  Since Linux 3.5, two I</proc> files can be used to "
"control these defaults; see B<mq_overview>(7)  for details."
msgstr "I<attr> が NULL の場合、キューは実装で定義されたデフォルト属性で作成される。 Linux 3.5 以降では、2 つの I</proc> ファイルがあり、これらのデフォルト値を制御できる。 詳細は B<mq_overview>(7) を参照。"

#. type: Plain text
#: build/C/man3/mq_open.3:169
msgid ""
"On success, B<mq_open>()  returns a message queue descriptor for use by "
"other message queue functions.  On error, B<mq_open>()  returns I<(mqd_t)\\ "
"-1>, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_open>()  はメッセージキュー記述子 (message queue "
"descriptor) を返す。 メッセージキュー記述子は他のメッセージキュー関連の関数で"
"使用される。 エラーの場合、 B<mq_open>()  は I<(mqd_t)\\ -1> を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/mq_open.3:170 build/C/man3/mq_open.3:174
#: build/C/man3/mq_unlink.3:50 build/C/man2/msgctl.2:341
#: build/C/man2/msgget.2:156 build/C/man2/msgop.2:357 build/C/man2/msgop.2:412
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/mq_open.3:174
msgid ""
"The queue exists, but the caller does not have permission to open it in the "
"specified mode."
msgstr ""
"キューは存在するが、呼び出し元が指定されたモードでそのキュー をオープンする許"
"可を持たない。"

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: build/C/man3/mq_open.3:179
msgid "I<name> contained more than one slash."
msgstr "I<name> にスラッシュが 2 個以上含まれていた。"

#. type: TP
#: build/C/man3/mq_open.3:179 build/C/man2/msgget.2:164
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man3/mq_open.3:190
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a queue with "
"this I<name> already exists."
msgstr ""
"I<oflag> に B<O_CREAT> と B<O_EXCL> の両方が指定されたが、指定された名前 "
"I<name> を持つキューがすでに存在する。"

#.  glibc checks whether the name starts with a "/" and if not,
#.  gives this error
#. type: Plain text
#: build/C/man3/mq_open.3:197
msgid "I<name> doesn't follow the format in B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/mq_open.3:229
msgid ""
"B<O_CREAT> was specified in I<oflag>, and I<attr> was not NULL, but I<attr-"
"E<gt>mq_maxmsg> or I<attr-E<gt>mq_msqsize> was invalid.  Both of these "
"fields must be greater than zero.  In a process that is unprivileged (does "
"not have the B<CAP_SYS_RESOURCE> capability), I<attr-E<gt>mq_maxmsg> must be "
"less than or equal to the I<msg_max> limit, and I<attr-E<gt>mq_msgsize> must "
"be less than or equal to the I<msgsize_max> limit.  In addition, even in a "
"privileged process, I<attr-E<gt>mq_maxmsg> cannot exceed the B<HARD_MAX> "
"limit.  (See B<mq_overview>(7)  for details of these limits.)"
msgstr ""
"I<oflag> に B<O_CREAT> が指定され、かつ I<attr> が NULL 以外だが、 I<attr-"
"E<gt>mq_maxmsg> か I<attr-E<gt>mq_msqsize> が不正であった。 これらのフィール"
"ドは両方とも 0 より大きくなければならない。 プロセスが特権を持たない "
"(B<CAP_SYS_RESOURCE> ケーパビリティを持たない) 場合、 I<attr-E<gt>mq_maxmsg> "
"と I<attr-E<gt>mq_msgsize> は、それぞれ上限 I<msg_max>、 I<msgsize_max> 以下"
"でなければならない。 また、特権プロセスの場合でも、 I<attr-E<gt>mq_maxmsg> "
"は B<HARD_MAX> 上限を超えることはできない。 (これらの上限に関する詳細は "
"B<mq_overview>(7)  を参照。)"

#. type: TP
#: build/C/man3/mq_open.3:229
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man3/mq_open.3:237
#, fuzzy
#| msgid ""
#| "The system limit on the total number of open files and message queues has "
#| "been reached."
msgid ""
"The per-process limit on the number of open file and message queue "
"descriptors has been reached (see the description of B<RLIMIT_NOFILE> in "
"B<getrlimit>(2))."
msgstr ""
"システム全体でオープンしているファイルとメッセージキューの合計数が システム上"
"限に達している。"

#. type: TP
#: build/C/man3/mq_open.3:237 build/C/man3/mq_unlink.3:53
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/mq_open.3:241 build/C/man3/mq_unlink.3:57
msgid "I<name> was too long."
msgstr "I<name> が長過ぎる。"

#. type: TP
#: build/C/man3/mq_open.3:241
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man3/mq_open.3:245
msgid ""
"The system-wide limit on the total number of open files and message queues "
"has been reached."
msgstr "システム全体でオープンしているファイルとメッセージキューの合計数がシステム全体の上限に達している。"

#. type: TP
#: build/C/man3/mq_open.3:245 build/C/man3/mq_open.3:254
#: build/C/man3/mq_unlink.3:57 build/C/man2/msgget.2:173
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/mq_open.3:254
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag>, and no queue with this "
"I<name> exists."
msgstr ""
"B<O_CREAT> フラグが I<oflag> に指定されなかったが、指定された名前 I<name> を"
"持つキューが存在しない。"

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: build/C/man3/mq_open.3:259
msgid "I<name> was just \"/\" followed by no other characters."
msgstr "I<name> が \"/\" だけで、その後ろに他の文字が続いていなかった。"

#. type: TP
#: build/C/man3/mq_open.3:262 build/C/man2/msgget.2:185
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man3/mq_open.3:269
msgid ""
"Insufficient space for the creation of a new message queue.  This probably "
"occurred because the I<queues_max> limit was encountered; see "
"B<mq_overview>(7)."
msgstr ""
"新しいメッセージキューを作成するのに十分な空間がない。 このエラーはおそらく "
"I<queues_max> 上限に抵触したため起こったのだろう。 B<mq_overview>(7)  を参"
"照。"

#. type: tbl table
#: build/C/man3/mq_open.3:279
#, no-wrap
msgid "B<mq_open>()"
msgstr "B<mq_open>()"

#. type: Plain text
#: build/C/man3/mq_open.3:301
msgid ""
"The B<mq_open>()  library function is implemented on top of a system call of "
"the same name.  The library function performs the check that the I<name> "
"starts with a slash (/), giving the B<EINVAL> error if it does not.  The "
"kernel system call expects I<name> to contain no preceding slash, so the C "
"library function passes I<name> without the preceding slash (i.e., I<name"
"+1>)  to the system call."
msgstr ""

#. type: SH
#: build/C/man3/mq_open.3:301 build/C/man7/mq_overview.7:369
#: build/C/man2/msgget.2:236 build/C/man2/msgop.2:541
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/mq_open.3:305
msgid ""
"In kernels before 2.6.14, the process umask was not applied to the "
"permissions specified in I<mode>."
msgstr ""
"2.6.14 より前のカーネルには、 プロセスの umask が I<mode> で指定された許可設"
"定に適用されなかった。"

#. type: Plain text
#: build/C/man3/mq_open.3:313
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man7/mq_overview.7:25
#, no-wrap
msgid "MQ_OVERVIEW"
msgstr "MQ_OVERVIEW"

#. type: Plain text
#: build/C/man7/mq_overview.7:28
msgid "mq_overview - overview of POSIX message queues"
msgstr "mq_overview - POSIX メッセージキューの概要"

#. type: Plain text
#: build/C/man7/mq_overview.7:36
msgid ""
"POSIX message queues allow processes to exchange data in the form of "
"messages.  This API is distinct from that provided by System V message "
"queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.), but provides "
"similar functionality."
msgstr ""
"POSIX メッセージキューを使用すると、プロセス間で メッセージの形でのデータのや"
"り取りを行うことができる。 この API は System V メッセージキューの API "
"(B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2)  など) とは異なるものだが、同様の機"
"能を提供する。"

#. type: Plain text
#: build/C/man7/mq_overview.7:51
msgid ""
"Message queues are created and opened using B<mq_open>(3); this function "
"returns a I<message queue descriptor> (I<mqd_t>), which is used to refer to "
"the open message queue in later calls.  Each message queue is identified by "
"a name of the form I</somename>; that is, a null-terminated string of up to "
"B<NAME_MAX> (i.e., 255) characters consisting of an initial slash, followed "
"by one or more characters, none of which are slashes.  Two processes can "
"operate on the same queue by passing the same name to B<mq_open>(3)."
msgstr ""
"メッセージキューの作成とオープンは B<mq_open>(3)  を使って行う。この関数は I<"
"メッセージキュー記述子 (message queue descriptor)> (I<mqd_t>)  を返す。これ以"
"降のコールでは、オープンされたメッセージキューは I<メッセージキュー記述子> を"
"使って参照される。 各メッセージキューは I</somename> の形の名前で区別すること"
"ができる。 その名前は、最大で B<NAME_MAX> (すなわち 255) 文字のヌル終端された"
"文字列で、 スラッシュで始まり、スラッシュ以外の文字が 1 文字以上続く形式であ"
"る。 B<mq_open>(3)  に同じ名前を渡すことで、2つのプロセスで同一のキューを 操"
"作することができる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:67
msgid ""
"Messages are transferred to and from a queue using B<mq_send>(3)  and "
"B<mq_receive>(3).  When a process has finished using the queue, it closes it "
"using B<mq_close>(3), and when the queue is no longer required, it can be "
"deleted using B<mq_unlink>(3).  Queue attributes can be retrieved and (in "
"some cases) modified using B<mq_getattr>(3)  and B<mq_setattr>(3).  A "
"process can request asynchronous notification of the arrival of a message on "
"a previously empty queue using B<mq_notify>(3)."
msgstr ""
"メッセージのキューへの送受信は B<mq_send>(3)  と B<mq_receive>(3)  を使って行"
"う。プロセスがキューの使用を終えるときには、 B<mq_close>(3)  を使ってキューを"
"クローズする。キューがもはや不要となった場合には、 B<mq_unlink>(3)  を使って"
"キューを削除できる。キューの属性は B<mq_getattr>(3)  で取得でき、 (制限はある"
"が)  B<mq_setattr>(3)  で変更できる。 B<mq_notify>(3)  を使うことで、空の"
"キューへのメッセージ到着を非同期で 通知するように要求することもできる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:80
msgid ""
"A message queue descriptor is a reference to an I<open message queue "
"description> (see B<open>(2)).  After a B<fork>(2), a child inherits copies "
"of its parent's message queue descriptors, and these descriptors refer to "
"the same open message queue descriptions as the corresponding message queue "
"descriptors in the parent.  Corresponding message queue descriptors in the "
"two processes share the flags (I<mq_flags>)  that are associated with the "
"open message queue description."
msgstr "メッセージキュー記述子は I<オープンメッセージキュー記述 (open message queue description)> への参照である (B<open>(2)  も参照)。 B<fork>(2)  実行後は、子プロセスは親プロセスのメッセージキュー記述子のコピーを継承する。 これらの記述子は、親プロセスの対応するメッセージキュー記述子と同じオープンメッセージキュー記述を参照している。親プロセスと子プロセスの対応するメッセージキュー記述子は、フラグ (I<mq_flags>)  を共有する。なぜなら、フラグはオープンメッセージキュー記述に 関連付けられているからである。"

#. type: Plain text
#: build/C/man7/mq_overview.7:93
msgid ""
"Each message has an associated I<priority>, and messages are always "
"delivered to the receiving process highest priority first.  Message "
"priorities range from 0 (low) to I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> "
"(high).  On Linux, I<sysconf(_SC_MQ_PRIO_MAX)> returns 32768, but POSIX.1 "
"requires only that an implementation support at least priorities in the "
"range 0 to 31; some implementations provide only this range."
msgstr "各メッセージにはそれぞれ I<優先度 (priority)> があり、メッセージの受信プロセスへの配送は常に 優先度の高いメッセージから順に行われる。 メッセージの優先度は 0 (低優先) から I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> (高優先) の値を持つ。 Linux では、 I<sysconf(_SC_MQ_PRIO_MAX)> は 32768 を返すが、 POSIX.1 で要求されているのは最低限 0 から 31 までの優先度を実装することだけであり、実装によってはこの範囲の優先度しかサポートされていない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:96
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX message queues."
msgstr ""
"この節の残りでは、POSIX メッセージキューの Linux の実装の詳細 について説明す"
"る。"

#. type: SS
#: build/C/man7/mq_overview.7:96
#, no-wrap
msgid "Library interfaces and system calls"
msgstr "ライブラリインターフェースとシステムコール"

#. type: Plain text
#: build/C/man7/mq_overview.7:102
msgid ""
"In most cases the B<mq_*>()  library interfaces listed above are implemented "
"on top of underlying system calls of the same name.  Deviations from this "
"scheme are indicated in the following table:"
msgstr ""
"ほとんどの場合、上記の B<mq_*>() ライブラリインターフェースは、同じ名前の下位"
"層のシステムコールを 使って実装されている。この枠組みにあてはまらないものを "
"以下の表に示す。"

#. type: tbl table
#: build/C/man7/mq_overview.7:106
#, no-wrap
msgid "Library interface"
msgstr "Library interface"

#. type: tbl table
#: build/C/man7/mq_overview.7:106
#, no-wrap
msgid "System call"
msgstr "System call"

#. type: tbl table
#: build/C/man7/mq_overview.7:107
#, no-wrap
msgid "mq_close(3)"
msgstr "mq_close(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:107
#, no-wrap
msgid "close(2)"
msgstr "close(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:108
#, no-wrap
msgid "mq_getattr(3)"
msgstr "mq_getattr(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:108 build/C/man7/mq_overview.7:113
#, no-wrap
msgid "mq_getsetattr(2)"
msgstr "mq_getsetattr(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:109
#, no-wrap
msgid "mq_notify(3)"
msgstr "mq_notify(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:109
#, no-wrap
msgid "mq_notify(2)"
msgstr "mq_notify(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:110
#, no-wrap
msgid "mq_open(3)"
msgstr "mq_open(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:110
#, no-wrap
msgid "mq_open(2)"
msgstr "mq_open(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:111
#, no-wrap
msgid "mq_receive(3)"
msgstr "mq_receive(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:111 build/C/man7/mq_overview.7:114
#, no-wrap
msgid "mq_timedreceive(2)"
msgstr "mq_timedreceive(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:112
#, no-wrap
msgid "mq_send(3)"
msgstr "mq_send(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:112 build/C/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedsend(2)"
msgstr "mq_timedsend(2)"

#. type: tbl table
#: build/C/man7/mq_overview.7:113
#, no-wrap
msgid "mq_setattr(3)"
msgstr "mq_setattr(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:114
#, no-wrap
msgid "mq_timedreceive(3)"
msgstr "mq_timedreceive(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedsend(3)"
msgstr "mq_timedsend(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:116
#, no-wrap
msgid "mq_unlink(3)"
msgstr "mq_unlink(3)"

#. type: tbl table
#: build/C/man7/mq_overview.7:116
#, no-wrap
msgid "mq_unlink(2)"
msgstr "mq_unlink(2)"

#. type: SS
#: build/C/man7/mq_overview.7:119
#, no-wrap
msgid "Versions"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/mq_overview.7:122
msgid ""
"POSIX message queues have been supported on Linux since kernel 2.6.6.  Glibc "
"support has been provided since version 2.3.4."
msgstr ""
"Linux では POSIX メッセージキューはカーネル 2.6.6 以降でサポートされている。 "
"glibc ではバージョン 2.3.4 以降でサポートされている。"

#. type: SS
#: build/C/man7/mq_overview.7:122
#, no-wrap
msgid "Kernel configuration"
msgstr "カーネルの設定"

#. type: Plain text
#: build/C/man7/mq_overview.7:127
msgid ""
"Support for POSIX message queues is configurable via the "
"B<CONFIG_POSIX_MQUEUE> kernel configuration option.  This option is enabled "
"by default."
msgstr ""
"POSIX メッセージキューのサポートは、カーネルの設定 (configuration)  オプショ"
"ン B<CONFIG_POSIX_MQUEUE> で設定可能である。このオプションはデフォルトでは有"
"効である。"

#. type: SS
#: build/C/man7/mq_overview.7:127
#, no-wrap
msgid "Persistence"
msgstr "持続性"

#. type: Plain text
#: build/C/man7/mq_overview.7:132
msgid ""
"POSIX message queues have kernel persistence: if not removed by "
"B<mq_unlink>(3), a message queue will exist until the system is shut down."
msgstr ""
"POSIX メッセージキューはカーネル内で保持される。 B<mq_unlink>(3)  で削除され"
"なければ、メッセージキューは システムがシャットダウンされるまで存在し続ける。"

#. type: SS
#: build/C/man7/mq_overview.7:132
#, no-wrap
msgid "Linking"
msgstr "リンク"

#. type: Plain text
#: build/C/man7/mq_overview.7:137
msgid ""
"Programs using the POSIX message queue API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""
"POSIX メッセージキュー API を使用したプログラムは I<cc -lrt> でコンパイルし、"
"リアルタイムライブラリ I<librt> とリンクしなければならない。"

#. type: SS
#: build/C/man7/mq_overview.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man7/mq_overview.7:141
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by POSIX message queues and to set the default attributes for new "
"message queues:"
msgstr ""
"以下のインターフェースを使って、 POSIX メッセージキューが消費するカーネル メ"
"モリーの量を制限したり、 新規のメッセージキューのデフォルト属性を設定したりす"
"ることができる。"

#. type: TP
#: build/C/man7/mq_overview.7:141
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_default> (since Linux 3.5)"
msgstr "I</proc/sys/fs/mqueue/msg_default> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man7/mq_overview.7:165
msgid ""
"This file defines the value used for a new queue's I<mq_maxmsg> setting when "
"the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 10.  The minimum and "
"maximum are as for I</proc/sys/fs/mqueue/msg_max>.  A new queue's default "
"I<mq_maxmsg> value will be the smaller of I<msg_default> and I<msg_max>.  Up "
"until Linux 2.6.28, the default I<mq_maxmsg> was 10; from Linux 2.6.28 to "
"Linux 3.4, the default was the value defined for the I<msg_max> limit."
msgstr ""
"このファイルは、I<attr> に NULL を指定して B<mq_open>(3) を呼び出してキューが"
"作成された際に、 その新規キューの I<mq_maxmsg> 設定に使用される値を定めてい"
"る。 このファイルのデフォルト値は 10 である。 最小値と最大値は I</proc/sys/"
"fs/mqueue/msg_max> と同様である。 新規キューのデフォルトの I<mq_maxmsg> 値は "
"I<msg_default> と I<msg_max> の小さい方となる。 Linux 2.6.28 より前は、デフォ"
"ルトの I<mq_maxmsg> は 10 であった。 Linux 2.6.28 から Linux 3.4 までは、 デ"
"フォルト値は I<msg_max> 上限で規定される値であった。"

#. type: TP
#: build/C/man7/mq_overview.7:165
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_max>"
msgstr "I</proc/sys/fs/mqueue/msg_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:186
msgid ""
"This file can be used to view and change the ceiling value for the maximum "
"number of messages in a queue.  This value acts as a ceiling on the I<attr-"
"E<gt>mq_maxmsg> argument given to B<mq_open>(3).  The default value for "
"I<msg_max> is 10.  The minimum value is 1 (10 in kernels before 2.6.28).  "
"The upper limit is B<HARD_MSGMAX>.  The I<msg_max> limit is ignored for "
"privileged processes (B<CAP_SYS_RESOURCE>), but the B<HARD_MSGMAX> ceiling "
"is nevertheless imposed."
msgstr ""
"このファイルを使って、一つのキューに入れられるメッセージの最大数の 上限値を参"
"照したり変更したりできる。この値は、 B<mq_open>(3)  に渡す I<attr-"
"E<gt>mq_maxmsg> 引数に対する上限値として機能する。 I<msg_max> のデフォルト"
"値は 10 で、 最小値は 1 (2.6.28 より前のカーネルでは 10) である。 I<msg_max> "
"に指定できる上限値は B<HARD_MSGMAX> である。 I<msg_max> 上限は特権プロセス "
"(B<CAP_SYS_RESOURCE>)  では無視されるが、上限値 B<HARD_MSGMAX> はどんな場合に"
"でも適用される。"

#. type: Plain text
#: build/C/man7/mq_overview.7:190
msgid "The definition of B<HARD_MSGMAX> has changed across kernel versions:"
msgstr "B<HARD_MSGMAX> の定義はカーネルのバージョンにより異なる。"

#. type: IP
#: build/C/man7/mq_overview.7:191 build/C/man7/mq_overview.7:194
#: build/C/man7/mq_overview.7:197 build/C/man7/mq_overview.7:245
#: build/C/man7/mq_overview.7:248 build/C/man7/mq_overview.7:250
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/mq_overview.7:194
msgid "Up to Linux 2.6.32: I<131072\\ /\\ sizeof(void\\ *)>"
msgstr "Linux 2.6.32 以前: I<131072\\ /\\ sizeof(void\\ *)>"

#. type: Plain text
#: build/C/man7/mq_overview.7:197
msgid "Linux 2.6.33 to 3.4: I<(32768\\ *\\ sizeof(void\\ *) / 4)>"
msgstr "Linux 2.6.33 以上 3.4 以下: I<(32768\\ *\\ sizeof(void\\ *) / 4)>"

#.  commit 5b5c4d1a1440e94994c73dddbad7be0676cd8b9a
#. type: Plain text
#: build/C/man7/mq_overview.7:201
msgid "Since Linux 3.5: 65,536"
msgstr "Linux 3.5 以降: 65,536"

#. type: TP
#: build/C/man7/mq_overview.7:202
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_default> (since Linux 3.5)"
msgstr "I</proc/sys/fs/mqueue/msgsize_default> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man7/mq_overview.7:229
msgid ""
"This file defines the value used for a new queue's I<mq_msgsize> setting "
"when the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 8192 (bytes).  The "
"minimum and maximum are as for I</proc/sys/fs/mqueue/msgsize_max>.  If "
"I<msgsize_default> exceeds I<msgsize_max>, a new queue's default "
"I<mq_msgsize> value is capped to the I<msgsize_max> limit.  Up until Linux "
"2.6.28, the default I<mq_msgsize> was 8192; from Linux 2.6.28 to Linux 3.4, "
"the default was the value defined for the I<msgsize_max> limit."
msgstr ""
"このファイルは、I<attr> に NULL を指定して B<mq_open>(3) を呼び出してキューが"
"作成された際に、 その新規キューの I<mq_msgsize> 設定に使用される値を定めてい"
"る。 このファイルのデフォルト値は 8192 バイトである。 最小値と最大値は I</"
"proc/sys/fs/mqueue/msgsize_max> と同様である。 \n"
"I<msgsize_default> が I<msgsize_max> より大きい場合は、 新規キューのデフォル"
"トの I<mq_msgsize> 値は I<msgsize_max> 上限となる。 Linux 2.6.28 より前は、デ"
"フォルトの I<mq_msgsize> は 8192 であった。 Linux 2.6.28 から Linux 3.4 まで"
"は、 デフォルト値は I<msgsize_max> 上限で規定される値であった。"

#. type: TP
#: build/C/man7/mq_overview.7:229
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_max>"
msgstr "I</proc/sys/fs/mqueue/msgsize_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:244
msgid ""
"This file can be used to view and change the ceiling on the maximum message "
"size.  This value acts as a ceiling on the I<attr-E<gt>mq_msgsize> argument "
"given to B<mq_open>(3).  The default value for I<msgsize_max> is 8192 "
"bytes.  The minimum value is 128 (8192 in kernels before 2.6.28).  The upper "
"limit for I<msgsize_max> has varied across kernel versions:"
msgstr ""
"このファイルを使って、メッセージの最大サイズの上限値を参照したり変更したりで"
"きる。 この値は、 B<mq_open>(3) に渡す I<attr-E<gt>mq_msgsize> 引数に対する"
"上限値として機能する。 I<msgsize_max> のデフォルト値は 8192 バイトで、 最小値"
"は 128 (2.6.28 より前のカーネルでは 8192) である。 I<msgsize_max> の上限は"
"カーネルのバージョンにより異なる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:248
msgid "Before Linux 2.6.28, the upper limit is B<INT_MAX>."
msgstr "Linux 2.6.28 より前のバージョンでは、上限は B<INT_MAX> である。"

#. type: Plain text
#: build/C/man7/mq_overview.7:250
msgid "From Linux 2.6.28 to 3.4, the limit is 1,048,576."
msgstr "Linux 2.6.28 から 3.4 では、上限は 1,048,576 である。"

#. type: Plain text
#: build/C/man7/mq_overview.7:253
msgid "Since Linux 3.5, the limit is 16,777,216 (B<HARD_MSGSIZEMAX>)."
msgstr "Linux 3.5 以降では、上限は 16,777,216 (B<HARD_MSGSIZEMAX>) である。"

#. type: Plain text
#: build/C/man7/mq_overview.7:262
msgid ""
"The I<msgsize_max> limit is ignored for privileged process "
"(B<CAP_SYS_RESOURCE>), but, since Linux 3.5, the B<HARD_MSGSIZEMAX> ceiling "
"is enforced for privileged processes."
msgstr ""
"I<msgsize_max> 上限は特権プロセス (B<CAP_SYS_RESOURCE>) では無視されるが、 "
"Linux 3.5 以降では特権プロセスにも B<HARD_MSGSIZEMAX> という上限が適用され"
"る。"

#. type: TP
#: build/C/man7/mq_overview.7:262
#, no-wrap
msgid "I</proc/sys/fs/mqueue/queues_max>"
msgstr "I</proc/sys/fs/mqueue/queues_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:274
msgid ""
"This file can be used to view and change the system-wide limit on the number "
"of message queues that can be created.  The default value for I<queues_max> "
"is 256.  No ceiling is imposed on the I<queues_max> limit; privileged "
"processes (B<CAP_SYS_RESOURCE>)  can exceed the limit (but see BUGS)."
msgstr ""
"このファイルを使って、作成可能なメッセージキュー数のシステム全体での制限を参"
"照したり変更したりできる。 I<queues_max> のデフォルト値は 256 である。 "
"I<queues_max> に課される上限値はない。 特権プロセス (B<CAP_SYS_RESOURCE>) は"
"この上限値を超えてメッセージキューを作成できる。"

#. type: SS
#: build/C/man7/mq_overview.7:274
#, no-wrap
msgid "Resource limit"
msgstr "リソース制限"

#. type: Plain text
#: build/C/man7/mq_overview.7:281
msgid ""
"The B<RLIMIT_MSGQUEUE> resource limit, which places a limit on the amount of "
"space that can be consumed by all of the message queues belonging to a "
"process's real user ID, is described in B<getrlimit>(2)."
msgstr ""
"リソース上限 B<RLIMIT_MSGQUEUE> は、プロセスの実 UID に対応する全メッセージ"
"キューが消費する メモリー空間の量に対して上限を設定する。 B<getrlimit>(2)  を"
"参照。"

#. type: SS
#: build/C/man7/mq_overview.7:281
#, no-wrap
msgid "Mounting the message queue filesystem"
msgstr "メッセージキューファイルシステムのマウント"

#. type: Plain text
#: build/C/man7/mq_overview.7:287
msgid ""
"On Linux, message queues are created in a virtual filesystem.  (Other "
"implementations may also provide such a feature, but the details are likely "
"to differ.)  This filesystem can be mounted (by the superuser) using the "
"following commands:"
msgstr ""
"Linux では、メッセージキューは仮想ファイルシステム内に作成される (他の実装で"
"も同様の機能が提供されているものもあるが、 詳細は違っているだろう)。 以下のコ"
"マンドを使うことで (スーパーユーザーは)  このファイルシステムをマウントでき"
"る:"

#. type: Plain text
#: build/C/man7/mq_overview.7:292
#, no-wrap
msgid ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"
msgstr ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"

#. type: Plain text
#: build/C/man7/mq_overview.7:296
msgid "The sticky bit is automatically enabled on the mount directory."
msgstr ""
"マウントしたディレクトリのスティッキービット (sticky bit) は 自動的にオンとな"
"る。"

#. type: Plain text
#: build/C/man7/mq_overview.7:303
msgid ""
"After the filesystem has been mounted, the message queues on the system can "
"be viewed and manipulated using the commands usually used for files (e.g., "
"B<ls>(1)  and B<rm>(1))."
msgstr ""
"メッセージキューファイルシステムのマウント後は、ファイルに対して 通常使うコマ"
"ンド (例えば B<ls>(1)  や B<rm>(1))  を使って、システム上のメッセージキューを"
"表示したり 操作したりできる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:306
msgid ""
"The contents of each file in the directory consist of a single line "
"containing information about the queue:"
msgstr ""
"ディレクトリ内の各ファイルの内容は 1行であり、 キューに関する情報が表示され"
"る。"

#. type: Plain text
#: build/C/man7/mq_overview.7:311
#, no-wrap
msgid ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"
msgstr ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"

#. type: Plain text
#: build/C/man7/mq_overview.7:315
msgid "These fields are as follows:"
msgstr "各フィールドの詳細は以下の通りである:"

#. type: TP
#: build/C/man7/mq_overview.7:315
#, no-wrap
msgid "B<QSIZE>"
msgstr "B<QSIZE>"

#. type: Plain text
#: build/C/man7/mq_overview.7:318
msgid "Number of bytes of data in all messages in the queue (but see BUGS)."
msgstr "キューに入っている全メッセージの合計バイト数 (ただし「バグ」を参照)。"

#. type: TP
#: build/C/man7/mq_overview.7:318
#, no-wrap
msgid "B<NOTIFY_PID>"
msgstr "B<NOTIFY_PID>"

#. type: Plain text
#: build/C/man7/mq_overview.7:324
msgid ""
"If this is nonzero, then the process with this PID has used B<mq_notify>(3)  "
"to register for asynchronous message notification, and the remaining fields "
"describe how notification occurs."
msgstr ""
"この値が 0 以外の場合、この値の PID を持つプロセスが B<mq_notify>(3)  を使っ"
"て、非同期のメッセージ通知を行うように設定したことを示す。 どのように通知が行"
"われるかは、以下のフィールドにより決定される。"

#. type: TP
#: build/C/man7/mq_overview.7:324
#, no-wrap
msgid "B<NOTIFY>"
msgstr "B<NOTIFY>"

#. type: Plain text
#: build/C/man7/mq_overview.7:334
msgid ""
"Notification method: 0 is B<SIGEV_SIGNAL>; 1 is B<SIGEV_NONE>; and 2 is "
"B<SIGEV_THREAD>."
msgstr ""
"通知方法: 0 は B<SIGEV_SIGNAL>; 1 は B<SIGEV_NONE>; 2 は B<SIGEV_THREAD>"

#. type: TP
#: build/C/man7/mq_overview.7:334
#, no-wrap
msgid "B<SIGNO>"
msgstr "B<SIGNO>"

#. type: Plain text
#: build/C/man7/mq_overview.7:338
msgid "Signal number to be used for B<SIGEV_SIGNAL>."
msgstr "B<SIGEV_SIGNAL> に使用されるシグナル番号。"

#. type: SS
#: build/C/man7/mq_overview.7:338
#, no-wrap
msgid "Linux implementation of message queue descriptors"
msgstr "Linux でのメッセージキュー記述子の実装"

#. type: Plain text
#: build/C/man7/mq_overview.7:347
#, fuzzy
#| msgid ""
#| "On Linux, a message queue descriptor is actually a file descriptor, and "
#| "can be monitored using B<select>(2), B<poll>(2), or B<epoll>(7).  This is "
#| "not portable."
msgid ""
"On Linux, a message queue descriptor is actually a file descriptor.  (POSIX "
"does not require such an implementation.)  This means that a message queue "
"descriptor can be monitored using B<select>(2), B<poll>(2), or B<epoll>(7).  "
"This is not portable."
msgstr ""
"Linux では、メッセージキュー記述子は実際はファイルディスクリプター (file "
"descriptor)  であり、 B<select>(2), B<poll>(2), B<epoll>(7)  を使って監視する"
"ことができる。 この機能の移植性はない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:352
msgid ""
"The close-on-exec flag (see B<open>(2))  is automatically set on the file "
"descriptor returned by B<mq_open>(2)."
msgstr ""

#. type: SS
#: build/C/man7/mq_overview.7:352
#, no-wrap
msgid "IPC namespaces"
msgstr "IPC 名前空間"

#. type: Plain text
#: build/C/man7/mq_overview.7:356
msgid ""
"For a discussion of the interaction of POSIX message queue objects and IPC "
"namespaces, see B<ipc_namespaces>(7)."
msgstr "POSIX メッセージキューオブジェクトと IPC 名前空間の相互の影響に関する議論は B<ipc_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man7/mq_overview.7:366
msgid ""
"System V message queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.) are "
"an older API for exchanging messages between processes.  POSIX message "
"queues provide a better designed interface than System V message queues; on "
"the other hand POSIX message queues are less widely available (especially on "
"older systems) than System V message queues."
msgstr ""
"System V メッセージキュー (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2)  など) は"
"プロセス間でメッセージをやり取りするための古い API である。 POSIX メッセージ"
"キューは System V メッセージキューよりもうまく 設計されたインターフェースを提"
"供している。 一方で、POSIX メッセージキューは System V メッセージキューと比べ"
"ると 利用できるシステムが少ない (特に、古いシステムでは少ない)。"

#. type: Plain text
#: build/C/man7/mq_overview.7:369
msgid ""
"Linux does not currently (2.6.26) support the use of access control lists "
"(ACLs) for POSIX message queues."
msgstr ""
"現在のことろ (バージョン 2.6.26 時点)、 Linux は POSIX メッセージキューに対す"
"るアクセス制御リスト (ACL) に 対応していない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:378
msgid ""
"In Linux versions 3.5 to 3.14, the kernel imposed a ceiling of 1024 "
"(B<HARD_QUEUESMAX>)  on the value to which the I<queues_max> limit could be "
"raised, and the ceiling was enforced even for privileged processes.  This "
"ceiling value was removed in Linux 3.14, and patches to stable kernels 3.5.x "
"to 3.13.x also removed the ceiling."
msgstr ""
"バージョン 3.5 以降 3.14 未満の Linux では、 I<queues_max> 上限を増やすことが"
"できる最大値として 1024 (B<HARD_QUEUESMAX>) という最大上限値がカーネルにより"
"適用されていた。 この最大上限値は特権プロセスにも適用されていた。 この最大上"
"限値は Linux 3.14 で削除され、 パッチで安定版カーネル 3.5.x から 3.13.x から"
"もこの最大上限値は削除された。"

#.  commit d6629859b36d
#.  commit de54b9ac253787c366bbfb28d901a31954eb3511
#. type: Plain text
#: build/C/man7/mq_overview.7:392
msgid ""
"As originally implemented (and documented), the QSIZE field displayed the "
"total number of (user-supplied)  bytes in all messages in the message "
"queue.  Some changes in Linux 3.5 inadvertently changed the behavior, so "
"that this field also included a count of kernel overhead bytes used to store "
"the messages in the queue.  This behavioral regression was rectified in "
"Linux 4.2 (and earlier stable kernel series), so that the count once more "
"included just the bytes of user data in messages in the queue."
msgstr ""

#. type: Plain text
#: build/C/man7/mq_overview.7:395
msgid ""
"An example of the use of various message queue functions is shown in "
"B<mq_notify>(3)."
msgstr ""
"各種のメッセージキュー関数を使用した例が B<mq_notify>(3)  に記載されている。"

#. type: Plain text
#: build/C/man7/mq_overview.7:409
msgid ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), "
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7), "
"B<namespaces>(7)"
msgstr ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), "
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7), "
"B<namespaces>(7)"

#. type: TH
#: build/C/man3/mq_receive.3:25
#, no-wrap
msgid "MQ_RECEIVE"
msgstr "MQ_RECEIVE"

#. type: Plain text
#: build/C/man3/mq_receive.3:28
msgid "mq_receive, mq_timedreceive - receive a message from a message queue"
msgstr "mq_receive, mq_timedreceive - メッセージキューからメッセージを受信する"

#. type: Plain text
#: build/C/man3/mq_receive.3:34
#, no-wrap
msgid ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"
msgstr ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:37 build/C/man3/mq_send.3:37
#, no-wrap
msgid ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:41
#, no-wrap
msgid ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:49 build/C/man3/mq_send.3:49
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/mq_receive.3:52
msgid "B<mq_timedreceive>():"
msgstr "B<mq_timedreceive>():"

#. type: Plain text
#: build/C/man3/mq_receive.3:54 build/C/man3/mq_send.3:54
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/mq_receive.3:75
msgid ""
"B<mq_receive>()  removes the oldest message with the highest priority from "
"the message queue referred to by the message queue descriptor I<mqdes>, and "
"places it in the buffer pointed to by I<msg_ptr>.  The I<msg_len> argument "
"specifies the size of the buffer pointed to by I<msg_ptr>; this must be "
"greater than or equal to the I<mq_msgsize> attribute of the queue (see "
"B<mq_getattr>(3)).  If I<msg_prio> is not NULL, then the buffer to which it "
"points is used to return the priority associated with the received message."
msgstr "B<mq_receive>()  は、メッセージキュー記述子 I<mqdes> で参照されるメッセージキューから最も高い優先度を持つ 最も古いメッセージを削除し、そのメッセージを I<msg_ptr> が指すバッファーに格納する。 I<msg_len> 引数は、 I<msg_ptr> が指すバッファーの大きさを示す。この値はキューの I<mq_msgsize> 属性以上でなければならない (B<mq_getattr>(3)  参照)。 I<msg_prio> が NULL 以外の場合、 I<msg_prio> が指すバッファーに受信したメッセージの優先度が格納される。"

#. type: Plain text
#: build/C/man3/mq_receive.3:85
msgid ""
"If the queue is empty, then, by default, B<mq_receive>()  blocks until a "
"message becomes available, or the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then "
"the call instead fails immediately with the error B<EAGAIN>."
msgstr ""
"キューが空の場合、デフォルトでは、 B<mq_receive>()  は、新しいメッセージが届"
"くか、関数呼び出しがシグナルハンドラーにより 中断されるまで、停止 (block) す"
"る。 メッセージキュー記述 (message queue description) で B<O_NONBLOCK> フラグ"
"が有効になっている場合は、 B<mq_receive>()  はエラー B<EAGAIN> ですぐに失敗す"
"る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:97
#, fuzzy
#| msgid ""
#| "B<mq_timedreceive>()  behaves just like B<mq_receive>(), except that if "
#| "the queue is empty and the B<O_NONBLOCK> flag is not enabled for the "
#| "message queue description, then I<abs_timeout> points to a structure "
#| "which specifies a ceiling on the time for which the call will block.  "
#| "This ceiling is an absolute timeout in seconds and nanoseconds since the "
#| "Epoch, 1970-01-01 00:00:00 +0000 (UTC), and it is specified in the "
#| "following structure:"
msgid ""
"B<mq_timedreceive>()  behaves just like B<mq_receive>(), except that if the "
"queue is empty and the B<O_NONBLOCK> flag is not enabled for the message "
"queue description, then I<abs_timeout> points to a structure which specifies "
"how long the call will block.  This value is an absolute timeout in seconds "
"and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified "
"in the following structure:"
msgstr ""
"B<mq_timedreceive>()  は B<mq_receive>()  と全く同じ動作をするが、 メッセージ"
"キューが空で、メッセージキュー記述で B<O_NONBLOCK> フラグが有効になっていない"
"場合に、この呼び出しが停止する時間の上限を I<abs_timeout> が指す構造体で指定"
"する点が異なる。この上限は、タイムアウトの時刻を、 時刻紀元 (Epoch; "
"1970-01-01 00:00:00 +0000 (UTC)) からの経過時間 (秒とナノ秒の組) で指定する。"
"タイムアウト時刻は以下の構造体で指定する:"

#. type: Plain text
#: build/C/man3/mq_receive.3:104 build/C/man3/mq_send.3:113
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;        /* 秒 */\n"
"    long   tv_nsec;       /* ナノ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:111
msgid ""
"If no message is available, and the timeout has already expired by the time "
"of the call, B<mq_timedreceive>()  returns immediately."
msgstr ""
"メッセージがキューになく、関数呼び出し時にすでにタイムアウト時刻が 過ぎている"
"場合、 B<mq_timedreceive>()  はすぐに返る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:120
msgid ""
"On success, B<mq_receive>()  and B<mq_timedreceive>()  return the number of "
"bytes in the received message; on error, -1 is returned, with I<errno> set "
"to indicate the error."
msgstr ""
"成功すると、 B<mq_receive>()  と B<mq_timedreceive>()  は受信したメッセージの"
"バイト数を返す。 エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定す"
"る。"

#. type: TP
#: build/C/man3/mq_receive.3:121 build/C/man3/mq_send.3:129
#: build/C/man2/msgop.2:363
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/mq_receive.3:127
msgid ""
"The queue was empty, and the B<O_NONBLOCK> flag was set for the message "
"queue description referred to by I<mqdes>."
msgstr ""
"キューが空で、かつ I<mqdes> で参照されるメッセージキュー記述で B<O_NONBLOCK> "
"フラグがセットされていた。"

#. type: Plain text
#: build/C/man3/mq_receive.3:132
#, fuzzy
#| msgid "The descriptor specified in I<mqdes> was invalid."
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for reading."
msgstr "I<mqdes> で指定された記述子が不正である。"

#. type: TP
#: build/C/man3/mq_receive.3:132 build/C/man3/mq_send.3:140
#: build/C/man2/msgop.2:379 build/C/man2/msgop.2:427
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man3/mq_receive.3:136 build/C/man3/mq_send.3:144
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr ""
"関数呼び出しがシグナルハンドラーにより中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/mq_receive.3:145 build/C/man3/mq_send.3:153
msgid ""
"The call would have blocked, and I<abs_timeout> was invalid, either because "
"I<tv_sec> was less than zero, or because I<tv_nsec> was less than zero or "
"greater than 1000 million."
msgstr ""
"関数呼び出しは停止するはずであったが、 I<abs_timeout> が不正であった。 "
"I<abs_timeout> が不正とは、 I<tv_sec> が 0 未満、もしくは I<tv_nsec> が 0 未"
"満か 1,000,000,000 より大きい、ということである。"

#. type: TP
#: build/C/man3/mq_receive.3:145 build/C/man3/mq_send.3:153
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: build/C/man3/mq_receive.3:151
msgid ""
"I<msg_len> was less than the I<mq_msgsize> attribute of the message queue."
msgstr "I<msg_len> がメッセージキューの I<mq_msgsize> 属性よりも小さかった。"

#. type: TP
#: build/C/man3/mq_receive.3:151 build/C/man3/mq_send.3:159
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man3/mq_receive.3:154 build/C/man3/mq_send.3:162
msgid "The call timed out before a message could be transferred."
msgstr "メッセージが転送される前に関数呼び出しがタイムアウトした。"

#. type: tbl table
#: build/C/man3/mq_receive.3:165
#, no-wrap
msgid ""
"B<mq_receive>(),\n"
"B<mq_timedreceive>()"
msgstr ""
"B<mq_receive>(),\n"
"B<mq_timedreceive>()"

#. type: Plain text
#: build/C/man3/mq_receive.3:175
msgid ""
"On Linux, B<mq_timedreceive>()  is a system call, and B<mq_receive>()  is a "
"library function layered on top of that system call."
msgstr ""
"Linux では、 B<mq_timedreceive>()  はシステムコールである。 B<mq_receive>()  "
"はライブラリ関数で、 B<mq_timedreceive>()  システムコールを用いて実装されてい"
"る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:184
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: build/C/man3/mq_send.3:25
#, no-wrap
msgid "MQ_SEND"
msgstr "MQ_SEND"

#. type: Plain text
#: build/C/man3/mq_send.3:28
msgid "mq_send, mq_timedsend - send a message to a message queue"
msgstr "mq_send, mq_timedsend - メッセージキューにメッセージを送信する"

#. type: Plain text
#: build/C/man3/mq_send.3:34
#, no-wrap
msgid ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"
msgstr ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_send.3:41
#, no-wrap
msgid ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_send.3:52
msgid "B<mq_timedsend>():"
msgstr "B<mq_timedsend>():"

#. type: Plain text
#: build/C/man3/mq_send.3:70
msgid ""
"B<mq_send>()  adds the message pointed to by I<msg_ptr> to the message queue "
"referred to by the message queue descriptor I<mqdes>.  The I<msg_len> "
"argument specifies the length of the message pointed to by I<msg_ptr>; this "
"length must be less than or equal to the queue's I<mq_msgsize> attribute.  "
"Zero-length messages are allowed."
msgstr "B<mq_send>() は、メッセージキュー記述子 I<mqdes> で参照されるメッセージキューに I<msg_ptr> が指すメッセージを追加する。 I<msg_len> 引数は、 I<msg_ptr> が指すメッセージの長さを示す。この長さはキューの I<mq_msgsize> 属性以下でなければならない。 長さが 0 のメッセージも認められている。"

#. type: Plain text
#: build/C/man3/mq_send.3:81
msgid ""
"The I<msg_prio> argument is a nonnegative integer that specifies the "
"priority of this message.  Messages are placed on the queue in decreasing "
"order of priority, with newer messages of the same priority being placed "
"after older messages with the same priority.  See B<mq_overview>(7)  for "
"details on the range for the message priority."
msgstr "I<msg_prio> 引数は、メッセージの優先度を指定する負でない整数である。 メッセージは優先度の降順でキューに格納され、同じ優先度の新しいメッセージは 同じ優先度の古いメッセージの後ろに格納される。メッセージの優先度の範囲については B<mq_overview>(7) を参照。"

#. type: Plain text
#: build/C/man3/mq_send.3:94
msgid ""
"If the message queue is already full (i.e., the number of messages on the "
"queue equals the queue's I<mq_maxmsg> attribute), then, by default, "
"B<mq_send>()  blocks until sufficient space becomes available to allow the "
"message to be queued, or until the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then "
"the call instead fails immediately with the error B<EAGAIN>."
msgstr ""
"メッセージキューがすでに一杯の場合 (すなわち、キューに入っているメッセージ数"
"がキューの I<mq_maxmsg> 属性と等しい場合)、デフォルトでは、 B<mq_send ()> "
"は、メッセージをキューイングするのに十分な空間ができるか、 関数呼び出しがシグ"
"ナルハンドラーにより中断されるまで、停止 (block) する。 メッセージキュー記述 "
"(message queue description) で B<O_NONBLOCK> フラグが有効になっている場合"
"は、 B<mq_send>()  はエラー B<EAGAIN> ですぐに失敗する。"

#. type: Plain text
#: build/C/man3/mq_send.3:106
#, fuzzy
#| msgid ""
#| "B<mq_timedsend>()  behaves just like B<mq_send>(), except that if the "
#| "queue is full and the B<O_NONBLOCK> flag is not enabled for the message "
#| "queue description, then I<abs_timeout> points to a structure which "
#| "specifies a ceiling on the time for which the call will block.  This "
#| "ceiling is an absolute timeout in seconds and nanoseconds since the "
#| "Epoch, 1970-01-01 00:00:00 +0000 (UTC), and it is specified in the "
#| "following structure:"
msgid ""
"B<mq_timedsend>()  behaves just like B<mq_send>(), except that if the queue "
"is full and the B<O_NONBLOCK> flag is not enabled for the message queue "
"description, then I<abs_timeout> points to a structure which specifies how "
"long the call will block.  This value is an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified in "
"the following structure:"
msgstr ""
"B<mq_timedsend>()  は B<mq_send>()  と全く同じ動作をするが、 メッセージキュー"
"が一杯で、メッセージキュー記述で B<O_NONBLOCK> フラグが有効になっていない場合"
"に、この呼び出しが停止する時間の上限を I<abs_timeout> が指す構造体で指定する"
"点が異なる。この上限は、タイムアウトの時刻を 時刻紀元 (Epoch; 1970-01-01 "
"00:00:00 +0000 (UTC)) からの経過時間 (秒とナノ秒の組) で指定する。タイムアウ"
"ト時刻は以下の構造体で指定する:"

#. type: Plain text
#: build/C/man3/mq_send.3:120
msgid ""
"If the message queue is full, and the timeout has already expired by the "
"time of the call, B<mq_timedsend>()  returns immediately."
msgstr ""
"メッセージキューが一杯で、関数呼び出し時にすでにタイムアウト時刻が 過ぎている"
"場合、 B<mq_timedsend>()  はすぐに返る。"

#. type: Plain text
#: build/C/man3/mq_send.3:128
msgid ""
"On success, B<mq_send>()  and B<mq_timedsend>()  return zero; on error, -1 "
"is returned, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_send>()  と B<mq_timedsend>()  は 0 を返す。 エラーの場"
"合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/mq_send.3:135
msgid ""
"The queue was full, and the B<O_NONBLOCK> flag was set for the message queue "
"description referred to by I<mqdes>."
msgstr ""
"キューが一杯で、かつ I<mqdes> で参照されるメッセージキュー記述で "
"B<O_NONBLOCK> フラグがセットされていた。"

#. type: Plain text
#: build/C/man3/mq_send.3:140
#, fuzzy
#| msgid "The descriptor specified in I<mqdes> was invalid."
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for writing."
msgstr "I<mqdes> で指定された記述子が不正である。"

#. type: Plain text
#: build/C/man3/mq_send.3:159
msgid ""
"I<msg_len> was greater than the I<mq_msgsize> attribute of the message queue."
msgstr "I<msg_len> がメッセージキューの I<mq_msgsize> 属性よりも大きかった。"

#. type: tbl table
#: build/C/man3/mq_send.3:173
#, no-wrap
msgid ""
"B<mq_send>(),\n"
"B<mq_timedsend>()"
msgstr ""
"B<mq_send>(),\n"
"B<mq_timedsend>()"

#. type: Plain text
#: build/C/man3/mq_send.3:183
msgid ""
"On Linux, B<mq_timedsend>()  is a system call, and B<mq_send>()  is a "
"library function layered on top of that system call."
msgstr ""
"Linux では、 B<mq_timedsend>()  はシステムコールである。 B<mq_send>()  はライ"
"ブラリ関数で、 B<mq_timedsend>()  システムコールを用いて実装されている。"

#. type: Plain text
#: build/C/man3/mq_send.3:192
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: build/C/man3/mq_unlink.3:25
#, no-wrap
msgid "MQ_UNLINK"
msgstr "MQ_UNLINK"

#. type: Plain text
#: build/C/man3/mq_unlink.3:28
msgid "mq_unlink - remove a message queue"
msgstr "mq_unlink - メッセージキューを削除する"

#. type: Plain text
#: build/C/man3/mq_unlink.3:33
#, no-wrap
msgid "B<int mq_unlink(const char *>I<name>B<);>\n"
msgstr "B<int mq_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_unlink.3:43
msgid ""
"B<mq_unlink>()  removes the specified message queue I<name>.  The message "
"queue name is removed immediately.  The queue itself is destroyed once any "
"other processes that have the queue open close their descriptors referring "
"to the queue."
msgstr ""
"B<mq_unlink>()  は指定されたメッセージキュー I<name> を削除する。 メッセージ"
"キュー名は直ちに削除される。 キュー自体は、そのキューをオープンした他のすべて"
"のプロセスが そのキューを参照する記述子をクローズした時点で破棄される。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:49
msgid ""
"On success B<mq_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_unlink>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:53
msgid "The caller does not have permission to unlink this message queue."
msgstr ""
"呼び出し元プロセスがこのメッセージキューを削除 (unlink) する 許可を持たない。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:61
msgid "There is no message queue with the given I<name>."
msgstr "指定された名前 I<name> を持つメッセージキューが存在しない。"

#. type: tbl table
#: build/C/man3/mq_unlink.3:71
#, no-wrap
msgid "B<mq_unlink>()"
msgstr "B<mq_unlink>()"

#. type: Plain text
#: build/C/man3/mq_unlink.3:83
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man2/msgctl.2:38
#, no-wrap
msgid "MSGCTL"
msgstr "MSGCTL"

#. type: TH
#: build/C/man2/msgctl.2:38 build/C/man2/msgop.2:40
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man2/msgctl.2:41
msgid "msgctl - System V message control operations"
msgstr "msgctl - System V メッセージ制御操作"

#. type: Plain text
#: build/C/man2/msgctl.2:46 build/C/man2/msgget.2:43 build/C/man2/msgop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/msgctl.2:48
#, no-wrap
msgid "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"
msgstr "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man2/msgctl.2:55
msgid ""
"B<msgctl>()  performs the control operation specified by I<cmd> on the System"
"\\ V message queue with identifier I<msqid>."
msgstr ""
"B<msgctl>()  はメッセージキュー識別子 I<msqid> で指定された System\\ V メッ"
"セージキュー (message queue) に対して I<cmd> で指定された制御操作を行なう。"

#. type: Plain text
#: build/C/man2/msgctl.2:59
msgid ""
"The I<msqid_ds> data structure is defined in I<E<lt>sys/msg.hE<gt>> as "
"follows:"
msgstr ""
"I<msqid_ds> データ構造体は I<E<lt>sys/msg.hE<gt>> で以下のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man2/msgctl.2:74
#, fuzzy, no-wrap
#| msgid ""
#| "struct msqid_ds {\n"
#| "    struct ipc_perm msg_perm;     /* Ownership and permissions */\n"
#| "    time_t          msg_stime;    /* Time of last msgsnd(2) */\n"
#| "    time_t          msg_rtime;    /* Time of last msgrcv(2) */\n"
#| "    time_t          msg_ctime;    /* Time of last change */\n"
#| "    unsigned long   __msg_cbytes; /* Current number of bytes in\n"
#| "                                     queue (nonstandard) */\n"
#| "    msgqnum_t       msg_qnum;     /* Current number of messages\n"
#| "                                     in queue */\n"
#| "    msglen_t        msg_qbytes;   /* Maximum number of bytes\n"
#| "                                     allowed in queue */\n"
#| "    pid_t           msg_lspid;    /* PID of last msgsnd(2) */\n"
#| "    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */\n"
#| "};\n"
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;   /* Ownership and permissions */\n"
"    time_t          msg_stime;  /* Time of last msgsnd(2) */\n"
"    time_t          msg_rtime;  /* Time of last msgrcv(2) */\n"
"    time_t          msg_ctime;  /* Time of creation or last\n"
"                                   modification by msgctl() */\n"
"    unsigned long   msg_cbytes; /* # of bytes in queue */\n"
"    msgqnum_t       msg_qnum;   /* # number of messages in queue */\n"
"    msglen_t        msg_qbytes; /* Maximum # of bytes in queue */\n"
"    pid_t           msg_lspid;  /* PID of last msgsnd(2) */\n"
"    pid_t           msg_lrpid;  /* PID of last msgrcv(2) */\n"
"};\n"
msgstr ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* 所有権と許可 */\n"
"    time_t          msg_stime;    /* 最後の msgsnd(2) の時刻 */\n"
"    time_t          msg_rtime;    /* 最後の msgrcv(2) の時刻 */\n"
"    time_t          msg_ctime;    /* 最後に変更が行われた時刻 */\n"
"    unsigned long   __msg_cbytes; /* キューにある現在のバイト数\n"
"                                     (非標準) */\n"
"    msgqnum_t       msg_qnum;     /* キューにある現在入っている\n"
"                                     メッセージの数 */\n"
"    msglen_t        msg_qbytes;   /* キューに許可されている\n"
"                                     最大バイト数 */\n"
"    pid_t           msg_lspid;    /* 最後の msgsnd(2) の PID */\n"
"    pid_t           msg_lrpid;    /* 最後の msgrcv(2) の PID */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:80
msgid "The fields of the I<msgid_ds> structure are as follows:"
msgstr "I<msgid_ds> 構造体のフィールドは以下の通りである:"

#. type: TP
#: build/C/man2/msgctl.2:80
#, no-wrap
msgid "I<msg_perm>"
msgstr "I<msg_perm>"

#. type: Plain text
#: build/C/man2/msgctl.2:86
msgid ""
"This is an I<ipc_perm> structure (see below) that specifies the access "
"permissions on the message queue."
msgstr ""

#. type: TP
#: build/C/man2/msgctl.2:86
#, no-wrap
msgid "I<msg_stime>"
msgstr "I<msg_stime>"

#. type: Plain text
#: build/C/man2/msgctl.2:91
msgid "Time of the last B<msgsnd>(2)  system call."
msgstr "最後の B<msgsnd>(2) システムコールの時刻。"

#. type: TP
#: build/C/man2/msgctl.2:91
#, no-wrap
msgid "I<msg_rtime>"
msgstr "I<msg_rtime>"

#. type: Plain text
#: build/C/man2/msgctl.2:96
msgid "Time of the last B<msgrcv>(2)  system call."
msgstr "最後の B<msgrcv>(2) システムコールの時刻。"

#. type: TP
#: build/C/man2/msgctl.2:96
#, no-wrap
msgid "I<msg_ctime>"
msgstr "I<msg_ctime>"

#. type: Plain text
#: build/C/man2/msgctl.2:102
msgid ""
"Time of creation of queue or time of last B<msgctl>()  B<IPC_SET> operation."
msgstr ""

#. type: TP
#: build/C/man2/msgctl.2:102
#, no-wrap
msgid "I<msg_cbytes>"
msgstr "I<msg_cbytes>"

#. type: Plain text
#: build/C/man2/msgctl.2:106
msgid ""
"Number of bytes in all messages currently on the message queue.  This is a "
"nonstandard Linux extension that is not specified in POSIX."
msgstr ""

#. type: TP
#: build/C/man2/msgctl.2:106
#, no-wrap
msgid "I<msg_qnum>"
msgstr "I<msg_qnum>"

#. type: Plain text
#: build/C/man2/msgctl.2:109
#, fuzzy
#| msgid "Number of bytes of data in all messages in the queue."
msgid "Number of messages currently on the message queue."
msgstr "キューに入っている全メッセージの合計バイト数。"

#. type: TP
#: build/C/man2/msgctl.2:109
#, no-wrap
msgid "I<msg_qbytes>"
msgstr "I<msg_qbytes>"

#. type: Plain text
#: build/C/man2/msgctl.2:113
#, fuzzy
#| msgid "Number of bytes of data in all messages in the queue."
msgid "Maximum number of bytes of message text allowed on the message queue."
msgstr "キューに入っている全メッセージの合計バイト数。"

#. type: TP
#: build/C/man2/msgctl.2:113
#, no-wrap
msgid "I<msg_lspid>"
msgstr "I<msg_lspid>"

#. type: Plain text
#: build/C/man2/msgctl.2:118
msgid "ID of the process that performed the last B<msgsnd>(2)  system call."
msgstr "最後の B<msgsnd>(2) システムコールを実行したプロセスの ID。"

#. type: TP
#: build/C/man2/msgctl.2:118
#, no-wrap
msgid "I<msg_lrpid>"
msgstr "I<msg_lrpid>"

#. type: Plain text
#: build/C/man2/msgctl.2:123
msgid "ID of the process that performed the last B<msgrcv>(2)  system call."
msgstr "最後の B<msgrcv>(2) システムコールを実行したプロセスの ID。"

#. type: Plain text
#: build/C/man2/msgctl.2:129
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"I<ipc_perm> 構造体は以下のように定義されている (強調されたフィールドは "
"B<IPC_SET> を使って設定可能である):"

#. type: Plain text
#: build/C/man2/msgctl.2:141
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;       /* Key supplied to msgget(2) */\n"
"    uid_t          B<uid>;         /* Effective UID of owner */\n"
"    gid_t          B<gid>;         /* Effective GID of owner */\n"
"    uid_t          cuid;        /* Effective UID of creator */\n"
"    gid_t          cgid;        /* Effective GID of creator */\n"
"    unsigned short B<mode>;        /* Permissions */\n"
"    unsigned short __seq;       /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key;       /* msgget(2) に与えるキー */\n"
"    uid_t          B<uid>;         /* 所有者の実効 UID */\n"
"    gid_t          B<gid>;         /* 所有者の実効 GID */\n"
"    uid_t          cuid;        /* 作成者の実効 UID */\n"
"    gid_t          cgid;        /* 作成者の実効 GID */\n"
"    unsigned short B<mode>;        /* 許可 */\n"
"    unsigned short __seq;       /* シーケンス番号 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:150
msgid ""
"The least significant 9 bits of the I<mode> field of the I<ipc_perm> "
"structure define the access permissions for the message queue.  The "
"permission bits are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man2/msgctl.2:152
#, no-wrap
msgid "0400"
msgstr "0400"

#. type: tbl table
#: build/C/man2/msgctl.2:152
#, no-wrap
msgid "Read by user"
msgstr "ユーザーによる読み出し"

#. type: tbl table
#: build/C/man2/msgctl.2:153
#, no-wrap
msgid "0200"
msgstr "0200"

#. type: tbl table
#: build/C/man2/msgctl.2:153
#, no-wrap
msgid "Write by user"
msgstr "ユーザーによる書き込み"

#. type: tbl table
#: build/C/man2/msgctl.2:154
#, no-wrap
msgid "0040"
msgstr "0040"

#. type: tbl table
#: build/C/man2/msgctl.2:154
#, no-wrap
msgid "Read by group"
msgstr "グループによる読み出し"

#. type: tbl table
#: build/C/man2/msgctl.2:155
#, no-wrap
msgid "0020"
msgstr "0020"

#. type: tbl table
#: build/C/man2/msgctl.2:155
#, no-wrap
msgid "Write by group"
msgstr "グループによる書き込み"

#. type: tbl table
#: build/C/man2/msgctl.2:156
#, no-wrap
msgid "0004"
msgstr "0004"

#. type: tbl table
#: build/C/man2/msgctl.2:156
#, no-wrap
msgid "Read by others"
msgstr "他人 (others) による読み出し"

#. type: tbl table
#: build/C/man2/msgctl.2:157
#, no-wrap
msgid "0002"
msgstr "0002"

#. type: tbl table
#: build/C/man2/msgctl.2:157
#, no-wrap
msgid "Write by others"
msgstr "他人 (others) による書き込み"

#. type: Plain text
#: build/C/man2/msgctl.2:161
msgid "Bits 0100, 0010, and 0001 (the execute bits) are unused by the system."
msgstr "ビット 0100, 0010, 0001 (実行ビット) をシステムは使用しない。"

#. type: Plain text
#: build/C/man2/msgctl.2:165
msgid "Valid values for I<cmd> are:"
msgstr "I<cmd> として有効な値は:"

#. type: TP
#: build/C/man2/msgctl.2:165
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man2/msgctl.2:174
msgid ""
"Copy information from the kernel data structure associated with I<msqid> "
"into the I<msqid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the message queue."
msgstr ""
"I<msqid> に関連づけられたメッセージキューデータ構造体から、ポインター I<buf> "
"が指し示す I<msqid_ds> 構造体に情報をコピーする。 呼び出し側はメッセージ"
"キューに対する読み込み許可を持っていなければならない。"

#. type: TP
#: build/C/man2/msgctl.2:174
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man2/msgctl.2:184
msgid ""
"Write the values of some members of the I<msqid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this message queue, "
"updating also its I<msg_ctime> member."
msgstr ""

#. type: Plain text
#: build/C/man2/msgctl.2:191
msgid ""
"The following members of the structure are updated: I<msg_qbytes>, "
"I<msg_perm.uid>, I<msg_perm.gid>, and (the least significant 9 bits of)  "
"I<msg_perm.mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/msgctl.2:203
#, fuzzy
#| msgid ""
#| "Write the values of some members of the I<msqid_ds> structure pointed to "
#| "by I<buf> to the kernel data structure associated with this message "
#| "queue, updating also its I<msg_ctime> member.  The following members of "
#| "the structure are updated: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm."
#| "gid>, and (the least significant 9 bits of)  I<msg_perm.mode>.  The "
#| "effective UID of the calling process must match the owner (I<msg_perm."
#| "uid>)  or creator (I<msg_perm.cuid>)  of the message queue, or the caller "
#| "must be privileged.  Appropriate privilege (Linux: the "
#| "B<CAP_SYS_RESOURCE> capability) is required to raise the I<msg_qbytes> "
#| "value beyond the system parameter B<MSGMNB>."
msgid ""
"The effective UID of the calling process must match the owner (I<msg_perm."
"uid>)  or creator (I<msg_perm.cuid>)  of the message queue, or the caller "
"must be privileged.  Appropriate privilege (Linux: the B<CAP_SYS_RESOURCE> "
"capability) is required to raise the I<msg_qbytes> value beyond the system "
"parameter B<MSGMNB>."
msgstr ""
"ポインター I<buf> が指し示す I<msqid_ds> 構造体のメンバーの値を、メッセージ"
"キューに関連づけられた カーネルデータ構造体に書き込み、 I<msg_ctime> メンバー"
"も更新する。 構造体のメンバーのうち、更新されるものを以下に示す: "
"I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, I<msg_perm.mode> (の下位 9 "
"ビット)。 呼び出したプロセスの実効ユーザー ID が、メッセージキューの所有者 "
"(I<msg_perm.uid>)  または作成者 (I<msg_perm.cuid>)  と一致するか、呼び出し元"
"が特権を持たなければならない。 I<msg_qbytes> をシステムパラメーターの "
"B<MSGMNB> を超えて設定するには、適切な特権 (Linux では B<CAP_SYS_RESOURCE> "
"ケーパビリティ (capability)) が必要である。"

#. type: TP
#: build/C/man2/msgctl.2:203
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man2/msgctl.2:217
msgid ""
"Immediately remove the message queue, awakening all waiting reader and "
"writer processes (with an error return and I<errno> set to B<EIDRM>).  The "
"calling process must have appropriate privileges or its effective user ID "
"must be either that of the creator or owner of the message queue.  The third "
"argument to B<msgctl>()  is ignored in this case."
msgstr ""
"メッセージキューをただちに削除する。 同時にその構造体の読み書きの待ち状態に"
"あったプロセスに通知する (エラーが返り、 I<errno> が B<EIDRM> に設定され"
"る)。 呼び出したプロセスが適切な特権を持っているか、 呼び出したプロセスの実効"
"ユーザー ID がメッセージキューの作成者か 所有者の実効ユーザー ID でなければな"
"らない。この場合、 B<msgctl>() の第 3 引数は無視される。"

#. type: TP
#: build/C/man2/msgctl.2:217
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:230
msgid ""
"Return information about system-wide message queue limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<msginfo> "
"(thus, a cast is required), defined in I<E<lt>sys/msg.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"システム全体でのメッセージキューの制限とパラメーターに関する情報を、 I<buf> "
"が指す構造体に入れて返す。 この構造体は I<msginfo> 型である (そのためキャスト"
"が必要である)。 I<msginfo> は B<_GNU_SOURCE> 機能検査マクロが定義された場合"
"に I<E<lt>sys/msg.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/msgctl.2:254
#, no-wrap
msgid ""
"struct msginfo {\n"
"    int msgpool; /* Size in kibibytes of buffer pool\n"
"                    used to hold message data;\n"
"                    unused within kernel */\n"
"    int msgmap;  /* Maximum number of entries in message\n"
"                    map; unused within kernel */\n"
"    int msgmax;  /* Maximum number of bytes that can be\n"
"                    written in a single message */\n"
"    int msgmnb;  /* Maximum number of bytes that can be\n"
"                    written to queue; used to initialize\n"
"                    msg_qbytes during queue creation\n"
"                    (msgget(2)) */\n"
"    int msgmni;  /* Maximum number of message queues */\n"
"    int msgssz;  /* Message segment size;\n"
"                    unused within kernel */\n"
"    int msgtql;  /* Maximum number of messages on all queues\n"
"                    in system; unused within kernel */\n"
"    unsigned short msgseg;\n"
"                 /* Maximum number of segments;\n"
"                    unused within kernel */\n"
"};\n"
msgstr ""
"struct msginfo {\n"
"    int msgpool; /* メッセージデータの保持に使用される\n"
"                    バッファープールの大きさ (1024 バイト単位);\n"
"                    カーネル内では未使用 */\n"
"    int msgmap;  /* メッセージマップの最大エントリー数;\n"
"                    カーネル内では未使用 */\n"
"    int msgmax;  /* 一つのメッセージに書き込み可能な\n"
"                    最大バイト数 */\n"
"    int msgmnb;  /* 一つのキューに書き込み可能な最大バイト数;\n"
"                    (msgget(2) での) キュー作成中の msg_qbytes\n"
"                    の初期化に使用される */\n"
"    int msgmni;  /* メッセージキューの数の最大値 */\n"
"    int msgssz;  /* メッセージセグメントのサイズ;\n"
"                    カーネル内では未使用 */\n"
"    int msgtql;  /* システム上の全キューの最大メッセージ数;\n"
"                    カーネル内では未使用 */\n"
"    unsigned short msgseg;\n"
"                 /* 最大セグメント数; カーネル内では未使用 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:267
msgid ""
"The I<msgmni>, I<msgmax>, and I<msgmnb> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""
"設定 I<msgmni ,> I<msgmax ,> I<msgmnb> は I</proc> にある同じ名前のファイル経"
"由で変更可能である。 詳しくは B<proc>(5)  を参照。"

#. type: TP
#: build/C/man2/msgctl.2:267
#, no-wrap
msgid "B<MSG_INFO> (Linux-specific)"
msgstr "B<MSG_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:284
msgid ""
"Return a I<msginfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by message queues: the I<msgpool> field "
"returns the number of message queues that currently exist on the system; the "
"I<msgmap> field returns the total number of messages in all queues on the "
"system; and the I<msgtql> field returns the total number of bytes in all "
"messages in all queues on the system."
msgstr ""
"B<IPC_INFO> のときと同じ情報を格納した I<msginfo> 構造体を返す。 但し、以下の"
"フィールドにはメッセージキューが 消費しているシステム資源に関する情報が格納さ"
"れる点が異なる。 I<msgpool> フィールドは現在システム上に存在するメッセージ"
"キューの数を返す。 I<msgmap> フィールドはシステム上の全てのキューに入っている"
"メッセージ総数を返す。 I<msgtql> フィールドはシステム上の全てのキューに入って"
"いる全メッセージの 総バイト数を返す。"

#. type: TP
#: build/C/man2/msgctl.2:284
#, no-wrap
msgid "B<MSG_STAT> (Linux-specific)"
msgstr "B<MSG_STAT> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:295
msgid ""
"Return a I<msqid_ds> structure as for B<IPC_STAT>.  However, the I<msqid> "
"argument is not a queue identifier, but instead an index into the kernel's "
"internal array that maintains information about all message queues on the "
"system."
msgstr ""
"B<IPC_STAT> と同じく I<msqid_ds> 構造体を返す。 但し、 I<msqid> 引数は、"
"キュー識別子ではなく、システム上の全てのメッセージキュー に関する情報を管理す"
"るカーネルの内部配列へのインデックスである。"

#. type: TP
#: build/C/man2/msgctl.2:295
#, no-wrap
msgid "B<MSG_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<MSG_STAT_ANY> (Linux 固有, Linux 4.17 以降)"

#. type: Plain text
#: build/C/man2/msgctl.2:308
msgid ""
"Return a I<msqid_ds> structure as for B<MSG_STAT>.  However, I<msg_perm."
"mode> is not checked for read access for I<msqid> meaning that any user can "
"employ this operation (just as any user may read I</proc/sysvipc/msg> to "
"obtain the same information)."
msgstr ""

#. type: Plain text
#: build/C/man2/msgctl.2:333
#, fuzzy
#| msgid ""
#| "On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A "
#| "successful B<IPC_INFO> or B<MSG_INFO> operation returns the index of the "
#| "highest used entry in the kernel's internal array recording information "
#| "about all message queues.  (This information can be used with repeated "
#| "B<MSG_STAT> operations to obtain information about all queues on the "
#| "system.)  A successful B<MSG_STAT> operation returns the identifier of "
#| "the queue whose index was given in I<msqid>."
msgid ""
"On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A successful "
"B<IPC_INFO> or B<MSG_INFO> operation returns the index of the highest used "
"entry in the kernel's internal array recording information about all message "
"queues.  (This information can be used with repeated B<MSG_STAT> or "
"B<MSG_STAT_ANY> operations to obtain information about all queues on the "
"system.)  A successful B<MSG_STAT> or B<MSG_STAT_ANY> operation returns the "
"identifier of the queue whose index was given in I<msqid>."
msgstr ""
"成功すると、 B<IPC_STAT>, B<IPC_SET>, B<IPC_RMID> は 0 を返す。 B<IPC_INFO> "
"と B<MSG_INFO> 操作は、成功すると、全てのメッセージキューに関する情報を 管理"
"しているカーネルの内部配列の使用中エントリーのインデックスの うち最大値を返"
"す (この情報は、システムの全てのメッセージキューに関する情報を 取得するため"
"に、 B<MSG_STAT> 操作を繰り返し実行する際に使用できる)。 B<MSG_STAT> 操作は、"
"成功すると、 I<msqid> で指定されたインデックスを持つメッセージキューの識別子"
"を返す。"

#. type: Plain text
#: build/C/man2/msgctl.2:337
msgid "On error, -1 is returned with I<errno> indicating the error."
msgstr "エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/msgctl.2:341
msgid "On failure, I<errno> is set to one of the following:"
msgstr "失敗した場合、 I<errno> は以下の値の中のどれか一つに設定される:"

#. type: Plain text
#: build/C/man2/msgctl.2:354
#, fuzzy
#| msgid ""
#| "The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the "
#| "calling process does not have read permission on the message queue "
#| "I<msqid>, and does not have the B<CAP_IPC_OWNER> capability."
msgid ""
"The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the calling "
"process does not have read permission on the message queue I<msqid>, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""
"引数 I<cmd> が B<IPC_STAT> または B<MSG_STAT> に等しいが、呼び出したプロセ"
"スがメッセージキュー I<msqid> に対する読み込み許可を持っておらず、かつ "
"B<CAP_IPC_OWNER> ケーパビリティを持っていない。"

#. type: TP
#: build/C/man2/msgctl.2:354 build/C/man2/msgop.2:371 build/C/man2/msgop.2:418
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/msgctl.2:365
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_STAT>, but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""
"引数 I<cmd> が B<IPC_SET> か B<IPC_STAT> で、ポインター I<buf> で指されてい"
"るアドレスがアクセス可能でない。"

#. type: TP
#: build/C/man2/msgctl.2:365 build/C/man2/msgop.2:376 build/C/man2/msgop.2:423
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: build/C/man2/msgctl.2:368 build/C/man2/msgop.2:379
msgid "The message queue was removed."
msgstr "メッセージキューが削除された。"

#. type: Plain text
#: build/C/man2/msgctl.2:379
msgid ""
"Invalid value for I<cmd> or I<msqid>.  Or: for a B<MSG_STAT> operation, the "
"index value specified in I<msqid> referred to an array slot that is "
"currently unused."
msgstr ""
"I<cmd> または I<msqid> に不正な値が設定された。 もしくは、 B<MSG_STAT> 操作の"
"場合に、 I<msqid> で指定されたインデックス値が現在未使用の配列のスロットを参"
"照いていた。"

#. type: TP
#: build/C/man2/msgctl.2:379 build/C/man2/msgctl.2:397
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/msgctl.2:397
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID>, but the "
"effective user ID of the calling process is not the creator (as found in "
"I<msg_perm.cuid>)  or the owner (as found in I<msg_perm.uid>)  of the "
"message queue, and the caller is not privileged (Linux: does not have the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""
"引数 I<cmd> が B<IPC_SET> か B<IPC_RMID> であるが、呼び出したプロセスの実効"
"ユーザー ID がメッセージキューの (I<msg_perm.cuid> として見つかる) 作成者 と "
"(I<msg_perm.uid> として見つかる) 所有者のいずれでもなく、 かつ呼び出し者に特"
"権がない (Linux では B<CAP_SYS_ADMIN> ケーパビリティがない)。"

#. type: Plain text
#: build/C/man2/msgctl.2:408
msgid ""
"An attempt (B<IPC_SET>)  was made to increase I<msg_qbytes> beyond the "
"system parameter B<MSGMNB>, but the caller is not privileged (Linux: does "
"not have the B<CAP_SYS_RESOURCE> capability)."
msgstr ""
"B<IPC_SET> で I<msg_qbytes> をシステムパラメーター B<MSGMNB> より大きな値に設"
"定しようとしたが、呼び出し元が特権を持っていなかった (Linux では、 "
"B<CAP_SYS_RESOURCE> ケーパビリティを持っていなかった)。"

#. type: Plain text
#: build/C/man2/msgctl.2:411 build/C/man2/msgget.2:193 build/C/man2/msgop.2:480
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/msgctl.2:424 build/C/man2/msgget.2:206 build/C/man2/msgop.2:503
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""
"Linux や POSIX の全てのバージョンでは、 I<E<lt>sys/types.hE<gt>> と "
"I<E<lt>sys/ipc.hE<gt>> のインクルードは必要ない。しかしながら、いくつかの古い"
"実装ではこれらのヘッダーファイルのインクルードが必要であり、 SVID でもこれら"
"のインクルードをするように記載されている。このような古いシステムへの移植性を"
"意図したアプリケーションではこれらのファイルをインクルードする必要があるかも"
"しれない。"

#. type: Plain text
#: build/C/man2/msgctl.2:436
msgid ""
"The B<IPC_INFO>, B<MSG_STAT>, and B<MSG_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"B<IPC_INFO>, B<MSG_STAT>, B<MSG_INFO> 操作は、 B<ipcs>(1)  プログラムで割り当"
"て済の資源に関する情報を提供するために 使用されている。将来、これらの操作は変"
"更されたり、 I</proc> ファイルシステムのインターフェースに移動されるかもしれ"
"ない。"

#. type: Plain text
#: build/C/man2/msgctl.2:450
msgid ""
"Various fields in the I<struct msqid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"I<struct msqid_ds> 内の多くのフィールドは、 Linux 2.2 では I<short> だった"
"が、Linux 2.4 では I<long> になった。 この利点を生かすには、glibc-2.1.91 以降"
"の環境下で 再コンパイルすれば十分である。 (カーネルは新しい形式の呼び出しと古"
"い形式の呼び出しを I<cmd> 内の B<IPC_64> フラグで区別する。)"

#. type: Plain text
#: build/C/man2/msgctl.2:457
msgid ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr "B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), B<mq_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/msgget.2:35
#, no-wrap
msgid "MSGGET"
msgstr "MSGGET"

#. type: TH
#: build/C/man2/msgget.2:35
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man2/msgget.2:38
msgid "msgget - get a System V message queue identifier"
msgstr "msgget - System V メッセージキュー識別子を取得する"

#. type: Plain text
#: build/C/man2/msgget.2:45
#, no-wrap
msgid "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"
msgstr "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgget.2:61
#, fuzzy
#| msgid ""
#| "The B<msgget>()  system call returns the System\\ V message queue "
#| "identifier associated with the value of the I<key> argument.  A new "
#| "message queue is created if I<key> has the value B<IPC_PRIVATE> or I<key> "
#| "isn't B<IPC_PRIVATE>, no message queue with the given key I<key> exists, "
#| "and B<IPC_CREAT> is specified in I<msgflg>."
msgid ""
"The B<msgget>()  system call returns the System\\ V message queue identifier "
"associated with the value of the I<key> argument.  It may be used either to "
"obtain the identifier of a previously created message queue (when I<msgflg> "
"is zero and I<key> does not have the value B<IPC_PRIVATE>), or to create a "
"new set."
msgstr ""
"B<msgget>()  システムコールは I<key> 引数の値に対応する System\\ V メッセー"
"ジキューの識別子を返す。 I<key> の値が B<IPC_PRIVATE> の場合、または I<key> "
"が B<IPC_PRIVATE> でなくても、 I<key> に対応するメッセージキューが存在せず、 "
"I<msgflg> に B<IPC_CREAT> が指定されている場合、 新しいメッセージキューが作成"
"される。"

#. type: Plain text
#: build/C/man2/msgget.2:76
msgid ""
"A new message queue is created if I<key> has the value B<IPC_PRIVATE> or "
"I<key> isn't B<IPC_PRIVATE>, no message queue with the given key I<key> "
"exists, and B<IPC_CREAT> is specified in I<msgflg>."
msgstr "I<key> の値が B<IPC_PRIVATE> の場合、または I<key> が B<IPC_PRIVATE> でなくても、 I<key> に対応するメッセージキューが存在せず、 I<msgflg> に B<IPC_CREAT> が指定されている場合、 新しいメッセージキューが作成される。"

#. type: Plain text
#: build/C/man2/msgget.2:95
msgid ""
"If I<msgflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a message queue "
"already exists for I<key>, then B<msgget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""
"I<msgflg> に B<IPC_CREAT> と B<IPC_EXCL> の両方が指定された場合、 I<key> に対"
"応するメッセージキューが既に存在すると、 B<msgget>()  は失敗し、 I<errno> に "
"B<EEXIST> が設定される。 (これは B<open>(2)  に B<O_CREAT | O_EXCL> を指定し"
"た場合の動作と同じである)"

#. type: Plain text
#: build/C/man2/msgget.2:105
msgid ""
"Upon creation, the least significant bits of the argument I<msgflg> define "
"the permissions of the message queue.  These permission bits have the same "
"format and semantics as the permissions specified for the I<mode> argument "
"of B<open>(2).  (The execute permissions are not used.)"
msgstr ""
"メッセージキューの作成時に、 I<msgflg> 引数の下位 9 ビットは、 そのメッセー"
"ジキューのアクセス許可の定義として使用される。 これらの許可ビットは "
"B<open>(2)  の引数 I<mode> と同じ形式で同じ意味である。 や B<creat>(2)  シ"
"ステムコールのアクセス許可パラメーターと同じ形式で、同じ意味を持つ。 (但し、"
"実行 (execute) 許可は使用されない。)"

#. type: Plain text
#: build/C/man2/msgget.2:112
msgid ""
"If a new message queue is created, then its associated data structure "
"I<msqid_ds> (see B<msgctl>(2))  is initialized as follows:"
msgstr ""
"新規のメッセージキューを作成する際、 B<msgget>()  システムコールはメッセージ"
"キューのデータ構造体 I<msqid_ds> を以下のように初期化する (I<msqid_ds> につい"
"ては B<msgctl>(2)  を参照):"

#. type: IP
#: build/C/man2/msgget.2:112 build/C/man2/msgget.2:117
#: build/C/man2/msgget.2:122 build/C/man2/msgget.2:127
#: build/C/man2/msgget.2:135 build/C/man2/msgget.2:138 build/C/man2/msgop.2:117
#: build/C/man2/msgop.2:122 build/C/man2/msgop.2:146 build/C/man2/msgop.2:153
#: build/C/man2/msgop.2:168 build/C/man2/msgop.2:171 build/C/man2/msgop.2:174
#: build/C/man2/msgop.2:220 build/C/man2/msgop.2:225 build/C/man2/msgop.2:239
#: build/C/man2/msgop.2:307 build/C/man2/msgop.2:309 build/C/man2/msgop.2:315
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man2/msgget.2:117
msgid ""
"I<msg_perm.cuid> and I<msg_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"I<msg_perm.cuid> と I<msg_perm.uid> に呼び出し元プロセスの実効 (effective) "
"ユーザーID を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:122
msgid ""
"I<msg_perm.cgid> and I<msg_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"I<msg_perm.cgid> と I<msg_perm.gid> に呼び出し元プロセスの実効 (effective) グ"
"ループID を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:127
msgid ""
"The least significant 9 bits of I<msg_perm.mode> are set to the least "
"significant 9 bits of I<msgflg>."
msgstr ""
"I<msg_perm.mode> の下位 9 ビットは I<msgflg> の下位 9 ビットを設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:135
msgid ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, and I<msg_rtime> are "
"set to 0."
msgstr ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, I<msg_rtime> に 0 を設"
"定される。"

#. type: Plain text
#: build/C/man2/msgget.2:138
msgid "I<msg_ctime> is set to the current time."
msgstr "I<msg_ctime> に現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:142
msgid "I<msg_qbytes> is set to the system limit B<MSGMNB>."
msgstr ""
"I<msg_qbytes> に、システムで決められたメッセージキューの最大サイズ B<MSGMNB> "
"を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:146
msgid ""
"If the message queue already exists the permissions are verified, and a "
"check is made to see if it is marked for destruction."
msgstr ""
"メッセージキューがすでに存在する場合は、アクセス許可の検査と、 破棄 "
"(destruction) マークがないかの確認が行われる。"

#. type: Plain text
#: build/C/man2/msgget.2:152
msgid ""
"If successful, the return value will be the message queue identifier (a "
"nonnegative integer), otherwise -1 with I<errno> indicating the error."
msgstr ""
"成功した場合、返り値はメッセージキュー識別子 (非負の整数) となる。 失敗した場"
"合は -1 が返され、 I<errno> にそのエラーが示される。"

#. type: Plain text
#: build/C/man2/msgget.2:156
msgid "On failure, I<errno> is set to one of the following values:"
msgstr "失敗した場合、 I<errno> に以下の値のいずれか一つが設定される:"

#. type: Plain text
#: build/C/man2/msgget.2:164
#, fuzzy
#| msgid ""
#| "A message queue exists for I<key>, but the calling process does not have "
#| "permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
#| "capability."
msgid ""
"A message queue exists for I<key>, but the calling process does not have "
"permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"I<key> に対応するメッセージキューは存在するが、 呼び出し元プロセスはその"
"キューに対するアクセス許可がなく、 B<CAP_IPC_OWNER> ケーパビリティも持ってい"
"ない。"

#. type: Plain text
#: build/C/man2/msgget.2:173
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<msgflg>, but a message "
"queue already exists for I<key>."
msgstr ""
"I<msgflg> に B<IPC_CREAT> と B<IPC_EXCL> が指定されたが、 I<key> に対応する"
"メッセージキューがすでに存在する。"

#. type: Plain text
#: build/C/man2/msgget.2:181
msgid ""
"No message queue exists for I<key> and I<msgflg> did not specify "
"B<IPC_CREAT>."
msgstr ""
"I<key> に対応するメッセージキューが存在せず、 I<msgflg> に B<IPC_CREAT> が指"
"定されていなかった。"

#. type: Plain text
#: build/C/man2/msgget.2:185
msgid ""
"A message queue has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""
"メッセージキューを作成しようとしたが、新しいデータ構造体を作成 するのに十分な"
"メモリーがシステムに存在しない。"

#. type: Plain text
#: build/C/man2/msgget.2:191
msgid ""
"A message queue has to be created but the system limit for the maximum "
"number of message queues (B<MSGMNI>)  would be exceeded."
msgstr ""
"メッセージキューを作成しようとしたが、作成すると システム全体のメッセージ"
"キュー数の最大値 (B<MSGMNI>)  を超えてしまう。"

#. type: Plain text
#: build/C/man2/msgget.2:216
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<msgflg> and creates a new message queue (on success)."
msgstr ""
"B<IPC_PRIVATE> はフラグではなく、 I<key_t> 型である。 この特別な値が I<key> "
"として使用された場合、 B<msgget>()  システムコールは I<msgflg> の下位 9 ビッ"
"ト以外の全てを無視して (成功した場合は) 新しいメッセージキューを作成する。"

#. type: Plain text
#: build/C/man2/msgget.2:220
msgid ""
"The following is a system limit on message queue resources affecting a "
"B<msgget>()  call:"
msgstr ""
"B<msgget>()  システムコールに影響を及ぼすメッセージキューの資源の システムと"
"しての制限を以下に示す:"

#. type: TP
#: build/C/man2/msgget.2:220
#, no-wrap
msgid "B<MSGMNI>"
msgstr "B<MSGMNI>"

#.  commit 0050ee059f7fc86b1df2527aaa14ed5dc72f9973
#. type: Plain text
#: build/C/man2/msgget.2:230
#, fuzzy
#| msgid ""
#| "System-wide limit on the number of message queues: policy dependent (on "
#| "Linux, this limit can be read and modified via I</proc/sys/kernel/"
#| "msgmni>)."
msgid ""
"System-wide limit on the number of message queues.  Before Linux 3.19, the "
"default value for this limit was calculated using a formula based on "
"available system memory.  Since Linux 3.19, the default value is 32,000.  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmni>."
msgstr ""
"システム全体のメッセージキュー数の上限値: 方針依存 (Linux では、この制限値は "
"I</proc/sys/kernel/msgmni> 経由で参照したり、変更したりできる)。"

#. type: SS
#: build/C/man2/msgget.2:230
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/msgget.2:236
msgid ""
"Until version 2.3.20, Linux would return B<EIDRM> for a B<msgget>()  on a "
"message queue scheduled for deletion."
msgstr ""
"Linux 2.3.20 までは、削除が予定されているメッセージキューに対して "
"B<msgget>()  を行うと B<EIDRM> がエラーとして返されるようになっていた。"

#. type: Plain text
#: build/C/man2/msgget.2:242
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"B<IPC_PRIVATE> という名前を選んだのはおそらく失敗であろう。 B<IPC_NEW> の方が"
"より明確にその機能を表しているだろう。"

#. type: Plain text
#: build/C/man2/msgget.2:250
msgid ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr "B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), B<mq_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/msgop.2:40
#, no-wrap
msgid "MSGOP"
msgstr "MSGOP"

#. type: Plain text
#: build/C/man2/msgop.2:43
msgid "msgrcv, msgsnd - System V message queue operations"
msgstr "msgrcv, msgsnd - System V メッセージキュー操作"

#. type: Plain text
#: build/C/man2/msgop.2:51
#, no-wrap
msgid "B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, int >I<msgflg>B<);>\n"
msgstr "B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgop.2:55
#, no-wrap
msgid ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"
msgstr ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgop.2:65
msgid ""
"The B<msgsnd>()  and B<msgrcv>()  system calls are used to send messages to, "
"and receive messages from, a System\\ V message queue.  The calling process "
"must have write permission on the message queue in order to send a message, "
"and read permission to receive a message."
msgstr "システムコール B<msgsnd>() と B<msgrcv>() は、 System\\ V メッセージキューへのメッセージの送信と、メッセージの受信に使用される。呼び出し元プロセスは、 メッセージを送信するためにはメッセージキューに対する書き込み許可を、 メッセージを受信するためには読み出し許可を持っていなければならない。"

#. type: Plain text
#: build/C/man2/msgop.2:70
msgid ""
"The I<msgp> argument is a pointer to a caller-defined structure of the "
"following general form:"
msgstr ""
"呼び出し元プロセスは以下に示す構造体を用意し、この構造体への ポインターを "
"I<msgp> 引数として渡す。"

#. type: Plain text
#: build/C/man2/msgop.2:77
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"
msgstr ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgop.2:96
msgid ""
"The I<mtext> field is an array (or other structure) whose size is specified "
"by I<msgsz>, a nonnegative integer value.  Messages of zero length (i.e., no "
"I<mtext> field) are permitted.  The I<mtype> field must have a strictly "
"positive integer value.  This value can be used by the receiving process for "
"message selection (see the description of B<msgrcv>()  below)."
msgstr ""
"I<mtext> フィールドは配列 (または他の構造体) で、その大きさは 非負の整数であ"
"る I<msgsz> で指定される。 長さ 0 のメッセージ (つまり I<mtext> フィールドが"
"ないメッセージ) も認められている。 B<mtype> フィールドは厳密に正の整数でなけ"
"ればならない。 この値は、メッセージを受信するプロセスでメッセージを選択するた"
"めに 使用される (下記の B<msgrcv>()  の説明を参照のこと)。"

#. type: SS
#: build/C/man2/msgop.2:96
#, no-wrap
msgid "msgsnd()"
msgstr "msgsnd()"

#. type: Plain text
#: build/C/man2/msgop.2:104
msgid ""
"The B<msgsnd>()  system call appends a copy of the message pointed to by "
"I<msgp> to the message queue whose identifier is specified by I<msqid>."
msgstr ""
"B<msgsnd>()  システムコールは I<msgp> 引数で指定されたメッセージのコピーを "
"I<msqid> で指定された識別子を持つメッセージキューへ追加する。"

#. type: Plain text
#: build/C/man2/msgop.2:117
msgid ""
"If sufficient space is available in the queue, B<msgsnd>()  succeeds "
"immediately.  The queue capacity is governed by the I<msg_qbytes> field in "
"the associated data structure for the message queue.  During queue creation "
"this field is initialized to B<MSGMNB> bytes, but this limit can be modified "
"using B<msgctl>(2).  A message queue is considered to be full if either of "
"the following conditions is true:"
msgstr ""
"キューに十分な空き容量がある場合、 B<msgsnd>()  は直ちに成功する。 キューの容"
"量は、メッセージキューのデータ構造体の I<msg_qbytes> フィールドで制御され"
"る。 キュー作成時にこのフィールドは B<MSGMNB> に初期化されるが、この制限は "
"B<msgctl>(2)  を使って変更できる。 次のいずれかの条件が成立する場合に、メッ"
"セージキューは一杯と判断される。"

#. type: Plain text
#: build/C/man2/msgop.2:122
msgid ""
"Adding a new message to the queue would cause the total number of bytes in "
"the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
msgstr ""
"新しいメッセージをそのキューに追加すると、 そのキューの全バイト数がキューの最"
"大サイズ (I<msg_qbytes> フィールド) を超過してしまう場合。"

#. type: Plain text
#: build/C/man2/msgop.2:131
msgid ""
"Adding another message to the queue would cause the total number of messages "
"in the queue to exceed the queue's maximum size (the I<msg_qbytes> field).  "
"This check is necessary to prevent an unlimited number of zero-length "
"messages being placed on the queue.  Although such messages contain no data, "
"they nevertheless consume (locked) kernel memory."
msgstr ""
"そのキューにもう一つメッセージを追加すると、 そのキューが全メッセージ数が"
"キューの最大サイズ (I<msg_qbytes> フィールド) を超過してしまう場合。 この"
"チェックは、無限個の長さ 0 のメッセージをそのキューに追加するのを防ぐために必"
"要である。 長さ 0 のメッセージはデータを含まないが、 (ロックされた) カーネル"
"メモリーを消費するからである。"

#. type: Plain text
#: build/C/man2/msgop.2:142
msgid ""
"If insufficient space is available in the queue, then the default behavior "
"of B<msgsnd>()  is to block until space becomes available.  If B<IPC_NOWAIT> "
"is specified in I<msgflg>, then the call instead fails with the error "
"B<EAGAIN>."
msgstr ""
"そのキューに十分な領域がない場合、 デフォルトの動作では、 必要な領域ができる"
"まで B<msgsnd>() は停止 (block) する。 I<msgflg> に B<IPC_NOWAIT> が指定され"
"た場合、 B<msgsnd>() はエラー B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/msgop.2:146
msgid "A blocked B<msgsnd>()  call may also fail if:"
msgstr "停止している B<msgsnd>()  は以下の場合にも失敗する。"

#. type: Plain text
#: build/C/man2/msgop.2:153
msgid ""
"the queue is removed, in which case the system call fails with I<errno> set "
"to B<EIDRM>; or"
msgstr "キューが削除された。 この場合、 I<errno> は B<EIDRM> に設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:165
msgid ""
"a signal is caught, in which case the system call fails with I<errno> set to "
"B<EINTR>;B<see> B<signal>(7).  (B<msgsnd>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""
"シグナルが捕捉された。 この場合、 I<errno> は B<EINTR> に設定される。 "
"B<signal>(7)  参照。 (B<msgsnd>()  は、たとえシグナルハンドラーの設定時に "
"B<SA_RESTART> を指定していたとしても、シグナルハンドラーによって割り込まれた"
"後で 自動的に再スタートすることは決してない。)"

#. type: Plain text
#: build/C/man2/msgop.2:168 build/C/man2/msgop.2:329
msgid ""
"Upon successful completion the message queue data structure is updated as "
"follows:"
msgstr ""
"正常に終了した場合、メッセージキューのデータ構造体は以下のように 更新される:"

#. type: Plain text
#: build/C/man2/msgop.2:171
msgid "I<msg_lspid> is set to the process ID of the calling process."
msgstr "I<msg_lspid> には呼び出し元プロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:174
msgid "I<msg_qnum> is incremented by 1."
msgstr "I<msg_qnum> は 1 増加する。"

#. type: Plain text
#: build/C/man2/msgop.2:177
msgid "I<msg_stime> is set to the current time."
msgstr "I<msg_stime> には現在時刻が設定される。"

#. type: SS
#: build/C/man2/msgop.2:177
#, no-wrap
msgid "msgrcv()"
msgstr "msgrcv()"

#. type: Plain text
#: build/C/man2/msgop.2:185
msgid ""
"The B<msgrcv>()  system call removes a message from the queue specified by "
"I<msqid> and places it in the buffer pointed to by I<msgp>."
msgstr ""
"B<msgrcv>()  システムコールは I<msqid> で指定されたキューからメッセージを削除"
"し、 I<msgp> で指定されたバッファーにそのメッセージを格納する。"

#. type: Plain text
#: build/C/man2/msgop.2:211
msgid ""
"The argument I<msgsz> specifies the maximum size in bytes for the member "
"I<mtext> of the structure pointed to by the I<msgp> argument.  If the "
"message text has length greater than I<msgsz>, then the behavior depends on "
"whether B<MSG_NOERROR> is specified in I<msgflg>.  If B<MSG_NOERROR> is "
"specified, then the message text will be truncated (and the truncated part "
"will be lost); if B<MSG_NOERROR> is not specified, then the message isn't "
"removed from the queue and the system call fails returning -1 with I<errno> "
"set to B<E2BIG>."
msgstr ""
"I<msgsz> 引数には I<msgp> 引数で指定された構造体の I<mtext> メンバーの最"
"大のバイト数を指定する。 メッセージのテキストの長さが I<msgsz> より大きい場合"
"の動作は、 I<msgflg> に B<MSG_NOERROR> が指定されているかどうかで決まる。 "
"B<MSG_NOERROR> が指定されていれば、メッセージのテキストは切り詰められる (切り"
"捨てられた部分は失われる)。 B<MSG_NOERROR> が指定されていなければ、メッセージ"
"はキューから削除されず、 システムコールは -1 を返して失敗し、 I<errno> に "
"B<E2BIG> が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:220
msgid ""
"Unless B<MSG_COPY> is specified in I<msgflg> (see below), the I<msgtyp> "
"argument specifies the type of message requested, as follows:"
msgstr ""
"B<MSG_COPY> が I<msgflg> に指定されていない場合 (下記参照)、 I<msgtyp> 引数"
"には要求するメッセージの型を指定する。 型は以下のように指定する:"

#. type: Plain text
#: build/C/man2/msgop.2:225
msgid "If I<msgtyp> is 0, then the first message in the queue is read."
msgstr "I<msgtyp> が 0 ならば、キューの最初にあるメッセージが読み込まれる。"

#. type: Plain text
#: build/C/man2/msgop.2:239
msgid ""
"If I<msgtyp> is greater than 0, then the first message in the queue of type "
"I<msgtyp> is read, unless B<MSG_EXCEPT> was specified in I<msgflg>, in which "
"case the first message in the queue of type not equal to I<msgtyp> will be "
"read."
msgstr ""
"I<msgtyp> が 0 より大きい場合、 I<msgflg> に B<MSG_EXCEPT> が指定されていなけ"
"れば、 I<msgtyp> 型のキューの最初のメッセージが読み込まれる。 B<MSG_EXCEPT> "
"が指定された場合は、 I<msgtyp> 型以外のキューの最初のメッセージが読み込まれ"
"る。"

#. type: Plain text
#: build/C/man2/msgop.2:247
msgid ""
"If I<msgtyp> is less than 0, then the first message in the queue with the "
"lowest type less than or equal to the absolute value of I<msgtyp> will be "
"read."
msgstr ""
"I<msgtyp> が 0 より小さければ、 I<msgtyp> の絶対値以下で最も小さい型を持つ"
"キューの最初のメッセージが読み込まれる。"

#. type: Plain text
#: build/C/man2/msgop.2:252
msgid ""
"The I<msgflg> argument is a bit mask constructed by ORing together zero or "
"more of the following flags:"
msgstr ""
"I<msgflg> 引数には、以下のフラグを任意の数だけ (0個も可)、これらの OR で指"
"定する:"

#. type: TP
#: build/C/man2/msgop.2:252
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: build/C/man2/msgop.2:259
msgid ""
"Return immediately if no message of the requested type is in the queue.  The "
"system call fails with I<errno> set to B<ENOMSG>."
msgstr ""
"キューに要求された型のメッセージがない場合には直ちに返る。 システムコールは失"
"敗し、 I<errno> には B<ENOMSG> が設定される。"

#. type: TP
#: build/C/man2/msgop.2:259
#, no-wrap
msgid "B<MSG_COPY> (since Linux 3.8)"
msgstr "B<MSG_COPY> (Linux 3.8 以降)"

#.  commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
#. type: Plain text
#: build/C/man2/msgop.2:266
msgid ""
"Nondestructively fetch a copy of the message at the ordinal position in the "
"queue specified by I<msgtyp> (messages are considered to be numbered "
"starting at 0)."
msgstr ""
"キューの中で I<msgtyp> で指定した位置にあるメッセージのコピーを、キューを変更"
"せずに (非破壊的に) 取り出す (メッセージの位置は 0 から順番に番号が割り当てら"
"れる)。"

#. type: Plain text
#: build/C/man2/msgop.2:280
msgid ""
"This flag must be specified in conjunction with B<IPC_NOWAIT>, with the "
"result that, if there is no message available at the given position, the "
"call fails immediately with the error B<ENOMSG>.  Because they alter the "
"meaning of I<msgtyp> in orthogonal ways, B<MSG_COPY> and B<MSG_EXCEPT> may "
"not both be specified in I<msgflg>."
msgstr ""
"このフラグは B<IPC_NOWAIT> と組み合わせて指定しなければならない。 その結果、"
"指定した位置にメッセージがなかった場合、呼び出しはエラー B<ENOMSG> ですぐに失"
"敗する。 B<MSG_COPY> と B<MSG_EXCEPT> は I<msgtyp> の意味を相容れない方法で使"
"用するため、この二つのフラグの両方を I<msgtyp> に指定することはできない。"

#. type: Plain text
#: build/C/man2/msgop.2:288
msgid ""
"The B<MSG_COPY> flag was added for the implementation of the kernel "
"checkpoint-restore facility and is available only if the kernel was built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""
"B<MSG_COPY> フラグは、 カーネルのチェックポイント復元 (checkpoint-restore) 機"
"能の実装のために追加された。 このフラグはカーネルが "
"B<CONFIG_CHECKPOINT_RESTORE> オプションを有効にして作成された場合にのみ利用で"
"きる。"

#. type: TP
#: build/C/man2/msgop.2:288
#, no-wrap
msgid "B<MSG_EXCEPT>"
msgstr "B<MSG_EXCEPT>"

#. type: Plain text
#: build/C/man2/msgop.2:296
msgid ""
"Used with I<msgtyp> greater than 0 to read the first message in the queue "
"with message type that differs from I<msgtyp>."
msgstr ""
"0 より大きな I<msgtyp> と一緒に使用して、 I<msgtyp> 以外のキューの最初のメッ"
"セージを読み込む。"

#. type: TP
#: build/C/man2/msgop.2:296
#, no-wrap
msgid "B<MSG_NOERROR>"
msgstr "B<MSG_NOERROR>"

#. type: Plain text
#: build/C/man2/msgop.2:301
msgid "To truncate the message text if longer than I<msgsz> bytes."
msgstr "I<msgsz> バイトよりも長かった場合はメッセージのテキストを切り詰める。"

#. type: Plain text
#: build/C/man2/msgop.2:307
msgid ""
"If no message of the requested type is available and B<IPC_NOWAIT> isn't "
"specified in I<msgflg>, the calling process is blocked until one of the "
"following conditions occurs:"
msgstr ""
"要求された型のメッセージが存在せず、 I<msgflg> に B<IPC_NOWAIT> が指定されて"
"いなかった場合、呼び出し元プロセスは 以下のいずれかの状況になるまで停止 "
"(block) される:"

#. type: Plain text
#: build/C/man2/msgop.2:309
msgid "A message of the desired type is placed in the queue."
msgstr "要求している型のメッセージがキューへ入れられた。"

#. type: Plain text
#: build/C/man2/msgop.2:315
msgid ""
"The message queue is removed from the system.  In this case, the system call "
"fails with I<errno> set to B<EIDRM>."
msgstr ""
"メッセージキューがシステムから削除された。 この場合、システムコールは失敗"
"し、 I<errno> に B<EIDRM> が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:326
msgid ""
"The calling process catches a signal.  In this case, the system call fails "
"with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""
"呼び出し元プロセスがシグナルを捕獲した。 この場合、システムコールは失敗し、 "
"I<errno> に B<EINTR> が設定される。 (B<msgrcv>()  は、たとえシグナルハンド"
"ラーの設定時に B<SA_RESTART> を指定していたとしても、シグナルハンドラーによっ"
"て割り込まれた後で 自動的に再スタートすることは決してない。)"

#. type: Plain text
#: build/C/man2/msgop.2:332
msgid "I<msg_lrpid> is set to the process ID of the calling process."
msgstr "I<msg_lrpid> には呼び出し元プロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:335
msgid "I<msg_qnum> is decremented by 1."
msgstr "I<msg_qnum> は 1 減算される。"

#. type: Plain text
#: build/C/man2/msgop.2:338
msgid "I<msg_rtime> is set to the current time."
msgstr "I<msg_rtime> には現在の時刻が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:351
msgid ""
"On failure both functions return -1 with I<errno> indicating the error, "
"otherwise B<msgsnd>()  returns 0 and B<msgrcv>()  returns the number of "
"bytes actually copied into the I<mtext> array."
msgstr ""
"失敗した場合は、どちらの関数も -1 を返し、エラーを I<errno> に表示する。成功"
"した場合、 B<msgsnd>()  は 0 を返し、 B<msgrcv>()  は I<mtext> 配列に実際にコ"
"ピーしたバイト数を返す。"

#. type: Plain text
#: build/C/man2/msgop.2:357
msgid ""
"When B<msgsnd>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""
"B<msgsnd>()  が失敗した場合、 B<errno> に以下の値のいずれかが設定される:"

#. type: Plain text
#: build/C/man2/msgop.2:363
#, fuzzy
#| msgid ""
#| "The calling process does not have write permission on the message queue, "
#| "and does not have the B<CAP_IPC_OWNER> capability."
msgid ""
"The calling process does not have write permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""
"呼び出し元プロセスにはメッセージキューに対する書き込み許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティもない。"

#. type: Plain text
#: build/C/man2/msgop.2:371
msgid ""
"The message can't be sent due to the I<msg_qbytes> limit for the queue and "
"B<IPC_NOWAIT> was specified in I<msgflg>."
msgstr ""
"I<msg_qbytes> がキューの制限を超えていたため、メッセージを送ることができず、"
"かつ I<msgflg> に B<IPC_NOWAIT> が指定されていた。"

#. type: Plain text
#: build/C/man2/msgop.2:376 build/C/man2/msgop.2:423
msgid "The address pointed to by I<msgp> isn't accessible."
msgstr "I<msgp> が指しているアドレスがアクセス可能でない。"

#. type: Plain text
#: build/C/man2/msgop.2:382
msgid ""
"Sleeping on a full message queue condition, the process caught a signal."
msgstr ""
"メッセージキューが要求した条件を満たすまで停止している時に、 プロセスがシグナ"
"ルを捕獲した。"

#. type: Plain text
#: build/C/man2/msgop.2:393
msgid ""
"Invalid I<msqid> value, or nonpositive I<mtype> value, or invalid I<msgsz> "
"value (less than 0 or greater than the system value B<MSGMAX>)."
msgstr ""
"I<msqid> が不適切な値であるか、 I<mtype> が正の値でないか、 I<msgsz> が不適切"
"な値 (0 以下か、システムで決まる値 B<MSGMAX> よりも大きい値) である。"

#. type: Plain text
#: build/C/man2/msgop.2:398
msgid ""
"The system does not have enough memory to make a copy of the message pointed "
"to by I<msgp>."
msgstr ""
"I<msgp> が指すメッセージのコピーを作成するのに十分なメモリーがシステムに存在"
"しない。"

#. type: Plain text
#: build/C/man2/msgop.2:404
msgid ""
"When B<msgrcv>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""
"B<msgrcv>()  が失敗した場合には I<errno> に以下の値のいずれかが設定される:"

#. type: TP
#: build/C/man2/msgop.2:404
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/msgop.2:412
msgid ""
"The message text length is greater than I<msgsz> and B<MSG_NOERROR> isn't "
"specified in I<msgflg>."
msgstr ""
"メッセージのテキストの長さが I<msgsz> よりも大きく、 I<msgflg> に "
"B<MSG_NOERROR> が設定されていなかった。"

#. type: Plain text
#: build/C/man2/msgop.2:418
#, fuzzy
#| msgid ""
#| "The calling process does not have read permission on the message queue, "
#| "and does not have the B<CAP_IPC_OWNER> capability."
msgid ""
"The calling process does not have read permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""
"呼び出し元プロセスにはメッセージキューに対する読み込み許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティもない。"

#. type: Plain text
#: build/C/man2/msgop.2:427
msgid ""
"While the process was sleeping to receive a message, the message queue was "
"removed."
msgstr ""
"メッセージを受信するためにプロセスが停止している間に、 メッセージキューが削除"
"された。"

#. type: Plain text
#: build/C/man2/msgop.2:432
msgid ""
"While the process was sleeping to receive a message, the process caught a "
"signal; see B<signal>(7)."
msgstr ""
"メッセージを受けるためにプロセスが停止している間に、 プロセスがシグナルを捕獲"
"した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/msgop.2:438
msgid "I<msqid> was invalid, or I<msgsz> was less than 0."
msgstr "I<msgid> が不正か、 I<msgsz> が 0 より小さい。"

#. type: TP
#: build/C/man2/msgop.2:438 build/C/man2/msgop.2:445
#, no-wrap
msgid "B<EINVAL> (since Linux 3.14)"
msgstr "B<EINVAL> (Linux 3.14 以降)"

#. type: Plain text
#: build/C/man2/msgop.2:445
msgid "I<msgflg> specified B<MSG_COPY>, but not B<IPC_NOWAIT>."
msgstr ""
"I<msgflg> に B<MSG_COPY> が指定されたが、 B<IPC_NOWAIT> が指定されていない。"

#. type: Plain text
#: build/C/man2/msgop.2:452
msgid "I<msgflg> specified both B<MSG_COPY> and B<MSG_EXCEPT>."
msgstr "I<msgflg> に B<MSG_COPY> と B<MSG_EXCEPT> の両方が指定された。"

#. type: TP
#: build/C/man2/msgop.2:452 build/C/man2/msgop.2:458
#, no-wrap
msgid "B<ENOMSG>"
msgstr "B<ENOMSG>"

#. type: Plain text
#: build/C/man2/msgop.2:458
msgid ""
"B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
"type existed on the message queue."
msgstr ""
"I<msgflg> に B<IPC_NOWAIT> が設定されており、 メッセージキューに要求された型"
"のメッセージが存在しなかった。"

#. type: Plain text
#: build/C/man2/msgop.2:468
msgid ""
"B<IPC_NOWAIT> and B<MSG_COPY> were specified in I<msgflg> and the queue "
"contains less than I<msgtyp> messages."
msgstr ""
"B<IPC_NOWAIT> と B<MSG_COPY> が I<msgflg> に指定されたが、 キューには "
"I<msgtyp> 未満のメッセージしか入っていなかった。"

#. type: TP
#: build/C/man2/msgop.2:468
#, no-wrap
msgid "B<ENOSYS> (since Linux 3.8)"
msgstr "B<ENOSYS> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/msgop.2:478
msgid ""
"Both B<MSG_COPY> and B<IPC_NOWAIT> were specified in I<msgflg>, and this "
"kernel was configured without B<CONFIG_CHECKPOINT_RESTORE>."
msgstr "I<msgflg> に I<MSG_COPY> と B<IPC_NOWAIT> の両方が指定されたが、カーネルが B<CONFIG_CHECKPOINT_RESTORE> なしで作成されている。"

#.  MSG_COPY since glibc 2.18
#. type: Plain text
#: build/C/man2/msgop.2:490
msgid ""
"The B<MSG_EXCEPT> and B<MSG_COPY> flags are Linux-specific; their "
"definitions can be obtained by defining the B<_GNU_SOURCE> feature test "
"macro."
msgstr ""
"フラグ B<MSG_EXCEPT> と B<MSG_COPY> は Linux 固有である。 これらの定義を得る"
"には、機能検査マクロ B<_GNU_SOURCE> を定義する。"

#. type: Plain text
#: build/C/man2/msgop.2:510
msgid ""
"The I<msgp> argument is declared as I<struct msgbuf\\ *> in glibc 2.0 and "
"2.1.  It is declared as I<void\\ *> in glibc 2.2 and later, as required by "
"SUSv2 and SUSv3."
msgstr ""
"I<msgp> 引数は、 glibc 2.0 と 2.1 では I<struct msgbuf\\ *> と宣言されてい"
"る。glibc 2.2 以降では、 SUSv2 と SUSv3 の要求通り、I<void\\ *> と宣言されて"
"いる。"

#. type: Plain text
#: build/C/man2/msgop.2:514
msgid ""
"The following limits on message queue resources affect the B<msgsnd>()  call:"
msgstr "以下は B<msgsnd> システムコールに影響するシステム制限である:"

#. type: TP
#: build/C/man2/msgop.2:514
#, no-wrap
msgid "B<MSGMAX>"
msgstr "B<MSGMAX>"

#. type: Plain text
#: build/C/man2/msgop.2:519
#, fuzzy
#| msgid ""
#| "Maximum size for a message text: 8192 bytes (on Linux, this limit can be "
#| "read and modified via I</proc/sys/kernel/msgmax>)."
msgid ""
"Maximum size of a message text, in bytes (default value: 8192 bytes).  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmax>."
msgstr ""
"メッセージのテキストの最大サイズ: 8192 バイト (Linux では、この制限値は I</"
"proc/sys/kernel/msgmax> 経由で読み出したり変更したりできる)。"

#. type: TP
#: build/C/man2/msgop.2:519
#, no-wrap
msgid "B<MSGMNB>"
msgstr "B<MSGMNB>"

#. type: Plain text
#: build/C/man2/msgop.2:535
#, fuzzy
#| msgid ""
#| "Default maximum size in bytes of a message queue: 16384 bytes (on Linux, "
#| "this limit can be read and modified via I</proc/sys/kernel/msgmnb>).  A "
#| "privileged process (Linux: a process with the B<CAP_SYS_RESOURCE> "
#| "capability)  can increase the size of a message queue beyond B<MSGMNB> by "
#| "a B<msgctl>(2)  system call."
msgid ""
"Maximum number of bytes that can be held in a message queue (default value: "
"16384 bytes).  On Linux, this limit can be read and modified via I</proc/sys/"
"kernel/msgmnb>.  A privileged process (Linux: a process with the "
"B<CAP_SYS_RESOURCE> capability)  can increase the size of a message queue "
"beyond B<MSGMNB> using the B<msgctl>(2)  B<IPC_SET> operation."
msgstr ""
"バイト単位でのメッセージキューのデフォルトの最大サイズ : 16384 バイト。 "
"(Linux では、この制限値は I</proc/sys/kernel/msgmnb> 経由で読み出したり変更し"
"たりできる)。 特権プロセス (Linux ではケーパビリティ B<CAP_SYS_RESOURCE> を"
"持ったプロセス) は B<msgctl>(2)  システムコールでメッセージキューのサイズを "
"B<MSGMNB> よりも大きい値に増やすことができる。"

#. type: Plain text
#: build/C/man2/msgop.2:541
msgid ""
"The implementation has no intrinsic system-wide limits on the number of "
"message headers (B<MSGTQL>)  and the number of bytes in the message pool "
"(B<MSGPOOL>)."
msgstr ""
"現在の実装では、システム全体のメッセージヘッダーの上限数 (B<MSGTQL>)  と、シ"
"ステム全体のメッセージプールの最大バイト数 (B<MSGPOOL>)  に関して実装依存の制"
"限はない。"

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: build/C/man2/msgop.2:561
msgid ""
"In Linux 3.13 and earlier, if B<msgrcv>()  was called with the B<MSG_COPY> "
"flag, but without B<IPC_NOWAIT>, and the message queue contained less than "
"I<msgtyp> messages, then the call would block until the next message is "
"written to the queue.  At that point, the call would return a copy of the "
"message, I<regardless> of whether that message was at the ordinal position "
"I<msgtyp>.  This bug is fixed in Linux 3.14."
msgstr ""
"Linux 3.13 以前では、 B<msgrcv>() の呼び出しで B<MSG_COPY> フラグは指定された"
"が B<IPC_NOWAIT> は指定されず、かつメッセージキューに I<msgtyp> 未満のメッ"
"セージしかない場合に、 B<msgrcv>() の呼び出しはキューに次のメッセージが書き込"
"まれるまで停止していた。 新しいメッセージが書き込まれた時点で、 そのメッセー"
"ジが指定された位置 I<msgtyp> かどうかにI<関わらず>、 B<msgrcv>() の呼び出しは"
"新たに書き込まれたメッセージのコピーを返していた。 このバグは Linux ３．１４"
"で修正された。"

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: build/C/man2/msgop.2:577
msgid ""
"Specifying both B<MSG_COPY> and B<MSC_EXCEPT> in I<msgflg> is a logical "
"error (since these flags impose different interpretations on I<msgtyp>).  In "
"Linux 3.13 and earlier, this error was not diagnosed by B<msgrcv>().  This "
"bug is fixed in Linux 3.14."
msgstr ""
"I<msg_copy> に B<MSG_COPY> と B<MSG_EXCEPT> の両方を指定するのは、論理的なエ"
"ラーである (なぜならこれらのフラグは I<msgtyp> を別の意味で解釈するからであ"
"る)。 Linux 3.13 以前では、B<msgrcv>() がこのエラーを検出しなかった。 このバ"
"グは Linux 3.14 で修正された。"

#. type: Plain text
#: build/C/man2/msgop.2:582
msgid "The program below demonstrates the use of B<msgsnd>()  and B<msgrcv>()."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:586
msgid ""
"The example program is first run with the B<-s> option to send a message and "
"then run again with the B<-r> option to receive a message."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:588
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:593
#, no-wrap
msgid ""
"$B< ./a.out -s>\n"
"sent: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""
"$B< ./a.out -s>\n"
"sent: a message at Wed Mar  4 16:25:45 2015\n"

#. type: Plain text
#: build/C/man2/msgop.2:596
#, no-wrap
msgid ""
"$B< ./a.out -r>\n"
"message received: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""
"$B< ./a.out -r>\n"
"message received: a message at Wed Mar  4 16:25:45 2015\n"

#. type: Plain text
#: build/C/man2/msgop.2:610
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/msg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/msg.hE<gt>\n"

#. type: Plain text
#: build/C/man2/msgop.2:615
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;\n"
"    char mtext[80];\n"
"};\n"
msgstr ""
"struct msgbuf {\n"
"    long mtype;\n"
"    char mtext[80];\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgop.2:621
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"

#. type: Plain text
#: build/C/man2/msgop.2:630
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"    fprintf(stderr, \"-s        send message using msgsnd()\\en\");\n"
"    fprintf(stderr, \"-r        read message using msgrcv()\\en\");\n"
"    fprintf(stderr, \"-t        message type (default is 1)\\en\");\n"
"    fprintf(stderr, \"-k        message queue key (default is 1234)\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"    fprintf(stderr, \"-s        send message using msgsnd()\\en\");\n"
"    fprintf(stderr, \"-r        read message using msgrcv()\\en\");\n"
"    fprintf(stderr, \"-t        message type (default is 1)\\en\");\n"
"    fprintf(stderr, \"-k        message queue key (default is 1234)\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/msgop.2:636
#, no-wrap
msgid ""
"static void\n"
"send_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
"    time_t t;\n"
msgstr ""
"static void\n"
"send_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
"    time_t t;\n"

#. type: Plain text
#: build/C/man2/msgop.2:638
#, no-wrap
msgid "    msg.mtype = msgtype;\n"
msgstr "    msg.mtype = msgtype;\n"

#. type: Plain text
#: build/C/man2/msgop.2:642
#, no-wrap
msgid ""
"    time(&t);\n"
"    snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",\n"
"            ctime(&t));\n"
msgstr ""
"    time(&t);\n"
"    snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",\n"
"            ctime(&t));\n"

#. type: Plain text
#: build/C/man2/msgop.2:650
#, no-wrap
msgid ""
"    if (msgsnd(qid, &msg, sizeof(msg.mtext),\n"
"                IPC_NOWAIT) == -1) {\n"
"        perror(\"msgsnd error\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"sent: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""
"    if (msgsnd(qid, &msg, sizeof(msg.mtext),\n"
"                IPC_NOWAIT) == -1) {\n"
"        perror(\"msgsnd error\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"sent: %s\\en\", msg.mtext);\n"
"}\n"

#. type: Plain text
#: build/C/man2/msgop.2:655
#, no-wrap
msgid ""
"static void\n"
"get_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
msgstr ""
"static void\n"
"get_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"

#. type: Plain text
#: build/C/man2/msgop.2:666
#, no-wrap
msgid ""
"    if (msgrcv(qid, &msg, sizeof(msg.mtext), msgtype,\n"
"               MSG_NOERROR | IPC_NOWAIT) == -1) {\n"
"        if (errno != ENOMSG) {\n"
"            perror(\"msgrcv\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"No message available for msgrcv()\\en\");\n"
"    } else\n"
"        printf(\"message received: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""
"    if (msgrcv(qid, &msg, sizeof(msg.mtext), msgtype,\n"
"               MSG_NOERROR | IPC_NOWAIT) == -1) {\n"
"        if (errno != ENOMSG) {\n"
"            perror(\"msgrcv\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"No message available for msgrcv()\\en\");\n"
"    } else\n"
"        printf(\"message received: %s\\en\", msg.mtext);\n"
"}\n"

#. type: Plain text
#: build/C/man2/msgop.2:674
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int qid, opt;\n"
"    int mode = 0;               /* 1 = send, 2 = receive */\n"
"    int msgtype = 1;\n"
"    int msgkey = 1234;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int qid, opt;\n"
"    int mode = 0;               /* 1 = send, 2 = receive */\n"
"    int msgtype = 1;\n"
"    int msgkey = 1234;\n"

#. type: Plain text
#: build/C/man2/msgop.2:695
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            mode = 1;\n"
"            break;\n"
"        case \\(aqr\\(aq:\n"
"            mode = 2;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            msgtype = atoi(optarg);\n"
"            if (msgtype E<lt>= 0)\n"
"                usage(argv[0], \"-t option must be greater than 0\\en\");\n"
"            break;\n"
"        case \\(aqk\\(aq:\n"
"            msgkey = atoi(optarg);\n"
"            break;\n"
"        default:\n"
"            usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            mode = 1;\n"
"            break;\n"
"        case \\(aqr\\(aq:\n"
"            mode = 2;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            msgtype = atoi(optarg);\n"
"            if (msgtype E<lt>= 0)\n"
"                usage(argv[0], \"-t option must be greater than 0\\en\");\n"
"            break;\n"
"        case \\(aqk\\(aq:\n"
"            msgkey = atoi(optarg);\n"
"            break;\n"
"        default:\n"
"            usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man2/msgop.2:698
#, no-wrap
msgid ""
"    if (mode == 0)\n"
"        usage(argv[0], \"must use either -s or -r option\\en\");\n"
msgstr ""
"    if (mode == 0)\n"
"        usage(argv[0], \"must use either -s or -r option\\en\");\n"

#. type: Plain text
#: build/C/man2/msgop.2:700
#, no-wrap
msgid "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"
msgstr "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"

#. type: Plain text
#: build/C/man2/msgop.2:705
#, no-wrap
msgid ""
"    if (qid == -1) {\n"
"        perror(\"msgget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (qid == -1) {\n"
"        perror(\"msgget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/msgop.2:710
#, no-wrap
msgid ""
"    if (mode == 2)\n"
"        get_msg(qid, msgtype);\n"
"    else\n"
"        send_msg(qid, msgtype);\n"
msgstr ""
"    if (mode == 2)\n"
"        get_msg(qid, msgtype);\n"
"    else\n"
"        send_msg(qid, msgtype);\n"

#. type: Plain text
#: build/C/man2/msgop.2:720
msgid ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), "
"B<sysvipc>(7)"
msgstr "B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), B<sysvipc>(7)"
