# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "__SETFPUCW"
msgstr ""

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/basename.3:27
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/addseverity.3:9 build/C/man3/argz_add.3:10 build/C/man3/backtrace.3:27 build/C/man3/basename.3:27 build/C/man3/envz_add.3:10 build/C/man3/ftok.3:29 build/C/man3/offsetof.3:28 build/C/man3/program_invocation_name.3:24 build/C/man3/realpath.3:28 build/C/man3/setjmp.3:24 build/C/man3/xcrypt.3:13
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:9 build/C/man3/addseverity.3:10 build/C/man3/argz_add.3:11 build/C/man3/backtrace.3:28 build/C/man3/basename.3:28 build/C/man3/envz_add.3:11 build/C/man3/ftok.3:30 build/C/man3/offsetof.3:29 build/C/man3/program_invocation_name.3:25 build/C/man3/realpath.3:29 build/C/man3/setjmp.3:25 build/C/man3/xcrypt.3:14
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:11
msgid "__setfpucw - set FPU control word on i386 architecture (obsolete)"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:11 build/C/man3/addseverity.3:12 build/C/man3/argz_add.3:15 build/C/man3/backtrace.3:31 build/C/man3/basename.3:30 build/C/man3/envz_add.3:14 build/C/man3/ftok.3:32 build/C/man3/offsetof.3:31 build/C/man3/program_invocation_name.3:28 build/C/man3/realpath.3:31 build/C/man3/setjmp.3:27 build/C/man3/xcrypt.3:16
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:13
msgid "B<#include E<lt>i386/fpu_control.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:15
msgid "B<void __setfpucw(unsigned short >I<control_word>B<);>"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:15 build/C/man3/addseverity.3:30 build/C/man3/argz_add.3:51 build/C/man3/backtrace.3:50 build/C/man3/basename.3:38 build/C/man3/envz_add.3:36 build/C/man3/ftok.3:39 build/C/man3/offsetof.3:37 build/C/man3/program_invocation_name.3:36 build/C/man3/realpath.3:53 build/C/man3/setjmp.3:48 build/C/man3/xcrypt.3:24
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:22
msgid ""
"B<__setfpucw>()  transfers I<control_word> to the registers of the FPU "
"(floating-point unit) on the i386 architecture.  This was used to control "
"floating-point precision, rounding and floating-point exceptions."
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:22 build/C/man3/addseverity.3:75 build/C/man3/argz_add.3:228 build/C/man3/backtrace.3:160 build/C/man3/basename.3:143 build/C/man3/envz_add.3:139 build/C/man3/ftok.3:82 build/C/man3/offsetof.3:63 build/C/man3/program_invocation_name.3:56 build/C/man3/realpath.3:152 build/C/man3/setjmp.3:151
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:24
msgid "This function was a nonstandard GNU extension."
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:24 build/C/man3/addseverity.3:82 build/C/man3/backtrace.3:162 build/C/man3/basename.3:145 build/C/man3/ftok.3:84 build/C/man3/program_invocation_name.3:59 build/C/man3/realpath.3:159 build/C/man3/setjmp.3:159
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:43
msgid ""
"As of glibc 2.1 this function does not exist anymore.  There are new "
"functions from C99, with prototypes in I<E<lt>fenv.hE<gt>>, to control FPU "
"rounding modes, like B<fegetround>(3), B<fesetround>(3), and the "
"floating-point environment, like B<fegetenv>(3), B<feholdexcept>(3), "
"B<fesetenv>(3), B<feupdateenv>(3), and FPU exception handling, like "
"B<feclearexcept>(3), B<fegetexceptflag>(3), B<feraiseexcept>(3), "
"B<fesetexceptflag>(3), and B<fetestexcept>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:51
msgid ""
"If direct access to the FPU control word is still needed, the B<_FPU_GETCW> "
"and B<_FPU_SETCW> macros from I<E<lt>fpu_control.hE<gt>> can be used."
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:51 build/C/man3/backtrace.3:199 build/C/man3/basename.3:181 build/C/man3/envz_add.3:141 build/C/man3/ftok.3:115 build/C/man3/offsetof.3:65
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:53
msgid "B<__setfpucw(0x1372)>"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:58
#, no-wrap
msgid ""
"Set FPU control word on the i386 architecture to\n"
"     - extended precision\n"
"     - rounding to nearest\n"
"     - exceptions on overflow, zero divide and NaN\n"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:58 build/C/man3/addseverity.3:85 build/C/man3/argz_add.3:233 build/C/man3/backtrace.3:284 build/C/man3/basename.3:198 build/C/man3/envz_add.3:163 build/C/man3/ftok.3:118 build/C/man3/program_invocation_name.3:63 build/C/man3/realpath.3:241 build/C/man3/setjmp.3:325 build/C/man3/xcrypt.3:90
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:60
msgid "B<feclearexcept>(3)"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:62
msgid "I<E<lt>fpu_control.hE<gt>>"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:62 build/C/man3/addseverity.3:87 build/C/man3/argz_add.3:235 build/C/man3/backtrace.3:291 build/C/man3/basename.3:201 build/C/man3/envz_add.3:165 build/C/man3/ftok.3:124 build/C/man3/offsetof.3:104 build/C/man3/program_invocation_name.3:65 build/C/man3/realpath.3:248 build/C/man3/setjmp.3:328 build/C/man3/xcrypt.3:92
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/__setfpucw.3:70 build/C/man3/addseverity.3:95 build/C/man3/argz_add.3:243 build/C/man3/backtrace.3:299 build/C/man3/basename.3:209 build/C/man3/envz_add.3:173 build/C/man3/ftok.3:132 build/C/man3/offsetof.3:112 build/C/man3/program_invocation_name.3:73 build/C/man3/realpath.3:256 build/C/man3/setjmp.3:336 build/C/man3/xcrypt.3:100
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/addseverity.3:9
#, no-wrap
msgid "ADDSEVERITY"
msgstr ""

#. type: TH
#: build/C/man3/addseverity.3:9
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: TH
#: build/C/man3/addseverity.3:9 build/C/man3/backtrace.3:27 build/C/man3/basename.3:27 build/C/man3/ftok.3:29 build/C/man3/offsetof.3:28 build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:12
msgid "addseverity - introduce new severity classes"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:16
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:18
#, no-wrap
msgid "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:23 build/C/man3/realpath.3:42 build/C/man3/setjmp.3:41
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:30
#, no-wrap
msgid ""
"B<addseverity>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:52
msgid ""
"This function allows the introduction of new severity classes which can be "
"addressed by the I<severity> argument of the B<fmtmsg>(3)  function.  By "
"default, that function knows only how to print messages for severity 0-4 "
"(with strings (none), HALT, ERROR, WARNING, INFO).  This call attaches the "
"given string I<s> to the given value I<severity>.  If I<s> is NULL, the "
"severity class with the numeric value I<severity> is removed.  It is not "
"possible to overwrite or remove one of the default severity classes.  The "
"severity value must be nonnegative."
msgstr ""

#. type: SH
#: build/C/man3/addseverity.3:52 build/C/man3/argz_add.3:192 build/C/man3/backtrace.3:119 build/C/man3/basename.3:122 build/C/man3/envz_add.3:112 build/C/man3/ftok.3:61 build/C/man3/offsetof.3:56 build/C/man3/realpath.3:93 build/C/man3/setjmp.3:116 build/C/man3/xcrypt.3:65
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:60
msgid ""
"Upon success, the value B<MM_OK> is returned.  Upon error, the return value "
"is B<MM_NOTOK>.  Possible errors include: out of memory, attempt to remove a "
"nonexistent or default severity class."
msgstr ""

#. type: SH
#: build/C/man3/addseverity.3:60 build/C/man3/backtrace.3:138 build/C/man3/xcrypt.3:71
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:63
msgid "B<addseverity>()  is provided in glibc since version 2.1."
msgstr ""

#. type: SH
#: build/C/man3/addseverity.3:63 build/C/man3/argz_add.3:199 build/C/man3/backtrace.3:144 build/C/man3/basename.3:130 build/C/man3/envz_add.3:119 build/C/man3/ftok.3:70 build/C/man3/realpath.3:140 build/C/man3/setjmp.3:134 build/C/man3/xcrypt.3:73
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:66 build/C/man3/argz_add.3:202 build/C/man3/backtrace.3:147 build/C/man3/basename.3:133 build/C/man3/envz_add.3:122 build/C/man3/ftok.3:73 build/C/man3/realpath.3:143 build/C/man3/setjmp.3:137 build/C/man3/xcrypt.3:76
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206 build/C/man3/backtrace.3:151 build/C/man3/basename.3:137 build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77 build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141 build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206 build/C/man3/backtrace.3:151 build/C/man3/basename.3:137 build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77 build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141 build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206 build/C/man3/backtrace.3:151 build/C/man3/basename.3:137 build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77 build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141 build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:73
#, no-wrap
msgid "B<addseverity>()"
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:73 build/C/man3/argz_add.3:225 build/C/man3/backtrace.3:158 build/C/man3/basename.3:141 build/C/man3/envz_add.3:136 build/C/man3/ftok.3:80 build/C/man3/realpath.3:150 build/C/man3/setjmp.3:145 build/C/man3/setjmp.3:149 build/C/man3/xcrypt.3:85
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/addseverity.3:73 build/C/man3/argz_add.3:225 build/C/man3/backtrace.3:158 build/C/man3/basename.3:141 build/C/man3/envz_add.3:136 build/C/man3/ftok.3:80 build/C/man3/realpath.3:150 build/C/man3/setjmp.3:145 build/C/man3/setjmp.3:149 build/C/man3/xcrypt.3:85
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:82
msgid ""
"This function is not specified in the X/Open Portability Guide although the "
"B<fmtmsg>(3)  function is.  It is available on System V systems."
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:85
msgid ""
"New severity classes can also be added by setting the environment variable "
"B<SEV_LEVEL>."
msgstr ""

#. type: Plain text
#: build/C/man3/addseverity.3:87
msgid "B<fmtmsg>(3)"
msgstr ""

#. type: TH
#: build/C/man3/argz_add.3:10
#, no-wrap
msgid "ARGZ_ADD"
msgstr ""

#. type: TH
#: build/C/man3/argz_add.3:10 build/C/man3/backtrace.3:27 build/C/man3/envz_add.3:10 build/C/man3/offsetof.3:28
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:15
msgid ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - functions to handle an argz list"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:18
#, no-wrap
msgid "B<#include E<lt>argz.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:21
#, no-wrap
msgid ""
"B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char "
"*>I<str>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:24
#, no-wrap
msgid ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:27
#, no-wrap
msgid ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:29
#, no-wrap
msgid "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:32
#, no-wrap
msgid ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:35
#, no-wrap
msgid ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char "
"**>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:37
#, no-wrap
msgid ""
"B<void argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char "
"*>I<entry>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:39
#, no-wrap
msgid ""
"B<void argz_extract(const char *>I<argz>B<, size_t >I<argz_len>B<, char "
"**>I<argv>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:42
#, no-wrap
msgid ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char "
"*>I<before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:44
#, no-wrap
msgid ""
"B<char *argz_next(const char *>I<argz>B<, size_t >I<argz_len>B<, const char "
"*>I<entry>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:48
#, no-wrap
msgid ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char "
"*>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int "
"*>I<replace_count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:50
#, no-wrap
msgid "B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:53 build/C/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:58
msgid ""
"An argz vector is a pointer to a character buffer together with a length.  "
"The intended interpretation of the character buffer is an array of strings, "
"where the strings are separated by null bytes (\\(aq\\e0\\(aq).  If the "
"length is nonzero, the last byte of the buffer must be a null byte."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:67
msgid ""
"These functions are for handling argz vectors.  The pair (NULL,0) is an argz "
"vector, and, conversely, argz vectors of length 0 must have null pointer.  "
"Allocation of nonempty argz vectors is done using B<malloc>(3), so that "
"B<free>(3)  can be used to dispose of them again."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:77
msgid ""
"B<argz_add>()  adds the string I<str> at the end of the array I<*argz>, and "
"updates I<*argz> and I<*argz_len>."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:85
msgid ""
"B<argz_add_sep>()  is similar, but splits the string I<str> into substrings "
"separated by the delimiter I<delim>.  For example, one might use this on a "
"UNIX search path with delimiter \\(aq:\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:99
msgid ""
"B<argz_append>()  appends the argz vector (I<buf>,\\ I<buf_len>)  after "
"(I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  (Thus, "
"I<*argz_len> will be increased by I<buf_len>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:104
msgid ""
"B<argz_count>()  counts the number of strings, that is, the number of null "
"bytes (\\(aq\\e0\\(aq), in (I<argz>,\\ I<argz_len>)."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:112
msgid ""
"B<argz_create>()  converts a UNIX-style argument vector I<argv>, terminated "
"by I<(char\\ *)\\ 0>, into an argz vector (I<*argz>,\\ I<*argz_len>)."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:120
msgid ""
"B<argz_create_sep>()  converts the null-terminated string I<str> into an "
"argz vector (I<*argz>,\\ I<*argz_len>)  by breaking it up at every "
"occurrence of the separator I<sep>."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:130
msgid ""
"B<argz_delete>()  removes the substring pointed to by I<entry> from the argz "
"vector (I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:145
msgid ""
"B<argz_extract>()  is the opposite of B<argz_create>().  It takes the argz "
"vector (I<argz>,\\ I<argz_len>)  and fills the array starting at I<argv> "
"with pointers to the substrings, and a final NULL, making a UNIX-style argv "
"vector.  The array I<argv> must have room for I<argz_count>(I<argz>, "
"I<argz_len>) + 1 pointers."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:164
msgid ""
"B<argz_insert>()  is the opposite of B<argz_delete>().  It inserts the "
"argument I<entry> at position I<before> into the argz vector (I<*argz>,\\ "
"I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  If I<before> is NULL, "
"then I<entry> will inserted at the end."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:173
msgid ""
"B<argz_next>()  is a function to step through the argz vector.  If I<entry> "
"is NULL, the first entry is returned.  Otherwise, the entry following is "
"returned.  It returns NULL if there is no following entry."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:185
msgid ""
"B<argz_replace>()  replaces each occurrence of I<str> with I<with>, "
"reallocating argz as necessary.  If I<replace_count> is non-NULL, "
"I<*replace_count> will be incremented by the number of replacements."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:192
msgid ""
"B<argz_stringify>()  is the opposite of B<argz_create_sep>().  It transforms "
"the argz vector into a normal string by replacing all null bytes "
"(\\(aq\\e0\\(aq) except the last by I<sep>."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:199
msgid ""
"All argz functions that do memory allocation have a return type of "
"I<error_t> (an integer type), and return 0 for success, and B<ENOMEM> if an "
"allocation error occurs."
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:210
#, no-wrap
msgid ""
"B<argz_add>(),\n"
"B<argz_add_sep>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:210 build/C/man3/argz_add.3:213 build/C/man3/argz_add.3:216 build/C/man3/argz_add.3:219 build/C/man3/argz_add.3:222 build/C/man3/backtrace.3:154 build/C/man3/backtrace.3:156 build/C/man3/envz_add.3:130 build/C/man3/envz_add.3:133
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:213
#, no-wrap
msgid ""
"B<argz_append>(),\n"
"B<argz_count>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:216
#, no-wrap
msgid ""
"B<argz_create>(),\n"
"B<argz_create_sep>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:219
#, no-wrap
msgid ""
"B<argz_delete>(),\n"
"B<argz_extract>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:222
#, no-wrap
msgid ""
"B<argz_insert>(),\n"
"B<argz_next>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/argz_add.3:225
#, no-wrap
msgid ""
"B<argz_replace>(),\n"
"B<argz_stringify>()"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:230 build/C/man3/envz_add.3:141
msgid "These functions are a GNU extension."
msgstr ""

#. type: SH
#: build/C/man3/argz_add.3:230 build/C/man3/basename.3:170 build/C/man3/realpath.3:210 build/C/man3/xcrypt.3:88
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:233
msgid ""
"Argz vectors without a terminating null byte may lead to Segmentation "
"Faults."
msgstr ""

#. type: Plain text
#: build/C/man3/argz_add.3:235
msgid "B<envz_add>(3)"
msgstr ""

#. type: TH
#: build/C/man3/backtrace.3:27
#, no-wrap
msgid "BACKTRACE"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:31
msgid ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - support for application "
"self-debugging"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:33
msgid "B<#include E<lt>execinfo.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:38
msgid "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:43
msgid ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> "
"I<size>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:50
msgid ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> "
"I<size>B<,> B<int> I<fd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:78
msgid ""
"B<backtrace>()  returns a backtrace for the calling program, in the array "
"pointed to by I<buffer>.  A backtrace is the series of currently active "
"function calls for the program.  Each item in the array pointed to by "
"I<buffer> is of type I<void\\ *>, and is the return address from the "
"corresponding stack frame.  The I<size> argument specifies the maximum "
"number of addresses that can be stored in I<buffer>.  If the backtrace is "
"larger than I<size>, then the addresses corresponding to the I<size> most "
"recent function calls are returned; to obtain the complete backtrace, make "
"sure that I<buffer> and I<size> are large enough."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:103
msgid ""
"Given the set of addresses returned by B<backtrace>()  in I<buffer>, "
"B<backtrace_symbols>()  translates the addresses into an array of strings "
"that describe the addresses symbolically.  The I<size> argument specifies "
"the number of addresses in I<buffer>.  The symbolic representation of each "
"address consists of the function name (if this can be determined), a "
"hexadecimal offset into the function, and the actual return address (in "
"hexadecimal).  The address of the array of string pointers is returned as "
"the function result of B<backtrace_symbols>().  This array is B<malloc>(3)ed "
"by B<backtrace_symbols>(), and must be freed by the caller.  (The strings "
"pointed to by the array of pointers need not and should not be freed.)"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:119
msgid ""
"B<backtrace_symbols_fd>()  takes the same I<buffer> and I<size> arguments as "
"B<backtrace_symbols>(), but instead of returning an array of strings to the "
"caller, it writes the strings, one per line, to the file descriptor I<fd>.  "
"B<backtrace_symbols_fd>()  does not call B<malloc>(3), and so can be "
"employed in situations where the latter function might fail, but see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:131
msgid ""
"B<backtrace>()  returns the number of addresses returned in I<buffer>, which "
"is not greater than I<size>.  If the return value is less than I<size>, then "
"the full backtrace was stored; if it is equal to I<size>, then it may have "
"been truncated, in which case the addresses of the oldest stack frames are "
"not returned."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:138
msgid ""
"On success, B<backtrace_symbols>()  returns a pointer to the array "
"B<malloc>(3)ed by the call; on error, NULL is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:144
msgid ""
"B<backtrace>(), B<backtrace_symbols>(), and B<backtrace_symbols_fd>()  are "
"provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/backtrace.3:154
#, no-wrap
msgid "B<backtrace>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/backtrace.3:156
#, no-wrap
msgid "B<backtrace_symbols>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/backtrace.3:158
#, no-wrap
msgid "B<backtrace_symbols_fd>()"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:162
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:166
msgid ""
"These functions make some assumptions about how a function's return address "
"is stored on the stack.  Note the following:"
msgstr ""

#. type: IP
#: build/C/man3/backtrace.3:166 build/C/man3/backtrace.3:172 build/C/man3/backtrace.3:174 build/C/man3/backtrace.3:176 build/C/man3/setjmp.3:313 build/C/man3/setjmp.3:318
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:172
msgid ""
"Omission of the frame pointers (as implied by any of B<gcc>(1)'s nonzero "
"optimization levels) may cause these assumptions to be violated."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:174
msgid "Inlined functions do not have stack frames."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:176
msgid "Tail-call optimization causes one stack frame to replace another."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:191
msgid ""
"B<backtrace>()  and B<backtrace_symbols_fd>()  don't call B<malloc>()  "
"explicitly, but they are part of I<libgcc>, which gets loaded dynamically "
"when first used.  Dynamic loading usually triggers a call to B<malloc>(3).  "
"If you need certain calls to these two functions to not allocate memory (in "
"signal handlers, for example), you need to make sure I<libgcc> is loaded "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:199
msgid ""
"The symbol names may be unavailable without the use of special linker "
"options.  For systems using the GNU linker, it is necessary to use the "
"I<-rdynamic> linker option.  Note that names of \"static\" functions are not "
"exposed, and won't be available in the backtrace."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:206
msgid ""
"The program below demonstrates the use of B<backtrace>()  and "
"B<backtrace_symbols>().  The following shell session shows what we might see "
"when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:220
#, no-wrap
msgid ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"
msgstr ""

#. type: SS
#: build/C/man3/backtrace.3:222 build/C/man3/offsetof.3:77
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:229
#, no-wrap
msgid ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:231
#, no-wrap
msgid "#define BT_BUF_SIZE 100\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:238
#, no-wrap
msgid ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int nptrs;\n"
"    void *buffer[BT_BUF_SIZE];\n"
"    char **strings;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:241
#, no-wrap
msgid ""
"    nptrs = backtrace(buffer, BT_BUF_SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:244
#, no-wrap
msgid ""
"    /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)\n"
"       would produce similar output to the following: */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:250
#, no-wrap
msgid ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:253
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:256
#, no-wrap
msgid ""
"    free(strings);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:262
#, no-wrap
msgid ""
"static void   /* \"static\" means don\\(aqt export the symbol... */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:271
#, no-wrap
msgid ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:279
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:283
#, no-wrap
msgid ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:291
msgid "B<addr2line>(1), B<gcc>(1), B<gdb>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man3/basename.3:27
#, no-wrap
msgid "BASENAME"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:30
msgid "basename, dirname - parse pathname components"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:33
#, no-wrap
msgid "B<#include E<lt>libgen.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:35
#, no-wrap
msgid "B<char *dirname(char *>I<path>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:37
#, no-wrap
msgid "B<char *basename(char *>I<path>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:42
msgid "Warning: there are two different functions B<basename>()  - see below."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:55
msgid ""
"The functions B<dirname>()  and B<basename>()  break a null-terminated "
"pathname string into directory and filename components.  In the usual case, "
"B<dirname>()  returns the string up to, but not including, the final "
"\\(aq/\\(aq, and B<basename>()  returns the component following the final "
"\\(aq/\\(aq.  Trailing \\(aq/\\(aq characters are not counted as part of the "
"pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:78
msgid ""
"If I<path> does not contain a slash, B<dirname>()  returns the string \".\" "
"while B<basename>()  returns a copy of I<path>.  If I<path> is the string "
"\"/\", then both B<dirname>()  and B<basename>()  return the string \"/\".  "
"If I<path> is a null pointer or points to an empty string, then both "
"B<dirname>()  and B<basename>()  return the string \".\"."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:84
msgid ""
"Concatenating the string returned by B<dirname>(), a \"/\", and the string "
"returned by B<basename>()  yields a complete pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:93
msgid ""
"Both B<dirname>()  and B<basename>()  may modify the contents of I<path>, so "
"it may be desirable to pass a copy when calling one of these functions."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:102
msgid ""
"These functions may return pointers to statically allocated memory which may "
"be overwritten by subsequent calls.  Alternatively, they may return a "
"pointer to some part of I<path>, so that the string referred to by I<path> "
"should not be modified or freed until the pointer returned by the function "
"is no longer required."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:109
msgid ""
"The following list of examples (taken from SUSv2)  shows the strings "
"returned by B<dirname>()  and B<basename>()  for different paths:"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "path    "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "dirname"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "basename"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "/usr/lib"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "/usr"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "lib"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:115
#, no-wrap
msgid "/usr/   "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:115 build/C/man3/basename.3:117
#, no-wrap
msgid "/"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:115 build/C/man3/basename.3:116
#, no-wrap
msgid "usr"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:116
#, no-wrap
msgid "usr     "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:116 build/C/man3/basename.3:118 build/C/man3/basename.3:119
#, no-wrap
msgid "."
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:117
#, no-wrap
msgid "/       "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:118
#, no-wrap
msgid "\\&.       "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:119
#, no-wrap
msgid "\\&..      "
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:119
#, no-wrap
msgid ".."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:130
msgid ""
"Both B<dirname>()  and B<basename>()  return pointers to null-terminated "
"strings.  (Do not pass these pointers to B<free>(3).)"
msgstr ""

#. type: tbl table
#: build/C/man3/basename.3:141
#, no-wrap
msgid ""
"B<basename>(),\n"
"B<dirname>()"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:145 build/C/man3/ftok.3:84
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:150
msgid ""
"There are two different versions of B<basename>()  - the POSIX version "
"described above, and the GNU version, which one gets after"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:155
#, no-wrap
msgid ""
"B<    #define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:164
msgid ""
"The GNU version never modifies its argument, and returns the empty string "
"when I<path> has a trailing slash, and in particular also when it is \"/\".  "
"There is no GNU version of B<dirname>()."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:170
msgid ""
"With glibc, one gets the POSIX version of B<basename>()  when "
"I<E<lt>libgen.hE<gt>> is included, and the GNU version otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:176
msgid ""
"In the glibc implementation, the POSIX versions of these functions modify "
"the I<path> argument, and segfault when called with a static string such as "
"\"/usr/\"."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:181
msgid ""
"Before glibc 2.2.1, the glibc version of B<dirname>()  did not correctly "
"handle pathnames with trailing \\(aq/\\(aq characters, and generated a "
"segfault if given a NULL argument."
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:186
msgid ""
"The following code snippet demonstrates the use of B<basename>()  and "
"B<dirname>():"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:190
#, no-wrap
msgid ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:196
#, no-wrap
msgid ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:201
msgid "B<basename>(1), B<dirname>(1)"
msgstr ""

#. type: TH
#: build/C/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:23
#, no-wrap
msgid ""
"B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:26
#, no-wrap
msgid ""
"B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int "
">I<override>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:33
#, no-wrap
msgid ""
"B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing "
"\\(aq=\\(aq is the empty string \"\".)"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is "
"non-NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector "
"(I<*envz>,\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an "
"entry with the same I<name> existed, it is removed."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ I<envz_len>)  "
"and returns the value if found, or NULL if not.  (Note that the value can "
"also be NULL, namely when there is an entry for I<name> without \\(aq=\\(aq "
"sign.)"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:119
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t> (an integer type), and return 0 for success, and B<ENOMEM> if an "
"allocation error occurs."
msgstr ""

#. type: tbl table
#: build/C/man3/envz_add.3:130
#, no-wrap
msgid ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/envz_add.3:133
#, no-wrap
msgid ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/envz_add.3:136
#, no-wrap
msgid ""
"B<envz_remove>(),\n"
"B<envz_strip>()"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:146
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:152
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int e_len = 0;\n"
"    char *str;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:155
#, no-wrap
msgid ""
"    for (int i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:162
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/envz_add.3:165
msgid "B<argz_add>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr ""

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:32
msgid "ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a "
"I<key_t> type System V IPC key, suitable for use with B<msgget>(2), "
"B<semget>(2), or B<shmget>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs "
"differ."
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""

#. type: tbl table
#: build/C/man3/ftok.3:80
#, no-wrap
msgid "B<ftok>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:86
msgid "On some ancient systems, the prototype was:"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:90
#, no-wrap
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:103
msgid ""
"Today, I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to "
"be undefined when I<proj_id> is zero."
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:115
msgid ""
"Of course, no guarantee can be given that the resulting I<key_t> is unique.  "
"Typically, a best-effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number "
"into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:118
msgid "See B<semget>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftok.3:124
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: build/C/man3/offsetof.3:28
#, no-wrap
msgid "OFFSETOF"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:31
msgid "offsetof - offset of a structure member"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:34
#, no-wrap
msgid "B<#include E<lt>stddef.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:36
#, no-wrap
msgid "B<size_t offsetof(>I<type>B<, >I<member>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:44
msgid ""
"The macro B<offsetof>()  returns the offset of the field I<member> from the "
"start of the structure I<type>."
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:51
msgid ""
"This macro is useful because the sizes of the fields that compose a "
"structure can vary across implementations, and compilers may insert "
"different numbers of padding bytes between fields.  Consequently, an "
"element's offset is not necessarily given by the sum of the sizes of the "
"previous elements."
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:56
msgid ""
"A compiler error will result if I<member> is not aligned to a byte boundary "
"(i.e., it is a bit field)."
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:63
msgid ""
"B<offsetof>()  returns the offset of the given I<member> within the given "
"I<type>, in units of bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:65
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:69
msgid ""
"On a Linux/i386 system, when compiled using the default B<gcc>(1)  options, "
"the program below produces the following output:"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:75
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"offsets: i=0; c=4; d=8 a=16\n"
"sizeof(struct s)=16\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:83
#, no-wrap
msgid ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:93
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct s {\n"
"        int i;\n"
"        char c;\n"
"        double d;\n"
"        char a[];\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:95
#, no-wrap
msgid "    /* Output is compiler dependent */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:100
#, no-wrap
msgid ""
"    printf(\"offsets: i=%zu; c=%zu; d=%zu a=%zu\\en\",\n"
"            offsetof(struct s, i), offsetof(struct s, c),\n"
"            offsetof(struct s, d), offsetof(struct s, a));\n"
"    printf(\"sizeof(struct s)=%zu\\en\", sizeof(struct s));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/offsetof.3:103
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: TH
#: build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "INVOCATION_NAME"
msgstr ""

#. type: TH
#: build/C/man3/program_invocation_name.3:24 build/C/man3/realpath.3:28
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:28
msgid ""
"program_invocation_name, program_invocation_short_name - obtain name used to "
"invoke calling program"
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:35
#, no-wrap
msgid ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:46
msgid ""
"I<program_invocation_name> contains the name that was used to invoke the "
"calling program.  This is the same as the value of I<argv[0]> in I<main>(), "
"with the difference that the scope of I<program_invocation_name> is global."
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:53
msgid ""
"I<program_invocation_short_name> contains the basename component of name "
"that was used to invoke the calling program.  That is, it is the same value "
"as I<program_invocation_name>, with all text up to and including the final "
"slash (/), if any, removed."
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:56
msgid ""
"These variables are automatically initialized by the glibc run-time startup "
"code."
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:59
msgid ""
"These variables are GNU extensions, and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:63
msgid ""
"The Linux-specific I</proc/[number]/cmdline> file provides access to similar "
"information."
msgstr ""

#. type: Plain text
#: build/C/man3/program_invocation_name.3:65
msgid "B<proc>(5)"
msgstr ""

#. type: TH
#: build/C/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:45
msgid "B<realpath>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/realpath.3:51
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:73
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>, "
"I</../> and extra \\(aq/\\(aq characters in the null-terminated string named "
"by I<path> to produce a canonicalized absolute pathname.  The resulting "
"pathname is stored as a null-terminated string, up to a maximum of "
"B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: build/C/man3/realpath.3:93
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses "
"B<malloc>(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the "
"resolved pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:98
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:105
msgid ""
"Otherwise, it returns NULL, the contents of the array I<resolved_path> are "
"undefined, and I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man3/realpath.3:105
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:106
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:109
msgid "Read or search permission was denied for a component of the path prefix."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:109
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: build/C/man3/realpath.3:118
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned "
"if I<resolved_path> is NULL.)"
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:118
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:121
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:121
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:124
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:124
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:131
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:131
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:134
msgid "The named file does not exist."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:134
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:137
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/realpath.3:137
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:140
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: tbl table
#: build/C/man3/realpath.3:150
#, no-wrap
msgid "B<realpath>()"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:154
msgid "4.4BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:159
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:171
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the "
"B<pathconf>(3)  function.  A typical source fragment would be"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:181
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""

#. .PP
#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#.  The prototype of
#.  .BR realpath ()
#.  is given in \fI<unistd.h>\fP in libc4 and libc5,
#.  but in \fI<stdlib.h>\fP everywhere else.
#. type: Plain text
#: build/C/man3/realpath.3:199
msgid "(But see the BUGS section.)"
msgstr ""

#. type: SS
#: build/C/man3/realpath.3:199
#, no-wrap
msgid "GNU extensions"
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:210
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is "
"not NULL, then the prefix of I<path> that is not readable or does not exist "
"is returned in I<resolved_path>."
msgstr ""

#.  .LP
#.  The libc4 and libc5 implementation contained a buffer overflow
#.  (fixed in libc-5.4.13).
#.  Thus, set-user-ID programs like
#.  .BR mount (8)
#.  needed a private version.
#. type: Plain text
#: build/C/man3/realpath.3:241
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be "
"obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""

#. type: Plain text
#: build/C/man3/realpath.3:248
msgid ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/setjmp.3:24
#, no-wrap
msgid "SETJMP"
msgstr ""

#. type: TH
#: build/C/man3/setjmp.3:24
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:27
msgid "setjmp, sigsetjmp, longjmp, siglongjmp - performing a nonlocal goto"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:30
#, no-wrap
msgid "B<#include E<lt>setjmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:33
#, no-wrap
msgid ""
"B<int setjmp(jmp_buf >I<env>B<);>\n"
"B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:36
#, no-wrap
msgid ""
"B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
"B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:45
msgid "B<setjmp>(): see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:48
msgid "B<sigsetjmp>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:58
msgid ""
"The functions described on this page are used for performing \"nonlocal "
"gotos\": transferring execution from one function to a predetermined "
"location in another function.  The B<setjmp>()  function dynamically "
"establishes the target to which control will later be transferred, and "
"B<longjmp>()  performs the transfer of execution."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:71
msgid ""
"The B<setjmp>()  function saves various information about the calling "
"environment (typically, the stack pointer, the instruction pointer, possibly "
"the values of other registers and the signal mask)  in the buffer I<env> for "
"later use by B<longjmp>().  In this case, B<setjmp>()  returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:86
msgid ""
"The B<longjmp>()  function uses the information saved in I<env> to transfer "
"control back to the point where B<setjmp>()  was called and to restore "
"(\"rewind\") the stack to its state at the time of the B<setjmp>()  call.  "
"In addition, and depending on the implementation (see NOTES), the values of "
"some other registers and the process signal mask may be restored to their "
"state at the time of the B<setjmp>()  call."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:99
msgid ""
"Following a successful B<longjmp>(), execution continues as if B<setjmp>()  "
"had returned for a second time.  This \"fake\" return can be distinguished "
"from a true B<setjmp>()  call because the \"fake\" return returns the value "
"provided in I<val>.  If the programmer mistakenly passes the value 0 in "
"I<val>, the \"fake\" return will instead return 1."
msgstr ""

#. type: SS
#: build/C/man3/setjmp.3:99
#, no-wrap
msgid "sigsetjmp() and siglongjmp()"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:105
msgid ""
"B<sigsetjmp>()  and B<siglongjmp>()  also perform nonlocal gotos, but "
"provide predictable handling of the process signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:116
msgid ""
"If, and only if, the I<savesigs> argument provided to B<sigsetjmp>()  is "
"nonzero, the process's current signal mask is saved in I<env> and will be "
"restored if a B<siglongjmp>()  is later performed with this I<env>."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:128
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  return 0 when called directly; on the "
"\"fake\" return that occurs after B<longjmp>()  or B<siglongjmp>(), the "
"nonzero value specified in I<val> is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:134
msgid "The B<longjmp>()  or B<siglongjmp>()  functions do not return."
msgstr ""

#. type: tbl table
#: build/C/man3/setjmp.3:145
#, no-wrap
msgid ""
"B<setjmp>(),\n"
"B<sigsetjmp>()"
msgstr ""

#. type: tbl table
#: build/C/man3/setjmp.3:149
#, no-wrap
msgid ""
"B<longjmp>(),\n"
"B<siglongjmp>()"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:155
msgid "B<setjmp>(), B<longjmp>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:159
msgid "B<sigsetjmp>(), B<siglongjmp>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#.  so that _FAVOR_BSD is triggered
#.  .BR _XOPEN_SOURCE_EXTENDED ,
#. type: Plain text
#: build/C/man3/setjmp.3:199
msgid ""
"POSIX does not specify whether B<setjmp>()  will save the signal mask (to be "
"later restored during B<longjmp>()).  In System V it will not.  In 4.3BSD it "
"will, and there is a function B<_setjmp>()  that will not.  The behavior "
"under Linux depends on the glibc version and the setting of feature test "
"macros.  On Linux with glibc versions before 2.19, B<setjmp>()  follows the "
"System V behavior by default, but the BSD behavior is provided if the "
"B<_BSD_SOURCE> feature test macro is explicitly defined and none of "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_GNU_SOURCE>, or "
"B<_SVID_SOURCE> is defined.  Since glibc 2.19, I<E<lt>setjmp.hE<gt>> exposes "
"only the System V version of B<setjmp>().  Programs that need the BSD "
"semantics should replace calls to B<setjmp>()  with calls to B<sigsetjmp>()  "
"with a nonzero I<savesigs> argument."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:214
msgid ""
"B<setjmp>()  and B<longjmp>()  can be useful for dealing with errors inside "
"deeply nested function calls or to allow a signal handler to pass control to "
"a specific point in the program, rather than returning to the point where "
"the handler interrupted the main program.  In the latter case, if you want "
"to portably save and restore signal masks, use B<sigsetjmp>()  and "
"B<siglongjmp>().  See also the discussion of program readability below."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:223
msgid ""
"The compiler may optimize variables into registers, and B<longjmp>()  may "
"restore the values of other registers in addition to the stack pointer and "
"program counter.  Consequently, the values of automatic variables are "
"unspecified after a call to B<longjmp>()  if they meet all the following "
"criteria:"
msgstr ""

#. type: IP
#: build/C/man3/setjmp.3:223 build/C/man3/setjmp.3:227 build/C/man3/setjmp.3:233
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:227
msgid ""
"they are local to the function that made the corresponding B<setjmp>()  "
"call;"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:233
msgid ""
"their values are changed between the calls to B<setjmp>()  and B<longjmp>(); "
"and"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:236
msgid "they are not declared as I<volatile>."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:240
msgid "Analogous remarks apply for B<siglongjmp>()."
msgstr ""

#. type: SS
#: build/C/man3/setjmp.3:240
#, no-wrap
msgid "Nonlocal gotos and program readability"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:260
msgid ""
"While it can be abused, the traditional C \"goto\" statement at least has "
"the benefit that lexical cues (the goto statement and the target label)  "
"allow the programmer to easily perceive the flow of control.  Nonlocal gotos "
"provide no such cues: multiple B<setjmp>()  calls might employ the same "
"I<jmp_buf> variable so that the content of the variable may change over the "
"lifetime of the application.  Consequently, the programmer may be forced to "
"perform detailed reading of the code to determine the dynamic target of a "
"particular B<longjmp>()  call.  (To make the programmer's life easier, each "
"B<setjmp>()  call should employ a unique I<jmp_buf> variable.)"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:266
msgid ""
"Adding further difficulty, the B<setjmp>()  and B<longjmp>()  calls may not "
"even be in the same source code module."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:270
msgid ""
"In summary, nonlocal gotos can make programs harder to understand and "
"maintain, and an alternative should be used if possible."
msgstr ""

#. type: SS
#: build/C/man3/setjmp.3:270
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:277
msgid ""
"If the function which called B<setjmp>()  returns before B<longjmp>()  is "
"called, the behavior is undefined.  Some kind of subtle or unsubtle chaos is "
"sure to result."
msgstr ""

#
#.  The following statement appeared in versions up to POSIX.1-2008 TC1,
#.  but is set to be removed in POSIX.1-2008 TC2:
#
#.      According to POSIX.1, if a
#.      .BR longjmp ()
#.      call is performed from a nested signal handler
#.      (i.e., from a handler that was invoked in response to a signal that was
#.      generated while another signal was already in the process of being
#.      handled), the behavior is undefined.
#. type: Plain text
#: build/C/man3/setjmp.3:295
msgid ""
"If, in a multithreaded program, a B<longjmp>()  call employs an I<env> "
"buffer that was initialized by a call to B<setjmp>()  in a different thread, "
"the behavior is undefined."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=516#c1195
#. type: Plain text
#: build/C/man3/setjmp.3:313
msgid ""
"POSIX.1-2008 Technical Corrigendum 2 adds B<longjmp>()  and B<siglongjmp>()  "
"to the list of async-signal-safe functions.  However, the standard "
"recommends avoiding the use of these functions from signal handlers and goes "
"on to point out that if these functions are called from a signal handler "
"that interrupted a call to a non-async-signal-safe function (or some "
"equivalent, such as the steps equivalent to B<exit>(3)  that occur upon a "
"return from the initial call to I<main>()), the behavior is undefined if the "
"program subsequently makes a call to a non-async-signal-safe function.  The "
"only way of avoiding undefined behavior is to ensure one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:318
msgid ""
"After long jumping from the signal handler, the program does not call any "
"non-async-signal-safe functions and does not return from the initial call to "
"I<main>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:325
msgid ""
"Any signal whose handler performs a long jump must be blocked during "
"I<every> call to a non-async-signal-safe function and no "
"non-async-signal-safe functions are called after returning from the initial "
"call to I<main>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:328
msgid "B<signal>(7), B<signal-safety>(7)"
msgstr ""

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "XCRYPT"
msgstr ""

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:16
msgid "xencrypt, xdecrypt, passwd2des - RFS password encryption"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:18
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:20
msgid "B<void passwd2des(char >I<*passwd>B<, char *>I<key>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:22
msgid "B<int xencrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:24
msgid "B<int xdecrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:28
msgid ""
"B<WARNING>: Do not use these functions in new code. They do not achieve any "
"type of acceptable cryptographic security guarantees."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:44
msgid ""
"The function B<passwd2des>()  takes a character string I<passwd> of "
"arbitrary length and fills a character array I<key> of length 8.  The array "
"I<key> is suitable for use as DES key.  It has odd parity set in bit 0 of "
"each byte.  Both other functions described here use this function to turn "
"their argument I<passwd> into a DES key."
msgstr ""

#.  (over the alphabet 0123456789abcdefABCDEF),
#.  (over the alphabet 0123456789abcdef)
#. type: Plain text
#: build/C/man3/xcrypt.3:61
msgid ""
"The B<xencrypt>()  function takes the ASCII character string I<secret> given "
"in hex, which must have a length that is a multiple of 16, encrypts it using "
"the DES key derived from I<passwd> by B<passwd2des>(), and outputs the "
"result again in I<secret> as a hex string of the same length."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:65
msgid "The B<xdecrypt>()  function performs the converse operation."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:71
msgid ""
"The functions B<xencrypt>()  and B<xdecrypt>()  return 1 on success and 0 on "
"error."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:73
msgid "These functions are available in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/xcrypt.3:85
#, no-wrap
msgid ""
"B<passwd2des>(),\n"
"B<xencrypt>(),\n"
"B<xdecrypt>()"
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:90
msgid "The prototypes are missing from the abovementioned include file."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:92
msgid "B<cbc_crypt>(3)"
msgstr ""
