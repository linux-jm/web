# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:27+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "__SETFPUCW"
msgstr "__SETFPUCW"

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/basename.3:27
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/addseverity.3:9
#: build/C/man3/argz_add.3:10 build/C/man3/backtrace.3:27
#: build/C/man3/basename.3:27 build/C/man3/envz_add.3:10 build/C/man3/ftok.3:29
#: build/C/man3/offsetof.3:28 build/C/man3/program_invocation_name.3:24
#: build/C/man3/realpath.3:28 build/C/man3/setjmp.3:24 build/C/man3/xcrypt.3:13
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/__setfpucw.3:9 build/C/man3/addseverity.3:10
#: build/C/man3/argz_add.3:11 build/C/man3/backtrace.3:28
#: build/C/man3/basename.3:28 build/C/man3/envz_add.3:11 build/C/man3/ftok.3:30
#: build/C/man3/offsetof.3:29 build/C/man3/program_invocation_name.3:25
#: build/C/man3/realpath.3:29 build/C/man3/setjmp.3:25 build/C/man3/xcrypt.3:14
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/__setfpucw.3:11
msgid "__setfpucw - set FPU control word on i386 architecture (obsolete)"
msgstr ""
"__setfpucw - i386 アーキテクチャーにおける FPU のコントロールワードの設定 "
"(obsolete)"

#. type: SH
#: build/C/man3/__setfpucw.3:11 build/C/man3/addseverity.3:12
#: build/C/man3/argz_add.3:15 build/C/man3/backtrace.3:31
#: build/C/man3/basename.3:30 build/C/man3/envz_add.3:14 build/C/man3/ftok.3:32
#: build/C/man3/offsetof.3:31 build/C/man3/program_invocation_name.3:28
#: build/C/man3/realpath.3:31 build/C/man3/setjmp.3:27 build/C/man3/xcrypt.3:16
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/__setfpucw.3:13
msgid "B<#include E<lt>i386/fpu_control.hE<gt>>"
msgstr "B<#include E<lt>i386/fpu_control.hE<gt>>"

#. type: Plain text
#: build/C/man3/__setfpucw.3:15
msgid "B<void __setfpucw(unsigned short >I<control_word>B<);>"
msgstr "B<void __setfpucw(unsigned short >I<control_word>B<);>"

#. type: SH
#: build/C/man3/__setfpucw.3:15 build/C/man3/addseverity.3:30
#: build/C/man3/argz_add.3:51 build/C/man3/backtrace.3:50
#: build/C/man3/basename.3:38 build/C/man3/envz_add.3:36 build/C/man3/ftok.3:39
#: build/C/man3/offsetof.3:37 build/C/man3/program_invocation_name.3:36
#: build/C/man3/realpath.3:53 build/C/man3/setjmp.3:48 build/C/man3/xcrypt.3:24
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/__setfpucw.3:22
msgid ""
"B<__setfpucw>()  transfers I<control_word> to the registers of the FPU "
"(floating-point unit) on the i386 architecture.  This was used to control "
"floating-point precision, rounding and floating-point exceptions."
msgstr ""
"B<__setfpucw>()  は、i386アーキテクチャーにおいて I<control_word> を FPU "
"(floating-point unit) のレジスターに転送する。 これは浮動小数点演算の精度、丸"
"め方、 および浮動小数点例外を制御するのに使われる。"

#. type: SH
#: build/C/man3/__setfpucw.3:22 build/C/man3/addseverity.3:75
#: build/C/man3/argz_add.3:228 build/C/man3/backtrace.3:160
#: build/C/man3/basename.3:143 build/C/man3/envz_add.3:139
#: build/C/man3/ftok.3:82 build/C/man3/offsetof.3:63
#: build/C/man3/program_invocation_name.3:56 build/C/man3/realpath.3:152
#: build/C/man3/setjmp.3:151
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/__setfpucw.3:24
msgid "This function was a nonstandard GNU extension."
msgstr "この関数は非標準で GNU 拡張である。"

#. type: SH
#: build/C/man3/__setfpucw.3:24 build/C/man3/addseverity.3:82
#: build/C/man3/backtrace.3:162 build/C/man3/basename.3:145
#: build/C/man3/ftok.3:84 build/C/man3/program_invocation_name.3:59
#: build/C/man3/realpath.3:159 build/C/man3/setjmp.3:159
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/__setfpucw.3:43
msgid ""
"As of glibc 2.1 this function does not exist anymore.  There are new "
"functions from C99, with prototypes in I<E<lt>fenv.hE<gt>>, to control FPU "
"rounding modes, like B<fegetround>(3), B<fesetround>(3), and the floating-"
"point environment, like B<fegetenv>(3), B<feholdexcept>(3), B<fesetenv>(3), "
"B<feupdateenv>(3), and FPU exception handling, like B<feclearexcept>(3), "
"B<fegetexceptflag>(3), B<feraiseexcept>(3), B<fesetexceptflag>(3), and "
"B<fetestexcept>(3)."
msgstr ""
"glibc 2.1 以降では、この関数は存在しない。 新たな関数群が C99 から導入され"
"た。これらのプロトタイプは I<E<lt>fenv.hE<gt>> に置かれている。 FPU の丸め"
"モードの制御には B<fegetround>(3), B<fesetround>(3) などが、浮動小数点関連の"
"環境には B<fegetenv>(3), B<feholdexcept>(3), B<fesetenv>(3), "
"B<feupdateenv>(3) などが、 FPU 例外処理には B<feclearexcept>(3), "
"B<fegetexceptflag>(3), B<feraiseexcept>(3), B<fesetexceptflag>(3), "
"B<fetestexcept>(3) などが導入された。"

#. type: Plain text
#: build/C/man3/__setfpucw.3:51
msgid ""
"If direct access to the FPU control word is still needed, the B<_FPU_GETCW> "
"and B<_FPU_SETCW> macros from I<E<lt>fpu_control.hE<gt>> can be used."
msgstr ""
"FPU のコントロールワードへどうしても直接アクセスする必要がある場合には、 "
"I<E<lt>fpu_control.hE<gt>> の B<_FPU_GETCW> マクロと B<_FPU_SETCW> マクロを用"
"いることは可能である。"

#. type: SH
#: build/C/man3/__setfpucw.3:51 build/C/man3/backtrace.3:199
#: build/C/man3/basename.3:181 build/C/man3/envz_add.3:141
#: build/C/man3/ftok.3:115 build/C/man3/offsetof.3:65
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/__setfpucw.3:53
msgid "B<__setfpucw(0x1372)>"
msgstr "B<__setfpucw(0x1372)>"

#. type: Plain text
#: build/C/man3/__setfpucw.3:58
#, no-wrap
msgid ""
"Set FPU control word on the i386 architecture to\n"
"     - extended precision\n"
"     - rounding to nearest\n"
"     - exceptions on overflow, zero divide and NaN\n"
msgstr ""

#. type: SH
#: build/C/man3/__setfpucw.3:58 build/C/man3/addseverity.3:85
#: build/C/man3/argz_add.3:233 build/C/man3/backtrace.3:284
#: build/C/man3/basename.3:198 build/C/man3/envz_add.3:163
#: build/C/man3/ftok.3:118 build/C/man3/program_invocation_name.3:63
#: build/C/man3/realpath.3:241 build/C/man3/setjmp.3:325
#: build/C/man3/xcrypt.3:90
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/__setfpucw.3:60
msgid "B<feclearexcept>(3)"
msgstr "B<feclearexcept>(3)"

#. type: Plain text
#: build/C/man3/__setfpucw.3:62
msgid "I<E<lt>fpu_control.hE<gt>>"
msgstr "I<E<lt>fpu_control.hE<gt>>"

#. type: SH
#: build/C/man3/__setfpucw.3:62 build/C/man3/addseverity.3:87
#: build/C/man3/argz_add.3:235 build/C/man3/backtrace.3:291
#: build/C/man3/basename.3:201 build/C/man3/envz_add.3:165
#: build/C/man3/ftok.3:124 build/C/man3/offsetof.3:104
#: build/C/man3/program_invocation_name.3:65 build/C/man3/realpath.3:248
#: build/C/man3/setjmp.3:328 build/C/man3/xcrypt.3:92
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/__setfpucw.3:70 build/C/man3/addseverity.3:95
#: build/C/man3/argz_add.3:243 build/C/man3/backtrace.3:299
#: build/C/man3/basename.3:209 build/C/man3/envz_add.3:173
#: build/C/man3/ftok.3:132 build/C/man3/offsetof.3:112
#: build/C/man3/program_invocation_name.3:73 build/C/man3/realpath.3:256
#: build/C/man3/setjmp.3:336 build/C/man3/xcrypt.3:100
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/addseverity.3:9
#, no-wrap
msgid "ADDSEVERITY"
msgstr "ADDSEVERITY"

#. type: TH
#: build/C/man3/addseverity.3:9
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: TH
#: build/C/man3/addseverity.3:9 build/C/man3/backtrace.3:27
#: build/C/man3/basename.3:27 build/C/man3/ftok.3:29 build/C/man3/offsetof.3:28
#: build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/addseverity.3:12
msgid "addseverity - introduce new severity classes"
msgstr "addseverity - 新しい重大度 (severity class) を導入する"

#. type: Plain text
#: build/C/man3/addseverity.3:16
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/addseverity.3:18
#, no-wrap
msgid "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"
msgstr "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/addseverity.3:23 build/C/man3/realpath.3:42
#: build/C/man3/setjmp.3:41
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/addseverity.3:30
#, no-wrap
msgid ""
"B<addseverity>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<addseverity>():\n"
"    glibc 2.19 以降:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 以前:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man3/addseverity.3:52
msgid ""
"This function allows the introduction of new severity classes which can be "
"addressed by the I<severity> argument of the B<fmtmsg>(3)  function.  By "
"default, that function knows only how to print messages for severity 0-4 "
"(with strings (none), HALT, ERROR, WARNING, INFO).  This call attaches the "
"given string I<s> to the given value I<severity>.  If I<s> is NULL, the "
"severity class with the numeric value I<severity> is removed.  It is not "
"possible to overwrite or remove one of the default severity classes.  The "
"severity value must be nonnegative."
msgstr ""
"この関数により、新しい重大度を導入できる。 この重大度は、 B<fmtmsg>(3)  関数"
"の I<severity> 引数に入れることができる。 デフォルトでは、 B<fmtmsg>(3)  関"
"数は重大度 0-4 (文字列では (none), HALT, ERROR, WARNING, INFO) の メッセージ"
"を表示する方法しか知らない。 この B<addseverity>(3)  の呼び出しにより、指定さ"
"れた文字列 I<s> に指定された値 I<severity> を付加する。 I<s> が NULL の場合、"
"数値 I<severity> の重大度が削除される。 デフォルトの重大度のどれかを上書きし"
"たり削除したりすることはできない。 重大度の値は負でない数としなければならな"
"い。"

#. type: SH
#: build/C/man3/addseverity.3:52 build/C/man3/argz_add.3:192
#: build/C/man3/backtrace.3:119 build/C/man3/basename.3:122
#: build/C/man3/envz_add.3:112 build/C/man3/ftok.3:61
#: build/C/man3/offsetof.3:56 build/C/man3/realpath.3:93
#: build/C/man3/setjmp.3:116 build/C/man3/xcrypt.3:65
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/addseverity.3:60
msgid ""
"Upon success, the value B<MM_OK> is returned.  Upon error, the return value "
"is B<MM_NOTOK>.  Possible errors include: out of memory, attempt to remove a "
"nonexistent or default severity class."
msgstr ""
"成功した場合、値 B<MM_OK> が返される。 エラーの場合、返り値は B<MM_NOTOK> で"
"ある。 起こる可能性があるエラーには、以下のものが含まれる: メモリーを使い果た"
"した。 存在しない重大度またはデフォルトの重大度を削除しようとした。"

#. type: SH
#: build/C/man3/addseverity.3:60 build/C/man3/backtrace.3:138
#: build/C/man3/xcrypt.3:71
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/addseverity.3:63
msgid "B<addseverity>()  is provided in glibc since version 2.1."
msgstr "B<addseverity>()  はバージョン 2.1 以降の glibc で提供されている。"

#. type: SH
#: build/C/man3/addseverity.3:63 build/C/man3/argz_add.3:199
#: build/C/man3/backtrace.3:144 build/C/man3/basename.3:130
#: build/C/man3/envz_add.3:119 build/C/man3/ftok.3:70
#: build/C/man3/realpath.3:140 build/C/man3/setjmp.3:134
#: build/C/man3/xcrypt.3:73
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/addseverity.3:66 build/C/man3/argz_add.3:202
#: build/C/man3/backtrace.3:147 build/C/man3/basename.3:133
#: build/C/man3/envz_add.3:122 build/C/man3/ftok.3:73
#: build/C/man3/realpath.3:143 build/C/man3/setjmp.3:137
#: build/C/man3/xcrypt.3:76
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206
#: build/C/man3/backtrace.3:151 build/C/man3/basename.3:137
#: build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77
#: build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141
#: build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206
#: build/C/man3/backtrace.3:151 build/C/man3/basename.3:137
#: build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77
#: build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141
#: build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/addseverity.3:70 build/C/man3/argz_add.3:206
#: build/C/man3/backtrace.3:151 build/C/man3/basename.3:137
#: build/C/man3/envz_add.3:126 build/C/man3/ftok.3:77
#: build/C/man3/realpath.3:147 build/C/man3/setjmp.3:141
#: build/C/man3/xcrypt.3:80
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/addseverity.3:73
#, no-wrap
msgid "B<addseverity>()"
msgstr "B<addseverity>()"

#. type: tbl table
#: build/C/man3/addseverity.3:73 build/C/man3/argz_add.3:225
#: build/C/man3/backtrace.3:158 build/C/man3/basename.3:141
#: build/C/man3/envz_add.3:136 build/C/man3/ftok.3:80
#: build/C/man3/realpath.3:150 build/C/man3/setjmp.3:145
#: build/C/man3/setjmp.3:149 build/C/man3/xcrypt.3:85
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/addseverity.3:73 build/C/man3/argz_add.3:225
#: build/C/man3/backtrace.3:158 build/C/man3/basename.3:141
#: build/C/man3/envz_add.3:136 build/C/man3/ftok.3:80
#: build/C/man3/realpath.3:150 build/C/man3/setjmp.3:145
#: build/C/man3/setjmp.3:149 build/C/man3/xcrypt.3:85
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/addseverity.3:82
msgid ""
"This function is not specified in the X/Open Portability Guide although the "
"B<fmtmsg>(3)  function is.  It is available on System V systems."
msgstr ""
"B<fmtmsg>(3)  関数は X/Open Portability Guide に指定されているが、 この関数は"
"指定されていない。 この関数は System V システムで利用可能である。"

#. type: Plain text
#: build/C/man3/addseverity.3:85
msgid ""
"New severity classes can also be added by setting the environment variable "
"B<SEV_LEVEL>."
msgstr ""
"新しい重大度は、環境変数 B<SEV_LEVEL> を設定することで追加することもできる。"

#. type: Plain text
#: build/C/man3/addseverity.3:87
msgid "B<fmtmsg>(3)"
msgstr "B<fmtmsg>(3)"

#. type: TH
#: build/C/man3/argz_add.3:10
#, no-wrap
msgid "ARGZ_ADD"
msgstr "ARGZ_ADD"

#. type: TH
#: build/C/man3/argz_add.3:10 build/C/man3/backtrace.3:27
#: build/C/man3/envz_add.3:10 build/C/man3/offsetof.3:28
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man3/argz_add.3:15
msgid ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - functions to handle an argz list"
msgstr ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - argz リストを操作するための関数群"

#. type: Plain text
#: build/C/man3/argz_add.3:18
#, no-wrap
msgid "B<#include E<lt>argz.hE<gt>>\n"
msgstr "B<#include E<lt>argz.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:21
#, no-wrap
msgid "B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<);>\n"
msgstr "B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:24
#, no-wrap
msgid ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"
msgstr ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:27
#, no-wrap
msgid ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"
msgstr ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:29
#, no-wrap
msgid "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"
msgstr "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:32
#, no-wrap
msgid ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:35
#, no-wrap
msgid ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:37
#, no-wrap
msgid "B<void argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<entry>B<);>\n"
msgstr "B<void argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:39
#, no-wrap
msgid "B<void argz_extract(const char *>I<argz>B<, size_t >I<argz_len>B<, char **>I<argv>B<);>\n"
msgstr "B<void argz_extract(const char *>I<argz>B<, size_t >I<argz_len>B<, char **>I<argv>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:42
#, no-wrap
msgid ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"
msgstr ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:44
#, no-wrap
msgid "B<char *argz_next(const char *>I<argz>B<, size_t >I<argz_len>B<, const char *>I<entry>B<);>\n"
msgstr "B<char *argz_next(const char *>I<argz>B<, size_t >I<argz_len>B<, const char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:48
#, no-wrap
msgid ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"
msgstr ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:50
#, no-wrap
msgid "B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"
msgstr "B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:53 build/C/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr "これらの関数は glibc 固有である。"

#. type: Plain text
#: build/C/man3/argz_add.3:58
msgid ""
"An argz vector is a pointer to a character buffer together with a length.  "
"The intended interpretation of the character buffer is an array of strings, "
"where the strings are separated by null bytes (\\(aq\\e0\\(aq).  If the "
"length is nonzero, the last byte of the buffer must be a null byte."
msgstr ""
"argz vector は長さ情報付きの文字バッファーへのポインターである。 文字バッ"
"ファーでは、複数の文字列がヌルバイト (\\(aq\\e0\\(aq) で区切られており、 文字"
"列の配列として解釈されるようになっている。 長さが 0 でない場合、バッファーの"
"最後のバイトはヌルバイトでなければならない。"

#. type: Plain text
#: build/C/man3/argz_add.3:67
msgid ""
"These functions are for handling argz vectors.  The pair (NULL,0) is an argz "
"vector, and, conversely, argz vectors of length 0 must have null pointer.  "
"Allocation of nonempty argz vectors is done using B<malloc>(3), so that "
"B<free>(3)  can be used to dispose of them again."
msgstr ""
"これらの関数は argz vector を操作するためのものである。 ペア (NULL,0) は "
"argz vector であり、逆に言えば 長さ 0 の argz vectorはヌルポインターを持たな"
"ければならない。 空でない argz vector の割り当ては B<malloc>(3)  を使って行わ"
"れる。したがって、argz vector を解放するのに B<free>(3)  を使うことができる。"

#. type: Plain text
#: build/C/man3/argz_add.3:77
msgid ""
"B<argz_add>()  adds the string I<str> at the end of the array I<*argz>, and "
"updates I<*argz> and I<*argz_len>."
msgstr ""
"B<argz_add>()  は、文字列 I<str> を配列 I<*argz> の末尾に追加し、 I<*argz> "
"と I<*argz_len> を更新する。"

#. type: Plain text
#: build/C/man3/argz_add.3:85
msgid ""
"B<argz_add_sep>()  is similar, but splits the string I<str> into substrings "
"separated by the delimiter I<delim>.  For example, one might use this on a "
"UNIX search path with delimiter \\(aq:\\(aq."
msgstr ""
"B<argz_add_sep>()  も同様の動作をするが、区切り文字 I<delim> にしたがって文字"
"列 I<str> を複数の文字列に分割する点が異なる。 例えば、区切り文字 \\(aq:"
"\\(aq を指定して、UNIX サーチパスに対して この関数を使うことができるだろう。"

#. type: Plain text
#: build/C/man3/argz_add.3:99
msgid ""
"B<argz_append>()  appends the argz vector (I<buf>,\\ I<buf_len>)  after "
"(I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  (Thus, "
"I<*argz_len> will be increased by I<buf_len>.)"
msgstr ""
"B<argz_append>()  は argz vector (I<buf>,\\ I<buf_len>)  の後ろに (I<*argz>,"
"\\ I<*argz_len>) を付け加え、 I<*argz> と I<*argz_len> を更新する。 (したがっ"
"て、 I<*argz_len> は I<buf_len> だけ増加する。)"

#. type: Plain text
#: build/C/man3/argz_add.3:104
msgid ""
"B<argz_count>()  counts the number of strings, that is, the number of null "
"bytes (\\(aq\\e0\\(aq), in (I<argz>,\\ I<argz_len>)."
msgstr ""
"B<argz_count>()  は (I<argz>,\\ I<argz_len>)  内の文字列の数を数える。実際に"
"はヌルバイト (\\(aq\\e0\\(aq) の数を数えている。"

#. type: Plain text
#: build/C/man3/argz_add.3:112
msgid ""
"B<argz_create>()  converts a UNIX-style argument vector I<argv>, terminated "
"by I<(char\\ *)\\ 0>, into an argz vector (I<*argz>,\\ I<*argz_len>)."
msgstr ""
"B<argz_create>() は、UNIX 流の引数ベクトルである (I<(char\\ *)\\ 0> で終端"
"される) I<argv> を、argz vector (I<*argz>,\\ I<*argz_len>)  に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:120
msgid ""
"B<argz_create_sep>()  converts the null-terminated string I<str> into an "
"argz vector (I<*argz>,\\ I<*argz_len>)  by breaking it up at every "
"occurrence of the separator I<sep>."
msgstr ""
"B<argz_create_sep>()  は、ヌル終端された文字列 I<str> を区切り文字 I<sep> が"
"現れる毎に分割しながら、argz vector (*I<argz>,\\ I<*argz_len>)  に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:130
msgid ""
"B<argz_delete>()  removes the substring pointed to by I<entry> from the argz "
"vector (I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>."
msgstr ""
"B<argz_delete>()  は、 I<entry> で指し示された文字列を argz vector (I<*argz>,"
"\\ I<*argz_len>) から削除し、 I<*argz> と I<*argz_len> を更新する。"

#. type: Plain text
#: build/C/man3/argz_add.3:145
msgid ""
"B<argz_extract>()  is the opposite of B<argz_create>().  It takes the argz "
"vector (I<argz>,\\ I<argz_len>)  and fills the array starting at I<argv> "
"with pointers to the substrings, and a final NULL, making a UNIX-style argv "
"vector.  The array I<argv> must have room for I<argz_count>(I<argz>, "
"I<argz_len>) + 1 pointers."
msgstr ""
"B<argz_extract>()  は B<argz_create>()  の反対の操作を行う。argz vector "
"(I<argz>,\\ I<argz_len>)  を調べ、 I<argv> から始まる配列をサブ文字列へのポイ"
"ンターで埋めていき、 一番最後に NULL を入れて、UNIX 流の argv ベクトルを作成"
"する。 配列 I<argv> は I<argz_count>(I<argz>,I<argz_len>) + 1 個のポインター"
"を収容できる空間を持っていなければならない。"

#. type: Plain text
#: build/C/man3/argz_add.3:164
msgid ""
"B<argz_insert>()  is the opposite of B<argz_delete>().  It inserts the "
"argument I<entry> at position I<before> into the argz vector (I<*argz>,\\ "
"I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  If I<before> is NULL, "
"then I<entry> will inserted at the end."
msgstr ""
"B<argz_insert>()  は B<argz_delete>()  の反対の操作を行う。argz vector "
"(I<*argz>,\\ I<*argz_len>)  の位置 I<before> に引数 I<entry> を挿入し、 "
"I<*argz> と I<*argz_len> を更新する。 I<before> が NULL の場合、 I<entry> は"
"末尾に挿入される。"

#. type: Plain text
#: build/C/man3/argz_add.3:173
msgid ""
"B<argz_next>()  is a function to step through the argz vector.  If I<entry> "
"is NULL, the first entry is returned.  Otherwise, the entry following is "
"returned.  It returns NULL if there is no following entry."
msgstr ""
"B<argz_next>()  は argz vector を順番に調べるための関数である。 I<entry> が "
"NULL の場合、最初のエントリーを返す。 そうでない場合、次のエントリーを返す。 "
"次のエントリーがない場合、NULL を返す。"

#. type: Plain text
#: build/C/man3/argz_add.3:185
msgid ""
"B<argz_replace>()  replaces each occurrence of I<str> with I<with>, "
"reallocating argz as necessary.  If I<replace_count> is non-NULL, "
"I<*replace_count> will be incremented by the number of replacements."
msgstr ""
"B<argz_replace>()  は、 I<str> をすべて I<with> で置き換える (必要に応じて "
"argz の再割り当てを行う)。 I<replace_count> が NULL でない場合、 "
"I<*replace_count> を置き換えを行った数だけ増やす。"

#. type: Plain text
#: build/C/man3/argz_add.3:192
msgid ""
"B<argz_stringify>()  is the opposite of B<argz_create_sep>().  It transforms "
"the argz vector into a normal string by replacing all null bytes (\\(aq"
"\\e0\\(aq) except the last by I<sep>."
msgstr ""
"B<argz_stringify>()  は B<argz_create_sep>()  の反対の操作を行う。 末尾の ヌ"
"ルバイト以外の全てのヌルバイト (\\(aq\\e0\\(aq) を I<sep> で置き換えて、 "
"argz vector を通常の文字列に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:199
msgid ""
"All argz functions that do memory allocation have a return type of "
"I<error_t> (an integer type), and return 0 for success, and B<ENOMEM> if an "
"allocation error occurs."
msgstr "メモリー割り当てを行う argz 関数群はすべて I<error_t> 型 (integer 型) の返り値を持つ。 成功した場合は 0 を返し、割り当てエラーが発生した場合は B<ENOMEM> を返す。"

#. type: tbl table
#: build/C/man3/argz_add.3:210
#, no-wrap
msgid ""
"B<argz_add>(),\n"
"B<argz_add_sep>(),\n"
msgstr ""
"B<argz_add>(),\n"
"B<argz_add_sep>(),\n"

#. type: tbl table
#: build/C/man3/argz_add.3:210 build/C/man3/argz_add.3:213
#: build/C/man3/argz_add.3:216 build/C/man3/argz_add.3:219
#: build/C/man3/argz_add.3:222 build/C/man3/backtrace.3:154
#: build/C/man3/backtrace.3:156 build/C/man3/envz_add.3:130
#: build/C/man3/envz_add.3:133
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/argz_add.3:213
#, no-wrap
msgid ""
"B<argz_append>(),\n"
"B<argz_count>(),\n"
msgstr ""
"B<argz_append>(),\n"
"B<argz_count>(),\n"

#. type: tbl table
#: build/C/man3/argz_add.3:216
#, no-wrap
msgid ""
"B<argz_create>(),\n"
"B<argz_create_sep>(),\n"
msgstr ""
"B<argz_create>(),\n"
"B<argz_create_sep>(),\n"

#. type: tbl table
#: build/C/man3/argz_add.3:219
#, no-wrap
msgid ""
"B<argz_delete>(),\n"
"B<argz_extract>(),\n"
msgstr ""
"B<argz_delete>(),\n"
"B<argz_extract>(),\n"

#. type: tbl table
#: build/C/man3/argz_add.3:222
#, no-wrap
msgid ""
"B<argz_insert>(),\n"
"B<argz_next>(),\n"
msgstr ""
"B<argz_insert>(),\n"
"B<argz_next>(),\n"

#. type: tbl table
#: build/C/man3/argz_add.3:225
#, no-wrap
msgid ""
"B<argz_replace>(),\n"
"B<argz_stringify>()"
msgstr ""
"B<argz_replace>(),\n"
"B<argz_stringify>()"

#. type: Plain text
#: build/C/man3/argz_add.3:230 build/C/man3/envz_add.3:141
msgid "These functions are a GNU extension."
msgstr "これらの関数は GNU による拡張である。"

#. type: SH
#: build/C/man3/argz_add.3:230 build/C/man3/basename.3:170
#: build/C/man3/realpath.3:210 build/C/man3/xcrypt.3:88
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/argz_add.3:233
msgid ""
"Argz vectors without a terminating null byte may lead to Segmentation Faults."
msgstr ""
"ヌルバイトで終端されていない argz vector を使用した場合、 segmentation fault "
"を起こすかもしれない。"

#. type: Plain text
#: build/C/man3/argz_add.3:235
msgid "B<envz_add>(3)"
msgstr "B<envz_add>(3)"

#. type: TH
#: build/C/man3/backtrace.3:27
#, no-wrap
msgid "BACKTRACE"
msgstr "BACKTRACE"

#. type: Plain text
#: build/C/man3/backtrace.3:31
msgid ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - support for application "
"self-debugging"
msgstr ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - アプリケーション自身での"
"デバッグのサポート"

#. type: Plain text
#: build/C/man3/backtrace.3:33
msgid "B<#include E<lt>execinfo.hE<gt>>"
msgstr "B<#include E<lt>execinfo.hE<gt>>"

#. type: Plain text
#: build/C/man3/backtrace.3:38
msgid "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"
msgstr "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:43
msgid ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> I<size>B<);>"
msgstr ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> I<size>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:50
msgid ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> I<size>B<,"
"> B<int> I<fd>B<);>"
msgstr ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> I<size>B<,"
"> B<int> I<fd>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:78
msgid ""
"B<backtrace>()  returns a backtrace for the calling program, in the array "
"pointed to by I<buffer>.  A backtrace is the series of currently active "
"function calls for the program.  Each item in the array pointed to by "
"I<buffer> is of type I<void\\ *>, and is the return address from the "
"corresponding stack frame.  The I<size> argument specifies the maximum "
"number of addresses that can be stored in I<buffer>.  If the backtrace is "
"larger than I<size>, then the addresses corresponding to the I<size> most "
"recent function calls are returned; to obtain the complete backtrace, make "
"sure that I<buffer> and I<size> are large enough."
msgstr ""
"B<backtrace>()  は、呼び出したプログラムのバックトレースを I<buffer> が指す配"
"列に入れて返す。バックトレースは、プログラムで 現在動作中の関数呼び出しの並び"
"である。 I<buffer> が指す配列の個々の要素は I<void\\ *> 型で、 対応するスタッ"
"クフレームからのリターンアドレスである。 I<size> 引数は I<buffer> に格納で"
"きるアドレスの最大個数を指定する。 バックトレースが I<size> より大きい場合、 "
"I<size> 個の直近の関数呼び出しに対応するアドレスが返される。 完全なバックト"
"レースを取得するためには、確実に I<buffer> と I<size> が十分大きくなるように"
"すること。"

#. type: Plain text
#: build/C/man3/backtrace.3:103
msgid ""
"Given the set of addresses returned by B<backtrace>()  in I<buffer>, "
"B<backtrace_symbols>()  translates the addresses into an array of strings "
"that describe the addresses symbolically.  The I<size> argument specifies "
"the number of addresses in I<buffer>.  The symbolic representation of each "
"address consists of the function name (if this can be determined), a "
"hexadecimal offset into the function, and the actual return address (in "
"hexadecimal).  The address of the array of string pointers is returned as "
"the function result of B<backtrace_symbols>().  This array is B<malloc>(3)ed "
"by B<backtrace_symbols>(), and must be freed by the caller.  (The strings "
"pointed to by the array of pointers need not and should not be freed.)"
msgstr ""
"B<backtrace>()  によって I<buffer> にアドレスの集合が得られたら、 "
"B<backtrace_symbols>()  によって、アドレス集合を、そのアドレスをシンボルで表"
"した文字列の配列 に翻訳できる。 I<size> 引数は I<buffer> に格納されたアドレ"
"スの数を指定する。 個々のアドレスのシンボル表現は、関数名 (特定できた場合)、 "
"関数へのオフセット (16進表記)、実際のリターンアドレス (16進表記)  から構成さ"
"れる。 B<backtrace_symbols>()  の実行結果としては、 文字列ポインターの配列の"
"アドレスが返される。 この配列は B<backtrace_symbols>()  によって "
"B<malloc>(3)  され、呼び出し側で free しなければならない (ポインターの配列が"
"指す個々の文字列は free する必要はないし、 free すべきでもない)。"

#. type: Plain text
#: build/C/man3/backtrace.3:119
msgid ""
"B<backtrace_symbols_fd>()  takes the same I<buffer> and I<size> arguments as "
"B<backtrace_symbols>(), but instead of returning an array of strings to the "
"caller, it writes the strings, one per line, to the file descriptor I<fd>.  "
"B<backtrace_symbols_fd>()  does not call B<malloc>(3), and so can be "
"employed in situations where the latter function might fail, but see NOTES."
msgstr "B<backtrace_symbols_fd>()  は、 B<backtrace_symbols>()  と同じ引数 I<buffer> と I<size> をとるが、呼び出し側に文字列の配列を返す代わりに、 文字列をファイルディスクリプター I<fd> に 1 行に 1 エントリーの形で書き込む。 B<backtrace_symbols_fd>()  は B<malloc>(3)  を呼び出さない。 そのため、これに続く関数が失敗する可能性がある状況でも利用できるが、「注意」も参照のこと。"

#. type: Plain text
#: build/C/man3/backtrace.3:131
msgid ""
"B<backtrace>()  returns the number of addresses returned in I<buffer>, which "
"is not greater than I<size>.  If the return value is less than I<size>, then "
"the full backtrace was stored; if it is equal to I<size>, then it may have "
"been truncated, in which case the addresses of the oldest stack frames are "
"not returned."
msgstr ""
"B<backtrace>()  は I<buffer> に格納したアドレスの個数を返す。その個数は "
"I<size> より大きくなることはない。 返り値が I<size> より小さい場合、バックト"
"レース全体が格納されている。返り値が I<size> と等しい場合、バックトレースは切"
"り詰められているかもしれない。 切り詰められた場合、最も古いスタックフレームの"
"アドレスは 返されないことになる。"

#. type: Plain text
#: build/C/man3/backtrace.3:138
msgid ""
"On success, B<backtrace_symbols>()  returns a pointer to the array "
"B<malloc>(3)ed by the call; on error, NULL is returned."
msgstr ""
"B<backtrace_symbols>()  は、成功すると、この呼び出しで B<malloc>(3)  された配"
"列へのポインターを返す。 エラーの場合、 NULL を返す。"

#. type: Plain text
#: build/C/man3/backtrace.3:144
msgid ""
"B<backtrace>(), B<backtrace_symbols>(), and B<backtrace_symbols_fd>()  are "
"provided in glibc since version 2.1."
msgstr ""
"B<backtrace>(), B<backtrace_symbols>(), B<backtrace_symbols_fd>()  はバージョ"
"ン 2.1 以降の glibc で提供されている。"

#. type: tbl table
#: build/C/man3/backtrace.3:154
#, no-wrap
msgid "B<backtrace>(),\n"
msgstr "B<backtrace>(),\n"

#. type: tbl table
#: build/C/man3/backtrace.3:156
#, no-wrap
msgid "B<backtrace_symbols>(),\n"
msgstr "B<backtrace_symbols>(),\n"

#. type: tbl table
#: build/C/man3/backtrace.3:158
#, no-wrap
msgid "B<backtrace_symbols_fd>()"
msgstr "B<backtrace_symbols_fd>()"

#. type: Plain text
#: build/C/man3/backtrace.3:162
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/backtrace.3:166
msgid ""
"These functions make some assumptions about how a function's return address "
"is stored on the stack.  Note the following:"
msgstr ""
"これらの関数は、関数のリターンアドレスがスタック上でどのように格納されるか に"
"関してある仮定を置いている。 以下の点に注意。"

#. type: IP
#: build/C/man3/backtrace.3:166 build/C/man3/backtrace.3:172
#: build/C/man3/backtrace.3:174 build/C/man3/backtrace.3:176
#: build/C/man3/setjmp.3:313 build/C/man3/setjmp.3:318
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/backtrace.3:172
msgid ""
"Omission of the frame pointers (as implied by any of B<gcc>(1)'s nonzero "
"optimization levels) may cause these assumptions to be violated."
msgstr ""
"(B<gcc>(1)  の 0 以外の最適化レベルで暗黙のうちに行われる)  フレームポイン"
"ターの省略を行うと、これらの前提が崩れる可能性がある。"

#. type: Plain text
#: build/C/man3/backtrace.3:174
msgid "Inlined functions do not have stack frames."
msgstr "インライン関数はスタックフレームを持たない。"

#. type: Plain text
#: build/C/man3/backtrace.3:176
msgid "Tail-call optimization causes one stack frame to replace another."
msgstr ""
"末尾呼び出しの最適化 (tail-call optimization) を行うと、 あるスタックフレーム"
"が別のスタックフレームを置き換える可能性がある。"

#. type: Plain text
#: build/C/man3/backtrace.3:191
msgid ""
"B<backtrace>()  and B<backtrace_symbols_fd>()  don't call B<malloc>()  "
"explicitly, but they are part of I<libgcc>, which gets loaded dynamically "
"when first used.  Dynamic loading usually triggers a call to B<malloc>(3).  "
"If you need certain calls to these two functions to not allocate memory (in "
"signal handlers, for example), you need to make sure I<libgcc> is loaded "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/backtrace.3:199
msgid ""
"The symbol names may be unavailable without the use of special linker "
"options.  For systems using the GNU linker, it is necessary to use the I<-"
"rdynamic> linker option.  Note that names of \"static\" functions are not "
"exposed, and won't be available in the backtrace."
msgstr ""
"シンボル名は特別なリンカーオプションを使用しないと利用できない場合がある。 "
"GNU リンカーを使用するシステムでは、 I<-rdynamic> リンカーオプションを使う必"
"要がある。 \"static\" な関数のシンボル名は公開されず、 バックトレースでは利用"
"できない点に注意すること。"

#. type: Plain text
#: build/C/man3/backtrace.3:206
msgid ""
"The program below demonstrates the use of B<backtrace>()  and "
"B<backtrace_symbols>().  The following shell session shows what we might see "
"when running the program:"
msgstr ""
"以下のプログラムは、 B<backtrace>()  と B<backtrace_symbols>()  の使用例を示"
"したものである。 以下に示すシェルのセッションは、 このプログラムを動かした際"
"の実行例である。"

#. type: Plain text
#: build/C/man3/backtrace.3:220
#, no-wrap
msgid ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"
msgstr ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"

#. type: SS
#: build/C/man3/backtrace.3:222 build/C/man3/offsetof.3:77
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/backtrace.3:229
#, no-wrap
msgid ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/backtrace.3:231
#, no-wrap
msgid "#define BT_BUF_SIZE 100\n"
msgstr "#define BT_BUF_SIZE 100\n"

#. type: Plain text
#: build/C/man3/backtrace.3:238
#, no-wrap
msgid ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int nptrs;\n"
"    void *buffer[BT_BUF_SIZE];\n"
"    char **strings;\n"
msgstr ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int nptrs;\n"
"    void *buffer[BT_BUF_SIZE];\n"
"    char **strings;\n"

#. type: Plain text
#: build/C/man3/backtrace.3:241
#, no-wrap
msgid ""
"    nptrs = backtrace(buffer, BT_BUF_SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"
msgstr ""
"    nptrs = backtrace(buffer, BT_BUF_SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"

#. type: Plain text
#: build/C/man3/backtrace.3:244
#, no-wrap
msgid ""
"    /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)\n"
"       would produce similar output to the following: */\n"
msgstr ""
"    /* backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO) を\n"
"       呼び出しても、以下と同様の出力が得られる。 */\n"

#. type: Plain text
#: build/C/man3/backtrace.3:250
#, no-wrap
msgid ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/backtrace.3:253
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"
msgstr ""
"    for (int j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"

#. type: Plain text
#: build/C/man3/backtrace.3:256
#, no-wrap
msgid ""
"    free(strings);\n"
"}\n"
msgstr ""
"    free(strings);\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:262
#, no-wrap
msgid ""
"static void   /* \"static\" means don\\(aqt export the symbol... */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"
msgstr ""
"static void   /* \"static\" はシンボルを公開しないことを意味する */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:271
#, no-wrap
msgid ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"
msgstr ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:279
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/backtrace.3:283
#, no-wrap
msgid ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:291
msgid ""
"B<addr2line>(1), B<gcc>(1), B<gdb>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"
msgstr "B<addr2line>(1), B<gcc>(1), B<gdb>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"

#. type: TH
#: build/C/man3/basename.3:27
#, no-wrap
msgid "BASENAME"
msgstr "BASENAME"

#. type: Plain text
#: build/C/man3/basename.3:30
msgid "basename, dirname - parse pathname components"
msgstr "basename, dirname - パス名を解析して各部分を取り出す"

#. type: Plain text
#: build/C/man3/basename.3:33
#, no-wrap
msgid "B<#include E<lt>libgen.hE<gt>>\n"
msgstr "B<#include E<lt>libgen.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/basename.3:35
#, no-wrap
msgid "B<char *dirname(char *>I<path>B<);>\n"
msgstr "B<char *dirname(char *>I<path>B<);>\n"

#. type: Plain text
#: build/C/man3/basename.3:37
#, no-wrap
msgid "B<char *basename(char *>I<path>B<);>\n"
msgstr "B<char *basename(char *>I<path>B<);>\n"

#. type: Plain text
#: build/C/man3/basename.3:42
msgid "Warning: there are two different functions B<basename>()  - see below."
msgstr ""
"警告: B<basename>()  には異なるバージョンが 2つ存在する。下記の「注意」の節を"
"参照のこと。"

#. type: Plain text
#: build/C/man3/basename.3:55
msgid ""
"The functions B<dirname>()  and B<basename>()  break a null-terminated "
"pathname string into directory and filename components.  In the usual case, "
"B<dirname>()  returns the string up to, but not including, the final \\(aq/"
"\\(aq, and B<basename>()  returns the component following the final \\(aq/"
"\\(aq.  Trailing \\(aq/\\(aq characters are not counted as part of the "
"pathname."
msgstr ""
"B<dirname>()  と B<basename>()  は、ヌルで終端されたパス名の文字列を、 ディレ"
"クトリ部分・ファイル名部分に分割する。 通常は、 B<dirname>()  は最後の \\(aq/"
"\\(aq までの部分 (最後の \\(aq/\\(aq は含まない) を返し、 B<basename>()  は最"
"後の \\(aq/\\(aq 以降の部分を返す。 文字列の末尾についた \\(aq/\\(aq 文字は、"
"パス名の一部とはみなされない。"

#. type: Plain text
#: build/C/man3/basename.3:78
msgid ""
"If I<path> does not contain a slash, B<dirname>()  returns the string \".\" "
"while B<basename>()  returns a copy of I<path>.  If I<path> is the string \"/"
"\", then both B<dirname>()  and B<basename>()  return the string \"/\".  If "
"I<path> is a null pointer or points to an empty string, then both "
"B<dirname>()  and B<basename>()  return the string \".\"."
msgstr ""
"I<path> に '/' 文字がない場合は、 B<dirname>()  は文字列 \".\" を返し、 "
"B<basename>()  は I<path> と同じ内容を返す。 I<path> が文字列 \"/\" に等しい"
"場合は、 B<dirname>()  も B<basename>()  も文字列 \"/\" を返す。 I<path> が "
"ヌルポインターだったり、空の文字列を指していた場合は、 B<dirname>()  も "
"B<basename>()  も文字列 \".\" を返す。"

#. type: Plain text
#: build/C/man3/basename.3:84
msgid ""
"Concatenating the string returned by B<dirname>(), a \"/\", and the string "
"returned by B<basename>()  yields a complete pathname."
msgstr ""
"B<dirname>()  の返した文字列、 \"/\"、 B<basename>()  の返した文字列、 を順に"
"結合すると、完全なパス名が得られる。"

#. type: Plain text
#: build/C/man3/basename.3:93
msgid ""
"Both B<dirname>()  and B<basename>()  may modify the contents of I<path>, so "
"it may be desirable to pass a copy when calling one of these functions."
msgstr ""
"B<dirname>()  と B<basename>()  は、いずれも I<path> の内容を変更することがあ"
"る。 したがって、これらの関数を呼び出す際には コピーを渡すのが望ましい。"

#. type: Plain text
#: build/C/man3/basename.3:102
msgid ""
"These functions may return pointers to statically allocated memory which may "
"be overwritten by subsequent calls.  Alternatively, they may return a "
"pointer to some part of I<path>, so that the string referred to by I<path> "
"should not be modified or freed until the pointer returned by the function "
"is no longer required."
msgstr ""
"これらの関数は、静的に割り当てられたメモリーへのポインターを返すことがあり、 "
"これらの領域は後の関数呼び出しで上書きされるかもしれない。 また、これらの関数"
"は I<path> の一部分を指すポインターを返すこともある。そのため、 I<path> で参"
"照される文字列は、関数が返すポインターが不要になるまでは 変更したり free した"
"りすべきではない。"

#. type: Plain text
#: build/C/man3/basename.3:109
msgid ""
"The following list of examples (taken from SUSv2)  shows the strings "
"returned by B<dirname>()  and B<basename>()  for different paths:"
msgstr ""
"以下の一連の例 (SUSv2 から引用) は、 いろいろな path に対して B<dirname>()  "
"と B<basename>()  が返す文字列を表したものである。"

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "path    "
msgstr "path    "

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "dirname"
msgstr "dirname"

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "basename"
msgstr "basename"

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "/usr/lib"
msgstr "/usr/lib"

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "/usr"
msgstr "/usr"

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "lib"
msgstr "lib"

#. type: tbl table
#: build/C/man3/basename.3:115
#, no-wrap
msgid "/usr/   "
msgstr "/usr/   "

#. type: tbl table
#: build/C/man3/basename.3:115 build/C/man3/basename.3:117
#, no-wrap
msgid "/"
msgstr "/"

#. type: tbl table
#: build/C/man3/basename.3:115 build/C/man3/basename.3:116
#, no-wrap
msgid "usr"
msgstr "usr"

#. type: tbl table
#: build/C/man3/basename.3:116
#, no-wrap
msgid "usr     "
msgstr "usr     "

#. type: tbl table
#: build/C/man3/basename.3:116 build/C/man3/basename.3:118
#: build/C/man3/basename.3:119
#, no-wrap
msgid "."
msgstr "."

#. type: tbl table
#: build/C/man3/basename.3:117
#, no-wrap
msgid "/       "
msgstr "/       "

#. type: tbl table
#: build/C/man3/basename.3:118
#, no-wrap
msgid "\\&.       "
msgstr "\\&.       "

#. type: tbl table
#: build/C/man3/basename.3:119
#, no-wrap
msgid "\\&..      "
msgstr "\\&..      "

#. type: tbl table
#: build/C/man3/basename.3:119
#, no-wrap
msgid ".."
msgstr ".."

#. type: Plain text
#: build/C/man3/basename.3:130
msgid ""
"Both B<dirname>()  and B<basename>()  return pointers to null-terminated "
"strings.  (Do not pass these pointers to B<free>(3).)"
msgstr ""
"B<dirname>()  と B<basename>()  は、いずれもヌルで終端された文字列へのポイン"
"ターを返す。 (これらのポインターを B<free>(3)  に渡さないこと。)"

#. type: tbl table
#: build/C/man3/basename.3:141
#, no-wrap
msgid ""
"B<basename>(),\n"
"B<dirname>()"
msgstr ""
"B<basename>(),\n"
"B<dirname>()"

#. type: Plain text
#: build/C/man3/basename.3:145 build/C/man3/ftok.3:84
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/basename.3:150
msgid ""
"There are two different versions of B<basename>()  - the POSIX version "
"described above, and the GNU version, which one gets after"
msgstr ""
"B<basename>()  には 2種類の異なるバージョンがある。 一つはすでに説明した "
"POSIX バージョンであり、 もう一つは GNU バージョンである。 GNU バージョンを使"
"用するには以下のようにする。"

#. type: Plain text
#: build/C/man3/basename.3:155
#, no-wrap
msgid ""
"B<    #define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<    #define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/basename.3:164
msgid ""
"The GNU version never modifies its argument, and returns the empty string "
"when I<path> has a trailing slash, and in particular also when it is \"/\".  "
"There is no GNU version of B<dirname>()."
msgstr ""
"GNU バージョンは引数を変更することはなく、 I<path> の末尾が '/'の場合は空の"
"文字列を返す。 特に I<path> が \"/\" の場合も空文字列を返す。 B<dirname>()  "
"には GNU バージョンはない。"

#. type: Plain text
#: build/C/man3/basename.3:170
msgid ""
"With glibc, one gets the POSIX version of B<basename>()  when I<E<lt>libgen."
"hE<gt>> is included, and the GNU version otherwise."
msgstr ""
"glibc では、 I<E<lt>libgen.hE<gt>> をインクルードすると POSIX バージョンの "
"B<basename>()  が使用され、それ以外の場合は GNU バージョンとなる。"

#. type: Plain text
#: build/C/man3/basename.3:176
msgid ""
"In the glibc implementation, the POSIX versions of these functions modify "
"the I<path> argument, and segfault when called with a static string such as "
"\"/usr/\"."
msgstr "glibc の実装では、これらの関数の POSIX バージョンは I<path> 引数が変更され、 \"/usr/\" などの静的文字列を指定されるとセグメンテーションフォールトを起こす。"

#. type: Plain text
#: build/C/man3/basename.3:181
msgid ""
"Before glibc 2.2.1, the glibc version of B<dirname>()  did not correctly "
"handle pathnames with trailing \\(aq/\\(aq characters, and generated a "
"segfault if given a NULL argument."
msgstr "バージョン 2.2.1 以前の glibc では、 glibc の B<dirname>()  は末尾が \\(aq/\\(aq 文字になっているパス名を正しく扱えず、 引数が NULL だとセグメンテーションフォールトを起こした。"

#. type: Plain text
#: build/C/man3/basename.3:186
msgid ""
"The following code snippet demonstrates the use of B<basename>()  and "
"B<dirname>():"
msgstr ""

#. type: Plain text
#: build/C/man3/basename.3:190
#, no-wrap
msgid ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"
msgstr ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"

#. type: Plain text
#: build/C/man3/basename.3:196
#, no-wrap
msgid ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"
msgstr ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"

#. type: Plain text
#: build/C/man3/basename.3:201
msgid "B<basename>(1), B<dirname>(1)"
msgstr "B<basename>(1), B<dirname>(1)"

#. type: TH
#: build/C/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr "ENVZ_ADD"

#. type: Plain text
#: build/C/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - 環境変"
"数文字列の操作"

#. type: Plain text
#: build/C/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr "B<#include E<lt>envz.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:23
#, no-wrap
msgid "B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:26
#, no-wrap
msgid "B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"
msgstr ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:33
#, no-wrap
msgid "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing \\(aq="
"\\(aq is the empty string \"\".)"
msgstr ""
"argz vector は長さ情報付きの文字バッファーへのポインターである。 "
"B<argz_add>(3)  を参照のこと。 envz vector は、文字列が \"name=value (名前="
"値)\" の形式になっている特別な argz vector である。 最初の \\(aq=\\(aq 以降は"
"すべて値とみなされる。\\(aq=\\(aq がなければ、 値は NULL と解釈される。(文字"
"列の一番最後の文字が \\(aq=\\(aq の場合、値は空文字列 \"\" と解釈される。)"

#. type: Plain text
#: build/C/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr "これらの関数は envz vector を操作するためのものである。"

#. type: Plain text
#: build/C/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is non-"
"NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector (I<*envz>,"
"\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an entry with "
"the same I<name> existed, it is removed."
msgstr ""
"B<envz_add>()  は、文字列 \"I<name>=I<value>\" (I<value> が NULL でない場合) "
"または \"I<name>\" (I<value> が NULL の場合) を envz vector (I<*envz>,\\ "
"I<*envz_len>)  に追加し、 I<*envz> と I<*envz_len> を更新する。 I<name> と同"
"じ名前を持つエントリーがあった場合、元のエントリーは削除される。"

#. type: Plain text
#: build/C/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""
"B<envz_entry>()  は、envz vector (I<envz>,\\ I<envz_len>)  から名前が "
"I<name> のエントリーを検索する。 見つかった場合はそのエントリーを返し、見つか"
"らなかった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the value if found, or NULL if not.  (Note that "
"the value can also be NULL, namely when there is an entry for I<name> "
"without \\(aq=\\(aq sign.)"
msgstr ""
"B<envz_get>()  は、envz vector (I<envz>,\\ I<envz_len>)  から名前が I<name> "
"のエントリーを検索する。 見つかった場合はエントリーの値を返し、見つからなかっ"
"た場合は NULL を返す。 (値は NULL の場合もあることに注意すること。名前が "
"I<name> のエントリーに \\(aq=\\(aq 符号がない場合が該当する。)"

#. type: Plain text
#: build/C/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""
"B<envz_merge>()  は、 B<envz_add>()  と同じように I<envz2> の各エントリーを "
"I<*envz> に追加する。 I<override> が真の場合、 I<envz2> の値で I<*envz> 内の"
"同じ名前をもつ値は上書きされる。 偽の場合は上書きされない。"

#. type: Plain text
#: build/C/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""
"B<envz_remove>()  は、名前が I<name> のエントリーがあれば (I<*envz>,\\ "
"I<*envz_len>)  から削除する。"

#. type: Plain text
#: build/C/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr "B<envz_strip>()  は、値が NULL のエントリーをすべて削除する。"

#. type: Plain text
#: build/C/man3/envz_add.3:119
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t> (an integer type), and return 0 for success, and B<ENOMEM> if an "
"allocation error occurs."
msgstr "メモリー割り当てを行う envz 関数群はすべて I<error_t> 型 (integer 型) の返り値を持つ。 成功した場合は 0 を返し、割り当てエラーが発生した場合は B<ENOMEM> を返す。"

#. type: tbl table
#: build/C/man3/envz_add.3:130
#, no-wrap
msgid ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"
msgstr ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"

#. type: tbl table
#: build/C/man3/envz_add.3:133
#, no-wrap
msgid ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"
msgstr ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"

#. type: tbl table
#: build/C/man3/envz_add.3:136
#, no-wrap
msgid ""
"B<envz_remove>(),\n"
"B<envz_strip>()"
msgstr ""
"B<envz_remove>(),\n"
"B<envz_strip>()"

#. type: Plain text
#: build/C/man3/envz_add.3:146
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:152
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int e_len = 0;\n"
"    char *str;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int e_len = 0;\n"
"    char *str;\n"

#. type: Plain text
#: build/C/man3/envz_add.3:155
#, no-wrap
msgid ""
"    for (int i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""
"    for (int i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"

#. type: Plain text
#: build/C/man3/envz_add.3:162
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/envz_add.3:165
msgid "B<argz_add>(3)"
msgstr "B<argz_add>(3)"

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr "FTOK"

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man3/ftok.3:32
msgid ""
"ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr "ftok - パス名とプロジェクト識別子を System V IPC キーに変換する"

#. type: Plain text
#: build/C/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"

#. type: Plain text
#: build/C/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a "
"I<key_t> type System V IPC key, suitable for use with B<msgget>(2), "
"B<semget>(2), or B<shmget>(2)."
msgstr ""
"B<ftok>()  関数は I<pathname> で与えられたファイル (存在し、アクセス可能でな"
"ければならない)  のファイル名の識別情報 (identity) と、 I<proj_id> (0 であっ"
"てはならない) の低位 8 ビットとを用いて、 I<key_t> 型の System V IPC キーを生"
"成する。 このキーは B<msgget>(2), B<semget>(2), B<shmget>(2)  などでの利用に"
"適している。"

#. type: Plain text
#: build/C/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs differ."
msgstr ""
"同じファイルを示すあらゆるパス名と、同じ I<proj_id> に対しては、結果の値は等"
"しくなる。 ファイルが違ったり (この場合両者は同時に存在しているはず)、 "
"I<proj_id> が異なると、返り値も異なる。"

#. type: Plain text
#: build/C/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""
"成功した場合は生成された I<key_t> の値が返される。 失敗すると -1 が返され、エ"
"ラーの内容が B<errno> に書き込まれる。この内容はシステムコール B<stat>(2)  の"
"ものと同じである。"

#. type: tbl table
#: build/C/man3/ftok.3:80
#, no-wrap
msgid "B<ftok>()"
msgstr "B<ftok>()"

#. type: Plain text
#: build/C/man3/ftok.3:86
msgid "On some ancient systems, the prototype was:"
msgstr "いくつかの古いシステムでは、プロトタイプは以下のようになっていた。"

#. type: Plain text
#: build/C/man3/ftok.3:90
#, no-wrap
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"
msgstr "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"

#. type: Plain text
#: build/C/man3/ftok.3:103
msgid ""
"Today, I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to "
"be undefined when I<proj_id> is zero."
msgstr ""
"現在では I<proj_id> は I<int> だが、依然として 8 ビットしか用いられない。 通"
"常は ASCII キャラクターが I<proj_id> に用いられる。 I<proj_id> が 0 のときの"
"振る舞いが未定義になっているのは、これが理由である。"

#. type: Plain text
#: build/C/man3/ftok.3:115
msgid ""
"Of course, no guarantee can be given that the resulting I<key_t> is unique.  "
"Typically, a best-effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number "
"into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""
"もちろん I<key_t> が他と重ならないものであるかどうかは保証されない。 最善の場"
"合の組み合わせを考えても、 I<proj_id> の 1 バイト、i ノード番号の低位 16 ビッ"
"ト、および デバイス番号の低位 8 ビットなので、結果は 32 ビットに過ぎない。 例"
"えば I</dev/hda1> と I</dev/sda1> それぞれにあるファイルに対して、衝突は容易"
"に起こりうる。"

#. type: Plain text
#: build/C/man3/ftok.3:118
msgid "See B<semget>(2)."
msgstr "B<semget>(2) を参照。"

#. type: Plain text
#: build/C/man3/ftok.3:124
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"
msgstr "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"

#. type: TH
#: build/C/man3/offsetof.3:28
#, no-wrap
msgid "OFFSETOF"
msgstr "OFFSETOF"

#. type: Plain text
#: build/C/man3/offsetof.3:31
msgid "offsetof - offset of a structure member"
msgstr "offsetof - 構造体のメンバーのオフセットを返す"

#. type: Plain text
#: build/C/man3/offsetof.3:34
#, no-wrap
msgid "B<#include E<lt>stddef.hE<gt>>\n"
msgstr "B<#include E<lt>stddef.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:36
#, no-wrap
msgid "B<size_t offsetof(>I<type>B<, >I<member>B<);>\n"
msgstr "B<size_t offsetof(>I<type>B<, >I<member>B<);>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:44
msgid ""
"The macro B<offsetof>()  returns the offset of the field I<member> from the "
"start of the structure I<type>."
msgstr ""
"B<offsetof>()  マクロは、フィールド I<member> の 構造体 I<type> の先頭からの"
"オフセットを返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:51
msgid ""
"This macro is useful because the sizes of the fields that compose a "
"structure can vary across implementations, and compilers may insert "
"different numbers of padding bytes between fields.  Consequently, an "
"element's offset is not necessarily given by the sum of the sizes of the "
"previous elements."
msgstr ""
"このマクロが有用なのは、 構造体を構成するフィールドのサイズは実装によって変化"
"するし、 コンパイラによりフィールド間に挿入するパディングのバイト数も 違う可"
"能性があるからである。 その結果、あるエレメントのオフセットは必ずしもそれより"
"前の エレメントのサイズの合計とはならない。"

#. type: Plain text
#: build/C/man3/offsetof.3:56
msgid ""
"A compiler error will result if I<member> is not aligned to a byte boundary "
"(i.e., it is a bit field)."
msgstr ""
"I<member> がバイト境界に位置していない場合 (すなわち、ビットフィールドの場"
"合) には、 コンパイラでエラーが発生する。"

#. type: Plain text
#: build/C/man3/offsetof.3:63
msgid ""
"B<offsetof>()  returns the offset of the given I<member> within the given "
"I<type>, in units of bytes."
msgstr ""
"B<offsetof>()  は、指定された I<member> の指定された I<type> の中でのオフセッ"
"トを、バイト単位で返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:65
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: build/C/man3/offsetof.3:69
msgid ""
"On a Linux/i386 system, when compiled using the default B<gcc>(1)  options, "
"the program below produces the following output:"
msgstr ""
"Linux/i386 システムで、 B<gcc>(1)  のデフォルトオプションで コンパイルされた"
"場合、下記のプログラムは以下のような出力を返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:75
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"offsets: i=0; c=4; d=8 a=16\n"
"sizeof(struct s)=16\n"
msgstr ""
"$B< ./a.out>\n"
"offsets: i=0; c=4; d=8 a=16\n"
"sizeof(struct s)=16\n"

#. type: Plain text
#: build/C/man3/offsetof.3:83
#, no-wrap
msgid ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:93
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct s {\n"
"        int i;\n"
"        char c;\n"
"        double d;\n"
"        char a[];\n"
"    };\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct s {\n"
"        int i;\n"
"        char c;\n"
"        double d;\n"
"        char a[];\n"
"    };\n"

#. type: Plain text
#: build/C/man3/offsetof.3:95
#, no-wrap
msgid "    /* Output is compiler dependent */\n"
msgstr "    /* 出力はコンパイラ依存である */\n"

#. type: Plain text
#: build/C/man3/offsetof.3:100
#, no-wrap
msgid ""
"    printf(\"offsets: i=%zu; c=%zu; d=%zu a=%zu\\en\",\n"
"            offsetof(struct s, i), offsetof(struct s, c),\n"
"            offsetof(struct s, d), offsetof(struct s, a));\n"
"    printf(\"sizeof(struct s)=%zu\\en\", sizeof(struct s));\n"
msgstr ""
"    printf(\"offsets: i=%zu; c=%zu; d=%zu a=%zu\\en\",\n"
"            offsetof(struct s, i), offsetof(struct s, c),\n"
"            offsetof(struct s, d), offsetof(struct s, a));\n"
"    printf(\"sizeof(struct s)=%zu\\en\", sizeof(struct s));\n"

#. type: Plain text
#: build/C/man3/offsetof.3:103
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: TH
#: build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "INVOCATION_NAME"
msgstr "INVOCATION_NAME"

#. type: TH
#: build/C/man3/program_invocation_name.3:24 build/C/man3/realpath.3:28
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:28
msgid ""
"program_invocation_name, program_invocation_short_name - obtain name used to "
"invoke calling program"
msgstr ""
"program_invocation_name, program_invocation_short_name - プログラムの起動に使"
"われた名前を取得する"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>errno.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:35
#, no-wrap
msgid ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"
msgstr ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:46
msgid ""
"I<program_invocation_name> contains the name that was used to invoke the "
"calling program.  This is the same as the value of I<argv[0]> in I<main>(), "
"with the difference that the scope of I<program_invocation_name> is global."
msgstr ""
"I<program_invocation_name> は、呼び出し元プログラムの起動に使用された名前を保"
"持する。 内容は I<main>()  の I<argv[0]> の値と同じだが、 "
"I<program_invocation_name> の方はスコープがグローバルである点が異なる。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:53
msgid ""
"I<program_invocation_short_name> contains the basename component of name "
"that was used to invoke the calling program.  That is, it is the same value "
"as I<program_invocation_name>, with all text up to and including the final "
"slash (/), if any, removed."
msgstr ""
"I<program_invocation_short_name> は、呼び出し元プログラムの起動に使用された名"
"前の basename 部分を 保持する。つまり、この変数の内容は、最後のスラッシュ "
"(/) とそれより前の 部分がある場合、 I<program_invocation_name> からこの部分を"
"削除したものとなる。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:56
msgid ""
"These variables are automatically initialized by the glibc run-time startup "
"code."
msgstr ""
"これらの変数は glibc のランタイムスタートアップコードで 自動的に初期化され"
"る。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:59
msgid ""
"These variables are GNU extensions, and should not be used in programs "
"intended to be portable."
msgstr ""
"これらの変数は GNU の拡張であり、 移植性が必要なプログラムでは使用すべきでな"
"い。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:63
msgid ""
"The Linux-specific I</proc/[number]/cmdline> file provides access to similar "
"information."
msgstr ""
"Linux 独自のファイル I</proc/[number]/cmdline> でも同様の情報を得ることができ"
"る。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:65
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: build/C/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr "REALPATH"

#. type: Plain text
#: build/C/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr "realpath - 正規化された絶対パス名を返す"

#. type: Plain text
#: build/C/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"

#. type: Plain text
#: build/C/man3/realpath.3:45
msgid "B<realpath>():"
msgstr "B<realpath>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/realpath.3:51
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* glibc 2.19 以降: */ _DEFAULT_SOURCE\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man3/realpath.3:73
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>, "
"I</../> and extra \\(aq/\\(aq characters in the null-terminated string named "
"by I<path> to produce a canonicalized absolute pathname.  The resulting "
"pathname is stored as a null-terminated string, up to a maximum of "
"B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""
"B<realpath>()  は I<path> として与えられたヌル終端された文字列中の すべてのシ"
"ンボリックリンクを展開し、 I</./>, I</../> による参照や余分な \\(aq/\\(aq を"
"解決して、正規化された絶対パス名を生成する。 得られた絶対パス名は、最大で "
"B<PATH_MAX> バイトのヌル終端された文字列として、 I<resolved_path> により参照"
"されるバッファーに格納される。 結果として返るパスの中には、シンボリックリンク"
"や I</./>, I</../> といった要素は含まれない。"

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: build/C/man3/realpath.3:93
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses "
"B<malloc>(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the "
"resolved pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""
"I<resolved_path> に NULL が指定されると、 B<realpath>()  は B<malloc>(3)  を"
"使って解決したパス名を保持するためのバッファーを 最大で B<PATH_MAX> バイトま"
"で割り当て、このバッファーへのポインターを返す。 呼び出し元は、 B<free>(3)  "
"を使ってこのバッファーを解放すべきである。"

#. type: Plain text
#: build/C/man3/realpath.3:98
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""
"エラーがなかった場合、 B<realpath>()  は I<resolved_path> へのポインターを返"
"す。"

#. type: Plain text
#: build/C/man3/realpath.3:105
msgid ""
"Otherwise, it returns NULL, the contents of the array I<resolved_path> are "
"undefined, and I<errno> is set to indicate the error."
msgstr ""
"それ以外の場合は NULL が返り、配列 I<resolved_path> の内容は不定となり、 "
"I<errno> にエラーの内容を示す値がセットされる。"

#. type: SH
#: build/C/man3/realpath.3:105
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/realpath.3:106
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/realpath.3:109
msgid ""
"Read or search permission was denied for a component of the path prefix."
msgstr ""
"パスのディレクトリ部分に、読み出し許可または検索許可が与えられていない。"

#. type: TP
#: build/C/man3/realpath.3:109
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: build/C/man3/realpath.3:118
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned "
"if I<resolved_path> is NULL.)"
msgstr ""
"I<path> が NULL である。 (バージョン 2.3 より前の glibc では、 "
"I<resolved_path> が NULL の場合にもこのエラーが返される。)"

#. type: TP
#: build/C/man3/realpath.3:118
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man3/realpath.3:121
msgid "An I/O error occurred while reading from the filesystem."
msgstr "ファイルシステムを読むときに、I/Oエラーが起こった。"

#. type: TP
#: build/C/man3/realpath.3:121
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man3/realpath.3:124
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名の変換にあたり、解決すべきシンボリックリンクの数が多過ぎた。"

#. type: TP
#: build/C/man3/realpath.3:124
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/realpath.3:131
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""
"パス名の一要素の文字数が B<NAME_MAX> を越えている、またはパス名全体の文字数"
"が B<PATH_MAX> を越えている。"

#. type: TP
#: build/C/man3/realpath.3:131
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/realpath.3:134
msgid "The named file does not exist."
msgstr "指定されたファイルが存在しない。"

#. type: TP
#: build/C/man3/realpath.3:134
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/realpath.3:137
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: TP
#: build/C/man3/realpath.3:137
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man3/realpath.3:140
msgid "A component of the path prefix is not a directory."
msgstr "パスのディレクトリ要素が、ディレクトリでない。"

#. type: tbl table
#: build/C/man3/realpath.3:150
#, no-wrap
msgid "B<realpath>()"
msgstr "B<realpath>()"

#. type: Plain text
#: build/C/man3/realpath.3:154
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/realpath.3:159
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""
"POSIX.1-2001 では I<resolved_path> が NULL の場合の動作は実装に依存するとして"
"いる。 POSIX.1-2008 では、このマニュアルページに書かれている動作が規定されて"
"いる。"

#. type: Plain text
#: build/C/man3/realpath.3:171
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the "
"B<pathconf>(3)  function.  A typical source fragment would be"
msgstr ""
"4.4BSD と Solaris では、パス名の長さの上限は (I<E<lt>sys/param.hE<gt>> の中に"
"ある)  B<MAXPATHLEN> である。SUSv2 では B<PATH_MAX> と B<NAME_MAX> が規定され"
"ており、 これらは I<E<lt>limits.hE<gt>> で定義されているか、 B<pathconf>(3)  "
"関数から得られる。以下のようなソースコードになっていることが多い。"

#. type: Plain text
#: build/C/man3/realpath.3:181
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"\t path_max = 4096;\n"
"#endif\n"

#. .PP
#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#.  The prototype of
#.  .BR realpath ()
#.  is given in \fI<unistd.h>\fP in libc4 and libc5,
#.  but in \fI<stdlib.h>\fP everywhere else.
#. type: Plain text
#: build/C/man3/realpath.3:199
msgid "(But see the BUGS section.)"
msgstr "(バグの章も参照のこと。)"

#. type: SS
#: build/C/man3/realpath.3:199
#, no-wrap
msgid "GNU extensions"
msgstr "GNU による拡張"

#. type: Plain text
#: build/C/man3/realpath.3:210
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is "
"not NULL, then the prefix of I<path> that is not readable or does not exist "
"is returned in I<resolved_path>."
msgstr ""
"呼び出しが B<EACCES> か B<ENOENT> で失敗し I<resolved_path> が NULL でない場"
"合、読むことができない、もしくは存在しない I<path> のディレクトリ要素 "
"(prefix) が I<resolved_path> で返される。"

#.  .LP
#.  The libc4 and libc5 implementation contained a buffer overflow
#.  (fixed in libc-5.4.13).
#.  Thus, set-user-ID programs like
#.  .BR mount (8)
#.  needed a private version.
#. type: Plain text
#: build/C/man3/realpath.3:241
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be "
"obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""
"この関数の POSIX.1-2001 版は、設計段階から問題がある。 出力バッファー "
"I<resolved_path> の適切なサイズを決定することができないからである。 "
"POSIX.1-2001 ではバッファーサイズとして B<PATH_MAX> は十分だとされているが、 "
"B<PATH_MAX> は定義済の定数である必要はなく、 B<pathconf>(3)  を使って得られる"
"値であってもよいことになっている。 B<pathconf>(3)  からバッファーサイズを取得"
"したとしても必ずしも十分ではない。 なぜなら、POSIX で警告されているように、 "
"B<pathconf>(3)  の返り値が大き過ぎて適切にメモリーを確保することができない か"
"もしれない一方で、 B<pathconf>(3)  は B<PATH_MAX> に制限がないことを示す -1 "
"を返すかもしれないからである。 I<resolved_path\\ ==\\ NULL> の機能を使うと、"
"この設計上の問題を回避することができる。 この機能は POSIX.1-2001 では標準化さ"
"れていないが、 POSIX.1-2008 では標準化されている。"

#. type: Plain text
#: build/C/man3/realpath.3:248
msgid ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"
msgstr ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"

#. type: TH
#: build/C/man3/setjmp.3:24
#, no-wrap
msgid "SETJMP"
msgstr "SETJMP"

#. type: TH
#: build/C/man3/setjmp.3:24
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: build/C/man3/setjmp.3:27
msgid "setjmp, sigsetjmp, longjmp, siglongjmp - performing a nonlocal goto"
msgstr "setjmp, sigsetjmp, longjmp, siglongjmp - 非局所的なジャンプの実行"

#. type: Plain text
#: build/C/man3/setjmp.3:30
#, no-wrap
msgid "B<#include E<lt>setjmp.hE<gt>>\n"
msgstr "B<#include E<lt>setjmp.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/setjmp.3:33
#, no-wrap
msgid ""
"B<int setjmp(jmp_buf >I<env>B<);>\n"
"B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"
msgstr ""
"B<int setjmp(jmp_buf >I<env>B<);>\n"
"B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"

#. type: Plain text
#: build/C/man3/setjmp.3:36
#, no-wrap
msgid ""
"B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
"B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"
msgstr ""
"B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
"B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"

#. type: Plain text
#: build/C/man3/setjmp.3:45
msgid "B<setjmp>(): see NOTES."
msgstr "B<setjmp>(): 「注意」参照。"

#. type: Plain text
#: build/C/man3/setjmp.3:48
msgid "B<sigsetjmp>(): _POSIX_C_SOURCE"
msgstr "B<sigsetjmp>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/setjmp.3:58
msgid ""
"The functions described on this page are used for performing \"nonlocal gotos"
"\": transferring execution from one function to a predetermined location in "
"another function.  The B<setjmp>()  function dynamically establishes the "
"target to which control will later be transferred, and B<longjmp>()  "
"performs the transfer of execution."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:71
msgid ""
"The B<setjmp>()  function saves various information about the calling "
"environment (typically, the stack pointer, the instruction pointer, possibly "
"the values of other registers and the signal mask)  in the buffer I<env> for "
"later use by B<longjmp>().  In this case, B<setjmp>()  returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:86
msgid ""
"The B<longjmp>()  function uses the information saved in I<env> to transfer "
"control back to the point where B<setjmp>()  was called and to restore "
"(\"rewind\") the stack to its state at the time of the B<setjmp>()  call.  "
"In addition, and depending on the implementation (see NOTES), the values of "
"some other registers and the process signal mask may be restored to their "
"state at the time of the B<setjmp>()  call."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:99
msgid ""
"Following a successful B<longjmp>(), execution continues as if B<setjmp>()  "
"had returned for a second time.  This \"fake\" return can be distinguished "
"from a true B<setjmp>()  call because the \"fake\" return returns the value "
"provided in I<val>.  If the programmer mistakenly passes the value 0 in "
"I<val>, the \"fake\" return will instead return 1."
msgstr ""

#. type: SS
#: build/C/man3/setjmp.3:99
#, no-wrap
msgid "sigsetjmp() and siglongjmp()"
msgstr "sigsetjmp() と siglongjmp()"

#. type: Plain text
#: build/C/man3/setjmp.3:105
msgid ""
"B<sigsetjmp>()  and B<siglongjmp>()  also perform nonlocal gotos, but "
"provide predictable handling of the process signal mask."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:116
#, fuzzy
#| msgid ""
#| "B<sigsetjmp>()  is similar to B<setjmp>().  If, and only if, I<savesigs> "
#| "is nonzero, the process's current signal mask is saved in I<env> and will "
#| "be restored if a B<siglongjmp>(3)  is later performed with this I<env>."
msgid ""
"If, and only if, the I<savesigs> argument provided to B<sigsetjmp>()  is "
"nonzero, the process's current signal mask is saved in I<env> and will be "
"restored if a B<siglongjmp>()  is later performed with this I<env>."
msgstr ""
"B<sigsetjmp>()  も B<setjmp>()  と同様である。 I<savesigs> が 0 以外の場合、 "
"このプロセスの現在のシグナルマスクも I<env> に保存され、 このシグナルは後で "
"B<siglongjmp>(3)  がこの I<env> で実行された際に復元される。"

#. type: Plain text
#: build/C/man3/setjmp.3:128
#, fuzzy
#| msgid ""
#| "B<setjmp>()  and B<sigsetjmp>()  return 0 if returning directly, and "
#| "nonzero when returning from B<longjmp>(3)  or B<siglongjmp>(3)  using the "
#| "saved context."
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  return 0 when called directly; on the \"fake"
"\" return that occurs after B<longjmp>()  or B<siglongjmp>(), the nonzero "
"value specified in I<val> is returned."
msgstr ""
"直接返ってくるときは、 B<setjmp>()  と B<sigsetjmp>()  は 0 を返し、保存した"
"コンテキストを使って B<longjmp>(3)  や B<siglongjmp>(3)  から返ってくるとき"
"は 0 以外を返す。"

#. type: Plain text
#: build/C/man3/setjmp.3:134
msgid "The B<longjmp>()  or B<siglongjmp>()  functions do not return."
msgstr "関数 B<longjmp>() と B<siglongjmp>() が返ることはない。"

#. type: tbl table
#: build/C/man3/setjmp.3:145
#, no-wrap
msgid ""
"B<setjmp>(),\n"
"B<sigsetjmp>()"
msgstr ""
"B<setjmp>(),\n"
"B<sigsetjmp>()"

#. type: tbl table
#: build/C/man3/setjmp.3:149
#, no-wrap
msgid ""
"B<longjmp>(),\n"
"B<siglongjmp>()"
msgstr ""
"B<longjmp>(),\n"
"B<siglongjmp>()"

#. type: Plain text
#: build/C/man3/setjmp.3:155
msgid "B<setjmp>(), B<longjmp>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<setjmp>(), B<longjmp>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: build/C/man3/setjmp.3:159
msgid "B<sigsetjmp>(), B<siglongjmp>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<sigsetjmp>(), B<siglongjmp>(): POSIX.1-2001, POSIX.1-2008."

#.  so that _FAVOR_BSD is triggered
#.  .BR _XOPEN_SOURCE_EXTENDED ,
#. type: Plain text
#: build/C/man3/setjmp.3:199
#, fuzzy
#| msgid ""
#| "POSIX does not specify whether B<setjmp>()  will save the signal mask (to "
#| "be later restored during B<longjmp>(3)).  In System V it will not.  In "
#| "4.3BSD it will, and there is a function B<_setjmp> that will not.  On "
#| "Linux with glibc versions before 2.19, B<setjmp>()  follows the System V "
#| "behavior by default, but the BSD behavior is provided if the "
#| "B<_BSD_SOURCE> feature test macro is defined and none of "
#| "B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
#| "B<_XOPEN_SOURCE_EXTENDED>, B<_GNU_SOURCE>, or B<_SVID_SOURCE> is "
#| "defined.  Since glibc 2.19, I<E<lt>setjmp.hE<gt>> exposes only the System "
#| "V version of B<setjmp>().  Programs that need the BSD semantics should "
#| "replace calls to B<setjmp>()  with calls to B<sigsetjmp>()  with a "
#| "nonzero I<savesigs> argument."
msgid ""
"POSIX does not specify whether B<setjmp>()  will save the signal mask (to be "
"later restored during B<longjmp>()).  In System V it will not.  In 4.3BSD it "
"will, and there is a function B<_setjmp>()  that will not.  The behavior "
"under Linux depends on the glibc version and the setting of feature test "
"macros.  On Linux with glibc versions before 2.19, B<setjmp>()  follows the "
"System V behavior by default, but the BSD behavior is provided if the "
"B<_BSD_SOURCE> feature test macro is explicitly defined and none of "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_GNU_SOURCE>, or "
"B<_SVID_SOURCE> is defined.  Since glibc 2.19, I<E<lt>setjmp.hE<gt>> exposes "
"only the System V version of B<setjmp>().  Programs that need the BSD "
"semantics should replace calls to B<setjmp>()  with calls to B<sigsetjmp>()  "
"with a nonzero I<savesigs> argument."
msgstr ""
"POSIX は、 (B<longjmp>() 中で後で復元できるように) B<setjmp>() がシグナルマス"
"クを保存すべきかどうかを規定していない。 System V では保存しない。 4.3BSD で"
"は保存する; 4.3BSD にはシグナルコンテキストを保存しない関数 B<_setjmp> もあ"
"る。 バージョン 2.19 より前の glibc を使う Linux では、 B<setjmp>() はデフォ"
"ルトでは System V の振る舞いに従うが、 B<_BSD_SOURCE> 機能検査マクロが定義さ"
"れ、 B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED>, B<_GNU_SOURCE>, B<_SVID_SOURCE> のいずれも定義され"
"ていない時は BSD の振る舞いとなる。 glibc 2.19 以降では、 I<E<lt>setjmp."
"hE<gt>> は System V 版の B<setjmp>() のみを公開するようになっている。 BSD の"
"動作を必要とするプログラムでは、 B<setjmp>() の呼び出しを、 I<savesigs> 引き"
"数に 0 以外の値を渡す B<sigsetjmp>() に置き換えるべきである。"

#. type: Plain text
#: build/C/man3/setjmp.3:214
msgid ""
"B<setjmp>()  and B<longjmp>()  can be useful for dealing with errors inside "
"deeply nested function calls or to allow a signal handler to pass control to "
"a specific point in the program, rather than returning to the point where "
"the handler interrupted the main program.  In the latter case, if you want "
"to portably save and restore signal masks, use B<sigsetjmp>()  and "
"B<siglongjmp>().  See also the discussion of program readability below."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:223
msgid ""
"The compiler may optimize variables into registers, and B<longjmp>()  may "
"restore the values of other registers in addition to the stack pointer and "
"program counter.  Consequently, the values of automatic variables are "
"unspecified after a call to B<longjmp>()  if they meet all the following "
"criteria:"
msgstr ""

#. type: IP
#: build/C/man3/setjmp.3:223 build/C/man3/setjmp.3:227
#: build/C/man3/setjmp.3:233
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man3/setjmp.3:227
msgid ""
"they are local to the function that made the corresponding B<setjmp>()  call;"
msgstr "その自動変数が、対応する B<setjmp>() 呼び出しを行った関数のローカル変数である。"

#. type: Plain text
#: build/C/man3/setjmp.3:233
msgid ""
"their values are changed between the calls to B<setjmp>()  and B<longjmp>(); "
"and"
msgstr "自動変数の値が B<setjmp>() と B<longjmp>() の間で変更されている。"

#. type: Plain text
#: build/C/man3/setjmp.3:236
msgid "they are not declared as I<volatile>."
msgstr "I<volatile> として宣言されていない。"

#. type: Plain text
#: build/C/man3/setjmp.3:240
msgid "Analogous remarks apply for B<siglongjmp>()."
msgstr "同様の注意が B<siglongjmp>()  にもあてはまる。"

#. type: SS
#: build/C/man3/setjmp.3:240
#, no-wrap
msgid "Nonlocal gotos and program readability"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:260
msgid ""
"While it can be abused, the traditional C \"goto\" statement at least has "
"the benefit that lexical cues (the goto statement and the target label)  "
"allow the programmer to easily perceive the flow of control.  Nonlocal gotos "
"provide no such cues: multiple B<setjmp>()  calls might employ the same "
"I<jmp_buf> variable so that the content of the variable may change over the "
"lifetime of the application.  Consequently, the programmer may be forced to "
"perform detailed reading of the code to determine the dynamic target of a "
"particular B<longjmp>()  call.  (To make the programmer's life easier, each "
"B<setjmp>()  call should employ a unique I<jmp_buf> variable.)"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:266
msgid ""
"Adding further difficulty, the B<setjmp>()  and B<longjmp>()  calls may not "
"even be in the same source code module."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:270
#, fuzzy
#| msgid ""
#| "B<setjmp>()  and B<sigsetjmp>()  make programs hard to understand and "
#| "maintain.  If possible, an alternative should be used."
msgid ""
"In summary, nonlocal gotos can make programs harder to understand and "
"maintain, and an alternative should be used if possible."
msgstr ""
"B<setjmp>()  や B<sigsetjmp>()  を使うと、プログラムは理解しづらく、保守しに"
"くいものになる。 別の方法が可能なら、それを使うべきである。"

#. type: SS
#: build/C/man3/setjmp.3:270
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:277
msgid ""
"If the function which called B<setjmp>()  returns before B<longjmp>()  is "
"called, the behavior is undefined.  Some kind of subtle or unsubtle chaos is "
"sure to result."
msgstr ""

#
#
#.  The following statement appeared in versions up to POSIX.1-2008 TC1,
#.  but is set to be removed in POSIX.1-2008 TC2:
#.      According to POSIX.1, if a
#.      .BR longjmp ()
#.      call is performed from a nested signal handler
#.      (i.e., from a handler that was invoked in response to a signal that was
#.      generated while another signal was already in the process of being
#.      handled), the behavior is undefined.
#. type: Plain text
#: build/C/man3/setjmp.3:295
msgid ""
"If, in a multithreaded program, a B<longjmp>()  call employs an I<env> "
"buffer that was initialized by a call to B<setjmp>()  in a different thread, "
"the behavior is undefined."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=516#c1195
#. type: Plain text
#: build/C/man3/setjmp.3:313
msgid ""
"POSIX.1-2008 Technical Corrigendum 2 adds B<longjmp>()  and B<siglongjmp>()  "
"to the list of async-signal-safe functions.  However, the standard "
"recommends avoiding the use of these functions from signal handlers and goes "
"on to point out that if these functions are called from a signal handler "
"that interrupted a call to a non-async-signal-safe function (or some "
"equivalent, such as the steps equivalent to B<exit>(3)  that occur upon a "
"return from the initial call to I<main>()), the behavior is undefined if the "
"program subsequently makes a call to a non-async-signal-safe function.  The "
"only way of avoiding undefined behavior is to ensure one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:318
msgid ""
"After long jumping from the signal handler, the program does not call any "
"non-async-signal-safe functions and does not return from the initial call to "
"I<main>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:325
msgid ""
"Any signal whose handler performs a long jump must be blocked during "
"I<every> call to a non-async-signal-safe function and no non-async-signal-"
"safe functions are called after returning from the initial call to I<main>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setjmp.3:328
msgid "B<signal>(7), B<signal-safety>(7)"
msgstr "B<signal>(7), B<signal-safety>(7)"

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "XCRYPT"
msgstr "XCRYPT"

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: build/C/man3/xcrypt.3:16
msgid "xencrypt, xdecrypt, passwd2des - RFS password encryption"
msgstr "xencrypt, xdecrypt, passwd2des - RFS パスワード暗号化"

#. type: Plain text
#: build/C/man3/xcrypt.3:18
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>"

#. type: Plain text
#: build/C/man3/xcrypt.3:20
msgid "B<void passwd2des(char >I<*passwd>B<, char *>I<key>B<);>"
msgstr "B<void passwd2des(char >I<*passwd>B<, char *>I<key>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:22
msgid "B<int xencrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr "B<int xencrypt(char *>I<secret>B<, char *>I<passwd>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:24
msgid "B<int xdecrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr "B<int xdecrypt(char *>I<secret>B<, char *>I<passwd>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:28
msgid ""
"B<WARNING>: Do not use these functions in new code. They do not achieve any "
"type of acceptable cryptographic security guarantees."
msgstr ""

#. type: Plain text
#: build/C/man3/xcrypt.3:44
msgid ""
"The function B<passwd2des>()  takes a character string I<passwd> of "
"arbitrary length and fills a character array I<key> of length 8.  The array "
"I<key> is suitable for use as DES key.  It has odd parity set in bit 0 of "
"each byte.  Both other functions described here use this function to turn "
"their argument I<passwd> into a DES key."
msgstr ""
"関数 B<passwd2des>()  は任意の長さの文字列 I<passwd> をとり、長さ 8 の文字配"
"列 I<key> を埋める。 配列 I<key> は DES キーとして使うのに適している。 この配"
"列の各バイトのビット 0 は奇数パリティである。 ここで説明されている残りの 2 つ"
"の関数は、 この関数を使い、引数 I<passwd> を DES キーに変換する。"

#.  (over the alphabet 0123456789abcdefABCDEF),
#.  (over the alphabet 0123456789abcdef)
#. type: Plain text
#: build/C/man3/xcrypt.3:61
msgid ""
"The B<xencrypt>()  function takes the ASCII character string I<secret> given "
"in hex, which must have a length that is a multiple of 16, encrypts it using "
"the DES key derived from I<passwd> by B<passwd2des>(), and outputs the "
"result again in I<secret> as a hex string of the same length."
msgstr ""
"B<xencrypt>()  関数は 16 進数で与えられた ASCII 文字列 I<secret> をとる。 こ"
"の長さは 16 の倍数でなければならない。 そして B<passwd2des>()  によって "
"I<passwd> から導き出された DES キーを使い、 I<secret> を暗号化する。 その結果"
"は 16 進数文字列として I<secret> に再び同じ長さで出力される。"

#. type: Plain text
#: build/C/man3/xcrypt.3:65
msgid "The B<xdecrypt>()  function performs the converse operation."
msgstr "B<xdecrypt>()  関数は逆の操作を行う。"

#. type: Plain text
#: build/C/man3/xcrypt.3:71
msgid ""
"The functions B<xencrypt>()  and B<xdecrypt>()  return 1 on success and 0 on "
"error."
msgstr ""
"関数 B<xencrypt>()  と B<xdecrypt>()  は、成功した場合に 1 を返し、失敗した場"
"合に 0 を返す。"

#. type: Plain text
#: build/C/man3/xcrypt.3:73
msgid "These functions are available in glibc since version 2.1."
msgstr "これらの関数はバージョン 2.1 以降の glibc で提供されている。"

#. type: tbl table
#: build/C/man3/xcrypt.3:85
#, no-wrap
msgid ""
"B<passwd2des>(),\n"
"B<xencrypt>(),\n"
"B<xdecrypt>()"
msgstr ""
"B<passwd2des>(),\n"
"B<xencrypt>(),\n"
"B<xdecrypt>()"

#. type: Plain text
#: build/C/man3/xcrypt.3:90
msgid "The prototypes are missing from the abovementioned include file."
msgstr "上記のインクルードファイルにプロトタイプがない。"

#. type: Plain text
#: build/C/man3/xcrypt.3:92
msgid "B<cbc_crypt>(3)"
msgstr "B<cbc_crypt>(3)"

#~ msgid "Set FPU control word on the i386 architecture to"
#~ msgstr "は、i386アーキテクチャーにおける FPU のコントロールワードを、"

#~ msgid "     - extended precision\n"
#~ msgstr "     - 拡張精度\n"

#~ msgid "     - rounding to nearest\n"
#~ msgstr "     - 最も近い整数へ丸める、中間の場合は偶数を選択する。\n"

#~ msgid "     - exceptions on overflow, zero divide and NaN\n"
#~ msgstr "     - 桁溢れ、0で除算、及び無効値(NaN)ときに例外を発生に設定する。\n"

#~ msgid "longjmp, siglongjmp - nonlocal jump to a saved stack context"
#~ msgstr ""
#~ "longjmp, siglongjmp - 保存されたスタックコンテキスト (stack context)  への"
#~ "非局所的なジャンプ"

#~ msgid ""
#~ "B<longjmp>()  and B<setjmp>(3)  are useful for dealing with errors and "
#~ "interrupts encountered in a low-level subroutine of a program.  "
#~ "B<longjmp>()  restores the environment saved by the last call of "
#~ "B<setjmp>(3)  with the corresponding I<env> argument.  After "
#~ "B<longjmp>()  is completed, program execution continues as if the "
#~ "corresponding call of B<setjmp>(3)  had just returned the value I<val>.  "
#~ "B<longjmp>()  cannot cause 0 to be returned.  If B<longjmp>()  is invoked "
#~ "with a second argument of 0, 1 will be returned instead."
#~ msgstr ""
#~ "B<longjmp>()  と B<setjmp>(3)  は、プログラムの低レベルなサブルーチンにお"
#~ "いて、 エラーや割り込みが発生した時の処理に便利である。 B<longjmp>()  は、"
#~ "I<env> 引数を指定して呼び出された最後の B<setjmp>(3)  によって保存された"
#~ "環境を復元する。 B<longjmp>()  の完了後、プログラムの実行は、まるで対応す"
#~ "る B<setjmp>(3)  の呼び出しが値 I<val> で返って来たかように続行される。 "
#~ "B<longjmp>()  は 0 を返すように指示することはできない。 二番目の引数に "
#~ "0 を指定して B<longjmp>()  が呼ばれた場合は、代わりに 1 が返されることにな"
#~ "る。"

#~ msgid ""
#~ "B<siglongjmp>()  is similar to B<longjmp>()  except for the type of its "
#~ "I<env> argument.  If, and only if, the B<sigsetjmp>(3)  call that set "
#~ "this I<env> used a nonzero I<savesigs> flag, B<siglongjmp>()  also "
#~ "restores the signal mask that was saved by B<sigsetjmp>(3)."
#~ msgstr ""
#~ "B<siglongjmp>()  は、引数 I<env> の型が異なる点以外は、 B<longjmp>()  と"
#~ "同様である。 I<env> を保存した B<sigsetjmp>(3)  が 0 以外の I<savesigs> フ"
#~ "ラグで呼び出されていた場合で、 かつ、その場合にのみ、 B<siglongjmp>(3)  "
#~ "は B<sigsetjmp>(3)  より保存されていたシグナルマスクの復元を行う。"

#~ msgid "These functions never return."
#~ msgstr "これらの関数が返ることはない。"

#~ msgid ""
#~ "C89, C99, and POSIX.1-2001 specify B<longjmp>().  POSIX.1-2001 specifies "
#~ "B<siglongjmp>()."
#~ msgstr ""
#~ "B<longjmp>()  は C89, C99, POSIX.1-2001 で規定されている。 "
#~ "B<siglongjmp>()  は POSIX.1-2001 で規定されている。"

#~ msgid ""
#~ "POSIX does not specify whether B<longjmp>()  will restore the signal "
#~ "context (see B<setjmp>(3)  for some more details).  If you want to "
#~ "portably save and restore signal masks, use B<sigsetjmp>(3)  and "
#~ "B<siglongjmp>()."
#~ msgstr ""
#~ "POSIX では、 B<longjmp>() がシグナルコンテキスト (signal context) を復元\n"
#~ "するかどうか規定されていない (B<setjmp>(3) にも少し詳しい情報がある)。\n"
#~ "移植性のある方法で、シグナルマスクを保存し復元させたい場合には、\n"
#~ "B<sigsetjmp>(3) と B<siglongjmp>() を使うこと。"

#~ msgid ""
#~ "The values of automatic variables are unspecified after a call to "
#~ "B<longjmp>()  if they meet all the following criteria:"
#~ msgstr ""
#~ "以下の条件が全て成立する場合、 B<longjmp>()  の呼び出しが行われた後の自動"
#~ "変数の値は未定義 (unspecified) となる。"

#~ msgid ""
#~ "B<longjmp>()  and B<siglongjmp>()  make programs hard to understand and "
#~ "maintain.  If possible, an alternative should be used."
#~ msgstr ""
#~ "B<longjmp>()  や B<siglongjmp>()  を使うと、プログラムは理解しづらく、保守"
#~ "しにくいものになる。 別の方法が可能なら、それを使うべきである。"

#~ msgid ""
#~ "Code size is about 40% greater and operations run about 45% slower than "
#~ "lists."
#~ msgstr ""
#~ "リストと比べて、コードサイズは 40% 大きくなり、操作は 45% 遅くなる。"

#~ msgid ""
#~ "In the macro definitions, I<TYPE> is the name of a user-defined "
#~ "structure, that must contain a field of type B<LIST_ENTRY>, "
#~ "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#~ "I<HEADNAME> is the name of a user-defined structure that must be declared "
#~ "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#~ "the examples below for further explanation of how these macros are used."
#~ msgstr ""
#~ "マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 "
#~ "B<LIST_ENTRY>, B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと "
#~ "指定された I<NAME> を含まなければならない。 引数 I<HEADNAME> はユーザー"
#~ "定義構造体の名前であり、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, "
#~ "B<CIRCLEQ_HEAD> を用いて宣言されなければならない。 これらのマクロがどのよ"
#~ "うに使われるかについての更なる説明は、 以下の例を参照すること。"

#~ msgid ""
#~ "A list is headed by a structure defined by the B<LIST_HEAD> macro.  This "
#~ "structure contains a single pointer to the first element on the list.  "
#~ "The elements are doubly linked so that an arbitrary element can be "
#~ "removed without traversing the list.  New elements can be added to the "
#~ "list after an existing element or at the head of the list.  A "
#~ "B<LIST_HEAD> structure is declared as follows:"
#~ msgstr ""
#~ "リストの先頭には、 B<LIST_HEAD> マクロで定義される構造体が置かれる。 この"
#~ "構造体はリストの最初の要素へのポインターを 1 つ含む。 要素は 2 重にリンク"
#~ "されており、 任意の要素はリストを辿らずに削除できる。 新しい要素は既存の要"
#~ "素の後またはリストの先頭に追加できる。 B<LIST_HEAD> 構造体は以下のように宣"
#~ "言されている:"

#~ msgid ""
#~ "where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> "
#~ "is the type of the elements to be linked into the list.  A pointer to the "
#~ "head of the list can later be declared as:"
#~ msgstr ""
#~ "ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> はリンク内でリ"
#~ "ンクされる要素の型である。 リストの先頭へのポインターは、その後で次のよう"
#~ "に宣言される:"

#~ msgid ""
#~ "A tail queue is headed by a structure defined by the B<TAILQ_HEAD> "
#~ "macro.  This structure contains a pair of pointers, one to the first "
#~ "element in the tail queue and the other to the last element in the tail "
#~ "queue.  The elements are doubly linked so that an arbitrary element can "
#~ "be removed without traversing the tail queue.  New elements can be added "
#~ "to the tail queue after an existing element, at the head of the tail "
#~ "queue, or at the end of the tail queue.  A B<TAILQ_HEAD> structure is "
#~ "declared as follows:"
#~ msgstr ""
#~ "テールキューの先頭には B<TAILQ_HEAD> マクロで定義される構造体が置かれる。 "
#~ "この構造体は 1 組のポインターを含んでいる。 1 つはテールキューの最初の要素"
#~ "へのポインターであり、 もう 1 つはテールキューの最後の要素へのポインターで"
#~ "ある。 要素は 2 重にリンクされており、 任意の要素はテールキューを辿らずに"
#~ "削除できる。 新しい要素は既存の要素の後またはテールキューの先頭または末尾"
#~ "に追加できる。 B<TAILQ_HEAD> 構造体は以下のように定義されている:"

#~ msgid ""
#~ "A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD> "
#~ "macro.  This structure contains a pair of pointers, one to the first "
#~ "element in the circular queue and the other to the last element in the "
#~ "circular queue.  The elements are doubly linked so that an arbitrary "
#~ "element can be removed without traversing the queue.  New elements can be "
#~ "added to the queue after an existing element, before an existing element, "
#~ "at the head of the queue, or at the end of the queue.  A B<CIRCLEQ_HEAD> "
#~ "structure is declared as follows:"
#~ msgstr ""
#~ "循環キューの先頭には B<CIRCLEQ_HEAD> マクロで定義される構造体が置かれる。 "
#~ "この構造体は 1 組のポインターを含んでいる。 1 つは循環キューの最初の要素へ"
#~ "のポインターであり、 もう 1 つは循環キューの最後の要素へのポインターであ"
#~ "る。 要素は 2 重にリンクされており、 任意の要素はキューを辿らずに削除でき"
#~ "る。 新しい要素は、既存の要素の後または前、またはキューの先頭または末尾に"
#~ "追加できる。 A B<CIRCLEQ_HEAD> 構造体は以下のように定義されている:"

#~ msgid ""
#~ "where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> "
#~ "is the type of the elements to be linked into the circular queue.  A "
#~ "pointer to the head of the circular queue can later be declared as:"
#~ msgstr ""
#~ "ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> は循環キュー内"
#~ "でリンクされる要素の型である。 循環キューの先頭へのポインターは、その後で"
#~ "次のように宣言される:"

#~ msgid ""
#~ "B<setjmp>()  and B<longjmp>(3)  are useful for dealing with errors and "
#~ "interrupts encountered in a low-level subroutine of a program.  "
#~ "B<setjmp>()  saves the stack context/environment in I<env> for later use "
#~ "by B<longjmp>(3).  The stack context will be invalidated if the function "
#~ "which called B<setjmp>()  returns."
#~ msgstr ""
#~ "B<setjmp>()  と B<longjmp>(3)  は、プログラムの低レベルなサブルーチン にお"
#~ "いて、エラーや割り込みが発生した時の処理に便利である。 B<setjmp>()  は、 "
#~ "B<longjmp>(3)  によって使われる I<env> に スタックコンテキスト/スタック環"
#~ "境を保存する。 B<setjmp>()  を呼び出した 関数が返るときに、そのスタックコ"
#~ "ンテキストは無効になる。"

#~ msgid ""
#~ "If you want to portably save and restore signal masks, use "
#~ "B<sigsetjmp>()  and B<siglongjmp>(3)."
#~ msgstr ""
#~ "移植性のある形でシグナルマスクを保存および復元したいのなら、 "
#~ "B<sigsetjmp>()  と B<siglongjmp>(3)  を使うこと。"
