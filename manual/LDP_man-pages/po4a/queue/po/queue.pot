# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/circleq.3:32
#, no-wrap
msgid "CIRCLEQ"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/slist.3:32 build/C/man3/stailq.3:32
#, no-wrap
msgid "2020-10-21"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/list.3:32 build/C/man3/slist.3:32 build/C/man3/stailq.3:32 build/C/man3/tailq.3:32 build/C/man7/queue.7:32
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/insque.3:36 build/C/man3/list.3:32 build/C/man3/slist.3:32 build/C/man3/stailq.3:32 build/C/man3/tailq.3:32 build/C/man7/queue.7:32
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:33 build/C/man3/insque.3:37 build/C/man3/list.3:33 build/C/man3/slist.3:33 build/C/man3/stailq.3:33 build/C/man3/tailq.3:33 build/C/man7/queue.7:33
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:53
msgid ""
"CIRCLEQ_EMPTY, CIRCLEQ_ENTRY, CIRCLEQ_FIRST, CIRCLEQ_FOREACH, "
"CIRCLEQ_FOREACH_REVERSE, CIRCLEQ_HEAD, CIRCLEQ_HEAD_INITIALIZER, "
"CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_LAST, CIRCLEQ_LOOP_NEXT, "
"CIRCLEQ_LOOP_PREV, CIRCLEQ_NEXT, CIRCLEQ_PREV, CIRCLEQ_REMOVE - "
"implementation of a doubly linked circular queue"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:53 build/C/man3/insque.3:39 build/C/man3/list.3:52 build/C/man3/slist.3:52 build/C/man3/stailq.3:55 build/C/man3/tailq.3:59
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:56 build/C/man3/list.3:55 build/C/man3/slist.3:55 build/C/man3/stailq.3:58 build/C/man3/tailq.3:62
#, no-wrap
msgid "B<#include E<lt>sys/queue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:58
#, no-wrap
msgid "B<int CIRCLEQ_EMPTY(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:60
#, no-wrap
msgid "B<CIRCLEQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:62
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_FIRST(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:65
#, no-wrap
msgid ""
"B<CIRCLEQ_FOREACH(struct TYPE *>I<var>B<, CIRCLEQ_HEAD *>I<head>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:68
#, no-wrap
msgid ""
"B<CIRCLEQ_FOREACH_REVERSE(struct TYPE *>I<var>B<, CIRCLEQ_HEAD "
"*>I<head>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:70
#, no-wrap
msgid "B<CIRCLEQ_HEAD(HEADNAME, TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:72
#, no-wrap
msgid "B<CIRCLEQ_HEAD CIRCLEQ_HEAD_INITIALIZER(CIRCLEQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:74
#, no-wrap
msgid "B<void CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:77
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:80
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:83
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:86
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:88
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_LAST(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:91
#, no-wrap
msgid ""
"B<void CIRCLEQ_LOOP_NEXT(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:94
#, no-wrap
msgid ""
"B<void CIRCLEQ_LOOP_PREV(CIRCLEQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:96
#, no-wrap
msgid ""
"B<struct TYPE *CIRCLEQ_NEXT(struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:98
#, no-wrap
msgid ""
"B<struct TYPE *CIRCLEQ_PREV(struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:101
#, no-wrap
msgid ""
"B<void CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:102 build/C/man3/insque.3:63 build/C/man3/list.3:93 build/C/man3/slist.3:92 build/C/man3/stailq.3:105 build/C/man3/tailq.3:117 build/C/man7/queue.7:35
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:104
msgid "These macros define and operate on doubly linked circular queues."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:117
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<CIRCLEQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<CIRCLEQ_HEAD>()."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:132
msgid ""
"A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD>()  "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the circular queue and the other to the last element in the circular "
"queue.  The elements are doubly linked so that an arbitrary element can be "
"removed without traversing the circular queue.  New elements can be added to "
"the circular queue after an existing element, before an existing element, at "
"the head of the circular queue, or at the end of the circular queue.  A "
"I<CIRCLEQ_HEAD> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:136
#, no-wrap
msgid "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:145
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the circular queue.  A pointer "
"to the head of the circular queue can later be declared as:"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:149 build/C/man3/list.3:138 build/C/man3/slist.3:137 build/C/man3/stailq.3:152 build/C/man3/tailq.3:164
#, no-wrap
msgid "struct HEADNAME *headp;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:157 build/C/man3/list.3:146 build/C/man3/slist.3:145 build/C/man3/stailq.3:160 build/C/man3/tailq.3:172
msgid "(The names I<head> and I<headp> are user selectable.)"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:162
msgid ""
"The macro B<CIRCLEQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"circular queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:166
msgid ""
"The macro B<CIRCLEQ_EMPTY>()  evaluates to true if there are no items on the "
"circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:171
msgid ""
"The macro B<CIRCLEQ_ENTRY>()  declares a structure that connects the "
"elements in the circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:175
msgid "The macro B<CIRCLEQ_FIRST>()  returns the first item on the circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:186
msgid ""
"The macro B<CIRCLEQ_FOREACH>()  traverses the circular queue referenced by "
"I<head> in the forward direction, assigning each element in turn to I<var>.  "
"I<var> is set to I<&head> if the loop completes normally, or if there were "
"no elements."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:193
msgid ""
"The macro B<CIRCLEQ_FOREACH_REVERSE>()  traverses the circular queue "
"referenced by I<head> in the reverse direction, assigning each element in "
"turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:198
msgid ""
"The macro B<CIRCLEQ_INIT>()  initializes the circular queue referenced by "
"I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:204
msgid ""
"The macro B<CIRCLEQ_INSERT_HEAD>()  inserts the new element I<elm> at the "
"head of the circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:210
msgid ""
"The macro B<CIRCLEQ_INSERT_TAIL>()  inserts the new element I<elm> at the "
"end of the circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:217
msgid ""
"The macro B<CIRCLEQ_INSERT_AFTER>()  inserts the new element I<elm> after "
"the element I<listelm>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:224
msgid ""
"The macro B<CIRCLEQ_INSERT_BEFORE>()  inserts the new element I<elm> before "
"the element I<listelm>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:228
msgid "The macro B<CIRCLEQ_LAST>()  returns the last item on the circular queue."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:234
msgid ""
"The macro B<CIRCLEQ_NEXT>()  returns the next item on the circular queue, or "
"I<&head> if this item is the last one."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:240
msgid ""
"The macro B<CIRCLEQ_PREV>()  returns the previous item on the circular "
"queue, or I<&head> if this item is the first one."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:247
msgid ""
"The macro B<CIRCLEQ_LOOP_NEXT>()  returns the next item on the circular "
"queue.  If I<elm> is the last element on the circular queue, the first "
"element is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:254
msgid ""
"The macro B<CIRCLEQ_LOOP_PREV>()  returns the previous item on the circular "
"queue.  If I<elm> is the first element on the circular queue, the last "
"element is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:260
msgid ""
"The macro B<CIRCLEQ_REMOVE>()  removes the element I<elm> from the circular "
"queue."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:260 build/C/man3/list.3:261 build/C/man3/slist.3:266 build/C/man3/stailq.3:299 build/C/man3/tailq.3:344
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:264
msgid ""
"B<CIRCLEQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:273
msgid ""
"B<CIRCLEQ_FIRST>(), B<CIRCLEQ_LAST>(), B<CIRCLEQ_NEXT>(), and "
"B<CIRCLEQ_PREV>()  return a pointer to the first, last, next or previous "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:277
msgid ""
"B<CIRCLEQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned "
"to the queue I<head>."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:277 build/C/man3/insque.3:115 build/C/man3/list.3:276 build/C/man3/slist.3:281 build/C/man3/stailq.3:314 build/C/man3/tailq.3:361 build/C/man7/queue.7:136
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:281
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (CIRCLEQ "
"macros first appeared in 4.4BSD)."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:281 build/C/man3/insque.3:144 build/C/man3/list.3:280 build/C/man3/slist.3:285 build/C/man3/stailq.3:318 build/C/man3/tailq.3:365
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:299
msgid ""
"The macros B<CIRCLEQ_FOREACH>()  and B<CIRCLEQ_FOREACH_REVERSE>()  don't "
"allow I<var> to be removed or freed within the loop, as it would interfere "
"with the traversal.  The macros B<CIRCLEQ_FOREACH_SAFE>()  and "
"B<CIRCLEQ_FOREACH_REVERSE_SAFE>(), which are present on the BSDs but are not "
"present in glibc, fix this limitation by allowing I<var> to safely be "
"removed from the list and freed from within the loop without interfering "
"with the traversal."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:299 build/C/man3/insque.3:151 build/C/man3/list.3:294 build/C/man3/slist.3:299 build/C/man3/stailq.3:332 build/C/man3/tailq.3:383
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:305 build/C/man3/list.3:300 build/C/man3/slist.3:305 build/C/man3/stailq.3:338 build/C/man3/tailq.3:389
#, no-wrap
msgid ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/queue.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:310
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    CIRCLEQ_ENTRY(entry) entries;           /* Queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:312
#, no-wrap
msgid "CIRCLEQ_HEAD(circlehead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:319
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct circlehead head;                 /* Queue head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:321
#, no-wrap
msgid "    CIRCLEQ_INIT(&head);                    /* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:324
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:327
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"    CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:330
#, no-wrap
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:333
#, no-wrap
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    CIRCLEQ_INSERT_BEFORE(&head, n2, n3, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:351
#, no-wrap
msgid ""
"    CIRCLEQ_REMOVE(&head, n2, entries);     /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    i = 0;\n"
"    CIRCLEQ_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
"                                            /* Reverse traversal. */\n"
"    CIRCLEQ_FOREACH_REVERSE(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* Queue deletion. */\n"
"    n1 = CIRCLEQ_FIRST(&head);\n"
"    while (n1 != (void *)&head) {\n"
"        n2 = CIRCLEQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    CIRCLEQ_INIT(&head);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:354 build/C/man3/insque.3:258 build/C/man3/list.3:346 build/C/man3/slist.3:354 build/C/man3/stailq.3:392 build/C/man3/tailq.3:438
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:355 build/C/man3/insque.3:259 build/C/man3/list.3:347 build/C/man3/slist.3:355 build/C/man3/stailq.3:393 build/C/man3/tailq.3:439 build/C/man7/queue.7:141
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:358 build/C/man3/list.3:350 build/C/man3/slist.3:358 build/C/man3/stailq.3:396 build/C/man3/tailq.3:442
msgid "B<insque>(3), B<queue>(7)"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:358 build/C/man3/insque.3:261 build/C/man3/list.3:350 build/C/man3/slist.3:358 build/C/man3/stailq.3:396 build/C/man3/tailq.3:442 build/C/man7/queue.7:149
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:366 build/C/man3/insque.3:269 build/C/man3/list.3:358 build/C/man3/slist.3:366 build/C/man3/stailq.3:404 build/C/man3/tailq.3:450 build/C/man7/queue.7:157
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "INSQUE"
msgstr ""

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:39
msgid "insque, remque - insert/remove an item from a queue"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:42
#, no-wrap
msgid "B<#include E<lt>search.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:44
#, no-wrap
msgid "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:46
#, no-wrap
msgid "B<void remque(void *>I<elem>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:51
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:56
msgid "B<insque>(), B<remque>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/insque.3:61
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:75
msgid ""
"The B<insque>()  and B<remque>()  functions manipulate doubly linked lists.  "
"Each element in the list is a structure of which the first two elements are "
"a forward and a backward pointer.  The linked list may be linear (i.e., NULL "
"forward pointer at the end of the list and NULL backward pointer at the "
"start of the list)  or circular."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:80
msgid ""
"The B<insque>()  function inserts the element pointed to by I<elem> "
"immediately after the element pointed to by I<prev>."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:87
msgid ""
"If the list is linear, then the call I<insque(elem, NULL)> can be used to "
"insert the initial list element, and the call sets the forward and backward "
"pointers of I<elem> to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:96
msgid ""
"If the list is circular, the caller should ensure that the forward and "
"backward pointers of the first element are initialized to point to that "
"element, and the I<prev> argument of the B<insque>()  call should also point "
"to the element."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:101
msgid ""
"The B<remque>()  function removes the element pointed to by I<elem> from the "
"doubly linked list."
msgstr ""

#. type: SH
#: build/C/man3/insque.3:101
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:104
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid ""
"B<insque>(),\n"
"B<remque>()"
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:117
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: SH
#: build/C/man3/insque.3:117
#, no-wrap
msgid "NOTES"
msgstr ""

#.  e.g., SunOS, Linux libc4 and libc5
#. type: Plain text
#: build/C/man3/insque.3:122
msgid ""
"On ancient systems, the arguments of these functions were of type I<struct "
"qelem *>, defined as:"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:130
#, no-wrap
msgid ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:137
msgid ""
"This is still what you will get if B<_GNU_SOURCE> is defined before "
"including I<E<lt>search.hE<gt>>."
msgstr ""

#.  Linux libc4 and libc 5 placed them
#.  in \fI<stdlib.h>\fP.
#. type: Plain text
#: build/C/man3/insque.3:144
msgid ""
"The location of the prototypes for these functions differs among several "
"versions of UNIX.  The above is the POSIX version.  Some systems place them "
"in I<E<lt>string.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:151
msgid ""
"In glibc 2.4 and earlier, it was not possible to specify I<prev> as NULL.  "
"Consequently, to build a linear list, the caller had to build a list using "
"an initial call that contained the first two elements of the list, with the "
"forward and backward pointers in each element suitably initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:155
msgid ""
"The program below demonstrates the use of B<insque>().  Here is an example "
"run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:164
#, no-wrap
msgid ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"
msgstr ""

#. type: SS
#: build/C/man3/insque.3:166
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:173
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:179
#, no-wrap
msgid ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:188
#, no-wrap
msgid ""
"static struct element *\n"
"new_element(void)\n"
"{\n"
"    struct element *e = malloc(sizeof(*e));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:191
#, no-wrap
msgid ""
"    return e;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:197
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:200
#, no-wrap
msgid ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:213
#, no-wrap
msgid ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:218
#, no-wrap
msgid ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:220
#, no-wrap
msgid "    /* Create first element and place it in the linked list */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:223
#, no-wrap
msgid ""
"    elem = new_element();\n"
"    first = elem;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:225
#, no-wrap
msgid "    elem-E<gt>name = argv[optind];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:233
#, no-wrap
msgid ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:235
#, no-wrap
msgid "    /* Add remaining command-line arguments as list elements */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:238
#, no-wrap
msgid ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:243
#, no-wrap
msgid ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:245
#, no-wrap
msgid "    /* Traverse the list from the start, printing element names */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:252
#, no-wrap
msgid ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:255
#, no-wrap
msgid ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:261
msgid "B<queue>(7)"
msgstr ""

#. type: TH
#: build/C/man3/list.3:32
#, no-wrap
msgid "LIST"
msgstr ""

#. type: TH
#: build/C/man3/list.3:32 build/C/man3/tailq.3:32
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. LIST_FOREACH_FROM,
#. LIST_FOREACH_SAFE,
#. LIST_FOREACH_FROM_SAFE,
#. LIST_PREV,
#. LIST_SWAP
#. type: Plain text
#: build/C/man3/list.3:52
msgid ""
"LIST_EMPTY, LIST_ENTRY, LIST_FIRST, LIST_FOREACH, LIST_HEAD, "
"LIST_HEAD_INITIALIZER, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_BEFORE, "
"LIST_INSERT_HEAD, LIST_NEXT, LIST_REMOVE - implementation of a doubly linked "
"list"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:57
#, no-wrap
msgid "B<int LIST_EMPTY(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:59
#, no-wrap
msgid "B<LIST_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:61
#, no-wrap
msgid "B<struct TYPE *LIST_FIRST(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. .PP
#. .BI "LIST_FOREACH_FROM(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ");"
#. .PP
#. .BI "LIST_FOREACH_FROM_SAFE(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. .PP
#. .BI "LIST_FOREACH_SAFE(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/list.3:69
#, no-wrap
msgid ""
"B<LIST_FOREACH(struct TYPE *>I<var>B<, LIST_HEAD *>I<head>B<, LIST_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:71
#, no-wrap
msgid "B<LIST_HEAD(HEADNAME, TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:73
#, no-wrap
msgid "B<LIST_HEAD LIST_HEAD_INITIALIZER(LIST_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:75
#, no-wrap
msgid "B<void LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:78
#, no-wrap
msgid ""
"B<void LIST_INSERT_AFTER(struct TYPE *>I<listelm>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:81
#, no-wrap
msgid ""
"B<void LIST_INSERT_BEFORE(struct TYPE *>I<listelm>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:84
#, no-wrap
msgid ""
"B<void LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "struct TYPE *LIST_PREV(struct TYPE *" elm ", LIST_HEAD *" head ", struct TYPE, LIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/list.3:88
#, no-wrap
msgid "B<struct TYPE *LIST_NEXT(struct TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void LIST_SWAP(LIST_HEAD *" head1 ", LIST_HEAD *" head2 ", struct TYPE, LIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/list.3:92
#, no-wrap
msgid "B<void LIST_REMOVE(struct TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:95 build/C/man3/slist.3:94
msgid "These macros define and operate on doubly linked lists."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:108
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<LIST_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<LIST_HEAD>()."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:121
msgid ""
"A list is headed by a structure defined by the B<LIST_HEAD>()  macro.  This "
"structure contains a single pointer to the first element on the list.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the list.  New elements can be added to the list after an "
"existing element, before an existing element, or at the head of the list.  A "
"I<LIST_HEAD> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:125
#, no-wrap
msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:134 build/C/man3/slist.3:133
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the list.  A pointer to the "
"head of the list can later be declared as:"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:151
msgid ""
"The macro B<LIST_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:155
msgid ""
"The macro B<LIST_EMPTY>()  evaluates to true if there are no elements in the "
"list."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:160
msgid ""
"The macro B<LIST_ENTRY>()  declares a structure that connects the elements "
"in the list."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:165
msgid ""
"The macro B<LIST_FIRST>()  returns the first element in the list or NULL if "
"the list is empty."
msgstr ""

#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_FROM ()
#.  behaves identically to
#.  .BR LIST_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found LIST element and begins the loop at
#.  .I var
#.  instead of the first element in the LIST referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_SAFE ()
#.  traverses the list referenced by
#.  .I head
#.  in the forward direction, assigning each element in turn to
#.  .IR var .
#.  However, unlike
#.  .BR LIST_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR LIST_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found LIST element and begins the loop at
#.  .I var
#.  instead of the first element in the LIST referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/list.3:211
msgid ""
"The macro B<LIST_FOREACH>()  traverses the list referenced by I<head> in the "
"forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:216
msgid "The macro B<LIST_INIT>()  initializes the list referenced by I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:222
msgid ""
"The macro B<LIST_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the list."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:229
msgid ""
"The macro B<LIST_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:236
msgid ""
"The macro B<LIST_INSERT_BEFORE>()  inserts the new element I<elm> before the "
"element I<listelm>."
msgstr ""

#.  .PP
#.  The macro
#.  .BR LIST_PREV ()
#.  returns the previous element in the list, or NULL if this is the first.
#.  List
#.  .I head
#.  must contain element
#.  .IR elm .
#. type: Plain text
#: build/C/man3/list.3:248
msgid ""
"The macro B<LIST_NEXT>()  returns the next element in the list, or NULL if "
"this is the last."
msgstr ""

#.  .PP
#.  The macro
#.  .BR LIST_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/list.3:261
msgid "The macro B<LIST_REMOVE>()  removes the element I<elm> from the list."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:265
msgid ""
"B<LIST_EMPTY>()  returns nonzero if the list is empty, and zero if the list "
"contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:272
msgid ""
"B<LIST_FIRST>(), and B<LIST_NEXT>()  return a pointer to the first or next "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:276
msgid ""
"B<LIST_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:280
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (LIST "
"macros first appeared in 4.4BSD)."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:294
msgid ""
"The macro B<LIST_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<LIST_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:305
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    LIST_ENTRY(entry) entries;              /* List. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:307
#, no-wrap
msgid "LIST_HEAD(listhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:314
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct listhead head;                   /* List head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:316
#, no-wrap
msgid "    LIST_INIT(&head);                       /* Initialize the list. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:319
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    LIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:322
#, no-wrap
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    LIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:325
#, no-wrap
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    LIST_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:329
#, no-wrap
msgid ""
"    i = 0;                                  /* Forward traversal. */\n"
"    LIST_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:343
#, no-wrap
msgid ""
"    LIST_REMOVE(n2, entries);               /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    LIST_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* List Deletion. */\n"
"    n1 = LIST_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = LIST_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    LIST_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/slist.3:32
#, no-wrap
msgid "SLIST"
msgstr ""

#. SLIST_FOREACH_FROM,
#. SLIST_FOREACH_FROM_SAFE,
#. SLIST_FOREACH_SAFE,
#. SLIST_REMOVE_AFTER,
#. SLIST_SWAP
#. type: Plain text
#: build/C/man3/slist.3:52
msgid ""
"SLIST_EMPTY, SLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH, SLIST_HEAD, "
"SLIST_HEAD_INITIALIZER, SLIST_INIT, SLIST_INSERT_AFTER, SLIST_INSERT_HEAD, "
"SLIST_NEXT, SLIST_REMOVE, SLIST_REMOVE_HEAD - implementation of a singly "
"linked list"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:57
#, no-wrap
msgid "B<int SLIST_EMPTY(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:59
#, no-wrap
msgid "B<SLIST_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:61
#, no-wrap
msgid "B<struct TYPE *SLIST_FIRST(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. .PP
#. .BI "SLIST_FOREACH_FROM(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ");"
#. .PP
#. .BI "SLIST_FOREACH_FROM_SAFE(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. .PP
#. .BI "SLIST_FOREACH_SAFE(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/slist.3:69
#, no-wrap
msgid ""
"B<SLIST_FOREACH(struct TYPE *>I<var>B<, SLIST_HEAD *>I<head>B<, SLIST_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:71
#, no-wrap
msgid "B<SLIST_HEAD(HEADNAME, TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:73
#, no-wrap
msgid "B<SLIST_HEAD SLIST_HEAD_INITIALIZER(SLIST_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:75
#, no-wrap
msgid "B<void SLIST_INIT(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:78
#, no-wrap
msgid ""
"B<void SLIST_INSERT_AFTER(struct TYPE *>I<listelm>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:81
#, no-wrap
msgid ""
"B<void SLIST_INSERT_HEAD(SLIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:83
#, no-wrap
msgid ""
"B<struct TYPE *SLIST_NEXT(struct TYPE *>I<elm>B<, SLIST_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void SLIST_REMOVE_AFTER(struct TYPE *" elm ", SLIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/slist.3:87
#, no-wrap
msgid ""
"B<void SLIST_REMOVE(SLIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, "
"SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void SLIST_SWAP(SLIST_HEAD *" head1 ", SLIST_HEAD *" head2 ", SLIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/slist.3:91
#, no-wrap
msgid "B<void SLIST_REMOVE_HEAD(SLIST_HEAD *>I<head>B<, SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:107
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<SLIST_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<SLIST_HEAD>()."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:120
msgid ""
"A singly linked list is headed by a structure defined by the B<SLIST_HEAD>()  "
"macro.  This structure contains a single pointer to the first element on the "
"list.  The elements are singly linked for minimum space and pointer "
"manipulation overhead at the expense of O(n) removal for arbitrary "
"elements.  New elements can be added to the list after an existing element "
"or at the head of the list.  An I<SLIST_HEAD> structure is declared as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:124
#, no-wrap
msgid "SLIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:150
msgid ""
"The macro B<SLIST_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:154
msgid ""
"The macro B<SLIST_EMPTY>()  evaluates to true if there are no elements in "
"the list."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:159
msgid ""
"The macro B<SLIST_ENTRY>()  declares a structure that connects the elements "
"in the list."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:163
msgid ""
"The macro B<SLIST_FIRST>()  returns the first element in the list or NULL if "
"the list is empty."
msgstr ""

#.  .PP
#.  The macro
#.  .BR SLIST_FOREACH_FROM ()
#.  behaves identically to
#.  .BR SLIST_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found SLIST element and begins the loop at
#.  .I var
#.  instead of the first element in the SLIST referenced by
#.  .IR head .
#.  .Pp
#.  The macro
#.  .BR SLIST_FOREACH_SAFE ()
#.  traverses the list referenced by
#.  .I head
#.  in the forward direction, assigning each element in
#.  turn to
#.  .IR var .
#.  However, unlike
#.  .BR SLIST_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR SLIST_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR SLIST_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found SLIST element and begins the loop at
#.  .I var
#.  instead of the first element in the SLIST referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/slist.3:211
msgid ""
"The macro B<SLIST_FOREACH>()  traverses the list referenced by I<head> in "
"the forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:216
msgid "The macro B<SLIST_INIT>()  initializes the list referenced by I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:222
msgid ""
"The macro B<SLIST_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the list."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:229
msgid ""
"The macro B<SLIST_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""

#.  .PP
#.  The macro
#.  .BR SLIST_REMOVE_AFTER ()
#.  removes the element after
#.  .I elm
#.  from the list.
#.  Unlike
#.  .IR SLIST_REMOVE ,
#.  this macro does not traverse the entire list.
#. type: Plain text
#: build/C/man3/slist.3:242
msgid "The macro B<SLIST_NEXT>()  returns the next element in the list."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:253
msgid ""
"The macro B<SLIST_REMOVE_HEAD>()  removes the element I<elm> from the head "
"of the list.  For optimum efficiency, elements being removed from the head "
"of the list should explicitly use this macro instead of the generic "
"I<SLIST_REMOVE> macro."
msgstr ""

#.  .PP
#.  The macro
#.  .BR SLIST_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/slist.3:266
msgid "The macro B<SLIST_REMOVE>()  removes the element I<elm> from the list."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:270
msgid ""
"B<SLIST_EMPTY>()  returns nonzero if the list is empty, and zero if the list "
"contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:277
msgid ""
"B<SLIST_FIRST>(), and B<SLIST_NEXT>()  return a pointer to the first or next "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:281
msgid ""
"B<SLIST_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:285
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (SLIST "
"macros first appeared in 4.4BSD)."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:299
msgid ""
"The macro B<SLIST_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<SLIST_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:310
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    SLIST_ENTRY(entry) entries;             /* Singly linked List. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:312
#, no-wrap
msgid "SLIST_HEAD(slisthead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:319
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct slisthead head;                  /* Singly linked List\n"
"                                               head. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:321
#, no-wrap
msgid "    SLIST_INIT(&head);                      /* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:324
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    SLIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:327
#, no-wrap
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    SLIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:330
#, no-wrap
msgid ""
"    SLIST_REMOVE(&head, n2, entry, entries);/* Deletion. */\n"
"    free(n2);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:334
#, no-wrap
msgid ""
"    n3 = SLIST_FIRST(&head);\n"
"    SLIST_REMOVE_HEAD(&head, entries);      /* Deletion from the head. */\n"
"    free(n3);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:340
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> 5; i++) {\n"
"        n1 = malloc(sizeof(struct entry));\n"
"        SLIST_INSERT_HEAD(&head, n1, entries);\n"
"        n1-E<gt>data = i;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:344
#, no-wrap
msgid ""
"                                            /* Forward traversal. */\n"
"    SLIST_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:351
#, no-wrap
msgid ""
"    while (!SLIST_EMPTY(&head)) {           /* List Deletion. */\n"
"        n1 = SLIST_FIRST(&head);\n"
"        SLIST_REMOVE_HEAD(&head, entries);\n"
"        free(n1);\n"
"    }\n"
"    SLIST_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/stailq.3:32
#, no-wrap
msgid "STAILQ"
msgstr ""

#. STAILQ_FOREACH_FROM,
#. STAILQ_FOREACH_FROM_SAFE,
#. STAILQ_FOREACH_SAFE,
#. STAILQ_LAST,
#. STAILQ_REMOVE_AFTER,
#. STAILQ_SWAP
#. type: Plain text
#: build/C/man3/stailq.3:55
msgid ""
"STAILQ_CONCAT, STAILQ_EMPTY, STAILQ_ENTRY, STAILQ_FIRST, STAILQ_FOREACH, "
"STAILQ_HEAD, STAILQ_HEAD_INITIALIZER, STAILQ_INIT, STAILQ_INSERT_AFTER, "
"STAILQ_INSERT_HEAD, STAILQ_INSERT_TAIL, STAILQ_NEXT, STAILQ_REMOVE, "
"STAILQ_REMOVE_HEAD, - implementation of a singly linked tail queue"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:60
#, no-wrap
msgid "B<void STAILQ_CONCAT(STAILQ_HEAD *>I<head1>B<, STAILQ_HEAD *>I<head2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:62
#, no-wrap
msgid "B<int STAILQ_EMPTY(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:64
#, no-wrap
msgid "B<STAILQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:66
#, no-wrap
msgid "B<struct TYPE *STAILQ_FIRST(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "STAILQ_FOREACH_FROM(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "STAILQ_FOREACH_FROM_SAFE(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#.  .PP
#.  .BI "STAILQ_FOREACH_SAFE(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/stailq.3:74
#, no-wrap
msgid ""
"B<STAILQ_FOREACH(struct TYPE *>I<var>B<, STAILQ_HEAD *>I<head>B<, "
"STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:76
#, no-wrap
msgid "B<STAILQ_HEAD(HEADNAME, TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:78
#, no-wrap
msgid "B<STAILQ_HEAD STAILQ_HEAD_INITIALIZER(STAILQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:80
#, no-wrap
msgid "B<void STAILQ_INIT(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:83
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_AFTER(STAILQ_HEAD *>I<head>B<, struct TYPE "
"*>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:86
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_HEAD(STAILQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "struct TYPE *STAILQ_LAST(STAILQ_HEAD *" head ", struct TYPE *" elm ", STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:91
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_TAIL(STAILQ_HEAD *>I<head>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:93
#, no-wrap
msgid ""
"B<struct TYPE *STAILQ_NEXT(struct TYPE *>I<elm>B<, STAILQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void STAILQ_REMOVE_AFTER(STAILQ_HEAD *" head ", struct TYPE *" elm ","
#.  .BI "                STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:99
#, no-wrap
msgid ""
"B<void STAILQ_REMOVE(STAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, "
"TYPE,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void STAILQ_SWAP(STAILQ_HEAD *" head1 ", STAILQ_HEAD *" head2 ","
#.  .BI "                STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:104
#, no-wrap
msgid ""
"B<void STAILQ_REMOVE_HEAD(STAILQ_HEAD *>I<head>B<, STAILQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:107
msgid "These macros define and operate on singly linked tail queues."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:120
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<STAILQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<STAILQ_HEAD>()."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:135
msgid ""
"A singly linked tail queue is headed by a structure defined by the "
"B<STAILQ_HEAD>()  macro.  This structure contains a pair of pointers, one to "
"the first element in the tail queue and the other to the last element in the "
"tail queue.  The elements are singly linked for minimum space and pointer "
"manipulation overhead at the expense of O(n) removal for arbitrary "
"elements.  New elements can be added to the tail queue after an existing "
"element, at the head of the tail queue, or at the end of the tail queue.  A "
"I<STAILQ_HEAD> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:139
#, no-wrap
msgid "STAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:148 build/C/man3/tailq.3:160
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the tail queue.  A pointer to "
"the head of the tail queue can later be declared as:"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:165
msgid ""
"The macro B<STAILQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"tail queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:173
msgid ""
"The macro B<STAILQ_CONCAT>()  concatenates the tail queue headed by I<head2> "
"onto the end of the one headed by I<head1> removing all entries from the "
"former."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:177
msgid ""
"The macro B<STAILQ_EMPTY>()  evaluates to true if there are no items on the "
"tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:182
msgid ""
"The macro B<STAILQ_ENTRY>()  declares a structure that connects the elements "
"in the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:187
msgid ""
"The macro B<STAILQ_FIRST>()  returns the first item on the tail queue or "
"NULL if the tail queue is empty."
msgstr ""

#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_FROM ()
#.  behaves identically to
#.  .BR STAILQ_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found STAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the STAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_SAFE ()
#.  traverses the tail queue referenced by
#.  .I head
#.  in the forward direction, assigning each element
#.  in turn to
#.  .IR var .
#.  However, unlike
#.  .BR STAILQ_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR STAILQ_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found STAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the STAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/stailq.3:235
msgid ""
"The macro B<STAILQ_FOREACH>()  traverses the tail queue referenced by "
"I<head> in the forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:240
msgid ""
"The macro B<STAILQ_INIT>()  initializes the tail queue referenced by "
"I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:246
msgid ""
"The macro B<STAILQ_INSERT_HEAD>()  inserts the new element I<elm> at the "
"head of the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:252
msgid ""
"The macro B<STAILQ_INSERT_TAIL>()  inserts the new element I<elm> at the end "
"of the tail queue."
msgstr ""

#.  .PP
#.  The macro
#.  .BR STAILQ_LAST ()
#.  returns the last item on the tail queue.
#.  If the tail queue is empty the return value is NULL .
#. type: Plain text
#: build/C/man3/stailq.3:264
msgid ""
"The macro B<STAILQ_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""

#.  .PP
#.  The macro
#.  .BR STAILQ_REMOVE_AFTER ()
#.  removes the element after
#.  .I elm
#.  from the tail queue.
#.  Unlike
#.  .BR STAILQ_REMOVE (),
#.  this macro does not traverse the entire tail queue.
#. type: Plain text
#: build/C/man3/stailq.3:277
msgid ""
"The macro B<STAILQ_NEXT>()  returns the next item on the tail queue, or NULL "
"this item is the last."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:286
msgid ""
"The macro B<STAILQ_REMOVE_HEAD>()  removes the element at the head of the "
"tail queue.  For optimum efficiency, elements being removed from the head of "
"the tail queue should use this macro explicitly rather than the generic "
"B<STAILQ_REMOVE>()  macro."
msgstr ""

#.  .PP
#.  The macro
#.  .BR STAILQ_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/stailq.3:299
msgid ""
"The macro B<STAILQ_REMOVE>()  removes the element I<elm> from the tail "
"queue."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:303
msgid ""
"B<STAILQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:310
msgid ""
"B<STAILQ_FIRST>(), and B<STAILQ_NEXT>()  return a pointer to the first or "
"next I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:314
msgid ""
"B<STAILQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:318
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (STAILQ "
"macros first appeared in 4.4BSD)."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:332
msgid ""
"The macro B<STAILQ_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<STAILQ_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:343
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    STAILQ_ENTRY(entry) entries;        /* Singly linked tail queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:345
#, no-wrap
msgid "STAILQ_HEAD(stailhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:352
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct stailhead head;              /* Singly linked tail queue\n"
"                                           head. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:354
#, no-wrap
msgid "    STAILQ_INIT(&head);                 /* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:357
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));  /* Insert at the head. */\n"
"    STAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:360
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));  /* Insert at the tail. */\n"
"    STAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:363
#, no-wrap
msgid ""
"    n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
"    STAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:366
#, no-wrap
msgid ""
"    STAILQ_REMOVE(&head, n2, entry, entries);/* Deletion. */\n"
"    free(n2);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:370
#, no-wrap
msgid ""
"    n3 = STAILQ_FIRST(&head);\n"
"    STAILQ_REMOVE_HEAD(&head, entries); /* Deletion from the head. */\n"
"    free(n3);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:389
#, no-wrap
msgid ""
"    n1 = STAILQ_FIRST(&head);\n"
"    n1-E<gt>data = 0;\n"
"    for (int i = 1; i E<lt> 5; i++) {\n"
"        n1 = malloc(sizeof(struct entry));\n"
"        STAILQ_INSERT_HEAD(&head, n1, entries);\n"
"        n1-E<gt>data = i;\n"
"    }\n"
"                                        /* Forward traversal. */\n"
"    STAILQ_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                        /* TailQ Deletion. */\n"
"    n1 = STAILQ_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = STAILQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    STAILQ_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/tailq.3:32
#, no-wrap
msgid "TAILQ"
msgstr ""

#. TAILQ_FOREACH_FROM,
#. TAILQ_FOREACH_FROM_SAFE,
#. TAILQ_FOREACH_REVERSE_FROM,
#. TAILQ_FOREACH_REVERSE_FROM_SAFE,
#. TAILQ_FOREACH_REVERSE_SAFE,
#. TAILQ_FOREACH_SAFE,
#. TAILQ_SWAP
#. type: Plain text
#: build/C/man3/tailq.3:59
msgid ""
"TAILQ_CONCAT, TAILQ_EMPTY, TAILQ_ENTRY, TAILQ_FIRST, TAILQ_FOREACH, "
"TAILQ_FOREACH_REVERSE, TAILQ_HEAD, TAILQ_HEAD_INITIALIZER, TAILQ_INIT, "
"TAILQ_INSERT_AFTER, TAILQ_INSERT_BEFORE, TAILQ_INSERT_HEAD, "
"TAILQ_INSERT_TAIL, TAILQ_LAST, TAILQ_NEXT, TAILQ_PREV, TAILQ_REMOVE - "
"implementation of a doubly linked tail queue"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:65
#, no-wrap
msgid ""
"B<void TAILQ_CONCAT(TAILQ_HEAD *>I<head1>B<, TAILQ_HEAD *>I<head2>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:67
#, no-wrap
msgid "B<int TAILQ_EMPTY(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:69
#, no-wrap
msgid "B<TAILQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:71
#, no-wrap
msgid "B<struct TYPE *TAILQ_FIRST(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "TAILQ_FOREACH_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/tailq.3:77
#, no-wrap
msgid ""
"B<TAILQ_FOREACH(struct TYPE *>I<var>B<, TAILQ_HEAD *>I<head>B<, TAILQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ", TYPE *" temp_var ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/tailq.3:88
#, no-wrap
msgid ""
"B<TAILQ_FOREACH_REVERSE(struct TYPE *>I<var>B<, TAILQ_HEAD *>I<head>B<, "
"HEADNAME,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:90
#, no-wrap
msgid "B<TAILQ_HEAD(HEADNAME, TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:92
#, no-wrap
msgid "B<TAILQ_HEAD TAILQ_HEAD_INITIALIZER(TAILQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:94
#, no-wrap
msgid "B<void TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:97
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, struct TYPE "
"*>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:100
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_BEFORE(struct TYPE *>I<listelm>B<, struct TYPE "
"*>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:103
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:106
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:108
#, no-wrap
msgid "B<struct TYPE *TAILQ_LAST(TAILQ_HEAD *>I<head>B<, HEADNAME);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:110
#, no-wrap
msgid ""
"B<struct TYPE *TAILQ_NEXT(struct TYPE *>I<elm>B<, TAILQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:112
#, no-wrap
msgid ""
"B<struct TYPE *TAILQ_PREV(struct TYPE *>I<elm>B<, HEADNAME, TAILQ_ENTRY "
">I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void TAILQ_SWAP(TAILQ_HEAD *" head1 ", TAILQ_HEAD *" head2 ", TYPE, TAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/tailq.3:116
#, no-wrap
msgid ""
"B<void TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, "
"TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:119
msgid "These macros define and operate on doubly linked tail queues."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:132
msgid ""
"In the macro definitions, I<TYPE> is the name of a user defined structure, "
"that must contain a field of type I<TAILQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user defined structure that must be "
"declared using the macro B<TAILQ_HEAD>()."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:147
msgid ""
"A tail queue is headed by a structure defined by the B<TAILQ_HEAD>()  "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the tail queue and the other to the last element in the tail queue.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the tail queue.  New elements can be added to the tail "
"queue after an existing element, before an existing element, at the head of "
"the tail queue, or at the end of the tail queue.  A I<TAILQ_HEAD> structure "
"is declared as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:151
#, no-wrap
msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:177
msgid ""
"The macro B<TAILQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"tail queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:185
msgid ""
"The macro B<TAILQ_CONCAT>()  concatenates the tail queue headed by I<head2> "
"onto the end of the one headed by I<head1> removing all entries from the "
"former."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:189
msgid ""
"The macro B<TAILQ_EMPTY>()  evaluates to true if there are no items on the "
"tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:194
msgid ""
"The macro B<TAILQ_ENTRY>()  declares a structure that connects the elements "
"in the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:199
msgid ""
"The macro B<TAILQ_FIRST>()  returns the first item on the tail queue or NULL "
"if the tail queue is empty."
msgstr ""

#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_FROM ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the TAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/tailq.3:222
msgid ""
"The macro B<TAILQ_FOREACH>()  traverses the tail queue referenced by I<head> "
"in the forward direction, assigning each element in turn to I<var>.  I<var> "
"is set to NULL if the loop completes normally, or if there were no elements."
msgstr ""

#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_REVERSE_FROM ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_REVERSE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .I var
#.  instead of the last element in the TAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macros
#.  .BR TAILQ_FOREACH_SAFE ()
#.  and
#.  .BR TAILQ_FOREACH_REVERSE_SAFE ()
#.  traverse the list referenced by
#.  .I head
#.  in the forward or reverse direction respectively,
#.  assigning each element in turn to
#.  .IR var .
#.  However, unlike their unsafe counterparts,
#.  .BR TAILQ_FOREACH ()
#.  and
#.  .BR TAILQ_FOREACH_REVERSE ()
#.  permit to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the TAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_REVERSE_FROM_SAFE ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_REVERSE_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .I var
#.  instead of the last element in the TAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/tailq.3:286
msgid ""
"The macro B<TAILQ_FOREACH_REVERSE>()  traverses the tail queue referenced by "
"I<head> in the reverse direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:291
msgid "The macro B<TAILQ_INIT>()  initializes the tail queue referenced by I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:297
msgid ""
"The macro B<TAILQ_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:303
msgid ""
"The macro B<TAILQ_INSERT_TAIL>()  inserts the new element I<elm> at the end "
"of the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:310
msgid ""
"The macro B<TAILQ_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:317
msgid ""
"The macro B<TAILQ_INSERT_BEFORE>()  inserts the new element I<elm> before "
"the element I<listelm>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:322
msgid ""
"The macro B<TAILQ_LAST>()  returns the last item on the tail queue.  If the "
"tail queue is empty the return value is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:326
msgid ""
"The macro B<TAILQ_NEXT>()  returns the next item on the tail queue, or NULL "
"if this item is the last."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:331
msgid ""
"The macro B<TAILQ_PREV>()  returns the previous item on the tail queue, or "
"NULL if this item is the first."
msgstr ""

#.  .PP
#.  The macro
#.  .BR TAILQ_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/tailq.3:344
msgid "The macro B<TAILQ_REMOVE>()  removes the element I<elm> from the tail queue."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:348
msgid ""
"B<TAILQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:357
msgid ""
"B<TAILQ_FIRST>(), B<TAILQ_LAST>(), B<TAILQ_NEXT>(), and B<TAILQ_PREV>()  "
"return a pointer to the first, last, next or previous I<TYPE> structure, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:361
msgid ""
"B<TAILQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:365
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.  (TAILQ "
"functions first appeared in 4.4BSD)."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:383
msgid ""
"The macros B<TAILQ_FOREACH>()  and B<TAILQ_FOREACH_REVERSE>()  don't allow "
"I<var> to be removed or freed within the loop, as it would interfere with "
"the traversal.  The macros B<TAILQ_FOREACH_SAFE>()  and "
"B<TAILQ_FOREACH_REVERSE_SAFE>(), which are present on the BSDs but are not "
"present in glibc, fix this limitation by allowing I<var> to safely be "
"removed from the list and freed from within the loop without interfering "
"with the traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:394
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    TAILQ_ENTRY(entry) entries;             /* Tail queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:396
#, no-wrap
msgid "TAILQ_HEAD(tailhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:403
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct tailhead head;                   /* Tail queue head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:405
#, no-wrap
msgid "    TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:408
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:411
#, no-wrap
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"    TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:414
#, no-wrap
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:417
#, no-wrap
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    TAILQ_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:435
#, no-wrap
msgid ""
"    TAILQ_REMOVE(&head, n2, entries);       /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    i = 0;\n"
"    TAILQ_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
"                                            /* Reverse traversal. */\n"
"    TAILQ_FOREACH_REVERSE(np, &head, tailhead, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* TailQ Deletion. */\n"
"    n1 = TAILQ_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = TAILQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    TAILQ_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man7/queue.7:32
#, no-wrap
msgid "QUEUE"
msgstr ""

#. type: TH
#: build/C/man7/queue.7:32
#, no-wrap
msgid "2020-11-16"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:35
msgid "queue - implementations of linked lists and queues"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:40
msgid ""
"The I<E<lt>sys/queue.hE<gt>> header file provides a set of macros that "
"define and operate on the following data structures:"
msgstr ""

#. type: IP
#: build/C/man7/queue.7:40 build/C/man7/queue.7:42 build/C/man7/queue.7:44 build/C/man7/queue.7:46 build/C/man7/queue.7:48 build/C/man7/queue.7:52 build/C/man7/queue.7:54 build/C/man7/queue.7:56 build/C/man7/queue.7:58 build/C/man7/queue.7:73 build/C/man7/queue.7:77 build/C/man7/queue.7:79 build/C/man7/queue.7:81 build/C/man7/queue.7:85 build/C/man7/queue.7:87 build/C/man7/queue.7:96 build/C/man7/queue.7:98 build/C/man7/queue.7:102 build/C/man7/queue.7:107 build/C/man7/queue.7:111 build/C/man7/queue.7:116 build/C/man7/queue.7:118 build/C/man7/queue.7:120 build/C/man7/queue.7:124 build/C/man7/queue.7:126 build/C/man7/queue.7:130 build/C/man7/queue.7:134
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:42
msgid "singly linked lists (SLIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:44
msgid "doubly linked lists (LIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:46
msgid "singly linked tail queues (STAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:48
msgid "doubly linked tail queues (TAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:50
msgid "doubly linked circular queues (CIRCLEQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:52
msgid "All structures support the following functionality:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:54
msgid "Insertion of a new entry at the head of the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:56
msgid "Insertion of a new entry after any element in the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:58
msgid "O(1) removal of an entry from the head of the list."
msgstr ""

#. .IP *
#.  Swapping the contents of two lists.
#. type: Plain text
#: build/C/man7/queue.7:62
msgid "Forward traversal through the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:66
msgid ""
"Code size and execution time depend on the complexity of the data structure "
"being used, so programmers should take care to choose the appropriate one."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:66
#, no-wrap
msgid "Singly linked lists (SLIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:73
msgid ""
"Singly linked lists are the simplest and support only the above "
"functionality.  Singly linked lists are ideal for applications with large "
"datasets and few or no removals, or for implementing a LIFO queue.  Singly "
"linked lists add the following functionality:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:75 build/C/man7/queue.7:81
msgid "O(n) removal of any entry in the list."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:75
#, no-wrap
msgid "Singly linked tail queues (STAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:77
msgid "Singly linked tail queues add the following functionality:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:79 build/C/man7/queue.7:118
msgid "Entries can be added at the end of a list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:83 build/C/man7/queue.7:122
msgid "They may be concatenated."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:85 build/C/man7/queue.7:102 build/C/man7/queue.7:111 build/C/man7/queue.7:124 build/C/man7/queue.7:134
msgid "However:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:87
msgid "All list insertions must specify the head of the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:89 build/C/man7/queue.7:128
msgid "Each head entry requires two pointers rather than one."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:93
msgid ""
"Singly linked tail queues are ideal for applications with large datasets and "
"few or no removals, or for implementing a FIFO queue."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:93
#, no-wrap
msgid "Doubly linked data structures"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:96
msgid ""
"All doubly linked types of data structures (lists and tail queues)  "
"additionally allow:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:98
msgid "Insertion of a new entry before any element in the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:100
msgid "O(1) removal of any entry in the list."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:104
msgid "Each element requires two pointers rather than one."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:104
#, no-wrap
msgid "Doubly linked lists (LIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:107
msgid ""
"Linked lists are the simplest of the doubly linked data structures.  They "
"add the following functionality over the above:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:109
msgid "They may be traversed backwards."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:114
msgid ""
"To traverse backwards, an entry to begin the traversal and the list in which "
"it is contained must be specified."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:114
#, no-wrap
msgid "Doubly linked tail queues (TAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:116
msgid "Tail queues add the following functionality:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:120
msgid "They may be traversed backwards, from tail to head."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:126
msgid "All list insertions and removals must specify the head of the list."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:128
#, no-wrap
msgid "Doubly linked circular queues (CIRCLEQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:130
msgid "Circular queues add the following functionality over the above:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:132
msgid "The first and last entries are connected."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:136
msgid "The termination condition for traversal is more complex."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:141
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.  "
"I<E<lt>sys/queue.hE<gt>> macros first appeared in 4.4BSD."
msgstr ""

#.  .BR tree (3)
#. type: Plain text
#: build/C/man7/queue.7:149
msgid ""
"B<circleq>(3), B<insque>(3), B<list>(3), B<slist>(3), B<stailq>(3), "
"B<tailq>(3)"
msgstr ""
