# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:36+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"#-#-#-#-#  ja.po (PACKAGE VERSION)  #-#-#-#-#\n"
"#-#-#-#-#  ja.po (PACKAGE VERSION)  #-#-#-#-#\n"

#. type: TH
#: build/C/man3/circleq.3:32
#, no-wrap
msgid "CIRCLEQ"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/slist.3:32 build/C/man3/stailq.3:32
#, no-wrap
msgid "2020-10-21"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/list.3:32 build/C/man3/slist.3:32
#: build/C/man3/stailq.3:32 build/C/man3/tailq.3:32 build/C/man7/queue.7:32
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/circleq.3:32 build/C/man3/insque.3:36 build/C/man3/list.3:32
#: build/C/man3/slist.3:32 build/C/man3/stailq.3:32 build/C/man3/tailq.3:32
#: build/C/man7/queue.7:32
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/circleq.3:33 build/C/man3/insque.3:37 build/C/man3/list.3:33
#: build/C/man3/slist.3:33 build/C/man3/stailq.3:33 build/C/man3/tailq.3:33
#: build/C/man7/queue.7:33
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/circleq.3:53
#, fuzzy
#| msgid ""
#| "LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
#| "LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
#| "TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
#| "CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
#| "CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - "
#| "implementations of lists, tail queues, and circular queues"
msgid ""
"CIRCLEQ_EMPTY, CIRCLEQ_ENTRY, CIRCLEQ_FIRST, CIRCLEQ_FOREACH, "
"CIRCLEQ_FOREACH_REVERSE, CIRCLEQ_HEAD, CIRCLEQ_HEAD_INITIALIZER, "
"CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_LAST, CIRCLEQ_LOOP_NEXT, "
"CIRCLEQ_LOOP_PREV, CIRCLEQ_NEXT, CIRCLEQ_PREV, CIRCLEQ_REMOVE - "
"implementation of a doubly linked circular queue"
msgstr ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - リスト・テール "
"(tail) キュー・循環キューの実装"

#. type: SH
#: build/C/man3/circleq.3:53 build/C/man3/insque.3:39 build/C/man3/list.3:52
#: build/C/man3/slist.3:52 build/C/man3/stailq.3:55 build/C/man3/tailq.3:59
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/circleq.3:56 build/C/man3/list.3:55 build/C/man3/slist.3:55
#: build/C/man3/stailq.3:58 build/C/man3/tailq.3:62
#, no-wrap
msgid "B<#include E<lt>sys/queue.hE<gt>>\n"
msgstr "B<#include E<lt>sys/queue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/circleq.3:58
#, no-wrap
msgid "B<int CIRCLEQ_EMPTY(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:60
#, no-wrap
msgid "B<CIRCLEQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:62
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_FIRST(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:65
#, no-wrap
msgid ""
"B<CIRCLEQ_FOREACH(struct TYPE *>I<var>B<, CIRCLEQ_HEAD *>I<head>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:68
#, no-wrap
msgid ""
"B<CIRCLEQ_FOREACH_REVERSE(struct TYPE *>I<var>B<, CIRCLEQ_HEAD *>I<head>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:70
#, fuzzy, no-wrap
#| msgid "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"
msgid "B<CIRCLEQ_HEAD(HEADNAME, TYPE);>\n"
msgstr "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/circleq.3:72
#, no-wrap
msgid "B<CIRCLEQ_HEAD CIRCLEQ_HEAD_INITIALIZER(CIRCLEQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:74
#, no-wrap
msgid "B<void CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:77
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:80
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:83
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:86
#, no-wrap
msgid ""
"B<void CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:88
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_LAST(CIRCLEQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:91
#, no-wrap
msgid ""
"B<void CIRCLEQ_LOOP_NEXT(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:94
#, no-wrap
msgid ""
"B<void CIRCLEQ_LOOP_PREV(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:96
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_NEXT(struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:98
#, no-wrap
msgid "B<struct TYPE *CIRCLEQ_PREV(struct TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:101
#, no-wrap
msgid ""
"B<void CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:102 build/C/man3/insque.3:63 build/C/man3/list.3:93
#: build/C/man3/slist.3:92 build/C/man3/stailq.3:105 build/C/man3/tailq.3:117
#: build/C/man7/queue.7:35
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/circleq.3:104
msgid "These macros define and operate on doubly linked circular queues."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:117
#, fuzzy
#| msgid ""
#| "In the macro definitions, I<TYPE> is the name of a user-defined "
#| "structure, that must contain a field of type B<LIST_ENTRY>, "
#| "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#| "I<HEADNAME> is the name of a user-defined structure that must be declared "
#| "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#| "the examples below for further explanation of how these macros are used."
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<CIRCLEQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<CIRCLEQ_HEAD>()."
msgstr ""
"マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引数 I<HEADNAME> はユーザー定義構造体の名前であ"
"り、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなけ"
"ればならない。 これらのマクロがどのように使われるかについての更なる説明は、 "
"以下の例を参照すること。"

#. type: Plain text
#: build/C/man3/circleq.3:132
#, fuzzy
#| msgid ""
#| "A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD> "
#| "macro.  This structure contains a pair of pointers, one to the first "
#| "element in the circular queue and the other to the last element in the "
#| "circular queue.  The elements are doubly linked so that an arbitrary "
#| "element can be removed without traversing the queue.  New elements can be "
#| "added to the queue after an existing element, before an existing element, "
#| "at the head of the queue, or at the end of the queue.  A B<CIRCLEQ_HEAD> "
#| "structure is declared as follows:"
msgid ""
"A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD>()  "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the circular queue and the other to the last element in the circular "
"queue.  The elements are doubly linked so that an arbitrary element can be "
"removed without traversing the circular queue.  New elements can be added to "
"the circular queue after an existing element, before an existing element, at "
"the head of the circular queue, or at the end of the circular queue.  A "
"I<CIRCLEQ_HEAD> structure is declared as follows:"
msgstr ""
"循環キューの先頭には B<CIRCLEQ_HEAD> マクロで定義される構造体が置かれる。 こ"
"の構造体は 1 組のポインターを含んでいる。 1 つは循環キューの最初の要素へのポ"
"インターであり、 もう 1 つは循環キューの最後の要素へのポインターである。 要素"
"は 2 重にリンクされており、 任意の要素はキューを辿らずに削除できる。 新しい要"
"素は、既存の要素の後または前、またはキューの先頭または末尾に追加できる。 A "
"B<CIRCLEQ_HEAD> 構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/circleq.3:136
#, no-wrap
msgid "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/circleq.3:145
#, fuzzy
#| msgid ""
#| "where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> "
#| "is the type of the elements to be linked into the circular queue.  A "
#| "pointer to the head of the circular queue can later be declared as:"
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the circular queue.  A pointer "
"to the head of the circular queue can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> は循環キュー内で"
"リンクされる要素の型である。 循環キューの先頭へのポインターは、その後で次のよ"
"うに宣言される:"

#. type: Plain text
#: build/C/man3/circleq.3:149 build/C/man3/list.3:138 build/C/man3/slist.3:137
#: build/C/man3/stailq.3:152 build/C/man3/tailq.3:164
#, no-wrap
msgid "struct HEADNAME *headp;\n"
msgstr "struct HEADNAME *headp;\n"

#. type: Plain text
#: build/C/man3/circleq.3:157 build/C/man3/list.3:146 build/C/man3/slist.3:145
#: build/C/man3/stailq.3:160 build/C/man3/tailq.3:172
msgid "(The names I<head> and I<headp> are user selectable.)"
msgstr "(名前 I<head> と I<headp> はユーザーが選択できる。)"

#. type: Plain text
#: build/C/man3/circleq.3:162
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INIT> initializes the circular queue referenced by "
#| "I<head>."
msgid ""
"The macro B<CIRCLEQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"circular queue I<head>."
msgstr "マクロ B<CIRCLEQ_INIT> は I<head> で参照される循環キューを初期化する。"

#. type: Plain text
#: build/C/man3/circleq.3:166
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_ENTRY> declares a structure that connects the "
#| "elements in the circular queue."
msgid ""
"The macro B<CIRCLEQ_EMPTY>()  evaluates to true if there are no items on the "
"circular queue."
msgstr "マクロ B<CIRCLEQ_ENTRY> は循環キューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/circleq.3:171
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_ENTRY> declares a structure that connects the "
#| "elements in the circular queue."
msgid ""
"The macro B<CIRCLEQ_ENTRY>()  declares a structure that connects the "
"elements in the circular queue."
msgstr "マクロ B<CIRCLEQ_ENTRY> は循環キューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/circleq.3:175
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_REMOVE> removes the element I<elm> from the circular "
#| "queue."
msgid ""
"The macro B<CIRCLEQ_FIRST>()  returns the first item on the circular queue."
msgstr "マクロ B<CIRCLEQ_REMOVE> は要素 I<elm> を循環キューから削除する。"

#. type: Plain text
#: build/C/man3/circleq.3:186
msgid ""
"The macro B<CIRCLEQ_FOREACH>()  traverses the circular queue referenced by "
"I<head> in the forward direction, assigning each element in turn to I<var>.  "
"I<var> is set to I<&head> if the loop completes normally, or if there were "
"no elements."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:193
msgid ""
"The macro B<CIRCLEQ_FOREACH_REVERSE>()  traverses the circular queue "
"referenced by I<head> in the reverse direction, assigning each element in "
"turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:198
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INIT> initializes the circular queue referenced by "
#| "I<head>."
msgid ""
"The macro B<CIRCLEQ_INIT>()  initializes the circular queue referenced by "
"I<head>."
msgstr "マクロ B<CIRCLEQ_INIT> は I<head> で参照される循環キューを初期化する。"

#. type: Plain text
#: build/C/man3/circleq.3:204
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_HEAD> inserts the new element I<elm> at the "
#| "head of the circular queue."
msgid ""
"The macro B<CIRCLEQ_INSERT_HEAD>()  inserts the new element I<elm> at the "
"head of the circular queue."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_HEAD> は新たな要素 I<elm> を循環キューの先頭に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/circleq.3:210
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_TAIL> inserts the new element I<elm> at the "
#| "end of the circular queue."
msgid ""
"The macro B<CIRCLEQ_INSERT_TAIL>()  inserts the new element I<elm> at the "
"end of the circular queue."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_TAIL> は新たな要素 I<elm> を循環キューの末尾に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/circleq.3:217
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_AFTER> inserts the new element I<elm> after "
#| "the element I<listelm>."
msgid ""
"The macro B<CIRCLEQ_INSERT_AFTER>()  inserts the new element I<elm> after "
"the element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿"
"入する。"

#. type: Plain text
#: build/C/man3/circleq.3:224
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_BEFORE> inserts the new element I<elm> before "
#| "the element I<listelm>."
msgid ""
"The macro B<CIRCLEQ_INSERT_BEFORE>()  inserts the new element I<elm> before "
"the element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の前に挿"
"入する。"

#. type: Plain text
#: build/C/man3/circleq.3:228
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_REMOVE> removes the element I<elm> from the circular "
#| "queue."
msgid ""
"The macro B<CIRCLEQ_LAST>()  returns the last item on the circular queue."
msgstr "マクロ B<CIRCLEQ_REMOVE> は要素 I<elm> を循環キューから削除する。"

#. type: Plain text
#: build/C/man3/circleq.3:234
msgid ""
"The macro B<CIRCLEQ_NEXT>()  returns the next item on the circular queue, or "
"I<&head> if this item is the last one."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:240
msgid ""
"The macro B<CIRCLEQ_PREV>()  returns the previous item on the circular "
"queue, or I<&head> if this item is the first one."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:247
msgid ""
"The macro B<CIRCLEQ_LOOP_NEXT>()  returns the next item on the circular "
"queue.  If I<elm> is the last element on the circular queue, the first "
"element is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:254
msgid ""
"The macro B<CIRCLEQ_LOOP_PREV>()  returns the previous item on the circular "
"queue.  If I<elm> is the first element on the circular queue, the last "
"element is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:260
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_REMOVE> removes the element I<elm> from the circular "
#| "queue."
msgid ""
"The macro B<CIRCLEQ_REMOVE>()  removes the element I<elm> from the circular "
"queue."
msgstr "マクロ B<CIRCLEQ_REMOVE> は要素 I<elm> を循環キューから削除する。"

#. type: SH
#: build/C/man3/circleq.3:260 build/C/man3/list.3:261 build/C/man3/slist.3:266
#: build/C/man3/stailq.3:299 build/C/man3/tailq.3:344
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:264
msgid ""
"B<CIRCLEQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:273
msgid ""
"B<CIRCLEQ_FIRST>(), B<CIRCLEQ_LAST>(), B<CIRCLEQ_NEXT>(), and "
"B<CIRCLEQ_PREV>()  return a pointer to the first, last, next or previous "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:277
msgid ""
"B<CIRCLEQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned "
"to the queue I<head>."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:277 build/C/man3/insque.3:115 build/C/man3/list.3:276
#: build/C/man3/slist.3:281 build/C/man3/stailq.3:314 build/C/man3/tailq.3:361
#: build/C/man7/queue.7:136
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/circleq.3:281
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (CIRCLEQ "
"macros first appeared in 4.4BSD)."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: SH
#: build/C/man3/circleq.3:281 build/C/man3/insque.3:144 build/C/man3/list.3:280
#: build/C/man3/slist.3:285 build/C/man3/stailq.3:318 build/C/man3/tailq.3:365
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/circleq.3:299
msgid ""
"The macros B<CIRCLEQ_FOREACH>()  and B<CIRCLEQ_FOREACH_REVERSE>()  don't "
"allow I<var> to be removed or freed within the loop, as it would interfere "
"with the traversal.  The macros B<CIRCLEQ_FOREACH_SAFE>()  and "
"B<CIRCLEQ_FOREACH_REVERSE_SAFE>(), which are present on the BSDs but are not "
"present in glibc, fix this limitation by allowing I<var> to safely be "
"removed from the list and freed from within the loop without interfering "
"with the traversal."
msgstr ""

#. type: SH
#: build/C/man3/circleq.3:299 build/C/man3/insque.3:151 build/C/man3/list.3:294
#: build/C/man3/slist.3:299 build/C/man3/stailq.3:332 build/C/man3/tailq.3:383
#, fuzzy, no-wrap
#| msgid "EXAMPLE"
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/circleq.3:305 build/C/man3/list.3:300 build/C/man3/slist.3:305
#: build/C/man3/stailq.3:338 build/C/man3/tailq.3:389
#, fuzzy, no-wrap
#| msgid ""
#| "#include E<lt>stdio.hE<gt>\n"
#| "#include E<lt>stdlib.hE<gt>\n"
#| "#include E<lt>unistd.hE<gt>\n"
#| "#include E<lt>search.hE<gt>\n"
msgid ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/queue.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"

#. type: Plain text
#: build/C/man3/circleq.3:310
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    CIRCLEQ_ENTRY(entry) entries;           /* Queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:312
#, no-wrap
msgid "CIRCLEQ_HEAD(circlehead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:319
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct circlehead head;                 /* Queue head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:321
#, fuzzy, no-wrap
#| msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgid "    CIRCLEQ_INIT(&head);                    /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/circleq.3:324
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));  /* Insert at the head. */\n"
#| "CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/circleq.3:327
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));  /* Insert at the tail. */\n"
#| "CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"    CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/\n"
"CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/circleq.3:330
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/circleq.3:333
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    CIRCLEQ_INSERT_BEFORE(&head, n2, n3, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/circleq.3:351
#, no-wrap
msgid ""
"    CIRCLEQ_REMOVE(&head, n2, entries);     /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    i = 0;\n"
"    CIRCLEQ_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
"                                            /* Reverse traversal. */\n"
"    CIRCLEQ_FOREACH_REVERSE(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* Queue deletion. */\n"
"    n1 = CIRCLEQ_FIRST(&head);\n"
"    while (n1 != (void *)&head) {\n"
"        n2 = CIRCLEQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    CIRCLEQ_INIT(&head);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:354 build/C/man3/insque.3:258 build/C/man3/list.3:346
#: build/C/man3/slist.3:354 build/C/man3/stailq.3:392 build/C/man3/tailq.3:438
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/circleq.3:355 build/C/man3/insque.3:259 build/C/man3/list.3:347
#: build/C/man3/slist.3:355 build/C/man3/stailq.3:393 build/C/man3/tailq.3:439
#: build/C/man7/queue.7:141
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/circleq.3:358 build/C/man3/list.3:350 build/C/man3/slist.3:358
#: build/C/man3/stailq.3:396 build/C/man3/tailq.3:442
#, fuzzy
#| msgid "B<insque>(), B<remque>():"
msgid "B<insque>(3), B<queue>(7)"
msgstr "B<insque>(), B<remque>():"

#. type: SH
#: build/C/man3/circleq.3:358 build/C/man3/insque.3:261 build/C/man3/list.3:350
#: build/C/man3/slist.3:358 build/C/man3/stailq.3:396 build/C/man3/tailq.3:442
#: build/C/man7/queue.7:149
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/circleq.3:366 build/C/man3/insque.3:269 build/C/man3/list.3:358
#: build/C/man3/slist.3:366 build/C/man3/stailq.3:404 build/C/man3/tailq.3:450
#: build/C/man7/queue.7:157
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "INSQUE"
msgstr "INSQUE"

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:39
msgid "insque, remque - insert/remove an item from a queue"
msgstr "insque, remque - キューにアイテムを挿入/削除する"

#. type: Plain text
#: build/C/man3/insque.3:42
#, no-wrap
msgid "B<#include E<lt>search.hE<gt>>\n"
msgstr "B<#include E<lt>search.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/insque.3:44
#, no-wrap
msgid "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"
msgstr "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"

#. type: Plain text
#: build/C/man3/insque.3:46
#, no-wrap
msgid "B<void remque(void *>I<elem>B<);>\n"
msgstr "B<void remque(void *>I<elem>B<);>\n"

#. type: Plain text
#: build/C/man3/insque.3:51
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/insque.3:56
msgid "B<insque>(), B<remque>():"
msgstr "B<insque>(), B<remque>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man3/insque.3:61
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:75
#, fuzzy
#| msgid ""
#| "The B<insque>()  and B<remque>()  functions manipulate doubly-linked "
#| "lists.  Each element in the list is a structure of which the first two "
#| "elements are a forward and a backward pointer.  The linked list may be "
#| "linear (i.e., NULL forward pointer at the end of the list and NULL "
#| "backward pointer at the start of the list)  or circular."
msgid ""
"The B<insque>()  and B<remque>()  functions manipulate doubly linked lists.  "
"Each element in the list is a structure of which the first two elements are "
"a forward and a backward pointer.  The linked list may be linear (i.e., NULL "
"forward pointer at the end of the list and NULL backward pointer at the "
"start of the list)  or circular."
msgstr ""
"関数 B<insque>() と B<remque>() は双方向連結リスト (doubly-linked list) を\n"
"操作する。リスト中のそれぞれの要素は、最初の二つの要素がそれぞれ次と前への\n"
"ポインターであるような構造体である。\n"
"リンクリストは、線形 (linear) か環状 (circular) のどちらかになる\n"
"(線形の場合には、リストの末尾では次へのポインターが NULL になり、\n"
"リストの先頭では前へのポインターが NULL になる)。"

#. type: Plain text
#: build/C/man3/insque.3:80
msgid ""
"The B<insque>()  function inserts the element pointed to by I<elem> "
"immediately after the element pointed to by I<prev>."
msgstr ""
"B<insque>() 関数は I<elem> で示される要素を I<prev> で示される\n"
"要素の直後に挿入する。"

#. type: Plain text
#: build/C/man3/insque.3:87
msgid ""
"If the list is linear, then the call I<insque(elem, NULL)> can be used to "
"insert the initial list element, and the call sets the forward and backward "
"pointers of I<elem> to NULL."
msgstr ""
"リストが線形の場合、I<insque(elem, NULL)> を呼び出すと、\n"
"リストの最初の要素を挿入することができる。\n"
"この呼び出しを行うと I<elem> の次へのポインターと前へのポインターに\n"
"共に NULL が設定される。"

#. type: Plain text
#: build/C/man3/insque.3:96
msgid ""
"If the list is circular, the caller should ensure that the forward and "
"backward pointers of the first element are initialized to point to that "
"element, and the I<prev> argument of the B<insque>()  call should also point "
"to the element."
msgstr ""
"リストが環状の場合、呼び出す側が、最初の要素の次へのポインターと前へのポイン"
"ター\n"
"が自分自身を指し、また  B<insque>() の呼び出しで I<prev> 引数が最初の要素\n"
"を指すように保証しなければならない。"

#. type: Plain text
#: build/C/man3/insque.3:101
#, fuzzy
#| msgid ""
#| "The B<remque>()  function removes the element pointed to by I<elem> from "
#| "the doubly-linked list."
msgid ""
"The B<remque>()  function removes the element pointed to by I<elem> from the "
"doubly linked list."
msgstr ""
"B<remque>() 関数は I<elem> で示される要素を双方向連結リストから取り除く。"

#. type: SH
#: build/C/man3/insque.3:101
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/insque.3:104
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/insque.3:108
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid ""
"B<insque>(),\n"
"B<remque>()"
msgstr ""
"B<insque>(),\n"
"B<remque>()"

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/insque.3:112
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/insque.3:117
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: SH
#: build/C/man3/insque.3:117
#, no-wrap
msgid "NOTES"
msgstr "注意"

#.  e.g., SunOS, Linux libc4 and libc5
#. type: Plain text
#: build/C/man3/insque.3:122
#, fuzzy
#| msgid ""
#| "Traditionally (e.g., SunOS, Linux libc4 and libc5), the arguments of "
#| "these functions were of type I<struct qelem *>, defined as:"
msgid ""
"On ancient systems, the arguments of these functions were of type I<struct "
"qelem *>, defined as:"
msgstr ""
"伝統的に (SunOS, Linux libc 4,5 では) これらの関数の引数は I<struct qelem "
"*>型であり、これは以下のように定義されている。"

#. type: Plain text
#: build/C/man3/insque.3:130
#, no-wrap
msgid ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"
msgstr ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"

#. type: Plain text
#: build/C/man3/insque.3:137
msgid ""
"This is still what you will get if B<_GNU_SOURCE> is defined before "
"including I<E<lt>search.hE<gt>>."
msgstr ""
"この定義は I<E<lt>search.hE<gt>> をインクルードする前に B<_GNU_SOURCE> を定義"
"することで得られる。"

#.  Linux libc4 and libc 5 placed them
#.  in \fI<stdlib.h>\fP.
#. type: Plain text
#: build/C/man3/insque.3:144
msgid ""
"The location of the prototypes for these functions differs among several "
"versions of UNIX.  The above is the POSIX version.  Some systems place them "
"in I<E<lt>string.hE<gt>>."
msgstr ""
"これらの関数のプロトタイプの置かれる場所は、UNIX の種類により異なる。\n"
"上記は POSIX 版である。 I<E<lt>string.hE<gt>> にあるシステムもある。"

#. type: Plain text
#: build/C/man3/insque.3:151
msgid ""
"In glibc 2.4 and earlier, it was not possible to specify I<prev> as NULL.  "
"Consequently, to build a linear list, the caller had to build a list using "
"an initial call that contained the first two elements of the list, with the "
"forward and backward pointers in each element suitably initialized."
msgstr ""
"glibc 2.4 以前では I<prev> に NULL を指定することができなかった。\n"
"その結果、線形のリストを作成するためには、\n"
"呼び出し側は、最初の呼び出しで、リストの最初の 2 つの要素を持ち、\n"
"各要素の次へのポインターと前へのポインターを適切に初期化したリストを\n"
"作成しなければならなかった。"

#. type: Plain text
#: build/C/man3/insque.3:155
msgid ""
"The program below demonstrates the use of B<insque>().  Here is an example "
"run of the program:"
msgstr ""
"次のプログラムは B<insque>() の使用法を示したものである。\n"
"下記はプログラムの実行例である。"

#. type: Plain text
#: build/C/man3/insque.3:164
#, no-wrap
msgid ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"
msgstr ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"

#. type: SS
#: build/C/man3/insque.3:166
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/insque.3:173
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"

#. type: Plain text
#: build/C/man3/insque.3:179
#, no-wrap
msgid ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"
msgstr ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"

#. type: Plain text
#: build/C/man3/insque.3:188
#, fuzzy, no-wrap
#| msgid ""
#| "    e = malloc(sizeof(struct element));\n"
#| "    if (e == NULL) {\n"
#| "        fprintf(stderr, \"malloc() failed\\en\");\n"
#| "        exit(EXIT_FAILURE);\n"
#| "    }\n"
msgid ""
"static struct element *\n"
"new_element(void)\n"
"{\n"
"    struct element *e = malloc(sizeof(*e));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    e = malloc(sizeof(struct element));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:191
#, no-wrap
msgid ""
"    return e;\n"
"}\n"
msgstr ""
"    return e;\n"
"}\n"

#. type: Plain text
#: build/C/man3/insque.3:197
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"

#. type: Plain text
#: build/C/man3/insque.3:200
#, no-wrap
msgid ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"
msgstr ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"

#. type: Plain text
#: build/C/man3/insque.3:213
#, fuzzy, no-wrap
#| msgid ""
#| "    errfnd = 0;\n"
#| "    circular = 0;\n"
#| "    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
#| "        switch (opt) {\n"
#| "        case 'c':\n"
#| "            circular = 1;\n"
#| "            break;\n"
#| "        default:\n"
#| "            errfnd = 1;\n"
#| "            break;\n"
#| "        }\n"
#| "    }\n"
msgid ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case 'c':\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:218
#, no-wrap
msgid ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:220
#, no-wrap
msgid "    /* Create first element and place it in the linked list */\n"
msgstr "    /* Create first element and place it in the linked list */\n"

#. type: Plain text
#: build/C/man3/insque.3:223
#, no-wrap
msgid ""
"    elem = new_element();\n"
"    first = elem;\n"
msgstr ""
"    elem = new_element();\n"
"    first = elem;\n"

#. type: Plain text
#: build/C/man3/insque.3:225
#, no-wrap
msgid "    elem-E<gt>name = argv[optind];\n"
msgstr "    elem-E<gt>name = argv[optind];\n"

#. type: Plain text
#: build/C/man3/insque.3:233
#, no-wrap
msgid ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"
msgstr ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:235
#, no-wrap
msgid "    /* Add remaining command-line arguments as list elements */\n"
msgstr "    /* Add remaining command-line arguments as list elements */\n"

#. type: Plain text
#: build/C/man3/insque.3:238
#, no-wrap
msgid ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"
msgstr ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"

#. type: Plain text
#: build/C/man3/insque.3:243
#, no-wrap
msgid ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"
msgstr ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:245
#, no-wrap
msgid "    /* Traverse the list from the start, printing element names */\n"
msgstr "    /* Traverse the list from the start, printing element names */\n"

#. type: Plain text
#: build/C/man3/insque.3:252
#, no-wrap
msgid ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"
msgstr ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"

#. type: Plain text
#: build/C/man3/insque.3:255
#, no-wrap
msgid ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"
msgstr ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"

#. type: Plain text
#: build/C/man3/insque.3:261
msgid "B<queue>(7)"
msgstr ""

#. type: TH
#: build/C/man3/list.3:32
#, no-wrap
msgid "LIST"
msgstr ""

#. type: TH
#: build/C/man3/list.3:32 build/C/man3/tailq.3:32
#, fuzzy, no-wrap
#| msgid "2007-12-28"
msgid "2020-12-21"
msgstr "2007-12-28"

#. LIST_FOREACH_FROM,
#. LIST_FOREACH_SAFE,
#. LIST_FOREACH_FROM_SAFE,
#. LIST_PREV,
#. LIST_SWAP
#. type: Plain text
#: build/C/man3/list.3:52
msgid ""
"LIST_EMPTY, LIST_ENTRY, LIST_FIRST, LIST_FOREACH, LIST_HEAD, "
"LIST_HEAD_INITIALIZER, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_BEFORE, "
"LIST_INSERT_HEAD, LIST_NEXT, LIST_REMOVE - implementation of a doubly linked "
"list"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:57
#, no-wrap
msgid "B<int LIST_EMPTY(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:59
#, no-wrap
msgid "B<LIST_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:61
#, no-wrap
msgid "B<struct TYPE *LIST_FIRST(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. .PP
#. .BI "LIST_FOREACH_FROM(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ");"
#. .PP
#. .BI "LIST_FOREACH_FROM_SAFE(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. .PP
#. .BI "LIST_FOREACH_SAFE(struct TYPE *" var ", LIST_HEAD *" head ", LIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/list.3:69
#, no-wrap
msgid "B<LIST_FOREACH(struct TYPE *>I<var>B<, LIST_HEAD *>I<head>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:71
#, fuzzy, no-wrap
#| msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgid "B<LIST_HEAD(HEADNAME, TYPE);>\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/list.3:73
#, no-wrap
msgid "B<LIST_HEAD LIST_HEAD_INITIALIZER(LIST_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:75
#, no-wrap
msgid "B<void LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:78
#, no-wrap
msgid ""
"B<void LIST_INSERT_AFTER(struct TYPE *>I<listelm>B<, struct TYPE *>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:81
#, no-wrap
msgid ""
"B<void LIST_INSERT_BEFORE(struct TYPE *>I<listelm>B<, struct TYPE *>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:84
#, no-wrap
msgid ""
"B<void LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "struct TYPE *LIST_PREV(struct TYPE *" elm ", LIST_HEAD *" head ", struct TYPE, LIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/list.3:88
#, no-wrap
msgid "B<struct TYPE *LIST_NEXT(struct TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void LIST_SWAP(LIST_HEAD *" head1 ", LIST_HEAD *" head2 ", struct TYPE, LIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/list.3:92
#, no-wrap
msgid "B<void LIST_REMOVE(struct TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:95 build/C/man3/slist.3:94
msgid "These macros define and operate on doubly linked lists."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:108
#, fuzzy
#| msgid ""
#| "In the macro definitions, I<TYPE> is the name of a user-defined "
#| "structure, that must contain a field of type B<LIST_ENTRY>, "
#| "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#| "I<HEADNAME> is the name of a user-defined structure that must be declared "
#| "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#| "the examples below for further explanation of how these macros are used."
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<LIST_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<LIST_HEAD>()."
msgstr ""
"マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引数 I<HEADNAME> はユーザー定義構造体の名前であ"
"り、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなけ"
"ればならない。 これらのマクロがどのように使われるかについての更なる説明は、 "
"以下の例を参照すること。"

#. type: Plain text
#: build/C/man3/list.3:121
#, fuzzy
#| msgid ""
#| "A list is headed by a structure defined by the B<LIST_HEAD> macro.  This "
#| "structure contains a single pointer to the first element on the list.  "
#| "The elements are doubly linked so that an arbitrary element can be "
#| "removed without traversing the list.  New elements can be added to the "
#| "list after an existing element or at the head of the list.  A "
#| "B<LIST_HEAD> structure is declared as follows:"
msgid ""
"A list is headed by a structure defined by the B<LIST_HEAD>()  macro.  This "
"structure contains a single pointer to the first element on the list.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the list.  New elements can be added to the list after an "
"existing element, before an existing element, or at the head of the list.  A "
"I<LIST_HEAD> structure is declared as follows:"
msgstr ""
"リストの先頭には、 B<LIST_HEAD> マクロで定義される構造体が置かれる。 この構造"
"体はリストの最初の要素へのポインターを 1 つ含む。 要素は 2 重にリンクされてお"
"り、 任意の要素はリストを辿らずに削除できる。 新しい要素は既存の要素の後また"
"はリストの先頭に追加できる。 B<LIST_HEAD> 構造体は以下のように宣言されている:"

#. type: Plain text
#: build/C/man3/list.3:125
#, no-wrap
msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/list.3:134 build/C/man3/slist.3:133
#, fuzzy
#| msgid ""
#| "where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> "
#| "is the type of the elements to be linked into the list.  A pointer to the "
#| "head of the list can later be declared as:"
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the list.  A pointer to the "
"head of the list can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> はリンク内でリン"
"クされる要素の型である。 リストの先頭へのポインターは、その後で次のように宣言"
"される:"

#. type: Plain text
#: build/C/man3/list.3:151
#, fuzzy
#| msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgid ""
"The macro B<LIST_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"list I<head>."
msgstr "マクロ B<LIST_INIT> は I<head> で参照されるリストを初期化する。"

#. type: Plain text
#: build/C/man3/list.3:155
#, fuzzy
#| msgid ""
#| "The macro B<LIST_ENTRY> declares a structure that connects the elements "
#| "in the list."
msgid ""
"The macro B<LIST_EMPTY>()  evaluates to true if there are no elements in the "
"list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/list.3:160
#, fuzzy
#| msgid ""
#| "The macro B<LIST_ENTRY> declares a structure that connects the elements "
#| "in the list."
msgid ""
"The macro B<LIST_ENTRY>()  declares a structure that connects the elements "
"in the list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/list.3:165
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the list."
msgid ""
"The macro B<LIST_FIRST>()  returns the first element in the list or NULL if "
"the list is empty."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_FROM ()
#.  behaves identically to
#.  .BR LIST_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found LIST element and begins the loop at
#.  .I var
#.  instead of the first element in the LIST referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_SAFE ()
#.  traverses the list referenced by
#.  .I head
#.  in the forward direction, assigning each element in turn to
#.  .IR var .
#.  However, unlike
#.  .BR LIST_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR LIST_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR LIST_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found LIST element and begins the loop at
#.  .I var
#.  instead of the first element in the LIST referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/list.3:211
msgid ""
"The macro B<LIST_FOREACH>()  traverses the list referenced by I<head> in the "
"forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:216
#, fuzzy
#| msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgid "The macro B<LIST_INIT>()  initializes the list referenced by I<head>."
msgstr "マクロ B<LIST_INIT> は I<head> で参照されるリストを初期化する。"

#. type: Plain text
#: build/C/man3/list.3:222
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the list."
msgid ""
"The macro B<LIST_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the list."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#. type: Plain text
#: build/C/man3/list.3:229
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_AFTER> inserts the new element I<elm> after the "
#| "element I<listelm>."
msgid ""
"The macro B<LIST_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<LIST_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#. type: Plain text
#: build/C/man3/list.3:236
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_BEFORE> inserts the new element I<elm> before "
#| "the element I<listelm>."
msgid ""
"The macro B<LIST_INSERT_BEFORE>()  inserts the new element I<elm> before the "
"element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の前に挿"
"入する。"

#.  .PP
#.  The macro
#.  .BR LIST_PREV ()
#.  returns the previous element in the list, or NULL if this is the first.
#.  List
#.  .I head
#.  must contain element
#.  .IR elm .
#. type: Plain text
#: build/C/man3/list.3:248
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the list."
msgid ""
"The macro B<LIST_NEXT>()  returns the next element in the list, or NULL if "
"this is the last."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#.  .PP
#.  The macro
#.  .BR LIST_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/list.3:261
#, fuzzy
#| msgid "The macro B<LIST_REMOVE> removes the element I<elm> from the list."
msgid "The macro B<LIST_REMOVE>()  removes the element I<elm> from the list."
msgstr "マクロ B<LIST_REMOVE> は要素 I<elm> をリストから削除する。"

#. type: Plain text
#: build/C/man3/list.3:265
msgid ""
"B<LIST_EMPTY>()  returns nonzero if the list is empty, and zero if the list "
"contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:272
msgid ""
"B<LIST_FIRST>(), and B<LIST_NEXT>()  return a pointer to the first or next "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:276
msgid ""
"B<LIST_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:280
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (LIST "
"macros first appeared in 4.4BSD)."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: Plain text
#: build/C/man3/list.3:294
msgid ""
"The macro B<LIST_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<LIST_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:305
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    LIST_ENTRY(entry) entries;              /* List. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:307
#, no-wrap
msgid "LIST_HEAD(listhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:314
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct listhead head;                   /* List head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:316
#, fuzzy, no-wrap
#| msgid "LIST_INIT(&head);                       /* Initialize the list. */\n"
msgid "    LIST_INIT(&head);                       /* Initialize the list. */\n"
msgstr "LIST_INIT(&head);                       /* リストを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/list.3:319
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "LIST_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    LIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/list.3:322
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    LIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/list.3:325
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "LIST_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    LIST_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/list.3:329
#, no-wrap
msgid ""
"    i = 0;                                  /* Forward traversal. */\n"
"    LIST_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/list.3:343
#, no-wrap
msgid ""
"    LIST_REMOVE(n2, entries);               /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    LIST_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* List Deletion. */\n"
"    n1 = LIST_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = LIST_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    LIST_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/slist.3:32
#, no-wrap
msgid "SLIST"
msgstr ""

#. SLIST_FOREACH_FROM,
#. SLIST_FOREACH_FROM_SAFE,
#. SLIST_FOREACH_SAFE,
#. SLIST_REMOVE_AFTER,
#. SLIST_SWAP
#. type: Plain text
#: build/C/man3/slist.3:52
msgid ""
"SLIST_EMPTY, SLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH, SLIST_HEAD, "
"SLIST_HEAD_INITIALIZER, SLIST_INIT, SLIST_INSERT_AFTER, SLIST_INSERT_HEAD, "
"SLIST_NEXT, SLIST_REMOVE, SLIST_REMOVE_HEAD - implementation of a singly "
"linked list"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:57
#, no-wrap
msgid "B<int SLIST_EMPTY(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:59
#, no-wrap
msgid "B<SLIST_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:61
#, no-wrap
msgid "B<struct TYPE *SLIST_FIRST(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. .PP
#. .BI "SLIST_FOREACH_FROM(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ");"
#. .PP
#. .BI "SLIST_FOREACH_FROM_SAFE(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. .PP
#. .BI "SLIST_FOREACH_SAFE(struct TYPE *" var ", SLIST_HEAD *" head ", SLIST_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/slist.3:69
#, no-wrap
msgid "B<SLIST_FOREACH(struct TYPE *>I<var>B<, SLIST_HEAD *>I<head>B<, SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:71
#, fuzzy, no-wrap
#| msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgid "B<SLIST_HEAD(HEADNAME, TYPE);>\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/slist.3:73
#, no-wrap
msgid "B<SLIST_HEAD SLIST_HEAD_INITIALIZER(SLIST_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:75
#, no-wrap
msgid "B<void SLIST_INIT(SLIST_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:78
#, no-wrap
msgid ""
"B<void SLIST_INSERT_AFTER(struct TYPE *>I<listelm>B<, struct TYPE *>I<elm>B<,>\n"
"B<                SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:81
#, no-wrap
msgid ""
"B<void SLIST_INSERT_HEAD(SLIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:83
#, no-wrap
msgid "B<struct TYPE *SLIST_NEXT(struct TYPE *>I<elm>B<, SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void SLIST_REMOVE_AFTER(struct TYPE *" elm ", SLIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/slist.3:87
#, no-wrap
msgid "B<void SLIST_REMOVE(SLIST_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. .PP
#. .BI "void SLIST_SWAP(SLIST_HEAD *" head1 ", SLIST_HEAD *" head2 ", SLIST_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/slist.3:91
#, no-wrap
msgid "B<void SLIST_REMOVE_HEAD(SLIST_HEAD *>I<head>B<, SLIST_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:107
#, fuzzy
#| msgid ""
#| "In the macro definitions, I<TYPE> is the name of a user-defined "
#| "structure, that must contain a field of type B<LIST_ENTRY>, "
#| "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#| "I<HEADNAME> is the name of a user-defined structure that must be declared "
#| "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#| "the examples below for further explanation of how these macros are used."
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<SLIST_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<SLIST_HEAD>()."
msgstr ""
"マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引数 I<HEADNAME> はユーザー定義構造体の名前であ"
"り、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなけ"
"ればならない。 これらのマクロがどのように使われるかについての更なる説明は、 "
"以下の例を参照すること。"

#. type: Plain text
#: build/C/man3/slist.3:120
#, fuzzy
#| msgid ""
#| "A list is headed by a structure defined by the B<LIST_HEAD> macro.  This "
#| "structure contains a single pointer to the first element on the list.  "
#| "The elements are doubly linked so that an arbitrary element can be "
#| "removed without traversing the list.  New elements can be added to the "
#| "list after an existing element or at the head of the list.  A "
#| "B<LIST_HEAD> structure is declared as follows:"
msgid ""
"A singly linked list is headed by a structure defined by the "
"B<SLIST_HEAD>()  macro.  This structure contains a single pointer to the "
"first element on the list.  The elements are singly linked for minimum space "
"and pointer manipulation overhead at the expense of O(n) removal for "
"arbitrary elements.  New elements can be added to the list after an existing "
"element or at the head of the list.  An I<SLIST_HEAD> structure is declared "
"as follows:"
msgstr ""
"リストの先頭には、 B<LIST_HEAD> マクロで定義される構造体が置かれる。 この構造"
"体はリストの最初の要素へのポインターを 1 つ含む。 要素は 2 重にリンクされてお"
"り、 任意の要素はリストを辿らずに削除できる。 新しい要素は既存の要素の後また"
"はリストの先頭に追加できる。 B<LIST_HEAD> 構造体は以下のように宣言されている:"

#. type: Plain text
#: build/C/man3/slist.3:124
#, fuzzy, no-wrap
#| msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgid "SLIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/slist.3:150
#, fuzzy
#| msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgid ""
"The macro B<SLIST_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"list I<head>."
msgstr "マクロ B<LIST_INIT> は I<head> で参照されるリストを初期化する。"

#. type: Plain text
#: build/C/man3/slist.3:154
#, fuzzy
#| msgid ""
#| "The macro B<LIST_ENTRY> declares a structure that connects the elements "
#| "in the list."
msgid ""
"The macro B<SLIST_EMPTY>()  evaluates to true if there are no elements in "
"the list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/slist.3:159
#, fuzzy
#| msgid ""
#| "The macro B<LIST_ENTRY> declares a structure that connects the elements "
#| "in the list."
msgid ""
"The macro B<SLIST_ENTRY>()  declares a structure that connects the elements "
"in the list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/slist.3:163
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the list."
msgid ""
"The macro B<SLIST_FIRST>()  returns the first element in the list or NULL if "
"the list is empty."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#.  .PP
#.  The macro
#.  .BR SLIST_FOREACH_FROM ()
#.  behaves identically to
#.  .BR SLIST_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found SLIST element and begins the loop at
#.  .I var
#.  instead of the first element in the SLIST referenced by
#.  .IR head .
#.  .Pp
#.  The macro
#.  .BR SLIST_FOREACH_SAFE ()
#.  traverses the list referenced by
#.  .I head
#.  in the forward direction, assigning each element in
#.  turn to
#.  .IR var .
#.  However, unlike
#.  .BR SLIST_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR SLIST_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR SLIST_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found SLIST element and begins the loop at
#.  .I var
#.  instead of the first element in the SLIST referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/slist.3:211
msgid ""
"The macro B<SLIST_FOREACH>()  traverses the list referenced by I<head> in "
"the forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:216
#, fuzzy
#| msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgid "The macro B<SLIST_INIT>()  initializes the list referenced by I<head>."
msgstr "マクロ B<LIST_INIT> は I<head> で参照されるリストを初期化する。"

#. type: Plain text
#: build/C/man3/slist.3:222
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the list."
msgid ""
"The macro B<SLIST_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the list."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#. type: Plain text
#: build/C/man3/slist.3:229
#, fuzzy
#| msgid ""
#| "The macro B<LIST_INSERT_AFTER> inserts the new element I<elm> after the "
#| "element I<listelm>."
msgid ""
"The macro B<SLIST_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<LIST_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#.  .PP
#.  The macro
#.  .BR SLIST_REMOVE_AFTER ()
#.  removes the element after
#.  .I elm
#.  from the list.
#.  Unlike
#.  .IR SLIST_REMOVE ,
#.  this macro does not traverse the entire list.
#. type: Plain text
#: build/C/man3/slist.3:242
#, fuzzy
#| msgid ""
#| "The macro B<LIST_ENTRY> declares a structure that connects the elements "
#| "in the list."
msgid "The macro B<SLIST_NEXT>()  returns the next element in the list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/slist.3:253
msgid ""
"The macro B<SLIST_REMOVE_HEAD>()  removes the element I<elm> from the head "
"of the list.  For optimum efficiency, elements being removed from the head "
"of the list should explicitly use this macro instead of the generic "
"I<SLIST_REMOVE> macro."
msgstr ""

#.  .PP
#.  The macro
#.  .BR SLIST_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/slist.3:266
#, fuzzy
#| msgid "The macro B<LIST_REMOVE> removes the element I<elm> from the list."
msgid "The macro B<SLIST_REMOVE>()  removes the element I<elm> from the list."
msgstr "マクロ B<LIST_REMOVE> は要素 I<elm> をリストから削除する。"

#. type: Plain text
#: build/C/man3/slist.3:270
msgid ""
"B<SLIST_EMPTY>()  returns nonzero if the list is empty, and zero if the list "
"contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:277
msgid ""
"B<SLIST_FIRST>(), and B<SLIST_NEXT>()  return a pointer to the first or next "
"I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:281
msgid ""
"B<SLIST_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the list I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:285
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (SLIST "
"macros first appeared in 4.4BSD)."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: Plain text
#: build/C/man3/slist.3:299
msgid ""
"The macro B<SLIST_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<SLIST_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:310
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    SLIST_ENTRY(entry) entries;             /* Singly linked List. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:312
#, no-wrap
msgid "SLIST_HEAD(slisthead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:319
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct slisthead head;                  /* Singly linked List\n"
"                                               head. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:321
#, fuzzy, no-wrap
#| msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgid "    SLIST_INIT(&head);                      /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/slist.3:324
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "LIST_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    SLIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/slist.3:327
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    SLIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/slist.3:330
#, no-wrap
msgid ""
"    SLIST_REMOVE(&head, n2, entry, entries);/* Deletion. */\n"
"    free(n2);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:334
#, no-wrap
msgid ""
"    n3 = SLIST_FIRST(&head);\n"
"    SLIST_REMOVE_HEAD(&head, entries);      /* Deletion from the head. */\n"
"    free(n3);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:340
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "LIST_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    for (int i = 0; i E<lt> 5; i++) {\n"
"        n1 = malloc(sizeof(struct entry));\n"
"        SLIST_INSERT_HEAD(&head, n1, entries);\n"
"        n1-E<gt>data = i;\n"
"    }\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/slist.3:344
#, no-wrap
msgid ""
"                                            /* Forward traversal. */\n"
"    SLIST_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/slist.3:351
#, no-wrap
msgid ""
"    while (!SLIST_EMPTY(&head)) {           /* List Deletion. */\n"
"        n1 = SLIST_FIRST(&head);\n"
"        SLIST_REMOVE_HEAD(&head, entries);\n"
"        free(n1);\n"
"    }\n"
"    SLIST_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/stailq.3:32
#, no-wrap
msgid "STAILQ"
msgstr ""

#. STAILQ_FOREACH_FROM,
#. STAILQ_FOREACH_FROM_SAFE,
#. STAILQ_FOREACH_SAFE,
#. STAILQ_LAST,
#. STAILQ_REMOVE_AFTER,
#. STAILQ_SWAP
#. type: Plain text
#: build/C/man3/stailq.3:55
msgid ""
"STAILQ_CONCAT, STAILQ_EMPTY, STAILQ_ENTRY, STAILQ_FIRST, STAILQ_FOREACH, "
"STAILQ_HEAD, STAILQ_HEAD_INITIALIZER, STAILQ_INIT, STAILQ_INSERT_AFTER, "
"STAILQ_INSERT_HEAD, STAILQ_INSERT_TAIL, STAILQ_NEXT, STAILQ_REMOVE, "
"STAILQ_REMOVE_HEAD, - implementation of a singly linked tail queue"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:60
#, no-wrap
msgid "B<void STAILQ_CONCAT(STAILQ_HEAD *>I<head1>B<, STAILQ_HEAD *>I<head2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:62
#, no-wrap
msgid "B<int STAILQ_EMPTY(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:64
#, no-wrap
msgid "B<STAILQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:66
#, no-wrap
msgid "B<struct TYPE *STAILQ_FIRST(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "STAILQ_FOREACH_FROM(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "STAILQ_FOREACH_FROM_SAFE(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#.  .PP
#.  .BI "STAILQ_FOREACH_SAFE(struct TYPE *" var ", STAILQ_HEAD *" head ", STAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/stailq.3:74
#, no-wrap
msgid "B<STAILQ_FOREACH(struct TYPE *>I<var>B<, STAILQ_HEAD *>I<head>B<, STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:76
#, fuzzy, no-wrap
#| msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgid "B<STAILQ_HEAD(HEADNAME, TYPE);>\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/stailq.3:78
#, no-wrap
msgid "B<STAILQ_HEAD STAILQ_HEAD_INITIALIZER(STAILQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:80
#, no-wrap
msgid "B<void STAILQ_INIT(STAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:83
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_AFTER(STAILQ_HEAD *>I<head>B<, struct TYPE *>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:86
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_HEAD(STAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "struct TYPE *STAILQ_LAST(STAILQ_HEAD *" head ", struct TYPE *" elm ", STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:91
#, no-wrap
msgid ""
"B<void STAILQ_INSERT_TAIL(STAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:93
#, no-wrap
msgid "B<struct TYPE *STAILQ_NEXT(struct TYPE *>I<elm>B<, STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void STAILQ_REMOVE_AFTER(STAILQ_HEAD *" head ", struct TYPE *" elm ","
#.  .BI "                STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:99
#, no-wrap
msgid ""
"B<void STAILQ_REMOVE(STAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, TYPE,>\n"
"B<                STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void STAILQ_SWAP(STAILQ_HEAD *" head1 ", STAILQ_HEAD *" head2 ","
#.  .BI "                STAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/stailq.3:104
#, no-wrap
msgid "B<void STAILQ_REMOVE_HEAD(STAILQ_HEAD *>I<head>B<, STAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:107
msgid "These macros define and operate on singly linked tail queues."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:120
#, fuzzy
#| msgid ""
#| "In the macro definitions, I<TYPE> is the name of a user-defined "
#| "structure, that must contain a field of type B<LIST_ENTRY>, "
#| "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#| "I<HEADNAME> is the name of a user-defined structure that must be declared "
#| "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#| "the examples below for further explanation of how these macros are used."
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type I<STAILQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user-defined structure that must be "
"declared using the macro B<STAILQ_HEAD>()."
msgstr ""
"マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引数 I<HEADNAME> はユーザー定義構造体の名前であ"
"り、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなけ"
"ればならない。 これらのマクロがどのように使われるかについての更なる説明は、 "
"以下の例を参照すること。"

#. type: Plain text
#: build/C/man3/stailq.3:135
#, fuzzy
#| msgid ""
#| "A tail queue is headed by a structure defined by the B<TAILQ_HEAD> "
#| "macro.  This structure contains a pair of pointers, one to the first "
#| "element in the tail queue and the other to the last element in the tail "
#| "queue.  The elements are doubly linked so that an arbitrary element can "
#| "be removed without traversing the tail queue.  New elements can be added "
#| "to the tail queue after an existing element, at the head of the tail "
#| "queue, or at the end of the tail queue.  A B<TAILQ_HEAD> structure is "
#| "declared as follows:"
msgid ""
"A singly linked tail queue is headed by a structure defined by the "
"B<STAILQ_HEAD>()  macro.  This structure contains a pair of pointers, one to "
"the first element in the tail queue and the other to the last element in the "
"tail queue.  The elements are singly linked for minimum space and pointer "
"manipulation overhead at the expense of O(n) removal for arbitrary "
"elements.  New elements can be added to the tail queue after an existing "
"element, at the head of the tail queue, or at the end of the tail queue.  A "
"I<STAILQ_HEAD> structure is declared as follows:"
msgstr ""
"テールキューの先頭には B<TAILQ_HEAD> マクロで定義される構造体が置かれる。 こ"
"の構造体は 1 組のポインターを含んでいる。 1 つはテールキューの最初の要素への"
"ポインターであり、 もう 1 つはテールキューの最後の要素へのポインターである。 "
"要素は 2 重にリンクされており、 任意の要素はテールキューを辿らずに削除でき"
"る。 新しい要素は既存の要素の後またはテールキューの先頭または末尾に追加でき"
"る。 B<TAILQ_HEAD> 構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/stailq.3:139
#, fuzzy, no-wrap
#| msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgid "STAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/stailq.3:148 build/C/man3/tailq.3:160
#, fuzzy
#| msgid ""
#| "where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> "
#| "is the type of the elements to be linked into the tail queue.  A pointer "
#| "to the head of the tail queue can later be declared as:"
msgid ""
"where I<struct HEADNAME> is the structure to be defined, and I<struct TYPE> "
"is the type of the elements to be linked into the tail queue.  A pointer to "
"the head of the tail queue can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> はテールキュー内"
"でリンクされる要素の型である。 テールキューの先頭へのポインターは、その後で次"
"のように宣言される:"

#. type: Plain text
#: build/C/man3/stailq.3:165
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgid ""
"The macro B<STAILQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"tail queue I<head>."
msgstr "マクロ B<TAILQ_INIT> は I<head> で参照されるテールキューを初期化する。"

#. type: Plain text
#: build/C/man3/stailq.3:173
msgid ""
"The macro B<STAILQ_CONCAT>()  concatenates the tail queue headed by I<head2> "
"onto the end of the one headed by I<head1> removing all entries from the "
"former."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:177
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_ENTRY> declares a structure that connects the elements "
#| "in the tail queue."
msgid ""
"The macro B<STAILQ_EMPTY>()  evaluates to true if there are no items on the "
"tail queue."
msgstr "マクロ B<TAILQ_ENTRY> はテールキューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/stailq.3:182
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_ENTRY> declares a structure that connects the elements "
#| "in the tail queue."
msgid ""
"The macro B<STAILQ_ENTRY>()  declares a structure that connects the elements "
"in the tail queue."
msgstr "マクロ B<TAILQ_ENTRY> はテールキューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/stailq.3:187
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end "
#| "of the tail queue."
msgid ""
"The macro B<STAILQ_FIRST>()  returns the first item on the tail queue or "
"NULL if the tail queue is empty."
msgstr ""
"マクロ B<TAILQ_INSERT_TAIL> は新たな要素 I<elm> をテールキューの末尾に挿入す"
"る。"

#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_FROM ()
#.  behaves identically to
#.  .BR STAILQ_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found STAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the STAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_SAFE ()
#.  traverses the tail queue referenced by
#.  .I head
#.  in the forward direction, assigning each element
#.  in turn to
#.  .IR var .
#.  However, unlike
#.  .BR STAILQ_FOREACH ()
#.  here it is permitted to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR STAILQ_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR STAILQ_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found STAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the STAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/stailq.3:235
msgid ""
"The macro B<STAILQ_FOREACH>()  traverses the tail queue referenced by "
"I<head> in the forward direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:240
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgid ""
"The macro B<STAILQ_INIT>()  initializes the tail queue referenced by I<head>."
msgstr "マクロ B<TAILQ_INIT> は I<head> で参照されるテールキューを初期化する。"

#. type: Plain text
#: build/C/man3/stailq.3:246
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the tail queue."
msgid ""
"The macro B<STAILQ_INSERT_HEAD>()  inserts the new element I<elm> at the "
"head of the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_HEAD> は新たな要素 I<elm> をテールキューの先頭に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/stailq.3:252
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end "
#| "of the tail queue."
msgid ""
"The macro B<STAILQ_INSERT_TAIL>()  inserts the new element I<elm> at the end "
"of the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_TAIL> は新たな要素 I<elm> をテールキューの末尾に挿入す"
"る。"

#.  .PP
#.  The macro
#.  .BR STAILQ_LAST ()
#.  returns the last item on the tail queue.
#.  If the tail queue is empty the return value is NULL .
#. type: Plain text
#: build/C/man3/stailq.3:264
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_AFTER> inserts the new element I<elm> after the "
#| "element I<listelm>."
msgid ""
"The macro B<STAILQ_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<TAILQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#.  .PP
#.  The macro
#.  .BR STAILQ_REMOVE_AFTER ()
#.  removes the element after
#.  .I elm
#.  from the tail queue.
#.  Unlike
#.  .BR STAILQ_REMOVE (),
#.  this macro does not traverse the entire tail queue.
#. type: Plain text
#: build/C/man3/stailq.3:277
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_REMOVE> removes the element I<elm> from the tail queue."
msgid ""
"The macro B<STAILQ_NEXT>()  returns the next item on the tail queue, or NULL "
"this item is the last."
msgstr "マクロ B<TAILQ_REMOVE> は要素 I<elm> をテールキューから削除する。"

#. type: Plain text
#: build/C/man3/stailq.3:286
msgid ""
"The macro B<STAILQ_REMOVE_HEAD>()  removes the element at the head of the "
"tail queue.  For optimum efficiency, elements being removed from the head of "
"the tail queue should use this macro explicitly rather than the generic "
"B<STAILQ_REMOVE>()  macro."
msgstr ""

#.  .PP
#.  The macro
#.  .BR STAILQ_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/stailq.3:299
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_REMOVE> removes the element I<elm> from the tail queue."
msgid ""
"The macro B<STAILQ_REMOVE>()  removes the element I<elm> from the tail queue."
msgstr "マクロ B<TAILQ_REMOVE> は要素 I<elm> をテールキューから削除する。"

#. type: Plain text
#: build/C/man3/stailq.3:303
msgid ""
"B<STAILQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:310
msgid ""
"B<STAILQ_FIRST>(), and B<STAILQ_NEXT>()  return a pointer to the first or "
"next I<TYPE> structure, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:314
msgid ""
"B<STAILQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:318
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs (STAILQ "
"macros first appeared in 4.4BSD)."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: Plain text
#: build/C/man3/stailq.3:332
msgid ""
"The macro B<STAILQ_FOREACH>()  doesn't allow I<var> to be removed or freed "
"within the loop, as it would interfere with the traversal.  The macro "
"B<STAILQ_FOREACH_SAFE>(), which is present on the BSDs but is not present in "
"glibc, fixes this limitation by allowing I<var> to safely be removed from "
"the list and freed from within the loop without interfering with the "
"traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:343
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    STAILQ_ENTRY(entry) entries;        /* Singly linked tail queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:345
#, no-wrap
msgid "STAILQ_HEAD(stailhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:352
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct stailhead head;              /* Singly linked tail queue\n"
"                                           head. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:354
#, fuzzy, no-wrap
#| msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgid "    STAILQ_INIT(&head);                 /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/stailq.3:357
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));  /* Insert at the head. */\n"
"    STAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/stailq.3:360
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
#| "TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));  /* Insert at the tail. */\n"
"    STAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/stailq.3:363
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
"    STAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/stailq.3:366
#, no-wrap
msgid ""
"    STAILQ_REMOVE(&head, n2, entry, entries);/* Deletion. */\n"
"    free(n2);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:370
#, no-wrap
msgid ""
"    n3 = STAILQ_FIRST(&head);\n"
"    STAILQ_REMOVE_HEAD(&head, entries); /* Deletion from the head. */\n"
"    free(n3);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stailq.3:389
#, no-wrap
msgid ""
"    n1 = STAILQ_FIRST(&head);\n"
"    n1-E<gt>data = 0;\n"
"    for (int i = 1; i E<lt> 5; i++) {\n"
"        n1 = malloc(sizeof(struct entry));\n"
"        STAILQ_INSERT_HEAD(&head, n1, entries);\n"
"        n1-E<gt>data = i;\n"
"    }\n"
"                                        /* Forward traversal. */\n"
"    STAILQ_FOREACH(np, &head, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                        /* TailQ Deletion. */\n"
"    n1 = STAILQ_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = STAILQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    STAILQ_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man3/tailq.3:32
#, no-wrap
msgid "TAILQ"
msgstr ""

#. TAILQ_FOREACH_FROM,
#. TAILQ_FOREACH_FROM_SAFE,
#. TAILQ_FOREACH_REVERSE_FROM,
#. TAILQ_FOREACH_REVERSE_FROM_SAFE,
#. TAILQ_FOREACH_REVERSE_SAFE,
#. TAILQ_FOREACH_SAFE,
#. TAILQ_SWAP
#. type: Plain text
#: build/C/man3/tailq.3:59
#, fuzzy
#| msgid ""
#| "LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
#| "LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
#| "TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
#| "CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
#| "CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - "
#| "implementations of lists, tail queues, and circular queues"
msgid ""
"TAILQ_CONCAT, TAILQ_EMPTY, TAILQ_ENTRY, TAILQ_FIRST, TAILQ_FOREACH, "
"TAILQ_FOREACH_REVERSE, TAILQ_HEAD, TAILQ_HEAD_INITIALIZER, TAILQ_INIT, "
"TAILQ_INSERT_AFTER, TAILQ_INSERT_BEFORE, TAILQ_INSERT_HEAD, "
"TAILQ_INSERT_TAIL, TAILQ_LAST, TAILQ_NEXT, TAILQ_PREV, TAILQ_REMOVE - "
"implementation of a doubly linked tail queue"
msgstr ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - リスト・テール "
"(tail) キュー・循環キューの実装"

#. type: Plain text
#: build/C/man3/tailq.3:65
#, no-wrap
msgid ""
"B<void TAILQ_CONCAT(TAILQ_HEAD *>I<head1>B<, TAILQ_HEAD *>I<head2>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:67
#, no-wrap
msgid "B<int TAILQ_EMPTY(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:69
#, no-wrap
msgid "B<TAILQ_ENTRY(TYPE);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:71
#, no-wrap
msgid "B<struct TYPE *TAILQ_FIRST(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "TAILQ_FOREACH_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/tailq.3:77
#, no-wrap
msgid "B<TAILQ_FOREACH(struct TYPE *>I<var>B<, TAILQ_HEAD *>I<head>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_REVERSE_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME, TAILQ_ENTRY " NAME ", TYPE *" temp_var ");"
#.  .PP
#.  .BI "TAILQ_FOREACH_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ", TAILQ_ENTRY " NAME ", struct TYPE *" temp_var ");"
#. type: Plain text
#: build/C/man3/tailq.3:88
#, no-wrap
msgid ""
"B<TAILQ_FOREACH_REVERSE(struct TYPE *>I<var>B<, TAILQ_HEAD *>I<head>B<, HEADNAME,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:90
#, fuzzy, no-wrap
#| msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgid "B<TAILQ_HEAD(HEADNAME, TYPE);>\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/tailq.3:92
#, no-wrap
msgid "B<TAILQ_HEAD TAILQ_HEAD_INITIALIZER(TAILQ_HEAD >I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:94
#, no-wrap
msgid "B<void TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:97
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<listelm>B<,>\n"
"B<                struct TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:100
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_BEFORE(struct TYPE *>I<listelm>B<, struct TYPE *>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:103
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:106
#, no-wrap
msgid ""
"B<void TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<,>\n"
"B<                TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:108
#, no-wrap
msgid "B<struct TYPE *TAILQ_LAST(TAILQ_HEAD *>I<head>B<, HEADNAME);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:110
#, no-wrap
msgid "B<struct TYPE *TAILQ_NEXT(struct TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:112
#, no-wrap
msgid "B<struct TYPE *TAILQ_PREV(struct TYPE *>I<elm>B<, HEADNAME, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#.  .PP
#.  .BI "void TAILQ_SWAP(TAILQ_HEAD *" head1 ", TAILQ_HEAD *" head2 ", TYPE, TAILQ_ENTRY " NAME ");"
#. type: Plain text
#: build/C/man3/tailq.3:116
#, no-wrap
msgid "B<void TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, struct TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:119
msgid "These macros define and operate on doubly linked tail queues."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:132
#, fuzzy
#| msgid ""
#| "In the macro definitions, I<TYPE> is the name of a user-defined "
#| "structure, that must contain a field of type B<LIST_ENTRY>, "
#| "B<TAILQ_ENTRY>, or B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument "
#| "I<HEADNAME> is the name of a user-defined structure that must be declared "
#| "using the macros B<LIST_HEAD>, B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See "
#| "the examples below for further explanation of how these macros are used."
msgid ""
"In the macro definitions, I<TYPE> is the name of a user defined structure, "
"that must contain a field of type I<TAILQ_ENTRY>, named I<NAME>.  The "
"argument I<HEADNAME> is the name of a user defined structure that must be "
"declared using the macro B<TAILQ_HEAD>()."
msgstr ""
"マクロ定義において I<TYPE> はユーザー定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引数 I<HEADNAME> はユーザー定義構造体の名前であ"
"り、 マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなけ"
"ればならない。 これらのマクロがどのように使われるかについての更なる説明は、 "
"以下の例を参照すること。"

#. type: Plain text
#: build/C/man3/tailq.3:147
#, fuzzy
#| msgid ""
#| "A tail queue is headed by a structure defined by the B<TAILQ_HEAD> "
#| "macro.  This structure contains a pair of pointers, one to the first "
#| "element in the tail queue and the other to the last element in the tail "
#| "queue.  The elements are doubly linked so that an arbitrary element can "
#| "be removed without traversing the tail queue.  New elements can be added "
#| "to the tail queue after an existing element, at the head of the tail "
#| "queue, or at the end of the tail queue.  A B<TAILQ_HEAD> structure is "
#| "declared as follows:"
msgid ""
"A tail queue is headed by a structure defined by the B<TAILQ_HEAD>()  "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the tail queue and the other to the last element in the tail queue.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the tail queue.  New elements can be added to the tail "
"queue after an existing element, before an existing element, at the head of "
"the tail queue, or at the end of the tail queue.  A I<TAILQ_HEAD> structure "
"is declared as follows:"
msgstr ""
"テールキューの先頭には B<TAILQ_HEAD> マクロで定義される構造体が置かれる。 こ"
"の構造体は 1 組のポインターを含んでいる。 1 つはテールキューの最初の要素への"
"ポインターであり、 もう 1 つはテールキューの最後の要素へのポインターである。 "
"要素は 2 重にリンクされており、 任意の要素はテールキューを辿らずに削除でき"
"る。 新しい要素は既存の要素の後またはテールキューの先頭または末尾に追加でき"
"る。 B<TAILQ_HEAD> 構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/tailq.3:151
#, no-wrap
msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/tailq.3:177
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgid ""
"The macro B<TAILQ_HEAD_INITIALIZER>()  evaluates to an initializer for the "
"tail queue I<head>."
msgstr "マクロ B<TAILQ_INIT> は I<head> で参照されるテールキューを初期化する。"

#. type: Plain text
#: build/C/man3/tailq.3:185
msgid ""
"The macro B<TAILQ_CONCAT>()  concatenates the tail queue headed by I<head2> "
"onto the end of the one headed by I<head1> removing all entries from the "
"former."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:189
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_ENTRY> declares a structure that connects the elements "
#| "in the tail queue."
msgid ""
"The macro B<TAILQ_EMPTY>()  evaluates to true if there are no items on the "
"tail queue."
msgstr "マクロ B<TAILQ_ENTRY> はテールキューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/tailq.3:194
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_ENTRY> declares a structure that connects the elements "
#| "in the tail queue."
msgid ""
"The macro B<TAILQ_ENTRY>()  declares a structure that connects the elements "
"in the tail queue."
msgstr "マクロ B<TAILQ_ENTRY> はテールキューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/tailq.3:199
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end "
#| "of the tail queue."
msgid ""
"The macro B<TAILQ_FIRST>()  returns the first item on the tail queue or NULL "
"if the tail queue is empty."
msgstr ""
"マクロ B<TAILQ_INSERT_TAIL> は新たな要素 I<elm> をテールキューの末尾に挿入す"
"る。"

#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_FROM ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the TAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/tailq.3:222
msgid ""
"The macro B<TAILQ_FOREACH>()  traverses the tail queue referenced by I<head> "
"in the forward direction, assigning each element in turn to I<var>.  I<var> "
"is set to NULL if the loop completes normally, or if there were no elements."
msgstr ""

#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_REVERSE_FROM ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_REVERSE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .I var
#.  instead of the last element in the TAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macros
#.  .BR TAILQ_FOREACH_SAFE ()
#.  and
#.  .BR TAILQ_FOREACH_REVERSE_SAFE ()
#.  traverse the list referenced by
#.  .I head
#.  in the forward or reverse direction respectively,
#.  assigning each element in turn to
#.  .IR var .
#.  However, unlike their unsafe counterparts,
#.  .BR TAILQ_FOREACH ()
#.  and
#.  .BR TAILQ_FOREACH_REVERSE ()
#.  permit to both remove
#.  .I var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_FROM_SAFE ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the loop at
#.  .I var
#.  instead of the first element in the TAILQ referenced by
#.  .IR head .
#.  .PP
#.  The macro
#.  .BR TAILQ_FOREACH_REVERSE_FROM_SAFE ()
#.  behaves identically to
#.  .BR TAILQ_FOREACH_REVERSE_SAFE ()
#.  when
#.  .I var
#.  is NULL, else it treats
#.  .I var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .I var
#.  instead of the last element in the TAILQ referenced by
#.  .IR head .
#. type: Plain text
#: build/C/man3/tailq.3:286
msgid ""
"The macro B<TAILQ_FOREACH_REVERSE>()  traverses the tail queue referenced by "
"I<head> in the reverse direction, assigning each element in turn to I<var>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:291
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgid ""
"The macro B<TAILQ_INIT>()  initializes the tail queue referenced by I<head>."
msgstr "マクロ B<TAILQ_INIT> は I<head> で参照されるテールキューを初期化する。"

#. type: Plain text
#: build/C/man3/tailq.3:297
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_HEAD> inserts the new element I<elm> at the head "
#| "of the tail queue."
msgid ""
"The macro B<TAILQ_INSERT_HEAD>()  inserts the new element I<elm> at the head "
"of the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_HEAD> は新たな要素 I<elm> をテールキューの先頭に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/tailq.3:303
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end "
#| "of the tail queue."
msgid ""
"The macro B<TAILQ_INSERT_TAIL>()  inserts the new element I<elm> at the end "
"of the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_TAIL> は新たな要素 I<elm> をテールキューの末尾に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/tailq.3:310
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_INSERT_AFTER> inserts the new element I<elm> after the "
#| "element I<listelm>."
msgid ""
"The macro B<TAILQ_INSERT_AFTER>()  inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<TAILQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#. type: Plain text
#: build/C/man3/tailq.3:317
#, fuzzy
#| msgid ""
#| "The macro B<CIRCLEQ_INSERT_BEFORE> inserts the new element I<elm> before "
#| "the element I<listelm>."
msgid ""
"The macro B<TAILQ_INSERT_BEFORE>()  inserts the new element I<elm> before "
"the element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の前に挿"
"入する。"

#. type: Plain text
#: build/C/man3/tailq.3:322
msgid ""
"The macro B<TAILQ_LAST>()  returns the last item on the tail queue.  If the "
"tail queue is empty the return value is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:326
msgid ""
"The macro B<TAILQ_NEXT>()  returns the next item on the tail queue, or NULL "
"if this item is the last."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:331
msgid ""
"The macro B<TAILQ_PREV>()  returns the previous item on the tail queue, or "
"NULL if this item is the first."
msgstr ""

#.  .PP
#.  The macro
#.  .BR TAILQ_SWAP ()
#.  swaps the contents of
#.  .I head1
#.  and
#.  .IR head2 .
#. type: Plain text
#: build/C/man3/tailq.3:344
#, fuzzy
#| msgid ""
#| "The macro B<TAILQ_REMOVE> removes the element I<elm> from the tail queue."
msgid ""
"The macro B<TAILQ_REMOVE>()  removes the element I<elm> from the tail queue."
msgstr "マクロ B<TAILQ_REMOVE> は要素 I<elm> をテールキューから削除する。"

#. type: Plain text
#: build/C/man3/tailq.3:348
msgid ""
"B<TAILQ_EMPTY>()  returns nonzero if the queue is empty, and zero if the "
"queue contains at least one entry."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:357
msgid ""
"B<TAILQ_FIRST>(), B<TAILQ_LAST>(), B<TAILQ_NEXT>(), and B<TAILQ_PREV>()  "
"return a pointer to the first, last, next or previous I<TYPE> structure, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:361
msgid ""
"B<TAILQ_HEAD_INITIALIZER>()  returns an initializer that can be assigned to "
"the queue I<head>."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:365
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.  (TAILQ "
"functions first appeared in 4.4BSD)."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: Plain text
#: build/C/man3/tailq.3:383
msgid ""
"The macros B<TAILQ_FOREACH>()  and B<TAILQ_FOREACH_REVERSE>()  don't allow "
"I<var> to be removed or freed within the loop, as it would interfere with "
"the traversal.  The macros B<TAILQ_FOREACH_SAFE>()  and "
"B<TAILQ_FOREACH_REVERSE_SAFE>(), which are present on the BSDs but are not "
"present in glibc, fix this limitation by allowing I<var> to safely be "
"removed from the list and freed from within the loop without interfering "
"with the traversal."
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:394
#, no-wrap
msgid ""
"struct entry {\n"
"    int data;\n"
"    TAILQ_ENTRY(entry) entries;             /* Tail queue. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:396
#, no-wrap
msgid "TAILQ_HEAD(tailhead, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:403
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct entry *n1, *n2, *n3, *np;\n"
"    struct tailhead head;                   /* Tail queue head. */\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tailq.3:405
#, fuzzy, no-wrap
#| msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgid "    TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/tailq.3:408
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"    TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/tailq.3:411
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
#| "TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgid ""
"    n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"    TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/tailq.3:414
#, fuzzy, no-wrap
#| msgid ""
#| "n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
#| "CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgid ""
"    n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"    TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/tailq.3:417
#, fuzzy, no-wrap
#| msgid ""
#| "n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
#| "TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgid ""
"    n3 = malloc(sizeof(struct entry));      /* Insert before. */\n"
"    TAILQ_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/tailq.3:435
#, no-wrap
msgid ""
"    TAILQ_REMOVE(&head, n2, entries);       /* Deletion. */\n"
"    free(n2);\n"
"                                            /* Forward traversal. */\n"
"    i = 0;\n"
"    TAILQ_FOREACH(np, &head, entries)\n"
"        np-E<gt>data = i++;\n"
"                                            /* Reverse traversal. */\n"
"    TAILQ_FOREACH_REVERSE(np, &head, tailhead, entries)\n"
"        printf(\"%i\\en\", np-E<gt>data);\n"
"                                            /* TailQ Deletion. */\n"
"    n1 = TAILQ_FIRST(&head);\n"
"    while (n1 != NULL) {\n"
"        n2 = TAILQ_NEXT(n1, entries);\n"
"        free(n1);\n"
"        n1 = n2;\n"
"    }\n"
"    TAILQ_INIT(&head);\n"
msgstr ""

#. type: TH
#: build/C/man7/queue.7:32
#, no-wrap
msgid "QUEUE"
msgstr "QUEUE"

#. type: TH
#: build/C/man7/queue.7:32
#, no-wrap
msgid "2020-11-16"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:35
msgid "queue - implementations of linked lists and queues"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:40
msgid ""
"The I<E<lt>sys/queue.hE<gt>> header file provides a set of macros that "
"define and operate on the following data structures:"
msgstr ""

#. type: IP
#: build/C/man7/queue.7:40 build/C/man7/queue.7:42 build/C/man7/queue.7:44
#: build/C/man7/queue.7:46 build/C/man7/queue.7:48 build/C/man7/queue.7:52
#: build/C/man7/queue.7:54 build/C/man7/queue.7:56 build/C/man7/queue.7:58
#: build/C/man7/queue.7:73 build/C/man7/queue.7:77 build/C/man7/queue.7:79
#: build/C/man7/queue.7:81 build/C/man7/queue.7:85 build/C/man7/queue.7:87
#: build/C/man7/queue.7:96 build/C/man7/queue.7:98 build/C/man7/queue.7:102
#: build/C/man7/queue.7:107 build/C/man7/queue.7:111 build/C/man7/queue.7:116
#: build/C/man7/queue.7:118 build/C/man7/queue.7:120 build/C/man7/queue.7:124
#: build/C/man7/queue.7:126 build/C/man7/queue.7:130 build/C/man7/queue.7:134
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/queue.7:42
msgid "singly linked lists (SLIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:44
msgid "doubly linked lists (LIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:46
msgid "singly linked tail queues (STAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:48
msgid "doubly linked tail queues (TAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:50
msgid "doubly linked circular queues (CIRCLEQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:52
#, fuzzy
#| msgid "Tail queues add the following functionality:"
msgid "All structures support the following functionality:"
msgstr "テールキューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man7/queue.7:54
msgid "Insertion of a new entry at the head of the list."
msgstr "新たなエントリーをリストの先頭に挿入する。"

#. type: Plain text
#: build/C/man7/queue.7:56
msgid "Insertion of a new entry after any element in the list."
msgstr "新たなエントリーをリストのどの要素よりも後に挿入する。"

#. type: Plain text
#: build/C/man7/queue.7:58
#, fuzzy
#| msgid "Insertion of a new entry at the head of the list."
msgid "O(1) removal of an entry from the head of the list."
msgstr "新たなエントリーをリストの先頭に挿入する。"

#. .IP *
#.  Swapping the contents of two lists.
#. type: Plain text
#: build/C/man7/queue.7:62
msgid "Forward traversal through the list."
msgstr "リストを順方向に辿る。"

#. type: Plain text
#: build/C/man7/queue.7:66
msgid ""
"Code size and execution time depend on the complexity of the data structure "
"being used, so programmers should take care to choose the appropriate one."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:66
#, no-wrap
msgid "Singly linked lists (SLIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:73
msgid ""
"Singly linked lists are the simplest and support only the above "
"functionality.  Singly linked lists are ideal for applications with large "
"datasets and few or no removals, or for implementing a LIFO queue.  Singly "
"linked lists add the following functionality:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:75 build/C/man7/queue.7:81
#, fuzzy
#| msgid "Removal of any entry in the list."
msgid "O(n) removal of any entry in the list."
msgstr "リストの任意のエントリーを削除する。"

#. type: SS
#: build/C/man7/queue.7:75
#, no-wrap
msgid "Singly linked tail queues (STAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:77
#, fuzzy
#| msgid "Tail queues add the following functionality:"
msgid "Singly linked tail queues add the following functionality:"
msgstr "テールキューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man7/queue.7:79 build/C/man7/queue.7:118
msgid "Entries can be added at the end of a list."
msgstr "エントリーをリストの最後に追加できる。"

#. type: Plain text
#: build/C/man7/queue.7:83 build/C/man7/queue.7:122
msgid "They may be concatenated."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:85 build/C/man7/queue.7:102 build/C/man7/queue.7:111
#: build/C/man7/queue.7:124 build/C/man7/queue.7:134
msgid "However:"
msgstr "ただし:"

#. type: Plain text
#: build/C/man7/queue.7:87
#, fuzzy
#| msgid "All list insertions and removals must specify the head of the list."
msgid "All list insertions must specify the head of the list."
msgstr "全てのリスト挿入と削除において、リストの先頭を指定しなければならない。"

#. type: Plain text
#: build/C/man7/queue.7:89 build/C/man7/queue.7:128
msgid "Each head entry requires two pointers rather than one."
msgstr "各先頭エントリーは 1 つではなく 2 つのポインターを必要とする。"

#. type: Plain text
#: build/C/man7/queue.7:93
msgid ""
"Singly linked tail queues are ideal for applications with large datasets and "
"few or no removals, or for implementing a FIFO queue."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:93
#, no-wrap
msgid "Doubly linked data structures"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:96
msgid ""
"All doubly linked types of data structures (lists and tail queues)  "
"additionally allow:"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:98
#, fuzzy
#| msgid "Insertion of a new entry after any element in the list."
msgid "Insertion of a new entry before any element in the list."
msgstr "新たなエントリーをリストのどの要素よりも後に挿入する。"

#. type: Plain text
#: build/C/man7/queue.7:100
#, fuzzy
#| msgid "Removal of any entry in the list."
msgid "O(1) removal of any entry in the list."
msgstr "リストの任意のエントリーを削除する。"

#. type: Plain text
#: build/C/man7/queue.7:104
#, fuzzy
#| msgid "Each head entry requires two pointers rather than one."
msgid "Each element requires two pointers rather than one."
msgstr "各先頭エントリーは 1 つではなく 2 つのポインターを必要とする。"

#. type: SS
#: build/C/man7/queue.7:104
#, no-wrap
msgid "Doubly linked lists (LIST)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:107
#, fuzzy
#| msgid ""
#| "Lists are the simplest of the three data structures and support only the "
#| "above functionality."
msgid ""
"Linked lists are the simplest of the doubly linked data structures.  They "
"add the following functionality over the above:"
msgstr ""
"リストは 3 つのデータ構造の中で最も単純であり、 上記の機能のみをサポートす"
"る。"

#. type: Plain text
#: build/C/man7/queue.7:109
#, fuzzy
#| msgid "They may be traversed backward, from tail to head."
msgid "They may be traversed backwards."
msgstr "逆方向に末尾から先頭へ辿ることができる。"

#. type: Plain text
#: build/C/man7/queue.7:114
msgid ""
"To traverse backwards, an entry to begin the traversal and the list in which "
"it is contained must be specified."
msgstr ""

#. type: SS
#: build/C/man7/queue.7:114
#, no-wrap
msgid "Doubly linked tail queues (TAILQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:116
msgid "Tail queues add the following functionality:"
msgstr "テールキューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man7/queue.7:120
#, fuzzy
#| msgid "They may be traversed backward, from tail to head."
msgid "They may be traversed backwards, from tail to head."
msgstr "逆方向に末尾から先頭へ辿ることができる。"

#. type: Plain text
#: build/C/man7/queue.7:126
msgid "All list insertions and removals must specify the head of the list."
msgstr "全てのリスト挿入と削除において、リストの先頭を指定しなければならない。"

#. type: SS
#: build/C/man7/queue.7:128
#, no-wrap
msgid "Doubly linked circular queues (CIRCLEQ)"
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:130
#, fuzzy
#| msgid "Circular queues add the following functionality:"
msgid "Circular queues add the following functionality over the above:"
msgstr "循環キューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man7/queue.7:132
msgid "The first and last entries are connected."
msgstr ""

#. type: Plain text
#: build/C/man7/queue.7:136
msgid "The termination condition for traversal is more complex."
msgstr "辿る際の終了条件がより複雑である。"

#. type: Plain text
#: build/C/man7/queue.7:141
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
#| "appeared in 4.4BSD."
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.  "
"I<E<lt>sys/queue.hE<gt>> macros first appeared in 4.4BSD."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#.  .BR tree (3)
#. type: Plain text
#: build/C/man7/queue.7:149
msgid ""
"B<circleq>(3), B<insque>(3), B<list>(3), B<slist>(3), B<stailq>(3), "
"B<tailq>(3)"
msgstr ""

#~ msgid "2014-08-19"
#~ msgstr "2014-08-19"

#~ msgid ""
#~ "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"
#~ msgstr ""
#~ "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"

#~ msgid ""
#~ "static struct element *\n"
#~ "new_element(void)\n"
#~ "{\n"
#~ "    struct element *e;\n"
#~ msgstr ""
#~ "static struct element *\n"
#~ "new_element(void)\n"
#~ "{\n"
#~ "    struct element *e;\n"

#~ msgid "Linux"
#~ msgstr "Linux"

#~ msgid ""
#~ "B<LIST_ENTRY(>I<TYPE>B<);>\n"
#~ "B<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
#~ "B<LIST_INSERT_AFTER(LIST_ENTRY *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
#~ "B<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
#~ "B<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
#~ msgstr ""
#~ "B<LIST_ENTRY(>I<TYPE>B<);>\n"
#~ "B<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
#~ "B<LIST_INSERT_AFTER(LIST_ENTRY *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
#~ "B<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
#~ "B<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"

#~ msgid ""
#~ "B<TAILQ_ENTRY(>I<TYPE>B<);>\n"
#~ "B<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
#~ "B<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ msgstr ""
#~ "B<TAILQ_ENTRY(>I<TYPE>B<);>\n"
#~ "B<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
#~ "B<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
#~ "B<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"

#~ msgid ""
#~ "B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\n"
#~ "B<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
#~ "B<CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ msgstr ""
#~ "B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\n"
#~ "B<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
#~ "B<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
#~ "B<CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
#~ "B<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\n"
#~ "B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"

#~ msgid ""
#~ "These macros define and operate on three types of data structures: lists, "
#~ "tail queues, and circular queues.  All three structures support the "
#~ "following functionality:"
#~ msgstr ""
#~ "これらのマクロは、次の 3 つのデータ構造を定義して操作する: リスト・テール"
#~ "キュー・循環キュー。 3 つのデータ構造すべてにおいて以下の機能がサポートさ"
#~ "れている:"

#~ msgid "1."
#~ msgstr "1."

#~ msgid "2."
#~ msgstr "2."

#~ msgid "3."
#~ msgstr "3."

#~ msgid ""
#~ "Code size is about 15% greater and operations run about 20% slower than "
#~ "lists."
#~ msgstr ""
#~ "リストと比べて、コードサイズは 15% 大きくなり、操作は 20% 遅くなる。"

#~ msgid "Entries can be added before another entry."
#~ msgstr "エントリーを他のエントリーの前に追加できる。"

#~ msgid "4."
#~ msgstr "4."

#~ msgid ""
#~ "Code size is about 40% greater and operations run about 45% slower than "
#~ "lists."
#~ msgstr ""
#~ "リストと比べて、コードサイズは 40% 大きくなり、操作は 45% 遅くなる。"

#~ msgid "Lists"
#~ msgstr "リスト"

#~ msgid "List example"
#~ msgstr "リストの例"

#~ msgid ""
#~ "LIST_HEAD(listhead, entry) head;\n"
#~ "struct listhead *headp;                 /* List head. */\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    LIST_ENTRY(entry) entries;          /* List. */\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"
#~ msgstr ""
#~ "LIST_HEAD(listhead, entry) head;\n"
#~ "struct listhead *headp;                 /* リストの先頭。*/\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    LIST_ENTRY(entry) entries;          /* リスト。 */\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"

#~ msgid ""
#~ "n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
#~ "LIST_INSERT_AFTER(n1, n2, entries);\n"
#~ "                                        /* Forward traversal. */\n"
#~ "for (np = head.lh_first; np != NULL; np = np-E<gt>entries.le_next)\n"
#~ "    np-E<gt> ...\n"
#~ msgstr ""
#~ "n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
#~ "LIST_INSERT_AFTER(n1, n2, entries);\n"
#~ "                                        /* 順方向に辿る。*/\n"
#~ "for (np = head.lh_first; np != NULL; np = np-E<gt>entries.le_next)\n"
#~ "    np-E<gt> ...\n"

#~ msgid ""
#~ "while (head.lh_first != NULL)           /* Delete. */\n"
#~ "    LIST_REMOVE(head.lh_first, entries);\n"
#~ msgstr ""
#~ "while (head.lh_first != NULL)           /* 削除する。*/\n"
#~ "    LIST_REMOVE(head.lh_first, entries);\n"

#~ msgid "Tail queues"
#~ msgstr "テールキュー"

#~ msgid "Tail queue example"
#~ msgstr "テールキューの例"

#~ msgid ""
#~ "TAILQ_HEAD(tailhead, entry) head;\n"
#~ "struct tailhead *headp;                 /* Tail queue head. */\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    TAILQ_ENTRY(entry) entries;         /* Tail queue. */\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"
#~ msgstr ""
#~ "TAILQ_HEAD(tailhead, entry) head;\n"
#~ "struct tailhead *headp;                 /* テールキューの先頭。*/\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    TAILQ_ENTRY(entry) entries;         /* テールキュー。*/\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"

#~ msgid ""
#~ "n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
#~ "TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
#~ "                                        /* Forward traversal. */\n"
#~ "for (np = head.tqh_first; np != NULL; np = np-E<gt>entries.tqe_next)\n"
#~ "    np-E<gt> ...\n"
#~ "                                        /* Delete. */\n"
#~ "while (head.tqh_first != NULL)\n"
#~ "    TAILQ_REMOVE(&head, head.tqh_first, entries);\n"
#~ msgstr ""
#~ "n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
#~ "TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
#~ "                                        /* 順方向に辿る。*/\n"
#~ "for (np = head.tqh_first; np != NULL; np = np-E<gt>entries.tqe_next)\n"
#~ "    np-E<gt> ...\n"
#~ "                                        /* 削除する。*/\n"
#~ "while (head.tqh_first != NULL)\n"
#~ "    TAILQ_REMOVE(&head, head.tqh_first, entries);\n"

#~ msgid "Circular queues"
#~ msgstr "循環キュー"

#~ msgid "Circular queue example"
#~ msgstr "循環キューの例"

#~ msgid ""
#~ "CIRCLEQ_HEAD(circleq, entry) head;\n"
#~ "struct circleq *headp;              /* Circular queue head. */\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    CIRCLEQ_ENTRY(entry) entries;   /* Circular queue. */\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"
#~ msgstr ""
#~ "CIRCLEQ_HEAD(circleq, entry) head;\n"
#~ "struct circleq *headp;                  /* 循環キューの先頭。*/\n"
#~ "struct entry {\n"
#~ "    ...\n"
#~ "    CIRCLEQ_ENTRY(entry) entries;       /* 循環キュー。*/\n"
#~ "    ...\n"
#~ "} *n1, *n2, *np;\n"

#~ msgid "CIRCLEQ_INIT(&head);                /* Initialize the circular queue. */\n"
#~ msgstr "CIRCLEQ_INIT(&head);                    /* 循環キューを初期化する。*/\n"

#~ msgid ""
#~ "n2 = malloc(sizeof(struct entry));  /* Insert before. */\n"
#~ "CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
#~ "                                    /* Forward traversal. */\n"
#~ "for (np = head.cqh_first; np != (void *)&head;\n"
#~ "        np = np-E<gt>entries.cqe_next)\n"
#~ "    np-E<gt> ...\n"
#~ "                                    /* Reverse traversal. */\n"
#~ "for (np = head.cqh_last; np != (void *)&head; np = np-E<gt>entries.cqe_prev)\n"
#~ "    np-E<gt> ...\n"
#~ "                                    /* Delete. */\n"
#~ "while (head.cqh_first != (void *)&head)\n"
#~ "    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"
#~ msgstr ""
#~ "n2 = malloc(sizeof(struct entry));      /* 前に挿入する。*/\n"
#~ "CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
#~ "                                        /* 順方向に辿る。*/\n"
#~ "for (np = head.cqh_first; np != (void *)&head; np = np-E<gt>entries.cqe_next)\n"
#~ "    np-E<gt> ...\n"
#~ "                                        /* 逆方向に辿る。*/\n"
#~ "for (np = head.cqh_last; np != (void *)&head; np = np-E<gt>entries.cqe_prev)\n"
#~ "    np-E<gt> ...\n"
#~ "                                        /* 削除する。*/\n"
#~ "while (head.cqh_first != (void *)&head)\n"
#~ "    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"
