# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-19 09:44+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/asprintf.3:27
#, no-wrap
msgid "ASPRINTF"
msgstr "ASPRINTF"

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26
#: build/C/man3/ferror.3:44 build/C/man3/setbuf.3:48 build/C/man3/wprintf.3:16
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26
#: build/C/man3/fclose.3:44 build/C/man3/fcloseall.3:25
#: build/C/man3/fflush.3:45 build/C/man3/fgetc.3:27 build/C/man3/fgetwc.3:18
#: build/C/man3/fmemopen.3:7 build/C/man3/fopen.3:44 build/C/man3/fputwc.3:16
#: build/C/man3/fread.3:46 build/C/man3/fseek.3:42 build/C/man3/getline.3:26
#: build/C/man3/gets.3:29 build/C/man3/getw.3:25
#: build/C/man3/open_memstream.3:9 build/C/man3/popen.3:40
#: build/C/man3/printf.3:34 build/C/man3/puts.3:26 build/C/man3/remove.3:31
#: build/C/man3/scanf.3:52 build/C/man3/wprintf.3:16
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26
#: build/C/man3/fclose.3:44 build/C/man3/fcloseall.3:25
#: build/C/man3/ferror.3:44 build/C/man3/fflush.3:45 build/C/man3/fgetc.3:27
#: build/C/man3/fgetwc.3:18 build/C/man3/flockfile.3:25
#: build/C/man3/fmemopen.3:7 build/C/man3/fmtmsg.3:13 build/C/man3/fopen.3:44
#: build/C/man3/fopencookie.3:26 build/C/man3/fpurge.3:25
#: build/C/man3/fputwc.3:16 build/C/man3/fread.3:46 build/C/man3/fseek.3:42
#: build/C/man3/fseeko.3:25 build/C/man3/getline.3:26 build/C/man3/gets.3:29
#: build/C/man3/getw.3:25 build/C/man2/link.2:32 build/C/man2/llseek.2:29
#: build/C/man2/lseek.2:46 build/C/man3/lseek64.3:26 build/C/man2/open.2:51
#: build/C/man2/openat2.2:24 build/C/man2/open_by_handle_at.2:25
#: build/C/man3/open_memstream.3:9 build/C/man3/perror.3:31
#: build/C/man2/pipe.2:36 build/C/man3/popen.3:40 build/C/man3/printf.3:34
#: build/C/man3/puts.3:26 build/C/man2/read.2:36 build/C/man2/readlink.2:44
#: build/C/man2/readv.2:32 build/C/man3/remove.3:31 build/C/man2/rename.2:33
#: build/C/man2/rmdir.2:30 build/C/man3/scanf.3:52 build/C/man3/setbuf.3:48
#: build/C/man3/stdin.3:13 build/C/man3/stdio.3:39 build/C/man3/stdio_ext.3:25
#: build/C/man2/symlink.2:33 build/C/man7/symlink.7:37
#: build/C/man3/tempnam.3:25 build/C/man3/tmpfile.3:31 build/C/man3/tmpnam.3:27
#: build/C/man2/unlink.2:33 build/C/man3/unlocked_stdio.3:25
#: build/C/man3/wprintf.3:16 build/C/man2/write.2:39
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/asprintf.3:28 build/C/man3/ctermid.3:27
#: build/C/man3/fclose.3:45 build/C/man3/fcloseall.3:26
#: build/C/man3/ferror.3:45 build/C/man3/fflush.3:46 build/C/man3/fgetc.3:28
#: build/C/man3/fgetwc.3:19 build/C/man3/flockfile.3:26
#: build/C/man3/fmemopen.3:8 build/C/man3/fmtmsg.3:14 build/C/man3/fopen.3:45
#: build/C/man3/fopencookie.3:27 build/C/man3/fpurge.3:26
#: build/C/man3/fputwc.3:17 build/C/man3/fread.3:47 build/C/man3/fseek.3:43
#: build/C/man3/fseeko.3:26 build/C/man3/getline.3:27 build/C/man3/gets.3:30
#: build/C/man3/getw.3:26 build/C/man2/link.2:33 build/C/man2/llseek.2:30
#: build/C/man2/lseek.2:47 build/C/man3/lseek64.3:27 build/C/man2/open.2:52
#: build/C/man2/openat2.2:25 build/C/man2/open_by_handle_at.2:26
#: build/C/man3/open_memstream.3:10 build/C/man3/perror.3:32
#: build/C/man2/pipe.2:37 build/C/man3/popen.3:41 build/C/man3/printf.3:35
#: build/C/man3/puts.3:27 build/C/man2/read.2:37 build/C/man2/readlink.2:45
#: build/C/man2/readv.2:33 build/C/man3/remove.3:32 build/C/man2/rename.2:34
#: build/C/man2/rmdir.2:31 build/C/man3/scanf.3:53 build/C/man3/setbuf.3:49
#: build/C/man3/stdin.3:14 build/C/man3/stdio.3:40 build/C/man3/stdio_ext.3:26
#: build/C/man2/symlink.2:34 build/C/man7/symlink.7:38
#: build/C/man3/tempnam.3:26 build/C/man3/tmpfile.3:32 build/C/man3/tmpnam.3:28
#: build/C/man2/unlink.2:34 build/C/man3/unlocked_stdio.3:26
#: build/C/man3/wprintf.3:17 build/C/man2/write.2:40
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/asprintf.3:30
msgid "asprintf, vasprintf - print to allocated string"
msgstr "asprintf, vasprintf - 文字列を割り当ててそれに出力する"

#. type: SH
#: build/C/man3/asprintf.3:30 build/C/man3/ctermid.3:29
#: build/C/man3/fclose.3:47 build/C/man3/fcloseall.3:28
#: build/C/man3/ferror.3:47 build/C/man3/fflush.3:48 build/C/man3/fgetc.3:30
#: build/C/man3/fgetwc.3:21 build/C/man3/flockfile.3:28
#: build/C/man3/fmemopen.3:10 build/C/man3/fmtmsg.3:16 build/C/man3/fopen.3:47
#: build/C/man3/fopencookie.3:29 build/C/man3/fpurge.3:28
#: build/C/man3/fputwc.3:19 build/C/man3/fread.3:49 build/C/man3/fseek.3:45
#: build/C/man3/fseeko.3:28 build/C/man3/getline.3:29 build/C/man3/gets.3:32
#: build/C/man3/getw.3:28 build/C/man2/link.2:35 build/C/man2/llseek.2:32
#: build/C/man2/lseek.2:49 build/C/man3/lseek64.3:29 build/C/man2/open.2:54
#: build/C/man2/openat2.2:27 build/C/man2/open_by_handle_at.2:29
#: build/C/man3/open_memstream.3:12 build/C/man3/perror.3:34
#: build/C/man2/pipe.2:39 build/C/man3/popen.3:43 build/C/man3/printf.3:38
#: build/C/man3/puts.3:29 build/C/man2/read.2:39 build/C/man2/readlink.2:47
#: build/C/man2/readv.2:35 build/C/man3/remove.3:34 build/C/man2/rename.2:36
#: build/C/man2/rmdir.2:33 build/C/man3/scanf.3:55 build/C/man3/setbuf.3:51
#: build/C/man3/stdin.3:16 build/C/man3/stdio.3:42 build/C/man3/stdio_ext.3:30
#: build/C/man2/symlink.2:36 build/C/man3/tempnam.3:28
#: build/C/man3/tmpfile.3:34 build/C/man3/tmpnam.3:30 build/C/man2/unlink.2:36
#: build/C/man3/unlocked_stdio.3:29 build/C/man3/wprintf.3:20
#: build/C/man2/write.2:42
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/asprintf.3:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/asprintf.3:34 build/C/man3/fclose.3:49 build/C/man3/ferror.3:49
#: build/C/man3/fflush.3:50 build/C/man3/fseek.3:47 build/C/man3/perror.3:36
#: build/C/man3/remove.3:36 build/C/man3/stdio.3:44
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: build/C/man3/asprintf.3:36
msgid "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"
msgstr "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"

#. type: Plain text
#: build/C/man3/asprintf.3:38
msgid ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list >I<ap>B<);>"

#. type: SH
#: build/C/man3/asprintf.3:38 build/C/man3/ctermid.3:45
#: build/C/man3/fclose.3:51 build/C/man3/fcloseall.3:35
#: build/C/man3/ferror.3:65 build/C/man3/fflush.3:52 build/C/man3/fgetc.3:44
#: build/C/man3/fgetwc.3:29 build/C/man3/flockfile.3:50
#: build/C/man3/fmemopen.3:35 build/C/man3/fmtmsg.3:24 build/C/man3/fopen.3:65
#: build/C/man3/fopencookie.3:37 build/C/man3/fpurge.3:41
#: build/C/man3/fputwc.3:27 build/C/man3/fread.3:59 build/C/man3/fseek.3:57
#: build/C/man3/fseeko.3:52 build/C/man3/getline.3:58 build/C/man3/gets.3:38
#: build/C/man3/getw.3:58 build/C/man2/link.2:66 build/C/man2/llseek.2:44
#: build/C/man2/lseek.2:55 build/C/man3/lseek64.3:37 build/C/man2/open.2:92
#: build/C/man2/openat2.2:40 build/C/man2/open_by_handle_at.2:43
#: build/C/man3/open_memstream.3:42 build/C/man3/perror.3:58
#: build/C/man2/pipe.2:58 build/C/man3/popen.3:65 build/C/man3/printf.3:84
#: build/C/man3/puts.3:43 build/C/man2/read.2:45 build/C/man2/readlink.2:87
#: build/C/man2/readv.2:67 build/C/man3/remove.3:38 build/C/man2/rename.2:77
#: build/C/man2/rmdir.2:37 build/C/man3/scanf.3:83 build/C/man3/setbuf.3:76
#: build/C/man3/stdin.3:24 build/C/man3/stdio.3:50 build/C/man3/stdio_ext.3:46
#: build/C/man2/symlink.2:75 build/C/man7/symlink.7:40
#: build/C/man3/tempnam.3:45 build/C/man3/tmpfile.3:40 build/C/man3/tmpnam.3:56
#: build/C/man2/unlink.2:66 build/C/man3/unlocked_stdio.3:108
#: build/C/man3/wprintf.3:55 build/C/man2/write.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/asprintf.3:53
msgid ""
"The functions B<asprintf>()  and B<vasprintf>()  are analogs of "
"B<sprintf>(3)  and B<vsprintf>(3), except that they allocate a string large "
"enough to hold the output including the terminating null byte (\\(aq"
"\\e0\\(aq), and return a pointer to it via the first argument.  This pointer "
"should be passed to B<free>(3)  to release the allocated storage when it is "
"no longer needed."
msgstr ""
"B<asprintf>()  関数と B<vasprintf>()  関数とは、それぞれ B<sprintf>(3)  関数"
"と B<vsprintf>(3)  関数とに似ているが、 出力文字列を (終端のヌルバイト (\\(aq"
"\\e0\\(aq) も含めて)  保持するのに十分な大きさのメモリーを確保し、 最初の引数"
"にその文字列へのポインターを返す。 このポインターは、不要になったら "
"B<free>(3)  に渡し、割り当てられた記憶領域を解放すべきである。"

#. type: SH
#: build/C/man3/asprintf.3:53 build/C/man3/ctermid.3:58
#: build/C/man3/fclose.3:59 build/C/man3/fcloseall.3:50
#: build/C/man3/fflush.3:79 build/C/man3/fgetc.3:99 build/C/man3/fgetwc.3:54
#: build/C/man3/flockfile.3:119 build/C/man3/fmemopen.3:140
#: build/C/man3/fmtmsg.3:149 build/C/man3/fopen.3:236
#: build/C/man3/fopencookie.3:238 build/C/man3/fpurge.3:57
#: build/C/man3/fputwc.3:53 build/C/man3/fread.3:84 build/C/man3/fseek.3:121
#: build/C/man3/fseeko.3:86 build/C/man3/getline.3:112 build/C/man3/gets.3:50
#: build/C/man3/getw.3:72 build/C/man2/link.2:187 build/C/man2/llseek.2:78
#: build/C/man2/lseek.2:187 build/C/man2/open.2:972 build/C/man2/openat2.2:393
#: build/C/man2/open_by_handle_at.2:276 build/C/man3/open_memstream.3:91
#: build/C/man2/pipe.2:149 build/C/man3/popen.3:125 build/C/man3/printf.3:855
#: build/C/man3/puts.3:84 build/C/man2/read.2:83 build/C/man2/readlink.2:154
#: build/C/man2/readv.2:267 build/C/man3/remove.3:60 build/C/man2/rename.2:303
#: build/C/man2/rmdir.2:40 build/C/man3/scanf.3:540 build/C/man3/setbuf.3:153
#: build/C/man2/symlink.2:141 build/C/man3/tempnam.3:97
#: build/C/man3/tmpfile.3:47 build/C/man3/tmpnam.3:105
#: build/C/man2/unlink.2:153 build/C/man3/wprintf.3:200 build/C/man2/write.2:96
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/asprintf.3:61
msgid ""
"When successful, these functions return the number of bytes printed, just "
"like B<sprintf>(3).  If memory allocation wasn't possible, or some other "
"error occurs, these functions will return -1, and the contents of I<strp> "
"are undefined."
msgstr ""
"成功すると、これらの関数は出力されたバイト数を (B<sprintf>(3)  のように) 返"
"す。 メモリーの割り当てができなかったり、 その他エラーが生じると、 これらの関"
"数は -1 を返し、 I<strp> の内容は未定義となる。"

#. type: SH
#: build/C/man3/asprintf.3:61 build/C/man3/ctermid.3:60
#: build/C/man3/fclose.3:90 build/C/man3/fcloseall.3:55
#: build/C/man3/ferror.3:114 build/C/man3/fflush.3:98 build/C/man3/fgetc.3:124
#: build/C/man3/fgetwc.3:69 build/C/man3/flockfile.3:126
#: build/C/man3/fmemopen.3:152 build/C/man3/fmtmsg.3:222
#: build/C/man3/fopen.3:293 build/C/man3/fopencookie.3:245
#: build/C/man3/fpurge.3:69 build/C/man3/fputwc.3:67 build/C/man3/fread.3:105
#: build/C/man3/fseek.3:169 build/C/man3/fseeko.3:100
#: build/C/man3/getline.3:140 build/C/man3/gets.3:58 build/C/man3/getw.3:79
#: build/C/man3/lseek64.3:187 build/C/man3/open_memstream.3:107
#: build/C/man3/perror.3:121 build/C/man3/popen.3:177 build/C/man3/printf.3:876
#: build/C/man3/puts.3:103 build/C/man3/remove.3:70 build/C/man3/scanf.3:587
#: build/C/man3/setbuf.3:165 build/C/man3/stdio_ext.3:124
#: build/C/man3/tempnam.3:108 build/C/man3/tmpfile.3:79
#: build/C/man3/tmpnam.3:110 build/C/man3/unlocked_stdio.3:115
#: build/C/man3/wprintf.3:208
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/asprintf.3:64 build/C/man3/ctermid.3:63
#: build/C/man3/fclose.3:93 build/C/man3/fcloseall.3:58
#: build/C/man3/ferror.3:117 build/C/man3/fflush.3:101 build/C/man3/fgetc.3:127
#: build/C/man3/fgetwc.3:72 build/C/man3/flockfile.3:129
#: build/C/man3/fmemopen.3:155 build/C/man3/fmtmsg.3:225
#: build/C/man3/fopen.3:296 build/C/man3/fopencookie.3:248
#: build/C/man3/fpurge.3:72 build/C/man3/fputwc.3:70 build/C/man3/fread.3:108
#: build/C/man3/fseek.3:172 build/C/man3/fseeko.3:103
#: build/C/man3/getline.3:143 build/C/man3/gets.3:61 build/C/man3/getw.3:82
#: build/C/man3/lseek64.3:190 build/C/man3/open_memstream.3:110
#: build/C/man3/perror.3:124 build/C/man3/popen.3:180 build/C/man3/printf.3:879
#: build/C/man3/puts.3:106 build/C/man3/remove.3:73 build/C/man3/scanf.3:590
#: build/C/man3/setbuf.3:168 build/C/man3/stdio_ext.3:127
#: build/C/man3/tempnam.3:111 build/C/man3/tmpfile.3:82
#: build/C/man3/tmpnam.3:113 build/C/man3/unlocked_stdio.3:118
#: build/C/man3/wprintf.3:211
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67
#: build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62
#: build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131
#: build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133
#: build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229
#: build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252
#: build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112
#: build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107
#: build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86
#: build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114
#: build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883
#: build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594
#: build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131
#: build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86
#: build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123
#: build/C/man3/wprintf.3:215
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67
#: build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62
#: build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131
#: build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133
#: build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229
#: build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252
#: build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112
#: build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107
#: build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86
#: build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114
#: build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883
#: build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594
#: build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131
#: build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86
#: build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123
#: build/C/man3/wprintf.3:215
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67
#: build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62
#: build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131
#: build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133
#: build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229
#: build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252
#: build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112
#: build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107
#: build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86
#: build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114
#: build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883
#: build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594
#: build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131
#: build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86
#: build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123
#: build/C/man3/wprintf.3:215
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/asprintf.3:72
#, no-wrap
msgid ""
"B<asprintf>(),\n"
"B<vasprintf>()"
msgstr ""
"B<asprintf>(),\n"
"B<vasprintf>()"

#. type: tbl table
#: build/C/man3/asprintf.3:72 build/C/man3/ctermid.3:70
#: build/C/man3/fclose.3:100 build/C/man3/fcloseall.3:65
#: build/C/man3/ferror.3:128 build/C/man3/fflush.3:108 build/C/man3/fgetc.3:139
#: build/C/man3/fgetwc.3:80 build/C/man3/flockfile.3:138
#: build/C/man3/fmemopen.3:162 build/C/man3/fmtmsg.3:232
#: build/C/man3/fopen.3:305 build/C/man3/fopencookie.3:255
#: build/C/man3/fpurge.3:79 build/C/man3/fputwc.3:78 build/C/man3/fread.3:116
#: build/C/man3/fseek.3:184 build/C/man3/fseeko.3:111
#: build/C/man3/getline.3:151 build/C/man3/gets.3:68 build/C/man3/getw.3:90
#: build/C/man3/lseek64.3:197 build/C/man3/open_memstream.3:119
#: build/C/man3/perror.3:131 build/C/man3/popen.3:188 build/C/man3/printf.3:896
#: build/C/man3/puts.3:117 build/C/man3/remove.3:80 build/C/man3/scanf.3:604
#: build/C/man3/setbuf.3:179 build/C/man3/stdio_ext.3:138
#: build/C/man3/stdio_ext.3:148 build/C/man3/tempnam.3:118
#: build/C/man3/tmpfile.3:89 build/C/man3/tmpnam.3:120
#: build/C/man3/tmpnam.3:123 build/C/man3/unlocked_stdio.3:141
#: build/C/man3/unlocked_stdio.3:145 build/C/man3/unlocked_stdio.3:149
#: build/C/man3/unlocked_stdio.3:154 build/C/man3/wprintf.3:225
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/asprintf.3:72 build/C/man3/printf.3:896
#: build/C/man3/scanf.3:604 build/C/man3/wprintf.3:225
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: SH
#: build/C/man3/asprintf.3:75 build/C/man3/ctermid.3:72
#: build/C/man3/fclose.3:102 build/C/man3/fcloseall.3:71
#: build/C/man3/ferror.3:130 build/C/man3/fflush.3:110 build/C/man3/fgetc.3:142
#: build/C/man3/fgetwc.3:82 build/C/man3/flockfile.3:140
#: build/C/man3/fmemopen.3:165 build/C/man3/fmtmsg.3:249
#: build/C/man3/fopen.3:307 build/C/man3/fopencookie.3:257
#: build/C/man3/fpurge.3:82 build/C/man3/fputwc.3:81 build/C/man3/fread.3:118
#: build/C/man3/fseek.3:187 build/C/man3/fseeko.3:114
#: build/C/man3/getline.3:154 build/C/man3/gets.3:71 build/C/man3/getw.3:92
#: build/C/man2/link.2:360 build/C/man2/llseek.2:97 build/C/man2/lseek.2:233
#: build/C/man2/open.2:1285 build/C/man2/openat2.2:471
#: build/C/man2/open_by_handle_at.2:383 build/C/man3/open_memstream.3:122
#: build/C/man3/perror.3:134 build/C/man2/pipe.2:196 build/C/man3/popen.3:191
#: build/C/man3/printf.3:899 build/C/man3/puts.3:119 build/C/man2/read.2:183
#: build/C/man2/readlink.2:222 build/C/man2/readv.2:327
#: build/C/man3/remove.3:82 build/C/man2/rename.2:523 build/C/man2/rmdir.2:128
#: build/C/man3/scanf.3:607 build/C/man3/setbuf.3:181 build/C/man3/stdin.3:113
#: build/C/man3/stdio.3:245 build/C/man2/symlink.2:231
#: build/C/man3/tempnam.3:120 build/C/man3/tmpfile.3:91
#: build/C/man3/tmpnam.3:125 build/C/man2/unlink.2:278
#: build/C/man3/unlocked_stdio.3:157 build/C/man3/wprintf.3:228
#: build/C/man2/write.2:243
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/asprintf.3:81
msgid ""
"These functions are GNU extensions, not in C or POSIX.  They are also "
"available under *BSD.  The FreeBSD implementation sets I<strp> to NULL on "
"error."
msgstr ""
"これらの関数は GNU の拡張であり、C や POSIX のものではない。 これらは *BSD で"
"も利用できる。 FreeBSD の実装では、エラーの際には I<strp> を NULL にセットす"
"る。"

#. type: SH
#: build/C/man3/asprintf.3:81 build/C/man3/ctermid.3:82
#: build/C/man3/fclose.3:114 build/C/man3/fcloseall.3:73
#: build/C/man3/ferror.3:141 build/C/man3/fflush.3:124 build/C/man3/fgetc.3:151
#: build/C/man3/fgetwc.3:99 build/C/man3/flockfile.3:146
#: build/C/man3/fmemopen.3:349 build/C/man3/fmtmsg.3:328
#: build/C/man3/fopen.3:407 build/C/man3/fopencookie.3:447
#: build/C/man3/fpurge.3:92 build/C/man3/fputwc.3:98 build/C/man3/fread.3:174
#: build/C/man3/fseek.3:189 build/C/man3/fseeko.3:116
#: build/C/man3/getline.3:196 build/C/man3/gets.3:103 build/C/man3/getw.3:99
#: build/C/man2/link.2:433 build/C/man2/llseek.2:107 build/C/man2/lseek.2:272
#: build/C/man3/lseek64.3:218 build/C/man2/open.2:1876
#: build/C/man2/openat2.2:580 build/C/man2/open_by_handle_at.2:751
#: build/C/man3/open_memstream.3:142 build/C/man3/perror.3:159
#: build/C/man2/pipe.2:286 build/C/man3/popen.3:224 build/C/man3/printf.3:1173
#: build/C/man3/puts.3:128 build/C/man2/read.2:255 build/C/man2/readlink.2:350
#: build/C/man2/readv.2:429 build/C/man3/remove.3:93 build/C/man2/rename.2:562
#: build/C/man2/rmdir.2:133 build/C/man3/scanf.3:768 build/C/man3/setbuf.3:217
#: build/C/man3/stdin.3:154 build/C/man3/stdio.3:249
#: build/C/man3/stdio_ext.3:150 build/C/man2/symlink.2:263
#: build/C/man7/symlink.7:565 build/C/man3/tempnam.3:183
#: build/C/man3/tmpfile.3:110 build/C/man3/tmpnam.3:178
#: build/C/man2/unlink.2:305 build/C/man3/unlocked_stdio.3:180
#: build/C/man3/wprintf.3:268 build/C/man2/write.2:337
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/asprintf.3:85
msgid "B<free>(3), B<malloc>(3), B<printf>(3)"
msgstr "B<free>(3), B<malloc>(3), B<printf>(3)"

#. type: SH
#: build/C/man3/asprintf.3:85 build/C/man3/ctermid.3:84
#: build/C/man3/fclose.3:121 build/C/man3/fcloseall.3:79
#: build/C/man3/ferror.3:146 build/C/man3/fflush.3:133 build/C/man3/fgetc.3:168
#: build/C/man3/fgetwc.3:104 build/C/man3/flockfile.3:148
#: build/C/man3/fmemopen.3:353 build/C/man3/fmtmsg.3:331
#: build/C/man3/fopen.3:414 build/C/man3/fopencookie.3:452
#: build/C/man3/fpurge.3:97 build/C/man3/fputwc.3:102 build/C/man3/fread.3:180
#: build/C/man3/fseek.3:192 build/C/man3/fseeko.3:118
#: build/C/man3/getline.3:202 build/C/man3/gets.3:121 build/C/man3/getw.3:105
#: build/C/man2/link.2:442 build/C/man2/llseek.2:111 build/C/man2/lseek.2:280
#: build/C/man3/lseek64.3:221 build/C/man2/open.2:1901
#: build/C/man2/openat2.2:584 build/C/man2/open_by_handle_at.2:767
#: build/C/man3/open_memstream.3:146 build/C/man3/perror.3:164
#: build/C/man2/pipe.2:296 build/C/man3/popen.3:234 build/C/man3/printf.3:1183
#: build/C/man3/puts.3:140 build/C/man2/read.2:268 build/C/man2/readlink.2:358
#: build/C/man2/readv.2:433 build/C/man3/remove.3:104 build/C/man2/rename.2:571
#: build/C/man2/rmdir.2:142 build/C/man3/scanf.3:775 build/C/man3/setbuf.3:226
#: build/C/man3/stdin.3:160 build/C/man3/stdio.3:256
#: build/C/man3/stdio_ext.3:153 build/C/man2/symlink.2:275
#: build/C/man7/symlink.7:584 build/C/man3/tempnam.3:188
#: build/C/man3/tmpfile.3:116 build/C/man3/tmpnam.3:183
#: build/C/man2/unlink.2:318 build/C/man3/unlocked_stdio.3:183
#: build/C/man3/wprintf.3:275 build/C/man2/write.2:349
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/asprintf.3:93 build/C/man3/ctermid.3:92
#: build/C/man3/fclose.3:129 build/C/man3/fcloseall.3:87
#: build/C/man3/ferror.3:154 build/C/man3/fflush.3:141 build/C/man3/fgetc.3:176
#: build/C/man3/fgetwc.3:112 build/C/man3/flockfile.3:156
#: build/C/man3/fmemopen.3:361 build/C/man3/fmtmsg.3:339
#: build/C/man3/fopen.3:422 build/C/man3/fopencookie.3:460
#: build/C/man3/fpurge.3:105 build/C/man3/fputwc.3:110 build/C/man3/fread.3:188
#: build/C/man3/fseek.3:200 build/C/man3/fseeko.3:126
#: build/C/man3/getline.3:210 build/C/man3/gets.3:129 build/C/man3/getw.3:113
#: build/C/man2/link.2:450 build/C/man2/llseek.2:119 build/C/man2/lseek.2:288
#: build/C/man3/lseek64.3:229 build/C/man2/open.2:1909
#: build/C/man2/openat2.2:592 build/C/man2/open_by_handle_at.2:775
#: build/C/man3/open_memstream.3:154 build/C/man3/perror.3:172
#: build/C/man2/pipe.2:304 build/C/man3/popen.3:242 build/C/man3/printf.3:1191
#: build/C/man3/puts.3:148 build/C/man2/read.2:276 build/C/man2/readlink.2:366
#: build/C/man2/readv.2:441 build/C/man3/remove.3:112 build/C/man2/rename.2:579
#: build/C/man2/rmdir.2:150 build/C/man3/scanf.3:783 build/C/man3/setbuf.3:234
#: build/C/man3/stdin.3:168 build/C/man3/stdio.3:264
#: build/C/man3/stdio_ext.3:161 build/C/man2/symlink.2:283
#: build/C/man7/symlink.7:592 build/C/man3/tempnam.3:196
#: build/C/man3/tmpfile.3:124 build/C/man3/tmpnam.3:191
#: build/C/man2/unlink.2:326 build/C/man3/unlocked_stdio.3:191
#: build/C/man3/wprintf.3:283 build/C/man2/write.2:357
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/ctermid.3:26
#, no-wrap
msgid "CTERMID"
msgstr "CTERMID"

#. type: Plain text
#: build/C/man3/ctermid.3:29
msgid "ctermid - get controlling terminal name"
msgstr "ctermid - 制御端末名の取得"

#. type: Plain text
#: build/C/man3/ctermid.3:34 build/C/man3/fgetc.3:33
#: build/C/man3/flockfile.3:31 build/C/man3/fmemopen.3:13
#: build/C/man3/fopen.3:50 build/C/man3/fread.3:52 build/C/man3/fseeko.3:31
#: build/C/man3/getline.3:32 build/C/man3/gets.3:35 build/C/man3/getw.3:31
#: build/C/man3/open_memstream.3:15 build/C/man3/popen.3:46
#: build/C/man3/printf.3:41 build/C/man3/puts.3:32 build/C/man2/rename.2:39
#: build/C/man3/scanf.3:58 build/C/man3/setbuf.3:54 build/C/man3/stdin.3:19
#: build/C/man3/tempnam.3:31 build/C/man3/tmpfile.3:37 build/C/man3/tmpnam.3:33
#: build/C/man3/unlocked_stdio.3:32
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ctermid.3:36
#, no-wrap
msgid "B<char *ctermid(char *>I<s>B<);>\n"
msgstr "B<char *ctermid(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/ctermid.3:41 build/C/man3/ferror.3:61
#: build/C/man3/flockfile.3:40 build/C/man3/fmemopen.3:20
#: build/C/man3/fopen.3:61 build/C/man3/fseeko.3:40 build/C/man3/getline.3:42
#: build/C/man3/getw.3:40 build/C/man2/link.2:51 build/C/man2/open.2:77
#: build/C/man3/open_memstream.3:26 build/C/man3/perror.3:50
#: build/C/man3/popen.3:55 build/C/man3/printf.3:61 build/C/man2/readlink.2:64
#: build/C/man2/readv.2:59 build/C/man2/rename.2:56 build/C/man3/scanf.3:73
#: build/C/man3/setbuf.3:68 build/C/man2/symlink.2:52 build/C/man3/tempnam.3:38
#: build/C/man3/tmpnam.3:41 build/C/man2/unlink.2:51
#: build/C/man3/unlocked_stdio.3:68 build/C/man3/wprintf.3:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/ctermid.3:45
msgid "B<ctermid>(): _POSIX_C_SOURCE"
msgstr "B<ctermid>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/ctermid.3:58
msgid ""
"B<ctermid>()  returns a string which is the pathname for the current "
"controlling terminal for this process.  If I<s> is NULL, a static buffer is "
"used, otherwise I<s> points to a buffer used to hold the terminal pathname.  "
"The symbolic constant B<L_ctermid> is the maximum number of characters in "
"the returned pathname."
msgstr ""
"B<ctermid>()  はプロセスの現在の制御端末のパス名を返す。 I<s> が NULL の場"
"合、静的なバッファーを用いる。それ以外の場合、 I<s> は端末パス名を保持するの"
"に使用されるバッファーへのポインターとなる。 シンボル定数 B<L_ctermid> は返さ"
"れるパス名の最大文字数である。"

#. type: Plain text
#: build/C/man3/ctermid.3:60
msgid "The pointer to the pathname."
msgstr "パス名へのポインター。"

#. type: tbl table
#: build/C/man3/ctermid.3:70
#, no-wrap
msgid "B<ctermid>()"
msgstr "B<ctermid>()"

#. type: tbl table
#: build/C/man3/ctermid.3:70 build/C/man3/fclose.3:100
#: build/C/man3/ferror.3:128 build/C/man3/fflush.3:108 build/C/man3/fgetc.3:139
#: build/C/man3/fgetwc.3:80 build/C/man3/flockfile.3:138
#: build/C/man3/fmemopen.3:162 build/C/man3/fopen.3:305
#: build/C/man3/fopencookie.3:255 build/C/man3/fputwc.3:78
#: build/C/man3/fread.3:116 build/C/man3/fseek.3:184 build/C/man3/fseeko.3:111
#: build/C/man3/getline.3:151 build/C/man3/gets.3:68 build/C/man3/getw.3:90
#: build/C/man3/lseek64.3:197 build/C/man3/open_memstream.3:119
#: build/C/man3/popen.3:188 build/C/man3/puts.3:117 build/C/man3/remove.3:80
#: build/C/man3/setbuf.3:179 build/C/man3/stdio_ext.3:148
#: build/C/man3/tmpfile.3:89 build/C/man3/tmpnam.3:123
#: build/C/man3/unlocked_stdio.3:154
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/ctermid.3:74
msgid "POSIX.1-2001, POSIX.1-2008, Svr4."
msgstr "POSIX.1-2001, POSIX.1-2008, Svr4."

#. type: SH
#: build/C/man3/ctermid.3:74 build/C/man3/fmemopen.3:218
#: build/C/man3/fopen.3:390 build/C/man3/gets.3:85 build/C/man3/getw.3:95
#: build/C/man2/link.2:427 build/C/man2/open.2:1843
#: build/C/man3/open_memstream.3:132 build/C/man3/popen.3:201
#: build/C/man3/printf.3:1029 build/C/man3/puts.3:121 build/C/man2/read.2:216
#: build/C/man3/remove.3:90 build/C/man2/rename.2:551 build/C/man2/rmdir.2:130
#: build/C/man3/scanf.3:699 build/C/man3/setbuf.3:187
#: build/C/man3/tempnam.3:180 build/C/man3/tmpnam.3:171
#: build/C/man2/unlink.2:302 build/C/man2/write.2:298
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/ctermid.3:78
#, fuzzy
#| msgid ""
#| "The path returned may not uniquely identify the controlling terminal; it "
#| "may, for example, be I</dev/tty>."
msgid ""
"The returned pathname may not uniquely identify the controlling terminal; it "
"may, for example, be I</dev/tty>."
msgstr ""
"返されたパスはたぶん制御端末を一意には特定できない。 たとえば I</dev/tty> の"
"ように。"

#.  in glibc 2.3.x, x >= 4, the glibc headers threw an error
#.  if ctermid() was given an argument; fixed in 2.4.
#. type: Plain text
#: build/C/man3/ctermid.3:82
msgid "It is not assured that the program can open the terminal."
msgstr "プログラムが端末をオープンできることは保証されていない。"

#. type: Plain text
#: build/C/man3/ctermid.3:84
msgid "B<ttyname>(3)"
msgstr "B<ttyname>(3)"

#. type: TH
#: build/C/man3/fclose.3:44
#, no-wrap
msgid "FCLOSE"
msgstr "FCLOSE"

#. type: TH
#: build/C/man3/fclose.3:44
#, no-wrap
msgid "2016-12-12"
msgstr "2016-12-12"

#. type: Plain text
#: build/C/man3/fclose.3:47
msgid "fclose - close a stream"
msgstr "fclose - ストリームを閉じる"

#. type: Plain text
#: build/C/man3/fclose.3:51
msgid "B<int fclose(FILE *>I<stream>B<);>"
msgstr "B<int fclose(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fclose.3:59
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<stream> "
"(writing any buffered output data using B<fflush>(3))  and closes the "
"underlying file descriptor."
msgstr ""
"B<fclose>() 関数は、 I<stream> が指すストリームを (バッファーリングされて\n"
"いた全ての出力データを B<fflush>(3) を用いて書き込んで) フラッシュし、\n"
"対応するファイルディスクリプターをクローズする。"

#. type: Plain text
#: build/C/man3/fclose.3:70
msgid ""
"Upon successful completion, 0 is returned.  Otherwise, B<EOF> is returned "
"and I<errno> is set to indicate the error.  In either case, any further "
"access (including another call to B<fclose>())  to the stream results in "
"undefined behavior."
msgstr ""
"関数が正常に終了すると 0 が返される。 正常に終了しなかった場合には B<EOF> が"
"返され、 I<errno> がエラーを示すために設定される。 どちらの場合も、そのスト"
"リームに対する (B<fclose>()  へのさらなる呼び出しを含む) それ以上のアクセス"
"は 未定義の動作を生じさせる。"

#. type: SH
#: build/C/man3/fclose.3:70 build/C/man3/ferror.3:104 build/C/man3/fflush.3:86
#: build/C/man3/fgetwc.3:63 build/C/man3/flockfile.3:124
#: build/C/man3/fopen.3:248 build/C/man3/fpurge.3:64 build/C/man3/fputwc.3:62
#: build/C/man3/fseek.3:136 build/C/man3/fseeko.3:95 build/C/man3/getline.3:127
#: build/C/man2/link.2:192 build/C/man2/llseek.2:85 build/C/man2/lseek.2:195
#: build/C/man2/open.2:982 build/C/man2/openat2.2:398
#: build/C/man2/open_by_handle_at.2:287 build/C/man2/pipe.2:170
#: build/C/man3/popen.3:151 build/C/man2/read.2:99 build/C/man2/readlink.2:163
#: build/C/man2/readv.2:287 build/C/man3/remove.3:65 build/C/man2/rename.2:308
#: build/C/man2/rmdir.2:45 build/C/man3/scanf.3:557 build/C/man2/symlink.2:146
#: build/C/man3/tempnam.3:104 build/C/man3/tmpfile.3:56
#: build/C/man3/tmpnam.3:108 build/C/man2/unlink.2:158 build/C/man2/write.2:131
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/fclose.3:71 build/C/man3/fflush.3:87 build/C/man3/fpurge.3:65
#: build/C/man2/link.2:289 build/C/man2/llseek.2:86 build/C/man2/lseek.2:196
#: build/C/man2/open.2:1271 build/C/man2/open_by_handle_at.2:348
#: build/C/man2/read.2:123 build/C/man2/readlink.2:208
#: build/C/man2/rename.2:449 build/C/man3/scanf.3:563
#: build/C/man2/symlink.2:211 build/C/man2/unlink.2:253
#: build/C/man2/write.2:155
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(stream)).
#. type: Plain text
#: build/C/man3/fclose.3:80
msgid "The file descriptor underlying I<stream> is not valid."
msgstr "I<stream> の基となるファイルディスクリプターが不正である。"

#. type: Plain text
#: build/C/man3/fclose.3:90
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2), or B<fflush>(3)."
msgstr ""
"B<fclose>()  関数はこれ以外にも B<close>(2), B<write>(2), B<fflush>(3)  の"
"ルーチンで失敗することがある。その場合は I<errno> が、失敗したルーチンで設定"
"された値に設定される。"

#. type: tbl table
#: build/C/man3/fclose.3:100
#, no-wrap
msgid "B<fclose>()"
msgstr "B<fclose>()"

#. type: Plain text
#: build/C/man3/fclose.3:104 build/C/man3/fgetc.3:144 build/C/man3/fseek.3:189
#: build/C/man3/puts.3:121
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: SH
#: build/C/man3/fclose.3:104 build/C/man3/fflush.3:115 build/C/man3/fgetwc.3:84
#: build/C/man3/fmemopen.3:177 build/C/man3/fmtmsg.3:265
#: build/C/man3/fopen.3:314 build/C/man3/fpurge.3:90 build/C/man3/fputwc.3:83
#: build/C/man2/link.2:369 build/C/man2/llseek.2:100 build/C/man2/lseek.2:243
#: build/C/man3/lseek64.3:199 build/C/man2/open.2:1332
#: build/C/man2/openat2.2:478 build/C/man2/open_by_handle_at.2:390
#: build/C/man3/open_memstream.3:126 build/C/man3/perror.3:144
#: build/C/man2/pipe.2:202 build/C/man3/popen.3:197 build/C/man3/printf.3:967
#: build/C/man2/read.2:185 build/C/man2/readlink.2:231 build/C/man2/readv.2:344
#: build/C/man2/rename.2:532 build/C/man3/scanf.3:638 build/C/man3/stdin.3:122
#: build/C/man2/symlink.2:241 build/C/man3/tempnam.3:125
#: build/C/man3/tmpfile.3:93 build/C/man3/tmpnam.3:136
#: build/C/man2/unlink.2:286 build/C/man3/wprintf.3:230
#: build/C/man2/write.2:252
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/fclose.3:114
msgid ""
"Note that B<fclose>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"B<fclose>()  は C ライブラリで提供されたユーザー空間バッファーだけをフラッ"
"シュする点に注意すること。 データを確実に物理的にディスクに記録するためには "
"カーネルバッファーも (B<sync>(2)  や B<fsync>(2)  を用いて) フラッシュしなけ"
"ればならない。"

#. type: Plain text
#: build/C/man3/fclose.3:121
msgid ""
"B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), "
"B<setbuf>(3)"
msgstr "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: build/C/man3/fcloseall.3:25
#, no-wrap
msgid "FCLOSEALL"
msgstr "FCLOSEALL"

#. type: TH
#: build/C/man3/fcloseall.3:25 build/C/man3/fflush.3:45
#: build/C/man3/fpurge.3:25 build/C/man3/fputwc.3:16 build/C/man3/fseeko.3:25
#: build/C/man3/gets.3:29 build/C/man3/popen.3:40 build/C/man3/remove.3:31
#: build/C/man3/stdin.3:13 build/C/man2/symlink.2:33 build/C/man3/tempnam.3:25
#: build/C/man3/tmpnam.3:27 build/C/man2/unlink.2:33
#: build/C/man3/unlocked_stdio.3:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/fcloseall.3:28
msgid "fcloseall - close all open streams"
msgstr "fcloseall - 開いているすべてのストリームを閉じる"

#. type: Plain text
#: build/C/man3/fcloseall.3:32 build/C/man3/fopencookie.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fcloseall.3:34
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr "B<int fcloseall(void);>\n"

#. type: Plain text
#: build/C/man3/fcloseall.3:43
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as "
"for B<fflush>(3)); buffered input is discarded."
msgstr ""
"B<fcloseall>()  関数は、呼び出し元プロセスが開いているすべてのストリームを閉"
"じる。 ストリームを閉じる前に、 (B<fflush>(3)  と同じように) 各ストリームの"
"バッファーに溜っている出力データは書き出される。 入力バッファー内のデータは破"
"棄される。"

#. type: Plain text
#: build/C/man3/fcloseall.3:50
msgid ""
"The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr "標準入出力 I<stdin>, I<stdout>, I<stderr> も閉じられる。"

#. type: Plain text
#: build/C/man3/fcloseall.3:55
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""
"この関数は、すべてのファイルが正常に閉じられた場合 0 を返す。 エラーの場合、 "
"B<EOF> を返す。"

#. type: tbl table
#: build/C/man3/fcloseall.3:65
#, no-wrap
msgid "B<fcloseall>()"
msgstr "B<fcloseall>()"

#. type: tbl table
#: build/C/man3/fcloseall.3:65
#, no-wrap
msgid "MT-Unsafe race:streams"
msgstr "MT-Unsafe race:streams"

#. type: Plain text
#: build/C/man3/fcloseall.3:71
msgid ""
"The B<fcloseall>()  function does not lock the streams, so it is not thread-"
"safe."
msgstr ""
"B<fcloseall>() 関数はストリームのロックを行わない。そのため、スレッドセーフで"
"はない。"

#. type: Plain text
#: build/C/man3/fcloseall.3:73
msgid "This function is a GNU extension."
msgstr "この関数は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/fcloseall.3:79
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: build/C/man3/ferror.3:44
#, no-wrap
msgid "FERROR"
msgstr "FERROR"

#. type: Plain text
#: build/C/man3/ferror.3:47
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr ""
"clearerr, feof, ferror, fileno - ストリームステータスのチェックとリセット"

#. type: Plain text
#: build/C/man3/ferror.3:51
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr "B<void clearerr(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:53
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr "B<int feof(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:55
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr "B<int ferror(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:57
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr "B<int fileno(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:65
msgid "B<fileno>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:70
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""
"関数 B<clearerr>()  は I<stream> で示されるストリームの EOF(end-of-file) 指示"
"子とエラー指示子をクリアする。"

#. type: Plain text
#: build/C/man3/ferror.3:78
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can be cleared only by the function B<clearerr>()."
msgstr ""
"関数 B<feof>()  は I<stream> で示されるストリームの EOF 指示子をテストし、 "
"セットされていれば 0 以外の数を返す。 EOF 指示子は、関数 B<clearerr>()  に"
"よってのみクリアすることができる。"

#. type: Plain text
#: build/C/man3/ferror.3:87
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can be "
"reset only by the B<clearerr>()  function."
msgstr ""
"関数 B<ferror>()  は I<stream> で示されるストリームのエラー指示子をテスト"
"し、 セットされていれば 0 以外の数を返す。 エラー指示子は、関数 "
"B<clearerr>()  によってのみリセットすることができる。"

#. type: Plain text
#: build/C/man3/ferror.3:101
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns the "
"integer file descriptor used to implement this stream.  The file descriptor "
"is still owned by I<stream> and will be closed when B<fclose>(3)  is "
"called.  Duplicate the file descriptor with B<dup>(2)  before passing it to "
"code that might close it."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:104 build/C/man3/fgetc.3:99 build/C/man3/fgetwc.3:54
#: build/C/man3/fputwc.3:53 build/C/man3/fread.3:84 build/C/man3/puts.3:84
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr ""
"これらの処理を停止せずに行いたいときは、 B<unlocked_stdio>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/ferror.3:114
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a "
"valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""
"これらの関数は失敗すべきではなく、また、外部変数 I<errno> に値をセットしな"
"い。 (しかし、 B<fileno>()  関数の場合で、引数が有効なストリームでなかった場"
"合、 関数は -1 を返し、 I<errno> に B<EBADF> を設定しなければならない。)"

#. type: tbl table
#: build/C/man3/ferror.3:125
#, no-wrap
msgid ""
"B<clearerr>(),\n"
"B<feof>(),\n"
msgstr ""
"B<clearerr>(),\n"
"B<feof>(),\n"

#. type: tbl table
#: build/C/man3/ferror.3:125 build/C/man3/fgetc.3:136 build/C/man3/fmtmsg.3:234
#: build/C/man3/fseek.3:181 build/C/man3/open_memstream.3:117
#: build/C/man3/printf.3:887 build/C/man3/printf.3:890
#: build/C/man3/printf.3:893 build/C/man3/scanf.3:598 build/C/man3/scanf.3:601
#: build/C/man3/setbuf.3:176 build/C/man3/stdio_ext.3:135
#: build/C/man3/stdio_ext.3:142 build/C/man3/stdio_ext.3:145
#: build/C/man3/wprintf.3:219 build/C/man3/wprintf.3:222
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/ferror.3:128
#, no-wrap
msgid ""
"B<ferror>(),\n"
"B<fileno>()"
msgstr ""
"B<ferror>(),\n"
"B<fileno>()"

#. type: Plain text
#: build/C/man3/ferror.3:137
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89, "
"C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""
"関数 B<clearerr>(), B<feof>(), B<ferror>()  は C89, C99, POSIX.1-2001, "
"POSIX.1-2008 に準拠している。"

#. type: Plain text
#: build/C/man3/ferror.3:141
msgid "The function B<fileno>()  conforms to POSIX.1-2001 and POSIX.1-2008."
msgstr "関数 B<fileno>() は POSIX.1-2001 と POSIX.1-2008 に準拠している。"

#. type: Plain text
#: build/C/man3/ferror.3:146
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fflush.3:45
#, no-wrap
msgid "FFLUSH"
msgstr "FFLUSH"

#. type: Plain text
#: build/C/man3/fflush.3:48
msgid "fflush - flush a stream"
msgstr "fflush - ストリームの内容を強制的に出力(フラッシュ)する"

#. type: Plain text
#: build/C/man3/fflush.3:52
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr "B<int fflush(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fflush.3:58
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function."
msgstr ""
"出力ストリームに関しては、 B<fflush>()  は、ユーザー空間でバッファーリングさ"
"れているすべてのデータを 指定された出力に書き出す (フラッシュする)、 もしくは"
"ストリーム I<stream> の下位にある書き込み関数を用いてこのストリームを更新す"
"る。"

#. type: Plain text
#: build/C/man3/fflush.3:64
msgid ""
"For input streams associated with seekable files (e.g., disk files, but not "
"pipes or terminals), B<fflush>()  discards any buffered data that has been "
"fetched from the underlying file, but has not been consumed by the "
"application."
msgstr ""
"seek 可能なファイルに関連付けられた入力ストリーム (ディスクファイルは seek 可"
"能だが、 パイプや端末は seek できない) に関しては、 B<fflush>()  は、対応する"
"ファイルから取得されたが、アプリケーションからは 読み出されていないバッファー"
"データを全て破棄する。"

#. type: Plain text
#: build/C/man3/fflush.3:66
msgid "The open status of the stream is unaffected."
msgstr ""
"ストリームは開いた状態のままであり、 この関数によって何の影響も受けない。"

#.  mtk: POSIX specifies that only output streams are flushed for this case.
#.  Also verified for glibc by experiment.
#. type: Plain text
#: build/C/man3/fflush.3:76
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""
"I<stream> 引数が NULL ならば、 B<fflush>()  は開いているI<すべての>出力スト"
"リームをフラッシュする。"

#. type: Plain text
#: build/C/man3/fflush.3:79
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""
"これらの処理をロックせずに行いたいときは、 B<unlocked_stdio>(3)  を参照のこ"
"と。"

#. type: Plain text
#: build/C/man3/fflush.3:86
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると 0 が返される。 その他の場合には B<EOF> が返され、 I<errno> が、エ"
"ラーに対応した値に設定される。"

#. type: Plain text
#: build/C/man3/fflush.3:91
msgid "I<stream> is not an open stream, or is not open for writing."
msgstr ""
"I<stream> は開いているストリームではない。 あるいはストリームは書き込み用では"
"ない。"

#. type: Plain text
#: build/C/man3/fflush.3:98
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""
"B<fflush>()  関数は B<write>(2)  に関して規定されているエラーで失敗することも"
"ある。 この場合 I<errno> もその値に設定される。"

#. type: tbl table
#: build/C/man3/fflush.3:108
#, no-wrap
msgid "B<fflush>()"
msgstr "B<fflush>()"

#. type: Plain text
#: build/C/man3/fflush.3:112
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C89, C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/fflush.3:115
msgid ""
"POSIX.1-2001 did not specify the behavior for flushing of input streams, but "
"the behavior is specified in POSIX.1-2008."
msgstr ""
"POSIX.1-2001 では入力ストリームのフラッシュの動作は規定されていなかったが、 "
"POSIX.1-2008 では規定されている。"

#. type: Plain text
#: build/C/man3/fflush.3:124
msgid ""
"Note that B<fflush>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"B<fflush>()  は、 C ライブラリが与えているユーザー空間のバッファーしかフラッ"
"シュしない。 データが物理的にディスクに保存されることを保証したければ、 カー"
"ネルバッファーもフラッシュしなければならない。 これには例えば B<sync>(2)  や "
"B<fsync>(2)  を用いる。"

#. type: Plain text
#: build/C/man3/fflush.3:133
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), "
"B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr "B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fgetc.3:27
#, no-wrap
msgid "FGETC"
msgstr "FGETC"

#. type: TH
#: build/C/man3/fgetc.3:27 build/C/man3/fopen.3:44 build/C/man2/link.2:32
#: build/C/man2/llseek.2:29 build/C/man3/puts.3:26 build/C/man2/readv.2:32
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man3/fgetc.3:30
msgid "fgetc, fgets, getc, getchar, ungetc - input of characters and strings"
msgstr "fgetc, fgets, getc, getchar, ungetc - 文字と文字列の入力"

#. type: Plain text
#: build/C/man3/fgetc.3:35
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr "B<int fgetc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetc.3:37
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetc.3:39
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr "B<int getc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetc.3:41
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr "B<int getchar(void);>\n"

#. type: Plain text
#: build/C/man3/fgetc.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetc.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""
"B<fgetc>()  は、 I<stream> から次の文字を I<unsigned char> として読み、 "
"I<int> にキャストして返す。ファイルの終わりやエラーとなった場合は B<EOF> を返"
"す。"

#. type: Plain text
#: build/C/man3/fgetc.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"B<getc>()  は B<fgetc>()  と同様だが、 I<stream> を複数回評価するマクロとして"
"実装されているかもしれない。"

#. type: Plain text
#: build/C/man3/fgetc.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr "B<getchar>()  は B<getc(>I<stdin>B<)> と同じである。"

#. type: Plain text
#: build/C/man3/fgetc.3:80
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream> "
"and stores them into the buffer pointed to by I<s>.  Reading stops after an "
"B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  A "
"terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character "
"in the buffer."
msgstr ""
"B<fgets>()  は I<stream> から最大で I<size> - 1 個の文字を読み込み、 I<s> が"
"指すバッファーに格納する。読み込みは B<EOF> または改行文字を読み込んだ後で停"
"止する。 読み込まれた改行文字はバッファーに格納される。 終端のヌルバイト "
"(\\(aq\\e0\\(aq)  が一つバッファーの中の最後の文字の後に書き込まれる。"

#. type: Plain text
#: build/C/man3/fgetc.3:91
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will "
"be returned in reverse order; only one pushback is guaranteed."
msgstr ""
"B<ungetc>()  は、後の read 操作で読めるように、 I<c> を I<unsigned char> に"
"キャストして I<stream> に書き戻す。 書き戻された文字は逆順に戻される; 書き戻"
"しとして保証されているのは、一文字だけである。"

#. type: Plain text
#: build/C/man3/fgetc.3:96
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""
"ここで述べた関数や I<stdio> ライブラリの入力関数を同じ入力ストリームに対して"
"互いに混ぜて使うことができる。"

#. type: Plain text
#: build/C/man3/fgetc.3:111
msgid ""
"B<fgetc>(), B<getc>(), and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""
"B<fgetc>(), B<getc>(), B<getchar>()  は、文字を I<unsigned char> として読ん"
"で I<int> にキャストして返す。ファイルの終わりやエラーの場合は B<EOF> を返"
"す。"

#. type: Plain text
#: build/C/man3/fgetc.3:117
msgid ""
"B<fgets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read."
msgstr ""
"B<fgets>() は、成功すると I<s> を返し、エラーや 1 文字も読み込んでいないのに"
"ファイルの終わりになった 場合に NULL を返す。"

#. type: Plain text
#: build/C/man3/fgetc.3:124
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr "B<ungetc>()  は成功すると I<c> を返し、エラーの場合は B<EOF> を返す。"

#. type: tbl table
#: build/C/man3/fgetc.3:136
#, no-wrap
msgid ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"
msgstr ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"

#. type: tbl table
#: build/C/man3/fgetc.3:139
#, no-wrap
msgid ""
"B<getchar>(),\n"
"B<ungetc>()"
msgstr ""
"B<getchar>(),\n"
"B<ungetc>()"

#. type: Plain text
#: build/C/man3/fgetc.3:151
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""
"入力ストリームのファイルディスクリプターに対して、 I<stdio> ライブラリの入力"
"関数と、低レベル呼び出しの B<read>(2)  を混ぜて呼び出す事は勧められない。 結"
"果がどうなるかは分からず、おそらくあなたの 望んでいる結果にはならないだろう。"

#. type: Plain text
#: build/C/man3/fgetc.3:168
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"

#. type: TH
#: build/C/man3/fgetwc.3:18
#, no-wrap
msgid "FGETWC"
msgstr "FGETWC"

#. type: TH
#: build/C/man3/fgetwc.3:18 build/C/man2/rmdir.2:30
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: build/C/man3/fgetwc.3:21
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr "fgetwc, getwc - ワイド文字を FILE ストリームから読み込む"

#. type: Plain text
#: build/C/man3/fgetwc.3:25 build/C/man3/fputwc.3:23 build/C/man3/wprintf.3:24
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fgetwc.3:28
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetwc.3:43
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns "
"it.  If the end of stream is reached, or if I<ferror(stream)> becomes true, "
"it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""
"B<fgetwc>()  関数は、 B<fgetc>(3)  に対応するワイド文字関数である。 この関数"
"は I<stream> からワイド文字を 1 文字読み込み、これを返す。 ストリームの終端に"
"達するか、I<ferror(stream)> が真になった場合には、 この関数は B<WEOF> を返"
"す。 ワイド文字変換でエラーが発生した場合は、 I<errno> に B<EILSEQ> をセット"
"し、 B<WEOF> を返す。"

#. type: Plain text
#: build/C/man3/fgetwc.3:51
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"B<getwc>()  関数あるいはマクロは、 B<fgetwc>()  と全く同じ動作をする。 この関"
"数はマクロとして実装されるかもしれないので、引数が複数回評価さ れるかもしれ"
"ない。この関数を使う理由はもはや存在しない。"

#. type: Plain text
#: build/C/man3/fgetwc.3:63
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"B<fgetwc>()  関数はストリームの次のワイド文字か、あるいは B<WEOF> を返す。 エ"
"ラーが起こった場合、 I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man3/fgetwc.3:65 build/C/man3/fputwc.3:64
msgid "Apart from the usual ones, there is"
msgstr "通常のエラーに加えて、以下のエラーがある:"

#. type: TP
#: build/C/man3/fgetwc.3:65 build/C/man3/fputwc.3:64 build/C/man3/scanf.3:568
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: build/C/man3/fgetwc.3:69
msgid ""
"The data obtained from the input stream does not form a valid character."
msgstr "入力ストリームから取得したデータが、正しい文字でない。"

#. type: tbl table
#: build/C/man3/fgetwc.3:80
#, no-wrap
msgid ""
"B<fgetwc>(),\n"
"B<getwc>()"
msgstr ""
"B<fgetwc>(),\n"
"B<getwc>()"

#. type: Plain text
#: build/C/man3/fgetwc.3:84 build/C/man3/fputwc.3:83 build/C/man3/wprintf.3:230
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: build/C/man3/fgetwc.3:91
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""
"B<fgetwc>()  の動作は、現在のロケールの B<LC_CTYPE> カテゴリーに依存する。"

#. type: Plain text
#: build/C/man3/fgetwc.3:99
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""
"B<fopen>(3)  システムコールに渡す追加情報がない場合には、 B<fgetwc>()  が実"
"際 にはマルチバイトシーケンスをストリームから読み込み、これをワイド文字に 変"
"換すると期待することは適切である。"

#. type: Plain text
#: build/C/man3/fgetwc.3:104
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/flockfile.3:25
#, no-wrap
msgid "FLOCKFILE"
msgstr "FLOCKFILE"

#. type: TH
#: build/C/man3/flockfile.3:25 build/C/man3/fmtmsg.3:13
#: build/C/man3/open_memstream.3:9 build/C/man2/pipe.2:36
#: build/C/man2/readlink.2:44 build/C/man2/rename.2:33
#: build/C/man7/symlink.7:37
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/flockfile.3:28
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr "flockfile, ftrylockfile, funlockfile - 標準入出力 FILE のロックを行う"

#. type: Plain text
#: build/C/man3/flockfile.3:35
#, no-wrap
msgid ""
"B<void flockfile(FILE *>I<filehandle>B<);>\n"
"B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
"B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:44 build/C/man3/wprintf.3:43
msgid "All functions shown above:"
msgstr "上記の全ての関数:"

#. type: Plain text
#: build/C/man3/flockfile.3:48
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:62
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""
"標準入出力関数はスレッドセーフである。これは、各 I<FILE> オブジェクトに対し、"
"ロック数 (lockcount) と (ロック数が 0 でない場合は) 所有者スレッド (owner "
"thread)  を管理することで実現される。 ライブラリの呼び出しが行われる毎に、標"
"準入出力関数は I<FILE> オブジェクトが他のスレッドによってロックされていない状"
"態になるまで待ち、 I<FILE> オブジェクトをロックし、要求されて入出力を行い、 "
"オブジェクトのロックを解除する。"

#. type: Plain text
#: build/C/man3/flockfile.3:68
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""
"(注: このロックは、 B<flock>(2)  や B<lockf>(3)  といった関数が行うロックとは"
"全く無関係である。)"

#. type: Plain text
#: build/C/man3/flockfile.3:76
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the "
"I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""
"これらのことはすべて C プログラマには見えない部分で行われるが、 より細かい制"
"御ができた方がよい理由が2つあるだろう。一つは、一つのスレッドが 行う一連の入"
"出力動作は一緒に行われ、他のスレッドの入出力によって中断されない 方がよいとい"
"うことであろう。もう一つは、効率を大きく上げるためには ロックのオーバヘッドを"
"避ける必要があるということであろう。"

#. type: Plain text
#: build/C/man3/flockfile.3:93
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming "
"in between.  If the reason for doing this was to achieve greater efficiency, "
"one does the I/O with the nonlocking versions of the stdio functions: with "
"B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of B<getc>(3)  and "
"B<putc>(3)."
msgstr ""
"この目的を実現するために、 I<FILE> オブジェクトのロック、一連の入出力動作の実"
"行、 ロックの解除をスレッドが明示的に指示することができる。 これにより、他の"
"スレッドが途中で入出力を行うのを防止する。 このようなことを行う理由が効率の向"
"上であるならば、 ロックを行わないバージョンの標準入出力関数を使うこともでき"
"る。 例えば、 B<getc>(3)  や B<putc>(3)  の代わりに B<getc_unlocked>(3)  や "
"B<putc_unlocked>(3)  を使用する。"

#. type: Plain text
#: build/C/man3/flockfile.3:104
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked "
"by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""
"B<flockfile>()  関数は、I<*filehandle> が他のスレッドにロックされていな い状"
"態になるまで待ったのち、現在のスレッドを I<*filehandle> のオーナに設 定し、"
"ロック数を加算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:108
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr "B<funlockfile>()  関数は、ロック数を減算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:119
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>().  "
"It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""
"B<ftrylockfile>()  関数は B<flockfile>()  のブロッキングを行わない バージョン"
"である。他のスレッドが I<*filehandle> をロックしている時は 何も行わず、そうで"
"ない場合は I<*filehandle> の所有権を獲得し、 ロック数を加算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:124
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""
"B<ftrylockfile>()  関数はロックに成功すると 0 を返し、 失敗した場合は 0 以外"
"の値を返す。"

#. type: Plain text
#: build/C/man3/flockfile.3:126
msgid "None."
msgstr "なし。"

#. type: tbl table
#: build/C/man3/flockfile.3:138
#, no-wrap
msgid ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"
msgstr ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"

#. type: Plain text
#: build/C/man3/flockfile.3:142 build/C/man3/popen.3:193
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/flockfile.3:146
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""
"B<_POSIX_THREAD_SAFE_FUNCTIONS> が定義されているときにこれらの関数を使用する"
"ことができる。"

#. type: Plain text
#: build/C/man3/flockfile.3:148
msgid "B<unlocked_stdio>(3)"
msgstr "B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fmemopen.3:7
#, no-wrap
msgid "FMEMOPEN"
msgstr "FMEMOPEN"

#. type: TH
#: build/C/man3/fmemopen.3:7
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man3/fmemopen.3:10
msgid "fmemopen - open memory as stream"
msgstr "fmemopen - メモリーをストリームとしてオープンする"

#. type: Plain text
#: build/C/man3/fmemopen.3:15
#, no-wrap
msgid "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:23
msgid "B<fmemopen>():"
msgstr "B<fmemopen>():"

#. type: TP
#: build/C/man3/fmemopen.3:26 build/C/man3/getline.3:49 build/C/man2/link.2:57
#: build/C/man2/open.2:83 build/C/man3/open_memstream.3:33
#: build/C/man3/printf.3:75 build/C/man2/readlink.2:78 build/C/man2/rename.2:62
#: build/C/man2/symlink.2:66 build/C/man2/unlink.2:57
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/fmemopen.3:29 build/C/man3/getline.3:52 build/C/man2/link.2:60
#: build/C/man2/open.2:86 build/C/man3/open_memstream.3:36
#: build/C/man3/printf.3:78 build/C/man2/readlink.2:81 build/C/man2/rename.2:65
#: build/C/man2/symlink.2:69 build/C/man2/unlink.2:60
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man3/fmemopen.3:29 build/C/man3/getline.3:52 build/C/man2/link.2:60
#: build/C/man2/open.2:86 build/C/man3/open_memstream.3:36
#: build/C/man3/printf.3:78 build/C/man2/readlink.2:81 build/C/man2/rename.2:65
#: build/C/man2/symlink.2:69 build/C/man2/unlink.2:60
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/fmemopen.3:32 build/C/man3/getline.3:55
#: build/C/man3/open_memstream.3:39 build/C/man3/printf.3:81
#: build/C/man2/rename.2:72 build/C/man3/unlocked_stdio.3:106
#, no-wrap
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/fmemopen.3:43
#, fuzzy
#| msgid ""
#| "The B<fmemopen>()  function opens a stream that permits the access "
#| "specified by I<mode>.  The stream allows I/O to be performed on the "
#| "string or memory buffer pointed to by I<buf>.  This buffer must be at "
#| "least I<size> bytes long."
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified "
"by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>."
msgstr ""
"B<fmemopen>()  関数は、ストリームをオープンし、そのストリームに I<mode> で指"
"定されたアクセス許可を設定する。 そのストリームを通じて、 I<buf> で指定された"
"文字列やメモリーバッファーへの読み書きができる。 このバッファーは少なくとも "
"I<size> バイトの長さでなければならない。"

#. type: Plain text
#: build/C/man3/fmemopen.3:48
#, fuzzy
#| msgid ""
#| "The I<flags> argument is a bit mask consisting of zero or more of the "
#| "following flags:"
msgid ""
"The I<mode> argument specifies the semantics of I/O on the stream, and is "
"one of the following:"
msgstr "I<flags> 引数は、以下のフラグの 0 個以上のビットマスクである。"

#. type: tbl table
#: build/C/man3/fmemopen.3:48 build/C/man3/fopen.3:165
#, no-wrap
msgid "I<r>"
msgstr "I<r>"

#. type: Plain text
#: build/C/man3/fmemopen.3:51
msgid "The stream is opened for reading."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:51 build/C/man3/fopen.3:166
#, no-wrap
msgid "I<w>"
msgstr "I<w>"

#. type: Plain text
#: build/C/man3/fmemopen.3:54
#, fuzzy
#| msgid "I<stream> is not an open stream, or is not open for writing."
msgid "The stream is opened for writing."
msgstr ""
"I<stream> は開いているストリームではない。 あるいはストリームは書き込み用では"
"ない。"

#. type: tbl table
#: build/C/man3/fmemopen.3:54 build/C/man3/fopen.3:167
#, no-wrap
msgid "I<a>"
msgstr "I<a>"

#. type: Plain text
#: build/C/man3/fmemopen.3:58
msgid ""
"Append; open the stream for writing, with the initial buffer position set to "
"the first null byte."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:58 build/C/man3/fopen.3:168
#, no-wrap
msgid "I<r+>"
msgstr "I<r+>"

#. type: Plain text
#: build/C/man3/fmemopen.3:61
msgid "Open the stream for reading and writing."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:61 build/C/man3/fopen.3:169
#, no-wrap
msgid "I<w+>"
msgstr "I<w+>"

#. type: Plain text
#: build/C/man3/fmemopen.3:66
#, fuzzy
#| msgid ""
#| "Open for reading and writing.  The file is created if it does not exist, "
#| "otherwise it is truncated.  The stream is positioned at the beginning of "
#| "the file."
msgid ""
"Open the stream for reading and writing.  The buffer contents are truncated "
"(i.e., \\(aq\\e0\\(aq is placed in the first byte of the buffer)."
msgstr ""
"読み出しおよび書き込みのために開く。 ファイルが存在していない場合には新たに作"
"成する。 存在している場合には長さゼロに切り詰められる。 ストリームはファイル"
"の先頭に位置される。"

#. type: tbl table
#: build/C/man3/fmemopen.3:66 build/C/man3/fopen.3:170
#, no-wrap
msgid "I<a+>"
msgstr "I<a+>"

#. type: Plain text
#: build/C/man3/fmemopen.3:70
#, fuzzy
#| msgid ""
#| "Open for reading and writing.  The stream is positioned at the beginning "
#| "of the file."
msgid ""
"Append; open the stream for reading and writing, with the initial buffer "
"position set to the first null byte."
msgstr ""
"読み出しおよび書き込みするために開く。 ストリームはファイルの先頭に位置され"
"る。"

#. type: Plain text
#: build/C/man3/fmemopen.3:83
msgid ""
"The stream maintains the notion of a current position, the location where "
"the next I/O operation will be performed.  The current position is "
"implicitly updated by I/O operations.  It can be explicitly updated using "
"B<fseek>(3), and determined using B<ftell>(3).  In all modes other than "
"append, the initial position is set to the start of the buffer.  In append "
"mode, if no null byte is found within the buffer, then the initial position "
"is I<size+1>."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:98
#, fuzzy
#| msgid ""
#| "If I<buf> is specified as NULL, then B<fmemopen>()  dynamically allocates "
#| "a buffer I<size> bytes long.  This is useful for an application that "
#| "wants to write data to a temporary buffer and then read it back again.  "
#| "The buffer is automatically freed when the stream is closed.  Note that "
#| "the caller has no way to obtain a pointer to the temporary buffer "
#| "allocated by this call (but see B<open_memstream>()  below)."
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  allocates a buffer of "
"I<size> bytes.  This is useful for an application that wants to write data "
"to a temporary buffer and then read it back again.  The initial position is "
"set to the start of the buffer.  The buffer is automatically freed when the "
"stream is closed.  Note that the caller has no way to obtain a pointer to "
"the temporary buffer allocated by this call (but see B<open_memstream>(3))."
msgstr ""
"I<buf> に NULL が指定された場合、 B<fmemopen>()  は動的に I<size> バイトの長"
"さのバッファーを確保する。 この方法は、一時バッファーにデータの書き込みを行っ"
"てから、 その内容を再度読み出すようなアプリケーションで有用である。 このバッ"
"ファーはストリームがクローズされるときに自動的に解放される。 呼び出し元からは"
"この関数が割り当てた一時バッファーへのポインター値を 知る方法は存在しない点に"
"注意 (下記の B<open_memstream>()  も参照)。"

#. type: Plain text
#: build/C/man3/fmemopen.3:104
msgid ""
"If I<buf> is not NULL, then it should point to a buffer of at least I<len> "
"bytes allocated by the caller."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:116
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or "
"closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in "
"the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""
"書き込み用にオープンされたストリームをフラッシュ (B<fflush>(3))  やクローズ "
"(B<fclose>(3))  した時に、 (バッファーに空きがあれば) ヌルバイトがバッファー"
"の末尾に書き込まれる。 このようにするためには、呼び出し元は バッファーに 1バ"
"イト余裕を作る (I<size> にこの 1バイトを含めた値を指定する) 必要がある。"

#. type: Plain text
#: build/C/man3/fmemopen.3:124
#, fuzzy
#| msgid ""
#| "In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer "
#| "do not cause read operations to return an end-of-file indication.  A read "
#| "from the buffer will indicate end-of-file only when the file pointer "
#| "advances I<size> bytes past the start of the buffer."
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do "
"not cause read operations to return an end-of-file indication.  A read from "
"the buffer will indicate end-of-file only when the current buffer position "
"advances I<size> bytes past the start of the buffer."
msgstr ""
"読み出し用にオープンされたストリームでは、 バッファー内にヌルバイト (\\(aq"
"\\e0\\(aq) があっても 読み出し操作がファイル末尾 (end-of-file) を返すことはな"
"い。 バッファーからの読み出しでファイル末尾が返るのは、 ファイルポインターが"
"バッファーの先頭から I<size> バイトを越えて先に進もうとした場合だけである。"

#. type: Plain text
#: build/C/man3/fmemopen.3:128
msgid ""
"Write operations take place either at the current position (for modes other "
"than append), or at the current size of the stream (for append modes)."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:138
#, fuzzy
#| msgid ""
#| "Attempts to write more than I<size> bytes to the buffer result in an "
#| "error.  (By default, such errors will be visible only when the I<stdio> "
#| "buffer is flushed.  Disabling buffering with the following call may be "
#| "useful to detect errors at the time of an output operation:"
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error.  "
"By default, such errors will be visible (by the absence of data) only when "
"the I<stdio> buffer is flushed.  Disabling buffering with the following call "
"may be useful to detect errors at the time of an output operation:"
msgstr ""
"バッファーに I<size> バイトよりたくさん書き込もうとした場合には、エラーとな"
"る。 (デフォルトでは、このようなエラーが見えるのは I<stdio> バッファーがフ"
"ラッシュされた時だけである。 以下の呼び出しを使ってバッファーリングを無効にす"
"る方法は、 出力操作を行った時点でエラーを検出するのに役立つ。"

#. type: Plain text
#: build/C/man3/fmemopen.3:140
#, no-wrap
msgid "    setbuf(stream, NULL);\n"
msgstr "    setbuf(stream, NULL);\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:149
#, fuzzy
#| msgid ""
#| "Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  "
#| "return a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is "
#| "set to indicate the error."
msgid ""
"Upon successful completion, B<fmemopen>()  returns a I<FILE> pointer.  "
"Otherwise, NULL is returned and I<errno> is set to indicate the error."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  は成功すると I<FILE> 型のポインターを"
"返す。 失敗すると NULL が返され、 I<errno> がエラーを示す値にセットされる。"

#. type: SH
#: build/C/man3/fmemopen.3:149 build/C/man3/fmtmsg.3:219
#: build/C/man3/fseeko.3:98 build/C/man2/link.2:356 build/C/man2/open.2:1281
#: build/C/man2/openat2.2:467 build/C/man2/open_by_handle_at.2:380
#: build/C/man3/open_memstream.3:102 build/C/man3/perror.3:114
#: build/C/man2/pipe.2:191 build/C/man2/readlink.2:218 build/C/man2/readv.2:316
#: build/C/man2/rename.2:516 build/C/man2/symlink.2:227
#: build/C/man2/unlink.2:274
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/fmemopen.3:152
msgid "B<fmemopen>()  was already available in glibc 1.0.x."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:162
#, no-wrap
msgid "B<fmemopen>(),"
msgstr "B<fmemopen>(),"

#. type: Plain text
#: build/C/man3/fmemopen.3:169
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems."
msgstr "POSIX.1-2008. この関数は POSIX.1-2001 では規定されておらず、 Linux 以外のシステムで広く利用できるわけではない。"

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: build/C/man3/fmemopen.3:177
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""
"POSIX.1-2008 では I<mode> の \\(aqb\\(aq は無視されるべきだと規定されて\n"
"いる。一方、Technical Corrigendum (正誤表) 1 では、I<mode> の\n"
"\\(aqb\\(aq が指定された場合の扱いは実装依存であることを許容するように\n"
"標準規格が修正されており、glibc の \\(aqb\\(aq の扱いは許されている。"

#. type: Plain text
#: build/C/man3/fmemopen.3:183
msgid ""
"There is no file descriptor associated with the file stream returned by this "
"function (i.e., B<fileno>(3)  will return an error if called on the returned "
"stream)."
msgstr "この関数が返すファイルストリームに対応するファイルディスクリプターはない (つまり、返されたストリームに対して B<fileno>(3)  を呼び出すとエラーが返ることになる)。"

#. type: Plain text
#: build/C/man3/fmemopen.3:189
msgid ""
"With version 2.22, binary mode (see below) was removed, many longstanding "
"bugs in the implementation of B<fmemopen>()  were fixed, and a new versioned "
"symbol was created for this interface."
msgstr ""

#. type: SS
#: build/C/man3/fmemopen.3:189
#, no-wrap
msgid "Binary mode"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:202
#, fuzzy
#| msgid ""
#| "The argument I<mode> is the same as for B<fopen>(3).  If I<mode> "
#| "specifies an append mode, then the initial file position is set to the "
#| "location of the first null byte (\\(aq\\e0\\(aq) in the buffer; otherwise "
#| "the initial file position is set to the start of the buffer.  Since glibc "
#| "2.9, the letter \\(aqb\\(aq may be specified as the second character in "
#| "I<mode>.  This provides \"binary\" mode: writes don't implicitly add a "
#| "terminating null byte, and B<fseek>(3)  B<SEEK_END> is relative to the "
#| "end of the buffer (i.e., the value specified by the I<size> argument), "
#| "rather than the current string length."
msgid ""
"From version 2.9 to 2.21, the glibc implementation of B<fmemopen>()  "
"supported a \"binary\" mode, enabled by specifying the letter \\(aqb\\(aq as "
"the second character in I<mode>.  In this mode, writes don't implicitly add "
"a terminating null byte, and B<fseek>(3)  B<SEEK_END> is relative to the end "
"of the buffer (i.e., the value specified by the I<size> argument), rather "
"than the current string length."
msgstr ""
"引数 I<mode> は B<fopen>(3) の場合と同じである。 I<mode> で追記モード\n"
"(append mode) が指定された場合、ファイル位置の初期値は バッファー中の\n"
"最初のヌルバイト (\\(aq\\e0\\(aq) の位置に設定される。\n"
"それ以外の場合は、ファイル位置の初期値はバッファーの先頭になる。 \n"
"glibc 2.9 以降では、文字 \\(aqb\\(aq を I<mode> の二番目の文字として指定\n"
"することができる。 この文字は「バイナリ」モードを指定するものである。\n"
"このモードでは、書き込み時に文字列終端のヌルバイトが黙って追加 される\n"
"ことはない。また、 B<fseek>(3) B<SEEK_END> は、文字列の長さからの相対値\n"
"ではなく、バッファーの末尾 (I<size> で指定した値) からの相対値となる。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: build/C/man3/fmemopen.3:214
#, fuzzy
#| msgid ""
#| "To specify binary mode for B<fmemopen>()  the \\(aqb\\(aq must be the "
#| "I<second> character in I<mode>.  Thus, for example, \"wb+\" has the "
#| "desired effect, but \"w+b\" does not.  This is inconsistent with the "
#| "treatment of I<mode> by B<fopen>(3)."
msgid ""
"An API bug afflicted the implementation of binary mode: to specify binary "
"mode, the \\(aqb\\(aq must be the I<second> character in I<mode>.  Thus, for "
"example, \"wb+\" has the desired effect, but \"w+b\" does not.  This is "
"inconsistent with the treatment of I<mode> by B<fopen>(3)."
msgstr ""
"B<fmemopen>() でバイナリモードを指定するには、\n"
"\\(aqb\\(aq は I<mode> の I<2 文字目> でなければならない。\n"
"例えば、 \"wb+\" は意図通りの効果になるが、 \"w+b\" はそうではない。\n"
"これは B<fopen>(3) の I<mode> の扱いとは異なる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:218
msgid ""
"Binary mode was removed in glibc 2.22; a \\(aqb\\(aq specified in I<mode> "
"has no effect."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: build/C/man3/fmemopen.3:229
#, fuzzy
#| msgid ""
#| "If I<size> is specified as zero, B<fmemopen>()  fails with the error "
#| "B<EINVAL>.  It would be more consistent if this case successfully created "
#| "a stream that then returned end of file on the first attempt at reading.  "
#| "Furthermore, POSIX.1-2008 does not specify a failure for this case."
msgid ""
"In versions of glibc before 2.22, if I<size> is specified as zero, "
"B<fmemopen>()  fails with the error B<EINVAL>.  It would be more consistent "
"if this case successfully created a stream that then returned end-of-file on "
"the first attempt at reading; since version 2.22, the glibc implementation "
"provides that behavior."
msgstr ""
"I<size> に 0 が指定された場合、 B<fmemopen>() はエラー B<EINVAL> で失敗\n"
"する。この場合にはストリームの作成に成功して、最初の読み出しを行った際に\n"
"EOF (end of file) が返される方が、ストリームの扱いの一貫性が増すだろう。\n"
"また、 POSIX.1-2008 ではこの場合のエラーは規定されていない。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: build/C/man3/fmemopen.3:239
#, fuzzy
#| msgid ""
#| "Specifying append mode (\"a\" or \"a+\") for B<fmemopen>()  sets the "
#| "initial file position to the first null byte, but (if the file offset is "
#| "reset to a location other than the end of the stream)  does not force "
#| "subsequent writes to append at the end of the stream."
msgid ""
"In versions of glibc before 2.22, specifying append mode (\"a\" or \"a+\") "
"for B<fmemopen>()  sets the initial buffer position to the first null byte, "
"but (if the current position is reset to a location other than the end of "
"the stream)  does not force subsequent writes to append at the end of the "
"stream.  This bug is fixed in glibc 2.22."
msgstr ""
"B<fmemopen>() に追記モード (\"a\" や \"a+\") を指定すると、\n"
"ファイル位置の初期値は最初のヌルバイトに設定されるが、(ファイル\n"
"オフセットをストリームの末尾以外の位置に再設定した場合)それ以降の\n"
"書き込みではストリームの末尾への追記が行われる訳ではない。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: build/C/man3/fmemopen.3:256
#, fuzzy
#| msgid ""
#| "If the I<mode> argument to B<fmemopen>()  specifies append (\"a\" or \"a+"
#| "\"), and the I<size> argument does not cover a null byte in I<buf>, then, "
#| "according to POSIX.1-2008, the initial file position should be set to the "
#| "next byte after the end of the buffer.  However, in this case the glibc "
#| "B<fmemopen>()  sets the file position to -1."
msgid ""
"In versions of glibc before 2.22, if the I<mode> argument to B<fmemopen>()  "
"specifies append (\"a\" or \"a+\"), and the I<size> argument does not cover "
"a null byte in I<buf>, then, according to POSIX.1-2008, the initial buffer "
"position should be set to the next byte after the end of the buffer.  "
"However, in this case the glibc B<fmemopen>()  sets the buffer position to "
"-1.  This bug is fixed in glibc 2.22."
msgstr ""
"B<fmemopen>() の I<mode> 引数に追記モード (\"a\" や \"a+\") を指定し、\n"
"I<size> 引数で指定した範囲の I<buf> 内にヌルバイトがない場合、\n"
"POSIX.1-2008 では、ファイル位置の初期値はバッファーの末尾の直後の\n"
"バイトに設定すべきとされている。しかし、glibc の B<fmemopen>() では\n"
"この場合ファイル位置は -1 に設定される。"

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14292
#. type: Plain text
#: build/C/man3/fmemopen.3:273
msgid ""
"In versions of glibc before 2.22, when a call to B<fseek>(3)  with a "
"I<whence> value of B<SEEK_END> was performed on a stream created by "
"B<fmemopen>(), the I<offset> was I<subtracted> from the end-of-stream "
"position, instead of being added.  This bug is fixed in glibc 2.22."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: build/C/man3/fmemopen.3:281
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""
"glibc 2.9 での B<fmemopen>() の「バイナリ」モードの追加は、\n"
"ABI (Application Binary Interface) が黙って変更された。\n"
"それ以前の B<fmemopen>() では I<mode> 内の \\(aqb\\(aq は無視されていた。"

#. type: SH
#: build/C/man3/fmemopen.3:281 build/C/man3/fmtmsg.3:269
#: build/C/man3/fopencookie.3:259 build/C/man3/fread.3:120
#: build/C/man3/getline.3:161 build/C/man2/open_by_handle_at.2:470
#: build/C/man3/open_memstream.3:139 build/C/man2/pipe.2:219
#: build/C/man3/printf.3:1073 build/C/man2/readlink.2:275
#: build/C/man2/readv.2:410 build/C/man3/scanf.3:734
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/fmemopen.3:291
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>(3)  to open a dynamically sized output buffer.  The "
"program scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr "このプログラムは B<fmemopen>()  を使って出力バッファーをオープンし、 B<open_memstream>(3)  を使って動的にサイズが変化する出力バッファーをオープンしている。 (プログラムの第一コマンドライン引数から取った) 入力文字列を スキャンして整数を読み込み、これらの整数の二乗を出力バッファーに書き出す。 このプログラムの実行例は以下のようになる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:296
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"

#. type: SS
#: build/C/man3/fmemopen.3:298 build/C/man3/fopencookie.3:283
#: build/C/man3/fread.3:133 build/C/man2/pipe.2:235
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/fmemopen.3:305
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:308
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:325
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:329
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:334
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:339
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
msgstr ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:342
#, no-wrap
msgid ""
"    fclose(in);\n"
"    fclose(out);\n"
msgstr ""
"    fclose(in);\n"
"    fclose(out);\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:344
#, no-wrap
msgid "    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"
msgstr "    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:348
#, no-wrap
msgid ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:353
msgid "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"
msgstr "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"

#. type: TH
#: build/C/man3/fmtmsg.3:13
#, no-wrap
msgid "FMTMSG"
msgstr "FMTMSG"

#. type: Plain text
#: build/C/man3/fmtmsg.3:16
msgid "fmtmsg - print formatted error messages"
msgstr "fmtmsg - 整形されたエラーメッセージを表示する"

#. type: Plain text
#: build/C/man3/fmtmsg.3:19
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:23
#, no-wrap
msgid ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:34
msgid ""
"This function displays a message described by its arguments on the "
"device(s)  specified in the I<classification> argument.  For messages "
"written to I<stderr>, the format depends on the B<MSGVERB> environment "
"variable."
msgstr ""
"この関数は、引数で記述されたメッセージを、 I<classification> 引数で指定さ"
"れたデバイス上に表示する。 I<stderr> に書き出されるメッセージのフォーマット"
"は、 B<MSGVERB> 環境変数に依存する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:41
msgid ""
"The I<label> argument identifies the source of the message.  The string must "
"consist of two colon separated parts where the first part has not more than "
"10 and the second part not more than 14 characters."
msgstr ""
"I<label> 引数はメッセージの発生源を識別する。 この文字列はコロンで区切られ"
"た 2 つの部分から構成されていなければならない。 1 つ目の部分は 10 文字以内で"
"なければならず、 2 つ目の部分は 14 文字以内でなければならない。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:45
msgid "The I<text> argument describes the condition of the error."
msgstr "I<text> 引数にはエラー条件を記述する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:50
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""
"I<action> 引数にはエラーから回復するために利用可能なステップを記述する。 こ"
"れが表示される場合、\"TO FIX: \" が前に付く。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:58
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique "
"identification number."
msgstr ""
"I<tag> 引数はより多くの情報を見つけるためのオンラインドキュメントへの参照で"
"ある。 これは I<label> 値とユニークな識別番号を含んでいるべきである。"

#. type: SS
#: build/C/man3/fmtmsg.3:58
#, no-wrap
msgid "Dummy arguments"
msgstr "ダミー引数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:77
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed.  "
"The dummy severity value B<NO_SEV> (0) says that no severity is supplied.  "
"The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char\\ *)\\ 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""
"各引数にはダミーの値を入れることができる。 ダミーの I<classification> 値 "
"B<MM_NULLMC> (0L) は出力を何も指定しない。そのため何も表示されない。 ダミー"
"の I<severity> 値 B<NO_SEV> (0) は重大度 (severity) が与えられていないことを"
"表す。 値 B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> は "
"I<((char\\ *)\\ 0)> と空文字列の別名であり、 B<MM_NULLSEV> は B<NO_SEV> の別"
"名である。"

#. type: SS
#: build/C/man3/fmtmsg.3:77
#, no-wrap
msgid "The classification argument"
msgstr "classification 引数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:81
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr "I<classification> 引数は 4 種類の情報を記述する値の和である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:83
msgid "The first value defines the output channel."
msgstr "最初の値は出力チャンネルを定義する。"

#. type: TP
#: build/C/man3/fmtmsg.3:83
#, no-wrap
msgid "B<MM_PRINT>"
msgstr "B<MM_PRINT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:87
msgid "Output to I<stderr>."
msgstr "I<stderr> に出力する。"

#. type: TP
#: build/C/man3/fmtmsg.3:87
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr "B<MM_CONSOLE>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:90
msgid "Output to the system console."
msgstr "システムコンソールに出力する。"

#. type: TP
#: build/C/man3/fmtmsg.3:90
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr "B<MM_PRINT | MM_CONSOLE>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:93
msgid "Output to both."
msgstr "両方に出力する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:95
msgid "The second value is the source of the error:"
msgstr "2 番目の値はエラーの発生源である:"

#. type: TP
#: build/C/man3/fmtmsg.3:95
#, no-wrap
msgid "B<MM_HARD>"
msgstr "B<MM_HARD>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:98
msgid "A hardware error occurred."
msgstr "ハードウェアエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:98
#, no-wrap
msgid "B<MM_FIRM>"
msgstr "B<MM_FIRM>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:101
msgid "A firmware error occurred."
msgstr "ファームウェアエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:101
#, no-wrap
msgid "B<MM_SOFT>"
msgstr "B<MM_SOFT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:104
msgid "A software error occurred."
msgstr "ソフトウェアエラーが起こった。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:106
msgid "The third value encodes the detector of the problem:"
msgstr "3 番目の値は問題の検知を行ったものをエンコードする:"

#. type: TP
#: build/C/man3/fmtmsg.3:106
#, no-wrap
msgid "B<MM_APPL>"
msgstr "B<MM_APPL>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:109
msgid "It is detected by an application."
msgstr "アプリケーションによって検知された。"

#. type: TP
#: build/C/man3/fmtmsg.3:109
#, no-wrap
msgid "B<MM_UTIL>"
msgstr "B<MM_UTIL>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:112
msgid "It is detected by a utility."
msgstr "ユーティリティによって検知された。"

#. type: TP
#: build/C/man3/fmtmsg.3:112
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr "B<MM_OPSYS>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:115
msgid "It is detected by the operating system."
msgstr "オペレーティングシステムによって検知された。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:117
msgid "The fourth value shows the severity of the incident:"
msgstr "4 番目の値は問題の重大度を表す:"

#. type: TP
#: build/C/man3/fmtmsg.3:117
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr "B<MM_RECOVER>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:120
msgid "It is a recoverable error."
msgstr "回復可能なエラーである。"

#. type: TP
#: build/C/man3/fmtmsg.3:120
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr "B<MM_NRECOV>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:123
msgid "It is a nonrecoverable error."
msgstr "回復不可能なエラーである。"

#. type: SS
#: build/C/man3/fmtmsg.3:123
#, no-wrap
msgid "The severity argument"
msgstr "severity 引数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:127
msgid "The I<severity> argument can take one of the following values:"
msgstr "I<severity> 引数は以下の 1 つの値をとることができる。"

#. type: TP
#: build/C/man3/fmtmsg.3:127
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr "B<MM_NOSEV>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:130
msgid "No severity is printed."
msgstr "重大度は表示されない。"

#. type: TP
#: build/C/man3/fmtmsg.3:130
#, no-wrap
msgid "B<MM_HALT>"
msgstr "B<MM_HALT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:133
msgid "This value is printed as HALT."
msgstr "この値は HALT として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:133
#, no-wrap
msgid "B<MM_ERROR>"
msgstr "B<MM_ERROR>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:136
msgid "This value is printed as ERROR."
msgstr "この値は ERROR として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:136
#, no-wrap
msgid "B<MM_WARNING>"
msgstr "B<MM_WARNING>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:139
msgid "This value is printed as WARNING."
msgstr "この値は WARNING として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:139
#, no-wrap
msgid "B<MM_INFO>"
msgstr "B<MM_INFO>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:142
msgid "This value is printed as INFO."
msgstr "この値は INFO として表示される。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:149
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""
"数値の場合は 0 から 4 である。 B<addseverity>(3)  または環境変数 "
"B<SEV_LEVEL> を使うことにより、表示するレベルと文字列を更に追加できる。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:151
msgid "The function can return 4 values:"
msgstr "関数は 4 つの値を返す:"

#. type: TP
#: build/C/man3/fmtmsg.3:151
#, no-wrap
msgid "B<MM_OK>"
msgstr "B<MM_OK>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:154
msgid "Everything went smooth."
msgstr "全てがうまくいった。"

#. type: TP
#: build/C/man3/fmtmsg.3:154
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr "B<MM_NOTOK>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:157
msgid "Complete failure."
msgstr "完全に失敗した。"

#. type: TP
#: build/C/man3/fmtmsg.3:157
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr "B<MM_NOMSG>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:161
msgid "Error writing to I<stderr>."
msgstr "I<stderr> に書き込むときにエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:161
#, no-wrap
msgid "B<MM_NOCON>"
msgstr "B<MM_NOCON>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:164
msgid "Error writing to the console."
msgstr "コンソールに書き込むときにエラーが起こった。"

#. type: SH
#: build/C/man3/fmtmsg.3:164
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:175
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to "
"the console.)  When this variable is defined, is non-NULL, and is a colon-"
"separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""
"環境変数 B<MSGVERB> (\"message verbosity\") は I<stderr> への出力の一部を抑制"
"するのに使うことができる。 (コンソールへの出力には影響しない。)  この変数が定"
"義されて、NULL でなく、 コロンで区切られた有効なキーワードのリストである場"
"合、 キーワードに対応するメッセージの一部のみが表示される。 有効なキーワード"
"は \"label\", \"severity\", \"text\", \"action\", \"tag\" である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:187
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""
"環境変数 B<SEV_LEVEL> は新しい重大度レベルを導入するのに使用できる。 デフォル"
"トでは、上記の 5 つの重大度レベルのみが利用可能である。 他の数値の場合、 "
"B<fmtmsg>()  は何も表示しない。 B<fmtmsg>()  を初めて呼び出す前に、ユーザー"
"が B<SEV_LEVEL> を"

#. type: Plain text
#: build/C/man3/fmtmsg.3:190
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr "SEV_LEVEL=[description[:description[:...]]]"

#. type: Plain text
#: build/C/man3/fmtmsg.3:195
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr "のような形式でプロセスの環境に設定すると、 B<fmtmsg>()  は (標準のレベル 0\\(en4 に加えて) level に指定された値も受け付け、 そのようなレベルの問題が発生すると指定された printstring を表示する。 各 description は"

#. type: Plain text
#: build/C/man3/fmtmsg.3:198
msgid "severity-keyword,level,printstring"
msgstr "severity-keyword,level,printstring"

#. type: Plain text
#: build/C/man3/fmtmsg.3:205
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0\\(en4), and use the indicated printstring "
"when such a level occurs."
msgstr "という形式である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:219
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the "
"string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""
"severity-keyword 部は B<fmtmsg>()  に使用されないが、存在しなければならな"
"い。 level 部は数値を文字列で表したものである。 数値は 4 より大きい値でなけれ"
"ばならない。 この値は B<fmtmsg>()  の severity 引数で使用されなければなら"
"ず、この重大度を選択する。 前もって宣言された重大度を上書きすることはできな"
"い。 printstring は、 この重大度のメッセージが B<fmtmsg>()  によって生成され"
"た場合に表示される文字列である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:222
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr "B<fmtmsg>()  は、バージョン 2.1 以降の glibc で提供されている。"

#. type: tbl table
#: build/C/man3/fmtmsg.3:232
#, no-wrap
msgid "B<fmtmsg>()"
msgstr "B<fmtmsg>()"

#. type: tbl table
#: build/C/man3/fmtmsg.3:234
#, no-wrap
msgid "glibc E<gt>= 2.16: MT-Safe\n"
msgstr "glibc E<gt>= 2.16: MT-Safe\n"

#. type: tbl table
#: build/C/man3/fmtmsg.3:236
#, no-wrap
msgid "glibc E<lt> 2.16: MT-Unsafe"
msgstr "glibc E<lt> 2.16: MT-Unsafe"

#. type: Plain text
#: build/C/man3/fmtmsg.3:243
msgid ""
"Before glibc 2.16, the B<fmtmsg>()  function uses a static variable that is "
"not protected, so it is not thread-safe."
msgstr ""
"glibc 2.16 より前のバージョンでは、 B<fmtmsg>() 関数は、 保護されていない静的"
"な変数を使うため、 スレッドセーフではない。"

#.  Modified in commit 7724defcf8873116fe4efab256596861eef21a94
#. type: Plain text
#: build/C/man3/fmtmsg.3:249
msgid ""
"Since glibc 2.16, the B<fmtmsg>()  function uses a lock to protect the "
"static variable, so it is thread-safe."
msgstr ""
"glibc 2.16 以降では、 B<fmtmsg>() 関数はロックを使って静的な変数を保護してお"
"り、 スレッドセーフである。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:259
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V."
msgstr "関数 B<fmtmsg>()  と B<addseverity>(3)  と環境変数 B<MSGVERB> と B<SEV_LEVEL> は System V に由来している。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:265
msgid ""
"The function B<fmtmsg>()  and the environment variable B<MSGVERB> are "
"described in POSIX.1-2001 and POSIX.1-2008."
msgstr "関数 B<fmtmsg>() と環境変数 B<MSGVERB> は POSIX.1-2001 と POSIX.1-2008 に規定されている。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:269
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""
"System V と UnixWare の man ページには、 「これらの関数は \"pfmt() と "
"addsev()\" または \"pfmt(), vpfmt(), lfmt(), vlfmt()\" で置き換えられてお"
"り、 将来は削除される予定である」と書かれている。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:274
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:280
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:301
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"      break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:304
msgid "The output should be:"
msgstr "出力は"

#. type: Plain text
#: build/C/man3/fmtmsg.3:309
#, no-wrap
msgid ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: See mount(8).  util-linux:mount:017\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:313
msgid "and after"
msgstr "のようになり、"

#. type: Plain text
#: build/C/man3/fmtmsg.3:317
#, no-wrap
msgid "MSGVERB=text:action; export MSGVERB\n"
msgstr "MSGVERB=text:action; export MSGVERB\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:321
msgid "the output becomes:"
msgstr "を実行すると、次のようになる。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:326
#, no-wrap
msgid ""
"unknown mount option\n"
"TO FIX: See mount(8).\n"
msgstr ""
"unknown mount option\n"
"TO FIX: See mount(8).\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:331
msgid "B<addseverity>(3), B<perror>(3)"
msgstr "B<addseverity>(3), B<perror>(3)"

#. type: TH
#: build/C/man3/fopen.3:44
#, no-wrap
msgid "FOPEN"
msgstr "FOPEN"

#. type: Plain text
#: build/C/man3/fopen.3:47
msgid "fopen, fdopen, freopen - stream open functions"
msgstr "fopen, fdopen, freopen - ストリームを開く関数"

#. type: Plain text
#: build/C/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:56
#, no-wrap
msgid "B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"
msgstr "B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:65
msgid "B<fdopen>(): _POSIX_C_SOURCE"
msgstr "B<fdopen>(): _POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/fopen.3:71
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<pathname> and associates a stream with it."
msgstr "B<fopen>()  関数は、 I<pathname> で指定された名前のファイルを開き、ストリームと結びつける。"

#. type: Plain text
#: build/C/man3/fopen.3:76
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""
"引数 I<mode> は、以下に続く文字のひとつから始まる文字列へのポインターであ\n"
"る (以下の述べる、追加の文字が後に続くこともある):"

#. type: TP
#: build/C/man3/fopen.3:76
#, no-wrap
msgid "B<r>"
msgstr "B<r>"

#. type: Plain text
#: build/C/man3/fopen.3:80
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr ""
"テキストファイルを読み出すために開く。 ストリームはファイルの先頭に位置され"
"る。"

#. type: TP
#: build/C/man3/fopen.3:80
#, no-wrap
msgid "B<r+>"
msgstr "B<r+>"

#. type: Plain text
#: build/C/man3/fopen.3:84
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr ""
"読み出しおよび書き込みするために開く。 ストリームはファイルの先頭に位置され"
"る。"

#. type: TP
#: build/C/man3/fopen.3:84
#, no-wrap
msgid "B<w>"
msgstr "B<w>"

#. type: Plain text
#: build/C/man3/fopen.3:88
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is "
"positioned at the beginning of the file."
msgstr ""
"ファイルを書き込みのために開く。 ファイルが既に存在する場合には長さゼロに切り"
"詰める。 ファイルがなかった場合には新たに作成する。 ストリームはファイルの先"
"頭に位置される。"

#. type: TP
#: build/C/man3/fopen.3:88
#, no-wrap
msgid "B<w+>"
msgstr "B<w+>"

#. type: Plain text
#: build/C/man3/fopen.3:94
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the "
"file."
msgstr ""
"読み出しおよび書き込みのために開く。 ファイルが存在していない場合には新たに作"
"成する。 存在している場合には長さゼロに切り詰められる。 ストリームはファイル"
"の先頭に位置される。"

#. type: TP
#: build/C/man3/fopen.3:94 build/C/man3/scanf.3:459
#, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#: build/C/man3/fopen.3:99
msgid ""
"Open for appending (writing at end of file).  The file is created if it does "
"not exist.  The stream is positioned at the end of the file."
msgstr ""
"追加 (ファイルの最後に書き込む) のために開く。 ファイルが存在していない場合に"
"は新たに作成する。 ストリームはファイルの最後に位置される。"

#. type: TP
#: build/C/man3/fopen.3:99
#, no-wrap
msgid "B<a+>"
msgstr "B<a+>"

#. type: Plain text
#: build/C/man3/fopen.3:108
#, fuzzy
#| msgid ""
#| "Open for reading and appending (writing at end of file).  The file is "
#| "created if it does not exist.  The initial file position for reading is "
#| "at the beginning of the file, but output is always appended to the end of "
#| "the file."
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  Output is always appended to the end of the "
"file.  POSIX is silent on what the initial read position is when using this "
"mode.  For glibc, the initial file position for reading is at the beginning "
"of the file, but for Android/BSD/MacOS, the initial file position for "
"reading is at the end of the file."
msgstr ""
"読み出しおよび追加 (ファイルの最後に書き込む) のために開く。 ファイルが存在し"
"ていない場合には新たに作成する。 読み出しの初期ファイル位置はファイルの先頭で"
"あるが、 書き込みは常にファイルの最後に追加される。"

#. type: Plain text
#: build/C/man3/fopen.3:121
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the two-"
"character strings described above.  This is strictly for compatibility with "
"C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX conforming "
"systems, including Linux.  (Other systems may treat text files and binary "
"files differently, and adding the \\(aqb\\(aq may be a good idea if you do I/"
"O to a binary file and expect that your program may be ported to non-UNIX "
"environments.)"
msgstr ""
"I<mode> 文字列には文字 \\(aqb\\(aq を追加指定することができ、 I<mode> 文字列"
"の最後の文字として指定する。 上記のうち 2 文字のモードの場合には 2 つの文字の"
"間に指定することもできる。 これは C89 との互換性のためだけに用意された もので"
"あり、関数の実行に対してはいかなる影響も持たない。 すなわち、Linux を含む全て"
"の POSIX 準拠システムでは、 この \\(aqb\\(aq は無視される。 (その他のシステム"
"ではテキストファイルとバイナリファイルを別々に扱うものもあるので、 もしバイナ"
"リファイルの入出力を行い、 そのプログラムが非 UNIX 環境へ移植されると予測する"
"なら、 \\(aqb\\(aqを付けておくのは良い考えである)"

#. type: Plain text
#: build/C/man3/fopen.3:124
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr "I<mode> の glibc による拡張の詳細については下記の「注意」を参照。"

#. type: Plain text
#: build/C/man3/fopen.3:129
msgid ""
"Any created file will have the mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""
"すべての生成されたファイルは、 B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666) のモードを そのプロセスの umask "
"値によって修正したモードを持つ (B<umask>(2)  を見よ)。"

#. type: Plain text
#: build/C/man3/fopen.3:144
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note "
"that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a "
"stream.  This operation may be an apparent no-op (as in I<fseek(..., 0L, "
"SEEK_CUR)> called for its synchronizing side effect)."
msgstr ""
"読み出し/書き込みストリームに対しては任意の順序で読み書きを行うことができ"
"る。 ただし ANSI C では、 (入力操作がファイルの末尾に到達した場合を除いて)  "
"出力と入力の間にはファイルの位置決め関数を 挟まなければならないことになってい"
"ることに注意されたい (この条件を満足しない場合には、読み込み操作は、 最後に書"
"き込まれたものでなく、以前に書き込まれた 値を返すことを許されている)。 した"
"がって、このようなストリームでの読み書き操作の間には B<fseek>(3)  または "
"B<fgetpos>(3)  操作を挟んでおくと良いだろう (Linux では本当に必要となることも"
"ときどきある)。 この操作は見かけ上何もしない操作 (no-op) でも良い (例えば "
"I<fseek(..., 0L, SEEK_CUR)> を その副次的効果である同期のためだけに呼べば良"
"い)。"

#. type: Plain text
#: build/C/man3/fopen.3:149
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at end-of-"
"file, as if preceded the call:"
msgstr ""
"ファイルを追加モード (I<mode> の最初の文字を B<a> にする) で開くと、\n"
"このストリームに対する書き込み操作は全て (先に以下の呼び出しを行った\n"
"かのように) ファイルの末尾で行われる。"

#. type: Plain text
#: build/C/man3/fopen.3:153
#, no-wrap
msgid "fseek(stream, 0, SEEK_END);\n"
msgstr "fseek(stream, 0, SEEK_END);\n"

#. type: Plain text
#: build/C/man3/fopen.3:159
msgid ""
"The file descriptor associated with the stream is opened as if by a call to "
"B<open>(2)  with the following flags:"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:164
#, no-wrap
msgid "fopen() mode"
msgstr "fopen() モード"

#. type: tbl table
#: build/C/man3/fopen.3:164
#, no-wrap
msgid "open() flags"
msgstr "open() フラグ"

#. type: tbl table
#: build/C/man3/fopen.3:165
#, no-wrap
msgid "O_RDONLY"
msgstr "O_RDONLY"

#. type: tbl table
#: build/C/man3/fopen.3:166
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_TRUNC"
msgstr "O_WRONLY | O_CREAT | O_TRUNC"

#. type: tbl table
#: build/C/man3/fopen.3:167
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_APPEND"
msgstr "O_WRONLY | O_CREAT | O_APPEND"

#. type: tbl table
#: build/C/man3/fopen.3:168
#, no-wrap
msgid "O_RDWR"
msgstr "O_RDWR"

#. type: tbl table
#: build/C/man3/fopen.3:169
#, no-wrap
msgid "O_RDWR | O_CREAT | O_TRUNC"
msgstr "O_RDWR | O_CREAT | O_TRUNC"

#. type: tbl table
#: build/C/man3/fopen.3:170
#, no-wrap
msgid "O_RDWR | O_CREAT | O_APPEND"
msgstr "O_RDWR | O_CREAT | O_APPEND"

#. type: SS
#: build/C/man3/fopen.3:174
#, no-wrap
msgid "fdopen()"
msgstr "fdopen()"

#. type: Plain text
#: build/C/man3/fopen.3:196
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", \"r+"
"\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of the "
"file descriptor.  The file position indicator of the new stream is set to "
"that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by "
"B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""
"B<fdopen>()  関数は、既存のファイルディスクリプター I<fd> にストリームを結び"
"つける。 ストリームの I<mode> (\"r\", \"r+\", \"w\", \"w+\", \"a\", \"a+\" の"
"いずれか) は ファイルディスクリプターのモードと互換のものでなければならな"
"い。 新しいストリームのファイル位置指示子は I<fd> に属している値に設定され"
"る。 error と end-of-file の各指示子はクリアされる。 \"w\" および \"w+\" モー"
"ドでのファイルの切り詰めは行われない。 ファイルディスクリプターの複製は行なわ"
"れない。 B<fdopen>()  で作成されたストリームが閉じられたときにファイルディス"
"クリプターも 閉じられる。 共有メモリーのオブジェクトへ B<fdopen>()  を行った"
"ときの結果は定義されていない。"

#. type: SS
#: build/C/man3/fopen.3:196
#, no-wrap
msgid "freopen()"
msgstr "freopen()"

#. type: Plain text
#: build/C/man3/fopen.3:210
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<pathname> and associates the stream pointed to by I<stream> with "
"it.  The original stream (if it exists) is closed.  The I<mode> argument is "
"used just as in the B<fopen>()  function."
msgstr "B<freopen>()  関数は I<path> で名前が指定されたファイルを開き、 I<stream> で指定されたストリームに、そのファイルを結びつける。 もとのストリームは (もし存在する場合には) 閉じられる。 I<mode> 引数は B<fopen>()  関数と同じ形で使われる。"

#. type: Plain text
#: build/C/man3/fopen.3:221
msgid ""
"If the I<pathname> argument is a null pointer, B<freopen>()  changes the "
"mode of the stream to that specified in I<mode>; that is, B<freopen>()  "
"reopens the pathname that is associated with the stream.  The specification "
"for this behavior was added in the C99 standard, which says:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:230
msgid ""
"In this case, the file descriptor associated with the stream need not be "
"closed if the call to B<freopen>()  succeeds.  It is implementation-defined "
"which changes of mode are permitted (if any), and under what circumstances."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:236
msgid ""
"The primary use of the B<freopen>()  function is to change the file "
"associated with a standard text stream (I<stderr>, I<stdin>, or I<stdout>)."
msgstr "B<freopen>() 関数の主な用途は、標準テキストストリーム (I<stderr>, I<stdin>, I<stdout>)  と対応付けられているファイルを変更することである。"

#. type: Plain text
#: build/C/man3/fopen.3:248
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>(), and B<freopen>()  return "
"a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  は成功すると I<FILE> 型のポインターを"
"返す。 失敗すると NULL が返され、 I<errno> がエラーを示す値にセットされる。"

#. type: TP
#: build/C/man3/fopen.3:249 build/C/man3/fseek.3:137 build/C/man3/getline.3:128
#: build/C/man2/link.2:295 build/C/man2/llseek.2:93 build/C/man2/lseek.2:200
#: build/C/man2/open.2:1051 build/C/man2/open.2:1059 build/C/man2/open.2:1064
#: build/C/man2/open.2:1074 build/C/man2/open.2:1083 build/C/man2/openat2.2:423
#: build/C/man2/openat2.2:427 build/C/man2/openat2.2:436
#: build/C/man2/open_by_handle_at.2:304 build/C/man2/open_by_handle_at.2:308
#: build/C/man2/open_by_handle_at.2:356 build/C/man2/pipe.2:175
#: build/C/man2/read.2:135 build/C/man2/read.2:146 build/C/man2/readlink.2:173
#: build/C/man2/readlink.2:182 build/C/man2/readv.2:301
#: build/C/man2/readv.2:308 build/C/man2/rename.2:351 build/C/man2/rename.2:476
#: build/C/man2/rename.2:480 build/C/man2/rename.2:488
#: build/C/man2/rename.2:496 build/C/man2/rmdir.2:67 build/C/man3/scanf.3:575
#: build/C/man2/unlink.2:257 build/C/man2/write.2:183
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/fopen.3:259
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  で与えられた I<mode> が不適切である。"

#. type: Plain text
#: build/C/man3/fopen.3:269
msgid ""
"The B<fopen>(), B<fdopen>(), and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  関数は B<malloc>(3)  ルーチンで規定さ"
"れているエラーでも失敗することがあり、 その時は対応する値に I<errno> をセット"
"する。"

#. type: Plain text
#: build/C/man3/fopen.3:276
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""
"B<fopen>()  関数は B<open>(2)  ルーチンで規定されているエラーでも失敗すること"
"があり、 その時は対応する値に I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/fopen.3:283
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""
"B<fdopen>()  関数は B<fcntl>(2)  ルーチンで規定されているエラーでも失敗するこ"
"とがあり、 その時は対応する値に I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/fopen.3:293
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3), and B<fflush>(3)."
msgstr ""
"B<freopen>()  関数は B<open>(2), B<fclose>(3), B<fflush>(3)  各ルーチンで規定"
"されているエラーでも失敗することがあり、 その時は対応する値に I<errno> をセッ"
"トする。"

#. type: tbl table
#: build/C/man3/fopen.3:305
#, no-wrap
msgid ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"
msgstr ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"

#. type: Plain text
#: build/C/man3/fopen.3:311
msgid "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: build/C/man3/fopen.3:314
msgid "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."

#. type: SS
#: build/C/man3/fopen.3:315 build/C/man2/link.2:407 build/C/man2/readlink.2:262
#: build/C/man2/rename.2:534 build/C/man2/symlink.2:250
#: build/C/man2/unlink.2:287
#, no-wrap
msgid "Glibc notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man3/fopen.3:318
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr ""
"GNU C ライブラリでは、 I<mode> に指定できる文字列として、以下の拡張が行われて"
"いる:"

#. type: TP
#: build/C/man3/fopen.3:318
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr "B<c> (glibc 2.3.3 以降)"

#. type: Plain text
#: build/C/man3/fopen.3:325
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""
"open 操作、それに続く read/write 操作の、 スレッドの取り消しポイント\n"
"(cancellation points) を作成しない。\n"
"このフラグは B<fdopen>() では無視される。"

#. type: TP
#: build/C/man3/fopen.3:325
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr "B<e> (glibc 2.7 以降)"

#. type: Plain text
#: build/C/man3/fopen.3:335
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""
"B<O_CLOEXEC> フラグを有効にしてファイルをオープンする。詳細は\n"
"B<open>(2) を参照。このフラグは B<fdopen>() では無視される。"

#. type: TP
#: build/C/man3/fopen.3:335
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr "B<m> (glibc 2.3 以降)"

#.  As at glibc 2.4:
#. type: Plain text
#: build/C/man3/fopen.3:347
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is attempted only "
"for a file opened for reading."
msgstr ""
"I/O システムコール (B<read>(2), B<write>(2))  ではなく、 B<mmap>(2)  を使って"
"ファイルにアクセスしようとする。 B<mmap>(2)  を使おうとするのは、読み出し用に"
"オープンするファイルについてだけである。"

#. type: TP
#: build/C/man3/fopen.3:347 build/C/man3/scanf.3:428
#, no-wrap
msgid "B<x>"
msgstr "B<x>"

#.  Since glibc 2.0?
#.  FIXME . C11 specifies this flag
#. type: Plain text
#: build/C/man3/fopen.3:364
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""
"ファイルを排他的にオープンする (B<open>(2)  の B<O_EXCL> フラグと同様)。 ファ"
"イルがすでに存在する場合、 B<fopen>()  は失敗し、 I<errno> に B<EEXIST> が"
"セットされる。 このフラグは B<fdopen>()  では無視される。"

#. type: Plain text
#: build/C/man3/fopen.3:372
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""
"上記の文字に加えて、\n"
"B<fopen>() と B<freopen>() では I<mode> に\n"
"以下の書式を 指定することができる。"

#. type: Plain text
#: build/C/man3/fopen.3:374
msgid "B< ,ccs=>I<string>"
msgstr "B< ,ccs=>I<string>"

#. type: Plain text
#: build/C/man3/fopen.3:390
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the B<,"
"ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""
"指定された I<string> は、符号化文字集合の名前と解釈され、\n"
"ストリームではワイド文字のストリームとして扱われる。\n"
"内部変換関数で入出力時に文字集合 I<string> との変換が行われる。\n"
"書式 B<,ccs=>I<string> が指定されない場合は、\n"
"ストリームをワイド文字のストリームとして扱うかは\n"
"最初のファイル操作時に決定される。\n"
"最初のファイル操作がワイド文字操作であった場合は、\n"
"そのストリームはワイド文字のストリームとして扱われ、\n"
"符号化文字集合との変換を行う関数が読み込まれる。"

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: build/C/man3/fopen.3:407
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters "
"preceding the \"ccs\" specification), the glibc implementation of "
"B<fopen>()  and B<freopen>()  limits the number of characters examined in "
"I<mode> to 7 (or, in glibc versions before 2.14, to 6, which was not enough "
"to include possible specifications such as \"rb+cmxe\").  The current "
"implementation of B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""
"I<mode> の個々のフラグ文字 (\"ccs\" 指定の前の文字) を解釈する際に、\n"
"glibc の B<fopen>() と B<freopen>() の実装では、\n"
"I<mode> の確認を最大 7 文字しか行わないという制限がある\n"
"(バージョン 2.14 より前の glibc では最大 6 文字だが、\n"
"6 文字では \"rb+cmxe\" などの指定を行うには不十分であった)。\n"
"B<fdopen>() の現在の実装では最大 5 文字の I<mode> しか解釈されない。"

#. type: Plain text
#: build/C/man3/fopen.3:414
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), "
"B<open_memstream>(3)"
msgstr "B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), B<open_memstream>(3)"

#. type: TH
#: build/C/man3/fopencookie.3:26
#, no-wrap
msgid "FOPENCOOKIE"
msgstr "FOPENCOOKIE"

#. type: TH
#: build/C/man3/fopencookie.3:26 build/C/man3/getline.3:26
#: build/C/man3/lseek64.3:26 build/C/man2/open.2:51 build/C/man2/openat2.2:24
#: build/C/man2/open_by_handle_at.2:25 build/C/man3/perror.3:31
#: build/C/man3/printf.3:34
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:26 build/C/man2/link.2:32
#: build/C/man2/llseek.2:29 build/C/man2/lseek.2:46 build/C/man3/lseek64.3:26
#: build/C/man2/open.2:51 build/C/man2/openat2.2:24
#: build/C/man2/open_by_handle_at.2:25 build/C/man2/pipe.2:36
#: build/C/man2/read.2:36 build/C/man2/readlink.2:44 build/C/man2/readv.2:32
#: build/C/man2/rename.2:33 build/C/man2/rmdir.2:30 build/C/man3/setbuf.3:48
#: build/C/man3/stdin.3:13 build/C/man2/symlink.2:33 build/C/man7/symlink.7:37
#: build/C/man2/unlink.2:33 build/C/man2/write.2:39
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/fopencookie.3:29
msgid "fopencookie - opening a custom stream"
msgstr "fopencookie - 独自のストリームをオープンする"

#. type: Plain text
#: build/C/man3/fopencookie.3:36
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:49
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the "
"stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""
"B<fopencookie>() を使うと、 プログラマーは標準 I/O ストリームの独自の実装を作"
"成することができる。\n"
"この実装はストリームのデータを自分が選んだ場所に格納することができる。 例え"
"ば、 B<fopencookie>() は B<fmemopen>(3) を実装するのに使用されている。 "
"B<fmemopen>(3) はメモリー上のバッファーに格納されたデータに対するストリームイ"
"ンターフェースを提供している。"

#. type: Plain text
#: build/C/man3/fopencookie.3:51
msgid "In order to create a custom stream the programmer must:"
msgstr ""
"独自のストリームを作成するためには、 プログラマーは以下を行う必要がある。"

#. type: IP
#: build/C/man3/fopencookie.3:51 build/C/man3/fopencookie.3:54
#: build/C/man3/fopencookie.3:65 build/C/man2/lseek.2:165
#: build/C/man2/lseek.2:167 build/C/man2/lseek.2:170 build/C/man2/lseek.2:172
#: build/C/man2/lseek.2:174 build/C/man2/lseek.2:177 build/C/man2/lseek.2:181
#: build/C/man2/lseek.2:184 build/C/man2/open.2:528 build/C/man2/open.2:532
#: build/C/man2/open.2:643 build/C/man2/open.2:645 build/C/man2/open.2:650
#: build/C/man2/open.2:653 build/C/man2/open.2:658 build/C/man2/open.2:664
#: build/C/man2/open.2:670 build/C/man2/open.2:676 build/C/man2/open.2:689
#: build/C/man2/open.2:869 build/C/man2/open.2:877 build/C/man2/open.2:1672
#: build/C/man2/open.2:1675 build/C/man2/open_by_handle_at.2:149
#: build/C/man2/open_by_handle_at.2:157 build/C/man2/open_by_handle_at.2:168
#: build/C/man2/open_by_handle_at.2:181 build/C/man2/pipe.2:102
#: build/C/man2/pipe.2:112 build/C/man2/pipe.2:122 build/C/man2/rename.2:217
#: build/C/man2/rename.2:220 build/C/man2/rename.2:222
#: build/C/man2/rename.2:229 build/C/man3/scanf.3:688 build/C/man3/scanf.3:693
#: build/C/man7/symlink.7:343 build/C/man7/symlink.7:353
#: build/C/man7/symlink.7:383 build/C/man7/symlink.7:443
#: build/C/man7/symlink.7:472 build/C/man7/symlink.7:501
#: build/C/man7/symlink.7:532 build/C/man7/symlink.7:545
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/fopencookie.3:54
msgid ""
"Implement four \"hook\" functions that are used internally by the standard I/"
"O library when performing I/O on the stream."
msgstr ""
"ストリームに対する I/O を実行する際に標準 I/O ライブラリが内部で使用する 4 つ"
"の \"フック\" 関数を実装する。"

#. type: Plain text
#: build/C/man3/fopencookie.3:65
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""
"\"cookie\" データ型を定義する。 \"cookie\" データ型は、上記のフック関数が使用"
"する管理情報 (例えば、データを格納する場所など) を提供する構造体である。 標準"
"の I/O パッケージにはこの cookie の内容に関する情報を持たないが (したがって "
"B<fopencookie>() に渡される際の型は I<void\\ *> である)、 フック関数が呼び出"
"される際に第一引数として cookie が渡される。"

#. type: Plain text
#: build/C/man3/fopencookie.3:70
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""
"B<fopencookie>() を呼び出して、新しいストリームをオープンし、 そのストリーム"
"に cookie とフック関数を関連付ける。"

#. type: Plain text
#: build/C/man3/fopencookie.3:78
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to "
"operate on that stream."
msgstr ""
"B<fopencookie>() 関数は B<fopen>(3) と同様の機能を持つ。 新しいストリームを"
"オープンし、 そのストリームに対して操作を行うのに使用する I<FILE> オブジェク"
"トへのポインターを返す。"

#. type: Plain text
#: build/C/man3/fopencookie.3:85
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is "
"to be associated with the new stream.  This pointer is supplied as the first "
"argument when the standard I/O library invokes any of the hook functions "
"described below."
msgstr ""
"I<cookie> 引数は、 新しいストリームに関連付けられる呼び出し元の cookie 構造"
"体へのポインターである。 このポインターは、 標準 I/O ライブラリが以下で説明す"
"るフック関数のいずれかを呼び出す際に第 1 引数として渡される。"

#. type: Plain text
#: build/C/man3/fopencookie.3:101
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""
"I<mode> 引数は B<fopen>(3) と同じ意味を持つ。 指定できるモードは I<r>, "
"I<w>, I<a>, I<r+>, I<w+>, I<a+> である。 詳細は B<fopen>(3) を参照。"

#. type: Plain text
#: build/C/man3/fopencookie.3:107
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""
"I<io_funcs> 引数は、 このストリームを実装するのに使用されるプログラマーが定"
"義した関数を指す 4 つのフィールドを持つ構造体である。 この構造体は以下のよう"
"に定義されている。"

#. type: Plain text
#: build/C/man3/fopencookie.3:116
#, no-wrap
msgid ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"
msgstr ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:120
msgid "The four fields are as follows:"
msgstr "4 つのフィールドの詳細は以下のとおりである。"

#. type: TP
#: build/C/man3/fopencookie.3:120
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr "I<cookie_read_function_t *read>"

#. type: Plain text
#: build/C/man3/fopencookie.3:124
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"この関数はストリームに対する read 操作を実装する。 呼び出される際、 3 つの引"
"数を受け取る。"

#. type: Plain text
#: build/C/man3/fopencookie.3:126
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr "    ssize_t read(void *cookie, char *buf, size_t size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:141
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""
"引数 I<buf> と I<size> は、 それぞれ、 入力データを配置できるバッファーとそ"
"のバッファーのサイズである。 関数の結果として、 I<read> 関数は I<buf> にコ"
"ピーされたバイト数を、 ファイル末尾の場合は 0 を、 エラーの場合は -1 を返"
"す。 I<read> 関数はストリームのオフセットを適切に更新すべきである。"

#. type: Plain text
#: build/C/man3/fopencookie.3:146
msgid ""
"If I<*read> is a null pointer, then reads from the custom stream always "
"return end of file."
msgstr ""
"I<*read> がヌルポインターの場合、 独自のストリームからの読み出しは常にファイ"
"ル末尾 (end of file) を返す。"

#. type: TP
#: build/C/man3/fopencookie.3:146
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr "I<cookie_write_function_t *write>"

#. type: Plain text
#: build/C/man3/fopencookie.3:150
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"この関数はストリームに対する write 操作を実装する。 呼び出される際、 3 つの引"
"数を受け取る。"

#. type: Plain text
#: build/C/man3/fopencookie.3:152
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr "    ssize_t write(void *cookie, const char *buf, size_t size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:168
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""
"引数 I<buf> と I<size> は、 それぞれ、 ストリームへの出力するデータが入った"
"バッファーとそのバッファーのサイズである。 関数の結果として、 I<write> 関数"
"は I<buf> からコピーされたバイト数を返し、 エラーの場合は -1 を返す。 (この関"
"数は負の値を返してはならない。) I<write> 関数はストリームのオフセットを適切に"
"更新すべきである。"

#. type: Plain text
#: build/C/man3/fopencookie.3:173
msgid "If I<*write> is a null pointer, then output to the stream is discarded."
msgstr ""
"I<*write> がヌルポインターの場合、 このストリームへの出力は破棄される。"

#. type: TP
#: build/C/man3/fopencookie.3:173
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr "I<cookie_seek_function_t *seek>"

#. type: Plain text
#: build/C/man3/fopencookie.3:177
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""
"この関数はストリームに対する seek 操作を実装する。 呼び出される際、 3 つの引"
"数を受け取る。"

#. type: Plain text
#: build/C/man3/fopencookie.3:179
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr "    int seek(void *cookie, off64_t *offset, int whence);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:185
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""
"I<*offset> 引数は新しいファイルオフセットを指定する。 新しいオフセットは "
"I<whence> に以下の値のどれが指定されたかに応じて決まる。"

#. type: TP
#: build/C/man3/fopencookie.3:186 build/C/man2/lseek.2:65
#, no-wrap
msgid "B<SEEK_SET>"
msgstr "B<SEEK_SET>"

#. type: Plain text
#: build/C/man3/fopencookie.3:191
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr ""
"ストリームオフセットを、ストリームの先頭から I<*offset> バイトの位置に設定す"
"る。"

#. type: TP
#: build/C/man3/fopencookie.3:191 build/C/man2/lseek.2:70
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr "B<SEEK_CUR>"

#. type: Plain text
#: build/C/man3/fopencookie.3:195
msgid "I<*offset> should be added to the current stream offset."
msgstr "ストリームの現在のオフセットに I<*offset> を加算する。"

#. type: TP
#: build/C/man3/fopencookie.3:195 build/C/man2/lseek.2:75
#, no-wrap
msgid "B<SEEK_END>"
msgstr "B<SEEK_END>"

#. type: Plain text
#: build/C/man3/fopencookie.3:199
msgid ""
"The stream offset should be set to the size of the stream plus I<*offset>."
msgstr ""
"ストリームのオフセットを、ストリームのサイズに I<*offset> を足した場所に設定"
"する。"

#. type: Plain text
#: build/C/man3/fopencookie.3:206
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""
"関数が返る前に、 I<seek> 関数はストリームの新しいオフセットを示すように "
"I<*offset> を更新すべきである。"

#. type: Plain text
#: build/C/man3/fopencookie.3:210
msgid ""
"As its function result, the I<seek> function should return 0 on success, and "
"-1 on error."
msgstr ""
"関数の結果として、 I<seek> 関数は成功すると 0 を、 エラーの場合 -1 を返す。"

#. type: Plain text
#: build/C/man3/fopencookie.3:215
msgid ""
"If I<*seek> is a null pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""
"I<*seek> がヌルポインターの場合、 このストリームに対して seek 操作を行うこと"
"ができない。"

#. type: TP
#: build/C/man3/fopencookie.3:215
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr "I<cookie_close_function_t *close>"

#. type: Plain text
#: build/C/man3/fopencookie.3:221
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""
"この関数はストリームをクローズする。 このフック関数では、 このストリームに割"
"り当てられたバッファーを解放するといったことができる。 呼び出される際、 1 つ"
"の引数を受け取る。"

#. type: Plain text
#: build/C/man3/fopencookie.3:223
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr "    int close(void *cookie);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:228
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""
"I<cookie> 引数は B<fopencookie>() の呼び出し時にプログラマーが渡した "
"cookie である。"

#. type: Plain text
#: build/C/man3/fopencookie.3:234
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""
"関数の結果として、 I<close> 関数は成功すると 0 を、 エラーの場合 B<EOF> を返"
"す。"

#. type: Plain text
#: build/C/man3/fopencookie.3:238
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is "
"closed."
msgstr ""
"I<*close> が NULL の場合、 ストリームがクローズされる際に特別な操作は何も行わ"
"れない。"

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: build/C/man3/fopencookie.3:245
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error, "
"NULL is returned."
msgstr ""
"成功すると B<fopencookie>() は新しいストリームへのポインターを返す。 エラーの"
"場合、 NULL が返される。"

#. type: tbl table
#: build/C/man3/fopencookie.3:255
#, no-wrap
msgid "B<fopencookie>()"
msgstr "B<fopencookie>()"

#. type: Plain text
#: build/C/man3/fopencookie.3:259
msgid "This function is a nonstandard GNU extension."
msgstr "この関数は非標準の GNU 拡張である。"

#. type: Plain text
#: build/C/man3/fopencookie.3:268
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""
"以下のプログラムは、 B<fmemopen>(3) で利用できるのと似た (同じではない) 機能"
"を持つ独自のストリームを実装している。 データがメモリーバッファーに格納される"
"ストリームを実装している。 このプログラムは、 コマンドライン引数をストリー"
"ムに書き込み、 それからストリームをたどって 5 文字ごとに 2 文字を読み出し"
"て、 それを標準出力に書き込む。 以下のシェルセッションはこのプログラムの使用"
"例である。"

#. type: Plain text
#: build/C/man3/fopencookie.3:276
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:283
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a "
"cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""
"このプログラムを改良して様々なエラー状況に強くすることもできる (例えば、 オー"
"プン済みのストリームに対応する cookie でストリームをオープンしようとした、 す"
"でにクローズされたストリームをクローズしようとした、など)。"

#. type: Plain text
#: build/C/man3/fopencookie.3:292
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:294
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr "#define INIT_BUF_SIZE 4\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:301
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:307
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:309
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr "    /* Buffer too small? Keep doubling size until big enough */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:319
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:321
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:325
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:328
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""
"    return size;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:334
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:336
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr "    /* Fetch minimum of bytes requested and bytes available */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:342
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:344
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:348
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:354
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:363
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:366
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:371
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:376
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:380
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:383
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:397
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    size_t nread;\n"
"    char buf[1000];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    size_t nread;\n"
"    char buf[1000];\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:399
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr "    /* Set up the cookie before calling fopencookie() */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:405
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:409
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:415
#, no-wrap
msgid ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:417
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr "    /* Write command-line arguments to our file */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:423
#, no-wrap
msgid ""
"    for (int j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    for (int j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:425
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr "    /* Read two bytes out of every five, until EOF */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:440
#, no-wrap
msgid ""
"    for (long p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == 0) {\n"
"            if (ferror(stream) != 0) {\n"
"                fprintf(stderr, \"fread failed\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (long p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == 0) {\n"
"            if (ferror(stream) != 0) {\n"
"                fprintf(stderr, \"fread failed\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:443
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", (int) nread, buf);\n"
"    }\n"
msgstr ""
"        printf(\"/%.*s/\\en\", (int) nread, buf);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:446 build/C/man3/fread.3:173
#: build/C/man2/open_by_handle_at.2:610 build/C/man2/open_by_handle_at.2:750
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:452
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"

#. type: TH
#: build/C/man3/fpurge.3:25
#, no-wrap
msgid "FPURGE"
msgstr "FPURGE"

#. type: Plain text
#: build/C/man3/fpurge.3:28
msgid "fpurge, __fpurge - purge a stream"
msgstr "fpurge, __fpurge - ストリームを一掃 (purge) する"

#. type: Plain text
#: build/C/man3/fpurge.3:32
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:34
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<int fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:38
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:40
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<void  __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:53
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""
"B<fpurge>()  関数は、与えられたストリームのバッファーをクリアする。 出力スト"
"リームでこれを行うと、書き出されていない出力は捨てられる。 入力ストリームでこ"
"れを行うと、 下層にあるオブジェクトから読み込まれ B<getc>(3)  による取得を"
"待っている入力が、すべて捨てられる。 これには B<ungetc>(3)  によって戻された"
"テキストも含まれる。 B<fflush>(3)  も参照のこと。"

#. type: Plain text
#: build/C/man3/fpurge.3:57
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a "
"value."
msgstr "B<__fpurge>()  関数も全く同じことを行うが、ただし返り値を返さない。"

#. type: Plain text
#: build/C/man3/fpurge.3:64
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""
"成功すると B<fpurge>()  は 0 を返す。 エラーが起こると -1 を返し、 I<errno> "
"を適切な値に設定する。"

#. type: Plain text
#: build/C/man3/fpurge.3:69
msgid "I<stream> is not an open stream."
msgstr "I<stream> がオープンされていない。"

#. type: tbl table
#: build/C/man3/fpurge.3:79
#, no-wrap
msgid "B<__fpurge>()"
msgstr "B<__fpurge>()"

#. type: tbl table
#: build/C/man3/fpurge.3:79 build/C/man3/stdio_ext.3:138
#: build/C/man3/unlocked_stdio.3:141
#, no-wrap
msgid "MT-Safe race:stream"
msgstr "MT-Safe race:stream"

#. type: Plain text
#: build/C/man3/fpurge.3:90
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()  "
"was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and "
"later."
msgstr ""
"これらの関数は標準ではなく、よって移植性もない。 B<fpurge>()  関数は 4.4BSD "
"で導入されたが、Linux では利用できない。 B<__fpurge>()  関数は Solaris で導入"
"され、glibc 2.1.95 以降には存在している。"

#. type: Plain text
#: build/C/man3/fpurge.3:92
msgid "Usually it is a mistake to want to discard input buffers."
msgstr "通常は入力バッファーを捨てようとするのは間違っている。"

#.  .BR fclean (3),
#. type: Plain text
#: build/C/man3/fpurge.3:97
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"

#. type: TH
#: build/C/man3/fputwc.3:16
#, no-wrap
msgid "FPUTWC"
msgstr "FPUTWC"

#. type: Plain text
#: build/C/man3/fputwc.3:19
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr "fputwc, putwc - ワイド文字を FILE ストリームに書き込む"

#. type: Plain text
#: build/C/man3/fputwc.3:26
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fputwc.3:42
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If "
"I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  "
"Otherwise, it returns I<wc>."
msgstr ""
"B<fputwc>()  関数は、 B<fputc>(3)  に対応するワイド文字関数である。この 関数"
"は、ワイド文字 I<wc> を I<stream> に書き込む。 I<ferror(stream)> が真になる"
"と、この関数は B<WEOF> を返す。 ワイド文字変換でエラーが発生した場合は、 "
"I<errno> に B<EILSEQ> をセットし、 B<WEOF> を返す。 それ以外の場合では、この"
"関数は I<wc> を返す。"

#. type: Plain text
#: build/C/man3/fputwc.3:50
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"B<putwc>()  関数あるいはマクロは、 B<fputwc>()  と全く同じ動作をする。 この関"
"数はマクロとして実装されるかもしれないので、引数が複数回評価さ れるかもしれ"
"ない。この関数を使う理由はもはや存在しない。"

#. type: Plain text
#: build/C/man3/fputwc.3:62
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error.  In the event of an error, I<errno> is set to indicate "
"the cause."
msgstr ""
"B<fputwc>()  関数は、エラーが起きなければ I<wc> を返す。エラーの場合には "
"B<WEOF> が返り、 I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man3/fputwc.3:67
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr "I<wc> からストリームの符号への変換に失敗した。"

#. type: tbl table
#: build/C/man3/fputwc.3:78
#, no-wrap
msgid ""
"B<fputwc>(),\n"
"B<putwc>()"
msgstr ""
"B<fputwc>(),\n"
"B<putwc>()"

#. type: Plain text
#: build/C/man3/fputwc.3:90
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""
"B<fputwc>()  の動作は現在のロケールの B<LC_CTYPE> カテゴリーに依存する。"

#. type: Plain text
#: build/C/man3/fputwc.3:98
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputwc>()  will actually write the multibyte "
"sequence corresponding to the wide character I<wc>."
msgstr ""
"B<fopen>(3)  システムコールに渡す追加情報がない場合には、 B<fputwc>()  は 実"
"際にはワイド文字 I<wc> に対応するマルチバイトシーケンスを書き込むと 期待して"
"よい。"

#. type: Plain text
#: build/C/man3/fputwc.3:102
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fread.3:46
#, no-wrap
msgid "FREAD"
msgstr "FREAD"

#. type: TH
#: build/C/man3/fread.3:46 build/C/man2/lseek.2:46 build/C/man3/scanf.3:52
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man3/fread.3:49
msgid "fread, fwrite - binary stream input/output"
msgstr "fread, fwrite - バイナリストリームの入出力"

#. type: Plain text
#: build/C/man3/fread.3:55
#, no-wrap
msgid "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"
msgstr "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fread.3:58
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fread.3:70
msgid ""
"The function B<fread>()  reads I<nmemb> items of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""
"B<fread>()  関数は I<stream> ポインターで指定されたストリームから I<nmemb> 個"
"のデータを読み込み、 I<ptr> で与えられた場所に格納する。 個々のデータは "
"I<size> バイトの長さを持つ。"

#. type: Plain text
#: build/C/man3/fread.3:81
msgid ""
"The function B<fwrite>()  writes I<nmemb> items of data, each I<size> bytes "
"long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""
"B<fwrite>()  関数は I<ptr> で指定された場所から得た I<nmemb> 個のデータを、 "
"I<stream> ポインターで指定されたストリームに書き込む。 個々のデータは "
"I<size> バイトの長さを持つ。"

#. type: Plain text
#: build/C/man3/fread.3:95
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of items read or "
"written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""
"成功すると、 B<fread>() と B<fwrite>() は読み書きを行った要素の個数を返す。\n"
"I<size> が 1 の場合は、この数字は転送されたバイト数と等しい。\n"
"エラーが生じた場合や、ファイルの末尾 (end-of-file) に達した場合、\n"
"返り値は指定した個数よりも小さい値 (または 0) となる。"

#. type: Plain text
#: build/C/man3/fread.3:98
msgid ""
"The file position indicator for the stream is advanced by the number of "
"bytes successfully read or written."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:105
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""
"B<fread>()  は end-of-file とエラーを区別しないので、 どちらが生じたかを判断"
"するためには、 呼び出し側で B<feof>(3)  と B<ferror>(3)  とを使用しなければな"
"らない。"

#. type: tbl table
#: build/C/man3/fread.3:116
#, no-wrap
msgid ""
"B<fread>(),\n"
"B<fwrite>()"
msgstr ""
"B<fread>(),\n"
"B<fwrite>()"

#. type: Plain text
#: build/C/man3/fread.3:120
msgid "POSIX.1-2001, POSIX.1-2008, C89."
msgstr "POSIX.1-2001, POSIX.1-2008, C89."

#. type: Plain text
#: build/C/man3/fread.3:125
msgid ""
"The program below demonstrates the use of B<fread>()  by parsing /bin/sh ELF "
"executable in binary mode and printing its magic and class:"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:131
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"ELF magic: 0x7f454c46\n"
"Class: 0x02\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:138
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fread.3:140
#, no-wrap
msgid "#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:149
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp = fopen(\"/bin/sh\", \"rb\");\n"
"    if (!fp) {\n"
"        perror(\"fopen\");\n"
"        return EXIT_FAILURE;\n"
"    }\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp = fopen(\"/bin/sh\", \"rb\");\n"
"    if (!fp) {\n"
"        perror(\"fopen\");\n"
"        return EXIT_FAILURE;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fread.3:151
#, no-wrap
msgid "    unsigned char buffer[4];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:157
#, no-wrap
msgid ""
"    size_t ret = fread(buffer, ARRAY_SIZE(buffer), sizeof(*buffer), fp);\n"
"    if (ret != sizeof(*buffer)) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    size_t ret = fread(buffer, ARRAY_SIZE(buffer), sizeof(*buffer), fp);\n"
"    if (ret != sizeof(*buffer)) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fread.3:160
#, no-wrap
msgid ""
"    printf(\"ELF magic: %#04x%02x%02x%02x\\en\", buffer[0], buffer[1],\n"
"           buffer[2], buffer[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:166
#, no-wrap
msgid ""
"    ret = fread(buffer, 1, 1, fp);\n"
"    if (ret != 1) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = fread(buffer, 1, 1, fp);\n"
"    if (ret != 1) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fread.3:168
#, no-wrap
msgid "    printf(\"Class: %#04x\\en\", buffer[0]);\n"
msgstr "    printf(\"Class: %#04x\\en\", buffer[0]);\n"

#. type: Plain text
#: build/C/man3/fread.3:170 build/C/man2/open_by_handle_at.2:667
#, no-wrap
msgid "    fclose(fp);\n"
msgstr "    fclose(fp);\n"

#. type: Plain text
#: build/C/man3/fread.3:180
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fseek.3:42
#, no-wrap
msgid "FSEEK"
msgstr "FSEEK"

#. type: TH
#: build/C/man3/fseek.3:42
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: build/C/man3/fseek.3:45
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr "fgetpos, fseek, fsetpos, ftell, rewind - ストリームの位置を変更する"

#. type: Plain text
#: build/C/man3/fseek.3:49
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:51
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr "B<long ftell(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:53
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr "B<void rewind(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:55
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:57
msgid "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"
msgstr "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:81
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or end-of-"
"file, respectively.  A successful call to the B<fseek>()  function clears "
"the end-of-file indicator for the stream and undoes any effects of the "
"B<ungetc>(3)  function on the same stream."
msgstr ""
"B<fseek>()  関数は I<stream> によって指定されたストリームにおいて、ファイル位"
"置表示子 (file position indicator) をセットする。新たな位置 (バイト単位)  は "
"I<whence> で指定された位置に I<offset> バイトを加えることによって与えられ"
"る。 I<whence> が B<SEEK_SET>, B<SEEK_CUR>, B<SEEK_END> のどれかになっている"
"場合は、それぞれファイルの先頭、現在の位置表示子、 ファイルの末尾からのオフ"
"セットが取られる。 B<fseek>()  関数の呼び出しが成功すると、ストリームの end-"
"of-file 表示子は クリアされ、それまでに B<ungetc>(3)  関数で戻したデータはな"
"かったことになる。"

#. type: Plain text
#: build/C/man3/fseek.3:87
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""
"B<ftell>()  関数は I<stream> によって指定されたストリームにおける、ファイル位"
"置表示子 の現時点での値を与える。"

#. type: Plain text
#: build/C/man3/fseek.3:94
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""
"B<rewind>()  関数は I<stream> によって指定されたストリームにおいて、ファイル"
"位置表示子 をファイルの先頭にセットする。この関数は以下と等価である。"

#. type: Plain text
#: build/C/man3/fseek.3:97
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr "(void) fseek(stream, 0L, SEEK_SET)"

#. type: Plain text
#: build/C/man3/fseek.3:101
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""
"ただし B<rewind>()  ではストリームに対するエラー表示子 (error indicator) も同"
"時に クリアされる ( B<clearerr>(3)  を見よ)。"

#. type: Plain text
#: build/C/man3/fseek.3:121
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with I<whence> set to "
"B<SEEK_SET>), setting and storing the current value of the file offset into "
"or from the object referenced by I<pos>.  On some non-UNIX systems, an "
"I<fpos_t> object may be a complex object and these routines may be the only "
"way to portably reposition a text stream."
msgstr ""
"B<fgetpos>()  関数と B<fsetpos>()  関数は、それぞれ B<ftell>()  と "
"B<fseek>()  で I<whence> に B<SEEK_SET> を指定した場合と同様の機能を、異なる"
"インターフェースで提供する。 B<fgetpos>()  はファイルオフセットの現在の値を "
"I<pos> が参照するオブジェクトに保存し、 B<fsetpos>()  はファイルオフセットを "
"I<pos> に設定する。 UNIX 以外のシステムにおいては、 I<fpos_t> が構造体などの"
"複雑なオブジェクトになっていて、これらのルーチンがテキス トストリームでファイ"
"ル位置を変更する方法のうち、移植性のある唯一のもの になっている場合もある。"

#. type: Plain text
#: build/C/man3/fseek.3:136
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"B<rewind>()  は返り値を持たない。 B<fgetpos>(), B<fseek>(), B<fsetpos>()  は"
"成功すると 0 を返す。 B<ftell>()  は現在のオフセットを返す。失敗した場合は返"
"り値は -1 となり、 I<errno> にエラーを示す値がセットされる。"

#. type: Plain text
#: build/C/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>.  Or: the resulting file offset would be negative."
msgstr ""
"B<fseek>()  関数に対して与えた I<whence> 引数が B<SEEK_SET>, B<SEEK_END>, "
"B<SEEK_CUR> 以外の値であった。 または、更新後のファイルオフセットが負になって"
"しまう。"

#. type: TP
#: build/C/man3/fseek.3:149 build/C/man2/lseek.2:229
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man3/fseek.3:154
#, fuzzy
#| msgid ""
#| "The file descriptor underlying I<stream> is invalid, or not open for "
#| "reading."
msgid ""
"The file descriptor underlying I<stream> is not seekable (e.g., it refers to "
"a pipe, FIFO, or socket)."
msgstr ""
"I<stream> に対応するファイルディスクリプターが無効であるが、 読み込み用にオー"
"プンされていない。"

#. type: Plain text
#: build/C/man3/fseek.3:169
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""
"B<fgetpos>(), B<fseek>(), B<fsetpos>(), B<ftell>()  は、それぞれ "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), B<malloc>(3)  などのルーチンを呼び出"
"す際に失敗する可能性がある。この場合は それぞれ対応した I<errno> が設定され"
"る。"

#. type: tbl table
#: build/C/man3/fseek.3:181
#, no-wrap
msgid ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"
msgstr ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"

#. type: tbl table
#: build/C/man3/fseek.3:184
#, no-wrap
msgid ""
"B<fgetpos>(),\n"
"B<fsetpos>()"
msgstr ""
"B<fgetpos>(),\n"
"B<fsetpos>()"

#. type: Plain text
#: build/C/man3/fseek.3:192
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr "B<lseek>(2), B<fseeko>(3)"

#. type: TH
#: build/C/man3/fseeko.3:25
#, no-wrap
msgid "FSEEKO"
msgstr "FSEEKO"

#. type: Plain text
#: build/C/man3/fseeko.3:28
msgid "fseeko, ftello - seek to or report file position"
msgstr "fseeko, ftello - ファイル位置を探す/報告する"

#. type: Plain text
#: build/C/man3/fseeko.3:33
#, no-wrap
msgid "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/fseeko.3:35
#, no-wrap
msgid "B<off_t ftello(FILE *>I<stream>B<);>\n"
msgstr "B<off_t ftello(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fseeko.3:44
msgid "B<fseeko>(), B<ftello>():"
msgstr "B<fseeko>(), B<ftello>():"

#. type: Plain text
#: build/C/man3/fseeko.3:48
msgid "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/fseeko.3:50
msgid "(defining the obsolete _LARGEFILE_SOURCE macro also works)"
msgstr "(廃止予定のマクロ _LARGEFILE_SOURCE を指定しても動作する)"

#. type: Plain text
#: build/C/man3/fseeko.3:73
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""
"B<fseeko>()  関数および B<ftello>()  関数は、 それぞれ B<fseek>(3)  および "
"B<ftell>(3)  と同一の機能を持つ (B<fseek>(3)  を見よ) が、ただし "
"B<fseeko>()  関数の I<offset> 引数と B<ftello>()  の返り値が、 I<long> ではな"
"く I<off_t> になっている。"

#. type: Plain text
#: build/C/man3/fseeko.3:86
msgid ""
"On some architectures, both I<off_t> and I<long> are 32-bit types, but "
"defining B<_FILE_OFFSET_BITS> with the value 64 (before including I<any> "
"header files)  will turn I<off_t> into a 64-bit type."
msgstr ""
"いくつかのアーキテクチャーでは、 I<off_t> と I<long> の両方が 32 ビット型だ"
"が、 (「どの」ヘッダーファイルをインクルードするよりも前に) "
"B<_FILE_OFFSET_BITS> を値 64 で定義すると、 I<off_t> が 64 ビット型になる。"

#. type: Plain text
#: build/C/man3/fseeko.3:95
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"成功した場合、 B<fseeko>()  は 0 を、 B<ftello>()  は現在のオフセットを返"
"す。 失敗した場合、-1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/fseeko.3:98
msgid "See the ERRORS in B<fseek>(3)."
msgstr "B<fseek>(3)  の「エラー」の節を参照。"

#. type: Plain text
#: build/C/man3/fseeko.3:100
msgid "These functions are available under glibc since version 2.1."
msgstr "これらの関数はバージョン 2.1 以降の glibc で利用可能である。"

#. type: tbl table
#: build/C/man3/fseeko.3:111
#, no-wrap
msgid ""
"B<fseeko>(),\n"
"B<ftello>()"
msgstr ""
"B<fseeko>(),\n"
"B<ftello>()"

#. type: Plain text
#: build/C/man3/fseeko.3:116
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr "POSIX.1-2001, POSIX.1-2008, SUSv2."

#. type: tbl table
#: build/C/man3/fseeko.3:118 build/C/man3/stdio.3:207
#, no-wrap
msgid "B<fseek>(3)"
msgstr "B<fseek>(3)"

#. type: TH
#: build/C/man3/getline.3:26
#, no-wrap
msgid "GETLINE"
msgstr "GETLINE"

#. type: Plain text
#: build/C/man3/getline.3:29
msgid "getline, getdelim - delimited string input"
msgstr "getline, getdelim - 区切り文字までの文字列入力を読み込む"

#. type: Plain text
#: build/C/man3/getline.3:34
#, no-wrap
msgid "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getline.3:37
#, no-wrap
msgid "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getline.3:47
msgid "B<getline>(), B<getdelim>():"
msgstr "B<getline>(), B<getdelim>():"

#. type: Plain text
#: build/C/man3/getline.3:65
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr ""
"B<getline>()  は I<stream> から 1 行全てを読み込み、テキストが含まれている"
"バッファーのアドレスを I<*lineptr> に格納する。 バッファーはヌル文字 (\\e0) "
"で終端される。 改行文字が見つかった場合は、改行文字もバッファーに格納される。"

#. type: Plain text
#: build/C/man3/getline.3:77
msgid ""
"If I<*lineptr> is set to NULL and I<*n> is set 0 before the call, then "
"B<getline>()  will allocate a buffer for storing the line.  This buffer "
"should be freed by the user program even if B<getline>()  failed."
msgstr ""
"I<*lineptr> が NULL にセットされ、 I<*n> が呼び出し前に 0 にセットされた場"
"合、 B<getline>()  は行の内容を格納するためのバッファーを確保する。 このバッ"
"ファーは、 B<getline>() が失敗した場合であっても、ユーザーのプログラムで解放"
"すべきである。"

#. type: Plain text
#: build/C/man3/getline.3:95
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""
"別の方法として、 B<getline>()  を呼び出す際に、 I<*lineptr> に B<malloc>(3)  "
"で確保した大きさ I<*n> バイトのバッファーへのポインターを入れて渡すこともでき"
"る。 読み込んだ行を保持するのに十分なバッファーがない場合、 B<getline>()  は "
"B<realloc>(3)  を使ってバッファーのサイズを変更し、必要に応じて I<*lineptr> "
"と I<*n> を更新する。"

#. type: Plain text
#: build/C/man3/getline.3:101
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""
"どちらの場合でも、呼び出しに成功したときには、 I<*lineptr> と I<*n> がバッ"
"ファーのアドレスと割り当てたサイズを反映した値に更新される。"

#. type: Plain text
#: build/C/man3/getline.3:112
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""
"B<getdelim>()  は B<getline>()  と同じように動作するが、改行文字以外の区切り"
"文字を引数 I<delim> に指定することができる。 B<getline>()  と同様に、ファイ"
"ル終端に達するまでに入力行に区切り文字が見付からない場合は、 区切り文字をバッ"
"ファーに追加しない。"

#. type: Plain text
#: build/C/man3/getline.3:121
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters "
"read, including the delimiter character, but not including the terminating "
"null byte (\\(aq\\e0\\(aq).  This value can be used to handle embedded null "
"bytes in the line read."
msgstr ""
"成功した場合、 B<getline>()  と B<getdelim>()  は読み込んだ文字数を返す。 文"
"字数には区切り文字は含まれるが、終端に使うヌルバイト (\\(aq\\e0\\(aq) は含ま"
"れない。 この値によって、読み込んだ行に含まれるヌルバイトを操作することができ"
"る。"

#. type: Plain text
#: build/C/man3/getline.3:127
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition).  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"どちらの関数も、行の読み込みに失敗した場合には -1 を返す (ファイルの終端に達"
"した場合にも -1 を返す)。 エラーが発生した場合には、 I<errno> にエラーの原因"
"を示す値が設定される。"

#. type: Plain text
#: build/C/man3/getline.3:137
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""
"引数が不正である (I<n> または I<lineptr> が NULL である。 もしくは "
"I<stream> が有効でない)。"

#. type: TP
#: build/C/man3/getline.3:137 build/C/man2/link.2:241 build/C/man2/open.2:1169
#: build/C/man2/open.2:1176 build/C/man2/readlink.2:199
#: build/C/man2/rename.2:388 build/C/man2/rmdir.2:85 build/C/man3/scanf.3:580
#: build/C/man2/symlink.2:187 build/C/man3/tempnam.3:105
#: build/C/man2/unlink.2:204
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/getline.3:140
msgid "Allocation or reallocation of the line buffer failed."
msgstr ""

#. type: tbl table
#: build/C/man3/getline.3:151
#, no-wrap
msgid ""
"B<getline>(),\n"
"B<getdelim>()"
msgstr ""
"B<getline>(),\n"
"B<getdelim>()"

#. type: Plain text
#: build/C/man3/getline.3:161
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""
"B<getline>()  と B<getdelim>()  は、どちらも元は GNU による拡張であったが、 "
"POSIX.1-2008 で標準化された。"

#. type: Plain text
#: build/C/man3/getline.3:166
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getline.3:174
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *stream;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t nread;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *stream;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t nread;\n"

#. type: Plain text
#: build/C/man3/getline.3:179
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getline.3:185
#, no-wrap
msgid ""
"    stream = fopen(argv[1], \"r\");\n"
"    if (stream == NULL) {\n"
"        perror(\"fopen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    stream = fopen(argv[1], \"r\");\n"
"    if (stream == NULL) {\n"
"        perror(\"fopen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getline.3:190
#, no-wrap
msgid ""
"    while ((nread = getline(&line, &len, stream)) != -1) {\n"
"        printf(\"Retrieved line of length %zd:\\en\", nread);\n"
"        fwrite(line, nread, 1, stdout);\n"
"    }\n"
msgstr ""
"    while ((nread = getline(&line, &len, stream)) != -1) {\n"
"        printf(\"Retrieved line of length %zd:\\en\", nread);\n"
"        fwrite(line, nread, 1, stdout);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getline.3:195
#, no-wrap
msgid ""
"    free(line);\n"
"    fclose(stream);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(line);\n"
"    fclose(stream);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getline.3:202
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"
msgstr "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"

#. type: TH
#: build/C/man3/gets.3:29
#, no-wrap
msgid "GETS"
msgstr "GETS"

#. type: Plain text
#: build/C/man3/gets.3:32
msgid "gets - get a string from standard input (DEPRECATED)"
msgstr "gets - 標準入力からの文字列を取得する (非推奨)"

#. type: Plain text
#: build/C/man3/gets.3:37
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr "B<char *gets(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:40
msgid "I<Never use this function>."
msgstr "I<この関数は使用しないこと>。"

#. type: Plain text
#: build/C/man3/gets.3:50
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""
"B<gets>()  は、改行文字か B<EOF> までの 1行を I<stdin> から読み込み I<s> が指"
"すバッファーに格納する (末尾の改行文字や B<EOF> はヌルバイト (\\(aq"
"\\e0\\(aq) に置き換えられる)。 バッファーオーバーランのチェックは行われない "
"(下記の「バグ」を参照)。"

#. type: Plain text
#: build/C/man3/gets.3:58
msgid ""
"B<gets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read.  However, given the lack of "
"buffer overrun checking, there can be no guarantees that the function will "
"even return."
msgstr ""
"B<gets>() は、成功すると I<s> を返し、エラーや 1 文字も読み込んでいないのに"
"ファイルの終わりになった 場合に NULL を返す。 しかし、バッファーの行き過ぎの"
"チェックが行われないため、この関数が返るという保証はない。"

#. type: tbl table
#: build/C/man3/gets.3:68
#, no-wrap
msgid "B<gets>()"
msgstr "B<gets>()"

#. type: Plain text
#: build/C/man3/gets.3:73
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/gets.3:85
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""
"LSB は B<gets>() を非推奨としている。\n"
"POSIX.1-2008 では B<gets>() に廃止予定の印が付けられている。\n"
"ISO C11 では B<gets>)() の規定が C 言語から削除されている。\n"
"glibc バージョン 2.16 以降では、機能検査マクロ B<_ISOC11_SOURCE> が定義され"
"た\n"
"場合、glibc ヘッダーファイルでは B<gets>)() の宣言が公開されない。"

#. type: Plain text
#: build/C/man3/gets.3:99
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer "
"security.  Use B<fgets>()  instead."
msgstr ""
"B<gets>()  は絶対に使用してはならない。 前もってデータを知ることなしに "
"B<gets>()  が何文字読むかを知ることはできず、 B<gets>()  がバッファーの終わり"
"を越えて書き込み続けるため、 B<gets>()  を使うのは極めて危険である。 これを利"
"用してコンピュータのセキュリティが破られてきた。 代わりに B<fgets>()  を使う"
"こと。"

#. type: Plain text
#: build/C/man3/gets.3:103
msgid ""
"For more information, see CWE-242 (aka \"Use of Inherently Dangerous Function"
"\") at http://cwe.mitre.org/data/definitions/242.html"
msgstr ""
"詳しい情報については、CWE-242 (別名 \"Use of Inherently Dangerous Function"
"\" (「本質的に危険な関数を使う」)) を参照。 http://cwe.mitre.org/data/"
"definitions/242.html で参照できる。"

#. type: Plain text
#: build/C/man3/gets.3:121
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"

#. type: TH
#: build/C/man3/getw.3:25
#, no-wrap
msgid "GETW"
msgstr "GETW"

#. type: TH
#: build/C/man3/getw.3:25 build/C/man3/tmpfile.3:31
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: build/C/man3/getw.3:28
msgid "getw, putw - input and output of words (ints)"
msgstr "getw, putw - ワード(int)の入出力"

#. type: Plain text
#: build/C/man3/getw.3:33
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr "B<int getw(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getw.3:35
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getw.3:44
msgid "B<getw>(), B<putw>():"
msgstr "B<getw>(), B<putw>():"

#. type: TP
#: build/C/man3/getw.3:47
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr "glibc 2.3.3 以降:"

#. type: Plain text
#: build/C/man3/getw.3:52
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/getw.3:52
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr "glibc 2.3.3 より前:"

#. type: Plain text
#: build/C/man3/getw.3:55
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/getw.3:65
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""
"B<getw>()  は I<stream> からワード (I<int>型) を読み込む。 この関数は、SVr4 "
"との互換性のために提供されている。 この関数の代わりに B<fread>(3)  を使用する"
"ことを勧める。"

#. type: Plain text
#: build/C/man3/getw.3:72
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)  "
"instead."
msgstr ""
"B<putw>()  は I<stream> にワード I<w> (I<int>型) を書き込む。 この関数は "
"SVr4 との互換性のために提供されているが、この関数の代わりに B<fwrite>(3)  を"
"使用することを勧める。"

#. type: Plain text
#: build/C/man3/getw.3:79
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""
"通常、 B<getw>()  は読み込んだワードを返し、 B<putw>()  は 0 を返す。 エラー"
"が発生した場合、これらの関数は B<EOF> を返す。"

#. type: tbl table
#: build/C/man3/getw.3:90
#, no-wrap
msgid ""
"B<getw>(),\n"
"B<putw>()"
msgstr ""
"B<getw>(),\n"
"B<putw>()"

#. type: Plain text
#: build/C/man3/getw.3:95
msgid "SVr4, SUSv2.  Not present in POSIX.1."
msgstr "SVr4, SUSv2.  POSIX.1 には存在しない。"

#. type: Plain text
#: build/C/man3/getw.3:99
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""
"エラーの時に返される値は、正しいデータとして返されることもある。 "
"B<ferror>(3)  を用いると、この二つの場合を区別することが出来る。"

#. type: Plain text
#: build/C/man3/getw.3:105
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"

#. type: TH
#: build/C/man2/link.2:32
#, no-wrap
msgid "LINK"
msgstr "LINK"

#. type: Plain text
#: build/C/man2/link.2:35
msgid "link, linkat - make a new name for a file"
msgstr "link, linkat - ファイルの新しい名前を作成する"

#. type: Plain text
#: build/C/man2/link.2:38 build/C/man2/pipe.2:42 build/C/man2/read.2:42
#: build/C/man2/readlink.2:50 build/C/man2/symlink.2:39
#: build/C/man2/unlink.2:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/link.2:40
#, no-wrap
msgid "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: build/C/man2/link.2:43 build/C/man2/readlink.2:56 build/C/man2/symlink.2:44
#: build/C/man2/unlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/link.2:46
#, no-wrap
msgid ""
"B<int linkat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<           int >I<newdirfd>B<, const char *>I<newpath>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int linkat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<           int >I<newdirfd>B<, const char *>I<newpath>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/link.2:54
msgid "B<linkat>():"
msgstr "B<linkat>():"

#. type: Plain text
#: build/C/man2/link.2:63 build/C/man2/open.2:89 build/C/man2/readlink.2:84
#: build/C/man2/rename.2:68 build/C/man2/symlink.2:72 build/C/man2/unlink.2:63
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: build/C/man2/link.2:69
msgid ""
"B<link>()  creates a new link (also known as a hard link) to an existing "
"file."
msgstr ""
"B<link>()  は存在するファイルへの新しいリンク (link)  (ハードリンク (hard "
"link) ともいう) を作成する。"

#. type: Plain text
#: build/C/man2/link.2:75
msgid "If I<newpath> exists, it will I<not> be overwritten."
msgstr "I<newpath> が存在する場合には、上書きはI<されない>。"

#. type: Plain text
#: build/C/man2/link.2:80
msgid ""
"This new name may be used exactly as the old one for any operation; both "
"names refer to the same file (and so have the same permissions and "
"ownership) and it is impossible to tell which name was the \"original\"."
msgstr ""
"この新しい名前は全ての操作において古い名前と完全に同じように使用される; 両方"
"の名前は同じファイルを参照しており (それで同じ許可 (permission) や所有者 "
"(ownership) となるので)、 どちらの名前が本来のものであるか判別できない。"

#. type: SS
#: build/C/man2/link.2:80
#, no-wrap
msgid "linkat()"
msgstr "linkat()"

#. type: Plain text
#: build/C/man2/link.2:86
msgid ""
"The B<linkat>()  system call operates in exactly the same way as B<link>(), "
"except for the differences described here."
msgstr ""
"B<linkat>() システムコールは B<link>() と全く同様に動作するが、以下で説明する"
"点が異なる。"

#. type: Plain text
#: build/C/man2/link.2:96
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<link>()  for a relative pathname)."
msgstr ""
"I<oldpath> で指定されたパス名が相対パスの場合、このパス名はファイルディスクリ"
"プター I<olddirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<link>(2) に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/link.2:108
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<link>())."
msgstr ""
"I<oldpath> で指定されたパス名が相対パスで、 I<olddirfd> が特別な値 "
"B<AT_FDCWD> の場合、 (B<link>(2) と同様に) I<oldpath> は呼び出したプロセスの"
"カレントワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/link.2:114 build/C/man2/rename.2:163
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr ""
"I<oldpath> で指定されたパス名が絶対パスの場合、 I<olddirfd> は無視される。"

#. type: Plain text
#: build/C/man2/link.2:122 build/C/man2/rename.2:171
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""
"I<newpath> の解釈は I<oldpath> と同じである。 相対パスのパス名がファイルディ"
"スクリプター I<newdirfd> が参照するディレクトリと解釈される点だけが異なる。"

#. type: Plain text
#: build/C/man2/link.2:125
msgid "The following values can be bitwise ORed in I<flags>:"
msgstr "以下の値のビット単位の論理和を I<flags> に指定できる。"

#. type: TP
#: build/C/man2/link.2:125
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (Linux 2.6.39 以降)"

#.  commit 11a7b371b64ef39fc5fb1b6f2218eef7c4d035e3
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/link.2:152
msgid ""
"If I<oldpath> is an empty string, create a link to the file referenced by "
"I<olddirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<olddirfd> can refer to any type of file except a "
"directory.  This will generally not work if the file has a link count of "
"zero (files created with B<O_TMPFILE> and without B<O_EXCL> are an "
"exception).  The caller must have the B<CAP_DAC_READ_SEARCH> capability in "
"order to use this flag.  This flag is Linux-specific; define B<_GNU_SOURCE> "
"to obtain its definition."
msgstr ""
"I<oldpath> が空文字列の場合、 I<olddirfd> が参照するファイルへのリンクを作成"
"する (I<olddirfd> は B<open>(2) の B<O_PATH> フラグを使って取得する)。 この場"
"合、 I<olddirfd> はディレクトリ以外の任意の型のファイルを参照することができ"
"る。 一般的には、 ファイルのリンクカウントが 0 の場合は、この操作は成功しな"
"い (ただし、 B<O_TMPFILE> が指定され B<O_EXCL> を指定せずに作成されたファイル"
"は例外である)。 このフラグを使用するためには、 呼び出し元は "
"B<CAP_DAC_READ_SEARCH> ケーパビリティを持っていなければならない。 このフラグ"
"は Linux 固有で、 この定義を得るには B<_GNU_SOURCE> を定義すること。"

#. type: TP
#: build/C/man2/link.2:152
#, no-wrap
msgid "B<AT_SYMLINK_FOLLOW> (since Linux 2.6.18)"
msgstr "B<AT_SYMLINK_FOLLOW> (Linux 2.6.18 以降)"

#. type: Plain text
#: build/C/man2/link.2:171
msgid ""
"By default, B<linkat>(), does not dereference I<oldpath> if it is a symbolic "
"link (like B<link>()).  The flag B<AT_SYMLINK_FOLLOW> can be specified in "
"I<flags> to cause I<oldpath> to be dereferenced if it is a symbolic link.  "
"If procfs is mounted, this can be used as an alternative to "
"B<AT_EMPTY_PATH>, like this:"
msgstr ""
"B<linkat>() は (B<link>() 同様) デフォルトでは I<oldpath> がシンボリックリン"
"クの場合リンクの展開を行わない。 フラグ B<AT_SYMLINK_FOLLOW> を I<flags> に指"
"定することができ、指定した場合 I<oldpath> がシンボリックリンクの場合リンクの"
"展開が行われる。 procfs がマウントされている場合、これは B<AT_EMPTY_PATH> の"
"代替として以下のように使うことができる。"

#. type: Plain text
#: build/C/man2/link.2:176
#, no-wrap
msgid ""
"linkat(AT_FDCWD, \"/proc/self/fd/E<lt>fdE<gt>\", newdirfd,\n"
"       newname, AT_SYMLINK_FOLLOW);\n"
msgstr ""
"linkat(AT_FDCWD, \"/proc/self/fd/E<lt>fdE<gt>\", newdirfd,\n"
"       newname, AT_SYMLINK_FOLLOW);\n"

#. type: Plain text
#: build/C/man2/link.2:182
msgid ""
"Before kernel 2.6.18, the I<flags> argument was unused, and had to be "
"specified as 0."
msgstr ""
"カーネル 2.6.18 より前では、 I<flags> 引数は未使用で、 0 を指定しなければな"
"らなかった。"

#. type: Plain text
#: build/C/man2/link.2:187
msgid "See B<openat>(2)  for an explanation of the need for B<linkat>()."
msgstr "B<linkat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/link.2:192 build/C/man3/remove.3:65 build/C/man2/rename.2:308
#: build/C/man2/rmdir.2:45 build/C/man2/symlink.2:146 build/C/man2/unlink.2:158
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: TP
#: build/C/man2/link.2:193 build/C/man2/open.2:988 build/C/man2/open.2:997
#: build/C/man2/readlink.2:164 build/C/man2/rename.2:309
#: build/C/man2/rmdir.2:46 build/C/man2/symlink.2:147 build/C/man3/tmpfile.3:57
#: build/C/man2/unlink.2:159
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/link.2:204
msgid ""
"Write access to the directory containing I<newpath> is denied, or search "
"permission is denied for one of the directories in the path prefix of "
"I<oldpath> or I<newpath>.  (See also B<path_resolution>(7).)"
msgstr ""
"I<newpath> を含んでいるディレクトリへの書き込みが許されていないか、 "
"I<oldpath> または I<newpath> へのディレクトリのどれかに検索許可がない "
"(B<path_resolution>(7)  を参照)。"

#. type: TP
#: build/C/man2/link.2:204 build/C/man2/open.2:1024 build/C/man2/rename.2:345
#: build/C/man2/symlink.2:156 build/C/man2/write.2:164
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/link.2:207 build/C/man2/rename.2:348
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr ""
"ディスクブロックか inode がそのファイルシステムのユーザークォータに達してい"
"た。"

#. type: TP
#: build/C/man2/link.2:207 build/C/man2/open.2:1030 build/C/man2/rename.2:468
#: build/C/man2/symlink.2:161 build/C/man3/tmpfile.3:60
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/link.2:211
msgid "I<newpath> already exists."
msgstr "I<newpath> が既に存在する。"

#. type: TP
#: build/C/man2/link.2:211 build/C/man2/llseek.2:90 build/C/man2/open.2:1036
#: build/C/man2/open_by_handle_at.2:297 build/C/man2/open_by_handle_at.2:352
#: build/C/man2/pipe.2:171 build/C/man2/read.2:127 build/C/man2/readlink.2:169
#: build/C/man2/rename.2:348 build/C/man2/rmdir.2:64 build/C/man2/symlink.2:165
#: build/C/man2/unlink.2:178 build/C/man2/write.2:170
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/link.2:214 build/C/man2/rename.2:351
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""
"I<oldpath> や I<newpath> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/link.2:214 build/C/man2/read.2:156 build/C/man2/readlink.2:187
#: build/C/man2/symlink.2:168 build/C/man2/unlink.2:182
#: build/C/man2/write.2:194
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/link.2:217 build/C/man2/symlink.2:171 build/C/man2/unlink.2:185
msgid "An I/O error occurred."
msgstr "I/O エラーが発生した。"

#. type: TP
#: build/C/man2/link.2:217 build/C/man2/open.2:1112 build/C/man2/open.2:1116
#: build/C/man2/openat2.2:441 build/C/man2/openat2.2:447
#: build/C/man2/open_by_handle_at.2:362 build/C/man2/readlink.2:190
#: build/C/man2/rename.2:361 build/C/man2/rmdir.2:73 build/C/man2/symlink.2:171
#: build/C/man2/unlink.2:190
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/link.2:221 build/C/man2/rename.2:365
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""
"I<oldpath> または I<newpath> を解決する際に遭遇したシンボリックリンクが多過ぎ"
"る。"

#. type: TP
#: build/C/man2/link.2:221 build/C/man2/rename.2:365
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: build/C/man2/link.2:233
msgid ""
"The file referred to by I<oldpath> already has the maximum number of links "
"to it.  For example, on an B<ext4>(5)  filesystem that does not employ the "
"I<dir_index> feature, the limit on the number of hard links to a file is "
"65,000; on B<btrfs>(5), the limit is 65,535 links."
msgstr ""

#. type: TP
#: build/C/man2/link.2:233 build/C/man2/open.2:1132 build/C/man2/readlink.2:193
#: build/C/man2/rename.2:372 build/C/man2/rmdir.2:77 build/C/man2/symlink.2:175
#: build/C/man2/unlink.2:194
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/link.2:236 build/C/man2/rename.2:375
msgid "I<oldpath> or I<newpath> was too long."
msgstr "I<oldpath> または I<newpath> が長過ぎる。"

#. type: TP
#: build/C/man2/link.2:236 build/C/man2/link.2:299 build/C/man2/link.2:307
#: build/C/man2/link.2:321 build/C/man2/link.2:326 build/C/man2/open.2:1146
#: build/C/man2/open.2:1150 build/C/man2/open.2:1155
#: build/C/man2/open_by_handle_at.2:313 build/C/man2/readlink.2:196
#: build/C/man2/rename.2:375 build/C/man2/rename.2:500 build/C/man2/rmdir.2:80
#: build/C/man2/symlink.2:178 build/C/man2/symlink.2:215
#: build/C/man2/unlink.2:197
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/link.2:241
msgid ""
"A directory component in I<oldpath> or I<newpath> does not exist or is a "
"dangling symbolic link."
msgstr ""
"I<oldpath> または I<newpath> のディレクトリ部分が存在しないか、 壊れた"
"(dangling)シンボリックリンクである。"

#. type: Plain text
#: build/C/man2/link.2:244 build/C/man2/open.2:1179 build/C/man2/readlink.2:202
#: build/C/man2/rename.2:391 build/C/man2/rmdir.2:88 build/C/man2/symlink.2:190
#: build/C/man2/unlink.2:207
msgid "Insufficient kernel memory was available."
msgstr "十分なカーネルメモリーがない。"

#. type: TP
#: build/C/man2/link.2:244 build/C/man2/open.2:1179 build/C/man2/rename.2:391
#: build/C/man2/symlink.2:190 build/C/man3/tmpfile.3:73
#: build/C/man2/write.2:222
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/link.2:248 build/C/man2/rename.2:395 build/C/man2/symlink.2:194
msgid "The device containing the file has no room for the new directory entry."
msgstr ""
"そのファイルを含んでいるデバイスに新しいディレクトリエントリーを 作成するため"
"の空きがない。"

#. type: TP
#: build/C/man2/link.2:248 build/C/man2/link.2:337 build/C/man2/open.2:1185
#: build/C/man2/open.2:1275 build/C/man2/open_by_handle_at.2:320
#: build/C/man2/readlink.2:202 build/C/man2/readlink.2:212
#: build/C/man2/rename.2:395 build/C/man2/rename.2:455 build/C/man2/rmdir.2:88
#: build/C/man2/symlink.2:194 build/C/man2/symlink.2:221
#: build/C/man2/unlink.2:207 build/C/man2/unlink.2:268
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/link.2:253
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory."
msgstr ""
"I<oldpath> または I<newpath> のディレクトリ部分が、実際には、ディレクトリでな"
"い。"

#. type: TP
#: build/C/man2/link.2:253 build/C/man2/link.2:257 build/C/man2/link.2:269
#: build/C/man2/link.2:347 build/C/man2/open.2:1229 build/C/man2/open.2:1236
#: build/C/man2/open_by_handle_at.2:369 build/C/man2/rename.2:508
#: build/C/man2/rmdir.2:108 build/C/man2/rmdir.2:119 build/C/man2/symlink.2:199
#: build/C/man2/unlink.2:212 build/C/man2/unlink.2:235 build/C/man2/write.2:227
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/link.2:257
msgid "I<oldpath> is a directory."
msgstr "I<oldpath> がディレクトリである。"

#. type: Plain text
#: build/C/man2/link.2:262
msgid ""
"The filesystem containing I<oldpath> and I<newpath> does not support the "
"creation of hard links."
msgstr ""
"I<oldpath> と I<newpath> を含んでいるファイルシステムがハードリンクをサポート"
"していない。"

#. type: TP
#: build/C/man2/link.2:262
#, no-wrap
msgid "B<EPERM> (since Linux 3.6)"
msgstr "B<EPERM> (Linux 3.6 以降)"

#. type: Plain text
#: build/C/man2/link.2:269
msgid ""
"The caller does not have permission to create a hard link to this file (see "
"the description of I</proc/sys/fs/protected_hardlinks> in B<proc>(5))."
msgstr ""
"呼び出し元にこのファイルへのハードリンクを作成する許可がなかった (B<proc>(5) "
"の I</proc/sys/fs/protected_hardlinks> の説明を参照)。"

#. type: Plain text
#: build/C/man2/link.2:275
msgid ""
"I<oldpath> is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/link.2:275 build/C/man2/open.2:1240 build/C/man2/rename.2:433
#: build/C/man2/rmdir.2:124 build/C/man2/symlink.2:204
#: build/C/man3/tmpfile.3:76 build/C/man2/unlink.2:240
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/link.2:278 build/C/man2/rename.2:436
msgid "The file is on a read-only filesystem."
msgstr "ファイルが読み込み専用のファイルシステムに存在する。"

#. type: TP
#: build/C/man2/link.2:278 build/C/man2/openat2.2:453
#: build/C/man2/openat2.2:461 build/C/man2/rename.2:436
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: build/C/man2/link.2:286
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<link>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""
"I<oldpath> と I<newpath> が同じマウントされたファイルシステムに存在しない。 "
"(Linux は 1 つのファイルシステムを複数のマウント位置に マウントすることを許可"
"している。 しかし B<link>()  は、たとえ同じファイルシステムであっても、 別々"
"のマウント位置を跨いでは動作しない。)"

#. type: Plain text
#: build/C/man2/link.2:289
msgid "The following additional errors can occur for B<linkat>():"
msgstr "B<linkat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/link.2:295 build/C/man2/rename.2:455
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr "I<olddirfd> か I<newdirfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/link.2:299 build/C/man2/unlink.2:261
msgid "An invalid flag value was specified in I<flags>."
msgstr "無効なフラグ値が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/link.2:307
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, but the caller did not have the "
"B<CAP_DAC_READ_SEARCH> capability."
msgstr ""
"B<AT_EMPTY_PATH> が I<flags> に指定されたが、呼び出し元が "
"B<CAP_DAC_READ_SEARCH> ケーパビリティを持っていなかった。"

#. type: Plain text
#: build/C/man2/link.2:312
msgid ""
"An attempt was made to link to the I</proc/self/fd/NN> file corresponding to "
"a file descriptor created with"
msgstr ""
"以下の呼び出しで作成されたファイルディスクリプターに対応する I</proc/self/fd/"
"NN> ファイルに対してリンクを行おおうとした。"

#. type: Plain text
#: build/C/man2/link.2:316
#, no-wrap
msgid "open(path, O_TMPFILE | O_EXCL, mode);\n"
msgstr "open(path, O_TMPFILE | O_EXCL, mode);\n"

#. type: Plain text
#: build/C/man2/link.2:321
msgid "See B<open>(2)."
msgstr "B<open>(2) 参照。"

#. type: Plain text
#: build/C/man2/link.2:326
msgid ""
"An attempt was made to link to a I</proc/self/fd/NN> file corresponding to a "
"file that has been deleted."
msgstr "削除済みのファイルに対応する I</proc/self/fd/NN> ファイルに対してリンクを行おおうとした。"

#. type: Plain text
#: build/C/man2/link.2:337
msgid ""
"I<oldpath> is a relative pathname and I<olddirfd> refers to a directory that "
"has been deleted, or I<newpath> is a relative pathname and I<newdirfd> "
"refers to a directory that has been deleted."
msgstr ""
"I<oldpath> が相対パス名で、 I<olddirfd> が削除されたディレクトリを参照してい"
"る。 または、 I<newpath> が相対パス名で、 I<newdirfd> が削除されたディレクト"
"リを参照している。"

#. type: Plain text
#: build/C/man2/link.2:347 build/C/man2/rename.2:465
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""
"I<oldpath> が相対パスで、 I<olddirfd> がディレクトリ以外のファイルを参照して"
"いる。または I<newpath> と I<newdirfd> に関して同じ状況である。"

#. type: Plain text
#: build/C/man2/link.2:356
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, I<oldpath> is an empty string, "
"and I<olddirfd> refers to a directory."
msgstr ""
"I<flags> に B<AT_EMPTY_PATH> が指定され、 I<oldpath> が空文字列で、 "
"I<olddirfd> がディレクトリを参照している。"

#. type: Plain text
#: build/C/man2/link.2:360
msgid ""
"B<linkat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<linkat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサポー"
"トはバージョン 2.4 で glibc に追加された。"

#.  SVr4 documents additional ENOLINK and
#.  EMULTIHOP error conditions; POSIX.1 does not document ELOOP.
#.  X/OPEN does not document EFAULT, ENOMEM or EIO.
#. type: Plain text
#: build/C/man2/link.2:366
msgid "B<link>(): SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES), POSIX.1-2008."
msgstr ""
"B<link>(): SVr4, 4.3BSD, POSIX.1-2001 (但し「注意」を参照), POSIX.1-2008."

#. type: Plain text
#: build/C/man2/link.2:369
msgid "B<linkat>(): POSIX.1-2008."
msgstr "B<linkat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/link.2:376
msgid ""
"Hard links, as created by B<link>(), cannot span filesystems.  Use "
"B<symlink>(2)  if this is required."
msgstr ""
"B<link>()  でファイルシステムを超えてハードリンクを作成することはできない。 "
"このような場合は B<symlink>(2)  を使用すること。"

#.  more precisely: since kernel 1.3.56
#.  For example, the default Solaris compilation environment
#.  behaves like Linux, and contributors to a March 2005
#.  thread in the Austin mailing list reported that some
#.  other (System V) implementations did/do the same -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/link.2:407
msgid ""
"POSIX.1-2001 says that B<link>()  should dereference I<oldpath> if it is a "
"symbolic link.  However, since kernel 2.0, Linux does not do so: if "
"I<oldpath> is a symbolic link, then I<newpath> is created as a (hard) link "
"to the same symbolic link file (i.e., I<newpath> becomes a symbolic link to "
"the same file that I<oldpath> refers to).  Some other implementations behave "
"in the same manner as Linux.  POSIX.1-2008 changes the specification of "
"B<link>(), making it implementation-dependent whether or not I<oldpath> is "
"dereferenced if it is a symbolic link.  For precise control over the "
"treatment of symbolic links when creating a link, use B<linkat>()."
msgstr "POSIX.1-2001 では、 I<oldpath> がシンボリックリンクである場合、 B<link>()  は I<oldpath> の参照を解決すべきであると記述されている。 しかし、カーネル 2.0 以降の Linux ではそのようになっていない。 I<oldpath> がシンボリックリンクである場合、 I<newpath> は同じシンボリックリンクファイルへの (ハード) リンクとして作成される (つまり I<newpath> は I<oldpath> が参照していた同じファイルへのシンボリックリンクになる)。 他のいくつかの実装でも Linux と同じように動作する。 POSIX.1-2008 では B<link>()  の仕様が変更され、 I<oldpath> がシンボリックリンクの場合にシンボリックリンクの参照を 解決するかどうかは実装依存となった。 リンク作成時のシンボリックリンクの扱いについての詳細な制御を行う場合には B<linkat>() を使用すること。"

#. type: Plain text
#: build/C/man2/link.2:427
msgid ""
"On older kernels where B<linkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<link>(), unless the B<AT_SYMLINK_FOLLOW> "
"is specified.  When I<oldpath> and I<newpath> are relative pathnames, glibc "
"constructs pathnames based on the symbolic links in I</proc/self/fd> that "
"correspond to the I<olddirfd> and I<newdirfd> arguments."
msgstr ""
"B<linkat>() が利用できない古いカーネルでは、 B<AT_SYMLINK_FOLLOW> が指定され"
"ていない場合、 glibc ラッパー関数は B<link>() を使用するモードにフォールバッ"
"クする。 I<oldpath> と I<newpath> が相対パスの場合、 glibc は I<olddirfd> と "
"I<newdirfd> 引数に対応する I</proc/self/fd> のシンボリックリンクに基づいて"
"それぞれパス名を構成する。"

#. type: Plain text
#: build/C/man2/link.2:433
msgid ""
"On NFS filesystems, the return code may be wrong in case the NFS server "
"performs the link creation and dies before it can say so.  Use B<stat>(2)  "
"to find out if the link got created."
msgstr ""
"NFS ファイルシステムでは、NFS サーバーがリンクを作成した後に、 それを伝える前"
"に死んだ場合には返り値が不正な場合がある。 リンクが作成できたかどうか見つける"
"ためには B<stat>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/link.2:442
msgid ""
"B<ln>(1), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<ln>(1), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/llseek.2:29
#, no-wrap
msgid "LLSEEK"
msgstr "LLSEEK"

#. type: Plain text
#: build/C/man2/llseek.2:32
msgid "_llseek - reposition read/write file offset"
msgstr "_llseek - ファイルの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man2/llseek.2:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/llseek.2:40
#, no-wrap
msgid ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"
msgstr ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man2/llseek.2:44 build/C/man2/openat2.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/llseek.2:49
msgid ""
"Note: for information about the B<llseek>(3)  library function, see "
"B<lseek64>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:56
#, fuzzy
#| msgid ""
#| "The B<lseek>()  function repositions the offset of the open file "
#| "associated with the file descriptor I<fd> to the argument I<offset> "
#| "according to the directive I<whence> as follows:"
msgid ""
"The B<_llseek>()  system call repositions the offset of the open file "
"description associated with the file descriptor I<fd> to the value"
msgstr ""
"B<lseek>()  関数は、ファイルディスクリプター (descriptor)  I<fd> に対応する"
"オープンされたファイルのオフセットを、 I<whence> に基づき I<offset> 引数の"
"位置へ以下のように変更する:"

#. type: Plain text
#: build/C/man2/llseek.2:58
msgid "(offset_high E<lt>E<lt> 32) | offset_low"
msgstr "(offset_high E<lt>E<lt> 32) | offset_low"

#. type: Plain text
#: build/C/man2/llseek.2:69
#, fuzzy
#| msgid ""
#| "The B<_llseek>()  function repositions the offset of the open file "
#| "associated with the file descriptor I<fd> to I<(offset_highE<lt>E<lt>32) "
#| "| offset_low> bytes relative to the beginning of the file, the current "
#| "position in the file, or the end of the file, depending on whether "
#| "I<whence> is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively.  It "
#| "returns the resulting file position in the argument I<result>."
msgid ""
"This new offset is a byte offset relative to the beginning of the file, the "
"current file offset, or the end of the file, depending on whether I<whence> "
"is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr ""
"B<_llseek>()  関数は、ファイルディスクリプター (descriptor)  I<fd> に関連づけ"
"られたオープンされたファイルのオフセットの位置を、相対的に "
"I<(offset_highE<lt>E<lt>32) | offset_low> バイトだけ変更する。 基準となる位置"
"を表す I<whence> には B<SEEK_SET>, B<SEEK_CUR>, B<SEEK_END> のいずれかを指定"
"し、それぞれ ファイルの先頭、ファイルの現在位置、 ファイルの最後を表す。 結果"
"のファイル位置を I<result> 引数に返す。"

#. type: Plain text
#: build/C/man2/llseek.2:75
msgid ""
"The new file offset is returned in the argument I<result>.  The type "
"I<loff_t> is a 64-bit signed type."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:78
msgid ""
"This system call exists on various 32-bit platforms to support seeking to "
"large file offsets."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:85
msgid ""
"Upon successful completion, B<_llseek>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合は、 B<_llseek>()  は 0 を返す。 そうでなれば -1 という値が返り、"
"エラーを示す I<errno> が設定される。"

#. type: Plain text
#: build/C/man2/llseek.2:90 build/C/man2/lseek.2:200
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> がオープンされたファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/llseek.2:93
msgid "Problem with copying results to user space."
msgstr "結果をユーザー空間にコピーするときに問題があった。"

#. type: Plain text
#: build/C/man2/llseek.2:97
msgid "I<whence> is invalid."
msgstr "I<whence> が不正である。"

#. type: Plain text
#: build/C/man2/llseek.2:100
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 特有であり、移植性の必要なプログラムでは使用してはいけない。"

#. type: Plain text
#: build/C/man2/llseek.2:107
msgid ""
"Glibc does not provide a wrapper for this system call.  To invoke it "
"directly, use B<syscall>(2).  However, you probably want to use the "
"B<lseek>(2)  wrapper function instead."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:111
msgid "B<lseek>(2), B<open>(2), B<lseek64>(3)"
msgstr "B<lseek>(2), B<open>(2), B<lseek64>(3)"

#. type: TH
#: build/C/man2/lseek.2:46
#, no-wrap
msgid "LSEEK"
msgstr "LSEEK"

#. type: Plain text
#: build/C/man2/lseek.2:49
msgid "lseek - reposition read/write file offset"
msgstr "lseek - ファイルの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man2/lseek.2:51 build/C/man3/lseek64.3:33
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/lseek.2:53 build/C/man3/lseek64.3:35 build/C/man2/rmdir.2:35
#: build/C/man2/write.2:44
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/lseek.2:55
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"
msgstr "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man2/lseek.2:65
#, fuzzy
#| msgid ""
#| "The B<lseek>()  function repositions the offset of the open file "
#| "associated with the file descriptor I<fd> to the argument I<offset> "
#| "according to the directive I<whence> as follows:"
msgid ""
"B<lseek>()  repositions the file offset of the open file description "
"associated with the file descriptor I<fd> to the argument I<offset> "
"according to the directive I<whence> as follows:"
msgstr ""
"B<lseek>()  関数は、ファイルディスクリプター (descriptor)  I<fd> に対応する"
"オープンされたファイルのオフセットを、 I<whence> に基づき I<offset> 引数の"
"位置へ以下のように変更する:"

#. type: Plain text
#: build/C/man2/lseek.2:70
msgid "The file offset is set to I<offset> bytes."
msgstr "ファイルオフセットは I<offset> バイトに設定される。"

#. type: Plain text
#: build/C/man2/lseek.2:75
msgid "The file offset is set to its current location plus I<offset> bytes."
msgstr "ファイルオフセットは現在位置に I<offset> バイトを足した位置になる。"

#. type: Plain text
#: build/C/man2/lseek.2:80
msgid "The file offset is set to the size of the file plus I<offset> bytes."
msgstr "ファイルオフセットはファイルのサイズに I<offset> バイトを足した位置になる。"

#. type: Plain text
#: build/C/man2/lseek.2:87
msgid ""
"B<lseek>()  allows the file offset to be set beyond the end of the file (but "
"this does not change the size of the file).  If data is later written at "
"this point, subsequent reads of the data in the gap (a \"hole\") return null "
"bytes (\\(aq\\e0\\(aq) until data is actually written into the gap."
msgstr "B<lseek>() は、オフセットをファイルの末尾を越えた位置に設定できる (但し、これによりファイルのサイズが変わらない)。 もしデータがこのオフセット位置以降に書き込まれた場合、 間の空隙の部分 (\"穴 (hole)\") の読み出しがあると、 実際にそこにデータを書き込まれるまではヌルバイト (\\(aq\\e0\\(aq) の列が返される。"

#. type: SS
#: build/C/man2/lseek.2:87
#, no-wrap
msgid "Seeking file data and holes"
msgstr "ファイルのデータとホールの探索"

#. type: Plain text
#: build/C/man2/lseek.2:90
msgid ""
"Since version 3.1, Linux supports the following additional values for "
"I<whence>:"
msgstr ""
"Linux バージョン 3.1 以降では、 I<whence> に以下の値も指定することができる。"

#. type: TP
#: build/C/man2/lseek.2:90
#, no-wrap
msgid "B<SEEK_DATA>"
msgstr "B<SEEK_DATA>"

#. type: Plain text
#: build/C/man2/lseek.2:101
msgid ""
"Adjust the file offset to the next location in the file greater than or "
"equal to I<offset> containing data.  If I<offset> points to data, then the "
"file offset is set to I<offset>."
msgstr ""
"ファイルオフセットを I<offset> 以上で次にデータがある位置に設定する。 "
"I<offset> がデータを指している場合には、 ファイルオフセットは I<offset> に設"
"定される。"

#. type: TP
#: build/C/man2/lseek.2:101
#, no-wrap
msgid "B<SEEK_HOLE>"
msgstr "B<SEEK_HOLE>"

#. type: Plain text
#: build/C/man2/lseek.2:115
msgid ""
"Adjust the file offset to the next hole in the file greater than or equal to "
"I<offset>.  If I<offset> points into the middle of a hole, then the file "
"offset is set to I<offset>.  If there is no hole past I<offset>, then the "
"file offset is adjusted to the end of the file (i.e., there is an implicit "
"hole at the end of any file)."
msgstr ""
"ファイルオフセットを、 位置が I<offset> 以上の次のホール (hole) に設定する。 "
"I<offset> がホールの内部にある場合は、ファイルシステムは I<offset> に設定され"
"る。 I<offset> 以降にホールがない場合は、 ファイルオフセットはファイル末尾に"
"設定される (つまり、 どのファイルの末尾にも暗黙のホールが存在するということ"
"だ)。"

#. type: Plain text
#: build/C/man2/lseek.2:121
msgid ""
"In both of the above cases, B<lseek>()  fails if I<offset> points past the "
"end of the file."
msgstr ""
"上記のどちらの場合も、 I<offset> がファイル末尾よりも先を指している場合には "
"B<lseek>() は失敗する。"

#. type: Plain text
#: build/C/man2/lseek.2:127
msgid ""
"These operations allow applications to map holes in a sparsely allocated "
"file.  This can be useful for applications such as file backup tools, which "
"can save space when creating backups and preserve holes, if they have a "
"mechanism for discovering holes."
msgstr ""
"これらの操作を使うことで、 アプリケーションが、 まばら (sparse ) にページが割"
"り当てられたファイルでホールをマップすることができる。 この機能はファイルバッ"
"クアップツールなどのアプリケーションで有用である。 ホールを見つける仕組みがあ"
"れば、 ファイルバックアップツールで、 バックアップを作成する際に保存領域を節"
"約し、ホールを保持することができる。"

#.  https://lkml.org/lkml/2011/4/22/79
#.  http://lwn.net/Articles/440255/
#.  http://blogs.oracle.com/bonwick/entry/seek_hole_and_seek_data
#. type: Plain text
#: build/C/man2/lseek.2:150
msgid ""
"For the purposes of these operations, a hole is a sequence of zeros that "
"(normally) has not been allocated in the underlying file storage.  However, "
"a filesystem is not obliged to report holes, so these operations are not a "
"guaranteed mechanism for mapping the storage space actually allocated to a "
"file.  (Furthermore, a sequence of zeros that actually has been written to "
"the underlying storage may not be reported as a hole.)  In the simplest "
"implementation, a filesystem can support the operations by making "
"B<SEEK_HOLE> always return the offset of the end of the file, and making "
"B<SEEK_DATA> always return I<offset> (i.e., even if the location referred to "
"by I<offset> is a hole, it can be considered to consist of data that is a "
"sequence of zeros)."
msgstr ""
"これらの操作の目的としては、 ホールは (通常は) バックエンドのファイルストレー"
"ジには割り当てられていない連続する 0 の列である。 しかし、ファイルシステムに"
"はホールを報告する義務はなく、 そのため、 これらの操作は、 ファイルに実際に割"
"り当てられたストレージ領域をマッピングする方法としては確実性のある仕組みでは"
"ない。 (また、バックエンドのストレージに実際に書き込まれた連続する 0 の列は"
"ホールとして報告されないこともある。) 最も単純な実装としては、 B<SEEK_HOLE> "
"は常にファイル末尾のオフセットを返すようにし、 B<SEEK_DATA> は常に I<offset> "
"を返すようにすることで、 ファイルシステムはこれらの操作をサポートすることがで"
"きる (B<SEEK_DATA> は常に I<offset> を返すというのは、 I<offset> が参照する場"
"所がホールであったとしても、 連続する 0 の列のデータで構成されているとみなす"
"ということである)。"

#. type: Plain text
#: build/C/man2/lseek.2:159
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<SEEK_DATA> and B<SEEK_HOLE> from I<E<lt>unistd.hE<gt>>."
msgstr ""
"I<E<lt>unistd.hE<gt>> から B<SEEK_DATA> と B<SEEK_HOLE> の定義を得るには、 機"
"能検査マクロ B<_GNU_SOURCE> を定義しなければならない。"

#. type: Plain text
#: build/C/man2/lseek.2:165
msgid ""
"The B<SEEK_HOLE> and B<SEEK_DATA> operations are supported for the following "
"filesystems:"
msgstr ""
"B<SEEK_HOLE>, B<SEEK_DATA> 操作に対応しているのは以下のファイルシステムであ"
"る。"

#. type: Plain text
#: build/C/man2/lseek.2:167
msgid "Btrfs (since Linux 3.1)"
msgstr "Btrfs (Linux 3.1 以降)"

#.  commit 93862d5e1ab875664c6cc95254fc365028a48bb1
#. type: Plain text
#: build/C/man2/lseek.2:170
msgid "OCFS (since Linux 3.2)"
msgstr "OCFS (Linux 3.2 以降)"

#. type: Plain text
#: build/C/man2/lseek.2:172
msgid "XFS (since Linux 3.5)"
msgstr "XFS (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man2/lseek.2:174
msgid "ext4 (since Linux 3.8)"
msgstr "ext4 (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/lseek.2:177
msgid "B<tmpfs>(5)  (since Linux 3.8)"
msgstr "B<tmpfs>(5)  (Linux 3.8 以降)"

#.  commit 1c6dcbe5ceff81c2cf8d929646af675cd59fe7c0
#.  commit 24bab491220faa446d945624086d838af41d616c
#. type: Plain text
#: build/C/man2/lseek.2:181
msgid "NFS (since Linux 3.18)"
msgstr "NFS (Linux 3.18 以降)"

#.  commit 0b5da8db145bfd44266ac964a2636a0cf8d7c286
#. type: Plain text
#: build/C/man2/lseek.2:184
msgid "FUSE (since Linux 4.5)"
msgstr "FUSE (Linux 4.5 以降)"

#.  commit 3a27411cb4bc3ce31db228e3569ad01b462a4310
#. type: Plain text
#: build/C/man2/lseek.2:187
msgid "GFS2 (since Linux 4.15)"
msgstr "GFS2 (Linux 4.15 以降)"

#. type: Plain text
#: build/C/man2/lseek.2:195
msgid ""
"Upon successful completion, B<lseek>()  returns the resulting offset "
"location as measured in bytes from the beginning of the file.  On error, the "
"value I<(off_t)\\ -1> is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合、 B<lseek>()  は結果のファイル位置をファイルの先頭からのバイト数"
"で返す。 エラーの場合、値 I<(off_t)\\ -1> が返され、 I<errno> にエラーが指示"
"される。"

#.  Some systems may allow negative offsets for character devices
#.  and/or for remote filesystems.
#. type: Plain text
#: build/C/man2/lseek.2:208
msgid ""
"I<whence> is not valid.  Or: the resulting file offset would be negative, or "
"beyond the end of a seekable device."
msgstr ""
"I<whence> が有効な値ではない。または、seek の結果、ファイルオフセットが負に\n"
"なってしまうか、 seek 可能なデバイスの末尾を越えてしまう。"

#. type: TP
#: build/C/man2/lseek.2:208 build/C/man2/open.2:1192 build/C/man2/open.2:1197
#: build/C/man2/open.2:1200
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man2/lseek.2:224
#, fuzzy
#| msgid ""
#| "I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and the current file offset is "
#| "beyond the end of the file."
msgid ""
"I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and I<offset> is beyond the end "
"of the file, or I<whence> is B<SEEK_DATA> and I<offset> is within a hole at "
"the end of the file."
msgstr ""
"I<whence> が B<SEEK_DATA> か B<SEEK_HOLE> で、\n"
"現在のファイルオフセットがファイルの末尾を超えた位置である。"

#. type: TP
#: build/C/man2/lseek.2:224 build/C/man2/open.2:1209
#: build/C/man2/open_by_handle_at.2:335
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#.  HP-UX 11 says EINVAL for this case (but POSIX.1 says EOVERFLOW)
#. type: Plain text
#: build/C/man2/lseek.2:229
msgid "The resulting file offset cannot be represented in an I<off_t>."
msgstr "結果のファイルオフセットを I<off_t> 型で表現することができない。"

#. type: Plain text
#: build/C/man2/lseek.2:233
msgid "I<fd> is associated with a pipe, socket, or FIFO."
msgstr "I<fd> がパイプ、ソケット、FIFO を参照している。"

#. type: Plain text
#: build/C/man2/lseek.2:235 build/C/man2/rmdir.2:130
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#.  FIXME . Review http://austingroupbugs.net/view.php?id=415 in the future
#. type: Plain text
#: build/C/man2/lseek.2:243
msgid ""
"B<SEEK_DATA> and B<SEEK_HOLE> are nonstandard extensions also present in "
"Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the "
"next POSIX revision (Issue 8)."
msgstr ""
"B<SEEK_DATA> と B<SEEK_HOLE> は非標準の拡張で、 Solaris, FreeBSD, DragonFly "
"BSD にも存在する。 これらは POSIX の次の版 (Issue 8) に入れるよう提案されてい"
"る。"

#. type: Plain text
#: build/C/man2/lseek.2:248
msgid ""
"See B<open>(2)  for a discussion of the relationship between file "
"descriptors, open file descriptions, and files."
msgstr ""
"ファイルディスクリプター、オープンファイル記述、ファイルの関係の説明について"
"は B<open>(2) を参照。"

#. type: Plain text
#: build/C/man2/lseek.2:257
msgid ""
"If the B<O_APPEND> file status flag is set on the open file description, "
"then a B<write>(2)  I<always> moves the file offset to the end of the file, "
"regardless of the use of B<lseek>()."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:261
msgid ""
"The I<off_t> data type is a signed integer data type specified by POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:265
msgid ""
"Some devices are incapable of seeking and POSIX does not specify which "
"devices must support B<lseek>()."
msgstr ""
"いくつかのデバイスでは seek ができない。 POSIX はどのデバイスが B<lseek>()  "
"に対応すべきかは規定していない。"

#.  Other systems return the number of written characters,
#.  using SEEK_SET to set the counter. (Of written characters.)
#. type: Plain text
#: build/C/man2/lseek.2:272
#, fuzzy
#| msgid "On Linux, using B<lseek>()  on a terminal device returns B<ESPIPE>."
msgid ""
"On Linux, using B<lseek>()  on a terminal device fails with the error "
"B<ESPIPE>."
msgstr ""
"Linux では、端末 (terminal) デバイスに B<lseek>() を使用すると B<ESPIPE> が返"
"る。"

#. type: Plain text
#: build/C/man2/lseek.2:280
msgid ""
"B<dup>(2), B<fallocate>(2), B<fork>(2), B<open>(2), B<fseek>(3), "
"B<lseek64>(3), B<posix_fallocate>(3)"
msgstr "B<dup>(2), B<fallocate>(2), B<fork>(2), B<open>(2), B<fseek>(3), B<lseek64>(3), B<posix_fallocate>(3)"

#. type: TH
#: build/C/man3/lseek64.3:26
#, no-wrap
msgid "LSEEK64"
msgstr "LSEEK64"

#. type: Plain text
#: build/C/man3/lseek64.3:29
msgid "lseek64 - reposition 64-bit read/write file offset"
msgstr "lseek64 - ファイルの 64 ビットの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man3/lseek64.3:31
msgid "B<#define _LARGEFILE64_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _LARGEFILE64_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/lseek64.3:37
msgid ""
"B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""
"B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man3/lseek64.3:54
msgid ""
"The B<lseek>()  family of functions reposition the offset of the open file "
"associated with the file descriptor I<fd> to I<offset> bytes relative to the "
"start, current position, or end of the file, when I<whence> has the value "
"B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr "B<lseek>() 関数ファミリーは、ファイルディスクリプター I<fd> に関連するオープンされたファイルのオフセットを、 ファイルの開始位置・現在位置・終端から I<offset> の位置へ変更する。 これは I<whence> がそれぞれ B<SEEK_SET>, B<SEEK_CUR>, B<SEEK_END> の場合に対応する。"

#. type: Plain text
#: build/C/man3/lseek64.3:57
msgid "For more details, return value, and errors, see B<lseek>(2)."
msgstr "更に詳しい説明・返り値・エラーは、 B<lseek>(2)  を参照すること。"

#.  For some background details, see:
#.  https://lore.kernel.org/linux-man/CAKgNAkhNSWR3uYhYYaxx74fZfJ3JrpfAAPVrK0AFk_cAOUsbDg@mail.gmail.com/
#. type: Plain text
#: build/C/man3/lseek64.3:68
msgid ""
"Four interfaces are available: B<lseek>(), B<lseek64>(), B<llseek>(), and "
"B<_llseek>()."
msgstr "4 つのインターフェースが使用可能である: B<lseek>(), B<lseek64>(), B<llseek>(), B<llseek>()"

#. type: SS
#: build/C/man3/lseek64.3:68
#, no-wrap
msgid "lseek()"
msgstr "lseek()"

#. type: Plain text
#: build/C/man3/lseek64.3:70 build/C/man3/lseek64.3:93
#: build/C/man3/lseek64.3:122
msgid "Prototype:"
msgstr "プロトタイプ:"

#. type: Plain text
#: build/C/man3/lseek64.3:74
#, no-wrap
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:83
#, fuzzy
#| msgid ""
#| "B<lseek>(2)  uses the type I<off_t>.  This is a 32-bit signed type on 32-"
#| "bit architectures, unless one compiles with"
msgid ""
"The C library's B<lseek>()  wrapper function uses the type I<off_t>.  This "
"is a 32-bit signed type on 32-bit architectures, unless one compiles with"
msgstr ""
"B<lseek>(2)  は型 I<off_t> を使う。 これは 32 ビットアーキテクチャー上では "
"32 ビット符号付き型である。 ただし、"

#. type: Plain text
#: build/C/man3/lseek64.3:87
#, no-wrap
msgid "#define _FILE_OFFSET_BITS 64\n"
msgstr "#define _FILE_OFFSET_BITS 64\n"

#. type: Plain text
#: build/C/man3/lseek64.3:91
msgid "in which case it is a 64-bit signed type."
msgstr "を定義してコンパイルした場合は 64 ビット符号付き型である。"

#. type: SS
#: build/C/man3/lseek64.3:91
#, no-wrap
msgid "lseek64()"
msgstr "lseek64()"

#. type: Plain text
#: build/C/man3/lseek64.3:97
#, no-wrap
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:108
msgid ""
"The B<lseek64>()  library function uses a 64-bit type even when I<off_t> is "
"a 32-bit type.  Its prototype (and the type I<off64_t>)  is available only "
"when one compiles with"
msgstr "ライブラリ関数 B<lseek64>()  は I<off_t> が 32 ビット型であっても 64 ビット型を使う。 このプロトタイプ (と型 I<off64_t>)  は、以下の定義をしてコンパイルした場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man3/lseek64.3:112
#, no-wrap
msgid "#define _LARGEFILE64_SOURCE\n"
msgstr "#define _LARGEFILE64_SOURCE\n"

#.  in glibc 2.0.94, not in 2.0.6
#. type: Plain text
#: build/C/man3/lseek64.3:120
msgid "The function B<lseek64>()  is available since glibc 2.1."
msgstr "関数 B<lseek64>()  は glibc 2.1 以降で使用可能である。"

#. type: SS
#: build/C/man3/lseek64.3:120
#, no-wrap
msgid "llseek()"
msgstr "llseek()"

#. type: Plain text
#: build/C/man3/lseek64.3:126
#, no-wrap
msgid "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:141
msgid ""
"The type I<loff_t> is a 64-bit signed type.  The B<llseek>()  library "
"function is available in glibc and works without special defines.  However, "
"the glibc headers do not provide a prototype.  Users should add the above "
"prototype, or something equivalent, to their own source.  When users "
"complained about data loss caused by a miscompilation of B<e2fsck>(8), glibc "
"2.1.3 added the link-time warning"
msgstr "型 I<loff_t> は 64 ビット符号付き型である。 ライブラリ関数 B<llseek>() は glibc で利用可能であり、 特別な定義なしに動作する。 しかしながら、 glibc のヘッダーはプロトタイプを供していない。 ユーザーは上記のプロトタイプまたはそれと同等のものを、 自身のソースに追加しなければならない。 このデータがないことによって B<e2fsck>(8)  のコンパイルが失敗するという苦情がユーザーから出たので、 glibc 2.1.3 では以下のようなリンク時の警告が追加された。"

#. type: Plain text
#: build/C/man3/lseek64.3:144
msgid "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."
msgstr "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."

#. type: Plain text
#: build/C/man3/lseek64.3:148
msgid ""
"This makes this function unusable if one desires a warning-free compilation."
msgstr ""
"これにより、警告なしでコンパイルしたい場合には、この関数を使用不可にできる。"

#.  glibc commit 5c5c0dd747070db624c8e2c43691cec854f114ef
#. type: Plain text
#: build/C/man3/lseek64.3:153
msgid ""
"Since glibc 2.28, this function symbol is no longer available to newly "
"linked applications."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:153
#, no-wrap
msgid "_llseek()"
msgstr "_llseek()"

#. type: Plain text
#: build/C/man3/lseek64.3:158
msgid ""
"On 32-bit architectures, this is the system call that is used (by the C "
"library wrapper functions)  to implement all of the above functions.  The "
"prototype is:"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:163
#, no-wrap
msgid ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"
msgstr ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:168
msgid "For more details, see B<llseek>(2)."
msgstr "更に詳しい情報は、 B<llseek>(2)  を参照すること。"

#
#
#.  In arch/x86/entry/syscalls/syscall_32.tbl,
#.  we see the following line:
#.     140     i386    _llseek                 sys_llseek
#.  This is essentially telling us that 'sys_llseek' (the name generated
#.  by SYSCALL_DEFINE5(llseek...)) is exposed to user-space as system call
#.  number 140, and that system call number will (IIUC) be exposed in
#.  autogenerated headers with the name "__NR__llseek" (i.e., "_llseek").
#.  The "i386" is telling us that this happens in i386 (32-bit Intel).
#.  There is nothing equivalent on x86-64, because 64 bit systems don't
#.  need an _llseek system call.
#. type: Plain text
#: build/C/man3/lseek64.3:187
msgid ""
"64-bit systems don't need an B<_llseek>()  system call.  Instead, they have "
"an B<lseek>(2)  system call that supports 64-bit file offsets."
msgstr ""

#. type: tbl table
#: build/C/man3/lseek64.3:197
#, no-wrap
msgid "B<lseek64>()"
msgstr "B<lseek64>()"

#. type: Plain text
#: build/C/man3/lseek64.3:218
msgid ""
"B<lseek64>()  is one of the functions that was specified in the Large File "
"Summit (LFS)  specification that was completed in 1996.  The purpose of the "
"specification was to provide transitional support that allowed applications "
"on 32-bit systems to access files whose size exceeds that which can be "
"represented with a 32-bit I<off_t> type.  As noted above, this symbol is "
"exposed by header files if the B<_LARGEFILE64_SOURCE> feature test macro is "
"defined.  ALternatively, on a 32-bit system, the symbol I<lseek> is aliased "
"to I<lseek64> if the macro B<_FILE_OFFSET_BITS> is defined with the value 64."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:221
msgid "B<llseek>(2), B<lseek>(2)"
msgstr "B<llseek>(2), B<lseek>(2)"

#. type: TH
#: build/C/man2/open.2:51
#, no-wrap
msgid "OPEN"
msgstr "OPEN"

#. type: Plain text
#: build/C/man2/open.2:54
msgid "open, openat, creat - open and possibly create a file"
msgstr "open, openat, creat - ファイルのオープン、作成を行う"

#. type: Plain text
#: build/C/man2/open.2:59
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/open.2:62
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
msgstr ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:64
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:68
#, no-wrap
msgid ""
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
msgstr ""
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:72
#, no-wrap
msgid ""
"/* Documented separately, in B<openat2>(2): */\n"
"B<int openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            const struct open_how *>I<how>B<, size_t >I<size>B<);>\n"
msgstr ""
"/* Documented separately, in B<openat2>(2): */\n"
"B<int openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            const struct open_how *>I<how>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:80
msgid "B<openat>():"
msgstr "B<openat>():"

#. type: Plain text
#: build/C/man2/open.2:104
msgid ""
"The B<open>()  system call opens the file specified by I<pathname>.  If the "
"specified file does not exist, it may optionally (if B<O_CREAT> is specified "
"in I<flags>)  be created by B<open>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:113
#, fuzzy
#| msgid ""
#| "Given a I<pathname> for a file, B<open>()  returns a file descriptor, a "
#| "small, nonnegative integer for use in subsequent system calls "
#| "(B<read>(2), B<write>(2), B<lseek>(2), B<fcntl>(2), etc.).  The file "
#| "descriptor returned by a successful call will be the lowest-numbered file "
#| "descriptor not currently open for the process."
msgid ""
"The return value of B<open>()  is a file descriptor, a small, nonnegative "
"integer that is used in subsequent system calls (B<read>(2), B<write>(2), "
"B<lseek>(2), B<fcntl>(2), etc.) to refer to the open file.  The file "
"descriptor returned by a successful call will be the lowest-numbered file "
"descriptor not currently open for the process."
msgstr ""
"ファイルの I<pathname> を与えると、 B<open>()  はファイルディスクリプターを返"
"す。 ファイルディスクリプターは、この後に続くシステムコール (B<read>(2), "
"B<write>(2), B<lseek>(2), B<fcntl>(2) など)  で使用される小さな非負の整数であ"
"る。 このシステムコールが成功した場合に返されるファイルディスクリプターは そ"
"のプロセスがその時点でオープンしていないファイルディスクリプターの うち最小の"
"数字のものとなる。"

#. type: Plain text
#: build/C/man2/open.2:125
msgid ""
"By default, the new file descriptor is set to remain open across an "
"B<execve>(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in "
"B<fcntl>(2)  is initially disabled); the B<O_CLOEXEC> flag, described below, "
"can be used to change this default.  The file offset is set to the beginning "
"of the file (see B<lseek>(2))."
msgstr ""
"デフォルトでは、新しいファイルディスクリプターは B<execve>(2) を実行した後"
"も\n"
"オープンされたままとなる (つまり、 B<fcntl>(2) に説明がある B<FD_CLOEXEC> \n"
"ファイルディスクリプターフラグは最初は無効である); 後述の B<O_CLOEXEC> フラ"
"グ\n"
"を使うとこのデフォルトを変更することができる。 ファイルオフセット \n"
"(file offset) はファイルの先頭に設定される (B<lseek>(2) 参照)。"

#. type: Plain text
#: build/C/man2/open.2:138
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  The open file description records the file "
"offset and the file status flags (see below).  A file descriptor is a "
"reference to an open file description; this reference is unaffected if "
"I<pathname> is subsequently removed or modified to refer to a different "
"file.  For further details on open file descriptions, see NOTES."
msgstr ""
"B<open>()  を呼び出すと、「オープンファイル記述」 I<(open file description)> "
"が作成される。ファイル記述とは、システム全体のオープン中のファイルのテーブル"
"のエントリーである。 このオープンファイル記述は、ファイルオフセットとファイル"
"状態フラグ (下記参照) が保持する。 ファイルディスクリプターはオープンファイ"
"ルっ記述への参照である。 この後で I<pathname> が削除されたり、他のファイルを"
"参照するように変更されたりしても、 この参照は影響を受けない。 オープンファイ"
"ル記述の詳細な説明は「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/open.2:146
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file read-"
"only, write-only, or read/write, respectively."
msgstr ""
"引数 I<flags> には、アクセスモード B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> のど"
"れかひとつが入っていなければならない。 これらはそれぞれ読み込み専用、書き込み"
"専用、読み書き用に ファイルをオープンすることを要求するものである。"

#.  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  I raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/64/focus=67
#.  TC1 (balloted in 2013), resolved this, so that those three constants
#.  are also categorized" as file status flags.
#. type: Plain text
#: build/C/man2/open.2:186
#, fuzzy
#| msgid ""
#| "In addition, zero or more file creation flags and file status flags can "
#| "be bitwise-I<or>'d in I<flags>.  The I<file creation flags> are "
#| "B<O_CLOEXEC>, B<O_CREAT>, B<O_DIRECTORY>, B<O_EXCL>, B<O_NOCTTY>, "
#| "B<O_NOFOLLOW>, B<O_TMPFILE>, B<O_TRUNC>, and B<O_TTY_INIT>.  The I<file "
#| "status flags> are all of the remaining flags listed below.  The "
#| "distinction between these two groups of flags is that the file status "
#| "flags can be retrieved and (in some cases)  modified; see B<fcntl>(2)  "
#| "for details."
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CLOEXEC>, "
"B<O_CREAT>, B<O_DIRECTORY>, B<O_EXCL>, B<O_NOCTTY>, B<O_NOFOLLOW>, "
"B<O_TMPFILE>, and B<O_TRUNC>.  The I<file status flags> are all of the "
"remaining flags listed below.  The distinction between these two groups of "
"flags is that the file creation flags affect the semantics of the open "
"operation itself, while the file status flags affect the semantics of "
"subsequent I/O operations.  The file status flags can be retrieved and (in "
"some cases)  modified; see B<fcntl>(2)  for details."
msgstr ""
"さらに、 I<flags> には、ファイル作成フラグ (file creation flag) とファイル状"
"態フラグ (file status flag) を 0 個以上「ビット単位の OR (bitwise-or)」で 指"
"定することができる。 I<ファイル作成フラグ> は B<O_CLOEXEC>, B<O_CREAT>, "
"B<O_DIRECTORY>, B<O_EXCL>, B<O_NOCTTY>, B<O_NOFOLLOW>, B<O_TMPFILE>, "
"B<O_TRUNC>, B<O_TTY_INIT> である。 I<ファイル状態フラグ> は以下のリストのうち"
"上記以外の残りのものである。 二種類のフラグの違いは、ファイル状態フラグの方は"
"その内容を取得したり (場合によっては) 変更したりできる点にある。詳細は "
"B<fcntl>(2) を参照。"

#. type: Plain text
#: build/C/man2/open.2:188
msgid ""
"The full list of file creation flags and file status flags is as follows:"
msgstr "すべてのファイル作成フラグとファイル状態フラグを以下のリストに示す。"

#. type: TP
#: build/C/man2/open.2:188
#, no-wrap
msgid "B<O_APPEND>"
msgstr "B<O_APPEND>"

#. type: Plain text
#: build/C/man2/open.2:198
#, fuzzy
#| msgid ""
#| "The file is opened in append mode.  Before each B<write>(2), the file "
#| "offset is positioned at the end of the file, as if with B<lseek>(2).  "
#| "B<O_APPEND> may lead to corrupted files on NFS filesystems if more than "
#| "one process appends data to a file at once.  This is because NFS does not "
#| "support appending to a file, so the client kernel has to simulate it, "
#| "which can't be done without a race condition."
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  The "
"modification of the file offset and the write operation are performed as a "
"single atomic step."
msgstr ""
"ファイルを追加 (append) モードでオープンする。 毎回の B<write>(2)  の前に "
"B<lseek>(2)  を行ったかのように、ファイルポインターをファイルの最後に移動す"
"る。 NFS ファイルシステムで、 B<O_APPEND> を使用すると、複数のプロセスがひと"
"つのファイルに同時にデータを追加した場合、 ファイルが壊れてしまうことがあ"
"る。 これは NFS が追加モードをサポートしていないため、 クライアントのカーネ"
"ル (kernel) がそれをシミュレートしなければならないのだが、 競合状態を避けるこ"
"とはできないからである。"

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
#: build/C/man2/open.2:208
#, fuzzy
#| msgid ""
#| "The file is opened in append mode.  Before each B<write>(2), the file "
#| "offset is positioned at the end of the file, as if with B<lseek>(2).  "
#| "B<O_APPEND> may lead to corrupted files on NFS filesystems if more than "
#| "one process appends data to a file at once.  This is because NFS does not "
#| "support appending to a file, so the client kernel has to simulate it, "
#| "which can't be done without a race condition."
msgid ""
"B<O_APPEND> may lead to corrupted files on NFS filesystems if more than one "
"process appends data to a file at once.  This is because NFS does not "
"support appending to a file, so the client kernel has to simulate it, which "
"can't be done without a race condition."
msgstr ""
"ファイルを追加 (append) モードでオープンする。 毎回の B<write>(2)  の前に "
"B<lseek>(2)  を行ったかのように、ファイルポインターをファイルの最後に移動す"
"る。 NFS ファイルシステムで、 B<O_APPEND> を使用すると、複数のプロセスがひと"
"つのファイルに同時にデータを追加した場合、 ファイルが壊れてしまうことがあ"
"る。 これは NFS が追加モードをサポートしていないため、 クライアントのカーネ"
"ル (kernel) がそれをシミュレートしなければならないのだが、 競合状態を避けるこ"
"とはできないからである。"

#. type: TP
#: build/C/man2/open.2:208
#, no-wrap
msgid "B<O_ASYNC>"
msgstr "B<O_ASYNC>"

#. type: Plain text
#: build/C/man2/open.2:222
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is available only for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details.  See also BUGS, below."
msgstr ""
"シグナル駆動 I/O (signal-driven I/O) を有効にする: このファイルディスクリプ"
"ターへの 入力または出力が可能になった場合に、シグナルを生成する (デフォルト"
"は B<SIGIO> であるが、 B<fcntl>(2)  によって変更可能である)。 この機能が使用"
"可能なのは端末、疑似端末、ソケットのみであり、 (Linux 2.6 以降では) パイプと "
"FIFO に対しても使用できる。 さらに詳しい説明は B<fcntl>(2)  を参照すること。 "
"下記の「バグ」も参照。"

#. type: TP
#: build/C/man2/open.2:222
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.23)"
msgstr "B<O_CLOEXEC> (Linux 2.6.23 以降)"

#.  NOTE! several other man pages refer to this text
#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX proposes to fix many APIs that provide hidden FDs
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=368
#. type: Plain text
#: build/C/man2/open.2:236
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag."
msgstr ""
"新しいファイルディスクリプターに対して close-on-exec フラグを有効にする。 こ"
"のフラグを指定することで、 プログラムは B<FD_CLOEXEC> フラグをセットするため"
"に B<fcntl>(2) B<F_SETFD> 操作を別途呼び出す必要がなくなる。"

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, file descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
#: build/C/man2/open.2:265
msgid ""
"Note that the use of this flag is essential in some multithreaded programs, "
"because using a separate B<fcntl>(2)  B<F_SETFD> operation to set the "
"B<FD_CLOEXEC> flag does not suffice to avoid race conditions where one "
"thread opens a file descriptor and attempts to set its close-on-exec flag "
"using B<fcntl>(2)  at the same time as another thread does a B<fork>(2)  "
"plus B<execve>(2).  Depending on the order of execution, the race may lead "
"to the file descriptor returned by B<open>()  being unintentionally leaked "
"to the program executed by the child process created by B<fork>(2).  (This "
"kind of race is in principle possible for any system call that creates a "
"file descriptor whose close-on-exec flag should be set, and various other "
"Linux system calls provide an equivalent of the B<O_CLOEXEC> flag to deal "
"with this problem.)"
msgstr ""
"ある種のマルチスレッドのプログラムはこのフラグの使用は不可欠である点に注意す"
"ること。 なぜなら、個別に B<FD_CLOEXEC> フラグを設定する B<fcntl>(2) "
"B<F_SETFD> 操作を呼び出したとしても、あるスレッドがファイルディスクリプター"
"を オープンするのと同時に別のスレッドが B<fork>(2) と B<execve>(2) を実行する"
"という競合条件を避けるのには十分ではないからである。 実行の順序に依存して、こ"
"の競合条件の結果、 B<open>() が返したファイルディスクリプターが B<fork>(2) で"
"作成された子プロセスにより実行されるプログラムに意図せず見えてしまう可能性が"
"ある。 (この種の競合は、 本質的に、 close-on-exec フラグをセットすべきファイ"
"ルディスクリプターを作成するどのシステムコールでも起こり得るものであり、 他の"
"いろいろな Linux システムコールでこの問題に対処するために B<O_CLOEXEC> と同等"
"の機能が提供されている。)"

#. type: TP
#: build/C/man2/open.2:265
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#. type: Plain text
#: build/C/man2/open.2:270
msgid "If I<pathname> does not exist, create it as a regular file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:273
msgid ""
"The owner (user ID) of the new file is set to the effective user ID of the "
"process."
msgstr ""

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
#: build/C/man2/open.2:289
msgid ""
"The group ownership (group ID) of the new file is set either to the "
"effective group ID of the process (System V semantics)  or to the group ID "
"of the parent directory (BSD semantics).  On Linux, the behavior depends on "
"whether the set-group-ID mode bit is set on the parent directory: if that "
"bit is set, then BSD semantics apply; otherwise, System V semantics apply.  "
"For some filesystems, the behavior also depends on the I<bsdgroups> and "
"I<sysvgroups> mount options described in B<mount>(8)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:314
msgid ""
"The I<mode> argument specifies the file mode bits to be applied when a new "
"file is created.  If neither B<O_CREAT> nor B<O_TMPFILE> is specified in "
"I<flags>, then I<mode> is ignored (and can thus be specified as 0, or simply "
"omitted).  The I<mode> argument B<must> be supplied if B<O_CREAT> or "
"B<O_TMPFILE> is specified in I<flags>; if it is not supplied, some arbitrary "
"bytes from the stack will be applied as the file mode."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:320
msgid ""
"The effective mode is modified by the process's I<umask> in the usual way: "
"in the absence of a default ACL, the mode of the created file is I<(mode\\ &"
"\\ \\(tiumask)>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:328
msgid ""
"Note that I<mode> applies only to future accesses of the newly created file; "
"the B<open>()  call that creates a read-only file may well return a read/"
"write file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:331
msgid "The following symbolic constants are provided for I<mode>:"
msgstr "I<mode> のために以下のシンボル定数が提供されている :"

#. type: TP
#: build/C/man2/open.2:332
#, no-wrap
msgid "B<S_IRWXU>"
msgstr "B<S_IRWXU>"

#. type: Plain text
#: build/C/man2/open.2:335
msgid "00700 user (file owner) has read, write, and execute permission"
msgstr ""
"00700 ユーザー (ファイルの所有者) に読み込み、書き込み、 実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:335
#, no-wrap
msgid "B<S_IRUSR>"
msgstr "B<S_IRUSR>"

#. type: Plain text
#: build/C/man2/open.2:338
msgid "00400 user has read permission"
msgstr "00400 ユーザーに読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:338
#, no-wrap
msgid "B<S_IWUSR>"
msgstr "B<S_IWUSR>"

#. type: Plain text
#: build/C/man2/open.2:341
msgid "00200 user has write permission"
msgstr "00200 ユーザーに書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:341
#, no-wrap
msgid "B<S_IXUSR>"
msgstr "B<S_IXUSR>"

#. type: Plain text
#: build/C/man2/open.2:344
msgid "00100 user has execute permission"
msgstr "00100 ユーザーに実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:344
#, no-wrap
msgid "B<S_IRWXG>"
msgstr "B<S_IRWXG>"

#. type: Plain text
#: build/C/man2/open.2:347
msgid "00070 group has read, write, and execute permission"
msgstr "00070 グループに読み込み、書き込み、実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:347
#, no-wrap
msgid "B<S_IRGRP>"
msgstr "B<S_IRGRP>"

#. type: Plain text
#: build/C/man2/open.2:350
msgid "00040 group has read permission"
msgstr "00040 グループに読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:350
#, no-wrap
msgid "B<S_IWGRP>"
msgstr "B<S_IWGRP>"

#. type: Plain text
#: build/C/man2/open.2:353
msgid "00020 group has write permission"
msgstr "00020 グループに書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:353
#, no-wrap
msgid "B<S_IXGRP>"
msgstr "B<S_IXGRP>"

#. type: Plain text
#: build/C/man2/open.2:356
msgid "00010 group has execute permission"
msgstr "00010 グループに実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:356
#, no-wrap
msgid "B<S_IRWXO>"
msgstr "B<S_IRWXO>"

#. type: Plain text
#: build/C/man2/open.2:359
msgid "00007 others have read, write, and execute permission"
msgstr "00007 他人 (others) に読み込み、書き込み、実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:359
#, no-wrap
msgid "B<S_IROTH>"
msgstr "B<S_IROTH>"

#. type: Plain text
#: build/C/man2/open.2:362
msgid "00004 others have read permission"
msgstr "00004 他人に読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:362
#, no-wrap
msgid "B<S_IWOTH>"
msgstr "B<S_IWOTH>"

#. type: Plain text
#: build/C/man2/open.2:365
msgid "00002 others have write permission"
msgstr "00002 他人に書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:365
#, no-wrap
msgid "B<S_IXOTH>"
msgstr "B<S_IXOTH>"

#. type: Plain text
#: build/C/man2/open.2:368
msgid "00001 others have execute permission"
msgstr "00001 他人に実行の許可がある。"

#. type: Plain text
#: build/C/man2/open.2:375
msgid ""
"According to POSIX, the effect when other bits are set in I<mode> is "
"unspecified.  On Linux, the following bits are also honored in I<mode>:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:376
#, no-wrap
msgid "B<S_ISUID>"
msgstr "B<S_ISUID>"

#. type: Plain text
#: build/C/man2/open.2:379
msgid "0004000 set-user-ID bit"
msgstr ""

#. type: TP
#: build/C/man2/open.2:379
#, no-wrap
msgid "B<S_ISGID>"
msgstr "B<S_ISGID>"

#. type: Plain text
#: build/C/man2/open.2:383
msgid "0002000 set-group-ID bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:383
#, no-wrap
msgid "B<S_ISVTX>"
msgstr "B<S_ISVTX>"

#. type: Plain text
#: build/C/man2/open.2:387
msgid "0001000 sticky bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:388
#, no-wrap
msgid "B<O_DIRECT> (since Linux 2.4.10)"
msgstr "B<O_DIRECT> (Linux 2.4.10 以降)"

#. type: Plain text
#: build/C/man2/open.2:405
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly to/"
"from user-space buffers.  The B<O_DIRECT> flag on its own makes an effort to "
"transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> flag that data and necessary metadata are transferred.  To "
"guarantee synchronous I/O, B<O_SYNC> must be used in addition to "
"B<O_DIRECT>.  See NOTES below for further discussion."
msgstr ""
"このファイルに対する I/O のキャッシュの効果を最小化しようとする。このフラグを"
"使うと、一般的に性能が低下する。 しかしアプリケーションが独自にキャッシングを"
"行っているような 特別な場合には役に立つ。 ファイルの I/O はユーザー空間バッ"
"ファーに対して直接行われる。 B<O_DIRECT> フラグ自身はデータを同期で転送しよう"
"とはするが、 B<O_SYNC> フラグのようにデータと必要なメタデータの転送が保証され"
"るわけではない。同期 I/O を保証するためには、 B<O_DIRECT> に加えて B<O_SYNC> "
"を使用しなければならない。下記の「注意」の節の議論も参照。"

#. type: Plain text
#: build/C/man2/open.2:409
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""
"ブロックデバイスに対する似通った意味のインターフェースが B<raw>(8)  で説明さ"
"れている (但し、このインターフェースは非推奨である)。"

#. type: TP
#: build/C/man2/open.2:409
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr "B<O_DIRECTORY>"

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
#: build/C/man2/open.2:421
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag was "
"added in kernel version 2.1.126, to avoid denial-of-service problems if "
"B<opendir>(3)  is called on a FIFO or tape device."
msgstr ""
"I<pathname> がディレクトリでなければオープンは失敗する。 このフラグは、 "
"B<opendir>(3)  が FIFO やテープデバイスに対してコールされた場合の サービス不"
"能 (denial-of-service) 攻撃を避けるために カーネル 2.1.126 で追加された。"

#. type: TP
#: build/C/man2/open.2:421
#, no-wrap
msgid "B<O_DSYNC>"
msgstr "B<O_DSYNC>"

#. type: Plain text
#: build/C/man2/open.2:427
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<data> integrity completion."
msgstr ""
"ファイルに対する書き込み操作は、同期 I/O のI<データ>完全性完了の要件に基づい"
"て行われる。"

#. type: Plain text
#: build/C/man2/open.2:439
msgid ""
"By the time B<write>(2)  (and similar)  return, the output data has been "
"transferred to the underlying hardware, along with any file metadata that "
"would be required to retrieve that data (i.e., as though each B<write>(2)  "
"was followed by a call to B<fdatasync>(2)).  I<See NOTES below>."
msgstr ""
"B<write>(2) (や同様のコール) が返るまでに、 書き込まれたデータおよびデータを"
"取得するのに必要なファイルメタデータが裏で利用されているハードウェアに転送さ"
"れる (つまり、B<write>(2) の後に B<fdatasync>(2) を呼び出したのと同じようにな"
"る)。 I<下記の「注意」も参照のこと>。"

#. type: TP
#: build/C/man2/open.2:439
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man2/open.2:450
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"fails with the error B<EEXIST>."
msgstr "この呼び出しでファイルが作成されることを保証する。このフラグが B<O_CREAT> と一緒に指定され、 I<pathname> のファイルが既に存在した場合、 B<open>() は B<EEXIST> エラーで失敗する。"

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
#: build/C/man2/open.2:458
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points."
msgstr ""
"これら二つのフラグが指定された際、シンボリックリンクは辿られない。 "
"I<pathname> がシンボリックリンクの場合、 シンボリックリンクがどこを指している"
"かに関わらず B<open>()  は失敗する。"

#. type: Plain text
#: build/C/man2/open.2:474
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""
"一般的には、 B<O_CREAT> を指定せずに B<O_EXCL> を使用した場合の\n"
"B<O_EXCL> の動作は規定されていない。\n"
"これには一つ例外があり、Linux 2.6 以降では、\n"
"I<pathname> がブロックデバイスを参照している場合、\n"
"B<O_CREAT> なしで B<O_EXCL> を使用することができる。\n"
"システムがそのブロックデバイスを使用中の場合 (例えば、\n"
"マウントされているなど)、 B<open>() はエラー B<EBUSY> で失敗する。"

#. type: Plain text
#: build/C/man2/open.2:496
msgid ""
"On NFS, B<O_EXCL> is supported only when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same filesystem (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If "
"B<link>(2)  returns 0, the lock is successful.  Otherwise, use B<stat>(2)  "
"on the unique file to check if its link count has increased to 2, in which "
"case the lock is also successful."
msgstr ""
"NFS では、 B<O_EXCL> は、Linux 2.6 以降で NFSv3 以降を使っている場合でのみサ"
"ポートされる。 B<O_EXCL> サポートが提供されていない NFS 環境では、このフラグ"
"に頼って ロック処理を実行するプログラムは競合状態 (race condition) に出会う "
"可能性がある。 ロックファイルを使用して不可分 (atomic) なファイルロックを実現"
"し、 NFS が B<O_EXCL> をサポートしているかに依存しないようにしたい場合、 移植"
"性のある方法は、同じファイルシステム上に他と名前の重ならない ファイル (例えば"
"ホスト名と PID を組み合わせた名前) を作成し、 B<link>(2)  を使用してそのロッ"
"クファイルへのリンクを作成することである。 B<link>(2)  コールの返り値が 0 な"
"らばロックに成功している。 あるいは、そのファイルに B<stat>(2)  を使用してリ"
"ンク数 (link count) が 2 になっているかをチェックする。 そうなっていれば、同"
"じくロックに成功しているということである。"

#. type: TP
#: build/C/man2/open.2:496
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr "B<O_LARGEFILE>"

#. type: Plain text
#: build/C/man2/open.2:518
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""
"(LFS) I<off_t> ではサイズを表せない (だだし I<off64_t> ではサイズを表せる)"
"ファ\n"
"イルをオープン可能にする。この定義を有効にするためには、(I<どの>ヘッダーファ"
"イ\n"
"ルをインクルードするよりも前に) B<_LARGEFILE64_SOURCE> マクロを定義しなけれ"
"ば\n"
"ならない。\n"
"32 ビットシステムにおいて大きなファイルにアクセスしたい場合、\n"
"(B<O_LARGEFILE> を使うよりも) B<_FILE_OFFSET_BITS> 機能検査マクロを 64 に\n"
"セットする方が望ましい方法である (B<feature_test_macros>(7) を参照)。"

#. type: TP
#: build/C/man2/open.2:518
#, no-wrap
msgid "B<O_NOATIME> (since Linux 2.6.8)"
msgstr "B<O_NOATIME> (Linux 2.6.8 以降)"

#. type: Plain text
#: build/C/man2/open.2:525
msgid ""
"Do not update the file last access time (I<st_atime> in the inode)  when the "
"file is B<read>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:527
msgid ""
"This flag can be employed only if one of the following conditions is true:"
msgstr ""

#.  Strictly speaking: the filesystem UID
#. type: Plain text
#: build/C/man2/open.2:532
msgid "The effective UID of the process matches the owner UID of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:537
msgid ""
"The calling process has the B<CAP_FOWNER> capability in its user namespace "
"and the owner UID of the file has a mapping in the namespace."
msgstr ""

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
#: build/C/man2/open.2:545
msgid ""
"This flag is intended for use by indexing or backup programs, where its use "
"can significantly reduce the amount of disk activity.  This flag may not be "
"effective on all filesystems.  One example is NFS, where the server "
"maintains the access time."
msgstr "このフラグはインデックス作成やバックアッププログラムで使うことを意図している。 これを使うとディスクに対する操作を大幅に減らすことができる。 このフラグは全てのファイルシステムに対して有効であるわけではない。 その一例が NFS であり、サーバがアクセス時刻を管理している。"

#. type: TP
#: build/C/man2/open.2:545
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr "B<O_NOCTTY>"

#. type: Plain text
#: build/C/man2/open.2:553
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(emit will not "
"become the process's controlling terminal even if the process does not have "
"one."
msgstr ""
"I<pathname> が端末 (terminal) デバイス \\(em B<tty>(4) 参照 \\(em を指してい"
"る\n"
"場合に、たとえそのプロセスが制御端末を持っていなくても、オープンしたファイ"
"ル\n"
"は制御端末にはならない。"

#. type: TP
#: build/C/man2/open.2:553
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr "B<O_NOFOLLOW>"

#. type: Plain text
#: build/C/man2/open.2:566
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a symbolic "
"link, then the open fails, with the error B<ELOOP>.  Symbolic links in "
"earlier components of the pathname will still be followed.  (Note that the "
"B<ELOOP> error that can occur in this case is indistinguishable from the "
"case where an open fails because there are too many symbolic links found "
"while resolving components in the prefix part of the pathname.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:569
msgid ""
"This flag is a FreeBSD extension, which was added to Linux in version "
"2.1.126, and has subsequently been standardized in POSIX.1-2008."
msgstr ""

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
#: build/C/man2/open.2:576
msgid "See also B<O_PATH> below."
msgstr ""

#. type: TP
#: build/C/man2/open.2:576
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr "B<O_NONBLOCK> または B<O_NDELAY>"

#. type: Plain text
#: build/C/man2/open.2:583
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the "
"B<open>()  nor any subsequent I/O operations on the file descriptor which is "
"returned will cause the calling process to wait."
msgstr "可能ならば、ファイルは非停止 (nonblocking) モードでオープンされる。 B<open>() も、返したファイルディスクリプターに対する以後のすべての操作も呼び出したプロセスを待たせることはない。"

#. type: Plain text
#: build/C/man2/open.2:597
msgid ""
"Note that the setting of this flag has no effect on the operation of "
"B<poll>(2), B<select>(2), B<epoll>(7), and similar, since those interfaces "
"merely inform the caller about whether a file descriptor is \"ready\", "
"meaning that an I/O operation performed on the file descriptor with the "
"B<O_NONBLOCK> flag I<clear> would not block."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:608
msgid ""
"Note that this flag has no effect for regular files and block devices; that "
"is, I/O operations will (briefly) block when device activity is required, "
"regardless of whether B<O_NONBLOCK> is set.  Since B<O_NONBLOCK> semantics "
"might eventually be implemented, applications should not depend upon "
"blocking behavior when specifying this flag for regular files and block "
"devices."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:615
msgid ""
"For the handling of FIFOs (named pipes), see also B<fifo>(7).  For a "
"discussion of the effect of B<O_NONBLOCK> in conjunction with mandatory file "
"locks and with file leases, see B<fcntl>(2)."
msgstr "FIFO (名前付きパイプ) を扱う場合には B<fifo>(7) も参照すること。 強制ファイルロック (mandatory file lock) やファイルリース (file lease) と組み合わせた場合の、 B<O_NONBLOCK> の効果についての議論は、 B<fcntl>(2) を参照すること。"

#. type: TP
#: build/C/man2/open.2:615
#, no-wrap
msgid "B<O_PATH> (since Linux 2.6.39)"
msgstr "B<O_PATH> (Linux 2.6.39 以降)"

#
#.  commit 1abf0c718f15a56a0a435588d1b104c7a37dc9bd
#.  commit 326be7b484843988afe57566b627fb7a70beac56
#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  http://thread.gmane.org/gmane.linux.man/2790/focus=3496
#. 	Subject: Re: [PATCH] open(2): document O_PATH
#. 	Newsgroups: gmane.linux.man, gmane.linux.kernel
#. type: Plain text
#: build/C/man2/open.2:638
msgid ""
"Obtain a file descriptor that can be used for two purposes: to indicate a "
"location in the filesystem tree and to perform operations that act purely at "
"the file descriptor level.  The file itself is not opened, and other file "
"operations (e.g., B<read>(2), B<write>(2), B<fchmod>(2), B<fchown>(2), "
"B<fgetxattr>(2), B<ioctl>(2), B<mmap>(2))  fail with the error B<EBADF>."
msgstr "このフラグを指定して取得したファイルディスクリプターは、 ファイルシステムツリー内での場所を示すため、 純粋にファイルディスクリプターレベルでの作用する操作を実行するため、 の二つの目的で使用することができる。 ファイル自身はオープンされず、 他のファイル操作 (例えば B<read>(2), B<write>(2), B<fchmod>(2), B<fchown>(2), B<fgetxattr>(2), B<ioctl>(2), B<mmap>(2)) はエラー B<EBADF> で失敗する。"

#. type: Plain text
#: build/C/man2/open.2:642
msgid ""
"The following operations I<can> be performed on the resulting file "
"descriptor:"
msgstr ""
"取得したファイルディスクリプターに対して以下の操作を行うことが「できる」。"

#. type: Plain text
#: build/C/man2/open.2:645
msgid "B<close>(2)."
msgstr "B<close>(2)."

#.  commit 332a2e1244bd08b9e3ecd378028513396a004a24
#. type: Plain text
#: build/C/man2/open.2:650
msgid ""
"B<fchdir>(2), if the file descriptor refers to a directory (since Linux 3.5)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:653
msgid "B<fstat>(2)  (since Linux 3.6)."
msgstr "B<fstat>(2) (Linux 3.6 以降)."

#.  fstat(): commit 55815f70147dcfa3ead5738fd56d3574e2e3c1c2
#.  fstatfs(): commit 9d05746e7b16d8565dddbe3200faa1e669d23bbf
#. type: Plain text
#: build/C/man2/open.2:658
msgid "B<fstatfs>(2)  (since Linux 3.12)."
msgstr "B<fstatfs>(2) (Linux 3.12 以降)."

#. type: Plain text
#: build/C/man2/open.2:664
msgid ""
"Duplicating the file descriptor (B<dup>(2), B<fcntl>(2)  B<F_DUPFD>, etc.)."
msgstr ""
"ファイルディスクリプターの複製 (B<dup>(2), B<fcntl>(2)  B<F_DUPFD> など)"

#. type: Plain text
#: build/C/man2/open.2:670
msgid ""
"Getting and setting file descriptor flags (B<fcntl>(2)  B<F_GETFD> and "
"B<F_SETFD>)."
msgstr ""
"ファイルディスクリプターフラグの取得と設定 (B<fcntl>(2) の B<F_GETFD> と "
"B<F_SETFD>)"

#. type: Plain text
#: build/C/man2/open.2:676
msgid ""
"Retrieving open file status flags using the B<fcntl>(2)  B<F_GETFL> "
"operation: the returned flags will include the bit B<O_PATH>."
msgstr ""
"B<fcntl>(2) の B<F_GETFL> 操作を使ったオープンされたファイルの状態フラグの取"
"得。 返されるフラグには B<O_PATH> ビットが含まれる。"

#. type: Plain text
#: build/C/man2/open.2:689
msgid ""
"Passing the file descriptor as the I<dirfd> argument of B<openat>()  and the "
"other \"*at()\" system calls.  This includes B<linkat>(2)  with "
"B<AT_EMPTY_PATH> (or via procfs using B<AT_SYMLINK_FOLLOW>)  even if the "
"file is not a directory."
msgstr "B<openat>() や他の \"*at()\" 系のシステムコールの I<dirfd> 引数としてそのファイルディスクリプターを渡す。 これには、 ファイルがディレクトリでない場合に B<linkat>(2) に B<AT_EMPTY_PATH> が指定された場合 (や procfs 経由で B<AT_SYMLINK_FOLLOW> が使用された場合) を含む。"

#. type: Plain text
#: build/C/man2/open.2:695
msgid ""
"Passing the file descriptor to another process via a UNIX domain socket (see "
"B<SCM_RIGHTS> in B<unix>(7))."
msgstr ""
"そのファイルディスクリプターを別のプロセスに UNIX ドメインソケット経由で渡"
"す。 (B<unix>(7) の B<SCM_RIGHTS> を参照)"

#. type: Plain text
#: build/C/man2/open.2:707
msgid ""
"When B<O_PATH> is specified in I<flags>, flag bits other than B<O_CLOEXEC>, "
"B<O_DIRECTORY>, and B<O_NOFOLLOW> are ignored."
msgstr ""
"I<flags> に B<O_PATH> が指定された場合、 B<O_CLOEXEC>, B<O_DIRECTORY>, "
"B<O_NOFOLLOW> 以外のフラグビットは無視される。"

#. type: Plain text
#: build/C/man2/open.2:725
msgid ""
"Opening a file or directory with the B<O_PATH> flag requires no permissions "
"on the object itself (but does require execute permission on the directories "
"in the path prefix).  Depending on the subsequent operation, a check for "
"suitable file permissions may be performed (e.g., B<fchdir>(2)  requires "
"execute permission on the directory referred to by its file descriptor "
"argument).  By contrast, obtaining a reference to a filesystem object by "
"opening it with the B<O_RDONLY> flag requires that the caller have read "
"permission on the object, even when the subsequent operation (e.g., "
"B<fchdir>(2), B<fstat>(2))  does not require read permission on the object."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:741
msgid ""
"If I<pathname> is a symbolic link and the B<O_NOFOLLOW> flag is also "
"specified, then the call returns a file descriptor referring to the symbolic "
"link.  This file descriptor can be used as the I<dirfd> argument in calls to "
"B<fchownat>(2), B<fstatat>(2), B<linkat>(2), and B<readlinkat>(2)  with an "
"empty pathname to have the calls operate on the symbolic link."
msgstr ""
"I<pathname> がシンボリックリンクで B<O_NOFOLLOW> フラグも合わせて指定された場"
"合、 この呼び出しではシンボリックリンクを参照するファイルディスクリプターを返"
"す。 このファイルディスクリプターは、 空のパス名を指定した B<fchownat>(2), "
"B<fstatat>(2), B<linkat>(2), B<readlinkat>(2) の呼び出しで I<dirfd> 引数とし"
"て使うことで、 そのシンボリックリンクに対して操作を行うことができる。"

#. type: Plain text
#: build/C/man2/open.2:751
msgid ""
"If I<pathname> refers to an automount point that has not yet been triggered, "
"so no other filesystem is mounted on it, then the call returns a file "
"descriptor referring to the automount directory without triggering a mount.  "
"B<fstatfs>(2)  can then be used to determine if it is, in fact, an "
"untriggered automount point (B<.f_type == AUTOFS_SUPER_MAGIC>)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:760
msgid ""
"One use of B<O_PATH> for regular files is to provide the equivalent of "
"POSIX.1's B<O_EXEC> functionality.  This permits us to open a file for which "
"we have execute permission but not read permission, and then execute that "
"file, with steps something like the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:767
#, no-wrap
msgid ""
"char buf[PATH_MAX];\n"
"fd = open(\"some_prog\", O_PATH);\n"
"snprintf(buf, PATH_MAX, \"/proc/self/fd/%d\", fd);\n"
"execl(buf, \"some_prog\", (char *) NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:774
msgid ""
"An B<O_PATH> file descriptor can also be passed as the argument of "
"B<fexecve>(3)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:774
#, no-wrap
msgid "B<O_SYNC>"
msgstr "B<O_SYNC>"

#. type: Plain text
#: build/C/man2/open.2:786
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<file> integrity completion (by contrast with the "
"synchronized I/O I<data> integrity completion provided by B<O_DSYNC>.)"
msgstr ""
"ファイルに対する書き込み操作は、同期 I/O のI<ファイル>完全性完了の要件に基づ"
"いて行われる (これに対し B<O_DSYNC> では同期 I/O のI<データ>完全性完了が提供"
"される)。"

#. type: Plain text
#: build/C/man2/open.2:797
msgid ""
"By the time B<write>(2)  (or similar)  returns, the output data and "
"associated file metadata have been transferred to the underlying hardware (i."
"e., as though each B<write>(2)  was followed by a call to B<fsync>(2)).  "
"I<See NOTES below>."
msgstr ""
"B<write>(2) (や同様のコール) が返るまでに、 書き込まれたデータと関連するファ"
"イルメタデータが裏で利用されているハードウェアに転送される (つまり、"
"B<write>(2) の後に B<fsync>(2) を呼び出したのと同じようになる)。 I<下記の「注"
"意」も参照のこと>。"

#. type: TP
#: build/C/man2/open.2:797
#, no-wrap
msgid "B<O_TMPFILE> (since Linux 3.11)"
msgstr "B<O_TMPFILE> (Linux 3.11 以降)"

#.  commit 60545d0d4610b02e55f65d141c95b18ccf855b6e
#.  commit f4e0c30c191f87851c4a53454abb55ee276f4a7e
#.  commit bb458c644a59dbba3a1fe59b27106c5e68e1c4bd
#. type: Plain text
#: build/C/man2/open.2:809
msgid ""
"Create an unnamed temporary regular file.  The I<pathname> argument "
"specifies a directory; an unnamed inode will be created in that directory's "
"filesystem.  Anything written to the resulting file will be lost when the "
"last file descriptor is closed, unless the file is given a name."
msgstr "名前なしの一時的な通常ファイルを作成する。 I<pathname> 引数はディレクトリを指定する。 名前なしの inode がそのディレクトリが存在するファイルシステムに作成される。 そのファイルに名前を付与しない限り、 作成されたファイルに書き込まれた内容は、 最後のファイルディスクリプターがクローズされる際に失われる。"

#. type: Plain text
#: build/C/man2/open.2:823
msgid ""
"B<O_TMPFILE> must be specified with one of B<O_RDWR> or B<O_WRONLY> and, "
"optionally, B<O_EXCL>.  If B<O_EXCL> is not specified, then B<linkat>(2)  "
"can be used to link the temporary file into the filesystem, making it "
"permanent, using code like the following:"
msgstr ""
"B<O_TMPFILE> は必ず B<O_RDWR> か B<O_WRONLY> のいずれかと一緒に使わなければな"
"らない。 B<O_EXCL> も指定することができる。 B<O_EXCL> が指定されなかった場"
"合、 B<linkat>(2) を使って、そのファイルシステムにこの一時ファイルへのリンク"
"を作成し、ファイルを永続化することができる。 以下のコードのようにすればよい。"

#. type: Plain text
#: build/C/man2/open.2:829
#, no-wrap
msgid ""
"char path[PATH_MAX];\n"
"fd = open(\"/path/to/dir\", O_TMPFILE | O_RDWR,\n"
"                        S_IRUSR | S_IWUSR);\n"
msgstr ""
"char path[PATH_MAX];\n"
"fd = open(\"/path/to/dir\", O_TMPFILE | O_RDWR,\n"
"                        S_IRUSR | S_IWUSR);\n"

#. type: Plain text
#: build/C/man2/open.2:831
#, no-wrap
msgid "/* File I/O on \\(aqfd\\(aq... */\n"
msgstr "/* \\(aqfd\\(aq に対するファイル I/O ... */\n"

#. type: Plain text
#: build/C/man2/open.2:833
#, no-wrap
msgid "linkat(fd, NULL, AT_FDCWD, \"/path/for/file\", AT_EMPTY_PATH);\n"
msgstr "linkat(fd, NULL, AT_FDCWD, \"/path/for/file\", AT_EMPTY_PATH);\n"

#. type: Plain text
#: build/C/man2/open.2:838
#, no-wrap
msgid ""
"/* If the caller doesn\\(aqt have the CAP_DAC_READ_SEARCH\n"
"   capability (needed to use AT_EMPTY_PATH with linkat(2)),\n"
"   and there is a proc(5) filesystem mounted, then the\n"
"   linkat(2) call above can be replaced with:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:843
#, no-wrap
msgid ""
"snprintf(path, PATH_MAX,  \"/proc/self/fd/%d\", fd);\n"
"linkat(AT_FDCWD, path, AT_FDCWD, \"/path/for/file\",\n"
"                        AT_SYMLINK_FOLLOW);\n"
"*/\n"
msgstr ""
"snprintf(path, PATH_MAX,  \"/proc/self/fd/%d\", fd);\n"
"linkat(AT_FDCWD, path, AT_FDCWD, \"/path/for/file\",\n"
"                        AT_SYMLINK_FOLLOW);\n"
"*/\n"

#. type: Plain text
#: build/C/man2/open.2:852
msgid ""
"In this case, the B<open>()  I<mode> argument determines the file permission "
"mode, as with B<O_CREAT>."
msgstr ""
"この場合、 B<open>() の I<mode> 引数は B<O_CREAT> と同様にファイルのアクセ"
"ス許可モードの決定に使われる。"

#. type: Plain text
#: build/C/man2/open.2:864
msgid ""
"Specifying B<O_EXCL> in conjunction with B<O_TMPFILE> prevents a temporary "
"file from being linked into the filesystem in the above manner.  (Note that "
"the meaning of B<O_EXCL> in this case is different from the meaning of "
"B<O_EXCL> otherwise.)"
msgstr ""
"B<O_TMPFILE> とともに B<O_EXCL> を指定すると、 一時ファイルに対して上記の方法"
"でファイルシステムへのリンクを行うことができなくなる (この場合の B<O_EXCL> の"
"意味は他の場合の B<O_EXCL> の意味とは異なる点に注意)。"

#.  Inspired by http://lwn.net/Articles/559147/
#. type: Plain text
#: build/C/man2/open.2:868
msgid "There are two main use cases for B<O_TMPFILE>:"
msgstr "B<O_TMPFILE> には主に二つの用途がある。"

#. type: Plain text
#: build/C/man2/open.2:877
msgid ""
"Improved B<tmpfile>(3)  functionality: race-free creation of temporary files "
"that (1) are automatically deleted when closed; (2) can never be reached via "
"any pathname; (3) are not subject to symlink attacks; and (4) do not require "
"the caller to devise unique names."
msgstr ""
"改善された B<tmpfile>(3) の機能: (1) クローズ時に自動的に削除される、 (2) パ"
"ス名では決して参照できない、 (3) シンボリックリンク攻撃ができない、 (4) 呼び"
"出し元が一意な名前を考える必要がない、 という特長を持つ競合のない一時ファイル"
"の作成。"

#. type: Plain text
#: build/C/man2/open.2:888
msgid ""
"Creating a file that is initially invisible, which is then populated with "
"data and adjusted to have appropriate filesystem attributes (B<fchown>(2), "
"B<fchmod>(2), B<fsetxattr>(2), etc.)  before being atomically linked into "
"the filesystem in a fully formed state (using B<linkat>(2)  as described "
"above)."
msgstr "最初は見えないファイルを作成し、 それからデータを書き込んだり、適切なファイルシステム属性を持つように調整したり (B<fchown>(2), B<fchmod>(2), B<fsetxattr>(2) など) した後、 準備が全て整った状態で (上述の B<linkat>(2) を使って) ファイルシステム内にアトミックにリンクを行う。"

#.  To check for support, grep for "tmpfile" in kernel sources
#.  commit 99b6436bc29e4f10e4388c27a3e4810191cc4788
#.  commit ab29743117f9f4c22ac44c13c1647fb24fb2bafe
#.  commit ef3b9af50bfa6a1f02cd7b3f5124b712b1ba3e3c
#.  commit 50732df02eefb39ab414ef655979c2c9b64ad21c
#. type: Plain text
#: build/C/man2/open.2:905
#, fuzzy
#| msgid ""
#| "B<O_TMPFILE> requires support by the underlying filesystem; only a subset "
#| "of Linux filesystems provide that support.  In the initial "
#| "implementation, support was provided in the ext2, ext3, ext4, UDF, Minix, "
#| "and shmem filesystems.  XFS support was added in Linux 3.15."
msgid ""
"B<O_TMPFILE> requires support by the underlying filesystem; only a subset of "
"Linux filesystems provide that support.  In the initial implementation, "
"support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem "
"filesystems.  Support for other filesystems has subsequently been added as "
"follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs "
"(Linux 4.9)"
msgstr ""
"B<O_TMPFILE> は、 裏で利用されるファイルシステムによるサポートが必要である。 "
"一部の Linux ファイルシステムだけがこの機能をサポートしている。 最初の実装で"
"は、 ext2, ext3, ext4, UDF, Minix, shmem ファイルシステムがサポートしてい"
"た。 XFS でのサポートが Linux 3.15 で追加された。"

#. type: TP
#: build/C/man2/open.2:905
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: build/C/man2/open.2:919
msgid ""
"If the file already exists and is a regular file and the access mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise, the effect of B<O_TRUNC> is unspecified."
msgstr ""
"ファイルが既に存在し、通常ファイルであり、 アクセスモードで書き込みが許可され"
"ている (つまり、 B<O_RDWR> または B<O_WRONLY> の) 場合、長さ 0 に切り詰め "
"(truncate) られる。 ファイルが FIFO または端末デバイスファイルの場合、 "
"B<O_TRUNC> フラグは無視される。 それ以外の場合、 B<O_TRUNC> の効果は未定義で"
"ある。"

#. type: SS
#: build/C/man2/open.2:919
#, no-wrap
msgid "creat()"
msgstr "creat()"

#. type: Plain text
#: build/C/man2/open.2:928
msgid ""
"A call to B<creat>()  is equivalent to calling B<open>()  with I<flags> "
"equal to B<O_CREAT|O_WRONLY|O_TRUNC>."
msgstr "B<creat>() の呼び出しは、 I<flags> に B<O_CREAT|O_WRONLY|O_TRUNC> を指定して B<open>() を呼び出すのと等価である。"

#. type: SS
#: build/C/man2/open.2:928
#, no-wrap
msgid "openat()"
msgstr "openat()"

#. type: Plain text
#: build/C/man2/open.2:934
msgid ""
"The B<openat>()  system call operates in exactly the same way as B<open>(), "
"except for the differences described here."
msgstr ""
"B<openat>() システムコールは B<open>() と全く同様に動作するが、以下で説明する"
"点が異なる。"

#. type: Plain text
#: build/C/man2/open.2:944
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<open>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<open>() に相対パス名を渡した場合のように、呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/open.2:956
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<open>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<open>() と同様に) I<pathname> は呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/open.2:963 build/C/man2/readlink.2:135
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""
"I<pathname> で指定されたパス名が絶対パスの場合、 I<dirfd> は無視される。"

#. type: SS
#: build/C/man2/open.2:963
#, no-wrap
msgid "openat2(2)"
msgstr "openat2(2)"

#. type: Plain text
#: build/C/man2/open.2:972
msgid ""
"The B<openat2>(2)  system call is an extension of B<openat>(), and provides "
"a superset of the features of B<openat>().  It is documented separately, in "
"B<openat2>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:982
#, fuzzy
#| msgid ""
#| "B<open>(), B<openat>(), and B<creat>()  return the new file descriptor, "
#| "or -1 if an error occurred (in which case, I<errno> is set appropriately)."
msgid ""
"B<open>(), B<openat>(), and B<creat>()  return the new file descriptor (a "
"nonnegative integer), or -1 if an error occurred (in which case, I<errno> is "
"set appropriately)."
msgstr ""
"B<open>(), B<openat>(), B<creat>() は新しいファイルディスクリプターを返す。 "
"エラーが発生した場合は -1 を返す (その場合は I<errno> が適切に設定される)。"

#. type: Plain text
#: build/C/man2/open.2:988
msgid ""
"B<open>(), B<openat>(), and B<creat>()  can fail with the following errors:"
msgstr "B<open>(), B<openat>(), B<creat>() は以下のエラーで失敗する。"

#. type: Plain text
#: build/C/man2/open.2:997
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""
"ファイルに対する要求されたアクセスが許されていないか、 I<pathname> のディレク"
"トリ部分の何れかのディレクトリに検索許可がなかった。 またはファイルが存在せ"
"ず、親ディレクトリへの書き込み許可がなかった。 (B<path_resolution>(7)  も参照"
"すること。)"

#.  commit 30aba6656f61ed44cba445a3c0d38b296fa9e8f5
#. type: Plain text
#: build/C/man2/open.2:1016
msgid ""
"Where B<O_CREAT> is specified, the I<protected_fifos> or "
"I<protected_regular> sysctl is enabled, the file already exists and is a "
"FIFO or regular file, the owner of the file is neither the current user nor "
"the owner of the containing directory, and the containing directory is both "
"world- or group-writable and sticky.  For details, see the descriptions of "
"I</proc/sys/fs/protected_fifos> and I</proc/sys/fs/protected_regular> in "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1016 build/C/man2/rename.2:328 build/C/man2/rmdir.2:55
#: build/C/man2/unlink.2:169
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/open.2:1024
msgid ""
"B<O_EXCL> was specified in I<flags> and I<pathname> refers to a block device "
"that is in use by the system (e.g., it is mounted)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1030
msgid ""
"Where B<O_CREAT> is specified, the file does not exist, and the user's quota "
"of disk blocks or inodes on the filesystem has been exhausted."
msgstr ""
"B<O_CREAT> が指定された場合で、そのファイルが存在せず、ディスクブロックか "
"inode がそのファイルシステムのユーザークォータに達していた。"

#. type: Plain text
#: build/C/man2/open.2:1036
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr "I<pathname> は既に存在し、 B<O_CREAT> と B<O_EXCL> が使用された。"

#. type: Plain text
#: build/C/man2/open.2:1040 build/C/man2/rmdir.2:67 build/C/man2/unlink.2:182
msgid "I<pathname> points outside your accessible address space."
msgstr "I<pathname> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/open.2:1040 build/C/man2/write.2:174
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/open.2:1044
msgid "See B<EOVERFLOW>."
msgstr "B<EOVERFLOW> 参照。"

#. type: TP
#: build/C/man2/open.2:1044 build/C/man2/read.2:131 build/C/man3/scanf.3:571
#: build/C/man3/tmpfile.3:63 build/C/man2/write.2:179
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/open.2:1051
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see "
"B<signal>(7)."
msgstr ""
"遅いデバイス (例えば FIFO、 B<fifo>(7)  参照) のオープンが完了するのを待って"
"停止している間に システムコールがシグナルハンドラーにより割り込まれた。 "
"B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/open.2:1059
msgid ""
"The filesystem does not support the B<O_DIRECT> flag.  See B<NOTES> for more "
"information."
msgstr ""
"ファイルシステムが B<O_DIRECT> フラグをサポートしていない。 詳細はB<注意>を参"
"照。"

#.  In particular, __O_TMPFILE instead of O_TMPFILE
#. type: Plain text
#: build/C/man2/open.2:1064
msgid "Invalid value in I<flags>."
msgstr "I<flags> に無効な値が入っている。"

#. type: Plain text
#: build/C/man2/open.2:1074
msgid ""
"B<O_TMPFILE> was specified in I<flags>, but neither B<O_WRONLY> nor "
"B<O_RDWR> was specified."
msgstr ""
"I<flags> に B<O_TMPFILE> が指定されたが、 B<O_WRONLY> も B<O_RDWR> も指定され"
"ていなかった。"

#. type: Plain text
#: build/C/man2/open.2:1083
msgid ""
"B<O_CREAT> was specified in I<flags> and the final component (\"basename\") "
"of the new file's I<pathname> is invalid (e.g., it contains characters not "
"permitted by the underlying filesystem)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1089
msgid ""
"The final component (\"basename\") of I<pathname> is invalid (e.g., it "
"contains characters not permitted by the underlying filesystem)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1089 build/C/man2/open.2:1098 build/C/man2/read.2:176
#: build/C/man2/rename.2:355 build/C/man2/unlink.2:185
#: build/C/man2/unlink.2:261
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/open.2:1098
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""
"I<pathname> はディレクトリを参照しており、書き込み要求が含まれていた (つまり "
"B<O_WRONLY> または B<O_RDWR> が設定されている)。"

#. type: Plain text
#: build/C/man2/open.2:1112
msgid ""
"I<pathname> refers to an existing directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""
"I<pathname> が存在するディレクトリを参照していて、 B<O_TMPFILE> および "
"B<O_WRONLY> と B<O_RDWR> の一方が I<flags> に指定されていたが、 このカーネル"
"バージョンでは B<O_TMPFILE> 機能が提供されていない。"

#. type: Plain text
#: build/C/man2/open.2:1116 build/C/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr "I<pathname> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/open.2:1125
msgid ""
"I<pathname> was a symbolic link, and I<flags> specified B<O_NOFOLLOW> but "
"not B<O_PATH>."
msgstr ""
"I<pathname> がシンボリックリンクで、 I<flags> に B<O_NOFOLLOW> が指定された"
"が、 B<O_PATH> が指定されていなかった。"

#. type: TP
#: build/C/man2/open.2:1125 build/C/man2/pipe.2:180 build/C/man3/tmpfile.3:67
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/open.2:1132
#, fuzzy
#| msgid ""
#| "The process already has the maximum number of files open (see the "
#| "description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"プロセスがオープンしているファイル数がすでに最大数に達している "
"(B<getrlimit>(2) の B<RLIMIT_NOFILE> の説明を参照)。"

#. type: Plain text
#: build/C/man2/open.2:1136 build/C/man2/rmdir.2:80 build/C/man2/unlink.2:197
msgid "I<pathname> was too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/open.2:1136 build/C/man2/pipe.2:183 build/C/man2/pipe.2:186
#: build/C/man3/tmpfile.3:70
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/open.2:1139 build/C/man2/pipe.2:186 build/C/man3/tmpfile.3:73
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされているファイルの総数がシステム全体の制限に達している。"

#. type: TP
#: build/C/man2/open.2:1139
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/open.2:1146
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""
"I<pathname> がデバイススペシャルファイルを参照しており、対応するデバイスが存"
"在しない。 (これは Linux カーネルのバグであり、この場合には B<ENXIO> が返され"
"るべきである)"

#. type: Plain text
#: build/C/man2/open.2:1150
#, fuzzy
#| msgid "The named file does not exist."
msgid "B<O_CREAT> is not set and the named file does not exist."
msgstr "その名前のファイルが存在しない。"

#. type: Plain text
#: build/C/man2/open.2:1155 build/C/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> の中のディレクトリ部分が存在しないか、壊れた (dangling)  シンボ"
"リックリンク (symbolic link) である。"

#. type: Plain text
#: build/C/man2/open.2:1169
msgid ""
"I<pathname> refers to a nonexistent directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""
"I<pathname> が存在しないディレクトリを参照していて、 B<O_TMPFILE> および "
"B<O_WRONLY> と B<O_RDWR> の一方が I<flags> に指定されていたが、 このカーネル"
"バージョンでは B<O_TMPFILE> 機能が提供されていない。"

#. type: Plain text
#: build/C/man2/open.2:1176
msgid ""
"The named file is a FIFO, but memory for the FIFO buffer can't be allocated "
"because the per-user hard limit on memory allocation for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1185
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""
"I<pathname> を作成する必要があるが、 I<pathname> を含んでいるデバイスに新しい"
"ファイルのための空き容量がない。"

#. type: Plain text
#: build/C/man2/open.2:1192
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""
"I<pathname> に含まれるディレクトリ部分のどれかが実際にはディレクトリでない。 "
"または B<O_DIRECTORY> が指定されており、 I<pathname> がディレクトリでない。"

#. type: Plain text
#: build/C/man2/open.2:1197
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO, and no process "
"has the FIFO open for reading."
msgstr "B<O_NONBLOCK> | B<O_WRONLY> が設定されており、指定したファイルが FIFO で そのファイルを読み込み用でオープンしている FIFO が存在しない。"

#. type: Plain text
#: build/C/man2/open.2:1200
msgid "The file is a device special file and no corresponding device exists."
msgstr "ファイルがデバイススペシャルファイルで、対応するデバイスが存在しない。"

#. type: Plain text
#: build/C/man2/open.2:1203
msgid "The file is a UNIX domain socket."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1203 build/C/man2/open_by_handle_at.2:332
#: build/C/man2/readv.2:313
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/open.2:1209
msgid "The filesystem containing I<pathname> does not support B<O_TMPFILE>."
msgstr ""
"I<pathname> を含んでいるファイルシステムが B<O_TMPFILE> をサポートしていな"
"い。"

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
#: build/C/man2/open.2:1229
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds "
"I<(1E<lt>E<lt>31)-1> bytes; see also B<O_LARGEFILE> above.  This is the "
"error specified by POSIX.1; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr "I<pathname> が参照しているのが、大き過ぎてオープンできない通常のファイルである。 通常、このエラーが発生するは、32 ビットプラットフォーム上で I<-D_FILE_OFFSET_BITS=64> を指定せずにコンパイルされたアプリケーションが、ファイルサイズが I<(1E<lt>31)-1> バイトを超えるファイルを開こうとした場合である。 上記の B<O_LARGEFILE> も参照。 これは POSIX.1 で規定されているエラーである。 2.6.24 より前のカーネルでは、Linux はこの場合にエラー B<EFBIG> を返していた。"

#.  Strictly speaking, it's the filesystem UID... (MTK)
#. type: Plain text
#: build/C/man2/open.2:1236
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged."
msgstr "B<O_NOATIME> フラグが指定されたが、呼び出し元の実効ユーザー ID が ファイルの所有者と一致せず、かつ呼び出し元に特権がない。"

#. type: Plain text
#: build/C/man2/open.2:1240 build/C/man2/write.2:231
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr "操作が file seal により禁止されている。 B<fcntl>(2)  参照。"

#. type: Plain text
#: build/C/man2/open.2:1245
msgid ""
"I<pathname> refers to a file on a read-only filesystem and write access was "
"requested."
msgstr ""
"I<pathname> が読み込み専用のファイルシステム上のファイルを参照しており、 書き"
"込みアクセスが要求された。"

#. type: TP
#: build/C/man2/open.2:1245 build/C/man2/open.2:1250 build/C/man2/open.2:1256
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/open.2:1250
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""
"I<pathname> が現在実行中の実行イメージを参照しており、書き込みが要求された。"

#. type: Plain text
#: build/C/man2/open.2:1256
#, fuzzy
#| msgid ""
#| "I<pathname> refers to a file on a read-only filesystem and write access "
#| "was requested."
msgid ""
"I<pathname> refers to a file that is currently in use as a swap file, and "
"the B<O_TRUNC> flag was specified."
msgstr ""
"I<pathname> が読み込み専用のファイルシステム上のファイルを参照しており、 書き"
"込みアクセスが要求された。"

#. type: Plain text
#: build/C/man2/open.2:1261
#, fuzzy
#| msgid ""
#| "I<pathname> refers to an executable image which is currently being "
#| "executed and write access was requested."
msgid ""
"I<pathname> refers to a file that is currently being read by the kernel (e."
"g., for module/firmware loading), and write access was requested."
msgstr ""
"I<pathname> が現在実行中の実行イメージを参照しており、書き込みが要求された。"

#. type: TP
#: build/C/man2/open.2:1261
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: build/C/man2/open.2:1268
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""
"B<O_NONBLOCK> フラグが指定されたが、そのファイルには矛盾するリースが設定され"
"ていた (B<fcntl>(2)  参照)。"

#. type: Plain text
#: build/C/man2/open.2:1271
msgid "The following additional errors can occur for B<openat>():"
msgstr "B<openat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/open.2:1275 build/C/man2/readlink.2:212
#: build/C/man2/unlink.2:257
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> が有効なファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/open.2:1281
msgid ""
"I<pathname> is a relative pathname and I<dirfd> is a file descriptor "
"referring to a file other than a directory."
msgstr ""
"I<pathname> が相対パス名で、 I<dirfd> がディレクトリ以外のファイルを参照して"
"いるファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/open.2:1285
msgid ""
"B<openat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<openat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサポー"
"トはバージョン 2.4 で glibc に追加された。"

#. type: Plain text
#: build/C/man2/open.2:1289
msgid "B<open>(), B<creat>()  SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<open>(), B<creat>()  SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/open.2:1292
msgid "B<openat>(): POSIX.1-2008."
msgstr "B<openat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/open.2:1295
msgid "B<openat2>(2)  is Linux-specific."
msgstr "B<openat2>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/open.2:1306
msgid ""
"The B<O_DIRECT>, B<O_NOATIME>, B<O_PATH>, and B<O_TMPFILE> flags are Linux-"
"specific.  One must define B<_GNU_SOURCE> to obtain their definitions."
msgstr ""
"フラグ B<O_DIRECT>, B<O_NOATIME>, B<O_PATH>, B<O_TMPFILE> は Linux 特有のもの"
"である。 これらのフラグの定義を得るためには B<_GNU_SOURCE> を定義しなければな"
"らない。"

#. type: Plain text
#: build/C/man2/open.2:1321
msgid ""
"The B<O_CLOEXEC>, B<O_DIRECTORY>, and B<O_NOFOLLOW> flags are not specified "
"in POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12, one "
"can obtain their definitions by defining either B<_POSIX_C_SOURCE> with a "
"value greater than or equal to 200809L or B<_XOPEN_SOURCE> with a value "
"greater than or equal to 700.  In glibc 2.11 and earlier, one obtains the "
"definitions by defining B<_GNU_SOURCE>."
msgstr ""
"フラグ B<O_CLOEXEC>, B<O_DIRECTORY>, B<O_NOFOLLOW> は POSIX.1-2001 では規定さ"
"れていないが、 POSIX.1-2008 では規定されている。 glibc 2.12 以降では、これら"
"の定義を得るには、 B<_POSIX_C_SOURCE> を 200809L 以上の値で定義するか、 "
"B<_XOPEN_SOURCE> を 700 以上の値で定義する。 glibc 2.11 以前では、 これらの定"
"義を得るには B<_GNU_SOURCE> を定義する。"

#. type: Plain text
#: build/C/man2/open.2:1332
msgid ""
"As noted in B<feature_test_macros>(7), feature test macros such as "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, and B<_GNU_SOURCE> must be defined "
"before including I<any> header files."
msgstr ""
"B<feature_test_macros>(7) に注意書きがあるように、 B<_POSIX_C_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_GNU_SOURCE> などの機能検査マクロはI<どの>ヘッダーファイ"
"ルをインクルードするより前に定義しなければならない。"

#. type: Plain text
#: build/C/man2/open.2:1341
#, fuzzy
#| msgid ""
#| "Under Linux, the B<O_NONBLOCK> flag indicates that one wants to open but "
#| "does not necessarily have the intention to read or write.  This is "
#| "typically used to open devices in order to get a file descriptor for use "
#| "with B<ioctl>(2)."
msgid ""
"Under Linux, the B<O_NONBLOCK> flag is sometimes used in cases where one "
"wants to open but does not necessarily have the intention to read or write.  "
"For example, this may be used to open a device in order to get a file "
"descriptor for use with B<ioctl>(2)."
msgstr ""
"Linux では、 B<O_NONBLOCK> フラグは、 open を実行したいが read または write "
"を実行する意図は 必ずしもないことを意味する。 これは B<ioctl>(2)  のための"
"ファイルディスクリプターを取得するために、 デバイスをオープンするときによく用"
"いられる。"

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
#: build/C/man2/open.2:1352
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""
"B<O_RDONLY | O_TRUNC> の影響は未定義であり、その動作は実装によって異なる。 多"
"くのシステムではファイルは実際に切り詰められる。"

#. type: Plain text
#: build/C/man2/open.2:1360
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""
"B<open>()  はスペシャルファイルをオープンすることができるが、 B<creat>()  で"
"スペシャルファイルを作成できない点に注意すること。 代わりに B<mknod>(2)  を使"
"用する。"

#. type: Plain text
#: build/C/man2/open.2:1383
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"I<st_ctime> and I<st_mtime> fields are set to the current time."
msgstr ""
"ファイルが新しく作成されると、 ファイルの I<st_atime>, I<st_ctime>, "
"I<st_mtime> フィールド (それぞれ最終アクセス時刻、最終状態変更時刻、最終修正"
"時刻である。 B<stat>(2)  参照) が現在時刻に設定される。 さらに親ディレクトリ"
"の I<st_ctime> と I<st_mtime> も現在時刻に設定される。 それ以外の場合で、"
"O_TRUNC フラグでファイルが修正されたときは、 ファイルの I<st_ctime> と "
"I<st_mtime> フィールドが現在時刻に設定される。"

#. type: Plain text
#: build/C/man2/open.2:1394
msgid ""
"The files in the I</proc/[pid]/fd> directory show the open file descriptors "
"of the process with the PID I<pid>.  The files in the I</proc/[pid]/fdinfo> "
"directory show even more information about these file descriptors.  See "
"B<proc>(5)  for further details of both of these directories."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1404
msgid ""
"The Linux header file B<E<lt>asm/fcntl.hE<gt>> doesn't define B<O_ASYNC>; "
"the (BSD-derived)  B<FASYNC> synonym is defined instead."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1404
#, no-wrap
msgid "Open file descriptions"
msgstr "オープンファイル記述"

#. type: Plain text
#: build/C/man2/open.2:1412
msgid ""
"The term open file description is the one used by POSIX to refer to the "
"entries in the system-wide table of open files.  In other contexts, this "
"object is variously also called an \"open file object\", a \"file handle\", "
"an \"open file table entry\", or\\(emin kernel-developer parlance\\(ema "
"I<struct file>."
msgstr ""
"オープンファイル記述という用語は POSIX で使用されている用語で、オープンされて"
"いるファイルのシステム共通のテーブルのエントリーを参照するものである。 別の文"
"脈では、このオブジェクトはいろいろな呼び方があり、 「オープンファイルオブジェ"
"クト」、「ファイルハンドル」、「オープンファイルテーブルエントリー」、 カーネ"
"ル開発者の用語では I<struct file> などと呼ばれる。"

#. type: Plain text
#: build/C/man2/open.2:1425
msgid ""
"When a file descriptor is duplicated (using B<dup>(2)  or similar), the "
"duplicate refers to the same open file description as the original file "
"descriptor, and the two file descriptors consequently share the file offset "
"and file status flags.  Such sharing can also occur between processes: a "
"child process created via B<fork>(2)  inherits duplicates of its parent's "
"file descriptors, and those duplicates refer to the same open file "
"descriptions."
msgstr ""
"ファイルディスクリプターが (B<dup>(2) や同様のシステムコールを使って) 複製さ"
"れる際に、 複製されたファイルディスクリプターは元のファイルディスクリプターと"
"同じオープンファイル記述を参照する。 結果として 2 つのファイルディスクリプ"
"ターはファイルオフセットとファイル状態フラグを共有する。 このような共有はプロ"
"セス間でも起こり得る。 B<fork>(2) で作成された子プロセスは親プロセスのファイ"
"ルディスクリプターの複製を継承し、これらの複製は同じオープンファイル記述を参"
"照する。"

#. type: Plain text
#: build/C/man2/open.2:1431
msgid ""
"Each B<open>()  of a file creates a new open file description; thus, there "
"may be multiple open file descriptions corresponding to a file inode."
msgstr "1 つのファイルに対して B<open>() を行う毎に、新しいオープンファイル記述が作成される。 したがって、 1 つのファイル inode に対して複数のオープンファイル記述が存在することがありえる。"

#. type: Plain text
#: build/C/man2/open.2:1440
msgid ""
"On Linux, one can use the B<kcmp>(2)  B<KCMP_FILE> operation to test whether "
"two file descriptors (in the same process or in two different processes)  "
"refer to the same open file description."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1440
#, no-wrap
msgid "Synchronized I/O"
msgstr "同期 I/O"

#. type: Plain text
#: build/C/man2/open.2:1455
msgid ""
"The POSIX.1-2008 \"synchronized I/O\" option specifies different variants of "
"synchronized I/O, and specifies the B<open>()  flags B<O_SYNC>, B<O_DSYNC>, "
"and B<O_RSYNC> for controlling the behavior.  Regardless of whether an "
"implementation supports this option, it must at least support the use of "
"B<O_SYNC> for regular files."
msgstr ""
"POSIX.1-2008 の「同期 I/O」の選択肢として複数種類が規定されており、 動作を制"
"御するために B<open>() フラグとして B<O_SYNC>, B<O_DSYNC>, B<O_RSYNC> が規定"
"されている。 この選択肢を実装がサポートしているかに関わらず、 各実装では少な"
"くとも通常のファイルに対して B<O_SYNC> が利用できなければならない。"

#. type: Plain text
#: build/C/man2/open.2:1470
#, fuzzy
#| msgid ""
#| "Linux implements B<O_SYNC> and B<O_DSYNC>, but not B<O_RSYNC>.  (Somewhat "
#| "incorrectly, glibc defines B<O_RSYNC> to have the same value as "
#| "B<O_SYNC>.)"
msgid ""
"Linux implements B<O_SYNC> and B<O_DSYNC>, but not B<O_RSYNC>.  Somewhat "
"incorrectly, glibc defines B<O_RSYNC> to have the same value as B<O_SYNC>.  "
"(B<O_RSYNC> is defined in the Linux header file I<E<lt>asm/fcntl.hE<gt>> on "
"HP PA-RISC, but it is not used.)"
msgstr ""
"Linux は B<O_SYNC> と B<O_DSYNC> を実装しているが、 B<O_RSYNC> は実装していな"
"い (少し間違っているのだが、 glibc では B<O_RSYNC> が B<O_SYNC> と同じ値で定"
"義されている)。"

#. type: Plain text
#: build/C/man2/open.2:1488
msgid ""
"B<O_SYNC> provides synchronized I/O I<file> integrity completion, meaning "
"write operations will flush data and all associated metadata to the "
"underlying hardware.  B<O_DSYNC> provides synchronized I/O I<data> integrity "
"completion, meaning write operations will flush data to the underlying "
"hardware, but will only flush metadata updates that are required to allow a "
"subsequent read operation to complete successfully.  Data integrity "
"completion can reduce the number of disk operations that are required for "
"applications that don't need the guarantees of file integrity completion."
msgstr ""
"B<O_SYNC> は、 同期 I/O でのI<ファイル>完全性完了を提供する。 つまり、 書き込"
"み操作はデータとすべての関連メタデータを裏で利用されているハードウェアにフ"
"ラッシュすることを意味する。 B<O_DSYNC> は、 同期 I/O でのI<データ>完全性完了"
"を提供する。 つまり、 書き込み操作はデータを裏で利用されているハードウェアに"
"フラッシュするが、 それ以降の読み出し操作が正常に完了するのに必要なメタデータ"
"の更新のみをフラッシュする。 データ完全性完了は、 ファイル完全性完了を必要と"
"しないアプリケーションで、 ディスク操作の数を減らすことができる。"

#. type: Plain text
#: build/C/man2/open.2:1505
msgid ""
"To understand the difference between the two types of completion, consider "
"two pieces of file metadata: the file last modification timestamp "
"(I<st_mtime>)  and the file length.  All write operations will update the "
"last file modification timestamp, but only writes that add data to the end "
"of the file will change the file length.  The last modification timestamp is "
"not needed to ensure that a read completes successfully, but the file length "
"is.  Thus, B<O_DSYNC> would only guarantee to flush updates to the file "
"length metadata (whereas B<O_SYNC> would also always flush the last "
"modification timestamp metadata)."
msgstr ""
"2 種類の完了の違いを理解するために、 ファイルメタデータの 2 つの要素、 ファイ"
"ルの最終修正時刻 (I<st_mtime>) とファイル長、を考える。 すべての書き込み操作"
"は最終修正時刻を更新するが、 ファイルの末尾にデータを追加する書き込み操作のみ"
"がファイル長を変更する。 最終修正時刻は、 読み出しが正常に完了するのに必要で"
"はないが、 ファイル長は必要である。 したがって、 B<O_DSYNC> はファイル長のメ"
"タデータの更新がフラッシュされることだけを保証する (これに対して B<O_SYNC> で"
"は最終修正時刻のメタデータも常にフラッシュされる)。"

#. type: Plain text
#: build/C/man2/open.2:1517
msgid ""
"Before Linux 2.6.33, Linux implemented only the B<O_SYNC> flag for "
"B<open>().  However, when that flag was specified, most filesystems actually "
"provided the equivalent of synchronized I/O I<data> integrity completion (i."
"e., B<O_SYNC> was actually implemented as the equivalent of B<O_DSYNC>)."
msgstr ""
"Linux 2.6.33 より前では、 Linux は B<open>() では B<O_SYNC> フラグのみを実装"
"していた。 しかしながら、 このフラグが指定された場合、 ほとんどのファイルシス"
"テムで提供されていたのは実際には同期 I/O でのI<データ>完全性完了と等価なもの"
"であった (つまり、 B<O_SYNC> は実際には B<O_DSYNC> と等価なものとして実装され"
"ていた)。"

#. type: Plain text
#: build/C/man2/open.2:1535
msgid ""
"Since Linux 2.6.33, proper B<O_SYNC> support is provided.  However, to "
"ensure backward binary compatibility, B<O_DSYNC> was defined with the same "
"value as the historical B<O_SYNC>, and B<O_SYNC> was defined as a new (two-"
"bit) flag value that includes the B<O_DSYNC> flag value.  This ensures that "
"applications compiled against new headers get at least B<O_DSYNC> semantics "
"on pre-2.6.33 kernels."
msgstr "Linux 2.6.33 以降では、 正しい B<O_SYNC> のサポートが提供されている。しかしながら、バイナリレベルの後方互換性を保証するため、 B<O_DSYNC> は以前の B<O_SYNC> と同じ値で定義されており、 B<O_SYNC> は B<O_DSYNC> フラグの値を含む新しい (2 ビットの) フラグ値として定義されている。これにより、新しいヘッダーを使ってコンパイルされたアプリケーションで、 2.6.33 より前のカーネルで少なくとも B<O_DSYNC> の動作は同じになることが保証される。"

#. type: SS
#: build/C/man2/open.2:1535 build/C/man2/readv.2:358
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/open.2:1546
msgid ""
"Since version 2.26, the glibc wrapper function for B<open>()  employs the "
"B<openat>()  system call, rather than the kernel's B<open>()  system call.  "
"For certain architectures, this is also true in glibc versions before 2.26."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1546
#, no-wrap
msgid "NFS"
msgstr "NFS"

#. type: Plain text
#: build/C/man2/open.2:1550
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""
"NFS を実現しているプロトコルには多くの不備があり、特に B<O_SYNC> と "
"B<O_NDELAY> に影響する。"

#. type: Plain text
#: build/C/man2/open.2:1565
msgid ""
"On NFS filesystems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""
"UID マッピングを使用している NFS ファイルシステムでは、 B<open>()  がファイル"
"ディスクリプターを返した場合でも B<read>(2)  が B<EACCES> で拒否される場合が"
"ある。 これはクライアントがアクセス許可のチェックを行って B<open>()  を実行す"
"るが、読み込みや書き込みの際には サーバーで UID マッピングが行われるためであ"
"る。"

#. type: SS
#: build/C/man2/open.2:1565
#, no-wrap
msgid "FIFOs"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1573
msgid ""
"Opening the read or write end of a FIFO blocks until the other end is also "
"opened (by another process or thread).  See B<fifo>(7)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1573
#, no-wrap
msgid "File access mode"
msgstr "ファイルアクセスモード"

#. type: Plain text
#: build/C/man2/open.2:1588
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR> do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>."
msgstr ""
"「アクセスモード」の値 B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> は、 I<flags> に指"
"定できる他の値と違い、個々のビットを指定するものではなく、 これらの値は "
"I<flags> の下位 2 ビットを定義する。 B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> はそ"
"れぞれ 0, 1, 2 に定義されている。 言い換えると、 B<O_RDONLY | O_WRONLY> の組"
"み合わせは論理的に間違いであり、確かに B<O_RDWR> と同じ意味ではない。"

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
#: build/C/man2/open.2:1605
msgid ""
"Linux reserves the special, nonstandard access mode 3 (binary 11) in "
"I<flags> to mean: check for read and write permission on the file and return "
"a file descriptor that can't be used for reading or writing.  This "
"nonstandard access mode is used by some Linux drivers to return a file "
"descriptor that is to be used only for device-specific B<ioctl>(2)  "
"operations."
msgstr "Linux では、特別な、非標準なアクセスモードとして 3 (バイナリでは 11) が 予約されており I<flags> に指定できる。 このアクセスモードを指定すると、ファイルの読み出し/書き込み許可をチェックし、 読み出しにも書き込みにも使用できないファイルディスクリプターを返す。 この非標準のアクセスモードはいくつかの Linux ドライバで、デバイス固有の B<ioctl>(2) 操作にのみ使用されるファイルディスクリプターを返すために使われている。"

#. type: SS
#: build/C/man2/open.2:1605
#, no-wrap
msgid "Rationale for openat() and other directory file descriptor APIs"
msgstr "openat() や他のディレクトリファイルディスクリプター API の基本原理"

#. type: Plain text
#: build/C/man2/open.2:1638
#, fuzzy
#| msgid ""
#| "B<openat>()  and the other system calls and library functions that take a "
#| "directory file descriptor argument (i.e., B<execveat>(2), "
#| "B<faccessat>(2), B<fanotify_mark>(2), B<fchmodat>(2), B<fchownat>(2), "
#| "B<fstatat>(2), B<futimesat>(2), B<linkat>(2), B<mkdirat>(2), "
#| "B<mknodat>(2), B<name_to_handle_at>(2), B<readlinkat>(2), B<renameat>(2), "
#| "B<symlinkat>(2), B<unlinkat>(2), B<utimensat>(2)  B<mkfifoat>(3), and "
#| "B<scandirat>(3))  are supported for two reasons.  Here, the explanation "
#| "is in terms of the B<openat>()  call, but the rationale is analogous for "
#| "the other interfaces."
msgid ""
"B<openat>()  and the other system calls and library functions that take a "
"directory file descriptor argument (i.e., B<execveat>(2), B<faccessat>(2), "
"B<fanotify_mark>(2), B<fchmodat>(2), B<fchownat>(2), B<fspick>(2), "
"B<fstatat>(2), B<futimesat>(2), B<linkat>(2), B<mkdirat>(2), "
"B<move_mount>(2), B<mknodat>(2), B<name_to_handle_at>(2), B<open_tree>(2), "
"B<openat2>(2), B<readlinkat>(2), B<renameat>(2), B<statx>(2), "
"B<symlinkat>(2), B<unlinkat>(2), B<utimensat>(2), B<mkfifoat>(3), and "
"B<scandirat>(3))  address two problems with the older interfaces that "
"preceded them.  Here, the explanation is in terms of the B<openat>()  call, "
"but the rationale is analogous for the other interfaces."
msgstr ""
"B<openat>() やディレクトリファイルディスクリプターを引数を取る他のシステム"
"コールやライブラリ関数 (B<execveat>(2), B<faccessat>(2), "
"B<fanotify_mark>(2), B<fchmodat>(2), B<fchownat>(2), B<fstatat>(2), "
"B<futimesat>(2), B<linkat>(2), B<mkdirat>(2), B<mknodat>(2), "
"B<name_to_handle_at>(2), B<readlinkat>(2), B<renameat>(2), B<symlinkat>(2), "
"B<unlinkat>(2), B<utimensat>(2) B<mkfifoat>(3), B<scandirat>(3)) は二つの理由"
"から用意されている。 ここでは、 B<openat> コールに関して説明するが、この基本"
"原理は他のインターフェースでも同じである。"

#. type: Plain text
#: build/C/man2/open.2:1672
#, fuzzy
#| msgid ""
#| "First, B<openat>()  allows an application to avoid race conditions that "
#| "could occur when using B<open>()  to open files in directories other than "
#| "the current working directory.  These race conditions result from the "
#| "fact that some component of the directory prefix given to B<open>()  "
#| "could be changed in parallel with the call to B<open>().  Suppose, for "
#| "example, that we wish to create the file I<path/to/xxx.dep> if the file "
#| "I<path/to/xxx> exists.  The problem is that between the existence check "
#| "and the file creation step, I<path> or I<to> (which might be symbolic "
#| "links)  could be modified to point to a different location.  Such races "
#| "can be avoided by opening a file descriptor for the target directory, and "
#| "then specifying that file descriptor as the I<dirfd> argument of (say)  "
#| "B<fstatat>(2)  and B<openat>()."
msgid ""
"First, B<openat>()  allows an application to avoid race conditions that "
"could occur when using B<open>()  to open files in directories other than "
"the current working directory.  These race conditions result from the fact "
"that some component of the directory prefix given to B<open>()  could be "
"changed in parallel with the call to B<open>().  Suppose, for example, that "
"we wish to create the file I<dir1/dir2/xxx.dep> if the file I<dir1/dir2/xxx> "
"exists.  The problem is that between the existence check and the file-"
"creation step, I<dir1> or I<dir2> (which might be symbolic links)  could be "
"modified to point to a different location.  Such races can be avoided by "
"opening a file descriptor for the target directory, and then specifying that "
"file descriptor as the I<dirfd> argument of (say)  B<fstatat>(2)  and "
"B<openat>().  The use of the I<dirfd> file descriptor also has other "
"benefits:"
msgstr ""
"最初の理由として、 B<openat>() を使うと、 アプリケーションは、 カレントワーキ"
"ングディレクトリ以外のディレクトリで B<open>() を使ってファイルをオープンする"
"際に起こり得る競合条件を避けることができる。 これらの競合条件は、 B<open>() "
"に渡されたディレクトリプレフィックスの構成要素が B<open>() の呼び出しと並行し"
"て変化する可能性があるという点に由来している。 例えば、ファイル I<path/to/"
"xxx> が存在する場合にファイル I<path/to/xxx.dep> を作成したいとする。 問題"
"は、存在確認とファイル作成の間に、 I<path> や I<to> (シンボリックリンクでもよ"
"い) が別の場所を指すように変更されることがあるということだ。 このような競合条"
"件は、 対象のディレクトリに対するファイルディスクリプターをオープンし、 それ"
"から B<fstatat>(2) や B<openat>() の I<dirfd> 引数としてそのファイルディス"
"クリプターを指定することで、 避けることができる。"

#. type: Plain text
#: build/C/man2/open.2:1675
msgid ""
"the file descriptor is a stable reference to the directory, even if the "
"directory is renamed; and"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1679
msgid ""
"the open file descriptor prevents the underlying filesystem from being "
"dismounted, just as when a process has a current working directory on a "
"filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1688
msgid ""
"Second, B<openat>()  allows the implementation of a per-thread \"current "
"working directory\", via file descriptor(s) maintained by the application.  "
"(This functionality can also be obtained by tricks based on the use of I</"
"proc/self/fd/>dirfd, but less efficiently.)"
msgstr ""
"二つ目として、 B<openat>() を使うと、アプリケーションが管理するファイルディス"
"クリプターにより、 スレッド単位の「カレントワーキングディレクトリ」を実装する"
"ことができる (この機能は、 I</proc/self/fd/dirfd> を使った方法でも実現するこ"
"とができるが、 効率の面で落とる)。"

#. type: Plain text
#: build/C/man2/open.2:1704
msgid ""
"The I<dirfd> argument for these APIs can be obtained by using B<open>()  or "
"B<openat>()  to open a directory (with either the B<O_RDONLY> or the "
"B<O_PATH> flag).  Alternatively, such a file descriptor can be obtained by "
"applying B<dirfd>(3)  to a directory stream created using B<opendir>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1718
msgid ""
"When these APIs are given a I<dirfd> argument of B<AT_FDCWD> or the "
"specified pathname is absolute, then they handle their pathname argument in "
"the same way as the corresponding conventional APIs.  However, in this case, "
"several of the APIs have a I<flags> argument that provides access to "
"functionality that is not available with the corresponding conventional APIs."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1718
#, no-wrap
msgid "O_DIRECT"
msgstr "O_DIRECT"

#. type: Plain text
#: build/C/man2/open.2:1734
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of user-space buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by filesystem and kernel version and might be "
"absent entirely.  However there is currently no filesystem-independent "
"interface for an application to discover these restrictions for a given file "
"or filesystem.  Some filesystems provide their own interfaces for doing so, "
"for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""
"B<O_DIRECT> フラグを使用する場合、ユーザー空間バッファーの長さやアドレス、 I/"
"O のファイルオフセットに関してアラインメントの制限が課されることがある。 "
"Linux では、アラインメントの制限はファイルシステムやカーネルのバージョンに "
"よって異なり、全く制限が存在しない場合もある。 しかしながら、現在のところ、指"
"定されたファイルやファイルシステムに対して こうした制限があるかを見つけるため"
"の、アプリケーション向けのインターフェースで ファイルシステム非依存のものは存"
"在しない。 いくつかのファイルシステムでは、制限を確認するための独自のインター"
"フェースが 提供されている。例えば、 B<xfsctl>(3)  の B<XFS_IOC_DIOINFO> 命令"
"である。"

#. type: Plain text
#: build/C/man2/open.2:1744
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the "
"filesystem.  Since Linux 2.6.0, alignment to the logical block size of the "
"underlying storage (typically 512 bytes) suffices.  The logical block size "
"can be determined using the B<ioctl>(2)  B<BLKSSZGET> operation or from the "
"shell using the command:"
msgstr ""
"Linux 2.4 では、転送サイズ、 ユーザーバッファーのアライメント、ファイルオフ"
"セットは、 ファイルシステムの論理ブロックサイズの倍数でなければならない。 "
"Linux 2.6.0 以降では、 内部で使われるストレージの論理ブロックサイズのアライメ"
"ント (通常は 512 バイト) で十分である。 論理ブロックサイズは B<ioctl>(2) "
"B<BLKSSZGET> 操作や以下のシェルコマンドから知ることができる。"

#. type: Plain text
#: build/C/man2/open.2:1748
#, no-wrap
msgid "blockdev --getss\n"
msgstr "blockdev --getss\n"

#. type: Plain text
#: build/C/man2/open.2:1784
msgid ""
"B<O_DIRECT> I/Os should never be run concurrently with the B<fork>(2)  "
"system call, if the memory buffer is a private mapping (i.e., any mapping "
"created with the B<mmap>(2)  B<MAP_PRIVATE> flag; this includes memory "
"allocated on the heap and statically allocated buffers).  Any such I/Os, "
"whether submitted via an asynchronous I/O interface or from another thread "
"in the process, should be completed before B<fork>(2)  is called.  Failure "
"to do so can result in data corruption and undefined behavior in parent and "
"child processes.  This restriction does not apply when the memory buffer for "
"the B<O_DIRECT> I/Os was created using B<shmat>(2)  or B<mmap>(2)  with the "
"B<MAP_SHARED> flag.  Nor does this restriction apply when the memory buffer "
"has been advised as B<MADV_DONTFORK> with B<madvise>(2), ensuring that it "
"will not be available to the child after B<fork>(2)."
msgstr ""
"メモリーバッファーがプライベートマッピング (B<mmap>(2) の B<MAP_PRIVATE>\n"
"フラグで作成されたマッピング) の場合には、B<O_DIRECT> I/O は\n"
"B<fork>(2) システムコールと同時に決して実行すべきではない \n"
"(プライベートマッピングには、ヒープ領域に割り当てられたメモリーや静的に\n"
"割り当てたバッファーも含まれる)。非同期 I/O インターフェース (AIO) 経由\n"
"やプロセス内の他のスレッドから発行された、このような I/O は、\n"
"B<fork>(2) が呼び出される前に完了されるべきである。\n"
"そうしなかった場合、データ破壊や、親プロセスや子プロセスでの予期しない\n"
"動作が起こる可能性がある。\n"
"B<O_DIRECT> I/O 用のメモリーバッファーが B<shmat>(2) やB<MAP_SHARED> フラグ\n"
"付きの B<mmap>(2) で作成された場合には、この制限はあてはまらない。\n"
"B<madvise>(2) でメモリーバッファーにアドバイス B<MADV_DONTFORK> が設定され\n"
"ている場合にも、この制限はあてはまらない(B<MADV_DONTFORK> はそのメモリー\n"
"バッファーが B<fork>(2) 後に子プロセスからは利用できないことを保証するも\n"
"のである)。"

#. type: Plain text
#: build/C/man2/open.2:1794
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""
"B<O_DIRECT> フラグは SGI IRIX で導入された。SGI IRIX にも Linux 2.4 と同様の "
"(ユーザーバッファーの) アラインメントの制限がある。 また、IRIX には適切な配置"
"とサイズを取得するための B<fcntl>(2)  コールがある。 FreeBSD 4.x も同じ名前の"
"フラグを導入したが、アラインメントの制限はない。"

#. type: Plain text
#: build/C/man2/open.2:1803
#, fuzzy
#| msgid ""
#| "B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  "
#| "Older Linux kernels simply ignore this flag.  Some filesystems may not "
#| "implement the flag and B<open>()  will fail with B<EINVAL> if it is used."
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some filesystems may not implement "
"the flag, in which case B<open>()  fails with the error B<EINVAL> if it is "
"used."
msgstr ""
"B<O_DIRECT> が Linux でサポートされたのは、カーネルバージョン 2.4.10 であ"
"る。 古い Linux カーネルは、このフラグを単に無視する。 B<O_DIRECT> フラグをサ"
"ポートしていないファイルシステムもあり、その場合は、 B<O_DIRECT> を使用する"
"と B<open>()  は B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/open.2:1814
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the filesystem correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""
"アプリケーションは、同じファイル、 特に同じファイルの重複するバイト領域に対し"
"て、 B<O_DIRECT> と通常の I/O を混ぜて使うのは避けるべきである。 ファイルシス"
"テムがこのような状況において一貫性の問題を正しく 扱うことができる場合であって"
"も、全体の I/O スループットは どちらか一方を使用するときと比べて低速になるで"
"あろう。 同様に、アプリケーションは、同じファイルに対して B<mmap>(2)  と直接 "
"I/O (B<O_DIRECT>)  を混ぜて使うのも避けるべきである。"

#. type: Plain text
#: build/C/man2/open.2:1836
msgid ""
"The behavior of B<O_DIRECT> with NFS will differ from local filesystems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will bypass the page cache only on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""
"NFS で B<O_DIRECT> を使った場合の動作はローカルのファイルシステムの場合と違"
"う。 古いカーネルや、ある種の設定でコンパイルされたカーネルは、 B<O_DIRECT> "
"と NFS の組み合わせをサポートしていないかもしれない。 NFS プロトコル自体は"
"サーバにフラグを渡す機能は持っていないので、 B<O_DIRECT> I/O はクライアント上"
"のページキャッシュをバイパスするだけになり、 サーバは I/O をキャッシュしてい"
"るかもしれない。 クライアントは、 B<O_DIRECT> の同期機構を保持するため、サー"
"バに対して I/O を同期して行うように依頼する。 サーバによっては、こうした状況"
"下、特に I/O サイズが小さい場合に 性能が大きく劣化する。 また、サーバによって"
"は、I/O が安定したストレージにまで行われたと、 クライアントに対して嘘をつくも"
"のもある。 これは、サーバの電源故障が起こった際にデータの完全性が保たれない "
"危険は少しあるが、性能面での不利な条件を回避するために行われている。 Linux "
"の NFS クライアントでは B<O_DIRECT> I/O でのアラインメントの制限はない。"

#. type: Plain text
#: build/C/man2/open.2:1843
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""
"まとめると、 B<O_DIRECT> は、注意して使うべきであるが、強力なツールとなる可能"
"性を持っている。 アプリケーションは B<O_DIRECT> をデフォルトでは無効になって"
"いる性能向上のためのオプションと 考えておくのがよいであろう。"

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
#: build/C/man2/open.2:1854
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""
"現在のところ、 B<open>()  の呼び出し時に B<O_ASYNC> を指定してシグナル駆動 I/"
"O を有効にすることはできない。 このフラグを有効にするには B<fcntl>(2)  を使用"
"すること。"

#. type: Plain text
#: build/C/man2/open.2:1862
msgid ""
"One must check for two different error codes, B<EISDIR> and B<ENOENT>, when "
"trying to determine whether the kernel supports B<O_TMPFILE> functionality."
msgstr ""
"カーネルが B<O_TMPFILE> 機能をサポートしているかを判定する際に、 B<EISDIR> "
"と B<ENOENT> の 2 つのエラーコードをチェックしなければならない。"

#. type: Plain text
#: build/C/man2/open.2:1876
msgid ""
"When both B<O_CREAT> and B<O_DIRECTORY> are specified in I<flags> and the "
"file specified by I<pathname> does not exist, B<open>()  will create a "
"regular file (i.e., B<O_DIRECTORY> is ignored)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1901
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<open_by_handle_at>(2), "
"B<openat2>(2), B<read>(2), B<socket>(2), B<stat>(2), B<umask>(2), "
"B<unlink>(2), B<write>(2), B<fopen>(3), B<acl>(5), B<fifo>(7), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr "B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<open_by_handle_at>(2), B<openat2>(2), B<read>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<write>(2), B<fopen>(3), B<acl>(5), B<fifo>(7), B<inode>(7), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/openat2.2:24
#, no-wrap
msgid "OPENAT2"
msgstr "OPENAT2"

#. type: Plain text
#: build/C/man2/openat2.2:27
msgid "openat2 - open and possibly create a file (extended)"
msgstr "openat2 - ファイルのオープン、作成を行う (拡張版)"

#. type: Plain text
#: build/C/man2/openat2.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>linux/openat2.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>linux/openat2.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/openat2.2:36
#, no-wrap
msgid ""
"B<long openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            struct open_how *>I<how>B<, size_t >I<size>B<);>\n"
msgstr ""
"B<long openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            struct open_how *>I<how>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/openat2.2:46
msgid ""
"The B<openat2>()  system call is an extension of B<openat>(2)  and provides "
"a superset of its functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:56
msgid ""
"The B<openat2>()  system call opens the file specified by I<pathname>.  If "
"the specified file does not exist, it may optionally (if B<O_CREAT> is "
"specified in I<how.flags>)  be created."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:80
#, fuzzy
#| msgid ""
#| "If the pathname given in I<pathname> is relative, then it is interpreted "
#| "relative to the directory referred to by the file descriptor I<dirfd> "
#| "(rather than relative to the current working directory of the calling "
#| "process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
#| "pathname)."
msgid ""
"As with B<openat>(2), if I<pathname> is a relative pathname, then it is "
"interpreted relative to the directory referred to by the file descriptor "
"I<dirfd> (or the current working directory of the calling process, if "
"I<dirfd> is the special value B<AT_FDCWD>).  If I<pathname> is an absolute "
"pathname, then I<dirfd> is ignored (unless I<how.resolve> contains "
"B<RESOLVE_IN_ROOT>, in which case I<pathname> is resolved relative to "
"I<dirfd>)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<unlink>() や B<rmdir>(2) に相対パス名を渡した場合のように、呼び出したプロ"
"セスのカレントワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/openat2.2:90
msgid ""
"Rather than taking a single I<flags> argument, an extensible structure "
"(I<how>) is passed to allow for future extensions.  The I<size> argument "
"must be specified as I<sizeof(struct open_how)>."
msgstr ""

#. type: SS
#: build/C/man2/openat2.2:90
#, no-wrap
msgid "The open_how structure"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:102
msgid ""
"The I<how> argument specifies how I<pathname> should be opened, and acts as "
"a superset of the I<flags> and I<mode> arguments to B<openat>(2).  This "
"argument is a pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:111
#, no-wrap
msgid ""
"struct open_how {\n"
"    u64 flags;    /* O_* flags */\n"
"    u64 mode;     /* Mode for O_{CREAT,TMPFILE} */\n"
"    u64 resolve;  /* RESOLVE_* flags */\n"
"    /* ... */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:126
msgid ""
"Any future extensions to B<openat2>()  will be implemented as new fields "
"appended to the above structure, with a zero value in a new field resulting "
"in the kernel behaving as though that extension field was not present.  "
"Therefore, the caller I<must> zero-fill this structure on initialization.  "
"(See the \"Extensibility\" section of the B<NOTES> for more detail on why "
"this is necessary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:130
#, fuzzy
#| msgid "The four fields are as follows:"
msgid "The fields of the I<open_how> structure are as follows:"
msgstr "4 つのフィールドの詳細は以下のとおりである。"

#. type: TP
#: build/C/man2/openat2.2:130
#, no-wrap
msgid "I<flags>"
msgstr "I<flags>"

#. type: Plain text
#: build/C/man2/openat2.2:141
msgid ""
"This field specifies the file creation and file status flags to use when "
"opening the file.  All of the B<O_*> flags defined for B<openat>(2)  are "
"valid B<openat2>()  flag values."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:150
msgid ""
"Whereas B<openat>(2)  ignores unknown bits in its I<flags> argument, "
"B<openat2>()  returns an error if unknown or conflicting flags are specified "
"in I<how.flags>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:150
#, no-wrap
msgid "I<mode>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:157
msgid ""
"This field specifies the mode for the new file, with identical semantics to "
"the I<mode> argument of B<openat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:180
msgid ""
"Whereas B<openat>(2)  ignores bits other than those in the range I<07777> in "
"its I<mode> argument, B<openat2>()  returns an error if I<how.mode> contains "
"bits other than I<07777>.  Similarly, an error is returned if B<openat2>()  "
"is called with a nonzero I<how.mode> and I<how.flags> does not contain "
"B<O_CREAT> or B<O_TMPFILE>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:180
#, no-wrap
msgid "I<resolve>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:190
msgid ""
"This is a bit-mask of flags that modify the way in which B<all> components "
"of I<pathname> will be resolved.  (See B<path_resolution>(7)  for background "
"information.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:196
msgid ""
"The primary use case for these flags is to allow trusted programs to "
"restrict how untrusted paths (or paths inside untrusted directories) are "
"resolved.  The full list of I<resolve> flags is as follows:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:197
#, no-wrap
msgid "B<RESOLVE_BENEATH>"
msgstr ""

#.  commit adb21d2b526f7f196b2f3fdca97d80ba05dd14a0
#. type: Plain text
#: build/C/man2/openat2.2:206
msgid ""
"Do not permit the path resolution to succeed if any component of the "
"resolution is not a descendant of the directory indicated by I<dirfd>.  This "
"causes absolute symbolic links (and absolute values of I<pathname>)  to be "
"rejected."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:212
msgid ""
"Currently, this flag also disables magic-link resolution (see below).  "
"However, this may change in the future.  Therefore, to ensure that magic "
"links are not resolved, the caller should explicitly specify "
"B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:212
#, no-wrap
msgid "B<RESOLVE_IN_ROOT>"
msgstr ""

#.  commit 8db52c7e7ee1bd861b6096fcafc0fe7d0f24a994
#. type: Plain text
#: build/C/man2/openat2.2:237
msgid ""
"Treat the directory referred to by I<dirfd> as the root directory while "
"resolving I<pathname>.  Absolute symbolic links are interpreted relative to "
"I<dirfd>.  If a prefix component of I<pathname> equates to I<dirfd>, then an "
"immediately following I<..\\&> component likewise equates to I<dirfd> (just "
"as I</..\\&> is traditionally equivalent to I</>).  If I<pathname> is an "
"absolute path, it is also interpreted relative to I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:248
msgid ""
"The effect of this flag is as though the calling process had used "
"B<chroot>(2)  to (temporarily) modify its root directory (to the directory "
"referred to by I<dirfd>).  However, unlike B<chroot>(2)  (which changes the "
"filesystem root permanently for a process), B<RESOLVE_IN_ROOT> allows a "
"program to efficiently restrict path resolution on a per-open basis."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:254
msgid ""
"Currently, this flag also disables magic-link resolution.  However, this may "
"change in the future.  Therefore, to ensure that magic links are not "
"resolved, the caller should explicitly specify B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:254
#, no-wrap
msgid "B<RESOLVE_NO_MAGICLINKS>"
msgstr ""

#.  commit 278121417a72d87fb29dd8c48801f80821e8f75a
#. type: Plain text
#: build/C/man2/openat2.2:258
msgid "Disallow all magic-link resolution during path resolution."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:268
msgid ""
"Magic links are symbolic link-like objects that are most notably found in "
"B<proc>(5); examples include I</proc/[pid]/exe> and I</proc/[pid]/fd/*>.  "
"(See B<symlink>(7)  for more details.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:271
msgid ""
"Unknowingly opening magic links can be risky for some applications.  "
"Examples of such risks include the following:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:272 build/C/man2/openat2.2:280
#: build/C/man2/openat2.2:507 build/C/man2/openat2.2:515
#: build/C/man2/openat2.2:528 build/C/man3/scanf.3:157 build/C/man3/scanf.3:163
#: build/C/man3/scanf.3:167 build/C/man3/scanf.3:186 build/C/man3/scanf.3:197
#: build/C/man3/scanf.3:208 build/C/man3/scanf.3:227 build/C/man3/scanf.3:239
#: build/C/man3/scanf.3:253
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man2/openat2.2:280
msgid ""
"If the process opening a pathname is a controlling process that currently "
"has no controlling terminal (see B<credentials>(7)), then opening a magic "
"link inside I</proc/[pid]/fd> that happens to refer to a terminal would "
"cause the process to acquire a controlling terminal."
msgstr ""

#.  From https://lwn.net/Articles/796868/:
#.      The presence of this flag will prevent a path lookup operation
#.      from traversing through one of these magic links, thus blocking
#.      (for example) attempts to escape from a container via a /proc
#.      entry for an open file descriptor.
#. type: Plain text
#: build/C/man2/openat2.2:291
msgid ""
"In a containerized environment, a magic link inside I</proc> may refer to an "
"object outside the container, and thus may provide a means to escape from "
"the container."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:297
msgid ""
"Because of such risks, an application may prefer to disable magic link "
"resolution using the B<RESOLVE_NO_MAGICLINKS> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:313
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a magic link, "
"I<how.resolve> contains B<RESOLVE_NO_MAGICLINKS>, and I<how.flags> contains "
"both B<O_PATH> and B<O_NOFOLLOW>, then an B<O_PATH> file descriptor "
"referencing the magic link will be returned."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:313
#, no-wrap
msgid "B<RESOLVE_NO_SYMLINKS>"
msgstr ""

#.  commit 278121417a72d87fb29dd8c48801f80821e8f75a
#. type: Plain text
#: build/C/man2/openat2.2:319
msgid ""
"Disallow resolution of symbolic links during path resolution.  This option "
"implies B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:335
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a symbolic "
"link, I<how.resolve> contains B<RESOLVE_NO_SYMLINKS>, and I<how.flags> "
"contains both B<O_PATH> and B<O_NOFOLLOW>, then an B<O_PATH> file descriptor "
"referencing the symbolic link will be returned."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:347
msgid ""
"Note that the effect of the B<RESOLVE_NO_SYMLINKS> flag, which affects the "
"treatment of symbolic links in all of the components of I<pathname>, differs "
"from the effect of the B<O_NOFOLLOW> file creation flag (in I<how.flags>), "
"which affects the handling of symbolic links only in the final component of "
"I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:361
msgid ""
"Applications that employ the B<RESOLVE_NO_SYMLINKS> flag are encouraged to "
"make its use configurable (unless it is used for a specific security "
"purpose), as symbolic links are very widely used by end-users.  Setting this "
"flag indiscriminately\\(emi.e., for purposes not specifically related to "
"security\\(emfor all uses of B<openat2>()  may result in spurious errors on "
"previously functional systems.  This may occur if, for example, a system "
"pathname that is used by an application is modified (e.g., in a new "
"distribution release)  so that a pathname component (now) contains a "
"symbolic link."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:361
#, no-wrap
msgid "B<RESOLVE_NO_XDEV>"
msgstr "B<RESOLVE_NO_XDEV>"

#.  commit 72ba29297e1439efaa54d9125b866ae9d15df339
#. type: Plain text
#: build/C/man2/openat2.2:374
msgid ""
"Disallow traversal of mount points during path resolution (including all "
"bind mounts).  Consequently, I<pathname> must either be on the same mount as "
"the directory referred to by I<dirfd>, or on the same mount as the current "
"working directory if I<dirfd> is specified as B<AT_FDCWD>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:388
msgid ""
"Applications that employ the B<RESOLVE_NO_XDEV> flag are encouraged to make "
"its use configurable (unless it is used for a specific security purpose), as "
"bind mounts are widely used by end-users.  Setting this flag indiscriminately"
"\\(emi.e., for purposes not specifically related to security\\(emfor all "
"uses of B<openat2>()  may result in spurious errors on previously functional "
"systems.  This may occur if, for example, a system pathname that is used by "
"an application is modified (e.g., in a new distribution release)  so that a "
"pathname component (now) contains a bind mount."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:393
msgid ""
"If any bits other than those listed above are set in I<how.resolve>, an "
"error is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:398
#, fuzzy
#| msgid ""
#| "On success, zero is returned.  On error, -1 is returned, and I<errno> is "
#| "set appropriately."
msgid ""
"On success, a new file descriptor is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/openat2.2:404
msgid ""
"The set of errors returned by B<openat2>()  includes all of the errors "
"returned by B<openat>(2), as well as the following additional errors:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:404
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/openat2.2:411
msgid ""
"An extension that this kernel does not support was specified in I<how>.  "
"(See the \"Extensibility\" section of B<NOTES> for more detail on how "
"extensions are handled.)"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:411 build/C/man2/read.2:100 build/C/man3/scanf.3:558
#: build/C/man2/write.2:132
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/openat2.2:423
msgid ""
"I<how.resolve> contains either B<RESOLVE_IN_ROOT> or B<RESOLVE_BENEATH>, and "
"the kernel could not ensure that a \"..\" component didn't escape (due to a "
"race condition or potential attack).  The caller may choose to retry the "
"B<openat2>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:427
msgid "An unknown flag or invalid value was specified in I<how>."
msgstr "未知のフラグか無効な値が I<how> に指定された。"

#. type: Plain text
#: build/C/man2/openat2.2:436
msgid ""
"I<mode> is nonzero, but I<how.flags> does not contain B<O_CREAT> or "
"B<O_TMPFILE>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:441
msgid "I<size> was smaller than any known version of I<struct open_how>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:447
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_SYMLINKS>, and one of the path "
"components was a symbolic link (or magic link)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:453
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_MAGICLINKS>, and one of the path "
"components was a magic link."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:461
msgid ""
"I<how.resolve> contains either B<RESOLVE_IN_ROOT> or B<RESOLVE_BENEATH>, and "
"an escape from the root during path resolution was detected."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:467
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_XDEV>, and a path component crosses a "
"mount point."
msgstr ""

#.  commit fddb5d430ad9fa91b49b1d34d0202ffe2fa0e179
#. type: Plain text
#: build/C/man2/openat2.2:471
msgid "B<openat2>()  first appeared in Linux 5.6."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:473
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/openat2.2:478
msgid ""
"The semantics of B<RESOLVE_BENEATH> were modeled after FreeBSD's "
"B<O_BENEATH>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:482
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。"

#. type: SS
#: build/C/man2/openat2.2:482
#, no-wrap
msgid "Extensibility"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:500
msgid ""
"In order to allow for future extensibility, B<openat2>()  requires the user-"
"space application to specify the size of the I<open_how> structure that it "
"is passing.  By providing this information, it is possible for B<openat2>()  "
"to provide both forwards- and backwards-compatibility, with I<size> acting "
"as an implicit version number.  (Because new extension fields will always be "
"appended, the structure size will always increase.)  This extensibility "
"design is very similar to other system calls such as B<sched_setattr>(2), "
"B<perf_event_open>(2), and B<clone3>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:507
msgid ""
"If we let I<usize> be the size of the structure as specified by the user-"
"space application, and I<ksize> be the size of the structure which the "
"kernel supports, then there are three cases to consider:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:515
msgid ""
"If I<ksize> equals I<usize>, then there is no version mismatch and I<how> "
"can be used verbatim."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:528
msgid ""
"If I<ksize> is larger than I<usize>, then there are some extension fields "
"that the kernel supports which the user-space application is unaware of.  "
"Because a zero value in any added extension field signifies a no-op, the "
"kernel treats all of the extension fields not provided by the user-space "
"application as having zero values.  This provides backwards-compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:543
msgid ""
"If I<ksize> is smaller than I<usize>, then there are some extension fields "
"which the user-space application is aware of but which the kernel does not "
"support.  Because any extension field must have its zero values signify a no-"
"op, the kernel can safely ignore the unsupported extension fields if they "
"are all-zero.  If any unsupported extension fields are nonzero, then -1 is "
"returned and I<errno> is set to B<E2BIG>.  This provides forwards-"
"compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:553
msgid ""
"Because the definition of I<struct open_how> may change in the future (with "
"new fields being added when system headers are updated), user-space "
"applications should zero-fill I<struct open_how> to ensure that recompiling "
"the program with new headers will not result in spurious errors at runtime.  "
"The simplest way is to use a designated initializer:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:558
#, no-wrap
msgid ""
"struct open_how how = { .flags = O_RDWR,\n"
"                        .resolve = RESOLVE_IN_ROOT };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:564
msgid "or explicitly using B<memset>(3)  or similar:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:571
#, no-wrap
msgid ""
"struct open_how how;\n"
"memset(&how, 0, sizeof(how));\n"
"how.flags = O_RDWR;\n"
"how.resolve = RESOLVE_IN_ROOT;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:580
msgid ""
"A user-space application that wishes to determine which extensions the "
"running kernel supports can do so by conducting a binary search on I<size> "
"with a structure which has every byte nonzero (to find the largest value "
"which doesn't produce an error of B<E2BIG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:584
msgid "B<openat>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr "B<openat>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/open_by_handle_at.2:25
#, no-wrap
msgid "OPEN_BY_HANDLE_AT"
msgstr "OPEN_BY_HANDLE_AT"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:29
msgid ""
"name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open "
"file via a handle"
msgstr ""
"name_to_handle_at, open_by_handle_at - パス名に対するハンドルの取得とハンドル"
"によるファイルのオープン"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:39
#, no-wrap
msgid ""
"B<int name_to_handle_at(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                      struct file_handle *>I<handle>B<,>\n"
"B<                      int *>I<mount_id>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int name_to_handle_at(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                      struct file_handle *>I<handle>B<,>\n"
"B<                      int *>I<mount_id>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:42
#, no-wrap
msgid ""
"B<int open_by_handle_at(int >I<mount_fd>B<, struct file_handle *>I<handle>B<,>\n"
"B<                      int >I<flags>B<);>\n"
msgstr ""
"B<int open_by_handle_at(int >I<mount_fd>B<, struct file_handle *>I<handle>B<,>\n"
"B<                      int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:59
msgid ""
"The B<name_to_handle_at>()  and B<open_by_handle_at>()  system calls split "
"the functionality of B<openat>(2)  into two parts: B<name_to_handle_at>()  "
"returns an opaque handle that corresponds to a specified file; "
"B<open_by_handle_at>()  opens the file corresponding to a handle returned by "
"a previous call to B<name_to_handle_at>()  and returns an open file "
"descriptor."
msgstr ""
"システムコール B<name_to_handle_at>() と B<open_by_handle_at>() は "
"B<openat>(2) の機能を 2 つに分割したものである。 B<name_to_handle_at>() は指"
"定されたファイルに対応するハンドルを返す。 B<open_by_handle_at>() は "
"B<name_to_handle_at>() が返したハンドルに対応するファイルをオープンし、 オー"
"プンされたファイルディスクリプターを返す。 "

#. type: SS
#: build/C/man2/open_by_handle_at.2:59
#, no-wrap
msgid "name_to_handle_at()"
msgstr "name_to_handle_at()"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:71
msgid ""
"The B<name_to_handle_at>()  system call returns a file handle and a mount ID "
"corresponding to the file specified by the I<dirfd> and I<pathname> "
"arguments.  The file handle is returned via the argument I<handle>, which is "
"a pointer to a structure of the following form:"
msgstr ""
"B<name_to_handle_at>() システムコールは、 引数 I<dirfd> と I<pathname> で指"
"定されるファイルに対応するファイルハンドルとマウント ID を返す。 ファイルハン"
"ドルは引数 I<handle> で返される。 I<handle> は以下の形式の構造体へのポイン"
"ターである。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:80
#, no-wrap
msgid ""
"struct file_handle {\n"
"    unsigned int  handle_bytes;   /* Size of f_handle [in, out] */\n"
"    int           handle_type;    /* Handle type [out] */\n"
"    unsigned char f_handle[0];    /* File identifier (sized by\n"
"                                     caller) [out] */\n"
"};\n"
msgstr ""
"struct file_handle {\n"
"    unsigned int  handle_bytes;   /* Size of f_handle [in, out] */\n"
"    int           handle_type;    /* Handle type [out] */\n"
"    unsigned char f_handle[0];    /* File identifier (sized by\n"
"                                     caller) [out] */\n"
"};\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:101
#, fuzzy
#| msgid ""
#| "It is the caller's responsibility to allocate the structure with a size "
#| "large enough to hold the handle returned in I<f_handle>.  Before the "
#| "call, the I<handle_bytes> field should be initialized to contain the "
#| "allocated size for I<f_handle>.  (The constant B<MAX_HANDLE_SZ>, defined "
#| "in I<E<lt>fcntl.hE<gt>>, specifies the maximum possible size for a file "
#| "handle.)  Upon successful return, the I<handle_bytes> field is updated to "
#| "contain the number of bytes actually written to I<f_handle>."
msgid ""
"It is the caller's responsibility to allocate the structure with a size "
"large enough to hold the handle returned in I<f_handle>.  Before the call, "
"the I<handle_bytes> field should be initialized to contain the allocated "
"size for I<f_handle>.  (The constant B<MAX_HANDLE_SZ>, defined in "
"I<E<lt>fcntl.hE<gt>>, specifies the maximum expected size for a file "
"handle.  It is not a guaranteed upper limit as future filesystems may "
"require more space.)  Upon successful return, the I<handle_bytes> field is "
"updated to contain the number of bytes actually written to I<f_handle>."
msgstr ""
"I<f_handle> で返されるハンドルを保持するのに十分な大きさの構造体を確保するの"
"は、 呼び出し元が責任をもって行う必要がある。 呼び出し前に、 I<handle_bytes> "
"フィールドは I<f_handle> 用に格納されたサイズで初期化すべきである "
"(I<E<lt>fcntl.hE<gt>> で定義されている定数 B<MAX_HANDLE_SZ> でファイルハンド"
"ルの最大サイズが規定されている)。 呼び出しが成功でリターンする際、 "
"I<handle_bytes> フィールドは I<f_handle> に実際に書き込まれたバイト数に更新さ"
"れる。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:123
#, fuzzy
#| msgid ""
#| "The caller can discover the required size for the I<file_handle> "
#| "structure by making a call in which I<handle-E<gt>handle_bytes> is zero; "
#| "in this case, the call fails with the error B<EOVERFLOW> and I<handle-"
#| "E<gt>handle_bytes> is set to indicate the required size; the caller can "
#| "then use this information to allocate a structure of the correct size "
#| "(see EXAMPLE below)."
msgid ""
"The caller can discover the required size for the I<file_handle> structure "
"by making a call in which I<handle-E<gt>handle_bytes> is zero; in this case, "
"the call fails with the error B<EOVERFLOW> and I<handle-E<gt>handle_bytes> "
"is set to indicate the required size; the caller can then use this "
"information to allocate a structure of the correct size (see EXAMPLES "
"below).  Some care is needed here as B<EOVERFLOW> can also indicate that no "
"file handle is available for this particular name in a filesystem which does "
"normally support file-handle lookup.  This case can be detected when the "
"B<EOVERFLOW> error is returned without I<handle_bytes> being increased."
msgstr ""
"呼び出し元では、 I<handle-E<gt>handle_bytes> を 0 に設定して呼び出しを行うこ"
"とで、 I<file_handle> 構造体に必要なサイズを知ることができる。 この場合、 こ"
"の呼び出しはエラー B<EOVERFLOW> で失敗し、 I<handle-E<gt>handle_bytes> に必要"
"なサイズが設定される。 呼び出し元はこの情報を使って、正しいサイズの構造体を割"
"り当てることができる (下記の「例」を参照)。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:134
msgid ""
"Other than the use of the I<handle_bytes> field, the caller should treat the "
"I<file_handle> structure as an opaque data type: the I<handle_type> and "
"I<f_handle> fields are needed only by a subsequent call to "
"B<open_by_handle_at>()."
msgstr ""
"I<handle_bytes> フィールドを使用する以外は、 呼び出し元は I<file_handle> 構造"
"体の内容を意識せずに扱うべきである。 フィールド I<handle_type> と "
"I<f_handle> は後で B<open_by_handle_at>() を呼び出す場合にだけ必要である。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:142
msgid ""
"The I<flags> argument is a bit mask constructed by ORing together zero or "
"more of B<AT_EMPTY_PATH> and B<AT_SYMLINK_FOLLOW>, described below."
msgstr ""
"I<flags> 引数は、 下記の B<AT_EMPTY_PATH> と B<AT_SYMLINK_FOLLOW> のうち 0 "
"個以上の論理和を取って構成されるビットマスクである。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:149
msgid ""
"Together, the I<pathname> and I<dirfd> arguments identify the file for which "
"a handle is to be obtained.  There are four distinct cases:"
msgstr ""
"引数 I<pathname> と I<dirfd> はその組み合わせでハンドルを取得するファイルを"
"指定する。 以下の 4 つのパターンがある。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:157
msgid ""
"If I<pathname> is a nonempty string containing an absolute pathname, then a "
"handle is returned for the file referred to by that pathname.  In this case, "
"I<dirfd> is ignored."
msgstr ""
"I<pathname> が空でない文字列で絶対パス名を含む場合、 このパス名が参照するファ"
"イルに対するハンドルが返される。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:168
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> has the special value B<AT_FDCWD>, then I<pathname> is interpreted "
"relative to the current working directory of the caller, and a handle is "
"returned for the file to which it refers."
msgstr ""
"I<pathname> が相対パスが入った空でない文字列で、 I<dirfd> が特別な値 "
"B<AT_FDCWD> の場合、 I<pathname> は呼び出し元のカレントワーキングディレクトリ"
"に対する相対パスと解釈され、 そのファイルに対するハンドルが返される。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:181
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> is a file descriptor referring to a directory, then I<pathname> is "
"interpreted relative to the directory referred to by I<dirfd>, and a handle "
"is returned for the file to which it refers.  (See B<openat>(2)  for an "
"explanation of why \"directory file descriptors\" are useful.)"
msgstr ""
"I<pathname> が相対パスが入った空でない文字列で、 I<dirfd> がディレクトリを参"
"照するファイルディスクリプターの場合、 I<pathname> は I<dirfd> が参照するディ"
"レクトリに対する相対パスと解釈され、 そのファイルを参照するハンドルが返され"
"る。(なぜ「ディレクトリファイルディスクリプター」が役に立つのかについては "
"B<openat>(2) を参照。)"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:195
msgid ""
"If I<pathname> is an empty string and I<flags> specifies the value "
"B<AT_EMPTY_PATH>, then I<dirfd> can be an open file descriptor referring to "
"any type of file, or B<AT_FDCWD>, meaning the current working directory, and "
"a handle is returned for the file to which it refers."
msgstr ""
"I<pathname> が空の文字列で I<flags> に B<AT_EMPTY_PATH> が指定されている場"
"合、 I<dirfd> には任意の種別のファイルを参照するオープンされたファイルディス"
"クリプターか B<AT_FDCWD> (カレントワーキングディレクトリを意味する) を指定で"
"き、 I<dirfd> が参照するファイルに対するハンドルが返される。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:211
#, fuzzy
#| msgid ""
#| "The I<mount_id> argument returns an identifier for the filesystem mount "
#| "that corresponds to I<pathname>.  This corresponds to the first field in "
#| "one of the records in I</proc/self/mountinfo>.  Opening the pathname in "
#| "the fifth field of that record yields a file descriptor for the mount "
#| "point; that file descriptor can be used in a subsequent call to "
#| "B<open_by_handle_at>()."
msgid ""
"The I<mount_id> argument returns an identifier for the filesystem mount that "
"corresponds to I<pathname>.  This corresponds to the first field in one of "
"the records in I</proc/self/mountinfo>.  Opening the pathname in the fifth "
"field of that record yields a file descriptor for the mount point; that file "
"descriptor can be used in a subsequent call to B<open_by_handle_at>().  "
"I<mount_id> is returned both for a successful call and for a call that "
"results in the error B<EOVERFLOW>."
msgstr ""
"I<mount_id> 引数は、 I<pathname> に対応するファイルシステムのマウントの識別"
"子を返す。 この識別子は I</proc/self/mountinfo> のいずれかのレコードの最初の"
"フィールドに対応する。 対応するレコードの 5 番目のフィールドのパス名をオープ"
"ンすると、 このマウントポイントのファイルディスクリプターが得られる。 この"
"ファイルディスクリプターはこの後の B<open_by_handle_at>() の呼び出しで使用で"
"きる。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:224
msgid ""
"By default, B<name_to_handle_at>()  does not dereference I<pathname> if it "
"is a symbolic link, and thus returns a handle for the link itself.  If "
"B<AT_SYMLINK_FOLLOW> is specified in I<flags>, I<pathname> is dereferenced "
"if it is a symbolic link (so that the call returns a handle for the file "
"referred to by the link)."
msgstr ""
"デフォルトでは、 B<name_to_handle_at>() は I<pathname> がシンボリックリンクの"
"場合にその展開 (dereference) を行わず、 リンク自身に対するハンドルを返す。 "
"B<AT_SYMLINK_FOLLOW> が I<flags> に指定されると、 I<pathname> がシンボリック"
"リンクの場合にリンクの展開が行われる (リンクが参照するファイルに対するハンド"
"ルが返される)。"

#.  commit 20fa19027286983ab2734b5910c4a687436e0c31
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:241
msgid ""
"B<name_to_handle_at>()  does not trigger a mount when the final component of "
"the pathname is an automount point.  When a filesystem supports both file "
"handles and automount points, a B<name_to_handle_at>()  call on an automount "
"point will return with error B<EOVERFLOW> without having increased "
"I<handle_bytes>.  This can happen since Linux 4.13 with NFS when accessing a "
"directory which is on a separate filesystem on the server.  In this case, "
"the automount can be triggered by adding a \"/\" to the end of the pathname."
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:241
#, no-wrap
msgid "open_by_handle_at()"
msgstr "open_by_handle_at()"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:248
msgid ""
"The B<open_by_handle_at>()  system call opens the file referred to by "
"I<handle>, a file handle returned by a previous call to "
"B<name_to_handle_at>()."
msgstr ""
"B<open_by_handle_at>() システムコールは I<handle> が参照するファイルをオープ"
"ンする。 I<handle> は 前に呼び出した B<name_to_handle_at>() が返したファイル"
"ハンドルである。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:258
msgid ""
"The I<mount_fd> argument is a file descriptor for any object (file, "
"directory, etc.)  in the mounted filesystem with respect to which I<handle> "
"should be interpreted.  The special value B<AT_FDCWD> can be specified, "
"meaning the current working directory of the caller."
msgstr ""
"I<mount_fd> 引数は、 I<handle> がそのファイルシステムに関連すると解釈される"
"マウントされたファイルシステム内の任意のオブジェクト (ファイル、 ディレクトリ"
"など) のファイルディスクリプターである。 特別な値 B<AT_FDCWD> も指定できる。 "
"この値は呼び出し元のカレントワーキングディレクトリを意味する。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:271
msgid ""
"The I<flags> argument is as for B<open>(2).  If I<handle> refers to a "
"symbolic link, the caller must specify the B<O_PATH> flag, and the symbolic "
"link is not dereferenced; the B<O_NOFOLLOW> flag, if specified, is ignored."
msgstr ""
"引数 I<flags> は B<open>(2) と同じである。 I<handle> がシンボリックリンクを"
"参照している場合、 呼び出し元は B<O_PATH> フラグを指定しなければならず、 その"
"シンボリックリンクは展開されない。 B<O_NOFOLLOW> が指定された場合は、 "
"B<O_NOFOLLOW> は無視される。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:276
msgid ""
"The caller must have the B<CAP_DAC_READ_SEARCH> capability to invoke "
"B<open_by_handle_at>()."
msgstr ""
"B<open_by_handle_at>() を呼び出すには、 呼び出し元が B<CAP_DAC_READ_SEARCH> "
"ケーパビリティーを持っていなければならない。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:283
msgid ""
"On success, B<name_to_handle_at>()  returns 0, and B<open_by_handle_at>()  "
"returns a file descriptor (a nonnegative integer)."
msgstr "成功すると、 B<name_to_handle_at>() は 0 を返し、 B<open_by_handle_at>() はファイルディスクリプター (非負の整数) を返す。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:287
msgid ""
"In the event of an error, both system calls return -1 and set I<errno> to "
"indicate the cause of the error."
msgstr ""
"エラーの場合、 どちらのシステムコールも -1 を返し、 I<errno> にエラーの原因を"
"示す値を設定する。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:294
msgid ""
"B<name_to_handle_at>()  and B<open_by_handle_at>()  can fail for the same "
"errors as B<openat>(2).  In addition, they can fail with the errors noted "
"below."
msgstr ""
"B<name_to_handle_at>() と B<open_by_handle_at>() は B<openat>(2) と同じエラー"
"で失敗する。 また、 これらのシステムコールは以下のエラーで失敗することもあ"
"る。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:297
msgid "B<name_to_handle_at>()  can fail with the following errors:"
msgstr "B<name_to_handle_at>() は以下のエラーで失敗することがある。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:304
msgid ""
"I<pathname>, I<mount_id>, or I<handle> points outside your accessible "
"address space."
msgstr ""
"I<pathname>, I<mount_id>, I<handle> のどれかがアクセス可能なアドレス空間の外"
"を指している。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:308
msgid "I<flags> includes an invalid bit value."
msgstr "I<flags> に無効なビット値が含まれている。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:313
msgid "I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ>."
msgstr "I<handle-E<gt>handle_bytes> が B<MAX_HANDLE_SZ> よりも大きい。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:320
msgid ""
"I<pathname> is an empty string, but B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""
"I<pathname> が空文字列だが、 I<flags> に B<AT_EMPTY_PATH> がされていなかっ"
"た。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:332
msgid ""
"The file descriptor supplied in I<dirfd> does not refer to a directory, and "
"it is not the case that both I<flags> includes B<AT_EMPTY_PATH> and "
"I<pathname> is an empty string."
msgstr ""
"I<dirfd> で指定されたファイルディスクリプターがディレクトリを参照しておら"
"ず、 両方の I<flags> に B<AT_EMPTY_PATH> が指定され、 かつ I<pathname> が空文"
"字列である場合でもない。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:335
msgid ""
"The filesystem does not support decoding of a pathname to a file handle."
msgstr ""
"ファイルシステムがパス名をファイルハンドルへの変換をサポートしていない。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:345
msgid ""
"The I<handle-E<gt>handle_bytes> value passed into the call was too small.  "
"When this error occurs, I<handle-E<gt>handle_bytes> is updated to indicate "
"the required size for the handle."
msgstr ""
"呼び出しに渡された I<handle-E<gt>handle_bytes> の値が小さすぎた。 このエラー"
"が発生した際、 I<handle-E<gt>handle_bytes> はハンドルに必要なサイズに更新され"
"る。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:348
msgid "B<open_by_handle_at>()  can fail with the following errors:"
msgstr "B<open_by_handle_at>() は以下のエラーで失敗することがある。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:352
msgid "I<mount_fd> is not an open file descriptor."
msgstr "I<mount_fd> がオープンされたファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:356
msgid "I<handle> points outside your accessible address space."
msgstr "I<handle> がアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:362
msgid ""
"I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ> or is equal to "
"zero."
msgstr ""
"I<handle-E<gt>handle_bytes> が B<MAX_HANDLE_SZ> より大きいか 0 に等しい。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:369
msgid ""
"I<handle> refers to a symbolic link, but B<O_PATH> was not specified in "
"I<flags>."
msgstr ""
"I<handle> がシンボリックリンクを参照しているが、 I<flags> に B<O_PATH> がされ"
"ていなかった。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:374
msgid "The caller does not have the B<CAP_DAC_READ_SEARCH> capability."
msgstr "呼び出し元が B<CAP_DAC_READ_SEARCH> ケーパビリティを持っていない。"

#. type: TP
#: build/C/man2/open_by_handle_at.2:374
#, no-wrap
msgid "B<ESTALE>"
msgstr "B<ESTALE>"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:380
msgid ""
"The specified I<handle> is not valid.  This error will occur if, for "
"example, the file has been deleted."
msgstr ""
"指定された I<handle> が有効ではない。 このエラーは、 例えばファイルが削除され"
"た場合などに発生する。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:383
msgid ""
"These system calls first appeared in Linux 2.6.39.  Library support is "
"provided in glibc since version 2.14."
msgstr ""
"これらのシステムコールは Linux 2.6.39 で初めて登場した。ライブラリによるサ"
"ポートはバージョン 2.14 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:385
msgid "These system calls are nonstandard Linux extensions."
msgstr "これらのシステムコールは非標準の Linux の拡張である。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:390
msgid ""
"FreeBSD has a broadly similar pair of system calls in the form of "
"B<getfh>()  and B<openfh>()."
msgstr ""
"FreeBSD には B<getfh>() と B<openfh>() というほとんど同じ機能のシステムコール"
"のペアが存在する。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:395
msgid ""
"A file handle can be generated in one process using B<name_to_handle_at>()  "
"and later used in a different process that calls B<open_by_handle_at>()."
msgstr ""
"あるプロセスで B<name_to_handle_at>() を使ってファイルハンドルを生成して、 そ"
"のハンドルを別のプロセスの B<open_by_handle_at>() で使用することができる。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:401
msgid ""
"Some filesystem don't support the translation of pathnames to file handles, "
"for example, I</proc>, I</sys>, and various network filesystems."
msgstr ""
"いくつかのファイルシステムでは、 パス名からファイルハンドルへの変換がサポート"
"されていない。 例えば、 I</proc>, I</sys> や種々のネットワークファイルシステ"
"ムなどである。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:408
msgid ""
"A file handle may become invalid (\"stale\") if a file is deleted, or for "
"other filesystem-specific reasons.  Invalid handles are notified by an "
"B<ESTALE> error from B<open_by_handle_at>()."
msgstr ""
"ファイルハンドルは、 ファイルが削除されたり、 その他のファイルシステム固有の"
"理由で、 無効 (\"stale\") になる場合がある。 無効なハンドルであることは、 "
"B<open_by_handle_at>() からエラー B<ESTALE> が返ることで通知される。"

#.  https://lwn.net/Articles/375888/
#. 	"Open by handle" - Jonathan Corbet, 2010-02-23
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:418
msgid ""
"These system calls are designed for use by user-space file servers.  For "
"example, a user-space NFS server might generate a file handle and pass it to "
"an NFS client.  Later, when the client wants to open the file, it could pass "
"the handle back to the server.  This sort of functionality allows a user-"
"space file server to operate in a stateless fashion with respect to the "
"files it serves."
msgstr ""
"これらのシステムコールは、 ユーザー空間のファイルサーバーでの使用を意図して設"
"計されている。 例えば、 ユーザー空間 NFS サーバーがファイルハンドルを生成し"
"て、 そのハンドルを NFS クライアントに渡すことができる。 その後、 クライアン"
"トがファイルをオープンしようとした際に、 このハンドルをサーバーに送り返すこと"
"ができる。 このような機能により、 ユーザー空間ファイルサーバーは、 そのサー"
"バーが提供するファイルに関してステートレスで (状態を保持せずに) 動作すること"
"ができる。"

#.  commit bcda76524cd1fa32af748536f27f674a13e56700
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:440
msgid ""
"If I<pathname> refers to a symbolic link and I<flags> does not specify "
"B<AT_SYMLINK_FOLLOW>, then B<name_to_handle_at>()  returns a handle for the "
"link (rather than the file to which it refers).  The process receiving the "
"handle can later perform operations on the symbolic link by converting the "
"handle to a file descriptor using B<open_by_handle_at>()  with the B<O_PATH> "
"flag, and then passing the file descriptor as the I<dirfd> argument in "
"system calls such as B<readlinkat>(2)  and B<fchownat>(2)."
msgstr ""
"I<pathname> がシンボリックリンクを参照していて、 I<flags> に "
"B<AT_SYMLINK_FOLLOW> が指定されていない場合、 B<name_to_handle_at>() は (シン"
"ボリックが参照するファイルではなく) リンクに対するハンドルを返す。 ハンドルを"
"受け取ったプロセスは、 B<open_by_handle_at>() の B<O_PATH> フラグを使ってハン"
"ドルをファイルディスクリプターに変換し、 そのファイルディスクリプターを "
"B<readlinkat>(2) や B<fchownat>(2) などのシステムコールの I<dirfd> 引数とし"
"て渡すことで、 そのシンボリックリンクに対して操作を行うことができる。"

#. type: SS
#: build/C/man2/open_by_handle_at.2:440
#, no-wrap
msgid "Obtaining a persistent filesystem ID"
msgstr "永続的なファイルシステム ID の取得"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:454
msgid ""
"The mount IDs in I</proc/self/mountinfo> can be reused as filesystems are "
"unmounted and mounted.  Therefore, the mount ID returned by "
"B<name_to_handle_at>()  (in I<*mount_id>)  should not be treated as a "
"persistent identifier for the corresponding mounted filesystem.  However, an "
"application can use the information in the I<mountinfo> record that "
"corresponds to the mount ID to derive a persistent identifier."
msgstr ""
"I</proc/self/mountinfo> のマウント ID は、 ファイルシステムのアンマウント、マ"
"ウントが行われるに連れて再利用されることがある。 したがって、 "
"B<name_to_handle_at>() (の I<*mount_id>) で返されたマウント ID は対応するマウ"
"ントされたファイルシステムを表す永続的な ID と考えるべきではない。 ただし、 "
"アプリケーションは、 マウント ID に対応する  I<mountinfo> レコードの情報を使"
"うことで、 永続的な ID を得ることができる。"

#.  e.g., http://stackoverflow.com/questions/6748429/using-libblkid-to-find-uuid-of-a-partition
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:470
msgid ""
"For example, one can use the device name in the fifth field of the "
"I<mountinfo> record to search for the corresponding device UUID via the "
"symbolic links in I</dev/disks/by-uuid>.  (A more comfortable way of "
"obtaining the UUID is to use the B<libblkid>(3)  library.)  That process can "
"then be reversed, using the UUID to look up the device name, and then "
"obtaining the corresponding mount point, in order to produce the I<mount_fd> "
"argument used by B<open_by_handle_at>()."
msgstr ""
"例えば、 I<mountinfo> レコードの 5 番目のフィールドのデバイス名を使って、 I</"
"dev/disks/by-uuid> のシンボリックリンク経由で対応するデバイス UUID を検索でき"
"る。 (UUID を取得するもっと便利な方法は B<libblkid>(3) ライブラリを使用するこ"
"とである。) そのプロセスは、逆に、 この UUID を使ってデバイス名を検索し、 対"
"応するマウントポイントを取得することで、 B<open_by_handle_at>() で使用する "
"I<mount_fd> 引数を生成することができる。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:482
msgid ""
"The two programs below demonstrate the use of B<name_to_handle_at>()  and "
"B<open_by_handle_at>().  The first program (I<t_name_to_handle_at.c>)  uses "
"B<name_to_handle_at>()  to obtain the file handle and mount ID for the file "
"specified in its command-line argument; the handle and mount ID are written "
"to standard output."
msgstr ""
"以下の 2 つのプログラムは B<name_to_handle_at>() と B<open_by_handle_at>() の"
"使用例を示したものである。 最初のプログラム (I<t_name_to_handle_at.c>) は "
"B<name_to_handle_at>() を使用して、 コマンドライン引数で指定されたファイル"
"に対応するファイルハンドルとマウント ID を取得する。 ハンドルとマウント ID は"
"標準出力に出力される。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:502
msgid ""
"The second program (I<t_open_by_handle_at.c>)  reads a mount ID and file "
"handle from standard input.  The program then employs "
"B<open_by_handle_at>()  to open the file using that handle.  If an optional "
"command-line argument is supplied, then the I<mount_fd> argument for "
"B<open_by_handle_at>()  is obtained by opening the directory named in that "
"argument.  Otherwise, I<mount_fd> is obtained by scanning I</proc/self/"
"mountinfo> to find a record whose mount ID matches the mount ID read from "
"standard input, and the mount directory specified in that record is opened.  "
"(These programs do not deal with the fact that mount IDs are not persistent.)"
msgstr ""
"2 つ目のプログラム (I<t_open_by_handle_at.c>) は、 標準入力からマウント ID と"
"ファイルハンドルを読み込む。 それから、 B<open_by_handle_at>() を利用して、 "
"そのハンドルを使ってファイルをオープンする。 追加のコマンドライン引数が指定"
"された場合は、 B<open_by_handle_at>() の I<mount_fd> 引数は、 この引数で"
"渡された名前のディレクトリをオープンして取得する。 それ以外の場合、 I</proc/"
"self/mountinfo> からスキャンして標準入力から読み込んだマウント ID に一致する"
"マウント ID を検索し、 そのレコードで指定されているマウントディレクトリをオー"
"プンして、 I<mount_fd> を入手する。 (これらのプログラムではマウント ID が永続"
"的ではない点についての対処は行わない。)"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:504
msgid "The following shell session demonstrates the use of these two programs:"
msgstr "以下のシェルセッションは、これら 2 つのプログラムの使用例である。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:514
#, no-wrap
msgid ""
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<./t_name_to_handle_at cecilia.txt E<gt> fh>\n"
"$ B<./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Operation not permitted\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>      # Need CAP_SYS_ADMIN\n"
"Read 31 bytes\n"
"$ B<rm cecilia.txt>\n"
msgstr ""
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<./t_name_to_handle_at cecilia.txt E<gt> fh>\n"
"$ B<./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Operation not permitted\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>      # Need CAP_SYS_ADMIN\n"
"Read 31 bytes\n"
"$ B<rm cecilia.txt>\n"

#.  Christoph Hellwig: That's why the file handles contain a generation
#.  counter that gets incremented in this case.
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:525
msgid ""
"Now we delete and (quickly) re-create the file so that it has the same "
"content and (by chance) the same inode.  Nevertheless, "
"B<open_by_handle_at>()  recognizes that the original file referred to by the "
"file handle no longer exists."
msgstr ""
"ここで、 ファイルを削除し (すぐに) 再作成する。 同じ内容で (運がよければ) 同"
"じ inode になる。 この場合でも、 B<open_by_handle_at>() はこのファイルハンド"
"ルが参照する元のファイルがすでに存在しないことを認識する。"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:536
#, no-wrap
msgid ""
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Display inode number\n"
"4072121\n"
"$ B<rm cecilia.txt>\n"
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Check inode number\n"
"4072121\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Stale NFS file handle\n"
msgstr ""
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Display inode number\n"
"4072121\n"
"$ B<rm cecilia.txt>\n"
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Check inode number\n"
"4072121\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Stale NFS file handle\n"

#. type: SS
#: build/C/man2/open_by_handle_at.2:538
#, no-wrap
msgid "Program source: t_name_to_handle_at.c"
msgstr "プログラムのソース: t_name_to_handle_at.c"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:550
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:553 build/C/man2/open_by_handle_at.2:626
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:560
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fhsize, flags, dirfd;\n"
"    char *pathname;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fhsize, flags, dirfd;\n"
"    char *pathname;\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:565
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s pathname\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s pathname\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:567
#, no-wrap
msgid "    pathname = argv[1];\n"
msgstr "    pathname = argv[1];\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:569
#, no-wrap
msgid "    /* Allocate file_handle structure */\n"
msgstr "    /* file_handle 構造体を確保する */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:574
#, no-wrap
msgid ""
"    fhsize = sizeof(*fhp);\n"
"    fhp = malloc(fhsize);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""
"    fhsize = sizeof(*fhp);\n"
"    fhp = malloc(fhsize);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:577
#, no-wrap
msgid ""
"    /* Make an initial call to name_to_handle_at() to discover\n"
"       the size required for file handle */\n"
msgstr ""
"    /* name_to_handle_at() を最初に呼び出して\n"
"       ファイルハンドルに必要なサイズを入手する */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:586
#, no-wrap
msgid ""
"    dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */\n"
"    flags = 0;                  /* For name_to_handle_at() calls */\n"
"    fhp-E<gt>handle_bytes = 0;\n"
"    if (name_to_handle_at(dirfd, pathname, fhp,\n"
"                &mount_id, flags) != -1 || errno != EOVERFLOW) {\n"
"        fprintf(stderr, \"Unexpected result from name_to_handle_at()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */\n"
"    flags = 0;                  /* For name_to_handle_at() calls */\n"
"    fhp-E<gt>handle_bytes = 0;\n"
"    if (name_to_handle_at(dirfd, pathname, fhp,\n"
"                &mount_id, flags) != -1 || errno != EOVERFLOW) {\n"
"        fprintf(stderr, \"Unexpected result from name_to_handle_at()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:588
#, no-wrap
msgid "    /* Reallocate file_handle structure with correct size */\n"
msgstr "    /* file_handle 構造体を正しいサイズに確保し直す */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:593
#, no-wrap
msgid ""
"    fhsize = sizeof(*fhp) + fhp-E<gt>handle_bytes;\n"
"    fhp = realloc(fhp, fhsize);         /* Copies fhp-E<gt>handle_bytes */\n"
"    if (fhp == NULL)\n"
"        errExit(\"realloc\");\n"
msgstr ""
"    fhsize = sizeof(*fhp) + fhp-E<gt>handle_bytes;\n"
"    fhp = realloc(fhp, fhsize);         /* Copies fhp-E<gt>handle_bytes */\n"
"    if (fhp == NULL)\n"
"        errExit(\"realloc\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:595
#, no-wrap
msgid "    /* Get file handle from pathname supplied on command line */\n"
msgstr "    /* コマンドラインで指定されたパス名からファイルハンドルを取得 */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:598
#, no-wrap
msgid ""
"    if (name_to_handle_at(dirfd, pathname, fhp, &mount_id, flags) == -1)\n"
"        errExit(\"name_to_handle_at\");\n"
msgstr ""
"    if (name_to_handle_at(dirfd, pathname, fhp, &mount_id, flags) == -1)\n"
"        errExit(\"name_to_handle_at\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:601
#, no-wrap
msgid ""
"    /* Write mount ID, file handle size, and file handle to stdout,\n"
"       for later reuse by t_open_by_handle_at.c */\n"
msgstr ""
"    /* t_open_by_handle_at.c で後で再利用できるように、マウント ID、\n"
"       ファイルハンドルのサイズ、ファイルハンドルを標準出力に書き出す */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:607
#, no-wrap
msgid ""
"    printf(\"%d\\en\", mount_id);\n"
"    printf(\"%u %d   \", fhp-E<gt>handle_bytes, fhp-E<gt>handle_type);\n"
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        printf(\" %02x\", fhp-E<gt>f_handle[j]);\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"%d\\en\", mount_id);\n"
"    printf(\"%u %d   \", fhp-E<gt>handle_bytes, fhp-E<gt>handle_type);\n"
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        printf(\" %02x\", fhp-E<gt>f_handle[j]);\n"
"    printf(\"\\en\");\n"

#. type: SS
#: build/C/man2/open_by_handle_at.2:611
#, no-wrap
msgid "Program source: t_open_by_handle_at.c"
msgstr "プログラムのソース: t_open_by_handle_at.c"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:623
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:632
#, no-wrap
msgid ""
"/* Scan /proc/self/mountinfo to find the line whose mount ID matches\n"
"   \\(aqmount_id\\(aq. (An easier way to do this is to install and use the\n"
"   \\(aqlibmount\\(aq library provided by the \\(aqutil-linux\\(aq project.)\n"
"   Open the corresponding mount path and return the resulting file\n"
"   descriptor. */\n"
msgstr ""
"/* /proc/self/mountinfo をスキャンして、マウント ID が \\(aqmount_id\\(aq に\n"
"   一致する行を探す。 (もっと簡単な方法は \\(aqutil-linux\\(aq プロジェクト\n"
"   が提供する \\(aqlibmount\\(aq ライブラリをインストールして使うことである)\n"
"   対応するマウントパスをオープンし、得られたファイルディスクリプターを返す。 */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:642
#, no-wrap
msgid ""
"static int\n"
"open_mount_path_by_id(int mount_id)\n"
"{\n"
"    char *linep;\n"
"    size_t lsize;\n"
"    char mount_path[PATH_MAX];\n"
"    int mi_mount_id, found;\n"
"    ssize_t nread;\n"
"    FILE *fp;\n"
msgstr ""
"static int\n"
"open_mount_path_by_id(int mount_id)\n"
"{\n"
"    char *linep;\n"
"    size_t lsize;\n"
"    char mount_path[PATH_MAX];\n"
"    int mi_mount_id, found;\n"
"    ssize_t nread;\n"
"    FILE *fp;\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:646
#, no-wrap
msgid ""
"    fp = fopen(\"/proc/self/mountinfo\", \"r\");\n"
"    if (fp == NULL)\n"
"        errExit(\"fopen\");\n"
msgstr ""
"    fp = fopen(\"/proc/self/mountinfo\", \"r\");\n"
"    if (fp == NULL)\n"
"        errExit(\"fopen\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:653
#, no-wrap
msgid ""
"    found = 0;\n"
"    linep = NULL;\n"
"    while (!found) {\n"
"        nread = getline(&linep, &lsize, fp);\n"
"        if (nread == -1)\n"
"            break;\n"
msgstr ""
"    found = 0;\n"
"    linep = NULL;\n"
"    while (!found) {\n"
"        nread = getline(&linep, &lsize, fp);\n"
"        if (nread == -1)\n"
"            break;\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:660
#, no-wrap
msgid ""
"        nread = sscanf(linep, \"%d %*d %*s %*s %s\",\n"
"                       &mi_mount_id, mount_path);\n"
"        if (nread != 2) {\n"
"            fprintf(stderr, \"Bad sscanf()\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        nread = sscanf(linep, \"%d %*d %*s %*s %s\",\n"
"                       &mi_mount_id, mount_path);\n"
"        if (nread != 2) {\n"
"            fprintf(stderr, \"Bad sscanf()\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:665
#, no-wrap
msgid ""
"        if (mi_mount_id == mount_id)\n"
"            found = 1;\n"
"    }\n"
"    free(linep);\n"
msgstr ""
"        if (mi_mount_id == mount_id)\n"
"            found = 1;\n"
"    }\n"
"    free(linep);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:672
#, no-wrap
msgid ""
"    if (!found) {\n"
"        fprintf(stderr, \"Could not find mount point\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (!found) {\n"
"        fprintf(stderr, \"Could not find mount point\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:675
#, no-wrap
msgid ""
"    return open(mount_path, O_RDONLY);\n"
"}\n"
msgstr ""
"    return open(mount_path, O_RDONLY);\n"
"}\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:686
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fd, mount_fd, handle_bytes;\n"
"    ssize_t nread;\n"
"    char buf[1000];\n"
"#define LINE_SIZE 100\n"
"    char line1[LINE_SIZE], line2[LINE_SIZE];\n"
"    char *nextp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fd, mount_fd, handle_bytes;\n"
"    ssize_t nread;\n"
"    char buf[1000];\n"
"#define LINE_SIZE 100\n"
"    char line1[LINE_SIZE], line2[LINE_SIZE];\n"
"    char *nextp;\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:691
#, no-wrap
msgid ""
"    if ((argc E<gt> 1 && strcmp(argv[1], \"--help\") == 0) || argc E<gt> 2) {\n"
"        fprintf(stderr, \"Usage: %s [mount-path]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((argc E<gt> 1 && strcmp(argv[1], \"--help\") == 0) || argc E<gt> 2) {\n"
"        fprintf(stderr, \"Usage: %s [mount-path]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:693
#, no-wrap
msgid "    /* Standard input contains mount ID and file handle information:\n"
msgstr "    /* マウント ID とファイルハンドル情報が入った標準入力:\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:697
#, no-wrap
msgid ""
"         Line 1: E<lt>mount_idE<gt>\n"
"         Line 2: E<lt>handle_bytesE<gt> E<lt>handle_typeE<gt>   E<lt>bytes of handle in hexE<gt>\n"
"    */\n"
msgstr ""
"         Line 1: E<lt>mount_idE<gt>\n"
"         Line 2: E<lt>handle_bytesE<gt> E<lt>handle_typeE<gt>   E<lt>bytes of handle in hexE<gt>\n"
"    */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:703
#, no-wrap
msgid ""
"    if ((fgets(line1, sizeof(line1), stdin) == NULL) ||\n"
"           (fgets(line2, sizeof(line2), stdin) == NULL)) {\n"
"        fprintf(stderr, \"Missing mount_id / file handle\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((fgets(line1, sizeof(line1), stdin) == NULL) ||\n"
"           (fgets(line2, sizeof(line2), stdin) == NULL)) {\n"
"        fprintf(stderr, \"Missing mount_id / file handle\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:705
#, no-wrap
msgid "    mount_id = atoi(line1);\n"
msgstr "    mount_id = atoi(line1);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:707
#, no-wrap
msgid "    handle_bytes = strtoul(line2, &nextp, 0);\n"
msgstr "    handle_bytes = strtoul(line2, &nextp, 0);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:709
#, no-wrap
msgid "    /* Given handle_bytes, we can now allocate file_handle structure */\n"
msgstr ""
"    /* handle_bytes があれば、\n"
"       file_handle 構造体をここで割り当てできる */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:713
#, no-wrap
msgid ""
"    fhp = malloc(sizeof(*fhp) + handle_bytes);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""
"    fhp = malloc(sizeof(*fhp) + handle_bytes);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:715
#, no-wrap
msgid "    fhp-E<gt>handle_bytes = handle_bytes;\n"
msgstr "    fhp-E<gt>handle_bytes = handle_bytes;\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:717
#, no-wrap
msgid "    fhp-E<gt>handle_type = strtoul(nextp, &nextp, 0);\n"
msgstr "    fhp-E<gt>handle_type = strtoul(nextp, &nextp, 0);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:720
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        fhp-E<gt>f_handle[j] = strtoul(nextp, &nextp, 16);\n"
msgstr ""
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        fhp-E<gt>f_handle[j] = strtoul(nextp, &nextp, 16);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:725
#, no-wrap
msgid ""
"    /* Obtain file descriptor for mount point, either by opening\n"
"       the pathname specified on the command line, or by scanning\n"
"       /proc/self/mounts to find a mount that matches the \\(aqmount_id\\(aq\n"
"       that we received from stdin. */\n"
msgstr ""
"    /* マウントポイントのファイルディスクリプターを取得する。\n"
"       取得は、コマンドラインで指定されたパス名をオープンするか、\n"
"       /proc/self/mounts をスキャンして標準入力から受け取った\n"
"       \\(aqmount_id\\(aq に一致するマウントを探すことで行う。 */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:730
#, no-wrap
msgid ""
"    if (argc E<gt> 1)\n"
"        mount_fd = open(argv[1], O_RDONLY);\n"
"    else\n"
"        mount_fd = open_mount_path_by_id(mount_id);\n"
msgstr ""
"    if (argc E<gt> 1)\n"
"        mount_fd = open(argv[1], O_RDONLY);\n"
"    else\n"
"        mount_fd = open_mount_path_by_id(mount_id);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:733
#, no-wrap
msgid ""
"    if (mount_fd == -1)\n"
"        errExit(\"opening mount fd\");\n"
msgstr ""
"    if (mount_fd == -1)\n"
"        errExit(\"opening mount fd\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:735
#, no-wrap
msgid "    /* Open file using handle and mount point */\n"
msgstr "    /* ハンドルとマウントポイントを使ってファイルをオープンする */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:739
#, no-wrap
msgid ""
"    fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);\n"
"    if (fd == -1)\n"
"        errExit(\"open_by_handle_at\");\n"
msgstr ""
"    fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);\n"
"    if (fd == -1)\n"
"        errExit(\"open_by_handle_at\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:741
#, no-wrap
msgid "    /* Try reading a few bytes from the file */\n"
msgstr "    /* そのファイルからバイトを読み出す */\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:745
#, no-wrap
msgid ""
"    nread = read(fd, buf, sizeof(buf));\n"
"    if (nread == -1)\n"
"        errExit(\"read\");\n"
msgstr ""
"    nread = read(fd, buf, sizeof(buf));\n"
"    if (nread == -1)\n"
"        errExit(\"read\");\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:747
#, no-wrap
msgid "    printf(\"Read %zd bytes\\en\", nread);\n"
msgstr "    printf(\"Read %zd bytes\\en\", nread);\n"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:757
msgid "B<open>(2), B<libblkid>(3), B<blkid>(8), B<findfs>(8), B<mount>(8)"
msgstr "B<open>(2), B<libblkid>(3), B<blkid>(8), B<findfs>(8), B<mount>(8)"

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:767
msgid ""
"The I<libblkid> and I<libmount> documentation in the latest I<util-linux> "
"release at E<.UR https://www.kernel.org/pub/linux/utils/util-linux/> E<.UE>"
msgstr ""
"E<.UR https://www.kernel.org/pub/linux/utils/util-linux/> E<.UE> で入手できる"
"最新の I<util-linux> リリースの I<libblkid> と I<libmount> のドキュメント。"

#. type: TH
#: build/C/man3/open_memstream.3:9
#, no-wrap
msgid "OPEN_MEMSTREAM"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:12
#, fuzzy
#| msgid "fmemopen, open_memstream, open_wmemstream - open memory as stream"
msgid "open_memstream, open_wmemstream - open a dynamic memory buffer stream"
msgstr ""
"fmemopen, open_memstream, open_wmemstream - メモリーをストリームとしてオープ"
"ンする"

#. type: Plain text
#: build/C/man3/open_memstream.3:17
#, no-wrap
msgid "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: build/C/man3/open_memstream.3:19 build/C/man3/unlocked_stdio.3:54
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/open_memstream.3:21
#, no-wrap
msgid "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: build/C/man3/open_memstream.3:30
msgid "B<open_memstream>(), B<open_wmemstream>():"
msgstr "B<open_memstream>(), B<open_wmemstream>():"

#. type: Plain text
#: build/C/man3/open_memstream.3:52
#, fuzzy
#| msgid ""
#| "The B<open_memstream>()  function opens a stream for writing to a "
#| "buffer.  The buffer is dynamically allocated (as with B<malloc>(3)), and "
#| "automatically grows as required.  After closing the stream, the caller "
#| "should B<free>(3)  this buffer."
msgid ""
"The B<open_memstream>()  function opens a stream for writing to a memory "
"buffer.  The function dynamically allocates the buffer, and the buffer "
"automatically grows as needed.  Initially, the buffer has a size of zero.  "
"After closing the stream, the caller should B<free>(3)  this buffer."
msgstr ""
"B<open_memstream>()  関数は、バッファーへの書き込み用にストリームをオープンす"
"る。 バッファーは (B<malloc>(3)  を使って) 動的に割り当てられ、必要に応じて自"
"動的に伸長する。 ストリームをクローズした後で、呼び出し元はこのバッファーを "
"B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/open_memstream.3:68
#, fuzzy
#| msgid ""
#| "When the stream is closed (B<fclose>(3))  or flushed (B<fflush>(3)), the "
#| "locations pointed to by I<ptr> and I<sizeloc> are updated to contain, "
#| "respectively, a pointer to the buffer and the current size of the "
#| "buffer.  These values remain valid only as long as the caller performs no "
#| "further output on the stream.  If further output is performed, then the "
#| "stream must again be flushed before trying to access these variables."
msgid ""
"The locations pointed to by I<ptr> and I<sizeloc> are used to report, "
"respectively, the current location and the size of the buffer.  The "
"locations referred to by these pointers are updated each time the stream is "
"flushed (B<fflush>(3))  and when the stream is closed (B<fclose>(3)).  These "
"values remain valid only as long as the caller performs no further output on "
"the stream.  If further output is performed, then the stream must again be "
"flushed before trying to access these values."
msgstr ""
"このストリームが クローズ (B<fclose>(3))  されたりフラッシュ (B<fflush>(3))  "
"された時に、 I<ptr> と I<sizeloc> の値はそれぞれバッファーへのポインターとそ"
"のサイズに更新される。 これらの値は、呼び出し元がそのストリームに新たな書き込"
"みを 行わない場合に限り有効である。 ストリームに書き込みを行った際には、これ"
"らの変数を参照する前に ストリームを再度フラッシュしなければならない。"

#. type: Plain text
#: build/C/man3/open_memstream.3:74
msgid ""
"A null byte is maintained at the end of the buffer.  This byte is I<not> "
"included in the size value stored at I<sizeloc>."
msgstr ""
"バッファー末尾のヌルバイトは保持される。 このヌルバイトは I<sizeloc> に格納さ"
"れるサイズには「含まれない」。"

#. type: Plain text
#: build/C/man3/open_memstream.3:85
#, fuzzy
#| msgid ""
#| "The stream's file position can be changed with B<fseek>(3)  or "
#| "B<fseeko>(3).  Moving the file position past the end of the data already "
#| "written fills the intervening space with zeros."
msgid ""
"The stream maintains the notion of a current position, which is initially "
"zero (the start of the buffer).  Each write operation implicitly adjusts the "
"buffer position.  The stream's buffer position can be explicitly changed "
"with B<fseek>(3)  or B<fseeko>(3).  Moving the buffer position past the end "
"of the data already written fills the intervening space with null characters."
msgstr ""
"ストリームのファイル位置は B<fseek>(3)  や B<fseeko>(3)  で変更できる。 すで"
"にデータが書き込まれた領域の末尾より先にファイル位置を動かすと、 その間の領域"
"は 0 で埋められる。"

#. type: Plain text
#: build/C/man3/open_memstream.3:91
msgid ""
"The B<open_wmemstream>()  is similar to B<open_memstream>(), but operates on "
"wide characters instead of bytes."
msgstr ""
"B<open_wmemstream>()  は B<open_memstream>()  と同様だが、バイトではなくワイ"
"ド文字に対して操作を行う点が異なる。"

#. type: Plain text
#: build/C/man3/open_memstream.3:102
msgid ""
"Upon successful completion, B<open_memstream>()  and B<open_wmemstream>()  "
"return a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set "
"to indicate the error."
msgstr "成功して終了した場合には、 B<open_memstream>(), B<open_wmemstream>()  は I<FILE> ポインターを返す。 失敗した場合は、 NULL を返し、 I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/open_memstream.3:107
msgid ""
"B<open_memstream>()  was already available in glibc 1.0.x.  "
"B<open_wmemstream>()  is available since glibc 2.4."
msgstr "B<open_memstream>() は glibc 1.0.x ですでに利用可能であった。 B<open_wmemstream>() は glibc 2.4 以降で利用可能である。"

#. type: tbl table
#: build/C/man3/open_memstream.3:117
#, no-wrap
msgid "B<open_memstream>(),\n"
msgstr "B<open_memstream>(),\n"

#. type: tbl table
#: build/C/man3/open_memstream.3:119
#, no-wrap
msgid "B<open_wmemstream>"
msgstr "B<open_wmemstream>"

#. type: Plain text
#: build/C/man3/open_memstream.3:126
msgid ""
"POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are "
"not widely available on other systems."
msgstr ""
"POSIX.1-2008.  これらの関数は POSIX.1-2001 では規定れていないが、 Linux 以外"
"のシステムで広く利用可能である。"

#. type: Plain text
#: build/C/man3/open_memstream.3:132
msgid ""
"There is no file descriptor associated with the file stream returned by "
"these functions (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""
"これらの関数が返すファイルストリームに対応するファイル ディスクリプターはな"
"い (つまり、返されたストリームに対して B<fileno>(3)  を呼び出すとエラーが返る"
"ことになる)。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=1996
#. type: Plain text
#: build/C/man3/open_memstream.3:139
msgid ""
"In glibc before version 2.7, seeking past the end of a stream created by "
"B<open_memstream>()  does not enlarge the buffer; instead the B<fseek>(3)  "
"call fails, returning -1."
msgstr ""
"バージョン 2.7 より前の glibc では、 B<open_memstream>()  で作成されたスト"
"リームの末尾より先にファイル位置を動かしても、 バッファーが伸長されず、 "
"B<fseek>(3)  が失敗し -1 が返る。"

#. type: Plain text
#: build/C/man3/open_memstream.3:142
msgid "See B<fmemopen>(3)."
msgstr "B<fmemopen>(3) 参照。"

#. type: Plain text
#: build/C/man3/open_memstream.3:146
msgid "B<fmemopen>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<fmemopen>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: build/C/man3/perror.3:31
#, no-wrap
msgid "PERROR"
msgstr "PERROR"

#. type: Plain text
#: build/C/man3/perror.3:34
msgid "perror - print a system error message"
msgstr "perror - システムエラーメッセージを出力する"

#. type: Plain text
#: build/C/man3/perror.3:38
msgid "B<void perror(const char *>I<s>B<);>"
msgstr "B<void perror(const char *>I<s>B<);>"

#. type: Plain text
#: build/C/man3/perror.3:40
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: build/C/man3/perror.3:42
msgid "B<const char * const >I<sys_errlist>B<[];>"
msgstr "B<const char * const >I<sys_errlist>B<[];>"

#. type: Plain text
#: build/C/man3/perror.3:44
msgid "B<int >I<sys_nerr>B<;>"
msgstr "B<int >I<sys_nerr>B<;>"

#. type: Plain text
#: build/C/man3/perror.3:46
msgid "B<int >I<errno>B<; >/* Not really declared this way; see errno(3) */"
msgstr "B<int >I<errno>B<; >/* 実際にこのように宣言されているわけではない。 errno(3) 参照 */"

#. type: Plain text
#: build/C/man3/perror.3:58
#, no-wrap
msgid ""
"I<sys_errlist>,\n"
"I<sys_nerr>:\n"
"    From glibc 2.19 to 2.31:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:63
msgid ""
"The B<perror>()  function produces a message on standard error describing "
"the last error encountered during a call to a system or library function."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:74
#, fuzzy
#| msgid ""
#| "The routine B<perror>()  produces a message on the standard error output, "
#| "describing the last error encountered during a call to a system or "
#| "library function.  First (if I<s> is not NULL and I<*s> is not a null "
#| "byte (\\(aq\\e0\\(aq)) the argument string I<s> is printed, followed by a "
#| "colon and a blank.  Then the message and a new-line."
msgid ""
"First (if I<s> is not NULL and I<*s> is not a null byte (\\(aq\\e0\\(aq)), "
"the argument string I<s> is printed, followed by a colon and a blank.  Then "
"an error message corresponding to the current value of I<errno> and a new-"
"line."
msgstr ""
"関数 B<perror>()  は、システムコールやライブラリ関数の呼び出しにおいて、最後"
"に発生した エラーに関する説明メッセージを生成し、標準エラー出力に出力する。 "
"(I<s> が NULL でなく、 I<*s> がヌルバイト (\\(aq\\e0\\(aq) でない場合には) 引"
"き数の文字列 I<s> がまず出力され、続いてコロン、空白が出力され、 それからメッ"
"セージと改行が出力される。"

#. type: Plain text
#: build/C/man3/perror.3:77
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:93
#, fuzzy
#| msgid ""
#| "The global error list I<sys_errlist>[] indexed by I<errno> can be used to "
#| "obtain the error message without the newline.  The largest message number "
#| "provided in the table is I<sys_nerr>-1.  Be careful when directly "
#| "accessing this list because new error values may not have been added to "
#| "I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays deprecated."
msgid ""
"The global error list I<sys_errlist>[], which can be indexed by I<errno>, "
"can be used to obtain the error message without the newline.  The largest "
"message number provided in the table is I<sys_nerr>-1.  Be careful when "
"directly accessing this list, because new error values may not have been "
"added to I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays "
"deprecated; use B<strerror>(3)  instead."
msgstr ""
"大域変数のエラーリスト I<sys_errlist>[] は I<errno> を添字とする配列で、こ"
"の\n"
"配列から改行無しのエラーメッセージが取得される。 テーブルでの最大のメッセー"
"ジ\n"
"番号は I<sys_nerr> -1 となる。 このテーブルを直接参照する際には注意するこ"
"と。\n"
"なぜなら、新しいエラー番号が I<sys_errlist>[] に追加済とは限らないからであ"
"る。\n"
"現在では、I<sys_errlist>[] の使用は非推奨となっている。"

#. type: Plain text
#: build/C/man3/perror.3:114
#, fuzzy
#| msgid ""
#| "When a system call fails, it usually returns -1 and sets the variable "
#| "I<errno> to a value describing what went wrong.  (These values can be "
#| "found in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The "
#| "function B<perror>()  serves to translate this error code into human-"
#| "readable form.  Note that I<errno> is undefined after a successful "
#| "library call: this call may well change this variable, even though it "
#| "succeeds, for example because it internally used some other library "
#| "function that failed.  Thus, if a failing call is not immediately "
#| "followed by a call to B<perror>(), the value of I<errno> should be saved."
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function "
"B<perror>()  serves to translate this error code into human-readable form.  "
"Note that I<errno> is undefined after a successful system call or library "
"function call: this call may well change this variable, even though it "
"succeeds, for example because it internally used some other library function "
"that failed.  Thus, if a failing call is not immediately followed by a call "
"to B<perror>(), the value of I<errno> should be saved."
msgstr ""
"システムコールが失敗した場合、通常、返り値として -1 が返り、 I<errno> にエ"
"ラーを識別する値が設定される (設定されるエラー番号は I<E<lt>errno.hE<gt>> に"
"記載されている)。 多くのライブラリ関数も同様の動作となる。 関数 B<perror>()  "
"は、このエラーコードの可読なメッセージへの変換を行う。 I<errno> は、ライブラ"
"リ呼び出しが成功した後には未定義であることに注意が必要である: その呼び出し自"
"身は成功したとしても、内部で呼び出した他のライブラリ関数が 失敗して、その結果"
"をこの変数に設定することがあるからだ。 よって、失敗した呼び出しの直後に "
"B<perror>()  を呼ばない場合には I<errno> の値を 保存しておかなければならな"
"い。"

#. type: Plain text
#: build/C/man3/perror.3:121
#, fuzzy
#| msgid ""
#| "The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
#| "I<E<lt>stdio.hE<gt>>."
msgid ""
"Since glibc version 2.32, the declarations of I<sys_errlist> and I<sys_nerr> "
"are no longer exposed by I<E<lt>stdio.hE<gt>>."
msgstr ""
"外部変数 I<sys_nerr> と I<sys_errlist> は glibc で定義されているが、 "
"I<E<lt>stdio.hE<gt>> に含まれている。"

#. type: tbl table
#: build/C/man3/perror.3:131
#, no-wrap
msgid "B<perror>()"
msgstr "B<perror>()"

#. type: tbl table
#: build/C/man3/perror.3:131
#, no-wrap
msgid "MT-Safe race:stderr"
msgstr "MT-Safe race:stderr"

#. type: Plain text
#: build/C/man3/perror.3:138
msgid "B<perror>(), I<errno>: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr "B<perror>(), I<errno>: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."

#. type: Plain text
#: build/C/man3/perror.3:144
#, fuzzy
#| msgid ""
#| "The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
#| "I<E<lt>stdio.hE<gt>>."
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> derive from BSD, but are not "
"specified in POSIX.1."
msgstr ""
"外部変数 I<sys_nerr> と I<sys_errlist> は glibc で定義されているが、 "
"I<E<lt>stdio.hE<gt>> に含まれている。"

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: build/C/man3/perror.3:159
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""
"外部変数 I<sys_nerr> と I<sys_errlist> は glibc で定義されているが、 "
"I<E<lt>stdio.hE<gt>> に含まれている。"

#. type: Plain text
#: build/C/man3/perror.3:164
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: Plain text
#: build/C/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr "pipe, pipe2 - パイプを生成する"

#. type: Plain text
#: build/C/man2/pipe.2:48
#, no-wrap
msgid ""
"/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */\n"
"B<struct fd_pair {>\n"
"B<long fd[2];>\n"
"B<};>\n"
"B<struct fd_pair pipe();>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:51
#, fuzzy, no-wrap
#| msgid "B<int pipe(int >I<pipefd>B<[2]);>\n"
msgid ""
"/* On all other architectures */\n"
"B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr "B<int pipe(int >I<pipefd>B<[2]);>\n"

#. type: Plain text
#: build/C/man2/pipe.2:55
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* O_* 定数の定義の取得 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pipe.2:57
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/pipe.2:73
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""
"B<pipe>()  はパイプを生成する。 パイプは、プロセス間通信に使用できる単方向の"
"データチャネルである。 配列 I<pipefd> は、パイプの両端を参照する二つのファイ"
"ルディスクリプターを 返すのに使用される。 I<pipefd[0]> がパイプの読み出し"
"側、 I<pipefd[1]> がパイプの書き込み側である。 パイプの書き込み側に書き込まれ"
"たデータは、 パイプの読み出し側から読み出されるまでカーネルでバッファーリング"
"される。 さらなる詳細は B<pipe>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/pipe.2:83
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""
"B<pipe2>()  は I<flags> が 0 の場合には B<pipe>()  と同じである。 I<flags> に"
"以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさせることがで"
"きる。"

#. type: TP
#: build/C/man2/pipe.2:83
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: build/C/man2/pipe.2:91
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""
"新しく生成される二つのファイルディスクリプターの close-on-exec "
"(B<FD_CLOEXEC>)  フラグをセットする。 このフラグが役に立つ理由については、 "
"B<open>(2)  の B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: TP
#: build/C/man2/pipe.2:91
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr "B<O_DIRECT> (Linux 3.4 以降)"

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
#: build/C/man2/pipe.2:101
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr ""
"「パケット」モードで入出力を行うパイプを作成する。 このパイプへの "
"B<write>(2) それぞれが別のパケットとして扱われ、 このパイプからの B<read>(2) "
"では一度に一つパケットが読み出される。 以下の点に注意すること。"

#. type: Plain text
#: build/C/man2/pipe.2:112
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in I<E<lt>limits."
"hE<gt>>."
msgstr ""
"B<PIPE_BUF> バイト (B<pipe>(7) 参照) より大きいデータを書き込んだ場合、複数の"
"パケットに分割される。\n"
"定数 B<PIPE_BUF> は I<E<lt>limits.hE<gt>> で定義されている。"

#. type: Plain text
#: build/C/man2/pipe.2:122
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in "
"the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr ""
"B<read>(2) で次のパケットよりも小さなバッファーサイズを指定した場合、要求され"
"たバイト数のデータが読み出され、そのパケットの超過分のバイトは破棄される。 可"
"能性のある最大サイズのパケットを読み出すには、B<PIPE_BUF> のバッファーサイズ"
"を指定すれば十分である (上の項目を参照)。"

#. type: Plain text
#: build/C/man2/pipe.2:127
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr ""
"長さ 0 のパケットはサポートされていない。 (バッファーサイズ 0 を指定した "
"B<read>(2) は何も行わず 0 を返す)。"

#. type: Plain text
#: build/C/man2/pipe.2:132
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr ""
"このフラグをサポートしていない古いカーネルでは、エラー B<EINVAL> が返る。これ"
"によりカーネルがサポートしていないことが分かる。"

#.  commit 0dbf5f20652108106cb822ad7662c786baaa03ff
#.  FIXME . But, it is not possible to specify O_DIRECT when opening a FIFO
#. type: Plain text
#: build/C/man2/pipe.2:140
msgid ""
"Since Linux 4.5, it is possible to change the B<O_DIRECT> setting of a pipe "
"file descriptor using B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:140
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: build/C/man2/pipe.2:149
#, fuzzy
#| msgid ""
#| "Set the B<O_NONBLOCK> file status flag on the two new open file "
#| "descriptions.  Using this flag saves extra calls to B<fcntl>(2)  to "
#| "achieve the same result."
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file descriptions "
"referred to by the new file descriptors.  Using this flag saves extra calls "
"to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成される二つのオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: Plain text
#: build/C/man2/pipe.2:156
#, fuzzy
#| msgid ""
#| "On success, zero is returned.  On error, -1 is returned, and I<errno> is "
#| "set appropriately."
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<pipefd> is left unchanged."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#.  http://austingroupbugs.net/view.php?id=467
#. type: Plain text
#: build/C/man2/pipe.2:170
msgid ""
"On Linux (and other systems), B<pipe>()  does not modify I<pipefd> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2.  The Linux-specific B<pipe2>()  system call likewise does "
"not modify I<pipefd> on failure."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:175
msgid "I<pipefd> is not valid."
msgstr "I<pipefd> が無効な値である。"

#. type: Plain text
#: build/C/man2/pipe.2:180
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr "(B<pipe2>())  I<flags> に無効な値が入っている。"

#. type: Plain text
#: build/C/man2/pipe.2:183 build/C/man3/tmpfile.3:70
#, fuzzy
#| msgid "The system limit on the total number of open files has been reached."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "オープンされているファイルの総数がシステムの制限に達している。"

#. type: Plain text
#: build/C/man2/pipe.2:191
msgid ""
"The user hard limit on memory that can be allocated for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:196
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"B<pipe2>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポート"
"はバージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/pipe.2:199
msgid "B<pipe>(): POSIX.1-2001, POSIX.1-2008."
msgstr " B<pipe>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/pipe.2:202
msgid "B<pipe2>()  is Linux-specific."
msgstr "B<pipe2>()  は Linux 固有である。"

#.  See http://math-atlas.sourceforge.net/devel/assembly/64.psabi.1.33.ps.Z
#.  for example, section 3.2.1 "Registers and the Stack Frame".
#. type: Plain text
#: build/C/man2/pipe.2:219
msgid ""
"The System V ABI on some architectures allows the use of more than one "
"register for returning multiple values; several architectures (namely, "
"Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64)  (ab)use this feature in "
"order to implement the B<pipe>()  system call in a functional manner: the "
"call doesn't take any arguments and returns a pair of file descriptors as "
"the return value on success.  The glibc B<pipe>()  wrapper function "
"transparently deals with this.  See B<syscall>(2)  for information regarding "
"registers used for storing second file descriptor."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/pipe.2:235
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the file "
"descriptors that it doesn't need for the pipe (see B<pipe>(7)).  The parent "
"then writes the string contained in the program's command-line argument to "
"the pipe, and the child reads this string a byte at a time from the pipe and "
"echoes it on standard output."
msgstr "以下のプログラムではパイプを生成し、その後 B<fork>(2)  で子プロセスを生成する。 子プロセスは同じパイプを参照するファイルディスクリプター集合のコピーを 継承する。 B<fork>(2)  の後、各プロセスはパイプ (B<pipe>(7)  を参照) に必要がなくなったファイルディスクリプターをクローズする。 親プロセスはプログラムのコマンドライン引数に含まれる 文字列をパイプへ書き込み、 子プロセスはこの文字列をパイプから 1 バイトずつ読み込んで標準出力にエコーする。"

#. type: Plain text
#: build/C/man2/pipe.2:243
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/pipe.2:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"

#. type: Plain text
#: build/C/man2/pipe.2:255
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:260
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:266
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:269
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""
"    if (cpid == 0) {    /* 子プロセスがパイプから読み込む */\n"
"        close(pipefd[1]);  /* 使用しない write 側はクローズする */\n"

#. type: Plain text
#: build/C/man2/pipe.2:272
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"

#. type: Plain text
#: build/C/man2/pipe.2:276
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/pipe.2:285
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"    } else {            /* 親プロセスは argv[1] をパイプへ書き込む */\n"
"        close(pipefd[0]);          /* 使用しない read 側はクローズする */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* 読み込み側が EOF に出会う */\n"
"        wait(NULL);                /* 子プロセスを待つ */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/pipe.2:296
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), "
"B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"
msgstr " B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"

#. type: TH
#: build/C/man3/popen.3:40
#, no-wrap
msgid "POPEN"
msgstr "POPEN"

#. type: Plain text
#: build/C/man3/popen.3:43
msgid "popen, pclose - pipe stream to or from a process"
msgstr "popen, pclose - プロセスとの入力/出力用のパイプストリーム"

#. type: Plain text
#: build/C/man3/popen.3:48
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/popen.3:50
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr "B<int pclose(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/popen.3:60
msgid "B<popen>(), B<pclose>():"
msgstr "B<popen>(), B<pclose>():"

#. type: Plain text
#: build/C/man3/popen.3:63
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man3/popen.3:74
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""
"B<popen>()  関数は、プロセスをオープンする。具体的には、 パイプを生成し、"
"フォークを行い、シェルを起動する。 定義から分かるように、パイプは一方向なの"
"で、 I<type> 引数には読み込みか書き込みのどちらか一方だけを指定できる (両方"
"は指定できない)。 生成されるストリームは、この指定に対応して、読み取り専用ま"
"たは 書き込み専用のいずれかとなる。"

#. type: Plain text
#: build/C/man3/popen.3:84
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell."
msgstr "I<command> 引数は、シェルのコマンドラインを含むヌル終端された文字列へのポインターである。 このコマンドは B<-c> フラグを用いて I</bin/sh> に渡される。 コマンドの解釈は (もし必要ならば) シェルによって行われる。"

#. type: Plain text
#: build/C/man3/popen.3:99
msgid ""
"The I<type> argument is a pointer to a null-terminated string which must "
"contain either the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq "
"for writing.  Since glibc 2.9, this argument can additionally include the "
"letter \\(aqe\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to "
"be set on the underlying file descriptor; see the description of the "
"B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr "I<type> 引数は、ヌル終端された文字列へのポインターで、 読み込みを示す文字 \\(aqr\\(aq か、書き込みを示す文字 \\(aqw\\(aq の どちらか一方を指定しなければならない。 glibc 2.9 以降では、この引数に文字 \\(aqe\\(aq を追加で指定できる。 文字 \\(aqe\\(aq を指定すると、 対応するファイルディスクリプターにおいて、 close-on-exec フラグ (B<FD_CLOEXEC>)  がセットされる。 これが役に立つ理由については、 B<open>(2)  の B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: Plain text
#: build/C/man3/popen.3:115
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than "
"B<fclose>(3).  Writing to such a stream writes to the standard input of the "
"command; the command's standard output is the same as that of the process "
"that called B<popen>(), unless this is altered by the command itself.  "
"Conversely, reading from the stream reads the command's standard output, and "
"the command's standard input is the same as that of the process that called "
"B<popen>()."
msgstr ""
"B<popen>()  からの返り値は、通常の標準 I/O ストリームと同じであるが、 "
"B<fclose>(3)  ではなく B<pclose>()  で閉じなくてはならないことだけが異なる。 "
"このストリームへ書き込んだ結果はコマンドの標準入力に書き込まれる。 そして、コ"
"マンドの標準出力は、 コマンドそのものが置き換わってしまわない限り、 "
"B<popen>()  を呼んだプロセスの標準出力と同じことになる。 逆に、 ストリームか"
"らの読み込みは、 そのコマンドの標準出力を読み込むことになる。 そして、そのコ"
"マンドの標準入力は B<popen>()  を呼んだプロセスの標準入力と同一である。"

#. type: Plain text
#: build/C/man3/popen.3:119
msgid "Note that output B<popen>()  streams are block buffered by default."
msgstr "デフォルトでは、 B<popen>() の出力ストリームは block buffered であることに注意すること。"

#. type: Plain text
#: build/C/man3/popen.3:125
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""
"B<pclose>()  関数は、(パイプに) 関連づけられたプロセスが終了するのを待ち、 "
"B<wait4>(2)  によって返されたコマンドの終了状態を返す。"

#. type: Plain text
#: build/C/man3/popen.3:135
#, fuzzy
#| msgid ""
#| "The B<popen>()  function returns NULL if the B<fork>(2)  or B<pipe>(2)  "
#| "calls fail, or if it cannot allocate memory."
msgid ""
"B<popen>(): on success, returns a pointer to an open stream that can be used "
"to read or write to the pipe; if the B<fork>(2)  or B<pipe>(2)  calls fail, "
"or if the function cannot allocate memory, NULL is returned."
msgstr ""
"B<popen>()  関数は、 B<fork>(2)  または B<pipe>(2)  呼び出しが失敗した場合"
"や、 メモリー割り当てができなかった場合、 NULL を返す。"

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: build/C/man3/popen.3:147
msgid ""
"B<pclose>(): on success, returns the exit status of the command; if "
"B<wait4>(2)  returns an error, or some other error is detected, -1 is "
"returned."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:151
msgid ""
"Both functions set I<errno> to an appropriate value in the case of an error."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:170
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""
"B<popen>()  関数は、メモリーアロケーションに失敗しても I<errno> をセットしな"
"い。 B<popen>()  が中で呼び出す B<fork>(2)  や B<pipe>(2)  が失敗した場合に"
"は、 I<errno> が適切にセットされる。 引数 I<type> が無効であり、この状態が"
"検知された場合には、 I<errno> が B<EINVAL> にセットされる。"

#. type: Plain text
#: build/C/man3/popen.3:177
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to B<ECHILD>."
msgstr ""
"B<pclose>()  が、子プロセスの状態を取得できなかった場合、 I<errno> が "
"B<ECHILD> にセットされる。"

#. type: tbl table
#: build/C/man3/popen.3:188
#, no-wrap
msgid ""
"B<popen>(),\n"
"B<pclose>()"
msgstr ""
"B<popen>(),\n"
"B<pclose>()"

#. type: Plain text
#: build/C/man3/popen.3:197
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr "I<type> に指定できる \\(aqe\\(aq は Linux での拡張である。"

#. type: Plain text
#: build/C/man3/popen.3:201
msgid "B<Note>: carefully read Caveats in B<system>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:214
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""
"読み込みのために開かれたコマンドの標準入力は B<popen>(), を呼んだプロセスと一"
"緒に、その読み取り位置を共有する。 そのため、もとのプロセスがバッファーリング"
"された読み取りを終了したら、 そのコマンドの入力位置は予想されたものには なっ"
"ていないかもしれない。 同様に、書き込みのために開かれたコマンドからの出力"
"は、 もとのプロセスの出力と混ざり合うことになるかもしれない。 後者は "
"B<popen>()  の前に B<fflush>(3)  を呼び出すことによって回避可能である。"

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: build/C/man3/popen.3:224
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""
"シェルの実行の失敗は、 シェルがコマンドの実行に失敗したことや、 コマンドがす"
"ぐに終了してしまったことと、区別がつかない。 唯一のヒントは終了状態が 127 に"
"なることである。"

#. type: Plain text
#: build/C/man3/popen.3:234
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"

#. type: TH
#: build/C/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr "PRINTF"

#. type: Plain text
#: build/C/man3/printf.3:38
msgid ""
"printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, "
"vsprintf, vsnprintf - formatted output conversion"
msgstr "printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, vsprintf, vsnprintf - 指定された書式に変換して出力を行う"

#. type: Plain text
#: build/C/man3/printf.3:47
#, no-wrap
msgid ""
"B<int printf(const char *>I<format>B<, ...);>\n"
"B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>\n"
"B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>\n"
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<int printf(const char *>I<format>B<, ...);>\n"
"B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>\n"
"B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>\n"
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: build/C/man3/printf.3:49 build/C/man3/scanf.3:64
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/printf.3:56
#, no-wrap
msgid ""
"B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""
"B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: build/C/man3/printf.3:66
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr "B<snprintf>(), B<vsnprintf>():"

#. type: Plain text
#: build/C/man3/printf.3:69
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man3/printf.3:73
msgid "B<dprintf>(), B<vdprintf>():"
msgstr "B<dprintf>(), B<vdprintf>():"

#. type: Plain text
#: build/C/man3/printf.3:109
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>(), and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""
"B<printf>()  関数グループは、以下で述べるように、 I<format> に従って出力を生"
"成するものである。 B<printf>()  と B<vprintf>()  は出力を I<stdout> (標準出力"
"ストリーム) に書き出す。 B<fprintf>()  と B<vfprintf>()  は出力を指定された出"
"力 I<stream> に書き出す。 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  は出力を文字列 I<str> に書き込む。"

#. type: Plain text
#: build/C/man3/printf.3:119
msgid ""
"The function B<dprintf>()  is the same as B<fprintf>()  except that it "
"outputs to a file descriptor, I<fd>, instead of to a I<stdio> stream."
msgstr "B<dprintf>() 関数は B<fprintf>(3) 関数と同じだが、 この関数は I<stdio> ストリームではなくファイルディスクリプター I<fd> に対して出力を行う点が異なる。"

#. type: Plain text
#: build/C/man3/printf.3:128
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""
"B<snprintf>()  と B<vsnprintf>()  は最大で I<size> バイトを I<str> に書き込"
"む (I<size> には文字列を終端するヌルバイト (\\(aq\\e0\\(aq) もを含まれる)。"

#. type: Plain text
#: build/C/man3/printf.3:154
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vdprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  are equivalent to the functions B<printf>(), B<fprintf>(), "
"B<dprintf>(), B<sprintf>(), B<snprintf>(), respectively, except that they "
"are called with a I<va_list> instead of a variable number of arguments.  "
"These functions do not call the I<va_end> macro.  Because they invoke the "
"I<va_arg> macro, the value of I<ap> is undefined after the call.  See "
"B<stdarg>(3)."
msgstr "B<vprintf>(), B<vfprintf>(), B<vdprintf>(), B<vsprintf>(), B<vsnprintf>()  の各関数はそれぞれ B<printf>(), B<fprintf>(), B<dprintf>(), B<sprintf>(), B<snprintf>(), の各関数と等価であり、可変数引数の代わりに I<va_list> を引数として呼び出される点だけが異なる。 これらの関数では I<va_end> マクロは呼び出されない。 これらの関数は I<va_arg> を呼び出すので、呼び出し後の I<ap> の値は未定義である。 B<stdarg>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/printf.3:161
msgid ""
"All of these functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr "これらの関数はすべて I<format> 文字列の制御に従って出力を書き出す。 I<format> 文字列は、これに続く引数 (または B<stdarg>(3)  の可変長引数機構を使ってアクセスできる引数)  をどのように変換して出力するかを指定する。"

#. type: Plain text
#: build/C/man3/printf.3:172
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""
"C99 と POSIX.1-2001 では、 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  の呼び出しで、範囲が重複するオブジェクト間でコピーが発生する"
"場合の 結果は不定であると規定されている (例えば、出力先の文字列と入力された "
"引数の一つが同じバッファーを参照している場合などである)。 「注意」の節を参"
"照。"

#. type: SS
#: build/C/man3/printf.3:172
#, no-wrap
msgid "Format of the format string"
msgstr "フォーマット文字列のフォーマット"

#. type: Plain text
#: build/C/man3/printf.3:194
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""
"フォーマット文字列は文字の列で、 (もしあるなら) 初期シフト状態で始まり、初期"
"シフト状態で終わる。 フォーマット用の文字列は 0 個以上の命令 (directives) に"
"よって構成される。 命令には、通常文字と変換指定 (conversion specifications) "
"がある。 通常文字は B<%> 以外の文字で、出力ストリームにそのままコピーされ"
"る。 変換指定は、それぞれが 0 個以上の引数を取る。 各変換指定は文字 B<%> で"
"始まり、 I<変換指定子 (conversion specifier)> で終わる。 B<%> と変換指定子の"
"間には、0 個以上の I<フラグ 、> 最小 I<フィールド幅 、> I<精度 、> I<長さ修飾"
"子> を (この順序で) 置くことができる。"

#. type: Plain text
#: build/C/man3/printf.3:211
#, fuzzy
#| msgid ""
#| "The arguments must correspond properly (after type promotion) with the "
#| "conversion specifier.  By default, the arguments are used in the order "
#| "given, where each \\(aq*\\(aq and each conversion specifier asks for the "
#| "next argument (and it is an error if insufficiently many arguments are "
#| "given).  One can also specify explicitly which argument is taken, at each "
#| "place where an argument is required, by writing \"%m$\" instead of \\(aq%"
#| "\\(aq and \"*m$\" instead of \\(aq*\\(aq, where the decimal integer m "
#| "denotes the position in the argument list of the desired argument, "
#| "indexed starting from 1.  Thus,"
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq (see I<Field width> and I<Precision> below) "
"and each conversion specifier asks for the next argument (and it is an error "
"if insufficiently many arguments are given).  One can also specify "
"explicitly which argument is taken, at each place where an argument is "
"required, by writing \"%m$\" instead of \\(aq%\\(aq and \"*m$\" instead of "
"\\(aq*\\(aq, where the decimal integer I<m> denotes the position in the "
"argument list of the desired argument, indexed starting from 1.  Thus,"
msgstr ""
"引数は (型の格上げの後は) 変換指定子が表す型と正確に対応しなければならな"
"い。 デフォルトでは、\\(aq*\\(aq や変換指定子が出てくる毎に次の引数を要求さ"
"れ、 引数は指定された順序で使用されていく (指定された引数の個数が不十分な"
"らエラーとなる)。 また、引数が必要な箇所で \\(aq%\\(aq の代わりに \"%m$"
"\"、 \\(aq*\\(aqの代わりに \"*m$\" と書くことで、 明示的にどの引数を使用す"
"るかを指定することもできる。 ここで 10進の整数 m は希望の引数の引数リスト"
"での位置を示す (最初の引数の番号が 1 である)。 従って、"

#. type: Plain text
#: build/C/man3/printf.3:215
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr "printf(\"%*d\", width, num);\n"

#. type: Plain text
#: build/C/man3/printf.3:219
msgid "and"
msgstr "と"

#. type: Plain text
#: build/C/man3/printf.3:223
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr "printf(\"%2$*1$d\", width, num);\n"

#. type: Plain text
#: build/C/man3/printf.3:239
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using \\(aq$"
"\\(aq is used, it must be used throughout for all conversions taking an "
"argument and all width and precision arguments, but it may be mixed with \"%%"
"\" formats, which do not consume an argument.  There may be no gaps in the "
"numbers of arguments specified using \\(aq$\\(aq; for example, if arguments "
"1 and 3 are specified, argument 2 must also be specified somewhere in the "
"format string."
msgstr ""
"は等価である。 二番目の書き方では同じ引数を繰り返し参照することができる。 "
"C99 標準には、 Single UNIX Specification 由来の \\(aq$\\(aq を使った書き方は"
"含まれていない。 \\(aq$\\(aq を使ったスタイルを使うと、引数を取る変換及び幅"
"と精度の引数を 全てこのスタイルで指定しなければならないが、 引数を消費し"
"ない \"%%\" フォーマットと混ざっているかもしれない。 \\(aq$\\(aq で指定される"
"引数の番号に空きがあってはならない。 例えば、もし引数 1 と 3 が指定される"
"と、引数 2 もフォーマット文字列のどこかで 指定されなければならない。"

#. type: Plain text
#: build/C/man3/printf.3:251
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  (See B<setlocale>(3).)  The POSIX "
"locale uses \\(aq.\\(aq as radix character, and does not have a grouping "
"character.  Thus,"
msgstr "数値変換には小数点や 1000 単位の区切り文字を使うものもある。 実際にどの文字を使うかはロケールの B<LC_NUMERIC> による (B<setlocale>(3) 参照)。 POSIX ロケールでは小数点に \\(aq.\\(aq を用い、 区切り文字は使わない。 従って、"

#. type: Plain text
#: build/C/man3/printf.3:255
#, no-wrap
msgid "printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr "printf(\"%\\(aq.2f\", 1234567.89);\n"

#. type: Plain text
#: build/C/man3/printf.3:260
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""
"は、 POSIX ロケールでは \"1234567.89\" 、 nl_NL ロケールでは "
"\"1234567,89\"、 da_DK ロケールでは \"1.234.567,89\" となる。"

#. type: SS
#: build/C/man3/printf.3:260
#, no-wrap
msgid "Flag characters"
msgstr "フラグ文字"

#. type: Plain text
#: build/C/man3/printf.3:262
msgid "The character % is followed by zero or more of the following flags:"
msgstr "% 文字の後ろには 0 個以上のフラグ文字が続く。"

#. type: TP
#: build/C/man3/printf.3:262
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: build/C/man3/printf.3:296
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""
"値は「別の形式」に変換される。 B<o> 変換の場合、(先頭文字が 0 になっていない"
"場合に先頭に 0 を追加することで)  出力文字列の最初の文字を 0 にする。 B<x> "
"と B<X> 変換の場合、数値が 0 でないときには文字列 \"0x\" (B<X> 変換の場合に"
"は \"0X\") が前に付与される。 B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, B<G> "
"変換では、 小数点に続く数字がなくても、 出力には常に小数点が含まれる (通常"
"は、小数点の後に数字が続く場合にのみ、 小数点が表示される)。 B<g> と B<G> 変"
"換の場合、他の変換とは異なり、末尾のゼロが変換結果から削除されない。 その他の"
"変換では、結果は未定義である。"

#. type: TP
#: build/C/man3/printf.3:296
#, no-wrap
msgid "B<\\&0>"
msgstr "B<\\&0>"

#. type: Plain text
#: build/C/man3/printf.3:336
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""
"値をゼロで埋める。 B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<a>, B<A>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, B<G> 変換では、変換した値の左側を空白文字の代わりにゼ"
"ロで埋める。 B<\\&0> と B<-> が両方とも指定された場合は、 B<\\&0> フラグは無"
"視される。 精度が数値変換 (B<d>, B<i>, B<o>, B<u>, B<x>, B<X>)  と同時に指定"
"された場合には、 B<\\&0> フラグは無視される。 その他の変換では、動作は未定義"
"である。"

#. type: TP
#: build/C/man3/printf.3:336
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: build/C/man3/printf.3:347
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  The converted value is padded on the right "
"with blanks, rather than on the left with blanks or zeros.  A B<-> overrides "
"a B<\\&0> if both are given."
msgstr ""
"変換値をフィールド境界で左揃えにする (デフォルトは右揃えである)。 変換された"
"値は 左側ではなく右側を空白文字やゼロで埋められる。 B<-> と B<\\&0> の両方が"
"指定された場合には、 B<-> が優先される。"

#. type: TP
#: build/C/man3/printf.3:347
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr "B<' '>"

#. type: Plain text
#: build/C/man3/printf.3:351
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(1個の半角スペース)  符号付き変換で生成された正の数字の前に空白 (または空文字"
"列) が置かれる。"

#. type: TP
#: build/C/man3/printf.3:351
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: build/C/man3/printf.3:359
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default, a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""
"符号付き変換によって出力される数字の前に、常に符号 (+ か -) が置かれる。 デ"
"フォルトでは、符号は負の数字の場合のみ付与される。 B<+> と半角スペースの 両方"
"が使われている場合には、 B<+> が優先される。"

#. type: Plain text
#: build/C/man3/printf.3:362
msgid ""
"The five flag characters above are defined in the C99 standard.  The Single "
"UNIX Specification specifies one further flag character."
msgstr ""
"上記の 5 つのフラグは C99 標準で定義されている。 Single UNIX Specified では、"
"さらにもう一つフラグ文字が規定されている。"

#. type: TP
#: build/C/man3/printf.3:362
#, no-wrap
msgid "B<\\(aq>"
msgstr "B<\\(aq>"

#. type: Plain text
#: build/C/man3/printf.3:381
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  (See B<setlocale>(3).)  Note that many versions "
"of B<gcc>(1)  cannot parse this option and will issue a warning.  (SUSv2 did "
"not include I<%\\(aqF>, but SUSv3 added it.)"
msgstr "10進数変換 (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  において、ロケール情報に指定があれば 1000 単位の区切り文字を出力する (B<setlocale>(3) 参照)。 B<gcc>(1)  の多くのバージョンは、このオプションを解釈することができず、 警告を出力することに注意せよ。 (I<%\\(aqF> は SUSv2 には含まれていなかったが、 SUSv3 で追加された。"

#. type: Plain text
#: build/C/man3/printf.3:383
msgid "glibc 2.2 adds one further flag character."
msgstr "glibc 2.2 では、さらに一つフラグ文字が追加されている。"

#. type: TP
#: build/C/man3/printf.3:383
#, no-wrap
msgid "B<I>"
msgstr "B<I>"

#.  outdigits keyword in locale file
#. type: Plain text
#: build/C/man3/printf.3:393
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""
"10進整数変換 (B<i>, B<d>, B<u>)  において、ロケールの代替出力数字があれば、そ"
"れを用いて出力する。 例えば、 glibc 2.2.3 以降では、ペルシア (\"fa_IR\") ロ"
"ケールで アラビア数字 (Arabic-Indic digits) を出力できる。"

#. type: SS
#: build/C/man3/printf.3:393
#, no-wrap
msgid "Field width"
msgstr "フィールド幅"

#. type: Plain text
#: build/C/man3/printf.3:409
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""
"最小のフィールド幅を指定する 10進数の数値文字列 (文字列の最初の文字は ゼロ以"
"外)。本項目はオプションである。 変換された値の文字数がフィールド長よりも少な"
"い場合、 フィールドの左側をスペースで埋める (左揃えのフラグがある場合は右側を"
"埋める)。 10進数の文字列の代わりに \"*\" や \"*m$\" (I<m> は 10進整数) を書く"
"こともできる。 \"*\" と \"*m$\" はそれぞれ、次の引数と I<m> 番目の引数を"
"フィールド幅として 使うことを指定する (これらの引数は I<int> 型でなければな"
"らない)。 フィールド幅に負の数が指定された場合は、 \\(aq-\\(aq フラグと正の数"
"のフィールド幅として扱われる。 フィールド幅が小さかったり指定がなかったりして"
"も、フィールドが切り詰められる ことはない。もし変換結果がフィールド幅よりも広"
"かった場合、 フィールドは変換結果が入る幅に広げられる。"

#. type: SS
#: build/C/man3/printf.3:409
#, no-wrap
msgid "Precision"
msgstr "精度"

#. type: Plain text
#: build/C/man3/printf.3:446
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that the "
"precision is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, the precision is taken to be zero.  A negative precision "
"is taken as if the precision were omitted.  This gives the minimum number of "
"digits to appear for B<d>, B<i>, B<o>, B<u>, B<x>, and B<X> conversions, the "
"number of digits to appear after the radix character for B<a>, B<A>, B<e>, "
"B<E>, B<f>, and B<F> conversions, the maximum number of significant digits "
"for B<g> and B<G> conversions, or the maximum number of characters to be "
"printed from a string for B<s> and B<S> conversions."
msgstr "オプションである精度は、ピリオド (\\(aq.\\(aq) とそれに続く10進数という 形式で指定する (10進数はオプション) 。 10進数の文字列の代わりに \"*\" や \"*m$\" (I<m> は 10 進整数)を書くこともできる。 \"*\" と \"*m$\" はそれぞれ、次の引数と I<m> 番目の引数を精度として 使うことを指定する (これらの引数は I<int> 型でなければならない)。 精度として \\(aq.\\(aq だけが指定された場合、 精度はゼロとみなされる。 精度が負の数だった場合、 精度は指定されなかったものとみなされる。 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変換では、表示される最小の桁数を指定する。 B<a>, B<A>, B<e>, B<E>, B<f>, B<F> 変換では、小数点以下に表示される数字の桁数を指定する。 B<g> と B<G> 変換では、有効数字の最大桁数を指定する。 B<s> と B<S> 変換では、文字列から出力される最大文字数を指定する。"

#. type: SS
#: build/C/man3/printf.3:446
#, no-wrap
msgid "Length modifier"
msgstr "長さ修飾子"

#. type: Plain text
#: build/C/man3/printf.3:456
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""
"「整数変換」とは、 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変換のことである。"

#. type: TP
#: build/C/man3/printf.3:456 build/C/man3/scanf.3:301
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: build/C/man3/printf.3:467
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""
"整数変換に対応する引数が I<signed char> か I<unsigned char> で、 B<n> 変換"
"に対応する引数が I<signed char> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:467 build/C/man3/scanf.3:291
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: build/C/man3/printf.3:478
msgid ""
"A following integer conversion corresponds to a I<short> or I<unsigned "
"short> argument, or a following B<n> conversion corresponds to a pointer to "
"a I<short> argument."
msgstr "整数変換に対応する引数が I<short> か I<unsigned short> で、 B<n> 変換に対応する引数が I<short> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:478 build/C/man3/scanf.3:318
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#. type: Plain text
#: build/C/man3/printf.3:497
msgid ""
"(ell) A following integer conversion corresponds to a I<long> or I<unsigned "
"long> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<long> argument, or a following B<c> conversion corresponds to a I<wint_t> "
"argument, or a following B<s> conversion corresponds to a pointer to "
"I<wchar_t> argument."
msgstr "各変換に対応する引数が、 整数変換では I<long> か I<unsigned long>、 B<n> 変換では I<long> へのポインター、 B<c> 変換では I<wint_t>、 B<s> 変換では I<wchar_t> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:497
#, no-wrap
msgid "B<ll>"
msgstr "B<ll> (エルエル)"

#. type: Plain text
#: build/C/man3/printf.3:509
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long> or "
"I<unsigned long long> argument, or a following B<n> conversion corresponds "
"to a pointer to a I<long long> argument."
msgstr "整数変換に対応する引数が I<long long> か I<unsigned long long> で、 B<n> 変換に対応する引数が I<long long> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:509 build/C/man3/scanf.3:361
#, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#: build/C/man3/printf.3:515
msgid ""
"A synonym for B<ll>.  This is a nonstandard extension, derived from BSD; "
"avoid its use in new code."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:515 build/C/man3/scanf.3:345
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#. type: Plain text
#: build/C/man3/printf.3:531
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr "B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, B<G> 変換に対応する引数が I<long double> であることを示す。 (C99 では %LF を使うことを認めているが、SUSv2 では認められていない。)"

#. type: TP
#: build/C/man3/printf.3:531 build/C/man3/scanf.3:309
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: build/C/man3/printf.3:542
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument, or a following B<n> conversion corresponds to a pointer to an "
"I<intmax_t> argument."
msgstr ""
"整数変換に対応する引数が I<intmax_t> か I<uintmax_t> で、 B<n> 変換に対応す"
"る引数が I<intmax_t> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:542 build/C/man3/scanf.3:373
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#. type: Plain text
#: build/C/man3/printf.3:553
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument, or a following B<n> conversion corresponds to a pointer to a "
"I<size_t> argument."
msgstr ""
"整数変換に対応する引数が I<size_t> か I<ssize_t> で、 B<n> 変換に対応する引"
"数が I<size_t> へのポインターであることを示す。"

#. type: TP
#: build/C/man3/printf.3:553
#, no-wrap
msgid "B<Z>"
msgstr "B<Z>"

#. type: Plain text
#: build/C/man3/printf.3:560
msgid ""
"A nonstandard synonym for B<z> that predates the appearance of B<z>.  Do not "
"use in new code."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:560 build/C/man3/scanf.3:366
#, no-wrap
msgid "B<t>"
msgstr "B<t>"

#. type: Plain text
#: build/C/man3/printf.3:569
msgid ""
"A following integer conversion corresponds to a I<ptrdiff_t> argument, or a "
"following B<n> conversion corresponds to a pointer to a I<ptrdiff_t> "
"argument."
msgstr ""
"整数変換に対応する引数が I<ptrdiff_t> で、 B<n> 変換に対応する引数が "
"I<ptrdiff_t> へのポインターであることを示す。"

#. type: Plain text
#: build/C/man3/printf.3:600
#, fuzzy
#| msgid ""
#| "SUSv3 specifies all of the above.  SUSv2 specified only the length "
#| "modifiers B<h> (in B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> "
#| "(in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, B<ls>)  and B<L> (in "
#| "B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgid ""
"SUSv3 specifies all of the above, except for those modifiers explicitly "
"noted as being nonstandard extensions.  SUSv2 specified only the length "
"modifiers B<h> (in B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in "
"B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, "
"B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""
"SUSv3 では上記のすべてが規定されている。 SUSv2 で規定されていたのは、 長さ修"
"飾子 B<h> (B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>), B<l> (B<ld>, B<li>, "
"B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, B<ls>), B<L> (B<Le>, B<LE>, B<Lf>, B<Lg>, "
"B<LG>)  だけであった。"

#. type: Plain text
#: build/C/man3/printf.3:615
msgid ""
"As a nonstandard extension, the GNU implementations treats B<ll> and B<L> as "
"synonyms, so that one can, for example, write B<llg> (as a synonym for the "
"standards-compliant B<Lg>)  and B<Ld> (as a synonym for the standards "
"compliant B<lld>).  Such usage is nonportable."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:615
#, no-wrap
msgid "Conversion specifiers"
msgstr "変換指定子"

#. type: Plain text
#: build/C/man3/printf.3:618
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""
"適用される変換の型を指定する文字。 変換指定子とその意味は以下の通りである。"

#. type: TP
#: build/C/man3/printf.3:618
#, no-wrap
msgid "B<d>, B<i>"
msgstr "B<d>, B<i>"

#. type: Plain text
#: build/C/man3/printf.3:628
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""
"I<int> 引数を符号付き 10 進表記に変換する。 精度指定があれば、精度で指定し"
"た桁数は必ず出力される。変換後の値が 指定された桁数に足りない場合は、左側が "
"0 で埋められる。 デフォルトの精度は 1 である。 0 を表示しようとした時に、明示"
"的に精度として 0 が指定されていると、 出力は空文字列となる。"

#. type: TP
#: build/C/man3/printf.3:628
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr "B<o>, B<u>, B<x>, B<X>"

#. type: Plain text
#: build/C/man3/printf.3:655
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""
"I<unsigned int> 引数を、 符号なし8進数 (B<o>), 符号なし10進数 (B<u>), 符号"
"なし16進数 (B<x> と B<X>)  に変換する。 B<x> 変換では B<abcdef> が使用され、 "
"B<X> 変換では B<ABCDEF> が使用される。 精度指定があれば、精度で指定した桁数は"
"必ず出力される。変換後の値が 指定された桁数に足りない場合は、左側が 0 で埋め"
"られる。"

#. type: TP
#: build/C/man3/printf.3:655
#, no-wrap
msgid "B<e>, B<E>"
msgstr "B<e>, B<E>"

#. type: Plain text
#: build/C/man3/printf.3:675
#, fuzzy
#| msgid ""
#| "The I<double> argument is rounded and converted in the style [-]dB<\\&."
#| ">dddB<e>\\(+-dd where there is one digit before the decimal-point "
#| "character and the number of digits after it is equal to the precision; if "
#| "the precision is missing, it is taken as 6; if the precision is zero, no "
#| "decimal-point character appears.  An B<E> conversion uses the letter B<E> "
#| "(rather than B<e>)  to introduce the exponent.  The exponent always "
#| "contains at least two digits; if the value is zero, the exponent is 00."
msgid ""
"The I<double> argument is rounded and converted in the style [-]dB<\\&."
">dddB<e>\\(+-dd where there is one digit (which is nonzero if the argument "
"is nonzero)  before the decimal-point character and the number of digits "
"after it is equal to the precision; if the precision is missing, it is taken "
"as 6; if the precision is zero, no decimal-point character appears.  An B<E> "
"conversion uses the letter B<E> (rather than B<e>)  to introduce the "
"exponent.  The exponent always contains at least two digits; if the value is "
"zero, the exponent is 00."
msgstr ""
"I<double> 引数を丸めて [-]dB<\\&.>dddB<e>\\(+-dd の形に変換する。\n"
"小数点の前には一桁の数字があり、小数点以下の桁数は精度で指定された桁数\n"
"になる。精度は指定されなかった場合 6 とみなされる。 精度が 0 の場合には、\n"
"小数点以下は表示されない。B<E> 変換では、指数を表現するときに (B<e> で\n"
"はなく) B<E> が使われる。指数部分は少なくとも 2桁表示される。つまり、\n"
"指数の値が 0 の場合には、00 と表示される。"

#. type: TP
#: build/C/man3/printf.3:675
#, no-wrap
msgid "B<f>, B<F>"
msgstr "B<f>, B<F>"

#. type: Plain text
#: build/C/man3/printf.3:686
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no decimal-"
"point character appears.  If a decimal point appears, at least one digit "
"appears before it."
msgstr ""
"I<double> 引数を丸めて [-]dddB<\\&.>ddd の形の10進表現に変換する。 小数点の"
"後の桁数は、精度で指定された値となる。 精度が指定されていない場合には 6 とし"
"て扱われる。 精度として明示的に 0 が指定されたときには、小数点以下は表示され"
"ない。 小数点を表示する際には、小数点の前に少なくとも一桁は数字が表示される。"

#. type: Plain text
#: build/C/man3/printf.3:699
msgid ""
"(SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  SUSv3 adds a "
"specification for B<F>.  The C99 standard specifies \"[-]inf\" or "
"\"[-]infinity\" for infinity, and a string starting with \"nan\" for NaN, in "
"the case of B<f> conversion, and \"[-]INF\" or \"[-]INFINITY\" or \"NAN\" in "
"the case of B<F> conversion.)"
msgstr "(SUSv2 では、B<F> は規定されておらず、無限や NaN に関する文字列表現を行ってもよいことになっている。 SUSv3 では B<F> の規定が追加された。 C99 標準では、B<f> 変換では、無限は \"[-]inf\" か \"[-]infinity\" と表示し、 NaN は文字列の先頭に `nan' をつけて表示するように規定されている。 B<F> 変換の場合は \"[-]INF\", \"[-]INFINITY\", \"NAN\" と表示される。)"

#. type: TP
#: build/C/man3/printf.3:699
#, no-wrap
msgid "B<g>, B<G>"
msgstr "B<g>, B<G>"

#. type: Plain text
#: build/C/man3/printf.3:724
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""
"I<double> 引数を B<f> か B<e> (B<G> 変換の場合は B<F> か B<E>)  の形式に変"
"換する。 精度は表示する桁数を指定する。 精度が指定されない場合は、6桁とみなさ"
"れる。 精度が 0 の場合は、1桁とみなされる。 変換される値の指数が、 -4 より小"
"さいか、精度以上の場合に、 B<e> 形式が使用される。 変換された結果の小数部分の"
"末尾の 0 は削除される。小数点が表示されるのは、 小数点以下に数字が少なくとも"
"一つある場合にだけである。"

#. type: TP
#: build/C/man3/printf.3:724
#, no-wrap
msgid "B<a>, B<A>"
msgstr "B<a>, B<A>"

#. type: Plain text
#: build/C/man3/printf.3:751
#, fuzzy
#| msgid ""
#| "(C99; not in SUSv2, but added in SUSv3)  For B<a> conversion, the "
#| "I<double> argument is converted to hexadecimal notation (using the "
#| "letters abcdef)  in the style [-]B<0x>hB<\\&.>hhhhB<p>\\(+-; for B<A> "
#| "conversion the prefix B<0X>, the letters ABCDEF, and the exponent "
#| "separator B<P> is used.  There is one hexadecimal digit before the "
#| "decimal point, and the number of digits after it is equal to the "
#| "precision.  The default precision suffices for an exact representation of "
#| "the value if an exact representation in base 2 exists and otherwise is "
#| "sufficiently large to distinguish values of type I<double>.  The digit "
#| "before the decimal point is unspecified for nonnormalized numbers, and "
#| "nonzero but otherwise unspecified for normalized numbers."
msgid ""
"(C99; not in SUSv2, but added in SUSv3)  For B<a> conversion, the I<double> "
"argument is converted to hexadecimal notation (using the letters abcdef)  in "
"the style [-]B<0x>hB<\\&.>hhhhB<p>\\(+-d; for B<A> conversion the prefix "
"B<0X>, the letters ABCDEF, and the exponent separator B<P> is used.  There "
"is one hexadecimal digit before the decimal point, and the number of digits "
"after it is equal to the precision.  The default precision suffices for an "
"exact representation of the value if an exact representation in base 2 "
"exists and otherwise is sufficiently large to distinguish values of type "
"I<double>.  The digit before the decimal point is unspecified for "
"nonnormalized numbers, and nonzero but otherwise unspecified for normalized "
"numbers.  The exponent always contains at least one digit; if the value is "
"zero, the exponent is 0."
msgstr ""
"(C99 にはあるが SUSv2 にはないが SUSv3 で追加された) \n"
"B<a> 変換では、 I<double> 引数を\n"
"(abcdef の文字を使って) [-]B<0x>hB<\\&.>hhhhB<p>\\(+- 形式の\n"
"16 進表記に変換する。\n"
"B<A> 変換では、前置文字列 B<0X>, 文字 ABCDEF, 指数文字 B<P> を用いる。\n"
"小数点の前には 1 桁の 16 進数が置かれ、小数点の後ろの桁数は 精度で指定\n"
"された値となる。デフォルトの精度は、その値が 2 進数で正確に表現できる\n"
"場合には、その値を正確に表現できる桁数となる。それ以外の場合は、\n"
"I<double> 型の値を区別するのに十分な大きさとなる。 小数点の前の数字は、\n"
"正規化されていない数の場合はいくつになるか分からない。 正規化された数の\n"
"場合は、 0 以外の値になるが、いくつになるかは分からない。"

#. type: TP
#: build/C/man3/printf.3:751 build/C/man3/scanf.3:471
#: build/C/man3/wprintf.3:146
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: build/C/man3/printf.3:769
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""
"B<l> 修飾子がなければ、 I<int> 引数を I<unsigned char> に変換して、その結果"
"に対応する文字を出力する。 B<l> 修飾子があれば、 I<wint_t> (ワイド文字) 引"
"数を、 B<wcrtomb>(3)  関数を初期シフト状態で呼び出してマルチバイト文字列に変"
"換し、 変換されたマルチバイト文字列を出力する。"

#. type: TP
#: build/C/man3/printf.3:769 build/C/man3/scanf.3:463
#: build/C/man3/wprintf.3:160
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: build/C/man3/printf.3:784
msgid ""
"If no B<l> modifier is present: the I<const char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""
"B<l> 修飾子がない場合、 引数は I<const char\\ *> 型で文字型の配列へのポイン"
"ター (文字列へのポインター) であることが 期待されている。配列中の文字は、終端"
"の ヌルバイト (\\(aq\\e0\\(aq)  が出てくるまで出力される (終端文字は出力され"
"ない)。 精度が指定されていると、指定された字数以上は出力されない。 精度が指定"
"された場合には、終端バイトが存在する必要はない。 精度が指定されていなかった"
"り、精度の値が配列の大きさより大きい場合には、 配列は終端のヌルバイトを含んで"
"いなければならない。"

#. type: Plain text
#: build/C/man3/printf.3:811
msgid ""
"If an B<l> modifier is present: the I<const wchar_t\\ *> argument is "
"expected to be a pointer to an array of wide characters.  Wide characters "
"from the array are converted to multibyte characters (each by a call to the "
"B<wcrtomb>(3)  function, with a conversion state starting in the initial "
"state before the first wide character), up to and including a terminating "
"null wide character.  The resulting multibyte characters are written up to "
"(but not including) the terminating null byte.  If a precision is specified, "
"no more bytes than the number specified are written, but no partial "
"multibyte characters are written.  Note that the precision determines the "
"number of I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""
"B<l> 修飾子が指定されている場合、 引数は I<const wchar_t\\ *> 型でワイド文"
"字の配列へのポインターであることが期待されている。 配列中のワイド文字は (1文"
"字毎に B<wcrtomb>(3)  を呼び出して) マルチバイト文字に変換される (最初のワイ"
"ド文字の変換の前に B<wcrtomb>()  のシフト状態を初期状態に戻してから変換は行わ"
"れる)。 マルチバイト文字への変換は、文字列を終端するヌルワイド文字が 出てくる"
"まで行われ、終端ヌルワイド文字も含めて変換される。 結果のマルチバイト文字列"
"は、終端のヌルバイトが出てくるまで 出力される (終端のヌルバイトは出力されな"
"い)。 精度が指定された場合、指定されたバイト数以上には出力されない。 但し、マ"
"ルチバイト文字の一部分だけが出力されることはない。 精度は「バイト」数を指定す"
"るものであり、「ワイド文字」数や 「画面での位置」を指定するものではないことに"
"注意。 精度が指定されていて、さらに出力が配列の末尾に達する前に出力バイト数"
"が 精度の値を超える場合だけは、配列はヌルワイド文字で終端されていなくてもよ"
"い。 それ以外の場合は、必ず配列はヌルワイド文字で終端されていなければならな"
"い。"

#. type: TP
#: build/C/man3/printf.3:811
#, no-wrap
msgid "B<C>"
msgstr "B<C>"

#. type: Plain text
#: build/C/man3/printf.3:817
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<lc>.  "
"Don't use."
msgstr ""
"(C99, C11 にはないが SUSv2, SUSv3, SUSv4 にはある)  B<lc> と同じ。使ってはな"
"らない。"

#. type: TP
#: build/C/man3/printf.3:817
#, no-wrap
msgid "B<S>"
msgstr "B<S>"

#. type: Plain text
#: build/C/man3/printf.3:823
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<ls>.  "
"Don't use."
msgstr ""
"(C99, C11 にはないが SUSv2, SUSv3, SUSv4 にはある)  B<ls> と同じ。使ってはな"
"らない。"

#. type: TP
#: build/C/man3/printf.3:823 build/C/man3/scanf.3:514
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: build/C/man3/printf.3:831
msgid ""
"The I<void\\ *> pointer argument is printed in hexadecimal (as if by B<%#x> "
"or B<%#lx>)."
msgstr ""
"I<void\\ *> ポインター引数を (B<%#x> や B<%#lx> のような) 16 進数で出力す"
"る。"

#. type: TP
#: build/C/man3/printf.3:831 build/C/man3/scanf.3:522
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: build/C/man3/printf.3:843
#, fuzzy
#| msgid ""
#| "The number of characters written so far is stored into the integer "
#| "pointed to by the corresponding argument.  That argument shall be an I<int"
#| "\\ *>, or variant whose size matches the (optionally)  supplied integer "
#| "length modifier.  No argument is converted.  The behavior is undefined if "
#| "the conversion specification includes any flags, a field width, or a "
#| "precision."
msgid ""
"The number of characters written so far is stored into the integer pointed "
"to by the corresponding argument.  That argument shall be an I<int\\ *>, or "
"variant whose size matches the (optionally)  supplied integer length "
"modifier.  No argument is converted.  (This specifier is not supported by "
"the bionic C library.)  The behavior is undefined if the conversion "
"specification includes any flags, a field width, or a precision."
msgstr ""
"これまでに書き込まれた文字数が対応する引数が指す整数に格納される。 この引き"
"数は I<int\\ *> 系でなければならず、そのサイズは指定された整数の長さ修飾子 "
"(省略可能) と一致していなければならない。 引数の変換は行われない。 変換指定"
"にフラグ、フィールド幅、精度に含まれていた場合の動作は不定である。"

#. type: TP
#: build/C/man3/printf.3:843
#, no-wrap
msgid "B<m>"
msgstr "B<m>"

#. type: Plain text
#: build/C/man3/printf.3:849
msgid ""
"(Glibc extension; supported by uClibc and musl.)  Print output of "
"I<strerror(errno)>.  No argument is required."
msgstr "(glibc での拡張; uClibc と musl で対応)  I<strerror(errno)> の出力を表示する。引数は必要ない。"

#. type: TP
#: build/C/man3/printf.3:849 build/C/man3/scanf.3:384
#, no-wrap
msgid "B<%>"
msgstr "B<%>"

#. type: Plain text
#: build/C/man3/printf.3:855
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""
"\\(aq%\\(aq 文字を出力する。変換される引数は無い。 変換指定全体を書くと \"%"
"%\" となる。"

#. type: Plain text
#: build/C/man3/printf.3:858
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""
"成功時には、上記の関数は書き込まれた文字数を返す (文字列の最後を示すために使"
"用するヌルバイトは数に含まれない)。"

#. type: Plain text
#: build/C/man3/printf.3:874
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit, then the return value is the "
"number of characters (excluding the terminating null byte)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""
"B<snprintf>()  と B<vsnprintf>()  は、 I<size> バイトを越える文字数を書き込ま"
"ない (I<size> には文字列を終端するヌルバイト (\\(aq\\e0\\(aq) も含まれる)。 "
"この制限によって出力が切り詰められた場合には、 もし十分なスペースがあれば書き"
"込まれたであろう文字の個数 (文字列を終端するヌルバイトを除く) を返す。 従っ"
"て、返り値が I<size> 以上だった場合、出力が切り詰められたことを意味する (後述"
"の注意も参照のこと)。"

#. type: Plain text
#: build/C/man3/printf.3:876
msgid "If an output error is encountered, a negative value is returned."
msgstr "エラーが発生した場合は、負の数を返す。"

#. type: tbl table
#: build/C/man3/printf.3:887
#, no-wrap
msgid ""
"B<printf>(),\n"
"B<fprintf>(),\n"
msgstr ""
"B<printf>(),\n"
"B<fprintf>(),\n"

#. type: tbl table
#: build/C/man3/printf.3:890
#, no-wrap
msgid ""
"B<sprintf>(),\n"
"B<snprintf>(),\n"
msgstr ""
"B<sprintf>(),\n"
"B<snprintf>(),\n"

#. type: tbl table
#: build/C/man3/printf.3:893
#, no-wrap
msgid ""
"B<vprintf>(),\n"
"B<vfprintf>(),\n"
msgstr ""
"B<vprintf>(),\n"
"B<vfprintf>(),\n"

#. type: tbl table
#: build/C/man3/printf.3:896
#, no-wrap
msgid ""
"B<vsprintf>(),\n"
"B<vsnprintf>()"
msgstr ""
"B<vsprintf>(),\n"
"B<vsnprintf>()"

#. type: Plain text
#: build/C/man3/printf.3:907
msgid ""
"B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"B<vsprintf>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), B<vsprintf>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: build/C/man3/printf.3:911
msgid "B<snprintf>(), B<vsnprintf>(): POSIX.1-2001, POSIX.1-2008, C99."
msgstr "B<snprintf>(), B<vsnprintf>(): POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: build/C/man3/printf.3:918
msgid ""
"The B<dprintf>()  and B<vdprintf>()  functions were originally GNU "
"extensions that were later standardized in POSIX.1-2008."
msgstr "B<dprintf>()  と B<vdprintf>()  は、どちらも元は GNU による拡張であったが、 POSIX.1-2008 で標準化された。"

#.  .PP
#.  Linux libc4 knows about the five C standard flags.
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  and the conversions
#.  \fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
#.  \fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
#.  \fBs\fP, \fBu\fP, \fBx\fP, and \fBX\fP,
#.  where \fBF\fP is a synonym for \fBf\fP.
#.  Additionally, it accepts \fBD\fP, \fBO\fP, and \fBU\fP as synonyms
#.  for \fBld\fP, \fBlo\fP, and \fBlu\fP.
#.  (This is bad, and caused serious bugs later, when
#.  support for \fB%D\fP disappeared.)
#.  No locale-dependent radix character,
#.  no thousands' separator, no NaN or infinity, no "%m$" and "*m$".
#.  .PP
#.  Linux libc5 knows about the five C standard flags and the \(aq flag,
#.  locale, "%m$" and "*m$".
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  \fBZ\fP, and \fBq\fP, but accepts \fBL\fP and \fBq\fP
#.  both for \fIlong double\fP and for \fIlong long\fP (this is a bug).
#.  It no longer recognizes \fBF\fP, \fBD\fP, \fBO\fP, and \fBU\fP,
#.  but adds the conversion character
#.  .BR m ,
#.  which outputs
#.  .IR strerror(errno) .
#.  .PP
#.  glibc 2.0 adds conversion characters \fBC\fP and \fBS\fP.
#. type: Plain text
#: build/C/man3/printf.3:961
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough.  POSIX.1-2001 and later align their specification of "
"B<snprintf>()  with C99."
msgstr "B<snprintf>()  の返り値を見ると、 SUSv2 と C99 標準は互いに矛盾している。 SUSv2 では、 B<snprintf>()  が I<size>=0 で呼び出された場合、 1 未満の値を何か返り値とするように規定している。 一方 C99 では、このような場合 I<str> を NULL とし、返り値として (通常通り) 出力バッファーが十分な大きさが あった場合に出力されるであろう文字数を返す。 POSIX.1-2001 やそれ以降では C99 の B<snprintf>() の規定にあわせたものとなっている。"

#. type: Plain text
#: build/C/man3/printf.3:964
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""
"glibc 2.1 では、長さ修飾子 B<hh>, B<j>, B<t>, B<z> と変換文字 B<a>, B<A> が追"
"加された。"

#. type: Plain text
#: build/C/man3/printf.3:967
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""
"glibc 2.2 では、 C99 で規定された意味での変換文字 B<F> と フラグ文字 B<I> が"
"追加された。"

#. type: Plain text
#: build/C/man3/printf.3:969
msgid "Some programs imprudently rely on code such as the following"
msgstr ""
"テキストを I<buf> に追加するのに、軽率にも次のようなコードを使っているプログ"
"ラムがある。"

#. type: Plain text
#: build/C/man3/printf.3:971
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr "    sprintf(buf, \"%s some further text\", buf);\n"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: build/C/man3/printf.3:987
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""
"しかしながら、標準規格では、 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  の呼び出しにおいて、コピー元とコピー先のバッファーが重なって"
"いた場合の 結果は不定である、と明記されている。 使用する B<gcc>(1)  のバー"
"ジョンや指定したコンパイラのオプション次第では、 上記のような呼び出しで、期待"
"した結果が得られ「ない」ことがある。"

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: build/C/man3/printf.3:1029
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6, they would return -1 when the output "
"was truncated."
msgstr ""
"glibc の B<snprintf>()  と B<vsnprintf>()  の実装は、バージョン 2.1 以降は "
"C99 標準に準拠しており、 上記の通りの動作をする。 glibc 2.0.6 までは、出力が"
"切り詰められた場合は -1 を返す。"

#.  .PP
#.  Linux libc4.[45] does not have a
#.  .BR snprintf (),
#.  but provides a libbsd that contains an
#.  .BR snprintf ()
#.  equivalent to
#.  .BR sprintf (),
#.  that is, one that ignores the
#.  .I size
#.  argument.
#.  Thus, the use of
#.  .BR snprintf ()
#.  with early libc4 leads to serious security problems.
#. type: Plain text
#: build/C/man3/printf.3:1059
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""
"B<sprintf>()  と B<vsprintf>()  は勝手に十分に長い文字列領域があると仮定する"
"ので、呼び出し側は 実際の領域からあふれないように注意しなければならない。 し"
"かし、これを保証することが不可能な場合が多い。 生成される文字列の長さはロケー"
"ル依存であり、予測が難しいことに注意。 代わりに B<snprintf>()  と "
"B<vsnprintf>()  (または B<asprintf>(3)  と B<vasprintf>(3))  を使うこと。"

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: build/C/man3/printf.3:1073
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""
"B<printf(>I<foo>B<);> のようなコードはしばしばバグを引き起こす。 なぜなら "
"I<foo> に % 文字が含まれてるかもしれないからである。 I<foo> が信頼できない"
"ユーザー入力から作られている場合には、 その中に B<%n> が含まれていることがあ"
"り、 B<printf>()  呼び出し時にメモリーへの書き込みが起こり、 セキュリティー"
"ホールを作ることになるかもしれない。"

#. type: Plain text
#: build/C/man3/printf.3:1077
msgid "To print I<Pi> to five decimal places:"
msgstr "I<Pi> を 5 桁で出力する。"

#. type: Plain text
#: build/C/man3/printf.3:1083
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"

#. type: Plain text
#: build/C/man3/printf.3:1092
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""
"日付と時間を \"Sunday, July 3, 10:02\" の形式で出力する。 (I<weekday> と "
"I<month> は文字列へのポインターである)"

#. type: Plain text
#: build/C/man3/printf.3:1098
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#: build/C/man3/printf.3:1104
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""
"日 - 月 - 年 の順序で表示を行う国も多い。 従って、国際版では書式で指定された"
"順番で 引数を表示できなければならない。"

#. type: Plain text
#: build/C/man3/printf.3:1110
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#: build/C/man3/printf.3:1117
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""
"I<format> はロケールに依存しており、引数の順番を変えることもできる。 "
"I<format> が"

#. type: Plain text
#: build/C/man3/printf.3:1121
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"

#. type: Plain text
#: build/C/man3/printf.3:1125
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr "であれば、 \"Sonntag, 3. Juli, 10:02\" という結果になる。"

#. type: Plain text
#: build/C/man3/printf.3:1128
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""
"十分に大きな文字列領域を確保して、そこにメッセージを格納するには (glibc 2.0 "
"と glibc 2.1 の両方で正しく動作するコード):"

#. type: Plain text
#: build/C/man3/printf.3:1133
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: build/C/man3/printf.3:1141
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n = 0;\n"
"    size_t size = 0;\n"
"    char *p = NULL;\n"
"    va_list ap;\n"
msgstr ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n = 0;\n"
"    size_t size = 0;\n"
"    char *p = NULL;\n"
"    va_list ap;\n"

#. type: Plain text
#: build/C/man3/printf.3:1143
#, no-wrap
msgid "    /* Determine required size */\n"
msgstr "    /* Determine required size */\n"

#. type: Plain text
#: build/C/man3/printf.3:1147 build/C/man3/printf.3:1161
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    n = vsnprintf(p, size, fmt, ap);\n"
"    va_end(ap);\n"
msgstr ""
"    va_start(ap, fmt);\n"
"    n = vsnprintf(p, size, fmt, ap);\n"
"    va_end(ap);\n"

#. type: Plain text
#: build/C/man3/printf.3:1150
#, no-wrap
msgid ""
"    if (n E<lt> 0)\n"
"        return NULL;\n"
msgstr ""
"    if (n E<lt> 0)\n"
"        return NULL;\n"

#. type: Plain text
#: build/C/man3/printf.3:1152
#, no-wrap
msgid "    /* One extra byte for \\(aq\\e0\\(aq */\n"
msgstr "    /* One extra byte for \\(aq\\e0\\(aq */\n"

#. type: Plain text
#: build/C/man3/printf.3:1157
#, no-wrap
msgid ""
"    size = (size_t) n + 1;\n"
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"
msgstr ""
"    size = (size_t) n + 1;\n"
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#: build/C/man3/printf.3:1166
#, no-wrap
msgid ""
"    if (n E<lt> 0) {\n"
"        free(p);\n"
"        return NULL;\n"
"    }\n"
msgstr ""
"    if (n E<lt> 0) {\n"
"        free(p);\n"
"        return NULL;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/printf.3:1169
#, no-wrap
msgid ""
"    return p;\n"
"}\n"
msgstr ""
"    return p;\n"
"}\n"

#. type: Plain text
#: build/C/man3/printf.3:1173
msgid ""
"If truncation occurs in glibc versions prior to 2.0.6, this is treated as an "
"error instead of being handled gracefully."
msgstr ""
"バージョン 2.0.6 より前の glibc で切り詰めが起こった場合、切り詰めは適切に処"
"理されず、エラーとして扱われる。"

#. type: Plain text
#: build/C/man3/printf.3:1183
msgid ""
"B<printf>(1), B<asprintf>(3), B<puts>(3), B<scanf>(3), B<setlocale>(3), "
"B<strfromd>(3), B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr "B<printf>(1), B<asprintf>(3), B<puts>(3), B<scanf>(3), B<setlocale>(3), B<strfromd>(3), B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"

#. type: TH
#: build/C/man3/puts.3:26
#, no-wrap
msgid "PUTS"
msgstr "PUTS"

#. type: Plain text
#: build/C/man3/puts.3:29
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr "fputc, fputs, putc, putchar, puts - 文字と文字列の出力"

#. type: Plain text
#: build/C/man3/puts.3:34
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:36
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:38
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:40
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr "B<int putchar(int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:42
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr "B<int puts(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:51
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""
"B<fputc>()  は、キャラクター I<c> を I<unsigned char> にキャストし、 "
"I<stream> に書き込む。"

#. type: Plain text
#: build/C/man3/puts.3:58
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"B<fputs>()  は、文字列 I<s> を I<stream> に書き込む。 文字列終端のヌルバイト "
"(\\(aq\\e0\\(aq) は出力しない。"

#. type: Plain text
#: build/C/man3/puts.3:65
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"B<putc>()  は、 I<stream> を一度以上評価するマクロとして実装されているかも知"
"れないという点を除き、 B<fputc>()  と同じである。"

#. type: Plain text
#: build/C/man3/puts.3:69
msgid "B<putchar(>I<c>B<)> is equivalent to B<putc(>I<c>B<, >I<stdout>B<)>."
msgstr "B<putchar(>I<c>B<)> は、 B<putc(>I<c>B<,>I<stdout>B<)> と同じである。"

#. type: Plain text
#: build/C/man3/puts.3:76
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr "B<puts>()  は、文字列 I<s> と改行を I<stdout> に書き込む。"

#. type: Plain text
#: build/C/man3/puts.3:81
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""
"ここで説明された関数はお互いに混在して使用することができ、また、 I<stdio> ラ"
"イブラリに含まれる他の出力関数を同じ出力ストリームに対して 呼び出す事が出来"
"る。"

#. type: Plain text
#: build/C/man3/puts.3:96
msgid ""
"B<fputc>(), B<putc>(), and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""
"B<fputc>(), B<putc>(), B<putchar>()  は I<unsigned char> として書き込まれた文"
"字を I<int> にキャストして返す。 エラーが発生した場合は B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/puts.3:103
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF> "
"on error."
msgstr ""
"B<puts>()  と B<fputs>()  は、成功すると負ではない数を、エラーが発生した場合"
"は B<EOF> を返す。"

#. type: tbl table
#: build/C/man3/puts.3:117
#, no-wrap
msgid ""
"B<fputc>(),\n"
"B<fputs>(),\n"
"B<putc>(),\n"
"B<putchar>(),\n"
"B<puts>()"
msgstr ""
"B<fputc>(),\n"
"B<fputs>(),\n"
"B<putc>(),\n"
"B<putchar>(),\n"
"B<puts>()"

#. type: Plain text
#: build/C/man3/puts.3:128
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""
"I<stdio> ライブラリに含まれる出力関数と、同じ出力ストリームに結びつけられた "
"ファイルディスクリプターに対する B<write>(2)  の低レベル呼び出しを混在して 使"
"用することは賢明ではない。 その結果は定義されておらず、望む結果が得られない可"
"能性が高い。"

#. type: Plain text
#: build/C/man3/puts.3:140
msgid ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"
msgstr ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man2/read.2:36
#, no-wrap
msgid "READ"
msgstr "READ"

#. type: TH
#: build/C/man2/read.2:36
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: build/C/man2/read.2:39
msgid "read - read from a file descriptor"
msgstr "read - ファイルディスクリプターから読み込む"

#. type: Plain text
#: build/C/man2/read.2:44
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: build/C/man2/read.2:53
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""
"B<read>()  はファイルディスクリプター (file descriptor)  I<fd> から最大 "
"I<count> バイトを I<buf> で始まるバッファーへ読み込もうとする。"

#. type: Plain text
#: build/C/man2/read.2:61
msgid ""
"On files that support seeking, the read operation commences at the file "
"offset, and the file offset is incremented by the number of bytes read.  If "
"the file offset is at or past the end of file, no bytes are read, and "
"B<read>()  returns zero."
msgstr "seek に対応しているファイルでは、read はファイルオフセットから行われ、ファイルオフセットは読み込んだバイト数分だけ進められる。ファイルオフセットがファイル末尾かそれより先の場合は、読み出しは行われず、 B<read>() は 0 を返す。"

#. type: Plain text
#: build/C/man2/read.2:76
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""
"I<count> が 0 の場合、 B<read>() は以下で説明するエラーを検出するI<場合がある"
">。 どのエラーもなかった場合、もしくは B<read>() がエラーのチェックを行わない"
"場合、 I<count> が 0 で呼び出された B<read>() は 0 を返し、何も行わない。"

#. type: Plain text
#: build/C/man2/read.2:83 build/C/man2/write.2:96
#, fuzzy
#| msgid "If I<count> is greater than B<SSIZE_MAX>, the result is unspecified."
msgid ""
"According to POSIX.1, if I<count> is greater than B<SSIZE_MAX>, the result "
"is implementation-defined; see NOTES for the upper limit on Linux."
msgstr "I<count> が B<SSIZE_MAX> より大きければ、結果は規定できない。"

#. type: Plain text
#: build/C/man2/read.2:93
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  See also NOTES."
msgstr "成功した場合、読み込んだバイト数を返す (0 はファイルの終りを意味する)。 ファイル位置はこの数だけ進められる。 この数が要求した数より小さかったとしてもエラーではない; 例えば今すぐには実際にそれだけの数しかない場合 (ファイルの最後に近いのかも しれないし、パイプ (pipe) や端末 (terminal) から読み込んでいるかもしれない) や B<read>()  がシグナル (signal) によって割り込まれた場合にこれは起こりえる。"

#. type: Plain text
#: build/C/man2/read.2:99
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately.  In this case, "
"it is left unspecified whether the file position (if any) changes."
msgstr "エラーの場合は、-1 が返され、 I<errno> が適切に設定される。この場合はファイル位置が変更されるかどうかは 不定である。"

#. type: Plain text
#: build/C/man2/read.2:112
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr "ファイルディスクリプター I<fd> がソケット以外のファイルを参照していて、 非停止 (nonblocking) モード (B<O_NONBLOCK>)  に設定されており、読み込みを行うと停止する状況にある。 B<O_NONBLOCK> フラグの詳細は B<open>(2) を参照。"

#. type: TP
#: build/C/man2/read.2:112 build/C/man2/write.2:144
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> または B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/read.2:123
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"ファイルディスクリプター I<fd> がソケットを参照していて、非停止 "
"(nonblocking) モード (B<O_NONBLOCK>)  に設定されており、読み込みを行うと停止"
"する状況にある。 POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めて"
"おり、 これら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性"
"が必要なアプリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/read.2:127
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> が有効なファイルディスクリプターでないか、読み込みのために オープン "
"(open) されていない。"

#. type: Plain text
#: build/C/man2/read.2:131 build/C/man2/write.2:174
msgid "I<buf> is outside your accessible address space."
msgstr "I<buf> がアクセス可能なアドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/read.2:135
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""
"何のデータも読み込まないうちにシグナルに割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/read.2:146
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr "I<fd> は読み込みに適していないオブジェクトを参照している。 もしくは、ファイルが B<O_DIRECT> フラグを指定してオープンされているが、 I<buf> に指定されたアドレス、 I<count> に指定された値、 ファイルオフセットのいずれかの アラインメントが不適切である。"

#. type: Plain text
#: build/C/man2/read.2:156
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""
"I<fd> が B<timerfd_create>(2)  の呼び出しで作成されたが、 B<read>()  に間違っ"
"たサイズのバッファーが渡された。 さらなる情報は B<timerfd_create>(2)  を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/read.2:176
#, fuzzy
#| msgid ""
#| "I/O error.  This will happen for example when the process is in a "
#| "background process group, tries to read from its controlling terminal, "
#| "and either it is ignoring or blocking B<SIGTTIN> or its process group is "
#| "orphaned.  It may also occur when there is a low-level I/O error while "
#| "reading from a disk or tape."
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling terminal, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape.  A further possible cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""
"I/O エラー。これは例えばプロセスがバックグランドプロセスグループで、それを制"
"御している端末から読み込もうとし、 B<SIGTTIN> が無視 (ignore) または禁止 "
"(blocking) されている場合や、 そのプロセスグループが孤立 (orphan) している場"
"合に起こる。 またディスクやテープを読んでいる時に低レベル I/O エラー が発生し"
"た場合にも起こる。"

#. type: Plain text
#: build/C/man2/read.2:180
msgid "I<fd> refers to a directory."
msgstr "I<fd> がディレクトリを参照している。"

#. type: Plain text
#: build/C/man2/read.2:183 build/C/man2/write.2:243
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""
"I<fd> に接続されたオブジェクトによっては、他のエラーが起こるかもしれない。"

#.  SVr4 documents additional error
#.  conditions EDEADLK, ENOLCK, ENOLNK, ENOSR, ENXIO, or ERANGE.
#. type: Plain text
#: build/C/man2/read.2:185 build/C/man2/write.2:247
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/read.2:192 build/C/man2/write.2:259
msgid ""
"The types I<size_t> and I<ssize_t> are, respectively, unsigned and signed "
"integer data types specified by POSIX.1."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: build/C/man2/read.2:200
msgid ""
"On Linux, B<read>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:216
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"I<st_atime> (last file access time)  updates to the server, and client side "
"reads satisfied from the client's cache will not cause I<st_atime> updates "
"on the server as there are no server-side reads.  UNIX semantics can be "
"obtained by disabling client-side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr "NFS において。少量のデータを読み込む場合、最初の時のみにタイム スタンプが更新され、続くコールでは更新されないだろう。 これはクライアント側で属性のキャッシングを行なうためである。 なぜならば、もし全ての NFS クライアントが I<st_atime> (最終ファイルアクセス時刻)  の更新をサーバーに送らず、クライアント側でキャッシュを読むことに満足して いれば、サーバー側での read は発生しないので I<st_atime> の更新は行なわれからだ。 UNIX の方式では、クライアント側の属性のキャッシングを無効にすることで、 これを得ることができる。しかしほとんどの状況ではこれは続くサーバーの 負荷を増加させ、パフォーマンスの低下をもたらす。"

#. type: Plain text
#: build/C/man2/read.2:219 build/C/man2/write.2:301
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""
"POSIX.1-2008/SUSv4 セクション XSI 2.9.7 (\"Thread Interactions with Regular "
"File Operations\") によると、"

#. type: Plain text
#: build/C/man2/read.2:224 build/C/man2/write.2:306
msgid ""
"All of the following functions shall be atomic with respect to each other in "
"the effects specified in POSIX.1-2008 when they operate on regular files or "
"symbolic links: ..."
msgstr ""
"以下のすべての関数では、 通常ファイルもしくはシンボリックリンクに対する操作で"
"は POSIX.1-2008 で規定された効果が互いにアトミックに行われなければならな"
"い: ..."

#
#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: build/C/man2/read.2:255
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in "
"Linux 3.14."
msgstr ""
"この後に書かれている API の中に B<read>() と B<readv>(2) である。 スレッド"
"（やプロセス) 間でアトミックに適用することが求められる効果の一つとして、 ファ"
"イルオフセットの更新がある。 しかしながら、 バージョン 3.14 より前の Linux で"
"は、 この限りではない。 オープンファイル記述 (open file description) を共有す"
"る 2 つのプロセスが同時に B<read>() (や B<readv>(2)) を実行した場合、 この I/"
"O 操作ではファイルオフセットの更新に関してはアトミックではなく、 2 つのプロセ"
"スの read で取得されるデータブロックが (間違って) 重なる可能性がある。 この問"
"題は Linux 3.14 で修正された。"

#. type: Plain text
#: build/C/man2/read.2:268
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"

#. type: TH
#: build/C/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr "READLINK"

#. type: Plain text
#: build/C/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr "readlink, readlinkat - シンボリックリンクの値を読む"

#. type: Plain text
#: build/C/man2/readlink.2:53
#, no-wrap
msgid "B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr "B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"

#. type: Plain text
#: build/C/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"

#. type: Plain text
#: build/C/man2/readlink.2:68
msgid "B<readlink>():"
msgstr "B<readlink>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/readlink.2:72 build/C/man2/symlink.2:60
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
" _XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* glibc 2.19 以前: */ _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man2/readlink.2:75
msgid "B<readlinkat>():"
msgstr "B<readlinkat>():"

#. type: Plain text
#: build/C/man2/readlink.2:101
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will (silently) truncate the contents (to a length "
"of I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr "B<readlink>()  は I<pathname> で与えられたシンボリックリンクの内容を I<buf> バッファーへ格納する、 I<buf> のサイズは I<bufsiz> である。 B<readlink>()  はヌルバイトを I<buf> に追加しない。 その内容全てを格納するのにバッファーが小さ過ぎる場合は、 (I<bufsiz> バイトの長さに) 内容を (黙って) 切り詰める。"

#. type: SS
#: build/C/man2/readlink.2:101
#, no-wrap
msgid "readlinkat()"
msgstr "readlinkat()"

#. type: Plain text
#: build/C/man2/readlink.2:107
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""
"B<readlinkat>() システムコールは B<readlink>() と全く同様に動作するが、以下で"
"説明する点が異なる。"

#. type: Plain text
#: build/C/man2/readlink.2:117
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<readlink>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/readlink.2:129
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<readlink>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<readlink>() と同様に) I<pathname> は呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスと解釈される。"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: build/C/man2/readlink.2:149
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the symbolic link referred to by I<dirfd> (which should "
"have been obtained using B<open>(2)  with the B<O_PATH> and B<O_NOFOLLOW> "
"flags)."
msgstr ""
"Linux 2.6.39 以降では、 I<pathname> に空文字列を指定できる。 その場合、呼び出"
"しは I<dirfd> が参照するシンボリックリンクに対して行われる (I<dirfd> はフラ"
"グ B<O_PATH> と B<O_NOFOLLOW> を指定した B<open>(2) を使って取得すべきであ"
"る)。"

#. type: Plain text
#: build/C/man2/readlink.2:154
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr "B<readlinkat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/readlink.2:163
#, fuzzy
#| msgid ""
#| "On success, these calls return the number of bytes placed in I<buf>.  On "
#| "error, -1 is returned and I<errno> is set to indicate the error."
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  (If "
"the returned value equals I<bufsiz>, then truncation may have occurred.)  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、これらのシステムコールは I<buf> に格納されたバイト数を返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/readlink.2:169
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"パスのディレクトリ部分に検索許可が与えられていない (B<path_resolution>(7)  も"
"参照すること)。"

#. type: Plain text
#: build/C/man2/readlink.2:173
msgid "I<buf> extends outside the process's allocated address space."
msgstr "I<buf> がプロセスに割り当てられたアドレス空間の外を指している。"

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: build/C/man2/readlink.2:182
msgid "I<bufsiz> is not positive."
msgstr "I<bufsiz> が正でない。"

#. type: Plain text
#: build/C/man2/readlink.2:187
msgid ""
"The named file (i.e., the final filename component of I<pathname>)  is not a "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:190
msgid "An I/O error occurred while reading from the filesystem."
msgstr "ファイルシステムの読み込み中に I/O エラーが起こった。"

#. type: Plain text
#: build/C/man2/readlink.2:193
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名にシンボリックリンクが多すぎる。"

#. type: Plain text
#: build/C/man2/readlink.2:196
msgid "A pathname, or a component of a pathname, was too long."
msgstr "パス名かパス名の一部分が長過ぎる。"

#. type: Plain text
#: build/C/man2/readlink.2:199
msgid "The named file does not exist."
msgstr "その名前のファイルが存在しない。"

#. type: Plain text
#: build/C/man2/readlink.2:205
msgid "A component of the path prefix is not a directory."
msgstr "パスのディレクトリ部分がディレクトリでない。"

#. type: Plain text
#: build/C/man2/readlink.2:208
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr "B<readlinkat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/readlink.2:218 build/C/man2/unlink.2:274
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/readlink.2:222
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<readlinkat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#. type: Plain text
#: build/C/man2/readlink.2:228
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""
"4.4BSD (B<readlink>()  は 4.2BSD で初めて登場した), POSIX.1-2001, "
"POSIX.1-2008."

#. type: Plain text
#: build/C/man2/readlink.2:231
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr "B<readlinkat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/readlink.2:239
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""
"バージョン 2.4 以前の glibc (バージョン 2.4 を含む) では、 B<readlink>()  の"
"返り値の型は I<int> で宣言されていた。現在では、返り値の型は I<ssize_t> であ"
"る (返り値 I<ssize_t> は POSIX.1-2001 で (新たに) 必須となった)。"

#. type: Plain text
#: build/C/man2/readlink.2:262
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using B<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr "静的な大きさのバッファーを使うと、 シンボリックリンクの内容を格納するのに十分な領域がない場合がある。 バッファーに必要なサイズは、 そのシンボリックリンクに対して B<lstat>(2) の呼び出しで返される I<stat.st_size> の値から取得できる。 ただし、 B<readlink>() や B<readlinkat>() が書き込んだバイト数をチェックして、 シンボリックリンクのサイズが二つの呼び出しの間で増えていないことを確認すべきである。 B<readlink>() や B<readlinkat>() 用のバッファーを動的に割り当てる方法でも、 バッファーサイズとして B<PATH_MAX> を使用する場合に共通する移植性の問題を解決することができる。 なぜなら、POSIX では、 システムがそのような上限値を定義していない場合には、 B<PATH_MAX> が定義されることが保証されていないからである。"

#. type: Plain text
#: build/C/man2/readlink.2:275
msgid ""
"On older kernels where B<readlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<readlink>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"B<readlinkat>() が利用できない古いカーネルでは、 glibc ラッパー関数は "
"B<readlink>() を使用するモードにフォールバックする。 I<pathname> が相対パスの"
"場合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリン"
"クに基づいてパス名を構成する。"

#. type: Plain text
#: build/C/man2/readlink.2:285
#, fuzzy
#| msgid ""
#| "The following program allocates the buffer needed by B<readlink>()  "
#| "dynamically from the information provided by B<lstat>(), making sure "
#| "there's no race condition between the calls."
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(2), falling back to a "
"buffer of size B<PATH_MAX> in cases where B<lstat>(2)  reports a size of "
"zero."
msgstr ""
"以下のプログラムは、 B<readlink>() が必要とするバッファーを、\n"
"B<lstat>() が提供する情報に基づいて動的に割り当てる。\n"
"また、両方の呼び出し間で競合条件がないことを保証している。"

#. type: Plain text
#: build/C/man2/readlink.2:293
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
" #include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/readlink.2:300
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"

#. type: Plain text
#: build/C/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:310
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:313
#, no-wrap
msgid ""
"    /* Add one to the link size, so that we can determine whether\n"
"       the buffer returned by readlink() was truncated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:315
#, no-wrap
msgid "    bufsiz = sb.st_size + 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:319
#, no-wrap
msgid ""
"    /* Some magic symlinks under (for example) /proc and /sys\n"
"       report \\(aqst_size\\(aq as zero. In that case, take PATH_MAX as\n"
"       a \"good enough\" estimate. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:322
#, no-wrap
msgid ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:328
#, no-wrap
msgid ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"     buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:334
#, no-wrap
msgid ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"     nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:336
#, no-wrap
msgid "    printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) nbytes, buf);\n"
msgstr "     printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) nbytes, buf);\n"

#. type: Plain text
#: build/C/man2/readlink.2:342
#, no-wrap
msgid ""
"    /* If the return value was equal to the buffer size, then the\n"
"       the link target was larger than expected (perhaps because the\n"
"       target was changed between the call to lstat() and the call to\n"
"       readlink()). Warn the user that the returned target may have\n"
"       been truncated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:345
#, no-wrap
msgid ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Returned buffer may have been truncated)\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:349
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"     free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/readlink.2:358
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr "READV"

#. type: Plain text
#: build/C/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into "
"multiple buffers"
msgstr "readv, writev, preadv, pwritev, preadv2, pwritev2 - 複数のバッファーへの読み書きを行なう"

#. type: Plain text
#: build/C/man2/readv.2:38
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/readv.2:40
#, no-wrap
msgid "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:42
#, no-wrap
msgid "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:51
#, no-wrap
msgid ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""
" B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:54
#, no-wrap
msgid ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""
" B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:67
#, no-wrap
msgid ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:77
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""
"B<readv>() システムコールは、ファイルディスクリプター I<fd> に関連付けられ"
"た\n"
"ファイルから、 I<iovcnt> 個のバッファー分のデータを読み込み、 I<iov> で指定\n"
"されたバッファーに格納する (\"scatter input\";「ばらまき入力」)。"

#. type: Plain text
#: build/C/man2/readv.2:87
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather output"
"\")."
msgstr ""
"B<writev>() システムコールは、 I<iov> で指定されたバッファーから最大 "
"I<iovcnt>\n"
"個のバッファー分のデータを取り出し、 ファイルディスクリプター I<fd> に関連付"
"けら\n"
"れたファイルに書き込む (\"gather output\";「かき集め出力」)。"

#. type: Plain text
#: build/C/man2/readv.2:96
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"ポインター I<iov> は I<iovec> 構造体の配列へのポインターである。 I<iovec> 構"
"造体は I<E<lt>sys/uio.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/readv.2:103
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"

#. type: Plain text
#: build/C/man2/readv.2:111
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""
"B<readv>() システムコールは、複数のバッファーにデータを読み込む点を除いて\n"
"B<read>(2) と全く同様の動作を行う。"

#. type: Plain text
#: build/C/man2/readv.2:117
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""
"B<writev>() システムコールは、複数のバッファーのデータを書き出す点以外は\n"
"B<write>(2) と全く同様の動作を行う。"

#. type: Plain text
#: build/C/man2/readv.2:136
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov[0]> before proceeding to I<iov[1]>, and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov[0]> before proceeding to I<iov[1]>, and so on."
msgstr ""
"バッファーは配列の順序で処理される。これは、 B<readv>()  が I<iov>[0] が完全"
"に一杯になるまでデータを詰めてから、 I<iov>[1] などに進むことを意味する (デー"
"タが十分ない場合は、 I<iov> が指すバッファーのいずれも一杯にならない)。 同様"
"に、 B<writev>()  は I<iov>[0] の内容を全部書き出してから I<iov>[1] などに進"
"む。"

#.  Regarding atomicity, see https://bugzilla.kernel.org/show_bug.cgi?id=10596
#. type: Plain text
#: build/C/man2/readv.2:155
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""
"B<readv>()  と B<writev>()  によるデータ転送は atomic に行われる。つまり、 "
"B<writev>()  によるデータ書き込みは一つのブロックとして行われ、他のプロセス"
"の write による書き込みと混ざり合うことはない (例外に関しては B<pipe>(7)  を"
"参照のこと)。同様に、 B<readv>()  はファイルから連続するデータブロックが読み"
"出すことが保証され、 同じファイル記述 (file description; B<open>(2)  参照) を"
"参照するファイルディスクリプターを持つ他のスレッドやプロセスが 実行した read "
"操作の影響を受けることはない。"

#. type: SS
#: build/C/man2/readv.2:155
#, no-wrap
msgid "preadv() and pwritev()"
msgstr "preadv() と pwritev()"

#. type: Plain text
#: build/C/man2/readv.2:168
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""
"B<preadv>() システムコールは B<readv>() と B<pread>(2) の機能を\n"
"組み合わせたものである。\n"
"B<readv>() と同じ処理を実行するが、\n"
"4 番目の引数 I<offset> が追加されており、\n"
"この引数は入力操作を行うファイルオフセットを指定する。"

#. type: Plain text
#: build/C/man2/readv.2:181
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""
"B<pwritev>() システムコールは B<writev>() と B<pwrite>(2) の機能を\n"
"組み合わせたものである。\n"
"B<writev>() と同じ処理を実行するが、\n"
"4 番目の引数 I<offset> が追加されており、\n"
"この引数は出力操作を行うファイルオフセットを指定する。"

#. type: Plain text
#: build/C/man2/readv.2:186
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""
"これらのシステムコールで、ファイルオフセットは変更されない。\n"
"I<fd> が参照するファイルは seek 可能でなければならない。"

#. type: SS
#: build/C/man2/readv.2:186
#, no-wrap
msgid "preadv2() and pwritev2()"
msgstr "preadv2() と pwritev2()"

#. type: Plain text
#: build/C/man2/readv.2:194
msgid ""
"These system calls are similar to B<preadv>()  and B<pwritev>()  calls, but "
"add a fifth argument, I<flags>, which modifies the behavior on a per-call "
"basis."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:202
msgid ""
"Unlike B<preadv>()  and B<pwritev>(), if the I<offset> argument is -1, then "
"the current file offset is used and updated."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:206
#, fuzzy
#| msgid ""
#| "The I<flags> argument is a bit mask consisting of zero or more of the "
#| "following flags:"
msgid ""
"The I<flags> argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr "I<flags> 引数は、以下のフラグの 0 個以上のビットマスクである。"

#. type: TP
#: build/C/man2/readv.2:206
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.7)"
msgstr "B<RWF_DSYNC> (Linux 4.7 以降)"

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: build/C/man2/readv.2:216
msgid ""
"Provide a per-write equivalent of the B<O_DSYNC> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:216
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.6)"
msgstr "B<RWF_HIPRI> (Linux 4.6 以降)"

#. type: Plain text
#: build/C/man2/readv.2:224
msgid ""
"High priority read/write.  Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources.  "
"(Currently, this feature is usable only on a file descriptor opened using "
"the B<O_DIRECT> flag.)"
msgstr ""

#. type: TP
#: build/C/man2/readv.2:224
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.7)"
msgstr "B<RWF_SYNC> (Linux 4.7 以降)"

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: build/C/man2/readv.2:234
msgid ""
"Provide a per-write equivalent of the B<O_SYNC> B<open>(2)  flag.  This flag "
"is meaningful only for B<pwritev2>(), and its effect applies only to the "
"data range written by the system call."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:234
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr "B<RWF_NOWAIT> (Linux 4.14 以降)"

#.  commit 3239d834847627b6634a4139cf1dc58f6f137a46
#.  commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
#. type: Plain text
#: build/C/man2/readv.2:250
msgid ""
"Do not wait for data which is not immediately available.  If this flag is "
"specified, the B<preadv2>()  system call will return instantly if it would "
"have to read data from the backing storage or wait for a lock.  If some data "
"was successfully read, it will return the number of bytes read.  If no bytes "
"were read, it will return -1 and set I<errno> to B<EAGAIN>.  Currently, this "
"flag is meaningful only for B<preadv2>()."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:250
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr "B<RWF_APPEND> (Linux 4.16 以降)"

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: build/C/man2/readv.2:267
msgid ""
"Provide a per-write equivalent of the B<O_APPEND> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call.  The I<offset> argument does not "
"affect the write operation; the data is always appended to the end of the "
"file.  However, if the I<offset> argument is -1, the current file offset is "
"updated."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:279
msgid ""
"On success, B<readv>(), B<preadv>(), and B<preadv2>()  return the number of "
"bytes read; B<writev>(), B<pwritev>(), and B<pwritev2>()  return the number "
"of bytes written."
msgstr "成功した場合、 B<readv>(), B<preadv>, B<preadv2> は読み込んだバイト数を返し、 B<writev>(), B<pwritev>(), B<pwritev2> は書き込んだバイト数を返す。"

#. type: Plain text
#: build/C/man2/readv.2:285
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:287
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/readv.2:301
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>(), B<preadv2>(), B<pwritev>(), and B<pwritev2>()  can also fail "
"for the same reasons as B<lseek>(2).  Additionally, the following errors are "
"defined:"
msgstr "B<read>(2)  や B<write>(2)  と同じエラーが定義されている。さらに、 B<preadv>(), B<preadv2>, B<pwritev>(), B<pwritev2> は B<lseek>(2) と同じ理由でも失敗する。また、追加で以下のエラーが定義されている:"

#. type: Plain text
#: build/C/man2/readv.2:308
msgid "The sum of the I<iov_len> values overflows an I<ssize_t> value."
msgstr "I<iov_len> の合計が I<ssize_t> の範囲をオーバーフローした。"

#. type: Plain text
#: build/C/man2/readv.2:313
msgid ""
"The vector count, I<iovcnt>, is less than zero or greater than the permitted "
"maximum."
msgstr "ベクタ数 I<iovcnt> が 0 より小さいか許可された最大値よりも大きかった。"

#. type: Plain text
#: build/C/man2/readv.2:316
msgid "An unknown flag is specified in I<flags>."
msgstr "未知のフラグが I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/readv.2:321
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""
"B<preadv>() と B<pwritev>() は Linux 2.6.30 で初めて登場した。\n"
"ライブラリによるサポートは glibc 2.10 で追加された。"

#. type: Plain text
#: build/C/man2/readv.2:327
msgid ""
"B<preadv2>()  and B<pwritev2>()  first appeared in Linux 4.6.  Library "
"support was added in glibc 2.26."
msgstr "B<preadv2>() と B<pwritev2>() は Linux 4.6 で初めて登場した。ライブラリによるサポートは glibc 2.26 で追加された。"

#.  Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
#.  and \fIint\fP as the return type.
#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: build/C/man2/readv.2:336
msgid ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system "
"calls first appeared in 4.2BSD)."
msgstr "B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (これらのシステムコールは 4.2BSD で初めて登場した)"

#. type: Plain text
#: build/C/man2/readv.2:340
msgid ""
"B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr "B<preadv>(), B<pwritev>(): 非標準だが、最近の BSD にも存在する。"

#. type: Plain text
#: build/C/man2/readv.2:344
msgid "B<preadv2>(), B<pwritev2>(): nonstandard Linux extension."
msgstr "B<preadv2>(), B<pwritev2>(): 非標準の Linux による拡張。"

#. type: Plain text
#: build/C/man2/readv.2:358
msgid ""
"POSIX.1 allows an implementation to place a limit on the number of items "
"that can be passed in I<iov>.  An implementation can advertise its limit by "
"defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the return "
"value from I<sysconf(_SC_IOV_MAX)>.  On modern Linux systems, the limit is "
"1024.  Back in Linux 2.0 days, this limit was 16."
msgstr "POSIX.1 では、 I<iov> で渡すことができる要素数に上限を設ける実装が認められている。 実装はこの上限値を広告することができ、 I<E<lt>limits.hE<gt>> の B<IOV_MAX> を定義することや、 実行時に I<sysconf(_SC_IOV_MAX)> の返り値経由で知ることができる。 最近の Linux では、 この上限値は 1024 である。 Linux 2.0 の頃は、 この値は 16 であった。"

#. type: Plain text
#: build/C/man2/readv.2:368
msgid ""
"The raw B<preadv>()  and B<pwritev>()  system calls have call signatures "
"that differ slightly from that of the corresponding GNU C library wrapper "
"functions shown in the SYNOPSIS.  The final argument, I<offset>, is unpacked "
"by the wrapper functions into two arguments in the system calls:"
msgstr ""
"素のシステムコール B<preadv>() と B<pwritev>() のシグネチャーは、 「書式」に"
"書かれている対応する GNU C ライブラリのラッパー関数のものとは少し異なる。 最"
"後の引数 I<offset> はラッパー関数によりシステムコールの 2 つの引数に展開"
"される。"

#. type: Plain text
#: build/C/man2/readv.2:370
msgid "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"
msgstr "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"

#. type: Plain text
#: build/C/man2/readv.2:373
msgid ""
"These arguments contain, respectively, the low order and high order 32 bits "
"of I<offset>."
msgstr ""
"これらの引数は、それぞれ、 I<offset> の下位 32 ビットと上位 32 ビットであ"
"る。"

#. type: SS
#: build/C/man2/readv.2:373
#, no-wrap
msgid "Historical C library/kernel differences"
msgstr "以前の C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/readv.2:399
msgid ""
"To deal with the fact that B<IOV_MAX> was so low on early versions of Linux, "
"the glibc wrapper functions for B<readv>()  and B<writev>()  did some extra "
"work if they detected that the underlying kernel system call failed because "
"this limit was exceeded.  In the case of B<readv>(), the wrapper function "
"allocated a temporary buffer large enough for all of the items specified by "
"I<iov>, passed that buffer in a call to B<read>(2), copied data from the "
"buffer to the locations specified by the I<iov_base> fields of the elements "
"of I<iov>, and then freed the buffer.  The wrapper function for B<writev>()  "
"performed the analogous task using a temporary buffer and a call to "
"B<write>(2)."
msgstr ""
"古いバージョンの Linux では B<IOV_MAX> が非常に小さかったという事実に対処する"
"ため、 glibc の B<readv>() と B<writev>() のラッパー関数は、 その関数の内部で"
"呼ばれるカーネルシステムコールがこの上限を超過して失敗したことを検出すると、 "
"追加の動作をしていた。 B<readv>() の場合、 ラッパー関数は I<iov> で指定された"
"全ての要素を格納できる大きさの一時バッファーを割り当て、 B<read>(2) を呼び出"
"す際にそのバッファーを渡し、 そのバッファーのデータを I<iov> の各要素の "
"I<iov_base> フィールドが指定する場所にコピーしてから、 そのバッファーを解放し"
"ていた。 B<writev>() のラッパー関数も、 同じように一時バッファーを使って "
"B<write>(2) を呼び出していた。"

#. type: Plain text
#: build/C/man2/readv.2:410
msgid ""
"The need for this extra effort in the glibc wrapper functions went away with "
"Linux 2.2 and later.  However, glibc continued to provide this behavior "
"until version 2.10.  Starting with glibc version 2.9, the wrapper functions "
"provide this behavior only if the library detects that the system is running "
"a Linux kernel older than version 2.6.18 (an arbitrarily selected kernel "
"version).  And since glibc 2.20 (which requires a minimum Linux kernel "
"version of 2.6.32), the glibc wrapper functions always just directly invoke "
"the system calls."
msgstr ""
"glibc ラッパー関数でのこの追加の動作は Linux 2.2 以降では必要なくなった。 し"
"かし、 glibc はバージョン 2.10 まではこの動作を続けていた。 glibc 2.9 以降で"
"は、 システムがバージョン 2.6.18 より前の Linux カーネル (2.6.18 は勝手に選択"
"したカーネルバージョンである) を実行しているとライブラリが検出した場合にの"
"み、 ラッパー関数はこの動作を行う。 glibc 2.20 以降では、 (Linux カーネルの"
"バージョン 2.6.32 以降が必須条件となり) glibc のラッパー関数は常にシステム"
"コールを直接呼び出すようになっている。"

#. type: Plain text
#: build/C/man2/readv.2:413
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr "以下のサンプルコードは B<writev>()  の使用方法を示すものである。"

#. type: Plain text
#: build/C/man2/readv.2:420
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"

#. type: Plain text
#: build/C/man2/readv.2:425
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"

#. type: Plain text
#: build/C/man2/readv.2:427
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr "nwritten = writev(STDOUT_FILENO, iov, 2);\n"

#. type: Plain text
#: build/C/man2/readv.2:433
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr "B<pread>(2), B<read>(2), B<write>(2)"

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr "REMOVE"

#. type: Plain text
#: build/C/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr "remove - ファイルやディレクトリを削除する"

#. type: Plain text
#: build/C/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr "B<int remove(const char *>I<pathname>B<);>"

#. type: Plain text
#: build/C/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the filesystem.  It calls B<unlink>(2)  for "
"files, and B<rmdir>(2)  for directories."
msgstr ""
"B<remove>()  はファイルシステムからファイル名を削除する。 ファイルに対しては "
"B<unlink>(2)  を、ディレクトリに対しては B<rmdir>(2)  を呼び出す。"

#. type: Plain text
#: build/C/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""
"もしその名前が ファイルへの最後のリンクで、かつ、どのプロセスもそのファイル"
"を 開いていないなら、ファイルも削除する。ファイルの占めていた 領域は他で使う"
"ことができるようになる。"

#. type: Plain text
#: build/C/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"名前がファイルへの最後のリンクであっても、どこかのプロセスが そのファイルを開"
"いているなら、ファイルの最後のファイルディスクリプター (file descriptor) が閉"
"じられるまでファイルは存在し続ける。"

#. type: Plain text
#: build/C/man3/remove.3:57 build/C/man2/unlink.2:78
msgid "If the name referred to a symbolic link, the link is removed."
msgstr "名前が指しているのがシンボリックリンクなら、そのリンクを削除する。"

#. type: Plain text
#: build/C/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""
"名前が指しているのがソケット、FIFO、デバイスの場合、名前は削除されるが、 その"
"ソケットなどを開いているプロセスはそのまま使い続けることができる。"

#. type: Plain text
#: build/C/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr "発生するエラーは B<unlink>(2)  および B<rmdir>(2)  と同じものである。"

#. type: tbl table
#: build/C/man3/remove.3:80
#, no-wrap
msgid "B<remove>()"
msgstr "B<remove>()"

#.  .SH NOTES
#.  Under libc4 and libc5,
#.  .BR remove ()
#.  was an alias for
#.  .BR unlink (2)
#.  (and hence would not remove directories).
#. type: Plain text
#: build/C/man3/remove.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."

#. type: Plain text
#: build/C/man3/remove.3:93 build/C/man2/unlink.2:305
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""
"NFS プロトコルに内在する問題により、まだ使用中のファイルが想定外に消えてしま"
"うことがありえる。"

#. type: Plain text
#: build/C/man3/remove.3:104
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"

#. type: TH
#: build/C/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr "RENAME"

#. type: Plain text
#: build/C/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr "rename, renameat, renameat2 - ファイルの名前や位置を変更する"

#. type: Plain text
#: build/C/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: build/C/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: build/C/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/rename.2:59
msgid "B<renameat>():"
msgstr "B<renameat>():"

#. type: Plain text
#: build/C/man2/rename.2:71
msgid "B<renameat2>():"
msgstr "B<renameat2>():"

#. type: Plain text
#: build/C/man2/rename.2:86
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""
"B<rename>()  はファイルの名前を変更し、必要ならばディレクトリ間の移動を行な"
"う。 そのファイルに対する (B<link>(2)  を使用して作られた) 他のハードリンク "
"(hard link) には影響はない。 オープン済の I<oldpath> に対するファイルディスク"
"リプターにも影響はない。"

#. type: Plain text
#: build/C/man2/rename.2:89
msgid ""
"Various restrictions determine whether or not the rename operation succeeds: "
"see ERRORS below."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:101
#, fuzzy
#| msgid ""
#| "If I<newpath> already exists, it will be atomically replaced (subject to "
#| "a few conditions; see ERRORS below), so that there is no point at which "
#| "another process attempting to access I<newpath> will find it missing."
msgid ""
"If I<newpath> already exists, it will be atomically replaced, so that there "
"is no point at which another process attempting to access I<newpath> will "
"find it missing.  However, there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""
"I<newpath> が既に存在する場合、それは不可分操作で (atomically) 置き換えられ"
"る (ただし、いくつかの条件がある; 以下の「エラー」のセクションを参照)。 その"
"ため、 I<newpath> にアクセスしようとしている他のプロセスがファイルを見失うこ"
"とはない (訳註: 常にアクセス可能である)。"

#. type: Plain text
#: build/C/man2/rename.2:109
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""
"I<oldpath> と I<newpath> がどちらも既存のハードリンクで、同じファイルを参照し"
"ている場合、 B<rename>()  は何も行わず、ステータスとして成功を返す。"

#. type: Plain text
#: build/C/man2/rename.2:117
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""
"I<newpath> が存在し、何らかの理由で操作が失敗した場合、 B<rename>()  は "
"I<newpath> の実体を元のまま残すことを保証する。"

#. type: Plain text
#: build/C/man2/rename.2:123
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""
"I<oldpath> にはディレクトリを指定することもできる。 この場合、 I<newpath> は"
"存在しないか、空のディレクトリでなければならない。"

#. type: Plain text
#: build/C/man2/rename.2:129
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""
"I<oldpath> がシンボリックリンク (symbolic link) を参照している場合は、 リンク"
"の名前が変更される。 また、 I<newpath> がシンボリックリンクを参照している場合"
"は、リンクが上書きされる。"

#. type: SS
#: build/C/man2/rename.2:129
#, no-wrap
msgid "renameat()"
msgstr "renameat()"

#. type: Plain text
#: build/C/man2/rename.2:135
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""
"B<renameat>() システムコールは B<rename>() と全く同様に動作するが、以下で説明"
"する点が異なる。"

#. type: Plain text
#: build/C/man2/rename.2:145
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""
"I<oldpath> で指定されたパス名が相対パスの場合、このパス名はファイルディスクリ"
"プター I<olddirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<rename>(2) に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/rename.2:157
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""
"I<oldpath> で指定されたパス名が相対パスで、 I<olddirfd> が特別な値 "
"B<AT_FDCWD> の場合、 (B<rename>(2) と同様に) I<oldpath> は呼び出したプロセス"
"のカレントワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/rename.2:176
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr "B<renameat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: SS
#: build/C/man2/rename.2:176
#, no-wrap
msgid "renameat2()"
msgstr "renameat2()"

#. type: Plain text
#: build/C/man2/rename.2:187
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call "
"with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""
"B<renameat2>() には追加の I<flags> 引数がある。 I<flags> 引数が 0 の "
"B<renameat2>() の呼び出しは B<renameat>() と等価である。"

#. type: Plain text
#: build/C/man2/rename.2:191
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr "I<flags> 引数は、以下のフラグの 0 個以上のビットマスクである。"

#. type: TP
#: build/C/man2/rename.2:191
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr "B<RENAME_EXCHANGE>"

#. type: Plain text
#: build/C/man2/rename.2:200
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""
"I<oldpath> と I<newpath> をアトミックに入れ換える。 両方のパス名が存在しなけ"
"ればならないが、 ファイル種別は異なっていてもよい (例えば、一方は空でないディ"
"レクトリで、もう一方はシンボリックリンクであるなど)。"

#. type: TP
#: build/C/man2/rename.2:200
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr "B<RENAME_NOREPLACE>"

#. type: Plain text
#: build/C/man2/rename.2:208
msgid ""
"Don't overwrite I<newpath> of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""
"rename の I<newpath> を上書きしない。 I<newpath> がすでに存在する場合エラーを"
"返す。"

#. type: Plain text
#: build/C/man2/rename.2:212
msgid "B<RENAME_NOREPLACE> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:216
msgid ""
"B<RENAME_NOREPLACE> requires support from the underlying filesystem.  "
"Support for various filesystems was added as follows:"
msgstr ""

#.  ext4: commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
#. type: Plain text
#: build/C/man2/rename.2:220
msgid "ext4 (Linux 3.15);"
msgstr " ext4 (Linux 3.15);"

#. type: Plain text
#: build/C/man2/rename.2:222
msgid "btrfs, shmem, and cifs (Linux 3.17);"
msgstr " btrfs, shmem, cifs (Linux 3.17);"

#.  btrfs: commit 80ace85c915d0f41016f82917218997b72431258
#.  shmem: commit 3b69ff51d087d265aa4af3a532fc4f20bf33e718
#.  cifs: commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
#.  gfs2 in 4.2?
#. type: Plain text
#: build/C/man2/rename.2:229
msgid "xfs (Linux 4.0);"
msgstr " xfs (Linux 4.0);"

#.  Also affs, bfs, exofs, hfs, hfsplus, jffs2, logfs, msdos,
#.  nilfs2, omfs, sysvfs, ubifs, udf, ufs
#.  hugetlbfs, ramfs
#.  local filesystems: commit f03b8ad8d38634d13e802165cc15917481b47835
#.  libfs: commit e0e0be8a835520e2f7c89f214dfda570922a1b90
#. type: Plain text
#: build/C/man2/rename.2:237
msgid ""
"Support for many other filesystems was added in Linux 4.9, including ext2, "
"minix, reiserfs, jfs, vfat, and bpf."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:238
#, no-wrap
msgid "B<RENAME_WHITEOUT> (since Linux 3.18)"
msgstr "B<RENAME_WHITEOUT> (Linux 3.18 以降)"

#.  commit 0d7a855526dd672e114aff2ac22b60fc6f155b08
#.  commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
#. type: Plain text
#: build/C/man2/rename.2:244
msgid ""
"This operation makes sense only for overlay/union filesystem implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:251
msgid ""
"Specifying B<RENAME_WHITEOUT> creates a \"whiteout\" object at the source of "
"the rename at the same time as performing the rename.  The whole operation "
"is atomic, so that if the rename succeeds then the whiteout will also have "
"been created."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:259
msgid ""
"A \"whiteout\" is an object that has special meaning in union/overlay "
"filesystem constructs.  In these constructs, multiple layers exist and only "
"the top one is ever modified.  A whiteout on an upper layer will effectively "
"hide a matching file in the lower layer, making it appear as if the file "
"didn't exist."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:267
msgid ""
"When a file that exists on the lower layer is renamed, the file is first "
"copied up (if not already on the upper layer)  and then renamed on the "
"upper, read-write layer.  At the same time, the source file needs to be "
"\"whiteouted\" (so that the version of the source file in the lower layer is "
"rendered invisible).  The whole operation needs to be done atomically."
msgstr ""

#.  https://www.freebsd.org/cgi/man.cgi?query=mount_unionfs&manpath=FreeBSD+11.0-RELEASE
#. type: Plain text
#: build/C/man2/rename.2:278
msgid ""
"When not part of a union/overlay, the whiteout appears as a character device "
"with a {0,0} device number.  (Note that other union/overlay implementations "
"may employ different methods for storing whiteout entries; specifically, BSD "
"union mount employs a separate inode type, B<DT_WHT>, which, while supported "
"by some filesystems available in Linux, such as CODA and XFS, is ignored by "
"the kernel's whiteout support code, as of Linux 4.19, at least.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:283
msgid ""
"B<RENAME_WHITEOUT> requires the same privileges as creating a device node (i."
"e., the B<CAP_MKNOD> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:287
msgid "B<RENAME_WHITEOUT> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#.  tmpfs: commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
#.  ext4: commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
#.  XFS: commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
#.  f2fs: commit 7e01e7ad746bc8198a8b46163ddc73a1c7d22339
#.  btrfs: commit cdd1fedf8261cd7a73c0596298902ff4f0f04492
#.  ubifs: commit 9e0a1fff8db56eaaebb74b4a3ef65f86811c4798
#. type: Plain text
#: build/C/man2/rename.2:303
msgid ""
"B<RENAME_WHITEOUT> requires support from the underlying filesystem.  Among "
"the filesystems that provide that support are tmpfs (since Linux 3.18), ext4 "
"(since Linux 3.18), XFS (since Linux 4.1), f2fs (since Linux 4.2), btrfs "
"(since Linux 4.7), and ubifs (since Linux 4.9)."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:328
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""
"I<oldpath> または I<newpath> を含んでいるディレクトリの書き込み許可がない。 "
"または、 I<oldpath> または I<newpath> のディレクトリ部分のどれかに検索許可が"
"ない。 または、 I<oldpath> がディレクトリで (I<..> エントリーを更新するのに必"
"要な) 書き込み許可がない (B<path_resolution>(7)  も参照)。"

#. type: Plain text
#: build/C/man2/rename.2:345
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such cases"
"\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""
"I<oldpath> または I<newpath> がディレクトリで、何らかのプロセスが使用中 (多"
"分、カレントワーキングディレクトリか、ルートディレクトリか、 読み込みのために"
"オープンされているかでろう)  もしくは、システムが使用中 (例えばマウントポイン"
"トである)  であり、システムがこれをエラーであると判断したために rename が失敗"
"した。 (このような場合に B<EBUSY> を返すことは規格では要求されていない点に注"
"意すること。 このような場合に、rename をとにかく実行してみるのは何の問題もな"
"い。 ただし、そのような状況で、システムが他に返すエラーがない場合には "
"B<EBUSY> を返すことが許されている。)"

#. type: Plain text
#: build/C/man2/rename.2:355
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""
"I<newpath> が I<oldpath> のパス部分を含んでいる。ディレクトリを自分自身のサブ"
"ディレクトリに 変更しようとした場合がほとんどである。"

#. type: Plain text
#: build/C/man2/rename.2:361
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""
"I<newpath> は存在しているディレクトリであるが、 I<oldpath> はディレクトリでな"
"い。"

#. type: Plain text
#: build/C/man2/rename.2:372
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""
"I<oldpath> は既に最大数までのリンクを持っているか、それがディレクトリで "
"I<newpath> を含んでいるディレクトリが最大数までのリンクを持っている。"

#. type: Plain text
#: build/C/man2/rename.2:388
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""
"I<oldpath> という名前のリンクが存在しない。 または、 I<newpath> というディレ"
"クトリが存在しない。 または、 I<oldpath> か I<newpath> が空の文字列である。"

#. type: Plain text
#: build/C/man2/rename.2:405
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""
"I<oldpath> か I<newpath> に含まれているディレクトリ部分が 実際にはディレクト"
"リでない。 または I<oldpath> がディレクトリで、 I<newpath> が存在してディレク"
"トリでない。"

#. type: TP
#: build/C/man2/rename.2:405
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr "B<ENOTEMPTY  または  EEXIST>"

#. type: Plain text
#: build/C/man2/rename.2:409
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than \"."
"\" and \"..\"."
msgstr ""
"I<newpath> が空でないディレクトリである。すなわち \".\" と \"..\" 以外を含ん"
"でいる。"

#. type: TP
#: build/C/man2/rename.2:409 build/C/man2/unlink.2:224
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr "B<EPERM> または B<EACCES>"

#. type: Plain text
#: build/C/man2/rename.2:433
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""
"I<oldpath> のあるディレクトリにスティッキービット (sticky bit)  "
"(B<S_ISVTX>)  が設定されており、 プロセスの実効ユーザー ID が 削除しようとす"
"るファイルのユーザー ID と そのファイルを含むディレクトリのユーザー ID のいず"
"れとも一致せず、かつ プロセスに特権がない (Linux では B<CAP_FOWNER> ケーパビ"
"リティ (capability) がない)。 または、 I<newpath> がすでに存在するファイル"
"で、親ディレクトリにスティッキービットが設定されており、 プロセスの実効ユー"
"ザー ID が 置き換えようとするファイルのユーザー ID と そのファイルを含むディ"
"レクトリのユーザー ID のいずれとも一致せず、かつ プロセスに特権がない (Linux "
"では B<CAP_FOWNER> ケーパビリティがない)。 または I<oldpath> と I<newpath> が"
"存在するファイルシステムが、要求された種類の名前の変更を サポートしていない。"

#. type: Plain text
#: build/C/man2/rename.2:444
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""
"I<oldpath> と I<newpath> が同じマウントされたファイルシステムに存在しない。 "
"(Linux は 1 つのファイルシステムを複数のマウント位置に マウントすることを許可"
"している。 しかし B<rename>()  は、たとえ同じファイルシステムであっても、 "
"別々のマウント位置を跨いでは動作しない。)"

#. type: Plain text
#: build/C/man2/rename.2:449
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr "B<renameat>() と B<renameat2>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/rename.2:468
msgid "The following additional errors can occur for B<renameat2>():"
msgstr "B<renameat2>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/rename.2:476
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""
"I<flags> に B<RENAME_NOREPLACE> が指定されているが、 I<newpath> がすでに存在"
"する。"

#. type: Plain text
#: build/C/man2/rename.2:480
msgid "An invalid flag was specified in I<flags>."
msgstr "無効なフラグ値が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/rename.2:488
msgid ""
"Both B<RENAME_NOREPLACE> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr "B<RENAME_NOREPLACE> と B<RENAME_EXCHANGE> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/rename.2:496
msgid ""
"Both B<RENAME_WHITEOUT> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:500
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr "I<flags> にファイルシステムでサポートされていないフラグが指定された。"

#. type: Plain text
#: build/C/man2/rename.2:508
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr ""
"I<flags> に B<RENAME_EXCHANGE> が指定されたが、 I<newpath> が存在しない。"

#. type: Plain text
#: build/C/man2/rename.2:516
msgid ""
"B<RENAME_WHITEOUT> was specified in I<flags>, but the caller does not have "
"the B<CAP_MKNOD> capability."
msgstr "B<RENAME_WHITEOUT> が I<flags> に指定されたが、呼び出し元が B<CAP_MKNOD> ケーパビリティを持っていない。"

#. type: Plain text
#: build/C/man2/rename.2:520
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<renameat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#. type: Plain text
#: build/C/man2/rename.2:523
msgid ""
"B<renameat2>()  was added to Linux in kernel 3.15; library support was added "
"in glibc 2.28."
msgstr "B<renameat2>()  はカーネル 3.15 で Linux に追加された。 ライブラリによるサポートは glibc 2.28 で追加された。"

#. type: Plain text
#: build/C/man2/rename.2:526
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/rename.2:529
msgid "B<renameat>(): POSIX.1-2008."
msgstr "B<renameat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/rename.2:532
msgid "B<renameat2>()  is Linux-specific."
msgstr "B<renameat2>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/rename.2:551
msgid ""
"On older kernels where B<renameat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<rename>().  When I<oldpath> and "
"I<newpath> are relative pathnames, glibc constructs pathnames based on the "
"symbolic links in I</proc/self/fd> that correspond to the I<olddirfd> and "
"I<newdirfd> arguments."
msgstr ""
"B<renameat>() が利用できない古いカーネルでは、 glibc ラッパー関数は "
"B<rename>() を使用するモードにフォールバックする。 I<oldpath> と I<newpath> "
"が相対パスの場合、 glibc は I<olddirfd> と I<newdirfd> 引数に対応する I</"
"proc/self/fd> のシンボリックリンクに基づいてそれぞれパス名を構成する。"

#. type: Plain text
#: build/C/man2/rename.2:562
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""
"NFS ファイルシステムでは、操作が失敗したからといって、 ファイルの名前が変更で"
"きなかったと決めてかかることはできない。 サーバが rename 操作を終えてからク"
"ラッシュした場合、 サーバが再び立ち上がったときに、 再送信された RPC が処理さ"
"れるが、これは失敗となる。 アプリケーションはこの問題を正しく取り扱うことが期"
"待されている。 同様の問題について B<link>(2)  にも書かれている。"

#. type: Plain text
#: build/C/man2/rename.2:571
msgid ""
"B<mv>(1), B<rename>(1), B<chmod>(2), B<link>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr " B<mv>(1), B<rename>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr "RMDIR"

#. type: Plain text
#: build/C/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr "rmdir - ディレクトリを削除する"

#. type: Plain text
#: build/C/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr "B<int rmdir(const char *>I<pathname>B<);>"

#. type: Plain text
#: build/C/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""
"B<rmdir>()  はディレクトリを削除する。削除するディレクトリは空でなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""
"I<pathname> を含んでいるディレクトリへの書き込みアクセスが プロセスの実効 "
"(effective) UID に対して許可されていないか、 I<pathname> に含まれているディレ"
"クトリのどれかに検索 (実行) 許可がないか、 I<pathname> に至るまでのディレクト"
"リのいずれかに対する検索許可がなかった。 (B<path_resolution>(7)  も参照のこ"
"と)"

#. type: Plain text
#: build/C/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux, this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""
"I<pathname> がシステムや別のプロセスにより使用中で削除することができない。 "
"Linux では、 I<pathname> がマウントポイントとして使用されているか、 呼び出し"
"たプロセスのルートディレクトリであることを意味する。"

#. type: Plain text
#: build/C/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr "I<pathname> の最後のディレクトリ部分が I<.> である。"

#. type: Plain text
#: build/C/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""
"I<pathname> か I<pathname> に含まれているディレクトリ部分が、実際には、ディレ"
"クトリでない。"

#. type: TP
#: build/C/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man2/rmdir.2:108
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1 also allows B<EEXIST> for this "
"condition."
msgstr "ディレクトリ I<pathname> に I<.> と I<..> 以外のエントリーがある。または、 I<pathname> を構成する最後の要素が I<..> である。 POSIX.1 は、この状況で B<EEXIST> を返すことを認めている。"

#. type: Plain text
#: build/C/man2/rmdir.2:119
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"I<pathname> を含んでいるディレクトリにスティッキービット(sticky-bit)  "
"(B<S_ISVTX>)  が設定されていて、プロセスの実効ユーザーID が削除しようとする"
"ファイルの ユーザーID とそのファイルを含むディレクトリのユーザーID のどちらと"
"も異なり、 プロセスも権限 (Linux では B<CAP_FOWNER> ケーパビリティ) がない。"

#. type: Plain text
#: build/C/man2/rmdir.2:124
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""
"I<pathname> を含んでいるファイルシステムがディレクトリの 削除をサポートしてい"
"ない。"

#. type: Plain text
#: build/C/man2/rmdir.2:128
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""
"I<pathname> が読み込み専用のファイルシステム上のディレクトリを参照している。"

#. type: Plain text
#: build/C/man2/rmdir.2:133
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""
"NFS プロトコルに潜在している欠陥によって、まだ使用中のディレクトリが 突然消滅"
"する現象が引き起こされることがある。"

#. type: Plain text
#: build/C/man2/rmdir.2:142
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"

#. type: TH
#: build/C/man3/scanf.3:52
#, no-wrap
msgid "SCANF"
msgstr "SCANF"

#. type: Plain text
#: build/C/man3/scanf.3:55
msgid ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr "scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - 書式付き入力変換"

#. type: Plain text
#: build/C/man3/scanf.3:62
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: build/C/man3/scanf.3:68
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: build/C/man3/scanf.3:79
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"

#. type: Plain text
#: build/C/man3/scanf.3:81
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr " _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/scanf.3:100
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""
"B<scanf>()  関数グループは、以下に述べるように、 I<format> に従って入力を読み"
"込むものである。 この書式には I<「変換指定」 (conversion specifications)> を"
"含めることができ、変換指定があれば、その変換の結果は I<format> に続く "
"I<pointer> 引数が指す場所に格納される。 それぞれの I<pointer> 引数の型"
"は、対応する変換指定が返す値に 適合していなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:111
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""
"I<format> 中の変換指定の個数が I<pointer> 引数の数より多かった場合の結果は"
"未定義である。 I<pointer> 引数の数が変換指定の個数よりも多かった場合、 余分"
"な I<pointer> 引数の評価は行われるが、それ以外は行われず無視される。"

#. type: Plain text
#: build/C/man3/scanf.3:123
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""
"B<scanf>()  関数は標準入力ストリーム I<stdin> からの入力を読み込む。 "
"B<fscanf>()  はストリームポインター I<stream> からの入力を読み込む。 "
"B<sscanf>()  は文字列ポインター I<str> で示された文字列からの入力を読み込む。"

#. type: Plain text
#: build/C/man3/scanf.3:141
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""
"B<vfscanf>()  関数は B<vfprintf>(3)  と同様に、ストリームポインター "
"I<stream> からの入力をポインターの可変長引数リストを用いて読み込む "
"(B<stdarg>(3)  を参照)。 B<vscanf>()  関数は、可変長引数のリストに基づき標"
"準入力からの読み取りを行う。 B<vsscanf>()  関数はそのリストに基づき文字列から"
"読み取る。 これらの関係は B<vprintf>(3)  と B<vsprintf>(3)  関数の関係と同様"
"である。"

#. type: Plain text
#: build/C/man3/scanf.3:155
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""
"I<format> 文字列は I<「命令」 (directive)> の列で構成される。命令は入力文字の"
"系列をどのように処理するかを指示する ものである。ある命令の処理が失敗すると、"
"入力はそれ以上読み込まれず、 B<scanf>()  は返る。「失敗」は I<「入力の失敗」 "
"(input failure)> と I<「一致の失敗」 (matching failure)> のいずれかである。 "
"入力の失敗は入力文字が使用できなかったことを意味し、 一致の失敗は入力が不適切"
"であったこと (下記参照) を意味する。"

#. type: Plain text
#: build/C/man3/scanf.3:157
msgid "A directive is one of the following:"
msgstr "命令は以下のいずれかである:"

#. type: Plain text
#: build/C/man3/scanf.3:163
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""
"ホワイトスペース (スペース、タブ、改行など; B<isspace>(3)  参照) の列。 この"
"命令は、入力中の任意の個数のホワイトスペースに一致する。 (「何もなし」にも一"
"致する)。"

#. type: Plain text
#: build/C/man3/scanf.3:167
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""
"通常文字 (つまり、ホワイトスペースと \\(aq%\\(aq 以外の文字)。 この文字は入力"
"の次の文字に正確に一致しなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:178
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""
"変換指定。変換指定は \\(aq%\\(aq (パーセント) 文字で始まる。 入力された文字の"
"系列はこの指定にもとづいて変換され、 変換結果は対応する I<pointer> 引数が指"
"す場所に格納される。 入力の次の文字が変換指定と一致しない場合は、変換は失敗す"
"る \\(emこれが I<「一致の失敗」 (matching failure)> である。"

#. type: Plain text
#: build/C/man3/scanf.3:186
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""
"I<format> 中の各々の I<「変換指定」> は文字 \\(aq%\\(aq か文字系列 \"B<"
"%>I<n>B<$>\" (違いについては後述) で始まり、以下の要素が続く。"

#. type: Plain text
#: build/C/man3/scanf.3:197
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""
"代入抑制文字 \\(aq*\\(aq (省略可能)。 B<scanf>()  は変換指定に指示された通り"
"入力を読み込むが、その入力は捨てられる。 対応する I<pointer> 引数は必要な"
"く、 B<scanf>()  が返す代入が成功した数にこの指定は含まれない。"

#. type: Plain text
#: build/C/man3/scanf.3:208
msgid ""
"For decimal conversions, an optional quote character (\\(aq).  This "
"specifies that the input number may include thousands' separators as defined "
"by the B<LC_NUMERIC> category of the current locale.  (See "
"B<setlocale>(3).)  The quote character may precede or follow the \\(aq*\\(aq "
"assignment-suppression character."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:227
msgid ""
"An optional \\(aqm\\(aq character.  This is used with string conversions (I<"
"%s>, I<%c>, I<%[>), and relieves the caller of the need to allocate a "
"corresponding buffer to hold the input: instead, B<scanf>()  allocates a "
"buffer of sufficient size, and assigns the address of this buffer to the "
"corresponding I<pointer> argument, which should be a pointer to a I<char\\ "
"*> variable (this variable does not need to be initialized before the "
"call).  The caller should subsequently B<free>(3)  this buffer when it is no "
"longer required."
msgstr ""
"文字 \\(aqm\\(aq (省略可能)。これは文字列変換 (I<%s>, I<%c>, I<%[>) とともに"
"使用され、これを使うと 呼び出し元が入力を保持する対応するバッファーを確保する"
"必要がなくなる。 代わりに B<scanf>()  が必要な大きさのバッファーを確保し、こ"
"のバッファーのアドレスを 対応する I<pointer> 引数に代入する。 I<pointer> 引"
"数は I<char\\ *> 型の変数へのポインターでなければならない (変数自体は呼び出"
"し前に初期化されている必要はない)。 呼び出し元は、不要になった時点で、この"
"バッファーを B<free>(3) すべきである。"

#. type: Plain text
#: build/C/man3/scanf.3:239
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""
"I<「最大フィールド幅」> を指定する 10進数 (省略可能)。 この最大値に達するか、"
"一致しない文字が見つかるか、のどちらかに なると、文字の読み込みを停止する。 "
"ほとんどの変換では、先頭のホワイトスペース文字は捨てられ (例外については後述"
"する)、 捨てられたこれらの文字は最大フィールド幅の計算には含まれない。 文字列"
"の入力変換では、入力の末尾を示す終端のヌルバイト (\\(aq\\e0\\(aq)  も格納され"
"るが、最大フィールド幅にはこの終端バイトは含まれない。"

#. type: Plain text
#: build/C/man3/scanf.3:253
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long> rather than a pointer "
"to an I<int>."
msgstr "I<「型修飾子」 (type modifier characters)> (省略可能)。 例えば、型修飾子 B<l> を B<%d> などの整数変換と一緒に使うと、対応する I<pointer> 引数が I<int> ではなく I<long> を参照していることを指定できる。"

#. type: Plain text
#: build/C/man3/scanf.3:258
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr "I<「変換指定」> : 実行すべき入力変換の種類を指定する。"

#. type: Plain text
#: build/C/man3/scanf.3:287
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications, then these correspond in "
"order with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form "
"(which is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer "
"that specifies that the converted input should be placed in the location "
"referred to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""
"I<format> 中の変換指定は、\\(aq%\\(aq で始まるか、 \"B<%>I<n>B<$>\" で始まる"
"かの、いずれかの形式である。 これら 2つの形式を同じ I<format> 文字列に混ぜる"
"ことはできない。但し、\"B<%>I<n>B<$>\" を 含む文字列に B<%%> と B<%*> を含め"
"ることはできる。 I<format> に \\(aq%\\(aq 指定が含まれている場合、各々の "
"\\(aq%\\(aq 指定と 後続の I<pointer> 引数はその順番通りに対応する。 \"B<"
"%>I<n>B<$>\" 形式 (POSIX.1-2001 では規定されているが、C99 にはない)  では、 "
"I<n> は 10進数であり、変換後の入力を I<format> の後ろの I<n> 番目の "
"I<pointer> 引数が参照する場所に格納することを指定する。"

#. type: SS
#: build/C/man3/scanf.3:287
#, no-wrap
msgid "Conversions"
msgstr "変換"

#. type: Plain text
#: build/C/man3/scanf.3:291
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr "変換指定には、以下の I<「型修飾子」> を入れることができる。"

#. type: Plain text
#: build/C/man3/scanf.3:301
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short> or I<unsigned "
"short> (rather than I<int>)."
msgstr "変換が B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<n> のいずれかであり、次のポインターが (I<int> ではなく)  I<short> か I<unsigned short> へのポインターであることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:309
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""
"B<h> と同じだが、次のポインターが I<signed char> か I<unsigned char> へのポイ"
"ンターであることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:318
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""
"B<h> と同じだが、次のポインターが I<intmax_t> か I<uintmax_t> へのポインター"
"であることを示す。 この修飾子は C99 で導入された。"

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: build/C/man3/scanf.3:345
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long> or "
"I<unsigned long> (rather than I<int>), or that the conversion will be one of "
"B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> (rather "
"than I<float>).  Specifying two B<l> characters is equivalent to B<L>.  If "
"used with B<%c> or B<%s>, the corresponding parameter is considered as a "
"pointer to a wide character or wide-character string respectively."
msgstr "変換が B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<n> か B<n> のいずれかであり次のポインターが (I<int> ではなく)  I<long> か I<unsigned long> へのポインターであること、または、変換が B<e>, B<f>, B<g> のうちのひとつであり次のポインターが (I<float> ではなく)  I<double> へのポインターであることのいずれかであることを示す。 B<l> 文字を二つ指定すると、 B<L> と同じ意味となる。 B<%c> や B<%s> とともに使用すると、 パラメーターはそれぞれワイド文字やワイド文字列へのポインターであると みなされる。"

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: build/C/man3/scanf.3:361
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""
"B<e>, B<f>, B<g> 変換で、次のポインターが I<long double> へのポインターである"
"ことを示す。もしくは、 B<d>, B<i>, B<o>, B<u>, B<x> 変換で、次のポインターが "
"I<long long> へのポインターであることのいずれかであることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:366
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr "B<L> と同一である。 この修飾子は ANSI C には存在しない。"

#. type: Plain text
#: build/C/man3/scanf.3:373
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""
"B<h> と同様だが、次のポインターが I<ptrdiff_t> へのポインターであることを示"
"す。 この修飾子は C99 で導入された。"

#. type: Plain text
#: build/C/man3/scanf.3:380
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""
"B<h> と同様だが、次のポインターが I<size_t> へのポインターであることを示す。 "
"この修飾子は C99 で導入された。"

#. type: Plain text
#: build/C/man3/scanf.3:384
msgid "The following I<conversion specifiers> are available:"
msgstr "以下の I<「変換指定子」> が利用可能である。"

#. type: Plain text
#: build/C/man3/scanf.3:393
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not occur."
msgstr ""
"文字 \\(aq%\\(aq に対応する。 書式文字列の中の B<%\\&%> は単一の文字 \\(aq%"
"\\(aq に対応する。 変換は行われず (但し、先頭のホワイトスペース文字は捨てられ"
"る)、 変数への代入は生じない。"

#. type: TP
#: build/C/man3/scanf.3:393
#, no-wrap
msgid "B<d>"
msgstr "B<d>"

#.  .TP
#.  .B D
#.  Equivalent to
#.  .IR ld ;
#.  this exists only for backward compatibility.
#.  (Note: thus only in libc4
#.  In libc5 and glibc the
#.  .B %D
#.  is silently ignored, causing old programs to fail mysteriously.)
#. type: Plain text
#: build/C/man3/scanf.3:407
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""
"符号つきの 10進の整数に対応する。 次のポインターは I<int> へのポインターでな"
"ければならない。"

#. type: TP
#: build/C/man3/scanf.3:407
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: build/C/man3/scanf.3:419
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""
"符号つき整数に対応する。 次のポインターは I<int> へのポインターでなければなら"
"ない。 この整数は I<0x> または I<0X> で開始する場合には 16 進数、 I<0> で開始"
"する場合には 8 進数、その他の場合には 10進数として読み込まれる。 この変換で使"
"用される文字は、これらの基数に対応しているものだけである。"

#. type: TP
#: build/C/man3/scanf.3:419
#, no-wrap
msgid "B<o>"
msgstr "B<o>"

#. type: Plain text
#: build/C/man3/scanf.3:423
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"符号なしの 8 進の整数に対応する。 次のポインターは I<unsigned int> でなければ"
"ならない。"

#. type: TP
#: build/C/man3/scanf.3:423
#, no-wrap
msgid "B<u>"
msgstr "B<u>"

#. type: Plain text
#: build/C/man3/scanf.3:428
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"符号なしの 10進の整数に対応する。 次のポインターは I<unsigned int> へのポイン"
"ターでなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:438
#, fuzzy
#| msgid ""
#| "Matches an unsigned hexadecimal integer; the next pointer must be a "
#| "pointer to I<unsigned int>."
msgid ""
"Matches an unsigned hexadecimal integer (that may optionally begin with a "
"prefix of I<0x> or I<0X>, which is discarded); the next pointer must be a "
"pointer to I<unsigned int>."
msgstr ""
"符号なしの 16 進の整数に対応する。 次のポインターは I<unsigned int> へのポイ"
"ンターでなければならない。"

#. type: TP
#: build/C/man3/scanf.3:438
#, no-wrap
msgid "B<X>"
msgstr "B<X>"

#. type: Plain text
#: build/C/man3/scanf.3:442
msgid "Equivalent to B<x>."
msgstr "B<x> と同一である。"

#. type: TP
#: build/C/man3/scanf.3:442
#, no-wrap
msgid "B<f>"
msgstr "B<f>"

#. type: Plain text
#: build/C/man3/scanf.3:447
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""
"符号つき浮動小数点実数に対応する。 次のポインターは I<float> へのポインターで"
"なければならない。"

#. type: TP
#: build/C/man3/scanf.3:447
#, no-wrap
msgid "B<e>"
msgstr "B<e>"

#. type: Plain text
#: build/C/man3/scanf.3:451 build/C/man3/scanf.3:455 build/C/man3/scanf.3:459
msgid "Equivalent to B<f>."
msgstr "B<f> と同一である。"

#. type: TP
#: build/C/man3/scanf.3:451
#, no-wrap
msgid "B<g>"
msgstr "B<g>"

#. type: TP
#: build/C/man3/scanf.3:455
#, no-wrap
msgid "B<E>"
msgstr "B<E>"

#. type: Plain text
#: build/C/man3/scanf.3:463
msgid "(C99) Equivalent to B<f>."
msgstr "(C99)  B<f> と同一である。"

#. type: Plain text
#: build/C/man3/scanf.3:471
#, fuzzy
#| msgid ""
#| "Matches a sequence of non-white-space characters; the next pointer must "
#| "be a pointer to character array that is long enough to hold the input "
#| "sequence and the terminating null byte (\\(aq\\e0\\(aq), which is added "
#| "automatically.  The input string stops at white space or at the maximum "
#| "field width, whichever occurs first."
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to the initial element of a character array that is long enough to "
"hold the input sequence and the terminating null byte (\\(aq\\e0\\(aq), "
"which is added automatically.  The input string stops at white space or at "
"the maximum field width, whichever occurs first."
msgstr ""
"ホワイトスペースではない文字で構成された文字列に対応する。 次のポインターは文"
"字の配列へのポインターでなければならず、 その文字配列は、入力された文字列と "
"(自動的に追加される) 終端のヌルバイト (\\(aq\\e0\\(aq) を格納するのに十分な大"
"きさでなければならない。 文字列の入力は、ホワイトスペースが入力されるか、最大"
"フィールド幅に 達するか、のどちらかが起こると停止される。"

#. type: Plain text
#: build/C/man3/scanf.3:481
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""
"I<「最大フィールド幅」> (デフォルトは 1) で指定された幅の文字の列に対応す"
"る。 次のポインターは I<char> へのポインターで、すべての文字を格納するのに十"
"分な領域が なければならない (終端のヌルバイトは追加されない)。 通常行われる先"
"頭のホワイトスペースの読み飛ばしは行われない。 先頭のホワイトスペースを読み飛"
"ばすためには、 フォーマット文の中で明示的にスペースを使用すれば良い。"

#. type: TP
#: build/C/man3/scanf.3:481
#, no-wrap
msgid "B<\\&[>"
msgstr "B<\\&[>"

#. type: Plain text
#: build/C/man3/scanf.3:514
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<\\(ha>).  To "
"include a close bracket in the set, make it the first character after the "
"open bracket or the circumflex; any other position will end the set.  The "
"hyphen character B<-> is also special; when placed between two other "
"characters, it adds all intervening characters to the set.  To include a "
"hyphen, make it the last character before the final close bracket.  For "
"instance, B<[\\(ha]0-9-]> means the set \"everything except close bracket, "
"zero through nine, and hyphen\".  The string ends with the appearance of a "
"character not in the (or, with a circumflex, in) set or when the field width "
"runs out."
msgstr "格納された文字列のうちから取り出された、 指定された文字の集合で構成される空ではない文字の列に対応する。 次のポインターは I<char> へのポインターでなければならず、 そこには文字列中のすべての文字と終端のヌルバイト を格納するための十分な領域がなければならない。 通常行われる先頭のホワイトスペースの読み飛ばしは行われない。 この文字列は特別な集合の中の文字で構成されている。 この集合は 開き括弧 B<[> と閉じ括弧 B<]> の間の文字で定義される。 開き括弧のあとの最初の文字が曲アクセント記号 (B<\\(ha>)  の場合、集合はこれらの文字を含まないものとなる。 閉じ括弧を集合に含ませるためには、この文字を開き括弧または 曲アクセント記号のあとの最初の文字にすればよい。 つまり、他の位置に閉じ括弧を置くと文字の集合が終る。 ハイフン B<-> もまた特殊文字である。 二つの異なる文字の間に置かれた時、この文字は、 その間にある全ての文字を集合に加える。 ハイフン自体を含ませるためには、 括弧が閉じる前の最後の一文字をハイフンにすればよい。 例えば、 B<[\\(ha]0-9-]> は「閉じ括弧、0 〜 9、ハイフンの 3 種類を除く全ての文字」の集合を意味する。 この文字列は 集合に含まれていない (曲アクセントの場合には含まれる) 文字の 出現または確保された領域が使い切られた時に終了する。"

#. type: Plain text
#: build/C/man3/scanf.3:522
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3)); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""
"(B<printf>(3)  の B<%p> で印字されるような) ポインター値に対応する。 次のポイ"
"ンターは I<void> へのポインターへのポインターでなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:540
#, fuzzy
#| msgid ""
#| "Nothing is expected; instead, the number of characters consumed thus far "
#| "from the input is stored through the next pointer, which must be a "
#| "pointer to I<int>.  This is I<not> a conversion, although it can be "
#| "suppressed with the B<*> assignment-suppression character.  The C "
#| "standard says: \"Execution of a B<%n> directive does not increment the "
#| "assignment count returned at the completion of execution\" but the "
#| "Corrigendum seems to contradict this.  Probably it is wise not to make "
#| "any assumptions on the effect of B<%n> conversions on the return value."
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion and does I<not> increase the count "
"returned by the function.  The assignment can be suppressed with the B<*> "
"assignment-suppression character, but the effect on the return value is "
"undefined.  Therefore B<%*n> conversions should not be used."
msgstr ""
"どんな入力も必要としない。 そのかわりに、 入力からここまで消費された文字数が"
"次のポインターで指定された場所に 格納される。 このポインターは I<int> へのポ"
"インターでなければならない。 変換を抑制するのであれば B<*> 代入抑制文字を使っ"
"て抑制することができるのだが、 この変換指定子は変換では「ない」。 C 言語の標"
"準規格では「実行の完了時に返される代入の回数は B<%n> 命令の実行では増加しな"
"い」となっているが、 正誤表の内容はこれと矛盾するようである。おそらく、 B<"
"%n> 変換が返り値に与える影響についてはどのような仮定もしないのが 賢明であろ"
"う。"

#. type: Plain text
#: build/C/man3/scanf.3:545
msgid ""
"On success, these functions return the number of input items successfully "
"matched and assigned; this can be fewer than provided for, or even zero, in "
"the event of an early matching failure."
msgstr "成功すると、これらの関数は、一致と代入が成功した入力要素の個数を返す。 返される値は渡された変換の個数よりも少ないこともあり、 最初に一致の失敗があった場合には 0 になることもある。"

#. type: Plain text
#: build/C/man3/scanf.3:557
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set to indicate the "
"error."
msgstr ""
"最初の変換が成功する前に入力の最後に達して、一致の失敗が起こった場合には、 "
"B<EOF> が返される。また、 読み込みエラーが発生した場合にも B<EOF> が返され"
"る。読み込みエラーの場合には、そのストリームの エラー指示子がセットされ "
"(B<ferror>(3)  参照)、 I<errno> にエラーを示す値がセットされる。"

#. type: Plain text
#: build/C/man3/scanf.3:563
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""
"I<stream> に対応するファイルディスクリプターが nonblocking となっており、 読"
"み込み操作は停止 (block) することになる。"

#. type: Plain text
#: build/C/man3/scanf.3:568
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for reading."
msgstr ""
"I<stream> に対応するファイルディスクリプターが無効であるが、 読み込み用にオー"
"プンされていない。"

#. type: Plain text
#: build/C/man3/scanf.3:571
msgid "Input byte sequence does not form a valid character."
msgstr "入力されたバイト列が有効な文字を構成していない。"

#. type: Plain text
#: build/C/man3/scanf.3:575
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr "読み込み操作がシグナルにより割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/scanf.3:580
msgid "Not enough arguments; or I<format> is NULL."
msgstr "引数が十分でない。または I<format> が NULL である。"

#. type: Plain text
#: build/C/man3/scanf.3:583
msgid "Out of memory."
msgstr "メモリー不足。"

#. type: TP
#: build/C/man3/scanf.3:583
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/scanf.3:587
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr "整数変換の結果が、対応する整数型に格納できるサイズを越えてしまう。"

#. type: tbl table
#: build/C/man3/scanf.3:598
#, no-wrap
msgid ""
"B<scanf>(),\n"
"B<fscanf>(),\n"
msgstr ""
" B<scanf>(),\n"
"B<fscanf>(),\n"

#. type: tbl table
#: build/C/man3/scanf.3:601
#, no-wrap
msgid ""
"B<sscanf>(),\n"
"B<vscanf>(),\n"
msgstr ""
" B<sscanf>(),\n"
"B<vscanf>(),\n"

#. type: tbl table
#: build/C/man3/scanf.3:604
#, no-wrap
msgid ""
"B<vsscanf>(),\n"
"B<vfscanf>()"
msgstr ""
" B<vsscanf>(),\n"
"B<vfscanf>()"

#. type: Plain text
#: build/C/man3/scanf.3:617
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""
"B<fscanf>(), B<scanf>(), B<sscanf>()  関数は C89, C99, POSIX.1-2001 に準拠し"
"ている。 これらの標準では、エラー B<ERANGE> は規定されていない。"

#. type: Plain text
#: build/C/man3/scanf.3:627
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""
"B<q> 指定子は I<long long> の 4.4BSD での記述方法である。 一方、整数変換での "
"B<ll> または B<L> の使用は GNU での拡張である。"

#. type: Plain text
#: build/C/man3/scanf.3:638
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""
"これらの関数の Linux 版は I<GNU> I<libio> ライブラリーを元にしている。 より簡"
"潔な説明には I<GNU> I<libc (glibc-1.08)> の I<info> 文書に目を通すこと。"

#. type: SS
#: build/C/man3/scanf.3:639
#, no-wrap
msgid "The 'a' assignment-allocation modifier"
msgstr "'a' 代入割り当て (assignment-allocation) 修飾子"

#. type: Plain text
#: build/C/man3/scanf.3:650
msgid ""
"Originally, the GNU C library supported dynamic allocation for string inputs "
"(as a nonstandard extension) via the B<a> character.  (This feature is "
"present at least as far back as glibc 2.0.)  Thus, one could write the "
"following to have B<scanf>()  allocate a buffer for an input string, with a "
"pointer to that buffer being returned in I<*buf>:"
msgstr ""
"元々、 GNU C ライブラリ (glibc) では、 B<a> 文字による文字列入力に対する動的"
"割り当て変換指定子 (dynamic allocation conversion specifier) を (非標準の拡張"
"として) サポートしている。この機能は少なくとも glibc 2.0 の時点ではすでに存在"
"している。 したがって、以下のようにして、 B<scanf>() に入力文字列に対してバッ"
"ファーを割り当てさせることができる。割り当てられたバッファーは I<*buf> で返さ"
"れる。"

#. type: Plain text
#: build/C/man3/scanf.3:653
#, no-wrap
msgid ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"
msgstr ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"

#. type: Plain text
#: build/C/man3/scanf.3:664
msgid ""
"The use of the letter B<a> for this purpose was problematic, since B<a> is "
"also specified by the ISO C standard as a synonym for B<f> (floating-point "
"input).  POSIX.1-2008 instead specifies the B<m> modifier for assignment "
"allocation (as documented in DESCRIPTION, above)."
msgstr ""
"この目的で文字 B<a> を使うのは問題をはらんでいる。 なぜなら、 B<a> は ISO C "
"標準では (浮動小数点入力を表す) の B<f> の同義語として定義されているからであ"
"る。 その代わり、 POSIX.1-2008 では、(上記の「説明」に書かれている通り) 代入"
"割り当てを行う修飾子として B<m> が規定されている。"

#. type: Plain text
#: build/C/man3/scanf.3:676
msgid ""
"Note that the B<a> modifier is not available if the program is compiled with "
"I<gcc -std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""
"B<a> 修飾子は I<gcc -std=c99> や I<gcc -D_ISOC99_SOURCE> でコンパイルしたプロ"
"グラムでは (B<_GNU_SOURCE> も同時に指定していない場合) 利用できない点に注意。"
"この場合、 B<a> は (上述の通り) 浮動小数点数を示す変換指定子と解釈される。"

#. type: Plain text
#: build/C/man3/scanf.3:682
msgid ""
"Support for the B<m> modifier was added to glibc starting with version 2.7, "
"and new programs should use that modifier instead of B<a>."
msgstr "B<m> 修飾子への対応はバージョン 2.7 以降の glibc で追加されている。新しいプログラムでは B<a> の代わりに B<m> を使用すべきである。"

#. type: Plain text
#: build/C/man3/scanf.3:688
msgid ""
"As well as being standardized by POSIX, the B<m> modifier has the following "
"further advantages over the use of B<a:>"
msgstr ""
"POSIX で標準化されているだけでなく、 B<m> 修飾子には B<a> を利用する場合に比"
"べて以下のような利点がある。"

#. type: Plain text
#: build/C/man3/scanf.3:693
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr "B<%c> 変換指定子にも適用できる (例えば B<%3mc>)。"

#. type: Plain text
#: build/C/man3/scanf.3:699
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)."
msgstr ""
"浮動小数点変換指定子としての B<%a> との紛らわしさが避けられる (また I<gcc -"
"std=c99> などの影響も避けられる)。"

#. type: Plain text
#: build/C/man3/scanf.3:712
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""
"全ての関数は、完全に C89 に準拠している。しかし 追加で B<q> と B<a> 指定子が"
"提供されており、同様に B<L> と B<l> 指定子の付加的な振る舞いもある。後者は、 "
"C89 で定義された指定子の振る舞いを変更するものなので、 バグとみなされるかもし"
"れない。"

#. type: Plain text
#: build/C/man3/scanf.3:728
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g., B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""
"ANSI C で定義された型修飾子と変換指定子の組み合わせの中には 意味を\n"
"なさないものがある (例えば、 B<%Ld>)。 これらが指定された場合、 \n"
"Linux 上でははっきりと定義された振る舞いをするかもしれないが、\n"
"他のアーキテクチャーでも同様になっているとは限らない。\n"
"それゆえに、ほとんどの場合、 ANSI C で定義されていない修飾子を使用した\n"
"方が良い。すなわち、 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変換や B<ll>\n"
"と組み合わせる場合には、 B<L> の代わりに B<q> を使用した方が良い。"

#. type: Plain text
#: build/C/man3/scanf.3:734
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""
"B<q> の使用方法は 4.4BSD と同じではない。 4.4BSD では B<q> は B<L> と同等に浮"
"動小数の変換に使用される。"

#. type: Plain text
#: build/C/man3/scanf.3:744
msgid ""
"To use the dynamic allocation conversion specifier, specify B<m> as a length "
"modifier (thus B<%ms> or B<%m[>I<range>B<]>).  The caller must B<free>(3)  "
"the returned string, as in the following example:"
msgstr ""
"動的割り当て変換指定子を使用するには、長さ修飾子として B<m> を指定する (つま"
"り、全体としては B<%ms> や B<%m[>I<range>B<]> となる)。以下の例にあるように、"
"呼び出し側は返された文字列を B<free>(3) しなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:749
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""
"char *p;\n"
"int n;\n"

#. type: Plain text
#: build/C/man3/scanf.3:760
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/scanf.3:768
msgid ""
"As shown in the above example, it is necessary to call B<free>(3)  only if "
"the B<scanf>()  call successfully read a string."
msgstr ""
"上記の例にあるように、 B<scanf>()  が文字列の読み込みに成功した場合にだけ、 "
"B<free>(3)  を呼び出す必要がある。"

#. type: Plain text
#: build/C/man3/scanf.3:775
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""
"B<getc>(3), B<printf>(3)  B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3),"

#. type: TH
#: build/C/man3/setbuf.3:48
#, no-wrap
msgid "SETBUF"
msgstr "SETBUF"

#. type: Plain text
#: build/C/man3/setbuf.3:51
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr ""
"setbuf, setbuffer, setlinebuf, setvbuf - ストリームのバッファーリングの操作"

#. type: Plain text
#: build/C/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:58
#, no-wrap
msgid "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:60
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr "B<void setlinebuf(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:63
#, no-wrap
msgid "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"
msgstr "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:76
#, no-wrap
msgid ""
"B<setbuffer>(),\n"
"B<setlinebuf>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:89
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)"
msgstr "バッファーリングには unbuffered, block buffered, line buffered の3つのタイプが ある。出力ストリームのタイプが unbuffered の場合、データを書き込むとすぐに出 力先ファイルに書き込まれるかターミナルに表示される。block buffered の場合、文 字の読み書きはブロック単位でいっぺんに行われる。line buffered の場合、 新しい行が出力されるか、ターミナルデバイスに接続しているストリーム (通常、I<stdin>) から新しい行が入力されるまで文字がたくわえられる。 ブロックを強制的に出力するには B<fflush>(3)  関数を使う。 (B<fclose>(3) を参照のこと)"

#. type: Plain text
#: build/C/man3/setbuf.3:97
msgid ""
"Normally all files are block buffered.  If a stream refers to a terminal (as "
"I<stdout> normally does), it is line buffered.  The standard error stream "
"I<stderr> is always unbuffered by default."
msgstr "通常、ファイルはすべて block buffered である。ストリームがターミナルを参照している場合 (I<stdout> は通常ターミナルを参照している)、ストリームは line buffered となる。標準エラー出力 I<stderr> はデフォルトでは常に unbuffered である。"

#. type: Plain text
#: build/C/man3/setbuf.3:104
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr ""
"B<setvbuf>()  関数は、オープンしている任意のストリームに対してバッファーを変"
"更できる。 引数 I<mode> は、次の 3 つのマクロのうちいずれかである:"

#. type: TP
#: build/C/man3/setbuf.3:105
#, no-wrap
msgid "B<_IONBF>"
msgstr "B<_IONBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:108
msgid "unbuffered"
msgstr "unbuffered"

#. type: TP
#: build/C/man3/setbuf.3:108
#, no-wrap
msgid "B<_IOLBF>"
msgstr "B<_IOLBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:111
msgid "line buffered"
msgstr "line buffered"

#. type: TP
#: build/C/man3/setbuf.3:111
#, no-wrap
msgid "B<_IOFBF>"
msgstr "B<_IOFBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:114
msgid "fully buffered"
msgstr "fully buffered"

#. type: Plain text
#: build/C/man3/setbuf.3:130
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at "
"least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The "
"B<setvbuf>()  function may be used only after opening a stream and before "
"any other operations have been performed on it."
msgstr ""
"unbuffered のファイルを除き、 I<buf> 引数は I<size> バイト以上の大きさのバッ"
"ファーを指していなければならない。このバッファーは現在の バッファーの代わりに"
"用いられる。もし、引数 I<buf> が NULL ならば、モードだけが変更される。 新しい"
"バッファーは次に読み書きした際に割り当てられる。 B<setvbuf>()  関数は、スト"
"リームをオープンした後、 そのストリームに対して何らかの操作をする前にのみ使用"
"できる。"

#. type: Plain text
#: build/C/man3/setbuf.3:136
msgid ""
"The other three calls are, in effect, simply aliases for calls to "
"B<setvbuf>().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr ""
"他の 3 つの関数は B<setvbuf>()  の呼び出しに単純に置き換えることができる。 "
"B<setbuf>()  関数は、"

#. type: Plain text
#: build/C/man3/setbuf.3:139
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"

#. type: Plain text
#: build/C/man3/setbuf.3:149
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer "
"is up to the caller, rather than being determined by the default B<BUFSIZ>.  "
"The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr ""
"と全く同等だし、 B<setbuffer>()  関数は、バッファーサイズがデフォルト値 "
"B<BUFSIZ> ではなく引数で与えられる点以外は同じである。 B<setlinebuf>()  関数"
"は以下と同じである。"

#. type: Plain text
#: build/C/man3/setbuf.3:152
msgid "setvbuf(stream, NULL, _IOLBF, 0);"
msgstr "setvbuf(stream, NULL, _IOLBF, 0);"

#. type: Plain text
#: build/C/man3/setbuf.3:163
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr ""
"B<setvbuf>()  関数は、成功した場合 0 を返す。 失敗した場合、0 以外の値を返す "
"(失敗とは、 I<mode> が不正な場合またはリクエストが条件を満たさない場合であ"
"る)。 B<setvbuf>()  関数が失敗した場合は I<errno> を設定することもある。"

#. type: Plain text
#: build/C/man3/setbuf.3:165
msgid "The other functions do not return a value."
msgstr "その他の関数は値を返さない。"

#. type: tbl table
#: build/C/man3/setbuf.3:176
#, no-wrap
msgid ""
"B<setbuf>(),\n"
"B<setbuffer>(),\n"
msgstr ""
" B<setbuf>(),\n"
"B<setbuffer>(),\n"

#. type: tbl table
#: build/C/man3/setbuf.3:179
#, no-wrap
msgid ""
"B<setlinebuf>(),\n"
"B<setvbuf>()"
msgstr ""
" B<setlinebuf>(),\n"
"B<setvbuf>()"

#. type: Plain text
#: build/C/man3/setbuf.3:187
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr ""
"B<setbuf>()  関数および B<setvbuf>()  関数は C89 と C99 に準拠している。"

#.  The
#.  .BR setbuffer ()
#.  and
#.  .BR setlinebuf ()
#.  functions are not portable to versions of BSD before 4.2BSD, and
#.  are available under Linux since libc 4.5.21.
#.  On 4.2BSD and 4.3BSD systems,
#.  .BR setbuf ()
#.  always uses a suboptimal buffer size and should be avoided.
#. .PP
#. type: Plain text
#: build/C/man3/setbuf.3:204
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr ""
"I<stream> を閉じる時 (プログラムを終了する際にもこれは起きる) には、 I<buf> "
"が指し示す空間とが存在していることを保証しなければならない。 例えば、次のよう"
"な使い方は許されない:"

#. type: Plain text
#: build/C/man3/setbuf.3:207
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:216
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/setbuf.3:226
msgid ""
"B<stdbuf>(1), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), "
"B<malloc>(3), B<printf>(3), B<puts>(3)"
msgstr "B<stdbuf>(1), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), B<printf>(3), B<puts>(3)"

#. type: TH
#: build/C/man3/stdin.3:13
#, no-wrap
msgid "STDIN"
msgstr "STDIN"

#. type: Plain text
#: build/C/man3/stdin.3:16
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr "stdin, stdout, stderr - 標準入出力ストリーム"

#. type: Plain text
#: build/C/man3/stdin.3:23
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"

#. type: Plain text
#: build/C/man3/stdin.3:35
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4))  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr "標準の環境では、 UNIX プログラムは起動時に、オープンされているストリー ムを 3 つ与えられる。それぞれ入力用、出力用、診断メッセージやエラーメッ セージの表示用のものである。これらは通常ユーザーの端末 (B<tty>(4) を参照) に接続されているが、親プロセスでの選択・設定によってファイル や他のデバイスに関連づけられていることもある (B<sh>(1)  の「リダイレクション」セクションも参照のこと)。"

#. type: Plain text
#: build/C/man3/stdin.3:45
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to "
"refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""
"入力ストリームは \"standard input\" と呼ばれる。出力ストリームは \"standard "
"output\"、エラーストリームは \"standard error\" と呼ばれる。 これらの用語を短"
"縮したものがそれぞれのファイルを示すシンボルとなる。つ まり I<stdin>, "
"I<stdout>, I<stderr> である。"

#. type: Plain text
#: build/C/man3/stdin.3:54
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""
"これらのシンボルは B<stdio>(3)  のマクロで、 FILE へのポインター型である。し"
"たがって B<fprintf>(3)  や B<fread>(3)  などの関数とともに用いることができ"
"る。"

#. type: Plain text
#: build/C/man3/stdin.3:63
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""
"I<FILE> は UNIX のファイルディスクリプターにバッファー機能を追加したラッパー "
"であるから、これらのマクロにも対応するファイルがあり、 UNIX の raw ファ イル"
"インターフェース (B<read>(2)  や B<lseek>(2)  など) によってアクセスすること"
"もできる。"

#. type: Plain text
#: build/C/man3/stdin.3:82
msgid ""
"On program startup, the integer file descriptors associated with the streams "
"I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO> "
"are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying "
"B<freopen>(3)  to one of these streams can change the file descriptor number "
"associated with the stream.)"
msgstr ""
"プログラムの起動時には、 ストリーム I<stdin>, I<stdout>, I<stderr> に結びつけ"
"られているファイルディスクリプターの番号は、 それぞれ 0, 1, 2 である。 プリプ"
"ロセッサシンボル B<STDIN_FILENO>, B<STDOUT_FILENO>, B<STDERR_FILENO> は "
"I<E<lt>unistd.hE<gt>> 中でそれぞれこれらの値に定義されている。 (これらのスト"
"リームに対して B<freopen>(3)  を適用することで、そのストリームに関連付けられ"
"たファイルディスクリプター の番号を変更することができる。)"

#. type: Plain text
#: build/C/man3/stdin.3:95
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""
"I<FILE> と raw なファイルディスクリプターの併用は、予期できない結果を生じ る"
"ことがあるので、通常は避けるべきである。 (マゾヒスティックな人に: POSIX.1 の"
"セクション 8.2.3 には、この混用で動作がどのようになりそう かが詳しく記述され"
"ている。)  一般的なルールは以下の通り: ファイルディスクリプターはカーネルに"
"よって 扱われ、 stdio は単にライブラリによって扱われるのである。すなわち例え"
"ば B<exec>(3)  の後には、子プロセスはオープンされているファイルディスクリプ"
"ター をすべて継承するが、親からのストリームはすべてアクセス不可となる。"

#. type: Plain text
#: build/C/man3/stdin.3:113
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3), "
"specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and "
"by normal program termination."
msgstr ""
"シンボル I<stdin>, I<stdout>, I<stderr> はすべてマクロとして定義されているの"
"で、これらへの代入 は移植性を保証されない。標準ストリームはライブラリ関数 "
"B<freopen>(3)  を用いれば、別のファイルを示すように変更することもできる。 こ"
"のライブラリ関数は I<stdin>, I<stdout>, I<stderr> の再割り当てが可能なように"
"特別に導入されたものである。 標準ストリームは B<exit>(3)  の呼び出しと、プロ"
"グラムの正常終了によってクローズされる。"

#. type: Plain text
#: build/C/man3/stdin.3:122
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""
"I<stdin>, I<stdout>, I<stderr> マクロは C89 に準拠している。 また C89 では、"
"これら 3 つのストリームがプログラム の起動時にオープンされているべきであるこ"
"とが規定されている。"

#. type: Plain text
#: build/C/man3/stdin.3:154
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until "
"B<fflush>(3)  or B<exit>(3)  is called, or a newline is printed.  This can "
"produce unexpected results, especially with debugging output.  The buffering "
"mode of the standard streams (or any other stream)  can be changed using the "
"B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""
"I<stderr> ストリームはバッファーリングされていない。 I<stdout> ストリームは、"
"端末に接続されているときには行単位でバッファーリング されている。一行に満たな"
"い内容は、 B<fflush>(3)  か B<exit>(3)  が呼び出されるか、改行文字が印字され"
"るまで表示されない。これは、 特にデバッグ時において、予期しない結果を生じる原"
"因となるかもしれない。 標準ストリームの (あるいは他のすべてのストリームの)  "
"バッファーリングモードは、 B<setbuf>(3)  または B<setvbuf>(3)  を呼び出すこと"
"によって変更できる。 ただし、 I<stdin> が端末に接続されているときは、端末のド"
"ライバでバッファーリングされている 可能性がある点にも注意すること。これは "
"stdio のバッファーリングとは全く 関係なく存在しうる。 (実際、通常だと端末入力"
"はカーネルによって行単位 でバッファーリングされている。) このカーネルによる入"
"力の扱いは B<tcsetattr>(3)  などの呼び出しによって変更することができる。 "
"B<stty>(1)  と B<termios>(3)  も参照すること。"

#. type: Plain text
#: build/C/man3/stdin.3:160
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"

#. type: TH
#: build/C/man3/stdio.3:39
#, no-wrap
msgid "STDIO"
msgstr "STDIO"

#. type: TH
#: build/C/man3/stdio.3:39
#, no-wrap
msgid "2017-11-26"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:42
msgid "stdio - standard input/output library functions"
msgstr "stdio - 標準入出力ライブラリ関数"

#. type: Plain text
#: build/C/man3/stdio.3:46
msgid "B<FILE *>I<stdin>B<;>"
msgstr "B<FILE *>I<stdin>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:48
msgid "B<FILE *>I<stdout>B<;>"
msgstr "B<FILE *>I<stdout>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:50
msgid "B<FILE *>I<stderr>B<;>"
msgstr "B<FILE *>I<stderr>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:57
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O "
"interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""
"標準入出力ライブラリは、簡単かつ効果のよい、 バッファーリングされたストリーム"
"入出力インターフェースを提供する。 入力と出力は論理データストリームに割り付け"
"られ、 入出力の物理的な特徴は隠蔽される。 このライブラリに属する関数とマクロ"
"を以下に挙げる。 より詳しい情報は個々の man ページから得ることができる。"

#. type: Plain text
#: build/C/man3/stdio.3:80
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal), then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning "
"requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""
"ファイルを I<オープン (open) する> ことによって、 ストリームは外部ファイル "
"(通常は物理デバイス) に連結される。 この操作には新しくファイルを作成すること"
"も含まれる。 既存のファイルと同じ名前のファイルを新たに作ると、 もとのファイ"
"ルの中身が捨てられてしまう。 ファイルが位置指定リクエストをサポートしている "
"(ディスクファイルなどが相当する。逆の例としては端末が挙げられる) 場合、 その"
"ストリームに連結された I<ファイル位置指示子 (file position indicator)> は、追"
"加モードで開かれない限りファイルの先頭 (0 バイト目) に位置する。 追加モードを"
"使用した場合、 位置指示子をファイルの先頭に置かれるか末尾に置かれるかは規定さ"
"れていない。 位置指示子は、 以降の読み書きや位置指定リクエストによって変更さ"
"れる。 すべての入力は、 B<fgetc>(3)  関数を次々に呼び出して文字を読み込んだか"
"のように行われる。 一方すべての出力は、 B<fputc>(3)  関数を次々に呼び出して文"
"字を書き込んだかのように行われる。"

#. type: Plain text
#: build/C/man3/stdio.3:90
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""
"ファイルを I<クローズ (close) する> ことによって、そのファイルはストリームか"
"ら切り離される。 出力ストリームは、そのストリームがファイルから切り離される前"
"にフラッシュされる (書き込まれていないすべてのバッファーの内容がホスト環境に"
"転送される)。 I<FILE> オブジェクトへのポインターの値は、 ファイルを閉じた後で"
"は不確定になる (ゴミになってしまう)。"

#. type: Plain text
#: build/C/man3/stdio.3:103
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned "
"at the start).  If the main function returns to its original caller, or the "
"B<exit>(3)  function is called, all open files are closed (hence all output "
"streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files properly."
msgstr ""
"ファイルはその後 (同じまたは別のプログラムによって)  再びオープンされることも"
"あり、 その内容が修正されたり変更されたりする (そのファイルで先頭への位置移動"
"が可能であれば)。 main 関数がもとの呼び出し側に返ったり、 B<exit>(3)  関数が"
"呼ばれた場合、 プログラムの終了の前に 現在開いているすべてのファイルは閉じら"
"れる (その結果、すべての出力ストリームはフラッシュされる)。 プログラムの停止"
"に B<abort>(3)  のような他の方法を用いた場合には、 ファイルが正しく閉じられる"
"保証はない。"

#. type: Plain text
#: build/C/man3/stdio.3:120
msgid ""
"At program startup, three text streams are predefined and need not be opened "
"explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional output), and I<standard error> (for "
"writing diagnostic output).  These streams are abbreviated I<stdin>, "
"I<stdout>, and I<stderr>.  When opened, the standard error stream is not "
"fully buffered; the standard input and output streams are fully buffered if "
"and only if the streams do not refer to an interactive device."
msgstr ""
"プログラムの起動時に 3 個のテキストストリームが予め定義されており、 それらは"
"明示的に開く必要がない。 I<標準入力 (standard input)> (通常の入力を読み取るの"
"に使う)、 I<標準出力 (standard output)> (通常の出力を書き込むのに使う)、 I<標"
"準エラー出力 (standard error)> (診断出力を書き込むのに使う) である。 これらの"
"ストリームは I<stdin>, I<stdout>, I<stderr> と短縮して表現される。 オープンさ"
"れたときには、 標準エラーストリームは 完全にはバッファーリングされていない。 "
"標準入力ストリームと標準出力ストリームは、 ストリームがインタラクティブなデバ"
"イスを参照していなければ、 完全にバッファーリングされている。"

#. type: Plain text
#: build/C/man3/stdio.3:130
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an "
"input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before "
"going off and computing so that the output will appear."
msgstr ""
"端末デバイスを参照する出力ストリームは、 デフォルトでは常に行単位でバッファー"
"リングされている。 ただしそのようなストリームにおけるバッファー内の出力は、 "
"端末デバイスを参照している入力ストリームからの読み込みがあるたびに、 自動的に"
"書き込まれる。 出力端末に行の一部を書き込んだ後で大量の計算を行う場合、 出力"
"が表示されるように、計算に取りかかる前に標準出力に対して B<fflush>(3)  を実行"
"する必要がある。"

#. type: Plain text
#: build/C/man3/stdio.3:142
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by B<cc>(1).  The SYNOPSIS sections of the "
"following manual pages indicate which include files are to be used, what the "
"compiler declaration for the function looks like and which external "
"variables are of interest."
msgstr "I<stdio> ライブラリは B<libc> ライブラリの一部であり、ルーチンは B<cc>(1) によって必要な時に自動的に読み込まれる。 後述する man ページ中の「書式」の節には、 どのインクルードファイルを使用しなければならないか、 その関数のコンパイラー宣言はどのようなものか、 どのような外部変数が関係するのかが示されている。"

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: build/C/man3/stdio.3:182
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""
"B<BUFSIZ>, B<EOF>, B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, "
"B<L_ctermid>, B<L_tmpnam>, B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, "
"B<TMP_MAX>, B<clearerr>, B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, "
"B<putc>, B<putchar>, B<stderr>, B<stdin>, B<stdout> はマクロとして定義されて"
"いる。 これらの名前は、現在の定義を B<#undef> で削除しない限り、再利用するこ"
"とはできない。 マクロ関数の関数版として、 B<feof>, B<ferror>, B<clearerr>, "
"B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar> がある。 マクロの定義が明"
"示的に消去されている場合には、 これらを使用することになるだろう。"

#. type: SS
#: build/C/man3/stdio.3:182
#, no-wrap
msgid "List of functions"
msgstr "関数のリスト"

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "Function"
msgstr "関数"

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "Description"
msgstr "説明"

#. type: tbl table
#: build/C/man3/stdio.3:188
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: build/C/man3/stdio.3:189
#, no-wrap
msgid "B<clearerr>(3)"
msgstr " B<clearerr>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:189 build/C/man3/stdio.3:192 build/C/man3/stdio.3:193
#, no-wrap
msgid "check and reset stream status"
msgstr "ストリームの状態の確認とリセット"

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "B<fclose>(3)"
msgstr " B<fclose>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "close a stream"
msgstr "ストリームをクローズする"

#. type: tbl table
#: build/C/man3/stdio.3:191
#, no-wrap
msgid "B<fdopen>(3)"
msgstr " B<fdopen>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:191 build/C/man3/stdio.3:199 build/C/man3/stdio.3:205
#, no-wrap
msgid "stream open functions"
msgstr "ストリームをオープンする"

#. type: tbl table
#: build/C/man3/stdio.3:192
#, no-wrap
msgid "B<feof>(3)"
msgstr " B<feof>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:193
#, no-wrap
msgid "B<ferror>(3)"
msgstr " B<ferror>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:194
#, no-wrap
msgid "B<fflush>(3)"
msgstr " B<fflush>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:194 build/C/man3/stdio.3:201
#, no-wrap
msgid "flush a stream"
msgstr "ストリームをフラッシュする"

#. type: tbl table
#: build/C/man3/stdio.3:195
#, no-wrap
msgid "B<fgetc>(3)"
msgstr " B<fgetc>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:195 build/C/man3/stdio.3:211 build/C/man3/stdio.3:212
#: build/C/man3/stdio.3:214
#, no-wrap
msgid "get next character or word from input stream"
msgstr "次の文字または語を入力ストリームから取得する"

#. type: tbl table
#: build/C/man3/stdio.3:196
#, no-wrap
msgid "B<fgetpos>(3)"
msgstr " B<fgetpos>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:196 build/C/man3/stdio.3:207 build/C/man3/stdio.3:208
#: build/C/man3/stdio.3:209 build/C/man3/stdio.3:223
#, no-wrap
msgid "reposition a stream"
msgstr "ストリームの位置指示子を移動する"

#. type: tbl table
#: build/C/man3/stdio.3:197
#, no-wrap
msgid "B<fgets>(3)"
msgstr " B<fgets>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:197 build/C/man3/stdio.3:213
#, no-wrap
msgid "get a line from a stream"
msgstr "行を入力ストリームから取得する"

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "B<fileno>(3)"
msgstr " B<fileno>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "return the integer descriptor of the argument stream"
msgstr "引数であるストリームの整数値のディスクリプターを返す"

#. type: tbl table
#: build/C/man3/stdio.3:199
#, no-wrap
msgid "B<fopen>(3)"
msgstr " B<fopen>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:200
#, no-wrap
msgid "B<fprintf>(3)"
msgstr " B<fprintf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:200 build/C/man3/stdio.3:217 build/C/man3/stdio.3:229
#: build/C/man3/stdio.3:238 build/C/man3/stdio.3:240 build/C/man3/stdio.3:242
#, no-wrap
msgid "formatted output conversion"
msgstr "書式付き出力変換"

#. type: tbl table
#: build/C/man3/stdio.3:201
#, no-wrap
msgid "B<fpurge>(3)"
msgstr " B<fpurge>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:202
#, no-wrap
msgid "B<fputc>(3)"
msgstr " B<fputc>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:202 build/C/man3/stdio.3:218 build/C/man3/stdio.3:219
#: build/C/man3/stdio.3:221
#, no-wrap
msgid "output a character or word to a stream"
msgstr "文字または語をストリームに出力する"

#. type: tbl table
#: build/C/man3/stdio.3:203
#, no-wrap
msgid "B<fputs>(3)"
msgstr " B<fputs>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:203 build/C/man3/stdio.3:220
#, no-wrap
msgid "output a line to a stream"
msgstr "行をストリームに出力する"

#. type: tbl table
#: build/C/man3/stdio.3:204
#, no-wrap
msgid "B<fread>(3)"
msgstr " B<fread>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:204 build/C/man3/stdio.3:210
#, no-wrap
msgid "binary stream input/output"
msgstr "バイナリーストリーム入出力"

#. type: tbl table
#: build/C/man3/stdio.3:205
#, no-wrap
msgid "B<freopen>(3)"
msgstr " B<freopen>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:206
#, no-wrap
msgid "B<fscanf>(3)"
msgstr " B<fscanf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:206 build/C/man3/stdio.3:224 build/C/man3/stdio.3:230
#: build/C/man3/stdio.3:239 build/C/man3/stdio.3:241 build/C/man3/stdio.3:243
#, no-wrap
msgid "input format conversion"
msgstr "書式付き入力変換"

#. type: tbl table
#: build/C/man3/stdio.3:208
#, no-wrap
msgid "B<fsetpos>(3)"
msgstr " B<fsetpos>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:209
#, no-wrap
msgid "B<ftell>(3)"
msgstr " B<ftell>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:210
#, no-wrap
msgid "B<fwrite>(3)"
msgstr " B<fwrite>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:211
#, no-wrap
msgid "B<getc>(3)"
msgstr " B<getc>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:212
#, no-wrap
msgid "B<getchar>(3)"
msgstr " B<getchar>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:213
#, no-wrap
msgid "B<gets>(3)"
msgstr " B<gets>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:214
#, no-wrap
msgid "B<getw>(3)"
msgstr " B<getw>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "B<mktemp>(3)"
msgstr " B<mktemp>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "make temporary filename (unique)"
msgstr "他と重ならないテンポラリファイル名を作る"

#. type: tbl table
#: build/C/man3/stdio.3:216
#, no-wrap
msgid "B<perror>(3)"
msgstr " B<perror>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:216 build/C/man3/stdio.3:231 build/C/man3/stdio.3:232
#: build/C/man3/stdio.3:233
#, no-wrap
msgid "system error messages"
msgstr "システムエラーメッセージ"

#. type: tbl table
#: build/C/man3/stdio.3:217
#, no-wrap
msgid "B<printf>(3)"
msgstr "B<printf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:218
#, no-wrap
msgid "B<putc>(3)"
msgstr " B<putc>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:219
#, no-wrap
msgid "B<putchar>(3)"
msgstr " B<putchar>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:220
#, no-wrap
msgid "B<puts>(3)"
msgstr " B<puts>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:221
#, no-wrap
msgid "B<putw>(3)"
msgstr " B<putw>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "B<remove>(3)"
msgstr " B<remove>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "remove directory entry"
msgstr "ディレクトリエントリーを削除する"

#. type: tbl table
#: build/C/man3/stdio.3:223
#, no-wrap
msgid "B<rewind>(3)"
msgstr " B<rewind>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:224
#, no-wrap
msgid "B<scanf>(3)"
msgstr " B<scanf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:225
#, no-wrap
msgid "B<setbuf>(3)"
msgstr " B<setbuf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:225 build/C/man3/stdio.3:226 build/C/man3/stdio.3:227
#: build/C/man3/stdio.3:228
#, no-wrap
msgid "stream buffering operations"
msgstr "ストリームのバッファーリングの操作"

#. type: tbl table
#: build/C/man3/stdio.3:226
#, no-wrap
msgid "B<setbuffer>(3)"
msgstr " B<setbuffer>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:227
#, no-wrap
msgid "B<setlinebuf>(3)"
msgstr " B<setlinebuf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:228
#, no-wrap
msgid "B<setvbuf>(3)"
msgstr " B<setvbuf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:229
#, no-wrap
msgid "B<sprintf>(3)"
msgstr " B<sprintf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:230
#, no-wrap
msgid "B<sscanf>(3)"
msgstr " B<sscanf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:231
#, no-wrap
msgid "B<strerror>(3)"
msgstr " B<strerror>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:232
#, no-wrap
msgid "B<sys_errlist>(3)"
msgstr " B<sys_errlist>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:233
#, no-wrap
msgid "B<sys_nerr>(3)"
msgstr " B<sys_nerr>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:234
#, no-wrap
msgid "B<tempnam>(3)"
msgstr " B<tempnam>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:234 build/C/man3/stdio.3:235 build/C/man3/stdio.3:236
#, no-wrap
msgid "temporary file routines"
msgstr "テンポラリファイルの操作"

#. type: tbl table
#: build/C/man3/stdio.3:235
#, no-wrap
msgid "B<tmpfile>(3)"
msgstr " B<tmpfile>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:236
#, no-wrap
msgid "B<tmpnam>(3)"
msgstr " B<tmpnam>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "B<ungetc>(3)"
msgstr " B<ungetc>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "un-get character from input stream"
msgstr "入力ストリームへ 1 文字戻す"

#. type: tbl table
#: build/C/man3/stdio.3:238
#, no-wrap
msgid "B<vfprintf>(3)"
msgstr " B<vfprintf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:239
#, no-wrap
msgid "B<vfscanf>(3)"
msgstr " B<vfscanf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:240
#, no-wrap
msgid "B<vprintf>(3)"
msgstr " B<vprintf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:241
#, no-wrap
msgid "B<vscanf>(3)"
msgstr " B<vscanf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:242
#, no-wrap
msgid "B<vsprintf>(3)"
msgstr " B<vsprintf>(3)"

#. type: tbl table
#: build/C/man3/stdio.3:243
#, no-wrap
msgid "B<vsscanf>(3)"
msgstr " B<vsscanf>(3)"

#. type: Plain text
#: build/C/man3/stdio.3:249
msgid "The I<stdio> library conforms to C89."
msgstr "I<stdio> ライブラリは C89 に準拠している。"

#. type: Plain text
#: build/C/man3/stdio.3:256
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/stdio_ext.3:25
#, no-wrap
msgid "STDIO_EXT"
msgstr "STDIO_EXT"

#. type: TH
#: build/C/man3/stdio_ext.3:25
#, no-wrap
msgid "2015-03-02"
msgstr "2015-03-02"

#. type: Plain text
#: build/C/man3/stdio_ext.3:30
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE "
"structure"
msgstr ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - 標準入出力ファイル構造体"
"へのインターフェース"

#. type: Plain text
#: build/C/man3/stdio_ext.3:34
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/stdio_ext.3:45
#, no-wrap
msgid ""
"B<size_t __fbufsize(FILE *>I<stream>B<);>\n"
"B<size_t __fpending(FILE *>I<stream>B<);>\n"
"B<int __flbf(FILE *>I<stream>B<);>\n"
"B<int __freadable(FILE *>I<stream>B<);>\n"
"B<int __fwritable(FILE *>I<stream>B<);>\n"
"B<int __freading(FILE *>I<stream>B<);>\n"
"B<int __fwriting(FILE *>I<stream>B<);>\n"
"B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>\n"
"B<void _flushlbf(void);>\n"
"B<void __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t __fbufsize(FILE *>I<stream>B<);>\n"
"B<size_t __fpending(FILE *>I<stream>B<);>\n"
"B<int __flbf(FILE *>I<stream>B<);>\n"
"B<int __freadable(FILE *>I<stream>B<);>\n"
"B<int __fwritable(FILE *>I<stream>B<);>\n"
"B<int __freading(FILE *>I<stream>B<);>\n"
"B<int __fwriting(FILE *>I<stream>B<);>\n"
"B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>\n"
"B<void _flushlbf(void);>\n"
"B<void __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/stdio_ext.3:51
msgid ""
"Solaris introduced routines to allow portable access to the internals of the "
"I<FILE> structure, and glibc also implemented these."
msgstr ""
"Solaris では、 I<FILE> 構造体の内部へポータブルなかたちで アクセスできる手段"
"が導入されており、これらは glibc でも実装されている。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:56
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""
"B<__fbufsize>()  関数は、指定されたストリームが使用しているバッファーサイズを"
"返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:63
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""
"B<__fpending>()  関数は、出力バッファーに入っているデータのバイト数を返す。 "
"ワイドキャラクターを扱うストリームの場合、ワイドキャラクター単位で計算され"
"る。 バッファーが読み出しモードの場合や読み出し専用で開かれている場合の この"
"関数の振舞いは未定義である。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:68
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is line-"
"buffered, and zero otherwise."
msgstr ""
"B<__flbf>()  関数は、ストリームがラインバッファーの場合は 0 以外を、 それ以外"
"の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:73
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""
"B<__freadable>()  関数は、ストリームが読み出し可能な場合は 0 以外を、 それ以"
"外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:78
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""
"B<__fwritable>()  関数は、ストリームが書き込み可能な場合は 0 以外を、 それ以"
"外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:84
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is read-"
"only, or if the last operation on the stream was a read operation, and zero "
"otherwise."
msgstr ""
"B<__freading>()  関数は、ストリームが読み出し専用の場合、またはストリームに対"
"する直前の操作が 読み出し操作であった場合は 0 以外を返し、それ以外の場合は 0 "
"を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:90
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is write-"
"only (or append-only), or if the last operation on the stream was a write "
"operation, and zero otherwise."
msgstr ""
"B<__fwriting>()  関数は、ストリームが書き込み専用(もしくは追加専用)の場合、 "
"またはストリームに対する直前の操作が書き込み操作であった場合は 0 以外を返"
"し、 それ以外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:98
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""
"B<__fsetlocking>()  関数は、ストリームのロック形式を選択するために使用でき"
"る。 返り値は、現在のロック形式である。 I<type> 引数は以下の 3 種類の値をと"
"ることができる :"

#. type: TP
#: build/C/man3/stdio_ext.3:98
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr "B<FSETLOCKING_INTERNAL>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:103
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""
"指定されたストリームに対して操作が行われる度に、操作の前後で 明示的に指示しな"
"くてもストリームのロック処理を行う (但し、*_unlocked 関数を使用した場合は例外"
"である)。 これがデフォルトのロック形式である。"

#. type: TP
#: build/C/man3/stdio_ext.3:103
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr "B<FSETLOCKING_BYCALLER>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:110
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in "
"case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""
"関数の呼び出し元でロックの面倒をみる。 (おそらく、複数のスレッドが存在する状"
"況では B<flockfile>(3)  を使うことになるだろう)  ロック形式が "
"B<FSETLOCKING_INTERNAL> にリセットされるまでは標準入出力関連の関数はロック処"
"理を行わない。"

#. type: TP
#: build/C/man3/stdio_ext.3:110
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr "B<FSETLOCKING_QUERY>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:114
msgid "Don't change the type of locking.  (Only return it.)"
msgstr "ロック形式の変更を行わない。(現在の形式を返すだけである)"

#. type: Plain text
#: build/C/man3/stdio_ext.3:120
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably "
"so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""
"B<_flushlbf>()  関数は、すべてのラインバッファー (line-buffered) タイプのスト"
"リームの 内容を出力(フラッシュ)する。 (当然ながら、端末への出力が強制的に行わ"
"れることになるので、 キーボードからの入力を読みこむ前にこの関数を呼んだ方がい"
"いだろう)"

#. type: Plain text
#: build/C/man3/stdio_ext.3:124
msgid ""
"The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr "B<__fpurge>()  関数は、ストリームのバッファーの内容を廃棄する。"

#. type: tbl table
#: build/C/man3/stdio_ext.3:135
#, no-wrap
msgid ""
"B<__fbufsize>(),\n"
"B<__fpending>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:138
#, no-wrap
msgid ""
"B<__fpurge>(),\n"
"B<__fsetlocking>()"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:142
#, no-wrap
msgid ""
"B<__flbf>(),\n"
"B<__freadable>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:145
#, no-wrap
msgid ""
"B<__freading>(),\n"
"B<__fwritable>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:148
#, no-wrap
msgid ""
"B<__fwriting>(),\n"
"B<_flushlbf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:153
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr "B<flockfile>(3), B<fpurge>(3)"

#. type: TH
#: build/C/man2/symlink.2:33 build/C/man7/symlink.7:37
#, no-wrap
msgid "SYMLINK"
msgstr "SYMLINK"

#. type: Plain text
#: build/C/man2/symlink.2:36
msgid "symlink, symlinkat - make a new name for a file"
msgstr "symlink, symlinkat - ファイルに新しい名前を付ける"

#. type: Plain text
#: build/C/man2/symlink.2:41
#, no-wrap
msgid "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"
msgstr "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: build/C/man2/symlink.2:47
#, no-wrap
msgid "B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char *>I<linkpath>B<);>\n"
msgstr "B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: build/C/man2/symlink.2:56
msgid "B<symlink>():"
msgstr "B<symlink>():"

#. type: Plain text
#: build/C/man2/symlink.2:63
msgid "B<symlinkat>():"
msgstr "B<symlinkat>():"

#. type: Plain text
#: build/C/man2/symlink.2:81
msgid ""
"B<symlink>()  creates a symbolic link named I<linkpath> which contains the "
"string I<target>."
msgstr ""
"B<symlink>()  は I<target> という文字列をファイルの内容として持つ "
"I<linkpath> というシンボリックリンク (symbolic link) を作成する。"

#. type: Plain text
#: build/C/man2/symlink.2:85
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""
"シンボリックリンクは実行時に解釈され、 リンクの内容でパスを置き換えて、そのパ"
"スを辿ることで、 ファイルやディレクトリに到達する。"

#. type: Plain text
#: build/C/man2/symlink.2:90
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""
"シンボリックリンクはパスの部分に I<..> を含むかもしれない。これは (もしリンク"
"の最初に使用された場合は) リンクの 存在するディレクトリの親ディレクトリが参照"
"される。"

#. type: Plain text
#: build/C/man2/symlink.2:94
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""
"シンボリックリンクは (ソフトリンク (soft link) とも呼ばれ)  存在するファイル"
"を指しているかもしれないし、 存在しないファイルを指しているかもしれない; 後者"
"の場合は壊れたリンク (dangling link) とも呼ばれる。"

#. type: Plain text
#: build/C/man2/symlink.2:101
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit "
"(B<S_ISVTX>)  set."
msgstr ""
"シンボリックリンクの許可 (permission) は無意味である; リンクを追跡する場合に"
"は所有権 (ownership) は無視される。 ただし、リンクの削除や名前の変更が要求さ"
"れ、かつリンクが存在する ディレクトリにスティッキービット (sticky bit)  "
"(B<S_ISVTX>)  が設定されている場合には、所有権のチェックが行われる。"

#. type: Plain text
#: build/C/man2/symlink.2:107
msgid "If I<linkpath> exists, it will I<not> be overwritten."
msgstr "I<linkpath> が存在する場合には上書きはI<されない>。"

#. type: SS
#: build/C/man2/symlink.2:107
#, no-wrap
msgid "symlinkat()"
msgstr "symlinkat()"

#. type: Plain text
#: build/C/man2/symlink.2:113
msgid ""
"The B<symlinkat>()  system call operates in exactly the same way as "
"B<symlink>(), except for the differences described here."
msgstr ""
"B<symlinkat>() システムコールは B<symlink>() と全く同様に動作するが、以下で説"
"明する点が異なる。"

#. type: Plain text
#: build/C/man2/symlink.2:123
msgid ""
"If the pathname given in I<linkpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<newdirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<symlink>()  for a relative pathname)."
msgstr ""
"I<linkpath> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<newdirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<symlink>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/symlink.2:135
msgid ""
"If I<linkpath> is relative and I<newdirfd> is the special value B<AT_FDCWD>, "
"then I<linkpath> is interpreted relative to the current working directory of "
"the calling process (like B<symlink>())."
msgstr ""
"I<linkpath> で指定されたパス名が相対パスで、 I<newdirfd> が特別な値 "
"B<AT_FDCWD> の場合、 (B<symlink>() と同様に) I<linkpath> は呼び出したプロセス"
"のカレントワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/symlink.2:141
msgid "If I<linkpath> is absolute, then I<newdirfd> is ignored."
msgstr ""
"I<linkpath> で指定されたパス名が絶対パスの場合、 I<newdirfd> は無視される。"

#. type: Plain text
#: build/C/man2/symlink.2:156
msgid ""
"Write access to the directory containing I<linkpath> is denied, or one of "
"the directories in the path prefix of I<linkpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""
"I<linkpath> を含んでいるディレクトリへの書き込みが拒否されたか、 I<linkpath> "
"に含まれているディレクトリのどれかに検索許可が与えられていない "
"(B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/symlink.2:161
msgid ""
"The user's quota of resources on the filesystem has been exhausted.  The "
"resources could be inodes or disk blocks, depending on the filesystem "
"implementation."
msgstr ""
"そのファイルシステムのリソース使用量がユーザークォータに達している。対象とな"
"るリソースは inode かディスクブロックで、どちらになるかはファイルシステムの実"
"装依存である。"

#. type: Plain text
#: build/C/man2/symlink.2:165
msgid "I<linkpath> already exists."
msgstr "I<linkpath> が既に存在する。"

#. type: Plain text
#: build/C/man2/symlink.2:168
msgid "I<target> or I<linkpath> points outside your accessible address space."
msgstr ""
"I<target> や I<linkpath> がアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/symlink.2:175
msgid "Too many symbolic links were encountered in resolving I<linkpath>."
msgstr "I<linkpath> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/symlink.2:178
msgid "I<target> or I<linkpath> was too long."
msgstr "I<target> または I<linkpath> が長過ぎる。"

#. type: Plain text
#: build/C/man2/symlink.2:187
msgid ""
"A directory component in I<linkpath> does not exist or is a dangling "
"symbolic link, or I<target> or I<linkpath> is an empty string."
msgstr "I<linkpath> に含まれるディレクトリ部分が存在しないか、壊れたリンクであるか、 I<target> か I<linkpath> が空文字列である。"

#. type: Plain text
#: build/C/man2/symlink.2:199
msgid ""
"A component used as a directory in I<linkpath> is not, in fact, a directory."
msgstr ""
"I<linkpath> に含まれるディレクトリ部分が、実際には、ディレクトリではない。"

#. type: Plain text
#: build/C/man2/symlink.2:204
msgid ""
"The filesystem containing I<linkpath> does not support the creation of "
"symbolic links."
msgstr ""
"I<linkpath> を含んでいるファイルシステム (file system) が シンボリックリンク"
"の作成をサポートしていない。"

#. type: Plain text
#: build/C/man2/symlink.2:208
msgid "I<linkpath> is on a read-only filesystem."
msgstr "I<linkpath> が読み込み専用のファイルシステムに存在している。"

#. type: Plain text
#: build/C/man2/symlink.2:211
msgid "The following additional errors can occur for B<symlinkat>():"
msgstr "B<symlinkat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/symlink.2:215
msgid "I<newdirfd> is not a valid file descriptor."
msgstr "I<newdirfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/symlink.2:221
msgid ""
"I<linkpath> is a relative pathname and I<newdirfd> refers to a directory "
"that has been deleted."
msgstr ""
"I<linkpath> が相対パス名で、 I<newdirfd> が削除されたディレクトリを参照してい"
"る。"

#. type: Plain text
#: build/C/man2/symlink.2:227
msgid ""
"I<linkpath> is relative and I<newdirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<linkpath> が相対パスで、 I<newdirfd> がディレクトリ以外のファイルを参照して"
"いるファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/symlink.2:231
msgid ""
"B<symlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<symlinkat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#.  SVr4 documents additional error codes EDQUOT and ENOSYS.
#.  See
#.  .BR open (2)
#.  re multiple files with the same name, and NFS.
#. type: Plain text
#: build/C/man2/symlink.2:238
msgid "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/symlink.2:241
msgid "B<symlinkat>(): POSIX.1-2008."
msgstr "B<symlinkat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/symlink.2:245
msgid "No checking of I<target> is done."
msgstr "I<target> についてのチェックは行なわれない。"

#. type: Plain text
#: build/C/man2/symlink.2:250
msgid ""
"Deleting the name referred to by a symbolic link will actually delete the "
"file (unless it also has other hard links).  If this behavior is not "
"desired, use B<link>(2)."
msgstr ""
"シンボリックリンクによって参照される名前を削除すると (それが他にハードリンク "
"(hard link) を持たなければ) 実際にファイルが削除される。 この動作が望んだもの"
"でない場合は、 B<link>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/symlink.2:263
msgid ""
"On older kernels where B<symlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<symlink>().  When I<linkpath> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<newdirfd> argument."
msgstr "B<symlinkat>() が利用できない古いカーネルでは、 glibc ラッパー関数は B<symlink>() を使用するモードにフォールバックする。 I<pathname> が相対パスの場合、 glibc は I<newdirfd> 引数に対応する I</proc/self/fd> のシンボリックリンクに基づいてパス名を構成する。"

#. type: Plain text
#: build/C/man2/symlink.2:275
msgid ""
"B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), "
"B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr "B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: Plain text
#: build/C/man7/symlink.7:40
msgid "symlink - symbolic link handling"
msgstr "symlink - シンボリックリンクの取り扱い"

#. type: Plain text
#: build/C/man7/symlink.7:44
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand "
"their behavior, you must first understand how hard links work."
msgstr ""
"シンボリックリンクは他のファイルへのポインターとして振る舞うファイルである。 "
"その挙動を理解するには、まずハードリンクがどのように機能するかを理解しておか"
"なければならない。"

#. type: Plain text
#: build/C/man7/symlink.7:60
msgid ""
"A hard link to a file is indistinguishable from the original file because it "
"is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same I<inode "
"number>, where an inode number is an index into the inode table, which "
"contains metadata about all files on a filesystem.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops "
"within the filesystem tree, which would confuse many programs)  and may not "
"refer to files on different filesystems (because inode numbers are not "
"unique across filesystems)."
msgstr ""
"あるファイルへのハードリンクは、 元々のファイルと区別することができない。 な"
"ぜなら、 ハードリンクは元々のファイル名の裏にあるオブジェクトへの参照だからで"
"ある。 (より正確には、 あるファイルへのハードリンクはそれぞれ同じ I<inode 番"
"号> への参照である。 inode 番号は inode テーブルへのインデックスで、 inode "
"テーブルはファイルシステム上のすべてのファイルについてのメタデータを保持して"
"いる。 B<stat>(2) 参照。) ファイルへの変更は、ファイルの参照に使用された名前"
"とは独立に行われる。 ハードリンクはディレクトリを参照することはできない (これ"
"はファイルシステムツリー内でループが発生する可能性を防止するためであり、 ルー"
"プが発生すると、 多くのプログラムが混乱してしまうことだろう)。 また、 ハード"
"リンクは異なるファイルシステム上のファイルを参照することもできない (inode 番"
"号はファイルシステムをまたがると一意ではないからである)。"

#. type: Plain text
#: build/C/man7/symlink.7:69
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname of another file, the file to which the link refers.  (The "
"contents of a symbolic link can be read using B<readlink>(2).)  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories "
"and may cross filesystem boundaries."
msgstr ""
"シンボリックリンクは特別な種類のファイルで、 ファイルの内容はそのリンクの参照"
"先の別のファイルのパス名を示す文字列である (シンボリックリンクの内容は "
"B<readlink>(2) を使って読むことができる)。 言い換えると、 シンボリックリンク"
"は別の名前へのポインターであり、 ファイルの裏にあるオブジェクトへのポインター"
"ではない。 この理由から、 シンボリックリンクではディレクトリへの参照やファイ"
"ルシステム境界を越える参照を行うことができる。"

#. type: Plain text
#: build/C/man7/symlink.7:75
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist "
"is said to be a I<dangling link>."
msgstr ""
"シンボリックリンクが参照する先のパス名が存在しないといけないという要件はな"
"い。 存在しないパス名を参照するシンボリックリンクは「壊れた (dangling) リン"
"ク」と呼ばれる。"

#. type: Plain text
#: build/C/man7/symlink.7:88
msgid ""
"Because a symbolic link and its referenced object coexist in the filesystem "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls "
"adopted their own link-following conventions in a somewhat ad-hoc fashion.  "
"Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""
"シンボリックリンクとその参照先のオブジェクトは一つのファイルシステムの名前空"
"間内に共存するので、 リンクそのものと参照先のオブジェクトの間で混乱が生じる可"
"能性がある。 かなり昔からあるシステムでは、 コマンドやシステムコールはいくら"
"かアドホックな方法の独自のリンクの辿り方の決まり事を採用している。 ここで"
"は、 Linux や他のシステムで実装されている、 もっと広く使われている方法のルー"
"ルについて概要を説明する。 サイト固有のアプリケーションもこれらのルールに準拠"
"し、 可能な限りユーザーインターフェースが一貫したものになるようにすることが重"
"要である。"

#. type: SS
#: build/C/man7/symlink.7:88
#, no-wrap
msgid "Magic links"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:101
msgid ""
"There is a special class of symbolic-link-like objects known as \"magic links"
"\", which can be found in certain pseudofilesystems such as B<proc>(5)  "
"(examples include I</proc/[pid]/exe> and I</proc/[pid]/fd/*>).  Unlike "
"normal symbolic links, magic links are not resolved through pathname-"
"expansion, but instead act as direct references to the kernel's own "
"representation of a file handle.  As such, these magic links allow users to "
"access files which cannot be referenced with normal paths (such as unlinked "
"files still referenced by a running program )."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:107
msgid ""
"Because they can bypass ordinary B<mount_namespaces>(7)-based restrictions, "
"magic links have been used as attack vectors in various exploits."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:107
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr "シンボリックリンクの所有権、アクセス許可、タイムスタンプ"

#. type: Plain text
#: build/C/man7/symlink.7:115
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""
"既存のシンボリックリンクの所有者とグループは B<lchown>(2) を使って変更するこ"
"とができる。 シンボリックリンクの所有権が問題となる場面は、 スティッキービッ"
"ト (B<stat>(2) 参照) がセットされたディレクトリで、 そのリンクの削除や名前の"
"変更を行おうとしている場合だけである。"

#. type: Plain text
#: build/C/man7/symlink.7:121
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""
"シンボリックリンクの最終アクセス時刻と最終修正時刻は B<utimensat>(2) や "
"B<lutimes>(3) で変更できる。"

#.  Linux does not currently implement an lchmod(2).
#. type: Plain text
#: build/C/man7/symlink.7:126
msgid ""
"On Linux, the permissions of an ordinary symbolic link are not used in any "
"operations; the permissions are always 0777 (read, write, and execute for "
"all user categories), and can't be changed."
msgstr "Linux では、通常のシンボリックリンクのアクセス許可 (permission) はどの操作でも使用されない。 アクセス許可は常に 0777 (すべてのユーザーカテゴリーにおいて読み出し、書き込み、実行が可能) で、変更できない。"

#. type: Plain text
#: build/C/man7/symlink.7:130
msgid ""
"However, magic links do not follow this rule.  They can have a non-0777 "
"mode, though this mode is not currently used in any permission checks."
msgstr ""

#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: SS
#: build/C/man7/symlink.7:144
#, no-wrap
msgid "Obtaining a file descriptor that refers to a symbolic link"
msgstr "シンボリックリンクを参照するファイルディスクリプターを取得する"

#. type: Plain text
#: build/C/man7/symlink.7:162
msgid ""
"Using the combination of the B<O_PATH> and B<O_NOFOLLOW> flags to "
"B<open>(2)  yields a file descriptor that can be passed as the I<dirfd> "
"argument in system calls such as B<fstatat>(2), B<fchownat>(2), "
"B<fchmodat>(2), B<linkat>(2), and B<readlinkat>(2), in order to operate on "
"the symbolic link itself (rather than the file to which it refers)."
msgstr ""
"B<open>(2) に B<O_PATH> と B<O_NOFOLLOW> の両方のフラグを指定すると、ファイル"
"ディスクリプターが得られる。このファイルディスクリプターは B<fstatat>(2), "
"B<fchownat>(2), B<fchmodat>(2), B<linkat> (2), B<readlinkat>(2) などのシステ"
"ムコールの I<dirfd> 引数として渡して、 (シンボリックリンクが参照するファイ"
"ルではなく) シンボリックリンク自身に対する操作を行うことができる。"

#. type: Plain text
#: build/C/man7/symlink.7:178
msgid ""
"By default (i.e., if the B<AT_SYMLINK_FOLLOW> flag is not specified), if "
"B<name_to_handle_at>(2)  is applied to a symbolic link, it yields a handle "
"for the symbolic link (rather than the file to which it refers).  One can "
"then obtain a file descriptor for the symbolic link (rather than the file to "
"which it refers)  by specifying the B<O_PATH> flag in a subsequent call to "
"B<open_by_handle_at>(2).  Again, that file descriptor can be used in the "
"aforementioned system calls to operate on the symbolic link itself."
msgstr ""
"デフォルトでは (すなわち B<AT_SYMLINK_FOLLOW> フラグが指定されなかった場"
"合)、 B<name_to_handle_at>(2) がシンボリックリンクに適用された場合、 (シンボ"
"リックリンクが参照するファイルではなく) シンボリックリンクへのハンドルが返さ"
"れる。 それ以降の B<open_by_handle_at>(2) で B<O_PATH> フラグを指定すること"
"で、 (シンボリックリンクが参照するファイルではなく) シンボリックリンクに対す"
"るファイルディスクリプターを得ることができる。 繰り返しになるが、 このファイ"
"ルディスクリプターを上述のシステムコールで使用し、 シンボリックリンク自身に操"
"作を行うことができる。"

#. type: SS
#: build/C/man7/symlink.7:178
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr "システムコールやコマンドによるシンボリックリンクの扱い"

#. type: Plain text
#: build/C/man7/symlink.7:193
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""
"シンボリックリンクは、 リンク自身に対する操作か、 リンクが参照するオブジェク"
"トに対する操作のいずれかとして扱われる。 後者の場合、 アプリケーションやシス"
"テムコールはリンクをI<辿る (follow)>と呼ばれる。 シンボリックリンクは他のシン"
"ボリックリンクを参照することもできる。 この場合、 シンボリックリンクでないオ"
"ブジェクトが見つかるか、 存在しないファイルを参照するシンボリックリンクが見つ"
"かるか、 ループが検出されるまで、 リンクの展開が行われる。 (ループの検出は辿"
"ることができるリンクの数に上限を設けることで行われる。 この上限を超過した場合"
"はエラーとなる。)"

#. type: Plain text
#: build/C/man7/symlink.7:196
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr "3 つの領域に分けて議論する必要がある。以下の 3 つである。"

#. type: IP
#: build/C/man7/symlink.7:196 build/C/man7/symlink.7:226
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/symlink.7:198
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""
"システムコールのファイル名引数としてシンボリックリンクが使用される場合。"

#. type: IP
#: build/C/man7/symlink.7:198 build/C/man7/symlink.7:234
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/symlink.7:201
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not "
"traversing a file tree."
msgstr ""
"ファイルツリーを辿っていないユーティリティーのコマンドライン引数としてシン"
"ボリックリンクが指定される場合。"

#. type: IP
#: build/C/man7/symlink.7:201
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/symlink.7:205
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""
"ファイルツリーを辿っているユーティリティーがシンボリックリンクを見つけた場合 "
"(コマンドラインで指定される場合もあれば、 ファイル階層を辿っている途中で遭遇"
"する場合もある)。"

#. type: Plain text
#: build/C/man7/symlink.7:220
msgid ""
"Before describing the treatment of symbolic links by system calls and "
"commands, we require some terminology.  Given a pathname of the form I<a/b/"
"c>, the part preceding the final slash (i.e., I<a/b>)  is called the "
"I<dirname> component, and the part following the final slash (i.e., I<c>)  "
"is called the I<basename> component."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:220
#, no-wrap
msgid "Treatment of symbolic links in system calls"
msgstr "システムコールにおけるシンボリックリンクの取り扱い"

#. type: Plain text
#: build/C/man7/symlink.7:223
msgid ""
"The first area is symbolic links used as filename arguments for system calls."
msgstr ""
"最初の領域は、システムコールのファイル名引数としてシンボリックリンクが使用"
"される場合である。"

#. type: Plain text
#: build/C/man7/symlink.7:226
#, fuzzy
#| msgid ""
#| "The first area is symbolic links used as filename arguments for system "
#| "calls."
msgid ""
"The treatment of symbolic links within a pathname passed to a system call is "
"as follows:"
msgstr ""
"最初の領域は、システムコールのファイル名引数としてシンボリックリンクが使用"
"される場合である。"

#. type: Plain text
#: build/C/man7/symlink.7:234
msgid ""
"Within the dirname component of a pathname, symbolic links are always "
"followed in nearly every system call.  (This is also true for commands.)  "
"The one exception is B<openat2>(2), which provides flags that can be used to "
"explicitly prevent following of symbolic links in the dirname component."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:246
#, fuzzy
#| msgid ""
#| "Except as noted below, all system calls follow symbolic links.  For "
#| "example, if there were a symbolic link I<slink> which pointed to a file "
#| "named I<afile>, the system call I<open(\"slink\" ...\\&)> would return a "
#| "file descriptor referring to the file I<afile>."
msgid ""
"Except as noted below, all system calls follow symbolic links in the "
"basename component of a pathname.  For example, if there were a symbolic "
"link I<slink> which pointed to a file named I<afile>, the system call "
"I<open(\"slink\" ...\\&)> would return a file descriptor referring to the "
"file I<afile>."
msgstr ""
"以下に述べる場合を除くと、 すべてのシステムコールはシンボリックリンクを辿"
"る。 例えば、 I<afile> という名前のファイルを指しているシンボリックリンク "
"I<slink> があったとすると、 システムコール I<open(\"slink\" ...\\&)> はファイ"
"ル I<afile> を参照するファイルディスクリプターを返す。"

#. type: Plain text
#: build/C/man7/symlink.7:262
#, fuzzy
#| msgid ""
#| "Various system calls do not follow links, and operate on the symbolic "
#| "link itself.  They are: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
#| "B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), "
#| "B<rename>(2), B<rmdir>(2), and B<unlink>(2)."
msgid ""
"Various system calls do not follow links in the basename component of a "
"pathname, and operate on the symbolic link itself.  They are: B<lchown>(2), "
"B<lgetxattr>(2), B<llistxattr>(2), B<lremovexattr>(2), B<lsetxattr>(2), "
"B<lstat>(2), B<readlink>(2), B<rename>(2), B<rmdir>(2), and B<unlink>(2)."
msgstr ""
"リンクを辿らず、シンボリックリンク自身に対して操作を行うシステムコールもあ"
"る。 このようなシステムコールとしては、 B<lchown>(2), B<lgetxattr>(2), "
"B<llistxattr>(2), B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), "
"B<readlink>(2), B<rename>(2), B<rmdir>(2), B<unlink>(2) がある。"

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: build/C/man7/symlink.7:287
#, fuzzy
#| msgid ""
#| "Certain other system calls optionally follow symbolic links.  They are: "
#| "B<faccessat>(2), B<fchownat>(2), B<fstatat>(2), B<linkat>(2), "
#| "B<name_to_handle_at>(2), B<open>(2), B<openat>(2), "
#| "B<open_by_handle_at>(2), and B<utimensat>(2); see their manual pages for "
#| "details.  Because B<remove>(3)  is an alias for B<unlink>(2), that "
#| "library function also does not follow symbolic links.  When B<rmdir>(2)  "
#| "is applied to a symbolic link, it fails with the error B<ENOTDIR>."
msgid ""
"Certain other system calls optionally follow symbolic links in the basename "
"component of a pathname.  They are: B<faccessat>(2), B<fchownat>(2), "
"B<fstatat>(2), B<linkat>(2), B<name_to_handle_at>(2), B<open>(2), "
"B<openat>(2), B<open_by_handle_at>(2), and B<utimensat>(2); see their manual "
"pages for details.  Because B<remove>(3)  is an alias for B<unlink>(2), that "
"library function also does not follow symbolic links.  When B<rmdir>(2)  is "
"applied to a symbolic link, it fails with the error B<ENOTDIR>."
msgstr ""
"他のいくつかのシステムコールは、指定された場合にのみシンボリックリンクを辿"
"る。 これらのシステムコールとしては、 B<faccessat>(2), B<fchownat>(2), "
"B<fstatat>(2), B<linkat>(2), B<name_to_handle_at>(2), B<open>(2), "
"B<openat>(2), B<open_by_handle_at>(2), B<utimensat>(2) がある。 詳細はそれぞ"
"れのマニュアルページを参照してほしい。 B<remove>(3) は B<unlink>(2) の別名な"
"ので、 このライブラリ関数もシンボリックリンクを辿らない。 B<rmdir>(2) がシン"
"ボリックリンクに対して行われた場合、その呼び出しはエラー B<ENOTDIR> で失敗す"
"る。"

#. type: Plain text
#: build/C/man7/symlink.7:301
msgid ""
"B<link>(2)  warrants special discussion.  POSIX.1-2001 specifies that "
"B<link>(2)  should dereference I<oldpath> if it is a symbolic link.  "
"However, Linux does not do this.  (By default, Solaris is the same, but the "
"POSIX.1-2001 specified behavior can be obtained with suitable compiler "
"options.)  POSIX.1-2008 changed the specification to allow either behavior "
"in an implementation."
msgstr "B<link>(2) については特別に議論が必要である。 POSIX.1-2001 では B<link>(2) は I<oldpath> がシンボリックリンクであればこれを展開するように規定している。 しかしながら、 Linux はシンボリックリンクを展開しない。 (デフォルトでは Solaris も同じだが、 適切なコンパイラーオプションを指定することで POSIX.1-2001 で規定された動作をさせることができる。) POSIX.1-2008 では、どちらの動作の実装も認められるように規定が変更された。"

#. type: SS
#: build/C/man7/symlink.7:301
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr "ファイルツリーを辿らないコマンド"

#. type: Plain text
#: build/C/man7/symlink.7:304
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""
"二つ目の領域は、 ファイルツリーを辿らないコマンドの、 コマンドライン引数の"
"ファイル名としてシンボリックリンクが指定される場合である。"

#. type: Plain text
#: build/C/man7/symlink.7:315
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the "
"contents of the file I<afile>."
msgstr ""
"以下に述べる場合を除くと、 コマンドはコマンドライン引数で指定された名前のシ"
"ンボリックリンクを辿る。 例えば、 I<afile> という名前のファイルを指しているシ"
"ンボリックリンク I<slink> があったとすると、 コマンド I<cat slink> は "
"I<afile> の内容を表示することになる。"

#. type: Plain text
#: build/C/man7/symlink.7:323
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees; for example, the command I<chown file> is "
"included in this rule, while the command I<chown\\ -R file>, which performs "
"a tree traversal, is not.  (The latter is described in the third area, "
"below.)"
msgstr ""
"大事な点として意識しておくべきなのは、 このルールが適用されるコマンドの中に"
"は、 オプション次第ではファイルツリーを辿る場合があるコマンドもあるということ"
"である。  例えば、 コマンド I<chown file> はこのルールに含まれるが、 コマン"
"ド I<chown\\ -R file> はツリーを辿る動作をするのであてはまらない (後者の場合"
"は、3 つ目の領域に該当する)。"

#. type: Plain text
#: build/C/man7/symlink.7:341
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link\\(emfor example, it is desired that "
"I<chown slink> change the ownership of the file that I<slink> is, whether it "
"is a symbolic link or not\\(emthen the I<-h> option should be used.  In the "
"above example, I<chown root slink> would change the ownership of the file "
"referred to by I<slink>, while I<chown\\ -h root slink> would change the "
"ownership of I<slink> itself."
msgstr ""
"シンボリックリンクを辿るのではなく、 コマンドがシンボリックリンク自身に対して"
"操作を行うことを明示的に指示したい場合、 例えば、 I<chown slink> で I<slink> "
"がシンボリックリンクかどうかに関わらず、 I<slink> のファイル自身の所有権を変"
"更したい場合は、 I<-h> オプションを使用すべきである。 上記の例では、 I<chown "
"root slink> は I<slink> が参照するファイルの所有権を変更するが、 I<chown\\ -"
"h root slink> は I<slink> 自身の所有権を変更する。"

#. type: Plain text
#: build/C/man7/symlink.7:343
msgid "There are some exceptions to this rule:"
msgstr "このルールにはいくつかの例外がある。"

#. type: Plain text
#: build/C/man7/symlink.7:353
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may "
"no longer be correct.)"
msgstr ""
"コマンド B<mv>(1) と B<rm>(1) は引数で指定された名前のシンボリックリンクを"
"辿らないが、 それぞれシンボリックリンク自身の名前変更と削除を行おうとする。 "
"(シンボリックリンクが相対パスでファイルを参照している場合、 そのシンボリック"
"リンクを別のディレクトリに移動すると、動かなくなることが非常によくある。 移動"
"の結果、 パスが正しくないものになってしまうからである。)"

#. type: Plain text
#: build/C/man7/symlink.7:383
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk\\(emthat is, "
"I<-R> option is not specified), the B<ls>(1)  command follows symbolic links "
"named as arguments if the I<-H> or I<-L> option is specified, or if the I<-"
"F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is "
"the only command where the I<-H> and I<-L> options affect its behavior even "
"though it is not doing a walk of a file tree.)"
msgstr ""
"B<ls>(1) コマンドもこのルールの例外である。 昔からあるシステムとの互換性のた"
"め (B<ls>(1) がツリーを辿らない場合、つまり I<-R> オプションが指定されなかっ"
"た場合)、 B<ls>(1) コマンドはオプション I<-H> か I<-L> が指定された場合、もし"
"くはオプション I<-F>, I<-d>, I<-l> が指定されなかった場合、 引数として指定"
"されたシンボリックリンクを辿る。 (B<ls>(1) コマンドは、 ファイルツリーを辿ら"
"ない場合であっても、 オプション I<-H> と I<-L> がその動作に影響を与える唯一の"
"コマンドである。)"

#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: build/C/man7/symlink.7:401
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the I<-"
"L> option is specified."
msgstr ""
"B<file>(1) コマンドもこのルールの例外である。 B<file>(1) コマンドは、 デフォ"
"ルトでは引数で指定されたシンボリックリンクを辿らない。 B<file>(1) コマンド"
"は、 I<-L> オプションが指定された場合、 引数で指定されたシンボリックリンク"
"を辿る。"

#. type: SS
#: build/C/man7/symlink.7:401
#, no-wrap
msgid "Commands traversing a file tree"
msgstr "ファイルツリーを辿るコマンド"

#. type: Plain text
#: build/C/man7/symlink.7:414
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), "
"B<ls>(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""
"次のコマンドは指定された場合もしくは常にファイルツリーを辿る: B<chgrp>(1), "
"B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), B<ls>(1), "
"B<pax>(1), B<rm>(1), B<tar>(1)。"

#. type: Plain text
#: build/C/man7/symlink.7:418
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links "
"listed as command-line arguments."
msgstr ""
"重要なのは、 ファイルツリーを辿っている際に見つかったシンボリックリンクに"
"も、 コマンドライン引数として渡されたシンボリックリンクにも、 以下のルール"
"が等しく適用される点である。"

#. type: Plain text
#: build/C/man7/symlink.7:423
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""
"「1 つ目のルール」は、 ディレクトリ以外のファイルを参照するシンボリックリンク"
"に適用される。 シンボリックリンクに適用される操作はシンボリックリンク自身に行"
"われるが、 そうでない場合はリンクは無視される。"

#. type: Plain text
#: build/C/man7/symlink.7:435
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""
"コマンド I<rm\\ -r slink directory> は I<slink> を削除するとともに、 ファイル"
"ツリーを辿る途中で見つけたシンボリックリンクも削除する。 シンボリックリンクは"
"削除できるからである。 B<rm>(1) が I<slink> が参照するファイルに影響をおよぼ"
"すことはない。"

#. type: Plain text
#: build/C/man7/symlink.7:440
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a \"logical"
"\" walk (where symbolic links that refer to directories are followed)."
msgstr ""
"「2 つ目のルール」は、 ディレクトリを参照するシンボリックリンクに適用され"
"る。 デフォルトでは、 ディレクトリを参照するシンボリックリンクを辿らない。 こ"
"の動作はしばしば「物理的な」ツリー探索 (\"physical\" walk) と呼ばれる。 これ"
"に対して (ディレクトリを参照するシンボリックリンクを辿る場合は) 「論理的な」"
"ツリー探索 (\"logical\" walk) と呼ばれる。"

#. type: Plain text
#: build/C/man7/symlink.7:443
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""
"一貫性を持たせるため、ファイルツリーを辿るコマンドが可能な限り従っている慣習"
"がいくつかある。"

#. type: Plain text
#: build/C/man7/symlink.7:456
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H> "
"(for \"half-logical\") flag.  This flag is intended to make the command-line "
"name space look like the logical name space.  (Note, for commands that do "
"not always do file tree traversals, the I<-H> flag will be ignored if the I<-"
"R> flag is not also specified.)"
msgstr ""
"I<-H> (\"half-logical\") フラグを指定すると、 参照先のファイル種別に関わら"
"ず、 コマンドにコマンドラインで指定されたシンボリックリンクを辿らせることがで"
"きる。 このフラグは、 コマンドラインの名前空間を論理的な名前空間のように見せ"
"るためのものである。 (常にファイルツリーを辿るわけではないコマンドでは、 I<-"
"R> フラグを一緒に指定しない限り、 I<-H> フラグは無視される点に注意。)"

#. type: Plain text
#: build/C/man7/symlink.7:472
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not "
"the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""
"例えば、 コマンド I<chown\\ -HR user slink> は I<slink> が指すファイルを頂点"
"とするファイル階層を辿る。 I<-H> は上記で説明した I<-h> フラグとは同じではな"
"いことに注意。 I<-H> フラグを指定すると、 アクションを実行する場合でも、 ツ"
"リーを辿る場合でも、 コマンドラインで指定されたシンボリックリンクの解決 "
"(dereference) を行う。 ユーザーがシンボリックリンクが指すファイル名を指定した"
"のと同じように見える。"

#. type: Plain text
#: build/C/man7/symlink.7:486
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look "
"like the logical name space.  (Note, for commands that do not always do file "
"tree traversals, the I<-L> flag will be ignored if the I<-R> flag is not "
"also specified.)"
msgstr ""
"I<-L> (\"logical\") フラグを指定すると、 参照先のファイル種別に関わらず、 コ"
"マンドが、 コマンドラインで指定された名前のシンボリックリンクも、 ファイルツ"
"リーを辿る際に見つけたシンボリックリンクも辿るようになる。 このフラグは、 名"
"前空間全体を論理的な名前空間のように見せるためのものである。 (常にファイルツ"
"リーを辿るわけではないコマンドでは、 I<-R> フラグを一緒に指定しない限り、 I<-"
"L> フラグは無視される点に注意。)"

#. type: Plain text
#: build/C/man7/symlink.7:501
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""
"例えば、 コマンド I<chown\\ -LR user slink> は I<slink> が参照するファイルの"
"所有者を変更する。\n"
"I<slink> がディレクトリを参照する場合、 B<chown> はそのシンボリックリンクが参"
"照するディレクトリを頂点とするファイル階層を辿る。 また、 B<chown> が辿るファ"
"イルツリー内でシンボリックリンクが見つかった場合、 I<slink> と同じように処理"
"される。"

#. type: Plain text
#: build/C/man7/symlink.7:508
msgid ""
"A command can be made to provide the default behavior by specifying the I<-"
"P> (for \"physical\") flag.  This flag is intended to make the entire name "
"space look like the physical name space."
msgstr ""
"I<-P> (\"physical\") フラグを指定すると、 コマンドはデフォルトの動作をするよ"
"うになる。 このフラグは名前空間全体を物理的な名前空間のように見せるためのもの"
"である。"

#. type: Plain text
#: build/C/man7/symlink.7:526
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, I<-"
"L>, and I<-P> flags are ignored if the I<-R> flag is not also specified.  In "
"addition, you may specify the I<-H>, I<-L>, and I<-P> options more than "
"once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and "
"then override that behavior on the command line."
msgstr ""
"デフォルトでファイルツリーを辿らないコマンドでは、 I<-R> フラグが同時に指定さ"
"れなかった場合、 フラグ I<-H>, I<-L>, I<-P> は無視される。 また、 I<-H>, I<-"
"L>, I<-P> は複数回同時に指定できるが、 最後に指定されたオプションでコマンドの"
"動作が決定される。 この動作は、 コマンドのエイリアスにある動作を指定しておい"
"て、 コマンドラインでその動作を上書きできるようにするためである。"

#. type: Plain text
#: build/C/man7/symlink.7:532
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr ""
"コマンド B<ls>(1) と B<rm>(1) には、 これらのルールに対する例外がある。"

#. type: Plain text
#: build/C/man7/symlink.7:545
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""
"B<rm>(1) コマンドは、 参照先のファイルではなく、シンボリックリンクに対して操"
"作を行う。 したがって、 シンボリックリンクを辿ることはない。 B<rm>(1) コマン"
"ドはオプション I<-H>, I<-L>, I<-P> をサポートしていない。"

#. type: Plain text
#: build/C/man7/symlink.7:565
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command "
"line.  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""
"古いシステムとの互換性を持たせるため、 B<ls>(1) コマンドは少し違った動作をす"
"る。 オプション I<-F>, I<-d>, I<-l> を指定した場合、 B<ls>(1) はコマンドライ"
"ンで指定されたシンボリックリンクを辿る。 I<-L> フラグが指定された場合、 コマ"
"ンドラインで指定された場合でも、 ファイルツリーを辿る際に見つかった場合で"
"も、 ファイル種別に関わらず、 B<ls>(1) はすべてのシンボリックリンクを辿る。"

#. type: Plain text
#: build/C/man7/symlink.7:584
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<namei>(1), B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), "
"B<readlink>(2), B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), "
"B<lutimes>(3), B<path_resolution>(7)"
msgstr "B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), B<namei>(1), B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<readlink>(2), B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), B<lutimes>(3), B<path_resolution>(7)"

#. type: TH
#: build/C/man3/tempnam.3:25
#, no-wrap
msgid "TEMPNAM"
msgstr "TEMPNAM"

#. type: Plain text
#: build/C/man3/tempnam.3:28
msgid "tempnam - create a name for a temporary file"
msgstr "tempnam - テンポラリファイルの名前を作成する"

#. type: Plain text
#: build/C/man3/tempnam.3:33
#, no-wrap
msgid "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"
msgstr "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"

#. type: Plain text
#: build/C/man3/tempnam.3:45
#, no-wrap
msgid ""
"B<tempnam>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:52
msgid ""
"I<Never use this function.> Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr ""
"I<決してこの関数を使用しないこと。> 代わりに B<mkstemp>(3)  か B<tmpfile>(3) "
"を使うこと。"

#. type: Plain text
#: build/C/man3/tempnam.3:66
msgid ""
"The B<tempnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist when "
"B<tempnam>()  checked.  The filename suffix of the pathname generated will "
"start with I<pfx> in case I<pfx> is a non-NULL string of at most five "
"bytes.  The directory prefix part of the pathname generated is required to "
"be \"appropriate\" (often that at least implies writable)."
msgstr ""
"B<tempnam>()  関数はファイル名として正しい文字列へのポインターを返す。 この"
"ファイル名を持つファイルは、 B<tempnam>()  がチェックした時点においては存在し"
"ない (しなかった)。 I<pfx> が NULL でない 5 バイト以内の文字列であれば、 生成"
"されるパス名のうちのファイル名の部分は I<pfx> から始まるものになる。 生成され"
"るディレクトリの部分は、「適切」でなければならない (大抵の場合、「適切」であ"
"るためにはまず少なくとも 書き込み可能でなければならない)。"

#. type: Plain text
#: build/C/man3/tempnam.3:69
msgid ""
"Attempts to find an appropriate directory go through the following steps:"
msgstr "適切なディレクトリの探索は、以下の手順にしたがって行われる。"

#. type: TP
#: build/C/man3/tempnam.3:69
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man3/tempnam.3:75
msgid ""
"In case the environment variable B<TMPDIR> exists and contains the name of "
"an appropriate directory, that is used."
msgstr ""
"環境変数 B<TMPDIR> が設定されていて、 その内容が適切なディレクトリの名前な"
"ら、それを用いる。"

#. type: TP
#: build/C/man3/tempnam.3:75
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man3/tempnam.3:80
msgid ""
"Otherwise, if the I<dir> argument is non-NULL and appropriate, it is used."
msgstr ""
"それ以外の場合、 I<dir> 引数が NULL でない文字列でかつ適切なら、それを用い"
"る。"

#. type: TP
#: build/C/man3/tempnam.3:80
#, no-wrap
msgid "c)"
msgstr "c)"

#. type: Plain text
#: build/C/man3/tempnam.3:87
msgid ""
"Otherwise, I<P_tmpdir> (as defined in I<E<lt>stdio.hE<gt>>)  is used when "
"appropriate."
msgstr ""
"それ以外の場合、 (I<E<lt>stdio.hE<gt>> で定義されている)  I<P_tmpdir> が適切"
"なら、それを用いる。"

#. type: TP
#: build/C/man3/tempnam.3:87
#, no-wrap
msgid "d)"
msgstr "d)"

#. type: Plain text
#: build/C/man3/tempnam.3:90
msgid "Finally an implementation-defined directory may be used."
msgstr "最後に実装で定義されたディレクトリが用いられることになる。"

#. type: Plain text
#: build/C/man3/tempnam.3:97
msgid ""
"The string returned by B<tempnam>()  is allocated using B<malloc>(3)  and "
"hence should be freed by B<free>(3)."
msgstr ""
"B<tempnam>()  が返す文字列は B<malloc>(3)  を使って確保される。そのため、 "
"B<free>(3)  で解放すべきである。"

#. type: Plain text
#: build/C/man3/tempnam.3:104
msgid ""
"On success, the B<tempnam>()  function returns a pointer to a unique "
"temporary filename.  It returns NULL if a unique name cannot be generated, "
"with I<errno> set to indicate the cause of the error."
msgstr ""
"成功すると B<tempnam>()  関数は、一意なテンポラリファイル名へのポインターを返"
"す。 一意な名前が生成できなければ NULL を返し、 I<errno> にエラーの原因を示す"
"値を設定する。"

#. type: Plain text
#: build/C/man3/tempnam.3:108
msgid "Allocation of storage failed."
msgstr "保存領域の割り当てに失敗した。"

#. type: tbl table
#: build/C/man3/tempnam.3:118
#, no-wrap
msgid "B<tempnam>()"
msgstr "B<tempnam>()"

#. type: tbl table
#: build/C/man3/tempnam.3:118
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: Plain text
#: build/C/man3/tempnam.3:125
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<tempnam>()  as obsolete."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 は B<tempnam>()  を廃止予定としてい"
"る。"

#. type: Plain text
#: build/C/man3/tempnam.3:144
msgid ""
"Although B<tempnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tempnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""
"B<tempnam>()  は推測が難しい名前を生成するが、それにもかかわらず、 "
"B<tempnam>()  がパス名を返してから、プログラムがそのファイルをオープンする ま"
"での間に、別のプログラムが同じパス名で、ファイルを B<open>(2)  で作成したり、"
"シンボリックリンクを作成したりする可能性がある。 これはセキュリティホールにつ"
"ながる可能性がある。 そのような可能性を回避するためには、 B<open>(2)  の "
"B<O_EXCL> フラグを使ってパス名をオープンすればよい。 もっといいのは、 "
"B<mkstemp>(3)  や B<tmpfile>(3)  を使うことである。"

#. type: Plain text
#: build/C/man3/tempnam.3:152
msgid ""
"SUSv2 does not mention the use of B<TMPDIR>; glibc will use it only when the "
"program is not set-user-ID.  On SVr4, the directory used under B<d)> is I</"
"tmp> (and this is what glibc does)."
msgstr ""
"SUSv2 では B<TMPDIR> に付いて言及されていない。 glibc は、プログラムが set-"
"user-ID されていない場合に限ってこれを用いる。 SVr4 では B<d)> で使用される"
"ディレクトリを I</tmp> と定めている (glibc もこの通りである)。"

#. type: Plain text
#: build/C/man3/tempnam.3:157
msgid ""
"Because it dynamically allocates memory used to return the pathname, "
"B<tempnam>()  is reentrant, and thus thread safe, unlike B<tmpnam>(3)."
msgstr ""
"パス名を返すのに使用するメモリーを動的に確保するので、 B<tmpnam>(3)  と違"
"い、 B<tempnam>()  はリエントラントであり、スレッドセーフである。"

#. type: Plain text
#: build/C/man3/tempnam.3:170
msgid ""
"The B<tempnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> (defined in I<E<lt>stdio.hE<gt>>)  times.  If it is "
"called more than B<TMP_MAX> times, the behavior is implementation defined."
msgstr ""
"B<tempnam>()  関数は最大 B<TMP_MAX> 回まで、呼び出される度に異なる文字列を作"
"成する (B<TMP_MAX> は I<E<lt>stdio.hE<gt>> で定義されている)。 もし "
"B<TMP_MAX> 回以上呼び出された場合、動作は実装依存である。"

#. type: Plain text
#: build/C/man3/tempnam.3:174
msgid "B<tempnam>()  uses at most the first five bytes from I<pfx>."
msgstr "B<tempnam>()  は最大で I<pfx> の先頭 5 バイトを使用する。"

#. type: Plain text
#: build/C/man3/tempnam.3:180
msgid ""
"The glibc implementation of B<tempnam>()  fails with the error B<EEXIST> "
"upon failure to find a unique name."
msgstr ""
"他と重ならない名前が見つけられなかった場合、glibc の B<tempnam>()  の実装はエ"
"ラー B<EEXIST> で失敗する。"

#. type: Plain text
#: build/C/man3/tempnam.3:183
msgid ""
"The precise meaning of \"appropriate\" is undefined; it is unspecified how "
"accessibility of a directory is determined."
msgstr ""
"「適切」という言葉の正確な意味は定義されていない。 ディレクトリに対してどの程"
"度のアクセス権限が必要なのかは指定されていない。"

#. type: Plain text
#: build/C/man3/tempnam.3:188
msgid "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"

#. type: TH
#: build/C/man3/tmpfile.3:31
#, no-wrap
msgid "TMPFILE"
msgstr "TMPFILE"

#. type: Plain text
#: build/C/man3/tmpfile.3:34
msgid "tmpfile - create a temporary file"
msgstr "tmpfile - テンポラリファイルを作成する"

#. type: Plain text
#: build/C/man3/tmpfile.3:39
#, no-wrap
msgid "B<FILE *tmpfile(void);>\n"
msgstr "B<FILE *tmpfile(void);>\n"

#. type: Plain text
#: build/C/man3/tmpfile.3:47
msgid ""
"The B<tmpfile>()  function opens a unique temporary file in binary read/"
"write (w+b) mode.  The file will be automatically deleted when it is closed "
"or the program terminates."
msgstr ""
"B<tmpfile>()  関数はユニークなテンポラリファイルを バイナリリードライトモー"
"ド (w+b) でオープンする。 このファイルはクローズ時またはプログラムの終了時に"
"自動的に削除される。"

#. type: Plain text
#: build/C/man3/tmpfile.3:56
msgid ""
"The B<tmpfile>()  function returns a stream descriptor, or NULL if a unique "
"filename cannot be generated or the unique file cannot be opened.  In the "
"latter case, I<errno> is set to indicate the error."
msgstr ""
"B<tmpfile>()  関数はファイルポインターを返すか、 ユニークなファイルが作れな"
"かったかオープンできなかった場合は NULL を返す。 後者の場合、エラーを表す "
"I<errno> を設定する。"

#. type: Plain text
#: build/C/man3/tmpfile.3:60
msgid "Search permission denied for directory in file's path prefix."
msgstr ""
"ファイルのあるディレクトリにサーチのアクセス権 (search permission) がない。"

#. type: Plain text
#: build/C/man3/tmpfile.3:63
msgid "Unable to generate a unique filename."
msgstr "ユニークなファイル名が作成できなかった。"

#. type: Plain text
#: build/C/man3/tmpfile.3:67
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr "呼び出しがシグナルにより割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/tmpfile.3:76
msgid "There was no room in the directory to add the new filename."
msgstr "ディレクトリに新しいファイルを追加するための空き領域がない。"

#. type: Plain text
#: build/C/man3/tmpfile.3:79
msgid "Read-only filesystem."
msgstr "読みだし専用ファイルシステムである。"

#. type: tbl table
#: build/C/man3/tmpfile.3:89
#, no-wrap
msgid "B<tmpfile>()"
msgstr "B<tmpfile>()"

#. type: Plain text
#: build/C/man3/tmpfile.3:93
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD, SUSv2."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD, SUSv2."

#. type: Plain text
#: build/C/man3/tmpfile.3:99
msgid ""
"POSIX.1-2001 specifies: an error message may be written to I<stdout> if the "
"stream cannot be opened."
msgstr ""
"POSIX.1-2001 では、 ストリームをオープンできなかった場合、 I<stdout> にエラー"
"メッセージが書き出される、と規定されている。"

#. type: Plain text
#: build/C/man3/tmpfile.3:110
msgid ""
"The standard does not specify the directory that B<tmpfile>()  will use.  "
"Glibc will try the path prefix I<P_tmpdir> defined in I<E<lt>stdio.hE<gt>>, "
"and if that fails the directory I</tmp>."
msgstr ""
"規格では B<tmpfile>()  が使うディレクトリは指定されていない。 glibc では "
"I<E<lt>stdio.hE<gt>> で定義されている I<P_tmpdir> をパスの先頭に使おうとす"
"る。 これが失敗した場合は、ディレクトリ I</tmp> を使う。"

#. type: Plain text
#: build/C/man3/tmpfile.3:116
msgid "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"
msgstr "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"

#. type: TH
#: build/C/man3/tmpnam.3:27
#, no-wrap
msgid "TMPNAM"
msgstr "TMPNAM"

#. type: Plain text
#: build/C/man3/tmpnam.3:30
msgid "tmpnam, tmpnam_r - create a name for a temporary file"
msgstr "tmpnam, tmpnam_r - 一時ファイルの名前を作成する"

#. type: Plain text
#: build/C/man3/tmpnam.3:36
#, no-wrap
msgid ""
"B<char *tmpnam(char *>I<s>B<);>\n"
"B<char *tmpnam_r(char *>I<s>B<);>\n"
msgstr ""
"B<char *tmpnam(char *>I<s>B<);>\n"
"B<char *tmpnam_r(char *>I<s>B<);>\n"

#. type: tbl table
#: build/C/man3/tmpnam.3:44 build/C/man3/tmpnam.3:123
#, no-wrap
msgid "B<tmpnam_r>()"
msgstr "B<tmpnam_r>()"

#. type: TP
#: build/C/man3/tmpnam.3:47
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "glibc 2.19 以降:"

#. type: Plain text
#: build/C/man3/tmpnam.3:50
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: build/C/man3/tmpnam.3:50
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:53
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/tmpnam.3:63
msgid ""
"B<Note:> avoid using these functions; use B<mkstemp>(3)  or B<tmpfile>(3)  "
"instead."
msgstr "B<注意:> これらの関数の使用は避けること。代わりに B<mkstemp>(3) か B<tmpfile>(3) を使うこと。"

#. type: Plain text
#: build/C/man3/tmpnam.3:85
msgid ""
"The B<tmpnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist at some point in "
"time, so that naive programmers may think it a suitable name for a temporary "
"file.  If the argument I<s> is NULL, this name is generated in an internal "
"static buffer and may be overwritten by the next call to B<tmpnam>().  If "
"I<s> is not NULL, the name is copied to the character array (of length at "
"least I<L_tmpnam>)  pointed to by I<s> and the value I<s> is returned in "
"case of success."
msgstr ""
"B<tmpnam>()  関数は、ファイル名に使える文字列へのポインターを返す。 ある時点"
"では同じ名前を持つファイルが存在しないファイル名が返されるので、 幼稚なプログ"
"ラマはこの文字列が一時ファイルのファイル名として 適していると考えるかもしれな"
"い。 引数 I<s> が NULL なら、この名前は内部の静的バッファーに作成され、 次"
"に B<tmpnam>()  関数が呼び出された時に上書きされる。 I<s> が NULL でなけれ"
"ば、ファイル名は I<s> が指す (少なくとも I<L_tmpnam> の長さを持つ) 文字配列に"
"コピーされ、 成功した場合は I<s> が返される。"

#. type: Plain text
#: build/C/man3/tmpnam.3:97
msgid ""
"The created pathname has a directory prefix I<P_tmpdir>.  (Both I<L_tmpnam> "
"and I<P_tmpdir> are defined in I<E<lt>stdio.hE<gt>>, just like the "
"B<TMP_MAX> mentioned below.)"
msgstr ""
"作成されるパス名は、ディレクトリの部分に I<P_tmpdir> が使われる。 "
"(I<L_tmpnam> と I<P_tmpdir> は、以下で説明する B<TMP_MAX> 同様 I<E<lt>stdio."
"hE<gt>> で定義されている。)"

#. type: Plain text
#: build/C/man3/tmpnam.3:105
msgid ""
"The B<tmpnam_r>()  function performs the same task as B<tmpnam>(), but "
"returns NULL (to indicate an error) if I<s> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:108
msgid ""
"These functions return a pointer to a unique temporary filename, or NULL if "
"a unique name cannot be generated."
msgstr "これらの関数は一意な一時ファイル名へのポインターを返す。 一意なファイル名が作成できなかった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/tmpnam.3:110
msgid "No errors are defined."
msgstr "エラーは定義されていない。"

#. type: tbl table
#: build/C/man3/tmpnam.3:120
#, no-wrap
msgid "B<tmpnam>()"
msgstr "B<tmpnam>()"

#. type: tbl table
#: build/C/man3/tmpnam.3:120
#, no-wrap
msgid "MT-Unsafe race:tmpnam/!s"
msgstr "MT-Unsafe race:tmpnam/!s"

#. type: Plain text
#: build/C/man3/tmpnam.3:131
msgid ""
"B<tmpnam>(): SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 marks "
"B<tmpnam>()  as obsolete."
msgstr "B<tmpnam>(): SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 は B<tmpnam>()  を廃止予定としている。"

#.  Appears to be on Solaris
#. type: Plain text
#: build/C/man3/tmpnam.3:136
msgid ""
"B<tmpnam_r>()  is a nonstandard extension that is also available on a few "
"other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:147
msgid ""
"The B<tmpnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> times.  If it is called more than B<TMP_MAX> times, "
"the behavior is implementation defined."
msgstr ""
"B<tmpnam>()  関数は最大 B<TMP_MAX> 回まで、呼び出される度に異なる文字列を作成"
"する。 B<TMP_MAX> 回以上呼び出された場合、その動作は実装依存である。"

#. type: Plain text
#: build/C/man3/tmpnam.3:163
msgid ""
"Although these functions generate names that are difficult to guess, it is "
"nevertheless possible that between the time that the pathname is returned "
"and the time that the program opens it, another program might create that "
"pathname using B<open>(2), or create it as a symbolic link.  This can lead "
"to security holes.  To avoid such possibilities, use the B<open>(2)  "
"B<O_EXCL> flag to open the pathname.  Or better yet, use B<mkstemp>(3)  or "
"B<tmpfile>(3)."
msgstr "これらの関数は推測が難しい名前を生成するが、それにもかかわらず、パス名が返されてから、プログラムがそのファイルをオープンするまでの間に、別のプログラムが同じパス名で、ファイルを B<open>(2)  で作成したり、シンボリックリンクを作成したりする可能性がある。 これはセキュリティホールにつながる可能性がある。 そのような可能性を回避するためには、 B<open>(2)  の B<O_EXCL> フラグを使ってパス名をオープンすればよい。 もっといいのは、 B<mkstemp>(3)  や B<tmpfile>(3)  を使うことである。"

#. type: Plain text
#: build/C/man3/tmpnam.3:171
msgid ""
"Portable applications that use threads cannot call B<tmpnam>()  with a NULL "
"argument if either B<_POSIX_THREADS> or B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""
"移植性が必要な、スレッドを使ったアプリケーションでは、 B<_POSIX_THREADS> か "
"B<_POSIX_THREAD_SAFE_FUNCTIONS> が定義されている場合に、 B<tmpnam>()  関数を "
"NULL 引数で呼び出してはならない。"

#. type: Plain text
#: build/C/man3/tmpnam.3:178
msgid ""
"Never use these functions.  Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr "決してこれらの関数を使用しないこと。代わりに B<mkstemp>(3)  か B<tmpfile>(3) を使うこと。"

#. type: Plain text
#: build/C/man3/tmpnam.3:183
msgid "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"
msgstr "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"

#. type: TH
#: build/C/man2/unlink.2:33
#, no-wrap
msgid "UNLINK"
msgstr "UNLINK"

#. type: Plain text
#: build/C/man2/unlink.2:36
msgid "unlink, unlinkat - delete a name and possibly the file it refers to"
msgstr ""
"unlink, unlinkat - 名前を削除し、場合によってはそれが参照しているファイルも削"
"除する"

#. type: Plain text
#: build/C/man2/unlink.2:41
#, no-wrap
msgid "B<int unlink(const char *>I<pathname>B<);>\n"
msgstr "B<int unlink(const char *>I<pathname>B<);>\n"

#. type: Plain text
#: build/C/man2/unlink.2:46
#, no-wrap
msgid "B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"
msgstr "B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/unlink.2:54
msgid "B<unlinkat>():"
msgstr "B<unlinkat>():"

#. type: Plain text
#: build/C/man2/unlink.2:72
msgid ""
"B<unlink>()  deletes a name from the filesystem.  If that name was the last "
"link to a file and no processes have the file open, the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""
"B<unlink>()  はファイルシステム上の名前を削除する。 もしその名前がファイルへ"
"の最後のリンク (link) であり、 どのプロセスもそのファイルをオープン (open) し"
"ていなければ、 ファイルは削除される。 ファイルが使用していたディスク上の領域"
"は再利用が可能になる。"

#. type: Plain text
#: build/C/man2/unlink.2:76
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"名前がファイルへの最後のリンクであっても、どこかのプロセスが そのファイルを開"
"いているなら、ファイルの最後のファイルディスクリプター (file descriptor) が閉"
"じられるまでファイルは存在し続ける。"

#. type: Plain text
#: build/C/man2/unlink.2:82
msgid ""
"If the name referred to a socket, FIFO, or device, the name for it is "
"removed but processes which have the object open may continue to use it."
msgstr ""
"名前が指しているのがソケット、FIFO、デバイスの場合、名前は削除されるが、 その"
"ソケットなどを開いているプロセスはそのまま使い続けることができる。"

#. type: SS
#: build/C/man2/unlink.2:82
#, no-wrap
msgid "unlinkat()"
msgstr "unlinkat()"

#. type: Plain text
#: build/C/man2/unlink.2:95
msgid ""
"The B<unlinkat>()  system call operates in exactly the same way as either "
"B<unlink>()  or B<rmdir>(2)  (depending on whether or not I<flags> includes "
"the B<AT_REMOVEDIR> flag)  except for the differences described here."
msgstr ""
"B<unlinkat>() システムコールは、B<unlink>() と B<rmdir>(2) のいずれかと全く同"
"じ動作をする (どちらと同じになるかは I<flags> に B<AT_REMOVEDIR> フラグが指定"
"されたかにより決まる) が、以下で説明する点が異なる。"

#. type: Plain text
#: build/C/man2/unlink.2:107
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
"pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<unlink>() や B<rmdir>(2) に相対パス名を渡した場合のように、呼び出したプロ"
"セスのカレントワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/unlink.2:121
msgid ""
"If the pathname given in I<pathname> is relative and I<dirfd> is the special "
"value B<AT_FDCWD>, then I<pathname> is interpreted relative to the current "
"working directory of the calling process (like B<unlink>()  and B<rmdir>(2))."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<unlink>() や B<rmdir>(2) と同様に) I<pathname> は呼び出したプロセ"
"スのカレントワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/unlink.2:127
msgid ""
"If the pathname given in I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""
"I<pathname> で指定されたパス名が絶対パスの場合、 I<dirfd> は無視される。"

#. type: Plain text
#: build/C/man2/unlink.2:133
msgid ""
"I<flags> is a bit mask that can either be specified as 0, or by ORing "
"together flag values that control the operation of B<unlinkat>().  "
"Currently, only one such flag is defined:"
msgstr ""
"I<flags> はビットマスクで、0 もしくは B<unlinkat>() の動作を制御するフラグ値"
"を論理和の形で指定することができる。現在のところ、定義されているフラグはひと"
"つだけである。"

#. type: TP
#: build/C/man2/unlink.2:133
#, no-wrap
msgid "B<AT_REMOVEDIR>"
msgstr "B<AT_REMOVEDIR>"

#. type: Plain text
#: build/C/man2/unlink.2:148
msgid ""
"By default, B<unlinkat>()  performs the equivalent of B<unlink>()  on "
"I<pathname>.  If the B<AT_REMOVEDIR> flag is specified, then performs the "
"equivalent of B<rmdir>(2)  on I<pathname>."
msgstr ""
"デフォルトでは、 B<unlinkat>() は I<pathname> に対して B<unlink>() と等価な動"
"作をする。 B<AT_REMOVEDIR> フラグが指定された場合、 I<pathname> に対して "
"B<rmdir>(2) と等価な動作をする。"

#. type: Plain text
#: build/C/man2/unlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<unlinkat>()."
msgstr "B<unlinkat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/unlink.2:169
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""
"I<pathname> を含んでいるディレクトリの書き込み許可がプロセスの実効 "
"(effective)  ユーザー ID に与えられていないか、 I<pathname> の中のディレクト"
"リのどれかに検索許可が与えられていない (B<path_resolution>(7)  も参照するこ"
"と)。"

#. type: Plain text
#: build/C/man2/unlink.2:178
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""
"システムか別のプロセスがそのファイルを使用中のため、\n"
"ファイル I<pathname> を unlink できない。\n"
"例えば、そのファイルがマウントポイントの場合や、\n"
"NFS クライアントソフトウェアがそのファイルがアクティブであるが\n"
"名前なし inode (nameless inode) であることを示すために作成した\n"
"場合 (\"NFS silly renamed\") などがある。"

#. type: Plain text
#: build/C/man2/unlink.2:190
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""
"I<pathname> がディレクトリを参照している。 (これは POSIX で規定されていない値"
"で、Linux 2.1.132 以降で返される。)"

#. type: Plain text
#: build/C/man2/unlink.2:194
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr "I<pathname> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/unlink.2:204
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""
"I<pathname> に対応するものが存在しないか、壊れたシンボリックリンクであるか、 "
"I<pathname> が空である。"

#. type: Plain text
#: build/C/man2/unlink.2:212
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "I<pathname> のディレクトリ部分が、実際には、ディレクトリでない。"

#. type: Plain text
#: build/C/man2/unlink.2:221
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""
"システムがディレクトリに対する unlink 操作を許可していない。 またはディレクト"
"リに対する unlink 操作のために必要な特権を 呼び出し元のプロセスが持っていな"
"い。 (これは POSIX で規定されているエラーの返し方である。 上述の通り、この場"
"合には Linux は B<EISDIR> を返す。)"

#. type: TP
#: build/C/man2/unlink.2:221
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr "B<EPERM> (Linux のみ)"

#. type: Plain text
#: build/C/man2/unlink.2:224
msgid "The filesystem does not allow unlinking of files."
msgstr "ファイルシステムがファイルに対する unlink 操作を許していない。"

#. type: Plain text
#: build/C/man2/unlink.2:235
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"I<pathname> を含んでいるディレクトリにスティッキービット (sticky-bit)  "
"(B<S_ISVTX>)  が設定されていて、プロセスの実効ユーザー ID が削除しようとする"
"ファイルの UID でもそれを含んでいるディレクトリのものでもなく、 かつプロセス"
"に特権がない (Linux では B<CAP_FOWNER> ケーパビリティ (capability) がない)。"

#. type: Plain text
#: build/C/man2/unlink.2:240
msgid ""
"The file to be unlinked is marked immutable or append-only.  (See "
"B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:244
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr "I<pathname> が読み込み専用のファイルシステムのファイルを参照している。"

#. type: Plain text
#: build/C/man2/unlink.2:253
msgid ""
"The same errors that occur for B<unlink>()  and B<rmdir>(2)  can also occur "
"for B<unlinkat>().  The following additional errors can occur for "
"B<unlinkat>():"
msgstr ""
"B<unlink>() と B<rmdir>(2) で発生するのと同じエラーが B<unlinkat>() でも起こ"
"る。 B<unlinkat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/unlink.2:268
msgid ""
"I<pathname> refers to a directory, and B<AT_REMOVEDIR> was not specified in "
"I<flags>."
msgstr ""
"I<pathname> がディレクトリを参照していて、 I<flags> に B<AT_REMOVEDIR> がされ"
"ていなかった。"

#. type: Plain text
#: build/C/man2/unlink.2:278
msgid ""
"B<unlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<unlinkat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#.  SVr4 documents additional error
#.  conditions EINTR, EMULTIHOP, ETXTBSY, ENOLINK.
#. type: Plain text
#: build/C/man2/unlink.2:283
msgid "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/unlink.2:286
msgid "B<unlinkat>(): POSIX.1-2008."
msgstr "B<unlinkat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/unlink.2:302
msgid ""
"On older kernels where B<unlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<unlink>()  or B<rmdir>(2).  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr "B<unlinkat>() が利用できない古いカーネルでは、 glibc ラッパー関数は B<unlink>() と B<rmdir>(2) を使用するモードにフォールバックする。 I<pathname> が相対パスの場合、 glibc は I<dirfd> 引数に対応する I</proc/self/fd> のシンボリックリンクに基づいてパス名を構成する。"

#. type: Plain text
#: build/C/man2/unlink.2:318
msgid ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr "B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man3/unlocked_stdio.3:25
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr "UNLOCKED_STDIO"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:29
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - ロックを行"
"わずに標準入出力を行う関数群"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:37
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:49
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:52
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:63
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:75
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:79
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:90
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:93
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:104
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:115
msgid ""
"Each of these functions has the same behavior as its counterpart without the "
"\"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""
"これらの関数は、末尾に \"_unlocked\" がついていない関数と同じ動作をするが、 "
"ファイルのロックを使用しない点が異なる。(これらの関数自身はファイルのロック "
"をセットせず、他の関数によってロックがセットされているかどうかのチェックも 行"
"わない) それゆえ、スレッド(thread)で安全に使用することができない。 "
"B<flockfile>(3)  を参照のこと。"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:141
#, no-wrap
msgid ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"
msgstr ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:145
#, no-wrap
msgid ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"
msgstr ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:145
#, no-wrap
msgid "MT-Unsafe race:stdin"
msgstr "MT-Unsafe race:stdin"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:149
#, no-wrap
msgid ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"
msgstr ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:149
#, no-wrap
msgid "MT-Unsafe race:stdout"
msgstr "MT-Unsafe race:stdout"

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:154
#, no-wrap
msgid ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"
msgstr ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:164
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001 and "
"POSIX.1-2008."
msgstr "B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), B<putchar_unlocked>()  の 4 つの関数は POSIX.1-2001 と POSIX.1-2008 に規定されている。"

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: build/C/man3/unlocked_stdio.3:180
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""
"非標準の B<*_unlocked>()  の仲間は 2、3 の UNIX システムで定義されており、 最"
"近の glibc では使用可能であるが、 これらの関数は使わない方がよいだろう。"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:183
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr "B<flockfile>(3), B<stdio>(3)"

#. type: TH
#: build/C/man3/wprintf.3:16
#, no-wrap
msgid "WPRINTF"
msgstr "WPRINTF"

#. type: Plain text
#: build/C/man3/wprintf.3:20
msgid ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - formatted wide-"
"character output conversion"
msgstr ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - ワイド文字を "
"フォーマットして出力する"

#. type: Plain text
#: build/C/man3/wprintf.3:29
#, no-wrap
msgid ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"
msgstr ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"

#. type: Plain text
#: build/C/man3/wprintf.3:34
#, no-wrap
msgid ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
msgstr ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"

#.  .BR wprintf (),
#.  .BR fwprintf (),
#.  .BR swprintf (),
#.  .BR vwprintf (),
#.  .BR vfwprintf (),
#.  .BR vswprintf ():
#. type: Plain text
#: build/C/man3/wprintf.3:51
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"

#. type: Plain text
#: build/C/man3/wprintf.3:53
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/wprintf.3:64
msgid ""
"The B<wprintf>()  family of functions is the wide-character equivalent of "
"the B<printf>(3)  family of functions.  It performs formatted output of wide "
"characters."
msgstr ""
"B<wprintf>()  ファミリーの関数は B<printf>(3)  ファミリーの関数の ワイド文字"
"版である。これらはワイド文字をフォーマットして出力する。"

#. type: Plain text
#: build/C/man3/wprintf.3:76
msgid ""
"The B<wprintf>()  and B<vwprintf>()  functions perform wide-character output "
"to I<stdout>.  I<stdout> must not be byte oriented; see B<fwide>(3)  for "
"more information."
msgstr ""
"B<wprintf>()  と B<vwprintf>()  関数は I<stdout> に出力を行なう。 I<stdout> "
"がバイト単位入出力であってはいけない。より詳しい説明は B<fwide>(3)  を参照す"
"ること。"

#. type: Plain text
#: build/C/man3/wprintf.3:88
msgid ""
"The B<fwprintf>()  and B<vfwprintf>()  functions perform wide-character "
"output to I<stream>.  I<stream> must not be byte oriented; see B<fwide>(3)  "
"for more information."
msgstr ""
"B<fwprintf>()  と B<vfwprintf>()  関数は I<stream> にワイド文字出力 を行な"
"う。 I<stream> がバイト単位入出力であってはいけない。 より詳しい説明は "
"B<fwide>(3)  を参照すること。"

#. type: Plain text
#: build/C/man3/wprintf.3:102
msgid ""
"The B<swprintf>()  and B<vswprintf>()  functions perform wide-character "
"output to an array of wide characters.  The programmer must ensure that "
"there is room for at least I<maxlen> wide characters at I<wcs>."
msgstr ""
"B<swprintf>()  と B<vswprintf>()  関数はワイド文字の配列に ワイド文字出力を行"
"なう。プログラマーは I<wcs> に最低でも I<maxlen> 文字のワイド文字を出力できる"
"空きがあることを保証しなければ ならない。"

#. type: Plain text
#: build/C/man3/wprintf.3:113
msgid ""
"These functions are like the B<printf>(3), B<vprintf>(3), B<fprintf>(3), "
"B<vfprintf>(3), B<sprintf>(3), B<vsprintf>(3)  functions except for the "
"following differences:"
msgstr ""
"これらの関数は B<printf>(3), B<vprintf>(3), B<fprintf>(3), B<vfprintf>(3), "
"B<sprintf>(3), B<vsprintf>(3)  関数に似ているが以下の 点で異っている。"

#. type: TP
#: build/C/man3/wprintf.3:113 build/C/man3/wprintf.3:118
#: build/C/man3/wprintf.3:121
#, no-wrap
msgid "B<\\(bu>"
msgstr "B<\\(bu>"

#. type: Plain text
#: build/C/man3/wprintf.3:118
msgid "The I<format> string is a wide-character string."
msgstr "I<format> がワイド文字列で与えられる。"

#. type: Plain text
#: build/C/man3/wprintf.3:121
msgid "The output consists of wide characters, not bytes."
msgstr "出力がバイトではなくワイド文字で構成される。"

#. type: Plain text
#: build/C/man3/wprintf.3:140
msgid ""
"B<swprintf>()  and B<vswprintf>()  take a I<maxlen> argument, B<sprintf>(3)  "
"and B<vsprintf>(3)  do not.  (B<snprintf>(3)  and B<vsnprintf>(3)  take a "
"I<maxlen> argument, but these functions do not return -1 upon buffer "
"overflow on Linux.)"
msgstr ""
"B<swprintf>()  と B<vswprintf>()  は I<maxlen> 引数を取るが、 "
"B<sprintf>()  と B<vsprintf>()  は取らない (B<snprintf>()  と "
"B<vsnprintf>()  は I<maxlen> 引数を取るが これらの関数が Linux では、バッ"
"ファーが溢れた場合でも -1 を返さない)。"

#. type: Plain text
#: build/C/man3/wprintf.3:146
msgid "The treatment of the conversion characters B<c> and B<s> is different:"
msgstr "B<c> と B<s> 変換文字の扱いが異っている:"

#. type: Plain text
#: build/C/man3/wprintf.3:160
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to a wide "
"character by a call to the B<btowc>(3)  function, and the resulting wide "
"character is written.  If an B<l> modifier is present, the I<wint_t> (wide "
"character) argument is written."
msgstr ""
"もし B<l> 修飾子が存在しない場合は I<int> 引数は B<btowc>(3)  関数によって"
"ワイド文字に変換される。そして結果のワイド文字が出力される。 B<l> 修飾子が存"
"在する場合は I<wint_t> (ワイド文字)引数が出力される。"

#. type: Plain text
#: build/C/man3/wprintf.3:200
msgid ""
"If no B<l> modifier is present: the I<const\\ char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string) "
"containing a multibyte character sequence beginning in the initial shift "
"state.  Characters from the array are converted to wide characters (each by "
"a call to the B<mbrtowc>(3)  function with a conversion state starting in "
"the initial state before the first byte).  The resulting wide characters are "
"written up to (but not including) the terminating null wide character (L\\(aq"
"\\e0\\(aq).  If a precision is specified, no more wide characters than the "
"number specified are written.  Note that the precision determines the number "
"of I<wide characters> written, not the number of I<bytes> or I<screen "
"positions>.  The array must contain a terminating null byte (\\(aq"
"\\e0\\(aq), unless a precision is given and it is so small that the number "
"of converted wide characters reaches it before the end of the array is "
"reached.  If an B<l> modifier is present: the I<const\\ wchar_t\\ *> "
"argument is expected to be a pointer to an array of wide characters.  Wide "
"characters from the array are written up to (but not including) a "
"terminating null wide character.  If a precision is specified, no more than "
"the number specified are written.  The array must contain a terminating null "
"wide character, unless a precision is given and it is smaller than or equal "
"to the number of wide characters in the array."
msgstr ""
"もし B<l> 修飾子が存在しない場合、 I<const\\ char\\ *> 引数は初期状態より始"
"まるマルチバイト文字列を含んだ char 型の配列へのポインター(文字列へのポイン"
"ター)とみなされる。 配列の文字は(最初のバイト前に初期状態で変換を開始し、それ"
"ぞれの文字を B<mbrtowc>(3)  関数によって)ワイド文字へと変換される。結果のワイ"
"ド文字は終端の ナルワイド文字 (L\\(aq\\e0\\(aq) の手前までが書き込まれる。精"
"度(precision)が指定された 場合、指定された数字を超えるワイド文字は書き込まれ"
"ない。精度は 書き込まれる I<バイト> 数や I<画面上の位置> ではなく I<ワイド文"
"字> の数を指定することに注意すること。 精度がない場合には配列の終端にナルバイ"
"ト (\\(aq\\e0\\(aq) を含む必要がある。 精度を指定する場合には、配列の最後に到"
"着する前に変換されたワイド文字の 数がそれに到達するよう、精度は十分に小さな数"
"でなければならない。 もし B<l> 修飾子が存在する場合、 I<const\\ wchar_t\\ *> "
"引数はワイド文字の配列へのポインターとみなされる。 配列のワイド文字列は終端"
"のナルワイド文字の手間まで出力される。 もし精度が指定された場合には指定された"
"精度以上の文字は出力されない。 精度を指定しない場合には終端のナルワイド文字を"
"含む必要がある。 精度を指定する場合にはそれはワイド文字の配列の大きさよりも小"
"さくな ければならない。"

#. type: Plain text
#: build/C/man3/wprintf.3:208
msgid ""
"The functions return the number of wide characters written, excluding the "
"terminating null wide character in case of the functions B<swprintf>()  and "
"B<vswprintf>().  They return -1 when an error occurs."
msgstr ""
"これらの関数は書き込まれたワイド文字の文字数を返す。 B<swprintf>()  と "
"B<vswprintf>()  関数の場合は 終端のナルワイド文字は含まない。エラーが起こった"
"場合は -1 を返す。"

#. type: tbl table
#: build/C/man3/wprintf.3:219
#, no-wrap
msgid ""
"B<wprintf>(),\n"
"B<fwprintf>(),\n"
msgstr ""
"B<wprintf>(),\n"
"B<fwprintf>(),\n"

#. type: tbl table
#: build/C/man3/wprintf.3:222
#, no-wrap
msgid ""
"B<swprintf>(),\n"
"B<vwprintf>(),\n"
msgstr ""
"B<swprintf>(),\n"
"B<vwprintf>(),\n"

#. type: tbl table
#: build/C/man3/wprintf.3:225
#, no-wrap
msgid ""
"B<vfwprintf>(),\n"
"B<vswprintf>()"
msgstr ""
"B<vfwprintf>(),\n"
"B<vswprintf>()"

#. type: Plain text
#: build/C/man3/wprintf.3:238
msgid ""
"The behavior of B<wprintf>()  et al. depends on the B<LC_CTYPE> category of "
"the current locale."
msgstr ""
"B<wprintf>()  等の動作は現在のロケールの B<LC_CTYPE> カテゴリーに依存してい"
"る。"

#. type: Plain text
#: build/C/man3/wprintf.3:268
msgid ""
"If the I<format> string contains non-ASCII wide characters, the program will "
"work correctly only if the B<LC_CTYPE> category of the current locale at run "
"time is the same as the B<LC_CTYPE> category of the current locale at "
"compile time.  This is because the I<wchar_t> representation is platform- "
"and locale-dependent.  (The glibc represents wide characters using their "
"Unicode (ISO-10646) code point, but other platforms don't do this.  Also, "
"the use of C99 universal character names of the form \\eunnnn does not solve "
"this problem.)  Therefore, in internationalized programs, the I<format> "
"string should consist of ASCII wide characters only, or should be "
"constructed at run time in an internationalized way (e.g., using "
"B<gettext>(3)  or B<iconv>(3), followed by B<mbstowcs>(3))."
msgstr ""
"I<format> 文字列が ASCII 以外のワイド文字を含んでいる場合、 実行時のロケール"
"の B<LC_CTYPE> カテゴリーがコンパイル時の B<LC_CTYPE> カテゴリーと 一致してい"
"る場合にのみプログラムは正常に動作する。これは I<wchar_t> の表現がロケールや"
"プラットホームに依存していることに原因がある。 (glibc ではワイド文字として "
"Unicode (ISO-10646) のコードポイントを 使用している。他のプラットホームではそ"
"うではない。同様に ISO C99 の \\eunnnn 形式の汎用文字名称はこの問題を解決しな"
"い。)  このため国際化されたプログラムでは I<format> 文字列を ASCII ワイド 文"
"字のみにするか、実行時に国際化された方法で構成する必要がある (例えば "
"B<gettext>()  と B<iconv>()  や B<mbstowcs>()  を組み合わて使用する)。"

#.  .BR wscanf (3)
#. type: Plain text
#: build/C/man3/wprintf.3:275
msgid "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"
msgstr "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "WRITE"
msgstr "WRITE"

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "2019-10-10"
msgstr "2019-10-10"

#. type: Plain text
#: build/C/man2/write.2:42
msgid "write - write to a file descriptor"
msgstr "write - ファイルディスクリプター (file descriptor) に書き込む"

#. type: Plain text
#: build/C/man2/write.2:46
msgid ""
"B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"
msgstr ""
"B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"

#. type: Plain text
#: build/C/man2/write.2:54
msgid ""
"B<write>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file referred to by the file descriptor I<fd>."
msgstr "B<write>()  は、 I<buf> から始まるバッファーから、ファイルディスクリプター I<fd> が参照するファイルへ、最大 I<count> バイトを書き込む。"

#. type: Plain text
#: build/C/man2/write.2:68
msgid ""
"The number of bytes written may be less than I<count> if, for example, there "
"is insufficient space on the underlying physical medium, or the "
"B<RLIMIT_FSIZE> resource limit is encountered (see B<setrlimit>(2)), or the "
"call was interrupted by a signal handler after having written less than "
"I<count> bytes.  (See also B<pipe>(7).)"
msgstr ""
"書き込まれるバイト数は I<count> よりも小さくなることがある。 例えば、書き込み"
"対象の物理メディアに十分な領域がない場合、 リソース上限 B<RLIMIT_FSIZE> に達"
"した場合 (B<setrlimit>(2)  参照)、 I<count> バイト未満の書き込みが行われた後"
"で 呼び出しがシグナルハンドラーにより割り込まれた場合、 などである。 "
"(B<pipe>(7)  も参照のこと。)"

#. type: Plain text
#: build/C/man2/write.2:82
msgid ""
"For a seekable file (i.e., one to which B<lseek>(2)  may be applied, for "
"example, a regular file)  writing takes place at the file offset, and the "
"file offset is incremented by the number of bytes actually written.  If the "
"file was B<open>(2)ed with B<O_APPEND>, the file offset is first set to the "
"end of the file before writing.  The adjustment of the file offset and the "
"write operation are performed as an atomic step."
msgstr "seek 可能なファイル (つまり B<lseek>(2)  が適用できるファイル、例えば通常のファイル) では、 書き込みはファイルオフセットから行われ、 ファイルオフセットは実際に書き込みが行われたバイト数分 加算される。ファイルが B<O_APPEND> で B<open>(2)  された場合、ファイルオフセットは書き込み前に ファイルの末尾に設定される。 ファイルオフセットの調整と書き込み操作はアトミックな処理として 実行される。"

#. type: Plain text
#: build/C/man2/write.2:89
msgid ""
"POSIX requires that a B<read>(2)  that can be proved to occur after a "
"B<write>()  has returned will return the new data.  Note that not all "
"filesystems are POSIX conforming."
msgstr ""
"POSIX は B<write>()  が行なわれた後に実行した B<read>(2)  が 新しいデータを返"
"すことを要求している。 全てのファイルシステムが POSIX 準拠ではない点に注意す"
"ること。"

#. type: Plain text
#: build/C/man2/write.2:100
msgid ""
"On success, the number of bytes written is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the cause of the error."
msgstr "成功すると、書き込まれたバイト数が返される。エラーの場合、 -1 が返り、 I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man2/write.2:118
msgid ""
"Note that a successful B<write>()  may transfer fewer than I<count> bytes.  "
"Such partial writes can occur for various reasons; for example, because "
"there was insufficient space on the disk device to write all of the "
"requested bytes, or because a blocked B<write>()  to a socket, pipe, or "
"similar was interrupted by a signal handler after it had transferred some, "
"but before it had transferred all of the requested bytes.  In the event of a "
"partial write, the caller can make another B<write>()  call to transfer the "
"remaining bytes.  The subsequent call will either transfer further bytes or "
"may result in an error (e.g., if the disk is now full)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:131
msgid ""
"If I<count> is zero and I<fd> refers to a regular file, then B<write>()  may "
"return a failure status if one of the errors below is detected.  If no "
"errors are detected, or error detection is not performed, 0 will be returned "
"without causing any other effect.  If I<count> is zero and I<fd> refers to a "
"file other than a regular file, the results are not specified."
msgstr "I<count> が 0 で、 I<fd> が通常のファイル (regular file) を参照している場合、 B<write>()  は後述のエラーのいずれかを検出した場合、失敗を返すことがある。 エラーが検出されなかった場合、もしくはエラー検出が実行されなかった場合、 0 が返され、他に何の影響も与えない。 I<count> が 0 で、 I<fd> が通常のファイル以外のファイルを参照している場合、 その結果は規定されていない。"

#. type: Plain text
#: build/C/man2/write.2:144
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the write would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr "ファイルディスクリプター I<fd> がソケット以外のファイルを参照していて、 非停止 (nonblocking) モード (B<O_NONBLOCK>)  に設定されており、書き込みを行うと停止する状況にある。 B<O_NONBLOCK> フラグの詳細は B<open>(2) を参照。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/write.2:155
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the write would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"ファイルディスクリプター I<fd> がソケットを参照していて、非停止 "
"(nonblocking) モード (B<O_NONBLOCK>)  に設定されており、書き込みを行うと停止"
"する状況にある。 POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めて"
"おり、 これら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性"
"が必要なアプリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/write.2:159
msgid "I<fd> is not a valid file descriptor or is not open for writing."
msgstr ""
"I<fd> が有効なファイルディスクリプターでないか書き込みのためにオープン "
"(open) されていない。"

#. type: TP
#: build/C/man2/write.2:159
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: build/C/man2/write.2:164
msgid ""
"I<fd> refers to a datagram socket for which a peer address has not been set "
"using B<connect>(2)."
msgstr ""
"I<fd> が、 B<connect>(2)  を使って通信相手のアドレスが設定されていないデータ"
"グラムソケットを 参照している。"

#. type: Plain text
#: build/C/man2/write.2:170
msgid ""
"The user's quota of disk blocks on the filesystem containing the file "
"referred to by I<fd> has been exhausted."
msgstr ""
"I<fd> が参照するファイルを含むファイルシステムのディスクブロックのユーザー"
"クォータの上限に達している。"

#. type: Plain text
#: build/C/man2/write.2:179
msgid ""
"An attempt was made to write a file that exceeds the implementation-defined "
"maximum file size or the process's file size limit, or to write at a "
"position past the maximum allowed offset."
msgstr ""
"実装定義の最大ファイルサイズまたはプロセスのファイルサイズ制限を 超えてファイ"
"ルに書き込もうとした。 または許可されたオフセット値の限界を超えた先の位置に "
"書き込もうとした。"

#. type: Plain text
#: build/C/man2/write.2:183
msgid ""
"The call was interrupted by a signal before any data was written; see "
"B<signal>(7)."
msgstr ""
"何のデータも書かない間にシグナルにより割り込まれた (interrupt)。 "
"B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/write.2:194
msgid ""
"I<fd> is attached to an object which is unsuitable for writing; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr "I<fd> が書き込みが不適切なオブジェクトを参照している。 もしくは、ファイルが B<O_DIRECT> フラグを指定してオープンされているが、 I<buf> に指定されたアドレス、 I<count> に指定された値、 ファイルオフセットのいずれかのアラインメントが不適切である。"

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: build/C/man2/write.2:222
msgid ""
"A low-level I/O error occurred while modifying the inode.  This error may "
"relate to the write-back of data written by an earlier B<write>(), which may "
"have been issued to a different file descriptor on the same file.  Since "
"Linux 4.13, errors from write-back come with a promise that they I<may> be "
"reported by subsequent.  B<write>()  requests, and I<will> be reported by a "
"subsequent B<fsync>(2)  (whether or not they were also reported by "
"B<write>()).  An alternate cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:227
msgid ""
"The device containing the file referred to by I<fd> has no room for the data."
msgstr ""
"I<fd> によって参照されるファイルを含むデバイス (device) に十分な空きがない。"

#. type: TP
#: build/C/man2/write.2:231
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man2/write.2:240
msgid ""
"I<fd> is connected to a pipe or socket whose reading end is closed.  When "
"this happens the writing process will also receive a B<SIGPIPE> signal.  "
"(Thus, the write return value is seen only if the program catches, blocks or "
"ignores this signal.)"
msgstr ""
"I<fd> がパイプ (pipe) かソケット (socket) に接続されており、 その反対側 (読み"
"込み側) がクローズ (close) されている。 これが発生した場合には、書き込みを行"
"なうプロセスは B<SIGPIPE> シグナル (signal)も受ける。 (したがって、プログラム"
"がこのシグナルを捕獲 (catch)、停止 (block)、無視 (ignore)  した場合のみ、"
"write の返り値を参照できる。)"

#. type: Plain text
#: build/C/man2/write.2:252
msgid ""
"Under SVr4 a write may be interrupted and return B<EINTR> at any point, not "
"just before any data is written."
msgstr ""
"SVr4 では write が割り込まれると、データが書き込まれる直前ではなく、 その時点"
"で B<EINTR> が返る。"

#. type: Plain text
#: build/C/man2/write.2:274
#, fuzzy
#| msgid ""
#| "A successful return from B<write>()  does not make any guarantee that "
#| "data has been committed to disk.  In fact, on some buggy implementations, "
#| "it does not even guarantee that space has successfully been reserved for "
#| "the data.  The only way to be sure is to call B<fsync>(2)  after you are "
#| "done writing all your data."
msgid ""
"A successful return from B<write>()  does not make any guarantee that data "
"has been committed to disk.  On some filesystems, including NFS, it does not "
"even guarantee that space has successfully been reserved for the data.  In "
"this case, some errors might be delayed until a future B<write>(), "
"B<fsync>(2), or even B<close>(2).  The only way to be sure is to call "
"B<fsync>(2)  after you are done writing all your data."
msgstr ""
"B<write>()  が成功して返ってきても、データがディスクに記録されたことを 保証す"
"るものではない。 実際、データのためのスペースが確保されたことすら保証されない"
"という バグっぽい実装もある。 これを確実にする唯一の方法は、 全てのデータを "
"write した後に B<fsync>(2)  を呼び出すことである。"

#. type: Plain text
#: build/C/man2/write.2:282
msgid ""
"If a B<write>()  is interrupted by a signal handler before any bytes are "
"written, then the call fails with the error B<EINTR>; if it is interrupted "
"after at least one byte has been written, the call succeeds, and returns the "
"number of bytes written."
msgstr ""
"B<write>()  が 1 バイトも書き込まないうちにシグナルハンドラーにより割り込まれ"
"た場合、 B<write>()  はエラー B<EINTR> で失敗する。 1バイトでも書き込んだ後で"
"割り込まれた場合には、 B<write>()  は成功し、書き込んだバイト数を返す。"

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: build/C/man2/write.2:290
msgid ""
"On Linux, B<write>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:298
msgid ""
"An error return value while performing B<write>()  using direct I/O does not "
"mean the entire write has failed. Partial data may be written and the data "
"at the file offset on which the B<write>()  was attempted should be "
"considered inconsistent."
msgstr ""

#
#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: build/C/man2/write.2:337
msgid ""
"Among the APIs subsequently listed are B<write>()  and B<writev>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<write>()  (or B<writev>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the blocks of data output by the two processes might "
"(incorrectly) overlap.  This problem was fixed in Linux 3.14."
msgstr ""
"この後に書かれている API の中に B<write>() と B<writev>(2) である。 スレッド"
"（やプロセス) 間でアトミックに適用することが求められる効果の一つとして、 ファ"
"イルオフセットの更新がある。 しかしながら、 バージョン 3.14 より前の Linux で"
"は、 この限りではない。 オープンファイル記述 (open file description) を共有す"
"る 2 つのプロセスが同時に B<write>() (や B<writev>(2)) を実行した場合、 この "
"I/O 操作ではファイルオフセットの更新に関してはアトミックではなく、 2 つのプロ"
"セスから出力されるデータブロックが (間違って) 重なる可能性がある。 この問題"
"は Linux 3.14 で修正された。"

#. type: Plain text
#: build/C/man2/write.2:349
msgid ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid ""
#~ "The B<ctermid>()  function is thread-safe with exceptions.  It is not "
#~ "thread-safe if called with a NULL parameter."
#~ msgstr ""
#~ "B<ctermid>() 関数は例外付きでスレッドセーフである。 NULL パラメーターで呼"
#~ "び出された場合はスレッドセーフではない。"

#~ msgid "dprintf, vdprintf - print to a file descriptor"
#~ msgstr "dprintf, vdprintf - ファイルディスクリプターに文字出力する"

#~ msgid ""
#~ "These functions are GNU extensions that are nowadays specified in "
#~ "POSIX.1-2008."
#~ msgstr ""
#~ "これらの関数は GNU による拡張であり、 現在では POSIX.1-2008 で規定されてい"
#~ "る。"

#~ msgid ""
#~ "The function B<fileno>()  examines the argument I<stream> and returns its "
#~ "integer descriptor."
#~ msgstr ""
#~ "関数 B<fileno>()  は、引数 I<stream> を調べ、その整数のディスクリプターを"
#~ "返す。"

#~ msgid ""
#~ "The B<clearerr>(), B<feof>(), B<ferror>(), and B<fileno>()  functions are "
#~ "thread-safe."
#~ msgstr ""
#~ "関数 B<clearerr>(), B<feof>(), B<ferror>(), B<fileno>() はスレッドセーフで"
#~ "ある。"

#~ msgid "The B<fflush>()  function is thread-safe."
#~ msgstr "関数 B<fflush>() はスレッドセーフである。"

#~ msgid "AVAILABILITY"
#~ msgstr "可用性"

#~ msgid ""
#~ "Alternatively, the caller can explicitly set I<buf> as the stdio stream "
#~ "buffer, at the same time informing stdio of the buffer's size, using:"
#~ msgstr ""
#~ "別の方法としては、 以下のように、 呼び出し側が明示的に stdio ストリーム"
#~ "バッファーとして I<buf> を指定し、バッファーの指定時にバッファーのサイズ"
#~ "を stdio に教える方法がある。"

#~ msgid ""
#~ "The B<fopen>()  and B<freopen>()  functions conform to C89.  The "
#~ "B<fdopen>()  function conforms to POSIX.1-1990."
#~ msgstr ""
#~ "B<fopen>()  関数と B<freopen>()  関数は C89に準拠している。 B<fdopen>()  "
#~ "関数は POSIX.1-1990 に準拠している。"

#~ msgid "The I<stream> specified is not a seekable stream."
#~ msgstr "指定した I<stream> がシークできない。"

#~ msgid "These functions are found on System V-like systems."
#~ msgstr "これらの関数は System-V 風のシステムに存在する。"

#~ msgid ""
#~ "The file referred to by I<oldpath> already has the maximum number of "
#~ "links to it."
#~ msgstr ""
#~ "I<oldpath> によって参照されるファイルは 既に最大数までのリンクを持ってい"
#~ "る。"

#~ msgid ""
#~ "When converting old code, substitute values for I<whence> with the "
#~ "following macros:"
#~ msgstr ""
#~ "古いコードを変換する時は I<whence> の値を以下のマクロに置き換えること:"

#~ msgid ""
#~ "Note that file descriptors created by B<dup>(2)  or B<fork>(2)  share the "
#~ "current file position pointer, so seeking on such files may be subject to "
#~ "race conditions."
#~ msgstr ""
#~ "B<dup>(2)  や B<fork>(2)  で作成されたファイルディスクリプターは、現在の"
#~ "ファイル位置ポインター (current file position pointer) を共有しているの"
#~ "で、 このようなファイルで移動を行うと競合状態を引き起こす可能性がある。"

#~ msgid ""
#~ "All the above functions are implemented in terms of this system call.  "
#~ "The prototype is:"
#~ msgstr ""
#~ "上記の全ての関数は、このシステムコールに基づいて実装される。 プロトタイプ"
#~ "は以下の通り:"

#~ msgid "The B<lseek64>()  function is thread-safe."
#~ msgstr "関数 B<lseek64>() はスレッドセーフである。"

#~ msgid ""
#~ "If the file does not exist, it will be created.  The owner (user ID) of "
#~ "the file is set to the effective user ID of the process.  The group "
#~ "ownership (group ID) is set either to the effective group ID of the "
#~ "process or to the group ID of the parent directory (depending on "
#~ "filesystem type and mount options, and the mode of the parent directory; "
#~ "see the mount options I<bsdgroups> and I<sysvgroups> described in "
#~ "B<mount>(8))."
#~ msgstr ""
#~ "ファイルが存在しなかった場合は作成 (create) する。 ファイルの所有者 (ユー"
#~ "ザー ID) は、プロセスの実効ユーザー ID に設定される。 グループ所有権 (グ"
#~ "ループ ID) は、プロセスの実効グループ ID または親ディレクトリのグループ "
#~ "ID に設定される (これは、ファイルシステムタイプ、マウントオプション、 親"
#~ "ディレクトリのモードに依存する。 B<mount>(8)  で説明されているマウントオプ"
#~ "ション I<bsdgroups> と I<sysvgroups> を参照)。"

#~ msgid ""
#~ "I<mode> specifies the permissions to use in case a new file is created.  "
#~ "This argument must be supplied when B<O_CREAT> or B<O_TMPFILE> is "
#~ "specified in I<flags>; if neither B<O_CREAT> nor B<O_TMPFILE> is "
#~ "specified, then I<mode> is ignored.  The effective permissions are "
#~ "modified by the process's I<umask> in the usual way: The permissions of "
#~ "the created file are I<(mode\\ &\\ ~umask)>.  Note that this mode applies "
#~ "only to future accesses of the newly created file; the B<open>()  call "
#~ "that creates a read-only file may well return a read/write file "
#~ "descriptor."
#~ msgstr ""
#~ "I<mode> は新しいファイルを作成する場合に使用するアクセス許可 (permission) "
#~ "を指定する。 I<flags> に B<O_CREAT> か B<O_TMPFILE> が指定されている場"
#~ "合、 I<mode> を指定しなければならない。 B<O_CREAT> も B<O_TMPFILE> も指定"
#~ "されていない場合、 I<mode> は無視される。 有効なアクセス許可は、普段と同じ"
#~ "ようにプロセスの I<umask> によって修正され、作成されたファイルの許可は "
#~ "I<(mode\\ &\\ ~umask)> となる。 このモードは、新しく作成されたファイルに対"
#~ "するそれ以降のアクセス にのみ適用される点に注意すること。 読み取り専用の"
#~ "ファイルを作成する B<open>()  コールであっても、 読み書き可能なファイル"
#~ "ディスクリプターを返すことがありうる。"

#~ msgid ""
#~ "If I<pathname> is a symbolic link, then the open fails.  This is a "
#~ "FreeBSD extension, which was added to Linux in version 2.1.126.  Symbolic "
#~ "links in earlier components of the pathname will still be followed.  See "
#~ "also B<O_PATH> below."
#~ msgstr ""
#~ "I<pathname> がシンボリックリンクだった場合、オープンは失敗する。 これは "
#~ "FreeBSD の拡張で、Linux には バージョン 2.1.126 で追加された。 このフラグ"
#~ "が指定された場合でも I<pathname> の前の方の要素 (最後のディレクトリセパ"
#~ "レータより前の部分) にあるシンボリックリンクについてはリンクが辿られる。 "
#~ "下記の B<O_PATH> も参照のこと。"

#~ msgid ""
#~ "B<close>(2); B<fchdir>(2)  (since Linux 3.5); B<fstat>(2)  (since Linux "
#~ "3.6)."
#~ msgstr ""
#~ "B<close>(2); B<fchdir>(2)  (Linux 3.5 以降); B<fstat>(2)  (Linux 3.6 以降)"

#~ msgid ""
#~ "B<O_CREAT> is not set and the named file does not exist.  Or, a directory "
#~ "component in I<pathname> does not exist or is a dangling symbolic link."
#~ msgstr ""
#~ "B<O_CREAT> が設定されておらず、かつ指定されたファイルが存在しない。 また"
#~ "は、 I<pathname> のディレクトリ部分が存在しないか壊れた (dangling) シンボ"
#~ "リックリンクである。"

#~ msgid ""
#~ "\"The thing that has always disturbed me about O_DIRECT is that the whole "
#~ "interface is just stupid, and was probably designed by a deranged monkey "
#~ "on some serious mind-controlling substances.\"\\(emLinus"
#~ msgstr ""
#~ "「O_DIRECT でいつも困るのは、インターフェース全部が本当にお馬鹿な点だ。 た"
#~ "ぶん危ないマインドコントロール剤で 頭がおかしくなったサルが設計したんじゃ"
#~ "ないかな」 \\(em Linus"

#~ msgid ""
#~ "To be of most use, the argument string should include the name of the "
#~ "function that incurred the error.  The error number is taken from the "
#~ "external variable I<errno>, which is set when errors occur but not "
#~ "cleared when successful calls are made."
#~ msgstr ""
#~ "このメッセージを最大限活用するためには、引数文字列にエラーが発生した 関"
#~ "数名を入れておくとよい。 エラー番号は外部変数 I<errno> から取得される。 "
#~ "I<errno> はエラーが発生した時に設定され、 成功した呼び出しではクリアされな"
#~ "い。"

#~ msgid ""
#~ "The function B<perror>()  and the external I<errno> (see B<errno>(3))  "
#~ "conform to C89, C99, 4.3BSD, POSIX.1-2001.  The externals I<sys_nerr> and "
#~ "I<sys_errlist> conform to BSD."
#~ msgstr ""
#~ "関数 B<perror>()  と外部変数 I<errno> (B<errno>(3)  参照) は C89, 4.3BSD, "
#~ "POSIX.1-2001 に準拠している。 外部変数 I<sys_nerr> と I<sys_errlist> は "
#~ "BSD に準拠している。"

#~ msgid "Too many file descriptors are in use by the process."
#~ msgstr "このプロセスで使われているファイルディスクリプターが多すぎる。"

#~ msgid ""
#~ "The B<pclose>()  function returns -1 if B<wait4>(2)  returns an error, or "
#~ "some other error is detected.  In the event of an error, these functions "
#~ "set I<errno> to indicate the cause of the error."
#~ msgstr ""
#~ "B<pclose>()  関数は、 B<wait4>(2)  がエラーを返したり、何か他のエラーが見"
#~ "つかった場合、 -1 を返す。 その場合、 I<errno> にエラーの原因を示す値が設"
#~ "定される。"

#~ msgid "or I<cc -std=c99>"
#~ msgstr "または I<cc -std=c99>"

#~ msgid ""
#~ "The B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
#~ "and B<vsprintf>()  functions conform to C89 and C99.  The B<snprintf>()  "
#~ "and B<vsnprintf>()  functions conform to C99."
#~ msgstr ""
#~ "B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
#~ "B<vsprintf>()  関数は、C89 と C99 に準拠している。 B<snprintf>()  と "
#~ "B<vsnprintf>()  は C99 に準拠している。"

#~ msgid ""
#~ "Other errors may occur, depending on the object connected to I<fd>.  "
#~ "POSIX allows a B<read>()  that is interrupted after reading some data to "
#~ "return -1 (with I<errno> set to B<EINTR>)  or to return the number of "
#~ "bytes already read."
#~ msgstr ""
#~ "I<fd> が接続しているオブジェクトによっては他のエラーも起こりえる。 POSIX "
#~ "では、 いくらかのデータを読んだ後に割り込みが起こった場合、 B<read>()  は "
#~ "(I<errno> に B<EINTR> を設定して) -1 を返してもよいし、 既に読み込んだバイ"
#~ "ト数を返してもよい。"

#~ msgid "The named file is not a symbolic link."
#~ msgstr "指定したファイルがシンボリックリンクでない。"

#~ msgid ""
#~ "It is not advisable to mix calls to B<readv>()  or B<writev>(), which "
#~ "operate on file descriptors, with the functions from the stdio library; "
#~ "the results will be undefined and probably not what you want."
#~ msgstr ""
#~ "ファイルディスクリプターに対する操作を行う B<readv>() や B<writev>() "
#~ "と、\n"
#~ "標準入出力ライブラリの関数をごちゃまぜにして呼ぶのはお薦めしない。\n"
#~ "どんな結果になるかは定義されておらず、おそらく期待する結果は\n"
#~ "得られないだろう。"

#~ msgid "The B<remove>()  function is thread-safe."
#~ msgstr "関数 B<remove>() はスレッドセーフである。"

#~ msgid ""
#~ "However, when overwriting there will probably be a window in which both "
#~ "I<oldpath> and I<newpath> refer to the file being renamed."
#~ msgstr ""
#~ "一方で、上書きを行なう場合は、rename が行なわれるファイルを I<oldpath> と "
#~ "I<newpath> の両方で参照できる瞬間がおそらく存在する。"

#~ msgid "B<renameat2>()  was added to Linux in kernel 3.15."
#~ msgstr "B<renameat2>()  はカーネル 2.6.16 で Linux に追加された。"

#~ msgid ""
#~ "Equivalent to I<ld>; this exists only for backward compatibility.  (Note: "
#~ "thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
#~ "causing old programs to fail mysteriously.)"
#~ msgstr ""
#~ "I<ld> と同一である。これは以前の仕様との互換性だけのためにある。 (注意: こ"
#~ "れは libc4 の場合だけである。 libc5 や glibc では B<%D> は暗黙のうちに無視"
#~ "され、古いプログラムにおいて謎に満ちた失敗の原因となる。)"

#~ msgid ""
#~ "The B<setbuf>(), B<setbuffer>(), B<setlinebuf>(), and B<setvbuf>()  "
#~ "functions are thread-safe."
#~ msgstr ""
#~ "関数 B<setbuf>(), B<setbuffer>(), B<setlinebuf>(), B<setvbuf>() はスレッド"
#~ "セーフである。"

#~ msgid ""
#~ "The B<__fbufsize>(), B<__fpending>(), B<__fpurge>()  and "
#~ "B<__fsetlocking>()  functions do not lock the stream, so they are not "
#~ "thread-safe."
#~ msgstr ""
#~ "関数 B<__fbufsize>(), B<__fpending>(), B<__fpurge>(), B<__fsetlocking>() "
#~ "は、 ストリームのロックを行わない。 そのため、スレッドセーフではない。"

#~ msgid ""
#~ "The B<__flbf>(), B<__freadable>(), B<__freading>(), B<__fwritable>(), "
#~ "B<__fwriting>()  and B<_flushlbf>()  functions are thread-safe."
#~ msgstr ""
#~ "関数 B<__flbf>(), B<__freadable>(), B<__freading>(), B<__fwritable>(), "
#~ "B<__fwriting>(), B<_flushlbf>() はスレッドセーフである。"

#~ msgid "System calls"
#~ msgstr "システムコール"

#~ msgid "The call was interrupted by a signal."
#~ msgstr "呼び出しがシグナルによって中断された。"

#~ msgid "Too many file descriptors in use by the process."
#~ msgstr "1 つのプロセスで使用可能なファイルディスクリプター数を超過した。"

#~ msgid "Too many files open in the system."
#~ msgstr "システム全体でオープン可能なファイル数を超過した。"

#~ msgid ""
#~ "The B<tmpnam>()  function is thread-safe with exceptions.  It is not "
#~ "thread-safe if called with a NULL parameter."
#~ msgstr ""
#~ "B<tmpnam>() 関数は例外付きでスレッドセーフである。 NULL パラメーターで呼び"
#~ "出された場合はスレッドセーフではない。"

#~ msgid "The B<tmpnam_r>()  function is thread-safe."
#~ msgstr "B<tmpnam_r>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "Although B<tmpnam>()  generates names that are difficult to guess, it is "
#~ "nevertheless possible that between the time that B<tmpnam>()  returns a "
#~ "pathname, and the time that the program opens it, another program might "
#~ "create that pathname using B<open>(2), or create it as a symbolic link.  "
#~ "This can lead to security holes.  To avoid such possibilities, use the "
#~ "B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
#~ "B<mkstemp>(3)  or B<tmpfile>(3)."
#~ msgstr ""
#~ "B<tmpnam>()  は推測が難しい名前を生成するが、それにもかかわらず、 "
#~ "B<tmpnam>()  がパス名を返してから、プログラムがそのファイルをオープンする "
#~ "までの間に、別のプログラムが同じパス名で、ファイルを B<open>(2)  で作成し"
#~ "たり、シンボリックリンクを作成したりする可能性がある。 これはセキュリティ"
#~ "ホールにつながる可能性がある。 そのような可能性を回避するためには、 "
#~ "B<open>(2)  の B<O_EXCL> フラグを使ってパス名をオープンすればよい。 もっと"
#~ "いいのは、 B<mkstemp>(3)  や B<tmpfile>(3)  を使うことである。"

#~ msgid "A POSIX draft proposed to use a function B<tmpnam_r>()  defined by"
#~ msgstr ""
#~ "POSIX 草案では、関数 B<tmpnam_r>()  を使うことを提案している。 この関数"
#~ "は、以下のように定義されており、 NULL を使わないようにという警告の意味で "
#~ "NULL を別扱いしている。"

#~ msgid ""
#~ "apparently as a warning not to use NULL.  A few systems implement it.  To "
#~ "get a glibc prototype for this function from I<E<lt>stdio.hE<gt>>, define "
#~ "B<_SVID_SOURCE> or B<_BSD_SOURCE> (before including I<any> header file)."
#~ msgstr ""
#~ "数は少ないが、この関数を実装しているシステムもある。 この関数の glibc のプ"
#~ "ロトタイプを I<E<lt>stdio.hE<gt>> から得るには、 (「どの」ヘッダーファイル"
#~ "をインクルードするよりも前に)  B<_SVID_SOURCE> か B<_BSD_SOURCE> を定義し"
#~ "ておく必要がある。"

#~ msgid ""
#~ "On success, the number of bytes written is returned (zero indicates "
#~ "nothing was written).  On error, -1 is returned, and I<errno> is set "
#~ "appropriately."
#~ msgstr ""
#~ "成功した場合、書き込まれたバイト数が返される (ゼロは何も書き込まれなかった"
#~ "ことを示す)。 エラーならば -1 が返され、I<errno> が適切に設定される。"

#~ msgid "A low-level I/O error occurred while modifying the inode."
#~ msgstr "inode の修正中に低レべル (low-level) I/O エラーが発生した。"
