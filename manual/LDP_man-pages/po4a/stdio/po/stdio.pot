# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/asprintf.3:27
#, no-wrap
msgid "ASPRINTF"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26 build/C/man3/ferror.3:44 build/C/man3/setbuf.3:48 build/C/man3/wprintf.3:16
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26 build/C/man3/fclose.3:44 build/C/man3/fcloseall.3:25 build/C/man3/fflush.3:45 build/C/man3/fgetc.3:27 build/C/man3/fgetwc.3:18 build/C/man3/fmemopen.3:7 build/C/man3/fopen.3:44 build/C/man3/fputwc.3:16 build/C/man3/fread.3:46 build/C/man3/fseek.3:42 build/C/man3/getline.3:26 build/C/man3/gets.3:29 build/C/man3/getw.3:25 build/C/man3/open_memstream.3:9 build/C/man3/popen.3:40 build/C/man3/printf.3:34 build/C/man3/puts.3:26 build/C/man3/remove.3:31 build/C/man3/scanf.3:52 build/C/man3/wprintf.3:16
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:27 build/C/man3/ctermid.3:26 build/C/man3/fclose.3:44 build/C/man3/fcloseall.3:25 build/C/man3/ferror.3:44 build/C/man3/fflush.3:45 build/C/man3/fgetc.3:27 build/C/man3/fgetwc.3:18 build/C/man3/flockfile.3:25 build/C/man3/fmemopen.3:7 build/C/man3/fmtmsg.3:13 build/C/man3/fopen.3:44 build/C/man3/fopencookie.3:26 build/C/man3/fpurge.3:25 build/C/man3/fputwc.3:16 build/C/man3/fread.3:46 build/C/man3/fseek.3:42 build/C/man3/fseeko.3:25 build/C/man3/getline.3:26 build/C/man3/gets.3:29 build/C/man3/getw.3:25 build/C/man2/link.2:32 build/C/man2/llseek.2:29 build/C/man2/lseek.2:46 build/C/man3/lseek64.3:26 build/C/man2/open.2:51 build/C/man2/openat2.2:24 build/C/man2/open_by_handle_at.2:25 build/C/man3/open_memstream.3:9 build/C/man3/perror.3:31 build/C/man2/pipe.2:36 build/C/man3/popen.3:40 build/C/man3/printf.3:34 build/C/man3/puts.3:26 build/C/man2/read.2:36 build/C/man2/readlink.2:44 build/C/man2/readv.2:32 build/C/man3/remove.3:31 build/C/man2/rename.2:33 build/C/man2/rmdir.2:30 build/C/man3/scanf.3:52 build/C/man3/setbuf.3:48 build/C/man3/stdin.3:13 build/C/man3/stdio.3:39 build/C/man3/stdio_ext.3:25 build/C/man2/symlink.2:33 build/C/man7/symlink.7:37 build/C/man3/tempnam.3:25 build/C/man3/tmpfile.3:31 build/C/man3/tmpnam.3:27 build/C/man2/unlink.2:33 build/C/man3/unlocked_stdio.3:25 build/C/man3/wprintf.3:16 build/C/man2/write.2:39
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:28 build/C/man3/ctermid.3:27 build/C/man3/fclose.3:45 build/C/man3/fcloseall.3:26 build/C/man3/ferror.3:45 build/C/man3/fflush.3:46 build/C/man3/fgetc.3:28 build/C/man3/fgetwc.3:19 build/C/man3/flockfile.3:26 build/C/man3/fmemopen.3:8 build/C/man3/fmtmsg.3:14 build/C/man3/fopen.3:45 build/C/man3/fopencookie.3:27 build/C/man3/fpurge.3:26 build/C/man3/fputwc.3:17 build/C/man3/fread.3:47 build/C/man3/fseek.3:43 build/C/man3/fseeko.3:26 build/C/man3/getline.3:27 build/C/man3/gets.3:30 build/C/man3/getw.3:26 build/C/man2/link.2:33 build/C/man2/llseek.2:30 build/C/man2/lseek.2:47 build/C/man3/lseek64.3:27 build/C/man2/open.2:52 build/C/man2/openat2.2:25 build/C/man2/open_by_handle_at.2:26 build/C/man3/open_memstream.3:10 build/C/man3/perror.3:32 build/C/man2/pipe.2:37 build/C/man3/popen.3:41 build/C/man3/printf.3:35 build/C/man3/puts.3:27 build/C/man2/read.2:37 build/C/man2/readlink.2:45 build/C/man2/readv.2:33 build/C/man3/remove.3:32 build/C/man2/rename.2:34 build/C/man2/rmdir.2:31 build/C/man3/scanf.3:53 build/C/man3/setbuf.3:49 build/C/man3/stdin.3:14 build/C/man3/stdio.3:40 build/C/man3/stdio_ext.3:26 build/C/man2/symlink.2:34 build/C/man7/symlink.7:38 build/C/man3/tempnam.3:26 build/C/man3/tmpfile.3:32 build/C/man3/tmpnam.3:28 build/C/man2/unlink.2:34 build/C/man3/unlocked_stdio.3:26 build/C/man3/wprintf.3:17 build/C/man2/write.2:40
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:30
msgid "asprintf, vasprintf - print to allocated string"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:30 build/C/man3/ctermid.3:29 build/C/man3/fclose.3:47 build/C/man3/fcloseall.3:28 build/C/man3/ferror.3:47 build/C/man3/fflush.3:48 build/C/man3/fgetc.3:30 build/C/man3/fgetwc.3:21 build/C/man3/flockfile.3:28 build/C/man3/fmemopen.3:10 build/C/man3/fmtmsg.3:16 build/C/man3/fopen.3:47 build/C/man3/fopencookie.3:29 build/C/man3/fpurge.3:28 build/C/man3/fputwc.3:19 build/C/man3/fread.3:49 build/C/man3/fseek.3:45 build/C/man3/fseeko.3:28 build/C/man3/getline.3:29 build/C/man3/gets.3:32 build/C/man3/getw.3:28 build/C/man2/link.2:35 build/C/man2/llseek.2:32 build/C/man2/lseek.2:49 build/C/man3/lseek64.3:29 build/C/man2/open.2:54 build/C/man2/openat2.2:27 build/C/man2/open_by_handle_at.2:29 build/C/man3/open_memstream.3:12 build/C/man3/perror.3:34 build/C/man2/pipe.2:39 build/C/man3/popen.3:43 build/C/man3/printf.3:38 build/C/man3/puts.3:29 build/C/man2/read.2:39 build/C/man2/readlink.2:47 build/C/man2/readv.2:35 build/C/man3/remove.3:34 build/C/man2/rename.2:36 build/C/man2/rmdir.2:33 build/C/man3/scanf.3:55 build/C/man3/setbuf.3:51 build/C/man3/stdin.3:16 build/C/man3/stdio.3:42 build/C/man3/stdio_ext.3:30 build/C/man2/symlink.2:36 build/C/man3/tempnam.3:28 build/C/man3/tmpfile.3:34 build/C/man3/tmpnam.3:30 build/C/man2/unlink.2:36 build/C/man3/unlocked_stdio.3:29 build/C/man3/wprintf.3:20 build/C/man2/write.2:42
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:34 build/C/man3/fclose.3:49 build/C/man3/ferror.3:49 build/C/man3/fflush.3:50 build/C/man3/fseek.3:47 build/C/man3/perror.3:36 build/C/man3/remove.3:36 build/C/man3/stdio.3:44
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:36
msgid "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:38
msgid ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list "
">I<ap>B<);>"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:38 build/C/man3/ctermid.3:45 build/C/man3/fclose.3:51 build/C/man3/fcloseall.3:35 build/C/man3/ferror.3:65 build/C/man3/fflush.3:52 build/C/man3/fgetc.3:44 build/C/man3/fgetwc.3:29 build/C/man3/flockfile.3:50 build/C/man3/fmemopen.3:35 build/C/man3/fmtmsg.3:24 build/C/man3/fopen.3:65 build/C/man3/fopencookie.3:37 build/C/man3/fpurge.3:41 build/C/man3/fputwc.3:27 build/C/man3/fread.3:59 build/C/man3/fseek.3:57 build/C/man3/fseeko.3:52 build/C/man3/getline.3:58 build/C/man3/gets.3:38 build/C/man3/getw.3:58 build/C/man2/link.2:66 build/C/man2/llseek.2:44 build/C/man2/lseek.2:55 build/C/man3/lseek64.3:37 build/C/man2/open.2:92 build/C/man2/openat2.2:40 build/C/man2/open_by_handle_at.2:43 build/C/man3/open_memstream.3:42 build/C/man3/perror.3:58 build/C/man2/pipe.2:58 build/C/man3/popen.3:65 build/C/man3/printf.3:84 build/C/man3/puts.3:43 build/C/man2/read.2:45 build/C/man2/readlink.2:87 build/C/man2/readv.2:67 build/C/man3/remove.3:38 build/C/man2/rename.2:77 build/C/man2/rmdir.2:37 build/C/man3/scanf.3:83 build/C/man3/setbuf.3:76 build/C/man3/stdin.3:24 build/C/man3/stdio.3:50 build/C/man3/stdio_ext.3:46 build/C/man2/symlink.2:75 build/C/man7/symlink.7:40 build/C/man3/tempnam.3:45 build/C/man3/tmpfile.3:40 build/C/man3/tmpnam.3:56 build/C/man2/unlink.2:66 build/C/man3/unlocked_stdio.3:108 build/C/man3/wprintf.3:55 build/C/man2/write.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:53
msgid ""
"The functions B<asprintf>()  and B<vasprintf>()  are analogs of "
"B<sprintf>(3)  and B<vsprintf>(3), except that they allocate a string large "
"enough to hold the output including the terminating null byte "
"(\\(aq\\e0\\(aq), and return a pointer to it via the first argument.  This "
"pointer should be passed to B<free>(3)  to release the allocated storage "
"when it is no longer needed."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:53 build/C/man3/ctermid.3:58 build/C/man3/fclose.3:59 build/C/man3/fcloseall.3:50 build/C/man3/fflush.3:79 build/C/man3/fgetc.3:99 build/C/man3/fgetwc.3:54 build/C/man3/flockfile.3:119 build/C/man3/fmemopen.3:140 build/C/man3/fmtmsg.3:149 build/C/man3/fopen.3:236 build/C/man3/fopencookie.3:238 build/C/man3/fpurge.3:57 build/C/man3/fputwc.3:53 build/C/man3/fread.3:84 build/C/man3/fseek.3:121 build/C/man3/fseeko.3:86 build/C/man3/getline.3:112 build/C/man3/gets.3:50 build/C/man3/getw.3:72 build/C/man2/link.2:187 build/C/man2/llseek.2:78 build/C/man2/lseek.2:187 build/C/man2/open.2:972 build/C/man2/openat2.2:393 build/C/man2/open_by_handle_at.2:276 build/C/man3/open_memstream.3:91 build/C/man2/pipe.2:149 build/C/man3/popen.3:125 build/C/man3/printf.3:855 build/C/man3/puts.3:84 build/C/man2/read.2:83 build/C/man2/readlink.2:154 build/C/man2/readv.2:267 build/C/man3/remove.3:60 build/C/man2/rename.2:303 build/C/man2/rmdir.2:40 build/C/man3/scanf.3:540 build/C/man3/setbuf.3:153 build/C/man2/symlink.2:141 build/C/man3/tempnam.3:97 build/C/man3/tmpfile.3:47 build/C/man3/tmpnam.3:105 build/C/man2/unlink.2:153 build/C/man3/wprintf.3:200 build/C/man2/write.2:96
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:61
msgid ""
"When successful, these functions return the number of bytes printed, just "
"like B<sprintf>(3).  If memory allocation wasn't possible, or some other "
"error occurs, these functions will return -1, and the contents of I<strp> "
"are undefined."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:61 build/C/man3/ctermid.3:60 build/C/man3/fclose.3:90 build/C/man3/fcloseall.3:55 build/C/man3/ferror.3:114 build/C/man3/fflush.3:98 build/C/man3/fgetc.3:124 build/C/man3/fgetwc.3:69 build/C/man3/flockfile.3:126 build/C/man3/fmemopen.3:152 build/C/man3/fmtmsg.3:222 build/C/man3/fopen.3:293 build/C/man3/fopencookie.3:245 build/C/man3/fpurge.3:69 build/C/man3/fputwc.3:67 build/C/man3/fread.3:105 build/C/man3/fseek.3:169 build/C/man3/fseeko.3:100 build/C/man3/getline.3:140 build/C/man3/gets.3:58 build/C/man3/getw.3:79 build/C/man3/lseek64.3:187 build/C/man3/open_memstream.3:107 build/C/man3/perror.3:121 build/C/man3/popen.3:177 build/C/man3/printf.3:876 build/C/man3/puts.3:103 build/C/man3/remove.3:70 build/C/man3/scanf.3:587 build/C/man3/setbuf.3:165 build/C/man3/stdio_ext.3:124 build/C/man3/tempnam.3:108 build/C/man3/tmpfile.3:79 build/C/man3/tmpnam.3:110 build/C/man3/unlocked_stdio.3:115 build/C/man3/wprintf.3:208
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:64 build/C/man3/ctermid.3:63 build/C/man3/fclose.3:93 build/C/man3/fcloseall.3:58 build/C/man3/ferror.3:117 build/C/man3/fflush.3:101 build/C/man3/fgetc.3:127 build/C/man3/fgetwc.3:72 build/C/man3/flockfile.3:129 build/C/man3/fmemopen.3:155 build/C/man3/fmtmsg.3:225 build/C/man3/fopen.3:296 build/C/man3/fopencookie.3:248 build/C/man3/fpurge.3:72 build/C/man3/fputwc.3:70 build/C/man3/fread.3:108 build/C/man3/fseek.3:172 build/C/man3/fseeko.3:103 build/C/man3/getline.3:143 build/C/man3/gets.3:61 build/C/man3/getw.3:82 build/C/man3/lseek64.3:190 build/C/man3/open_memstream.3:110 build/C/man3/perror.3:124 build/C/man3/popen.3:180 build/C/man3/printf.3:879 build/C/man3/puts.3:106 build/C/man3/remove.3:73 build/C/man3/scanf.3:590 build/C/man3/setbuf.3:168 build/C/man3/stdio_ext.3:127 build/C/man3/tempnam.3:111 build/C/man3/tmpfile.3:82 build/C/man3/tmpnam.3:113 build/C/man3/unlocked_stdio.3:118 build/C/man3/wprintf.3:211
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67 build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62 build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131 build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133 build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229 build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252 build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112 build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107 build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86 build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114 build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883 build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594 build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131 build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86 build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123 build/C/man3/wprintf.3:215
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67 build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62 build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131 build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133 build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229 build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252 build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112 build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107 build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86 build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114 build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883 build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594 build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131 build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86 build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123 build/C/man3/wprintf.3:215
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:68 build/C/man3/ctermid.3:67 build/C/man3/fclose.3:97 build/C/man3/fcloseall.3:62 build/C/man3/ferror.3:121 build/C/man3/fflush.3:105 build/C/man3/fgetc.3:131 build/C/man3/fgetwc.3:76 build/C/man3/flockfile.3:133 build/C/man3/fmemopen.3:159 build/C/man3/fmtmsg.3:229 build/C/man3/fopen.3:300 build/C/man3/fopencookie.3:252 build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:74 build/C/man3/fread.3:112 build/C/man3/fseek.3:176 build/C/man3/fseeko.3:107 build/C/man3/getline.3:147 build/C/man3/gets.3:65 build/C/man3/getw.3:86 build/C/man3/lseek64.3:194 build/C/man3/open_memstream.3:114 build/C/man3/perror.3:128 build/C/man3/popen.3:184 build/C/man3/printf.3:883 build/C/man3/puts.3:110 build/C/man3/remove.3:77 build/C/man3/scanf.3:594 build/C/man3/setbuf.3:172 build/C/man3/stdio_ext.3:131 build/C/man3/tempnam.3:115 build/C/man3/tmpfile.3:86 build/C/man3/tmpnam.3:117 build/C/man3/unlocked_stdio.3:123 build/C/man3/wprintf.3:215
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:72
#, no-wrap
msgid ""
"B<asprintf>(),\n"
"B<vasprintf>()"
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:72 build/C/man3/ctermid.3:70 build/C/man3/fclose.3:100 build/C/man3/fcloseall.3:65 build/C/man3/ferror.3:128 build/C/man3/fflush.3:108 build/C/man3/fgetc.3:139 build/C/man3/fgetwc.3:80 build/C/man3/flockfile.3:138 build/C/man3/fmemopen.3:162 build/C/man3/fmtmsg.3:232 build/C/man3/fopen.3:305 build/C/man3/fopencookie.3:255 build/C/man3/fpurge.3:79 build/C/man3/fputwc.3:78 build/C/man3/fread.3:116 build/C/man3/fseek.3:184 build/C/man3/fseeko.3:111 build/C/man3/getline.3:151 build/C/man3/gets.3:68 build/C/man3/getw.3:90 build/C/man3/lseek64.3:197 build/C/man3/open_memstream.3:119 build/C/man3/perror.3:131 build/C/man3/popen.3:188 build/C/man3/printf.3:896 build/C/man3/puts.3:117 build/C/man3/remove.3:80 build/C/man3/scanf.3:604 build/C/man3/setbuf.3:179 build/C/man3/stdio_ext.3:138 build/C/man3/stdio_ext.3:148 build/C/man3/tempnam.3:118 build/C/man3/tmpfile.3:89 build/C/man3/tmpnam.3:120 build/C/man3/tmpnam.3:123 build/C/man3/unlocked_stdio.3:141 build/C/man3/unlocked_stdio.3:145 build/C/man3/unlocked_stdio.3:149 build/C/man3/unlocked_stdio.3:154 build/C/man3/wprintf.3:225
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/asprintf.3:72 build/C/man3/printf.3:896 build/C/man3/scanf.3:604 build/C/man3/wprintf.3:225
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:75 build/C/man3/ctermid.3:72 build/C/man3/fclose.3:102 build/C/man3/fcloseall.3:71 build/C/man3/ferror.3:130 build/C/man3/fflush.3:110 build/C/man3/fgetc.3:142 build/C/man3/fgetwc.3:82 build/C/man3/flockfile.3:140 build/C/man3/fmemopen.3:165 build/C/man3/fmtmsg.3:249 build/C/man3/fopen.3:307 build/C/man3/fopencookie.3:257 build/C/man3/fpurge.3:82 build/C/man3/fputwc.3:81 build/C/man3/fread.3:118 build/C/man3/fseek.3:187 build/C/man3/fseeko.3:114 build/C/man3/getline.3:154 build/C/man3/gets.3:71 build/C/man3/getw.3:92 build/C/man2/link.2:360 build/C/man2/llseek.2:97 build/C/man2/lseek.2:233 build/C/man2/open.2:1285 build/C/man2/openat2.2:471 build/C/man2/open_by_handle_at.2:383 build/C/man3/open_memstream.3:122 build/C/man3/perror.3:134 build/C/man2/pipe.2:196 build/C/man3/popen.3:191 build/C/man3/printf.3:899 build/C/man3/puts.3:119 build/C/man2/read.2:183 build/C/man2/readlink.2:222 build/C/man2/readv.2:327 build/C/man3/remove.3:82 build/C/man2/rename.2:523 build/C/man2/rmdir.2:128 build/C/man3/scanf.3:607 build/C/man3/setbuf.3:181 build/C/man3/stdin.3:113 build/C/man3/stdio.3:245 build/C/man2/symlink.2:231 build/C/man3/tempnam.3:120 build/C/man3/tmpfile.3:91 build/C/man3/tmpnam.3:125 build/C/man2/unlink.2:278 build/C/man3/unlocked_stdio.3:157 build/C/man3/wprintf.3:228 build/C/man2/write.2:243
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:81
msgid ""
"These functions are GNU extensions, not in C or POSIX.  They are also "
"available under *BSD.  The FreeBSD implementation sets I<strp> to NULL on "
"error."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:81 build/C/man3/ctermid.3:82 build/C/man3/fclose.3:114 build/C/man3/fcloseall.3:73 build/C/man3/ferror.3:141 build/C/man3/fflush.3:124 build/C/man3/fgetc.3:151 build/C/man3/fgetwc.3:99 build/C/man3/flockfile.3:146 build/C/man3/fmemopen.3:349 build/C/man3/fmtmsg.3:328 build/C/man3/fopen.3:407 build/C/man3/fopencookie.3:447 build/C/man3/fpurge.3:92 build/C/man3/fputwc.3:98 build/C/man3/fread.3:174 build/C/man3/fseek.3:189 build/C/man3/fseeko.3:116 build/C/man3/getline.3:196 build/C/man3/gets.3:103 build/C/man3/getw.3:99 build/C/man2/link.2:433 build/C/man2/llseek.2:107 build/C/man2/lseek.2:272 build/C/man3/lseek64.3:218 build/C/man2/open.2:1876 build/C/man2/openat2.2:580 build/C/man2/open_by_handle_at.2:751 build/C/man3/open_memstream.3:142 build/C/man3/perror.3:159 build/C/man2/pipe.2:286 build/C/man3/popen.3:224 build/C/man3/printf.3:1173 build/C/man3/puts.3:128 build/C/man2/read.2:255 build/C/man2/readlink.2:350 build/C/man2/readv.2:429 build/C/man3/remove.3:93 build/C/man2/rename.2:562 build/C/man2/rmdir.2:133 build/C/man3/scanf.3:768 build/C/man3/setbuf.3:217 build/C/man3/stdin.3:154 build/C/man3/stdio.3:249 build/C/man3/stdio_ext.3:150 build/C/man2/symlink.2:263 build/C/man7/symlink.7:565 build/C/man3/tempnam.3:183 build/C/man3/tmpfile.3:110 build/C/man3/tmpnam.3:178 build/C/man2/unlink.2:305 build/C/man3/unlocked_stdio.3:180 build/C/man3/wprintf.3:268 build/C/man2/write.2:337
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:85
msgid "B<free>(3), B<malloc>(3), B<printf>(3)"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:85 build/C/man3/ctermid.3:84 build/C/man3/fclose.3:121 build/C/man3/fcloseall.3:79 build/C/man3/ferror.3:146 build/C/man3/fflush.3:133 build/C/man3/fgetc.3:168 build/C/man3/fgetwc.3:104 build/C/man3/flockfile.3:148 build/C/man3/fmemopen.3:353 build/C/man3/fmtmsg.3:331 build/C/man3/fopen.3:414 build/C/man3/fopencookie.3:452 build/C/man3/fpurge.3:97 build/C/man3/fputwc.3:102 build/C/man3/fread.3:180 build/C/man3/fseek.3:192 build/C/man3/fseeko.3:118 build/C/man3/getline.3:202 build/C/man3/gets.3:121 build/C/man3/getw.3:105 build/C/man2/link.2:442 build/C/man2/llseek.2:111 build/C/man2/lseek.2:280 build/C/man3/lseek64.3:221 build/C/man2/open.2:1901 build/C/man2/openat2.2:584 build/C/man2/open_by_handle_at.2:767 build/C/man3/open_memstream.3:146 build/C/man3/perror.3:164 build/C/man2/pipe.2:296 build/C/man3/popen.3:234 build/C/man3/printf.3:1183 build/C/man3/puts.3:140 build/C/man2/read.2:268 build/C/man2/readlink.2:358 build/C/man2/readv.2:433 build/C/man3/remove.3:104 build/C/man2/rename.2:571 build/C/man2/rmdir.2:142 build/C/man3/scanf.3:775 build/C/man3/setbuf.3:226 build/C/man3/stdin.3:160 build/C/man3/stdio.3:256 build/C/man3/stdio_ext.3:153 build/C/man2/symlink.2:275 build/C/man7/symlink.7:584 build/C/man3/tempnam.3:188 build/C/man3/tmpfile.3:116 build/C/man3/tmpnam.3:183 build/C/man2/unlink.2:318 build/C/man3/unlocked_stdio.3:183 build/C/man3/wprintf.3:275 build/C/man2/write.2:349
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:93 build/C/man3/ctermid.3:92 build/C/man3/fclose.3:129 build/C/man3/fcloseall.3:87 build/C/man3/ferror.3:154 build/C/man3/fflush.3:141 build/C/man3/fgetc.3:176 build/C/man3/fgetwc.3:112 build/C/man3/flockfile.3:156 build/C/man3/fmemopen.3:361 build/C/man3/fmtmsg.3:339 build/C/man3/fopen.3:422 build/C/man3/fopencookie.3:460 build/C/man3/fpurge.3:105 build/C/man3/fputwc.3:110 build/C/man3/fread.3:188 build/C/man3/fseek.3:200 build/C/man3/fseeko.3:126 build/C/man3/getline.3:210 build/C/man3/gets.3:129 build/C/man3/getw.3:113 build/C/man2/link.2:450 build/C/man2/llseek.2:119 build/C/man2/lseek.2:288 build/C/man3/lseek64.3:229 build/C/man2/open.2:1909 build/C/man2/openat2.2:592 build/C/man2/open_by_handle_at.2:775 build/C/man3/open_memstream.3:154 build/C/man3/perror.3:172 build/C/man2/pipe.2:304 build/C/man3/popen.3:242 build/C/man3/printf.3:1191 build/C/man3/puts.3:148 build/C/man2/read.2:276 build/C/man2/readlink.2:366 build/C/man2/readv.2:441 build/C/man3/remove.3:112 build/C/man2/rename.2:579 build/C/man2/rmdir.2:150 build/C/man3/scanf.3:783 build/C/man3/setbuf.3:234 build/C/man3/stdin.3:168 build/C/man3/stdio.3:264 build/C/man3/stdio_ext.3:161 build/C/man2/symlink.2:283 build/C/man7/symlink.7:592 build/C/man3/tempnam.3:196 build/C/man3/tmpfile.3:124 build/C/man3/tmpnam.3:191 build/C/man2/unlink.2:326 build/C/man3/unlocked_stdio.3:191 build/C/man3/wprintf.3:283 build/C/man2/write.2:357
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/ctermid.3:26
#, no-wrap
msgid "CTERMID"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:29
msgid "ctermid - get controlling terminal name"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:34 build/C/man3/fgetc.3:33 build/C/man3/flockfile.3:31 build/C/man3/fmemopen.3:13 build/C/man3/fopen.3:50 build/C/man3/fread.3:52 build/C/man3/fseeko.3:31 build/C/man3/getline.3:32 build/C/man3/gets.3:35 build/C/man3/getw.3:31 build/C/man3/open_memstream.3:15 build/C/man3/popen.3:46 build/C/man3/printf.3:41 build/C/man3/puts.3:32 build/C/man2/rename.2:39 build/C/man3/scanf.3:58 build/C/man3/setbuf.3:54 build/C/man3/stdin.3:19 build/C/man3/tempnam.3:31 build/C/man3/tmpfile.3:37 build/C/man3/tmpnam.3:33 build/C/man3/unlocked_stdio.3:32
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:36
#, no-wrap
msgid "B<char *ctermid(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:41 build/C/man3/ferror.3:61 build/C/man3/flockfile.3:40 build/C/man3/fmemopen.3:20 build/C/man3/fopen.3:61 build/C/man3/fseeko.3:40 build/C/man3/getline.3:42 build/C/man3/getw.3:40 build/C/man2/link.2:51 build/C/man2/open.2:77 build/C/man3/open_memstream.3:26 build/C/man3/perror.3:50 build/C/man3/popen.3:55 build/C/man3/printf.3:61 build/C/man2/readlink.2:64 build/C/man2/readv.2:59 build/C/man2/rename.2:56 build/C/man3/scanf.3:73 build/C/man3/setbuf.3:68 build/C/man2/symlink.2:52 build/C/man3/tempnam.3:38 build/C/man3/tmpnam.3:41 build/C/man2/unlink.2:51 build/C/man3/unlocked_stdio.3:68 build/C/man3/wprintf.3:39
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:45
msgid "B<ctermid>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:58
msgid ""
"B<ctermid>()  returns a string which is the pathname for the current "
"controlling terminal for this process.  If I<s> is NULL, a static buffer is "
"used, otherwise I<s> points to a buffer used to hold the terminal pathname.  "
"The symbolic constant B<L_ctermid> is the maximum number of characters in "
"the returned pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:60
msgid "The pointer to the pathname."
msgstr ""

#. type: tbl table
#: build/C/man3/ctermid.3:70
#, no-wrap
msgid "B<ctermid>()"
msgstr ""

#. type: tbl table
#: build/C/man3/ctermid.3:70 build/C/man3/fclose.3:100 build/C/man3/ferror.3:128 build/C/man3/fflush.3:108 build/C/man3/fgetc.3:139 build/C/man3/fgetwc.3:80 build/C/man3/flockfile.3:138 build/C/man3/fmemopen.3:162 build/C/man3/fopen.3:305 build/C/man3/fopencookie.3:255 build/C/man3/fputwc.3:78 build/C/man3/fread.3:116 build/C/man3/fseek.3:184 build/C/man3/fseeko.3:111 build/C/man3/getline.3:151 build/C/man3/gets.3:68 build/C/man3/getw.3:90 build/C/man3/lseek64.3:197 build/C/man3/open_memstream.3:119 build/C/man3/popen.3:188 build/C/man3/puts.3:117 build/C/man3/remove.3:80 build/C/man3/setbuf.3:179 build/C/man3/stdio_ext.3:148 build/C/man3/tmpfile.3:89 build/C/man3/tmpnam.3:123 build/C/man3/unlocked_stdio.3:154
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:74
msgid "POSIX.1-2001, POSIX.1-2008, Svr4."
msgstr ""

#. type: SH
#: build/C/man3/ctermid.3:74 build/C/man3/fmemopen.3:218 build/C/man3/fopen.3:390 build/C/man3/gets.3:85 build/C/man3/getw.3:95 build/C/man2/link.2:427 build/C/man2/open.2:1843 build/C/man3/open_memstream.3:132 build/C/man3/popen.3:201 build/C/man3/printf.3:1029 build/C/man3/puts.3:121 build/C/man2/read.2:216 build/C/man3/remove.3:90 build/C/man2/rename.2:551 build/C/man2/rmdir.2:130 build/C/man3/scanf.3:699 build/C/man3/setbuf.3:187 build/C/man3/tempnam.3:180 build/C/man3/tmpnam.3:171 build/C/man2/unlink.2:302 build/C/man2/write.2:298
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:78
msgid ""
"The returned pathname may not uniquely identify the controlling terminal; it "
"may, for example, be I</dev/tty>."
msgstr ""

#.  in glibc 2.3.x, x >= 4, the glibc headers threw an error
#.  if ctermid() was given an argument; fixed in 2.4.
#. type: Plain text
#: build/C/man3/ctermid.3:82
msgid "It is not assured that the program can open the terminal."
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:84
msgid "B<ttyname>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fclose.3:44
#, no-wrap
msgid "FCLOSE"
msgstr ""

#. type: TH
#: build/C/man3/fclose.3:44
#, no-wrap
msgid "2016-12-12"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:47
msgid "fclose - close a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:51
msgid "B<int fclose(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:59
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<stream> "
"(writing any buffered output data using B<fflush>(3))  and closes the "
"underlying file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:70
msgid ""
"Upon successful completion, 0 is returned.  Otherwise, B<EOF> is returned "
"and I<errno> is set to indicate the error.  In either case, any further "
"access (including another call to B<fclose>())  to the stream results in "
"undefined behavior."
msgstr ""

#. type: SH
#: build/C/man3/fclose.3:70 build/C/man3/ferror.3:104 build/C/man3/fflush.3:86 build/C/man3/fgetwc.3:63 build/C/man3/flockfile.3:124 build/C/man3/fopen.3:248 build/C/man3/fpurge.3:64 build/C/man3/fputwc.3:62 build/C/man3/fseek.3:136 build/C/man3/fseeko.3:95 build/C/man3/getline.3:127 build/C/man2/link.2:192 build/C/man2/llseek.2:85 build/C/man2/lseek.2:195 build/C/man2/open.2:982 build/C/man2/openat2.2:398 build/C/man2/open_by_handle_at.2:287 build/C/man2/pipe.2:170 build/C/man3/popen.3:151 build/C/man2/read.2:99 build/C/man2/readlink.2:163 build/C/man2/readv.2:287 build/C/man3/remove.3:65 build/C/man2/rename.2:308 build/C/man2/rmdir.2:45 build/C/man3/scanf.3:557 build/C/man2/symlink.2:146 build/C/man3/tempnam.3:104 build/C/man3/tmpfile.3:56 build/C/man3/tmpnam.3:108 build/C/man2/unlink.2:158 build/C/man2/write.2:131
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man3/fclose.3:71 build/C/man3/fflush.3:87 build/C/man3/fpurge.3:65 build/C/man2/link.2:289 build/C/man2/llseek.2:86 build/C/man2/lseek.2:196 build/C/man2/open.2:1271 build/C/man2/open_by_handle_at.2:348 build/C/man2/read.2:123 build/C/man2/readlink.2:208 build/C/man2/rename.2:449 build/C/man3/scanf.3:563 build/C/man2/symlink.2:211 build/C/man2/unlink.2:253 build/C/man2/write.2:155
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(stream)).
#. type: Plain text
#: build/C/man3/fclose.3:80
msgid "The file descriptor underlying I<stream> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:90
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2), or B<fflush>(3)."
msgstr ""

#. type: tbl table
#: build/C/man3/fclose.3:100
#, no-wrap
msgid "B<fclose>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:104 build/C/man3/fgetc.3:144 build/C/man3/fseek.3:189 build/C/man3/puts.3:121
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: SH
#: build/C/man3/fclose.3:104 build/C/man3/fflush.3:115 build/C/man3/fgetwc.3:84 build/C/man3/fmemopen.3:177 build/C/man3/fmtmsg.3:265 build/C/man3/fopen.3:314 build/C/man3/fpurge.3:90 build/C/man3/fputwc.3:83 build/C/man2/link.2:369 build/C/man2/llseek.2:100 build/C/man2/lseek.2:243 build/C/man3/lseek64.3:199 build/C/man2/open.2:1332 build/C/man2/openat2.2:478 build/C/man2/open_by_handle_at.2:390 build/C/man3/open_memstream.3:126 build/C/man3/perror.3:144 build/C/man2/pipe.2:202 build/C/man3/popen.3:197 build/C/man3/printf.3:967 build/C/man2/read.2:185 build/C/man2/readlink.2:231 build/C/man2/readv.2:344 build/C/man2/rename.2:532 build/C/man3/scanf.3:638 build/C/man3/stdin.3:122 build/C/man2/symlink.2:241 build/C/man3/tempnam.3:125 build/C/man3/tmpfile.3:93 build/C/man3/tmpnam.3:136 build/C/man2/unlink.2:286 build/C/man3/wprintf.3:230 build/C/man2/write.2:252
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:114
msgid ""
"Note that B<fclose>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:121
msgid ""
"B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), "
"B<setbuf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fcloseall.3:25
#, no-wrap
msgid "FCLOSEALL"
msgstr ""

#. type: TH
#: build/C/man3/fcloseall.3:25 build/C/man3/fflush.3:45 build/C/man3/fpurge.3:25 build/C/man3/fputwc.3:16 build/C/man3/fseeko.3:25 build/C/man3/gets.3:29 build/C/man3/popen.3:40 build/C/man3/remove.3:31 build/C/man3/stdin.3:13 build/C/man2/symlink.2:33 build/C/man3/tempnam.3:25 build/C/man3/tmpnam.3:27 build/C/man2/unlink.2:33 build/C/man3/unlocked_stdio.3:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:28
msgid "fcloseall - close all open streams"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:32 build/C/man3/fopencookie.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:34
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:43
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as "
"for B<fflush>(3)); buffered input is discarded."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:50
msgid "The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:55
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""

#. type: tbl table
#: build/C/man3/fcloseall.3:65
#, no-wrap
msgid "B<fcloseall>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fcloseall.3:65
#, no-wrap
msgid "MT-Unsafe race:streams"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:71
msgid ""
"The B<fcloseall>()  function does not lock the streams, so it is not "
"thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:73
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:79
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ferror.3:44
#, no-wrap
msgid "FERROR"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:47
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:51
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:53
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:55
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:57
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:65
msgid "B<fileno>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:70
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:78
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can be cleared only by the function B<clearerr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:87
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can be "
"reset only by the B<clearerr>()  function."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:101
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns the "
"integer file descriptor used to implement this stream.  The file descriptor "
"is still owned by I<stream> and will be closed when B<fclose>(3)  is "
"called.  Duplicate the file descriptor with B<dup>(2)  before passing it to "
"code that might close it."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:104 build/C/man3/fgetc.3:99 build/C/man3/fgetwc.3:54 build/C/man3/fputwc.3:53 build/C/man3/fread.3:84 build/C/man3/puts.3:84
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:114
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a "
"valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""

#. type: tbl table
#: build/C/man3/ferror.3:125
#, no-wrap
msgid ""
"B<clearerr>(),\n"
"B<feof>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/ferror.3:125 build/C/man3/fgetc.3:136 build/C/man3/fmtmsg.3:234 build/C/man3/fseek.3:181 build/C/man3/open_memstream.3:117 build/C/man3/printf.3:887 build/C/man3/printf.3:890 build/C/man3/printf.3:893 build/C/man3/scanf.3:598 build/C/man3/scanf.3:601 build/C/man3/setbuf.3:176 build/C/man3/stdio_ext.3:135 build/C/man3/stdio_ext.3:142 build/C/man3/stdio_ext.3:145 build/C/man3/wprintf.3:219 build/C/man3/wprintf.3:222
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/ferror.3:128
#, no-wrap
msgid ""
"B<ferror>(),\n"
"B<fileno>()"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:137
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89, "
"C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:141
msgid "The function B<fileno>()  conforms to POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:146
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fflush.3:45
#, no-wrap
msgid "FFLUSH"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:48
msgid "fflush - flush a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:52
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:58
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:64
msgid ""
"For input streams associated with seekable files (e.g., disk files, but not "
"pipes or terminals), B<fflush>()  discards any buffered data that has been "
"fetched from the underlying file, but has not been consumed by the "
"application."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:66
msgid "The open status of the stream is unaffected."
msgstr ""

#.  mtk: POSIX specifies that only output streams are flushed for this case.
#.  Also verified for glibc by experiment.
#. type: Plain text
#: build/C/man3/fflush.3:76
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:79
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:86
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:91
msgid "I<stream> is not an open stream, or is not open for writing."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:98
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/fflush.3:108
#, no-wrap
msgid "B<fflush>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:112
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:115
msgid ""
"POSIX.1-2001 did not specify the behavior for flushing of input streams, but "
"the behavior is specified in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:124
msgid ""
"Note that B<fflush>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:133
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), "
"B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fgetc.3:27
#, no-wrap
msgid "FGETC"
msgstr ""

#. type: TH
#: build/C/man3/fgetc.3:27 build/C/man3/fopen.3:44 build/C/man2/link.2:32 build/C/man2/llseek.2:29 build/C/man3/puts.3:26 build/C/man2/readv.2:32
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:30
msgid "fgetc, fgets, getc, getchar, ungetc - input of characters and strings"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:35
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:37
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:39
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:41
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:80
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream> "
"and stores them into the buffer pointed to by I<s>.  Reading stops after an "
"B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  A "
"terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character "
"in the buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:91
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will "
"be returned in reverse order; only one pushback is guaranteed."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:96
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:111
msgid ""
"B<fgetc>(), B<getc>(), and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:117
msgid ""
"B<fgets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:124
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr ""

#. type: tbl table
#: build/C/man3/fgetc.3:136
#, no-wrap
msgid ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/fgetc.3:139
#, no-wrap
msgid ""
"B<getchar>(),\n"
"B<ungetc>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:151
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetc.3:168
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: build/C/man3/fgetwc.3:18
#, no-wrap
msgid "FGETWC"
msgstr ""

#. type: TH
#: build/C/man3/fgetwc.3:18 build/C/man2/rmdir.2:30
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:21
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:25 build/C/man3/fputwc.3:23 build/C/man3/wprintf.3:24
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:28
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:43
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns "
"it.  If the end of stream is reached, or if I<ferror(stream)> becomes true, "
"it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:51
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:63
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>.  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:65 build/C/man3/fputwc.3:64
msgid "Apart from the usual ones, there is"
msgstr ""

#. type: TP
#: build/C/man3/fgetwc.3:65 build/C/man3/fputwc.3:64 build/C/man3/scanf.3:568
#, no-wrap
msgid "B<EILSEQ>"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:69
msgid "The data obtained from the input stream does not form a valid character."
msgstr ""

#. type: tbl table
#: build/C/man3/fgetwc.3:80
#, no-wrap
msgid ""
"B<fgetwc>(),\n"
"B<getwc>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:84 build/C/man3/fputwc.3:83 build/C/man3/wprintf.3:230
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:91
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:99
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:104
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/flockfile.3:25
#, no-wrap
msgid "FLOCKFILE"
msgstr ""

#. type: TH
#: build/C/man3/flockfile.3:25 build/C/man3/fmtmsg.3:13 build/C/man3/open_memstream.3:9 build/C/man2/pipe.2:36 build/C/man2/readlink.2:44 build/C/man2/rename.2:33 build/C/man7/symlink.7:37
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:28
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:35
#, no-wrap
msgid ""
"B<void flockfile(FILE *>I<filehandle>B<);>\n"
"B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
"B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:44 build/C/man3/wprintf.3:43
msgid "All functions shown above:"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:48
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:62
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:68
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:76
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the "
"I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:93
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming "
"in between.  If the reason for doing this was to achieve greater efficiency, "
"one does the I/O with the nonlocking versions of the stdio functions: with "
"B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of B<getc>(3)  and "
"B<putc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:104
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked "
"by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:108
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:119
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>().  "
"It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:124
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:126
msgid "None."
msgstr ""

#. type: tbl table
#: build/C/man3/flockfile.3:138
#, no-wrap
msgid ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:142 build/C/man3/popen.3:193
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:146
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:148
msgid "B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fmemopen.3:7
#, no-wrap
msgid "FMEMOPEN"
msgstr ""

#. type: TH
#: build/C/man3/fmemopen.3:7
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:10
msgid "fmemopen - open memory as stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:15
#, no-wrap
msgid ""
"B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char "
"*>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:23
msgid "B<fmemopen>():"
msgstr ""

#. type: TP
#: build/C/man3/fmemopen.3:26 build/C/man3/getline.3:49 build/C/man2/link.2:57 build/C/man2/open.2:83 build/C/man3/open_memstream.3:33 build/C/man3/printf.3:75 build/C/man2/readlink.2:78 build/C/man2/rename.2:62 build/C/man2/symlink.2:66 build/C/man2/unlink.2:57
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:29 build/C/man3/getline.3:52 build/C/man2/link.2:60 build/C/man2/open.2:86 build/C/man3/open_memstream.3:36 build/C/man3/printf.3:78 build/C/man2/readlink.2:81 build/C/man2/rename.2:65 build/C/man2/symlink.2:69 build/C/man2/unlink.2:60
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: build/C/man3/fmemopen.3:29 build/C/man3/getline.3:52 build/C/man2/link.2:60 build/C/man2/open.2:86 build/C/man3/open_memstream.3:36 build/C/man3/printf.3:78 build/C/man2/readlink.2:81 build/C/man2/rename.2:65 build/C/man2/symlink.2:69 build/C/man2/unlink.2:60
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:32 build/C/man3/getline.3:55 build/C/man3/open_memstream.3:39 build/C/man3/printf.3:81 build/C/man2/rename.2:72 build/C/man3/unlocked_stdio.3:106
#, no-wrap
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:43
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified "
"by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:48
msgid ""
"The I<mode> argument specifies the semantics of I/O on the stream, and is "
"one of the following:"
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:48 build/C/man3/fopen.3:165
#, no-wrap
msgid "I<r>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:51
msgid "The stream is opened for reading."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:51 build/C/man3/fopen.3:166
#, no-wrap
msgid "I<w>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:54
msgid "The stream is opened for writing."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:54 build/C/man3/fopen.3:167
#, no-wrap
msgid "I<a>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:58
msgid ""
"Append; open the stream for writing, with the initial buffer position set to "
"the first null byte."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:58 build/C/man3/fopen.3:168
#, no-wrap
msgid "I<r+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:61
msgid "Open the stream for reading and writing."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:61 build/C/man3/fopen.3:169
#, no-wrap
msgid "I<w+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:66
msgid ""
"Open the stream for reading and writing.  The buffer contents are truncated "
"(i.e., \\(aq\\e0\\(aq is placed in the first byte of the buffer)."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:66 build/C/man3/fopen.3:170
#, no-wrap
msgid "I<a+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:70
msgid ""
"Append; open the stream for reading and writing, with the initial buffer "
"position set to the first null byte."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:83
msgid ""
"The stream maintains the notion of a current position, the location where "
"the next I/O operation will be performed.  The current position is "
"implicitly updated by I/O operations.  It can be explicitly updated using "
"B<fseek>(3), and determined using B<ftell>(3).  In all modes other than "
"append, the initial position is set to the start of the buffer.  In append "
"mode, if no null byte is found within the buffer, then the initial position "
"is I<size+1>."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:98
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  allocates a buffer of "
"I<size> bytes.  This is useful for an application that wants to write data "
"to a temporary buffer and then read it back again.  The initial position is "
"set to the start of the buffer.  The buffer is automatically freed when the "
"stream is closed.  Note that the caller has no way to obtain a pointer to "
"the temporary buffer allocated by this call (but see B<open_memstream>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:104
msgid ""
"If I<buf> is not NULL, then it should point to a buffer of at least I<len> "
"bytes allocated by the caller."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:116
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or "
"closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in "
"the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:124
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do "
"not cause read operations to return an end-of-file indication.  A read from "
"the buffer will indicate end-of-file only when the current buffer position "
"advances I<size> bytes past the start of the buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:128
msgid ""
"Write operations take place either at the current position (for modes other "
"than append), or at the current size of the stream (for append modes)."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:138
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error.  "
"By default, such errors will be visible (by the absence of data) only when "
"the I<stdio> buffer is flushed.  Disabling buffering with the following call "
"may be useful to detect errors at the time of an output operation:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:140
#, no-wrap
msgid "    setbuf(stream, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:149
msgid ""
"Upon successful completion, B<fmemopen>()  returns a I<FILE> pointer.  "
"Otherwise, NULL is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man3/fmemopen.3:149 build/C/man3/fmtmsg.3:219 build/C/man3/fseeko.3:98 build/C/man2/link.2:356 build/C/man2/open.2:1281 build/C/man2/openat2.2:467 build/C/man2/open_by_handle_at.2:380 build/C/man3/open_memstream.3:102 build/C/man3/perror.3:114 build/C/man2/pipe.2:191 build/C/man2/readlink.2:218 build/C/man2/readv.2:316 build/C/man2/rename.2:516 build/C/man2/symlink.2:227 build/C/man2/unlink.2:274
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:152
msgid "B<fmemopen>()  was already available in glibc 1.0.x."
msgstr ""

#. type: tbl table
#: build/C/man3/fmemopen.3:162
#, no-wrap
msgid "B<fmemopen>(),"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:169
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: build/C/man3/fmemopen.3:177
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:183
msgid ""
"There is no file descriptor associated with the file stream returned by this "
"function (i.e., B<fileno>(3)  will return an error if called on the returned "
"stream)."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:189
msgid ""
"With version 2.22, binary mode (see below) was removed, many longstanding "
"bugs in the implementation of B<fmemopen>()  were fixed, and a new versioned "
"symbol was created for this interface."
msgstr ""

#. type: SS
#: build/C/man3/fmemopen.3:189
#, no-wrap
msgid "Binary mode"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:202
msgid ""
"From version 2.9 to 2.21, the glibc implementation of B<fmemopen>()  "
"supported a \"binary\" mode, enabled by specifying the letter \\(aqb\\(aq as "
"the second character in I<mode>.  In this mode, writes don't implicitly add "
"a terminating null byte, and B<fseek>(3)  B<SEEK_END> is relative to the end "
"of the buffer (i.e., the value specified by the I<size> argument), rather "
"than the current string length."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: build/C/man3/fmemopen.3:214
msgid ""
"An API bug afflicted the implementation of binary mode: to specify binary "
"mode, the \\(aqb\\(aq must be the I<second> character in I<mode>.  Thus, for "
"example, \"wb+\" has the desired effect, but \"w+b\" does not.  This is "
"inconsistent with the treatment of I<mode> by B<fopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:218
msgid ""
"Binary mode was removed in glibc 2.22; a \\(aqb\\(aq specified in I<mode> "
"has no effect."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: build/C/man3/fmemopen.3:229
msgid ""
"In versions of glibc before 2.22, if I<size> is specified as zero, "
"B<fmemopen>()  fails with the error B<EINVAL>.  It would be more consistent "
"if this case successfully created a stream that then returned end-of-file on "
"the first attempt at reading; since version 2.22, the glibc implementation "
"provides that behavior."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: build/C/man3/fmemopen.3:239
msgid ""
"In versions of glibc before 2.22, specifying append mode (\"a\" or \"a+\") "
"for B<fmemopen>()  sets the initial buffer position to the first null byte, "
"but (if the current position is reset to a location other than the end of "
"the stream)  does not force subsequent writes to append at the end of the "
"stream.  This bug is fixed in glibc 2.22."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: build/C/man3/fmemopen.3:256
msgid ""
"In versions of glibc before 2.22, if the I<mode> argument to B<fmemopen>()  "
"specifies append (\"a\" or \"a+\"), and the I<size> argument does not cover "
"a null byte in I<buf>, then, according to POSIX.1-2008, the initial buffer "
"position should be set to the next byte after the end of the buffer.  "
"However, in this case the glibc B<fmemopen>()  sets the buffer position to "
"-1.  This bug is fixed in glibc 2.22."
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14292
#. type: Plain text
#: build/C/man3/fmemopen.3:273
msgid ""
"In versions of glibc before 2.22, when a call to B<fseek>(3)  with a "
"I<whence> value of B<SEEK_END> was performed on a stream created by "
"B<fmemopen>(), the I<offset> was I<subtracted> from the end-of-stream "
"position, instead of being added.  This bug is fixed in glibc 2.22."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: build/C/man3/fmemopen.3:281
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""

#. type: SH
#: build/C/man3/fmemopen.3:281 build/C/man3/fmtmsg.3:269 build/C/man3/fopencookie.3:259 build/C/man3/fread.3:120 build/C/man3/getline.3:161 build/C/man2/open_by_handle_at.2:470 build/C/man3/open_memstream.3:139 build/C/man2/pipe.2:219 build/C/man3/printf.3:1073 build/C/man2/readlink.2:275 build/C/man2/readv.2:410 build/C/man3/scanf.3:734
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:291
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>(3)  to open a dynamically sized output buffer.  The "
"program scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:296
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""

#. type: SS
#: build/C/man3/fmemopen.3:298 build/C/man3/fopencookie.3:283 build/C/man3/fread.3:133 build/C/man2/pipe.2:235
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:305
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:308
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:325
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:329
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:334
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:339
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:342
#, no-wrap
msgid ""
"    fclose(in);\n"
"    fclose(out);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:344
#, no-wrap
msgid "    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:348
#, no-wrap
msgid ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:353
msgid "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fmtmsg.3:13
#, no-wrap
msgid "FMTMSG"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:16
msgid "fmtmsg - print formatted error messages"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:19
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:23
#, no-wrap
msgid ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:34
msgid ""
"This function displays a message described by its arguments on the device(s)  "
"specified in the I<classification> argument.  For messages written to "
"I<stderr>, the format depends on the B<MSGVERB> environment variable."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:41
msgid ""
"The I<label> argument identifies the source of the message.  The string must "
"consist of two colon separated parts where the first part has not more than "
"10 and the second part not more than 14 characters."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:45
msgid "The I<text> argument describes the condition of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:50
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:58
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique "
"identification number."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:58
#, no-wrap
msgid "Dummy arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:77
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed.  "
"The dummy severity value B<NO_SEV> (0) says that no severity is supplied.  "
"The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char\\ *)\\ 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:77
#, no-wrap
msgid "The classification argument"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:81
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:83
msgid "The first value defines the output channel."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:83
#, no-wrap
msgid "B<MM_PRINT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:87
msgid "Output to I<stderr>."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:87
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:90
msgid "Output to the system console."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:90
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:93
msgid "Output to both."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:95
msgid "The second value is the source of the error:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:95
#, no-wrap
msgid "B<MM_HARD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:98
msgid "A hardware error occurred."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:98
#, no-wrap
msgid "B<MM_FIRM>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:101
msgid "A firmware error occurred."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:101
#, no-wrap
msgid "B<MM_SOFT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:104
msgid "A software error occurred."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:106
msgid "The third value encodes the detector of the problem:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:106
#, no-wrap
msgid "B<MM_APPL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:109
msgid "It is detected by an application."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:109
#, no-wrap
msgid "B<MM_UTIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:112
msgid "It is detected by a utility."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:112
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:115
msgid "It is detected by the operating system."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:117
msgid "The fourth value shows the severity of the incident:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:117
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:120
msgid "It is a recoverable error."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:120
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:123
msgid "It is a nonrecoverable error."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:123
#, no-wrap
msgid "The severity argument"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:127
msgid "The I<severity> argument can take one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:127
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:130
msgid "No severity is printed."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:130
#, no-wrap
msgid "B<MM_HALT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:133
msgid "This value is printed as HALT."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:133
#, no-wrap
msgid "B<MM_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:136
msgid "This value is printed as ERROR."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:136
#, no-wrap
msgid "B<MM_WARNING>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:139
msgid "This value is printed as WARNING."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:139
#, no-wrap
msgid "B<MM_INFO>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:142
msgid "This value is printed as INFO."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:149
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:151
msgid "The function can return 4 values:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:151
#, no-wrap
msgid "B<MM_OK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:154
msgid "Everything went smooth."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:154
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:157
msgid "Complete failure."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:157
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:161
msgid "Error writing to I<stderr>."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:161
#, no-wrap
msgid "B<MM_NOCON>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:164
msgid "Error writing to the console."
msgstr ""

#. type: SH
#: build/C/man3/fmtmsg.3:164
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:175
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to "
"the console.)  When this variable is defined, is non-NULL, and is a "
"colon-separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:187
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:190
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:195
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:198
msgid "severity-keyword,level,printstring"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:205
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0\\(en4), and use the indicated printstring "
"when such a level occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:219
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the "
"string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:222
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/fmtmsg.3:232
#, no-wrap
msgid "B<fmtmsg>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fmtmsg.3:234
#, no-wrap
msgid "glibc E<gt>= 2.16: MT-Safe\n"
msgstr ""

#. type: tbl table
#: build/C/man3/fmtmsg.3:236
#, no-wrap
msgid "glibc E<lt> 2.16: MT-Unsafe"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:243
msgid ""
"Before glibc 2.16, the B<fmtmsg>()  function uses a static variable that is "
"not protected, so it is not thread-safe."
msgstr ""

#.  Modified in commit 7724defcf8873116fe4efab256596861eef21a94
#. type: Plain text
#: build/C/man3/fmtmsg.3:249
msgid ""
"Since glibc 2.16, the B<fmtmsg>()  function uses a lock to protect the "
"static variable, so it is thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:259
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:265
msgid ""
"The function B<fmtmsg>()  and the environment variable B<MSGVERB> are "
"described in POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:269
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:274
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:280
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:301
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:304
msgid "The output should be:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:309
#, no-wrap
msgid ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:313
msgid "and after"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:317
#, no-wrap
msgid "MSGVERB=text:action; export MSGVERB\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:321
msgid "the output becomes:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:326
#, no-wrap
msgid ""
"unknown mount option\n"
"TO FIX: See mount(8).\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:331
msgid "B<addseverity>(3), B<perror>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fopen.3:44
#, no-wrap
msgid "FOPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:47
msgid "fopen, fdopen, freopen - stream open functions"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:56
#, no-wrap
msgid ""
"B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:65
msgid "B<fdopen>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:71
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<pathname> and associates a stream with it."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:76
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:76
#, no-wrap
msgid "B<r>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:80
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:80
#, no-wrap
msgid "B<r+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:84
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:84
#, no-wrap
msgid "B<w>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:88
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is "
"positioned at the beginning of the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:88
#, no-wrap
msgid "B<w+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:94
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the "
"file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:94 build/C/man3/scanf.3:459
#, no-wrap
msgid "B<a>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:99
msgid ""
"Open for appending (writing at end of file).  The file is created if it does "
"not exist.  The stream is positioned at the end of the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:99
#, no-wrap
msgid "B<a+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:108
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  Output is always appended to the end of the "
"file.  POSIX is silent on what the initial read position is when using this "
"mode.  For glibc, the initial file position for reading is at the beginning "
"of the file, but for Android/BSD/MacOS, the initial file position for "
"reading is at the end of the file."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:121
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the "
"two-character strings described above.  This is strictly for compatibility "
"with C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX "
"conforming systems, including Linux.  (Other systems may treat text files "
"and binary files differently, and adding the \\(aqb\\(aq may be a good idea "
"if you do I/O to a binary file and expect that your program may be ported to "
"non-UNIX environments.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:124
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:129
msgid ""
"Any created file will have the mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:144
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note "
"that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a "
"stream.  This operation may be an apparent no-op (as in I<fseek(..., 0L, "
"SEEK_CUR)> called for its synchronizing side effect)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:149
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at "
"end-of-file, as if preceded the call:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:153
#, no-wrap
msgid "fseek(stream, 0, SEEK_END);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:159
msgid ""
"The file descriptor associated with the stream is opened as if by a call to "
"B<open>(2)  with the following flags:"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:164
#, no-wrap
msgid "fopen() mode"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:164
#, no-wrap
msgid "open() flags"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:165
#, no-wrap
msgid "O_RDONLY"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:166
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_TRUNC"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:167
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_APPEND"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:168
#, no-wrap
msgid "O_RDWR"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:169
#, no-wrap
msgid "O_RDWR | O_CREAT | O_TRUNC"
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:170
#, no-wrap
msgid "O_RDWR | O_CREAT | O_APPEND"
msgstr ""

#. type: SS
#: build/C/man3/fopen.3:174
#, no-wrap
msgid "fdopen()"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:196
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", "
"\"r+\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of "
"the file descriptor.  The file position indicator of the new stream is set "
"to that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by "
"B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""

#. type: SS
#: build/C/man3/fopen.3:196
#, no-wrap
msgid "freopen()"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:210
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<pathname> and associates the stream pointed to by I<stream> with "
"it.  The original stream (if it exists) is closed.  The I<mode> argument is "
"used just as in the B<fopen>()  function."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:221
msgid ""
"If the I<pathname> argument is a null pointer, B<freopen>()  changes the "
"mode of the stream to that specified in I<mode>; that is, B<freopen>()  "
"reopens the pathname that is associated with the stream.  The specification "
"for this behavior was added in the C99 standard, which says:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:230
msgid ""
"In this case, the file descriptor associated with the stream need not be "
"closed if the call to B<freopen>()  succeeds.  It is implementation-defined "
"which changes of mode are permitted (if any), and under what circumstances."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:236
msgid ""
"The primary use of the B<freopen>()  function is to change the file "
"associated with a standard text stream (I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:248
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>(), and B<freopen>()  return "
"a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:249 build/C/man3/fseek.3:137 build/C/man3/getline.3:128 build/C/man2/link.2:295 build/C/man2/llseek.2:93 build/C/man2/lseek.2:200 build/C/man2/open.2:1051 build/C/man2/open.2:1059 build/C/man2/open.2:1064 build/C/man2/open.2:1074 build/C/man2/open.2:1083 build/C/man2/openat2.2:423 build/C/man2/openat2.2:427 build/C/man2/openat2.2:436 build/C/man2/open_by_handle_at.2:304 build/C/man2/open_by_handle_at.2:308 build/C/man2/open_by_handle_at.2:356 build/C/man2/pipe.2:175 build/C/man2/read.2:135 build/C/man2/read.2:146 build/C/man2/readlink.2:173 build/C/man2/readlink.2:182 build/C/man2/readv.2:301 build/C/man2/readv.2:308 build/C/man2/rename.2:351 build/C/man2/rename.2:476 build/C/man2/rename.2:480 build/C/man2/rename.2:488 build/C/man2/rename.2:496 build/C/man2/rmdir.2:67 build/C/man3/scanf.3:575 build/C/man2/unlink.2:257 build/C/man2/write.2:183
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:259
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:269
msgid ""
"The B<fopen>(), B<fdopen>(), and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:276
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:283
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:293
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3), and "
"B<fflush>(3)."
msgstr ""

#. type: tbl table
#: build/C/man3/fopen.3:305
#, no-wrap
msgid ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:311
msgid "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:314
msgid "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: SS
#: build/C/man3/fopen.3:315 build/C/man2/link.2:407 build/C/man2/readlink.2:262 build/C/man2/rename.2:534 build/C/man2/symlink.2:250 build/C/man2/unlink.2:287
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:318
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:318
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:325
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:325
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:335
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:335
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr ""

#.  As at glibc 2.4:
#. type: Plain text
#: build/C/man3/fopen.3:347
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is attempted only "
"for a file opened for reading."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:347 build/C/man3/scanf.3:428
#, no-wrap
msgid "B<x>"
msgstr ""

#.  Since glibc 2.0?
#.  FIXME . C11 specifies this flag
#. type: Plain text
#: build/C/man3/fopen.3:364
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:372
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:374
msgid "B< ,ccs=>I<string>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:390
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the "
"B<,ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: build/C/man3/fopen.3:407
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters "
"preceding the \"ccs\" specification), the glibc implementation of B<fopen>()  "
"and B<freopen>()  limits the number of characters examined in I<mode> to 7 "
"(or, in glibc versions before 2.14, to 6, which was not enough to include "
"possible specifications such as \"rb+cmxe\").  The current implementation of "
"B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:414
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), "
"B<open_memstream>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:26
#, no-wrap
msgid "FOPENCOOKIE"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:26 build/C/man3/getline.3:26 build/C/man3/lseek64.3:26 build/C/man2/open.2:51 build/C/man2/openat2.2:24 build/C/man2/open_by_handle_at.2:25 build/C/man3/perror.3:31 build/C/man3/printf.3:34
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:26 build/C/man2/link.2:32 build/C/man2/llseek.2:29 build/C/man2/lseek.2:46 build/C/man3/lseek64.3:26 build/C/man2/open.2:51 build/C/man2/openat2.2:24 build/C/man2/open_by_handle_at.2:25 build/C/man2/pipe.2:36 build/C/man2/read.2:36 build/C/man2/readlink.2:44 build/C/man2/readv.2:32 build/C/man2/rename.2:33 build/C/man2/rmdir.2:30 build/C/man3/setbuf.3:48 build/C/man3/stdin.3:13 build/C/man2/symlink.2:33 build/C/man7/symlink.7:37 build/C/man2/unlink.2:33 build/C/man2/write.2:39
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:29
msgid "fopencookie - opening a custom stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:36
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:49
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the "
"stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:51
msgid "In order to create a custom stream the programmer must:"
msgstr ""

#. type: IP
#: build/C/man3/fopencookie.3:51 build/C/man3/fopencookie.3:54 build/C/man3/fopencookie.3:65 build/C/man2/lseek.2:165 build/C/man2/lseek.2:167 build/C/man2/lseek.2:170 build/C/man2/lseek.2:172 build/C/man2/lseek.2:174 build/C/man2/lseek.2:177 build/C/man2/lseek.2:181 build/C/man2/lseek.2:184 build/C/man2/open.2:528 build/C/man2/open.2:532 build/C/man2/open.2:643 build/C/man2/open.2:645 build/C/man2/open.2:650 build/C/man2/open.2:653 build/C/man2/open.2:658 build/C/man2/open.2:664 build/C/man2/open.2:670 build/C/man2/open.2:676 build/C/man2/open.2:689 build/C/man2/open.2:869 build/C/man2/open.2:877 build/C/man2/open.2:1672 build/C/man2/open.2:1675 build/C/man2/open_by_handle_at.2:149 build/C/man2/open_by_handle_at.2:157 build/C/man2/open_by_handle_at.2:168 build/C/man2/open_by_handle_at.2:181 build/C/man2/pipe.2:102 build/C/man2/pipe.2:112 build/C/man2/pipe.2:122 build/C/man2/rename.2:217 build/C/man2/rename.2:220 build/C/man2/rename.2:222 build/C/man2/rename.2:229 build/C/man3/scanf.3:688 build/C/man3/scanf.3:693 build/C/man7/symlink.7:343 build/C/man7/symlink.7:353 build/C/man7/symlink.7:383 build/C/man7/symlink.7:443 build/C/man7/symlink.7:472 build/C/man7/symlink.7:501 build/C/man7/symlink.7:532 build/C/man7/symlink.7:545
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:54
msgid ""
"Implement four \"hook\" functions that are used internally by the standard "
"I/O library when performing I/O on the stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:65
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:70
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:78
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to "
"operate on that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:85
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is "
"to be associated with the new stream.  This pointer is supplied as the first "
"argument when the standard I/O library invokes any of the hook functions "
"described below."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:101
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:107
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:116
#, no-wrap
msgid ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:120
msgid "The four fields are as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:120
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:124
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:126
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:141
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:146
msgid ""
"If I<*read> is a null pointer, then reads from the custom stream always "
"return end of file."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:146
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:150
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:152
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:168
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:173
msgid "If I<*write> is a null pointer, then output to the stream is discarded."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:173
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:177
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:179
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:185
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:186 build/C/man2/lseek.2:65
#, no-wrap
msgid "B<SEEK_SET>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:191
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:191 build/C/man2/lseek.2:70
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:195
msgid "I<*offset> should be added to the current stream offset."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:195 build/C/man2/lseek.2:75
#, no-wrap
msgid "B<SEEK_END>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:199
msgid "The stream offset should be set to the size of the stream plus I<*offset>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:206
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:210
msgid ""
"As its function result, the I<seek> function should return 0 on success, and "
"-1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:215
msgid ""
"If I<*seek> is a null pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:215
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:221
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:223
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:228
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:234
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:238
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is "
"closed."
msgstr ""

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: build/C/man3/fopencookie.3:245
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error, "
"NULL is returned."
msgstr ""

#. type: tbl table
#: build/C/man3/fopencookie.3:255
#, no-wrap
msgid "B<fopencookie>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:259
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:268
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:276
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:283
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a "
"cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:292
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:294
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:301
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:307
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:309
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:319
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:321
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:325
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:328
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:334
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:336
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:342
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:344
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:348
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:354
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:363
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:366
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:371
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:376
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:380
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:383
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:397
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    size_t nread;\n"
"    char buf[1000];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:399
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:405
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:409
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:415
#, no-wrap
msgid ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:417
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:423
#, no-wrap
msgid ""
"    for (int j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:425
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:440
#, no-wrap
msgid ""
"    for (long p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == 0) {\n"
"            if (ferror(stream) != 0) {\n"
"                fprintf(stderr, \"fread failed\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:443
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", (int) nread, buf);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:446 build/C/man3/fread.3:173 build/C/man2/open_by_handle_at.2:610 build/C/man2/open_by_handle_at.2:750
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:452
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fpurge.3:25
#, no-wrap
msgid "FPURGE"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:28
msgid "fpurge, __fpurge - purge a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:32
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:34
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:38
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:40
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:53
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:57
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a "
"value."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:64
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:69
msgid "I<stream> is not an open stream."
msgstr ""

#. type: tbl table
#: build/C/man3/fpurge.3:79
#, no-wrap
msgid "B<__fpurge>()"
msgstr ""

#. type: tbl table
#: build/C/man3/fpurge.3:79 build/C/man3/stdio_ext.3:138 build/C/man3/unlocked_stdio.3:141
#, no-wrap
msgid "MT-Safe race:stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:90
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()  "
"was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and "
"later."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:92
msgid "Usually it is a mistake to want to discard input buffers."
msgstr ""

#.  .BR fclean (3),
#. type: Plain text
#: build/C/man3/fpurge.3:97
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fputwc.3:16
#, no-wrap
msgid "FPUTWC"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:19
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:26
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:42
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If "
"I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  "
"Otherwise, it returns I<wc>."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:50
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:62
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error.  In the event of an error, I<errno> is set to indicate "
"the cause."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:67
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr ""

#. type: tbl table
#: build/C/man3/fputwc.3:78
#, no-wrap
msgid ""
"B<fputwc>(),\n"
"B<putwc>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:90
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:98
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputwc>()  will actually write the multibyte "
"sequence corresponding to the wide character I<wc>."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:102
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fread.3:46
#, no-wrap
msgid "FREAD"
msgstr ""

#. type: TH
#: build/C/man3/fread.3:46 build/C/man2/lseek.2:46 build/C/man3/scanf.3:52
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:49
msgid "fread, fwrite - binary stream input/output"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:55
#, no-wrap
msgid ""
"B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:58
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:70
msgid ""
"The function B<fread>()  reads I<nmemb> items of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:81
msgid ""
"The function B<fwrite>()  writes I<nmemb> items of data, each I<size> bytes "
"long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:95
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of items read or "
"written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:98
msgid ""
"The file position indicator for the stream is advanced by the number of "
"bytes successfully read or written."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:105
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""

#. type: tbl table
#: build/C/man3/fread.3:116
#, no-wrap
msgid ""
"B<fread>(),\n"
"B<fwrite>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:120
msgid "POSIX.1-2001, POSIX.1-2008, C89."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:125
msgid ""
"The program below demonstrates the use of B<fread>()  by parsing /bin/sh ELF "
"executable in binary mode and printing its magic and class:"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:131
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"ELF magic: 0x7f454c46\n"
"Class: 0x02\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:138
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:140
#, no-wrap
msgid "#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:149
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp = fopen(\"/bin/sh\", \"rb\");\n"
"    if (!fp) {\n"
"        perror(\"fopen\");\n"
"        return EXIT_FAILURE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:151
#, no-wrap
msgid "    unsigned char buffer[4];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:157
#, no-wrap
msgid ""
"    size_t ret = fread(buffer, ARRAY_SIZE(buffer), sizeof(*buffer), fp);\n"
"    if (ret != sizeof(*buffer)) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:160
#, no-wrap
msgid ""
"    printf(\"ELF magic: %#04x%02x%02x%02x\\en\", buffer[0], buffer[1],\n"
"           buffer[2], buffer[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:166
#, no-wrap
msgid ""
"    ret = fread(buffer, 1, 1, fp);\n"
"    if (ret != 1) {\n"
"        fprintf(stderr, \"fread() failed: %zu\\en\", ret);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:168
#, no-wrap
msgid "    printf(\"Class: %#04x\\en\", buffer[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:170 build/C/man2/open_by_handle_at.2:667
#, no-wrap
msgid "    fclose(fp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:180
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fseek.3:42
#, no-wrap
msgid "FSEEK"
msgstr ""

#. type: TH
#: build/C/man3/fseek.3:42
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:45
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:49
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:51
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:53
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:55
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:57
msgid "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:81
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or "
"end-of-file, respectively.  A successful call to the B<fseek>()  function "
"clears the end-of-file indicator for the stream and undoes any effects of "
"the B<ungetc>(3)  function on the same stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:87
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:94
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:97
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:101
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:121
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with I<whence> set to "
"B<SEEK_SET>), setting and storing the current value of the file offset into "
"or from the object referenced by I<pos>.  On some non-UNIX systems, an "
"I<fpos_t> object may be a complex object and these routines may be the only "
"way to portably reposition a text stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:136
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>.  Or: the resulting file offset would be negative."
msgstr ""

#. type: TP
#: build/C/man3/fseek.3:149 build/C/man2/lseek.2:229
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:154
msgid ""
"The file descriptor underlying I<stream> is not seekable (e.g., it refers to "
"a pipe, FIFO, or socket)."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:169
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""

#. type: tbl table
#: build/C/man3/fseek.3:181
#, no-wrap
msgid ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/fseek.3:184
#, no-wrap
msgid ""
"B<fgetpos>(),\n"
"B<fsetpos>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:192
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fseeko.3:25
#, no-wrap
msgid "FSEEKO"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:28
msgid "fseeko, ftello - seek to or report file position"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:33
#, no-wrap
msgid "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:35
#, no-wrap
msgid "B<off_t ftello(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:44
msgid "B<fseeko>(), B<ftello>():"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:48
msgid "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:50
msgid "(defining the obsolete _LARGEFILE_SOURCE macro also works)"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:73
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:86
msgid ""
"On some architectures, both I<off_t> and I<long> are 32-bit types, but "
"defining B<_FILE_OFFSET_BITS> with the value 64 (before including I<any> "
"header files)  will turn I<off_t> into a 64-bit type."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:95
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:98
msgid "See the ERRORS in B<fseek>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:100
msgid "These functions are available under glibc since version 2.1."
msgstr ""

#. type: tbl table
#: build/C/man3/fseeko.3:111
#, no-wrap
msgid ""
"B<fseeko>(),\n"
"B<ftello>()"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:116
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr ""

#. type: tbl table
#: build/C/man3/fseeko.3:118 build/C/man3/stdio.3:207
#, no-wrap
msgid "B<fseek>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getline.3:26
#, no-wrap
msgid "GETLINE"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:29
msgid "getline, getdelim - delimited string input"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:34
#, no-wrap
msgid ""
"B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:37
#, no-wrap
msgid ""
"B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, "
"FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:47
msgid "B<getline>(), B<getdelim>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:65
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is "
"null-terminated and includes the newline character, if one was found."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:77
msgid ""
"If I<*lineptr> is set to NULL and I<*n> is set 0 before the call, then "
"B<getline>()  will allocate a buffer for storing the line.  This buffer "
"should be freed by the user program even if B<getline>()  failed."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:95
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:101
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:112
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:121
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters "
"read, including the delimiter character, but not including the terminating "
"null byte (\\(aq\\e0\\(aq).  This value can be used to handle embedded null "
"bytes in the line read."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:127
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition).  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:137
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""

#. type: TP
#: build/C/man3/getline.3:137 build/C/man2/link.2:241 build/C/man2/open.2:1169 build/C/man2/open.2:1176 build/C/man2/readlink.2:199 build/C/man2/rename.2:388 build/C/man2/rmdir.2:85 build/C/man3/scanf.3:580 build/C/man2/symlink.2:187 build/C/man3/tempnam.3:105 build/C/man2/unlink.2:204
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:140
msgid "Allocation or reallocation of the line buffer failed."
msgstr ""

#. type: tbl table
#: build/C/man3/getline.3:151
#, no-wrap
msgid ""
"B<getline>(),\n"
"B<getdelim>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:161
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:166
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:174
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *stream;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t nread;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:179
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:185
#, no-wrap
msgid ""
"    stream = fopen(argv[1], \"r\");\n"
"    if (stream == NULL) {\n"
"        perror(\"fopen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:190
#, no-wrap
msgid ""
"    while ((nread = getline(&line, &len, stream)) != -1) {\n"
"        printf(\"Retrieved line of length %zd:\\en\", nread);\n"
"        fwrite(line, nread, 1, stdout);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:195
#, no-wrap
msgid ""
"    free(line);\n"
"    fclose(stream);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:202
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/gets.3:29
#, no-wrap
msgid "GETS"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:32
msgid "gets - get a string from standard input (DEPRECATED)"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:37
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:40
msgid "I<Never use this function>."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:50
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:58
msgid ""
"B<gets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read.  However, given the lack of "
"buffer overrun checking, there can be no guarantees that the function will "
"even return."
msgstr ""

#. type: tbl table
#: build/C/man3/gets.3:68
#, no-wrap
msgid "B<gets>()"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:73
msgid "C89, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:85
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:99
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer "
"security.  Use B<fgets>()  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:103
msgid ""
"For more information, see CWE-242 (aka \"Use of Inherently Dangerous "
"Function\") at http://cwe.mitre.org/data/definitions/242.html"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:121
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getw.3:25
#, no-wrap
msgid "GETW"
msgstr ""

#. type: TH
#: build/C/man3/getw.3:25 build/C/man3/tmpfile.3:31
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:28
msgid "getw, putw - input and output of words (ints)"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:33
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:35
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:44
msgid "B<getw>(), B<putw>():"
msgstr ""

#. type: TP
#: build/C/man3/getw.3:47
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:52
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: build/C/man3/getw.3:52
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:55
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:65
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:72
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:79
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""

#. type: tbl table
#: build/C/man3/getw.3:90
#, no-wrap
msgid ""
"B<getw>(),\n"
"B<putw>()"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:95
msgid "SVr4, SUSv2.  Not present in POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:99
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:105
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/link.2:32
#, no-wrap
msgid "LINK"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:35
msgid "link, linkat - make a new name for a file"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:38 build/C/man2/pipe.2:42 build/C/man2/read.2:42 build/C/man2/readlink.2:50 build/C/man2/symlink.2:39 build/C/man2/unlink.2:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:40
#, no-wrap
msgid "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:43 build/C/man2/readlink.2:56 build/C/man2/symlink.2:44 build/C/man2/unlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:46
#, no-wrap
msgid ""
"B<int linkat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<           int >I<newdirfd>B<, const char *>I<newpath>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:54
msgid "B<linkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:63 build/C/man2/open.2:89 build/C/man2/readlink.2:84 build/C/man2/rename.2:68 build/C/man2/symlink.2:72 build/C/man2/unlink.2:63
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:69
msgid ""
"B<link>()  creates a new link (also known as a hard link) to an existing "
"file."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:75
msgid "If I<newpath> exists, it will I<not> be overwritten."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:80
msgid ""
"This new name may be used exactly as the old one for any operation; both "
"names refer to the same file (and so have the same permissions and "
"ownership) and it is impossible to tell which name was the \"original\"."
msgstr ""

#. type: SS
#: build/C/man2/link.2:80
#, no-wrap
msgid "linkat()"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:86
msgid ""
"The B<linkat>()  system call operates in exactly the same way as B<link>(), "
"except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:96
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<link>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:108
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<link>())."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:114 build/C/man2/rename.2:163
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:122 build/C/man2/rename.2:171
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:125
msgid "The following values can be bitwise ORed in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/link.2:125
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 11a7b371b64ef39fc5fb1b6f2218eef7c4d035e3
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/link.2:152
msgid ""
"If I<oldpath> is an empty string, create a link to the file referenced by "
"I<olddirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<olddirfd> can refer to any type of file except a "
"directory.  This will generally not work if the file has a link count of "
"zero (files created with B<O_TMPFILE> and without B<O_EXCL> are an "
"exception).  The caller must have the B<CAP_DAC_READ_SEARCH> capability in "
"order to use this flag.  This flag is Linux-specific; define B<_GNU_SOURCE> "
"to obtain its definition."
msgstr ""

#. type: TP
#: build/C/man2/link.2:152
#, no-wrap
msgid "B<AT_SYMLINK_FOLLOW> (since Linux 2.6.18)"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:171
msgid ""
"By default, B<linkat>(), does not dereference I<oldpath> if it is a symbolic "
"link (like B<link>()).  The flag B<AT_SYMLINK_FOLLOW> can be specified in "
"I<flags> to cause I<oldpath> to be dereferenced if it is a symbolic link.  "
"If procfs is mounted, this can be used as an alternative to "
"B<AT_EMPTY_PATH>, like this:"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:176
#, no-wrap
msgid ""
"linkat(AT_FDCWD, \"/proc/self/fd/E<lt>fdE<gt>\", newdirfd,\n"
"       newname, AT_SYMLINK_FOLLOW);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:182
msgid ""
"Before kernel 2.6.18, the I<flags> argument was unused, and had to be "
"specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:187
msgid "See B<openat>(2)  for an explanation of the need for B<linkat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:192 build/C/man3/remove.3:65 build/C/man2/rename.2:308 build/C/man2/rmdir.2:45 build/C/man2/symlink.2:146 build/C/man2/unlink.2:158
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/link.2:193 build/C/man2/open.2:988 build/C/man2/open.2:997 build/C/man2/readlink.2:164 build/C/man2/rename.2:309 build/C/man2/rmdir.2:46 build/C/man2/symlink.2:147 build/C/man3/tmpfile.3:57 build/C/man2/unlink.2:159
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:204
msgid ""
"Write access to the directory containing I<newpath> is denied, or search "
"permission is denied for one of the directories in the path prefix of "
"I<oldpath> or I<newpath>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/link.2:204 build/C/man2/open.2:1024 build/C/man2/rename.2:345 build/C/man2/symlink.2:156 build/C/man2/write.2:164
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:207 build/C/man2/rename.2:348
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr ""

#. type: TP
#: build/C/man2/link.2:207 build/C/man2/open.2:1030 build/C/man2/rename.2:468 build/C/man2/symlink.2:161 build/C/man3/tmpfile.3:60
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:211
msgid "I<newpath> already exists."
msgstr ""

#. type: TP
#: build/C/man2/link.2:211 build/C/man2/llseek.2:90 build/C/man2/open.2:1036 build/C/man2/open_by_handle_at.2:297 build/C/man2/open_by_handle_at.2:352 build/C/man2/pipe.2:171 build/C/man2/read.2:127 build/C/man2/readlink.2:169 build/C/man2/rename.2:348 build/C/man2/rmdir.2:64 build/C/man2/symlink.2:165 build/C/man2/unlink.2:178 build/C/man2/write.2:170
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:214 build/C/man2/rename.2:351
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/link.2:214 build/C/man2/read.2:156 build/C/man2/readlink.2:187 build/C/man2/symlink.2:168 build/C/man2/unlink.2:182 build/C/man2/write.2:194
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:217 build/C/man2/symlink.2:171 build/C/man2/unlink.2:185
msgid "An I/O error occurred."
msgstr ""

#. type: TP
#: build/C/man2/link.2:217 build/C/man2/open.2:1112 build/C/man2/open.2:1116 build/C/man2/openat2.2:441 build/C/man2/openat2.2:447 build/C/man2/open_by_handle_at.2:362 build/C/man2/readlink.2:190 build/C/man2/rename.2:361 build/C/man2/rmdir.2:73 build/C/man2/symlink.2:171 build/C/man2/unlink.2:190
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:221 build/C/man2/rename.2:365
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""

#. type: TP
#: build/C/man2/link.2:221 build/C/man2/rename.2:365
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:233
msgid ""
"The file referred to by I<oldpath> already has the maximum number of links "
"to it.  For example, on an B<ext4>(5)  filesystem that does not employ the "
"I<dir_index> feature, the limit on the number of hard links to a file is "
"65,000; on B<btrfs>(5), the limit is 65,535 links."
msgstr ""

#. type: TP
#: build/C/man2/link.2:233 build/C/man2/open.2:1132 build/C/man2/readlink.2:193 build/C/man2/rename.2:372 build/C/man2/rmdir.2:77 build/C/man2/symlink.2:175 build/C/man2/unlink.2:194
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:236 build/C/man2/rename.2:375
msgid "I<oldpath> or I<newpath> was too long."
msgstr ""

#. type: TP
#: build/C/man2/link.2:236 build/C/man2/link.2:299 build/C/man2/link.2:307 build/C/man2/link.2:321 build/C/man2/link.2:326 build/C/man2/open.2:1146 build/C/man2/open.2:1150 build/C/man2/open.2:1155 build/C/man2/open_by_handle_at.2:313 build/C/man2/readlink.2:196 build/C/man2/rename.2:375 build/C/man2/rename.2:500 build/C/man2/rmdir.2:80 build/C/man2/symlink.2:178 build/C/man2/symlink.2:215 build/C/man2/unlink.2:197
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:241
msgid ""
"A directory component in I<oldpath> or I<newpath> does not exist or is a "
"dangling symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:244 build/C/man2/open.2:1179 build/C/man2/readlink.2:202 build/C/man2/rename.2:391 build/C/man2/rmdir.2:88 build/C/man2/symlink.2:190 build/C/man2/unlink.2:207
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/link.2:244 build/C/man2/open.2:1179 build/C/man2/rename.2:391 build/C/man2/symlink.2:190 build/C/man3/tmpfile.3:73 build/C/man2/write.2:222
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:248 build/C/man2/rename.2:395 build/C/man2/symlink.2:194
msgid "The device containing the file has no room for the new directory entry."
msgstr ""

#. type: TP
#: build/C/man2/link.2:248 build/C/man2/link.2:337 build/C/man2/open.2:1185 build/C/man2/open.2:1275 build/C/man2/open_by_handle_at.2:320 build/C/man2/readlink.2:202 build/C/man2/readlink.2:212 build/C/man2/rename.2:395 build/C/man2/rename.2:455 build/C/man2/rmdir.2:88 build/C/man2/symlink.2:194 build/C/man2/symlink.2:221 build/C/man2/unlink.2:207 build/C/man2/unlink.2:268
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:253
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory."
msgstr ""

#. type: TP
#: build/C/man2/link.2:253 build/C/man2/link.2:257 build/C/man2/link.2:269 build/C/man2/link.2:347 build/C/man2/open.2:1229 build/C/man2/open.2:1236 build/C/man2/open_by_handle_at.2:369 build/C/man2/rename.2:508 build/C/man2/rmdir.2:108 build/C/man2/rmdir.2:119 build/C/man2/symlink.2:199 build/C/man2/unlink.2:212 build/C/man2/unlink.2:235 build/C/man2/write.2:227
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:257
msgid "I<oldpath> is a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:262
msgid ""
"The filesystem containing I<oldpath> and I<newpath> does not support the "
"creation of hard links."
msgstr ""

#. type: TP
#: build/C/man2/link.2:262
#, no-wrap
msgid "B<EPERM> (since Linux 3.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:269
msgid ""
"The caller does not have permission to create a hard link to this file (see "
"the description of I</proc/sys/fs/protected_hardlinks> in B<proc>(5))."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:275
msgid "I<oldpath> is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/link.2:275 build/C/man2/open.2:1240 build/C/man2/rename.2:433 build/C/man2/rmdir.2:124 build/C/man2/symlink.2:204 build/C/man3/tmpfile.3:76 build/C/man2/unlink.2:240
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:278 build/C/man2/rename.2:436
msgid "The file is on a read-only filesystem."
msgstr ""

#. type: TP
#: build/C/man2/link.2:278 build/C/man2/openat2.2:453 build/C/man2/openat2.2:461 build/C/man2/rename.2:436
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:286
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<link>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:289
msgid "The following additional errors can occur for B<linkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:295 build/C/man2/rename.2:455
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:299 build/C/man2/unlink.2:261
msgid "An invalid flag value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:307
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, but the caller did not have the "
"B<CAP_DAC_READ_SEARCH> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:312
msgid ""
"An attempt was made to link to the I</proc/self/fd/NN> file corresponding to "
"a file descriptor created with"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:316
#, no-wrap
msgid "open(path, O_TMPFILE | O_EXCL, mode);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:321
msgid "See B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:326
msgid ""
"An attempt was made to link to a I</proc/self/fd/NN> file corresponding to a "
"file that has been deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:337
msgid ""
"I<oldpath> is a relative pathname and I<olddirfd> refers to a directory that "
"has been deleted, or I<newpath> is a relative pathname and I<newdirfd> "
"refers to a directory that has been deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:347 build/C/man2/rename.2:465
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:356
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, I<oldpath> is an empty string, "
"and I<olddirfd> refers to a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:360
msgid ""
"B<linkat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional ENOLINK and
#.  EMULTIHOP error conditions; POSIX.1 does not document ELOOP.
#.  X/OPEN does not document EFAULT, ENOMEM or EIO.
#. type: Plain text
#: build/C/man2/link.2:366
msgid "B<link>(): SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES), POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:369
msgid "B<linkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:376
msgid ""
"Hard links, as created by B<link>(), cannot span filesystems.  Use "
"B<symlink>(2)  if this is required."
msgstr ""

#.  more precisely: since kernel 1.3.56
#.  For example, the default Solaris compilation environment
#.  behaves like Linux, and contributors to a March 2005
#.  thread in the Austin mailing list reported that some
#.  other (System V) implementations did/do the same -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/link.2:407
msgid ""
"POSIX.1-2001 says that B<link>()  should dereference I<oldpath> if it is a "
"symbolic link.  However, since kernel 2.0, Linux does not do so: if "
"I<oldpath> is a symbolic link, then I<newpath> is created as a (hard) link "
"to the same symbolic link file (i.e., I<newpath> becomes a symbolic link to "
"the same file that I<oldpath> refers to).  Some other implementations behave "
"in the same manner as Linux.  POSIX.1-2008 changes the specification of "
"B<link>(), making it implementation-dependent whether or not I<oldpath> is "
"dereferenced if it is a symbolic link.  For precise control over the "
"treatment of symbolic links when creating a link, use B<linkat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:427
msgid ""
"On older kernels where B<linkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<link>(), unless the B<AT_SYMLINK_FOLLOW> "
"is specified.  When I<oldpath> and I<newpath> are relative pathnames, glibc "
"constructs pathnames based on the symbolic links in I</proc/self/fd> that "
"correspond to the I<olddirfd> and I<newdirfd> arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:433
msgid ""
"On NFS filesystems, the return code may be wrong in case the NFS server "
"performs the link creation and dies before it can say so.  Use B<stat>(2)  "
"to find out if the link got created."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:442
msgid ""
"B<ln>(1), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/llseek.2:29
#, no-wrap
msgid "LLSEEK"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:32
msgid "_llseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:40
#, no-wrap
msgid ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:44 build/C/man2/openat2.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:49
msgid ""
"Note: for information about the B<llseek>(3)  library function, see "
"B<lseek64>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:56
msgid ""
"The B<_llseek>()  system call repositions the offset of the open file "
"description associated with the file descriptor I<fd> to the value"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:58
msgid "(offset_high E<lt>E<lt> 32) | offset_low"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:69
msgid ""
"This new offset is a byte offset relative to the beginning of the file, the "
"current file offset, or the end of the file, depending on whether I<whence> "
"is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:75
msgid ""
"The new file offset is returned in the argument I<result>.  The type "
"I<loff_t> is a 64-bit signed type."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:78
msgid ""
"This system call exists on various 32-bit platforms to support seeking to "
"large file offsets."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:85
msgid ""
"Upon successful completion, B<_llseek>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:90 build/C/man2/lseek.2:200
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:93
msgid "Problem with copying results to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:97
msgid "I<whence> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:100
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:107
msgid ""
"Glibc does not provide a wrapper for this system call.  To invoke it "
"directly, use B<syscall>(2).  However, you probably want to use the "
"B<lseek>(2)  wrapper function instead."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:111
msgid "B<lseek>(2), B<open>(2), B<lseek64>(3)"
msgstr ""

#. type: TH
#: build/C/man2/lseek.2:46
#, no-wrap
msgid "LSEEK"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:49
msgid "lseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:51 build/C/man3/lseek64.3:33
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:53 build/C/man3/lseek64.3:35 build/C/man2/rmdir.2:35 build/C/man2/write.2:44
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:55
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:65
msgid ""
"B<lseek>()  repositions the file offset of the open file description "
"associated with the file descriptor I<fd> to the argument I<offset> "
"according to the directive I<whence> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:70
msgid "The file offset is set to I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:75
msgid "The file offset is set to its current location plus I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:80
msgid "The file offset is set to the size of the file plus I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:87
msgid ""
"B<lseek>()  allows the file offset to be set beyond the end of the file (but "
"this does not change the size of the file).  If data is later written at "
"this point, subsequent reads of the data in the gap (a \"hole\") return null "
"bytes (\\(aq\\e0\\(aq) until data is actually written into the gap."
msgstr ""

#. type: SS
#: build/C/man2/lseek.2:87
#, no-wrap
msgid "Seeking file data and holes"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:90
msgid ""
"Since version 3.1, Linux supports the following additional values for "
"I<whence>:"
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:90
#, no-wrap
msgid "B<SEEK_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:101
msgid ""
"Adjust the file offset to the next location in the file greater than or "
"equal to I<offset> containing data.  If I<offset> points to data, then the "
"file offset is set to I<offset>."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:101
#, no-wrap
msgid "B<SEEK_HOLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:115
msgid ""
"Adjust the file offset to the next hole in the file greater than or equal to "
"I<offset>.  If I<offset> points into the middle of a hole, then the file "
"offset is set to I<offset>.  If there is no hole past I<offset>, then the "
"file offset is adjusted to the end of the file (i.e., there is an implicit "
"hole at the end of any file)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:121
msgid ""
"In both of the above cases, B<lseek>()  fails if I<offset> points past the "
"end of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:127
msgid ""
"These operations allow applications to map holes in a sparsely allocated "
"file.  This can be useful for applications such as file backup tools, which "
"can save space when creating backups and preserve holes, if they have a "
"mechanism for discovering holes."
msgstr ""

#.  https://lkml.org/lkml/2011/4/22/79
#.  http://lwn.net/Articles/440255/
#.  http://blogs.oracle.com/bonwick/entry/seek_hole_and_seek_data
#. type: Plain text
#: build/C/man2/lseek.2:150
msgid ""
"For the purposes of these operations, a hole is a sequence of zeros that "
"(normally) has not been allocated in the underlying file storage.  However, "
"a filesystem is not obliged to report holes, so these operations are not a "
"guaranteed mechanism for mapping the storage space actually allocated to a "
"file.  (Furthermore, a sequence of zeros that actually has been written to "
"the underlying storage may not be reported as a hole.)  In the simplest "
"implementation, a filesystem can support the operations by making "
"B<SEEK_HOLE> always return the offset of the end of the file, and making "
"B<SEEK_DATA> always return I<offset> (i.e., even if the location referred to "
"by I<offset> is a hole, it can be considered to consist of data that is a "
"sequence of zeros)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:159
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<SEEK_DATA> and B<SEEK_HOLE> from I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:165
msgid ""
"The B<SEEK_HOLE> and B<SEEK_DATA> operations are supported for the following "
"filesystems:"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:167
msgid "Btrfs (since Linux 3.1)"
msgstr ""

#.  commit 93862d5e1ab875664c6cc95254fc365028a48bb1
#. type: Plain text
#: build/C/man2/lseek.2:170
msgid "OCFS (since Linux 3.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:172
msgid "XFS (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:174
msgid "ext4 (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:177
msgid "B<tmpfs>(5)  (since Linux 3.8)"
msgstr ""

#.  commit 1c6dcbe5ceff81c2cf8d929646af675cd59fe7c0
#.  commit 24bab491220faa446d945624086d838af41d616c
#. type: Plain text
#: build/C/man2/lseek.2:181
msgid "NFS (since Linux 3.18)"
msgstr ""

#.  commit 0b5da8db145bfd44266ac964a2636a0cf8d7c286
#. type: Plain text
#: build/C/man2/lseek.2:184
msgid "FUSE (since Linux 4.5)"
msgstr ""

#.  commit 3a27411cb4bc3ce31db228e3569ad01b462a4310
#. type: Plain text
#: build/C/man2/lseek.2:187
msgid "GFS2 (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:195
msgid ""
"Upon successful completion, B<lseek>()  returns the resulting offset "
"location as measured in bytes from the beginning of the file.  On error, the "
"value I<(off_t)\\ -1> is returned and I<errno> is set to indicate the error."
msgstr ""

#.  Some systems may allow negative offsets for character devices
#.  and/or for remote filesystems.
#. type: Plain text
#: build/C/man2/lseek.2:208
msgid ""
"I<whence> is not valid.  Or: the resulting file offset would be negative, or "
"beyond the end of a seekable device."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:208 build/C/man2/open.2:1192 build/C/man2/open.2:1197 build/C/man2/open.2:1200
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:224
msgid ""
"I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and I<offset> is beyond the end "
"of the file, or I<whence> is B<SEEK_DATA> and I<offset> is within a hole at "
"the end of the file."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:224 build/C/man2/open.2:1209 build/C/man2/open_by_handle_at.2:335
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#.  HP-UX 11 says EINVAL for this case (but POSIX.1 says EOVERFLOW)
#. type: Plain text
#: build/C/man2/lseek.2:229
msgid "The resulting file offset cannot be represented in an I<off_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:233
msgid "I<fd> is associated with a pipe, socket, or FIFO."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:235 build/C/man2/rmdir.2:130
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#.  FIXME . Review http://austingroupbugs.net/view.php?id=415 in the future
#. type: Plain text
#: build/C/man2/lseek.2:243
msgid ""
"B<SEEK_DATA> and B<SEEK_HOLE> are nonstandard extensions also present in "
"Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the "
"next POSIX revision (Issue 8)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:248
msgid ""
"See B<open>(2)  for a discussion of the relationship between file "
"descriptors, open file descriptions, and files."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:257
msgid ""
"If the B<O_APPEND> file status flag is set on the open file description, "
"then a B<write>(2)  I<always> moves the file offset to the end of the file, "
"regardless of the use of B<lseek>()."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:261
msgid "The I<off_t> data type is a signed integer data type specified by POSIX.1."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:265
msgid ""
"Some devices are incapable of seeking and POSIX does not specify which "
"devices must support B<lseek>()."
msgstr ""

#.  Other systems return the number of written characters,
#.  using SEEK_SET to set the counter. (Of written characters.)
#. type: Plain text
#: build/C/man2/lseek.2:272
msgid ""
"On Linux, using B<lseek>()  on a terminal device fails with the error "
"B<ESPIPE>."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:280
msgid ""
"B<dup>(2), B<fallocate>(2), B<fork>(2), B<open>(2), B<fseek>(3), "
"B<lseek64>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: build/C/man3/lseek64.3:26
#, no-wrap
msgid "LSEEK64"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:29
msgid "lseek64 - reposition 64-bit read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:31
msgid "B<#define _LARGEFILE64_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:37
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:54
msgid ""
"The B<lseek>()  family of functions reposition the offset of the open file "
"associated with the file descriptor I<fd> to I<offset> bytes relative to the "
"start, current position, or end of the file, when I<whence> has the value "
"B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:57
msgid "For more details, return value, and errors, see B<lseek>(2)."
msgstr ""

#
#.  For some background details, see:
#.  https://lore.kernel.org/linux-man/CAKgNAkhNSWR3uYhYYaxx74fZfJ3JrpfAAPVrK0AFk_cAOUsbDg@mail.gmail.com/
#. type: Plain text
#: build/C/man3/lseek64.3:68
msgid ""
"Four interfaces are available: B<lseek>(), B<lseek64>(), B<llseek>(), and "
"B<_llseek>()."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:68
#, no-wrap
msgid "lseek()"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:70 build/C/man3/lseek64.3:93 build/C/man3/lseek64.3:122
msgid "Prototype:"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:74
#, no-wrap
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:83
msgid ""
"The C library's B<lseek>()  wrapper function uses the type I<off_t>.  This "
"is a 32-bit signed type on 32-bit architectures, unless one compiles with"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:87
#, no-wrap
msgid "#define _FILE_OFFSET_BITS 64\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:91
msgid "in which case it is a 64-bit signed type."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:91
#, no-wrap
msgid "lseek64()"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:97
#, no-wrap
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:108
msgid ""
"The B<lseek64>()  library function uses a 64-bit type even when I<off_t> is "
"a 32-bit type.  Its prototype (and the type I<off64_t>)  is available only "
"when one compiles with"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:112
#, no-wrap
msgid "#define _LARGEFILE64_SOURCE\n"
msgstr ""

#.  in glibc 2.0.94, not in 2.0.6
#. type: Plain text
#: build/C/man3/lseek64.3:120
msgid "The function B<lseek64>()  is available since glibc 2.1."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:120
#, no-wrap
msgid "llseek()"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:126
#, no-wrap
msgid "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:141
msgid ""
"The type I<loff_t> is a 64-bit signed type.  The B<llseek>()  library "
"function is available in glibc and works without special defines.  However, "
"the glibc headers do not provide a prototype.  Users should add the above "
"prototype, or something equivalent, to their own source.  When users "
"complained about data loss caused by a miscompilation of B<e2fsck>(8), glibc "
"2.1.3 added the link-time warning"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:144
msgid "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:148
msgid "This makes this function unusable if one desires a warning-free compilation."
msgstr ""

#.  glibc commit 5c5c0dd747070db624c8e2c43691cec854f114ef
#. type: Plain text
#: build/C/man3/lseek64.3:153
msgid ""
"Since glibc 2.28, this function symbol is no longer available to newly "
"linked applications."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:153
#, no-wrap
msgid "_llseek()"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:158
msgid ""
"On 32-bit architectures, this is the system call that is used (by the C "
"library wrapper functions)  to implement all of the above functions.  The "
"prototype is:"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:163
#, no-wrap
msgid ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:168
msgid "For more details, see B<llseek>(2)."
msgstr ""

#.  In arch/x86/entry/syscalls/syscall_32.tbl,
#.  we see the following line:
#
#.     140     i386    _llseek                 sys_llseek
#
#.  This is essentially telling us that 'sys_llseek' (the name generated
#.  by SYSCALL_DEFINE5(llseek...)) is exposed to user-space as system call
#.  number 140, and that system call number will (IIUC) be exposed in
#.  autogenerated headers with the name "__NR__llseek" (i.e., "_llseek").
#.  The "i386" is telling us that this happens in i386 (32-bit Intel).
#.  There is nothing equivalent on x86-64, because 64 bit systems don't
#.  need an _llseek system call.
#. type: Plain text
#: build/C/man3/lseek64.3:187
msgid ""
"64-bit systems don't need an B<_llseek>()  system call.  Instead, they have "
"an B<lseek>(2)  system call that supports 64-bit file offsets."
msgstr ""

#. type: tbl table
#: build/C/man3/lseek64.3:197
#, no-wrap
msgid "B<lseek64>()"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:218
msgid ""
"B<lseek64>()  is one of the functions that was specified in the Large File "
"Summit (LFS)  specification that was completed in 1996.  The purpose of the "
"specification was to provide transitional support that allowed applications "
"on 32-bit systems to access files whose size exceeds that which can be "
"represented with a 32-bit I<off_t> type.  As noted above, this symbol is "
"exposed by header files if the B<_LARGEFILE64_SOURCE> feature test macro is "
"defined.  ALternatively, on a 32-bit system, the symbol I<lseek> is aliased "
"to I<lseek64> if the macro B<_FILE_OFFSET_BITS> is defined with the value "
"64."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:221
msgid "B<llseek>(2), B<lseek>(2)"
msgstr ""

#. type: TH
#: build/C/man2/open.2:51
#, no-wrap
msgid "OPEN"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:54
msgid "open, openat, creat - open and possibly create a file"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:59
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:62
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:64
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:68
#, no-wrap
msgid ""
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int "
">I<flags>B<);>\n"
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<, "
"mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:72
#, no-wrap
msgid ""
"/* Documented separately, in B<openat2>(2): */\n"
"B<int openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            const struct open_how *>I<how>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:80
msgid "B<openat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:104
msgid ""
"The B<open>()  system call opens the file specified by I<pathname>.  If the "
"specified file does not exist, it may optionally (if B<O_CREAT> is specified "
"in I<flags>)  be created by B<open>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:113
msgid ""
"The return value of B<open>()  is a file descriptor, a small, nonnegative "
"integer that is used in subsequent system calls (B<read>(2), B<write>(2), "
"B<lseek>(2), B<fcntl>(2), etc.) to refer to the open file.  The file "
"descriptor returned by a successful call will be the lowest-numbered file "
"descriptor not currently open for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:125
msgid ""
"By default, the new file descriptor is set to remain open across an "
"B<execve>(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in "
"B<fcntl>(2)  is initially disabled); the B<O_CLOEXEC> flag, described below, "
"can be used to change this default.  The file offset is set to the beginning "
"of the file (see B<lseek>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:138
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  The open file description records the file "
"offset and the file status flags (see below).  A file descriptor is a "
"reference to an open file description; this reference is unaffected if "
"I<pathname> is subsequently removed or modified to refer to a different "
"file.  For further details on open file descriptions, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:146
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file "
"read-only, write-only, or read/write, respectively."
msgstr ""

#.  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  I raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/64/focus=67
#.  TC1 (balloted in 2013), resolved this, so that those three constants
#.  are also categorized" as file status flags.
#. type: Plain text
#: build/C/man2/open.2:186
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CLOEXEC>, "
"B<O_CREAT>, B<O_DIRECTORY>, B<O_EXCL>, B<O_NOCTTY>, B<O_NOFOLLOW>, "
"B<O_TMPFILE>, and B<O_TRUNC>.  The I<file status flags> are all of the "
"remaining flags listed below.  The distinction between these two groups of "
"flags is that the file creation flags affect the semantics of the open "
"operation itself, while the file status flags affect the semantics of "
"subsequent I/O operations.  The file status flags can be retrieved and (in "
"some cases)  modified; see B<fcntl>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:188
msgid "The full list of file creation flags and file status flags is as follows:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:188
#, no-wrap
msgid "B<O_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:198
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  The "
"modification of the file offset and the write operation are performed as a "
"single atomic step."
msgstr ""

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
#: build/C/man2/open.2:208
msgid ""
"B<O_APPEND> may lead to corrupted files on NFS filesystems if more than one "
"process appends data to a file at once.  This is because NFS does not "
"support appending to a file, so the client kernel has to simulate it, which "
"can't be done without a race condition."
msgstr ""

#. type: TP
#: build/C/man2/open.2:208
#, no-wrap
msgid "B<O_ASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:222
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is available only for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details.  See also BUGS, below."
msgstr ""

#. type: TP
#: build/C/man2/open.2:222
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.23)"
msgstr ""

#.  NOTE! several other man pages refer to this text
#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX proposes to fix many APIs that provide hidden FDs
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=368
#. type: Plain text
#: build/C/man2/open.2:236
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag."
msgstr ""

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, file descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
#: build/C/man2/open.2:265
msgid ""
"Note that the use of this flag is essential in some multithreaded programs, "
"because using a separate B<fcntl>(2)  B<F_SETFD> operation to set the "
"B<FD_CLOEXEC> flag does not suffice to avoid race conditions where one "
"thread opens a file descriptor and attempts to set its close-on-exec flag "
"using B<fcntl>(2)  at the same time as another thread does a B<fork>(2)  "
"plus B<execve>(2).  Depending on the order of execution, the race may lead "
"to the file descriptor returned by B<open>()  being unintentionally leaked "
"to the program executed by the child process created by B<fork>(2).  (This "
"kind of race is in principle possible for any system call that creates a "
"file descriptor whose close-on-exec flag should be set, and various other "
"Linux system calls provide an equivalent of the B<O_CLOEXEC> flag to deal "
"with this problem.)"
msgstr ""

#. type: TP
#: build/C/man2/open.2:265
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:270
msgid "If I<pathname> does not exist, create it as a regular file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:273
msgid ""
"The owner (user ID) of the new file is set to the effective user ID of the "
"process."
msgstr ""

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
#: build/C/man2/open.2:289
msgid ""
"The group ownership (group ID) of the new file is set either to the "
"effective group ID of the process (System V semantics)  or to the group ID "
"of the parent directory (BSD semantics).  On Linux, the behavior depends on "
"whether the set-group-ID mode bit is set on the parent directory: if that "
"bit is set, then BSD semantics apply; otherwise, System V semantics apply.  "
"For some filesystems, the behavior also depends on the I<bsdgroups> and "
"I<sysvgroups> mount options described in B<mount>(8)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:314
msgid ""
"The I<mode> argument specifies the file mode bits to be applied when a new "
"file is created.  If neither B<O_CREAT> nor B<O_TMPFILE> is specified in "
"I<flags>, then I<mode> is ignored (and can thus be specified as 0, or simply "
"omitted).  The I<mode> argument B<must> be supplied if B<O_CREAT> or "
"B<O_TMPFILE> is specified in I<flags>; if it is not supplied, some arbitrary "
"bytes from the stack will be applied as the file mode."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:320
msgid ""
"The effective mode is modified by the process's I<umask> in the usual way: "
"in the absence of a default ACL, the mode of the created file is I<(mode\\ "
"&\\ \\(tiumask)>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:328
msgid ""
"Note that I<mode> applies only to future accesses of the newly created file; "
"the B<open>()  call that creates a read-only file may well return a "
"read/write file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:331
msgid "The following symbolic constants are provided for I<mode>:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:332
#, no-wrap
msgid "B<S_IRWXU>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:335
msgid "00700 user (file owner) has read, write, and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:335
#, no-wrap
msgid "B<S_IRUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:338
msgid "00400 user has read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:338
#, no-wrap
msgid "B<S_IWUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:341
msgid "00200 user has write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:341
#, no-wrap
msgid "B<S_IXUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:344
msgid "00100 user has execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:344
#, no-wrap
msgid "B<S_IRWXG>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:347
msgid "00070 group has read, write, and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:347
#, no-wrap
msgid "B<S_IRGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:350
msgid "00040 group has read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:350
#, no-wrap
msgid "B<S_IWGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:353
msgid "00020 group has write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:353
#, no-wrap
msgid "B<S_IXGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:356
msgid "00010 group has execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:356
#, no-wrap
msgid "B<S_IRWXO>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:359
msgid "00007 others have read, write, and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:359
#, no-wrap
msgid "B<S_IROTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:362
msgid "00004 others have read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:362
#, no-wrap
msgid "B<S_IWOTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:365
msgid "00002 others have write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:365
#, no-wrap
msgid "B<S_IXOTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:368
msgid "00001 others have execute permission"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:375
msgid ""
"According to POSIX, the effect when other bits are set in I<mode> is "
"unspecified.  On Linux, the following bits are also honored in I<mode>:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:376
#, no-wrap
msgid "B<S_ISUID>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:379
msgid "0004000 set-user-ID bit"
msgstr ""

#. type: TP
#: build/C/man2/open.2:379
#, no-wrap
msgid "B<S_ISGID>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:383
msgid "0002000 set-group-ID bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:383
#, no-wrap
msgid "B<S_ISVTX>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:387
msgid "0001000 sticky bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:388
#, no-wrap
msgid "B<O_DIRECT> (since Linux 2.4.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:405
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly "
"to/from user-space buffers.  The B<O_DIRECT> flag on its own makes an effort "
"to transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> flag that data and necessary metadata are transferred.  To "
"guarantee synchronous I/O, B<O_SYNC> must be used in addition to "
"B<O_DIRECT>.  See NOTES below for further discussion."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:409
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:409
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr ""

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
#: build/C/man2/open.2:421
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag was "
"added in kernel version 2.1.126, to avoid denial-of-service problems if "
"B<opendir>(3)  is called on a FIFO or tape device."
msgstr ""

#. type: TP
#: build/C/man2/open.2:421
#, no-wrap
msgid "B<O_DSYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:427
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<data> integrity completion."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:439
msgid ""
"By the time B<write>(2)  (and similar)  return, the output data has been "
"transferred to the underlying hardware, along with any file metadata that "
"would be required to retrieve that data (i.e., as though each B<write>(2)  "
"was followed by a call to B<fdatasync>(2)).  I<See NOTES below>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:439
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:450
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"fails with the error B<EEXIST>."
msgstr ""

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
#: build/C/man2/open.2:458
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:474
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:496
msgid ""
"On NFS, B<O_EXCL> is supported only when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same filesystem (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If B<link>(2)  "
"returns 0, the lock is successful.  Otherwise, use B<stat>(2)  on the unique "
"file to check if its link count has increased to 2, in which case the lock "
"is also successful."
msgstr ""

#. type: TP
#: build/C/man2/open.2:496
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:518
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:518
#, no-wrap
msgid "B<O_NOATIME> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:525
msgid ""
"Do not update the file last access time (I<st_atime> in the inode)  when the "
"file is B<read>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:527
msgid "This flag can be employed only if one of the following conditions is true:"
msgstr ""

#.  Strictly speaking: the filesystem UID
#. type: Plain text
#: build/C/man2/open.2:532
msgid "The effective UID of the process matches the owner UID of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:537
msgid ""
"The calling process has the B<CAP_FOWNER> capability in its user namespace "
"and the owner UID of the file has a mapping in the namespace."
msgstr ""

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
#: build/C/man2/open.2:545
msgid ""
"This flag is intended for use by indexing or backup programs, where its use "
"can significantly reduce the amount of disk activity.  This flag may not be "
"effective on all filesystems.  One example is NFS, where the server "
"maintains the access time."
msgstr ""

#. type: TP
#: build/C/man2/open.2:545
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:553
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(emit will not "
"become the process's controlling terminal even if the process does not have "
"one."
msgstr ""

#. type: TP
#: build/C/man2/open.2:553
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:566
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a symbolic "
"link, then the open fails, with the error B<ELOOP>.  Symbolic links in "
"earlier components of the pathname will still be followed.  (Note that the "
"B<ELOOP> error that can occur in this case is indistinguishable from the "
"case where an open fails because there are too many symbolic links found "
"while resolving components in the prefix part of the pathname.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:569
msgid ""
"This flag is a FreeBSD extension, which was added to Linux in version "
"2.1.126, and has subsequently been standardized in POSIX.1-2008."
msgstr ""

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
#: build/C/man2/open.2:576
msgid "See also B<O_PATH> below."
msgstr ""

#. type: TP
#: build/C/man2/open.2:576
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:583
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the "
"B<open>()  nor any subsequent I/O operations on the file descriptor which is "
"returned will cause the calling process to wait."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:597
msgid ""
"Note that the setting of this flag has no effect on the operation of "
"B<poll>(2), B<select>(2), B<epoll>(7), and similar, since those interfaces "
"merely inform the caller about whether a file descriptor is \"ready\", "
"meaning that an I/O operation performed on the file descriptor with the "
"B<O_NONBLOCK> flag I<clear> would not block."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:608
msgid ""
"Note that this flag has no effect for regular files and block devices; that "
"is, I/O operations will (briefly) block when device activity is required, "
"regardless of whether B<O_NONBLOCK> is set.  Since B<O_NONBLOCK> semantics "
"might eventually be implemented, applications should not depend upon "
"blocking behavior when specifying this flag for regular files and block "
"devices."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:615
msgid ""
"For the handling of FIFOs (named pipes), see also B<fifo>(7).  For a "
"discussion of the effect of B<O_NONBLOCK> in conjunction with mandatory file "
"locks and with file leases, see B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:615
#, no-wrap
msgid "B<O_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 1abf0c718f15a56a0a435588d1b104c7a37dc9bd
#.  commit 326be7b484843988afe57566b627fb7a70beac56
#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#
#.  http://thread.gmane.org/gmane.linux.man/2790/focus=3496
#. 	Subject: Re: [PATCH] open(2): document O_PATH
#. 	Newsgroups: gmane.linux.man, gmane.linux.kernel
#. type: Plain text
#: build/C/man2/open.2:638
msgid ""
"Obtain a file descriptor that can be used for two purposes: to indicate a "
"location in the filesystem tree and to perform operations that act purely at "
"the file descriptor level.  The file itself is not opened, and other file "
"operations (e.g., B<read>(2), B<write>(2), B<fchmod>(2), B<fchown>(2), "
"B<fgetxattr>(2), B<ioctl>(2), B<mmap>(2))  fail with the error B<EBADF>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:642
msgid ""
"The following operations I<can> be performed on the resulting file "
"descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:645
msgid "B<close>(2)."
msgstr ""

#.  commit 332a2e1244bd08b9e3ecd378028513396a004a24
#. type: Plain text
#: build/C/man2/open.2:650
msgid ""
"B<fchdir>(2), if the file descriptor refers to a directory (since Linux "
"3.5)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:653
msgid "B<fstat>(2)  (since Linux 3.6)."
msgstr ""

#.  fstat(): commit 55815f70147dcfa3ead5738fd56d3574e2e3c1c2
#.  fstatfs(): commit 9d05746e7b16d8565dddbe3200faa1e669d23bbf
#. type: Plain text
#: build/C/man2/open.2:658
msgid "B<fstatfs>(2)  (since Linux 3.12)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:664
msgid "Duplicating the file descriptor (B<dup>(2), B<fcntl>(2)  B<F_DUPFD>, etc.)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:670
msgid ""
"Getting and setting file descriptor flags (B<fcntl>(2)  B<F_GETFD> and "
"B<F_SETFD>)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:676
msgid ""
"Retrieving open file status flags using the B<fcntl>(2)  B<F_GETFL> "
"operation: the returned flags will include the bit B<O_PATH>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:689
msgid ""
"Passing the file descriptor as the I<dirfd> argument of B<openat>()  and the "
"other \"*at()\" system calls.  This includes B<linkat>(2)  with "
"B<AT_EMPTY_PATH> (or via procfs using B<AT_SYMLINK_FOLLOW>)  even if the "
"file is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:695
msgid ""
"Passing the file descriptor to another process via a UNIX domain socket (see "
"B<SCM_RIGHTS> in B<unix>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:707
msgid ""
"When B<O_PATH> is specified in I<flags>, flag bits other than B<O_CLOEXEC>, "
"B<O_DIRECTORY>, and B<O_NOFOLLOW> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:725
msgid ""
"Opening a file or directory with the B<O_PATH> flag requires no permissions "
"on the object itself (but does require execute permission on the directories "
"in the path prefix).  Depending on the subsequent operation, a check for "
"suitable file permissions may be performed (e.g., B<fchdir>(2)  requires "
"execute permission on the directory referred to by its file descriptor "
"argument).  By contrast, obtaining a reference to a filesystem object by "
"opening it with the B<O_RDONLY> flag requires that the caller have read "
"permission on the object, even when the subsequent operation (e.g., "
"B<fchdir>(2), B<fstat>(2))  does not require read permission on the object."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:741
msgid ""
"If I<pathname> is a symbolic link and the B<O_NOFOLLOW> flag is also "
"specified, then the call returns a file descriptor referring to the symbolic "
"link.  This file descriptor can be used as the I<dirfd> argument in calls to "
"B<fchownat>(2), B<fstatat>(2), B<linkat>(2), and B<readlinkat>(2)  with an "
"empty pathname to have the calls operate on the symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:751
msgid ""
"If I<pathname> refers to an automount point that has not yet been triggered, "
"so no other filesystem is mounted on it, then the call returns a file "
"descriptor referring to the automount directory without triggering a mount.  "
"B<fstatfs>(2)  can then be used to determine if it is, in fact, an "
"untriggered automount point (B<.f_type == AUTOFS_SUPER_MAGIC>)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:760
msgid ""
"One use of B<O_PATH> for regular files is to provide the equivalent of "
"POSIX.1's B<O_EXEC> functionality.  This permits us to open a file for which "
"we have execute permission but not read permission, and then execute that "
"file, with steps something like the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:767
#, no-wrap
msgid ""
"char buf[PATH_MAX];\n"
"fd = open(\"some_prog\", O_PATH);\n"
"snprintf(buf, PATH_MAX, \"/proc/self/fd/%d\", fd);\n"
"execl(buf, \"some_prog\", (char *) NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:774
msgid ""
"An B<O_PATH> file descriptor can also be passed as the argument of "
"B<fexecve>(3)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:774
#, no-wrap
msgid "B<O_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:786
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<file> integrity completion (by contrast with the "
"synchronized I/O I<data> integrity completion provided by B<O_DSYNC>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:797
msgid ""
"By the time B<write>(2)  (or similar)  returns, the output data and "
"associated file metadata have been transferred to the underlying hardware "
"(i.e., as though each B<write>(2)  was followed by a call to B<fsync>(2)).  "
"I<See NOTES below>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:797
#, no-wrap
msgid "B<O_TMPFILE> (since Linux 3.11)"
msgstr ""

#.  commit 60545d0d4610b02e55f65d141c95b18ccf855b6e
#.  commit f4e0c30c191f87851c4a53454abb55ee276f4a7e
#.  commit bb458c644a59dbba3a1fe59b27106c5e68e1c4bd
#. type: Plain text
#: build/C/man2/open.2:809
msgid ""
"Create an unnamed temporary regular file.  The I<pathname> argument "
"specifies a directory; an unnamed inode will be created in that directory's "
"filesystem.  Anything written to the resulting file will be lost when the "
"last file descriptor is closed, unless the file is given a name."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:823
msgid ""
"B<O_TMPFILE> must be specified with one of B<O_RDWR> or B<O_WRONLY> and, "
"optionally, B<O_EXCL>.  If B<O_EXCL> is not specified, then B<linkat>(2)  "
"can be used to link the temporary file into the filesystem, making it "
"permanent, using code like the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:829
#, no-wrap
msgid ""
"char path[PATH_MAX];\n"
"fd = open(\"/path/to/dir\", O_TMPFILE | O_RDWR,\n"
"                        S_IRUSR | S_IWUSR);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:831
#, no-wrap
msgid "/* File I/O on \\(aqfd\\(aq... */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:833
#, no-wrap
msgid "linkat(fd, NULL, AT_FDCWD, \"/path/for/file\", AT_EMPTY_PATH);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:838
#, no-wrap
msgid ""
"/* If the caller doesn\\(aqt have the CAP_DAC_READ_SEARCH\n"
"   capability (needed to use AT_EMPTY_PATH with linkat(2)),\n"
"   and there is a proc(5) filesystem mounted, then the\n"
"   linkat(2) call above can be replaced with:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:843
#, no-wrap
msgid ""
"snprintf(path, PATH_MAX,  \"/proc/self/fd/%d\", fd);\n"
"linkat(AT_FDCWD, path, AT_FDCWD, \"/path/for/file\",\n"
"                        AT_SYMLINK_FOLLOW);\n"
"*/\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:852
msgid ""
"In this case, the B<open>()  I<mode> argument determines the file permission "
"mode, as with B<O_CREAT>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:864
msgid ""
"Specifying B<O_EXCL> in conjunction with B<O_TMPFILE> prevents a temporary "
"file from being linked into the filesystem in the above manner.  (Note that "
"the meaning of B<O_EXCL> in this case is different from the meaning of "
"B<O_EXCL> otherwise.)"
msgstr ""

#.  Inspired by http://lwn.net/Articles/559147/
#. type: Plain text
#: build/C/man2/open.2:868
msgid "There are two main use cases for B<O_TMPFILE>:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:877
msgid ""
"Improved B<tmpfile>(3)  functionality: race-free creation of temporary files "
"that (1) are automatically deleted when closed; (2) can never be reached via "
"any pathname; (3) are not subject to symlink attacks; and (4) do not require "
"the caller to devise unique names."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:888
msgid ""
"Creating a file that is initially invisible, which is then populated with "
"data and adjusted to have appropriate filesystem attributes (B<fchown>(2), "
"B<fchmod>(2), B<fsetxattr>(2), etc.)  before being atomically linked into "
"the filesystem in a fully formed state (using B<linkat>(2)  as described "
"above)."
msgstr ""

#.  To check for support, grep for "tmpfile" in kernel sources
#.  commit 99b6436bc29e4f10e4388c27a3e4810191cc4788
#.  commit ab29743117f9f4c22ac44c13c1647fb24fb2bafe
#.  commit ef3b9af50bfa6a1f02cd7b3f5124b712b1ba3e3c
#.  commit 50732df02eefb39ab414ef655979c2c9b64ad21c
#. type: Plain text
#: build/C/man2/open.2:905
msgid ""
"B<O_TMPFILE> requires support by the underlying filesystem; only a subset of "
"Linux filesystems provide that support.  In the initial implementation, "
"support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem "
"filesystems.  Support for other filesystems has subsequently been added as "
"follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs "
"(Linux 4.9)"
msgstr ""

#. type: TP
#: build/C/man2/open.2:905
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:919
msgid ""
"If the file already exists and is a regular file and the access mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise, the effect of B<O_TRUNC> is unspecified."
msgstr ""

#. type: SS
#: build/C/man2/open.2:919
#, no-wrap
msgid "creat()"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:928
msgid ""
"A call to B<creat>()  is equivalent to calling B<open>()  with I<flags> "
"equal to B<O_CREAT|O_WRONLY|O_TRUNC>."
msgstr ""

#. type: SS
#: build/C/man2/open.2:928
#, no-wrap
msgid "openat()"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:934
msgid ""
"The B<openat>()  system call operates in exactly the same way as B<open>(), "
"except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:944
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<open>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:956
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<open>())."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:963 build/C/man2/readlink.2:135
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: SS
#: build/C/man2/open.2:963
#, no-wrap
msgid "openat2(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:972
msgid ""
"The B<openat2>(2)  system call is an extension of B<openat>(), and provides "
"a superset of the features of B<openat>().  It is documented separately, in "
"B<openat2>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:982
msgid ""
"B<open>(), B<openat>(), and B<creat>()  return the new file descriptor (a "
"nonnegative integer), or -1 if an error occurred (in which case, I<errno> is "
"set appropriately)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:988
msgid "B<open>(), B<openat>(), and B<creat>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:997
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""

#.  commit 30aba6656f61ed44cba445a3c0d38b296fa9e8f5
#. type: Plain text
#: build/C/man2/open.2:1016
msgid ""
"Where B<O_CREAT> is specified, the I<protected_fifos> or "
"I<protected_regular> sysctl is enabled, the file already exists and is a "
"FIFO or regular file, the owner of the file is neither the current user nor "
"the owner of the containing directory, and the containing directory is both "
"world- or group-writable and sticky.  For details, see the descriptions of "
"I</proc/sys/fs/protected_fifos> and I</proc/sys/fs/protected_regular> in "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1016 build/C/man2/rename.2:328 build/C/man2/rmdir.2:55 build/C/man2/unlink.2:169
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1024
msgid ""
"B<O_EXCL> was specified in I<flags> and I<pathname> refers to a block device "
"that is in use by the system (e.g., it is mounted)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1030
msgid ""
"Where B<O_CREAT> is specified, the file does not exist, and the user's quota "
"of disk blocks or inodes on the filesystem has been exhausted."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1036
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1040 build/C/man2/rmdir.2:67 build/C/man2/unlink.2:182
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1040 build/C/man2/write.2:174
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1044
msgid "See B<EOVERFLOW>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1044 build/C/man2/read.2:131 build/C/man3/scanf.3:571 build/C/man3/tmpfile.3:63 build/C/man2/write.2:179
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1051
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1059
msgid ""
"The filesystem does not support the B<O_DIRECT> flag.  See B<NOTES> for more "
"information."
msgstr ""

#.  In particular, __O_TMPFILE instead of O_TMPFILE
#. type: Plain text
#: build/C/man2/open.2:1064
msgid "Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1074
msgid ""
"B<O_TMPFILE> was specified in I<flags>, but neither B<O_WRONLY> nor "
"B<O_RDWR> was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1083
msgid ""
"B<O_CREAT> was specified in I<flags> and the final component (\"basename\") "
"of the new file's I<pathname> is invalid (e.g., it contains characters not "
"permitted by the underlying filesystem)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1089
msgid ""
"The final component (\"basename\") of I<pathname> is invalid (e.g., it "
"contains characters not permitted by the underlying filesystem)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1089 build/C/man2/open.2:1098 build/C/man2/read.2:176 build/C/man2/rename.2:355 build/C/man2/unlink.2:185 build/C/man2/unlink.2:261
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1098
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1112
msgid ""
"I<pathname> refers to an existing directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1116 build/C/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1125
msgid ""
"I<pathname> was a symbolic link, and I<flags> specified B<O_NOFOLLOW> but "
"not B<O_PATH>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1125 build/C/man2/pipe.2:180 build/C/man3/tmpfile.3:67
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1132
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1136 build/C/man2/rmdir.2:80 build/C/man2/unlink.2:197
msgid "I<pathname> was too long."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1136 build/C/man2/pipe.2:183 build/C/man2/pipe.2:186 build/C/man3/tmpfile.3:70
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1139 build/C/man2/pipe.2:186 build/C/man3/tmpfile.3:73
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1139
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1146
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1150
msgid "B<O_CREAT> is not set and the named file does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1155 build/C/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1169
msgid ""
"I<pathname> refers to a nonexistent directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1176
msgid ""
"The named file is a FIFO, but memory for the FIFO buffer can't be allocated "
"because the per-user hard limit on memory allocation for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1185
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1192
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1197
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO, and no process "
"has the FIFO open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1200
msgid "The file is a device special file and no corresponding device exists."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1203
msgid "The file is a UNIX domain socket."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1203 build/C/man2/open_by_handle_at.2:332 build/C/man2/readv.2:313
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1209
msgid "The filesystem containing I<pathname> does not support B<O_TMPFILE>."
msgstr ""

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
#: build/C/man2/open.2:1229
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds "
"I<(1E<lt>E<lt>31)-1> bytes; see also B<O_LARGEFILE> above.  This is the "
"error specified by POSIX.1; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr ""

#.  Strictly speaking, it's the filesystem UID... (MTK)
#. type: Plain text
#: build/C/man2/open.2:1236
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1240 build/C/man2/write.2:231
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1245
msgid ""
"I<pathname> refers to a file on a read-only filesystem and write access was "
"requested."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1245 build/C/man2/open.2:1250 build/C/man2/open.2:1256
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1250
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1256
msgid ""
"I<pathname> refers to a file that is currently in use as a swap file, and "
"the B<O_TRUNC> flag was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1261
msgid ""
"I<pathname> refers to a file that is currently being read by the kernel "
"(e.g., for module/firmware loading), and write access was requested."
msgstr ""

#. type: TP
#: build/C/man2/open.2:1261
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1268
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1271
msgid "The following additional errors can occur for B<openat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1275 build/C/man2/readlink.2:212 build/C/man2/unlink.2:257
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1281
msgid ""
"I<pathname> is a relative pathname and I<dirfd> is a file descriptor "
"referring to a file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1285
msgid ""
"B<openat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1289
msgid "B<open>(), B<creat>()  SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1292
msgid "B<openat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1295
msgid "B<openat2>(2)  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1306
msgid ""
"The B<O_DIRECT>, B<O_NOATIME>, B<O_PATH>, and B<O_TMPFILE> flags are "
"Linux-specific.  One must define B<_GNU_SOURCE> to obtain their definitions."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1321
msgid ""
"The B<O_CLOEXEC>, B<O_DIRECTORY>, and B<O_NOFOLLOW> flags are not specified "
"in POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12, one "
"can obtain their definitions by defining either B<_POSIX_C_SOURCE> with a "
"value greater than or equal to 200809L or B<_XOPEN_SOURCE> with a value "
"greater than or equal to 700.  In glibc 2.11 and earlier, one obtains the "
"definitions by defining B<_GNU_SOURCE>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1332
msgid ""
"As noted in B<feature_test_macros>(7), feature test macros such as "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, and B<_GNU_SOURCE> must be defined "
"before including I<any> header files."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1341
msgid ""
"Under Linux, the B<O_NONBLOCK> flag is sometimes used in cases where one "
"wants to open but does not necessarily have the intention to read or write.  "
"For example, this may be used to open a device in order to get a file "
"descriptor for use with B<ioctl>(2)."
msgstr ""

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
#: build/C/man2/open.2:1352
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1360
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1383
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"I<st_ctime> and I<st_mtime> fields are set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1394
msgid ""
"The files in the I</proc/[pid]/fd> directory show the open file descriptors "
"of the process with the PID I<pid>.  The files in the I</proc/[pid]/fdinfo> "
"directory show even more information about these file descriptors.  See "
"B<proc>(5)  for further details of both of these directories."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1404
msgid ""
"The Linux header file B<E<lt>asm/fcntl.hE<gt>> doesn't define B<O_ASYNC>; "
"the (BSD-derived)  B<FASYNC> synonym is defined instead."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1404
#, no-wrap
msgid "Open file descriptions"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1412
msgid ""
"The term open file description is the one used by POSIX to refer to the "
"entries in the system-wide table of open files.  In other contexts, this "
"object is variously also called an \"open file object\", a \"file handle\", "
"an \"open file table entry\", or\\(emin kernel-developer parlance\\(ema "
"I<struct file>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1425
msgid ""
"When a file descriptor is duplicated (using B<dup>(2)  or similar), the "
"duplicate refers to the same open file description as the original file "
"descriptor, and the two file descriptors consequently share the file offset "
"and file status flags.  Such sharing can also occur between processes: a "
"child process created via B<fork>(2)  inherits duplicates of its parent's "
"file descriptors, and those duplicates refer to the same open file "
"descriptions."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1431
msgid ""
"Each B<open>()  of a file creates a new open file description; thus, there "
"may be multiple open file descriptions corresponding to a file inode."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1440
msgid ""
"On Linux, one can use the B<kcmp>(2)  B<KCMP_FILE> operation to test whether "
"two file descriptors (in the same process or in two different processes)  "
"refer to the same open file description."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1440
#, no-wrap
msgid "Synchronized I/O"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1455
msgid ""
"The POSIX.1-2008 \"synchronized I/O\" option specifies different variants of "
"synchronized I/O, and specifies the B<open>()  flags B<O_SYNC>, B<O_DSYNC>, "
"and B<O_RSYNC> for controlling the behavior.  Regardless of whether an "
"implementation supports this option, it must at least support the use of "
"B<O_SYNC> for regular files."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1470
msgid ""
"Linux implements B<O_SYNC> and B<O_DSYNC>, but not B<O_RSYNC>.  Somewhat "
"incorrectly, glibc defines B<O_RSYNC> to have the same value as B<O_SYNC>.  "
"(B<O_RSYNC> is defined in the Linux header file I<E<lt>asm/fcntl.hE<gt>> on "
"HP PA-RISC, but it is not used.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1488
msgid ""
"B<O_SYNC> provides synchronized I/O I<file> integrity completion, meaning "
"write operations will flush data and all associated metadata to the "
"underlying hardware.  B<O_DSYNC> provides synchronized I/O I<data> integrity "
"completion, meaning write operations will flush data to the underlying "
"hardware, but will only flush metadata updates that are required to allow a "
"subsequent read operation to complete successfully.  Data integrity "
"completion can reduce the number of disk operations that are required for "
"applications that don't need the guarantees of file integrity completion."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1505
msgid ""
"To understand the difference between the two types of completion, consider "
"two pieces of file metadata: the file last modification timestamp "
"(I<st_mtime>)  and the file length.  All write operations will update the "
"last file modification timestamp, but only writes that add data to the end "
"of the file will change the file length.  The last modification timestamp is "
"not needed to ensure that a read completes successfully, but the file length "
"is.  Thus, B<O_DSYNC> would only guarantee to flush updates to the file "
"length metadata (whereas B<O_SYNC> would also always flush the last "
"modification timestamp metadata)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1517
msgid ""
"Before Linux 2.6.33, Linux implemented only the B<O_SYNC> flag for "
"B<open>().  However, when that flag was specified, most filesystems actually "
"provided the equivalent of synchronized I/O I<data> integrity completion "
"(i.e., B<O_SYNC> was actually implemented as the equivalent of B<O_DSYNC>)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1535
msgid ""
"Since Linux 2.6.33, proper B<O_SYNC> support is provided.  However, to "
"ensure backward binary compatibility, B<O_DSYNC> was defined with the same "
"value as the historical B<O_SYNC>, and B<O_SYNC> was defined as a new "
"(two-bit) flag value that includes the B<O_DSYNC> flag value.  This ensures "
"that applications compiled against new headers get at least B<O_DSYNC> "
"semantics on pre-2.6.33 kernels."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1535 build/C/man2/readv.2:358
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1546
msgid ""
"Since version 2.26, the glibc wrapper function for B<open>()  employs the "
"B<openat>()  system call, rather than the kernel's B<open>()  system call.  "
"For certain architectures, this is also true in glibc versions before 2.26."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1546
#, no-wrap
msgid "NFS"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1550
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1565
msgid ""
"On NFS filesystems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1565
#, no-wrap
msgid "FIFOs"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1573
msgid ""
"Opening the read or write end of a FIFO blocks until the other end is also "
"opened (by another process or thread).  See B<fifo>(7)  for further details."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1573
#, no-wrap
msgid "File access mode"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1588
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR> do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>."
msgstr ""

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
#: build/C/man2/open.2:1605
msgid ""
"Linux reserves the special, nonstandard access mode 3 (binary 11) in "
"I<flags> to mean: check for read and write permission on the file and return "
"a file descriptor that can't be used for reading or writing.  This "
"nonstandard access mode is used by some Linux drivers to return a file "
"descriptor that is to be used only for device-specific B<ioctl>(2)  "
"operations."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1605
#, no-wrap
msgid "Rationale for openat() and other directory file descriptor APIs"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1638
msgid ""
"B<openat>()  and the other system calls and library functions that take a "
"directory file descriptor argument (i.e., B<execveat>(2), B<faccessat>(2), "
"B<fanotify_mark>(2), B<fchmodat>(2), B<fchownat>(2), B<fspick>(2), "
"B<fstatat>(2), B<futimesat>(2), B<linkat>(2), B<mkdirat>(2), "
"B<move_mount>(2), B<mknodat>(2), B<name_to_handle_at>(2), B<open_tree>(2), "
"B<openat2>(2), B<readlinkat>(2), B<renameat>(2), B<statx>(2), "
"B<symlinkat>(2), B<unlinkat>(2), B<utimensat>(2), B<mkfifoat>(3), and "
"B<scandirat>(3))  address two problems with the older interfaces that "
"preceded them.  Here, the explanation is in terms of the B<openat>()  call, "
"but the rationale is analogous for the other interfaces."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1672
msgid ""
"First, B<openat>()  allows an application to avoid race conditions that "
"could occur when using B<open>()  to open files in directories other than "
"the current working directory.  These race conditions result from the fact "
"that some component of the directory prefix given to B<open>()  could be "
"changed in parallel with the call to B<open>().  Suppose, for example, that "
"we wish to create the file I<dir1/dir2/xxx.dep> if the file I<dir1/dir2/xxx> "
"exists.  The problem is that between the existence check and the "
"file-creation step, I<dir1> or I<dir2> (which might be symbolic links)  "
"could be modified to point to a different location.  Such races can be "
"avoided by opening a file descriptor for the target directory, and then "
"specifying that file descriptor as the I<dirfd> argument of (say)  "
"B<fstatat>(2)  and B<openat>().  The use of the I<dirfd> file descriptor "
"also has other benefits:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1675
msgid ""
"the file descriptor is a stable reference to the directory, even if the "
"directory is renamed; and"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1679
msgid ""
"the open file descriptor prevents the underlying filesystem from being "
"dismounted, just as when a process has a current working directory on a "
"filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1688
msgid ""
"Second, B<openat>()  allows the implementation of a per-thread \"current "
"working directory\", via file descriptor(s) maintained by the application.  "
"(This functionality can also be obtained by tricks based on the use of "
"I</proc/self/fd/>dirfd, but less efficiently.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1704
msgid ""
"The I<dirfd> argument for these APIs can be obtained by using B<open>()  or "
"B<openat>()  to open a directory (with either the B<O_RDONLY> or the "
"B<O_PATH> flag).  Alternatively, such a file descriptor can be obtained by "
"applying B<dirfd>(3)  to a directory stream created using B<opendir>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1718
msgid ""
"When these APIs are given a I<dirfd> argument of B<AT_FDCWD> or the "
"specified pathname is absolute, then they handle their pathname argument in "
"the same way as the corresponding conventional APIs.  However, in this case, "
"several of the APIs have a I<flags> argument that provides access to "
"functionality that is not available with the corresponding conventional "
"APIs."
msgstr ""

#. type: SS
#: build/C/man2/open.2:1718
#, no-wrap
msgid "O_DIRECT"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1734
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of user-space buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by filesystem and kernel version and might be "
"absent entirely.  However there is currently no filesystem-independent "
"interface for an application to discover these restrictions for a given file "
"or filesystem.  Some filesystems provide their own interfaces for doing so, "
"for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1744
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the "
"filesystem.  Since Linux 2.6.0, alignment to the logical block size of the "
"underlying storage (typically 512 bytes) suffices.  The logical block size "
"can be determined using the B<ioctl>(2)  B<BLKSSZGET> operation or from the "
"shell using the command:"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1748
#, no-wrap
msgid "blockdev --getss\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1784
msgid ""
"B<O_DIRECT> I/Os should never be run concurrently with the B<fork>(2)  "
"system call, if the memory buffer is a private mapping (i.e., any mapping "
"created with the B<mmap>(2)  B<MAP_PRIVATE> flag; this includes memory "
"allocated on the heap and statically allocated buffers).  Any such I/Os, "
"whether submitted via an asynchronous I/O interface or from another thread "
"in the process, should be completed before B<fork>(2)  is called.  Failure "
"to do so can result in data corruption and undefined behavior in parent and "
"child processes.  This restriction does not apply when the memory buffer for "
"the B<O_DIRECT> I/Os was created using B<shmat>(2)  or B<mmap>(2)  with the "
"B<MAP_SHARED> flag.  Nor does this restriction apply when the memory buffer "
"has been advised as B<MADV_DONTFORK> with B<madvise>(2), ensuring that it "
"will not be available to the child after B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1794
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1803
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some filesystems may not implement "
"the flag, in which case B<open>()  fails with the error B<EINVAL> if it is "
"used."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1814
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the filesystem correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1836
msgid ""
"The behavior of B<O_DIRECT> with NFS will differ from local filesystems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will bypass the page cache only on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1843
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
#: build/C/man2/open.2:1854
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1862
msgid ""
"One must check for two different error codes, B<EISDIR> and B<ENOENT>, when "
"trying to determine whether the kernel supports B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1876
msgid ""
"When both B<O_CREAT> and B<O_DIRECTORY> are specified in I<flags> and the "
"file specified by I<pathname> does not exist, B<open>()  will create a "
"regular file (i.e., B<O_DIRECTORY> is ignored)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:1901
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<open_by_handle_at>(2), "
"B<openat2>(2), B<read>(2), B<socket>(2), B<stat>(2), B<umask>(2), "
"B<unlink>(2), B<write>(2), B<fopen>(3), B<acl>(5), B<fifo>(7), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/openat2.2:24
#, no-wrap
msgid "OPENAT2"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:27
msgid "openat2 - open and possibly create a file (extended)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>linux/openat2.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:36
#, no-wrap
msgid ""
"B<long openat2(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<            struct open_how *>I<how>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:46
msgid ""
"The B<openat2>()  system call is an extension of B<openat>(2)  and provides "
"a superset of its functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:56
msgid ""
"The B<openat2>()  system call opens the file specified by I<pathname>.  If "
"the specified file does not exist, it may optionally (if B<O_CREAT> is "
"specified in I<how.flags>)  be created."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:80
msgid ""
"As with B<openat>(2), if I<pathname> is a relative pathname, then it is "
"interpreted relative to the directory referred to by the file descriptor "
"I<dirfd> (or the current working directory of the calling process, if "
"I<dirfd> is the special value B<AT_FDCWD>).  If I<pathname> is an absolute "
"pathname, then I<dirfd> is ignored (unless I<how.resolve> contains "
"B<RESOLVE_IN_ROOT>, in which case I<pathname> is resolved relative to "
"I<dirfd>)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:90
msgid ""
"Rather than taking a single I<flags> argument, an extensible structure "
"(I<how>) is passed to allow for future extensions.  The I<size> argument "
"must be specified as I<sizeof(struct open_how)>."
msgstr ""

#. type: SS
#: build/C/man2/openat2.2:90
#, no-wrap
msgid "The open_how structure"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:102
msgid ""
"The I<how> argument specifies how I<pathname> should be opened, and acts as "
"a superset of the I<flags> and I<mode> arguments to B<openat>(2).  This "
"argument is a pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:111
#, no-wrap
msgid ""
"struct open_how {\n"
"    u64 flags;    /* O_* flags */\n"
"    u64 mode;     /* Mode for O_{CREAT,TMPFILE} */\n"
"    u64 resolve;  /* RESOLVE_* flags */\n"
"    /* ... */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:126
msgid ""
"Any future extensions to B<openat2>()  will be implemented as new fields "
"appended to the above structure, with a zero value in a new field resulting "
"in the kernel behaving as though that extension field was not present.  "
"Therefore, the caller I<must> zero-fill this structure on initialization.  "
"(See the \"Extensibility\" section of the B<NOTES> for more detail on why "
"this is necessary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:130
msgid "The fields of the I<open_how> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:130
#, no-wrap
msgid "I<flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:141
msgid ""
"This field specifies the file creation and file status flags to use when "
"opening the file.  All of the B<O_*> flags defined for B<openat>(2)  are "
"valid B<openat2>()  flag values."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:150
msgid ""
"Whereas B<openat>(2)  ignores unknown bits in its I<flags> argument, "
"B<openat2>()  returns an error if unknown or conflicting flags are specified "
"in I<how.flags>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:150
#, no-wrap
msgid "I<mode>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:157
msgid ""
"This field specifies the mode for the new file, with identical semantics to "
"the I<mode> argument of B<openat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:180
msgid ""
"Whereas B<openat>(2)  ignores bits other than those in the range I<07777> in "
"its I<mode> argument, B<openat2>()  returns an error if I<how.mode> contains "
"bits other than I<07777>.  Similarly, an error is returned if B<openat2>()  "
"is called with a nonzero I<how.mode> and I<how.flags> does not contain "
"B<O_CREAT> or B<O_TMPFILE>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:180
#, no-wrap
msgid "I<resolve>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:190
msgid ""
"This is a bit-mask of flags that modify the way in which B<all> components "
"of I<pathname> will be resolved.  (See B<path_resolution>(7)  for background "
"information.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:196
msgid ""
"The primary use case for these flags is to allow trusted programs to "
"restrict how untrusted paths (or paths inside untrusted directories) are "
"resolved.  The full list of I<resolve> flags is as follows:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:197
#, no-wrap
msgid "B<RESOLVE_BENEATH>"
msgstr ""

#.  commit adb21d2b526f7f196b2f3fdca97d80ba05dd14a0
#. type: Plain text
#: build/C/man2/openat2.2:206
msgid ""
"Do not permit the path resolution to succeed if any component of the "
"resolution is not a descendant of the directory indicated by I<dirfd>.  This "
"causes absolute symbolic links (and absolute values of I<pathname>)  to be "
"rejected."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:212
msgid ""
"Currently, this flag also disables magic-link resolution (see below).  "
"However, this may change in the future.  Therefore, to ensure that magic "
"links are not resolved, the caller should explicitly specify "
"B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:212
#, no-wrap
msgid "B<RESOLVE_IN_ROOT>"
msgstr ""

#.  commit 8db52c7e7ee1bd861b6096fcafc0fe7d0f24a994
#. type: Plain text
#: build/C/man2/openat2.2:237
msgid ""
"Treat the directory referred to by I<dirfd> as the root directory while "
"resolving I<pathname>.  Absolute symbolic links are interpreted relative to "
"I<dirfd>.  If a prefix component of I<pathname> equates to I<dirfd>, then an "
"immediately following I<..\\&> component likewise equates to I<dirfd> (just "
"as I</..\\&> is traditionally equivalent to I</>).  If I<pathname> is an "
"absolute path, it is also interpreted relative to I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:248
msgid ""
"The effect of this flag is as though the calling process had used "
"B<chroot>(2)  to (temporarily) modify its root directory (to the directory "
"referred to by I<dirfd>).  However, unlike B<chroot>(2)  (which changes the "
"filesystem root permanently for a process), B<RESOLVE_IN_ROOT> allows a "
"program to efficiently restrict path resolution on a per-open basis."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:254
msgid ""
"Currently, this flag also disables magic-link resolution.  However, this may "
"change in the future.  Therefore, to ensure that magic links are not "
"resolved, the caller should explicitly specify B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:254
#, no-wrap
msgid "B<RESOLVE_NO_MAGICLINKS>"
msgstr ""

#.  commit 278121417a72d87fb29dd8c48801f80821e8f75a
#. type: Plain text
#: build/C/man2/openat2.2:258
msgid "Disallow all magic-link resolution during path resolution."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:268
msgid ""
"Magic links are symbolic link-like objects that are most notably found in "
"B<proc>(5); examples include I</proc/[pid]/exe> and I</proc/[pid]/fd/*>.  "
"(See B<symlink>(7)  for more details.)"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:271
msgid ""
"Unknowingly opening magic links can be risky for some applications.  "
"Examples of such risks include the following:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:272 build/C/man2/openat2.2:280 build/C/man2/openat2.2:507 build/C/man2/openat2.2:515 build/C/man2/openat2.2:528 build/C/man3/scanf.3:157 build/C/man3/scanf.3:163 build/C/man3/scanf.3:167 build/C/man3/scanf.3:186 build/C/man3/scanf.3:197 build/C/man3/scanf.3:208 build/C/man3/scanf.3:227 build/C/man3/scanf.3:239 build/C/man3/scanf.3:253
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:280
msgid ""
"If the process opening a pathname is a controlling process that currently "
"has no controlling terminal (see B<credentials>(7)), then opening a magic "
"link inside I</proc/[pid]/fd> that happens to refer to a terminal would "
"cause the process to acquire a controlling terminal."
msgstr ""

#.  From https://lwn.net/Articles/796868/:
#.      The presence of this flag will prevent a path lookup operation
#.      from traversing through one of these magic links, thus blocking
#.      (for example) attempts to escape from a container via a /proc
#.      entry for an open file descriptor.
#. type: Plain text
#: build/C/man2/openat2.2:291
msgid ""
"In a containerized environment, a magic link inside I</proc> may refer to an "
"object outside the container, and thus may provide a means to escape from "
"the container."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:297
msgid ""
"Because of such risks, an application may prefer to disable magic link "
"resolution using the B<RESOLVE_NO_MAGICLINKS> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:313
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a magic link, "
"I<how.resolve> contains B<RESOLVE_NO_MAGICLINKS>, and I<how.flags> contains "
"both B<O_PATH> and B<O_NOFOLLOW>, then an B<O_PATH> file descriptor "
"referencing the magic link will be returned."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:313
#, no-wrap
msgid "B<RESOLVE_NO_SYMLINKS>"
msgstr ""

#.  commit 278121417a72d87fb29dd8c48801f80821e8f75a
#. type: Plain text
#: build/C/man2/openat2.2:319
msgid ""
"Disallow resolution of symbolic links during path resolution.  This option "
"implies B<RESOLVE_NO_MAGICLINKS>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:335
msgid ""
"If the trailing component (i.e., basename) of I<pathname> is a symbolic "
"link, I<how.resolve> contains B<RESOLVE_NO_SYMLINKS>, and I<how.flags> "
"contains both B<O_PATH> and B<O_NOFOLLOW>, then an B<O_PATH> file descriptor "
"referencing the symbolic link will be returned."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:347
msgid ""
"Note that the effect of the B<RESOLVE_NO_SYMLINKS> flag, which affects the "
"treatment of symbolic links in all of the components of I<pathname>, differs "
"from the effect of the B<O_NOFOLLOW> file creation flag (in I<how.flags>), "
"which affects the handling of symbolic links only in the final component of "
"I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:361
msgid ""
"Applications that employ the B<RESOLVE_NO_SYMLINKS> flag are encouraged to "
"make its use configurable (unless it is used for a specific security "
"purpose), as symbolic links are very widely used by end-users.  Setting this "
"flag indiscriminately\\(emi.e., for purposes not specifically related to "
"security\\(emfor all uses of B<openat2>()  may result in spurious errors on "
"previously functional systems.  This may occur if, for example, a system "
"pathname that is used by an application is modified (e.g., in a new "
"distribution release)  so that a pathname component (now) contains a "
"symbolic link."
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:361
#, no-wrap
msgid "B<RESOLVE_NO_XDEV>"
msgstr ""

#.  commit 72ba29297e1439efaa54d9125b866ae9d15df339
#. type: Plain text
#: build/C/man2/openat2.2:374
msgid ""
"Disallow traversal of mount points during path resolution (including all "
"bind mounts).  Consequently, I<pathname> must either be on the same mount as "
"the directory referred to by I<dirfd>, or on the same mount as the current "
"working directory if I<dirfd> is specified as B<AT_FDCWD>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:388
msgid ""
"Applications that employ the B<RESOLVE_NO_XDEV> flag are encouraged to make "
"its use configurable (unless it is used for a specific security purpose), as "
"bind mounts are widely used by end-users.  Setting this flag "
"indiscriminately\\(emi.e., for purposes not specifically related to "
"security\\(emfor all uses of B<openat2>()  may result in spurious errors on "
"previously functional systems.  This may occur if, for example, a system "
"pathname that is used by an application is modified (e.g., in a new "
"distribution release)  so that a pathname component (now) contains a bind "
"mount."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:393
msgid ""
"If any bits other than those listed above are set in I<how.resolve>, an "
"error is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:398
msgid ""
"On success, a new file descriptor is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:404
msgid ""
"The set of errors returned by B<openat2>()  includes all of the errors "
"returned by B<openat>(2), as well as the following additional errors:"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:404
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:411
msgid ""
"An extension that this kernel does not support was specified in I<how>.  "
"(See the \"Extensibility\" section of B<NOTES> for more detail on how "
"extensions are handled.)"
msgstr ""

#. type: TP
#: build/C/man2/openat2.2:411 build/C/man2/read.2:100 build/C/man3/scanf.3:558 build/C/man2/write.2:132
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:423
msgid ""
"I<how.resolve> contains either B<RESOLVE_IN_ROOT> or B<RESOLVE_BENEATH>, and "
"the kernel could not ensure that a \"..\" component didn't escape (due to a "
"race condition or potential attack).  The caller may choose to retry the "
"B<openat2>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:427
msgid "An unknown flag or invalid value was specified in I<how>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:436
msgid ""
"I<mode> is nonzero, but I<how.flags> does not contain B<O_CREAT> or "
"B<O_TMPFILE>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:441
msgid "I<size> was smaller than any known version of I<struct open_how>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:447
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_SYMLINKS>, and one of the path "
"components was a symbolic link (or magic link)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:453
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_MAGICLINKS>, and one of the path "
"components was a magic link."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:461
msgid ""
"I<how.resolve> contains either B<RESOLVE_IN_ROOT> or B<RESOLVE_BENEATH>, and "
"an escape from the root during path resolution was detected."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:467
msgid ""
"I<how.resolve> contains B<RESOLVE_NO_XDEV>, and a path component crosses a "
"mount point."
msgstr ""

#.  commit fddb5d430ad9fa91b49b1d34d0202ffe2fa0e179
#. type: Plain text
#: build/C/man2/openat2.2:471
msgid "B<openat2>()  first appeared in Linux 5.6."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:473
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:478
msgid ""
"The semantics of B<RESOLVE_BENEATH> were modeled after FreeBSD's "
"B<O_BENEATH>."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:482
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: SS
#: build/C/man2/openat2.2:482
#, no-wrap
msgid "Extensibility"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:500
msgid ""
"In order to allow for future extensibility, B<openat2>()  requires the "
"user-space application to specify the size of the I<open_how> structure that "
"it is passing.  By providing this information, it is possible for "
"B<openat2>()  to provide both forwards- and backwards-compatibility, with "
"I<size> acting as an implicit version number.  (Because new extension fields "
"will always be appended, the structure size will always increase.)  This "
"extensibility design is very similar to other system calls such as "
"B<sched_setattr>(2), B<perf_event_open>(2), and B<clone3>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:507
msgid ""
"If we let I<usize> be the size of the structure as specified by the "
"user-space application, and I<ksize> be the size of the structure which the "
"kernel supports, then there are three cases to consider:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:515
msgid ""
"If I<ksize> equals I<usize>, then there is no version mismatch and I<how> "
"can be used verbatim."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:528
msgid ""
"If I<ksize> is larger than I<usize>, then there are some extension fields "
"that the kernel supports which the user-space application is unaware of.  "
"Because a zero value in any added extension field signifies a no-op, the "
"kernel treats all of the extension fields not provided by the user-space "
"application as having zero values.  This provides backwards-compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:543
msgid ""
"If I<ksize> is smaller than I<usize>, then there are some extension fields "
"which the user-space application is aware of but which the kernel does not "
"support.  Because any extension field must have its zero values signify a "
"no-op, the kernel can safely ignore the unsupported extension fields if they "
"are all-zero.  If any unsupported extension fields are nonzero, then -1 is "
"returned and I<errno> is set to B<E2BIG>.  This provides "
"forwards-compatibility."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:553
msgid ""
"Because the definition of I<struct open_how> may change in the future (with "
"new fields being added when system headers are updated), user-space "
"applications should zero-fill I<struct open_how> to ensure that recompiling "
"the program with new headers will not result in spurious errors at runtime.  "
"The simplest way is to use a designated initializer:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:558
#, no-wrap
msgid ""
"struct open_how how = { .flags = O_RDWR,\n"
"                        .resolve = RESOLVE_IN_ROOT };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:564
msgid "or explicitly using B<memset>(3)  or similar:"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:571
#, no-wrap
msgid ""
"struct open_how how;\n"
"memset(&how, 0, sizeof(how));\n"
"how.flags = O_RDWR;\n"
"how.resolve = RESOLVE_IN_ROOT;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:580
msgid ""
"A user-space application that wishes to determine which extensions the "
"running kernel supports can do so by conducting a binary search on I<size> "
"with a structure which has every byte nonzero (to find the largest value "
"which doesn't produce an error of B<E2BIG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/openat2.2:584
msgid "B<openat>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/open_by_handle_at.2:25
#, no-wrap
msgid "OPEN_BY_HANDLE_AT"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:29
msgid ""
"name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open "
"file via a handle"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:39
#, no-wrap
msgid ""
"B<int name_to_handle_at(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                      struct file_handle *>I<handle>B<,>\n"
"B<                      int *>I<mount_id>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:42
#, no-wrap
msgid ""
"B<int open_by_handle_at(int >I<mount_fd>B<, struct file_handle "
"*>I<handle>B<,>\n"
"B<                      int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:59
msgid ""
"The B<name_to_handle_at>()  and B<open_by_handle_at>()  system calls split "
"the functionality of B<openat>(2)  into two parts: B<name_to_handle_at>()  "
"returns an opaque handle that corresponds to a specified file; "
"B<open_by_handle_at>()  opens the file corresponding to a handle returned by "
"a previous call to B<name_to_handle_at>()  and returns an open file "
"descriptor."
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:59
#, no-wrap
msgid "name_to_handle_at()"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:71
msgid ""
"The B<name_to_handle_at>()  system call returns a file handle and a mount ID "
"corresponding to the file specified by the I<dirfd> and I<pathname> "
"arguments.  The file handle is returned via the argument I<handle>, which is "
"a pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:80
#, no-wrap
msgid ""
"struct file_handle {\n"
"    unsigned int  handle_bytes;   /* Size of f_handle [in, out] */\n"
"    int           handle_type;    /* Handle type [out] */\n"
"    unsigned char f_handle[0];    /* File identifier (sized by\n"
"                                     caller) [out] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:101
msgid ""
"It is the caller's responsibility to allocate the structure with a size "
"large enough to hold the handle returned in I<f_handle>.  Before the call, "
"the I<handle_bytes> field should be initialized to contain the allocated "
"size for I<f_handle>.  (The constant B<MAX_HANDLE_SZ>, defined in "
"I<E<lt>fcntl.hE<gt>>, specifies the maximum expected size for a file "
"handle.  It is not a guaranteed upper limit as future filesystems may "
"require more space.)  Upon successful return, the I<handle_bytes> field is "
"updated to contain the number of bytes actually written to I<f_handle>."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:123
msgid ""
"The caller can discover the required size for the I<file_handle> structure "
"by making a call in which I<handle-E<gt>handle_bytes> is zero; in this case, "
"the call fails with the error B<EOVERFLOW> and I<handle-E<gt>handle_bytes> "
"is set to indicate the required size; the caller can then use this "
"information to allocate a structure of the correct size (see EXAMPLES "
"below).  Some care is needed here as B<EOVERFLOW> can also indicate that no "
"file handle is available for this particular name in a filesystem which does "
"normally support file-handle lookup.  This case can be detected when the "
"B<EOVERFLOW> error is returned without I<handle_bytes> being increased."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:134
msgid ""
"Other than the use of the I<handle_bytes> field, the caller should treat the "
"I<file_handle> structure as an opaque data type: the I<handle_type> and "
"I<f_handle> fields are needed only by a subsequent call to "
"B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:142
msgid ""
"The I<flags> argument is a bit mask constructed by ORing together zero or "
"more of B<AT_EMPTY_PATH> and B<AT_SYMLINK_FOLLOW>, described below."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:149
msgid ""
"Together, the I<pathname> and I<dirfd> arguments identify the file for which "
"a handle is to be obtained.  There are four distinct cases:"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:157
msgid ""
"If I<pathname> is a nonempty string containing an absolute pathname, then a "
"handle is returned for the file referred to by that pathname.  In this case, "
"I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:168
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> has the special value B<AT_FDCWD>, then I<pathname> is interpreted "
"relative to the current working directory of the caller, and a handle is "
"returned for the file to which it refers."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:181
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> is a file descriptor referring to a directory, then I<pathname> is "
"interpreted relative to the directory referred to by I<dirfd>, and a handle "
"is returned for the file to which it refers.  (See B<openat>(2)  for an "
"explanation of why \"directory file descriptors\" are useful.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:195
msgid ""
"If I<pathname> is an empty string and I<flags> specifies the value "
"B<AT_EMPTY_PATH>, then I<dirfd> can be an open file descriptor referring to "
"any type of file, or B<AT_FDCWD>, meaning the current working directory, and "
"a handle is returned for the file to which it refers."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:211
msgid ""
"The I<mount_id> argument returns an identifier for the filesystem mount that "
"corresponds to I<pathname>.  This corresponds to the first field in one of "
"the records in I</proc/self/mountinfo>.  Opening the pathname in the fifth "
"field of that record yields a file descriptor for the mount point; that file "
"descriptor can be used in a subsequent call to B<open_by_handle_at>().  "
"I<mount_id> is returned both for a successful call and for a call that "
"results in the error B<EOVERFLOW>."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:224
msgid ""
"By default, B<name_to_handle_at>()  does not dereference I<pathname> if it "
"is a symbolic link, and thus returns a handle for the link itself.  If "
"B<AT_SYMLINK_FOLLOW> is specified in I<flags>, I<pathname> is dereferenced "
"if it is a symbolic link (so that the call returns a handle for the file "
"referred to by the link)."
msgstr ""

#.  commit 20fa19027286983ab2734b5910c4a687436e0c31
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:241
msgid ""
"B<name_to_handle_at>()  does not trigger a mount when the final component of "
"the pathname is an automount point.  When a filesystem supports both file "
"handles and automount points, a B<name_to_handle_at>()  call on an automount "
"point will return with error B<EOVERFLOW> without having increased "
"I<handle_bytes>.  This can happen since Linux 4.13 with NFS when accessing a "
"directory which is on a separate filesystem on the server.  In this case, "
"the automount can be triggered by adding a \"/\" to the end of the pathname."
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:241
#, no-wrap
msgid "open_by_handle_at()"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:248
msgid ""
"The B<open_by_handle_at>()  system call opens the file referred to by "
"I<handle>, a file handle returned by a previous call to "
"B<name_to_handle_at>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:258
msgid ""
"The I<mount_fd> argument is a file descriptor for any object (file, "
"directory, etc.)  in the mounted filesystem with respect to which I<handle> "
"should be interpreted.  The special value B<AT_FDCWD> can be specified, "
"meaning the current working directory of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:271
msgid ""
"The I<flags> argument is as for B<open>(2).  If I<handle> refers to a "
"symbolic link, the caller must specify the B<O_PATH> flag, and the symbolic "
"link is not dereferenced; the B<O_NOFOLLOW> flag, if specified, is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:276
msgid ""
"The caller must have the B<CAP_DAC_READ_SEARCH> capability to invoke "
"B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:283
msgid ""
"On success, B<name_to_handle_at>()  returns 0, and B<open_by_handle_at>()  "
"returns a file descriptor (a nonnegative integer)."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:287
msgid ""
"In the event of an error, both system calls return -1 and set I<errno> to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:294
msgid ""
"B<name_to_handle_at>()  and B<open_by_handle_at>()  can fail for the same "
"errors as B<openat>(2).  In addition, they can fail with the errors noted "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:297
msgid "B<name_to_handle_at>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:304
msgid ""
"I<pathname>, I<mount_id>, or I<handle> points outside your accessible "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:308
msgid "I<flags> includes an invalid bit value."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:313
msgid "I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ>."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:320
msgid ""
"I<pathname> is an empty string, but B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:332
msgid ""
"The file descriptor supplied in I<dirfd> does not refer to a directory, and "
"it is not the case that both I<flags> includes B<AT_EMPTY_PATH> and "
"I<pathname> is an empty string."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:335
msgid "The filesystem does not support decoding of a pathname to a file handle."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:345
msgid ""
"The I<handle-E<gt>handle_bytes> value passed into the call was too small.  "
"When this error occurs, I<handle-E<gt>handle_bytes> is updated to indicate "
"the required size for the handle."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:348
msgid "B<open_by_handle_at>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:352
msgid "I<mount_fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:356
msgid "I<handle> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:362
msgid ""
"I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ> or is equal to "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:369
msgid ""
"I<handle> refers to a symbolic link, but B<O_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:374
msgid "The caller does not have the B<CAP_DAC_READ_SEARCH> capability."
msgstr ""

#. type: TP
#: build/C/man2/open_by_handle_at.2:374
#, no-wrap
msgid "B<ESTALE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:380
msgid ""
"The specified I<handle> is not valid.  This error will occur if, for "
"example, the file has been deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:383
msgid ""
"These system calls first appeared in Linux 2.6.39.  Library support is "
"provided in glibc since version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:385
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:390
msgid ""
"FreeBSD has a broadly similar pair of system calls in the form of B<getfh>()  "
"and B<openfh>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:395
msgid ""
"A file handle can be generated in one process using B<name_to_handle_at>()  "
"and later used in a different process that calls B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:401
msgid ""
"Some filesystem don't support the translation of pathnames to file handles, "
"for example, I</proc>, I</sys>, and various network filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:408
msgid ""
"A file handle may become invalid (\"stale\") if a file is deleted, or for "
"other filesystem-specific reasons.  Invalid handles are notified by an "
"B<ESTALE> error from B<open_by_handle_at>()."
msgstr ""

#.  https://lwn.net/Articles/375888/
#. 	"Open by handle" - Jonathan Corbet, 2010-02-23
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:418
msgid ""
"These system calls are designed for use by user-space file servers.  For "
"example, a user-space NFS server might generate a file handle and pass it to "
"an NFS client.  Later, when the client wants to open the file, it could pass "
"the handle back to the server.  This sort of functionality allows a "
"user-space file server to operate in a stateless fashion with respect to the "
"files it serves."
msgstr ""

#.  commit bcda76524cd1fa32af748536f27f674a13e56700
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:440
msgid ""
"If I<pathname> refers to a symbolic link and I<flags> does not specify "
"B<AT_SYMLINK_FOLLOW>, then B<name_to_handle_at>()  returns a handle for the "
"link (rather than the file to which it refers).  The process receiving the "
"handle can later perform operations on the symbolic link by converting the "
"handle to a file descriptor using B<open_by_handle_at>()  with the B<O_PATH> "
"flag, and then passing the file descriptor as the I<dirfd> argument in "
"system calls such as B<readlinkat>(2)  and B<fchownat>(2)."
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:440
#, no-wrap
msgid "Obtaining a persistent filesystem ID"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:454
msgid ""
"The mount IDs in I</proc/self/mountinfo> can be reused as filesystems are "
"unmounted and mounted.  Therefore, the mount ID returned by "
"B<name_to_handle_at>()  (in I<*mount_id>)  should not be treated as a "
"persistent identifier for the corresponding mounted filesystem.  However, an "
"application can use the information in the I<mountinfo> record that "
"corresponds to the mount ID to derive a persistent identifier."
msgstr ""

#.  e.g., http://stackoverflow.com/questions/6748429/using-libblkid-to-find-uuid-of-a-partition
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:470
msgid ""
"For example, one can use the device name in the fifth field of the "
"I<mountinfo> record to search for the corresponding device UUID via the "
"symbolic links in I</dev/disks/by-uuid>.  (A more comfortable way of "
"obtaining the UUID is to use the B<libblkid>(3)  library.)  That process can "
"then be reversed, using the UUID to look up the device name, and then "
"obtaining the corresponding mount point, in order to produce the I<mount_fd> "
"argument used by B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:482
msgid ""
"The two programs below demonstrate the use of B<name_to_handle_at>()  and "
"B<open_by_handle_at>().  The first program (I<t_name_to_handle_at.c>)  uses "
"B<name_to_handle_at>()  to obtain the file handle and mount ID for the file "
"specified in its command-line argument; the handle and mount ID are written "
"to standard output."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:502
msgid ""
"The second program (I<t_open_by_handle_at.c>)  reads a mount ID and file "
"handle from standard input.  The program then employs B<open_by_handle_at>()  "
"to open the file using that handle.  If an optional command-line argument is "
"supplied, then the I<mount_fd> argument for B<open_by_handle_at>()  is "
"obtained by opening the directory named in that argument.  Otherwise, "
"I<mount_fd> is obtained by scanning I</proc/self/mountinfo> to find a record "
"whose mount ID matches the mount ID read from standard input, and the mount "
"directory specified in that record is opened.  (These programs do not deal "
"with the fact that mount IDs are not persistent.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:504
msgid "The following shell session demonstrates the use of these two programs:"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:514
#, no-wrap
msgid ""
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<./t_name_to_handle_at cecilia.txt E<gt> fh>\n"
"$ B<./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Operation not permitted\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>      # Need CAP_SYS_ADMIN\n"
"Read 31 bytes\n"
"$ B<rm cecilia.txt>\n"
msgstr ""

#.  Christoph Hellwig: That's why the file handles contain a generation
#.  counter that gets incremented in this case.
#. type: Plain text
#: build/C/man2/open_by_handle_at.2:525
msgid ""
"Now we delete and (quickly) re-create the file so that it has the same "
"content and (by chance) the same inode.  Nevertheless, "
"B<open_by_handle_at>()  recognizes that the original file referred to by the "
"file handle no longer exists."
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:536
#, no-wrap
msgid ""
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Display inode number\n"
"4072121\n"
"$ B<rm cecilia.txt>\n"
"$ B<echo \\(aqCan you please think about it?\\(aq E<gt> cecilia.txt>\n"
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Check inode number\n"
"4072121\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Stale NFS file handle\n"
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:538
#, no-wrap
msgid "Program source: t_name_to_handle_at.c"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:550
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:553 build/C/man2/open_by_handle_at.2:626
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:560
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fhsize, flags, dirfd;\n"
"    char *pathname;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:565
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s pathname\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:567
#, no-wrap
msgid "    pathname = argv[1];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:569
#, no-wrap
msgid "    /* Allocate file_handle structure */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:574
#, no-wrap
msgid ""
"    fhsize = sizeof(*fhp);\n"
"    fhp = malloc(fhsize);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:577
#, no-wrap
msgid ""
"    /* Make an initial call to name_to_handle_at() to discover\n"
"       the size required for file handle */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:586
#, no-wrap
msgid ""
"    dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */\n"
"    flags = 0;                  /* For name_to_handle_at() calls */\n"
"    fhp-E<gt>handle_bytes = 0;\n"
"    if (name_to_handle_at(dirfd, pathname, fhp,\n"
"                &mount_id, flags) != -1 || errno != EOVERFLOW) {\n"
"        fprintf(stderr, \"Unexpected result from "
"name_to_handle_at()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:588
#, no-wrap
msgid "    /* Reallocate file_handle structure with correct size */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:593
#, no-wrap
msgid ""
"    fhsize = sizeof(*fhp) + fhp-E<gt>handle_bytes;\n"
"    fhp = realloc(fhp, fhsize);         /* Copies fhp-E<gt>handle_bytes */\n"
"    if (fhp == NULL)\n"
"        errExit(\"realloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:595
#, no-wrap
msgid "    /* Get file handle from pathname supplied on command line */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:598
#, no-wrap
msgid ""
"    if (name_to_handle_at(dirfd, pathname, fhp, &mount_id, flags) == -1)\n"
"        errExit(\"name_to_handle_at\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:601
#, no-wrap
msgid ""
"    /* Write mount ID, file handle size, and file handle to stdout,\n"
"       for later reuse by t_open_by_handle_at.c */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:607
#, no-wrap
msgid ""
"    printf(\"%d\\en\", mount_id);\n"
"    printf(\"%u %d   \", fhp-E<gt>handle_bytes, fhp-E<gt>handle_type);\n"
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        printf(\" %02x\", fhp-E<gt>f_handle[j]);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: SS
#: build/C/man2/open_by_handle_at.2:611
#, no-wrap
msgid "Program source: t_open_by_handle_at.c"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:623
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:632
#, no-wrap
msgid ""
"/* Scan /proc/self/mountinfo to find the line whose mount ID matches\n"
"   \\(aqmount_id\\(aq. (An easier way to do this is to install and use the\n"
"   \\(aqlibmount\\(aq library provided by the \\(aqutil-linux\\(aq "
"project.)\n"
"   Open the corresponding mount path and return the resulting file\n"
"   descriptor. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:642
#, no-wrap
msgid ""
"static int\n"
"open_mount_path_by_id(int mount_id)\n"
"{\n"
"    char *linep;\n"
"    size_t lsize;\n"
"    char mount_path[PATH_MAX];\n"
"    int mi_mount_id, found;\n"
"    ssize_t nread;\n"
"    FILE *fp;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:646
#, no-wrap
msgid ""
"    fp = fopen(\"/proc/self/mountinfo\", \"r\");\n"
"    if (fp == NULL)\n"
"        errExit(\"fopen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:653
#, no-wrap
msgid ""
"    found = 0;\n"
"    linep = NULL;\n"
"    while (!found) {\n"
"        nread = getline(&linep, &lsize, fp);\n"
"        if (nread == -1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:660
#, no-wrap
msgid ""
"        nread = sscanf(linep, \"%d %*d %*s %*s %s\",\n"
"                       &mi_mount_id, mount_path);\n"
"        if (nread != 2) {\n"
"            fprintf(stderr, \"Bad sscanf()\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:665
#, no-wrap
msgid ""
"        if (mi_mount_id == mount_id)\n"
"            found = 1;\n"
"    }\n"
"    free(linep);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:672
#, no-wrap
msgid ""
"    if (!found) {\n"
"        fprintf(stderr, \"Could not find mount point\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:675
#, no-wrap
msgid ""
"    return open(mount_path, O_RDONLY);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:686
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fd, mount_fd, handle_bytes;\n"
"    ssize_t nread;\n"
"    char buf[1000];\n"
"#define LINE_SIZE 100\n"
"    char line1[LINE_SIZE], line2[LINE_SIZE];\n"
"    char *nextp;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:691
#, no-wrap
msgid ""
"    if ((argc E<gt> 1 && strcmp(argv[1], \"--help\") == 0) || argc E<gt> 2) "
"{\n"
"        fprintf(stderr, \"Usage: %s [mount-path]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:693
#, no-wrap
msgid "    /* Standard input contains mount ID and file handle information:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:697
#, no-wrap
msgid ""
"         Line 1: E<lt>mount_idE<gt>\n"
"         Line 2: E<lt>handle_bytesE<gt> E<lt>handle_typeE<gt>   E<lt>bytes "
"of handle in hexE<gt>\n"
"    */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:703
#, no-wrap
msgid ""
"    if ((fgets(line1, sizeof(line1), stdin) == NULL) ||\n"
"           (fgets(line2, sizeof(line2), stdin) == NULL)) {\n"
"        fprintf(stderr, \"Missing mount_id / file handle\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:705
#, no-wrap
msgid "    mount_id = atoi(line1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:707
#, no-wrap
msgid "    handle_bytes = strtoul(line2, &nextp, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:709
#, no-wrap
msgid "    /* Given handle_bytes, we can now allocate file_handle structure */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:713
#, no-wrap
msgid ""
"    fhp = malloc(sizeof(*fhp) + handle_bytes);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:715
#, no-wrap
msgid "    fhp-E<gt>handle_bytes = handle_bytes;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:717
#, no-wrap
msgid "    fhp-E<gt>handle_type = strtoul(nextp, &nextp, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:720
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        fhp-E<gt>f_handle[j] = strtoul(nextp, &nextp, 16);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:725
#, no-wrap
msgid ""
"    /* Obtain file descriptor for mount point, either by opening\n"
"       the pathname specified on the command line, or by scanning\n"
"       /proc/self/mounts to find a mount that matches the "
"\\(aqmount_id\\(aq\n"
"       that we received from stdin. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:730
#, no-wrap
msgid ""
"    if (argc E<gt> 1)\n"
"        mount_fd = open(argv[1], O_RDONLY);\n"
"    else\n"
"        mount_fd = open_mount_path_by_id(mount_id);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:733
#, no-wrap
msgid ""
"    if (mount_fd == -1)\n"
"        errExit(\"opening mount fd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:735
#, no-wrap
msgid "    /* Open file using handle and mount point */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:739
#, no-wrap
msgid ""
"    fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);\n"
"    if (fd == -1)\n"
"        errExit(\"open_by_handle_at\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:741
#, no-wrap
msgid "    /* Try reading a few bytes from the file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:745
#, no-wrap
msgid ""
"    nread = read(fd, buf, sizeof(buf));\n"
"    if (nread == -1)\n"
"        errExit(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:747
#, no-wrap
msgid "    printf(\"Read %zd bytes\\en\", nread);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:757
msgid "B<open>(2), B<libblkid>(3), B<blkid>(8), B<findfs>(8), B<mount>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/open_by_handle_at.2:767
msgid ""
"The I<libblkid> and I<libmount> documentation in the latest I<util-linux> "
"release at E<.UR https://www.kernel.org/pub/linux/utils/util-linux/> E<.UE>"
msgstr ""

#. type: TH
#: build/C/man3/open_memstream.3:9
#, no-wrap
msgid "OPEN_MEMSTREAM"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:12
msgid "open_memstream, open_wmemstream - open a dynamic memory buffer stream"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:17
#, no-wrap
msgid "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:19 build/C/man3/unlocked_stdio.3:54
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:21
#, no-wrap
msgid "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:30
msgid "B<open_memstream>(), B<open_wmemstream>():"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:52
msgid ""
"The B<open_memstream>()  function opens a stream for writing to a memory "
"buffer.  The function dynamically allocates the buffer, and the buffer "
"automatically grows as needed.  Initially, the buffer has a size of zero.  "
"After closing the stream, the caller should B<free>(3)  this buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:68
msgid ""
"The locations pointed to by I<ptr> and I<sizeloc> are used to report, "
"respectively, the current location and the size of the buffer.  The "
"locations referred to by these pointers are updated each time the stream is "
"flushed (B<fflush>(3))  and when the stream is closed (B<fclose>(3)).  These "
"values remain valid only as long as the caller performs no further output on "
"the stream.  If further output is performed, then the stream must again be "
"flushed before trying to access these values."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:74
msgid ""
"A null byte is maintained at the end of the buffer.  This byte is I<not> "
"included in the size value stored at I<sizeloc>."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:85
msgid ""
"The stream maintains the notion of a current position, which is initially "
"zero (the start of the buffer).  Each write operation implicitly adjusts the "
"buffer position.  The stream's buffer position can be explicitly changed "
"with B<fseek>(3)  or B<fseeko>(3).  Moving the buffer position past the end "
"of the data already written fills the intervening space with null "
"characters."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:91
msgid ""
"The B<open_wmemstream>()  is similar to B<open_memstream>(), but operates on "
"wide characters instead of bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:102
msgid ""
"Upon successful completion, B<open_memstream>()  and B<open_wmemstream>()  "
"return a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:107
msgid ""
"B<open_memstream>()  was already available in glibc 1.0.x.  "
"B<open_wmemstream>()  is available since glibc 2.4."
msgstr ""

#. type: tbl table
#: build/C/man3/open_memstream.3:117
#, no-wrap
msgid "B<open_memstream>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/open_memstream.3:119
#, no-wrap
msgid "B<open_wmemstream>"
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:126
msgid ""
"POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are "
"not widely available on other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:132
msgid ""
"There is no file descriptor associated with the file stream returned by "
"these functions (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=1996
#. type: Plain text
#: build/C/man3/open_memstream.3:139
msgid ""
"In glibc before version 2.7, seeking past the end of a stream created by "
"B<open_memstream>()  does not enlarge the buffer; instead the B<fseek>(3)  "
"call fails, returning -1."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:142
msgid "See B<fmemopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/open_memstream.3:146
msgid "B<fmemopen>(3), B<fopen>(3), B<setbuf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/perror.3:31
#, no-wrap
msgid "PERROR"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:34
msgid "perror - print a system error message"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:38
msgid "B<void perror(const char *>I<s>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:40
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:42
msgid "B<const char * const >I<sys_errlist>B<[];>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:44
msgid "B<int >I<sys_nerr>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:46
msgid "B<int >I<errno>B<; >/* Not really declared this way; see errno(3) */"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:58
#, no-wrap
msgid ""
"I<sys_errlist>,\n"
"I<sys_nerr>:\n"
"    From glibc 2.19 to 2.31:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:63
msgid ""
"The B<perror>()  function produces a message on standard error describing "
"the last error encountered during a call to a system or library function."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:74
msgid ""
"First (if I<s> is not NULL and I<*s> is not a null byte (\\(aq\\e0\\(aq)), "
"the argument string I<s> is printed, followed by a colon and a blank.  Then "
"an error message corresponding to the current value of I<errno> and a "
"new-line."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:77
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:93
msgid ""
"The global error list I<sys_errlist>[], which can be indexed by I<errno>, "
"can be used to obtain the error message without the newline.  The largest "
"message number provided in the table is I<sys_nerr>-1.  Be careful when "
"directly accessing this list, because new error values may not have been "
"added to I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays "
"deprecated; use B<strerror>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:114
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function "
"B<perror>()  serves to translate this error code into human-readable form.  "
"Note that I<errno> is undefined after a successful system call or library "
"function call: this call may well change this variable, even though it "
"succeeds, for example because it internally used some other library function "
"that failed.  Thus, if a failing call is not immediately followed by a call "
"to B<perror>(), the value of I<errno> should be saved."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:121
msgid ""
"Since glibc version 2.32, the declarations of I<sys_errlist> and I<sys_nerr> "
"are no longer exposed by I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: tbl table
#: build/C/man3/perror.3:131
#, no-wrap
msgid "B<perror>()"
msgstr ""

#. type: tbl table
#: build/C/man3/perror.3:131
#, no-wrap
msgid "MT-Safe race:stderr"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:138
msgid "B<perror>(), I<errno>: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:144
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> derive from BSD, but are not "
"specified in POSIX.1."
msgstr ""

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: build/C/man3/perror.3:159
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:164
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "PIPE"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:48
#, no-wrap
msgid ""
"/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */\n"
"B<struct fd_pair {>\n"
"B<long fd[2];>\n"
"B<};>\n"
"B<struct fd_pair pipe();>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:51
#, no-wrap
msgid ""
"/* On all other architectures */\n"
"B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:55
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant "
"definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:57
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:73
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:83
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:83
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:91
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:91
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr ""

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
#: build/C/man2/pipe.2:101
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:112
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in "
"I<E<lt>limits.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:122
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in "
"the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:127
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:132
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr ""

#.  commit 0dbf5f20652108106cb822ad7662c786baaa03ff
#.  FIXME . But, it is not possible to specify O_DIRECT when opening a FIFO
#. type: Plain text
#: build/C/man2/pipe.2:140
msgid ""
"Since Linux 4.5, it is possible to change the B<O_DIRECT> setting of a pipe "
"file descriptor using B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:140
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:149
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file descriptions "
"referred to by the new file descriptors.  Using this flag saves extra calls "
"to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:156
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<pipefd> is left unchanged."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=467
#. type: Plain text
#: build/C/man2/pipe.2:170
msgid ""
"On Linux (and other systems), B<pipe>()  does not modify I<pipefd> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2.  The Linux-specific B<pipe2>()  system call likewise does "
"not modify I<pipefd> on failure."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:175
msgid "I<pipefd> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:180
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:183 build/C/man3/tmpfile.3:70
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:191
msgid ""
"The user hard limit on memory that can be allocated for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:196
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:199
msgid "B<pipe>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:202
msgid "B<pipe2>()  is Linux-specific."
msgstr ""

#.  See http://math-atlas.sourceforge.net/devel/assembly/64.psabi.1.33.ps.Z
#.  for example, section 3.2.1 "Registers and the Stack Frame".
#. type: Plain text
#: build/C/man2/pipe.2:219
msgid ""
"The System V ABI on some architectures allows the use of more than one "
"register for returning multiple values; several architectures (namely, "
"Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64)  (ab)use this feature in "
"order to implement the B<pipe>()  system call in a functional manner: the "
"call doesn't take any arguments and returns a pair of file descriptors as "
"the return value on success.  The glibc B<pipe>()  wrapper function "
"transparently deals with this.  See B<syscall>(2)  for information regarding "
"registers used for storing second file descriptor."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/pipe.2:235
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the file "
"descriptors that it doesn't need for the pipe (see B<pipe>(7)).  The parent "
"then writes the string contained in the program's command-line argument to "
"the pipe, and the child reads this string a byte at a time from the pipe and "
"echoes it on standard output."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:243
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:255
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:260
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:266
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:269
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:272
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:276
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:285
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:296
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), "
"B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"
msgstr ""

#. type: TH
#: build/C/man3/popen.3:40
#, no-wrap
msgid "POPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:43
msgid "popen, pclose - pipe stream to or from a process"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:48
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:50
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:60
msgid "B<popen>(), B<pclose>():"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:63
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:74
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:84
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:99
msgid ""
"The I<type> argument is a pointer to a null-terminated string which must "
"contain either the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq "
"for writing.  Since glibc 2.9, this argument can additionally include the "
"letter \\(aqe\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to "
"be set on the underlying file descriptor; see the description of the "
"B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:115
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than "
"B<fclose>(3).  Writing to such a stream writes to the standard input of the "
"command; the command's standard output is the same as that of the process "
"that called B<popen>(), unless this is altered by the command itself.  "
"Conversely, reading from the stream reads the command's standard output, and "
"the command's standard input is the same as that of the process that called "
"B<popen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:119
msgid "Note that output B<popen>()  streams are block buffered by default."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:125
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:135
msgid ""
"B<popen>(): on success, returns a pointer to an open stream that can be used "
"to read or write to the pipe; if the B<fork>(2)  or B<pipe>(2)  calls fail, "
"or if the function cannot allocate memory, NULL is returned."
msgstr ""

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: build/C/man3/popen.3:147
msgid ""
"B<pclose>(): on success, returns the exit status of the command; if "
"B<wait4>(2)  returns an error, or some other error is detected, -1 is "
"returned."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:151
msgid "Both functions set I<errno> to an appropriate value in the case of an error."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:170
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:177
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to "
"B<ECHILD>."
msgstr ""

#. type: tbl table
#: build/C/man3/popen.3:188
#, no-wrap
msgid ""
"B<popen>(),\n"
"B<pclose>()"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:197
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:201
msgid "B<Note>: carefully read Caveats in B<system>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:214
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: build/C/man3/popen.3:224
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:234
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr ""

#. type: TH
#: build/C/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:38
msgid ""
"printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, "
"vsprintf, vsnprintf - formatted output conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:47
#, no-wrap
msgid ""
"B<int printf(const char *>I<format>B<, ...);>\n"
"B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>\n"
"B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>\n"
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, "
"...);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:49 build/C/man3/scanf.3:64
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:56
#, no-wrap
msgid ""
"B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:66
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:69
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:73
msgid "B<dprintf>(), B<vdprintf>():"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:109
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>(), and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:119
msgid ""
"The function B<dprintf>()  is the same as B<fprintf>()  except that it "
"outputs to a file descriptor, I<fd>, instead of to a I<stdio> stream."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:128
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:154
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vdprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  are equivalent to the functions B<printf>(), B<fprintf>(), "
"B<dprintf>(), B<sprintf>(), B<snprintf>(), respectively, except that they "
"are called with a I<va_list> instead of a variable number of arguments.  "
"These functions do not call the I<va_end> macro.  Because they invoke the "
"I<va_arg> macro, the value of I<ap> is undefined after the call.  See "
"B<stdarg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:161
msgid ""
"All of these functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:172
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:172
#, no-wrap
msgid "Format of the format string"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:194
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:211
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq (see I<Field width> and I<Precision> below) "
"and each conversion specifier asks for the next argument (and it is an error "
"if insufficiently many arguments are given).  One can also specify "
"explicitly which argument is taken, at each place where an argument is "
"required, by writing \"%m$\" instead of \\(aq%\\(aq and \"*m$\" instead of "
"\\(aq*\\(aq, where the decimal integer I<m> denotes the position in the "
"argument list of the desired argument, indexed starting from 1.  Thus,"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:215
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:219
msgid "and"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:223
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:239
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using "
"\\(aq$\\(aq is used, it must be used throughout for all conversions taking "
"an argument and all width and precision arguments, but it may be mixed with "
"\"%%\" formats, which do not consume an argument.  There may be no gaps in "
"the numbers of arguments specified using \\(aq$\\(aq; for example, if "
"arguments 1 and 3 are specified, argument 2 must also be specified somewhere "
"in the format string."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:251
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  (See B<setlocale>(3).)  The POSIX "
"locale uses \\(aq.\\(aq as radix character, and does not have a grouping "
"character.  Thus,"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:255
#, no-wrap
msgid "printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:260
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:260
#, no-wrap
msgid "Flag characters"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:262
msgid "The character % is followed by zero or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:262
#, no-wrap
msgid "B<#>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:296
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:296
#, no-wrap
msgid "B<\\&0>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:336
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:336
#, no-wrap
msgid "B<->"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:347
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  The converted value is padded on the right "
"with blanks, rather than on the left with blanks or zeros.  A B<-> overrides "
"a B<\\&0> if both are given."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:347
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:351
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:351
#, no-wrap
msgid "B<+>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:359
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default, a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:362
msgid ""
"The five flag characters above are defined in the C99 standard.  The Single "
"UNIX Specification specifies one further flag character."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:362
#, no-wrap
msgid "B<\\(aq>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:381
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  (See B<setlocale>(3).)  Note that many versions "
"of B<gcc>(1)  cannot parse this option and will issue a warning.  (SUSv2 did "
"not include I<%\\(aqF>, but SUSv3 added it.)"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:383
msgid "glibc 2.2 adds one further flag character."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:383
#, no-wrap
msgid "B<I>"
msgstr ""

#.  outdigits keyword in locale file
#. type: Plain text
#: build/C/man3/printf.3:393
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:393
#, no-wrap
msgid "Field width"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:409
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:409
#, no-wrap
msgid "Precision"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:446
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that the "
"precision is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, the precision is taken to be zero.  A negative precision "
"is taken as if the precision were omitted.  This gives the minimum number of "
"digits to appear for B<d>, B<i>, B<o>, B<u>, B<x>, and B<X> conversions, the "
"number of digits to appear after the radix character for B<a>, B<A>, B<e>, "
"B<E>, B<f>, and B<F> conversions, the maximum number of significant digits "
"for B<g> and B<G> conversions, or the maximum number of characters to be "
"printed from a string for B<s> and B<S> conversions."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:446
#, no-wrap
msgid "Length modifier"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:456
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:456 build/C/man3/scanf.3:301
#, no-wrap
msgid "B<hh>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:467
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:467 build/C/man3/scanf.3:291
#, no-wrap
msgid "B<h>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:478
msgid ""
"A following integer conversion corresponds to a I<short> or I<unsigned "
"short> argument, or a following B<n> conversion corresponds to a pointer to "
"a I<short> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:478 build/C/man3/scanf.3:318
#, no-wrap
msgid "B<l>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:497
msgid ""
"(ell) A following integer conversion corresponds to a I<long> or I<unsigned "
"long> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<long> argument, or a following B<c> conversion corresponds to a I<wint_t> "
"argument, or a following B<s> conversion corresponds to a pointer to "
"I<wchar_t> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:497
#, no-wrap
msgid "B<ll>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:509
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long> or "
"I<unsigned long long> argument, or a following B<n> conversion corresponds "
"to a pointer to a I<long long> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:509 build/C/man3/scanf.3:361
#, no-wrap
msgid "B<q>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:515
msgid ""
"A synonym for B<ll>.  This is a nonstandard extension, derived from BSD; "
"avoid its use in new code."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:515 build/C/man3/scanf.3:345
#, no-wrap
msgid "B<L>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:531
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:531 build/C/man3/scanf.3:309
#, no-wrap
msgid "B<j>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:542
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument, or a following B<n> conversion corresponds to a pointer to an "
"I<intmax_t> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:542 build/C/man3/scanf.3:373
#, no-wrap
msgid "B<z>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:553
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument, or a following B<n> conversion corresponds to a pointer to a "
"I<size_t> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:553
#, no-wrap
msgid "B<Z>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:560
msgid ""
"A nonstandard synonym for B<z> that predates the appearance of B<z>.  Do not "
"use in new code."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:560 build/C/man3/scanf.3:366
#, no-wrap
msgid "B<t>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:569
msgid ""
"A following integer conversion corresponds to a I<ptrdiff_t> argument, or a "
"following B<n> conversion corresponds to a pointer to a I<ptrdiff_t> "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:600
msgid ""
"SUSv3 specifies all of the above, except for those modifiers explicitly "
"noted as being nonstandard extensions.  SUSv2 specified only the length "
"modifiers B<h> (in B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in "
"B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, "
"B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:615
msgid ""
"As a nonstandard extension, the GNU implementations treats B<ll> and B<L> as "
"synonyms, so that one can, for example, write B<llg> (as a synonym for the "
"standards-compliant B<Lg>)  and B<Ld> (as a synonym for the standards "
"compliant B<lld>).  Such usage is nonportable."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:615
#, no-wrap
msgid "Conversion specifiers"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:618
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:618
#, no-wrap
msgid "B<d>, B<i>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:628
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:628
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:655
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:655
#, no-wrap
msgid "B<e>, B<E>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:675
msgid ""
"The I<double> argument is rounded and converted in the style "
"[-]dB<\\&.>dddB<e>\\(+-dd where there is one digit (which is nonzero if the "
"argument is nonzero)  before the decimal-point character and the number of "
"digits after it is equal to the precision; if the precision is missing, it "
"is taken as 6; if the precision is zero, no decimal-point character "
"appears.  An B<E> conversion uses the letter B<E> (rather than B<e>)  to "
"introduce the exponent.  The exponent always contains at least two digits; "
"if the value is zero, the exponent is 00."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:675
#, no-wrap
msgid "B<f>, B<F>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:686
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no "
"decimal-point character appears.  If a decimal point appears, at least one "
"digit appears before it."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:699
msgid ""
"(SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  SUSv3 adds a "
"specification for B<F>.  The C99 standard specifies \"[-]inf\" or "
"\"[-]infinity\" for infinity, and a string starting with \"nan\" for NaN, in "
"the case of B<f> conversion, and \"[-]INF\" or \"[-]INFINITY\" or \"NAN\" in "
"the case of B<F> conversion.)"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:699
#, no-wrap
msgid "B<g>, B<G>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:724
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:724
#, no-wrap
msgid "B<a>, B<A>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:751
msgid ""
"(C99; not in SUSv2, but added in SUSv3)  For B<a> conversion, the I<double> "
"argument is converted to hexadecimal notation (using the letters abcdef)  in "
"the style [-]B<0x>hB<\\&.>hhhhB<p>\\(+-d; for B<A> conversion the prefix "
"B<0X>, the letters ABCDEF, and the exponent separator B<P> is used.  There "
"is one hexadecimal digit before the decimal point, and the number of digits "
"after it is equal to the precision.  The default precision suffices for an "
"exact representation of the value if an exact representation in base 2 "
"exists and otherwise is sufficiently large to distinguish values of type "
"I<double>.  The digit before the decimal point is unspecified for "
"nonnormalized numbers, and nonzero but otherwise unspecified for normalized "
"numbers.  The exponent always contains at least one digit; if the value is "
"zero, the exponent is 0."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:751 build/C/man3/scanf.3:471 build/C/man3/wprintf.3:146
#, no-wrap
msgid "B<c>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:769
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:769 build/C/man3/scanf.3:463 build/C/man3/wprintf.3:160
#, no-wrap
msgid "B<s>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:784
msgid ""
"If no B<l> modifier is present: the I<const char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:811
msgid ""
"If an B<l> modifier is present: the I<const wchar_t\\ *> argument is "
"expected to be a pointer to an array of wide characters.  Wide characters "
"from the array are converted to multibyte characters (each by a call to the "
"B<wcrtomb>(3)  function, with a conversion state starting in the initial "
"state before the first wide character), up to and including a terminating "
"null wide character.  The resulting multibyte characters are written up to "
"(but not including) the terminating null byte.  If a precision is specified, "
"no more bytes than the number specified are written, but no partial "
"multibyte characters are written.  Note that the precision determines the "
"number of I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:811
#, no-wrap
msgid "B<C>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:817
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<lc>.  "
"Don't use."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:817
#, no-wrap
msgid "B<S>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:823
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<ls>.  "
"Don't use."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:823 build/C/man3/scanf.3:514
#, no-wrap
msgid "B<p>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:831
msgid ""
"The I<void\\ *> pointer argument is printed in hexadecimal (as if by B<%#x> "
"or B<%#lx>)."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:831 build/C/man3/scanf.3:522
#, no-wrap
msgid "B<n>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:843
msgid ""
"The number of characters written so far is stored into the integer pointed "
"to by the corresponding argument.  That argument shall be an I<int\\ *>, or "
"variant whose size matches the (optionally)  supplied integer length "
"modifier.  No argument is converted.  (This specifier is not supported by "
"the bionic C library.)  The behavior is undefined if the conversion "
"specification includes any flags, a field width, or a precision."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:843
#, no-wrap
msgid "B<m>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:849
msgid ""
"(Glibc extension; supported by uClibc and musl.)  Print output of "
"I<strerror(errno)>.  No argument is required."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:849 build/C/man3/scanf.3:384
#, no-wrap
msgid "B<%>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:855
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:858
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:874
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit, then the return value is the "
"number of characters (excluding the terminating null byte)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:876
msgid "If an output error is encountered, a negative value is returned."
msgstr ""

#. type: tbl table
#: build/C/man3/printf.3:887
#, no-wrap
msgid ""
"B<printf>(),\n"
"B<fprintf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/printf.3:890
#, no-wrap
msgid ""
"B<sprintf>(),\n"
"B<snprintf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/printf.3:893
#, no-wrap
msgid ""
"B<vprintf>(),\n"
"B<vfprintf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/printf.3:896
#, no-wrap
msgid ""
"B<vsprintf>(),\n"
"B<vsnprintf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:907
msgid ""
"B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"B<vsprintf>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:911
msgid "B<snprintf>(), B<vsnprintf>(): POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:918
msgid ""
"The B<dprintf>()  and B<vdprintf>()  functions were originally GNU "
"extensions that were later standardized in POSIX.1-2008."
msgstr ""

#.  .PP
#.  Linux libc4 knows about the five C standard flags.
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  and the conversions
#.  \fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
#.  \fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
#.  \fBs\fP, \fBu\fP, \fBx\fP, and \fBX\fP,
#.  where \fBF\fP is a synonym for \fBf\fP.
#.  Additionally, it accepts \fBD\fP, \fBO\fP, and \fBU\fP as synonyms
#.  for \fBld\fP, \fBlo\fP, and \fBlu\fP.
#.  (This is bad, and caused serious bugs later, when
#.  support for \fB%D\fP disappeared.)
#.  No locale-dependent radix character,
#.  no thousands' separator, no NaN or infinity, no "%m$" and "*m$".
#.  .PP
#.  Linux libc5 knows about the five C standard flags and the \(aq flag,
#.  locale, "%m$" and "*m$".
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  \fBZ\fP, and \fBq\fP, but accepts \fBL\fP and \fBq\fP
#.  both for \fIlong double\fP and for \fIlong long\fP (this is a bug).
#.  It no longer recognizes \fBF\fP, \fBD\fP, \fBO\fP, and \fBU\fP,
#.  but adds the conversion character
#.  .BR m ,
#.  which outputs
#.  .IR strerror(errno) .
#.  .PP
#.  glibc 2.0 adds conversion characters \fBC\fP and \fBS\fP.
#. type: Plain text
#: build/C/man3/printf.3:961
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough.  POSIX.1-2001 and later align their specification of "
"B<snprintf>()  with C99."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:964
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:967
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:969
msgid "Some programs imprudently rely on code such as the following"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:971
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: build/C/man3/printf.3:987
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: build/C/man3/printf.3:1029
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6, they would return -1 when the output "
"was truncated."
msgstr ""

#.  .PP
#.  Linux libc4.[45] does not have a
#.  .BR snprintf (),
#.  but provides a libbsd that contains an
#.  .BR snprintf ()
#.  equivalent to
#.  .BR sprintf (),
#.  that is, one that ignores the
#.  .I size
#.  argument.
#.  Thus, the use of
#.  .BR snprintf ()
#.  with early libc4 leads to serious security problems.
#. type: Plain text
#: build/C/man3/printf.3:1059
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: build/C/man3/printf.3:1073
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1077
msgid "To print I<Pi> to five decimal places:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1083
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1092
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1098
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1104
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1110
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1117
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1121
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1125
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1128
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1133
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1141
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n = 0;\n"
"    size_t size = 0;\n"
"    char *p = NULL;\n"
"    va_list ap;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1143
#, no-wrap
msgid "    /* Determine required size */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1147 build/C/man3/printf.3:1161
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    n = vsnprintf(p, size, fmt, ap);\n"
"    va_end(ap);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1150
#, no-wrap
msgid ""
"    if (n E<lt> 0)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1152
#, no-wrap
msgid "    /* One extra byte for \\(aq\\e0\\(aq */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1157
#, no-wrap
msgid ""
"    size = (size_t) n + 1;\n"
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1166
#, no-wrap
msgid ""
"    if (n E<lt> 0) {\n"
"        free(p);\n"
"        return NULL;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1169
#, no-wrap
msgid ""
"    return p;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1173
msgid ""
"If truncation occurs in glibc versions prior to 2.0.6, this is treated as an "
"error instead of being handled gracefully."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1183
msgid ""
"B<printf>(1), B<asprintf>(3), B<puts>(3), B<scanf>(3), B<setlocale>(3), "
"B<strfromd>(3), B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""

#. type: TH
#: build/C/man3/puts.3:26
#, no-wrap
msgid "PUTS"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:29
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:34
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:36
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:38
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:40
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:42
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:51
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:58
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:65
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:69
msgid "B<putchar(>I<c>B<)> is equivalent to B<putc(>I<c>B<, >I<stdout>B<)>."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:76
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:81
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:96
msgid ""
"B<fputc>(), B<putc>(), and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:103
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF> "
"on error."
msgstr ""

#. type: tbl table
#: build/C/man3/puts.3:117
#, no-wrap
msgid ""
"B<fputc>(),\n"
"B<fputs>(),\n"
"B<putc>(),\n"
"B<putchar>(),\n"
"B<puts>()"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:128
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:140
msgid ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man2/read.2:36
#, no-wrap
msgid "READ"
msgstr ""

#. type: TH
#: build/C/man2/read.2:36
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:39
msgid "read - read from a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:44
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:53
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:61
msgid ""
"On files that support seeking, the read operation commences at the file "
"offset, and the file offset is incremented by the number of bytes read.  If "
"the file offset is at or past the end of file, no bytes are read, and "
"B<read>()  returns zero."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:76
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:83 build/C/man2/write.2:96
msgid ""
"According to POSIX.1, if I<count> is greater than B<SSIZE_MAX>, the result "
"is implementation-defined; see NOTES for the upper limit on Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:93
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  See also NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:99
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately.  In this case, "
"it is left unspecified whether the file position (if any) changes."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:112
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""

#. type: TP
#: build/C/man2/read.2:112 build/C/man2/write.2:144
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/read.2:123
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:127
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:131 build/C/man2/write.2:174
msgid "I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:135
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:146
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:156
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:176
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling terminal, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape.  A further possible cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:180
msgid "I<fd> refers to a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:183 build/C/man2/write.2:243
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EDEADLK, ENOLCK, ENOLNK, ENOSR, ENXIO, or ERANGE.
#. type: Plain text
#: build/C/man2/read.2:185 build/C/man2/write.2:247
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:192 build/C/man2/write.2:259
msgid ""
"The types I<size_t> and I<ssize_t> are, respectively, unsigned and signed "
"integer data types specified by POSIX.1."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: build/C/man2/read.2:200
msgid ""
"On Linux, B<read>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:216
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"I<st_atime> (last file access time)  updates to the server, and client side "
"reads satisfied from the client's cache will not cause I<st_atime> updates "
"on the server as there are no server-side reads.  UNIX semantics can be "
"obtained by disabling client-side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:219 build/C/man2/write.2:301
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:224 build/C/man2/write.2:306
msgid ""
"All of the following functions shall be atomic with respect to each other in "
"the effects specified in POSIX.1-2008 when they operate on regular files or "
"symbolic links: ..."
msgstr ""

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: build/C/man2/read.2:255
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in "
"Linux 3.14."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:268
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""

#. type: TH
#: build/C/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:53
#, no-wrap
msgid ""
"B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:68
msgid "B<readlink>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/readlink.2:72 build/C/man2/symlink.2:60
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:75
msgid "B<readlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:101
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will (silently) truncate the contents (to a length "
"of I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""

#. type: SS
#: build/C/man2/readlink.2:101
#, no-wrap
msgid "readlinkat()"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:107
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:117
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:129
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<readlink>())."
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: build/C/man2/readlink.2:149
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the symbolic link referred to by I<dirfd> (which should "
"have been obtained using B<open>(2)  with the B<O_PATH> and B<O_NOFOLLOW> "
"flags)."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:154
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:163
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  (If "
"the returned value equals I<bufsiz>, then truncation may have occurred.)  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:169
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:173
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: build/C/man2/readlink.2:182
msgid "I<bufsiz> is not positive."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:187
msgid ""
"The named file (i.e., the final filename component of I<pathname>)  is not a "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:190
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:193
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:196
msgid "A pathname, or a component of a pathname, was too long."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:199
msgid "The named file does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:205
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:208
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:218 build/C/man2/unlink.2:274
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:222
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:228
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:231
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:239
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:262
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using B<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:275
msgid ""
"On older kernels where B<readlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<readlink>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:285
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(2), falling back to a "
"buffer of size B<PATH_MAX> in cases where B<lstat>(2)  reports a size of "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:293
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:300
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:310
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:313
#, no-wrap
msgid ""
"    /* Add one to the link size, so that we can determine whether\n"
"       the buffer returned by readlink() was truncated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:315
#, no-wrap
msgid "    bufsiz = sb.st_size + 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:319
#, no-wrap
msgid ""
"    /* Some magic symlinks under (for example) /proc and /sys\n"
"       report \\(aqst_size\\(aq as zero. In that case, take PATH_MAX as\n"
"       a \"good enough\" estimate. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:322
#, no-wrap
msgid ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:328
#, no-wrap
msgid ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:334
#, no-wrap
msgid ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:336
#, no-wrap
msgid ""
"    printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) "
"nbytes, buf);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:342
#, no-wrap
msgid ""
"    /* If the return value was equal to the buffer size, then the\n"
"       the link target was larger than expected (perhaps because the\n"
"       target was changed between the call to lstat() and the call to\n"
"       readlink()). Warn the user that the returned target may have\n"
"       been truncated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:345
#, no-wrap
msgid ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Returned buffer may have been truncated)\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:349
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:358
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into "
"multiple buffers"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:38
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:40
#, no-wrap
msgid ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:42
#, no-wrap
msgid ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:51
#, no-wrap
msgid ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:54
#, no-wrap
msgid ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:67
#, no-wrap
msgid ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:77
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:87
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather "
"output\")."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:96
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:103
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:111
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:117
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:136
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov[0]> before proceeding to I<iov[1]>, and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov[0]> before proceeding to I<iov[1]>, and so on."
msgstr ""

#.  Regarding atomicity, see https://bugzilla.kernel.org/show_bug.cgi?id=10596
#. type: Plain text
#: build/C/man2/readv.2:155
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""

#. type: SS
#: build/C/man2/readv.2:155
#, no-wrap
msgid "preadv() and pwritev()"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:168
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:181
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:186
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""

#. type: SS
#: build/C/man2/readv.2:186
#, no-wrap
msgid "preadv2() and pwritev2()"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:194
msgid ""
"These system calls are similar to B<preadv>()  and B<pwritev>()  calls, but "
"add a fifth argument, I<flags>, which modifies the behavior on a per-call "
"basis."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:202
msgid ""
"Unlike B<preadv>()  and B<pwritev>(), if the I<offset> argument is -1, then "
"the current file offset is used and updated."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:206
msgid ""
"The I<flags> argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr ""

#. type: TP
#: build/C/man2/readv.2:206
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: build/C/man2/readv.2:216
msgid ""
"Provide a per-write equivalent of the B<O_DSYNC> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:216
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:224
msgid ""
"High priority read/write.  Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources.  "
"(Currently, this feature is usable only on a file descriptor opened using "
"the B<O_DIRECT> flag.)"
msgstr ""

#. type: TP
#: build/C/man2/readv.2:224
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: build/C/man2/readv.2:234
msgid ""
"Provide a per-write equivalent of the B<O_SYNC> B<open>(2)  flag.  This flag "
"is meaningful only for B<pwritev2>(), and its effect applies only to the "
"data range written by the system call."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:234
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr ""

#.  commit 3239d834847627b6634a4139cf1dc58f6f137a46
#.  commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
#. type: Plain text
#: build/C/man2/readv.2:250
msgid ""
"Do not wait for data which is not immediately available.  If this flag is "
"specified, the B<preadv2>()  system call will return instantly if it would "
"have to read data from the backing storage or wait for a lock.  If some data "
"was successfully read, it will return the number of bytes read.  If no bytes "
"were read, it will return -1 and set I<errno> to B<EAGAIN>.  Currently, this "
"flag is meaningful only for B<preadv2>()."
msgstr ""

#. type: TP
#: build/C/man2/readv.2:250
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr ""

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: build/C/man2/readv.2:267
msgid ""
"Provide a per-write equivalent of the B<O_APPEND> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call.  The I<offset> argument does not "
"affect the write operation; the data is always appended to the end of the "
"file.  However, if the I<offset> argument is -1, the current file offset is "
"updated."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:279
msgid ""
"On success, B<readv>(), B<preadv>(), and B<preadv2>()  return the number of "
"bytes read; B<writev>(), B<pwritev>(), and B<pwritev2>()  return the number "
"of bytes written."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:285
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:287
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:301
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>(), B<preadv2>(), B<pwritev>(), and B<pwritev2>()  can also fail "
"for the same reasons as B<lseek>(2).  Additionally, the following errors are "
"defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:308
msgid "The sum of the I<iov_len> values overflows an I<ssize_t> value."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:313
msgid ""
"The vector count, I<iovcnt>, is less than zero or greater than the permitted "
"maximum."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:316
msgid "An unknown flag is specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:321
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:327
msgid ""
"B<preadv2>()  and B<pwritev2>()  first appeared in Linux 4.6.  Library "
"support was added in glibc 2.26."
msgstr ""

#.  Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
#.  and \fIint\fP as the return type.
#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: build/C/man2/readv.2:336
msgid ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system "
"calls first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:340
msgid "B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:344
msgid "B<preadv2>(), B<pwritev2>(): nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:358
msgid ""
"POSIX.1 allows an implementation to place a limit on the number of items "
"that can be passed in I<iov>.  An implementation can advertise its limit by "
"defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the return "
"value from I<sysconf(_SC_IOV_MAX)>.  On modern Linux systems, the limit is "
"1024.  Back in Linux 2.0 days, this limit was 16."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:368
msgid ""
"The raw B<preadv>()  and B<pwritev>()  system calls have call signatures "
"that differ slightly from that of the corresponding GNU C library wrapper "
"functions shown in the SYNOPSIS.  The final argument, I<offset>, is unpacked "
"by the wrapper functions into two arguments in the system calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:370
msgid "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:373
msgid ""
"These arguments contain, respectively, the low order and high order 32 bits "
"of I<offset>."
msgstr ""

#. type: SS
#: build/C/man2/readv.2:373
#, no-wrap
msgid "Historical C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:399
msgid ""
"To deal with the fact that B<IOV_MAX> was so low on early versions of Linux, "
"the glibc wrapper functions for B<readv>()  and B<writev>()  did some extra "
"work if they detected that the underlying kernel system call failed because "
"this limit was exceeded.  In the case of B<readv>(), the wrapper function "
"allocated a temporary buffer large enough for all of the items specified by "
"I<iov>, passed that buffer in a call to B<read>(2), copied data from the "
"buffer to the locations specified by the I<iov_base> fields of the elements "
"of I<iov>, and then freed the buffer.  The wrapper function for B<writev>()  "
"performed the analogous task using a temporary buffer and a call to "
"B<write>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:410
msgid ""
"The need for this extra effort in the glibc wrapper functions went away with "
"Linux 2.2 and later.  However, glibc continued to provide this behavior "
"until version 2.10.  Starting with glibc version 2.9, the wrapper functions "
"provide this behavior only if the library detects that the system is running "
"a Linux kernel older than version 2.6.18 (an arbitrarily selected kernel "
"version).  And since glibc 2.20 (which requires a minimum Linux kernel "
"version of 2.6.32), the glibc wrapper functions always just directly invoke "
"the system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:413
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:420
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:425
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:427
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:433
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr ""

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the filesystem.  It calls B<unlink>(2)  for "
"files, and B<rmdir>(2)  for directories."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:57 build/C/man2/unlink.2:78
msgid "If the name referred to a symbolic link, the link is removed."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/remove.3:80
#, no-wrap
msgid "B<remove>()"
msgstr ""

#.  .SH NOTES
#.  Under libc4 and libc5,
#.  .BR remove ()
#.  was an alias for
#.  .BR unlink (2)
#.  (and hence would not remove directories).
#. type: Plain text
#: build/C/man3/remove.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:93 build/C/man2/unlink.2:305
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:104
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:59
msgid "B<renameat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:71
msgid "B<renameat2>():"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:86
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:89
msgid ""
"Various restrictions determine whether or not the rename operation succeeds: "
"see ERRORS below."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:101
msgid ""
"If I<newpath> already exists, it will be atomically replaced, so that there "
"is no point at which another process attempting to access I<newpath> will "
"find it missing.  However, there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:109
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:117
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:123
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:129
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""

#. type: SS
#: build/C/man2/rename.2:129
#, no-wrap
msgid "renameat()"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:135
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:145
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:157
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:176
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr ""

#. type: SS
#: build/C/man2/rename.2:176
#, no-wrap
msgid "renameat2()"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:187
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call "
"with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:191
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: build/C/man2/rename.2:191
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:200
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:200
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:208
msgid ""
"Don't overwrite I<newpath> of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:212
msgid "B<RENAME_NOREPLACE> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:216
msgid ""
"B<RENAME_NOREPLACE> requires support from the underlying filesystem.  "
"Support for various filesystems was added as follows:"
msgstr ""

#.  ext4: commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
#. type: Plain text
#: build/C/man2/rename.2:220
msgid "ext4 (Linux 3.15);"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:222
msgid "btrfs, shmem, and cifs (Linux 3.17);"
msgstr ""

#.  btrfs: commit 80ace85c915d0f41016f82917218997b72431258
#.  shmem: commit 3b69ff51d087d265aa4af3a532fc4f20bf33e718
#.  cifs: commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
#
#.  gfs2 in 4.2?
#. type: Plain text
#: build/C/man2/rename.2:229
msgid "xfs (Linux 4.0);"
msgstr ""

#.  Also affs, bfs, exofs, hfs, hfsplus, jffs2, logfs, msdos,
#.  nilfs2, omfs, sysvfs, ubifs, udf, ufs
#.  hugetlbfs, ramfs
#.  local filesystems: commit f03b8ad8d38634d13e802165cc15917481b47835
#.  libfs: commit e0e0be8a835520e2f7c89f214dfda570922a1b90
#. type: Plain text
#: build/C/man2/rename.2:237
msgid ""
"Support for many other filesystems was added in Linux 4.9, including ext2, "
"minix, reiserfs, jfs, vfat, and bpf."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:238
#, no-wrap
msgid "B<RENAME_WHITEOUT> (since Linux 3.18)"
msgstr ""

#.  commit 0d7a855526dd672e114aff2ac22b60fc6f155b08
#.  commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
#. type: Plain text
#: build/C/man2/rename.2:244
msgid ""
"This operation makes sense only for overlay/union filesystem "
"implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:251
msgid ""
"Specifying B<RENAME_WHITEOUT> creates a \"whiteout\" object at the source of "
"the rename at the same time as performing the rename.  The whole operation "
"is atomic, so that if the rename succeeds then the whiteout will also have "
"been created."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:259
msgid ""
"A \"whiteout\" is an object that has special meaning in union/overlay "
"filesystem constructs.  In these constructs, multiple layers exist and only "
"the top one is ever modified.  A whiteout on an upper layer will effectively "
"hide a matching file in the lower layer, making it appear as if the file "
"didn't exist."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:267
msgid ""
"When a file that exists on the lower layer is renamed, the file is first "
"copied up (if not already on the upper layer)  and then renamed on the "
"upper, read-write layer.  At the same time, the source file needs to be "
"\"whiteouted\" (so that the version of the source file in the lower layer is "
"rendered invisible).  The whole operation needs to be done atomically."
msgstr ""

#.  https://www.freebsd.org/cgi/man.cgi?query=mount_unionfs&manpath=FreeBSD+11.0-RELEASE
#. type: Plain text
#: build/C/man2/rename.2:278
msgid ""
"When not part of a union/overlay, the whiteout appears as a character device "
"with a {0,0} device number.  (Note that other union/overlay implementations "
"may employ different methods for storing whiteout entries; specifically, BSD "
"union mount employs a separate inode type, B<DT_WHT>, which, while supported "
"by some filesystems available in Linux, such as CODA and XFS, is ignored by "
"the kernel's whiteout support code, as of Linux 4.19, at least.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:283
msgid ""
"B<RENAME_WHITEOUT> requires the same privileges as creating a device node "
"(i.e., the B<CAP_MKNOD> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:287
msgid "B<RENAME_WHITEOUT> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#.  tmpfs: commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
#.  ext4: commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
#.  XFS: commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
#.  f2fs: commit 7e01e7ad746bc8198a8b46163ddc73a1c7d22339
#.  btrfs: commit cdd1fedf8261cd7a73c0596298902ff4f0f04492
#.  ubifs: commit 9e0a1fff8db56eaaebb74b4a3ef65f86811c4798
#. type: Plain text
#: build/C/man2/rename.2:303
msgid ""
"B<RENAME_WHITEOUT> requires support from the underlying filesystem.  Among "
"the filesystems that provide that support are tmpfs (since Linux 3.18), ext4 "
"(since Linux 3.18), XFS (since Linux 4.1), f2fs (since Linux 4.2), btrfs "
"(since Linux 4.7), and ubifs (since Linux 4.9)."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:328
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:345
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such "
"cases\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:355
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:361
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:372
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:388
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:405
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:405
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:409
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than "
"\".\" and \"..\"."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:409 build/C/man2/unlink.2:224
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:433
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:444
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:449
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:468
msgid "The following additional errors can occur for B<renameat2>():"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:476
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:480
msgid "An invalid flag was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:488
msgid "Both B<RENAME_NOREPLACE> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:496
msgid "Both B<RENAME_WHITEOUT> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:500
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:508
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:516
msgid ""
"B<RENAME_WHITEOUT> was specified in I<flags>, but the caller does not have "
"the B<CAP_MKNOD> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:520
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:523
msgid ""
"B<renameat2>()  was added to Linux in kernel 3.15; library support was added "
"in glibc 2.28."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:526
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:529
msgid "B<renameat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:532
msgid "B<renameat2>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:551
msgid ""
"On older kernels where B<renameat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<rename>().  When I<oldpath> and "
"I<newpath> are relative pathnames, glibc constructs pathnames based on the "
"symbolic links in I</proc/self/fd> that correspond to the I<olddirfd> and "
"I<newdirfd> arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:562
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:571
msgid ""
"B<mv>(1), B<rename>(1), B<chmod>(2), B<link>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux, this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""

#. type: TP
#: build/C/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man2/rmdir.2:108
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1 also allows B<EEXIST> for this "
"condition."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:119
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:124
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:128
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:133
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:142
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""

#. type: TH
#: build/C/man3/scanf.3:52
#, no-wrap
msgid "SCANF"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:55
msgid "scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:62
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:68
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:79
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:81
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:100
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:111
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:123
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:141
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:155
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:157
msgid "A directive is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:163
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:167
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:178
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:186
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:197
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:208
msgid ""
"For decimal conversions, an optional quote character (\\(aq).  This "
"specifies that the input number may include thousands' separators as defined "
"by the B<LC_NUMERIC> category of the current locale.  (See B<setlocale>(3).)  "
"The quote character may precede or follow the \\(aq*\\(aq "
"assignment-suppression character."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:227
msgid ""
"An optional \\(aqm\\(aq character.  This is used with string conversions "
"(I<%s>, I<%c>, I<%[>), and relieves the caller of the need to allocate a "
"corresponding buffer to hold the input: instead, B<scanf>()  allocates a "
"buffer of sufficient size, and assigns the address of this buffer to the "
"corresponding I<pointer> argument, which should be a pointer to a I<char\\ "
"*> variable (this variable does not need to be initialized before the "
"call).  The caller should subsequently B<free>(3)  this buffer when it is no "
"longer required."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:239
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:253
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long> rather than a pointer "
"to an I<int>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:258
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:287
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications, then these correspond in "
"order with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form "
"(which is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer "
"that specifies that the converted input should be placed in the location "
"referred to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""

#. type: SS
#: build/C/man3/scanf.3:287
#, no-wrap
msgid "Conversions"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:291
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:301
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short> or I<unsigned "
"short> (rather than I<int>)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:309
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:318
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: build/C/man3/scanf.3:345
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long> or "
"I<unsigned long> (rather than I<int>), or that the conversion will be one of "
"B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> (rather "
"than I<float>).  Specifying two B<l> characters is equivalent to B<L>.  If "
"used with B<%c> or B<%s>, the corresponding parameter is considered as a "
"pointer to a wide character or wide-character string respectively."
msgstr ""

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: build/C/man3/scanf.3:361
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:366
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:373
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:380
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:384
msgid "The following I<conversion specifiers> are available:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:393
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not "
"occur."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:393
#, no-wrap
msgid "B<d>"
msgstr ""

#.  .TP
#.  .B D
#.  Equivalent to
#.  .IR ld ;
#.  this exists only for backward compatibility.
#.  (Note: thus only in libc4
#.  In libc5 and glibc the
#.  .B %D
#.  is silently ignored, causing old programs to fail mysteriously.)
#. type: Plain text
#: build/C/man3/scanf.3:407
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:407
#, no-wrap
msgid "B<i>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:419
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:419
#, no-wrap
msgid "B<o>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:423
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:423
#, no-wrap
msgid "B<u>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:428
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:438
msgid ""
"Matches an unsigned hexadecimal integer (that may optionally begin with a "
"prefix of I<0x> or I<0X>, which is discarded); the next pointer must be a "
"pointer to I<unsigned int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:438
#, no-wrap
msgid "B<X>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:442
msgid "Equivalent to B<x>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:442
#, no-wrap
msgid "B<f>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:447
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:447
#, no-wrap
msgid "B<e>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:451 build/C/man3/scanf.3:455 build/C/man3/scanf.3:459
msgid "Equivalent to B<f>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:451
#, no-wrap
msgid "B<g>"
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:455
#, no-wrap
msgid "B<E>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:463
msgid "(C99) Equivalent to B<f>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:471
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to the initial element of a character array that is long enough to "
"hold the input sequence and the terminating null byte (\\(aq\\e0\\(aq), "
"which is added automatically.  The input string stops at white space or at "
"the maximum field width, whichever occurs first."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:481
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:481
#, no-wrap
msgid "B<\\&[>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:514
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<\\(ha>).  To "
"include a close bracket in the set, make it the first character after the "
"open bracket or the circumflex; any other position will end the set.  The "
"hyphen character B<-> is also special; when placed between two other "
"characters, it adds all intervening characters to the set.  To include a "
"hyphen, make it the last character before the final close bracket.  For "
"instance, B<[\\(ha]0-9-]> means the set \"everything except close bracket, "
"zero through nine, and hyphen\".  The string ends with the appearance of a "
"character not in the (or, with a circumflex, in) set or when the field width "
"runs out."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:522
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3)); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:540
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion and does I<not> increase the count "
"returned by the function.  The assignment can be suppressed with the B<*> "
"assignment-suppression character, but the effect on the return value is "
"undefined.  Therefore B<%*n> conversions should not be used."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:545
msgid ""
"On success, these functions return the number of input items successfully "
"matched and assigned; this can be fewer than provided for, or even zero, in "
"the event of an early matching failure."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:557
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:563
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:568
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for "
"reading."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:571
msgid "Input byte sequence does not form a valid character."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:575
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:580
msgid "Not enough arguments; or I<format> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:583
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:583
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:587
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr ""

#. type: tbl table
#: build/C/man3/scanf.3:598
#, no-wrap
msgid ""
"B<scanf>(),\n"
"B<fscanf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/scanf.3:601
#, no-wrap
msgid ""
"B<sscanf>(),\n"
"B<vscanf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/scanf.3:604
#, no-wrap
msgid ""
"B<vsscanf>(),\n"
"B<vfscanf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:617
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:627
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:638
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""

#. type: SS
#: build/C/man3/scanf.3:639
#, no-wrap
msgid "The 'a' assignment-allocation modifier"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:650
msgid ""
"Originally, the GNU C library supported dynamic allocation for string inputs "
"(as a nonstandard extension) via the B<a> character.  (This feature is "
"present at least as far back as glibc 2.0.)  Thus, one could write the "
"following to have B<scanf>()  allocate a buffer for an input string, with a "
"pointer to that buffer being returned in I<*buf>:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:653
#, no-wrap
msgid ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:664
msgid ""
"The use of the letter B<a> for this purpose was problematic, since B<a> is "
"also specified by the ISO C standard as a synonym for B<f> (floating-point "
"input).  POSIX.1-2008 instead specifies the B<m> modifier for assignment "
"allocation (as documented in DESCRIPTION, above)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:676
msgid ""
"Note that the B<a> modifier is not available if the program is compiled with "
"I<gcc -std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:682
msgid ""
"Support for the B<m> modifier was added to glibc starting with version 2.7, "
"and new programs should use that modifier instead of B<a>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:688
msgid ""
"As well as being standardized by POSIX, the B<m> modifier has the following "
"further advantages over the use of B<a:>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:693
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:699
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:712
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:728
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g., B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:734
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:744
msgid ""
"To use the dynamic allocation conversion specifier, specify B<m> as a length "
"modifier (thus B<%ms> or B<%m[>I<range>B<]>).  The caller must B<free>(3)  "
"the returned string, as in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:749
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:760
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:768
msgid ""
"As shown in the above example, it is necessary to call B<free>(3)  only if "
"the B<scanf>()  call successfully read a string."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:775
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""

#. type: TH
#: build/C/man3/setbuf.3:48
#, no-wrap
msgid "SETBUF"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:51
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:58
#, no-wrap
msgid "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:60
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:63
#, no-wrap
msgid ""
"B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:76
#, no-wrap
msgid ""
"B<setbuffer>(),\n"
"B<setlinebuf>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:89
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:97
msgid ""
"Normally all files are block buffered.  If a stream refers to a terminal (as "
"I<stdout> normally does), it is line buffered.  The standard error stream "
"I<stderr> is always unbuffered by default."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:104
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:105
#, no-wrap
msgid "B<_IONBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:108
msgid "unbuffered"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:108
#, no-wrap
msgid "B<_IOLBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:111
msgid "line buffered"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:111
#, no-wrap
msgid "B<_IOFBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:114
msgid "fully buffered"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:130
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at "
"least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The "
"B<setvbuf>()  function may be used only after opening a stream and before "
"any other operations have been performed on it."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:136
msgid ""
"The other three calls are, in effect, simply aliases for calls to "
"B<setvbuf>().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:139
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:149
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer "
"is up to the caller, rather than being determined by the default B<BUFSIZ>.  "
"The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:152
msgid "setvbuf(stream, NULL, _IOLBF, 0);"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:163
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:165
msgid "The other functions do not return a value."
msgstr ""

#. type: tbl table
#: build/C/man3/setbuf.3:176
#, no-wrap
msgid ""
"B<setbuf>(),\n"
"B<setbuffer>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/setbuf.3:179
#, no-wrap
msgid ""
"B<setlinebuf>(),\n"
"B<setvbuf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:187
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr ""

#.  The
#.  .BR setbuffer ()
#.  and
#.  .BR setlinebuf ()
#.  functions are not portable to versions of BSD before 4.2BSD, and
#.  are available under Linux since libc 4.5.21.
#.  On 4.2BSD and 4.3BSD systems,
#.  .BR setbuf ()
#.  always uses a suboptimal buffer size and should be avoided.
#. .PP
#. type: Plain text
#: build/C/man3/setbuf.3:204
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:207
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:216
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:226
msgid ""
"B<stdbuf>(1), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), "
"B<malloc>(3), B<printf>(3), B<puts>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdin.3:13
#, no-wrap
msgid "STDIN"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:16
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:23
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:35
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4))  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:45
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to "
"refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:54
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:63
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:82
msgid ""
"On program startup, the integer file descriptors associated with the streams "
"I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO> "
"are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying "
"B<freopen>(3)  to one of these streams can change the file descriptor number "
"associated with the stream.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:95
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:113
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3), "
"specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and "
"by normal program termination."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:122
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:154
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until "
"B<fflush>(3)  or B<exit>(3)  is called, or a newline is printed.  This can "
"produce unexpected results, especially with debugging output.  The buffering "
"mode of the standard streams (or any other stream)  can be changed using the "
"B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:160
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdio.3:39
#, no-wrap
msgid "STDIO"
msgstr ""

#. type: TH
#: build/C/man3/stdio.3:39
#, no-wrap
msgid "2017-11-26"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:42
msgid "stdio - standard input/output library functions"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:46
msgid "B<FILE *>I<stdin>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:48
msgid "B<FILE *>I<stdout>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:50
msgid "B<FILE *>I<stderr>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:57
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O "
"interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:80
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal), then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning "
"requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:90
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:103
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned "
"at the start).  If the main function returns to its original caller, or the "
"B<exit>(3)  function is called, all open files are closed (hence all output "
"streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files "
"properly."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:120
msgid ""
"At program startup, three text streams are predefined and need not be opened "
"explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional output), and I<standard error> (for "
"writing diagnostic output).  These streams are abbreviated I<stdin>, "
"I<stdout>, and I<stderr>.  When opened, the standard error stream is not "
"fully buffered; the standard input and output streams are fully buffered if "
"and only if the streams do not refer to an interactive device."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:130
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an "
"input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before "
"going off and computing so that the output will appear."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:142
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by B<cc>(1).  The SYNOPSIS sections of the "
"following manual pages indicate which include files are to be used, what the "
"compiler declaration for the function looks like and which external "
"variables are of interest."
msgstr ""

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: build/C/man3/stdio.3:182
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""

#. type: SS
#: build/C/man3/stdio.3:182
#, no-wrap
msgid "List of functions"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "Function"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "Description"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:188
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:189
#, no-wrap
msgid "B<clearerr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:189 build/C/man3/stdio.3:192 build/C/man3/stdio.3:193
#, no-wrap
msgid "check and reset stream status"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "B<fclose>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "close a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:191
#, no-wrap
msgid "B<fdopen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:191 build/C/man3/stdio.3:199 build/C/man3/stdio.3:205
#, no-wrap
msgid "stream open functions"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:192
#, no-wrap
msgid "B<feof>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:193
#, no-wrap
msgid "B<ferror>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:194
#, no-wrap
msgid "B<fflush>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:194 build/C/man3/stdio.3:201
#, no-wrap
msgid "flush a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:195
#, no-wrap
msgid "B<fgetc>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:195 build/C/man3/stdio.3:211 build/C/man3/stdio.3:212 build/C/man3/stdio.3:214
#, no-wrap
msgid "get next character or word from input stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:196
#, no-wrap
msgid "B<fgetpos>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:196 build/C/man3/stdio.3:207 build/C/man3/stdio.3:208 build/C/man3/stdio.3:209 build/C/man3/stdio.3:223
#, no-wrap
msgid "reposition a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:197
#, no-wrap
msgid "B<fgets>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:197 build/C/man3/stdio.3:213
#, no-wrap
msgid "get a line from a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "B<fileno>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "return the integer descriptor of the argument stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:199
#, no-wrap
msgid "B<fopen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:200
#, no-wrap
msgid "B<fprintf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:200 build/C/man3/stdio.3:217 build/C/man3/stdio.3:229 build/C/man3/stdio.3:238 build/C/man3/stdio.3:240 build/C/man3/stdio.3:242
#, no-wrap
msgid "formatted output conversion"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:201
#, no-wrap
msgid "B<fpurge>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:202
#, no-wrap
msgid "B<fputc>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:202 build/C/man3/stdio.3:218 build/C/man3/stdio.3:219 build/C/man3/stdio.3:221
#, no-wrap
msgid "output a character or word to a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:203
#, no-wrap
msgid "B<fputs>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:203 build/C/man3/stdio.3:220
#, no-wrap
msgid "output a line to a stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:204
#, no-wrap
msgid "B<fread>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:204 build/C/man3/stdio.3:210
#, no-wrap
msgid "binary stream input/output"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:205
#, no-wrap
msgid "B<freopen>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:206
#, no-wrap
msgid "B<fscanf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:206 build/C/man3/stdio.3:224 build/C/man3/stdio.3:230 build/C/man3/stdio.3:239 build/C/man3/stdio.3:241 build/C/man3/stdio.3:243
#, no-wrap
msgid "input format conversion"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:208
#, no-wrap
msgid "B<fsetpos>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:209
#, no-wrap
msgid "B<ftell>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:210
#, no-wrap
msgid "B<fwrite>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:211
#, no-wrap
msgid "B<getc>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:212
#, no-wrap
msgid "B<getchar>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:213
#, no-wrap
msgid "B<gets>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:214
#, no-wrap
msgid "B<getw>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "B<mktemp>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "make temporary filename (unique)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:216
#, no-wrap
msgid "B<perror>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:216 build/C/man3/stdio.3:231 build/C/man3/stdio.3:232 build/C/man3/stdio.3:233
#, no-wrap
msgid "system error messages"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:217
#, no-wrap
msgid "B<printf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:218
#, no-wrap
msgid "B<putc>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:219
#, no-wrap
msgid "B<putchar>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:220
#, no-wrap
msgid "B<puts>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:221
#, no-wrap
msgid "B<putw>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "B<remove>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "remove directory entry"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:223
#, no-wrap
msgid "B<rewind>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:224
#, no-wrap
msgid "B<scanf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:225
#, no-wrap
msgid "B<setbuf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:225 build/C/man3/stdio.3:226 build/C/man3/stdio.3:227 build/C/man3/stdio.3:228
#, no-wrap
msgid "stream buffering operations"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:226
#, no-wrap
msgid "B<setbuffer>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:227
#, no-wrap
msgid "B<setlinebuf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:228
#, no-wrap
msgid "B<setvbuf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:229
#, no-wrap
msgid "B<sprintf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:230
#, no-wrap
msgid "B<sscanf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:231
#, no-wrap
msgid "B<strerror>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:232
#, no-wrap
msgid "B<sys_errlist>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:233
#, no-wrap
msgid "B<sys_nerr>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:234
#, no-wrap
msgid "B<tempnam>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:234 build/C/man3/stdio.3:235 build/C/man3/stdio.3:236
#, no-wrap
msgid "temporary file routines"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:235
#, no-wrap
msgid "B<tmpfile>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:236
#, no-wrap
msgid "B<tmpnam>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "B<ungetc>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "un-get character from input stream"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:238
#, no-wrap
msgid "B<vfprintf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:239
#, no-wrap
msgid "B<vfscanf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:240
#, no-wrap
msgid "B<vprintf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:241
#, no-wrap
msgid "B<vscanf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:242
#, no-wrap
msgid "B<vsprintf>(3)"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:243
#, no-wrap
msgid "B<vsscanf>(3)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:249
msgid "The I<stdio> library conforms to C89."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:256
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdio_ext.3:25
#, no-wrap
msgid "STDIO_EXT"
msgstr ""

#. type: TH
#: build/C/man3/stdio_ext.3:25
#, no-wrap
msgid "2015-03-02"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:30
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE "
"structure"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:34
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:45
#, no-wrap
msgid ""
"B<size_t __fbufsize(FILE *>I<stream>B<);>\n"
"B<size_t __fpending(FILE *>I<stream>B<);>\n"
"B<int __flbf(FILE *>I<stream>B<);>\n"
"B<int __freadable(FILE *>I<stream>B<);>\n"
"B<int __fwritable(FILE *>I<stream>B<);>\n"
"B<int __freading(FILE *>I<stream>B<);>\n"
"B<int __fwriting(FILE *>I<stream>B<);>\n"
"B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>\n"
"B<void _flushlbf(void);>\n"
"B<void __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:51
msgid ""
"Solaris introduced routines to allow portable access to the internals of the "
"I<FILE> structure, and glibc also implemented these."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:56
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:63
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:68
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is "
"line-buffered, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:73
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:78
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:84
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is "
"read-only, or if the last operation on the stream was a read operation, and "
"zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:90
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is "
"write-only (or append-only), or if the last operation on the stream was a "
"write operation, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:98
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:98
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:103
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:103
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:110
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in "
"case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:110
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:114
msgid "Don't change the type of locking.  (Only return it.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:120
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably "
"so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:124
msgid "The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:135
#, no-wrap
msgid ""
"B<__fbufsize>(),\n"
"B<__fpending>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:138
#, no-wrap
msgid ""
"B<__fpurge>(),\n"
"B<__fsetlocking>()"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:142
#, no-wrap
msgid ""
"B<__flbf>(),\n"
"B<__freadable>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:145
#, no-wrap
msgid ""
"B<__freading>(),\n"
"B<__fwritable>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio_ext.3:148
#, no-wrap
msgid ""
"B<__fwriting>(),\n"
"B<_flushlbf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:153
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr ""

#. type: TH
#: build/C/man2/symlink.2:33 build/C/man7/symlink.7:37
#, no-wrap
msgid "SYMLINK"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:36
msgid "symlink, symlinkat - make a new name for a file"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:41
#, no-wrap
msgid "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:47
#, no-wrap
msgid ""
"B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char "
"*>I<linkpath>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:56
msgid "B<symlink>():"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:63
msgid "B<symlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:81
msgid ""
"B<symlink>()  creates a symbolic link named I<linkpath> which contains the "
"string I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:85
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:90
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:94
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:101
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit (B<S_ISVTX>)  "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:107
msgid "If I<linkpath> exists, it will I<not> be overwritten."
msgstr ""

#. type: SS
#: build/C/man2/symlink.2:107
#, no-wrap
msgid "symlinkat()"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:113
msgid ""
"The B<symlinkat>()  system call operates in exactly the same way as "
"B<symlink>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:123
msgid ""
"If the pathname given in I<linkpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<newdirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<symlink>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:135
msgid ""
"If I<linkpath> is relative and I<newdirfd> is the special value B<AT_FDCWD>, "
"then I<linkpath> is interpreted relative to the current working directory of "
"the calling process (like B<symlink>())."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:141
msgid "If I<linkpath> is absolute, then I<newdirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:156
msgid ""
"Write access to the directory containing I<linkpath> is denied, or one of "
"the directories in the path prefix of I<linkpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:161
msgid ""
"The user's quota of resources on the filesystem has been exhausted.  The "
"resources could be inodes or disk blocks, depending on the filesystem "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:165
msgid "I<linkpath> already exists."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:168
msgid "I<target> or I<linkpath> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:175
msgid "Too many symbolic links were encountered in resolving I<linkpath>."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:178
msgid "I<target> or I<linkpath> was too long."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:187
msgid ""
"A directory component in I<linkpath> does not exist or is a dangling "
"symbolic link, or I<target> or I<linkpath> is an empty string."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:199
msgid "A component used as a directory in I<linkpath> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:204
msgid ""
"The filesystem containing I<linkpath> does not support the creation of "
"symbolic links."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:208
msgid "I<linkpath> is on a read-only filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:211
msgid "The following additional errors can occur for B<symlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:215
msgid "I<newdirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:221
msgid ""
"I<linkpath> is a relative pathname and I<newdirfd> refers to a directory "
"that has been deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:227
msgid ""
"I<linkpath> is relative and I<newdirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:231
msgid ""
"B<symlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional error codes EDQUOT and ENOSYS.
#.  See
#.  .BR open (2)
#.  re multiple files with the same name, and NFS.
#. type: Plain text
#: build/C/man2/symlink.2:238
msgid "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:241
msgid "B<symlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:245
msgid "No checking of I<target> is done."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:250
msgid ""
"Deleting the name referred to by a symbolic link will actually delete the "
"file (unless it also has other hard links).  If this behavior is not "
"desired, use B<link>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:263
msgid ""
"On older kernels where B<symlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<symlink>().  When I<linkpath> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<newdirfd> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:275
msgid ""
"B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), "
"B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:40
msgid "symlink - symbolic link handling"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:44
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand "
"their behavior, you must first understand how hard links work."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:60
msgid ""
"A hard link to a file is indistinguishable from the original file because it "
"is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same I<inode "
"number>, where an inode number is an index into the inode table, which "
"contains metadata about all files on a filesystem.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops "
"within the filesystem tree, which would confuse many programs)  and may not "
"refer to files on different filesystems (because inode numbers are not "
"unique across filesystems)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:69
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname of another file, the file to which the link refers.  (The "
"contents of a symbolic link can be read using B<readlink>(2).)  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories "
"and may cross filesystem boundaries."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:75
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist "
"is said to be a I<dangling link>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:88
msgid ""
"Because a symbolic link and its referenced object coexist in the filesystem "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls "
"adopted their own link-following conventions in a somewhat ad-hoc fashion.  "
"Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:88
#, no-wrap
msgid "Magic links"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:101
msgid ""
"There is a special class of symbolic-link-like objects known as \"magic "
"links\", which can be found in certain pseudofilesystems such as B<proc>(5)  "
"(examples include I</proc/[pid]/exe> and I</proc/[pid]/fd/*>).  Unlike "
"normal symbolic links, magic links are not resolved through "
"pathname-expansion, but instead act as direct references to the kernel's own "
"representation of a file handle.  As such, these magic links allow users to "
"access files which cannot be referenced with normal paths (such as unlinked "
"files still referenced by a running program )."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:107
msgid ""
"Because they can bypass ordinary B<mount_namespaces>(7)-based restrictions, "
"magic links have been used as attack vectors in various exploits."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:107
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:115
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:121
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""

#.  Linux does not currently implement an lchmod(2).
#. type: Plain text
#: build/C/man7/symlink.7:126
msgid ""
"On Linux, the permissions of an ordinary symbolic link are not used in any "
"operations; the permissions are always 0777 (read, write, and execute for "
"all user categories), and can't be changed."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:130
msgid ""
"However, magic links do not follow this rule.  They can have a non-0777 "
"mode, though this mode is not currently used in any permission checks."
msgstr ""

#
#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: SS
#: build/C/man7/symlink.7:144
#, no-wrap
msgid "Obtaining a file descriptor that refers to a symbolic link"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:162
msgid ""
"Using the combination of the B<O_PATH> and B<O_NOFOLLOW> flags to B<open>(2)  "
"yields a file descriptor that can be passed as the I<dirfd> argument in "
"system calls such as B<fstatat>(2), B<fchownat>(2), B<fchmodat>(2), "
"B<linkat>(2), and B<readlinkat>(2), in order to operate on the symbolic link "
"itself (rather than the file to which it refers)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:178
msgid ""
"By default (i.e., if the B<AT_SYMLINK_FOLLOW> flag is not specified), if "
"B<name_to_handle_at>(2)  is applied to a symbolic link, it yields a handle "
"for the symbolic link (rather than the file to which it refers).  One can "
"then obtain a file descriptor for the symbolic link (rather than the file to "
"which it refers)  by specifying the B<O_PATH> flag in a subsequent call to "
"B<open_by_handle_at>(2).  Again, that file descriptor can be used in the "
"aforementioned system calls to operate on the symbolic link itself."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:178
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:193
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:196
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:196 build/C/man7/symlink.7:226
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:198
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:198 build/C/man7/symlink.7:234
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:201
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not "
"traversing a file tree."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:201
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:205
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:220
msgid ""
"Before describing the treatment of symbolic links by system calls and "
"commands, we require some terminology.  Given a pathname of the form "
"I<a/b/c>, the part preceding the final slash (i.e., I<a/b>)  is called the "
"I<dirname> component, and the part following the final slash (i.e., I<c>)  "
"is called the I<basename> component."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:220
#, no-wrap
msgid "Treatment of symbolic links in system calls"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:223
msgid ""
"The first area is symbolic links used as filename arguments for system "
"calls."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:226
msgid ""
"The treatment of symbolic links within a pathname passed to a system call is "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:234
msgid ""
"Within the dirname component of a pathname, symbolic links are always "
"followed in nearly every system call.  (This is also true for commands.)  "
"The one exception is B<openat2>(2), which provides flags that can be used to "
"explicitly prevent following of symbolic links in the dirname component."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:246
msgid ""
"Except as noted below, all system calls follow symbolic links in the "
"basename component of a pathname.  For example, if there were a symbolic "
"link I<slink> which pointed to a file named I<afile>, the system call "
"I<open(\"slink\" ...\\&)> would return a file descriptor referring to the "
"file I<afile>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:262
msgid ""
"Various system calls do not follow links in the basename component of a "
"pathname, and operate on the symbolic link itself.  They are: B<lchown>(2), "
"B<lgetxattr>(2), B<llistxattr>(2), B<lremovexattr>(2), B<lsetxattr>(2), "
"B<lstat>(2), B<readlink>(2), B<rename>(2), B<rmdir>(2), and B<unlink>(2)."
msgstr ""

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: build/C/man7/symlink.7:287
msgid ""
"Certain other system calls optionally follow symbolic links in the basename "
"component of a pathname.  They are: B<faccessat>(2), B<fchownat>(2), "
"B<fstatat>(2), B<linkat>(2), B<name_to_handle_at>(2), B<open>(2), "
"B<openat>(2), B<open_by_handle_at>(2), and B<utimensat>(2); see their manual "
"pages for details.  Because B<remove>(3)  is an alias for B<unlink>(2), that "
"library function also does not follow symbolic links.  When B<rmdir>(2)  is "
"applied to a symbolic link, it fails with the error B<ENOTDIR>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:301
msgid ""
"B<link>(2)  warrants special discussion.  POSIX.1-2001 specifies that "
"B<link>(2)  should dereference I<oldpath> if it is a symbolic link.  "
"However, Linux does not do this.  (By default, Solaris is the same, but the "
"POSIX.1-2001 specified behavior can be obtained with suitable compiler "
"options.)  POSIX.1-2008 changed the specification to allow either behavior "
"in an implementation."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:301
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:304
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:315
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the "
"contents of the file I<afile>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:323
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees; for example, the command I<chown file> is "
"included in this rule, while the command I<chown\\ -R file>, which performs "
"a tree traversal, is not.  (The latter is described in the third area, "
"below.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:341
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link\\(emfor example, it is desired that "
"I<chown slink> change the ownership of the file that I<slink> is, whether it "
"is a symbolic link or not\\(emthen the I<-h> option should be used.  In the "
"above example, I<chown root slink> would change the ownership of the file "
"referred to by I<slink>, while I<chown\\ -h root slink> would change the "
"ownership of I<slink> itself."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:343
msgid "There are some exceptions to this rule:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:353
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may "
"no longer be correct.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:383
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk\\(emthat is, "
"I<-R> option is not specified), the B<ls>(1)  command follows symbolic links "
"named as arguments if the I<-H> or I<-L> option is specified, or if the "
"I<-F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is "
"the only command where the I<-H> and I<-L> options affect its behavior even "
"though it is not doing a walk of a file tree.)"
msgstr ""

#
#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: build/C/man7/symlink.7:401
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the "
"I<-L> option is specified."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:401
#, no-wrap
msgid "Commands traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:414
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), "
"B<ls>(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:418
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links "
"listed as command-line arguments."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:423
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:435
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:440
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a "
"\"logical\" walk (where symbolic links that refer to directories are "
"followed)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:443
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:456
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H> "
"(for \"half-logical\") flag.  This flag is intended to make the command-line "
"name space look like the logical name space.  (Note, for commands that do "
"not always do file tree traversals, the I<-H> flag will be ignored if the "
"I<-R> flag is not also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:472
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not "
"the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:486
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look "
"like the logical name space.  (Note, for commands that do not always do file "
"tree traversals, the I<-L> flag will be ignored if the I<-R> flag is not "
"also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:501
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:508
msgid ""
"A command can be made to provide the default behavior by specifying the "
"I<-P> (for \"physical\") flag.  This flag is intended to make the entire "
"name space look like the physical name space."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:526
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, "
"I<-L>, and I<-P> flags are ignored if the I<-R> flag is not also specified.  "
"In addition, you may specify the I<-H>, I<-L>, and I<-P> options more than "
"once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and "
"then override that behavior on the command line."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:532
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:545
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:565
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command "
"line.  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:584
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<namei>(1), B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), "
"B<readlink>(2), B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), "
"B<lutimes>(3), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man3/tempnam.3:25
#, no-wrap
msgid "TEMPNAM"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:28
msgid "tempnam - create a name for a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:33
#, no-wrap
msgid "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:45
#, no-wrap
msgid ""
"B<tempnam>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:52
msgid "I<Never use this function.> Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:66
msgid ""
"The B<tempnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist when "
"B<tempnam>()  checked.  The filename suffix of the pathname generated will "
"start with I<pfx> in case I<pfx> is a non-NULL string of at most five "
"bytes.  The directory prefix part of the pathname generated is required to "
"be \"appropriate\" (often that at least implies writable)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:69
msgid "Attempts to find an appropriate directory go through the following steps:"
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:69
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:75
msgid ""
"In case the environment variable B<TMPDIR> exists and contains the name of "
"an appropriate directory, that is used."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:75
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:80
msgid "Otherwise, if the I<dir> argument is non-NULL and appropriate, it is used."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:80
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:87
msgid ""
"Otherwise, I<P_tmpdir> (as defined in I<E<lt>stdio.hE<gt>>)  is used when "
"appropriate."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:87
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:90
msgid "Finally an implementation-defined directory may be used."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:97
msgid ""
"The string returned by B<tempnam>()  is allocated using B<malloc>(3)  and "
"hence should be freed by B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:104
msgid ""
"On success, the B<tempnam>()  function returns a pointer to a unique "
"temporary filename.  It returns NULL if a unique name cannot be generated, "
"with I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:108
msgid "Allocation of storage failed."
msgstr ""

#. type: tbl table
#: build/C/man3/tempnam.3:118
#, no-wrap
msgid "B<tempnam>()"
msgstr ""

#. type: tbl table
#: build/C/man3/tempnam.3:118
#, no-wrap
msgid "MT-Safe env"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:125
msgid "SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<tempnam>()  as obsolete."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:144
msgid ""
"Although B<tempnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tempnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:152
msgid ""
"SUSv2 does not mention the use of B<TMPDIR>; glibc will use it only when the "
"program is not set-user-ID.  On SVr4, the directory used under B<d)> is "
"I</tmp> (and this is what glibc does)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:157
msgid ""
"Because it dynamically allocates memory used to return the pathname, "
"B<tempnam>()  is reentrant, and thus thread safe, unlike B<tmpnam>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:170
msgid ""
"The B<tempnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> (defined in I<E<lt>stdio.hE<gt>>)  times.  If it is "
"called more than B<TMP_MAX> times, the behavior is implementation defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:174
msgid "B<tempnam>()  uses at most the first five bytes from I<pfx>."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:180
msgid ""
"The glibc implementation of B<tempnam>()  fails with the error B<EEXIST> "
"upon failure to find a unique name."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:183
msgid ""
"The precise meaning of \"appropriate\" is undefined; it is unspecified how "
"accessibility of a directory is determined."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:188
msgid "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: build/C/man3/tmpfile.3:31
#, no-wrap
msgid "TMPFILE"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:34
msgid "tmpfile - create a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:39
#, no-wrap
msgid "B<FILE *tmpfile(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:47
msgid ""
"The B<tmpfile>()  function opens a unique temporary file in binary "
"read/write (w+b) mode.  The file will be automatically deleted when it is "
"closed or the program terminates."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:56
msgid ""
"The B<tmpfile>()  function returns a stream descriptor, or NULL if a unique "
"filename cannot be generated or the unique file cannot be opened.  In the "
"latter case, I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:60
msgid "Search permission denied for directory in file's path prefix."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:63
msgid "Unable to generate a unique filename."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:67
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:76
msgid "There was no room in the directory to add the new filename."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:79
msgid "Read-only filesystem."
msgstr ""

#. type: tbl table
#: build/C/man3/tmpfile.3:89
#, no-wrap
msgid "B<tmpfile>()"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:93
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD, SUSv2."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:99
msgid ""
"POSIX.1-2001 specifies: an error message may be written to I<stdout> if the "
"stream cannot be opened."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:110
msgid ""
"The standard does not specify the directory that B<tmpfile>()  will use.  "
"Glibc will try the path prefix I<P_tmpdir> defined in I<E<lt>stdio.hE<gt>>, "
"and if that fails the directory I</tmp>."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:116
msgid "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: build/C/man3/tmpnam.3:27
#, no-wrap
msgid "TMPNAM"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:30
msgid "tmpnam, tmpnam_r - create a name for a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:36
#, no-wrap
msgid ""
"B<char *tmpnam(char *>I<s>B<);>\n"
"B<char *tmpnam_r(char *>I<s>B<);>\n"
msgstr ""

#. type: tbl table
#: build/C/man3/tmpnam.3:44 build/C/man3/tmpnam.3:123
#, no-wrap
msgid "B<tmpnam_r>()"
msgstr ""

#. type: TP
#: build/C/man3/tmpnam.3:47
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:50
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/tmpnam.3:50
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:53
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:63
msgid ""
"B<Note:> avoid using these functions; use B<mkstemp>(3)  or B<tmpfile>(3)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:85
msgid ""
"The B<tmpnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist at some point in "
"time, so that naive programmers may think it a suitable name for a temporary "
"file.  If the argument I<s> is NULL, this name is generated in an internal "
"static buffer and may be overwritten by the next call to B<tmpnam>().  If "
"I<s> is not NULL, the name is copied to the character array (of length at "
"least I<L_tmpnam>)  pointed to by I<s> and the value I<s> is returned in "
"case of success."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:97
msgid ""
"The created pathname has a directory prefix I<P_tmpdir>.  (Both I<L_tmpnam> "
"and I<P_tmpdir> are defined in I<E<lt>stdio.hE<gt>>, just like the "
"B<TMP_MAX> mentioned below.)"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:105
msgid ""
"The B<tmpnam_r>()  function performs the same task as B<tmpnam>(), but "
"returns NULL (to indicate an error) if I<s> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:108
msgid ""
"These functions return a pointer to a unique temporary filename, or NULL if "
"a unique name cannot be generated."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:110
msgid "No errors are defined."
msgstr ""

#. type: tbl table
#: build/C/man3/tmpnam.3:120
#, no-wrap
msgid "B<tmpnam>()"
msgstr ""

#. type: tbl table
#: build/C/man3/tmpnam.3:120
#, no-wrap
msgid "MT-Unsafe race:tmpnam/!s"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:131
msgid ""
"B<tmpnam>(): SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 marks "
"B<tmpnam>()  as obsolete."
msgstr ""

#.  Appears to be on Solaris
#. type: Plain text
#: build/C/man3/tmpnam.3:136
msgid ""
"B<tmpnam_r>()  is a nonstandard extension that is also available on a few "
"other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:147
msgid ""
"The B<tmpnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> times.  If it is called more than B<TMP_MAX> times, "
"the behavior is implementation defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:163
msgid ""
"Although these functions generate names that are difficult to guess, it is "
"nevertheless possible that between the time that the pathname is returned "
"and the time that the program opens it, another program might create that "
"pathname using B<open>(2), or create it as a symbolic link.  This can lead "
"to security holes.  To avoid such possibilities, use the B<open>(2)  "
"B<O_EXCL> flag to open the pathname.  Or better yet, use B<mkstemp>(3)  or "
"B<tmpfile>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:171
msgid ""
"Portable applications that use threads cannot call B<tmpnam>()  with a NULL "
"argument if either B<_POSIX_THREADS> or B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:178
msgid "Never use these functions.  Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:183
msgid "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"
msgstr ""

#. type: TH
#: build/C/man2/unlink.2:33
#, no-wrap
msgid "UNLINK"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:36
msgid "unlink, unlinkat - delete a name and possibly the file it refers to"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:41
#, no-wrap
msgid "B<int unlink(const char *>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:46
#, no-wrap
msgid ""
"B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:54
msgid "B<unlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:72
msgid ""
"B<unlink>()  deletes a name from the filesystem.  If that name was the last "
"link to a file and no processes have the file open, the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:76
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:82
msgid ""
"If the name referred to a socket, FIFO, or device, the name for it is "
"removed but processes which have the object open may continue to use it."
msgstr ""

#. type: SS
#: build/C/man2/unlink.2:82
#, no-wrap
msgid "unlinkat()"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:95
msgid ""
"The B<unlinkat>()  system call operates in exactly the same way as either "
"B<unlink>()  or B<rmdir>(2)  (depending on whether or not I<flags> includes "
"the B<AT_REMOVEDIR> flag)  except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:107
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
"pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:121
msgid ""
"If the pathname given in I<pathname> is relative and I<dirfd> is the special "
"value B<AT_FDCWD>, then I<pathname> is interpreted relative to the current "
"working directory of the calling process (like B<unlink>()  and "
"B<rmdir>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:127
msgid "If the pathname given in I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:133
msgid ""
"I<flags> is a bit mask that can either be specified as 0, or by ORing "
"together flag values that control the operation of B<unlinkat>().  "
"Currently, only one such flag is defined:"
msgstr ""

#. type: TP
#: build/C/man2/unlink.2:133
#, no-wrap
msgid "B<AT_REMOVEDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:148
msgid ""
"By default, B<unlinkat>()  performs the equivalent of B<unlink>()  on "
"I<pathname>.  If the B<AT_REMOVEDIR> flag is specified, then performs the "
"equivalent of B<rmdir>(2)  on I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<unlinkat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:169
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:178
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:190
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:194
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:204
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:212
msgid "A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:221
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""

#. type: TP
#: build/C/man2/unlink.2:221
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:224
msgid "The filesystem does not allow unlinking of files."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:235
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:240
msgid ""
"The file to be unlinked is marked immutable or append-only.  (See "
"B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:244
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:253
msgid ""
"The same errors that occur for B<unlink>()  and B<rmdir>(2)  can also occur "
"for B<unlinkat>().  The following additional errors can occur for "
"B<unlinkat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:268
msgid ""
"I<pathname> refers to a directory, and B<AT_REMOVEDIR> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:278
msgid ""
"B<unlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EINTR, EMULTIHOP, ETXTBSY, ENOLINK.
#. type: Plain text
#: build/C/man2/unlink.2:283
msgid "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:286
msgid "B<unlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:302
msgid ""
"On older kernels where B<unlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<unlink>()  or B<rmdir>(2).  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:318
msgid ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man3/unlocked_stdio.3:25
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:29
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:37
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:49
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:52
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:63
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE "
"*>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:75
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:79
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:90
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:93
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:104
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:115
msgid ""
"Each of these functions has the same behavior as its counterpart without the "
"\"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:141
#, no-wrap
msgid ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:145
#, no-wrap
msgid ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:145
#, no-wrap
msgid "MT-Unsafe race:stdin"
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:149
#, no-wrap
msgid ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:149
#, no-wrap
msgid "MT-Unsafe race:stdout"
msgstr ""

#. type: tbl table
#: build/C/man3/unlocked_stdio.3:154
#, no-wrap
msgid ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:164
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001 and "
"POSIX.1-2008."
msgstr ""

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: build/C/man3/unlocked_stdio.3:180
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:183
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/wprintf.3:16
#, no-wrap
msgid "WPRINTF"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:20
msgid ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - formatted "
"wide-character output conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:29
#, no-wrap
msgid ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:34
#, no-wrap
msgid ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list "
">I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
msgstr ""

#.  .BR wprintf (),
#.  .BR fwprintf (),
#.  .BR swprintf (),
#.  .BR vwprintf (),
#.  .BR vfwprintf (),
#.  .BR vswprintf ():
#. type: Plain text
#: build/C/man3/wprintf.3:51
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:53
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:64
msgid ""
"The B<wprintf>()  family of functions is the wide-character equivalent of "
"the B<printf>(3)  family of functions.  It performs formatted output of wide "
"characters."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:76
msgid ""
"The B<wprintf>()  and B<vwprintf>()  functions perform wide-character output "
"to I<stdout>.  I<stdout> must not be byte oriented; see B<fwide>(3)  for "
"more information."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:88
msgid ""
"The B<fwprintf>()  and B<vfwprintf>()  functions perform wide-character "
"output to I<stream>.  I<stream> must not be byte oriented; see B<fwide>(3)  "
"for more information."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:102
msgid ""
"The B<swprintf>()  and B<vswprintf>()  functions perform wide-character "
"output to an array of wide characters.  The programmer must ensure that "
"there is room for at least I<maxlen> wide characters at I<wcs>."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:113
msgid ""
"These functions are like the B<printf>(3), B<vprintf>(3), B<fprintf>(3), "
"B<vfprintf>(3), B<sprintf>(3), B<vsprintf>(3)  functions except for the "
"following differences:"
msgstr ""

#. type: TP
#: build/C/man3/wprintf.3:113 build/C/man3/wprintf.3:118 build/C/man3/wprintf.3:121
#, no-wrap
msgid "B<\\(bu>"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:118
msgid "The I<format> string is a wide-character string."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:121
msgid "The output consists of wide characters, not bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:140
msgid ""
"B<swprintf>()  and B<vswprintf>()  take a I<maxlen> argument, B<sprintf>(3)  "
"and B<vsprintf>(3)  do not.  (B<snprintf>(3)  and B<vsnprintf>(3)  take a "
"I<maxlen> argument, but these functions do not return -1 upon buffer "
"overflow on Linux.)"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:146
msgid "The treatment of the conversion characters B<c> and B<s> is different:"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:160
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to a wide "
"character by a call to the B<btowc>(3)  function, and the resulting wide "
"character is written.  If an B<l> modifier is present, the I<wint_t> (wide "
"character) argument is written."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:200
msgid ""
"If no B<l> modifier is present: the I<const\\ char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string) "
"containing a multibyte character sequence beginning in the initial shift "
"state.  Characters from the array are converted to wide characters (each by "
"a call to the B<mbrtowc>(3)  function with a conversion state starting in "
"the initial state before the first byte).  The resulting wide characters are "
"written up to (but not including) the terminating null wide character "
"(L\\(aq\\e0\\(aq).  If a precision is specified, no more wide characters "
"than the number specified are written.  Note that the precision determines "
"the number of I<wide characters> written, not the number of I<bytes> or "
"I<screen positions>.  The array must contain a terminating null byte "
"(\\(aq\\e0\\(aq), unless a precision is given and it is so small that the "
"number of converted wide characters reaches it before the end of the array "
"is reached.  If an B<l> modifier is present: the I<const\\ wchar_t\\ *> "
"argument is expected to be a pointer to an array of wide characters.  Wide "
"characters from the array are written up to (but not including) a "
"terminating null wide character.  If a precision is specified, no more than "
"the number specified are written.  The array must contain a terminating null "
"wide character, unless a precision is given and it is smaller than or equal "
"to the number of wide characters in the array."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:208
msgid ""
"The functions return the number of wide characters written, excluding the "
"terminating null wide character in case of the functions B<swprintf>()  and "
"B<vswprintf>().  They return -1 when an error occurs."
msgstr ""

#. type: tbl table
#: build/C/man3/wprintf.3:219
#, no-wrap
msgid ""
"B<wprintf>(),\n"
"B<fwprintf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/wprintf.3:222
#, no-wrap
msgid ""
"B<swprintf>(),\n"
"B<vwprintf>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/wprintf.3:225
#, no-wrap
msgid ""
"B<vfwprintf>(),\n"
"B<vswprintf>()"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:238
msgid ""
"The behavior of B<wprintf>()  et al. depends on the B<LC_CTYPE> category of "
"the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:268
msgid ""
"If the I<format> string contains non-ASCII wide characters, the program will "
"work correctly only if the B<LC_CTYPE> category of the current locale at run "
"time is the same as the B<LC_CTYPE> category of the current locale at "
"compile time.  This is because the I<wchar_t> representation is platform- "
"and locale-dependent.  (The glibc represents wide characters using their "
"Unicode (ISO-10646) code point, but other platforms don't do this.  Also, "
"the use of C99 universal character names of the form \\eunnnn does not solve "
"this problem.)  Therefore, in internationalized programs, the I<format> "
"string should consist of ASCII wide characters only, or should be "
"constructed at run time in an internationalized way (e.g., using "
"B<gettext>(3)  or B<iconv>(3), followed by B<mbstowcs>(3))."
msgstr ""

#.  .BR wscanf (3)
#. type: Plain text
#: build/C/man3/wprintf.3:275
msgid "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"
msgstr ""

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "WRITE"
msgstr ""

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:42
msgid "write - write to a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:46
msgid "B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:54
msgid ""
"B<write>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:68
msgid ""
"The number of bytes written may be less than I<count> if, for example, there "
"is insufficient space on the underlying physical medium, or the "
"B<RLIMIT_FSIZE> resource limit is encountered (see B<setrlimit>(2)), or the "
"call was interrupted by a signal handler after having written less than "
"I<count> bytes.  (See also B<pipe>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:82
msgid ""
"For a seekable file (i.e., one to which B<lseek>(2)  may be applied, for "
"example, a regular file)  writing takes place at the file offset, and the "
"file offset is incremented by the number of bytes actually written.  If the "
"file was B<open>(2)ed with B<O_APPEND>, the file offset is first set to the "
"end of the file before writing.  The adjustment of the file offset and the "
"write operation are performed as an atomic step."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:89
msgid ""
"POSIX requires that a B<read>(2)  that can be proved to occur after a "
"B<write>()  has returned will return the new data.  Note that not all "
"filesystems are POSIX conforming."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:100
msgid ""
"On success, the number of bytes written is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:118
msgid ""
"Note that a successful B<write>()  may transfer fewer than I<count> bytes.  "
"Such partial writes can occur for various reasons; for example, because "
"there was insufficient space on the disk device to write all of the "
"requested bytes, or because a blocked B<write>()  to a socket, pipe, or "
"similar was interrupted by a signal handler after it had transferred some, "
"but before it had transferred all of the requested bytes.  In the event of a "
"partial write, the caller can make another B<write>()  call to transfer the "
"remaining bytes.  The subsequent call will either transfer further bytes or "
"may result in an error (e.g., if the disk is now full)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:131
msgid ""
"If I<count> is zero and I<fd> refers to a regular file, then B<write>()  may "
"return a failure status if one of the errors below is detected.  If no "
"errors are detected, or error detection is not performed, 0 will be returned "
"without causing any other effect.  If I<count> is zero and I<fd> refers to a "
"file other than a regular file, the results are not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:144
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the write would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/write.2:155
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the write would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:159
msgid "I<fd> is not a valid file descriptor or is not open for writing."
msgstr ""

#. type: TP
#: build/C/man2/write.2:159
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:164
msgid ""
"I<fd> refers to a datagram socket for which a peer address has not been set "
"using B<connect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:170
msgid ""
"The user's quota of disk blocks on the filesystem containing the file "
"referred to by I<fd> has been exhausted."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:179
msgid ""
"An attempt was made to write a file that exceeds the implementation-defined "
"maximum file size or the process's file size limit, or to write at a "
"position past the maximum allowed offset."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:183
msgid ""
"The call was interrupted by a signal before any data was written; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:194
msgid ""
"I<fd> is attached to an object which is unsuitable for writing; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: build/C/man2/write.2:222
msgid ""
"A low-level I/O error occurred while modifying the inode.  This error may "
"relate to the write-back of data written by an earlier B<write>(), which may "
"have been issued to a different file descriptor on the same file.  Since "
"Linux 4.13, errors from write-back come with a promise that they I<may> be "
"reported by subsequent.  B<write>()  requests, and I<will> be reported by a "
"subsequent B<fsync>(2)  (whether or not they were also reported by "
"B<write>()).  An alternate cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:227
msgid ""
"The device containing the file referred to by I<fd> has no room for the "
"data."
msgstr ""

#. type: TP
#: build/C/man2/write.2:231
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:240
msgid ""
"I<fd> is connected to a pipe or socket whose reading end is closed.  When "
"this happens the writing process will also receive a B<SIGPIPE> signal.  "
"(Thus, the write return value is seen only if the program catches, blocks or "
"ignores this signal.)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:252
msgid ""
"Under SVr4 a write may be interrupted and return B<EINTR> at any point, not "
"just before any data is written."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:274
msgid ""
"A successful return from B<write>()  does not make any guarantee that data "
"has been committed to disk.  On some filesystems, including NFS, it does not "
"even guarantee that space has successfully been reserved for the data.  In "
"this case, some errors might be delayed until a future B<write>(), "
"B<fsync>(2), or even B<close>(2).  The only way to be sure is to call "
"B<fsync>(2)  after you are done writing all your data."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:282
msgid ""
"If a B<write>()  is interrupted by a signal handler before any bytes are "
"written, then the call fails with the error B<EINTR>; if it is interrupted "
"after at least one byte has been written, the call succeeds, and returns the "
"number of bytes written."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: build/C/man2/write.2:290
msgid ""
"On Linux, B<write>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:298
msgid ""
"An error return value while performing B<write>()  using direct I/O does not "
"mean the entire write has failed. Partial data may be written and the data "
"at the file offset on which the B<write>()  was attempted should be "
"considered inconsistent."
msgstr ""

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: build/C/man2/write.2:337
msgid ""
"Among the APIs subsequently listed are B<write>()  and B<writev>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<write>()  (or B<writev>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the blocks of data output by the two processes might "
"(incorrectly) overlap.  This problem was fixed in Linux 3.14."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:349
msgid ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"
msgstr ""
