# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-19 09:32+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#.  Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
#.  Written by Stephen M. Cameron <scameron@beardog.cce.hp.com>
#.  %%%LICENSE_START(GPLv2_ONELINE)
#.  Licensed under GNU General Public License version 2 (GPLv2)
#.  %%%LICENSE_END
#.  shorthand for double quote that works everywhere.
#. type: ds q
#: build/C/man4/cciss.4:9 build/C/man4/hpsa.4:9
#, no-wrap
msgid "\\N'34'"
msgstr "\\N'34'"

#. type: TH
#: build/C/man4/cciss.4:10
#, no-wrap
msgid "CCISS"
msgstr "CCISS"

#. type: TH
#: build/C/man4/cciss.4:10 build/C/man4/hd.4:29 build/C/man4/hpsa.4:10
#: build/C/man7/pipe.7:25 build/C/man4/random.4:17 build/C/man4/sd.4:26
#: build/C/man3/syslog.3:37 build/C/man4/wavelan.4:15
#, no-wrap
msgid "2017-09-15"
msgstr " 2017-09-15"

#. type: TH
#: build/C/man4/cciss.4:10 build/C/man4/console_codes.4:22
#: build/C/man5/core.5:25 build/C/man4/cpuid.4:26 build/C/man4/dsp56k.4:26
#: build/C/man4/fd.4:27 build/C/man7/fifo.7:12 build/C/man4/full.4:26
#: build/C/man3/gnu_get_libc_version.3:26 build/C/man4/hd.4:29
#: build/C/man4/hpsa.4:10 build/C/man4/initrd.4:35 build/C/man4/lp.4:26
#: build/C/man3/makedev.3:26 build/C/man4/mem.4:26 build/C/man2/mknod.2:15
#: build/C/man4/mouse.4:25 build/C/man4/msr.4:26 build/C/man4/null.4:26
#: build/C/man7/pipe.7:25 build/C/man4/ram.4:26 build/C/man4/random.4:17
#: build/C/man4/sd.4:26 build/C/man4/sk98lin.4:27 build/C/man4/st.4:25
#: build/C/man2/syslog.2:32 build/C/man3/syslog.3:37 build/C/man4/ttyS.4:26
#: build/C/man7/uri.7:48 build/C/man4/vcs.4:29 build/C/man4/wavelan.4:15
#: build/C/man4/lirc.4:24 build/C/man4/smartpqi.4:9 build/C/man4/veth.4:28
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man4/cciss.4:10 build/C/man4/console_codes.4:22
#: build/C/man5/core.5:25 build/C/man4/cpuid.4:26 build/C/man4/dsp56k.4:26
#: build/C/man4/fd.4:27 build/C/man7/fifo.7:12 build/C/man4/full.4:26
#: build/C/man3/gnu_get_libc_version.3:26 build/C/man4/hd.4:29
#: build/C/man4/hpsa.4:10 build/C/man4/initrd.4:35 build/C/man4/lp.4:26
#: build/C/man3/makedev.3:26 build/C/man4/mem.4:26 build/C/man3/mkfifo.3:28
#: build/C/man2/mknod.2:15 build/C/man4/mouse.4:25 build/C/man4/msr.4:26
#: build/C/man4/null.4:26 build/C/man7/pipe.7:25 build/C/man4/ram.4:26
#: build/C/man4/random.4:17 build/C/man4/sd.4:26 build/C/man3/setlogmask.3:25
#: build/C/man4/sk98lin.4:27 build/C/man4/st.4:25 build/C/man3/stdarg.3:43
#: build/C/man2/syslog.2:32 build/C/man3/syslog.3:37 build/C/man4/ttyS.4:26
#: build/C/man7/uri.7:48 build/C/man4/vcs.4:29 build/C/man4/wavelan.4:15
#: build/C/man4/lirc.4:24 build/C/man4/smartpqi.4:9 build/C/man4/veth.4:28
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man4/cciss.4:11 build/C/man4/console_codes.4:23
#: build/C/man5/core.5:26 build/C/man4/cpuid.4:27 build/C/man4/dsp56k.4:27
#: build/C/man4/fd.4:28 build/C/man7/fifo.7:13 build/C/man4/full.4:27
#: build/C/man3/gnu_get_libc_version.3:27 build/C/man4/hd.4:30
#: build/C/man4/hpsa.4:11 build/C/man4/initrd.4:36 build/C/man4/lp.4:27
#: build/C/man3/makedev.3:27 build/C/man4/mem.4:27 build/C/man3/mkfifo.3:29
#: build/C/man2/mknod.2:16 build/C/man4/mouse.4:26 build/C/man4/msr.4:27
#: build/C/man4/null.4:27 build/C/man7/pipe.7:26 build/C/man4/ram.4:27
#: build/C/man4/random.4:18 build/C/man4/sd.4:27 build/C/man3/setlogmask.3:26
#: build/C/man4/sk98lin.4:28 build/C/man4/st.4:26 build/C/man3/stdarg.3:44
#: build/C/man2/syslog.2:33 build/C/man3/syslog.3:38 build/C/man4/ttyS.4:27
#: build/C/man7/uri.7:49 build/C/man4/vcs.4:30 build/C/man4/wavelan.4:16
#: build/C/man4/lirc.4:25 build/C/man4/smartpqi.4:10 build/C/man4/veth.4:29
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man4/cciss.4:13
msgid "cciss - HP Smart Array block driver"
msgstr ""

#. type: SH
#: build/C/man4/cciss.4:13 build/C/man4/dsp56k.4:29
#: build/C/man3/gnu_get_libc_version.3:29 build/C/man4/hpsa.4:13
#: build/C/man4/lp.4:29 build/C/man3/makedev.3:29 build/C/man3/mkfifo.3:31
#: build/C/man2/mknod.2:18 build/C/man4/random.4:20 build/C/man4/sd.4:29
#: build/C/man3/setlogmask.3:28 build/C/man4/sk98lin.4:30 build/C/man4/st.4:28
#: build/C/man3/stdarg.3:46 build/C/man2/syslog.2:36 build/C/man3/syslog.3:40
#: build/C/man7/uri.7:51 build/C/man4/wavelan.4:18 build/C/man4/smartpqi.4:12
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man4/cciss.4:16
#, no-wrap
msgid "modprobe cciss [ cciss_allow_hpsa=1 ]\n"
msgstr "modprobe cciss [ cciss_allow_hpsa=1 ]\n"

#. type: SH
#: build/C/man4/cciss.4:17 build/C/man4/console_codes.4:25
#: build/C/man5/core.5:28 build/C/man4/cpuid.4:29 build/C/man4/dsp56k.4:47
#: build/C/man4/fd.4:143 build/C/man7/fifo.7:15 build/C/man4/full.4:41
#: build/C/man3/gnu_get_libc_version.3:36 build/C/man4/hd.4:32
#: build/C/man4/hpsa.4:17 build/C/man4/initrd.4:71 build/C/man4/lp.4:45
#: build/C/man3/makedev.3:38 build/C/man4/mem.4:29 build/C/man3/mkfifo.3:62
#: build/C/man2/mknod.2:48 build/C/man4/mouse.4:32 build/C/man4/msr.4:29
#: build/C/man4/null.4:29 build/C/man7/pipe.7:28 build/C/man4/ram.4:29
#: build/C/man4/random.4:24 build/C/man4/sd.4:71 build/C/man3/setlogmask.3:34
#: build/C/man4/sk98lin.4:62 build/C/man4/st.4:37 build/C/man3/stdarg.3:56
#: build/C/man2/syslog.2:46 build/C/man3/syslog.3:61 build/C/man4/ttyS.4:29
#: build/C/man7/uri.7:71 build/C/man4/vcs.4:32 build/C/man4/wavelan.4:20
#: build/C/man4/lirc.4:27 build/C/man4/smartpqi.4:21 build/C/man4/veth.4:31
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#.  commit 253d2464df446456c0bba5ed4137a7be0b278aa8
#. type: Plain text
#: build/C/man4/cciss.4:24
msgid ""
"B<Note>: This obsolete driver was removed from the kernel in version 4.14, "
"as it is superseded by the B<hpsa>(4)  driver in newer kernels."
msgstr "B<注意>: この時代遅れのドライバはカーネル 4.14 で削除された。新しいバージョンのカーネルでは B<hpsa>(4) ドライバーで置き換えられている。"

#. type: Plain text
#: build/C/man4/cciss.4:27
msgid "B<cciss> is a block driver for older HP Smart Array RAID controllers."
msgstr ""

#. type: SS
#: build/C/man4/cciss.4:27 build/C/man4/hpsa.4:20 build/C/man4/initrd.4:180
#, no-wrap
msgid "Options"
msgstr "オプション"

#. type: Plain text
#: build/C/man4/cciss.4:36
msgid ""
"I<cciss_allow_hpsa=1>: This option prevents the B<cciss> driver from "
"attempting to drive any controllers that the B<hpsa>(4)  driver is capable "
"of controlling, which is to say, the B<cciss> driver is restricted by this "
"option to the following controllers:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:55
#, no-wrap
msgid ""
"    Smart Array 5300\n"
"    Smart Array 5i\n"
"    Smart Array 532\n"
"    Smart Array 5312\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6400\n"
"    Smart Array 6400 EM\n"
"    Smart Array 6i\n"
"    Smart Array P600\n"
"    Smart Array P400i\n"
"    Smart Array E200i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"
msgstr ""
"    Smart Array 5300\n"
"    Smart Array 5i\n"
"    Smart Array 532\n"
"    Smart Array 5312\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6400\n"
"    Smart Array 6400 EM\n"
"    Smart Array 6i\n"
"    Smart Array P600\n"
"    Smart Array P400i\n"
"    Smart Array E200i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"

#. type: SS
#: build/C/man4/cciss.4:56 build/C/man4/hpsa.4:39
#, no-wrap
msgid "Supported hardware"
msgstr "サポートされるハードウェア"

#. type: Plain text
#: build/C/man4/cciss.4:60
msgid "The B<cciss> driver supports the following Smart Array boards:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:86
#, no-wrap
msgid ""
"    Smart Array 5300\n"
"    Smart Array 5i\n"
"    Smart Array 532\n"
"    Smart Array 5312\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6400\n"
"    Smart Array 6400 U320 Expansion Module\n"
"    Smart Array 6i\n"
"    Smart Array P600\n"
"    Smart Array P800\n"
"    Smart Array E400\n"
"    Smart Array P400i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"
"    Smart Array P700m\n"
"    Smart Array P212\n"
"    Smart Array P410\n"
"    Smart Array P410i\n"
"    Smart Array P411\n"
"    Smart Array P812\n"
"    Smart Array P712m\n"
"    Smart Array P711m\n"
msgstr ""
"    Smart Array 5300\n"
"    Smart Array 5i\n"
"    Smart Array 532\n"
"    Smart Array 5312\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6400\n"
"    Smart Array 6400 U320 Expansion Module\n"
"    Smart Array 6i\n"
"    Smart Array P600\n"
"    Smart Array P800\n"
"    Smart Array E400\n"
"    Smart Array P400i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"
"    Smart Array P700m\n"
"    Smart Array P212\n"
"    Smart Array P410\n"
"    Smart Array P410i\n"
"    Smart Array P411\n"
"    Smart Array P812\n"
"    Smart Array P712m\n"
"    Smart Array P711m\n"

#. type: SS
#: build/C/man4/cciss.4:87 build/C/man4/hpsa.4:81
#, no-wrap
msgid "Configuration details"
msgstr "設定の詳細"

#. type: Plain text
#: build/C/man4/cciss.4:96 build/C/man4/hpsa.4:89
msgid ""
"To configure HP Smart Array controllers, use the HP Array Configuration "
"Utility (either B<hpacuxe>(8)  or B<hpacucli>(8))  or the Offline ROM-based "
"Configuration Utility (ORCA)  run from the Smart Array's option ROM at boot "
"time."
msgstr ""
"HP Smart Array コントローラーを設定するには、\n"
"HP Array Configuration Utility (B<hpacuxe>(8) か B<hpacucli>(8)) または\n"
"起動時に Smart Array のオプション ROM から起動される\n"
"Offline ROM-based Configuration Utility (ORCA) を使うこと。"

#. type: SH
#: build/C/man4/cciss.4:96 build/C/man4/dsp56k.4:111 build/C/man4/fd.4:206
#: build/C/man4/full.4:61 build/C/man4/hd.4:95 build/C/man4/hpsa.4:89
#: build/C/man4/initrd.4:430 build/C/man4/lp.4:129 build/C/man4/mem.4:91
#: build/C/man4/mouse.4:184 build/C/man4/null.4:53 build/C/man4/ram.4:42
#: build/C/man4/random.4:325 build/C/man4/sd.4:129 build/C/man4/sk98lin.4:564
#: build/C/man4/st.4:892 build/C/man4/ttyS.4:44 build/C/man4/vcs.4:95
#: build/C/man4/smartpqi.4:106
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: SS
#: build/C/man4/cciss.4:97 build/C/man4/hpsa.4:90 build/C/man4/smartpqi.4:107
#, no-wrap
msgid "Device nodes"
msgstr "デバイスノード"

#. type: Plain text
#: build/C/man4/cciss.4:99
msgid "The device naming scheme is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:101
msgid "Major numbers:"
msgstr "メジャー番号:"

#. type: Plain text
#: build/C/man4/cciss.4:110
#, no-wrap
msgid ""
"    104     cciss0\n"
"    105     cciss1\n"
"    106     cciss2\n"
"    105     cciss3\n"
"    108     cciss4\n"
"    109     cciss5\n"
"    110     cciss6\n"
"    111     cciss7\n"
msgstr ""
"    104     cciss0\n"
"    105     cciss1\n"
"    106     cciss2\n"
"    105     cciss3\n"
"    108     cciss4\n"
"    109     cciss5\n"
"    110     cciss6\n"
"    111     cciss7\n"

#. type: Plain text
#: build/C/man4/cciss.4:112
msgid "Minor numbers:"
msgstr "マイナー番号:"

#. type: Plain text
#: build/C/man4/cciss.4:120
#, no-wrap
msgid ""
"    b7 b6 b5 b4 b3 b2 b1 b0\n"
"    |----+----| |----+----|\n"
"         |           |\n"
"         |           +-------- Partition ID (0=wholedev, 1-15 partition)\n"
"         |\n"
"         +-------------------- Logical Volume number\n"
msgstr ""
"    b7 b6 b5 b4 b3 b2 b1 b0\n"
"    |----+----| |----+----|\n"
"         |           |\n"
"         |           +-------- Partition ID (0=wholedev, 1-15 partition)\n"
"         |\n"
"         +-------------------- Logical Volume number\n"

#. type: Plain text
#: build/C/man4/cciss.4:123
msgid "The device naming scheme is:"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:125
#, no-wrap
msgid "/dev/cciss/c0d0"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:125
#, no-wrap
msgid "Controller 0, disk 0, whole device"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:126
#, no-wrap
msgid "/dev/cciss/c0d0p1"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:126
#, no-wrap
msgid "Controller 0, disk 0, partition 1"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:127
#, no-wrap
msgid "/dev/cciss/c0d0p2"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:127
#, no-wrap
msgid "Controller 0, disk 0, partition 2"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:128
#, no-wrap
msgid "/dev/cciss/c0d0p3"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:128
#, no-wrap
msgid "Controller 0, disk 0, partition 3"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:130
#, no-wrap
msgid "/dev/cciss/c1d1"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:130
#, no-wrap
msgid "Controller 1, disk 1, whole device"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:131
#, no-wrap
msgid "/dev/cciss/c1d1p1"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:131
#, no-wrap
msgid "Controller 1, disk 1, partition 1"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:132
#, no-wrap
msgid "/dev/cciss/c1d1p2"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:132
#, no-wrap
msgid "Controller 1, disk 1, partition 2"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:133
#, no-wrap
msgid "/dev/cciss/c1d1p3"
msgstr ""

#. type: tbl table
#: build/C/man4/cciss.4:133
#, no-wrap
msgid "Controller 1, disk 1, partition 3"
msgstr ""

#. type: SS
#: build/C/man4/cciss.4:135
#, no-wrap
msgid "Files in /proc"
msgstr "/proc 以下のファイル"

#. type: Plain text
#: build/C/man4/cciss.4:141
msgid ""
"The files I</proc/driver/cciss/cciss[0-9]+> contain information about the "
"configuration of each controller.  For example:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:162
#, no-wrap
msgid ""
"$ B<cd /proc/driver/cciss>\n"
"$ B<ls -l>\n"
"total 0\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss0\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss1\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss2\n"
"$ B<cat cciss2>\n"
"cciss2: HP Smart Array P800 Controller\n"
"Board ID: 0x3223103c\n"
"Firmware Version: 7.14\n"
"IRQ: 16\n"
"Logical drives: 1\n"
"Current Q depth: 0\n"
"Current # commands on controller: 0\n"
"Max Q depth since init: 1\n"
"Max # commands on controller since init: 2\n"
"Max SG entries since init: 32\n"
"Sequential access devices: 0\n"
msgstr ""
"$ B<cd /proc/driver/cciss>\n"
"$ B<ls -l>\n"
"total 0\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss0\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss1\n"
"-rw-r--r-- 1 root root 0 2010-09-10 10:38 cciss2\n"
"$ B<cat cciss2>\n"
"cciss2: HP Smart Array P800 Controller\n"
"Board ID: 0x3223103c\n"
"Firmware Version: 7.14\n"
"IRQ: 16\n"
"Logical drives: 1\n"
"Current Q depth: 0\n"
"Current # commands on controller: 0\n"
"Max Q depth init: 1 以降\n"
"Max # commands on controller since init: 2\n"
"Max SG entries since init: 32\n"
"Sequential access devices: 0\n"

#. type: Plain text
#: build/C/man4/cciss.4:164
#, no-wrap
msgid "cciss/c2d0:   36.38GB       RAID 0\n"
msgstr " cciss/c2d0:   36.38GB       RAID 0\n"

#. type: SS
#: build/C/man4/cciss.4:167
#, no-wrap
msgid "Files in /sys"
msgstr "/sys 以下のファイル"

#. type: TP
#: build/C/man4/cciss.4:168
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/model>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/model>"

#. type: Plain text
#: build/C/man4/cciss.4:174
msgid ""
"Displays the SCSI INQUIRY page 0 model for logical drive I<Y> of controller "
"I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:174
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/rev>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/rev>"

#. type: Plain text
#: build/C/man4/cciss.4:180
msgid ""
"Displays the SCSI INQUIRY page 0 revision for logical drive I<Y> of "
"controller I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:180
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/unique_id>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/unique_id>"

#. type: Plain text
#: build/C/man4/cciss.4:186
msgid ""
"Displays the SCSI INQUIRY page 83 serial number for logical drive I<Y> of "
"controller I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:186
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/vendor>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/vendor>"

#. type: Plain text
#: build/C/man4/cciss.4:192
msgid ""
"Displays the SCSI INQUIRY page 0 vendor for logical drive I<Y> of controller "
"I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:192
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/block:cciss!cXdY>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/block:cciss!cXdY>"

#. type: Plain text
#: build/C/man4/cciss.4:196
msgid "A symbolic link to I</sys/block/cciss!cXdY>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:196
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/rescan>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/rescan>"

#. type: Plain text
#: build/C/man4/cciss.4:200
msgid ""
"When this file is written to, the driver rescans the controller to discover "
"any new, removed, or modified logical drives."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:200
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/resettable>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/resettable>"

#. type: Plain text
#: build/C/man4/cciss.4:209
msgid ""
"A value of 1 displayed in this file indicates that the \"reset_devices=1\" "
"kernel parameter (used by B<kdump>)  is honored by this controller.  A value "
"of 0 indicates that the \"reset_devices=1\" kernel parameter will not be "
"honored.  Some models of Smart Array are not able to honor this parameter."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:209
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/lunid>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/lunid>"

#. type: Plain text
#: build/C/man4/cciss.4:215
msgid ""
"Displays the 8-byte LUN ID used to address logical drive I<Y> of controller "
"I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:215
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/raid_level>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/raid_level>"

#. type: Plain text
#: build/C/man4/cciss.4:221
msgid "Displays the RAID level of logical drive I<Y> of controller I<X>."
msgstr ""

#. type: TP
#: build/C/man4/cciss.4:221
#, no-wrap
msgid "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/usage_count>"
msgstr "I</sys/bus/pci/devices/E<lt>devE<gt>/ccissX/cXdY/usage_count>"

#. type: Plain text
#: build/C/man4/cciss.4:227
msgid ""
"Displays the usage count (number of opens) of logical drive I<Y> of "
"controller I<X>."
msgstr ""

#. type: SS
#: build/C/man4/cciss.4:227
#, no-wrap
msgid "SCSI tape drive and medium changer support"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:238
msgid ""
"SCSI sequential access devices and medium changer devices are supported and "
"appropriate device nodes are automatically created (e.g., I</dev/st0>, I</"
"dev/st1>, etc.; see B<st>(4)  for more details.)  You must enable \"SCSI "
"tape drive support for Smart Array 5xxx\" and \"SCSI support\" in your "
"kernel configuration to be able to use SCSI tape drives with your Smart "
"Array 5xxx controller."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:256
msgid ""
"Additionally, note that the driver will not engage the SCSI core at init "
"time.  The driver must be directed to dynamically engage the SCSI core via "
"the I</proc> filesystem entry, which the \"block\" side of the driver "
"creates as I</proc/driver/cciss/cciss*> at run time.  This is because at "
"driver init time, the SCSI core may not yet be initialized (because the "
"driver is a block driver) and attempting to register it with the SCSI core "
"in such a case would cause a hang.  This is best done via an initialization "
"script (typically in I</etc/init.d>, but could vary depending on "
"distribution).  For example:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:263
#, no-wrap
msgid ""
"for x in /proc/driver/cciss/cciss[0-9]*\n"
"do\n"
"    echo \"engage scsi\" E<gt> $x\n"
"done\n"
msgstr ""
" for x in /proc/driver/cciss/cciss[0-9]*\n"
"do\n"
"    echo \"engage scsi\" E<gt> $x\n"
"done\n"

#. type: Plain text
#: build/C/man4/cciss.4:268
msgid ""
"Once the SCSI core is engaged by the driver, it cannot be disengaged (except "
"by unloading the driver, if it happens to be linked as a module.)"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:272
msgid ""
"Note also that if no sequential access devices or medium changers are "
"detected, the SCSI core will not be engaged by the action of the above "
"script."
msgstr ""

#. type: SS
#: build/C/man4/cciss.4:272
#, no-wrap
msgid "Hot plug support for SCSI tape drives"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:282
msgid ""
"Hot plugging of SCSI tape drives is supported, with some caveats.  The "
"B<cciss> driver must be informed that changes to the SCSI bus have been "
"made.  This may be done via the I</proc> filesystem.  For example:"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:284
#, no-wrap
msgid "    echo \"rescan\" E<gt> /proc/scsi/cciss0/1\n"
msgstr "    echo \"rescan\" E<gt> /proc/scsi/cciss0/1\n"

#. type: Plain text
#: build/C/man4/cciss.4:286
msgid "This causes the driver to:"
msgstr ""

#. type: IP
#: build/C/man4/cciss.4:287 build/C/man4/initrd.4:97 build/C/man4/initrd.4:335
#: build/C/man4/initrd.4:442 build/C/man4/st.4:905 build/C/man7/uri.7:532
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man4/cciss.4:290
msgid ""
"query the adapter about changes to the physical SCSI buses and/or fiber "
"channel arbitrated loop, and"
msgstr ""

#. type: IP
#: build/C/man4/cciss.4:290 build/C/man4/initrd.4:101 build/C/man4/initrd.4:343
#: build/C/man4/initrd.4:453 build/C/man4/st.4:925 build/C/man7/uri.7:536
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man4/cciss.4:293
msgid ""
"make note of any new or removed sequential access devices or medium changers."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:300
msgid ""
"The driver will output messages indicating which devices have been added or "
"removed and the controller, bus, target, and lun used to address each "
"device.  The driver then notifies the SCSI midlayer of these changes."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:307
msgid ""
"Note that the naming convention of the I</proc> filesystem entries contains "
"a number in addition to the driver name (e.g., \"cciss0\" instead of just "
"\"cciss\", which you might expect)."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:325
msgid ""
"Note: I<Only> sequential access devices and medium changers are presented as "
"SCSI devices to the SCSI midlayer by the B<cciss> driver.  Specifically, "
"physical SCSI disk drives are I<not> presented to the SCSI midlayer.  The "
"only disk devices that are presented to the kernel are logical drives that "
"the array controller constructs from regions on the physical drives.  The "
"logical drives are presented to the block layer (not to the SCSI midlayer).  "
"It is important for the driver to prevent the kernel from accessing the "
"physical drives directly, since these drives are used by the array "
"controller to construct the logical drives."
msgstr ""

#. type: SS
#: build/C/man4/cciss.4:325
#, no-wrap
msgid "SCSI error handling for tape drives and medium changers"
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:333
msgid ""
"The Linux SCSI midlayer provides an error-handling protocol that is "
"initiated whenever a SCSI command fails to complete within a certain amount "
"of time (which can vary depending on the command).  The B<cciss> driver "
"participates in this protocol to some extent.  The normal protocol is a four-"
"step process:"
msgstr ""

#. type: IP
#: build/C/man4/cciss.4:333 build/C/man4/cciss.4:335 build/C/man4/cciss.4:337
#: build/C/man4/cciss.4:339 build/C/man5/core.5:49 build/C/man5/core.5:66
#: build/C/man5/core.5:70 build/C/man5/core.5:74 build/C/man5/core.5:77
#: build/C/man5/core.5:90 build/C/man5/core.5:97 build/C/man5/core.5:112
#: build/C/man5/core.5:129 build/C/man5/core.5:307 build/C/man5/core.5:311
#: build/C/man5/core.5:317 build/C/man5/core.5:320 build/C/man5/core.5:327
#: build/C/man5/core.5:333 build/C/man5/core.5:342 build/C/man5/core.5:350
#: build/C/man5/core.5:354 build/C/man4/lirc.4:290 build/C/man4/lirc.4:298
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man4/cciss.4:335
msgid "First, the device is told to abort the command."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:337
msgid "If that doesn't work, the device is reset."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:339
msgid "If that doesn't work, the SCSI bus is reset."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:341
msgid "If that doesn't work, the host bus adapter is reset."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:359
msgid ""
"The B<cciss> driver is a block driver as well as a SCSI driver and only the "
"tape drives and medium changers are presented to the SCSI midlayer.  "
"Furthermore, unlike more straightforward SCSI drivers, disk I/O continues "
"through the block side during the SCSI error-recovery process.  Therefore, "
"the B<cciss> driver implements only the first two of these actions, aborting "
"the command, and resetting the device.  Note also that most tape drives will "
"not oblige in aborting commands, and sometimes it appears they will not even "
"obey a reset command, though in most circumstances they will.  If the "
"command cannot be aborted and the device cannot be reset, the device will be "
"set offline."
msgstr ""

#. type: Plain text
#: build/C/man4/cciss.4:367
msgid ""
"In the event that the error-handling code is triggered and a tape drive is "
"successfully reset or the tardy command is successfully aborted, the tape "
"drive may still not allow I/O to continue until some command is issued that "
"positions the tape to a known position.  Typically you must rewind the tape "
"(by issuing I<mt -f /dev/st0 rewind> for example) before I/O can proceed "
"again to a tape drive that was reset."
msgstr ""

#. type: SH
#: build/C/man4/cciss.4:367 build/C/man4/console_codes.4:674
#: build/C/man5/core.5:689 build/C/man4/cpuid.4:93 build/C/man4/dsp56k.4:116
#: build/C/man4/fd.4:225 build/C/man7/fifo.7:67 build/C/man4/full.4:63
#: build/C/man3/gnu_get_libc_version.3:89 build/C/man4/hd.4:97
#: build/C/man4/hpsa.4:219 build/C/man4/initrd.4:486 build/C/man4/lp.4:138
#: build/C/man3/makedev.3:107 build/C/man4/mem.4:97 build/C/man3/mkfifo.3:203
#: build/C/man2/mknod.2:288 build/C/man4/mouse.4:188 build/C/man4/msr.4:60
#: build/C/man4/null.4:68 build/C/man7/pipe.7:404 build/C/man4/ram.4:44
#: build/C/man4/random.4:340 build/C/man3/setlogmask.3:95
#: build/C/man4/sk98lin.4:586 build/C/man4/st.4:957 build/C/man3/stdarg.3:312
#: build/C/man2/syslog.2:385 build/C/man3/syslog.3:359 build/C/man4/ttyS.4:46
#: build/C/man7/uri.7:706 build/C/man4/vcs.4:187 build/C/man4/wavelan.4:138
#: build/C/man4/lirc.4:443 build/C/man4/smartpqi.4:320 build/C/man4/veth.4:102
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man4/cciss.4:372
msgid "B<hpsa>(4), B<cciss_vol_status>(8), B<hpacucli>(8), B<hpacuxe>(8)"
msgstr " B<hpsa>(4), B<cciss_vol_status>(8), B<hpacucli>(8), B<hpacuxe>(8)"

#.  .SH AUTHORS
#.  Don Brace, Steve Cameron, Chase Maupin, Mike Miller, Michael Ni,
#.  Charles White, Francis Wiran
#.  and probably some other people.
#. type: Plain text
#: build/C/man4/cciss.4:384
msgid ""
"E<.UR http://cciss.sf.net> E<.UE ,> and I<Documentation/blockdev/cciss.txt> "
"and I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss> in the Linux "
"kernel source tree"
msgstr ""

#. type: SH
#: build/C/man4/cciss.4:384 build/C/man4/console_codes.4:677
#: build/C/man5/core.5:702 build/C/man4/cpuid.4:102 build/C/man4/dsp56k.4:122
#: build/C/man4/fd.4:233 build/C/man7/fifo.7:76 build/C/man4/full.4:67
#: build/C/man3/gnu_get_libc_version.3:91 build/C/man4/hd.4:102
#: build/C/man4/hpsa.4:237 build/C/man4/initrd.4:500 build/C/man4/lp.4:144
#: build/C/man3/makedev.3:110 build/C/man4/mem.4:101 build/C/man3/mkfifo.3:212
#: build/C/man2/mknod.2:303 build/C/man4/mouse.4:191 build/C/man4/msr.4:64
#: build/C/man4/null.4:72 build/C/man7/pipe.7:420 build/C/man4/ram.4:48
#: build/C/man4/random.4:346 build/C/man4/sd.4:138 build/C/man3/setlogmask.3:99
#: build/C/man4/sk98lin.4:590 build/C/man4/st.4:967 build/C/man3/stdarg.3:316
#: build/C/man2/syslog.2:389 build/C/man3/syslog.3:365 build/C/man4/ttyS.4:53
#: build/C/man7/uri.7:715 build/C/man4/vcs.4:192 build/C/man4/wavelan.4:145
#: build/C/man4/lirc.4:447 build/C/man4/smartpqi.4:328 build/C/man4/veth.4:108
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man4/cciss.4:392 build/C/man4/console_codes.4:685
#: build/C/man5/core.5:710 build/C/man4/cpuid.4:110 build/C/man4/dsp56k.4:130
#: build/C/man4/fd.4:241 build/C/man7/fifo.7:84 build/C/man4/full.4:75
#: build/C/man3/gnu_get_libc_version.3:99 build/C/man4/hd.4:110
#: build/C/man4/hpsa.4:245 build/C/man4/initrd.4:508 build/C/man4/lp.4:152
#: build/C/man3/makedev.3:118 build/C/man4/mem.4:109 build/C/man3/mkfifo.3:220
#: build/C/man2/mknod.2:311 build/C/man4/mouse.4:199 build/C/man4/msr.4:72
#: build/C/man4/null.4:80 build/C/man7/pipe.7:428 build/C/man4/ram.4:56
#: build/C/man4/random.4:354 build/C/man4/sd.4:146
#: build/C/man3/setlogmask.3:107 build/C/man4/sk98lin.4:598
#: build/C/man4/st.4:975 build/C/man3/stdarg.3:324 build/C/man2/syslog.2:397
#: build/C/man3/syslog.3:373 build/C/man4/ttyS.4:61 build/C/man7/uri.7:723
#: build/C/man4/vcs.4:200 build/C/man4/wavelan.4:153 build/C/man4/lirc.4:455
#: build/C/man4/smartpqi.4:336 build/C/man4/veth.4:116
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man4/console_codes.4:22
#, no-wrap
msgid "CONSOLE_CODES"
msgstr "CONSOLE_CODES"

#. type: TH
#: build/C/man4/console_codes.4:22 build/C/man4/dsp56k.4:26
#: build/C/man4/fd.4:27 build/C/man4/lp.4:26 build/C/man3/mkfifo.3:28
#: build/C/man2/mknod.2:15 build/C/man4/mouse.4:25 build/C/man4/sk98lin.4:27
#: build/C/man2/syslog.2:32 build/C/man7/uri.7:48
#, no-wrap
msgid "2020-08-13"
msgstr " 2020-08-13"

#. type: Plain text
#: build/C/man4/console_codes.4:25
msgid "console_codes - Linux console escape and control sequences"
msgstr ""
"console_codes - Linux コンソールのエスケープシーケンスとコントロール シーケン"
"ス"

#. type: Plain text
#: build/C/man4/console_codes.4:32
msgid ""
"The Linux console implements a large subset of the VT102 and ECMA-48/ISO "
"6429/ANSI X3.64 terminal controls, plus certain private-mode sequences for "
"changing the color palette, character-set mapping, and so on.  In the "
"tabular descriptions below, the second column gives ECMA-48 or DEC mnemonics "
"(the latter if prefixed with DEC) for the given function.  Sequences without "
"a mnemonic are neither ECMA-48 nor VT102."
msgstr ""
"Linux コンソールは VT102 と ECMA-48/ISO6429/ANSI X3.64 端末コンソールの サブ"
"セットに、カラーパレットや文字集合のマッピングなどを変更する プライベートモー"
"ドシーケンスを加えて実装されている。 以下の表では、機能の ECMA-48 または DEC "
"のニーモニクス(DECで始まれば後者)を 2 番目の桁に記す。 ニーモニクスのないもの"
"は ECMA-48 でも VT102 でもないものである。"

#. type: Plain text
#: build/C/man4/console_codes.4:37
msgid ""
"After all the normal output processing has been done, and a stream of "
"characters arrives at the console driver for actual printing, the first "
"thing that happens is a translation from the code used for processing to the "
"code used for printing."
msgstr ""
"すべての出力作業が終って、実際に印字するために文字のストリームが コンソールド"
"ライバーに届いた時、最初に行なわれるのが、処理用コードから 印字用のコードへの"
"変換である。"

#. type: Plain text
#: build/C/man4/console_codes.4:43
msgid ""
"If the console is in UTF-8 mode, then the incoming bytes are first assembled "
"into 16-bit Unicode codes.  Otherwise, each byte is transformed according to "
"the current mapping table (which translates it to a Unicode value).  See the "
"B<Character Sets> section below for discussion."
msgstr ""
"もし、コンソールが UTF-8 モードなら、入って来たバイト(byte)は 16 ビットの "
"Unicode に組み立てられる。そうでなければ、それぞれの バイトは現在の(各バイト"
"を Unicode の値に変換する)マッピングテーブルに 従って変換される。これに関して"
"は下のキャラクターセット(Charcter Sets)  節を参照のこと。"

#. type: Plain text
#: build/C/man4/console_codes.4:49
msgid ""
"In the normal case, the Unicode value is converted to a font index, and this "
"is stored in video memory, so that the corresponding glyph (as found in "
"video ROM) appears on the screen.  Note that the use of Unicode (and the "
"design of the PC hardware)  allows us to use 512 different glyphs "
"simultaneously."
msgstr ""
"通常、Unicode の値はフォントインデックス(font index) に変換され、 ビデオメモ"
"リーに蓄えられる。そして(ビデオ ROM 中に見付けられる)  対応するグリフ(glyph)"
"が画面に現れる。 Unicode を用いると、(PC 互換機の設計では) 512 の異なった グ"
"リフを同時に利用できるようになる。"

#. type: Plain text
#: build/C/man4/console_codes.4:56
msgid ""
"If the current Unicode value is a control character, or we are currently "
"processing an escape sequence, the value will treated specially.  Instead of "
"being turned into a font index and rendered as a glyph, it may trigger "
"cursor movement or other control functions.  See the B<Linux Console "
"Controls> section below for discussion."
msgstr ""
"現在の Unicode の値がコントロール文字であるかエスケープシーケンスを 処理して"
"いる時には、その値は特別に扱われる。 フォントのインデックスに変換されてグリフ"
"として表示される代わりに、カーソルの 移動やその他のコントロール機能を実行させ"
"る。 詳しいことは、後述の「LINUX コンソールコントロール」のセクションを参照の"
"こと。"

#. type: Plain text
#: build/C/man4/console_codes.4:68
msgid ""
"It is generally not good practice to hard-wire terminal controls into "
"programs.  Linux supports a B<terminfo>(5)  database of terminal "
"capabilities.  Rather than emitting console escape sequences by hand, you "
"will almost always want to use a terminfo-aware screen library or utility "
"such as B<ncurses>(3), B<tput>(1), or B<reset>(1)."
msgstr ""
"一般に端末コントロールコードをプログラム中に直接記述するのは 良いことではな"
"い。 Linuxでは、端末において実現可能な操作のデータベースである "
"B<terminfo>(5)  をサポートしている。 コンソールエスケープシーケンスをわざわざ"
"入力するよりも、ほとんどの場合 terminfo の情報を参照する B<ncurses>(3), "
"B<tput>(1), や B<reset>(1)  などのスクリーンライブラリやユーティリティーを使"
"いたいと思うであろう。"

#. type: SS
#: build/C/man4/console_codes.4:68
#, no-wrap
msgid "Linux console controls"
msgstr "Linux コンソールコントロール"

#. type: Plain text
#: build/C/man4/console_codes.4:72
msgid ""
"This section describes all the control characters and escape sequences that "
"invoke special functions (i.e., anything other than writing a glyph at the "
"current cursor location) on the Linux console."
msgstr ""
"この章では Linux コンソールにおいて特殊な機能(つまり、現在のカーソル位置に 文"
"字のイメージを印字する以外のこと)を起こさせる全てのコントロール文字と エス"
"ケープシーケンスについて述べる。"

#. type: Plain text
#: build/C/man4/console_codes.4:74
msgid "B<Control characters>"
msgstr "B<コントロール文字>"

#. type: Plain text
#: build/C/man4/console_codes.4:85
msgid ""
"A character is a control character if (before transformation according to "
"the mapping table) it has one of the 14 codes 00 (NUL), 07 (BEL), 08 (BS), "
"09 (HT), 0a (LF), 0b (VT), 0c (FF), 0d (CR), 0e (SO), 0f (SI), 18 (CAN), 1a "
"(SUB), 1b (ESC), 7f (DEL).  One can set a \"display control characters\" "
"mode (see below), and allow 07, 09, 0b, 18, 1a, 7f to be displayed as "
"glyphs.  On the other hand, in UTF-8 mode all codes 00\\(en1f are regarded "
"as control characters, regardless of any \"display control characters\" mode."
msgstr "コントロール文字とは、(マッピングテーブルによる変換前のコードが)  00 (NUL), 07 (BEL), 08 (BS), 09 (HT), 0a (LF), 0b (VT), 0c (FF), 0d (CR), 0e (SO), 0f (SI), 18 (CAN), 1a (SUB), 1b (ESC), 7f (DEL) の 14 のコードのうちのどれかである文字である。 \"コントロール文字表示(display control characters)\"モード(後述)を 設定すると、07, 09, 0b, 18, 1a, 7f をグリフとして表示することができる。 一方、 UTF-8 モードでは、00\\(en1f の全てのコードは、コントロール文字表示 モードが指定された場合でもコントロール文字として扱われる。"

#. type: Plain text
#: build/C/man4/console_codes.4:94
msgid ""
"If we have a control character, it is acted upon immediately and then "
"discarded (even in the middle of an escape sequence)  and the escape "
"sequence continues with the next character.  (However, ESC starts a new "
"escape sequence, possibly aborting a previous unfinished one, and CAN and "
"SUB abort any escape sequence.)  The recognized control characters are BEL, "
"BS, HT, LF, VT, FF, CR, SO, SI, CAN, SUB, ESC, DEL, CSI.  They do what one "
"would expect:"
msgstr ""
"コントロール文字がある時には、それはすぐに(たとえエスケープシーケンスの 途中"
"でも)実行され、破棄される。エスケープシーケンスは次の文字から続けられる (しか"
"し、ESC は新しいエスケープシーケンスを始めるので、 前の終了していないエスケー"
"プシーケンスが中止される可能性がある。 さらに、CAN と SUB はどんなエスケープ"
"シーケンスも中止する)。 認められているコントロール文字は、BEL, BS, HT, LF, "
"VT, FF, CR, SO, SI, CAN, SUB, ESC, DEL, CSI である。これらは期待どおりの動作"
"をする:"

#. type: Plain text
#: build/C/man4/console_codes.4:96
msgid "BEL (0x07, B<\\(haG>) beeps;"
msgstr "BEL (0x07, B<\\(haG>) はビープ音を鳴らす;"

#. type: Plain text
#: build/C/man4/console_codes.4:99
msgid ""
"BS (0x08, B<\\(haH>) backspaces one column (but not past the beginning of "
"the line);"
msgstr "BS (0x08, B<\\(haH>) はバックスペース (ただし、行頭は越えない);"

#. type: Plain text
#: build/C/man4/console_codes.4:102
msgid ""
"HT (0x09, B<\\(haI>) goes to the next tab stop or to the end of the line if "
"there is no earlier tab stop;"
msgstr "HT (0x09, B<\\(haI>) は次のタブストップ(tab stop)へ移動する、そこから行末までに タブストップが無い場合は行の終りに移動する;"

#. type: Plain text
#: build/C/man4/console_codes.4:106
msgid ""
"LF (0x0A, B<\\(haJ>), VT (0x0B, B<\\(haK>) and FF (0x0C, B<\\(haL>) all give "
"a linefeed, and if LF/NL (new-line mode) is set also a carriage return;"
msgstr "LF (0x0A, B<\\(haJ>), VT (0x0B, B<\\(haK>), FF (0x0C, B<\\(haL>) これらは全て ラインフィード(linefeed)を与える; LF/NL (ニューラインモード(new line mode))がセットされていれば キャリッジリターンもアクティブにする;"

#. type: Plain text
#: build/C/man4/console_codes.4:108
msgid "CR (0x0D, B<\\(haM>) gives a carriage return;"
msgstr "CR (0x0D, B<\\(haM>) はキャリッジリターンを与える;"

#. type: Plain text
#: build/C/man4/console_codes.4:110
msgid "SO (0x0E, B<\\(haN>) activates the G1 character set;"
msgstr "SO (0x0E, B<\\(haN>) は G1 文字集合をアクティブにする。"

#. type: Plain text
#: build/C/man4/console_codes.4:112
msgid "SI (0x0F, B<\\(haO>) activates the G0 character set;"
msgstr "SI (0x0F, B<\\(haO>) は G0 文字集合をアクティブにする;"

#. type: Plain text
#: build/C/man4/console_codes.4:114
msgid "CAN (0x18, B<\\(haX>) and SUB (0x1A, B<\\(haZ>) abort escape sequences;"
msgstr "CAN (0x18, B<\\(haX>) と SUB (0x1A, B<\\(haZ>) はエスケープシーケンスを中止する;"

#. type: Plain text
#: build/C/man4/console_codes.4:116
msgid "ESC (0x1B, B<\\(ha[>) starts an escape sequence;"
msgstr "ESC (0x1B, B<\\(ha[>) はエスケープシーケンスを始める。"

#. type: Plain text
#: build/C/man4/console_codes.4:118
msgid "DEL (0x7F) is ignored;"
msgstr "DEL (0x7F) は無視される;"

#. type: Plain text
#: build/C/man4/console_codes.4:120
msgid "CSI (0x9B) is equivalent to ESC [."
msgstr "CSI (0x9B) は ESC [ と等価。"

#. type: Plain text
#: build/C/man4/console_codes.4:122
msgid "B<ESC- but not CSI-sequences>"
msgstr "B<エスケープシーケンスであるが CSI シーケンスでないもの>"

#. type: tbl table
#: build/C/man4/console_codes.4:124
#, no-wrap
msgid "ESC c"
msgstr "ESC c"

#. type: tbl table
#: build/C/man4/console_codes.4:124
#, no-wrap
msgid "RIS"
msgstr "RIS"

#. type: tbl table
#: build/C/man4/console_codes.4:124
#, no-wrap
msgid "Reset."
msgstr "リセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:125
#, no-wrap
msgid "ESC D"
msgstr "ESC D"

#. type: tbl table
#: build/C/man4/console_codes.4:125
#, no-wrap
msgid "IND"
msgstr "IND"

#. type: tbl table
#: build/C/man4/console_codes.4:125
#, no-wrap
msgid "Linefeed."
msgstr "ラインフィード。"

#. type: tbl table
#: build/C/man4/console_codes.4:126
#, no-wrap
msgid "ESC E"
msgstr "ESC E"

#. type: tbl table
#: build/C/man4/console_codes.4:126
#, no-wrap
msgid "NEL"
msgstr "NEL"

#. type: tbl table
#: build/C/man4/console_codes.4:126
#, no-wrap
msgid "Newline."
msgstr "ニューライン。"

#. type: tbl table
#: build/C/man4/console_codes.4:127
#, no-wrap
msgid "ESC H"
msgstr "ESC H"

#. type: tbl table
#: build/C/man4/console_codes.4:127
#, no-wrap
msgid "HTS"
msgstr "HTS"

#. type: tbl table
#: build/C/man4/console_codes.4:127
#, no-wrap
msgid "Set tab stop at current column."
msgstr "現在の桁の位置にタブストップを設定する。"

#. type: tbl table
#: build/C/man4/console_codes.4:128
#, no-wrap
msgid "ESC M"
msgstr "ESC M"

#. type: tbl table
#: build/C/man4/console_codes.4:128
#, no-wrap
msgid "RI"
msgstr "RI"

#. type: tbl table
#: build/C/man4/console_codes.4:128
#, no-wrap
msgid "Reverse linefeed."
msgstr "逆ラインフィード"

#. type: tbl table
#: build/C/man4/console_codes.4:129
#, no-wrap
msgid "ESC Z"
msgstr "ESC Z"

#. type: tbl table
#: build/C/man4/console_codes.4:129
#, no-wrap
msgid "DECID"
msgstr "DECID"

#. type: tbl table
#: build/C/man4/console_codes.4:133
#, no-wrap
msgid ""
"DEC private identification. The kernel\n"
"returns the string  ESC [ ? 6 c, claiming\n"
"that it is a VT102."
msgstr ""
"DEC固有の識別用。\n"
"カーネルは文字列 ESC [ ? 6 c を返す。\n"
"これは端末がVT102であることを意味する。"

#. type: tbl table
#: build/C/man4/console_codes.4:134
#, no-wrap
msgid "ESC 7"
msgstr "ESC 7"

#. type: tbl table
#: build/C/man4/console_codes.4:134
#, no-wrap
msgid "DECSC"
msgstr "DECSC"

#. type: tbl table
#: build/C/man4/console_codes.4:137
#, no-wrap
msgid ""
"Save current state (cursor coordinates,\n"
"attributes, character sets pointed at by G0, G1)."
msgstr ""
"現在の状態 (カーソルの座標、属性、G0, G1 で示している\n"
"文字集合) をセーブする。"

#. type: tbl table
#: build/C/man4/console_codes.4:138
#, no-wrap
msgid "ESC 8"
msgstr "ESC 8"

#. type: tbl table
#: build/C/man4/console_codes.4:138
#, no-wrap
msgid "DECRC"
msgstr "DECRC"

#. type: tbl table
#: build/C/man4/console_codes.4:138
#, no-wrap
msgid "Restore state most recently saved by ESC 7."
msgstr "最後に ESC 7 でセーブした状態を復帰させる。"

#. type: tbl table
#: build/C/man4/console_codes.4:139
#, no-wrap
msgid "ESC ["
msgstr "ESC ["

#. type: tbl table
#: build/C/man4/console_codes.4:139
#, no-wrap
msgid "CSI"
msgstr "CSI"

#. type: tbl table
#: build/C/man4/console_codes.4:139
#, no-wrap
msgid "Control sequence introducer"
msgstr "コントロールシーケンスを導入する。"

#. type: tbl table
#: build/C/man4/console_codes.4:140
#, no-wrap
msgid "ESC %"
msgstr "ESC %"

#. type: tbl table
#: build/C/man4/console_codes.4:140
#, no-wrap
msgid "Start sequence selecting character set"
msgstr "キャラクターセットを選択するシーケンスを開始する。"

#. type: tbl table
#: build/C/man4/console_codes.4:141
#, no-wrap
msgid "ESC % @"
msgstr "ESC % @"

#. type: tbl table
#: build/C/man4/console_codes.4:141
#, no-wrap
msgid "\\0\\0\\0Select default (ISO 646 / ISO 8859-1)"
msgstr "\\0\\0\\0 デフォルト(ISO 646 / ISO 8859-1)を選択する。"

#. type: tbl table
#: build/C/man4/console_codes.4:142
#, no-wrap
msgid "ESC % G"
msgstr "ESC % G"

#. type: tbl table
#: build/C/man4/console_codes.4:142
#, no-wrap
msgid "\\0\\0\\0Select UTF-8"
msgstr "\\0\\0\\0 UTF-8 を選択する。"

#. type: tbl table
#: build/C/man4/console_codes.4:143
#, no-wrap
msgid "ESC % 8"
msgstr "ESC % 8"

#. type: tbl table
#: build/C/man4/console_codes.4:143
#, no-wrap
msgid "\\0\\0\\0Select UTF-8 (obsolete)"
msgstr "\\0\\0\\0 UTF-8 を選択する(旧式)。"

#. type: tbl table
#: build/C/man4/console_codes.4:144
#, no-wrap
msgid "ESC # 8"
msgstr "ESC # 8"

#. type: tbl table
#: build/C/man4/console_codes.4:144
#, no-wrap
msgid "DECALN"
msgstr "DECALN"

#. type: tbl table
#: build/C/man4/console_codes.4:144
#, no-wrap
msgid "DEC screen alignment test - fill screen with E's."
msgstr "DEC のスクリーン調整テスト - スクリーンを E でうめる。"

#. type: tbl table
#: build/C/man4/console_codes.4:145
#, no-wrap
msgid "ESC ("
msgstr "ESC ("

#. type: tbl table
#: build/C/man4/console_codes.4:145
#, no-wrap
msgid "Start sequence defining G0 character set"
msgstr "G0 文字集合を定義するシーケンスを開始する。"

#. type: tbl table
#: build/C/man4/console_codes.4:146
#, no-wrap
msgid "ESC ( B"
msgstr "ESC ( B"

#. type: tbl table
#: build/C/man4/console_codes.4:146
#, no-wrap
msgid "\\0\\0\\0Select default (ISO 8859-1 mapping)"
msgstr "\\0\\0\\0 デフォルト(ISO 8859-1 マッピング)を選択する。"

#. type: tbl table
#: build/C/man4/console_codes.4:147
#, no-wrap
msgid "ESC ( 0"
msgstr "ESC ( 0"

#. type: tbl table
#: build/C/man4/console_codes.4:147
#, no-wrap
msgid "\\0\\0\\0Select VT100 graphics mapping"
msgstr "\\0\\0\\0 VT100 グラフィクスマッピングを選択する。"

#. type: tbl table
#: build/C/man4/console_codes.4:148
#, no-wrap
msgid "ESC ( U"
msgstr "ESC ( U"

#. type: tbl table
#: build/C/man4/console_codes.4:148
#, no-wrap
msgid "\\0\\0\\0Select null mapping - straight to character ROM"
msgstr "\\0\\0\\0 ヌルマッピングを選択する - キャラクター ROM から直接マッピングする。"

#. type: tbl table
#: build/C/man4/console_codes.4:149
#, no-wrap
msgid "ESC ( K"
msgstr "ESC ( K"

#. type: tbl table
#: build/C/man4/console_codes.4:149
#, no-wrap
msgid "\\0\\0\\0Select user mapping - the map that is loaded by"
msgstr "\\0\\0\\0 ユーザー定義のマッピングを選択する - そのマップ"

#. type: tbl table
#: build/C/man4/console_codes.4:150
#, no-wrap
msgid "\\0\\0\\0the utility B<mapscrn>(8)."
msgstr "\\0\\0\\0 は B<mapscrn>(8) ユーティリティーによってロードされる。"

#. type: tbl table
#: build/C/man4/console_codes.4:151
#, no-wrap
msgid "ESC )"
msgstr "ESC )"

#. type: tbl table
#: build/C/man4/console_codes.4:151
#, no-wrap
msgid "Start sequence defining G1"
msgstr "G1 を定義するシーケンスを開始する。"

#. type: tbl table
#: build/C/man4/console_codes.4:152
#, no-wrap
msgid "(followed by one of B, 0, U, K, as above)."
msgstr "(すでに述べたように B, 0, U, K のどれかが次に続く)"

#. type: tbl table
#: build/C/man4/console_codes.4:153
#, no-wrap
msgid "ESC E<gt>"
msgstr "ESC E<gt>"

#. type: tbl table
#: build/C/man4/console_codes.4:153
#, no-wrap
msgid "DECPNM"
msgstr "DECPNM"

#. type: tbl table
#: build/C/man4/console_codes.4:153
#, no-wrap
msgid "Set numeric keypad mode"
msgstr "数値キーパッドモード(numeric keypad mode)をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:154
#, no-wrap
msgid "ESC ="
msgstr "ESC ="

#. type: tbl table
#: build/C/man4/console_codes.4:154
#, no-wrap
msgid "DECPAM"
msgstr "DECPAM"

#. type: tbl table
#: build/C/man4/console_codes.4:154
#, no-wrap
msgid "Set application keypad mode"
msgstr "アプリケーションキーパッドモード(application keypad mode) をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:155
#, no-wrap
msgid "ESC ]"
msgstr "ESC ]"

#. type: tbl table
#: build/C/man4/console_codes.4:155
#, no-wrap
msgid "OSC"
msgstr "OSC"

#. type: tbl table
#: build/C/man4/console_codes.4:162
#, no-wrap
msgid ""
"(Should be: Operating system command)\n"
"ESC ] P I<nrrggbb>: set palette, with parameter\n"
"given in 7 hexadecimal digits after the final P :-(.\n"
"Here I<n> is the color (0\\(en15), and I<rrggbb> indicates\n"
"the red/green/blue values (0\\(en255).\n"
"ESC ] R: reset palette"
msgstr ""
"(\"Operating system command\"のことだろう)\n"
"ESC ] P I<nrrggbb>: 最後の P のあとの 7 つの 16 進数を\n"
"パラメーターとして :-( パレットをセットする。\n"
"ここで、I<n>は色 (0\\(en15)、I<rrggbb>は赤/緑/青の値\n"
"(0\\(en255)を意味する。\n"
"ESC ] R: パレットをリセットする。"

#. type: Plain text
#: build/C/man4/console_codes.4:166
msgid "B<ECMA-48 CSI sequences>"
msgstr "B<ECMA-48 CSI シーケンス>"

#. type: Plain text
#: build/C/man4/console_codes.4:172
msgid ""
"CSI (or ESC [) is followed by a sequence of parameters, at most NPAR (16), "
"that are decimal numbers separated by semicolons.  An empty or absent "
"parameter is taken to be 0.  The sequence of parameters may be preceded by a "
"single question mark."
msgstr ""
"CSI (または ESC [ ) のあとに、最大で NPAR (16) 個のセミコロンで区切られた 10 "
"進数のパラメーターシーケンスが続く。 空であるかそこにないパラメーターは 0 と"
"される。 パラメーターシーケンスの前にはひとつのクエスチョンマークがつくことが"
"ある。"

#. type: Plain text
#: build/C/man4/console_codes.4:176
msgid ""
"However, after CSI [ (or ESC [ [) a single character is read and this entire "
"sequence is ignored.  (The idea is to ignore an echoed function key.)"
msgstr ""
"しかし、CSI [ (または ESC [ [ ) の後では、一文字が読まれ、このすべての パラ"
"メーターシーケンスが無視される(要するにファンクションキーのエコーは 無視され"
"るということである)。"

#. type: Plain text
#: build/C/man4/console_codes.4:178
msgid "The action of a CSI sequence is determined by its final character."
msgstr "CSI シーケンスの動作は、その最後の文字によって決まる。"

#. type: tbl table
#: build/C/man4/console_codes.4:180
#, no-wrap
msgid "@"
msgstr "@"

#. type: tbl table
#: build/C/man4/console_codes.4:180
#, no-wrap
msgid "ICH"
msgstr "ICH"

#. type: tbl table
#: build/C/man4/console_codes.4:180
#, no-wrap
msgid "Insert the indicated # of blank characters."
msgstr "指示された数の空白文字を挿入する。"

#. type: tbl table
#: build/C/man4/console_codes.4:181
#, no-wrap
msgid "A"
msgstr "A"

#. type: tbl table
#: build/C/man4/console_codes.4:181
#, no-wrap
msgid "CUU"
msgstr "CUU"

#. type: tbl table
#: build/C/man4/console_codes.4:181
#, no-wrap
msgid "Move cursor up the indicated # of rows."
msgstr "指示された数だけカーソルを上方向に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:182
#, no-wrap
msgid "B"
msgstr "B"

#. type: tbl table
#: build/C/man4/console_codes.4:182
#, no-wrap
msgid "CUD"
msgstr "CUD"

#. type: tbl table
#: build/C/man4/console_codes.4:182 build/C/man4/console_codes.4:205
#, no-wrap
msgid "Move cursor down the indicated # of rows."
msgstr "カーソルを指示された数の行だけ下方向に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:183
#, no-wrap
msgid "C"
msgstr "C"

#. type: tbl table
#: build/C/man4/console_codes.4:183
#, no-wrap
msgid "CUF"
msgstr "CUF"

#. type: tbl table
#: build/C/man4/console_codes.4:183 build/C/man4/console_codes.4:202
#, no-wrap
msgid "Move cursor right the indicated # of columns."
msgstr "カーソルを指示された数の桁だけ右に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:184
#, no-wrap
msgid "D"
msgstr "D"

#. type: tbl table
#: build/C/man4/console_codes.4:184
#, no-wrap
msgid "CUB"
msgstr "CUB"

#. type: tbl table
#: build/C/man4/console_codes.4:184
#, no-wrap
msgid "Move cursor left the indicated # of columns."
msgstr "カーソルを指示された数の桁だけ左に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:185
#, no-wrap
msgid "E"
msgstr "E"

#. type: tbl table
#: build/C/man4/console_codes.4:185
#, no-wrap
msgid "CNL"
msgstr "CNL"

#. type: tbl table
#: build/C/man4/console_codes.4:185
#, no-wrap
msgid "Move cursor down the indicated # of rows, to column 1."
msgstr "カーソルを指示された数の行だけ下の第 1 桁に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:186
#, no-wrap
msgid "F"
msgstr "F"

#. type: tbl table
#: build/C/man4/console_codes.4:186
#, no-wrap
msgid "CPL"
msgstr "CPL"

#. type: tbl table
#: build/C/man4/console_codes.4:186
#, no-wrap
msgid "Move cursor up the indicated # of rows, to column 1."
msgstr "カーソルを指示された数の行だけ上の第 1 桁に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:187
#, no-wrap
msgid "G"
msgstr "G"

#. type: tbl table
#: build/C/man4/console_codes.4:187
#, no-wrap
msgid "CHA"
msgstr "CHA"

#. type: tbl table
#: build/C/man4/console_codes.4:187 build/C/man4/console_codes.4:221
#, no-wrap
msgid "Move cursor to indicated column in current row."
msgstr "カーソルを現在の行の指示された桁に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:188
#, no-wrap
msgid "H"
msgstr "H"

#. type: tbl table
#: build/C/man4/console_codes.4:188
#, no-wrap
msgid "CUP"
msgstr "CUP"

#. type: tbl table
#: build/C/man4/console_codes.4:188
#, no-wrap
msgid "Move cursor to the indicated row, column (origin at 1,1)."
msgstr "カーソルを指示された行、桁(1,1を原点とする)に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:189
#, no-wrap
msgid "J"
msgstr "J"

#. type: tbl table
#: build/C/man4/console_codes.4:189
#, no-wrap
msgid "ED"
msgstr "ED"

#. type: tbl table
#: build/C/man4/console_codes.4:189
#, no-wrap
msgid "Erase display (default: from cursor to end of display)."
msgstr "ディスプレイの消去(デフォルト: カーソルからディスプレイの最後まで)。"

#. type: tbl table
#: build/C/man4/console_codes.4:190
#, no-wrap
msgid "ESC [ 1 J: erase from start to cursor."
msgstr "ESC [ 1 J: 最初からカーソルまでの消去。"

#. type: tbl table
#: build/C/man4/console_codes.4:191
#, no-wrap
msgid "ESC [ 2 J: erase whole display."
msgstr "ESC [ 2 J: ディスプレイ全体の消去。"

#. type: tbl table
#: build/C/man4/console_codes.4:192
#, no-wrap
msgid "ESC [ 3 J: erase whole display including scroll-back"
msgstr "ESC [ 3 J: スクロールバッファーも含めたディスプレイ全体の"

#. type: tbl table
#: build/C/man4/console_codes.4:193
#, no-wrap
msgid "           buffer (since Linux 3.0)."
msgstr "           消去 (Linux 3.0 以降)。"

#.  ESC [ 3 J: commit f8df13e0a901fe55631fed66562369b4dba40f8b
#. type: tbl table
#: build/C/man4/console_codes.4:195
#, no-wrap
msgid "K"
msgstr "K"

#.  ESC [ 3 J: commit f8df13e0a901fe55631fed66562369b4dba40f8b
#. type: tbl table
#: build/C/man4/console_codes.4:195
#, no-wrap
msgid "EL"
msgstr "EL"

#.  ESC [ 3 J: commit f8df13e0a901fe55631fed66562369b4dba40f8b
#. type: tbl table
#: build/C/man4/console_codes.4:195
#, no-wrap
msgid "Erase line (default: from cursor to end of line)."
msgstr "行の消去(デフォルト: カーソルから行末まで)。"

#. type: tbl table
#: build/C/man4/console_codes.4:196
#, no-wrap
msgid "ESC [ 1 K: erase from start of line to cursor."
msgstr "ESC [ 1 K: 行頭からカーソルまでの消去。"

#. type: tbl table
#: build/C/man4/console_codes.4:197
#, no-wrap
msgid "ESC [ 2 K: erase whole line."
msgstr "ESC [ 2 K: 行全体の消去。"

#. type: tbl table
#: build/C/man4/console_codes.4:198
#, no-wrap
msgid "L"
msgstr "L"

#. type: tbl table
#: build/C/man4/console_codes.4:198
#, no-wrap
msgid "IL"
msgstr "IL"

#. type: tbl table
#: build/C/man4/console_codes.4:198
#, no-wrap
msgid "Insert the indicated # of blank lines."
msgstr "指示された数の空行を挿入する。"

#. type: tbl table
#: build/C/man4/console_codes.4:199
#, no-wrap
msgid "M"
msgstr "M"

#. type: tbl table
#: build/C/man4/console_codes.4:199
#, no-wrap
msgid "DL"
msgstr "DL"

#. type: tbl table
#: build/C/man4/console_codes.4:199
#, no-wrap
msgid "Delete the indicated # of lines."
msgstr "指示された数の行を削除する。"

#. type: tbl table
#: build/C/man4/console_codes.4:200
#, no-wrap
msgid "P"
msgstr "P"

#. type: tbl table
#: build/C/man4/console_codes.4:200
#, no-wrap
msgid "DCH"
msgstr "DCH"

#. type: tbl table
#: build/C/man4/console_codes.4:200
#, no-wrap
msgid "Delete the indicated # of characters on current line."
msgstr "現在の行から指示された数の文字を削除する。"

#. type: tbl table
#: build/C/man4/console_codes.4:201
#, no-wrap
msgid "X"
msgstr "X"

#. type: tbl table
#: build/C/man4/console_codes.4:201
#, no-wrap
msgid "ECH"
msgstr "ECH"

#. type: tbl table
#: build/C/man4/console_codes.4:201
#, no-wrap
msgid "Erase the indicated # of characters on current line."
msgstr "現在の行から指示された数の文字を消去する。"

#. type: tbl table
#: build/C/man4/console_codes.4:202
#, no-wrap
msgid "a"
msgstr "a"

#. type: tbl table
#: build/C/man4/console_codes.4:202
#, no-wrap
msgid "HPR"
msgstr "HPR"

#. type: tbl table
#: build/C/man4/console_codes.4:203
#, no-wrap
msgid "c"
msgstr "c"

#. type: tbl table
#: build/C/man4/console_codes.4:203
#, no-wrap
msgid "DA"
msgstr "DA"

#. type: tbl table
#: build/C/man4/console_codes.4:203
#, no-wrap
msgid "Answer ESC [ ? 6 c: \"I am a VT102\"."
msgstr "ESC [ ? 6 c を返す: \"私はVT102です\"(ということ)。"

#. type: tbl table
#: build/C/man4/console_codes.4:204
#, no-wrap
msgid "d"
msgstr "d"

#. type: tbl table
#: build/C/man4/console_codes.4:204
#, no-wrap
msgid "VPA"
msgstr "VPA"

#. type: tbl table
#: build/C/man4/console_codes.4:204
#, no-wrap
msgid "Move cursor to the indicated row, current column."
msgstr "カーソルを指示された行の現在の桁に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:205
#, no-wrap
msgid "e"
msgstr "e"

#. type: tbl table
#: build/C/man4/console_codes.4:205
#, no-wrap
msgid "VPR"
msgstr "VPR"

#. type: tbl table
#: build/C/man4/console_codes.4:206
#, no-wrap
msgid "f"
msgstr "f"

#. type: tbl table
#: build/C/man4/console_codes.4:206
#, no-wrap
msgid "HVP"
msgstr "HVP"

#. type: tbl table
#: build/C/man4/console_codes.4:206
#, no-wrap
msgid "Move cursor to the indicated row, column."
msgstr "カーソルを指示された行、桁に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:207
#, no-wrap
msgid "g"
msgstr "g"

#. type: tbl table
#: build/C/man4/console_codes.4:207
#, no-wrap
msgid "TBC"
msgstr "TBC"

#. type: tbl table
#: build/C/man4/console_codes.4:207
#, no-wrap
msgid "Without parameter: clear tab stop at current position."
msgstr "パラメーターなしの時: 現在位置のタブストップを削除する。"

#. type: tbl table
#: build/C/man4/console_codes.4:208
#, no-wrap
msgid "ESC [ 3 g: delete all tab stops."
msgstr "ESC [ 3 g: すべてのタブストップを削除する。"

#. type: tbl table
#: build/C/man4/console_codes.4:209
#, no-wrap
msgid "h"
msgstr "h"

#. type: tbl table
#: build/C/man4/console_codes.4:209
#, no-wrap
msgid "SM"
msgstr "SM"

#. type: tbl table
#: build/C/man4/console_codes.4:209
#, no-wrap
msgid "Set Mode (see below)."
msgstr "モードのセット(後述)。"

#. type: tbl table
#: build/C/man4/console_codes.4:210
#, no-wrap
msgid "l"
msgstr "l"

#. type: tbl table
#: build/C/man4/console_codes.4:210
#, no-wrap
msgid "RM"
msgstr "RM"

#. type: tbl table
#: build/C/man4/console_codes.4:210
#, no-wrap
msgid "Reset Mode (see below)."
msgstr "モードのリセット(後述)。"

#. type: tbl table
#: build/C/man4/console_codes.4:211
#, no-wrap
msgid "m"
msgstr "m"

#. type: tbl table
#: build/C/man4/console_codes.4:211
#, no-wrap
msgid "SGR"
msgstr "SGR"

#. type: tbl table
#: build/C/man4/console_codes.4:211
#, no-wrap
msgid "Set attributes (see below)."
msgstr "属性のセット(後述)。"

#. type: tbl table
#: build/C/man4/console_codes.4:212
#, no-wrap
msgid "n"
msgstr "n"

#. type: tbl table
#: build/C/man4/console_codes.4:212
#, no-wrap
msgid "DSR"
msgstr "DSR"

#. type: tbl table
#: build/C/man4/console_codes.4:212
#, no-wrap
msgid "Status report (see below)."
msgstr "状態の報告(後述)。"

#. type: tbl table
#: build/C/man4/console_codes.4:213
#, no-wrap
msgid "q"
msgstr "q"

#. type: tbl table
#: build/C/man4/console_codes.4:213
#, no-wrap
msgid "DECLL"
msgstr "DECLL"

#. type: tbl table
#: build/C/man4/console_codes.4:213
#, no-wrap
msgid "Set keyboard LEDs."
msgstr "キーボードの LED をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:214
#, no-wrap
msgid "ESC [ 0 q: clear all LEDs"
msgstr "ESC [ 0 q: すべての LED を消す。"

#. type: tbl table
#: build/C/man4/console_codes.4:215
#, no-wrap
msgid "ESC [ 1 q: set Scroll Lock LED"
msgstr "ESC [ 1 q: スクロールロック LED を点灯。"

#. type: tbl table
#: build/C/man4/console_codes.4:216
#, no-wrap
msgid "ESC [ 2 q: set Num Lock LED"
msgstr "ESC [ 2 q: ナンバーロック LED を点灯。"

#. type: tbl table
#: build/C/man4/console_codes.4:217
#, no-wrap
msgid "ESC [ 3 q: set Caps Lock LED"
msgstr "ESC [ 3 q: キャピタルロック LED を点灯。"

#. type: tbl table
#: build/C/man4/console_codes.4:218
#, no-wrap
msgid "r"
msgstr "r"

#. type: tbl table
#: build/C/man4/console_codes.4:218
#, no-wrap
msgid "DECSTBM"
msgstr "DECSTBM"

#. type: tbl table
#: build/C/man4/console_codes.4:218
#, no-wrap
msgid "Set scrolling region; parameters are top and bottom row."
msgstr "スクロールの範囲のセット; パラメーターは一番上の行と一番下の行。"

#. type: tbl table
#: build/C/man4/console_codes.4:219
#, no-wrap
msgid "s"
msgstr "s"

#. type: tbl table
#: build/C/man4/console_codes.4:219 build/C/man4/console_codes.4:220
#, no-wrap
msgid "?"
msgstr "?"

#. type: tbl table
#: build/C/man4/console_codes.4:219
#, no-wrap
msgid "Save cursor location."
msgstr "カーソル位置の保存。"

#. type: tbl table
#: build/C/man4/console_codes.4:220
#, no-wrap
msgid "u"
msgstr "u"

#. type: tbl table
#: build/C/man4/console_codes.4:220
#, no-wrap
msgid "Restore cursor location."
msgstr "カーソル位置の復帰。"

#. type: tbl table
#: build/C/man4/console_codes.4:221
#, no-wrap
msgid "\\`"
msgstr "\\`"

#. type: tbl table
#: build/C/man4/console_codes.4:221
#, no-wrap
msgid "HPA"
msgstr "HPA"

#. type: Plain text
#: build/C/man4/console_codes.4:225
msgid "B<ECMA-48 Set Graphics Rendition>"
msgstr "B<ECMA-48 グラフィクスレンディション(Graphics Rendition)の設定>"

#. type: Plain text
#: build/C/man4/console_codes.4:232
msgid ""
"The ECMA-48 SGR sequence ESC [ I<parameters> m sets display attributes.  "
"Several attributes can be set in the same sequence, separated by "
"semicolons.  An empty parameter (between semicolons or string initiator or "
"terminator) is interpreted as a zero."
msgstr ""
"ECMA-48 SGR シーケンス ESC [ E<lt>パラメーターE<gt> m は表示属性を設定する。 "
"セミコロンで区切ることで、同じシーケンスでいくつかの属性を設定できる。 空パラ"
"メーター(セミコロンか文字列開始文字か文字列終端文字の間)はゼロと解釈される。"

#. type: tbl table
#: build/C/man4/console_codes.4:234
#, no-wrap
msgid "param"
msgstr "パラメーター"

#. type: tbl table
#: build/C/man4/console_codes.4:234
#, no-wrap
msgid "result"
msgstr "結果"

#. type: tbl table
#: build/C/man4/console_codes.4:235 build/C/man4/fd.4:63
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:101 build/C/man4/mouse.4:144
#: build/C/man4/mouse.4:145 build/C/man4/mouse.4:146 build/C/man4/mouse.4:147
#: build/C/man4/mouse.4:148 build/C/man4/mouse.4:180 build/C/man4/mouse.4:181
#: build/C/man4/mouse.4:182 build/C/man4/st.4:435 build/C/man2/syslog.2:303
#, no-wrap
msgid "0"
msgstr "0"

#. type: tbl table
#: build/C/man4/console_codes.4:235
#, no-wrap
msgid "reset all attributes to their defaults"
msgstr "すべての属性をデフォルトにリセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:236 build/C/man4/fd.4:102
#: build/C/man4/mouse.4:99 build/C/man4/mouse.4:144 build/C/man4/mouse.4:180
#: build/C/man4/st.4:440 build/C/man2/syslog.2:304
#, no-wrap
msgid "1"
msgstr "1"

#. type: tbl table
#: build/C/man4/console_codes.4:236
#, no-wrap
msgid "set bold"
msgstr "ボールド(bold)をセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:237 build/C/man4/fd.4:73 build/C/man4/fd.4:83
#: build/C/man4/fd.4:84 build/C/man4/fd.4:85 build/C/man4/fd.4:86
#: build/C/man4/fd.4:87 build/C/man4/fd.4:88 build/C/man4/fd.4:89
#: build/C/man4/fd.4:90 build/C/man4/fd.4:91 build/C/man4/fd.4:92
#: build/C/man4/fd.4:103 build/C/man4/fd.4:104 build/C/man4/fd.4:105
#: build/C/man4/fd.4:106 build/C/man4/fd.4:116 build/C/man4/fd.4:117
#: build/C/man4/fd.4:118 build/C/man4/fd.4:119 build/C/man4/fd.4:120
#: build/C/man4/fd.4:121 build/C/man4/fd.4:122 build/C/man4/fd.4:123
#: build/C/man4/fd.4:124 build/C/man4/fd.4:125 build/C/man4/fd.4:126
#: build/C/man4/fd.4:127 build/C/man4/fd.4:137 build/C/man4/fd.4:138
#: build/C/man4/fd.4:139 build/C/man4/fd.4:140 build/C/man4/fd.4:141
#: build/C/man4/mouse.4:40 build/C/man4/mouse.4:100 build/C/man4/mouse.4:145
#: build/C/man4/mouse.4:181 build/C/man4/st.4:445 build/C/man2/syslog.2:305
#, no-wrap
msgid "2"
msgstr "2"

#. type: tbl table
#: build/C/man4/console_codes.4:237
#, no-wrap
msgid "set half-bright (simulated with color on a color display)"
msgstr "ハーフブライト(half-bright)(カラーディスプレイでは色で代用)をセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:238 build/C/man4/fd.4:73
#: build/C/man4/mouse.4:42 build/C/man4/mouse.4:147 build/C/man2/syslog.2:307
#, no-wrap
msgid "4"
msgstr "4"

#. type: tbl table
#: build/C/man4/console_codes.4:242
#, no-wrap
msgid ""
"set underscore (simulated with color on a color display)\n"
"(the colors used to simulate dim or underline are set\n"
"using ESC ] ...)"
msgstr ""
"下線(underscore)をセット(カラーディスプレイでは色で代用)。\n"
"(ディムや下線を代用するのに使われる色は\n"
"ESC ] ... によりセット)"

#. type: tbl table
#: build/C/man4/console_codes.4:243 build/C/man4/mouse.4:44
#: build/C/man4/mouse.4:148 build/C/man2/syslog.2:308
#, no-wrap
msgid "5"
msgstr "5"

#. type: tbl table
#: build/C/man4/console_codes.4:243
#, no-wrap
msgid "set blink"
msgstr "点滅(blink)をセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:244 build/C/man4/mouse.4:43
#: build/C/man2/syslog.2:310
#, no-wrap
msgid "7"
msgstr "7"

#. type: tbl table
#: build/C/man4/console_codes.4:244
#, no-wrap
msgid "set reverse video"
msgstr "反転表示(reverce video)をセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:245 build/C/man4/fd.4:84 build/C/man4/fd.4:85
#: build/C/man4/fd.4:104 build/C/man4/fd.4:118 build/C/man4/fd.4:119
#: build/C/man4/sk98lin.4:408 build/C/man4/sk98lin.4:409
#, no-wrap
msgid "10"
msgstr "10"

#. type: tbl table
#: build/C/man4/console_codes.4:248
#, no-wrap
msgid ""
"reset selected mapping, display control flag,\n"
"and toggle meta flag (ECMA-48 says \"primary font\")."
msgstr ""
"選択したマッピング、ディスプレイコントロールフラグ(display control flag)、\n"
"トグルメタフラグ(toggle meta flag)をリセットする (ECMA-48では\"primary font\"と呼んでいる)。"

#. type: tbl table
#: build/C/man4/console_codes.4:249 build/C/man4/fd.4:87
#, no-wrap
msgid "11"
msgstr "11"

#. type: tbl table
#: build/C/man4/console_codes.4:252
#, no-wrap
msgid ""
"select null mapping, set display control flag,\n"
"reset toggle meta flag (ECMA-48 says \"first alternate font\")."
msgstr ""
"ヌルマッピングを選択、ディスプレイコントロールフラグをセット、\n"
"トグルメタフラグをリセットする\n"
"(ECMA-48 では\"first alternate font\"と呼んでいる)。"

#. type: tbl table
#: build/C/man4/console_codes.4:253 build/C/man4/fd.4:102 build/C/man4/fd.4:116
#, no-wrap
msgid "12"
msgstr "12"

#. type: tbl table
#: build/C/man4/console_codes.4:259
#, no-wrap
msgid ""
"select null mapping, set display control flag,\n"
"set toggle meta flag (ECMA-48 says \"second alternate font\").\n"
"The toggle meta flag\n"
"causes the high bit of a byte to be toggled\n"
"before the mapping table translation is done."
msgstr ""
"ヌルマッピングを選択、ディスプレイコントロールフラグをセット、\n"
"トグルメタフラグをセットする (ECMA-48 では \"second alternate font\" と呼んでいる)。\n"
"トグルメタフラグがたっていると、\n"
"マッピングテーブルによる変換をする前に、\n"
"バイトの上位の1ビットがトグルされる。"

#. type: tbl table
#: build/C/man4/console_codes.4:260 build/C/man4/fd.4:122 build/C/man4/fd.4:123
#: build/C/man4/fd.4:124
#, no-wrap
msgid "21"
msgstr "21"

#. type: tbl table
#: build/C/man4/console_codes.4:263
#, no-wrap
msgid ""
"set underline; before Linux 4.17, this value\n"
"set normal intensity (as is done in many other terminals)"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:264 build/C/man4/fd.4:125
#, no-wrap
msgid "22"
msgstr "22"

#. type: tbl table
#: build/C/man4/console_codes.4:264
#, no-wrap
msgid "set normal intensity"
msgstr "通常の輝度にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:265 build/C/man4/fd.4:86 build/C/man4/fd.4:127
#, no-wrap
msgid "24"
msgstr "24"

#. type: tbl table
#: build/C/man4/console_codes.4:265
#, no-wrap
msgid "underline off"
msgstr "下線オフ。"

#. type: tbl table
#: build/C/man4/console_codes.4:266
#, no-wrap
msgid "25"
msgstr "25"

#. type: tbl table
#: build/C/man4/console_codes.4:266
#, no-wrap
msgid "blink off"
msgstr "点滅オフ。"

#. type: tbl table
#: build/C/man4/console_codes.4:267
#, no-wrap
msgid "27"
msgstr "27"

#. type: tbl table
#: build/C/man4/console_codes.4:267
#, no-wrap
msgid "reverse video off"
msgstr "反転表示オフ。"

#. type: tbl table
#: build/C/man4/console_codes.4:268
#, no-wrap
msgid "30"
msgstr "30"

#. type: tbl table
#: build/C/man4/console_codes.4:268
#, no-wrap
msgid "set black foreground"
msgstr "フォアグラウンド(foreground)を黒にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:269
#, no-wrap
msgid "31"
msgstr "31"

#. type: tbl table
#: build/C/man4/console_codes.4:269
#, no-wrap
msgid "set red foreground"
msgstr "フォアグラウンドを赤にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:270 build/C/man4/fd.4:137
#, no-wrap
msgid "32"
msgstr "32"

#. type: tbl table
#: build/C/man4/console_codes.4:270
#, no-wrap
msgid "set green foreground"
msgstr "フォアグラウンドを緑にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:271
#, no-wrap
msgid "33"
msgstr "33"

#. type: tbl table
#: build/C/man4/console_codes.4:271
#, no-wrap
msgid "set brown foreground"
msgstr "フォアグラウンドを茶にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:272
#, no-wrap
msgid "34"
msgstr "34"

#. type: tbl table
#: build/C/man4/console_codes.4:272
#, no-wrap
msgid "set blue foreground"
msgstr "フォアグラウンドを青にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:273
#, no-wrap
msgid "35"
msgstr "35"

#. type: tbl table
#: build/C/man4/console_codes.4:273
#, no-wrap
msgid "set magenta foreground"
msgstr "フォアグラウンドをマゼンダにセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:274 build/C/man4/fd.4:137 build/C/man4/fd.4:138
#, no-wrap
msgid "36"
msgstr "36"

#. type: tbl table
#: build/C/man4/console_codes.4:274
#, no-wrap
msgid "set cyan foreground"
msgstr "フォアグラウンドをシアンにセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:275
#, no-wrap
msgid "37"
msgstr "37"

#. type: tbl table
#: build/C/man4/console_codes.4:275
#, no-wrap
msgid "set white foreground"
msgstr "フォアグラウンドを白にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:276
#, no-wrap
msgid "38"
msgstr "38"

#. type: tbl table
#: build/C/man4/console_codes.4:279
#, no-wrap
msgid ""
"256/24-bit foreground color follows, shoehorned into 16 basic colors\n"
"(before Linux 3.16: set underscore on, set default foreground color)"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:280
#, no-wrap
msgid "39"
msgstr "39"

#. type: tbl table
#: build/C/man4/console_codes.4:283
#, no-wrap
msgid ""
"set default foreground color\n"
"(before Linux 3.16: set underscore off, set default foreground color)"
msgstr ""
"デフォルトのフォアグラウンドの色を設定する\n"
"(Linux 3.16 より前: 下線表示を解除し、デフォルトのフォアグラウンドの色をセット)"

#. type: tbl table
#: build/C/man4/console_codes.4:284 build/C/man4/fd.4:73 build/C/man4/fd.4:83
#: build/C/man4/fd.4:89 build/C/man4/fd.4:116 build/C/man4/fd.4:139
#, no-wrap
msgid "40"
msgstr "40"

#. type: tbl table
#: build/C/man4/console_codes.4:284
#, no-wrap
msgid "set black background"
msgstr "バックグラウンド(background)を黒にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:285 build/C/man4/fd.4:84
#, no-wrap
msgid "41"
msgstr "41"

#. type: tbl table
#: build/C/man4/console_codes.4:285
#, no-wrap
msgid "set red background"
msgstr "バックグラウンドを赤にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:286 build/C/man4/fd.4:85
#, no-wrap
msgid "42"
msgstr "42"

#. type: tbl table
#: build/C/man4/console_codes.4:286
#, no-wrap
msgid "set green background"
msgstr "バックグラウンドを緑にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:287
#, no-wrap
msgid "43"
msgstr "43"

#. type: tbl table
#: build/C/man4/console_codes.4:287
#, no-wrap
msgid "set brown background"
msgstr "バックグラウンドを茶にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:288 build/C/man4/fd.4:122 build/C/man4/fd.4:140
#, no-wrap
msgid "44"
msgstr "44"

#. type: tbl table
#: build/C/man4/console_codes.4:288
#, no-wrap
msgid "set blue background"
msgstr "バックグラウンドを青にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:289
#, no-wrap
msgid "45"
msgstr "45"

#. type: tbl table
#: build/C/man4/console_codes.4:289
#, no-wrap
msgid "set magenta background"
msgstr "バックグラウンドをマゼンダにセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:290
#, no-wrap
msgid "46"
msgstr "46"

#. type: tbl table
#: build/C/man4/console_codes.4:290
#, no-wrap
msgid "set cyan background"
msgstr "バックグラウンドをシアンにセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:291
#, no-wrap
msgid "47"
msgstr "47"

#. type: tbl table
#: build/C/man4/console_codes.4:291
#, no-wrap
msgid "set white background"
msgstr "バックグラウンドを白にセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:292 build/C/man4/fd.4:84 build/C/man4/fd.4:141
#, no-wrap
msgid "48"
msgstr "48"

#. type: tbl table
#: build/C/man4/console_codes.4:294
#, no-wrap
msgid "256/24-bit background color follows, shoehorned into 8 basic colors"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:295
#, no-wrap
msgid "49"
msgstr "49"

#. type: tbl table
#: build/C/man4/console_codes.4:295
#, no-wrap
msgid "set default background color"
msgstr "バックグラウンドをデフォルトにセット。"

#. type: tbl table
#: build/C/man4/console_codes.4:296
#, no-wrap
msgid "90..97"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:296
#, no-wrap
msgid "set foreground to bright versions of 30..37"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:297
#, no-wrap
msgid "100.107"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:297
#, no-wrap
msgid "set background, same as 40..47 (bright not supported)"
msgstr ""

#. type: Plain text
#: build/C/man4/console_codes.4:301
msgid "Commands 38 and 48 require further arguments:"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:303
#, no-wrap
msgid ";5;x"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:306
#, no-wrap
msgid ""
"256 color: values 0..15 are IBGR (black, red, green, ... white),\n"
"16..231 a 6x6x6 color cube, 232..255 a grayscale ramp"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:307
#, no-wrap
msgid ";2;r;g;b"
msgstr ""

#. type: tbl table
#: build/C/man4/console_codes.4:307
#, no-wrap
msgid "24-bit color, r/g/b components are in the range 0..255"
msgstr ""

#. type: Plain text
#: build/C/man4/console_codes.4:311
msgid "B<ECMA-48 Mode Switches>"
msgstr "B<ECMA-48 モードスイッチ(Mode Switches)>"

#. type: TP
#: build/C/man4/console_codes.4:311
#, no-wrap
msgid "ESC [ 3 h"
msgstr "ESC [ 3 h"

#. type: Plain text
#: build/C/man4/console_codes.4:314
msgid "DECCRM (default off): Display control chars."
msgstr "DECCRM (デフォルトではオフ): コントロール文字を表示する。"

#. type: TP
#: build/C/man4/console_codes.4:314
#, no-wrap
msgid "ESC [ 4 h"
msgstr "ESC [ 4 h"

#. type: Plain text
#: build/C/man4/console_codes.4:317
msgid "DECIM (default off): Set insert mode."
msgstr "DECIM (デフォルトではオフ): 挿入モードにする。"

#. type: TP
#: build/C/man4/console_codes.4:317
#, no-wrap
msgid "ESC [ 20 h"
msgstr "ESC [ 20 h"

#. type: Plain text
#: build/C/man4/console_codes.4:321
msgid "LF/NL (default off): Automatically follow echo of LF, VT or FF with CR."
msgstr ""
"LF/NL (デフォルトではオフ): LF, VT, FFをエコーしたあと自動的 CR をつける。"

#. type: Plain text
#: build/C/man4/console_codes.4:324
msgid "B<ECMA-48 Status Report Commands>"
msgstr "B<ECMA-48 状態リポートコマンド(Status Report Commands)>"

#. type: TP
#: build/C/man4/console_codes.4:324
#, no-wrap
msgid "ESC [ 5 n"
msgstr "ESC [ 5 n"

#. type: Plain text
#: build/C/man4/console_codes.4:327
msgid "Device status report (DSR): Answer is ESC [ 0 n (Terminal OK)."
msgstr "デバイス状態のリポート(DSR): 返事は ESC [ 0 n (端末 OK)."

#. type: TP
#: build/C/man4/console_codes.4:327
#, no-wrap
msgid "ESC [ 6 n"
msgstr "ESC [ 6 n"

#. type: Plain text
#: build/C/man4/console_codes.4:332
msgid ""
"Cursor position report (CPR): Answer is ESC [ I<y> ; I<x> R, where I<x,y> is "
"the cursor location."
msgstr ""
"カーソル位置のリポート(CPR): 返事は ESC [ I<y> ; I<x> R、 I<x,y> はカーソルの"
"位置をあらわす。"

#. type: Plain text
#: build/C/man4/console_codes.4:334
msgid "B<DEC Private Mode (DECSET/DECRST) sequences>"
msgstr "B<DEC プライベートモード (DECSET/DECRST) シーケンス>"

#. type: Plain text
#: build/C/man4/console_codes.4:340
msgid ""
"These are not described in ECMA-48.  We list the Set Mode sequences; the "
"Reset Mode sequences are obtained by replacing the final \\(aqh\\(aq by "
"\\(aql\\(aq."
msgstr ""
"これらは ECMA-48 では記述されていない。ここでは、セットモード シーケンス "
"(Set Mode sequences)を記載する; 最後の \\(aqh\\(aq を \\(aql\\(aq に 置き換え"
"るとリセットモードシーケンス(Reset Mode sequences)になる。"

#. type: TP
#: build/C/man4/console_codes.4:340
#, no-wrap
msgid "ESC [ ? 1 h"
msgstr "ESC [ ? 1 h"

#. type: Plain text
#: build/C/man4/console_codes.4:344
msgid ""
"DECCKM (default off): When set, the cursor keys send an ESC O prefix, rather "
"than ESC [."
msgstr ""
"DECCKM (デフォルトはオフ): セットされた時にはカーソルキーは ESC [ ではなく "
"ESC O を前につけて送る。"

#. type: TP
#: build/C/man4/console_codes.4:344
#, no-wrap
msgid "ESC [ ? 3 h"
msgstr "ESC [ ? 3 h"

#. type: Plain text
#: build/C/man4/console_codes.4:351
msgid ""
"DECCOLM (default off = 80 columns): 80/132 col mode switch.  The driver "
"sources note that this alone does not suffice; some user-mode utility such "
"as B<resizecons>(8)  has to change the hardware registers on the console "
"video card."
msgstr ""
"DECCOLM (デフォルトはオフ = 80 桁): 80/132 の桁モード切替え。 ドライバーの"
"ソースの注釈には、これだけでは十分でなく B<resizecons>(8)  のようなユーザー"
"モードのユーティリティーで、コンソールビデオカードの ハードウェアレジスターを"
"変える必要があると書かれている。"

#. type: TP
#: build/C/man4/console_codes.4:351
#, no-wrap
msgid "ESC [ ? 5 h"
msgstr "ESC [ ? 5 h"

#. type: Plain text
#: build/C/man4/console_codes.4:354
msgid "DECSCNM (default off): Set reverse-video mode."
msgstr "DECSCNM (デフォルトはオフ): 反転表示モードのセット。"

#. type: TP
#: build/C/man4/console_codes.4:354
#, no-wrap
msgid "ESC [ ? 6 h"
msgstr "ESC [ ? 6 h"

#. type: Plain text
#: build/C/man4/console_codes.4:358
msgid ""
"DECOM (default off): When set, cursor addressing is relative to the upper "
"left corner of the scrolling region."
msgstr ""
"DECOM(デフォルトはオフ): セットされた時には、カーソルのアドレッシングが、 ス"
"クロール範囲の左上隅からの相対位置になる。"

#. type: TP
#: build/C/man4/console_codes.4:358
#, no-wrap
msgid "ESC [ ? 7 h"
msgstr "ESC [ ? 7 h"

#. type: Plain text
#: build/C/man4/console_codes.4:364
msgid ""
"DECAWM (default on): Set autowrap on.  In this mode, a graphic character "
"emitted after column 80 (or column 132 of DECCOLM is on)  forces a wrap to "
"the beginning of the following line first."
msgstr ""
"DECAWM(デフォルトはオン): オートラップを設定。このモードの時は、80 桁 "
"(DECCOLM がオンのときは 132 桁)を超えたグラフィックキャラクターは、 強制的に"
"次の行の先頭に折り返されて表示される。"

#. type: TP
#: build/C/man4/console_codes.4:364
#, no-wrap
msgid "ESC [ ? 8 h"
msgstr "ESC [ ? 8 h"

#. type: Plain text
#: build/C/man4/console_codes.4:367
msgid "DECARM (default on): Set keyboard autorepeat on."
msgstr "DECARM(デフォルトはオン): キーボードのオートリピートをオンにセット。"

#. type: TP
#: build/C/man4/console_codes.4:367
#, no-wrap
msgid "ESC [ ? 9 h"
msgstr "ESC [ ? 9 h"

#. type: Plain text
#: build/C/man4/console_codes.4:371
msgid ""
"X10 Mouse Reporting (default off): Set reporting mode to 1 (or reset to "
"0)\\(emsee below."
msgstr ""
"X10 マウスリポート(デフォルトはオフ): リポートモードを 1 にセット(または、 0 "
"にリセット)\\(em後述"

#. type: TP
#: build/C/man4/console_codes.4:371
#, no-wrap
msgid "ESC [ ? 25 h"
msgstr "ESC [ ? 25 h"

#. type: Plain text
#: build/C/man4/console_codes.4:374
msgid "DECTECM (default on): Make cursor visible."
msgstr "DECTECM (デフォルトはオン): カーソルを可視(visible)にする。"

#. type: TP
#: build/C/man4/console_codes.4:374
#, no-wrap
msgid "ESC [ ? 1000 h"
msgstr "ESC [ ? 1000 h"

#. type: Plain text
#: build/C/man4/console_codes.4:379
msgid ""
"X11 Mouse Reporting (default off): Set reporting mode to 2 (or reset to "
"0)\\(emsee below."
msgstr ""
"X11 マウスリポート(デフォルトはオフ): リポートモードを 2 にセット(または、 0"
"にリセット)\\(em後述"

#. type: Plain text
#: build/C/man4/console_codes.4:381
msgid "B<Linux Console Private CSI Sequences>"
msgstr "B<Linux コンソールプライベート CSI シーケンス>"

#. type: Plain text
#: build/C/man4/console_codes.4:388
msgid ""
"The following sequences are neither ECMA-48 nor native VT102.  They are "
"native to the Linux console driver.  Colors are in SGR parameters: 0 = "
"black, 1 = red, 2 = green, 3 = brown, 4 = blue, 5 = magenta, 6 = cyan, 7 = "
"white; 8\\(en15 = bright versions of 0\\(en7."
msgstr "以下のシーケンスは ECMA-48 のものでも本来の VT102 のものでもでもなく、 Linuxコンソールドライバーに固有なシーケンスである。色は SGR パラメーターで 表現される: 0 = 黒, 1= 赤, 2 = 緑, 3 = 茶, 4 = 青, 5 = マゼンタ, 6 = シアン, 7 = 白; 8\\(en15 は 0\\(en7 の色が明るいバージョンである。"

#. type: tbl table
#: build/C/man4/console_codes.4:390
#, no-wrap
msgid "ESC [ 1 ; I<n> ]"
msgstr "ESC [ 1 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:390
#, no-wrap
msgid "Set color I<n> as the underline color."
msgstr "下線の色をI<n> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:391
#, no-wrap
msgid "ESC [ 2 ; I<n> ]"
msgstr "ESC [ 2 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:391
#, no-wrap
msgid "Set color I<n> as the dim color."
msgstr "ディムの色をI<n> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:392
#, no-wrap
msgid "ESC [ 8 ]       "
msgstr "ESC [ 8 ]       "

#. type: tbl table
#: build/C/man4/console_codes.4:392
#, no-wrap
msgid "Make the current color pair the default attributes."
msgstr "現在の色のペアをデフォルト属性にする。"

#. type: tbl table
#: build/C/man4/console_codes.4:393
#, no-wrap
msgid "ESC [ 9 ; I<n> ]"
msgstr "ESC [ 9 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:393
#, no-wrap
msgid "Set screen blank timeout to I<n> minutes."
msgstr "スクリーンブランク(screen blank)のタイムアウトを I<n> 分にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:394
#, no-wrap
msgid "ESC [ 10 ; I<n> ]"
msgstr "ESC [ 10 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:394
#, no-wrap
msgid "Set bell frequency in Hz."
msgstr "ベルの周波数(Hz)をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:395
#, no-wrap
msgid "ESC [ 11 ; I<n> ]"
msgstr "ESC [ 11 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:395
#, no-wrap
msgid "Set bell duration in msec."
msgstr "ベルの鳴っている時間(msec)をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:396
#, no-wrap
msgid "ESC [ 12 ; I<n> ]"
msgstr "ESC [ 12 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:396
#, no-wrap
msgid "Bring specified console to the front."
msgstr "指定のコンソールを前面に持ってくる。"

#. type: tbl table
#: build/C/man4/console_codes.4:397
#, no-wrap
msgid "ESC [ 13 ]      "
msgstr "ESC [ 13 ]      "

#. type: tbl table
#: build/C/man4/console_codes.4:397
#, no-wrap
msgid "Unblank the screen."
msgstr "スクリーンをアンブランク(unblank)する。"

#. type: tbl table
#: build/C/man4/console_codes.4:398
#, no-wrap
msgid "ESC [ 14 ; I<n> ]   "
msgstr "ESC [ 14 ; I<n> ]   "

#. type: tbl table
#: build/C/man4/console_codes.4:398
#, no-wrap
msgid "Set the VESA powerdown interval in minutes."
msgstr "VESA電源停止インターバル(VESA powerdown interval)をセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:399
#, no-wrap
msgid "ESC [ 15 ]"
msgstr " ESC [ 15 ]"

#. type: tbl table
#: build/C/man4/console_codes.4:402
#, no-wrap
msgid ""
"Bring the previous console to the front\n"
"(since Linux 2.6.0)."
msgstr ""
"直前のコンソールを前面に持ってくる\n"
"(Linux 2.6.0 以降)"

#. type: tbl table
#: build/C/man4/console_codes.4:403
#, no-wrap
msgid "ESC [ 16 ; I<n> ]"
msgstr " ESC [ 16 ; I<n> ]"

#. type: tbl table
#: build/C/man4/console_codes.4:406
#, no-wrap
msgid ""
"Set the cursor blink interval in milliseconds\n"
"(since Linux 4.2)."
msgstr ""

#. type: SS
#: build/C/man4/console_codes.4:409
#, no-wrap
msgid "Character sets"
msgstr "文字集合"

#. type: Plain text
#: build/C/man4/console_codes.4:414
msgid ""
"The kernel knows about 4 translations of bytes into console-screen symbols.  "
"The four tables are: a) Latin1 -E<gt> PC, b) VT100 graphics -E<gt> PC, c) PC "
"-E<gt> PC, d) user-defined."
msgstr ""
"カーネルは、バイト列からコンソールスクリーン符号の変換を 4 つ 知っている。 4 "
"つの変換テーブルとは、a) Latin1 -E<gt> PC, b) VT100 graphics -E<gt> PC, c) "
"PC -E<gt> PC, d) ユーザー定義, である。"

#. type: Plain text
#: build/C/man4/console_codes.4:420
msgid ""
"There are two character sets, called G0 and G1, and one of them is the "
"current character set.  (Initially G0.)  Typing B<\\(haN> causes G1 to "
"become current, B<\\(haO> causes G0 to become current."
msgstr "G0 と G1 と呼ばれる二つの文字集合があり、そのうち一つが現在の 文字集合である(初期値は G0 )。 B<\\(haN> をタイプすると G1 が B<\\(haO> を入力すると G0 が現在の文字集合になる。"

#. type: Plain text
#: build/C/man4/console_codes.4:428
msgid ""
"These variables G0 and G1 point at a translation table, and can be changed "
"by the user.  Initially they point at tables a) and b), respectively.  The "
"sequences ESC ( B and ESC ( 0 and ESC ( U and ESC ( K cause G0 to point at "
"translation table a), b), c) and d), respectively.  The sequences ESC ) B "
"and ESC ) 0 and ESC ) U and ESC ) K cause G1 to point at translation table "
"a), b), c) and d), respectively."
msgstr ""
"変数 G0 と G1 は変換テーブルを指しており、ユーザーにより変更できる。 最初はそ"
"れぞれテーブル a) と テーブル b) を指している。 ESC ( B 、 ESC ( 0 、 ESC "
"( U 、 ESC ( K のそれぞれのシーケンスにより、 G0 が変換テーブル a)、 b)、 "
"c)、 d) を指すようになる。 また、ESC ) B 、 ESC ) 0 、 ESC ) U 、 ESC ) K の"
"それぞれのシーケンス により、G1 が変換テーブル a)、 b)、 c)、 d) を指すように"
"なる。"

#. type: Plain text
#: build/C/man4/console_codes.4:438
msgid ""
"The sequence ESC c causes a terminal reset, which is what you want if the "
"screen is all garbled.  The oft-advised \"echo \\(haV\\(haO\" will make only "
"G0 current, but there is no guarantee that G0 points at table a).  In some "
"distributions there is a program B<reset>(1)  that just does \"echo \\(ha[c"
"\".  If your terminfo entry for the console is correct (and has an entry rs1="
"\\eEc), then \"tput reset\" will also work."
msgstr "ESC c のシーケンスは端末をリセットする。スクリーンがめちゃくちゃになった 時にそうすることが必要である。よくアドバイスされる \"echo \\(haV\\(haO\" は G0 を現在の文字集合にするだけであり、G0 がテーブル a) を指しているという 保証はない。 いくつかのディストリビューションには、 B<reset>(1)  というプログラムが含まれるが、これはただ \"echo \\(ha[c\" を実行するものである。 もし、コンソールの terminfo エントリーが正しい(かつ rs1=\\eEc のエントリーが ある)ならば、\"tput reset\"でも同じ効果がある。"

#. type: Plain text
#: build/C/man4/console_codes.4:446
msgid ""
"The user-defined mapping table can be set using B<mapscrn>(8).  The result "
"of the mapping is that if a symbol c is printed, the symbol s = map[c] is "
"sent to the video memory.  The bitmap that corresponds to s is found in the "
"character ROM, and can be changed using B<setfont>(8)."
msgstr ""
"ユーザー定義のマッピングテーブルは B<mapscrn>(8)  を使って定義できる。 マッピ"
"ングの結果、シンボル c が印字されるとシンボル s = map[c] が ビデオメモリーに"
"送られる。s に対応するビットマップはキャラクター ROM にあり、 B<setfont>(8)  "
"により変更可能である。"

#. type: SS
#: build/C/man4/console_codes.4:446
#, no-wrap
msgid "Mouse tracking"
msgstr "マウストラッキング"

#. type: Plain text
#: build/C/man4/console_codes.4:458
msgid ""
"The mouse tracking facility is intended to return B<xterm>(1)-compatible "
"mouse status reports.  Because the console driver has no way to know the "
"device or type of the mouse, these reports are returned in the console input "
"stream only when the virtual terminal driver receives a mouse update ioctl.  "
"These ioctls must be generated by a mouse-aware user-mode application such "
"as the B<gpm>(8)  daemon."
msgstr ""
"マウストラッキング機能は、 B<xterm>(1)-互換の マウスステータスリポート(mouse "
"status reports)を返させるためのものである。 コンソールドライバーはマウスのデ"
"バイスや種類について知る方法が ないので、仮想ターミナルドライバーがマウス更新"
"の ioctl を受け取った時だけ、 マウスステータスリポートがコンソールの入力スト"
"リームに送られる。 この ioctl は、 B<gpm>(8)  デーモンのようなマウス対応の"
"ユーザーモード アプリケーションが発生しなければならない。"

#. type: Plain text
#: build/C/man4/console_codes.4:464
msgid ""
"The mouse tracking escape sequences generated by B<xterm>(1) encode numeric "
"parameters in a single character as I<value>+040.  For example, \\(aq!\\(aq "
"is 1.  The screen coordinate system is 1-based."
msgstr ""
"B<xterm>(1) によって生成される全てのマウス追跡エスケープシーケンスのための パ"
"ラメーターは、数値を I<value>+040 のように符号化し、一つの文字として あらわ"
"す。 例えば、\\(aq!\\(aq は 1 になる。スクリーン座標は 1 をベースにする。"

#. type: Plain text
#: build/C/man4/console_codes.4:474
msgid ""
"The X10 compatibility mode sends an escape sequence on button press encoding "
"the location and the mouse button pressed.  It is enabled by sending ESC [ ? "
"9 h and disabled with ESC [ ? 9 l.  On button press, B<xterm>(1) sends ESC "
"[ M I<bxy> (6 characters).  Here I<b> is button-1, and I<x> and I<y> are the "
"x and y coordinates of the mouse when the button was pressed.  This is the "
"same code the kernel also produces."
msgstr ""
"X10 互換モードでは、ボタンが押された時にマウスの位置と押されたマウスの ボタン"
"とをエンコードしたエスケープシーケンスを送る。 この機能は ESC [ ? 9 h を送る"
"と有効になり ESC [ ? 9 l により無効になる。 ボタンが押されると B<xterm>(1) "
"は ESC [ M I<bxy> (の 6 文字)を送る。 ここで I<b> は button-1, I<x> と I<y> "
"は マウスがボタンが押された 時の x と y 座標である。 このコードはカーネルが発"
"生するのと同じコードである。"

#. type: Plain text
#: build/C/man4/console_codes.4:489
msgid ""
"Normal tracking mode (not implemented in Linux 2.0.24) sends an escape "
"sequence on both button press and release.  Modifier information is also "
"sent.  It is enabled by sending ESC [ ? 1000 h and disabled with ESC [ ? "
"1000 l.  On button press or release, B<xterm>(1) sends ESC [ M I<bxy>.  The "
"low two bits of I<b> encode button information: 0=MB1 pressed, 1=MB2 "
"pressed, 2=MB3 pressed, 3=release.  The upper bits encode what modifiers "
"were down when the button was pressed and are added together: 4=Shift, "
"8=Meta, 16=Control.  Again I<x> and I<y> are the x and y coordinates of the "
"mouse event.  The upper left corner is (1,1)."
msgstr ""
"ノーマルトラッキングモード(Normal tracking mode)(Linux 2.0.24 では 実装されて"
"いない)では、両方のボタンが押されたか離された時に エスケープシーケンスが送ら"
"れる。 モディファイアの情報も一緒に送られる。 この機能は、ESC [ ? 1000 h を送"
"ると有効になり ESC [ ? 1000 l で無効になる。 ボタンが押されるか離されるかした"
"時には、B<xterm>(1) は ESC [ M I<bxy> を送る。 I<b> の低位の2ビットにはボタン"
"情報がエンコードされる: 0=MB1 が押された, 1=MB2 が押された, 2=MB3 が押され"
"た, 3=離された。 高位のビットには、ボタンが押された時にどのモディファイアがダ"
"ウンしていたかが エンコードされる: 4=Shift, 8=Meta, 16=Control。 そして、上位"
"と下位ビットが加算される。 ここでも I<x> と I<y> は、マウスイベントが起こった"
"時の x と y 座標であり、左上の隅が(1,1)である。"

#. type: SS
#: build/C/man4/console_codes.4:489
#, no-wrap
msgid "Comparisons with other terminals"
msgstr "他のターミナルとの比較"

#. type: Plain text
#: build/C/man4/console_codes.4:496
msgid ""
"Many different terminal types are described, like the Linux console, as "
"being \"VT100-compatible\".  Here we discuss differences between the Linux "
"console and the two most important others, the DEC VT102 and B<xterm>(1)."
msgstr ""
"多くの異なるターミナルタイプが、Linux コンソールのように、\"VT100互換\"を 名"
"乗っている。 ここでは、Linux コンソールと 2 つの最も重要なターミナルである "
"DEC VT102 と B<xterm>(1)  との違いについて述べる。"

#. type: Plain text
#: build/C/man4/console_codes.4:498
msgid "B<Control-character handling>"
msgstr "B<コントロール文字の取り扱い>"

#. type: Plain text
#: build/C/man4/console_codes.4:500
msgid "The VT102 also recognized the following control characters:"
msgstr "VT102 は以下のコントロール文字も認識する:"

#. type: Plain text
#: build/C/man4/console_codes.4:502
msgid "NUL (0x00) was ignored;"
msgstr "NUL (0x00) は無視される;"

#. type: Plain text
#: build/C/man4/console_codes.4:504
msgid "ENQ (0x05) triggered an answerback message;"
msgstr "ENQ (0x05) はアンサーバックメッセージ(answerback message)を発生する;"

#. type: Plain text
#: build/C/man4/console_codes.4:506
msgid "DC1 (0x11, B<\\(haQ>, XON) resumed transmission;"
msgstr "DC1 (0x11, B<\\(haQ>, XON) は送信を再開する;"

#. type: Plain text
#: build/C/man4/console_codes.4:509
msgid ""
"DC3 (0x13, B<\\(haS>, XOFF) caused VT100 to ignore (and stop transmitting)  "
"all codes except XOFF and XON."
msgstr "DC3 (0x13, B<\\(haS>, XOFF) は VT100 に XOFF と XON 以外のコードを無視(そして 送信の停止)を起こさせる。"

#. type: Plain text
#: build/C/man4/console_codes.4:511
msgid "VT100-like DC1/DC3 processing may be enabled by the terminal driver."
msgstr "端末ドライバーにより VT100 に似た DC1/DC3 処理を有効にする。"

#. type: Plain text
#: build/C/man4/console_codes.4:517
msgid ""
"The B<xterm>(1)  program (in VT100 mode) recognizes the control characters "
"BEL, BS, HT, LF, VT, FF, CR, SO, SI, ESC."
msgstr ""
"B<xterm>(1)  (VT100 モード)は BEL, BS, HT, LF, VT, FF, CR, SO, SI, ESC の コ"
"ントロール文字を認識する。"

#. type: Plain text
#: build/C/man4/console_codes.4:519
msgid "B<Escape sequences>"
msgstr "B<エスケープシーケンス>"

#. type: Plain text
#: build/C/man4/console_codes.4:521
msgid "VT100 console sequences not implemented on the Linux console:"
msgstr ""
"Linux コンソールで実装されていない VT100 コンソールシーケンスは以下の通り:"

#. type: tbl table
#: build/C/man4/console_codes.4:523
#, no-wrap
msgid "ESC N"
msgstr "ESC N"

#. type: tbl table
#: build/C/man4/console_codes.4:523
#, no-wrap
msgid "SS2"
msgstr "SS2"

#. type: tbl table
#: build/C/man4/console_codes.4:523
#, no-wrap
msgid "Single shift 2. (Select G2 character set for the next"
msgstr "シングルシフト 2 (次の文字だけ G2"

#. type: tbl table
#: build/C/man4/console_codes.4:524 build/C/man4/console_codes.4:526
#, no-wrap
msgid "character only.)"
msgstr "文字集合を選択する)。"

#. type: tbl table
#: build/C/man4/console_codes.4:525
#, no-wrap
msgid "ESC O"
msgstr "ESC O"

#. type: tbl table
#: build/C/man4/console_codes.4:525
#, no-wrap
msgid "SS3"
msgstr "SS3"

#. type: tbl table
#: build/C/man4/console_codes.4:525
#, no-wrap
msgid "Single shift 3. (Select G3 character set for the next"
msgstr "シングルシフト 3 (次の文字だけ G3"

#. type: tbl table
#: build/C/man4/console_codes.4:527
#, no-wrap
msgid "ESC P"
msgstr "ESC P"

#. type: tbl table
#: build/C/man4/console_codes.4:527
#, no-wrap
msgid "DCS"
msgstr "DCS"

#. type: tbl table
#: build/C/man4/console_codes.4:527
#, no-wrap
msgid "Device control string (ended by ESC \\e)"
msgstr "デバイス制御文字列 (ESC \\e で終わる)"

#. type: tbl table
#: build/C/man4/console_codes.4:528
#, no-wrap
msgid "ESC X"
msgstr "ESC X"

#. type: tbl table
#: build/C/man4/console_codes.4:528
#, no-wrap
msgid "SOS"
msgstr "SOS"

#. type: tbl table
#: build/C/man4/console_codes.4:528
#, no-wrap
msgid "Start of string."
msgstr "文字列の始まり。"

#. type: tbl table
#: build/C/man4/console_codes.4:529
#, no-wrap
msgid "ESC \\(ha"
msgstr " ESC \\(ha"

#. type: tbl table
#: build/C/man4/console_codes.4:529
#, no-wrap
msgid "PM"
msgstr "PM"

#. type: tbl table
#: build/C/man4/console_codes.4:529
#, no-wrap
msgid "Privacy message (ended by ESC \\e)"
msgstr "プライバシーメッセージ(ESC \\e で終わる)。"

#. type: tbl table
#: build/C/man4/console_codes.4:530
#, no-wrap
msgid "ESC \\e"
msgstr "ESC \\e"

#. type: TH
#: build/C/man4/console_codes.4:530 build/C/man4/st.4:25
#, no-wrap
msgid "ST"
msgstr "ST"

#. type: tbl table
#: build/C/man4/console_codes.4:530
#, no-wrap
msgid "String terminator"
msgstr "文字列の終端文字。"

#. type: tbl table
#: build/C/man4/console_codes.4:531
#, no-wrap
msgid "ESC * ..."
msgstr "ESC * ..."

#. type: tbl table
#: build/C/man4/console_codes.4:531
#, no-wrap
msgid "Designate G2 character set"
msgstr "G2 文字集合を指定する。"

#. type: tbl table
#: build/C/man4/console_codes.4:532
#, no-wrap
msgid "ESC + ..."
msgstr "ESC + ..."

#. type: tbl table
#: build/C/man4/console_codes.4:532
#, no-wrap
msgid "Designate G3 character set"
msgstr "G3 文字集合を指定する。"

#. type: Plain text
#: build/C/man4/console_codes.4:545
msgid ""
"The program B<xterm>(1)  (in VT100 mode) recognizes ESC c, ESC # 8, ESC "
"E<gt>, ESC =, ESC D, ESC E, ESC H, ESC M, ESC N, ESC O, ESC P ... ESC \\e, "
"ESC Z (it answers ESC [ ? 1 ; 2 c, \"I am a VT100 with advanced video option"
"\")  and ESC \\(ha ... ESC \\e with the same meanings as indicated above.  "
"It accepts ESC (, ESC ), ESC *, ESC + followed by 0, A, B for the DEC "
"special character and line drawing set, UK, and US-ASCII, respectively."
msgstr "B<xterm>(1)  (VT100 モード)は ESC c, ESC # 8, ESC E<gt>, ESC =, ESC D, ESC E, ESC H, ESC M, ESC N, ESC O, ESC P ... ESC \\e, ESC Z を認識する(\"わたしは高等ビデオオプション付きの VT100 です\"という 意味で ESC [ ? 1 ; 2 c と返答する)、ESC \\(ha ... ESC \\e は上述と同じ意味を あらわす。ESC (, ESC ), ESC *, ESC + に続く 0, A, B を DEC 特殊文字と して受け、それぞれラインドローイング(line drawing) のセット、UK、 US-ASCII をあらわす。"

#. type: Plain text
#: build/C/man4/console_codes.4:549
msgid ""
"The user can configure B<xterm>(1) to respond to VT220-specific control "
"sequences, and it will identify itself as a VT52, VT100, and up depending on "
"the way it is configured and initialized."
msgstr ""
"ユーザーは B<xterm>(1) が VT220 特有のコントロールシーケンスに 反応するように"
"設定でき、また設定と初期化のされかたによって 自分自身を VT52, VT100 などと認"
"識する。"

#. type: Plain text
#: build/C/man4/console_codes.4:554
msgid ""
"It accepts ESC ] (OSC) for the setting of certain resources.  In addition to "
"the ECMA-48 string terminator (ST), B<xterm>(1) accepts a BEL to terminate "
"an OSC string.  These are a few of the OSC control sequences recognized by "
"B<xterm>(1):"
msgstr ""
"xterm は、特定のリソースの設定のために ESC ] (OSC) を受け付ける。 ECMA-48 の"
"文字列終端文字 (ST) に加えて、 B<xterm>(1) は BEL を OSC 文字列を終端するもの"
"として受け付ける。 以下は B<xterm>(1) が認識する OSC コントロールシーケンスの"
"一部である。"

#. type: tbl table
#: build/C/man4/console_codes.4:556
#, no-wrap
msgid "ESC ] 0 ; I<txt> ST"
msgstr "ESC ] 0 ; I<txt> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:556
#, no-wrap
msgid "Set icon name and window title to I<txt>."
msgstr "アイコン名とウインドウタイトルを I<txt> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:557
#, no-wrap
msgid "ESC ] 1 ; I<txt> ST"
msgstr "ESC ] 1 ; I<txt> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:557
#, no-wrap
msgid "Set icon name to I<txt>."
msgstr "アイコン名を I<txt> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:558
#, no-wrap
msgid "ESC ] 2 ; I<txt> ST"
msgstr "ESC ] 2 ; I<txt> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:558
#, no-wrap
msgid "Set window title to I<txt>."
msgstr "ウインドウタイトルを I<txt> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:559
#, no-wrap
msgid "ESC ] 4 ; I<num>; I<txt> ST"
msgstr "ESC ] 4 ; I<num>; I<txt> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:559
#, no-wrap
msgid "Set ANSI color I<num> to I<txt>."
msgstr "ANSI 色 I<num> を I<txt> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:560
#, no-wrap
msgid "ESC ] 10 ; I<txt> ST"
msgstr "ESC ] 10 ; I<txt> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:560
#, no-wrap
msgid "Set dynamic text color to I<txt>."
msgstr "動的テキスト色を I<txt> にセットする。"

#. type: tbl table
#: build/C/man4/console_codes.4:561
#, no-wrap
msgid "ESC ] 4 6 ; I<name> ST"
msgstr "ESC ] 4 6 ; I<name> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:561
#, no-wrap
msgid "Change log file to I<name> (normally disabled"
msgstr "ログファイルを I<name> に変更する (通常は"

#. type: tbl table
#: build/C/man4/console_codes.4:562
#, no-wrap
msgid "by a compile-time option)"
msgstr "コンパイル時オプションにより無効になっている)。"

#. type: tbl table
#: build/C/man4/console_codes.4:563
#, no-wrap
msgid "ESC ] 5 0 ; I<fn> ST"
msgstr "ESC ] 5 0 ; I<fn> ST"

#. type: tbl table
#: build/C/man4/console_codes.4:563
#, no-wrap
msgid "Set font to I<fn>."
msgstr "フォントを I<fn> にセットする。"

#. type: Plain text
#: build/C/man4/console_codes.4:568
msgid ""
"It recognizes the following with slightly modified meaning (saving more "
"state, behaving closer to VT100/VT220):"
msgstr ""
"以下のものは、少し違った意味にとられる (より多くの状態を保存し、より VT100/"
"VT220 に近いふるまいをする):"

#. type: tbl table
#: build/C/man4/console_codes.4:570
#, no-wrap
msgid "ESC 7  DECSC"
msgstr "ESC 7  DECSC"

#. type: tbl table
#: build/C/man4/console_codes.4:570
#, no-wrap
msgid "Save cursor"
msgstr "カーソルの保存。"

#. type: tbl table
#: build/C/man4/console_codes.4:571
#, no-wrap
msgid "ESC 8  DECRC"
msgstr "ESC 8  DECRC"

#. type: tbl table
#: build/C/man4/console_codes.4:571
#, no-wrap
msgid "Restore cursor"
msgstr "カーソルの復元。"

#. type: Plain text
#: build/C/man4/console_codes.4:575
msgid "It also recognizes"
msgstr "また、次のものも認識する:"

#. type: tbl table
#: build/C/man4/console_codes.4:577
#, no-wrap
msgid "ESC F"
msgstr "ESC F"

#. type: tbl table
#: build/C/man4/console_codes.4:577
#, no-wrap
msgid "Cursor to lower left corner of screen (if enabled by"
msgstr "カーソルをスクリーンの左下に移動する。"

#. type: tbl table
#: build/C/man4/console_codes.4:578
#, no-wrap
msgid "B<xterm>(1)'s B<hpLowerleftBugCompat> resource)"
msgstr "(B<xterm>(1) の B<hpLowerleftBugCompat>リソースにより有効な時)"

#. type: tbl table
#: build/C/man4/console_codes.4:579
#, no-wrap
msgid "ESC l"
msgstr "ESC l"

#. type: tbl table
#: build/C/man4/console_codes.4:579
#, no-wrap
msgid "Memory lock (per HP terminals)."
msgstr "(HP ターミナル毎に)メモリーロック。"

#. type: tbl table
#: build/C/man4/console_codes.4:580
#, no-wrap
msgid "Locks memory above the cursor."
msgstr "カーソルより上のメモリーをロックする。"

#. type: tbl table
#: build/C/man4/console_codes.4:581
#, no-wrap
msgid "ESC m"
msgstr "ESC m"

#. type: tbl table
#: build/C/man4/console_codes.4:581
#, no-wrap
msgid "Memory unlock (per HP terminals)."
msgstr "(HP ターミナル毎に)メモリーロックを解除する。"

#. type: tbl table
#: build/C/man4/console_codes.4:582
#, no-wrap
msgid "ESC n"
msgstr "ESC n"

#. type: tbl table
#: build/C/man4/console_codes.4:582
#, no-wrap
msgid "LS2"
msgstr "LS2"

#. type: tbl table
#: build/C/man4/console_codes.4:582
#, no-wrap
msgid "Invoke the G2 character set."
msgstr "G2 文字集合の呼び出し。"

#. type: tbl table
#: build/C/man4/console_codes.4:583
#, no-wrap
msgid "ESC o"
msgstr "ESC o"

#. type: tbl table
#: build/C/man4/console_codes.4:583
#, no-wrap
msgid "LS3"
msgstr "LS3"

#. type: tbl table
#: build/C/man4/console_codes.4:583
#, no-wrap
msgid "Invoke the G3 character set."
msgstr "G3 文字集合の呼び出し。"

#. type: tbl table
#: build/C/man4/console_codes.4:584
#, no-wrap
msgid "ESC |"
msgstr "ESC |"

#. type: tbl table
#: build/C/man4/console_codes.4:584
#, no-wrap
msgid "LS3R"
msgstr "LS3R"

#. type: tbl table
#: build/C/man4/console_codes.4:584
#, no-wrap
msgid "Invoke the G3 character set as GR."
msgstr "G3 文字集合を GR として呼び出す。"

#. type: tbl table
#: build/C/man4/console_codes.4:585
#, no-wrap
msgid "ESC }"
msgstr "ESC }"

#. type: tbl table
#: build/C/man4/console_codes.4:585
#, no-wrap
msgid "LS2R"
msgstr "LS2R"

#. type: tbl table
#: build/C/man4/console_codes.4:585
#, no-wrap
msgid "Invoke the G2 character set as GR."
msgstr "G2 文字集合を GR として呼び出す。"

#. type: tbl table
#: build/C/man4/console_codes.4:586
#, no-wrap
msgid "ESC \\(ti"
msgstr " ESC \\(ti"

#. type: tbl table
#: build/C/man4/console_codes.4:586
#, no-wrap
msgid "LS1R"
msgstr "LS1R"

#. type: tbl table
#: build/C/man4/console_codes.4:586
#, no-wrap
msgid "Invoke the G1 character set as GR."
msgstr "G1 文字集合を GR として呼び出す。"

#. type: Plain text
#: build/C/man4/console_codes.4:592
msgid ""
"It also recognizes ESC % and provides a more complete UTF-8 implementation "
"than Linux console."
msgstr ""
"また ESC % を認識し、Linux コンソールより更に完全な UTF-8 実装を提供する。"

#. type: Plain text
#: build/C/man4/console_codes.4:594
msgid "B<CSI Sequences>"
msgstr "B<CSI シーケンス>"

#. type: Plain text
#: build/C/man4/console_codes.4:608
msgid ""
"Old versions of B<xterm>(1), for example, from X11R5, interpret the blink "
"SGR as a bold SGR.  Later versions which implemented ANSI colors, for "
"example, XFree86 3.1.2A in 1995, improved this by allowing the blink "
"attribute to be displayed as a color.  Modern versions of xterm implement "
"blink SGR as blinking text and still allow colored text as an alternate "
"rendering of SGRs.  Stock X11R6 versions did not recognize the color-setting "
"SGRs until the X11R6.8 release, which incorporated XFree86 xterm.  All "
"ECMA-48 CSI sequences recognized by Linux are also recognized by I<xterm>, "
"however B<xterm>(1) implements several ECMA-48 and DEC control sequences not "
"recognized by Linux."
msgstr ""
"X11R5 由来のような、古いバージョンの B<xterm>(1) はブリンク SGR を ボールド "
"SGR として解釈する。 1995 年の XFree86 3.1.2A のような、ANSI カラーが実装され"
"た、より新しい バージョンでは、ブリンク属性を色として表示することによってこれ"
"を 改善している。 最近のバージョンの xterm はブリンク SGR をテキストをブリン"
"クさせることで 実装し、さらにまた、SGR 表示の代替案として色付きのテキストも利"
"用できる。 Stock X11R6 版では、XFree86 xterm が組み入れられた X11R6.8 リリー"
"スまで 色設定 SGR を認識しなかった。 Linux が認識する他のすべての ECMA-48 "
"CSI シーケンスは I<xterm> でも認識されるが、B<xterm>(1) は Linux が認識しな"
"い いくつかの ECMA-48 と DEC のコントロールシーケンスも実装している。"

#. type: Plain text
#: build/C/man4/console_codes.4:622
msgid ""
"The B<xterm>(1)  program recognizes all of the DEC Private Mode sequences "
"listed above, but none of the Linux private-mode sequences.  For discussion "
"of B<xterm>(1)'s own private-mode sequences, refer to the I<Xterm Control "
"Sequences> document by Edward Moy, Stephen Gildea, and Thomas E.\\& Dickey "
"available with the X distribution.  That document, though terse, is much "
"longer than this manual page.  For a chronological overview,"
msgstr "B<xterm>(1) は上述のすべての DEC プライベートモードのシーケンスを認識するが、 Linux プライベートモードのシーケンスはどれも認識しない。 B<xterm>(1) 自身のプライベートモードシーケンスに関しての議論は、 X 配布とともに入手可能な Edward Moy, Stephen Gildea,Thomas E.\\& Dickey による I<Xterm Control Sequences> ドキュメントを参照されたい。 このドキュメントは、簡潔なものであるが、このマニュアルページより 遥かに長いものである。 年代順の概観としては、"

#. type: Plain text
#: build/C/man4/console_codes.4:626
msgid "E<.UR http://invisible-island.net\\:/xterm\\:/xterm.log.html> E<.UE>"
msgstr "E<.UR http://invisible-island.net\\:/xterm\\:/xterm.log.html> E<.UE>"

#. type: Plain text
#: build/C/man4/console_codes.4:629
msgid "details changes to xterm."
msgstr "には xterm の変更の詳細がある。"

#. type: Plain text
#: build/C/man4/console_codes.4:631
msgid "The I<vttest> program"
msgstr "I<vttest> は"

#. type: Plain text
#: build/C/man4/console_codes.4:635
msgid "E<.UR http://invisible-island.net\\:/vttest/> E<.UE>"
msgstr "E<.UR http://invisible-island.net\\:/vttest/> E<.UE>"

#. type: Plain text
#: build/C/man4/console_codes.4:640
msgid ""
"demonstrates many of these control sequences.  The B<xterm>(1) source "
"distribution also contains sample scripts which exercise other features."
msgstr ""
"で入手でき、これらのコントロールシーケンスの多くに関するデモを行う。 "
"B<xterm>(1) ソース配布パッケージには その他の機能を学ぶことが出来るサンプルス"
"クリプトが入っている。"

#. type: SH
#: build/C/man4/console_codes.4:640 build/C/man5/core.5:575
#: build/C/man4/cpuid.4:62 build/C/man4/fd.4:208 build/C/man7/fifo.7:53
#: build/C/man4/initrd.4:441 build/C/man3/makedev.3:86 build/C/man2/mknod.2:257
#: build/C/man4/msr.4:47 build/C/man4/null.4:57 build/C/man4/random.4:329
#: build/C/man4/st.4:904 build/C/man2/syslog.2:377 build/C/man3/syslog.3:338
#: build/C/man7/uri.7:592 build/C/man4/smartpqi.4:313
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man4/console_codes.4:643
msgid ""
"ESC 8 (DECRC) is not able to restore the character set changed with ESC %."
msgstr "ESC 8 (DECRC) は ESC % で変更された文字集合を復元することはできない。"

#. type: SH
#: build/C/man4/console_codes.4:643 build/C/man7/pipe.7:343
#: build/C/man4/random.4:333 build/C/man4/sk98lin.4:580
#: build/C/man3/stdarg.3:256 build/C/man7/uri.7:673 build/C/man4/lirc.4:435
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man4/console_codes.4:646
msgid ""
"In 2.0.23, CSI is broken, and NUL is not ignored inside escape sequences."
msgstr ""
"2.0.23 では CSI が壊れていて、エスケープシーケンス中の NUL が 無視されない。"

#. type: Plain text
#: build/C/man4/console_codes.4:655
msgid ""
"Some older kernel versions (after 2.0) interpret 8-bit control sequences.  "
"These \"C1 controls\" use codes between 128 and 159 to replace ESC [, ESC ] "
"and similar two-byte control sequence initiators.  There are fragments of "
"that in modern kernels (either overlooked or broken by changes to support "
"UTF-8), but the implementation is incomplete and should be regarded as "
"unreliable."
msgstr ""
"古いバージョン(2.0 以降)のカーネルには、8 ビット制御シーケンスを解釈する。 こ"
"れらの \"C1 コントロール\" は ESC [, ESC ] および同様な制御シーケンス 起動子"
"を置き換えるために 128 から 159 のコードを使う。 新しいカーネルでは (UTF-8 対"
"応の変更時に見落とされたか壊れたために)  寸断しているが、実装は不完全で信頼で"
"きないものと評価されている。"

#. type: Plain text
#: build/C/man4/console_codes.4:670
msgid ""
"Linux \"private mode\" sequences do not follow the rules in ECMA-48 for "
"private mode control sequences.  In particular, those ending with ] do not "
"use a standard terminating character.  The OSC (set palette) sequence is a "
"greater problem, since B<xterm>(1) may interpret this as a control sequence "
"which requires a string terminator (ST).  Unlike the B<setterm>(1) sequences "
"which will be ignored (since they are invalid control sequences), the "
"palette sequence will make B<xterm>(1) appear to hang (though pressing the "
"return-key will fix that).  To accommodate applications which have been "
"hardcoded to use Linux control sequences, set the B<xterm>(1) resource "
"B<brokenLinuxOSC> to true."
msgstr ""
"Linux \"プライベートモード\" シーケンスは ECMA-48 のプライベートモード コント"
"ロールシーケンスのルールに従っていない。 特に、 ] で終わるものは標準終端文字"
"を使えない。 OSC(パレット設定)シーケンスは大きな問題がある。 B<xterm>(1) はこ"
"れを文字列終端文字 (ST) が必要なコントロールシーケンスと 解釈するかもしれない"
"からである。 (不正なコントロールシーケンスなので)無視される B<setterm>(1) "
"シーケンスと 違い、パレットシーケンスは B<xterm>(1) をハングさせるかもしれな"
"い (しかしリターンキーを押すことで回復できる)。 Linux コントロールシーケンス"
"をハードコードしているアプリケーションに 適応させるには、B<xterm>(1) リソース"
"の B<brokenLinuxOSC> を 真 (true) に設定する。"

#. type: Plain text
#: build/C/man4/console_codes.4:674
msgid ""
"An older version of this document implied that Linux recognizes the ECMA-48 "
"control sequence for invisible text.  It is ignored."
msgstr ""
"このドキュメントの古いバージョンでは、Linux が ECMA-48 の不可視テキストの コ"
"ントロールシーケンスを認識するかのように書かれていた。 これは無視される。"

#. type: Plain text
#: build/C/man4/console_codes.4:677
msgid "B<ioctl_console>(2), B<charsets>(7)"
msgstr " B<ioctl_console>(2), B<charsets>(7)"

#. type: TH
#: build/C/man5/core.5:25
#, no-wrap
msgid "CORE"
msgstr "CORE"

#. type: TH
#: build/C/man5/core.5:25 build/C/man3/stdarg.3:43 build/C/man4/vcs.4:29
#: build/C/man4/veth.4:28
#, no-wrap
msgid "2020-11-01"
msgstr " 2020-11-01"

#. type: Plain text
#: build/C/man5/core.5:28
msgid "core - core dump file"
msgstr "core - コアダンプファイル"

#. type: Plain text
#: build/C/man5/core.5:39
msgid ""
"The default action of certain signals is to cause a process to terminate and "
"produce a I<core dump file>, a file containing an image of the process's "
"memory at the time of termination.  This image can be used in a debugger (e."
"g., B<gdb>(1))  to inspect the state of the program at the time that it "
"terminated.  A list of the signals which cause a process to dump core can be "
"found in B<signal>(7)."
msgstr ""
"ある種のシグナルを受けた場合のデフォルトのアクションは、 プロセスを終了し "
"(terminate)、 I<コアダンプファイル (core dump file)> を生成することである。コ"
"アダンプファイルは、ディスク上に生成される 終了時のプロセスのメモリーイメージ"
"を内容とするファイルである。 このイメージをデバッガ (例えば B<gdb>(1))  に読"
"み込んで、 プログラムが終了した時点のプログラムの状態を検査することができ"
"る。 どのシグナルを受けたときにプロセスがコアダンプを生成するかのリストは "
"B<signal>(7)  に書かれている。"

#. type: Plain text
#: build/C/man5/core.5:46
msgid ""
"A process can set its soft B<RLIMIT_CORE> resource limit to place an upper "
"limit on the size of the core dump file that will be produced if it receives "
"a \"core dump\" signal; see B<getrlimit>(2)  for details."
msgstr ""
"プロセスはソフトリソース制限 B<RLIMIT_CORE> を設定することで、「コアダンプ」"
"シグナルを受信した際に生成される コアダンプファイルのサイズに上限を課すことが"
"できる。詳細は B<getrlimit>(2)  を参照。"

#. type: Plain text
#: build/C/man5/core.5:49
msgid ""
"There are various circumstances in which a core dump file is not produced:"
msgstr "コアダンプファイルが生成されない状況がいくつかある:"

#. type: Plain text
#: build/C/man5/core.5:66
msgid ""
"The process does not have permission to write the core file.  (By default, "
"the core file is called I<core> or I<core.pid>, where I<pid> is the ID of "
"the process that dumped core, and is created in the current working "
"directory.  See below for details on naming.)  Writing the core file fails "
"if the directory in which it is to be created is not writable, or if a file "
"with the same name exists and is not writable or is not a regular file (e."
"g., it is a directory or a symbolic link)."
msgstr ""
"プロセスがコアファイルを書き込む許可を持たない場合 (デフォルトでは、コアファ"
"イルは I<core> か I<core.pid> (I<pid> はコアダンプを行うプロセスの ID) という"
"名前で、カレントワーキングディレクトリに生成される。 命名規則の詳細は下記を参"
"照)。 コアファイルを生成しようとしたディレクトリが書き込み可能でない場合、 も"
"しくは同じ名前のファイルが存在し、そのファイルが書き込み可能でも 通常のファイ"
"ルでもない場合 (例えば、ディレクトリやシンボリックリンク)、 コアファイルの生"
"成は失敗する。"

#. type: Plain text
#: build/C/man5/core.5:70
msgid ""
"A (writable, regular) file with the same name as would be used for the core "
"dump already exists, but there is more than one hard link to that file."
msgstr ""
"コアダンプに使おうとしたのと同じ名前の (書き込み可能な、通常の) ファイルが す"
"でに存在し、そのファイルに対するハードリンクが 2個以上ある場合。"

#. type: Plain text
#: build/C/man5/core.5:74
msgid ""
"The filesystem where the core dump file would be created is full; or has run "
"out of inodes; or is mounted read-only; or the user has reached their quota "
"for the filesystem."
msgstr ""
"コアダンプファイルを生成しようとしたファイルシステムがフルであるか、 inode が"
"全て使用されているか、読み込み専用でマウントされている場合。 または、そのユー"
"ザーのディスク使用量がそのファイルシステムの クオータ (quota) に達している。"

#. type: Plain text
#: build/C/man5/core.5:77
msgid ""
"The directory in which the core dump file is to be created does not exist."
msgstr "コアダンプファイルを生成しようとしたディレクトリが存在しない場合。"

#. type: Plain text
#: build/C/man5/core.5:90
msgid ""
"The B<RLIMIT_CORE> (core file size) or B<RLIMIT_FSIZE> (file size) resource "
"limits for the process are set to zero; see B<getrlimit>(2)  and the "
"documentation of the shell's I<ulimit> command (I<limit> in B<csh>(1))."
msgstr ""
"プロセス毎のリソース制限 B<RLIMIT_CORE> (コアファイルのサイズ) か "
"B<RLIMIT_FSIZE> (ファイルサイズ) が 0 に設定されている場合。 "
"B<getrlimit>(2)  やシェルの I<ulimit> コマンドのドキュメント (B<csh>(1)  の "
"I<limit>)  を参照。"

#. type: Plain text
#: build/C/man5/core.5:97
msgid ""
"The binary being executed by the process does not have read permission "
"enabled.  (This is a security measure to ensure that an executable whose "
"contents are not readable does not produce a\\(empossibly readable\\(emcore "
"dump containing an image of the executable.)"
msgstr ""

#.  FIXME . Perhaps relocate discussion of /proc/sys/fs/suid_dumpable
#.  and PR_SET_DUMPABLE to this page?
#. type: Plain text
#: build/C/man5/core.5:112
#, fuzzy
#| msgid ""
#| "The process is executing a set-user-ID (set-group-ID) program that is "
#| "owned by a user (group) other than the real user (group)  ID of the "
#| "process.  (However, see the description of the B<prctl>(2)  "
#| "B<PR_SET_DUMPABLE> operation, and the description of the I</proc/sys/fs/"
#| "suid_dumpable> file in B<proc>(5).)"
msgid ""
"The process is executing a set-user-ID (set-group-ID) program that is owned "
"by a user (group) other than the real user (group)  ID of the process, or "
"the process is executing a program that has file capabilities (see "
"B<capabilities>(7)).  (However, see the description of the B<prctl>(2)  "
"B<PR_SET_DUMPABLE> operation, and the description of the I</proc/sys/fs/"
"suid_dumpable> file in B<proc>(5).)"
msgstr ""
"プロセスが実行している set-user-ID (set-group-ID) プログラムの所有者の ユー"
"ザー (グループ) が、プロセスの実 UID (実 GID) と異なる場合 (但し、 "
"B<prctl>(2)  B<PR_SET_DUMPABLE> 操作の説明と、 B<proc>(5)  の I</proc/sys/fs/"
"suid_dumpable> ファイルの説明も参照のこと)。"

#. type: Plain text
#: build/C/man5/core.5:129
msgid ""
"I</proc/sys/kernel/core_pattern> is empty and I</proc/sys/kernel/"
"core_uses_pid> contains the value 0.  (These files are described below.)  "
"Note that if I</proc/sys/kernel/core_pattern> is empty and I</proc/sys/"
"kernel/core_uses_pid> contains the value 1, core dump files will have names "
"of the form I<.pid>, and such files are hidden unless one uses the B<ls>(1)  "
"I<-a> option."
msgstr ""

#.  commit 046d662f481830e652ac34cd112249adde16452a
#. type: Plain text
#: build/C/man5/core.5:135
msgid ""
"(Since Linux 3.7)  The kernel was configured without the B<CONFIG_COREDUMP> "
"option."
msgstr ""
"(Linux 3.7 以降) カーネルの設定で B<CONFIG_COREDUMP> オプションが有効になって"
"いない。"

#. type: Plain text
#: build/C/man5/core.5:141
msgid ""
"In addition, a core dump may exclude part of the address space of the "
"process if the B<madvise>(2)  B<MADV_DONTDUMP> flag was employed."
msgstr ""
"上記に加えて、 B<madvise>(2) の B<MADV_DONTDUMP> フラグが使用されている場合、"
"プロセスのアドレス空間の一部がコアダンプから除外される場合がある。"

#. type: Plain text
#: build/C/man5/core.5:150
msgid ""
"On systems that employ B<systemd>(1)  as the I<init> framework, core dumps "
"may instead be placed in a location determined by B<systemd>(1).  See below "
"for further details."
msgstr ""

#. type: SS
#: build/C/man5/core.5:150
#, no-wrap
msgid "Naming of core dump files"
msgstr "コアダンプファイルの名前"

#. type: Plain text
#: build/C/man5/core.5:159
msgid ""
"By default, a core dump file is named I<core>, but the I</proc/sys/kernel/"
"core_pattern> file (since Linux 2.6 and 2.4.21)  can be set to define a "
"template that is used to name core dump files.  The template can contain % "
"specifiers which are substituted by the following values when a core file is "
"created:"
msgstr ""
"デフォルトでは、コアダンプファイルの名前は I<core> となるが、コアダンプファイ"
"ルの名前を決めるのに使われるテンプレートを I</proc/sys/kernel/core_pattern> "
"ファイルに定義することで、ファイル名を変更することができる (I</proc/sys/"
"kernel/core_pattern> は Linux 2.6 および 2.4.21 以降で利用できる)。 テンプ"
"レートには % 指示子 (specifier) を入れることができる。 これはコアファイルが生"
"成される際に、以下の値に置き換えられる。"

#. type: TP
#: build/C/man5/core.5:162
#, no-wrap
msgid "%%"
msgstr "%%"

#. type: Plain text
#: build/C/man5/core.5:165
msgid "A single % character."
msgstr "1 つの % 文字。"

#. type: TP
#: build/C/man5/core.5:165
#, no-wrap
msgid "%c"
msgstr "%c"

#. type: Plain text
#: build/C/man5/core.5:168
msgid ""
"Core file size soft resource limit of crashing process (since Linux 2.6.24)."
msgstr "クラッシュしたプロセスのコアファイルのサイズに関するソフトリソース上限 (Linux 2.6.24 以降)。"

#. type: TP
#: build/C/man5/core.5:168
#, no-wrap
msgid "%d"
msgstr "%d"

#.  Added in git commit 12a2b4b2241e318b4f6df31228e4272d2c2968a1
#. type: Plain text
#: build/C/man5/core.5:175
msgid ""
"Dump mode\\(emsame as value returned by B<prctl>(2)  B<PR_GET_DUMPABLE> "
"(since Linux 3.7)."
msgstr "ダンプモード \\(em B<prctl>(2) B<PR_GET_DUMPABLE> が返す値と同じ (Linux 3.7 以降)。"

#. type: TP
#: build/C/man5/core.5:175
#, no-wrap
msgid "%e"
msgstr "%e"

#. type: Plain text
#: build/C/man5/core.5:188
msgid ""
"The process or thread's I<comm> value, which typically is the same as the "
"executable filename (without path prefix, and truncated to a maximum of 15 "
"characters), but may have been modified to be something different; see the "
"discussion of I</proc/[pid]/comm> and I</proc/[pid]/task/[tid]/comm> in "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man5/core.5:188
#, no-wrap
msgid "%E"
msgstr "%E"

#. type: Plain text
#: build/C/man5/core.5:193
msgid ""
"Pathname of executable, with slashes (\\(aq/\\(aq) replaced by exclamation "
"marks (\\(aq!\\(aq)  (since Linux 3.0)."
msgstr ""
"実行ファイルのパス名。スラッシュ (\\(aq/\\(aq) は感嘆符 (\\(aq!\\(aq) に置き"
"換えられる。 (Linux 3.0 以降)"

#. type: TP
#: build/C/man5/core.5:193
#, no-wrap
msgid "%g"
msgstr "%g"

#. type: Plain text
#: build/C/man5/core.5:196
msgid "Numeric real GID of dumped process."
msgstr "ダンプされたプロセスの実グループ ID (real GID) の数値。"

#. type: TP
#: build/C/man5/core.5:196
#, no-wrap
msgid "%h"
msgstr "%h"

#. type: Plain text
#: build/C/man5/core.5:199
msgid "Hostname (same as I<nodename> returned by B<uname>(2))."
msgstr "ホスト名 (B<uname>(2) で返される I<nodename> と同じ)。"

#. type: TP
#: build/C/man5/core.5:199
#, no-wrap
msgid "%i"
msgstr "%i"

#.  commit b03023ecbdb76c1dec86b41ed80b123c22783220
#. type: Plain text
#: build/C/man5/core.5:205
msgid ""
"TID of thread that triggered core dump, as seen in the PID namespace in "
"which the thread resides (since Linux 3.18)."
msgstr "コアダンプのきっかけとなったスレッドの TID; そのスレッドが属している PID 名前空間での TID (Linux 3.18 以降)。"

#. type: TP
#: build/C/man5/core.5:205
#, no-wrap
msgid "%I"
msgstr "%I"

#.  commit b03023ecbdb76c1dec86b41ed80b123c22783220
#. type: Plain text
#: build/C/man5/core.5:210
msgid ""
"TID of thread that triggered core dump, as seen in the initial PID namespace "
"(since Linux 3.18)."
msgstr "コアダンプのきっかけとなったスレッドの TID; そのスレッドの初期 PID 名前空間での TID (Linux 3.18 以降)。"

#. type: TP
#: build/C/man5/core.5:210
#, no-wrap
msgid "%p"
msgstr "%p"

#. type: Plain text
#: build/C/man5/core.5:214
msgid ""
"PID of dumped process, as seen in the PID namespace in which the process "
"resides."
msgstr "ダンプされるプロセスの PID; そのプロセスが属している PID 名前空間での PID。"

#. type: TP
#: build/C/man5/core.5:214
#, no-wrap
msgid "%P"
msgstr "%P"

#.  Added in git commit 65aafb1e7484b7434a0c1d4c593191ebe5776a2f
#. type: Plain text
#: build/C/man5/core.5:219
msgid ""
"PID of dumped process, as seen in the initial PID namespace (since Linux "
"3.12)."
msgstr "ダンプされるプロセスの PID; 初期 PID 名前空間での PID (Linux 3.12 以降)。"

#. type: TP
#: build/C/man5/core.5:219
#, no-wrap
msgid "%s"
msgstr "%s"

#. type: Plain text
#: build/C/man5/core.5:222
msgid "Number of signal causing dump."
msgstr "ダンプを引き起こしたシグナルの番号。"

#. type: TP
#: build/C/man5/core.5:222
#, no-wrap
msgid "%t"
msgstr "%t"

#. type: Plain text
#: build/C/man5/core.5:226
msgid ""
"Time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00 "
"+0000 (UTC)."
msgstr ""
"ダンプ時刻、紀元 (Epoch; 1970-01-01 00:00:00 +0000 (UTC))  からの秒数。"

#. type: TP
#: build/C/man5/core.5:226
#, no-wrap
msgid "%u"
msgstr "%u"

#. type: Plain text
#: build/C/man5/core.5:229
msgid "Numeric real UID of dumped process."
msgstr "ダンプされたプロセスの実ユーザー ID (real UID) の数値。"

#. type: Plain text
#: build/C/man5/core.5:250
msgid ""
"A single % at the end of the template is dropped from the core filename, as "
"is the combination of a % followed by any character other than those listed "
"above.  All other characters in the template become a literal part of the "
"core filename.  The template may include \\(aq/\\(aq characters, which are "
"interpreted as delimiters for directory names.  The maximum size of the "
"resulting core filename is 128 bytes (64 bytes in kernels before 2.6.19).  "
"The default value in this file is \"core\".  For backward compatibility, if "
"I</proc/sys/kernel/core_pattern> does not include I<%p> and I</proc/sys/"
"kernel/core_uses_pid> (see below)  is nonzero, then .PID will be appended to "
"the core filename."
msgstr "テンプレートの末尾に 1 個だけ % がある場合、 その % はコアファイル名には含められない。また、上で列挙されて いない % と文字の組み合わせがあった場合も同様である。 テンプレートにおける他の文字は、 コアファイル名としてそのまま使われる。 テンプレートには \\(aq/\\(aq 文字を入れることができ、 ディレクトリ名の区切り文字と解釈される。 結果として生成されるコアファイル名の最大サイズは 128 バイトである (2.6.19 より前のカーネルでは 64 バイト)。 このファイルのデフォルト値は \"core\" である。 以前のものとの互換性のため、 I</proc/sys/kernel/core_pattern> に I<%p> が含まれず、 かつ I</proc/sys/kernel/core_uses_pid> (下記参照) が 0 でない場合は、.PID がコアファイル名に追加される。"

#. type: Plain text
#: build/C/man5/core.5:259
msgid ""
"Paths are interpreted according to the settings that are active for the "
"crashing process.  That means the crashing process's mount namespace (see "
"B<mount_namespaces>(7)), its current working directory (found via "
"B<getcwd>(2)), and its root directory (see B<chroot>(2))."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:270
msgid ""
"Since version 2.4, Linux has also provided a more primitive method of "
"controlling the name of the core dump file.  If the I</proc/sys/kernel/"
"core_uses_pid> file contains the value 0, then a core dump file is simply "
"named I<core>.  If this file contains a nonzero value, then the core dump "
"file includes the process ID in a name of the form I<core.PID>."
msgstr ""
"バージョン 2.4 以降の Linux では コアダンプファイルの名前を制御する原始的な方"
"法も提供されている。 I</proc/sys/kernel/core_uses_pid> ファイルに値 0 が書か"
"れている場合、コアダンプファイルは単純に I<core> という名前になる。このファイ"
"ルに 0 以外の値が書かれている場合、 コアダンプファイルは I<core.PID> という形"
"式の名前になり、ファイル名にプロセス ID が含まれる。"

#.  9520628e8ceb69fa9a4aee6b57f22675d9e1b709
#. type: Plain text
#: build/C/man5/core.5:277
msgid ""
"Since Linux 3.6, if I</proc/sys/fs/suid_dumpable> is set to 2 (\"suidsafe"
"\"), the pattern must be either an absolute pathname (starting with a "
"leading \\(aq/\\(aq character) or a pipe, as defined below."
msgstr ""
"Linux 3.6 以降では、I</proc/sys/fs/suid_dumpable> が 2 (\"suidsafe\") に設定"
"されている場合、テンプレートは、絶対パス名 (先頭に \\(aq/\\(aq 文字があるパス"
"名) かパイプ (以下で説明) のどちらかでなければならない。"

#. type: SS
#: build/C/man5/core.5:277
#, no-wrap
msgid "Piping core dumps to a program"
msgstr "コアダンプのプログラムへのパイプ"

#. type: Plain text
#: build/C/man5/core.5:284
msgid ""
"Since kernel 2.6.19, Linux supports an alternate syntax for the I</proc/sys/"
"kernel/core_pattern> file.  If the first character of this file is a pipe "
"symbol (B<|>), then the remainder of the line is interpreted as the command-"
"line for a user-space program (or script) that is to be executed."
msgstr "カーネル 2.6.19 以降では、Linux は I</proc/sys/kernel/core_pattern> ファイルの別の構文をサポートしている。 このファイルの最初の文字がパイプ記号 (B<|>) であれば、 その行の残りの部分は実行されるユーザー空間プログラムのコマンドラインとして解釈される。"

#.  commit 315c69261dd3fa12dbc830d4fa00d1fad98d3b03
#. type: Plain text
#: build/C/man5/core.5:303
msgid ""
"Since kernel 5.3.0, the pipe template is split on spaces into an argument "
"list I<before> the template parameters are expanded.  In earlier kernels, "
"the template parameters are expanded first and the resulting string is split "
"on spaces into an argument list.  This means that in earlier kernels "
"executable names added by the I<%e> and I<%E> template parameters could get "
"split into multiple arguments.  So the core dump handler needs to put the "
"executable names as the last argument and ensure it joins all parts of the "
"executable name using spaces.  Executable names with multiple spaces in them "
"are not correctly represented in earlier kernels, meaning that the core dump "
"handler needs to use mechanisms to find the executable name."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:307
msgid ""
"Instead of being written to a file, the core dump is given as standard input "
"to the program.  Note the following points:"
msgstr "コアダンプは、ファイルに書き込まれるのではなく、 プログラムの標準入力として渡される。 以下の点に注意すること。"

#. type: Plain text
#: build/C/man5/core.5:311
msgid ""
"The program must be specified using an absolute pathname (or a pathname "
"relative to the root directory, I</>), and must immediately follow the '|' "
"character."
msgstr ""
"プログラムは絶対パス名 (もしくはルートディレクトリ I</> からの 相対パス名) で"
"指定されなければならない。 また、'|' 文字の直後から始めなければならない。"

#. type: Plain text
#: build/C/man5/core.5:317
msgid ""
"The command-line arguments can include any of the % specifiers listed "
"above.  For example, to pass the PID of the process that is being dumped, "
"specify I<%p> in an argument."
msgstr ""
"コマンドライン引数には、上記のリストにある % 指示子を含めることができる。 "
"例えば、ダンプされるプロセスの PID を渡すには、 引数に I<%p> を指定する。"

#. type: Plain text
#: build/C/man5/core.5:320
msgid "The process created to run the program runs as user and group I<root>."
msgstr ""
"プログラムを実行するために生成されるプロセスは、 ユーザー、グループとも "
"I<root> として実行される。"

#. type: Plain text
#: build/C/man5/core.5:327
msgid ""
"Running as I<root> does not confer any exceptional security bypasses.  "
"Namely, LSMs (e.g., SELinux) are still active and may prevent the handler "
"from accessing details about the crashed process via I</proc/[pid]>."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:333
msgid ""
"The program pathname is interpreted with respect to the initial mount "
"namespace as it is always executed there.  It is not affected by the "
"settings (e.g., root directory, mount namespace, current working directory)  "
"of the crashing process."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:342
msgid ""
"The process runs in the initial namespaces (PID, mount, user, and so on)  "
"and not in the namespaces of the crashing process.  One can utilize "
"specifiers such as I<%P> to find the right I</proc/[pid]> directory and "
"probe/enter the crashing process's namespaces if needed."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:350
msgid ""
"The process starts with its current working directory as the root "
"directory.  If desired, it is possible change to the working directory of "
"the dumping process by employing the value provided by the I<%P> specifier "
"to change to the location of the dumping process via I</proc/[pid]/cwd>."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:354
msgid ""
"Command-line arguments can be supplied to the program (since Linux 2.6.24), "
"delimited by white space (up to a total line length of 128 bytes)."
msgstr ""
"コマンドライン引数をプログラムに与えることができ (Linux 2.6.24 以降)、 引"
"数はホワイトスペースで区切る (1行の最大長は 128 バイトが上限である)。"

#. type: Plain text
#: build/C/man5/core.5:360
msgid ""
"The B<RLIMIT_CORE> limit is not enforced for core dumps that are piped to a "
"program via this mechanism."
msgstr ""

#. type: SS
#: build/C/man5/core.5:360
#, no-wrap
msgid "/proc/sys/kernel/core_pipe_limit"
msgstr " /proc/sys/kernel/core_pipe_limit"

#. type: Plain text
#: build/C/man5/core.5:374
msgid ""
"When collecting core dumps via a pipe to a user-space program, it can be "
"useful for the collecting program to gather data about the crashing process "
"from that process's I</proc/[pid]> directory.  In order to do this safely, "
"the kernel must wait for the program collecting the core dump to exit, so as "
"not to remove the crashing process's I</proc/[pid]> files prematurely.  This "
"in turn creates the possibility that a misbehaving collecting program can "
"block the reaping of a crashed process by simply never exiting."
msgstr ""

#.  commit a293980c2e261bd5b0d2a77340dd04f684caff58
#. type: Plain text
#: build/C/man5/core.5:384
msgid ""
"Since Linux 2.6.32, the I</proc/sys/kernel/core_pipe_limit> can be used to "
"defend against this possibility.  The value in this file defines how many "
"concurrent crashing processes may be piped to user-space programs in "
"parallel.  If this value is exceeded, then those crashing processes above "
"this value are noted in the kernel log and their core dumps are skipped."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:392
msgid ""
"A value of 0 in this file is special.  It indicates that unlimited processes "
"may be captured in parallel, but that no waiting will take place (i.e., the "
"collecting program is not guaranteed access to I</proc/E<lt>crashing-"
"PIDE<gt>>).  The default value for this file is 0."
msgstr ""

#. type: SS
#: build/C/man5/core.5:392
#, no-wrap
msgid "Controlling which mappings are written to the core dump"
msgstr "どのマッピングをコアダンプに書き込むかを制御する"

#. type: Plain text
#: build/C/man5/core.5:398
msgid ""
"Since kernel 2.6.23, the Linux-specific I</proc/[pid]/coredump_filter> file "
"can be used to control which memory segments are written to the core dump "
"file in the event that a core dump is performed for the process with the "
"corresponding process ID."
msgstr "カーネル 2.6.23 以降では、Linux 固有のファイル I</proc/[pid]/coredump_filter> を使って、対応するプロセス ID を持つプロセスに対してコアダンプが行われる 際に、どのメモリーセグメントをコアダンプファイルに書き込むかを制御できる。"

#. type: Plain text
#: build/C/man5/core.5:404
msgid ""
"The value in the file is a bit mask of memory mapping types (see "
"B<mmap>(2)).  If a bit is set in the mask, then memory mappings of the "
"corresponding type are dumped; otherwise they are not dumped.  The bits in "
"this file have the following meanings:"
msgstr ""
"このファイルの値はメモリーマッピング種別 (B<mmap>(2)  参照) のビットマスクで"
"ある。 マスク内のあるビットがセットされると、そのビットに対応する種別の メモ"
"リーマッピングがダンプされる。セットされていないものはダンプされない。 この"
"ファイルの各ビットは以下の意味を持つ。"

#. type: TP
#: build/C/man5/core.5:407
#, no-wrap
msgid "bit 0"
msgstr "bit 0"

#. type: Plain text
#: build/C/man5/core.5:410
msgid "Dump anonymous private mappings."
msgstr ""
"無名のプライベートマッピング (anonymous private mappings) をダンプする。"

#. type: TP
#: build/C/man5/core.5:410
#, no-wrap
msgid "bit 1"
msgstr "bit 1"

#. type: Plain text
#: build/C/man5/core.5:413
msgid "Dump anonymous shared mappings."
msgstr "無名の共有マッピング (anonymous shared mappings) をダンプする。"

#. type: TP
#: build/C/man5/core.5:413
#, no-wrap
msgid "bit 2"
msgstr "bit 2"

#. type: Plain text
#: build/C/man5/core.5:416
msgid "Dump file-backed private mappings."
msgstr ""
"ファイルと関連付けられたプライベートマッピング (file-backed private "
"mappings) をダンプする。"

#. type: TP
#: build/C/man5/core.5:416
#, no-wrap
msgid "bit 3"
msgstr "bit 3"

#.  file-backed shared mappings of course also update the underlying
#.  mapped file.
#. type: Plain text
#: build/C/man5/core.5:421
msgid "Dump file-backed shared mappings."
msgstr ""
"ファイルと関連付けられた共有マッピング (file-backed shared mappings) をダンプ"
"する。"

#. type: TP
#: build/C/man5/core.5:421
#, no-wrap
msgid "bit 4 (since Linux 2.6.24)"
msgstr "bit 4 (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man5/core.5:424
msgid "Dump ELF headers."
msgstr "ELF ヘッダーをダンプする。"

#. type: TP
#: build/C/man5/core.5:424
#, no-wrap
msgid "bit 5 (since Linux 2.6.28)"
msgstr "bit 5 (Linux 2.6.28 以降)"

#. type: Plain text
#: build/C/man5/core.5:427
msgid "Dump private huge pages."
msgstr "プライベートなヒュージページ (private huge page) をダンプする。"

#. type: TP
#: build/C/man5/core.5:427
#, no-wrap
msgid "bit 6 (since Linux 2.6.28)"
msgstr "bit 6 (Linux 2.6.28 以降)"

#. type: Plain text
#: build/C/man5/core.5:430
msgid "Dump shared huge pages."
msgstr "共有されたヒュージページ (shared huge page) をダンプする。"

#. type: TP
#: build/C/man5/core.5:430
#, no-wrap
msgid "bit 7 (since Linux 4.4)"
msgstr "bit 7 (Linux 4.4 以降)"

#.  commit ab27a8d04b32b6ee8c30c14c4afd1058e8addc82
#. type: Plain text
#: build/C/man5/core.5:434
msgid "Dump private DAX pages."
msgstr "プライベートな DAX ページをダンプする。"

#. type: TP
#: build/C/man5/core.5:434
#, no-wrap
msgid "bit 8 (since Linux 4.4)"
msgstr "bit 8 (Linux 4.4 以降)"

#.  commit ab27a8d04b32b6ee8c30c14c4afd1058e8addc82
#. type: Plain text
#: build/C/man5/core.5:438
msgid "Dump shared DAX pages."
msgstr "共有された DAX ページをダンプする。"

#. type: Plain text
#: build/C/man5/core.5:447
msgid ""
"By default, the following bits are set: 0, 1, 4 (if the "
"B<CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS> kernel configuration option is "
"enabled), and 5.  This default can be modified at boot time using the "
"I<coredump_filter> boot option."
msgstr "デフォルトでは、ビット 0, 1, 4, 5 がセットされる。 (ビット 4 がセットされるのは、カーネルが設定オプション B<CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS> を有効にして作成された場合である)。このデフォルト値は I<coredump_filter> ブートオプションを使うことで起動時に変更できる。"

#. type: Plain text
#: build/C/man5/core.5:450
msgid ""
"The value of this file is displayed in hexadecimal.  (The default value is "
"thus displayed as 33.)"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:457
msgid ""
"Memory-mapped I/O pages such as frame buffer are never dumped, and virtual "
"DSO (B<vdso>(7))  pages are always dumped, regardless of the "
"I<coredump_filter> value."
msgstr "I<coredump_filter> の値に関わらず、フレームバッファーなどの memory-mapped I/O に関する ページは決してダンプされず、仮想 DSO ページ (B<vdso>(7)) は常にダンプされる。"

#. type: Plain text
#: build/C/man5/core.5:467
msgid ""
"A child process created via B<fork>(2)  inherits its parent's "
"I<coredump_filter> value; the I<coredump_filter> value is preserved across "
"an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成される子プロセスは親プロセスの I<coredump_filter> の値を継"
"承する。 B<execve>(2)  の前後で I<coredump_filter> の値は保持される。"

#. type: Plain text
#: build/C/man5/core.5:471
msgid ""
"It can be useful to set I<coredump_filter> in the parent shell before "
"running a program, for example:"
msgstr ""
"例のように、プログラムを実行する前に親シェルの I<coredump_filter> を設定して"
"おくと役立つことがある。"

#. type: Plain text
#: build/C/man5/core.5:476
#, no-wrap
msgid ""
"$B< echo 0x7 E<gt> /proc/self/coredump_filter>\n"
"$B< ./some_program>\n"
msgstr ""
"$B< echo 0x7 E<gt> /proc/self/coredump_filter>\n"
"$B< ./some_program>\n"

#. type: Plain text
#: build/C/man5/core.5:483
msgid ""
"This file is provided only if the kernel was built with the "
"B<CONFIG_ELF_CORE> configuration option."
msgstr ""
"このファイルが提供されるのは、カーネルが設定オプション B<CONFIG_ELF_CORE> を"
"有効にして作成された場合だけである。"

#. type: SS
#: build/C/man5/core.5:483
#, no-wrap
msgid "Core dumps and systemd"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:497
msgid ""
"On systems using the B<systemd>(1)  I<init> framework, core dumps may be "
"placed in a location determined by B<systemd>(1).  To do this, "
"B<systemd>(1)  employs the I<core_pattern> feature that allows piping core "
"dumps to a program.  One can verify this by checking whether core dumps are "
"being piped to the B<systemd-coredump>(8)  program:"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:502
#, no-wrap
msgid ""
"$ B<cat /proc/sys/kernel/core_pattern>\n"
"|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %e\n"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:515
msgid ""
"In this case, core dumps will be placed in the location configured for "
"B<systemd-coredump>(8), typically as B<lz4>(1)  compressed files in the "
"directory I</var/lib/systemd/coredump/>.  One can list the core dumps that "
"have been recorded by B<systemd-coredump>(8)  using B<coredumpctl>(1):"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:523
#, no-wrap
msgid ""
"$ B<coredumpctl list | tail -5>\n"
"Wed 2017-10-11 22:25:30 CEST  2748 1000 1000 3 present  /usr/bin/sleep\n"
"Thu 2017-10-12 06:29:10 CEST  2716 1000 1000 3 present  /usr/bin/sleep\n"
"Thu 2017-10-12 06:30:50 CEST  2767 1000 1000 3 present  /usr/bin/sleep\n"
"Thu 2017-10-12 06:37:40 CEST  2918 1000 1000 3 present  /usr/bin/cat\n"
"Thu 2017-10-12 08:13:07 CEST  2955 1000 1000 3 present  /usr/bin/cat\n"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:537
msgid ""
"The information shown for each core dump includes the date and time of the "
"dump, the PID, UID, and GID of the dumping process, the signal number that "
"caused the core dump, and the pathname of the executable that was being run "
"by the dumped process.  Various options to B<coredumpctl>(1)  allow a "
"specified coredump file to be pulled from the B<systemd>(1)  location into a "
"specified file.  For example, to extract the core dump for PID 2955 shown "
"above to a file named I<core> in the current directory, one could use:"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:541
#, no-wrap
msgid "$ B<coredumpctl dump 2955 -o core>\n"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:547
msgid "For more extensive details, see the B<coredumpctl>(1)  manual page."
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:554
msgid ""
"To (persistently) disable the B<systemd>(1)  mechanism that archives core "
"dumps, restoring to something more like traditional Linux behavior, one can "
"set an override for the B<systemd>(1)  mechanism, using something like:"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:560
#, no-wrap
msgid ""
"# B<echo \"kernel.core_pattern=core.%p\" E<gt> \\e>\n"
"               B</etc/sysctl.d/50-coredump.conf>\n"
"# B</lib/systemd/systemd-sysctl>\n"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:568
msgid ""
"It is also possible to temporarily (i.e., until the next reboot) change the "
"I<core_pattern> setting using a command such as the following (which causes "
"the names of core dump files to include the executable name as well as the "
"number of the signal which triggered the core dump):"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:572
#, no-wrap
msgid "# B<sysctl -w kernel.core_pattern=\"%e-%s.core\">\n"
msgstr ""

#. type: Plain text
#: build/C/man5/core.5:580
msgid ""
"The B<gdb>(1)  I<gcore> command can be used to obtain a core dump of a "
"running process."
msgstr ""
"B<gdb>(1)  の I<gcore> コマンドを使用すると、実行中のプロセスのコアダンプを取"
"得できる。"

#.  Changed with commit 6409324b385f3f63a03645b4422e3be67348d922
#.  Always including the PID in the name of the core file made
#.  sense for LinuxThreads, where each thread had a unique PID,
#.  but doesn't seem to serve any purpose with NPTL, where all the
#.  threads in a process share the same PID (as POSIX.1 requires).
#.  Probably the behavior is maintained so that applications using
#.  LinuxThreads continue appending the PID (the kernel has no easy
#.  way of telling which threading implementation the user-space
#.  application is using). -- mtk, April 2006
#. type: Plain text
#: build/C/man5/core.5:605
msgid ""
"In Linux versions up to and including 2.6.27, if a multithreaded process "
"(or, more precisely, a process that shares its memory with another process "
"by being created with the B<CLONE_VM> flag of B<clone>(2))  dumps core, then "
"the process ID is always appended to the core filename, unless the process "
"ID was already included elsewhere in the filename via a I<%p> specification "
"in I</proc/sys/kernel/core_pattern>.  (This is primarily useful when "
"employing the obsolete LinuxThreads implementation, where each thread of a "
"process has a different PID.)"
msgstr "バージョン 2.6.27 以前の Linux では、 マルチスレッドプロセス (より正確には、 B<clone>(2)  の B<CLONE_VM> で生成された別プロセスとメモリーを共有しているプロセス)  がコアダンプを生成する場合、 コアファイル名にプロセス ID が必ず付加される。 ただし、 I</proc/sys/kernel/core_pattern> の I<%p> 指定によりコアファイル名のどこか他の場所にプロセス ID が すでに含まれている場合は、プロセス ID が末尾に付加されない。 (この機能が主に役に立つのはすでに使われなくなった LinuxThreads 実装を利用している場合である。 LinuxThreads 実装では、プロセス内の個々のスレッドは異なるプロセス ID を持つ。)"

#. type: SH
#: build/C/man5/core.5:605 build/C/man3/gnu_get_libc_version.3:64
#: build/C/man3/stdarg.3:272 build/C/man4/vcs.4:103
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man5/core.5:613
msgid ""
"The program below can be used to demonstrate the use of the pipe syntax in "
"the I</proc/sys/kernel/core_pattern> file.  The following shell session "
"demonstrates the use of this program (compiled to create an executable named "
"I<core_pattern_pipe_test>):"
msgstr ""
"以下のプログラムは I</proc/sys/kernel/core_pattern> ファイルのパイプ構文の使"
"用例を示している。 以下のシェルのセッションはこのプログラムの使用例を示すもの"
"である (コンパイルして I<core_pattern_pipe_test> という名前の実行ファイルを作"
"成している)。"

#. type: Plain text
#: build/C/man5/core.5:634
#, no-wrap
msgid ""
"$B< cc -o core_pattern_pipe_test core_pattern_pipe_test.c>\n"
"$B< su>\n"
"Password:\n"
"#B< echo \"|$PWD/core_pattern_pipe_test %p UID=%u GID=%g sig=%s\" E<gt> \\e>\n"
"B</proc/sys/kernel/core_pattern>\n"
"#B< exit>\n"
"$B< sleep 100>\n"
"B<\\(ha\\e>                     # type control-backslash\n"
"Quit (core dumped)\n"
"$B< cat core.info>\n"
"argc=5\n"
"argc[0]=E<lt>/home/mtk/core_pattern_pipe_testE<gt>\n"
"argc[1]=E<lt>20575E<gt>\n"
"argc[2]=E<lt>UID=1000E<gt>\n"
"argc[3]=E<lt>GID=100E<gt>\n"
"argc[4]=E<lt>sig=3E<gt>\n"
"Total bytes in core dump: 282624\n"
msgstr ""
" $B< cc -o core_pattern_pipe_test core_pattern_pipe_test.c>\n"
"$B< su>\n"
"Password:\n"
"#B< echo \"|$PWD/core_pattern_pipe_test %p UID=%u GID=%g sig=%s\" E<gt> \\e>\n"
"B</proc/sys/kernel/core_pattern>\n"
"#B< exit>\n"
"$B< sleep 100>\n"
"B<\\(ha\\e>                     # type control-backslash\n"
"Quit (core dumped)\n"
"$B< cat core.info>\n"
"argc=5\n"
"argc[0]=E<lt>/home/mtk/core_pattern_pipe_testE<gt>\n"
"argc[1]=E<lt>20575E<gt>\n"
"argc[2]=E<lt>UID=1000E<gt>\n"
"argc[3]=E<lt>GID=100E<gt>\n"
"argc[4]=E<lt>sig=3E<gt>\n"
"Total bytes in core dump: 282624\n"

#. type: SS
#: build/C/man5/core.5:636 build/C/man3/gnu_get_libc_version.3:74
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man5/core.5:640
#, no-wrap
msgid "/* core_pattern_pipe_test.c */\n"
msgstr "/* core_pattern_pipe_test.c */\n"

#. type: Plain text
#: build/C/man5/core.5:648
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man5/core.5:650
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: build/C/man5/core.5:658
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t nread, tot;\n"
"    char buf[BUF_SIZE];\n"
"    FILE *fp;\n"
"    char cwd[PATH_MAX];\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t nread, tot;\n"
"    char buf[BUF_SIZE];\n"
"    FILE *fp;\n"
"    char cwd[PATH_MAX];\n"

#. type: Plain text
#: build/C/man5/core.5:661
#, no-wrap
msgid ""
"    /* Change our current working directory to that of the\n"
"       crashing process */\n"
msgstr ""
"    /* Change our current working directory to that of the\n"
"       crashing process */\n"

#. type: Plain text
#: build/C/man5/core.5:664
#, no-wrap
msgid ""
"    snprintf(cwd, PATH_MAX, \"/proc/%s/cwd\", argv[1]);\n"
"    chdir(cwd);\n"
msgstr ""
"    snprintf(cwd, PATH_MAX, \"/proc/%s/cwd\", argv[1]);\n"
"    chdir(cwd);\n"

#. type: Plain text
#: build/C/man5/core.5:666
#, no-wrap
msgid "    /* Write output to file \"core.info\" in that directory */\n"
msgstr "    /* Write output to file \"core.info\" in that directory */\n"

#. type: Plain text
#: build/C/man5/core.5:670
#, no-wrap
msgid ""
"    fp = fopen(\"core.info\", \"w+\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    fp = fopen(\"core.info\", \"w+\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man5/core.5:673
#, no-wrap
msgid ""
"    /* Display command-line arguments given to core_pattern\n"
"       pipe program */\n"
msgstr ""
"    /* Display command-line arguments given to core_pattern\n"
"       pipe program */\n"

#. type: Plain text
#: build/C/man5/core.5:677
#, no-wrap
msgid ""
"    fprintf(fp, \"argc=%d\\en\", argc);\n"
"    for (int j = 0; j E<lt> argc; j++)\n"
"        fprintf(fp, \"argc[%d]=E<lt>%sE<gt>\\en\", j, argv[j]);\n"
msgstr ""
"     fprintf(fp, \"argc=%d\\en\", argc);\n"
"    for (int j = 0; j E<lt> argc; j++)\n"
"        fprintf(fp, \"argc[%d]=E<lt>%sE<gt>\\en\", j, argv[j]);\n"

#. type: Plain text
#: build/C/man5/core.5:679
#, no-wrap
msgid "    /* Count bytes in standard input (the core dump) */\n"
msgstr "    /* Count bytes in standard input (the core dump) */\n"

#. type: Plain text
#: build/C/man5/core.5:684
#, no-wrap
msgid ""
"    tot = 0;\n"
"    while ((nread = read(STDIN_FILENO, buf, BUF_SIZE)) E<gt> 0)\n"
"        tot += nread;\n"
"    fprintf(fp, \"Total bytes in core dump: %zd\\en\", tot);\n"
msgstr ""
"     tot = 0;\n"
"    while ((nread = read(STDIN_FILENO, buf, BUF_SIZE)) E<gt> 0)\n"
"        tot += nread;\n"
"    fprintf(fp, \"Total bytes in core dump: %zd\\en\", tot);\n"

#. type: Plain text
#: build/C/man5/core.5:688
#, no-wrap
msgid ""
"    fclose(fp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    fclose(fp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man5/core.5:702
msgid ""
"B<bash>(1), B<coredumpctl>(1), B<gdb>(1), B<getrlimit>(2), B<mmap>(2), "
"B<prctl>(2), B<sigaction>(2), B<elf>(5), B<proc>(5), B<pthreads>(7), "
"B<signal>(7), B<systemd-coredump>(8)"
msgstr " B<bash>(1), B<coredumpctl>(1), B<gdb>(1), B<getrlimit>(2), B<mmap>(2), B<prctl>(2), B<sigaction>(2), B<elf>(5), B<proc>(5), B<pthreads>(7), B<signal>(7), B<systemd-coredump>(8)"

#. type: TH
#: build/C/man4/cpuid.4:26
#, no-wrap
msgid "CPUID"
msgstr "CPUID"

#. type: TH
#: build/C/man4/cpuid.4:26
#, no-wrap
msgid "2019-08-02"
msgstr " 2019-08-02"

#. type: Plain text
#: build/C/man4/cpuid.4:29
msgid "cpuid - x86 CPUID access device"
msgstr "cpuid - x86 CPUID アクセスデバイス"

#. type: Plain text
#: build/C/man4/cpuid.4:31
msgid "CPUID provides an interface for querying information about the x86 CPU."
msgstr ""
"CPUID は x86 CPU に関する情報を問い合わせるためのインターフェースを提供する。"

#. type: Plain text
#: build/C/man4/cpuid.4:38
msgid ""
"This device is accessed by B<lseek>(2)  or B<pread>(2)  to the appropriate "
"CPUID level and reading in chunks of 16 bytes.  A larger read size means "
"multiple reads of consecutive levels."
msgstr ""
"このデバイスには B<lseek>(2) と B<pread>(2) を使って、 適切な CPUID レベルに"
"アクセスし、 16 バイトのデータを読み出す。 もっと大きな読み出しサイズを指定す"
"ると、 連続する複数のレベルが読み出される。"

#. type: Plain text
#: build/C/man4/cpuid.4:47
msgid ""
"The lower 32 bits of the file position is used as the incoming I<%eax>, and "
"the upper 32 bits of the file position as the incoming I<%ecx>, the latter "
"is intended for \"counting\" I<eax> levels like I<eax=4>."
msgstr ""
"ファイル位置の下位 32 ビットは次の I<%eax> として使用され、 ファイル位置の上"
"位 32 ビットは次の I<%ecx> として使用される。 後者は、 I<eax=4> のように "
"I<eax> レベルを数えるのを意図したものである。"

#. type: Plain text
#: build/C/man4/cpuid.4:57
msgid ""
"This driver uses I</dev/cpu/CPUNUM/cpuid>, where I<CPUNUM> is the minor "
"number, and on an SMP box will direct the access to CPU I<CPUNUM> as listed "
"in I</proc/cpuinfo>."
msgstr ""
"このドライバーは I</dev/cpu/CPUNUM/cpuid> を使用する。 なお I<CPUNUM> はマイ"
"ナー番号である。 SMP マシンでは、 このドライバーは I</proc/cpuinfo> に載って"
"いる CPU I<CPUNUM> にアクセスする。"

#. type: Plain text
#: build/C/man4/cpuid.4:62
msgid ""
"This file is protected so that it can be read only by the user I<root>, or "
"members of the group I<root>."
msgstr ""
"このファイルは、 ユーザー I<root> またはグループ I<root> だけが読み出しできる"
"ように保護されている。"

#. type: Plain text
#: build/C/man4/cpuid.4:67
msgid ""
"The CPUID instruction can be directly executed by a program using inline "
"assembler.  However this device allows convenient access to all CPUs without "
"changing process affinity."
msgstr ""
"CPUID 命令はインラインアセンブラーを使ってプログラムで直接実行できる。 しか"
"し、 このデバイスを使うことで、 プロセスの affinity を変更せずにすべての CPU "
"に便利にアクセスできる。"

#. type: Plain text
#: build/C/man4/cpuid.4:76
msgid ""
"Most of the information in I<cpuid> is reported by the kernel in cooked form "
"either in I</proc/cpuinfo> or through subdirectories in I</sys/devices/"
"system/cpu>.  Direct CPUID access through this device should only be used in "
"exceptional cases."
msgstr ""
"I<cpuid> の情報のほとんどは、 I</proc/cpuinfo> か、 I</sys/devices/system/"
"cpu> のサブディレクトリ経由で読みやすい形で参照できる。 このデバイス経由で直"
"接 CPUID にアクセスするのは例外的な場合にだけにすべきである。"

#. type: Plain text
#: build/C/man4/cpuid.4:82
msgid ""
"The I<cpuid> driver is not auto-loaded.  On modular kernels you might need "
"to use the following command to load it explicitly before use:"
msgstr ""
"I<cpuid> ドライバーは自動ではロードされない。 モジュールに対応したカーネルで"
"は、 使用する前に以下のコマンドを使って明示的にロードする必要がある。"

#. type: Plain text
#: build/C/man4/cpuid.4:86
#, no-wrap
msgid "$ modprobe cpuid\n"
msgstr " $ modprobe cpuid\n"

#. type: Plain text
#: build/C/man4/cpuid.4:91
msgid ""
"There is no support for CPUID functions that require additional input "
"registers."
msgstr "追加の入力レジスターが必要な CPUID 機能はサポートされていない。"

#. type: Plain text
#: build/C/man4/cpuid.4:93
msgid "Very old x86 CPUs don't support CPUID."
msgstr "非常に古い x86 CPU では CPUID はサポートされていない。"

#. type: Plain text
#: build/C/man4/cpuid.4:95
msgid "B<cpuid>(1)"
msgstr " B<cpuid>(1)"

#. type: Plain text
#: build/C/man4/cpuid.4:99
msgid ""
"Intel Corporation, Intel 64 and IA-32 Architectures Software Developer's "
"Manual Volume 2A: Instruction Set Reference, A-M, 3-180 CPUID reference."
msgstr ""
"Intel Corporation, Intel 64 and IA-32 Architectures Software Developer's "
"Manual Volume 2A: Instruction Set Reference, A-M, 3-180 CPUID reference."

#. type: Plain text
#: build/C/man4/cpuid.4:102
msgid ""
"Intel Corporation, Intel Processor Identification and the CPUID Instruction, "
"Application note 485."
msgstr ""
"Intel Corporation, Intel Processor Identification and the CPUID Instruction, "
"Application note 485."

#. type: TH
#: build/C/man4/dsp56k.4:26
#, no-wrap
msgid "DSP56K"
msgstr "DSP56K"

#. type: Plain text
#: build/C/man4/dsp56k.4:29
msgid "dsp56k - DSP56001 interface device"
msgstr "dsp56k - DSP56001 のインターフェースデバイス"

#. type: Plain text
#: build/C/man4/dsp56k.4:32
#, no-wrap
msgid "B<#include E<lt>asm/dsp56k.hE<gt>>\n"
msgstr " B<#include E<lt>asm/dsp56k.hE<gt>>\n"

#. type: Plain text
#: build/C/man4/dsp56k.4:35
#, no-wrap
msgid ""
"B<ssize_t read(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
"B<ssize_t write(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<ssize_t read(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
"B<ssize_t write(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: build/C/man4/dsp56k.4:41
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, DSP56K_UPLOAD, struct dsp56k_upload *>I<program>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_TX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_RX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_FLAGS, struct dsp56k_host_flags *>I<flags>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_CMD, int >I<cmd>B<);>\n"
msgstr ""
"B<int ioctl(int >I<fd>B<, DSP56K_UPLOAD, struct dsp56k_upload *>I<program>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_TX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_RX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_FLAGS, struct dsp56k_host_flags *>I<flags>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_CMD, int >I<cmd>B<);>\n"

#. type: SH
#: build/C/man4/dsp56k.4:42 build/C/man4/fd.4:30 build/C/man4/full.4:29
#: build/C/man4/initrd.4:38 build/C/man4/lp.4:31 build/C/man4/mouse.4:28
#: build/C/man4/sd.4:34
#, no-wrap
msgid "CONFIGURATION"
msgstr "設定"

#. type: Plain text
#: build/C/man4/dsp56k.4:47
msgid ""
"The B<dsp56k> device is a character device with major number 55 and minor "
"number 0."
msgstr "B<dsp56k> デバイスは、メジャー番号 55、マイナー番号 0 の キャラクターデバイスである。"

#. type: Plain text
#: build/C/man4/dsp56k.4:53
msgid ""
"The Motorola DSP56001 is a fully programmable 24-bit digital signal "
"processor found in Atari Falcon030-compatible computers.  The I<dsp56k> "
"special file is used to control the DSP56001, and to send and receive data "
"using the bidirectional handshaked host port."
msgstr ""
"Motorola DSP56001 は、Atari Falcon030 互換のコンピュータで使われている フルプ"
"ログラマブルな 24 ビットのデジタルシグナルプロセッサーである。 スペシャルファ"
"イル I<dsp56k> は、DSP56001 の制御と 双方向ハンドシェイクホストポートでのデー"
"タの送受信のために使われる。"

#. type: Plain text
#: build/C/man4/dsp56k.4:63
msgid ""
"To send a data stream to the signal processor, use B<write>(2)  to the "
"device, and B<read>(2)  to receive processed data.  The data can be sent or "
"received in 8, 16, 24, or 32-bit quantities on the host side, but will "
"always be seen as 24-bit quantities in the DSP56001."
msgstr ""
"データストリームをシグナルプロセッサーに送信するためには、 デバイスに対して "
"B<write>(2)  を使うこと。 処理されたデータを受信するためには、 B<read>(2)  を"
"使うこと。 ホスト側では、データは 8, 16, 24, 32 ビット単位で送受信できるが、 "
"DSP56001 内では、24 ビット単位で扱われる。"

#. type: Plain text
#: build/C/man4/dsp56k.4:68
msgid ""
"The following B<ioctl>(2)  calls are used to control the I<dsp56k> device:"
msgstr ""
"次の B<ioctl>(2)  コールが I<dsp56k> デバイスを制御するために使われる。"

#. type: IP
#: build/C/man4/dsp56k.4:68
#, no-wrap
msgid "B<DSP56K_UPLOAD>"
msgstr "B<DSP56K_UPLOAD>"

#. type: Plain text
#: build/C/man4/dsp56k.4:75
msgid ""
"resets the DSP56001 and uploads a program.  The third B<ioctl>(2)  argument "
"must be a pointer to a I<struct dsp56k_upload> with members I<bin> pointing "
"to a DSP56001 binary program, and I<len> set to the length of the program, "
"counted in 24-bit words."
msgstr "DSP56001 をリセットし、プログラムをアップロードする。 B<ioctl>(2)  の 3 番目の引数は、 構造体 I<struct dsp56k_upload> へのポインターでなければならない。 構造体のメンバー I<bin> は DSP56001 バイナリプログラムを指し、 構造体のメンバー I<len> は 24 ビットワードで数えた プログラムの長さに設定されていなければならない。"

#. type: IP
#: build/C/man4/dsp56k.4:75
#, no-wrap
msgid "B<DSP56K_SET_TX_WSIZE>"
msgstr "B<DSP56K_SET_TX_WSIZE>"

#. type: Plain text
#: build/C/man4/dsp56k.4:83
#, fuzzy
#| msgid ""
#| "sets the transmit word size.  Allowed values are in the range 1 to 4, and "
#| "is the number of bytes that will be sent at a time to the DSP56001.  "
#| "These data quantities will either be padded with zero bytes, or truncated "
#| "to fit the native 24-bit data format of the DSP56001."
msgid ""
"sets the transmit word size.  Allowed values are in the range 1 to 4, and is "
"the number of bytes that will be sent at a time to the DSP56001.  These data "
"quantities will either be padded with bytes containing zero, or truncated to "
"fit the native 24-bit data format of the DSP56001."
msgstr ""
"送信ワードサイズを設定する。 設定できる値は 1 〜 4 の範囲で、このバイト数分だ"
"け 1 度に DSP56001 に送信する。 このデータ単位は、DSP56001 本来の 24 ビット"
"データ形式に合わせるため、 ゼロのバイトで埋められたり、切り詰められたりする。"

#. type: IP
#: build/C/man4/dsp56k.4:83
#, no-wrap
msgid "B<DSP56K_SET_RX_WSIZE>"
msgstr "B<DSP56K_SET_RX_WSIZE>"

#. type: Plain text
#: build/C/man4/dsp56k.4:90
msgid ""
"sets the receive word size.  Allowed values are in the range 1 to 4, and is "
"the number of bytes that will be received at a time from the DSP56001.  "
"These data quantities will either truncated, or padded with a null byte "
"(\\(aq\\e0\\(aq) to fit the native 24-bit data format of the DSP56001."
msgstr ""
"受信ワードサイズを設定する。 設定できる値は 1 〜 4 の範囲で、 このバイト数分"
"だけ 1 度に DSP56001 から受信する。 このデータ単位は、DSP56001 本来の 24 ビッ"
"トデータ形式に合わせるため、 切り詰められたり、ヌルバイト (\\(aq\\e0\\(aq) で"
"埋められたりする。"

#. type: IP
#: build/C/man4/dsp56k.4:90
#, no-wrap
msgid "B<DSP56K_HOST_FLAGS>"
msgstr "B<DSP56K_HOST_FLAGS>"

#. type: Plain text
#: build/C/man4/dsp56k.4:97
msgid ""
"read and write the host flags.  The host flags are four general-purpose bits "
"that can be read by both the hosting computer and the DSP56001.  Bits 0 and "
"1 can be written by the host, and bits 2 and 3 can be written by the "
"DSP56001."
msgstr ""
"ホストフラグを読み書きする。 ホストフラグは、一般的な目的で使うことのできる"
"ビットで、 ホストコンピュータと DSP56001 の両方から読むことができる。 ビット "
"0 と 1 は、ホストによって書き込むことができ、 ビット 2 と 3 は、DSP56001 に"
"よって書き込むことができる。"

#. type: Plain text
#: build/C/man4/dsp56k.4:107
msgid ""
"To access the host flags, the third B<ioctl>(2)  argument must be a pointer "
"to a I<struct dsp56k_host_flags>.  If bit 0 or 1 is set in the I<dir> "
"member, the corresponding bit in I<out> will be written to the host flags.  "
"The state of all host flags will be returned in the lower four bits of the "
"I<status> member."
msgstr ""
"ホストフラグにアクセスするためには、 B<ioctl>(2)  の 3 番目の引数が 構造体 "
"I<struct dsp56k_host_flags> へのポインターでなければならない。 この構造体のメ"
"ンバー I<dir> のビット 0 または 1 が設定されると、 メンバー I<out> の対応する"
"ビットの値がホストフラグに書き込まれる。 すべてのホストフラグの状態は、構造体"
"のメンバー I<status> の 下から 4 ビットとして返される。"

#. type: IP
#: build/C/man4/dsp56k.4:107
#, no-wrap
msgid "B<DSP56K_HOST_CMD>"
msgstr "B<DSP56K_HOST_CMD>"

#. type: Plain text
#: build/C/man4/dsp56k.4:111
msgid ""
"sends a host command.  Allowed values are in the range 0 to 31, and is a "
"user-defined command handled by the program running in the DSP56001."
msgstr ""
"ホストコマンドを送信する。 送信できる値は 0 〜 31 の範囲で、DSP56001 で動作し"
"ているプログラムによって 処理されるユーザー定義コマンドである。"

#.  .SH AUTHORS
#.  Fredrik Noring <noring@nocrew.org>, lars brinkhoff <lars@nocrew.org>,
#.  Tomas Berndtsson <tomas@nocrew.org>.
#. type: Plain text
#: build/C/man4/dsp56k.4:116
msgid "I</dev/dsp56k>"
msgstr " I</dev/dsp56k>"

#. type: Plain text
#: build/C/man4/dsp56k.4:122
msgid ""
"I<linux/include/asm-m68k/dsp56k.h>, I<linux/drivers/char/dsp56k.c>, E<.UR "
"http://dsp56k.nocrew.org/> E<.UE ,> DSP56000/DSP56001 Digital Signal "
"Processor User's Manual"
msgstr ""
"I<linux/include/asm-m68k/dsp56k.h>, I<linux/drivers/char/dsp56k.c>, E<.UR "
"http://dsp56k.nocrew.org/> E<.UE ,> DSP56000/DSP56001 Digital Signal "
"Processor User's Manual"

#. type: TH
#: build/C/man4/fd.4:27
#, no-wrap
msgid "FD"
msgstr "FD"

#. type: Plain text
#: build/C/man4/fd.4:30
msgid "fd - floppy disk device"
msgstr "fd - フロッピーディスク(floppy disk)デバイス"

#. type: Plain text
#: build/C/man4/fd.4:47
msgid ""
"Floppy drives are block devices with major number 2.  Typically they are "
"owned by root:floppy (i.e., user root, group floppy) and have either mode "
"0660 (access checking via group membership) or mode 0666 (everybody has "
"access).  The minor numbers encode the device type, drive number, and "
"controller number.  For each device type (that is, combination of density "
"and track count)  there is a base minor number.  To this base number, add "
"the drive's number on its controller and 128 if the drive is on the "
"secondary controller.  In the following device tables, I<n> represents the "
"drive number."
msgstr "フロッピードライブはメジャーナンバー 2 を持つブロックデバイスである。 一般的には、このデバイスのオーナーは root:floppy (オーナー root、グループ floppy) で、 モード 0660 (グループの構成員であることによってアクセスチェックが行われる)、 または、モード 0666 (誰でもアクセスできる) である。 マイナーナンバーはデバイスのタイプ、ドライブの番号、 コントローラーの番号を符号化したものである。それぞれのデバイスタイプ (これは、密度 (density) とトラックカウント (track count) の組合せである)  は、ベースとなるマイナーナンバーを持っている。このベースナンバーにその コントローラー上のドライブナンバーを加える。もし、そのドライブが 2 番目の コントローラーに接続されているなら、さらに 128 を加える。次のデバイス テーブルでは、 I<n> はドライブ番号を表す。 [訳注] 以下のテーブルに用いられる用語は表の整形の関係から原文のままとなっている。 Name (名前)、Capac. (容量)、Cyl. (シリンダ数)、Sect. (セクター数)、 Heads. (ヘッダー数)、Base minor # (ベースマイナーナンバー)。"

#. type: Plain text
#: build/C/man4/fd.4:54
msgid ""
"B<Warning: if you use formats with more tracks than supported by your drive, "
"you may cause it mechanical damage.> Trying once if more tracks than the "
"usual 40/80 are supported should not damage it, but no warranty is given for "
"that.  If you are not sure, don't create device entries for those formats, "
"so as to prevent their usage."
msgstr ""
"B<警告: ドライブがサポートしているよりも多くのトラックを持つように フォーマッ"
"トした場合、ドライブに機械的なダメージを与えることになる かもしれない。> 通常"
"の 40/80 よりも多くのトラックがサポートされているかどうかを 一度試すだけでは"
"ドライブにダメージを与えることはないはずだが、 ダメージを与えないという保証は"
"ない。 確信がない場合は、そのような使い方が行われないように、 そうしたフォー"
"マットのドライブエントリーを作成しないこと。"

#. type: Plain text
#: build/C/man4/fd.4:57
msgid ""
"Drive-independent device files which automatically detect the media format "
"and capacity:"
msgstr ""
"メディアのフォーマットと容量を自動的に検出する ドライブ非依存のデバイスファイ"
"ル:"

#. type: tbl table
#: build/C/man4/fd.4:60 build/C/man4/fd.4:70 build/C/man4/fd.4:80
#: build/C/man4/fd.4:99 build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Name"
msgstr "名前"

#. type: tbl table
#: build/C/man4/fd.4:60 build/C/man4/fd.4:70 build/C/man4/fd.4:80
#: build/C/man4/fd.4:99 build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Base"
msgstr "ベース"

#. type: tbl table
#: build/C/man4/fd.4:61 build/C/man4/fd.4:71 build/C/man4/fd.4:81
#: build/C/man4/fd.4:100 build/C/man4/fd.4:114 build/C/man4/fd.4:135
#, no-wrap
msgid "minor #"
msgstr "マイナー番号"

#. type: tbl table
#: build/C/man4/fd.4:62 build/C/man4/fd.4:72 build/C/man4/fd.4:82
#: build/C/man4/fd.4:101 build/C/man4/fd.4:115 build/C/man4/fd.4:136
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: build/C/man4/fd.4:63
#, no-wrap
msgid "B<fd>I<n>"
msgstr "B<fd>I<n>"

#. type: Plain text
#: build/C/man4/fd.4:67
msgid "5.25 inch double-density device files:"
msgstr "5.25 インチ倍密度 (double-density) デバイスファイル:"

#. type: tbl table
#: build/C/man4/fd.4:70 build/C/man4/fd.4:80 build/C/man4/fd.4:99
#: build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Capacity"
msgstr "容量"

#. type: tbl table
#: build/C/man4/fd.4:70 build/C/man4/fd.4:80 build/C/man4/fd.4:99
#: build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Cyl."
msgstr "シリンダー"

#. type: tbl table
#: build/C/man4/fd.4:70 build/C/man4/fd.4:80 build/C/man4/fd.4:99
#: build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Sect."
msgstr "セクター"

#. type: tbl table
#: build/C/man4/fd.4:70 build/C/man4/fd.4:80 build/C/man4/fd.4:99
#: build/C/man4/fd.4:113 build/C/man4/fd.4:134
#, no-wrap
msgid "Heads"
msgstr "ヘッド"

#. type: tbl table
#: build/C/man4/fd.4:71 build/C/man4/fd.4:81 build/C/man4/fd.4:100
#: build/C/man4/fd.4:114 build/C/man4/fd.4:135
#, no-wrap
msgid "KiB"
msgstr "KiB"

#. type: tbl table
#: build/C/man4/fd.4:73
#, no-wrap
msgid "B<fd>I<n>B<d360>"
msgstr "B<fd>I<n>B<d360>"

#. type: tbl table
#: build/C/man4/fd.4:73 build/C/man4/fd.4:83 build/C/man4/fd.4:102
#: build/C/man4/fd.4:116
#, no-wrap
msgid "360"
msgstr " 360"

#. type: tbl table
#: build/C/man4/fd.4:73 build/C/man4/fd.4:83 build/C/man4/fd.4:86
#: build/C/man4/fd.4:102 build/C/man4/fd.4:103 build/C/man4/fd.4:116
#: build/C/man4/fd.4:117
#, no-wrap
msgid "9"
msgstr "9"

#. type: Plain text
#: build/C/man4/fd.4:77
msgid "5.25 inch high-density device files:"
msgstr "5.25 インチ高密度 (high-density) デバイスファイル:"

#. type: tbl table
#: build/C/man4/fd.4:83
#, no-wrap
msgid "B<fd>I<n>B<h360>"
msgstr "B<fd>I<n>B<h360>"

#. type: tbl table
#: build/C/man4/fd.4:83 build/C/man4/fd.4:92 build/C/man4/fd.4:121
#, no-wrap
msgid "20"
msgstr "20"

#. type: tbl table
#: build/C/man4/fd.4:84
#, no-wrap
msgid "B<fd>I<n>B<h410>"
msgstr "B<fd>I<n>B<h410>"

#. type: tbl table
#: build/C/man4/fd.4:84
#, no-wrap
msgid "410"
msgstr " 410"

#. type: tbl table
#: build/C/man4/fd.4:85
#, no-wrap
msgid "B<fd>I<n>B<h420>"
msgstr "B<fd>I<n>B<h420>"

#. type: tbl table
#: build/C/man4/fd.4:85
#, no-wrap
msgid "420"
msgstr " 420"

#. type: tbl table
#: build/C/man4/fd.4:85
#, no-wrap
msgid "64"
msgstr "64"

#. type: tbl table
#: build/C/man4/fd.4:86
#, no-wrap
msgid "B<fd>I<n>B<h720>"
msgstr "B<fd>I<n>B<h720>"

#. type: tbl table
#: build/C/man4/fd.4:86 build/C/man4/fd.4:103 build/C/man4/fd.4:117
#, no-wrap
msgid "720"
msgstr " 720"

#. type: tbl table
#: build/C/man4/fd.4:86 build/C/man4/fd.4:87 build/C/man4/fd.4:88
#: build/C/man4/fd.4:89 build/C/man4/fd.4:92 build/C/man4/fd.4:102
#: build/C/man4/fd.4:103 build/C/man4/fd.4:104 build/C/man4/fd.4:105
#: build/C/man4/fd.4:106 build/C/man4/fd.4:117 build/C/man4/fd.4:120
#: build/C/man4/fd.4:121 build/C/man4/fd.4:122 build/C/man4/fd.4:125
#: build/C/man4/fd.4:126 build/C/man4/fd.4:127 build/C/man4/fd.4:137
#: build/C/man4/fd.4:138 build/C/man4/fd.4:139 build/C/man4/fd.4:140
#: build/C/man4/fd.4:141
#, no-wrap
msgid "80"
msgstr "80"

#. type: tbl table
#: build/C/man4/fd.4:87
#, no-wrap
msgid "B<fd>I<n>B<h880>"
msgstr "B<fd>I<n>B<h880>"

#. type: tbl table
#: build/C/man4/fd.4:87
#, no-wrap
msgid "880"
msgstr " 880"

#. type: tbl table
#: build/C/man4/fd.4:88
#, no-wrap
msgid "B<fd>I<n>B<h1200>"
msgstr "B<fd>I<n>B<h1200>"

#. type: tbl table
#: build/C/man4/fd.4:88 build/C/man4/mouse.4:74
#, no-wrap
msgid "1200"
msgstr "1200"

#. type: tbl table
#: build/C/man4/fd.4:88
#, no-wrap
msgid "15"
msgstr "15"

#. type: tbl table
#: build/C/man4/fd.4:88
#, no-wrap
msgid "8"
msgstr "8"

#. type: tbl table
#: build/C/man4/fd.4:89
#, no-wrap
msgid "B<fd>I<n>B<h1440>"
msgstr "B<fd>I<n>B<h1440>"

#. type: tbl table
#: build/C/man4/fd.4:89 build/C/man4/fd.4:120
#, no-wrap
msgid "1440"
msgstr " 1440"

#. type: tbl table
#: build/C/man4/fd.4:89 build/C/man4/fd.4:90 build/C/man4/fd.4:91
#: build/C/man4/fd.4:120
#, no-wrap
msgid "18"
msgstr "18"

#. type: tbl table
#: build/C/man4/fd.4:90
#, no-wrap
msgid "B<fd>I<n>B<h1476>"
msgstr "B<fd>I<n>B<h1476>"

#. type: tbl table
#: build/C/man4/fd.4:90
#, no-wrap
msgid "1476"
msgstr " 1476"

#. type: tbl table
#: build/C/man4/fd.4:90 build/C/man4/fd.4:118 build/C/man4/fd.4:123
#, no-wrap
msgid "82"
msgstr "82"

#. type: tbl table
#: build/C/man4/fd.4:90
#, no-wrap
msgid "56"
msgstr "56"

#. type: tbl table
#: build/C/man4/fd.4:91
#, no-wrap
msgid "B<fd>I<n>B<h1494>"
msgstr "B<fd>I<n>B<h1494>"

#. type: tbl table
#: build/C/man4/fd.4:91
#, no-wrap
msgid "1494"
msgstr " 1494"

#. type: tbl table
#: build/C/man4/fd.4:91 build/C/man4/fd.4:119 build/C/man4/fd.4:124
#, no-wrap
msgid "83"
msgstr "83"

#. type: tbl table
#: build/C/man4/fd.4:91
#, no-wrap
msgid "72"
msgstr "72"

#. type: tbl table
#: build/C/man4/fd.4:92
#, no-wrap
msgid "B<fd>I<n>B<h1600>"
msgstr "B<fd>I<n>B<h1600>"

#. type: tbl table
#: build/C/man4/fd.4:92 build/C/man4/fd.4:121
#, no-wrap
msgid "1600"
msgstr " 1600"

#. type: tbl table
#: build/C/man4/fd.4:92
#, no-wrap
msgid "92"
msgstr "92"

#. type: Plain text
#: build/C/man4/fd.4:96
msgid "3.5 inch double-density device files:"
msgstr "3.5 インチ倍密度 (double-density) デバイスファイル:"

#. type: tbl table
#: build/C/man4/fd.4:102 build/C/man4/fd.4:116
#, no-wrap
msgid "B<fd>I<n>B<u360>"
msgstr "B<fd>I<n>B<u360>"

#. type: tbl table
#: build/C/man4/fd.4:103 build/C/man4/fd.4:117
#, no-wrap
msgid "B<fd>I<n>B<u720>"
msgstr "B<fd>I<n>B<u720>"

#. type: tbl table
#: build/C/man4/fd.4:103 build/C/man4/fd.4:117
#, no-wrap
msgid "16"
msgstr "16"

#. type: tbl table
#: build/C/man4/fd.4:104
#, no-wrap
msgid "B<fd>I<n>B<u800>"
msgstr "B<fd>I<n>B<u800>"

#. type: tbl table
#: build/C/man4/fd.4:104
#, no-wrap
msgid "800"
msgstr " 800"

#. type: tbl table
#: build/C/man4/fd.4:104
#, no-wrap
msgid "120"
msgstr "120"

#. type: tbl table
#: build/C/man4/fd.4:105
#, no-wrap
msgid "B<fd>I<n>B<u1040>"
msgstr "B<fd>I<n>B<u1040>"

#. type: tbl table
#: build/C/man4/fd.4:105
#, no-wrap
msgid "1040"
msgstr " 1040"

#. type: tbl table
#: build/C/man4/fd.4:105
#, no-wrap
msgid "13"
msgstr "13"

#. type: tbl table
#: build/C/man4/fd.4:105
#, no-wrap
msgid "84"
msgstr "84"

#. type: tbl table
#: build/C/man4/fd.4:106
#, no-wrap
msgid "B<fd>I<n>B<u1120>"
msgstr "B<fd>I<n>B<u1120>"

#. type: tbl table
#: build/C/man4/fd.4:106
#, no-wrap
msgid "1120"
msgstr " 1120"

#. type: tbl table
#: build/C/man4/fd.4:106
#, no-wrap
msgid "14"
msgstr "14"

#. type: tbl table
#: build/C/man4/fd.4:106
#, no-wrap
msgid "88"
msgstr "88"

#. type: Plain text
#: build/C/man4/fd.4:110
msgid "3.5 inch high-density device files:"
msgstr "3.5 インチ高密度 (high-density) デバイスファイル:"

#. type: tbl table
#: build/C/man4/fd.4:118
#, no-wrap
msgid "B<fd>I<n>B<u820>"
msgstr "B<fd>I<n>B<u820>"

#. type: tbl table
#: build/C/man4/fd.4:118
#, no-wrap
msgid "820"
msgstr " 820"

#. type: tbl table
#: build/C/man4/fd.4:118
#, no-wrap
msgid "52"
msgstr "52"

#. type: tbl table
#: build/C/man4/fd.4:119
#, no-wrap
msgid "B<fd>I<n>B<u830>"
msgstr "B<fd>I<n>B<u830>"

#. type: tbl table
#: build/C/man4/fd.4:119
#, no-wrap
msgid "830"
msgstr " 830"

#. type: tbl table
#: build/C/man4/fd.4:119
#, no-wrap
msgid "68"
msgstr "68"

#. type: tbl table
#: build/C/man4/fd.4:120
#, no-wrap
msgid "B<fd>I<n>B<u1440>"
msgstr "B<fd>I<n>B<u1440>"

#. type: tbl table
#: build/C/man4/fd.4:120
#, no-wrap
msgid "28"
msgstr "28"

#. type: tbl table
#: build/C/man4/fd.4:121
#, no-wrap
msgid "B<fd>I<n>B<u1600>"
msgstr "B<fd>I<n>B<u1600>"

#. type: tbl table
#: build/C/man4/fd.4:121
#, no-wrap
msgid "124"
msgstr "124"

#. type: tbl table
#: build/C/man4/fd.4:122
#, no-wrap
msgid "B<fd>I<n>B<u1680>"
msgstr "B<fd>I<n>B<u1680>"

#. type: tbl table
#: build/C/man4/fd.4:122
#, no-wrap
msgid "1680"
msgstr " 1680"

#. type: tbl table
#: build/C/man4/fd.4:123
#, no-wrap
msgid "B<fd>I<n>B<u1722>"
msgstr "B<fd>I<n>B<u1722>"

#. type: tbl table
#: build/C/man4/fd.4:123
#, no-wrap
msgid "1722"
msgstr " 1722"

#. type: tbl table
#: build/C/man4/fd.4:123
#, no-wrap
msgid "60"
msgstr "60"

#. type: tbl table
#: build/C/man4/fd.4:124
#, no-wrap
msgid "B<fd>I<n>B<u1743>"
msgstr "B<fd>I<n>B<u1743>"

#. type: tbl table
#: build/C/man4/fd.4:124
#, no-wrap
msgid "1743"
msgstr " 1743"

#. type: tbl table
#: build/C/man4/fd.4:124
#, no-wrap
msgid "76"
msgstr "76"

#. type: tbl table
#: build/C/man4/fd.4:125
#, no-wrap
msgid "B<fd>I<n>B<u1760>"
msgstr "B<fd>I<n>B<u1760>"

#. type: tbl table
#: build/C/man4/fd.4:125
#, no-wrap
msgid "1760"
msgstr " 1760"

#. type: tbl table
#: build/C/man4/fd.4:125
#, no-wrap
msgid "96"
msgstr "96"

#. type: tbl table
#: build/C/man4/fd.4:126
#, no-wrap
msgid "B<fd>I<n>B<u1840>"
msgstr "B<fd>I<n>B<u1840>"

#. type: tbl table
#: build/C/man4/fd.4:126
#, no-wrap
msgid "1840"
msgstr " 1840"

#. type: tbl table
#: build/C/man4/fd.4:126
#, no-wrap
msgid "23"
msgstr "23"

#. type: tbl table
#: build/C/man4/fd.4:126
#, no-wrap
msgid "116"
msgstr "116"

#. type: tbl table
#: build/C/man4/fd.4:127
#, no-wrap
msgid "B<fd>I<n>B<u1920>"
msgstr "B<fd>I<n>B<u1920>"

#. type: tbl table
#: build/C/man4/fd.4:127
#, no-wrap
msgid "1920"
msgstr " 1920"

#. type: tbl table
#: build/C/man4/fd.4:127 build/C/man4/sk98lin.4:406 build/C/man4/sk98lin.4:407
#, no-wrap
msgid "100"
msgstr "100"

#. type: Plain text
#: build/C/man4/fd.4:131
msgid "3.5 inch extra-density device files:"
msgstr "3.5 インチ拡張密度 (extra-density) デバイスファイル:"

#. type: tbl table
#: build/C/man4/fd.4:137
#, no-wrap
msgid "B<fd>I<n>B<u2880>"
msgstr "B<fd>I<n>B<u2880>"

#. type: tbl table
#: build/C/man4/fd.4:137 build/C/man4/fd.4:138
#, no-wrap
msgid "2880"
msgstr " 2880"

#. type: tbl table
#: build/C/man4/fd.4:138
#, no-wrap
msgid "B<fd>I<n>B<CompaQ>"
msgstr "B<fd>I<n>B<CompaQ>"

#. type: tbl table
#: build/C/man4/fd.4:139
#, no-wrap
msgid "B<fd>I<n>B<u3200>"
msgstr "B<fd>I<n>B<u3200>"

#. type: tbl table
#: build/C/man4/fd.4:139
#, no-wrap
msgid "3200"
msgstr " 3200"

#. type: tbl table
#: build/C/man4/fd.4:139
#, no-wrap
msgid "104"
msgstr "104"

#. type: tbl table
#: build/C/man4/fd.4:140
#, no-wrap
msgid "B<fd>I<n>B<u3520>"
msgstr "B<fd>I<n>B<u3520>"

#. type: tbl table
#: build/C/man4/fd.4:140
#, no-wrap
msgid "3520"
msgstr " 3520"

#. type: tbl table
#: build/C/man4/fd.4:140
#, no-wrap
msgid "108"
msgstr "108"

#. type: tbl table
#: build/C/man4/fd.4:141
#, no-wrap
msgid "B<fd>I<n>B<u3840>"
msgstr "B<fd>I<n>B<u3840>"

#. type: tbl table
#: build/C/man4/fd.4:141
#, no-wrap
msgid "3840"
msgstr " 3840"

#. type: tbl table
#: build/C/man4/fd.4:141
#, no-wrap
msgid "112"
msgstr "112"

#. type: Plain text
#: build/C/man4/fd.4:148
msgid ""
"B<fd> special files access the floppy disk drives in raw mode.  The "
"following B<ioctl>(2)  calls are supported by B<fd> devices:"
msgstr ""
"B<fd> スペシャルファイルはフロッピーディスクドライブにローモード (raw mode)"
"で アクセスする。B<fd> では、次の B<ioctl>(2)  コールがサポートされている。"

#. type: IP
#: build/C/man4/fd.4:148
#, no-wrap
msgid "B<FDCLRPRM>"
msgstr "B<FDCLRPRM>"

#. type: Plain text
#: build/C/man4/fd.4:150
msgid "clears the media information of a drive (geometry of disk in drive)."
msgstr ""
"ドライブのメディア情報(ドライブ内のディスクのジオメトリ情報)をクリアす る。"

#. type: IP
#: build/C/man4/fd.4:150
#, no-wrap
msgid "B<FDSETPRM>"
msgstr "B<FDSETPRM>"

#. type: Plain text
#: build/C/man4/fd.4:154
msgid ""
"sets the media information of a drive.  The media information will be lost "
"when the media is changed."
msgstr ""
"ドライブのメディア情報をセットする。メディア情報はメディアが交換された 時、失"
"われる。"

#. type: IP
#: build/C/man4/fd.4:154
#, no-wrap
msgid "B<FDDEFPRM>"
msgstr "B<FDDEFPRM>"

#. type: Plain text
#: build/C/man4/fd.4:160
msgid ""
"sets the media information of a drive (geometry of disk in drive).  The "
"media information will not be lost when the media is changed.  This will "
"disable autodetection.  In order to reenable autodetection, you have to "
"issue an B<FDCLRPRM>."
msgstr ""
"ドライブのメディア情報(ドライブ内のディスクのジオメトリ情報)をセットす る。メ"
"ディア情報はメディアが交換された時でも失われない。これは(メディ ア情報の)自動"
"検出を無効にする。自動検出を再び有効にするために、 B<FDCLRPRM> を発行しなけれ"
"ばならない。"

#. type: IP
#: build/C/man4/fd.4:160 build/C/man4/fd.4:172
#, no-wrap
msgid "B<FDGETDRVTYP>"
msgstr "B<FDGETDRVTYP>"

#. type: Plain text
#: build/C/man4/fd.4:165
msgid ""
"returns the type of a drive (name parameter).  For formats which work in "
"several drive types, B<FDGETDRVTYP> returns a name which is appropriate for "
"the oldest drive type which supports this format."
msgstr ""
"ドライブのタイプ(名前引数)を返す。それぞれのドライブタイプに適合するよ うに"
"フォーマットを行うため、B<FDGETDRVTYP> はフォーマットをサポート する最も古い"
"ドライブタイプのために適切な名前を返す。"

#. type: IP
#: build/C/man4/fd.4:165
#, no-wrap
msgid "B<FDFLUSH>"
msgstr "B<FDFLUSH>"

#. type: Plain text
#: build/C/man4/fd.4:167
msgid "invalidates the buffer cache for the given drive."
msgstr "与えられたドライブのバッファーキャッシュを無効にする。"

#. type: IP
#: build/C/man4/fd.4:167 build/C/man4/fd.4:170
#, no-wrap
msgid "B<FDSETMAXERRS>"
msgstr "B<FDSETMAXERRS>"

#. type: Plain text
#: build/C/man4/fd.4:170
msgid ""
"sets the error thresholds for reporting errors, aborting the operation, "
"recalibrating, resetting, and reading sector by sector."
msgstr ""
"エラーの報告、操作の中止、再試行、リセット、セクター毎の読み込みのため のエ"
"ラー閾値をセットする。"

#. type: Plain text
#: build/C/man4/fd.4:172
msgid "gets the current error thresholds."
msgstr "現在のエラー閾値を得る。"

#. type: Plain text
#: build/C/man4/fd.4:174
msgid "gets the internal name of the drive."
msgstr "ドライブの内部名を得る。"

#. type: IP
#: build/C/man4/fd.4:174
#, no-wrap
msgid "B<FDWERRORCLR>"
msgstr "B<FDWERRORCLR>"

#. type: Plain text
#: build/C/man4/fd.4:176
msgid "clears the write error statistics."
msgstr "書き込みエラーの統計をクリアーする。"

#. type: IP
#: build/C/man4/fd.4:176
#, no-wrap
msgid "B<FDWERRORGET>"
msgstr "B<FDWERRORGET>"

#. type: Plain text
#: build/C/man4/fd.4:183
msgid ""
"reads the write error statistics.  These include the total number of write "
"errors, the location and disk of the first write error, and the location and "
"disk of the last write error.  Disks are identified by a generation number "
"which is incremented at (almost) each disk change."
msgstr ""
"書き込みエラーの統計を読む。統計は、書き込みエラーの合計、最初の書き込 みエ"
"ラーはどのディスクのどこで起こったか、そして、最後の書き込みエラー がどのディ"
"スクのどこで起こったかという情報を含んでいる。ディスクはディ スクの交換ごとに"
"増えるジェネレーション番号によって識別される。"

#. type: IP
#: build/C/man4/fd.4:183
#, no-wrap
msgid "B<FDTWADDLE>"
msgstr "B<FDTWADDLE>"

#. type: Plain text
#: build/C/man4/fd.4:187
msgid ""
"Switch the drive motor off for a few microseconds.  This might be needed in "
"order to access a disk whose sectors are too close together."
msgstr ""
"数ミリ秒の間ドライブのモーターのスイッチを切る。これはディスクのセクター 同士"
"が接近しすぎているディスクのアクセスのために必要であろう。"

#. type: IP
#: build/C/man4/fd.4:187
#, no-wrap
msgid "B<FDSETDRVPRM>"
msgstr "B<FDSETDRVPRM>"

#. type: Plain text
#: build/C/man4/fd.4:189
msgid "sets various drive parameters."
msgstr "ドライブの様々なパラメーターをセットする。"

#. type: IP
#: build/C/man4/fd.4:189
#, no-wrap
msgid "B<FDGETDRVPRM>"
msgstr "B<FDGETDRVPRM>"

#. type: Plain text
#: build/C/man4/fd.4:191
msgid "reads these parameters back."
msgstr "(B<FDSETDRVPRM> を使ってセットした)パラメーターを読みだす。"

#. type: IP
#: build/C/man4/fd.4:191
#, no-wrap
msgid "B<FDGETDRVSTAT>"
msgstr "B<FDGETDRVSTAT>"

#. type: Plain text
#: build/C/man4/fd.4:193
msgid "gets the cached drive state (disk changed, write protected et al.)"
msgstr ""
"キャッシュされているドライブの状態(ディスクの交換、ライトプロテクトな ど)を得"
"る。"

#. type: IP
#: build/C/man4/fd.4:193
#, no-wrap
msgid "B<FDPOLLDRVSTAT>"
msgstr "B<FDPOLLDRVSTAT>"

#. type: Plain text
#: build/C/man4/fd.4:195
msgid "polls the drive and return its state."
msgstr "ドライブをポーリングして、その状態を返す。"

#. type: IP
#: build/C/man4/fd.4:195
#, no-wrap
msgid "B<FDGETFDCSTAT>"
msgstr "B<FDGETFDCSTAT>"

#. type: Plain text
#: build/C/man4/fd.4:197
msgid "gets the floppy controller state."
msgstr "フロッピーコントローラーの状態を得る。"

#. type: IP
#: build/C/man4/fd.4:197
#, no-wrap
msgid "B<FDRESET>"
msgstr "B<FDRESET>"

#. type: Plain text
#: build/C/man4/fd.4:199
msgid "resets the floppy controller under certain conditions."
msgstr "フロッピーコントローラーを信頼できる状態にリセットする。"

#. type: IP
#: build/C/man4/fd.4:199
#, no-wrap
msgid "B<FDRAWCMD>"
msgstr "B<FDRAWCMD>"

#. type: Plain text
#: build/C/man4/fd.4:201
msgid "sends a raw command to the floppy controller."
msgstr "フロッピーコントローラーに低レベルのコマンド(raw command)を送る。"

#. type: Plain text
#: build/C/man4/fd.4:206
msgid ""
"For more precise information, consult also the I<E<lt>linux/fd.hE<gt>> and "
"I<E<lt>linux/fdreg.hE<gt>> include files, as well as the "
"B<floppycontrol>(1)  manual page."
msgstr ""
"より正確な情報のためには、マニュアルページ B<floppycontrol>(1)  だけでなく、"
"インクルードファイル I<E<lt>linux/fd.hE<gt>> と I<E<lt>linux/fdarg.hE<gt>> も"
"参照のこと。"

#. type: Plain text
#: build/C/man4/fd.4:208
msgid "I</dev/fd*>"
msgstr " I</dev/fd*>"

#. type: Plain text
#: build/C/man4/fd.4:214
msgid ""
"The various formats permit reading and writing many types of disks.  "
"However, if a floppy is formatted with an inter-sector gap that is too "
"small, performance may drop, to the point of needing a few seconds to access "
"an entire track.  To prevent this, use interleaved formats."
msgstr ""
"様々なディスクのタイプで様々な種類のフォーマットの読み書きが許されている。 し"
"かし、小さすぎるセクター間ギャップでフォーマットされたフロッピーでは、 トラッ"
"ク全体のアクセスに数秒必要になるため、性能が低下することだろう。 これを防ぐた"
"めには、インターリーブドフォーマット (interleaved format) を用いればよい。"

#. type: Plain text
#: build/C/man4/fd.4:218
msgid ""
"It is not possible to read floppies which are formatted using GCR (group "
"code recording), which is used by Apple II and Macintosh computers (800k "
"disks)."
msgstr ""
"Apple II や Macintosh コンピュータで使用されている、 GCR (group code "
"recording) を使ってフォーマットされたフロッピー (800k ディスク) を読むことは"
"できない。"

#.  .SH AUTHORS
#.  Alain Knaff (Alain.Knaff@imag.fr), David Niemi
#.  (niemidc@clark.net), Bill Broadhurst (bbroad@netcom.com).
#. type: Plain text
#: build/C/man4/fd.4:225
msgid ""
"Reading floppies which are hard sectored (one hole per sector, with the "
"index hole being a little skewed) is not supported.  This used to be common "
"with older 8-inch floppies."
msgstr ""
"ハードセクター型のフロッピーの読み込みはサポートされていない (ハードセクター"
"型のフロッピーでは、セクター毎にホール (hole) が一つあり、 少しずれた位置にイ"
"ンデックスホールが存在する)。 これは、昔の 8 インチフロッピーで一般的に使われ"
"ていた方式である。"

#. type: Plain text
#: build/C/man4/fd.4:233
msgid ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"
msgstr ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"

#. type: TH
#: build/C/man7/fifo.7:12
#, no-wrap
msgid "FIFO"
msgstr "FIFO"

#. type: TH
#: build/C/man7/fifo.7:12
#, no-wrap
msgid "2017-11-26"
msgstr " 2017-11-26"

#. type: Plain text
#: build/C/man7/fifo.7:15
msgid "fifo - first-in first-out special file, named pipe"
msgstr "fifo - FIFO 特殊ファイル、名前付きパイプ"

#. type: Plain text
#: build/C/man7/fifo.7:27
msgid ""
"A FIFO special file (a named pipe) is similar to a pipe, except that it is "
"accessed as part of the filesystem.  It can be opened by multiple processes "
"for reading or writing.  When processes are exchanging data via the FIFO, "
"the kernel passes all data internally without writing it to the filesystem.  "
"Thus, the FIFO special file has no contents on the filesystem; the "
"filesystem entry merely serves as a reference point so that processes can "
"access the pipe using a name in the filesystem."
msgstr "FIFO 特殊ファイル (名前付きパイプ) はパイプに似ているが、 FIFO はファイルシステムの一部に関連付けられている点が異なる。複数のプロセスが読み込みや書き込みのために FIFO をオープンすることができる。プロセスが FIFO を通してデータを交換する場合、カーネルは、データを実際にはファイルシステムに書き込まず、すべてのデータを内部的に渡す。このように、 FIFO 特殊ファイルはファイルシステム上には内容を持たない。ファイルシステムのエントリーは、プロセスがファイルシステム上の名前を使用してそのパイプにアクセスできるように参照ポイントを提供しているだけである。"

#. type: Plain text
#: build/C/man7/fifo.7:34
msgid ""
"The kernel maintains exactly one pipe object for each FIFO special file that "
"is opened by at least one process.  The FIFO must be opened on both ends "
"(reading and writing)  before data can be passed.  Normally, opening the "
"FIFO blocks until the other end is opened also."
msgstr "カーネルは、少なくとも一つのプロセスによってオープンされている FIFO 特殊ファイルに関して、 1 つの FIFO 特殊ファイルにつき 1 つのパイプオブジェクトを管理する。データを渡す前に、 FIFO の両端 (書き込み側と読み出し側) がオープンされていなければならない。通常、 FIFO をオープンしようとした場合、その反対側がオープンされるまで停止 (block) される。"

#. type: Plain text
#: build/C/man7/fifo.7:43
msgid ""
"A process can open a FIFO in nonblocking mode.  In this case, opening for "
"read-only succeeds even if no one has opened on the write side yet and "
"opening for write-only fails with B<ENXIO> (no such device or address) "
"unless the other end has already been opened."
msgstr "プロセスは FIFO を非停止 (nonblocking) モードでオープンすることもできる。この場合、読み込み専用でオープンしようとした場合には、書き込み側を誰もオープンしていなくても成功する。書き込み専用でオープンしようとした場合には、反対側がすでにオープンされていない限り、 B<ENXIO> (そのようなデバイスまたはアドレスは存在しない) というエラーで失敗する。"

#. type: Plain text
#: build/C/man7/fifo.7:53
msgid ""
"Under Linux, opening a FIFO for read and write will succeed both in blocking "
"and nonblocking mode.  POSIX leaves this behavior undefined.  This can be "
"used to open a FIFO for writing while there are no readers available.  A "
"process that uses both ends of the connection in order to communicate with "
"itself should be very careful to avoid deadlocks."
msgstr "Linux では、 FIFO を読み書き両用でオープンした場合、 停止、非停止のどちらのモードでも成功する。 POSIX では、この場合の動作は定義されていない。この動作は、読み込み側がいない時に書き込み用に FIFO をオープンするために使用できる。自分自身と通信するために FIFO の両端を使用するプロセスでは、デッドロックを避けるために細心の注意を払う必要がある。"

#. type: Plain text
#: build/C/man7/fifo.7:56
msgid "For details of the semantics of I/O on FIFOs, see B<pipe>(7)."
msgstr "FIFO における入出力の動作の詳細については、 B<pipe>(7) を参照のこと。"

#. type: Plain text
#: build/C/man7/fifo.7:61
msgid ""
"When a process tries to write to a FIFO that is not opened for read on the "
"other side, the process is sent a B<SIGPIPE> signal."
msgstr "プロセスが、反対の読み込み側がオープンされていない FIFO に書き込もうとした場合、そのプロセスに B<SIGPIPE> シグナルが送られる。"

#. type: Plain text
#: build/C/man7/fifo.7:67
msgid ""
"FIFO special files can be created by B<mkfifo>(3), and are indicated by I<ls"
"\\ -l> with the file type \\(aqp\\(aq."
msgstr "FIFO 特殊ファイルは B<mkfifo>(3)  で作成することができ、 I<ls\\ -l> ではファイル種別 \\(aqp\\(aq で表示される。"

#. type: Plain text
#: build/C/man7/fifo.7:76
msgid ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"
msgstr ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"

#. type: TH
#: build/C/man4/full.4:26
#, no-wrap
msgid "FULL"
msgstr "FULL"

#. type: TH
#: build/C/man4/full.4:26 build/C/man4/initrd.4:35 build/C/man4/lirc.4:24
#, no-wrap
msgid "2019-03-06"
msgstr " 2019-03-06"

#. type: Plain text
#: build/C/man4/full.4:29
msgid "full - always full device"
msgstr "full - いつも full であるデバイス"

#. type: Plain text
#: build/C/man4/full.4:34
msgid ""
"If your system does not have I</dev/full> created already, it can be created "
"with the following commands:"
msgstr ""
"システムに作成済みの I</dev/full> がない場合、 次のコマンドにより作成できる。"

#. type: Plain text
#: build/C/man4/full.4:39
#, no-wrap
msgid ""
"mknod -m 666 /dev/full c 1 7\n"
"chown root:root /dev/full\n"
msgstr ""
" mknod -m 666 /dev/full c 1 7\n"
"chown root:root /dev/full\n"

#. type: Plain text
#: build/C/man4/full.4:46
msgid ""
"The file I</dev/full> has major device number 1 and minor device number 7."
msgstr "I</dev/full> は、メジャーデバイス番号 1、 マイナーデバイス番号 7 のファイルである。"

#. type: Plain text
#: build/C/man4/full.4:53
msgid ""
"Writes to the I</dev/full> device fail with an B<ENOSPC> error.  This can be "
"used to test how a program handles disk-full errors."
msgstr ""
"I</dev/full> デバイスへの書き込みは、 B<ENOSPC> エラーで失敗する。 この動作を"
"使って、プログラムがディスクフルのエラーをどのように 処理するかをテストでき"
"る。"

#. type: Plain text
#: build/C/man4/full.4:57
msgid "Reads from the I</dev/full> device will return \\e0 characters."
msgstr ""
"I</dev/full> デバイスからの読み出しでは、\\e0 文字(ヌル文字)が返される。"

#. type: Plain text
#: build/C/man4/full.4:61
msgid "Seeks on I</dev/full> will always succeed."
msgstr "I</dev/full> のシーク (seek) は常に成功する。"

#. type: Plain text
#: build/C/man4/full.4:63
msgid "I</dev/full>"
msgstr " I</dev/full>"

#. type: Plain text
#: build/C/man4/full.4:67
msgid "B<mknod>(1), B<null>(4), B<zero>(4)"
msgstr "B<mknod>(1), B<null>(4), B<zero>(4)"

#. type: TH
#: build/C/man3/gnu_get_libc_version.3:26
#, no-wrap
msgid "GNU_GET_LIBC_VERSION"
msgstr "GNU_GET_LIBC_VERSION"

#. type: TH
#: build/C/man3/gnu_get_libc_version.3:26 build/C/man3/setlogmask.3:25
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:29
msgid ""
"gnu_get_libc_version, gnu_get_libc_release - get glibc version and release"
msgstr ""
"gnu_get_libc_version, gnu_get_libc_release - glibc のバージョンと リリース状"
"態を取得する"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:32
#, no-wrap
msgid "B<#include E<lt>gnu/libc-version.hE<gt>>\n"
msgstr "B<#include E<lt>gnu/libc-version.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:35
#, no-wrap
msgid ""
"B<const char *gnu_get_libc_version(void);>\n"
"B<const char *gnu_get_libc_release(void);>\n"
msgstr ""
"B<const char *gnu_get_libc_version(void);>\n"
"B<const char *gnu_get_libc_release(void);>\n"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:40
msgid ""
"The function B<gnu_get_libc_version>()  returns a string that identifies the "
"glibc version available on the system."
msgstr ""
"B<gnu_get_libc_version>()  関数は、システムで利用可能な glibc のバージョンを"
"特定する文字列を返す。"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:47
msgid ""
"The function B<gnu_get_libc_release>()  returns a string indicates the "
"release status of the glibc version available on the system.  This will be a "
"string such as I<stable>."
msgstr ""
"B<gnu_get_libc_release>()  関数は、システムで利用可能な glibc バージョンのリ"
"リース状態を示す 文字列を返す。 I<stable> といった文字列が返される。"

#. type: SH
#: build/C/man3/gnu_get_libc_version.3:47 build/C/man3/mkfifo.3:178
#: build/C/man2/mknod.2:244 build/C/man4/vcs.4:101 build/C/man4/smartpqi.4:309
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:49
msgid "These functions first appeared in glibc in version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 で初めて登場した。"

#. type: SH
#: build/C/man3/gnu_get_libc_version.3:49 build/C/man3/makedev.3:61
#: build/C/man3/mkfifo.3:184 build/C/man3/setlogmask.3:75
#: build/C/man3/stdarg.3:229 build/C/man3/syslog.3:275
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:52 build/C/man3/makedev.3:64
#: build/C/man3/mkfifo.3:187 build/C/man3/setlogmask.3:78
#: build/C/man3/stdarg.3:232 build/C/man3/syslog.3:278
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:56 build/C/man3/makedev.3:68
#: build/C/man3/mkfifo.3:191 build/C/man3/setlogmask.3:82
#: build/C/man3/stdarg.3:236 build/C/man3/syslog.3:282
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:56 build/C/man3/makedev.3:68
#: build/C/man3/mkfifo.3:191 build/C/man3/setlogmask.3:82
#: build/C/man3/stdarg.3:236 build/C/man3/syslog.3:282
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:56 build/C/man3/makedev.3:68
#: build/C/man3/mkfifo.3:191 build/C/man3/setlogmask.3:82
#: build/C/man3/stdarg.3:236 build/C/man3/syslog.3:282
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:60
#, no-wrap
msgid ""
"B<gnu_get_libc_version>(),\n"
"B<gnu_get_libc_release>()"
msgstr ""
"B<gnu_get_libc_version>(),\n"
"B<gnu_get_libc_release>()"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:60 build/C/man3/makedev.3:73
#: build/C/man3/mkfifo.3:195 build/C/man3/setlogmask.3:85
#: build/C/man3/stdarg.3:241 build/C/man3/stdarg.3:244
#: build/C/man3/syslog.3:286 build/C/man3/syslog.3:290
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/gnu_get_libc_version.3:60 build/C/man3/makedev.3:73
#: build/C/man3/mkfifo.3:195 build/C/man3/stdarg.3:241
#: build/C/man3/syslog.3:286
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/gnu_get_libc_version.3:62 build/C/man3/makedev.3:75
#: build/C/man3/mkfifo.3:197 build/C/man2/mknod.2:248
#: build/C/man3/setlogmask.3:88 build/C/man3/stdarg.3:246
#: build/C/man2/syslog.2:374 build/C/man3/syslog.3:292 build/C/man7/uri.7:584
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:64
msgid "These functions are glibc-specific."
msgstr "これらの関数は glibc 固有である。"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:66
msgid "When run, the program below will produce output such as the following:"
msgstr "下記のプログラムを実行すると、次のような出力が得られる。"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:72
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"GNU libc version: 2.8\n"
"GNU libc release: stable\n"
msgstr ""
"$B< ./a.out>\n"
"GNU libc version: 2.8\n"
"GNU libc release: stable\n"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:80
#, no-wrap
msgid ""
"#include E<lt>gnu/libc-version.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>gnu/libc-version.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:88
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n"
"    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n"
"    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/gnu_get_libc_version.3:91
msgid "B<confstr>(3)"
msgstr "B<confstr>(3)"

#. type: TH
#: build/C/man4/hd.4:29
#, no-wrap
msgid "HD"
msgstr "HD"

#. type: Plain text
#: build/C/man4/hd.4:32
msgid "hd - MFM/IDE hard disk devices"
msgstr "hd - MFM/IDE ハードディスクデバイス"

#. type: Plain text
#: build/C/man4/hd.4:47
msgid ""
"The B<hd*> devices are block devices to access MFM/IDE hard disk drives in "
"raw mode.  The master drive on the primary IDE controller (major device "
"number 3) is B<hda>; the slave drive is B<hdb>.  The master drive of the "
"second controller (major device number 22)  is B<hdc> and the slave is "
"B<hdd>."
msgstr ""
"B<hd*> デバイスは MFM/IDE ハードディスクドライブにローモード (raw mode)  でア"
"クセスするためのブロックデバイス (block device) である。プライマリ (primary) "
"IDE コントローラー (メジャーナンバー 3) の マスタードライブ (mater drive) は "
"B<hda>、スレーブドライブ (slave drive) は B<hdb> である。また、セカンドコント"
"ローラー (メジャーナンバー 22) のマスター ドライブは B<hdc> スレーブは "
"B<hdd> である。"

#. type: Plain text
#: build/C/man4/hd.4:71
msgid ""
"General IDE block device names have the form B<hd>I<X>, or B<hd>I<XP>, where "
"I<X> is a letter denoting the physical drive, and I<P> is a number denoting "
"the partition on that physical drive.  The first form, B<hd>I<X>, is used to "
"address the whole drive.  Partition numbers are assigned in the order the "
"partitions are discovered, and only nonempty, nonextended partitions get a "
"number.  However, partition numbers 1\\(en4 are given to the four partitions "
"described in the MBR (the \"primary\" partitions), regardless of whether "
"they are unused or extended.  Thus, the first logical partition will be "
"B<hd>I<X>B<5>\\&.  Both DOS-type partitioning and BSD-disklabel partitioning "
"are supported.  You can have at most 63 partitions on an IDE disk."
msgstr ""
"一般的な IDE ブロックデバイスの名前は B<hd>I<X>または、 B<hd>I<XP>という形態"
"をとる。この、 I<X> の部分は物理的なドライブを表す文字で、 I<P> の部分はその"
"物理的なドライブ上のパーティション (partition) を表す数字で ある。この最初の"
"形式 B<hd>I<X> はドライブ全体を示すのに使われる。 パーティションナンバーは発"
"見されたパーティションに順に割り付けられる。 パーティションナンバーが割り付け"
"られるのは、空でなく (nonempty) かつ 拡張パーティションでない (nonextended) "
"パーティションのみである。 このうち、パーティションナンバー 1 から 4 はそれが"
"使われていなくても、 また拡張パーティションだとしても MBR に記述される四つの"
"パーティション (いわゆる、プラマリ'パーティション) に与えられる。 従って、最"
"初の論理パーティション (logical pertition) は、 B<hd>I<X>B<5>となるだろう。 "
"(IDE ハードディスクでは) DOS タイプのパーティショニング (partitioning)  と "
"BSD ディスクラベル (BSD-disklabel) によるパーティショニングの両方が サポート"
"されている。また、IDE ディスク上に最高 63 のパーティションを 作成する事ができ"
"る。"

#. type: Plain text
#: build/C/man4/hd.4:77
msgid ""
"For example, I</dev/hda> refers to all of the first IDE drive in the system; "
"and I</dev/hdb3> refers to the third DOS \"primary\" partition on the second "
"one."
msgstr ""
"例えば、 I</dev/hda> はシステムの最初の IDE ドライブ全体を参照する。そして、 "
"I</dev/hdb3> はセカンドドライブの三つめの DOS `プライマリ'パーティションを参"
"照する。"

#. type: Plain text
#: build/C/man4/hd.4:79 build/C/man4/ttyS.4:34
msgid "They are typically created by:"
msgstr "これらは典型的には次のようにして作られる。"

#. type: Plain text
#: build/C/man4/hd.4:93
#, no-wrap
msgid ""
"mknod -m 660 /dev/hda b 3 0\n"
"mknod -m 660 /dev/hda1 b 3 1\n"
"mknod -m 660 /dev/hda2 b 3 2\n"
"\\&...\n"
"mknod -m 660 /dev/hda8 b 3 8\n"
"mknod -m 660 /dev/hdb b 3 64\n"
"mknod -m 660 /dev/hdb1 b 3 65\n"
"mknod -m 660 /dev/hdb2 b 3 66\n"
"\\&...\n"
"mknod -m 660 /dev/hdb8 b 3 72\n"
"chown root:disk /dev/hd*\n"
msgstr ""
" mknod -m 660 /dev/hda b 3 0\n"
"mknod -m 660 /dev/hda1 b 3 1\n"
"mknod -m 660 /dev/hda2 b 3 2\n"
"\\&...\n"
"mknod -m 660 /dev/hda8 b 3 8\n"
"mknod -m 660 /dev/hdb b 3 64\n"
"mknod -m 660 /dev/hdb1 b 3 65\n"
"mknod -m 660 /dev/hdb2 b 3 66\n"
"\\&...\n"
"mknod -m 660 /dev/hdb8 b 3 72\n"
"chown root:disk /dev/hd*\n"

#. type: Plain text
#: build/C/man4/hd.4:97
msgid "I</dev/hd*>"
msgstr " I</dev/hd*>"

#. type: Plain text
#: build/C/man4/hd.4:102
msgid "B<chown>(1), B<mknod>(1), B<sd>(4), B<mount>(8)"
msgstr "B<chown>(1), B<mknod>(1), B<sd>(4)  B<mount>(8),"

#. type: TH
#: build/C/man4/hpsa.4:10
#, no-wrap
msgid "HPSA"
msgstr "HPSA"

#. type: Plain text
#: build/C/man4/hpsa.4:13
msgid "hpsa - HP Smart Array SCSI driver"
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:16
#, no-wrap
msgid "modprobe hpsa [ hpsa_allow_any=1 ]\n"
msgstr "modprobe hpsa [ hpsa_allow_any=1 ]\n"

#. type: Plain text
#: build/C/man4/hpsa.4:20
msgid "B<hpsa> is a SCSI driver for HP Smart Array RAID controllers."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:39
msgid ""
"I<hpsa_allow_any=1>: This option allows the driver to attempt to operate on "
"any HP Smart Array hardware RAID controller, even if it is not explicitly "
"known to the driver.  This allows newer hardware to work with older "
"drivers.  Typically this is used to allow installation of operating systems "
"from media that predates the RAID controller, though it may also be used to "
"enable B<hpsa> to drive older controllers that would normally be handled by "
"the B<cciss>(4)  driver.  These older boards have not been tested and are "
"not supported with B<hpsa>, and B<cciss>(4)  should still be used for these."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:43
msgid "The B<hpsa> driver supports the following Smart Array boards:"
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:54
#, no-wrap
msgid ""
"    Smart Array P700M\n"
"    Smart Array P212\n"
"    Smart Array P410\n"
"    Smart Array P410i\n"
"    Smart Array P411\n"
"    Smart Array P812\n"
"    Smart Array P712m\n"
"    Smart Array P711m\n"
"    StorageWorks P1210m\n"
msgstr ""
"    Smart Array P700M\n"
"    Smart Array P212\n"
"    Smart Array P410\n"
"    Smart Array P410i\n"
"    Smart Array P411\n"
"    Smart Array P812\n"
"    Smart Array P712m\n"
"    Smart Array P711m\n"
"    StorageWorks P1210m\n"

#.  commit 135ae6edeb51979d0998daf1357f149a7d6ebb08
#. type: Plain text
#: build/C/man4/hpsa.4:58
msgid "Since Linux 4.14, the following Smart Array boards are also supported:"
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:80
#, no-wrap
msgid ""
"    Smart Array 5300\n"
"    Smart Array 5312\n"
"    Smart Array 532\n"
"    Smart Array 5i\n"
"    Smart Array 6400\n"
"    Smart Array 6400 EM\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"
"    Smart Array P400\n"
"    Smart Array P400i\n"
"    Smart Array P600\n"
"    Smart Array P700m\n"
"    Smart Array P800\n"
msgstr ""
"     Smart Array 5300\n"
"    Smart Array 5312\n"
"    Smart Array 532\n"
"    Smart Array 5i\n"
"    Smart Array 6400\n"
"    Smart Array 6400 EM\n"
"    Smart Array 641\n"
"    Smart Array 642\n"
"    Smart Array 6i\n"
"    Smart Array E200\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E200i\n"
"    Smart Array E500\n"
"    Smart Array P400\n"
"    Smart Array P400i\n"
"    Smart Array P600\n"
"    Smart Array P700m\n"
"    Smart Array P800\n"

#. type: Plain text
#: build/C/man4/hpsa.4:104
msgid ""
"Logical drives are accessed via the SCSI disk driver (B<sd>(4)), tape drives "
"via the SCSI tape driver (B<st>(4)), and the RAID controller via the SCSI "
"generic driver (B<sg>(4)), with device nodes named I</dev/sd*>, I</dev/st*>, "
"and I</dev/sg*>, respectively."
msgstr ""

#. type: SS
#: build/C/man4/hpsa.4:104
#, no-wrap
msgid "HPSA-specific host attribute files in /sys"
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:105
#, no-wrap
msgid "I</sys/class/scsi_host/host*/rescan>"
msgstr "I</sys/class/scsi_host/host*/rescan>"

#. type: Plain text
#: build/C/man4/hpsa.4:119
msgid ""
"This is a write-only attribute.  Writing to this attribute will cause the "
"driver to scan for new, changed, or removed devices (e.g., hot-plugged tape "
"drives, or newly configured or deleted logical drives, etc.)  and notify the "
"SCSI midlayer of any changes detected.  Normally a rescan is triggered "
"automatically by HP's Array Configuration Utility (either the GUI or the "
"command-line variety); thus, for logical drive changes, the user should not "
"normally have to use this attribute.  This attribute may be useful when hot "
"plugging devices like tape drives, or entire storage boxes containing "
"preconfigured logical drives."
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:119
#, no-wrap
msgid "I</sys/class/scsi_host/host*/firmware_revision>"
msgstr "I</sys/class/scsi_host/host*/firmware_revision>"

#. type: Plain text
#: build/C/man4/hpsa.4:122
msgid "This attribute contains the firmware version of the Smart Array."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:124 build/C/man4/hpsa.4:139 build/C/man4/hpsa.4:152
#: build/C/man4/hpsa.4:168 build/C/man4/smartpqi.4:143
#: build/C/man4/smartpqi.4:173 build/C/man4/smartpqi.4:189
#: build/C/man4/smartpqi.4:205 build/C/man4/smartpqi.4:221
#: build/C/man4/smartpqi.4:237 build/C/man4/smartpqi.4:263
#: build/C/man4/smartpqi.4:279 build/C/man4/smartpqi.4:301
msgid "For example:"
msgstr "例:"

#. type: Plain text
#: build/C/man4/hpsa.4:130
#, no-wrap
msgid ""
"# B<cd /sys/class/scsi_host/host4>\n"
"# B<cat firmware_revision>\n"
"7.14\n"
msgstr ""
" # B<cd /sys/class/scsi_host/host4>\n"
"# B<cat firmware_revision>\n"
"7.14\n"

#. type: SS
#: build/C/man4/hpsa.4:133
#, no-wrap
msgid "HPSA-specific disk attribute files in /sys"
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:134
#, no-wrap
msgid "I</sys/class/scsi_disk/c:b:t:l/device/unique_id>"
msgstr "I</sys/class/scsi_disk/c:b:t:l/device/unique_id>"

#. type: Plain text
#: build/C/man4/hpsa.4:137
msgid ""
"This attribute contains a 32 hex-digit unique ID for each logical drive."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:145
#, no-wrap
msgid ""
"# B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat unique_id>\n"
"600508B1001044395355323037570F77\n"
msgstr ""
" # B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat unique_id>\n"
"600508B1001044395355323037570F77\n"

#. type: TP
#: build/C/man4/hpsa.4:147
#, no-wrap
msgid "I</sys/class/scsi_disk/c:b:t:l/device/raid_level>"
msgstr "I</sys/class/scsi_disk/c:b:t:l/device/raid_level>"

#. type: Plain text
#: build/C/man4/hpsa.4:150
msgid "This attribute contains the RAID level of each logical drive."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:158
#, no-wrap
msgid ""
"# B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat raid_level>\n"
"RAID 0\n"
msgstr ""
" # B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat raid_level>\n"
"RAID 0\n"

#. type: TP
#: build/C/man4/hpsa.4:160
#, no-wrap
msgid "I</sys/class/scsi_disk/c:b:t:l/device/lunid>"
msgstr "I</sys/class/scsi_disk/c:b:t:l/device/lunid>"

#. type: Plain text
#: build/C/man4/hpsa.4:166
msgid ""
"This attribute contains the 16 hex-digit (8 byte) LUN ID by which a logical "
"drive or physical device can be addressed.  I<c>:I<b>:I<t>:I<l> are the "
"controller, bus, target, and lun of the device."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:174
#, no-wrap
msgid ""
"# B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat lunid>\n"
"0x0000004000000000\n"
msgstr ""
" # B<cd /sys/class/scsi_disk/4:0:0:0/device>\n"
"# B<cat lunid>\n"
"0x0000004000000000\n"

#. type: SS
#: build/C/man4/hpsa.4:177
#, no-wrap
msgid "Supported ioctl() operations"
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:189
msgid ""
"For compatibility with applications written for the B<cciss>(4)  driver, "
"many, but not all of the ioctls supported by the B<cciss>(4)  driver are "
"also supported by the B<hpsa> driver.  The data structures used by these "
"ioctls are described in the Linux kernel source file I<include/linux/"
"cciss_ioctl.h>."
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:189 build/C/man4/smartpqi.4:39
#, no-wrap
msgid "B<CCISS_DEREGDISK>, B<CCISS_REGNEWDISK>, B<CCISS_REGNEWD>"
msgstr "B<CCISS_DEREGDISK>, B<CCISS_REGNEWDISK>, B<CCISS_REGNEWD>"

#. type: Plain text
#: build/C/man4/hpsa.4:195
msgid ""
"These three ioctls all do exactly the same thing, which is to cause the "
"driver to rescan for new devices.  This does exactly the same thing as "
"writing to the hpsa-specific host \"rescan\" attribute."
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:195 build/C/man4/smartpqi.4:49
#, no-wrap
msgid "B<CCISS_GETPCIINFO>"
msgstr "B<CCISS_GETPCIINFO>"

#. type: Plain text
#: build/C/man4/hpsa.4:198
msgid ""
"Returns PCI domain, bus, device and function and \"board ID\" (PCI subsystem "
"ID)."
msgstr ""

#. type: TP
#: build/C/man4/hpsa.4:198 build/C/man4/smartpqi.4:53
#, no-wrap
msgid "B<CCISS_GETDRIVVER>"
msgstr "B<CCISS_GETDRIVVER>"

#. type: Plain text
#: build/C/man4/hpsa.4:201
msgid "Returns driver version in three bytes encoded as:"
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:206
#, no-wrap
msgid ""
"(major_version E<lt>E<lt> 16) | (minor_version E<lt>E<lt> 8) |\n"
"    (subminor_version)\n"
msgstr ""
" (major_version E<lt>E<lt> 16) | (minor_version E<lt>E<lt> 8) |\n"
"    (subminor_version)\n"

#. type: TP
#: build/C/man4/hpsa.4:208
#, no-wrap
msgid "B<CCISS_PASSTHRU>, B<CCISS_BIG_PASSTHRU>"
msgstr "B<CCISS_PASSTHRU>, B<CCISS_BIG_PASSTHRU>"

#. type: Plain text
#: build/C/man4/hpsa.4:219
msgid ""
"Allows \"BMIC\" and \"CISS\" commands to be passed through to the Smart "
"Array.  These are used extensively by the HP Array Configuration Utility, "
"SNMP storage agents, and so on.  See I<cciss_vol_status> at E<.UR http://"
"cciss.sf.net> E<.UE> for some examples."
msgstr ""

#. type: Plain text
#: build/C/man4/hpsa.4:226
msgid ""
"B<cciss>(4), B<sd>(4), B<st>(4), B<cciss_vol_status>(8), B<hpacucli>(8), "
"B<hpacuxe>(8),"
msgstr ""
"B<cciss>(4), B<sd>(4), B<st>(4), B<cciss_vol_status>(8), B<hpacucli>(8), "
"B<hpacuxe>(8),"

#.  .SH AUTHORS
#.  Don Brace, Steve Cameron, Tom Lawler, Mike Miller, Scott Teel
#.  and probably some other people.
#. type: Plain text
#: build/C/man4/hpsa.4:237
msgid ""
"E<.UR http://cciss.sf.net> E<.UE ,> and I<Documentation/scsi/hpsa.txt> and "
"I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss> in the Linux kernel "
"source tree"
msgstr ""
"Linux カーネルのソースツリーの E<.UR http://cciss.sf.net> E<.UE ,> "
"I<Documentation/scsi/hpsa.txt>, I<Documentation/ABI/testing/sysfs-bus-pci-"
"devices-cciss>"

#. type: TH
#: build/C/man4/initrd.4:35
#, no-wrap
msgid "INITRD"
msgstr "INITRD"

#. type: Plain text
#: build/C/man4/initrd.4:38
msgid "initrd - boot loader initialized RAM disk"
msgstr "initrd - ブートローダーによって初期化された RAM ディスク"

#. type: Plain text
#: build/C/man4/initrd.4:50
msgid ""
"I</dev/initrd> is a read-only block device assigned major number 1 and minor "
"number 250.  Typically I</dev/initrd> is owned by root:disk with mode 0400 "
"(read access by root only).  If the Linux system does not have I</dev/"
"initrd> already created, it can be created with the following commands:"
msgstr "I</dev/initrd> は、メジャー番号 1、マイナー番号 250 が割り当てられた 読み込み専用のブロックデバイスである。 普通、 I</dev/initrd> の所有者は root:disk であり、モードは 400 (root のみが読み出し可能) である。 もし、Linux システムに作成済の I</dev/initrd> ファイルがなかった場合、以下のコマンドで作成することができる:"

#. type: Plain text
#: build/C/man4/initrd.4:55
#, no-wrap
msgid ""
"mknod -m 400 /dev/initrd b 1 250\n"
"chown root:disk /dev/initrd\n"
msgstr ""
" mknod -m 400 /dev/initrd b 1 250\n"
"chown root:disk /dev/initrd\n"

#. type: Plain text
#: build/C/man4/initrd.4:71
msgid ""
"Also, support for both \"RAM disk\" and \"Initial RAM disk\" (e.g., "
"B<CONFIG_BLK_DEV_RAM=y> and B<CONFIG_BLK_DEV_INITRD=y>)  must be compiled "
"directly into the Linux kernel to use I</dev/initrd>.  When using I</dev/"
"initrd>, the RAM disk driver cannot be loaded as a module."
msgstr ""
"また、 I</dev/initrd> を使用するためには、 \"RAM disk\" と \"Initial RAM disk"
"\" の両方の機能が Linux カーネルに直接組み込まれていなければならない (例え"
"ば、カーネルのコンパイル時の設定で B<CONFIG_BLK_DEV_RAM=y> かつ "
"B<CONFIG_BLK_DEV_INITRD=y> とする)。 I</dev/initrd> を使用する場合には、RAM "
"ディスクドライバをモジュールとして ロードすることはできない。"

#. type: Plain text
#: build/C/man4/initrd.4:80
msgid ""
"The special file I</dev/initrd> is a read-only block device.  This device is "
"a RAM disk that is initialized (e.g., loaded)  by the boot loader before the "
"kernel is started.  The kernel then can use I</dev/initrd>'s contents for a "
"two-phase system boot-up."
msgstr ""
"I</dev/initrd> スペシャルファイルは読み込み専用のブロックデバイスである。 こ"
"のデバイスはカーネルが起動される前にブートローダー (boot loader)  によって初"
"期化 (例えば、ロード) される RAM ディスクである。 その後、カーネルは I</dev/"
"initrd> の内容を二段階のシステム起動 (two-phase system boot-up)  で利用するこ"
"とができる。"

#. type: Plain text
#: build/C/man4/initrd.4:93
msgid ""
"In the first boot-up phase, the kernel starts up and mounts an initial root "
"filesystem from the contents of I</dev/initrd> (e.g., RAM disk initialized "
"by the boot loader).  In the second phase, additional drivers or other "
"modules are loaded from the initial root device's contents.  After loading "
"the additional modules, a new root filesystem (i.e., the normal root "
"filesystem) is mounted from a different device."
msgstr ""
"最初のブートアップ段階 (first boot-up phase) では、カーネルは (例えば、ブート"
"ローダーによって初期化された RAM disk である)  I</dev/initrd> の内容を初期"
"ルートファイルシステム (root file-system) としてマウント して起動する。 第二"
"段階では初期ルートデバイスに含まれているものから、追加のドライ バやその他のモ"
"ジュールがロードされる。 追加のモジュールがロードされた後、新しいルートファイ"
"ルシステム (すなわち、通常時のルートファイルシステム)  が別のデバイスからマウ"
"ントされる。"

#. type: SS
#: build/C/man4/initrd.4:93
#, no-wrap
msgid "Boot-up operation"
msgstr "ブートアップ作業"

#. type: Plain text
#: build/C/man4/initrd.4:97
msgid "When booting up with B<initrd>, the system boots as follows:"
msgstr "B<initrd> を利用した時は、システムは次のようにブートする:"

#. type: Plain text
#: build/C/man4/initrd.4:101
msgid ""
"The boot loader loads the kernel program and I</dev/initrd>'s contents into "
"memory."
msgstr ""
"ブートローダーはカーネルプログラムと I</dev/initrd> の内容をメモリーにロード"
"する。"

#. type: Plain text
#: build/C/man4/initrd.4:109
msgid ""
"On kernel startup, the kernel uncompresses and copies the contents of the "
"device I</dev/initrd> onto device I</dev/ram0> and then frees the memory "
"used by I</dev/initrd>."
msgstr ""
"カーネル起動時、カーネルは I</dev/initrd> デバイスの内容を展開 (uncompress) "
"し、 I</dev/ram0> にコピーする。さらに、 I</dev/initrd> の使っていたメモリー"
"を解放する。"

#. type: IP
#: build/C/man4/initrd.4:109 build/C/man4/initrd.4:351
#: build/C/man4/initrd.4:470 build/C/man4/st.4:932
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man4/initrd.4:113
msgid ""
"The kernel then read-write mounts the device I</dev/ram0> as the initial "
"root filesystem."
msgstr ""
"カーネルは I</dev/ram0> デバイスを初期のルートファイルシステムとして読み書き"
"可能な形式でマウン トする。"

#. type: IP
#: build/C/man4/initrd.4:113 build/C/man4/initrd.4:355 build/C/man4/st.4:939
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man4/initrd.4:118
msgid ""
"If the indicated normal root filesystem is also the initial root filesystem "
"(e.g., I</dev/ram0>)  then the kernel skips to the last step for the usual "
"boot sequence."
msgstr ""
"指示されたルートファイルシステムが初期ルートファイルシステム (例えば I</dev/"
"ram0>)  と同一の場合は、カーネルは普通のブートシーケンスのための最後のステッ"
"プを 省略する。"

#. type: IP
#: build/C/man4/initrd.4:118 build/C/man4/initrd.4:361 build/C/man4/st.4:944
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man4/initrd.4:130
msgid ""
"If the executable file I</linuxrc> is present in the initial root "
"filesystem, I</linuxrc> is executed with UID 0.  (The file I</linuxrc> must "
"have executable permission.  The file I</linuxrc> can be any valid "
"executable, including a shell script.)"
msgstr ""
"I</linuxrc> という実行可能なファイルが初期ルートファイルシステムに存在すれ"
"ば、 I</linuxrc> を UID 0 (すなわち、root) の権限で実行する。 (I</linuxrc> "
"ファイルは実行可能パーミッションが与えられていなければならない。 I</linuxrc> "
"は正当な実行ファイルであればよく、シェルスクリプトでも構わない。)"

#. type: IP
#: build/C/man4/initrd.4:130 build/C/man4/initrd.4:370
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: build/C/man4/initrd.4:142
msgid ""
"If I</linuxrc> is not executed or when I</linuxrc> terminates, the normal "
"root filesystem is mounted.  (If I</linuxrc> exits with any filesystems "
"mounted on the initial root filesystem, then the behavior of the kernel is "
"B<UNSPECIFIED>.  See the NOTES section for the current kernel behavior.)"
msgstr ""
"I</linuxrc> が実行されない、または、 I</linuxrc> の実行が終了した時は、通常時"
"ルートファイルシステムがマウントされる。 (I</linuxrc> を終了した時、何らかの"
"ファイルシステムが初期ルートファイルシステム上に マウントされている場合のカー"
"ネルの動作は B<決められていない (不定である)>。 現在のカーネルがどのように動"
"作するかは、 「注意」のセクションを参照のこと。)"

#. type: IP
#: build/C/man4/initrd.4:142 build/C/man4/initrd.4:372
#, no-wrap
msgid "7."
msgstr "7."

#. type: Plain text
#: build/C/man4/initrd.4:173
msgid ""
"If the normal root filesystem has a directory I</initrd>, the device I</dev/"
"ram0> is moved from I</> to I</initrd>.  Otherwise, if the directory I</"
"initrd> does not exist, the device I</dev/ram0> is unmounted.  (When moved "
"from I</> to I</initrd>, I</dev/ram0> is not unmounted and therefore "
"processes can remain running from I</dev/ram0>.  If directory I</initrd> "
"does not exist on the normal root filesystem and any processes remain "
"running from I</dev/ram0> when I</linuxrc> exits, the behavior of the kernel "
"is B<UNSPECIFIED>.  See the NOTES section for the current kernel behavior.)"
msgstr ""
"通常時ルートファイルシステムに ディレクトリ I</initrd> があれば、 I</dev/"
"ram0> デバイスは I</> から I</initrd> に移動される。 I</initrd> ディレクトリ"
"が存在しない場合は、 I</dev/ram0> はアンマウントされる。 (I</> が I</initrd> "
"に移動された場合には、 I</dev/ram0> はアンマウントされず、その結果、 I</dev/"
"ram0> で走り始めたプロセスはそのまま残る事ができる。 もし、 I</initrd> ディレ"
"クトリが通常時ルートファイルシステムに存在せず、 I</linuxrc> が終了した時に "
"I</dev/ram0> 上で実行された、なんらかのプロセスが走り続けていた場合の カーネ"
"ルの動作は B<決められていない (不定である)>。 現在のカーネルが、この時どのよ"
"うな動作をするかについては、 「注意」を参照のこと。)"

#. type: IP
#: build/C/man4/initrd.4:173 build/C/man4/initrd.4:375
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: build/C/man4/initrd.4:180
msgid ""
"The usual boot sequence (e.g., invocation of I</sbin/init>)  is performed on "
"the normal root filesystem."
msgstr ""
"普通のブートシーケンス (例えば、 I</sbin/init> の起動) が通常時ルートファイル"
"システム上で行われる。"

#. type: Plain text
#: build/C/man4/initrd.4:184
msgid ""
"The following boot loader options, when used with B<initrd>, affect the "
"kernel's boot-up operation:"
msgstr ""
"B<initrd> を用いる場合に、カーネルのブートアップ操作に影響を与える ブートロー"
"ダーオプションは次のようなものがある、"

#. type: TP
#: build/C/man4/initrd.4:184
#, no-wrap
msgid "B<initrd=>I<filename>"
msgstr "B<initrd=>I<filename>"

#. type: Plain text
#: build/C/man4/initrd.4:199
msgid ""
"Specifies the file to load as the contents of I</dev/initrd>.  For "
"B<LOADLIN> this is a command-line option.  For B<LILO> you have to use this "
"command in the B<LILO> configuration file I</etc/lilo.config>.  The filename "
"specified with this option will typically be a gzipped filesystem image."
msgstr ""
"I</dev/initrd> の内容としてロードするファイルを指定する。 B<LOADLIN> では、こ"
"れはコマンドラインオプションである。 B<LILO> では、 B<LILO> の設定ファイル "
"I</etc/lilo.config> 内でコマンドとして使用しなければならない。 このオプション"
"で指定されるファイルは、多くの場合 gzip 圧縮された ファイルシステムイメージで"
"ある。"

#. type: TP
#: build/C/man4/initrd.4:199
#, no-wrap
msgid "B<noinitrd>"
msgstr " B<noinitrd>"

#. type: Plain text
#: build/C/man4/initrd.4:214
msgid ""
"This boot option disables the two-phase boot-up operation.  The kernel "
"performs the usual boot sequence as if I</dev/initrd> was not initialized.  "
"With this option, any contents of I</dev/initrd> loaded into memory by the "
"boot loader contents are preserved.  This option permits the contents of I</"
"dev/initrd> to be any data and need not be limited to a filesystem image.  "
"However, device I</dev/initrd> is read-only and can be read only one time "
"after system startup."
msgstr ""
"この起動オプションは二段階の起動操作を無効にする。 カーネルは I</dev/initrd> "
"が初期化されていない場合と同様の、通常のブートアップ動作を行う。 このオプショ"
"ンを用いると、ブートローダーによってメモリー上にロードされた I</dev/initrd> "
"の内容はそのまま保存される。 つまり、このオプションを用いることによって、 I</"
"dev/initrd> の内容を (ブート以外の目的に) 利用することが可能になる。また、そ"
"の内容は ファイルシステムイメージに限定されない。 しかし、 I</dev/initrd> デ"
"バイスは読みだしのみ可能であり、システムの起動後 1 度しか読み出す事 ができな"
"い。"

#. type: TP
#: build/C/man4/initrd.4:214
#, no-wrap
msgid "B<root=>I<device-name>"
msgstr "B<root=>I<device-name>"

#. type: Plain text
#: build/C/man4/initrd.4:232
msgid ""
"Specifies the device to be used as the normal root filesystem.  For "
"B<LOADLIN> this is a command-line option.  For B<LILO> this is a boot time "
"option or can be used as an option line in the B<LILO> configuration file I</"
"etc/lilo.config>.  The device specified by this option must be a mountable "
"device having a suitable root filesystem."
msgstr ""
"通常時ルートファイルシステムとして使われるデバイスを指定する。 B<LOADLIN> で"
"は、これはコマンドラインオプションである。 B<LILO> ではコマンドラインオプショ"
"ン、または、 B<LILO> の設定ファイルである I</etc/lilo.config> のオプションラ"
"インとして使用する。 このオプションで指定されるデバイスは、適切なルートファイ"
"ルシステムとし てマウント可能なデバイスでなければならない。"

#. type: SS
#: build/C/man4/initrd.4:232
#, no-wrap
msgid "Changing the normal root filesystem"
msgstr "通常時ルートファイルシステムの変更"

#.  commit dc7a08166f3a5f23e79e839a8a88849bd3397c32
#. type: Plain text
#: build/C/man4/initrd.4:256
msgid ""
"By default, the kernel's settings (e.g., set in the kernel file with "
"B<rdev>(8)  or compiled into the kernel file), or the boot loader option "
"setting is used for the normal root filesystems.  For an NFS-mounted normal "
"root filesystem, one has to use the B<nfs_root_name> and B<nfs_root_addrs> "
"boot options to give the NFS settings.  For more information on NFS-mounted "
"root see the kernel documentation file I<Documentation/filesystems/nfs/"
"nfsroot.txt> (or I<Documentation/filesystems/nfsroot.txt> before Linux "
"2.6.33).  For more information on setting the root filesystem see also the "
"B<LILO> and B<LOADLIN> documentation."
msgstr "デフォルトでは、カーネルの設定 (例えば、 B<rdev>(8)  を用いてカーネルファイル内にセットされたもの、または、コンパイル時にカー ネルファイル内に埋め込まれたもの)、 または、ブートローダーのオプション設定によって指定されたものが通常時ルー トファイルシステムとして使われる。 NFS マウントされた通常時ルートファイルシステムを利用する場合、 B<nfs_root_name> と B<nfs_root_addrs> ブートオプションを使って NFS の設定を与えなければならない。 NFS マウントされたルート (ファイルシステム) についての より詳しい情報は、カーネルのドキュメントファイル I<Documentation/filesystems/nfs/nfsroot.txt> (Linux 2.6.33 より前は I<Documentation/filesystems/nfsroot.txt>) を参照のこと。 ルートファイルシステムの設定についてのより詳しい情報は、 B<LILO> と B<LOADLIN> のドキュメントも参照のこと。"

#. type: Plain text
#: build/C/man4/initrd.4:288
msgid ""
"It is also possible for the I</linuxrc> executable to change the normal root "
"device.  For I</linuxrc> to change the normal root device, I</proc> must be "
"mounted.  After mounting I</proc>, I</linuxrc> changes the normal root "
"device by writing into the proc files I</proc/sys/kernel/real-root-dev>, I</"
"proc/sys/kernel/nfs-root-name>, and I</proc/sys/kernel/nfs-root-addrs>.  For "
"a physical root device, the root device is changed by having I</linuxrc> "
"write the new root filesystem device number into I</proc/sys/kernel/real-"
"root-dev>.  For an NFS root filesystem, the root device is changed by having "
"I</linuxrc> write the NFS setting into files I</proc/sys/kernel/nfs-root-"
"name> and I</proc/sys/kernel/nfs-root-addrs> and then writing 0xff (e.g., "
"the pseudo-NFS-device number) into file I</proc/sys/kernel/real-root-dev>.  "
"For example, the following shell command line would change the normal root "
"device to I</dev/hdb1>:"
msgstr ""
"また、 I</linuxrc> を用いる事によっても通常時ルートファイルシステムデバイスを"
"変更すること ができる。 I</linuxrc> を用いて、通常時ルートデバイスを変更する"
"ためには、 I</proc> がマウントされていなければならない。 I</proc> をマウント"
"した後で、 I</linuxrc> は proc ファイル I</proc/sys/kernel/real-root-dev>, "
"I</proc/sys/kernel/nfs-root-name>, I</proc/sys/kernel/nfs-root-addrs> に書き"
"込みを行い、通常時ルートデバイスを変更する。 (NFS ではない) 物理的なルートデ"
"バイスの場合、 I</linuxrc> が新しいルートファイルシステムのデバイス番号を I</"
"proc/sys/kernel/real-root-dev> に書き込むことで、ルートデバイスが変更され"
"る。 NFS ルートファイルシステムの場合、 I</linuxrc> が NFS の設定を I</proc/"
"sys/kernel/nfs-root-name> と I</proc/sys/kernel/nfs-root-addrs> に書き込み、"
"それから I</proc/sys/kernel/real-root-dev> に (疑似 NFS デバイスナンバーであ"
"る) 0xff を書き込むことで、 ルートデバイスが変更される。 例えば、次のシェルコ"
"マンドラインにより、通常時ルートデバイスを I</dev/hdb1> に変更できるだろう:"

#. type: Plain text
#: build/C/man4/initrd.4:292
#, no-wrap
msgid "echo 0x365 E<gt>/proc/sys/kernel/real-root-dev\n"
msgstr " echo 0x365 E<gt>/proc/sys/kernel/real-root-dev\n"

#. type: Plain text
#: build/C/man4/initrd.4:300
msgid ""
"For an NFS example, the following shell command lines would change the "
"normal root device to the NFS directory I</var/nfsroot> on a local networked "
"NFS server with IP number 193.8.232.7 for a system with IP number "
"193.8.232.2 and named \"idefix\":"
msgstr ""
"また、NFS の場合、次のようなシェルコマンドラインにより、 193.8.232.2 という "
"IP アドレスを持つ \"idefix\" という名前の システムの、通常時ルートデバイスと"
"して、 ローカルネットワークの 193.8.232.2 という IP アドレスを持つ NFS サーバ"
"の NFS ディレクトリ I</var/nfsroot> をマウントするように変更できる:"

#. type: Plain text
#: build/C/man4/initrd.4:307
#, no-wrap
msgid ""
"echo /var/nfsroot E<gt>/proc/sys/kernel/nfs-root-name\n"
"echo 193.8.232.2:193.8.232.7::255.255.255.0:idefix \\e\n"
"    E<gt>/proc/sys/kernel/nfs-root-addrs\n"
"echo 255 E<gt>/proc/sys/kernel/real-root-dev\n"
msgstr ""
" echo /var/nfsroot E<gt>/proc/sys/kernel/nfs-root-name\n"
"echo 193.8.232.2:193.8.232.7::255.255.255.0:idefix \\e\n"
"    E<gt>/proc/sys/kernel/nfs-root-addrs\n"
"echo 255 E<gt>/proc/sys/kernel/real-root-dev\n"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#.  FIXME . Should this manual page  describe the pivot_root mechanism?
#. type: Plain text
#: build/C/man4/initrd.4:329
msgid ""
"B<Note>: The use of I</proc/sys/kernel/real-root-dev> to change the root "
"filesystem is obsolete.  See the Linux kernel source file I<Documentation/"
"admin-guide/initrd.rst> (or I<Documentation/initrd.txt> before Linux 4.10)  "
"as well as B<pivot_root>(2)  and B<pivot_root>(8)  for information on the "
"modern method of changing the root filesystem."
msgstr "B<注意>: ルートファイルシステムを変更するために I</proc/sys/kernel/real-root-dev> を使うのは以前の方法である。 ルートファイルシステムを変更する新しい方法についての情報は、 Linux カーネルソースに含まれる I<Documentation/admin-guide/initrd.rst> (Linux 4.10 より前は I<Documentation/initrd.txt>) ファイルを参照のこと。また、 B<pivot_root>(2) や B<pivot_root>(8) も参照のこと。"

#. type: SS
#: build/C/man4/initrd.4:329 build/C/man4/random.4:127 build/C/man7/uri.7:109
#, no-wrap
msgid "Usage"
msgstr "使い方"

#. type: Plain text
#: build/C/man4/initrd.4:333
msgid ""
"The main motivation for implementing B<initrd> was to allow for modular "
"kernel configuration at system installation."
msgstr ""
"B<initrd> が実装された主な目的は、システムインストール時に、モジュール化され"
"たカー ネルの設定を可能にすることであった。"

#. type: Plain text
#: build/C/man4/initrd.4:335
msgid "A possible system installation scenario is as follows:"
msgstr "次のような流れのシステムインストールが可能になる:"

#. type: Plain text
#: build/C/man4/initrd.4:343
msgid ""
"The loader program boots from floppy or other media with a minimal kernel (e."
"g., support for I</dev/ram>, I</dev/initrd>, and the ext2 filesystem) and "
"loads I</dev/initrd> with a gzipped version of the initial filesystem."
msgstr ""
"ローダープログラムは、フロッピーやその他のメディアから、 最小限のカーネル (例"
"えば、 I</dev/ram>, I</dev/initrd>, ext2 ファイルシステムのみのサポートした"
"カーネル) をブートし、 gzip 圧縮された初期ファイルシステムイメージを I</dev/"
"initrd> にロードする。"

#. type: Plain text
#: build/C/man4/initrd.4:351
msgid ""
"The executable I</linuxrc> determines what is needed to (1) mount the normal "
"root filesystem (i.e., device type, device drivers, filesystem) and (2) the "
"distribution media (e.g., CD-ROM, network, tape, ...).  This can be done by "
"asking the user, by auto-probing, or by using a hybrid approach."
msgstr ""
"実行ファイル I</linuxrc> は、(1) 通常時ルートファイルシステムのマウントに何が"
"必要か (すなわち、デバイスタイプ、デバイスドライバ、ファイルシステム)、 (2) "
"配布メディアに何が必要か (例えば、CD-ROM, ネットワーク、テープなど)  を決定す"
"る。決定は、ユーザーへの問い合わせ、自動検出、あるいはその両者の 方法を組み合"
"わせて行われる。"

#. type: Plain text
#: build/C/man4/initrd.4:355
msgid ""
"The executable I</linuxrc> loads the necessary modules from the initial root "
"filesystem."
msgstr ""
"実行ファイル I</linuxrc> は、初期ルートファイルシステムから必要なモジュールを"
"ロードする。"

#. type: Plain text
#: build/C/man4/initrd.4:361
msgid ""
"The executable I</linuxrc> creates and populates the root filesystem.  (At "
"this stage the normal root filesystem does not have to be a completed system "
"yet.)"
msgstr ""
"実行ファイル I</linuxrc> は、ルートファイルシステムを作成し、配置する (この段"
"階では、通常時ルー トファイルシステムは完全なシステムである必要はない)。"

#. type: Plain text
#: build/C/man4/initrd.4:370
msgid ""
"The executable I</linuxrc> sets I</proc/sys/kernel/real-root-dev>, unmounts "
"I</proc>, the normal root filesystem and any other filesystems it has "
"mounted, and then terminates."
msgstr "実行ファイル I</linuxrc> は、 I</proc/sys/kernel/real-root-dev> を設定し、 I</proc>、通常の root ファイルシステム、マウントされているその他のファイルシステムをアンマウントし、実行を終了する。"

#. type: Plain text
#: build/C/man4/initrd.4:372
msgid "The kernel then mounts the normal root filesystem."
msgstr "次に、カーネルは、通常時ルートファイルシステムをマウントする。"

#. type: Plain text
#: build/C/man4/initrd.4:375
msgid ""
"Now that the filesystem is accessible and intact, the boot loader can be "
"installed."
msgstr ""
"この段階で、ファイルシステムは全く変更が行われていない状態で、 アクセスできる"
"状態になる。 また、ブートローダーをインストールすることができる。"

#. type: Plain text
#: build/C/man4/initrd.4:384
msgid ""
"The boot loader is configured to load into I</dev/initrd> a filesystem with "
"the set of modules that was used to bring up the system.  (e.g., device I</"
"dev/ram0> can be modified, then unmounted, and finally, the image is written "
"from I</dev/ram0> to a file.)"
msgstr ""
"ブートローダーを設定し、システム起動時に使用されるカーネルモジュールのセッ ト"
"を含んだファイルシステムを I</dev/initrd> にロードする (例えば、 I</dev/"
"ram0> デバイスの内容を修正し、アンマウントする。最後に、 I</dev/ram0> のイ"
"メージをファイルに書き出す)。"

#. type: IP
#: build/C/man4/initrd.4:384
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: build/C/man4/initrd.4:387
msgid ""
"The system is now bootable and additional installation tasks can be "
"performed."
msgstr ""
"これで、システムがブート可能になる。この後、さらにその他のインストール の作業"
"を実行できる。"

#. type: Plain text
#: build/C/man4/initrd.4:393
msgid ""
"The key role of I</dev/initrd> in the above is to reuse the configuration "
"data during normal system operation without requiring initial kernel "
"selection, a large generic kernel or, recompiling the kernel."
msgstr ""
"上記の動作での I</dev/initrd> の役割のキーポイントは、初期カーネルの選択や大"
"きなジェネリックカーネル、 カーネルの再構築なしに、通常のシステム操作で再利用"
"可能な設定データを利 用することにある。"

#. type: Plain text
#: build/C/man4/initrd.4:406
msgid ""
"A second scenario is for installations where Linux runs on systems with "
"different hardware configurations in a single administrative network.  In "
"such cases, it may be desirable to use only a small set of kernels (ideally "
"only one) and to keep the system-specific part of configuration information "
"as small as possible.  In this case, create a common file with all needed "
"modules.  Then, only the I</linuxrc> file or a file executed by I</linuxrc> "
"would be different."
msgstr ""
"2 番目のケースは、一つの管理上のネットワークにおいて、異なる設定のハー ドウェ"
"アのシステム上で Linux を動作させるためのインストールを行う場合 である。 この"
"ようなケースの場合、ごく小数のカーネルのセット (理想的にはたった一 つのカーネ"
"ル) のみを利用し、システム固有の設定情報は可能な限り小さくす ることが望ましい"
"であろう。 この場合、全ての必要なモジュールが入った共通ファイルを作成する。 "
"そして、 I</linuxrc> ファイル、または、 I</linuxrc> から実行されるファイルの"
"みを異なったものにしておく。"

#. type: Plain text
#: build/C/man4/initrd.4:413
msgid ""
"A third scenario is more convenient recovery disks.  Because information "
"like the location of the root filesystem partition is not needed at boot "
"time, the system loaded from I</dev/initrd> can use a dialog and/or auto-"
"detection followed by a possible sanity check."
msgstr ""
"3 番目のケースは、より便利な復旧用ディスクを作る場合である。 ルートファイルシ"
"ステムのパーティションの位置といった情報は ブート時に必要ないため、 I</dev/"
"initrd> からロードされたシステムは、 必要な正常性チェックを行った後で、ユー"
"ザーへの問い合わせや自動検出 (もしくはその両方) を行うことができるようにな"
"る。"

#. type: Plain text
#: build/C/man4/initrd.4:430
msgid ""
"Last but not least, Linux distributions on CD-ROM may use B<initrd> for easy "
"installation from the CD-ROM.  The distribution can use B<LOADLIN> to "
"directly load I</dev/initrd> from CD-ROM without the need of any floppies.  "
"The distribution could also use a B<LILO> boot floppy and then bootstrap a "
"bigger RAM disk via I</dev/initrd> from the CD-ROM."
msgstr ""
"(他にもたくさん例があるだろうが) 最後の例としては、 B<initrd> を利用すると、"
"CD-ROM 上の Linux ディストリビューションを より簡単に CD-ROM からインストール"
"することができるだろう。 ディストリビューションは、 B<LOADLIN> を使って、フ"
"ロッピーを全く利用せずに CD-ROM から I</dev/initrd> を直接ロードすることがで"
"きる。 また、 B<LILO> ブートフロッピーを使ってブートを行い、 I</dev/initrd> "
"を通して CD-ROM からより大きな RAM ディスクを起動することもできる。"

#. type: Plain text
#: build/C/man4/initrd.4:432
msgid "I</dev/initrd>"
msgstr "I</dev/initrd>"

#. type: Plain text
#: build/C/man4/initrd.4:434
msgid "I</dev/ram0>"
msgstr "I</dev/ram0>"

#. type: Plain text
#: build/C/man4/initrd.4:436
msgid "I</linuxrc>"
msgstr "I</linuxrc>"

#. type: Plain text
#: build/C/man4/initrd.4:441
msgid "I</initrd>"
msgstr "I</initrd>"

#. type: Plain text
#: build/C/man4/initrd.4:453
msgid ""
"With the current kernel, any filesystems that remain mounted when I</dev/"
"ram0> is moved from I</> to I</initrd> continue to be accessible.  However, "
"the I</proc/mounts> entries are not updated."
msgstr ""
"現在のカーネルでは、 I</dev/ram0> が I</> から I</initrd> に移動された際に、"
"移動時にマウントされていたファイルシステムは、 その後も継続的にアクセス可能で"
"ある。しかし、 I</proc/mounts> のエントリーは更新されない。"

#. type: Plain text
#: build/C/man4/initrd.4:470
msgid ""
"With the current kernel, if directory I</initrd> does not exist, then I</dev/"
"ram0> will B<not> be fully unmounted if I</dev/ram0> is used by any process "
"or has any filesystem mounted on it.  If I</dev/ram0> is B<not> fully "
"unmounted, then I</dev/ram0> will remain in memory."
msgstr ""
"現在のカーネルでは、ディレクトリ I</initrd> が存在しない場合、 I</dev/ram0> "
"を何らかのプロセスが利用していたり、何らかのファイルシステムが I</dev/ram0> "
"上にマウントされていると、 I</dev/ram0> は完全にはアンマウント「されない」。 "
"I</dev/ram0> が、完全にアンマウント「されなければ」、 I</dev/ram0> はメモリー"
"上に残ってしまうはずである。"

#.  .SH AUTHORS
#.  The kernel code for device
#.  .BR initrd
#.  was written by Werner Almesberger <almesber@lrc.epfl.ch> and
#.  Hans Lermen <lermen@elserv.ffm.fgan.de>.
#.  The code for
#.  .BR initrd
#.  was added to the baseline Linux kernel in development version 1.3.73.
#. type: Plain text
#: build/C/man4/initrd.4:486
msgid ""
"Users of I</dev/initrd> should not depend on the behavior given in the above "
"notes.  The behavior may change in future versions of the Linux kernel."
msgstr ""
"I</dev/initrd> の利用者は、上記の注意事項で述べた動作に依存しないようにすべき"
"である。 これらの動作は Linux カーネルの将来のバージョンでは変更される かもし"
"れないからだ。"

#. type: Plain text
#: build/C/man4/initrd.4:492
msgid "B<chown>(1), B<mknod>(1), B<ram>(4), B<freeramdisk>(8), B<rdev>(8)"
msgstr "B<chown>(1), B<mknod>(1), B<ram>(4), B<freeramdisk>(8), B<rdev>(8)"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: build/C/man4/initrd.4:500
msgid ""
"I<Documentation/admin-guide/initrd.rst> (or I<Documentation/initrd.txt> "
"before Linux 4.10)  in the Linux kernel source tree, the LILO documentation, "
"the LOADLIN documentation, the SYSLINUX documentation"
msgstr "Linux カーネルソースの I<Documentation/admin-guide/initrd.rst> (Linux 4.10 より前では I<Documentation/initrd.txt>)、 LILO のドキュメント、LOADLIN のドキュメント、SYSLINUX のドキュメント"

#. type: TH
#: build/C/man4/lp.4:26
#, no-wrap
msgid "LP"
msgstr "LP"

#. type: Plain text
#: build/C/man4/lp.4:29
msgid "lp - line printer devices"
msgstr "lp - ラインプリンターデバイス"

#. type: Plain text
#: build/C/man4/lp.4:31
msgid "B<#include E<lt>linux/lp.hE<gt>>"
msgstr "B<#include E<lt>linux/lp.hE<gt>>"

#. type: Plain text
#: build/C/man4/lp.4:45
msgid ""
"B<lp>[0\\(en2] are character devices for the parallel line printers; they "
"have major number 6 and minor number 0\\(en2.  The minor numbers correspond "
"to the printer port base addresses 0x03bc, 0x0378, and 0x0278.  Usually they "
"have mode 220 and are owned by user I<root> and group I<lp>.  You can use "
"printer ports either with polling or with interrupts.  Interrupts are "
"recommended when high traffic is expected, for example, for laser printers.  "
"For typical dot matrix printers, polling will usually be enough.  The "
"default is polling."
msgstr "B<lp>[0\\(en2] はパラレルプリンターのためのキャラクターデバイスでメジャー ナンバー 6 マイナーナンバー 0\\(en2 を持つ。マイナーナンバーは、ベース アドレス 0x03bc, 0x0378, 0x0278 のそれぞれのプリンターポートに対応する 通常、このデバイスファイルは、モード 220 で、所有権はユーザー I<root> でグループ I<lp> となっている。プリンターポートはポーリング(polling)または割り込み (interrupts) のどちらを用いても利用できる。割り込みの利用は、高負荷が 予想される時、例えばレーザープリンターをプリンタポートに接続する場合な どに推奨される。普通のドットマトリクスプリンターでは、ポーリングの利用 で通常は十分である。デフォルトではポーリングを利用する。"

#. type: Plain text
#: build/C/man4/lp.4:49
msgid "The following B<ioctl>(2)  calls are supported:"
msgstr "次の B<ioctl>(2)  コールがサポートされている。"

#. type: IP
#: build/C/man4/lp.4:49
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPTIME, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPTIME, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:58
msgid ""
"Sets the amount of time that the driver sleeps before rechecking the printer "
"when the printer's buffer appears to be filled to I<arg>.  If you have a "
"fast printer, decrease this number; if you have a slow printer, then "
"increase it.  This is in hundredths of a second, the default 2 being 0.02 "
"seconds.  It influences only the polling driver."
msgstr "プリンターのバッファー (buffer) がいっぱいになった時、ドライバがプリンター を再チェックするまでに休止する時間を I<arg> とする。高速なプリンター の時はこれを減らし、遅いプリンターの時には増やす。単位は1秒の100分の1 で、デフォルトの2は0.02秒にあたる。ポーリングドライバ (polling driver) のみに影響する。"

#. type: IP
#: build/C/man4/lp.4:58
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPCHAR, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPCHAR, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:66
msgid ""
"Sets the maximum number of busy-wait iterations which the polling driver "
"does while waiting for the printer to get ready for receiving a character to "
"I<arg>.  If printing is too slow, increase this number; if the system gets "
"too slow, decrease this number.  The default is 1000.  It influences only "
"the polling driver."
msgstr "ポーリングドライバがプリンターの文字受取り準備ができるのを待 つビジーウエイト (busy-wait) の回数の最大値を I<arg> とする。 もし印刷が遅すぎる時はこれを増やし、システムが遅くなりすぎる時には 減らす。デフォルトは 1000 である。ポーリングドライバのみに影響する。"

#. type: IP
#: build/C/man4/lp.4:66
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPABORT, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPABORT, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:72
msgid ""
"If I<arg> is 0, the printer driver will retry on errors, otherwise it will "
"abort.  The default is 0."
msgstr ""
"もし、I<arg> が 0 なら、プリンタードライバはエラーについて再試行 を行う。それ"
"以外の場合は中止する。デフォルトは 0 である。"

#. type: IP
#: build/C/man4/lp.4:72
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPABORTOPEN, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPABORTOPEN, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:79
msgid ""
"If I<arg> is 0, B<open>(2)  will be aborted on error, otherwise error will "
"be ignored.  The default is to ignore it."
msgstr ""
"もし、I<arg> が 0 なら B<open>(2)  の結果がエラーの場合、動作が中止される。そ"
"れ以外ならエラーは無 視される。デフォルトではエラーは無視される。"

#. type: IP
#: build/C/man4/lp.4:79
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPCAREFUL, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPCAREFUL, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:85
msgid ""
"If I<arg> is 0, then the out-of-paper, offline, and error signals are "
"required to be false on all writes, otherwise they are ignored.  The default "
"is to ignore them."
msgstr "I<arg> が 0 のときには、すべての書き出しの時に、紙切れ、オフライン、エ ラーのシグナルが偽 (false) であることが必要とされるが、0 以外ならこれらのシグナルは無視される。デフォルトでもこれらのシグナルは無視される。"

#. type: IP
#: build/C/man4/lp.4:85
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPWAIT, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPWAIT, int >I<arg>B<)>"

#.  FIXME . Actually, since Linux 2.2, the default is 1
#. type: Plain text
#: build/C/man4/lp.4:97
msgid ""
"Sets the number of busy waiting iterations to wait before strobing the "
"printer to accept a just-written character, and the number of iterations to "
"wait before turning the strobe off again, to I<arg>.  The specification says "
"this time should be 0.5 microseconds, but experience has shown the delay "
"caused by the code is already enough.  For that reason, the default value is "
"0.  This is used for both the polling and the interrupt driver."
msgstr ""
"プリンターが送られた文字を受け取るのを待つため、ドライバが文字を送っ てからス"
"トローブ(strobe)するまでの待ちの繰り返しの回数と、ストローブ を再びオフにする"
"までの待ちの繰り返しの回数を I<arg>に設定 する。仕様によればこの時間は 0.5 マ"
"イクロ秒とするべきだが、経験によれば このコードによって生じる遅れで十分であ"
"る。そのため、デフォルトでは 0 で ある。これは、ポーリングと割り込みドライバ"
"の両方で使われる。"

#. type: IP
#: build/C/man4/lp.4:97
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPSETIRQ, int >I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPSETIRQ, int >I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:108
msgid ""
"This B<ioctl>(2)  requires superuser privileges.  It takes an I<int> "
"containing the new IRQ as argument.  As a side effect, the printer will be "
"reset.  When I<arg> is 0, the polling driver will be used, which is also "
"default."
msgstr ""
"この B<ioctl>(2)  を使うには、スーパーユーザーの権限が必要である。新しいIRQを"
"示す I<int> を引数としてとる。また、副作用としてプリンターはリセットされる。 "
"I<arg>が0の時またはデフォルトの動作では、ポーリングドライバーが使わ れる。"

#. type: IP
#: build/C/man4/lp.4:108
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPGETIRQ, int *>I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPGETIRQ, int *>I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:111
msgid "Stores the currently used IRQ in I<arg>."
msgstr "現在使われているIRQをI<arg>にいれる。"

#. type: IP
#: build/C/man4/lp.4:111
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPGETSTATUS, int *>I<arg>B<)>"
msgstr "B<int ioctl(int >I<fd>B<, LPGETSTATUS, int *>I<arg>B<)>"

#. type: Plain text
#: build/C/man4/lp.4:115
msgid ""
"Stores the value of the status port in I<arg>.  The bits have the following "
"meaning:"
msgstr ""
"ステータスポートの値をI<arg>に収める。各ビットには次のような意味が ある："

#. type: tbl table
#: build/C/man4/lp.4:117
#, no-wrap
msgid "LP_PBUSY"
msgstr "LP_PBUSY"

#. type: tbl table
#: build/C/man4/lp.4:117
#, no-wrap
msgid "inverted busy input, active high"
msgstr "ビジー信号の反転、ハイがアクティブ"

#. type: tbl table
#: build/C/man4/lp.4:118
#, no-wrap
msgid "LP_PACK"
msgstr "LP_PACK"

#. type: tbl table
#: build/C/man4/lp.4:118
#, no-wrap
msgid "unchanged acknowledge input, active low"
msgstr "アクノリッジ信号、ローがアクティブ"

#. type: tbl table
#: build/C/man4/lp.4:119
#, no-wrap
msgid "LP_POUTPA"
msgstr "LP_POUTPA"

#. type: tbl table
#: build/C/man4/lp.4:119
#, no-wrap
msgid "unchanged out-of-paper input, active high"
msgstr "紙切れ信号、ハイがアクティブ"

#. type: tbl table
#: build/C/man4/lp.4:120
#, no-wrap
msgid "LP_PSELECD"
msgstr "LP_PSELECD"

#. type: tbl table
#: build/C/man4/lp.4:120
#, no-wrap
msgid "unchanged selected input, active high"
msgstr "選択信号、ハイがアクティブ"

#. type: tbl table
#: build/C/man4/lp.4:121
#, no-wrap
msgid "LP_PERRORP"
msgstr "LP_PERRORP"

#. type: tbl table
#: build/C/man4/lp.4:121
#, no-wrap
msgid "unchanged error input, active low"
msgstr "エラー信号、ローがアクティブ"

#. type: Plain text
#: build/C/man4/lp.4:126
msgid ""
"Refer to your printer manual for the meaning of the signals.  Note that "
"undocumented bits may also be set, depending on your printer."
msgstr ""
"信号の意味については各自のプリンターのマニュアルを参照のこと。プリンター に"
"よっては記載のないビットもセットされるかもしれないので、注意のこと。"

#. type: IP
#: build/C/man4/lp.4:126
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, LPRESET)>"
msgstr "B<int ioctl(int >I<fd>B<, LPRESET)>"

#. type: Plain text
#: build/C/man4/lp.4:129
msgid "Resets the printer.  No argument is used."
msgstr "プリンターをリセットする。引数はとらない。"

#.  .SH AUTHORS
#.  The printer driver was originally written by Jim Weigand and Linus
#.  Torvalds.
#.  It was further improved by Michael K.\& Johnson.
#.  The interrupt code was written by Nigel Gamble.
#.  Alan Cox modularized it.
#.  LPCAREFUL, LPABORT, LPGETSTATUS were added by Chris Metcalf.
#. type: Plain text
#: build/C/man4/lp.4:138
msgid "I</dev/lp*>"
msgstr " I</dev/lp*>"

#. type: Plain text
#: build/C/man4/lp.4:144
msgid "B<chmod>(1), B<chown>(1), B<mknod>(1), B<lpcntl>(8), B<tunelp>(8)"
msgstr "B<chmod>(1), B<chown>(1), B<mknod>(1), B<lpcntl>(8), B<tunelp>(8)"

#. type: TH
#: build/C/man3/makedev.3:26
#, no-wrap
msgid "MAKEDEV"
msgstr "MAKEDEV"

#. type: TH
#: build/C/man3/makedev.3:26
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: build/C/man3/makedev.3:29
msgid "makedev, major, minor - manage a device number"
msgstr "makedev, major, minor - デバイス番号の操作"

#. type: Plain text
#: build/C/man3/makedev.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysmacros.hE<gt>>\n"
msgstr " B<#include E<lt>sys/sysmacros.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/makedev.3:34
#, no-wrap
msgid "B<dev_t makedev(unsigned int >I<maj>B<, unsigned int >I<min>B<);>\n"
msgstr "B<dev_t makedev(unsigned int >I<maj>B<, unsigned int >I<min>B<);>\n"

#. type: Plain text
#: build/C/man3/makedev.3:37
#, no-wrap
msgid ""
"B<unsigned int major(dev_t >I<dev>B<);>\n"
"B<unsigned int minor(dev_t >I<dev>B<);>\n"
msgstr ""
"B<unsigned int major(dev_t >I<dev>B<);>\n"
"B<unsigned int minor(dev_t >I<dev>B<);>\n"

#. type: Plain text
#: build/C/man3/makedev.3:44
msgid ""
"A device ID consists of two parts: a major ID, identifying the class of the "
"device, and a minor ID, identifying a specific instance of a device in that "
"class.  A device ID is represented using the type I<dev_t>."
msgstr ""
"デバイス ID は、メジャー ID とマイナー ID の二つの部分から構成される。\n"
"メジャー ID はデバイスクラスの識別に使用され、マイナー ID は\n"
"そのクラス内の特定のデバイスインスタンスの識別に使用される。\n"
"デバイス ID は I<dev_t> 型を用いて表現される。"

#. type: Plain text
#: build/C/man3/makedev.3:51
msgid ""
"Given major and minor device IDs, B<makedev>()  combines these to produce a "
"device ID, returned as the function result.  This device ID can be given to "
"B<mknod>(2), for example."
msgstr ""
"B<makedev>() は、指定されたメジャー ID とマイナー ID を組み合わせて\n"
"デバイス ID を生成し、関数の結果として返す。\n"
"このデバイス ID は B<mknod>(2) などに渡すことができる。"

#. type: Plain text
#: build/C/man3/makedev.3:61
msgid ""
"The B<major>()  and B<minor>()  functions perform the converse task: given a "
"device ID, they return, respectively, the major and minor components.  These "
"macros can be useful to, for example, decompose the device IDs in the "
"structure returned by B<stat>(2)."
msgstr ""
"関数 B<major>() と B<minor>() は B<makedev>() と反対の処理を行う。\n"
"つまり、device ID を渡すと、それぞれメジャー ID 部分とマイナー ID 部分\n"
"を返す。これらのマクロは、例えば、 B<stat>(2) が返す構造体に含まれる\n"
"デバイス ID を分解する場合などで役に立つ。"

#. type: tbl table
#: build/C/man3/makedev.3:73
#, no-wrap
msgid ""
"B<makedev>(),\n"
"B<major>(),\n"
"B<minor>()"
msgstr ""

#.  The BSDs, HP-UX, Solaris, AIX, Irix.
#.  The header location is inconsistent:
#.  Could be sys/mkdev.h, sys/sysmacros.h, or sys/types.h.
#. type: Plain text
#: build/C/man3/makedev.3:86
msgid ""
"The B<makedev>(), B<major>(), and B<minor>()  functions are not specified in "
"POSIX.1, but are present on many other systems."
msgstr ""
"関数 B<makedev>(), B<major>(), B<minor>() は\n"
"POSIX.1 では規定されていないが、他の多くのシステムにも存在する。"

#. type: Plain text
#: build/C/man3/makedev.3:95
msgid ""
"These interfaces are defined as macros.  Since glibc 2.3.3, they have been "
"aliases for three GNU-specific functions: B<gnu_dev_makedev>(), "
"B<gnu_dev_major>(), and B<gnu_dev_minor>().  The latter names are exported, "
"but the traditional names are more portable."
msgstr ""
"これらのインターフェースはマクロとして定義されている。\n"
"glibc 2.3.3 以降では、これらは GNU 固有の 3 つの関数\n"
"B<gnu_dev_makedev>(), B<gnu_dev_major>(), B<gnu_dev_minor>() の\n"
"エイリアス (別名) となっている。後者の名前がエクスポートされるが、\n"
"以前から使われている前者の名前の方が移植性がある。"

#.  glibc commit dbab6577c6684c62bd2521c1c29dc25c3cac966f
#.  glibc commit e16deca62e16f645213dffd4ecd1153c37765f17
#. type: Plain text
#: build/C/man3/makedev.3:107
msgid ""
"The BSDs expose the definitions for these macros via I<E<lt>sys/types."
"hE<gt>>.  Depending on the version, glibc also exposes definitions for these "
"macros from that header file if suitable feature test macros are defined.  "
"However, this behavior was deprecated in glibc 2.25, and since glibc 2.28, "
"I<E<lt>sys/types.hE<gt>> no longer provides these definitions."
msgstr ""

#. type: Plain text
#: build/C/man3/makedev.3:110
msgid "B<mknod>(2), B<stat>(2)"
msgstr "B<mknod>(2), B<stat>(2)"

#. type: TH
#: build/C/man4/mem.4:26
#, no-wrap
msgid "MEM"
msgstr "MEM"

#. type: TH
#: build/C/man4/mem.4:26
#, no-wrap
msgid "2015-01-02"
msgstr "2015-01-02"

#. type: Plain text
#: build/C/man4/mem.4:29
msgid "mem, kmem, port - system memory, kernel memory and system ports"
msgstr ""
"mem, kmem, port - システムメモリー(system memory)、カーネルメモリー (kernel "
"memory)、システムポート(sysmem ports)"

#. type: Plain text
#: build/C/man4/mem.4:34
msgid ""
"I</dev/mem> is a character device file that is an image of the main memory "
"of the computer.  It may be used, for example, to examine (and even patch) "
"the system."
msgstr "I</dev/mem> はコンピュータのメインメモリーイメージのキャラクターデバイスファイルである。このデバイスは、例えば、システムを 検査するため (また、パッチをあてるため) に使われるだろう。"

#. type: Plain text
#: build/C/man4/mem.4:39
msgid ""
"Byte addresses in I</dev/mem> are interpreted as physical memory addresses.  "
"References to nonexistent locations cause errors to be returned."
msgstr "I</dev/mem> のバイトアドレスは 物理メモリーアドレスとして解釈される。 存在していない場所への参照はエラーが返される。"

#. type: Plain text
#: build/C/man4/mem.4:42
msgid ""
"Examining and patching is likely to lead to unexpected results when read-"
"only or write-only bits are present."
msgstr ""
"読み込み専用(read-only)あるいは書き込み専用(write-only)のビットへの検 査ある"
"いはパッチ当ては予期せぬ結果をもたらすことがある。"

#. type: Plain text
#: build/C/man4/mem.4:49
msgid ""
"Since Linux 2.6.26, and depending on the architecture, the "
"B<CONFIG_STRICT_DEVMEM> kernel configuration option limits the areas which "
"can be accessed through this file.  For example: on x86, RAM access is not "
"allowed but accessing memory-mapped PCI regions is."
msgstr ""
"Linux 2.6.26 以降では、 アーキテクチャーによっては、 カーネル設定オプション "
"B<CONFIG_STRICT_DEVMEM> によりこのファイル経由でアクセスできる領域が制限され"
"る。 例えば、 x86 では、 RAM アクセスは許可されないが、メモリーマップ PCI 領"
"域へのアクセスは許可される。"

#. type: Plain text
#: build/C/man4/mem.4:51 build/C/man4/mem.4:70 build/C/man4/mem.4:84
#: build/C/man4/ram.4:35
msgid "It is typically created by:"
msgstr "典型的には次のようにして作られる。:"

#. type: Plain text
#: build/C/man4/mem.4:56
#, no-wrap
msgid ""
"mknod -m 660 /dev/mem c 1 1\n"
"chown root:kmem /dev/mem\n"
msgstr ""
" mknod -m 660 /dev/mem c 1 1\n"
"chown root:kmem /dev/mem\n"

#. type: Plain text
#: build/C/man4/mem.4:68
msgid ""
"The file I</dev/kmem> is the same as I</dev/mem>, except that the kernel "
"virtual memory rather than physical memory is accessed.  Since Linux 2.6.26, "
"this file is available only if the B<CONFIG_DEVKMEM> kernel configuration "
"option is enabled."
msgstr "I</dev/kmem> ファイルは I</dev/mem> と同じだが、 物理メモリーへのアクセスではなく、カーネルの仮想 メモリーへのアクセスである点が異なる。 Linux 2.6.26 以降では、 このファイルが利用できるのは、 カーネル設定オプション B<CONFIG_DEVKMEM> が有効になっている場合だけである。"

#. type: Plain text
#: build/C/man4/mem.4:75
#, no-wrap
msgid ""
"mknod -m 640 /dev/kmem c 1 2\n"
"chown root:kmem /dev/kmem\n"
msgstr ""
" mknod -m 640 /dev/kmem c 1 2\n"
"chown root:kmem /dev/kmem\n"

#. type: Plain text
#: build/C/man4/mem.4:82
msgid "I</dev/port> is similar to I</dev/mem>, but the I/O ports are accessed."
msgstr "I</dev/port> は I</dev/mem> に似ているが I/O ポート(I/O ports)へのアクセスが行われる。"

#. type: Plain text
#: build/C/man4/mem.4:89
#, no-wrap
msgid ""
"mknod -m 660 /dev/port c 1 4\n"
"chown root:kmem /dev/port\n"
msgstr ""
" mknod -m 660 /dev/port c 1 4\n"
"chown root:kmem /dev/port\n"

#. type: Plain text
#: build/C/man4/mem.4:93
msgid "I</dev/mem>"
msgstr "I</dev/mem>"

#. type: Plain text
#: build/C/man4/mem.4:95
msgid "I</dev/kmem>"
msgstr "I</dev/kmem>"

#. type: Plain text
#: build/C/man4/mem.4:97
msgid "I</dev/port>"
msgstr "I</dev/port>"

#. type: Plain text
#: build/C/man4/mem.4:101
msgid "B<chown>(1), B<mknod>(1), B<ioperm>(2)"
msgstr "B<chown>(1), B<mknod>(1), B<ioperm>(2)"

#. type: TH
#: build/C/man3/mkfifo.3:28
#, no-wrap
msgid "MKFIFO"
msgstr "MKFIFO"

#. type: TH
#: build/C/man3/mkfifo.3:28
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/mkfifo.3:31
msgid "mkfifo, mkfifoat - make a FIFO special file (a named pipe)"
msgstr "mkfifo, mkfifoat - FIFOスペシャルファイル(名前付きパイプ)を作成する"

#. type: Plain text
#: build/C/man3/mkfifo.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mkfifo.3:37
#, no-wrap
msgid "B<int mkfifo(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkfifo(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/mkfifo.3:40 build/C/man2/mknod.2:29
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mkfifo.3:42
#, no-wrap
msgid "B<int mkfifoat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkfifoat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/mkfifo.3:47 build/C/man2/mknod.2:37 build/C/man3/syslog.3:54
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/mkfifo.3:50
msgid "B<mkfifoat>():"
msgstr "B<mkfifoat>():"

#. type: TP
#: build/C/man3/mkfifo.3:53
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/mkfifo.3:56
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr " _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man3/mkfifo.3:56
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/mkfifo.3:59
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: build/C/man3/mkfifo.3:69
msgid ""
"B<mkfifo>()  makes a FIFO special file with name I<pathname>.  I<mode> "
"specifies the FIFO's permissions.  It is modified by the process's B<umask> "
"in the usual way: the permissions of the created file are B<(>I<mode>B< & "
"\\(tiumask)>."
msgstr "B<mkfifo>()  は名前 I<pathname> を持つFIFOスペシャルファイルを作成 する。FIFOの許可モードは I<mode> で指定され、プロセスの B<umask> によって通常の方式で変更を受ける: 作成されたファイルの許可 モードは B<(>I<mode>B< & \\(tiumask)> となる。"

#. type: Plain text
#: build/C/man3/mkfifo.3:76
msgid ""
"A FIFO special file is similar to a pipe, except that it is created in a "
"different way.  Instead of being an anonymous communications channel, a FIFO "
"special file is entered into the filesystem by calling B<mkfifo>()."
msgstr ""
"FIFOスペシャルファイルはパイプに似ているが、作成のされ方のみが異なって いる。"
"FIFOスペシャルファイルは名前のない通信路ではなく、 B<mkfifo>()  の呼び出しに"
"よりファイルシステムの中に加えられる。"

#. type: Plain text
#: build/C/man3/mkfifo.3:86
msgid ""
"Once you have created a FIFO special file in this way, any process can open "
"it for reading or writing, in the same way as an ordinary file.  However, it "
"has to be open at both ends simultaneously before you can proceed to do any "
"input or output operations on it.  Opening a FIFO for reading normally "
"blocks until some other process opens the same FIFO for writing, and vice "
"versa.  See B<fifo>(7)  for nonblocking handling of FIFO special files."
msgstr ""
"ひとたびこのようにしてFIFOスペシャルファイルが作成されると、通常のファ イルと"
"同じように、どのプロセスからでも読み出し、書き込み用にこれをオー プンすること"
"ができる。ただし、これに対する全ての入出力操作に先立って その両端がオープンさ"
"れている必要がある。FIFOを読み出し用にオープンする と、通常他のプロセスによっ"
"て同じFIFOが書き込み用にオープンされるまでブ ロックされ、逆の場合も同様であ"
"る。 FIFOスペシャルファイルをブロックせずに扱う方法については B<fifo>(7)  を"
"参照のこと。"

#. type: SS
#: build/C/man3/mkfifo.3:86
#, no-wrap
msgid "mkfifoat()"
msgstr "mkfifoat()"

#. type: Plain text
#: build/C/man3/mkfifo.3:92
msgid ""
"The B<mkfifoat>()  function operates in exactly the same way as B<mkfifo>(), "
"except for the differences described here."
msgstr ""
"B<mkfifoat>() システムコールは B<mkfifo>() と全く同様に動作するが、以下で説明"
"する点が異なる。"

#. type: Plain text
#: build/C/man3/mkfifo.3:102
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkfifo>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<mkfifo>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man3/mkfifo.3:114
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mkfifo>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<mkfifo>() と同様に) I<pathname> は呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man3/mkfifo.3:120 build/C/man2/mknod.2:148
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""
"I<pathname> で指定されたパス名が絶対パスの場合、 I<dirfd> は無視される。"

#. type: SH
#: build/C/man3/mkfifo.3:120 build/C/man2/mknod.2:153
#: build/C/man3/setlogmask.3:69 build/C/man4/st.4:840 build/C/man2/syslog.2:318
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/mkfifo.3:128
msgid ""
"On success B<mkfifo>()  and B<mkfifoat>()  return 0.  In the case of an "
"error, -1 is returned (in which case, I<errno> is set appropriately)."
msgstr ""
"成功した場合 B<mkfifo>() と B<mkfifoat>() は 0 を返す。 エラーの場合 -1 を返"
"す (また I<errno> が適切に設定される)。"

#. type: SH
#: build/C/man3/mkfifo.3:128 build/C/man2/mknod.2:160
#: build/C/man3/setlogmask.3:71 build/C/man2/syslog.2:334
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/mkfifo.3:129 build/C/man2/mknod.2:161 build/C/man4/st.4:841
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/mkfifo.3:133
msgid ""
"One of the directories in I<pathname> did not allow search (execute) "
"permission."
msgstr "I<pathname> の中のディレクトリの一つに対し検索(実行)許可がない。"

#. type: TP
#: build/C/man3/mkfifo.3:133 build/C/man2/mknod.2:169
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man3/mkfifo.3:137 build/C/man2/mknod.2:173
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr ""
"ディスクブロックか inode がそのファイルシステムのユーザークォータに達してい"
"た。"

#. type: TP
#: build/C/man3/mkfifo.3:137 build/C/man2/mknod.2:173
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man3/mkfifo.3:143 build/C/man2/mknod.2:180
msgid ""
"I<pathname> already exists.  This includes the case where I<pathname> is a "
"symbolic link, dangling or not."
msgstr ""
"I<pathname> がすでに存在する。 これには I<pathname> がシンボリックリンクであ"
"る場合も含まれる (シンボリックリンクがリンク切れか (dangling) どうかは関係な"
"い)。"

#. type: TP
#: build/C/man3/mkfifo.3:143 build/C/man2/mknod.2:192
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/mkfifo.3:151
msgid ""
"Either the total length of I<pathname> is greater than B<PATH_MAX>, or an "
"individual filename component has a length greater than B<NAME_MAX>.  In the "
"GNU system, there is no imposed limit on overall filename length, but some "
"filesystems may place limits on the length of a component."
msgstr ""
"I<pathname> の長さが B<PATH_MAX> を超えているか、個々のファイル 名部分の長さ"
"が B<NAME_MAX> を超えている。GNUシステムにおいては、ファ イル名の全体の長さに"
"対しては制限は課せられていないが、ファイルシステム によっては各部分の長さに制"
"限のある可能性がある。"

#. type: TP
#: build/C/man3/mkfifo.3:151 build/C/man2/mknod.2:195
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/mkfifo.3:155 build/C/man2/mknod.2:200
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> 中のディレクトリ部分が存在しない、 もしくはリンク先の無いシンボ"
"リックリンクである。"

#. type: TP
#: build/C/man3/mkfifo.3:155 build/C/man2/mknod.2:203 build/C/man4/st.4:870
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man3/mkfifo.3:158
msgid "The directory or filesystem has no room for the new file."
msgstr "ディレクトリまたはファイルシステムに新規ファイルを作成する余地がない。"

#. type: TP
#: build/C/man3/mkfifo.3:158 build/C/man3/mkfifo.3:172 build/C/man2/mknod.2:208
#: build/C/man2/mknod.2:238
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man3/mkfifo.3:162 build/C/man2/mknod.2:213
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "I<pathname> 中のディレクトリ要素が、実際にはディレクトリでない。"

#. type: TP
#: build/C/man3/mkfifo.3:162 build/C/man2/mknod.2:227 build/C/man4/st.4:885
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man3/mkfifo.3:165
msgid "I<pathname> refers to a read-only filesystem."
msgstr "I<pathname> が読み取り専用のファイルシステムを指している。"

#. type: Plain text
#: build/C/man3/mkfifo.3:168
msgid "The following additional errors can occur for B<mkfifoat>():"
msgstr "B<mkfifoat>() では以下のエラーも発生する。"

#. type: TP
#: build/C/man3/mkfifo.3:168 build/C/man2/mknod.2:234
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man3/mkfifo.3:172 build/C/man2/mknod.2:238
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man3/mkfifo.3:178
msgid ""
"I<pathname> is a relative path and I<dirfd> is a file descriptor referring "
"to a file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: Plain text
#: build/C/man3/mkfifo.3:184
msgid ""
"B<mkfifoat>()  was added to glibc in version 2.4.  It is implemented using "
"B<mknodat>(2), available on Linux since kernel 2.6.16."
msgstr ""
"B<mkfifoat>() は glibc 2.4 で追加された。これは、カーネル 2.6.16 以降の "
"Linux で利用できる B<mknodat>(2) を使って実装されている。"

#. type: tbl table
#: build/C/man3/mkfifo.3:195
#, no-wrap
msgid ""
"B<mkfifo>(),\n"
"B<mkfifoat>()"
msgstr ""
" B<mkfifo>(),\n"
"B<mkfifoat>()"

#. type: Plain text
#: build/C/man3/mkfifo.3:200
msgid "B<mkfifo>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<mkfifo>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/mkfifo.3:203
msgid "B<mkfifoat>(): POSIX.1-2008."
msgstr "B<mkfifoat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man3/mkfifo.3:212
msgid ""
"B<mkfifo>(1), B<close>(2), B<open>(2), B<read>(2), B<stat>(2), B<umask>(2), "
"B<write>(2), B<fifo>(7)"
msgstr ""
"B<mkfifo>(1), B<close>(2), B<open>(2), B<read>(2), B<stat>(2), B<umask>(2), "
"B<write>(2), B<fifo>(7)"

#. type: TH
#: build/C/man2/mknod.2:15
#, no-wrap
msgid "MKNOD"
msgstr "MKNOD"

#. type: Plain text
#: build/C/man2/mknod.2:18
msgid "mknod, mknodat - create a special or ordinary file"
msgstr "mknod, mknodat - 特殊ファイルや通常のファイルを作成する"

#. type: Plain text
#: build/C/man2/mknod.2:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mknod.2:26
#, no-wrap
msgid "B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"
msgstr "B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"

#. type: Plain text
#: build/C/man2/mknod.2:32
#, no-wrap
msgid "B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"
msgstr "B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"

#. type: Plain text
#: build/C/man2/mknod.2:40
msgid "B<mknod>():"
msgstr "B<mknod>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: build/C/man2/mknod.2:46
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mknod.2:58
msgid ""
"The system call B<mknod>()  creates a filesystem node (file, device special "
"file, or named pipe) named I<pathname>, with attributes specified by I<mode> "
"and I<dev>."
msgstr ""
"システムコール B<mknod>()  は I<pathname> という名前のファイルシステムノード "
"(ファイル、デバイススペシャルファイル、名前付きパイプ) を、 属性 I<mode> と "
"I<dev> の指定にしたがって作成する。"

#. type: Plain text
#: build/C/man2/mknod.2:66
#, fuzzy
#| msgid ""
#| "The I<mode> argument specifies both the permissions to use and the type "
#| "of node to be created.  It should be a combination (using bitwise OR) of "
#| "one of the file types listed below and the permissions for the new node."
msgid ""
"The I<mode> argument specifies both the file mode to use and the type of "
"node to be created.  It should be a combination (using bitwise OR) of one of "
"the file types listed below and zero or more of the file mode bits listed in "
"B<inode>(7)."
msgstr ""
"I<mode> 引数には、作成するノードの許可属性 (permission) とタイプを指定す"
"る。 I<mode> の指定は以下にあげるファイルタイプのうちの 1 つと、 許可属性の組"
"合せ (ビットごとの OR を使用) で行う。"

#. type: Plain text
#: build/C/man2/mknod.2:72
#, fuzzy
#| msgid ""
#| "The permissions are modified by the process's I<umask> in the usual way: "
#| "the permissions of the created node are I<(mode & ~umask)>."
msgid ""
"The file mode is modified by the process's I<umask> in the usual way: in the "
"absence of a default ACL, the permissions of the created node are (I<mode> & "
"\\(tiI<umask>)."
msgstr ""
"許可属性は通常通り、プロセスの I<umask> によって修正され、作成されたノードの"
"許可属性は I<(mode & ~umask)> となる。"

#.  (S_IFSOCK since Linux 1.2.4)
#. type: Plain text
#: build/C/man2/mknod.2:86
msgid ""
"The file type must be one of B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO>, "
"or B<S_IFSOCK> to specify a regular file (which will be created empty), "
"character special file, block special file, FIFO (named pipe), or UNIX "
"domain socket, respectively.  (Zero file type is equivalent to type "
"B<S_IFREG>.)"
msgstr ""
"ファイルタイプには B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO>, "
"B<S_IFSOCK> のいずれかを指定しなければならない。 それぞれ順に、通常のファイ"
"ル (空のファイルとして作成される)・ キャラクタースペシャルファイル・ブロック"
"スペシャルファイル・ FIFO (名前付きパイプ)・UNIX ドメインソケットである (ファ"
"イルタイプ 0 は B<S_IFREG> と同じである)。"

#. type: Plain text
#: build/C/man2/mknod.2:99
msgid ""
"If the file type is B<S_IFCHR> or B<S_IFBLK>, then I<dev> specifies the "
"major and minor numbers of the newly created device special file "
"(B<makedev>(3)  may be useful to build the value for I<dev>); otherwise it "
"is ignored."
msgstr ""
"ファイルタイプが B<S_IFCHR> または B<S_IFBLK> のとき、 I<dev> には作成するデ"
"バイススペシャルファイルのメジャー番号と マイナー番号を指定する "
"(B<makedev>(3)  は I<dev> のこれらの番号を作成する際に役立つだろう)。 それ以"
"外の場合は I<dev> は無視される。"

#. type: Plain text
#: build/C/man2/mknod.2:105
msgid ""
"If I<pathname> already exists, or is a symbolic link, this call fails with "
"an B<EEXIST> error."
msgstr ""
"I<pathname> が既に存在する場合、またはシンボリックリンクの場合、 この呼び出し"
"は B<EEXIST> エラーで失敗する。"

#. type: Plain text
#: build/C/man2/mknod.2:114
msgid ""
"The newly created node will be owned by the effective user ID of the "
"process.  If the directory containing the node has the set-group-ID bit set, "
"or if the filesystem is mounted with BSD group semantics, the new node will "
"inherit the group ownership from its parent directory; otherwise it will be "
"owned by the effective group ID of the process."
msgstr ""
"新しく作成されたノードの所有者はプロセスの実効ユーザー ID にセットされる。 新"
"たに作られたノードを保持する 親ディレクトリの set-group-ID ビットがセットされ"
"ていたり、 ファイルシステムが BSD のグループセマンティクスにしたがって マウン"
"トされている場合には、新しいノードのグループ所有権は親ディレクトリの グループ"
"所有権を継承する (親ディレクトリと同じになる)。 また、そうでなかった場合の所"
"有グループはプロセスの実効グループ ID となる。"

#. type: SS
#: build/C/man2/mknod.2:114
#, no-wrap
msgid "mknodat()"
msgstr "mknodat()"

#. type: Plain text
#: build/C/man2/mknod.2:120
msgid ""
"The B<mknodat>()  system call operates in exactly the same way as "
"B<mknod>(), except for the differences described here."
msgstr ""
"B<mknodat>() システムコールは B<mknod>() と全く同様に動作するが、以下で説明す"
"る点が異なる。"

#. type: Plain text
#: build/C/man2/mknod.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mknod>()  for a relative pathname)."
msgstr ""
"I<pathname> で指定されたパス名が相対パスの場合、このパス名はファイルディスク"
"リプター I<dirfd> が参照するディレクトリに対する相対パスと解釈される "
"(B<mknod>() に相対パス名を渡した場合のように、呼び出したプロセスのカレント"
"ワーキングディレクトリに対する相対パスではない)。"

#. type: Plain text
#: build/C/man2/mknod.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mknod>())."
msgstr ""
"I<pathname> で指定されたパス名が相対パスで、 I<dirfd> が特別な値 B<AT_FDCWD> "
"の場合、 (B<mknod>() と同様に) I<pathname> は呼び出したプロセスのカレントワー"
"キングディレクトリに対する相対パスと解釈される。"

#. type: Plain text
#: build/C/man2/mknod.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<mknodat>()."
msgstr "B<mknodat>() の必要性についての説明については B<openat>(2) を参照。"

#. type: Plain text
#: build/C/man2/mknod.2:160
msgid ""
"B<mknod>()  and B<mknodat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""
"B<mknod>() と B<mknodat>() は成功した場合 0 を、失敗した場合 -1 を返す (失敗"
"した場合 I<errno> がエラーの内容にしたがってセットされる)。"

#. type: Plain text
#: build/C/man2/mknod.2:169
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""
"プロセスが親ディレクトリへの書き込み許可を持たない。 もしくはパス名 "
"I<pathname> 中のディレクトリ部分のどれかに検索許可属性が無い "
"(B<path_resolution>(7)  も参照すること)。"

#. type: TP
#: build/C/man2/mknod.2:180 build/C/man4/st.4:850
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/mknod.2:183
msgid "I<pathname> points outside your accessible address space."
msgstr ""
"I<pathname> がそのプロセスのアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/mknod.2:183 build/C/man4/st.4:854 build/C/man2/syslog.2:335
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/mknod.2:188
msgid ""
"I<mode> requested creation of something other than a regular file, device "
"special file, FIFO or socket."
msgstr ""
"I<mode> が通常のファイル・デバイススペシャルファイル・FIFO・ソケット以外を 作"
"成するようにセットされている。"

#. type: TP
#: build/C/man2/mknod.2:188
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/mknod.2:192
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""
"パス名 I<pathname> を解決するときに、含まれているシンボリックリンクが多すぎ"
"た。"

#. type: Plain text
#: build/C/man2/mknod.2:195
msgid "I<pathname> was too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/mknod.2:200 build/C/man4/st.4:862
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mknod.2:203
msgid "Insufficient kernel memory was available."
msgstr "十分なカーネルメモリーが無い。"

#. type: Plain text
#: build/C/man2/mknod.2:208
msgid "The device containing I<pathname> has no room for the new node."
msgstr "I<pathname> のあるデバイスに新たにノードを作成する空きが無い。"

#. type: TP
#: build/C/man2/mknod.2:213 build/C/man2/syslog.2:359
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  For UNIX domain sockets and regular files, EPERM is returned only in
#.  Linux 2.2 and earlier; in Linux 2.4 and later, unprivileged can
#.  use mknod() to make these files.
#. type: Plain text
#: build/C/man2/mknod.2:227
msgid ""
"I<mode> requested creation of something other than a regular file, FIFO "
"(named pipe), or UNIX domain socket, and the caller is not privileged "
"(Linux: does not have the B<CAP_MKNOD> capability); also returned if the "
"filesystem containing I<pathname> does not support the type of node "
"requested."
msgstr ""
"I<mode> は通常のファイル・FIFO (名前付きパイプ)・UNIX ドメインソケット以外を "
"作成するようにセットされているが、実行者が特権 (Linux では B<CAP_MKNOD> ケー"
"パビリティ (capability)) を持っていない。 または I<pathname> を保持するファイ"
"ルシステムが、指定されたノード形式をサポートしていない。"

#. type: Plain text
#: build/C/man2/mknod.2:231
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr "I<pathname> が読み出し専用ファイルシステム上のファイルを指している。"

#. type: Plain text
#: build/C/man2/mknod.2:234
msgid "The following additional errors can occur for B<mknodat>():"
msgstr "B<mknodat>() では以下のエラーも発生する。"

#. type: Plain text
#: build/C/man2/mknod.2:244
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"I<pathname> が相対パスで、 I<dirfd> がディレクトリ以外のファイルを参照してい"
"るファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/mknod.2:248
msgid ""
"B<mknodat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<mknodat>()  はカーネル 2.6.16 で Linux に追加された。 ライブラリによるサ"
"ポートはバージョン 2.4 で glibc に追加された。"

#.  The Linux version differs from the SVr4 version in that it
#.  does not require root permission to create pipes, also in that no
#.  EMULTIHOP, ENOLINK, or EINTR error is documented.
#. type: Plain text
#: build/C/man2/mknod.2:254
msgid "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (but see below), POSIX.1-2008."
msgstr "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (下記も参照), POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mknod.2:257
msgid "B<mknodat>(): POSIX.1-2008."
msgstr "B<mknodat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mknod.2:275
msgid ""
"POSIX.1-2001 says: \"The only portable use of B<mknod>()  is to create a "
"FIFO-special file.  If I<mode> is not B<S_IFIFO> or I<dev> is not 0, the "
"behavior of B<mknod>()  is unspecified.\" However, nowadays one should never "
"use B<mknod>()  for this purpose; one should use B<mkfifo>(3), a function "
"especially defined for this purpose."
msgstr ""
"POSIX.1-2001 では次のように書いている： 「B<mknod>()  の唯一の移植性のある使"
"用法は、FIFO スペシャルファイルを作成することである。 I<mode> が B<S_IFIFO> "
"ではない場合、または I<dev> が 0 ではない場合、 B<mknod>()  の挙動は規定され"
"ていない。」 しかしながら、現在ではこの目的のために B<mknod>()  を使用すべき"
"ではない。この目的のために特別に定義された関数である B<mkfifo>()  を使用すべ"
"きである。"

#.  and one should make UNIX domain sockets with socket(2) and bind(2).
#. type: Plain text
#: build/C/man2/mknod.2:282
msgid ""
"Under Linux, B<mknod>()  cannot be used to create directories.  One should "
"make directories with B<mkdir>(2)."
msgstr ""
"Linux では、ディレクトリを作成するために B<mknod>() を使用することはできな"
"い。 ディレクトリは B<mkdir>(2)  で作成すべきである。"

#. type: Plain text
#: build/C/man2/mknod.2:288
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mknod>()  and B<mknodat>()."
msgstr ""
"NFS を実現しているプロトコルには多くの不備が存在し、 それらのいくつかは "
"B<mknod>() と B<mknodat>() に影響を与える。"

#. type: Plain text
#: build/C/man2/mknod.2:303
msgid ""
"B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), "
"B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), "
"B<makedev>(3), B<mkfifo>(3), B<acl>(5), B<path_resolution>(7)"
msgstr " B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<makedev>(3), B<mkfifo>(3), B<acl>(5), B<path_resolution>(7)"

#. type: TH
#: build/C/man4/mouse.4:25
#, no-wrap
msgid "MOUSE"
msgstr "MOUSE"

#. type: Plain text
#: build/C/man4/mouse.4:28
msgid "mouse - serial mouse interface"
msgstr "mouse - シリアルマウスインターフェース"

#. type: Plain text
#: build/C/man4/mouse.4:32
msgid ""
"Serial mice are connected to a serial RS232/V24 dialout line, see "
"B<ttyS>(4)  for a description."
msgstr ""
"シリアルマウスは RS232/V24 ダイアルアウトラインに接続される。 RS232/V24 ダイ"
"アルアウトライン については B<ttyS>(4)  を参照のこと。"

#. type: SS
#: build/C/man4/mouse.4:33
#, no-wrap
msgid "Introduction"
msgstr "概説"

#. type: Plain text
#: build/C/man4/mouse.4:35
msgid "The pinout of the usual 9 pin plug as used for serial mice is:"
msgstr "シリアルマウスで使われる普通の 9 ピンプラグのピン配列は以下である:"

#. type: tbl table
#: build/C/man4/mouse.4:39
#, no-wrap
msgid "pin"
msgstr "pin"

#. type: tbl table
#: build/C/man4/mouse.4:39
#, no-wrap
msgid "name"
msgstr "name"

#. type: tbl table
#: build/C/man4/mouse.4:39
#, no-wrap
msgid "used for"
msgstr "used for"

#. type: tbl table
#: build/C/man4/mouse.4:40
#, no-wrap
msgid "RX"
msgstr "RX"

#. type: tbl table
#: build/C/man4/mouse.4:40
#, no-wrap
msgid "Data"
msgstr "Data"

#. type: tbl table
#: build/C/man4/mouse.4:41 build/C/man4/mouse.4:101 build/C/man4/mouse.4:146
#: build/C/man4/mouse.4:182 build/C/man2/syslog.2:306
#, no-wrap
msgid "3"
msgstr "3"

#. type: tbl table
#: build/C/man4/mouse.4:41
#, no-wrap
msgid "TX"
msgstr "TX"

#. type: tbl table
#: build/C/man4/mouse.4:41
#, no-wrap
msgid "-12 V, Imax = 10 mA"
msgstr "-12 V, Imax = 10 mA"

#. type: tbl table
#: build/C/man4/mouse.4:42
#, no-wrap
msgid "DTR"
msgstr "DTR"

#. type: tbl table
#: build/C/man4/mouse.4:42 build/C/man4/mouse.4:43
#, no-wrap
msgid "+12 V, Imax = 10 mA"
msgstr "+12 V, Imax = 10 mA"

#. type: tbl table
#: build/C/man4/mouse.4:43
#, no-wrap
msgid "RTS"
msgstr "RTS"

#. type: tbl table
#: build/C/man4/mouse.4:44
#, no-wrap
msgid "GND"
msgstr "GND"

#. type: tbl table
#: build/C/man4/mouse.4:44
#, no-wrap
msgid "Ground"
msgstr "Ground"

#. type: Plain text
#: build/C/man4/mouse.4:48
msgid "This is the specification, in fact 9 V suffices with most mice."
msgstr "これは仕様書であり、実際はほとんどのマウスでは 9 V で十分である。"

#. type: Plain text
#: build/C/man4/mouse.4:54
msgid ""
"The mouse driver can recognize a mouse by dropping RTS to low and raising it "
"again.  About 14 ms later the mouse will send 0x4D (\\(aqM\\(aq) on the data "
"line.  After a further 63 ms, a Microsoft-compatible 3-button mouse will "
"send 0x33 (\\(aq3\\(aq)."
msgstr ""
"マウスドライバは RTS をロー(low)に落し、再び上げることによって、マウスを認識"
"でき る。およそ 14 ms 後、マウスはデータライン上に 0x4D (\\(aqM\\(aq) を送る"
"だろう。さら に 63ms あと、マイクロソフト互換 3ボタンマウスは 0x33 "
"(\\(aq3\\(aq) を送る。"

#. type: Plain text
#: build/C/man4/mouse.4:66
msgid ""
"The relative mouse movement is sent as I<dx> (positive means right)  and "
"I<dy> (positive means down).  Various mice can operate at different speeds.  "
"To select speeds, cycle through the speeds 9600, 4800, 2400, and 1200 bit/s, "
"each time writing the two characters from the table below and waiting 0.1 "
"seconds.  The following table shows available speeds and the strings that "
"select them:"
msgstr ""
"マウスの相対的な移動は、I<dx>(正が右)とI<dy>(正が下)として伝えられる。 各種の"
"マウスは異なったスピードで操作できる。スピードを選択するには、 下の表の２文字"
"を送ってから 0.1 秒待つことで、9600, 4800, 2400, 1200 bit/s を順に選べる。 以"
"下の表では選択可能なスピードとそれを選択するための文字列を示している。"

#. type: tbl table
#: build/C/man4/mouse.4:70
#, no-wrap
msgid "bit/s"
msgstr "bit/s"

#. type: tbl table
#: build/C/man4/mouse.4:70
#, no-wrap
msgid "string"
msgstr "string"

#. type: tbl table
#: build/C/man4/mouse.4:71
#, no-wrap
msgid "9600"
msgstr "9600"

#. type: tbl table
#: build/C/man4/mouse.4:71
#, no-wrap
msgid "*q"
msgstr "*q"

#. type: tbl table
#: build/C/man4/mouse.4:72
#, no-wrap
msgid "4800"
msgstr "4800"

#. type: tbl table
#: build/C/man4/mouse.4:72
#, no-wrap
msgid "*p"
msgstr "*p"

#. type: tbl table
#: build/C/man4/mouse.4:73
#, no-wrap
msgid "2400"
msgstr "2400"

#. type: tbl table
#: build/C/man4/mouse.4:73
#, no-wrap
msgid "*o"
msgstr "*o"

#. type: tbl table
#: build/C/man4/mouse.4:74
#, no-wrap
msgid "*n"
msgstr "*n"

#. type: Plain text
#: build/C/man4/mouse.4:78
msgid ""
"The first byte of a data packet can be used for synchronization purposes."
msgstr "データパケットの第 1 バイトは同期をとるのに利用できる。"

#. type: SS
#: build/C/man4/mouse.4:78
#, no-wrap
msgid "Microsoft protocol"
msgstr "マイクロソフト プロトコル(Microsoft Protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:94
msgid ""
"The B<Microsoft> protocol uses 1 start bit, 7 data bits, no parity and one "
"stop bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte "
"packets.  The I<dx> and I<dy> movements are sent as two's-complement, I<lb> "
"(I<rb>)  are set when the left (right)  button is pressed:"
msgstr ""
"B<マイクロソフト>プロトコルは、1200 bits/sec のスピードで、1 ス タートビット"
"(1 start bit)、7 データビット(7 data bits)、パリティな し、1 ストップビット"
"(1 stop bit)である。 データは RxD に 3 バイトのパケットとして送られる。I<dx> "
"と I<dy> の動きは 2 の補数表示で送られ、左(右)のボタンが押された時には I<lb> "
"(I<rb>)がセットされる。"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "byte"
msgstr "byte"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d6"
msgstr "d6"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d5"
msgstr "d5"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d4"
msgstr "d4"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d3"
msgstr "d3"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d2"
msgstr "d2"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d1"
msgstr "d1"

#. type: tbl table
#: build/C/man4/mouse.4:98 build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d0"
msgstr "d0"

#. type: tbl table
#: build/C/man4/mouse.4:99 build/C/man4/mouse.4:144 build/C/man4/mouse.4:180
#, no-wrap
msgid "lb"
msgstr "lb"

#. type: tbl table
#: build/C/man4/mouse.4:99 build/C/man4/mouse.4:144 build/C/man4/mouse.4:180
#, no-wrap
msgid "rb"
msgstr "rb"

#. type: tbl table
#: build/C/man4/mouse.4:99
#, no-wrap
msgid "dy7"
msgstr "dy7"

#. type: tbl table
#: build/C/man4/mouse.4:99 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy6"
msgstr "dy6"

#. type: tbl table
#: build/C/man4/mouse.4:99
#, no-wrap
msgid "dx7"
msgstr "dx7"

#. type: tbl table
#: build/C/man4/mouse.4:99 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx6"
msgstr "dx6"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx5"
msgstr "dx5"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx4"
msgstr "dx4"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx3"
msgstr "dx3"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx2"
msgstr "dx2"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx1"
msgstr "dx1"

#. type: tbl table
#: build/C/man4/mouse.4:100 build/C/man4/mouse.4:181
#, no-wrap
msgid "dx0"
msgstr "dx0"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy5"
msgstr "dy5"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy4"
msgstr "dy4"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy3"
msgstr "dy3"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy2"
msgstr "dy2"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy1"
msgstr "dy1"

#. type: tbl table
#: build/C/man4/mouse.4:101 build/C/man4/mouse.4:182
#, no-wrap
msgid "dy0"
msgstr "dy0"

#. type: SS
#: build/C/man4/mouse.4:103
#, no-wrap
msgid "3-button Microsoft protocol"
msgstr "3つボタン マイクロソフト プロトコル(3-button Microsoft protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:112
msgid ""
"Original Microsoft mice only have two buttons.  However, there are some "
"three button mice which also use the Microsoft protocol.  Pressing or "
"releasing the middle button is reported by sending a packet with zero "
"movement and no buttons pressed.  (Thus, unlike for the other two buttons, "
"the status of the middle button is not reported in each packet.)"
msgstr ""
"本来のマイクロソフトマウスは 2 つのボタンしか持たない。しかし、3 つボタン の"
"マウスでマイクロソフトプロトコルの物も存在する。真中のボタンを押す、 または放"
"すということは、動きゼロでボタンが押されていないというパケット を送ることで伝"
"えられる。(従って他の二つのボタンと違い、真中のボタ ンのステータスは、それぞ"
"れのパケットからは伝わって来ない。)"

#. type: SS
#: build/C/man4/mouse.4:112
#, no-wrap
msgid "Logitech protocol"
msgstr "ロジテック プロトコル(Logitech protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:121
msgid ""
"Logitech serial 3-button mice use a different extension of the Microsoft "
"protocol: when the middle button is up, the above 3-byte packet is sent.  "
"When the middle button is down a 4-byte packet is sent, where the 4th byte "
"has value 0x20 (or at least has the 0x20 bit set).  In particular, a press "
"of the middle button is reported as 0,0,0,0x20 when no other buttons are "
"down."
msgstr ""
"ロジテック シリアル 3つボタンマウスは、マイクロソフト プロトコルとは 異なった"
"拡張をしている。:真中のボタンが押されてないと、上記 3バイトの パケットが送ら"
"れる。真中のボタンが押されていると、4バイトのパケットが 送られる。第４バイト"
"は 0x20 の値を持っている(あるいは、少なくとも 0x20 ビットがセットされてい"
"る)。 但し、他のボタンが押されていない状態で、 真中のボタンが押されると、"
"0,0,0,0x20 と伝えられる。"

#. type: SS
#: build/C/man4/mouse.4:121
#, no-wrap
msgid "Mousesystems protocol"
msgstr "マウスシステムズ プロトコル(Mousesystems protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:139
msgid ""
"The B<Mousesystems> protocol uses 1 start bit, 8 data bits, no parity and "
"two stop bits at the speed of 1200 bits/sec.  Data is sent to RxD in 5-byte "
"packets.  I<dx> is sent as the sum of the two two's-complement values, I<dy> "
"is send as negated sum of the two two's-complement values.  I<lb> (I<mb>, "
"I<rb>)  are cleared when the left (middle, right) button is pressed:"
msgstr ""
"B<マウスシステムズ>プロトコルは、1200 bits/secで、1 スタートビット、 8 データ"
"ビット、パリティなし、2 ストップビットである。 データは、RxD に 5 バイトのパ"
"ケットとして送られる。I<dx> は 2 つの 2 の補数の和として送られ、I<dy> は 2 つ"
"の 2 の補数の和の否定 として送られる。左(中、右)のボタンが押された時には"
"I<lb> (I<mb>, I<rb>) がクリアされる。"

#. type: tbl table
#: build/C/man4/mouse.4:143 build/C/man4/mouse.4:179
#, no-wrap
msgid "d7"
msgstr "d7"

#. type: tbl table
#: build/C/man4/mouse.4:144 build/C/man4/mouse.4:180
#, no-wrap
msgid "mb"
msgstr "mb"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa6"
msgstr "dxa6"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa5"
msgstr "dxa5"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa4"
msgstr "dxa4"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa3"
msgstr "dxa3"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa2"
msgstr "dxa2"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa1"
msgstr "dxa1"

#. type: tbl table
#: build/C/man4/mouse.4:145
#, no-wrap
msgid "dxa0"
msgstr "dxa0"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya6"
msgstr "dya6"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya5"
msgstr "dya5"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya4"
msgstr "dya4"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya3"
msgstr "dya3"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya2"
msgstr "dya2"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya1"
msgstr "dya1"

#. type: tbl table
#: build/C/man4/mouse.4:146
#, no-wrap
msgid "dya0"
msgstr "dya0"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb6"
msgstr "dxb6"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb5"
msgstr "dxb5"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb4"
msgstr "dxb4"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb3"
msgstr "dxb3"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb2"
msgstr "dxb2"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb1"
msgstr "dxb1"

#. type: tbl table
#: build/C/man4/mouse.4:147
#, no-wrap
msgid "dxb0"
msgstr "dxb0"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb6"
msgstr "dyb6"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb5"
msgstr "dyb5"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb4"
msgstr "dyb4"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb3"
msgstr "dyb3"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb2"
msgstr "dyb2"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb1"
msgstr "dyb1"

#. type: tbl table
#: build/C/man4/mouse.4:148
#, no-wrap
msgid "dyb0"
msgstr "dyb0"

#. type: Plain text
#: build/C/man4/mouse.4:153
msgid ""
"Bytes 4 and 5 describe the change that occurred since bytes 2 and 3 were "
"transmitted."
msgstr "第 4,5 バイトには、第 2,3 バイトが送られたあと生じた変更が記述される。"

#. type: SS
#: build/C/man4/mouse.4:153
#, no-wrap
msgid "Sun protocol"
msgstr "サン プロトコル(Sun protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:158
msgid ""
"The B<Sun> protocol is the 3-byte version of the above 5-byte Mousesystems "
"protocol: the last two bytes are not sent."
msgstr ""
"B<サン> プロトコルは、上記の 5 バイト マウスシステムプロトコルの 3 バイト版で"
"す。後の 2 バイトは送られません。"

#. type: SS
#: build/C/man4/mouse.4:158
#, no-wrap
msgid "MM protocol"
msgstr "MM プロトコル(MM protocol)"

#. type: Plain text
#: build/C/man4/mouse.4:175
msgid ""
"The B<MM> protocol uses 1 start bit, 8 data bits, odd parity and one stop "
"bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte packets.  "
"I<dx> and I<dy> are sent as single signed values, the sign bit indicating a "
"negative value.  I<lb> (I<mb>, I<rb>)  are set when the left (middle, right) "
"button is pressed:"
msgstr ""
"B<MM> プロトコルは 1200 bits/sec で 1 スタートビット、8 データビッ ト、奇数パ"
"リティ、 1 ストップビットを使う。データは RxD に 3 バイトのパ ケットとして送"
"られる。I<dx> と I<dy> は一つの符号つきの値として 送られ、サインビットは負の"
"値を表す。左(中、右)のボタンが押された時には I<lb> (I<mb>, I<rb>)がセットされ"
"る。"

#. type: tbl table
#: build/C/man4/mouse.4:180
#, no-wrap
msgid "dxs"
msgstr "dxs"

#. type: tbl table
#: build/C/man4/mouse.4:180
#, no-wrap
msgid "dys"
msgstr "dys"

#. type: TP
#: build/C/man4/mouse.4:185
#, no-wrap
msgid "I</dev/mouse>"
msgstr "I</dev/mouse>"

#. type: Plain text
#: build/C/man4/mouse.4:188
msgid "A commonly used symbolic link pointing to a mouse device."
msgstr "一般的にマウスデバイスをさすのに使われるシンボリックリンク"

#. type: Plain text
#: build/C/man4/mouse.4:191
msgid "B<ttyS>(4), B<gpm>(8)"
msgstr "B<ttyS>(4), B<gpm>(8)"

#. type: TH
#: build/C/man4/msr.4:26
#, no-wrap
msgid "MSR"
msgstr "MSR"

#. type: TH
#: build/C/man4/msr.4:26
#, no-wrap
msgid "2009-03-31"
msgstr "2009-03-31"

#. type: Plain text
#: build/C/man4/msr.4:29
msgid "msr - x86 CPU MSR access device"
msgstr "msr - x86 CPU MSR へアクセスするためのデバイス"

#. type: Plain text
#: build/C/man4/msr.4:36
msgid ""
"I</dev/cpu/CPUNUM/msr> provides an interface to read and write the model-"
"specific registers (MSRs) of an x86 CPU.  I<CPUNUM> is the number of the CPU "
"to access as listed in I</proc/cpuinfo>."
msgstr ""
"I</dev/cpu/CPUNUM/msr> は x86 CPU の モデル固有レジスター (model-specific "
"registers; MSRs) の読み書きインターフェースを提供する。 I<CPUNUM> はアクセス"
"する CPU の番号で、 I</proc/cpuinfo> に表示される値である。"

#. type: Plain text
#: build/C/man4/msr.4:42
msgid ""
"The register access is done by opening the file and seeking to the MSR "
"number as offset in the file, and then reading or writing in chunks of 8 "
"bytes.  An I/O transfer of more than 8 bytes means multiple reads or writes "
"of the same register."
msgstr ""
"レジスターアクセスは、 ファイルをオープンし、 MSR 番号分だけファイルのオフ"
"セットを変更し、 8 バイト単位での読み書きを行う形で行われる。 つまり、 8 バイ"
"トを超える I/O 転送は、同じレジスターに対する複数回の読み書きとなる。"

#. type: Plain text
#: build/C/man4/msr.4:47
msgid ""
"This file is protected so that it can be read and written only by the user "
"I<root>, or members of the group I<root>."
msgstr ""
"このファイルは保護されており、 I<root> ユーザー、もしくは I<root> グループの"
"メンバだけが読み書きできる。"

#. type: Plain text
#: build/C/man4/msr.4:53
msgid ""
"The I<msr> driver is not auto-loaded.  On modular kernels you might need to "
"use the following command to load it explicitly before use:"
msgstr ""
"I<msr> ドライバは自動ではロードされない。 モジュールが有効になったカーネルで"
"は、 以下のコマンドを使って、 使用する前に明示的にドライバをロードする必要が"
"あるだろう。"

#. type: Plain text
#: build/C/man4/msr.4:57
#, no-wrap
msgid "$ modprobe msr\n"
msgstr " $ modprobe msr\n"

#. type: Plain text
#: build/C/man4/msr.4:64
msgid ""
"Intel Corporation Intel 64 and IA-32 Architectures Software Developer's "
"Manual Volume 3B Appendix B, for an overview of the Intel CPU MSRs."
msgstr ""
"Intel CPU MSR の概要については Intel Corporation Intel 64 and IA-32 "
"Architectures Software Developer's Manual Volume 3B Appendix B を参照。"

#. type: TH
#: build/C/man4/null.4:26
#, no-wrap
msgid "NULL"
msgstr "NULL"

#. type: TH
#: build/C/man4/null.4:26
#, no-wrap
msgid "2015-07-23"
msgstr " 2015-07-23"

#. type: Plain text
#: build/C/man4/null.4:29
msgid "null, zero - data sink"
msgstr "null, zero - データの掃きだめ"

#. type: Plain text
#: build/C/man4/null.4:35
msgid ""
"Data written to the I</dev/null> and I</dev/zero> special files is discarded."
msgstr "スペシャルファイル I</dev/null> または I</dev/zero> に書かれたデータは捨てられる。"

#. type: Plain text
#: build/C/man4/null.4:43
msgid ""
"Reads from I</dev/null> always return end of file (i.e., B<read>(2)  returns "
"0), whereas reads from I</dev/zero> always return bytes containing zero "
"(\\(aq\\e0\\(aq characters)."
msgstr "I</dev/null> を読むと常に end of file が返され (つまり、 B<read>(2)  は 0 を返す)、対照的 に I</dev/zero> を読むと常にバイト数 0 (\\(aq\\e0\\(aq 文字) が返される。"

#. type: Plain text
#: build/C/man4/null.4:45
msgid "These devices are typically created by:"
msgstr "これらのデバイスは通常次のように作られる:"

#. type: Plain text
#: build/C/man4/null.4:51
#, no-wrap
msgid ""
"mknod -m 666 /dev/null c 1 3\n"
"mknod -m 666 /dev/zero c 1 5\n"
"chown root:root /dev/null /dev/zero\n"
msgstr ""
" mknod -m 666 /dev/null c 1 3\n"
"mknod -m 666 /dev/zero c 1 5\n"
"chown root:root /dev/null /dev/zero\n"

#. type: Plain text
#: build/C/man4/null.4:55
msgid "I</dev/null>"
msgstr "I</dev/null>"

#. type: Plain text
#: build/C/man4/null.4:57
msgid "I</dev/zero>"
msgstr "I</dev/zero>"

#. type: Plain text
#: build/C/man4/null.4:60
msgid ""
"If these devices are not writable and readable for all users, many programs "
"will act strangely."
msgstr ""
"これらのデバイスが全てのユーザーに対して読み書き可能でない場合、 多くのプログ"
"ラムの動作がおかしくなるだろう。"

#.  commit 2b83868723d090078ac0e2120e06a1cc94dbaef0
#. type: Plain text
#: build/C/man4/null.4:68
msgid ""
"Since Linux 2.6.31, reads from I</dev/zero> are interruptible by signals.  "
"(This change was made to help with bad latencies for large reads from I</dev/"
"zero>.)"
msgstr ""

#. type: Plain text
#: build/C/man4/null.4:72
msgid "B<chown>(1), B<mknod>(1), B<full>(4)"
msgstr "B<chown>(1), B<mknod>(1), B<full>(4)"

#. type: TH
#: build/C/man7/pipe.7:25
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: Plain text
#: build/C/man7/pipe.7:28
msgid "pipe - overview of pipes and FIFOs"
msgstr "pipe - パイプと FIFO の概要"

#. type: Plain text
#: build/C/man7/pipe.7:37
msgid ""
"Pipes and FIFOs (also known as named pipes)  provide a unidirectional "
"interprocess communication channel.  A pipe has a I<read end> and a I<write "
"end>.  Data written to the write end of a pipe can be read from the read end "
"of the pipe."
msgstr ""
"パイプと FIFO (名前付きパイプともいう) は、 単方向のプロセス間通信チャネルを"
"提供する。 パイプには「読み出し側」と「書き込み側」がある。 パイプの書き込み"
"側で書き込まれたデータは、 パイプの読み出し側から読み出すことができる。"

#. type: Plain text
#: build/C/man7/pipe.7:47
msgid ""
"A pipe is created using B<pipe>(2), which creates a new pipe and returns two "
"file descriptors, one referring to the read end of the pipe, the other "
"referring to the write end.  Pipes can be used to create a communication "
"channel between related processes; see B<pipe>(2)  for an example."
msgstr ""
"パイプを作成するには B<pipe>(2)  を使用する。 B<pipe>(2)  は新しいパイプを作"
"成し、ファイルディスクリプターを二つ返す。 ディスクリプターのうち、一方はパイ"
"プの読み出し側を、もう一方は 書き込み側を参照している。 パイプは関連するプロ"
"セス間の通信を作成するのに使用できる。 例は B<pipe>(2)  を参照。"

#. type: Plain text
#: build/C/man7/pipe.7:66
msgid ""
"A FIFO (short for First In First Out) has a name within the filesystem "
"(created using B<mkfifo>(3)), and is opened using B<open>(2).  Any process "
"may open a FIFO, assuming the file permissions allow it.  The read end is "
"opened using the B<O_RDONLY> flag; the write end is opened using the "
"B<O_WRONLY> flag.  See B<fifo>(7)  for further details.  I<Note>: although "
"FIFOs have a pathname in the filesystem, I/O on FIFOs does not involve "
"operations on the underlying device (if there is one)."
msgstr ""
"FIFO (First In First Out の省略) はファイルシステムでの名前を持ち、 "
"B<open>(2)  を使ってオープンできる (B<mkfifo>(3)  を使って作成される)。 どん"
"なプロセスでも、ファイルのアクセス許可があれば FIFO をオープンする ことができ"
"る。 読み出し側をオープンするには B<O_RDONLY> フラグを使用し、書き込み側を"
"オープンするには B<O_WRONLY> フラグを使用する。詳細は B<fifo>(7)  を参照。 "
"【注意】 FIFO はファイルシステム内のパス名を持つが、 FIFO に対して入出力を"
"行っても、(ファイルシステムが存在するデバイスが あったとしても) そのデバイス"
"に対する操作は発生しない。"

#. type: SS
#: build/C/man7/pipe.7:66
#, no-wrap
msgid "I/O on pipes and FIFOs"
msgstr "パイプや FIFO に対する入出力"

#. type: Plain text
#: build/C/man7/pipe.7:71
msgid ""
"The only difference between pipes and FIFOs is the manner in which they are "
"created and opened.  Once these tasks have been accomplished, I/O on pipes "
"and FIFOs has exactly the same semantics."
msgstr ""
"パイプと FIFO の違いは作成やオープンの方法だけである。 これらの操作が完了した"
"後は、パイプと FIFO に対する入出力は 全く同じ仕組みで行われる。"

#. type: Plain text
#: build/C/man7/pipe.7:85
msgid ""
"If a process attempts to read from an empty pipe, then B<read>(2)  will "
"block until data is available.  If a process attempts to write to a full "
"pipe (see below), then B<write>(2)  blocks until sufficient data has been "
"read from the pipe to allow the write to complete.  Nonblocking I/O is "
"possible by using the B<fcntl>(2)  B<F_SETFL> operation to enable the "
"B<O_NONBLOCK> open file status flag."
msgstr ""
"プロセスが空のパイプから読み出しを行おうとした場合、 B<read>(2)  はデータが読"
"み出し可能になるまで停止する。 プロセスがフル状態のパイプに書き込みを行おうと"
"した場合、 B<write>(2)  は書き込みを完了するのに十分な量のパイプからの読み出"
"しが 行われるまで停止する。 非停止 (nonblocking) I/O を使うこともできる。 非"
"停止 I/O を使うには、 B<fcntl>(2)  B<F_SETFL> 操作を使って、 B<O_NONBLOCK> "
"オープンファイル状態フラグを有効にする。"

#. type: Plain text
#: build/C/man7/pipe.7:89
msgid ""
"The communication channel provided by a pipe is a I<byte stream>: there is "
"no concept of message boundaries."
msgstr ""
"パイプにより提供される通信チャネルは「バイトストリーム」であり、 メッセージ境"
"界の概念はない。"

#. type: Plain text
#: build/C/man7/pipe.7:116
msgid ""
"If all file descriptors referring to the write end of a pipe have been "
"closed, then an attempt to B<read>(2)  from the pipe will see end-of-file "
"(B<read>(2)  will return 0).  If all file descriptors referring to the read "
"end of a pipe have been closed, then a B<write>(2)  will cause a B<SIGPIPE> "
"signal to be generated for the calling process.  If the calling process is "
"ignoring this signal, then B<write>(2)  fails with the error B<EPIPE>.  An "
"application that uses B<pipe>(2)  and B<fork>(2)  should use suitable "
"B<close>(2)  calls to close unnecessary duplicate file descriptors; this "
"ensures that end-of-file and B<SIGPIPE>/B<EPIPE> are delivered when "
"appropriate."
msgstr ""
"パイプの書き込み側を参照しているファイルディスクリプターが すべてクローズされ"
"た後で、そのパイプから B<read>(2)  を行おうとした場合、 end-of-file (ファイル"
"末尾) が見える (B<read>(2)  は 0 を返す)。 パイプの読み出し側を参照している"
"ファイルディスクリプターが すべてクローズされた後で、 B<write>(2)  を行うと、"
"呼び出し元プロセスに B<SIGPIPE> シグナルが送られる。 呼び出し元プロセスがこの"
"シグナルを無視しているときには、 B<write>(2)  はエラー B<EPIPE> で失敗する。 "
"B<pipe>(2)  と B<fork>(2)  を使用するアプリケーションでは、 B<close>(2)  を適"
"切に使って不必要なファイルディスクリプターの複製を クローズすべきである。こう"
"することで、必要な時に確実に end-of-file や B<SIGPIPE>/B<EPIPE> が配送される"
"ようになる。"

#. type: Plain text
#: build/C/man7/pipe.7:120
msgid "It is not possible to apply B<lseek>(2)  to a pipe."
msgstr "パイプには B<lseek>(2)  を行うことはできない。"

#. type: SS
#: build/C/man7/pipe.7:120
#, no-wrap
msgid "Pipe capacity"
msgstr "パイプの容量"

#. type: Plain text
#: build/C/man7/pipe.7:132
msgid ""
"A pipe has a limited capacity.  If the pipe is full, then a B<write>(2)  "
"will block or fail, depending on whether the B<O_NONBLOCK> flag is set (see "
"below).  Different implementations have different limits for the pipe "
"capacity.  Applications should not rely on a particular capacity: an "
"application should be designed so that a reading process consumes data as "
"soon as it is available, so that a writing process does not remain blocked."
msgstr ""
"パイプの容量には上限がある。 パイプがフルの場合、 B<write>(2)  は停止したり失"
"敗したりする。どちらになるかは B<O_NONBLOCK> フラグがセットされているかどうか"
"に依存する (下記参照)。 実装により、パイプの容量の上限は異なる。 アプリケー"
"ションは特定の容量を前提にすべきではない。 書き込み側のプロセスが停止したまま"
"にならないよう、 読み出し側のプロセスはデータが利用可能になったらできるだけす"
"ぐに 読み出しを行うように、アプリケーションを設計すべきである。"

#. type: Plain text
#: build/C/man7/pipe.7:147
msgid ""
"In Linux versions before 2.6.11, the capacity of a pipe was the same as the "
"system page size (e.g., 4096 bytes on i386).  Since Linux 2.6.11, the pipe "
"capacity is 16 pages (i.e., 65,536 bytes in a system with a page size of "
"4096 bytes).  Since Linux 2.6.35, the default pipe capacity is 16 pages, but "
"the capacity can be queried and set using the B<fcntl>(2)  B<F_GETPIPE_SZ> "
"and B<F_SETPIPE_SZ> operations.  See B<fcntl>(2)  for more information."
msgstr "バージョン 2.6.11 より前の Linux ではパイプの容量はシステムのページサイズ と同じであった (例えば i386 では 4096 バイト)。 Linux 2.6.11 以降では、パイプの容量は 16 ページ (すなわち、 ページサイズが 4096 バイトのシステムでは 65536 バイト) である。 Linux 2.6.35 以降では、パイプの容量のデフォルト値は 16 ページだが、 パイプの容量は B<fcntl>(2) の B<F_GETPIPE_SZ> と B<F_SETPIPE_SZ> 操作を使って参照、設定できる。 詳細は B<fcntl>(2) 参照。"

#. type: Plain text
#: build/C/man7/pipe.7:155
msgid ""
"The following B<ioctl>(2)  operation, which can be applied to a file "
"descriptor that refers to either end of a pipe, places a count of the number "
"of unread bytes in the pipe in the I<int> buffer pointed to by the final "
"argument of the call:"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:157
#, no-wrap
msgid "    ioctl(fd, FIONREAD, &nbytes);\n"
msgstr "    ioctl(fd, FIONREAD, &nbytes);\n"

#. type: Plain text
#: build/C/man7/pipe.7:163
msgid ""
"The B<FIONREAD> operation is not specified in any standard, but is provided "
"on many implementations."
msgstr ""

#. type: SS
#: build/C/man7/pipe.7:163
#, no-wrap
msgid "/proc files"
msgstr " /proc ファイル"

#. type: Plain text
#: build/C/man7/pipe.7:165
msgid ""
"On Linux, the following files control how much memory can be used for pipes:"
msgstr ""

#. type: TP
#: build/C/man7/pipe.7:165
#, no-wrap
msgid "I</proc/sys/fs/pipe-max-pages> (only in Linux 2.6.34)"
msgstr ""

#.  commit b492e95be0ae672922f4734acf3f5d35c30be948
#. type: Plain text
#: build/C/man7/pipe.7:173
msgid ""
"An upper limit, in pages, on the capacity that an unprivileged user (one "
"without the B<CAP_SYS_RESOURCE> capability)  can set for a pipe."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:176
msgid ""
"The default value for this limit is 16 times the default pipe capacity (see "
"above); the lower limit is two pages."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:179
msgid ""
"This interface was removed in Linux 2.6.35, in favor of I</proc/sys/fs/pipe-"
"max-size>."
msgstr ""

#. type: TP
#: build/C/man7/pipe.7:179
#, no-wrap
msgid "I</proc/sys/fs/pipe-max-size> (since Linux 2.6.35)"
msgstr ""

#.  commit ff9da691c0498ff81fdd014e7a0731dab2337dac
#.  This limit is not checked on pipe creation, where the capacity is
#.  always PIPE_DEF_BUFS, regardless of pipe-max-size
#. type: Plain text
#: build/C/man7/pipe.7:192
msgid ""
"The maximum size (in bytes) of individual pipes that can be set by users "
"without the B<CAP_SYS_RESOURCE> capability.  The value assigned to this file "
"may be rounded upward, to reflect the value actually employed for a "
"convenient implementation.  To determine the rounded-up value, display the "
"contents of this file after assigning a value to it."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:199
msgid ""
"The default value for this file is 1048576 (1\\ MiB).  The minimum value "
"that can be assigned to this file is the system page size.  Attempts to set "
"a limit less than the page size cause B<write>(2)  to fail with the error "
"B<EINVAL>."
msgstr ""

#.  commit 086e774a57fba4695f14383c0818994c0b31da7c
#. type: Plain text
#: build/C/man7/pipe.7:204
msgid ""
"Since Linux 4.9, the value on this file also acts as a ceiling on the "
"default capacity of a new pipe or newly opened FIFO."
msgstr ""

#. type: TP
#: build/C/man7/pipe.7:204
#, no-wrap
msgid "I</proc/sys/fs/pipe-user-pages-hard> (since Linux 4.5)"
msgstr ""

#.  commit 759c01142a5d0f364a462346168a56de28a80f52
#. type: Plain text
#: build/C/man7/pipe.7:217
msgid ""
"The hard limit on the total size (in pages) of all pipes created or set by a "
"single unprivileged user (i.e., one with neither the B<CAP_SYS_RESOURCE> nor "
"the B<CAP_SYS_ADMIN> capability).  So long as the total number of pages "
"allocated to pipe buffers for this user is at this limit, attempts to create "
"new pipes will be denied, and attempts to increase a pipe's capacity will be "
"denied."
msgstr ""

#.  The default was chosen to avoid breaking existing applications that
#.  make intensive use of pipes (e.g., for splicing).
#. type: Plain text
#: build/C/man7/pipe.7:222
msgid ""
"When the value of this limit is zero (which is the default), no hard limit "
"is applied."
msgstr ""

#. type: TP
#: build/C/man7/pipe.7:222
#, no-wrap
msgid "I</proc/sys/fs/pipe-user-pages-soft> (since Linux 4.5)"
msgstr ""

#.  commit 759c01142a5d0f364a462346168a56de28a80f52
#. type: Plain text
#: build/C/man7/pipe.7:235
msgid ""
"The soft limit on the total size (in pages) of all pipes created or set by a "
"single unprivileged user (i.e., one with neither the B<CAP_SYS_RESOURCE> nor "
"the B<CAP_SYS_ADMIN> capability).  So long as the total number of pages "
"allocated to pipe buffers for this user is at this limit, individual pipes "
"created by a user will be limited to one page, and attempts to increase a "
"pipe's capacity will be denied."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:239
msgid ""
"When the value of this limit is zero, no soft limit is applied.  The default "
"value for this file is 16384, which permits creating up to 1024 pipes with "
"the default capacity."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:246
msgid ""
"Before Linux 4.9, some bugs affected the handling of the I<pipe-user-pages-"
"soft> and I<pipe-user-pages-hard> limits; see BUGS."
msgstr ""

#. type: SS
#: build/C/man7/pipe.7:246
#, no-wrap
msgid "PIPE_BUF"
msgstr "PIPE_BUF"

#. type: Plain text
#: build/C/man7/pipe.7:268
msgid ""
"POSIX.1 says that B<write>(2)s of less than B<PIPE_BUF> bytes must be "
"atomic: the output data is written to the pipe as a contiguous sequence.  "
"Writes of more than B<PIPE_BUF> bytes may be nonatomic: the kernel may "
"interleave the data with data written by other processes.  POSIX.1 requires "
"B<PIPE_BUF> to be at least 512 bytes.  (On Linux, B<PIPE_BUF> is 4096 "
"bytes.)  The precise semantics depend on whether the file descriptor is "
"nonblocking (B<O_NONBLOCK>), whether there are multiple writers to the pipe, "
"and on I<n>, the number of bytes to be written:"
msgstr "POSIX.1 では、 B<PIPE_BUF> バイト以下の B<write>(2)  は atomic に行われること、つまりパイプへの出力データの書き込みは 連続したシーケンスとして行われることを必須としている (MUST)。 B<PIPE_BUF> バイトより多くのデータを書き込み場合は atomic とはならない、 つまりパイプへの他のプロセスによるデータの書き込みが間に入る 可能性がある。 POSIX.1-2001 の仕様では、 B<PIPE_BUF> は最小でも 512 バイトであることが要求されている (Linux では B<PIPE_BUF> は 4096 バイトである)。 正確な動作は、ファイルディスクリプターが nonblocking (B<O_NONBLOCK>)  かどうか、パイプへの書き込みが複数から行われるかどうか、および書き込みを行うバイト数 I<n> により決定される。"

#. type: TP
#: build/C/man7/pipe.7:268
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> 無効, I<n> E<lt>= B<PIPE_BUF>"

#. type: Plain text
#: build/C/man7/pipe.7:277
msgid ""
"All I<n> bytes are written atomically; B<write>(2)  may block if there is "
"not room for I<n> bytes to be written immediately"
msgstr ""
"I<n> バイト全部の書き込みが atomic に行われる。 I<n> バイト分をすぐに書き込む"
"余地がない場合は B<write>(2)  は停止 (block) することがある。"

#. type: TP
#: build/C/man7/pipe.7:277
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> 有効, I<n> E<lt>= B<PIPE_BUF>"

#. type: Plain text
#: build/C/man7/pipe.7:291
msgid ""
"If there is room to write I<n> bytes to the pipe, then B<write>(2)  succeeds "
"immediately, writing all I<n> bytes; otherwise B<write>(2)  fails, with "
"I<errno> set to B<EAGAIN>."
msgstr ""
"パイプに I<n> バイトを書き込む余地がある場合は、 I<n> バイト全部がすぐに書き"
"込まれる。 余地がない場合は、 B<write>(2)  は失敗し、 I<errno> に B<EAGAIN> "
"がセットされる。"

#. type: TP
#: build/C/man7/pipe.7:291
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<gt> B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> 無効, I<n> E<gt> B<PIPE_BUF>"

#. type: Plain text
#: build/C/man7/pipe.7:303
msgid ""
"The write is nonatomic: the data given to B<write>(2)  may be interleaved "
"with B<write>(2)s by other process; the B<write>(2)  blocks until I<n> bytes "
"have been written."
msgstr ""
"書き込みは atomic とはならない。 B<write>(2)  に渡されたデータの間に、他のプ"
"ロセスにより B<write>(2)  されたデータが入ることがある。 B<write>(2)  は "
"I<n> バイトの書き込みが完了するまで停止する。"

#. type: TP
#: build/C/man7/pipe.7:303
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<gt> B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> 有効, I<n> E<gt> B<PIPE_BUF>"

#. type: Plain text
#: build/C/man7/pipe.7:318
msgid ""
"If the pipe is full, then B<write>(2)  fails, with I<errno> set to "
"B<EAGAIN>.  Otherwise, from 1 to I<n> bytes may be written (i.e., a "
"\"partial write\" may occur; the caller should check the return value from "
"B<write>(2)  to see how many bytes were actually written), and these bytes "
"may be interleaved with writes by other processes."
msgstr ""
"パイプがフルの場合、 B<write>(2)  は失敗し、 I<errno> に B<EAGAIN> がセットさ"
"れる。 それ以外の場合、1 バイト以上 I<n> バイト以下のデータが書き込まれる (つ"
"まり「一部分だけ書き込まれる」場合もあり得る)。 呼び出し元は B<write>(2)  の"
"返り値を参照し、実際に何バイト書き込まれたのかを確認すべきである。 また、書き"
"込みに成功したデータも、他のプロセスが書き込んだデータが 間に入ることがある。"

#. type: SS
#: build/C/man7/pipe.7:318
#, no-wrap
msgid "Open file status flags"
msgstr "オープンファイル状態フラグ"

#. type: Plain text
#: build/C/man7/pipe.7:324
msgid ""
"The only open file status flags that can be meaningfully applied to a pipe "
"or FIFO are B<O_NONBLOCK> and B<O_ASYNC>."
msgstr ""
"オープンファイル状態フラグのうち、パイプや FIFO に対して意味を持つのは "
"B<O_NONBLOCK> と B<O_ASYNC> だけである。"

#. type: Plain text
#: build/C/man7/pipe.7:337
#, fuzzy
#| msgid ""
#| "Setting the B<O_ASYNC> flag for the read end of a pipe causes a signal "
#| "(B<SIGIO> by default) to be generated when new input becomes available on "
#| "the pipe (see B<fcntl>(2)  for details).  On Linux, B<O_ASYNC> is "
#| "supported for pipes and FIFOs only since kernel 2.6."
msgid ""
"Setting the B<O_ASYNC> flag for the read end of a pipe causes a signal "
"(B<SIGIO> by default) to be generated when new input becomes available on "
"the pipe.  The target for delivery of signals must be set using the "
"B<fcntl>(2)  B<F_SETOWN> command.  On Linux, B<O_ASYNC> is supported for "
"pipes and FIFOs only since kernel 2.6."
msgstr ""
"パイプの読み出し側に B<O_ASYNC> フラグをセットすると、パイプに新たな入力があ"
"るとシグナル (デフォルトでは B<SIGIO>)  が生成される (詳細は B<fcntl>(2)  を"
"参照)。 Linux では、 パイプと FIFO に対する B<O_ASYNC> はカーネル 2.6 以降で"
"のみサポートされている。"

#. type: SS
#: build/C/man7/pipe.7:337
#, no-wrap
msgid "Portability notes"
msgstr "移植に関する注意"

#. type: Plain text
#: build/C/man7/pipe.7:343
msgid ""
"On some systems (but not Linux), pipes are bidirectional: data can be "
"transmitted in both directions between the pipe ends.  POSIX.1 requires only "
"unidirectional pipes.  Portable applications should avoid reliance on "
"bidirectional pipe semantics."
msgstr "いくつかのシステム (Linux ではない) では、パイプは双方向である、 つまりパイプの両端間でデータを両方向に送信することができる。 POSIX.1 で必須とされているのは、一方向のパイプだけである。 移植を考慮したアプリケーションでは、双方向パイプの仕組みを 前提にすべきではない。"

#.  These bugs where remedied by a series of patches, in particular,
#.  commit b0b91d18e2e97b741b294af9333824ecc3fadfd8 and
#.  commit a005ca0e6813e1d796a7422a7e31d8b8d6555df1
#. type: Plain text
#: build/C/man7/pipe.7:355
msgid ""
"Before Linux 4.9, some bugs affected the handling of the I<pipe-user-pages-"
"soft> and I<pipe-user-pages-hard> limits when using the B<fcntl>(2)  "
"B<F_SETPIPE_SZ> operation to change a pipe's capacity:"
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:355
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:362
msgid ""
"When increasing the pipe capacity, the checks against the soft and hard "
"limits were made against existing consumption, and excluded the memory "
"required for the increased pipe capacity.  The new increase in pipe capacity "
"could then push the total memory used by the user for pipes (possibly far) "
"over a limit.  (This could also trigger the problem described next.)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:365
msgid ""
"Starting with Linux 4.9, the limit checking includes the memory required for "
"the new pipe capacity."
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:365
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:371
msgid ""
"The limit checks were performed even when the new pipe capacity was less "
"than the existing pipe capacity.  This could lead to problems if a user set "
"a large pipe capacity, and then the limits were lowered, with the result "
"that the user could no longer decrease the pipe capacity."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:375
msgid ""
"Starting with Linux 4.9, checks against the limits are performed only when "
"increasing a pipe's capacity; an unprivileged user can always decrease a "
"pipe's capacity."
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:375
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:377
msgid "The accounting and checking against the limits were done as follows:"
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:380
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:382
msgid "Test whether the user has exceeded the limit."
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:382
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:384
msgid "Make the new pipe buffer allocation."
msgstr ""

#. type: IP
#: build/C/man7/pipe.7:384
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:386
msgid "Account new allocation against the limits."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:394
msgid ""
"This was racey.  Multiple processes could pass point (a) simultaneously, and "
"then allocate pipe buffers that were accounted for only in step (c), with "
"the result that the user's pipe buffer allocation could be pushed over the "
"limit."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:398
msgid ""
"Starting with Linux 4.9, the accounting step is performed before doing the "
"allocation, and the operation fails if the limit would be exceeded."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:404
msgid ""
"Before Linux 4.9, bugs similar to points (1) and (3) could also occur when "
"the kernel allocated memory for a new pipe buffer; that is, when calling "
"B<pipe>(2)  and when opening a previously unopened FIFO."
msgstr ""

#. type: Plain text
#: build/C/man7/pipe.7:420
msgid ""
"B<mkfifo>(1), B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), "
"B<select>(2), B<socketpair>(2), B<splice>(2), B<stat>(2), B<tee>(2), "
"B<vmsplice>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"
msgstr " B<mkfifo>(1), B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), B<select>(2), B<socketpair>(2), B<splice>(2), B<stat>(2), B<tee>(2), B<vmsplice>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"

#. type: TH
#: build/C/man4/ram.4:26
#, no-wrap
msgid "RAM"
msgstr "RAM"

#. type: TH
#: build/C/man4/ram.4:26
#, no-wrap
msgid "1992-11-21"
msgstr "1992-11-21"

#. type: Plain text
#: build/C/man4/ram.4:29
msgid "ram - ram disk device"
msgstr "ram - RAM ディスクデバイス"

#. type: Plain text
#: build/C/man4/ram.4:33
msgid "The I<ram> device is a block device to access the ram disk in raw mode."
msgstr ""
"I<ram> デバイスは RAM ディスクにローモード (raw mode) でアクセスするための ブ"
"ロックデバイス (block device) である。"

#. type: Plain text
#: build/C/man4/ram.4:40
#, no-wrap
msgid ""
"mknod -m 660 /dev/ram b 1 1\n"
"chown root:disk /dev/ram\n"
msgstr ""
" mknod -m 660 /dev/ram b 1 1\n"
"chown root:disk /dev/ram\n"

#. type: Plain text
#: build/C/man4/ram.4:44
msgid "I</dev/ram>"
msgstr " I</dev/ram>"

#. type: Plain text
#: build/C/man4/ram.4:48
msgid "B<chown>(1), B<mknod>(1), B<mount>(8)"
msgstr "B<chown>(1), B<mknod>(1), B<mount>(8)"

#. type: TH
#: build/C/man4/random.4:17
#, no-wrap
msgid "RANDOM"
msgstr "RANDOM"

#. type: Plain text
#: build/C/man4/random.4:20
msgid "random, urandom - kernel random number source devices"
msgstr "random, urandom - カーネル乱数ソースデバイス"

#. type: Plain text
#: build/C/man4/random.4:22
msgid "#include E<lt>linux/random.hE<gt>"
msgstr "#include E<lt>linux/random.hE<gt>"

#. type: Plain text
#: build/C/man4/random.4:24
msgid "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"
msgstr "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"

#. type: Plain text
#: build/C/man4/random.4:34
msgid ""
"The character special files I</dev/random> and I</dev/urandom> (present "
"since Linux 1.3.30)  provide an interface to the kernel's random number "
"generator.  The file I</dev/random> has major device number 1 and minor "
"device number 8.  The file I</dev/urandom> has major device number 1 and "
"minor device number 9."
msgstr "(Linux 1.3.30 から提供されている) I</dev/random> 、 I</dev/urandom> キャラクタースペシャルファイルは カーネル乱数ジェネレーターへのインターフェースを提供する。 I</dev/random> ファイルはメジャーデバイス番号 1 マイナーデバイス番号 8 である。 I</dev/urandom> ファイルはメジャーデバイス番号 1 マイナーデバイス番号 9 である。"

#. type: Plain text
#: build/C/man4/random.4:40
msgid ""
"The random number generator gathers environmental noise from device drivers "
"and other sources into an entropy pool.  The generator also keeps an "
"estimate of the number of bits of noise in the entropy pool.  From this "
"entropy pool, random numbers are created."
msgstr ""
"乱数ジェネレーターはデバイスドライバやその他の源からの環境ノイズを エントロ"
"ピープールへ集める。 また、ジェネレーターはエントロピープール内のノイズのビッ"
"ト数の推定値を 保持する。 このエントロピープールから乱数が生成される。"

#. type: Plain text
#: build/C/man4/random.4:47
msgid ""
"Linux 3.17 and later provides the simpler and safer B<getrandom>(2)  "
"interface which requires no special files; see the B<getrandom>(2)  manual "
"page for details."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:54
msgid ""
"When read, the I</dev/urandom> device returns random bytes using a "
"pseudorandom number generator seeded from the entropy pool.  Reads from this "
"device do not block (i.e., the CPU is not yielded), but can incur an "
"appreciable delay when requesting large amounts of data."
msgstr ""

#.  This is a real problem; see
#.  commit 9b4d008787f864f17d008c9c15bbe8a0f7e2fc24
#. type: Plain text
#: build/C/man4/random.4:63
msgid ""
"When read during early boot time, I</dev/urandom> may return data prior to "
"the entropy pool being initialized.  If this is of concern in your "
"application, use B<getrandom>(2)  or I</dev/random> instead."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:71
msgid ""
"The I</dev/random> device is a legacy interface which dates back to a time "
"where the cryptographic primitives used in the implementation of I</dev/"
"urandom> were not widely trusted.  It will return random bytes only within "
"the estimated number of bits of fresh noise in the entropy pool, blocking if "
"necessary.  I</dev/random> is suitable for applications that need high "
"quality randomness, and can afford indeterminate delays."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:90
msgid ""
"When the entropy pool is empty, reads from I</dev/random> will block until "
"additional environmental noise is gathered.  If B<open>(2)  is called for I</"
"dev/random> with the B<O_NONBLOCK> flag, a subsequent B<read>(2)  will not "
"block if the requested number of bytes is not available.  Instead, the "
"available bytes are returned.  If no byte is available, B<read>(2)  will "
"return -1 and I<errno> will be set to B<EAGAIN>."
msgstr "エントロピープールが空の時は、I</dev/random> からの読み出しは、 更なる環境ノイズが得られるまで、ブロックされる。 B<open>(2) が I</dev/random> に対して B<O_NONBLOCK> フラグ付きで呼ばれると、 それ以降の B<read>(2) は要求したバイト数のデータが利用可能になるまで停止しない。 その代わり、 利用可能なデータが返される。 利用可能なバイトが全くない場合、 B<read>(2) は -1 を返し、 I<errno> に B<EAGAIN> が設定される。"

#. type: Plain text
#: build/C/man4/random.4:105
msgid ""
"The B<O_NONBLOCK> flag has no effect when opening I</dev/urandom>.  When "
"calling B<read>(2)  for the device I</dev/urandom>, reads of up to 256 bytes "
"will return as many bytes as are requested and will not be interrupted by a "
"signal handler.  Reads with a buffer over this limit may return less than "
"the requested number of bytes or fail with the error B<EINTR>, if "
"interrupted by a signal handler."
msgstr ""

#.  commit 79a8468747c5f95ed3d5ce8376a3e82e0c5857fc
#.  SEC_XFER_SIZE in drivers/char/random.c
#. type: Plain text
#: build/C/man4/random.4:120
msgid ""
"Since Linux 3.16, a B<read>(2)  from I</dev/urandom> will return at most "
"32\\ MB.  A B<read>(2)  from I</dev/random> will return at most 512 bytes "
"(340 bytes on Linux kernels before version 2.6.12)."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:127
msgid ""
"Writing to I</dev/random> or I</dev/urandom> will update the entropy pool "
"with the data written, but this will not result in a higher entropy count.  "
"This means that it will impact the contents read from both files, but it "
"will not make reads from I</dev/random> faster."
msgstr ""
"I</dev/random> や I</dev/urandom> に書き込みを行うと、 書き込まれたデータでエ"
"ントロピープールが更新される。 しかし、 エントロピーカウントが増えるわけでは"
"ない。 つまり、 I</dev/random> と I</dev/urandom> の両方のファイルから読み出"
"される内容に影響があるが、 I</dev/random> からの読み出しが早くなるわけではな"
"いということだ。"

#. type: Plain text
#: build/C/man4/random.4:138
msgid ""
"The I</dev/random> interface is considered a legacy interface, and I</dev/"
"urandom> is preferred and sufficient in all use cases, with the exception of "
"applications which require randomness during early boot time; for these "
"applications, B<getrandom>(2)  must be used instead, because it will block "
"until the entropy pool is initialized."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:153
msgid ""
"If a seed file is saved across reboots as recommended below, the output is "
"cryptographically secure against attackers without local root access as soon "
"as it is reloaded in the boot sequence, and perfectly adequate for network "
"encryption session keys.  (All major Linux distributions have saved the seed "
"file across reboots since 2000 at least.)  Since reads from I</dev/random> "
"may block, users will usually want to open it in nonblocking mode (or "
"perform a read with timeout), and provide some sort of user notification if "
"the desired entropy is not immediately available."
msgstr "下記で推奨しているように再起動の前後で乱数種ファイルが保存される場合、起動シーケンスにおいて乱数種が 再ロードされた直後から、その出力はローカルのルートアクセスができない 攻撃者に対して暗号的に安全なものとなり、ネットワーク暗号化のセッションキーとして使うには完全に最適なものとなる。 (すべての主な Linux のディストリビューションは少なくとも 2000 年以降はリブートの前後で乱数種のファイルを保存するようになっている。) I</dev/random> からの読み出しは停止 (block) する可能性があるので、ユーザーは普通 このファイルを非停止 (nonblocking) モードで開こうとし (もしくはタイムアウトを指定して読み出しを実行し)、希望するレベルの エントロピーはすぐには利用できない場合には、何らかの通知を行うことだろう。"

#. type: SS
#: build/C/man4/random.4:153 build/C/man4/smartpqi.4:314
#, no-wrap
msgid "Configuration"
msgstr "Configuration"

#. type: Plain text
#: build/C/man4/random.4:157
msgid ""
"If your system does not have I</dev/random> and I</dev/urandom> created "
"already, they can be created with the following commands:"
msgstr ""
"システムにあらかじめ作成された I</dev/random> と I</dev/urandom> が存在しない"
"なら、次のようなコマンドで作成できる。"

#. type: Plain text
#: build/C/man4/random.4:163
#, no-wrap
msgid ""
"mknod -m 666 /dev/random c 1 8\n"
"mknod -m 666 /dev/urandom c 1 9\n"
"chown root:root /dev/random /dev/urandom\n"
msgstr ""
" mknod -m 666 /dev/random c 1 8\n"
"mknod -m 666 /dev/urandom c 1 9\n"
"chown root:root /dev/random /dev/urandom\n"

#. type: Plain text
#: build/C/man4/random.4:174
msgid ""
"When a Linux system starts up without much operator interaction, the entropy "
"pool may be in a fairly predictable state.  This reduces the actual amount "
"of noise in the entropy pool below the estimate.  In order to counteract "
"this effect, it helps to carry entropy pool information across shut-downs "
"and start-ups.  To do this, add the lines to an appropriate script which is "
"run during the Linux system start-up sequence:"
msgstr ""
"オペレータの操作なしに Linux システムが起動した直後は、 エントロピープールは"
"意外性の乏しい均一な状態にあるだろう。 これにより、エントロピープールの実際の"
"ノイズ量は評価値より少なくなる。 この効果を打ち消すために、シャットダウンか"
"ら (次の) 起動時まで持ち越した エントロピープールの情報が助けになる。 エント"
"ロピープールを持ち越すためには、 Linux システムの起動時に実行される適切なスク"
"リプトに、 以下の行を追加すればよい:"

#. type: Plain text
#: build/C/man4/random.4:191
#, no-wrap
msgid ""
"echo \"Initializing random number generator...\"\n"
"random_seed=/var/run/random-seed\n"
"# Carry a random seed from start-up to start-up\n"
"# Load and then save the whole entropy pool\n"
"if [ -f $random_seed ]; then\n"
"    cat $random_seed E<gt>/dev/urandom\n"
"else\n"
"    touch $random_seed\n"
"fi\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"echo \"Initializing random number generator...\"\n"
"random_seed=/var/run/random-seed\n"
"# 乱数種を今回のスタートアップから次回のスタートアップまで持ち越す。\n"
"# ロードを行い、その後、全てのエントロピープールを保存する。\n"
"if [ -f $random_seed ]; then\n"
"    cat $random_seed E<gt>/dev/urandom\n"
"else\n"
"    touch $random_seed\n"
"fi\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"

#. type: Plain text
#: build/C/man4/random.4:196
msgid ""
"Also, add the following lines in an appropriate script which is run during "
"the Linux system shutdown:"
msgstr ""
"また、Linux システムのシャットダウン時に実行される適切なスクリプトに、 以下の"
"行を追加すればよい:"

#. type: Plain text
#: build/C/man4/random.4:209
#, no-wrap
msgid ""
"# Carry a random seed from shut-down to start-up\n"
"# Save the whole entropy pool\n"
"echo \"Saving random seed...\"\n"
"random_seed=/var/run/random-seed\n"
"touch $random_seed\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"# 乱数種を今回のシャットダウンから次回のスタートアップまで持ち越す。\n"
"# 全てのエントロピープールを保存する。\n"
"echo \"Saving random seed...\"\n"
"random_seed=/var/run/random-seed\n"
"touch $random_seed\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"

#. type: Plain text
#: build/C/man4/random.4:216
msgid ""
"In the above examples, we assume Linux 2.6.0 or later, where I</proc/sys/"
"kernel/random/poolsize> returns the size of the entropy pool in bits (see "
"below)."
msgstr ""

#. type: SS
#: build/C/man4/random.4:216
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man4/random.4:222
msgid ""
"The files in the directory I</proc/sys/kernel/random> (present since 2.3.16) "
"provide additional information about the I</dev/random> device:"
msgstr "ディレクトリ I</proc/sys/kernel/random> にあるファイル (2.3.16 以降で存在する) で、 I</dev/random> デバイスに関する追加の情報を参照できる。"

#. type: TP
#: build/C/man4/random.4:222
#, no-wrap
msgid "I<entropy_avail>"
msgstr "I<entropy_avail>"

#. type: Plain text
#: build/C/man4/random.4:226
msgid ""
"This read-only file gives the available entropy, in bits.  This will be a "
"number in the range 0 to 4096."
msgstr "この読み込み専用のファイルは使用可能なエントロピーをビット単位で表示する。値は 0 から 4096 までの範囲の数字である。"

#. type: TP
#: build/C/man4/random.4:226
#, no-wrap
msgid "I<poolsize>"
msgstr "I<poolsize>"

#. type: Plain text
#: build/C/man4/random.4:231
msgid ""
"This file gives the size of the entropy pool.  The semantics of this file "
"vary across kernel versions:"
msgstr "このファイルはエントロピープールのサイズを示す。 このファイルの意味はカーネルバージョンにより異なる。"

#. type: TP
#: build/C/man4/random.4:232
#, no-wrap
msgid "Linux 2.4:"
msgstr "Linux 2.4:"

#. type: Plain text
#: build/C/man4/random.4:239
msgid ""
"This file gives the size of the entropy pool in I<bytes>.  Normally, this "
"file will have the value 512, but it is writable, and can be changed to any "
"value for which an algorithm is available.  The choices are 32, 64, 128, "
"256, 512, 1024, or 2048."
msgstr ""
"このファイルはエントロピープールのサイズを「バイト」単位で規定する。 通常、こ"
"のファイルの値は 512 になるが、書き込み可能であり、 アルゴリズムで利用可能な"
"任意の値に変更できる。 選択可能な値は 32, 64, 128, 256, 512, 1024, 2048 であ"
"る。"

#. type: TP
#: build/C/man4/random.4:239
#, no-wrap
msgid "Linux 2.6 and later:"
msgstr "Linux 2.6 以降:"

#. type: Plain text
#: build/C/man4/random.4:244
msgid ""
"This file is read-only, and gives the size of the entropy pool in I<bits>.  "
"It contains the value 4096."
msgstr ""
"このファイルは読み出し専用であり、 エントロピープールのサイズを「ビット」単位"
"で規定する。 値は 4096 である。"

#. type: TP
#: build/C/man4/random.4:245
#, no-wrap
msgid "I<read_wakeup_threshold>"
msgstr "I<read_wakeup_threshold>"

#. type: Plain text
#: build/C/man4/random.4:252
msgid ""
"This file contains the number of bits of entropy required for waking up "
"processes that sleep waiting for entropy from I</dev/random>.  The default "
"is 64."
msgstr ""

#. type: TP
#: build/C/man4/random.4:252
#, no-wrap
msgid "I<write_wakeup_threshold>"
msgstr "I<write_wakeup_threshold>"

#. type: Plain text
#: build/C/man4/random.4:263
msgid ""
"This file contains the number of bits of entropy below which we wake up "
"processes that do a B<select>(2)  or B<poll>(2)  for write access to I</dev/"
"random>.  These values can be changed by writing to the files."
msgstr "ファイル I<write_wakeup_threshold> はエントロピーのビット数を保持しており、この値以下になったら I</dev/random> への書き込みアクセスのために B<select>(2)  または B<poll>(2)  を実行するプロセスを起こす。 この値はファイルに書き込みを行うことによって変更できる。"

#. type: TP
#: build/C/man4/random.4:263
#, no-wrap
msgid "I<uuid> and I<boot_id>"
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:270
msgid ""
"These read-only files contain random strings like 6fd5a44b-35f4-4ad4-"
"a9b9-6b9be13e1fe9.  The former is generated afresh for each read, the latter "
"was generated once."
msgstr "これらの読み込み専用のファイルは 6fd5a44b-35f4-4ad4-a9b9-6b9be13e1fe9 のような ランダムな文字列を保持している。 前者は読み込みの度に新たに生成され、 後者は 1 度だけ生成される。"

#. type: SS
#: build/C/man4/random.4:270
#, no-wrap
msgid "ioctl(2) interface"
msgstr "ioctl(2) インターフェース"

#. type: Plain text
#: build/C/man4/random.4:281
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to either I</dev/random> or I</dev/urandom>.  All requests "
"performed will interact with the input entropy pool impacting both I</dev/"
"random> and I</dev/urandom>.  The B<CAP_SYS_ADMIN> capability is required "
"for all requests except B<RNDGETENTCNT>."
msgstr ""
"以下の B<ioctl>(2) 要求が I</dev/random> や I</dev/urandom> に接続されたファ"
"イルディスクリプターに対して定義されている。 実行されたすべての要求は、 I</"
"dev/random> と I</dev/urandom> に影響を与える入力エントロピープールとやり取り"
"を行う。 B<RNDGETENTCNT> 以外のすべての要求には B<CAP_SYS_ADMIN> ケーパビリ"
"ティが必要である。"

#. type: TP
#: build/C/man4/random.4:281
#, no-wrap
msgid "B<RNDGETENTCNT>"
msgstr "B<RNDGETENTCNT>"

#. type: Plain text
#: build/C/man4/random.4:288
msgid ""
"Retrieve the entropy count of the input pool, the contents will be the same "
"as the I<entropy_avail> file under proc.  The result will be stored in the "
"int pointed to by the argument."
msgstr ""
"入力エントロピープールのカウントを取得する。 取得される内容は proc の "
"I<entropy_avail> ファイルと同じである。 結果は引数が指す整数 (int) に格納さ"
"れる。"

#. type: TP
#: build/C/man4/random.4:288
#, no-wrap
msgid "B<RNDADDTOENTCNT>"
msgstr "B<RNDADDTOENTCNT>"

#. type: Plain text
#: build/C/man4/random.4:292
msgid ""
"Increment or decrement the entropy count of the input pool by the value "
"pointed to by the argument."
msgstr ""
"入力エントロピープールのカウントを引数が指す値だけ加算または減算する。"

#. type: TP
#: build/C/man4/random.4:292
#, no-wrap
msgid "B<RNDGETPOOL>"
msgstr "B<RNDGETPOOL>"

#. type: Plain text
#: build/C/man4/random.4:295
msgid "Removed in Linux 2.6.9."
msgstr "Linux 2.6.9 で削除された。"

#. type: TP
#: build/C/man4/random.4:295
#, no-wrap
msgid "B<RNDADDENTROPY>"
msgstr "B<RNDADDENTROPY>"

#. type: Plain text
#: build/C/man4/random.4:303
msgid ""
"Add some additional entropy to the input pool, incrementing the entropy "
"count.  This differs from writing to I</dev/random> or I</dev/urandom>, "
"which only adds some data but does not increment the entropy count.  The "
"following structure is used:"
msgstr ""
"入力プールに追加のエントロピーを追加し、エントロピーカウントを増やす。 この要"
"求は I</dev/random> や I</dev/urandom> への書き込みとは異なる。 I</dev/"
"random> や I</dev/urandom> への書き込みでは、 何らかのデータが追加されるだけ"
"で、 エントロピーカウントは増やされない。 以下の構造体が使用される。"

#. type: Plain text
#: build/C/man4/random.4:311
#, no-wrap
msgid ""
"struct rand_pool_info {\n"
"    int    entropy_count;\n"
"    int    buf_size;\n"
"    __u32  buf[0];\n"
"};\n"
msgstr ""
" struct rand_pool_info {\n"
"    int    entropy_count;\n"
"    int    buf_size;\n"
"    __u32  buf[0];\n"
"};\n"

#. type: Plain text
#: build/C/man4/random.4:321
msgid ""
"Here I<entropy_count> is the value added to (or subtracted from) the entropy "
"count, and I<buf> is the buffer of size I<buf_size> which gets added to the "
"entropy pool."
msgstr ""
"I<entropy_count> はエントロピーカウントに加算 (または減算) する値である。 "
"I<buf> は大きさが I<buf_size> のバッファーで、この内容がエントロピープールに"
"追加される。"

#. type: TP
#: build/C/man4/random.4:321
#, no-wrap
msgid "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"
msgstr "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"

#. type: Plain text
#: build/C/man4/random.4:325
msgid ""
"Zero the entropy count of all pools and add some system data (such as wall "
"clock) to the pools."
msgstr ""
"すべてのプールのエントロピーカウントを 0 にし、何らかのシステムデータ (現在の"
"時刻など) をプールに追加する。"

#. type: Plain text
#: build/C/man4/random.4:327
msgid "I</dev/random>"
msgstr " I</dev/random>"

#. type: Plain text
#: build/C/man4/random.4:329
msgid "I</dev/urandom>"
msgstr " I</dev/urandom>"

#. type: Plain text
#: build/C/man4/random.4:333
msgid ""
"For an overview and comparison of the various interfaces that can be used to "
"obtain randomness, see B<random>(7)."
msgstr ""

#.  .SH AUTHOR
#.  The kernel's random number generator was written by
#.  Theodore Ts'o (tytso@athena.mit.edu).
#. type: Plain text
#: build/C/man4/random.4:340
msgid ""
"During early boot time, reads from I</dev/urandom> may return data prior to "
"the entropy pool being initialized."
msgstr ""

#. type: Plain text
#: build/C/man4/random.4:344
msgid "B<mknod>(1), B<getrandom>(2), B<random>(7)"
msgstr " B<mknod>(1), B<getrandom>(2), B<random>(7)"

#. type: Plain text
#: build/C/man4/random.4:346
msgid "RFC\\ 1750, \"Randomness Recommendations for Security\""
msgstr "RFC\\ 1750, \"Randomness Recommendations for Security\""

#. type: TH
#: build/C/man4/sd.4:26
#, no-wrap
msgid "SD"
msgstr "SD"

#. type: Plain text
#: build/C/man4/sd.4:29
msgid "sd - driver for SCSI disk drives"
msgstr "sd - SCSI ディスクドライブのためのドライバ"

#. type: Plain text
#: build/C/man4/sd.4:33
#, no-wrap
msgid ""
"B<#include E<lt>linux/hdreg.hE<gt>        >/* for HDIO_GETGEO */\n"
"B<#include E<lt>linux/fs.hE<gt>           >/* for BLKGETSIZE and BLKRRPART */\n"
msgstr ""
"B<#include E<lt>linux/hdreg.hE<gt>        >/* for HDIO_GETGEO */\n"
"B<#include E<lt>linux/fs.hE<gt>           >/* for BLKGETSIZE and BLKRRPART */\n"

#. type: Plain text
#: build/C/man4/sd.4:45
msgid ""
"The block device name has the following form: B<sd>I<lp,> where I<l> is a "
"letter denoting the physical drive, and I<p> is a number denoting the "
"partition on that physical drive.  Often, the partition number, I<p>, will "
"be left off when the device corresponds to the whole drive."
msgstr ""
"このブロックデバイス (block device) の名前は、次のような形式をとる: "
"B<sd>I<lp,> このうち、 I<l> は物理ドライブを意味する文字であり、 I<p> はその"
"物理ドライブ上のパーティション (partition) を意味する数字である。 パーティ"
"ションナンバー I<p> がない場合は、そのデバイスファイルはドライブ全体をさす。"

#. type: Plain text
#: build/C/man4/sd.4:54
msgid ""
"SCSI disks have a major device number of 8, and a minor device number of the "
"form (16 * I<drive_number>) + I<partition_number>, where I<drive_number> is "
"the number of the physical drive in order of detection, and "
"I<partition_number> is as follows:"
msgstr ""
"SCSI ディスクはメジャーナンバー 8 を持ち、次のような形式のマイナーナンバー を"
"持つ。(16 * I<drive_number>) + I<partition_number>、 この I<drive_number> は"
"検出された物理ドライブの番号であり、 I<partition_number> は次のようになる:"

#. type: IP
#: build/C/man4/sd.4:54
#, no-wrap
msgid "+3"
msgstr " +3"

#. type: Plain text
#: build/C/man4/sd.4:56
msgid "partition 0 is the whole drive"
msgstr "パーティション 0 はドライブ全体"

#. type: Plain text
#: build/C/man4/sd.4:58
msgid "partitions 1\\(en4 are the DOS \"primary\" partitions"
msgstr "パーティション 1 〜 4 は DOS の \"基本 (primary)\" パーティション"

#. type: Plain text
#: build/C/man4/sd.4:60
msgid "partitions 5\\(en8 are the DOS \"extended\" (or \"logical\") partitions"
msgstr ""
"パーティション 5 〜 8 は DOS の \"拡張 (extended)\" (または、\"論理 "
"(logical)\") パーティション。"

#. type: Plain text
#: build/C/man4/sd.4:68
msgid ""
"For example, I</dev/sda> will have major 8, minor 0, and will refer to all "
"of the first SCSI drive in the system; and I</dev/sdb3> will have major 8, "
"minor 19, and will refer to the third DOS \"primary\" partition on the "
"second SCSI drive in the system."
msgstr ""
"例えば、 I</dev/sda> はメジャーナンバー 8 マイナーナンバー 0 を持ち、システム"
"の最初の SCSI ドライブ全体を参照する。そして、 I</dev/sdb3> はメジャーナン"
"バー 8 マイナーナンバー 19 を持ち、システムの二つ目の SCSI ドライブの三番目"
"の DOS \"基本\" パーティションを参照する。"

#. type: Plain text
#: build/C/man4/sd.4:71
msgid ""
"At this time, only block devices are provided.  Raw devices have not yet "
"been implemented."
msgstr ""
"現在は、ブロックデバイスだけが提供されている。ローデバイス (raw device)  はま"
"だ実装されていない。"

#. type: Plain text
#: build/C/man4/sd.4:75
msgid "The following I<ioctl>s are provided:"
msgstr "次の I<ioctl> が提供されている:"

#. type: TP
#: build/C/man4/sd.4:75
#, no-wrap
msgid "B<HDIO_GETGEO>"
msgstr "B<HDIO_GETGEO>"

#. type: Plain text
#: build/C/man4/sd.4:78
msgid "Returns the BIOS disk parameters in the following structure:"
msgstr "次のような構造体を用いて BIOS のディスクパラメーターを返す:"

#. type: Plain text
#: build/C/man4/sd.4:87
#, no-wrap
msgid ""
"struct hd_geometry {\n"
"    unsigned char  heads;\n"
"    unsigned char  sectors;\n"
"    unsigned short cylinders;\n"
"    unsigned long  start;\n"
"};\n"
msgstr ""
"struct hd_geometry {\n"
"    unsigned char  heads;\n"
"    unsigned char  sectors;\n"
"    unsigned short cylinders;\n"
"    unsigned long  start;\n"
"};\n"

#. type: Plain text
#: build/C/man4/sd.4:93
msgid "A pointer to this structure is passed as the B<ioctl>(2)  parameter."
msgstr ""
"この構造体へのポインターが B<ioctl>(2)  へのパラメーターとして渡される。"

#. type: Plain text
#: build/C/man4/sd.4:108
msgid ""
"The information returned in the parameter is the disk geometry of the drive "
"I<as understood by DOS!> This geometry is I<not> the physical geometry of "
"the drive.  It is used when constructing the drive's partition table, "
"however, and is needed for convenient operation of B<fdisk>(1), "
"B<efdisk>(1), and B<lilo>(1).  If the geometry information is not available, "
"zero will be returned for all of the parameters."
msgstr ""
"このパラメーターに入れられて返される情報は、 I<DOS によって理解されるような> "
"ドライブのジオメトリである。 このジオメトリは、ドライブの物理的なジオメトリ "
"I<ではない。> この情報はドライブのパーティションテーブルを作成する時に用いら"
"れる、 また、 B<fdisk>(1), B<efdisk>(1), B<lilo>(1)  の適切な操作に必要であ"
"る。 もし、ジオメトリの情報が得られなければ、それぞれの値全てにゼロが入れ ら"
"れて返される。"

#. type: TP
#: build/C/man4/sd.4:108
#, no-wrap
msgid "B<BLKGETSIZE>"
msgstr "B<BLKGETSIZE>"

#. type: Plain text
#: build/C/man4/sd.4:115
msgid ""
"Returns the device size in sectors.  The B<ioctl>(2)  parameter should be a "
"pointer to a I<long>."
msgstr ""
"セクタの数で表したデバイスのサイズが返される。 B<ioctl>(2)  のパラメーター"
"は、 I<long> へのポインターでなければならない。"

#. type: TP
#: build/C/man4/sd.4:115
#, no-wrap
msgid "B<BLKRRPART>"
msgstr "B<BLKRRPART>"

#. type: Plain text
#: build/C/man4/sd.4:119
msgid ""
"Forces a reread of the SCSI disk partition tables.  No parameter is needed."
msgstr ""
"強制的に、SCSI ディスクのパーティションテーブルの再読み込みを行う。 パラメー"
"ターは必要ない。"

#. type: Plain text
#: build/C/man4/sd.4:129
msgid ""
"The SCSI B<ioctl>(2)  operations are also supported.  If the B<ioctl>(2)  "
"parameter is required, and it is NULL, then B<ioctl>(2)  fails with the "
"error B<EINVAL>."
msgstr ""
"SCSI の B<ioctl>(2) 操作も同様にサポートされる。 B<ioctl>(2) の\n"
"パラメーターが必要で、そのパラメーターが NULL の場合は、 \n"
"B<ioctl>(2) はエラー B<EINVAL> で失敗する。"

#. type: TP
#: build/C/man4/sd.4:130
#, no-wrap
msgid "I</dev/sd[a-h]>"
msgstr " I</dev/sd[a-h]>"

#. type: Plain text
#: build/C/man4/sd.4:133
msgid "the whole device"
msgstr "デバイス全体"

#. type: TP
#: build/C/man4/sd.4:133
#, no-wrap
msgid "I</dev/sd[a-h][0-8]>"
msgstr " I</dev/sd[a-h][0-8]>"

#. .SH SEE ALSO
#. .BR scsi (4)
#. type: Plain text
#: build/C/man4/sd.4:138
msgid "individual block partitions"
msgstr "個々のブロックパーティション"

#. type: TH
#: build/C/man3/setlogmask.3:25
#, no-wrap
msgid "SETLOGMASK"
msgstr "SETLOGMASK"

#. type: Plain text
#: build/C/man3/setlogmask.3:28
msgid "setlogmask - set log priority mask"
msgstr "setlogmask - ログの優先度マスクを設定する"

#. type: Plain text
#: build/C/man3/setlogmask.3:31
#, no-wrap
msgid "B<#include E<lt>syslog.hE<gt>>\n"
msgstr "B<#include E<lt>syslog.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/setlogmask.3:33
#, no-wrap
msgid "B<int setlogmask(int >I<mask>B<);>\n"
msgstr "B<int setlogmask(int >I<mask>B<);>\n"

#. type: Plain text
#: build/C/man3/setlogmask.3:43
msgid ""
"A process has a log priority mask that determines which calls to "
"B<syslog>(3)  may be logged.  All other calls will be ignored.  Logging is "
"enabled for the priorities that have the corresponding bit set in I<mask>.  "
"The initial mask is such that logging is enabled for all priorities."
msgstr ""
"プロセスにはログ優先度マスク(log priority mask)が用意されていて、 これを用い"
"て B<syslog>(3)  が呼び出された場合にログ記録を行うかどうかを決定する。 他の"
"すべての関数が呼び出された場合はログ記録が行われない。 I<mask> の各ビットは優"
"先度に対応しており、対応するビットが 1 にセットされている 優先度に対してログ"
"収集(logging)が有効になる。 マスクの初期値は、すべての優先度に対してログ収集"
"が有効になるような値である。"

#. type: Plain text
#: build/C/man3/setlogmask.3:49
msgid ""
"The B<setlogmask>()  function sets this logmask for the calling process, and "
"returns the previous mask.  If the mask argument is 0, the current logmask "
"is not modified."
msgstr ""
"B<setlogmask>()  関数は、呼び出し元のプロセスに対するログマスクを設定し、 変"
"更前のマスクを返す。 I<mask> 引数が 0 ならば、現在のログマスクは変更されな"
"い。"

#. type: Plain text
#: build/C/man3/setlogmask.3:69
msgid ""
"The eight priorities are B<LOG_EMERG>, B<LOG_ALERT>, B<LOG_CRIT>, "
"B<LOG_ERR>, B<LOG_WARNING>, B<LOG_NOTICE>, B<LOG_INFO>, and B<LOG_DEBUG>.  "
"The bit corresponding to a priority I<p> is I<LOG_MASK(p)>.  Some systems "
"also provide a macro I<LOG_UPTO(p)> for the mask of all priorities in the "
"above list up to and including I<p>."
msgstr ""
"以下の8レベルの優先度が定義されている(優先度の高い順)： B<LOG_EMERG>, "
"B<LOG_ALERT>, B<LOG_CRIT>, B<LOG_ERR>, B<LOG_WARNING>, B<LOG_NOTICE>, "
"B<LOG_INFO>, B<LOG_DEBUG>。 優先度 I<p> に対応するビット列は I<LOG_MASK(p)> "
"によって求められる。 優先度 I<p> 以上のすべての優先度 (I<p> を含む) のマスク"
"ビットを 求めることができるマクロ I<LOG_UPTO(p)> を使用できるシステムもある。"

#. type: Plain text
#: build/C/man3/setlogmask.3:71
msgid "This function returns the previous log priority mask."
msgstr "変更前のログ優先度マスクの値を返す。"

#.  .SH NOTES
#.  The glibc logmask handling was broken in versions before glibc 2.1.1.
#. type: Plain text
#: build/C/man3/setlogmask.3:75
msgid "None."
msgstr "なし。"

#. type: tbl table
#: build/C/man3/setlogmask.3:85
#, no-wrap
msgid "B<setlogmask>()"
msgstr "B<setlogmask>()"

#. type: tbl table
#: build/C/man3/setlogmask.3:85
#, no-wrap
msgid "MT-Unsafe race:LogMask"
msgstr "MT-Unsafe race:LogMask"

#.  Note that the description in POSIX.1-2001 is flawed.
#. type: Plain text
#: build/C/man3/setlogmask.3:91
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#.  FIXME . https://www.austingroupbugs.net/view.php?id=1033
#. type: Plain text
#: build/C/man3/setlogmask.3:95
msgid ""
"B<LOG_UPTO>()  will be included in the next release of the POSIX "
"specification (Issue 8)."
msgstr ""

#. type: Plain text
#: build/C/man3/setlogmask.3:99
msgid "B<closelog>(3), B<openlog>(3), B<syslog>(3)"
msgstr "B<closelog>(3), B<openlog>(3), B<syslog>(3)"

#. type: TH
#: build/C/man4/sk98lin.4:27
#, no-wrap
msgid "SK98LIN"
msgstr "SK98LIN"

#. type: Plain text
#: build/C/man4/sk98lin.4:30
msgid "sk98lin - Marvell/SysKonnect Gigabit Ethernet driver v6.21"
msgstr "sk98lin - Marvell/SysKonnect ギガビットイーサネットドライバ v6.21"

#. type: Plain text
#: build/C/man4/sk98lin.4:62
msgid ""
"B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] "
"[B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>] "
"[B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] [B<FlowCtrl_B=>I<i,j,..."
">] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] [B<ConType=>I<i,j,...>] "
"[B<Moderation=>I<i,j,...>] [B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,..."
">] [B<RlmtMode=>I<i,j,...>]"
msgstr ""
"B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] "
"[B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>] "
"[B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] [B<FlowCtrl_B=>I<i,j,..."
">] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] [B<ConType=>I<i,j,...>] "
"[B<Moderation=>I<i,j,...>] [B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,..."
">] [B<RlmtMode=>I<i,j,...>]"

#. type: Plain text
#: build/C/man4/sk98lin.4:67
msgid ""
"B<Note>: This obsolete driver was removed from the kernel in version 2.6.26."
msgstr "B<注意>: この時代遅れのドライバはカーネル 2.6.26 で削除された。"

#. type: Plain text
#: build/C/man4/sk98lin.4:74
msgid ""
"B<sk98lin> is the Gigabit Ethernet driver for Marvell and SysKonnect network "
"adapter cards.  It supports SysKonnect SK-98xx/SK-95xx compliant Gigabit "
"Ethernet Adapter and any Yukon compliant chipset."
msgstr ""
"B<sk98lin> は Marvell と SysKonnect のネットワークアダプターカードの ギガビッ"
"トイーサネットドライバである。 これは SysKonnect SK-98xx/SK-95xx 互換のギガ"
"ビットイーサネットアダプターと Yukon 互換のチップセットをサポートしている。"

#. type: Plain text
#: build/C/man4/sk98lin.4:81
msgid ""
"When loading the driver using insmod, parameters for the network adapter "
"cards might be stated as a sequence of comma separated commands.  If for "
"instance two network adapters are installed and AutoNegotiation on Port A of "
"the first adapter should be ON, but on the Port A of the second adapter "
"switched OFF, one must enter:"
msgstr ""
"insmod を使ってドライバをロードする際、 ネットワークアダプターカードのパラ"
"メーターを コンマで区切られたコマンドの列として指定することができる。 2 つの"
"ネットワークアダプターが取り付けられている時に、 例えば、1 つ目のアダプターの"
"ポート A の自動ネゴシエーションは ON にするが、 2 つ目のアダプターのポート A "
"は OFF にする場合は、 以下のように入力すればよい:"

#. type: Plain text
#: build/C/man4/sk98lin.4:83
#, no-wrap
msgid "   insmod sk98lin.o AutoNeg_A=On,Off\n"
msgstr "   insmod sk98lin.o AutoNeg_A=On,Off\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:98
msgid ""
"After B<sk98lin> is bound to one or more adapter cards and the I</proc> "
"filesystem is mounted on your system, a dedicated statistics file will be "
"created in the folder I</proc/net/sk98lin> for all ports of the installed "
"network adapter cards.  Those files are named I<eth[x]>, where I<x> is the "
"number of the interface that has been assigned to a dedicated port by the "
"system."
msgstr ""
"B<sk98lin> が 1 つ以上のアダプターカードに関連づけられていて、 かつ I</proc> "
"ファイルシステムがシステムにマウントされている場合、 取り付けられているネット"
"ワークアダプターカードの全てのポートについて、 (ポート単位に) 専用の統計ファ"
"イルがフォルダ I</proc/net/sk98lin> に作られる。 これらのファイルは "
"I<eth[x]> という名前であり、 I<x> はインターフェースの番号である。 この番号は"
"システムによってポート毎に割り当てられたものである。"

#. type: Plain text
#: build/C/man4/sk98lin.4:108
msgid ""
"If loading is finished, any desired IP address can be assigned to the "
"respective I<eth[x]> interface using the B<ifconfig>(8)  command.  This "
"causes the adapter to connect to the Ethernet and to display a status "
"message on the console saying \"ethx: network connection up using port y\" "
"followed by the configured or detected connection parameters."
msgstr ""
"ロードが完了すると、 B<ifconfig>(8)  コマンドを使って、各 I<eth[x]> インター"
"フェースに希望する IP アドレスを割り当てることができる。 これによりアダプター"
"がイーサネットに接続され、 コンソールに状態メッセージが表示される。 このメッ"
"セージでは、 \"ethx: network connection up using port y\" の後に 設定されたり"
"検出された接続パラメーターが表示される。"

#. type: Plain text
#: build/C/man4/sk98lin.4:124
msgid ""
"The B<sk98lin> also supports large frames (also called jumbo frames).  Using "
"jumbo frames can improve throughput tremendously when transferring large "
"amounts of data.  To enable large frames, the MTU (maximum transfer unit) "
"size for an interface is to be set to a high value.  The default MTU size is "
"1500 and can be changed up to 9000 (bytes).  Setting the MTU size can be "
"done when assigning the IP address to the interface or later by using the "
"B<ifconfig>(8)  command with the mtu parameter.  If for instance eth0 needs "
"an IP address and a large frame MTU size, the following two commands might "
"be used:"
msgstr ""
"B<sk98lin> はラージフレーム (ジャンボフレームとも呼ばれる) もサポートする。 "
"ジャンボフレームを使うと、大量のデータを転送する際に、 スループットを大幅に向"
"上させることができる。 ラージフレームを有効にするには、 インターフェースの "
"MTU (maximum transfer unit, 最大転送単位) サイズを 大きな値に設定すればよ"
"い。 デフォルトの MTU サイズは 1500 であり、 最大で 9000 (バイト) まで設定す"
"ることができる。 MTU サイズを設定するのは、 インターフェースに IP アドレスを"
"割り当てるときにもできるし、後から B<ifconfig>(8)  コマンドに mtu 引数を指"
"定することで設定することもできる。 例えば、eth0 に IP アドレスとラージフレー"
"ム MTU サイズを 割り当てたい場合、以下の 2 つのコマンドを実行すればよい:"

#. type: Plain text
#: build/C/man4/sk98lin.4:127
#, no-wrap
msgid ""
"    ifconfig eth0 10.1.1.1\n"
"    ifconfig eth0 mtu 9000\n"
msgstr ""
"    ifconfig eth0 10.1.1.1\n"
"    ifconfig eth0 mtu 9000\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:129
msgid "Those two commands might even be combined into one:"
msgstr "これらの 2 つのコマンドは 1 つにまとめることもできる:"

#. type: Plain text
#: build/C/man4/sk98lin.4:131
#, no-wrap
msgid "    ifconfig eth0 10.1.1.1 mtu 9000\n"
msgstr "    ifconfig eth0 10.1.1.1 mtu 9000\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:144
msgid ""
"Note that large frames can be used only if permitted by your network "
"infrastructure.  This means, that any switch being used in your Ethernet "
"must also support large frames.  Quite some switches support large frames, "
"but need to be configured to do so.  Most of the times, their default "
"setting is to support only standard frames with an MTU size of 1500 "
"(bytes).  In addition to the switches inside the network, all network "
"adapters that are to be used must also be enabled regarding jumbo frames.  "
"If an adapter is not set to receive large frames, it will simply drop them."
msgstr ""
"ラージフレームを使用できるのは、ネットワーク環境全体で ラージフレームの使用が"
"認められている場合のみである点に注意すること。 つまり、イーサネットで使われて"
"いる全てのスイッチでも ラージフレームがサポートされていなければならない。 多"
"くのスイッチがラージフレームをサポートしてはいるが、 設定を行う必要がある。 "
"多くの場合、デフォルトの設定では標準フレーム (1500 バイトの MTU サイズ) だけ"
"しかサポートしない。 ネットワーク内のスイッチに加え、 使用される全てのネット"
"ワークアダプターでも ジャンボフレームが有効になっていなければならない。 アダ"
"プターがラージフレームを受け取るように設定されていない場合、 アダプターはその"
"フレームを単純に捨ててしまう。"

#. type: Plain text
#: build/C/man4/sk98lin.4:148
msgid ""
"Switching back to the standard Ethernet frame size can be done by using the "
"B<ifconfig>(8)  command again:"
msgstr ""
"標準のイーサネットフレームサイズに戻すのは、再び B<ifconfig>(8)  コマンドを使"
"えばよい:"

#. type: Plain text
#: build/C/man4/sk98lin.4:150
#, no-wrap
msgid "    ifconfig eth0 mtu 1500\n"
msgstr "    ifconfig eth0 mtu 1500\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:156
msgid ""
"The Marvell/SysKonnect Gigabit Ethernet driver for Linux is able to support "
"VLAN and Link Aggregation according to IEEE standards 802.1, 802.1q, and "
"802.3ad.  Those features are available only after installation of open "
"source modules which can be found on the Internet:"
msgstr ""
"Linux の Marvell/SysKonnect ギガビットイーサネットドライバは、 IEEE 規格 "
"802.1, 802.1q, 802.3ad に準拠する VLAN と Link Aggregation に対応している。 "
"これらの機能は、インターネットにあるオープンソースモジュールを インストールし"
"た後でのみ利用可能である:"

#. type: Plain text
#: build/C/man4/sk98lin.4:161
msgid ""
"I<VLAN>: E<.UR http://www.candelatech.com\\:/\\(tigreear\\:/vlan.html> E<.UE>"
msgstr " I<VLAN>: E<.UR http://www.candelatech.com\\:/\\(tigreear\\:/vlan.html> E<.UE>"

#. type: Plain text
#: build/C/man4/sk98lin.4:167
msgid ""
"I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/\\(tiyumo> E<.UE>"
msgstr " I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/\\(tiyumo> E<.UE>"

#. type: Plain text
#: build/C/man4/sk98lin.4:171
msgid ""
"Note that Marvell/SysKonnect does not offer any support for these open "
"source modules and does not take the responsibility for any kind of failures "
"or problems arising when using these modules."
msgstr ""
"Marvell/SysKonnect は、これらのオープンソースモジュールに対するサポートは "
"行っておらず、これらを使った場合に生じるいかなる失敗や問題についても 責任を負"
"わない点に注意すること。"

#. type: SS
#: build/C/man4/sk98lin.4:171 build/C/man4/wavelan.4:39
#, no-wrap
msgid "Parameters"
msgstr "パラメーター"

#. type: TP
#: build/C/man4/sk98lin.4:172
#, no-wrap
msgid "B<Speed_A=>I<i,j,...>"
msgstr "B<Speed_A=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:189
msgid ""
"This parameter is used to set the speed capabilities of port A of an adapter "
"card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr ""
"このパラメーターはアダプターカードのポート A がサポートするリンク速度を 設定"
"するのに使われる。これは Yukon copper アダプターでのみ有効である。 使用可能な"
"値は以下の通り: I<10>, I<100>, I<1000>, I<Auto>。 デフォルトは I<Auto> であ"
"る。 通常、リンク速度はリンクの確立時に 2 つのポートの間で自動設定される。 こ"
"れに失敗した場合、ポートはこの引数で指定された設定になる。"

#. type: TP
#: build/C/man4/sk98lin.4:189
#, no-wrap
msgid "B<Speed_B=>I<i,j,...>"
msgstr "B<Speed_B=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:206
msgid ""
"This parameter is used to set the speed capabilities of port B of an adapter "
"card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr ""
"このパラメーターはアダプターカードのポート B がサポートするリンク速度を 設定"
"するのに使われる。これは Yukon copper アダプターでのみ有効である。 使用可能な"
"値は以下の通り: I<10>, I<100>, I<1000>, I<Auto>。 デフォルトは I<Auto> であ"
"る。 通常、リンク速度はリンクの確立時に 2 つのポートの間で自動設定される。 こ"
"れに失敗した場合、ポートはこの引数で指定された設定になる。"

#. type: TP
#: build/C/man4/sk98lin.4:206
#, no-wrap
msgid "B<AutoNeg_A=>I<i,j,...>"
msgstr "B<AutoNeg_A=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:220
msgid ""
"Enables or disables the use of autonegotiation of port A of an adapter "
"card.  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the "
"default.  The I<Sense> mode automatically detects whether the link partner "
"supports auto-negotiation or not."
msgstr ""
"アダプターカードのポート A の自動設定 (autonegotiation) の使用を 有効または無"
"効にする。使用可能な値は以下の通り: I<On>, I<Off>, I<Sense>。 デフォルトは "
"I<On> である。 I<Sense> モードはリンクパートナが自動設定をサポートしているか"
"否かを 自動的に検知する。"

#. type: TP
#: build/C/man4/sk98lin.4:220
#, no-wrap
msgid "B<AutoNeg_B=>I<i,j,...>"
msgstr "B<AutoNeg_B=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:234
msgid ""
"Enables or disables the use of autonegotiation of port B of an adapter "
"card.  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the "
"default.  The I<Sense> mode automatically detects whether the link partner "
"supports auto-negotiation or not."
msgstr ""
"アダプターカードのポート B の自動設定 (autonegotiation) の使用を 有効または無"
"効にする。使用可能な値は以下の通り: I<On>, I<Off>, I<Sense>。 デフォルトは "
"I<On> である。 I<Sense> モードはリンクパートナが自動設定をサポートしているか"
"否かを 自動的に検知する。"

#. type: TP
#: build/C/man4/sk98lin.4:234
#, no-wrap
msgid "B<DupCap_A=>I<i,j,...>"
msgstr "B<DupCap_A=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:264
msgid ""
"This parameter indicates the duplex mode to be used for port A of an adapter "
"card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_A of port A is not set "
"to I<Sense>.  If AutoNeg_A is set to I<On>, all three values of DupCap_A "
"( I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_A is set to "
"I<Off>, only DupCap_A values I<Full> and I<Half> are allowed.  This DupCap_A "
"parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr ""
"この引数はアダプターカードのポート A で使う二重通信 (duplex) モードを示"
"す。 使用可能な値は以下の通り: I<Half>, I<Full>, I<Both>。 デフォルトは "
"I<Both> である。 この引数はポート A の AutoNeg_A が I<Sense> に設定されてい"
"ない場合にのみ有効である。 AutoNeg_A が I<On> の場合、DupCap_A の 3 つの値 "
"(I<Half>, I<Full>, I<Both>)  のうちどれでも指定することができる。 AutoNeg_A "
"が I<Off> の場合、DupCap_A の値 I<Full> と I<Half> のみを指定することができ"
"る。 この DupCap_A 引数は、リンクパートナが全ての二重通信の組み合わせを サ"
"ポートしていない場合に役に立つ。"

#. type: TP
#: build/C/man4/sk98lin.4:264
#, no-wrap
msgid "B<DupCap_B=>I<i,j,...>"
msgstr "B<DupCap_B=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:294
msgid ""
"This parameter indicates the duplex mode to be used for port B of an adapter "
"card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_B of port B is not set "
"to I<Sense>.  If AutoNeg_B is set to I<On>, all three values of DupCap_B "
"( I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_B is set to "
"I<Off>, only DupCap_B values I<Full> and I<Half> are allowed.  This DupCap_B "
"parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr ""
"この引数はアダプターカードのポート B で使う二重通信モードを示す。 使用可能"
"な値は以下の通り: I<Half>, I<Full>, I<Both>。 デフォルトは I<Both> である。 "
"この引数はポート B の AutoNeg_B が I<Sense> に設定されていない場合にのみ有"
"効である。 AutoNeg_B が I<On> の場合、DupCap_B の 3 つの値 (I<Half>, "
"I<Full>, I<Both>)  のうちどれでも指定することができる。 AutoNeg_B が I<Off> "
"の場合、DupCap_B の値 I<Full> と I<Half> のみを指定することができる。 この "
"DupCap_B 引数は、リンクパートナが全ての二重通信の組み合わせを サポートして"
"いない場合に役に立つ。"

#. type: TP
#: build/C/man4/sk98lin.4:294
#, no-wrap
msgid "B<FlowCtrl_A=>I<i,j,...>"
msgstr "B<FlowCtrl_A=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:307 build/C/man4/sk98lin.4:339
msgid ""
"This parameter can be used to set the flow control capabilities the port "
"reports during auto-negotiation.  Possible values are: I<Sym>, I<SymOrRem>, "
"I<LocSend>, or I<None>; I<SymOrRem> is the default.  The different modes "
"have the following meaning:"
msgstr ""
"この引数は自動設定時にポートが対向に伝える フロー制御機能を設定する。 使用"
"可能な値は以下の通り: I<Sym>, I<SymOrRem>, I<LocSend>, I<None>。 デフォルト"
"は I<SymOrRem> である。 それぞれのモードには以下のような意味がある:"

#. type: Plain text
#: build/C/man4/sk98lin.4:311 build/C/man4/sk98lin.4:343
#, no-wrap
msgid ""
"I<Sym>\n"
"= Symmetric\n"
" both link partners are allowed to send PAUSE frames\n"
msgstr ""
"I<Sym>\n"
"= Symmetric\n"
" リンクパートナの双方が PAUSE フレームを送ることができる。\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:315 build/C/man4/sk98lin.4:347
#, no-wrap
msgid ""
"I<SymOrRem>\n"
"= SymmetricOrRemote\n"
" both or only remote partner are allowed to send PAUSE frames\n"
msgstr ""
"I<SymOrRem>\n"
"= SymmetricOrRemote\n"
" リンクパートナの双方またはリモートパートナのみが\n"
"PAUSE フレームを送ることができる。\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:319 build/C/man4/sk98lin.4:351
#, no-wrap
msgid ""
"I<LocSend>\n"
"= LocalSend\n"
" only local link partner is allowed to send PAUSE frames\n"
msgstr ""
"I<LocSend>\n"
"= LocalSend\n"
" ローカルリンクパートナのみが PAUSE フレームを送ることができる。\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:323 build/C/man4/sk98lin.4:355
#, no-wrap
msgid ""
"I<None>\n"
"= None\n"
" no link partner is allowed to send PAUSE frames\n"
msgstr ""
"I<None>\n"
"= None\n"
" リンクパートナのどちらも PAUSE フレームを送ることはできない。\n"

#. type: Plain text
#: build/C/man4/sk98lin.4:326
msgid "Note that this parameter is ignored if AutoNeg_A is set to I<Off>."
msgstr ""
"このパラメーターは AutoNeg_A が I<Off> の場合には無視される点に注意すること。"

#. type: TP
#: build/C/man4/sk98lin.4:326
#, no-wrap
msgid "B<FlowCtrl_B=>I<i,j,...>"
msgstr "B<FlowCtrl_B=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:359
msgid "Note that this parameter is ignored if AutoNeg_B is set to I<Off>."
msgstr ""
"このパラメーターは AutoNeg_B が I<Off> の場合には無視される点に注意すること。"

#. type: TP
#: build/C/man4/sk98lin.4:359
#, no-wrap
msgid "B<Role_A=>I<i,j,...>"
msgstr "B<Role_A=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:375
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two 1000Base-"
"T ports to communicate, one must take the role of the master (providing "
"timing information), while the other must be the slave.  Possible values "
"are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  Usually, the "
"role of a port is negotiated between two ports during link establishment, "
"but if that fails the port A of an adapter card can be forced to a specific "
"setting with this parameter."
msgstr ""
"この引数は 1000Base-T アダプターカードでのみ有効である。 2 つの 1000Base-T "
"ポートが通信する場合、 片方が (タイミング情報を提供する) マスタの役割をしなけ"
"ればならず、 もう片方がスレーブにならなければならない。 使用可能な値は以下の"
"通り: I<Auto>, I<Master>, I<Slave>。 デフォルトは I<Auto> である。 通常、ポー"
"トの役割は 2 つのポートでリンクを確立するときに自動設定される。 自動設定に失"
"敗した場合、 アダプターカードのポート A はこの引数で指定された設定になる。"

#. type: TP
#: build/C/man4/sk98lin.4:375
#, no-wrap
msgid "B<Role_B=>I<i,j,...>"
msgstr "B<Role_B=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:392
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two 1000Base-"
"T ports to communicate, one must take the role of the master (providing "
"timing information), while the other must be the slave.  Possible values "
"are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  Usually, the "
"role of a port is negotiated between two ports during link establishment, "
"but if that fails the port B of an adapter card can be forced to a specific "
"setting with this parameter."
msgstr ""
"この引数は 1000Base-T アダプターカードでのみ有効である。 2 つの 1000Base-T "
"ポートが通信する場合、 片方が (タイミング情報を提供する) マスタの役割をしなけ"
"ればならず、 もう片方がスレーブにならなければならない。 使用可能な値は以下の"
"通り: I<Auto>, I<Master>, I<Slave>。 デフォルトは I<Auto> である。 通常、ポー"
"トの役割は 2 つのポートでリンクを確立するときに自動設定される。 自動設定に失"
"敗した場合、 アダプターカードのポート B はこの引数で指定された設定になる。"

#. type: TP
#: build/C/man4/sk98lin.4:392
#, no-wrap
msgid "B<ConType=>I<i,j,...>"
msgstr "B<ConType=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:400
msgid ""
"This parameter is a combination of all five per-port parameters within one "
"single parameter.  This simplifies the configuration of both ports of an "
"adapter card.  The different values of this variable reflect the most "
"meaningful combinations of port parameters.  Possible values and their "
"corresponding combination of per-port parameters:"
msgstr ""
"この引数は、ポート毎に指定する、全部で 5 個の引数の組み合わせを、 1 つの"
"引数にしたものである。 これによりアダプターカードの 2 つのポートの設定を簡"
"略化できる。 この変数のそれぞれの値は、 ポート引数の最も意味のある組み合わ"
"せを反映したものである。 使用可能な値とそれに対応するポート毎のパラメーターの"
"組み合わせは、 以下の通り:"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "ConType"
msgstr "ConType"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "DupCap"
msgstr "DupCap"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "AutoNeg"
msgstr "AutoNeg"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "FlowCtrl"
msgstr "FlowCtrl"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "Role"
msgstr "Role"

#. type: tbl table
#: build/C/man4/sk98lin.4:404
#, no-wrap
msgid "Speed"
msgstr "Speed"

#. type: tbl table
#: build/C/man4/sk98lin.4:405
#, no-wrap
msgid "I<Auto>"
msgstr "I<Auto>"

#. type: tbl table
#: build/C/man4/sk98lin.4:405
#, no-wrap
msgid "Both"
msgstr "Both"

#. type: tbl table
#: build/C/man4/sk98lin.4:405
#, no-wrap
msgid "On"
msgstr "On"

#. type: tbl table
#: build/C/man4/sk98lin.4:405
#, no-wrap
msgid "SymOrRem"
msgstr "SymOrRem"

#. type: tbl table
#: build/C/man4/sk98lin.4:405 build/C/man4/sk98lin.4:406
#: build/C/man4/sk98lin.4:407 build/C/man4/sk98lin.4:408
#: build/C/man4/sk98lin.4:409
#, no-wrap
msgid "Auto"
msgstr "Auto"

#. type: tbl table
#: build/C/man4/sk98lin.4:406
#, no-wrap
msgid "I<100FD>"
msgstr "I<100FD>"

#. type: tbl table
#: build/C/man4/sk98lin.4:406 build/C/man4/sk98lin.4:408
#, no-wrap
msgid "Full"
msgstr "Full"

#. type: tbl table
#: build/C/man4/sk98lin.4:406 build/C/man4/sk98lin.4:407
#: build/C/man4/sk98lin.4:408 build/C/man4/sk98lin.4:409
#, no-wrap
msgid "Off"
msgstr "Off"

#. type: tbl table
#: build/C/man4/sk98lin.4:406 build/C/man4/sk98lin.4:407
#: build/C/man4/sk98lin.4:408 build/C/man4/sk98lin.4:409
#, no-wrap
msgid "None"
msgstr "なし"

#. type: tbl table
#: build/C/man4/sk98lin.4:407
#, no-wrap
msgid "I<100HD>"
msgstr "I<100HD>"

#. type: tbl table
#: build/C/man4/sk98lin.4:407 build/C/man4/sk98lin.4:409
#, no-wrap
msgid "Half"
msgstr "Half"

#. type: tbl table
#: build/C/man4/sk98lin.4:408
#, no-wrap
msgid "I<10FD>"
msgstr "I<10FD>"

#. type: tbl table
#: build/C/man4/sk98lin.4:409
#, no-wrap
msgid "I<10HD>"
msgstr "I<10HD>"

#. type: Plain text
#: build/C/man4/sk98lin.4:420
msgid ""
"Stating any other port parameter together with this I<ConType> parameter "
"will result in a merged configuration of those settings.  This is due to the "
"fact, that the per-port parameters (e.g., I<Speed_A>)  have a higher "
"priority than the combined variable I<ConType>."
msgstr ""
"その他のポート引数を I<ConType> 引数と組み合わせて指定すると、それらの設"
"定を結合した設定となる。 これは、ポート毎の引数 (例えば I<Speed_A>)  の方が"
"組み合わせ変数 I<ConType> より優先順位が高いためである。"

#. type: TP
#: build/C/man4/sk98lin.4:420
#, no-wrap
msgid "B<Moderation=>I<i,j,...>"
msgstr "B<Moderation=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:437
msgid ""
"Interrupt moderation is employed to limit the maximum number of interrupts "
"the driver has to serve.  That is, one or more interrupts (which indicate "
"any transmit or receive packet to be processed) are queued until the driver "
"processes them.  When queued interrupts are to be served, is determined by "
"the I<IntsPerSec> parameter, which is explained later below.  Possible "
"moderation modes are: I<None>, I<Static>, or I<Dynamic>; I<None> is the "
"default.  The different modes have the following meaning:"
msgstr ""
"割り込み調停 (interrupt moderation) は、ドライバが処理を開始しなければ ならな"
"い割り込み回数の最大値を設定するために使用される。 つまり、ドライバが処理を行"
"うまで、1回以上の割り込み (送信または受信パケットが処理されること) がキューに"
"入れられる。 キューに入れられた割り込みがいつ処理されるかは、 以下で説明する "
"I<IntsPerSec> 引数で決定される。 使用可能な調停モードは以下の通り: "
"I<None>, I<Static>, I<Dynamic>。 デフォルトは I<None> である。 それぞれのモー"
"ドは以下の意味を持つ:"

#. type: Plain text
#: build/C/man4/sk98lin.4:442
msgid ""
"I<None> No interrupt moderation is applied on the adapter card.  Therefore, "
"each transmit or receive interrupt is served immediately as soon as it "
"appears on the interrupt line of the adapter card."
msgstr ""
"I<None> アダプターカードに対して割り込み調停を適用しない。 よって送信または受"
"信割り込みは、 アダプターカードの割り込み線に現れると直ぐに処理される。"

#. type: Plain text
#: build/C/man4/sk98lin.4:456
msgid ""
"I<Static> Interrupt moderation is applied on the adapter card.  All transmit "
"and receive interrupts are queued until a complete moderation interval "
"ends.  If such a moderation interval ends, all queued interrupts are "
"processed in one big bunch without any delay.  The term I<Static> reflects "
"the fact, that interrupt moderation is always enabled, regardless how much "
"network load is currently passing via a particular interface.  In addition, "
"the duration of the moderation interval has a fixed length that never "
"changes while the driver is operational."
msgstr ""
"I<Static> アダプターカードに対して割り込み調停が適用される。 全ての送信または"
"受信割り込みは、調停間隔が完全に終わるまで キューに入れられる。 この調停間隔"
"が終わると、キューに入れられた全ての割り込みは、 1個の大きな塊として遅延なく"
"処理される。 I<Static> という用語は、あるインターフェースに現在どれだけの "
"ネットワーク負荷がかかっているかに関わらず、 割り込み調停が常に有効になること"
"を表している。 さらに、調停間隔の時間は固定で、ドライバが動作している間は変化"
"しない。"

#. type: Plain text
#: build/C/man4/sk98lin.4:466
msgid ""
"I<Dynamic> Interrupt moderation might be applied on the adapter card, "
"depending on the load of the system.  If the driver detects that the system "
"load is too high, the driver tries to shield the system against too much "
"network load by enabling interrupt moderation.  If\\(emat a later time"
"\\(emthe CPU utilization decreases again (or if the network load is "
"negligible), the interrupt moderation will automatically be disabled."
msgstr ""
"I<Dynamic> システムの負荷に応じて、アダプターカードに対して割り込み調停が適用"
"される。 ドライバがシステムの負荷が高すぎると検出した場合、 割り込み調停を有"
"効にすることにより、 過剰なネットワーク負荷からシステムを保護しようとする。 "
"\\(emその後に\\(emCPU 利用率が再び下がった場合 (またはネットワーク負荷が極わ"
"ずかになった場合)、 割り込み調停は自動的に無効にされる。"

#. type: Plain text
#: build/C/man4/sk98lin.4:472
msgid ""
"Interrupt moderation should be used when the driver has to handle one or "
"more interfaces with a high network load, which\\(emas a consequence"
"\\(emleads also to a high CPU utilization.  When moderation is applied in "
"such high network load situations, CPU load might be reduced by 20\\(en30% "
"on slow computers."
msgstr "ドライバが扱わなければならないインターフェースのうち ネットワーク負荷が高いものが 1 つ以上あり、 \\(emその結果\\(emCPU 利用率が高くなっている場合、 割り込み調停を使うべきである。 ネットワーク負荷が高い状況で調停が適用されると、 遅いコンピュータでは CPU 負荷が 20\\(en30% 削減されるだろう。"

#. type: Plain text
#: build/C/man4/sk98lin.4:476
msgid ""
"Note that the drawback of using interrupt moderation is an increase of the "
"round-trip-time (RTT), due to the queuing and serving of interrupts at "
"dedicated moderation times."
msgstr ""
"割り込み調停を使うことの欠点として、 往復遅延時間 (round-trip-time, RTT) の増"
"加がある点に注意すること。 これは、割り込みがキューに入れられ、まとめて処理さ"
"れるためである。"

#. type: TP
#: build/C/man4/sk98lin.4:476
#, no-wrap
msgid "B<IntsPerSec=>I<i,j,...>"
msgstr "B<IntsPerSec=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:486
msgid ""
"This parameter determines the length of any interrupt moderation interval.  "
"Assuming that static interrupt moderation is to be used, an I<IntsPerSec> "
"parameter value of 2000 will lead to an interrupt moderation interval of 500 "
"microseconds.  Possible values for this parameter are in the range of "
"30...40000 (interrupts per second).  The default value is 2000."
msgstr ""
"この引数は割り込み調停の間隔を決定する。 静的 (static) 割り込み調停が使われ"
"ている場合、 I<IntsPerSec> 引数の値が 2000 であれば、割り込み調停の間隔は "
"500 ミリ秒になる。 この引数に設定可能な値は 30...40000 の範囲で、 これは 1 "
"秒毎の割り込み回数である。 デフォルト値は 2000 である。"

#. type: Plain text
#: build/C/man4/sk98lin.4:490
msgid ""
"This parameter is used only if either static or dynamic interrupt moderation "
"is enabled on a network adapter card.  This parameter is ignored if no "
"moderation is applied."
msgstr ""
"この引数は静的 (static) または動的 (dynamic) 割り込み調停が 有効になってい"
"るときにのみ使用される。 この引数は割り込み調停が適用されていない場合には無"
"視される。"

#. type: Plain text
#: build/C/man4/sk98lin.4:497
msgid ""
"Note that the duration of the moderation interval is to be chosen with "
"care.  At first glance, selecting a very long duration (e.g., only 100 "
"interrupts per second) seems to be meaningful, but the increase of packet-"
"processing delay is tremendous.  On the other hand, selecting a very short "
"moderation time might compensate the use of any moderation being applied."
msgstr ""
"調停間隔の期間は注意して選ぶこと。 一見したところでは、とても長い期間 (例え"
"ば 1 秒間に 100 回だけの割り込み) を 選ぶことに意味があるように見えるかもしれ"
"ないが、そうすると パケット処理の遅延が激しく増加する。 一方で、とても短い調"
"停時間を選ぶと、割り込み調停を使う意味がなくなってしまう。"

#. type: TP
#: build/C/man4/sk98lin.4:497
#, no-wrap
msgid "B<PrefPort=>I<i,j,...>"
msgstr "B<PrefPort=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:509
msgid ""
"This parameter is used to force the preferred port to A or B (on dual-port "
"network adapters).  The preferred port is the one that is used if both ports "
"A and B are detected as fully functional.  Possible values are: I<A> or "
"I<B>; I<A> is the default."
msgstr ""
"この引数は (2 ポートのネットワークアダプターで)  優先 (preferred) ポートを "
"A または B のどちらにするかを指定するのに使われる。 優先ポートとは、A と B の"
"両方のポートが完全に機能していると検知された場合に 使用されるポートである。 "
"使用可能な値は以下の通り: I<A> または I<B>。 デフォルトは I<A> である。"

#. type: TP
#: build/C/man4/sk98lin.4:509
#, no-wrap
msgid "B<RlmtMode=>I<i,j,...>"
msgstr "B<RlmtMode=>I<i,j,...>"

#. type: Plain text
#: build/C/man4/sk98lin.4:525
msgid ""
"RLMT monitors the status of the port.  If the link of the active port fails, "
"RLMT switches immediately to the standby link.  The virtual link is "
"maintained as long as at least one \"physical\" link is up.  This parameters "
"states how RLMT should monitor both ports.  Possible values are: "
"I<CheckLinkState>, I<CheckLocalPort>, I<CheckSeg>, or I<DualNet>; "
"I<CheckLinkState> is the default.  The different modes have the following "
"meaning:"
msgstr ""
"RLMT はポートの状態を監視する。 アクティブなポートのリンクが落ちた場合、 "
"RLMT は即時に待機しているリンクに切り替える。 少なくとも 1 つの「物理的」リン"
"クが起動するまでは、仮想リンクが維持される。 この引数は RLMT が両方のポート"
"をどのように監視するかを決める。 使用可能な値は以下の通り: "
"I<CheckLinkState>, I<CheckLocalPort>, I<CheckSeg>, I<DualNet>。 デフォルトは "
"I<CheckLinkState> である。 各モードは以下のような意味を持つ。"

#. type: Plain text
#: build/C/man4/sk98lin.4:530
msgid ""
"I<CheckLinkState> Check link state only: RLMT uses the link state reported "
"by the adapter hardware for each individual port to determine whether a port "
"can be used for all network traffic or not."
msgstr ""
"I<CheckLinkState> リンク状態のチェックのみ: RLMT は、各ポートについてアダプ"
"ターハードウェアが報告するリンク状態を使い、 そのポートが全てのネットワークト"
"ラフィックを送受信するのに使用可能かを 決定する。"

#. type: Plain text
#: build/C/man4/sk98lin.4:537
msgid ""
"I<CheckLocalPort> In this mode, RLMT monitors the network path between the "
"two ports of an adapter by regularly exchanging packets between them.  This "
"mode requires a network configuration in which the two ports are able to "
"\"see\" each other (i.e., there must not be any router between the ports)."
msgstr ""
"I<CheckLocalPort> このモードでは、RLMT はアダプターカードの 2 つのポートの間"
"で 定期的にパケットを交換することにより、 2 つのポートの間のネットワーク経路"
"を監視する。 このモードでは 2 つのポートが互いに「見える」ような ネットワーク"
"設定が必要である (つまり、ポート間にルーターがあってはならない)。"

#. type: Plain text
#: build/C/man4/sk98lin.4:545
msgid ""
"I<CheckSeg> Check local port and segmentation: This mode supports the same "
"functions as the CheckLocalPort mode and additionally checks network "
"segmentation between the ports.  Therefore, this mode is to be used only if "
"Gigabit Ethernet switches are installed on the network that have been "
"configured to use the Spanning Tree protocol."
msgstr ""
"I<CheckSeg> ローカルポートとセグメントをチェックする。 このモードは "
"CheckLocalPort モードと同じ機能を提供し、 更にポート間のネットワークセグメン"
"トをチェックする。 よって、このモードはネットワーク上に スパニングツリープロ"
"トコル (Spanning Tree protocol) を 使うように設定されたギガビットイーサネット"
"スイッチが 設置されている場合にのみ使用できる。"

#. type: Plain text
#: build/C/man4/sk98lin.4:555
msgid ""
"I<DualNet> In this mode, ports A and B are used as separate devices.  If you "
"have a dual port adapter, port A will be configured as I<eth[x]> and port B "
"as I<eth[x+1]>.  Both ports can be used independently with distinct IP "
"addresses.  The preferred port setting is not used.  RLMT is turned off."
msgstr ""
"I<DualNet> このモードでは、ポート A と B が別々のデバイスとして使用される。 "
"2 ポートのアダプターを持っている場合、ポート A を I<eth[x]> に、ポート B を "
"I<eth[x+1]> に設定することができる。 2 つのポートは別々の IP アドレスを付けて"
"独立に使用することができる。 優先ポートの設定は使用されない。 RLMT は無効にさ"
"れる。"

#. type: Plain text
#: build/C/man4/sk98lin.4:564
msgid ""
"Note that RLMT modes I<CheckLocalPort> and I<CheckLinkState> are designed to "
"operate in configurations where a network path between the ports on one "
"adapter exists.  Moreover, they are not designed to work where adapters are "
"connected back-to-back."
msgstr ""
"RLMT モード I<CheckLocalPort> と I<CheckLinkState> は、1 つのアダプター上の"
"ポート間でネットワーク経路があるような設定で 動作するように設計されている。 "
"さらに、このモードはアダプター同士が直結 (back-to-back) で 接続されている状態"
"で動作するようには設計されていない。"

#. type: TP
#: build/C/man4/sk98lin.4:565
#, no-wrap
msgid "I</proc/net/sk98lin/eth[x]>"
msgstr "I</proc/net/sk98lin/eth[x]>"

#. type: Plain text
#: build/C/man4/sk98lin.4:570
msgid ""
"The statistics file of a particular interface of an adapter card.  It "
"contains generic information about the adapter card plus a detailed summary "
"of all transmit and receive counters."
msgstr ""
"アダプターカードの特定のインターフェースの統計ファイル。 このファイルには、ア"
"ダプターカードの一般的な情報と、 全ての送信・受信カウンターの詳細な一覧が含ま"
"れる。"

#. type: TP
#: build/C/man4/sk98lin.4:570
#, no-wrap
msgid "I</usr/src/linux/Documentation/networking/sk98lin.txt>"
msgstr "I</usr/src/linux/Documentation/networking/sk98lin.txt>"

#. type: Plain text
#: build/C/man4/sk98lin.4:580
msgid ""
"This is the I<README> file of the I<sk98lin> driver.  It contains a detailed "
"installation HOWTO and describes all parameters of the driver.  It denotes "
"also common problems and provides the solution to them."
msgstr ""
"I<sk98lin> ドライバの I<README> ファイルである。 これには詳細なインストール "
"HOWTO が含まれており、 ドライバの全ての引数が記述されている。 また一般的な"
"問題とその解決法についても書かれている。"

#.  .SH AUTHORS
#.  Ralph Roesler \(em rroesler@syskonnect.de
#.  .br
#.  Mirko Lindner \(em mlindner@syskonnect.de
#. type: Plain text
#: build/C/man4/sk98lin.4:586
msgid "Report any bugs to linux@syskonnect.de"
msgstr "バグは linux@syskonnect.de に報告してほしい。"

#. type: Plain text
#: build/C/man4/sk98lin.4:590
msgid "B<ifconfig>(8), B<insmod>(8), B<modprobe>(8)"
msgstr "B<insmod>(8), B<ifconfig>(8), B<modprobe>(8)"

#. type: TH
#: build/C/man4/st.4:25
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man4/st.4:28
msgid "st - SCSI tape device"
msgstr "st - SCSI テープデバイス"

#. type: Plain text
#: build/C/man4/st.4:31
#, no-wrap
msgid "B<#include E<lt>sys/mtio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mtio.hE<gt>>\n"

#. type: Plain text
#: build/C/man4/st.4:36
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"
msgstr ""
"B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"

#. type: Plain text
#: build/C/man4/st.4:46
msgid ""
"The B<st> driver provides the interface to a variety of SCSI tape devices.  "
"Currently, the driver takes control of all detected devices of type "
"\\(lqsequential-access\\(rq.  The B<st> driver uses major device number 9."
msgstr ""
"B<st> ドライバーは様々な SCSI テープデバイスのインターフェイスを提供する。 現"
"在では、ドライバーは検出された全ての \\(lqシーケンシャルアクセス (sequential-"
"access) \\(rq タイプのデバイスへの 制御を行う。 B<st> ドライバーはメジャーデ"
"バイス番号 9 を用いる。"

#. type: Plain text
#: build/C/man4/st.4:66
msgid ""
"Each device uses eight minor device numbers.  The lowermost five bits in the "
"minor numbers are assigned sequentially in the order of detection.  In the "
"2.6 kernel, the bits above the eight lowermost bits are concatenated to the "
"five lowermost bits to form the tape number.  The minor numbers can be "
"grouped into two sets of four numbers: the principal (auto-rewind) minor "
"device numbers, I<n>, and the \\(lqno-rewind\\(rq device numbers, (I<n> + "
"128).  Devices opened using the principal device number will be sent a "
"B<REWIND> command when they are closed.  Devices opened using the \\(lqno-"
"rewind\\(rq device number will not.  (Note that using an auto-rewind device "
"for positioning the tape with, for instance, mt does not lead to the desired "
"result: the tape is rewound after the mt command and the next command starts "
"from the beginning of the tape)."
msgstr ""
"それぞれのデバイスは 8 つのマイナーデバイス番号を使う。 マイナー番号の低位側"
"の 5 ビットは、検出された順に割り当てられる。 カーネル 2.6 では、 低位側 8 "
"ビットよりも上位にあるビット群がこの 5 ビットに連結 (concatenate)  され、テー"
"プ番号となる。 マイナー番号は、それぞれ 4 つの数字からなる二つのセットに グ"
"ループ分けされる。 基本 (自動巻き戻し) デバイス番号 I<n>、 および \\(lq非巻き"
"戻し (no-rewind) \\(rq デバイス番号 (I<n> + 128).  である。 基本デバイス番号"
"を用いてオープンされたデバイスには、 クローズする時に B<REWIND> コマンドが送"
"られる。 \\(lq非巻き戻し\\(rq デバイス番号を用いてオープンされた場合は "
"\\s-1REWIND\\s+1 コマンドは送られない (自動巻き戻しデバイスをテープの位置決め"
"に (例えば mt で) 用いても、 望む結果は得られない。テープは mt コマンドの後で"
"巻き戻され、 次のコマンドはテープの先頭から始まってしまう)。"

#. type: Plain text
#: build/C/man4/st.4:80
msgid ""
"Within each group, four minor numbers are available to define devices with "
"different characteristics (block size, compression, density, etc.)  When the "
"system starts up, only the first device is available.  The other three are "
"activated when the default characteristics are defined (see below).  (By "
"changing compile-time constants, it is possible to change the balance "
"between the maximum number of tape drives and the number of minor numbers "
"for each drive.  The default allocation allows control of 32 tape drives.  "
"For instance, it is possible to control up to 64 tape drives with two minor "
"numbers for different options.)"
msgstr ""
"それぞれのグループで、異なった特性 (ブロックサイズ・圧縮・ 密度など) のデバイ"
"スを定義するために 4 つのマイナー番号が利用できる。 システムが起動したときに"
"は、最初のデバイスだけが使える。 他の 3 つはデフォルトの特性が定義されて初め"
"て使えるようになる (後述)。 (コンパイル時の定数を変更することによって、テープ"
"ドライブの最大数と、 それぞれのドライブに割り当てられるマイナー番号の個数とを"
"調整できる。 デフォルトの割り当てでは 32 台までのテープドライブを制御でき"
"る。 例えば 64 台までのテープドライブを、異なったオプションを持つ 二つのマイ"
"ナー番号で制御するようにもできる。)"

#. type: Plain text
#: build/C/man4/st.4:82
msgid "Devices are typically created by:"
msgstr "デバイスは普通次のように作られる:"

#. type: Plain text
#: build/C/man4/st.4:93
#, no-wrap
msgid ""
"mknod -m 666 /dev/st0 c 9 0\n"
"mknod -m 666 /dev/st0l c 9 32\n"
"mknod -m 666 /dev/st0m c 9 64\n"
"mknod -m 666 /dev/st0a c 9 96\n"
"mknod -m 666 /dev/nst0 c 9 128\n"
"mknod -m 666 /dev/nst0l c 9 160\n"
"mknod -m 666 /dev/nst0m c 9 192\n"
"mknod -m 666 /dev/nst0a c 9 224\n"
msgstr ""
"mknod -m 666 /dev/st0 c 9 0\n"
"mknod -m 666 /dev/st0l c 9 32\n"
"mknod -m 666 /dev/st0m c 9 64\n"
"mknod -m 666 /dev/st0a c 9 96\n"
"mknod -m 666 /dev/nst0 c 9 128\n"
"mknod -m 666 /dev/nst0l c 9 160\n"
"mknod -m 666 /dev/nst0m c 9 192\n"
"mknod -m 666 /dev/nst0a c 9 224\n"

#. type: Plain text
#: build/C/man4/st.4:97
msgid "There is no corresponding block device."
msgstr "これらには対応するブロックデバイスは存在しない。"

#. type: Plain text
#: build/C/man4/st.4:112
msgid ""
"The driver uses an internal buffer that has to be large enough to hold at "
"least one tape block.  In kernels before 2.1.121, the buffer is allocated as "
"one contiguous block.  This limits the block size to the largest contiguous "
"block of memory the kernel allocator can provide.  The limit is currently "
"128\\ kB for 32-bit architectures and 256\\ kB for 64-bit architectures.  In "
"newer kernels the driver allocates the buffer in several parts if "
"necessary.  By default, the maximum number of parts is 16.  This means that "
"the maximum block size is very large (2\\ MB if allocation of 16 blocks of "
"128\\ kB succeeds)."
msgstr "ドライバは内部バッファーを使い、その大きさは少なくともテープの 1 ブロックを保持できるように取られる。 2.1.121 以前のカーネルでは、 バッファーは連続する一つのブロックとして割り当てられる。この方法だと、 ブロックサイズの最大値はカーネルの割り当て可能な連続メモリーブロックに 制限される。この制限は 32 ビットアーキテクチャーでは 128\\ kB、 64 ビットアーキテクチャーでは 256\\ kB である。これ以降のカーネルでは、 ドライバは必要に応じていくつかにわかれたバッファーを割り当てる。 デフォルトでは 16 個までの部分に分割できる。すなわち ブロックサイズの最大値は非常に大きい (128\\ kB のブロック 16 個の 割り当てに成功すれば 2\\ MB となる)。"

#. type: Plain text
#: build/C/man4/st.4:121
msgid ""
"The driver's internal buffer size is determined by a compile-time constant "
"which can be overridden with a kernel startup option.  In addition to this, "
"the driver tries to allocate a larger temporary buffer at run time if "
"necessary.  However, run-time allocation of large contiguous blocks of "
"memory may fail and it is advisable not to rely too much on dynamic buffer "
"allocation with kernels older than 2.1.121 (this applies also to demand-"
"loading the driver with kerneld or kmod)."
msgstr ""
"ドライバの内部バッファーのサイズはコンパイル時の定数で定義される。 これはカー"
"ネルの起動時オプションによって上書き可能である。 さらにドライバは実行時にも、"
"必要に応じてより大きな一時バッファーを 割り当てようとする。しかし実行時に大き"
"な連続メモリーブロックを 割り当てようとすると失敗することがあるので、 "
"2.1.121 以前のカーネルでは、動的なバッファー割り当てはあまりあてにしないほう"
"が良い (これは kerneld や kmod によるドライバのデマンドロードに関しても当ては"
"まる)。"

#. type: Plain text
#: build/C/man4/st.4:134
msgid ""
"The driver does not specifically support any tape drive brand or model.  "
"After system start-up the tape device options are defined by the drive "
"firmware.  For example, if the drive firmware selects fixed-block mode, the "
"tape device uses fixed-block mode.  The options can be changed with explicit "
"B<ioctl>(2)  calls and remain in effect when the device is closed and "
"reopened.  Setting the options affects both the auto-rewind and the "
"nonrewind device."
msgstr ""
"ドライバはドライブのメーカやモデルを特定してサポートするわけではない。 システ"
"ムが起動すると、テープデバイスのオプションがドライブの ファームウェアによって"
"定義される。例えば、 ドライブのファームウェアが固定長ブロックモードを選択すれ"
"ば、 テープデバイスは固定長ブロックモードを使うことになる。このオプションは "
"B<ioctl>(2)  コールを明示的に使えば変更でき、 その変更はデバイスがクローズさ"
"れて再びオープンされたときも残る。 オプションの設定は、 自動巻き戻しデバイス"
"と非巻き戻しデバイスの両方に影響する。"

#. type: Plain text
#: build/C/man4/st.4:143
msgid ""
"Different options can be specified for the different devices within the "
"subgroup of four.  The options take effect when the device is opened.  For "
"example, the system administrator can define one device that writes in fixed-"
"block mode with a certain block size, and one which writes in variable-block "
"mode (if the drive supports both modes)."
msgstr ""
"4 つのサブグループそれぞれのデバイスに対して異なるオプションを 与えることがで"
"きる。オプションはデバイスがオープンされたときに 効力を発揮する。例えば、シス"
"テム管理者はあるデバイスを 適当なブロックサイズの固定長ブロックモードで書き込"
"むように定義し、 別のデバイスを可変長ブロックモードで書き込むようにできる (ド"
"ライブが 両方のモードをサポートしていれば)。"

#. type: Plain text
#: build/C/man4/st.4:166
msgid ""
"The driver supports B<tape partitions> if they are supported by the drive.  "
"(Note that the tape partitions have nothing to do with disk partitions.  A "
"partitioned tape can be seen as several logical tapes within one medium.)  "
"Partition support has to be enabled with an B<ioctl>(2).  The tape location "
"is preserved within each partition across partition changes.  The partition "
"used for subsequent tape operations is selected with an B<ioctl>(2).  The "
"partition switch is executed together with the next tape operation in order "
"to avoid unnecessary tape movement.  The maximum number of partitions on a "
"tape is defined by a compile-time constant (originally four).  The driver "
"contains an B<ioctl>(2)  that can format a tape with either one or two "
"partitions."
msgstr ""
"このドライバは、 B<テープのパーティション> をサポートしている (ドライブがサ"
"ポートしている場合)。 (テープのパーティションはディスクパーティションとはなん"
"の関係もない。 パーティション化されたテープは、一つのメディアに複数の論理テー"
"プが 存在するかのように見える。)  パーティションのサポートは B<ioctl>(2)  に"
"よって有効にできる。 パーティションが変更されると、 テープの位置はそれぞれの"
"パーティション内部で保存される。 パーティションの選択は B<ioctl>(2)  で行"
"う。 それ以降のテープ操作の対象は、そのパーティションになる。 パーティション"
"の切り替えは、次のテープ操作と同時に行われ、 不必要なテープ移動をしなくてすむ"
"ようになっている。 一つのテープにおけるパーティションの最大数は コンパイル時"
"の定数によって定義される (通常は 4)。 ドライバには、テープの 1 つまたは 2 つ"
"のパーティションをフォーマットできるような B<ioctl>(2)  が用意されている。"

#. type: Plain text
#: build/C/man4/st.4:171
msgid ""
"Device I</dev/tape> is usually created as a hard or soft link to the default "
"tape device on the system."
msgstr ""
"通常、システムのデフォルトのテープデバイスに対するハードリンク またはソフトリ"
"ンクとして、デバイス I</dev/tape> が作成される。"

#. type: Plain text
#: build/C/man4/st.4:175
msgid ""
"Starting from kernel 2.6.2, the driver exports in the sysfs directory I</sys/"
"class/scsi_tape> the attached devices and some parameters assigned to the "
"devices."
msgstr ""
"カーネル 2.6.2 以降では、このドライバは sysfs ディレクトリ I</sys/class/"
"scsi_tape> に、アタッチしたデバイスとそのデバイスに割当てたパラメーターをエク"
"スポートする。"

#. type: SS
#: build/C/man4/st.4:175
#, no-wrap
msgid "Data transfer"
msgstr "データ転送"

#. type: Plain text
#: build/C/man4/st.4:188
msgid ""
"The driver supports operation in both fixed-block mode and variable-block "
"mode (if supported by the drive).  In fixed-block mode the drive writes "
"blocks of the specified size and the block size is not dependent on the byte "
"counts of the write system calls.  In variable-block mode one tape block is "
"written for each write call and the byte count determines the size of the "
"corresponding tape block.  Note that the blocks on the tape don't contain "
"any information about the writing mode: when reading, the only important "
"thing is to use commands that accept the block sizes on the tape."
msgstr ""
"このドライバは固定長ブロックモードと可変長ブロックモードの 両方をサポートして"
"いる (ドライブがサポートしていれば)。 固定長ブロックモードでは、ドライブは決"
"まったサイズのブロックを (複数個) 書き込む。このブロックサイズは write システ"
"ムコールのバイト数によらない。 可変長ブロックモードでは、 write コールごとに"
"一つのテープブロックに書き込みが行われる。 したがってバイト数が対応するテープ"
"ブロックのサイズを決める。 テープ上のブロックには、書き込みモードの情報は一切"
"含まれない。 読み込みのときに重要なことは、テープのブロックサイズを受け入れ"
"る コマンドを使うかどうかだけである。"

#. type: Plain text
#: build/C/man4/st.4:196
msgid ""
"In variable-block mode the read byte count does not have to match the tape "
"block size exactly.  If the byte count is larger than the next block on "
"tape, the driver returns the data and the function returns the actual block "
"size.  If the block size is larger than the byte count, an error is returned."
msgstr "可変長ブロックモードでは、読み込みバイト数はテープのブロックサイズと 必ずしも一致していなくても良い。バイト数がテープの次のブロックよりも 大きければ、ドライバはそのデータを返し、関数は実際のブロックサイズを返す。 ブロックサイズがバイト数よりも大きければ、エラーが返される。"

#. type: Plain text
#: build/C/man4/st.4:205
msgid ""
"In fixed-block mode the read byte counts can be arbitrary if buffering is "
"enabled, or a multiple of the tape block size if buffering is disabled.  "
"Kernels before 2.1.121 allow writes with arbitrary byte count if buffering "
"is enabled.  In all other cases (kernel before 2.1.121 with buffering "
"disabled or newer kernel) the write byte count must be a multiple of the "
"tape block size."
msgstr ""
"固定長ブロックモードでは、バッファーリングが有効になっていれば 読み込みバイト"
"数は任意の大きさでよい。バッファーリングが無効の場合は、 テープのブロックサイ"
"ズの整数倍でなければならない。 2.1.121 以前の カーネルでは、バッファーリング"
"が有効な場合には 任意のバイト数の書き込みができる。その他の場合すべて "
"(2.1.121 以前のカーネルでバッファーが無効な場合と、新しいカーネルの場合)  で"
"は、書き込みバイト数はテープブロックサイズの整数倍でなければならない。"

#. type: Plain text
#: build/C/man4/st.4:214
msgid ""
"In the 2.6 kernel, the driver tries to use direct transfers between the user "
"buffer and the device.  If this is not possible, the driver's internal "
"buffer is used.  The reasons for not using direct transfers include improper "
"alignment of the user buffer (default is 512 bytes but this can be changed "
"by the HBA driver), one or more pages of the user buffer not reachable by "
"the SCSI adapter, and so on."
msgstr ""
"2.6 カーネルでは、このドライバはユーザーバッファーとデバイス間で、 データの直"
"接転送 (direct transfer) を試みる。 これが不可能な場合は、ドライバの内部バッ"
"ファーを用いる。 直接転送ができない理由としては、ユーザーバッファーのアライン"
"メントが適切でない (デフォルトは 512 バイトだが HBA ドライバによって変更され"
"ている可能性がある)、 ユーザーバッファーのページが SCSI アダプターから見えな"
"い、 などが考えられる。"

#. type: Plain text
#: build/C/man4/st.4:217
msgid ""
"A filemark is automatically written to tape if the last tape operation "
"before close was a write."
msgstr ""
"テープをクローズする直前のテープ操作命令が書き込みであれば、 ファイルマークが"
"自動的にテープへ書き込まれる。"

#. type: Plain text
#: build/C/man4/st.4:229
msgid ""
"When a filemark is encountered while reading, the following happens.  If "
"there are data remaining in the buffer when the filemark is found, the "
"buffered data is returned.  The next read returns zero bytes.  The following "
"read returns data from the next file.  The end of recorded data is signaled "
"by returning zero bytes for two consecutive read calls.  The third read "
"returns an error."
msgstr ""
"読み込み時にファイルマークに出会うと、以下が実行される。 ファイルマークが見付"
"かったときにバッファーにデータが残っていると、 バッファーのデータが返される。"
"次の読み込み操作は 0 バイトを返す。 その次の読み込みは次のファイルからのデー"
"タを返す。 記録データの末尾は、読み込み操作が二回続けて 0 バイトを返して来る"
"かたちで通知される。三回目の読み込みはエラーを返す。"

#. type: SS
#: build/C/man4/st.4:229
#, no-wrap
msgid "Ioctls"
msgstr "ioctl"

#. type: Plain text
#: build/C/man4/st.4:240
msgid ""
"The driver supports three B<ioctl>(2)  requests.  Requests not recognized by "
"the B<st> driver are passed to the B<SCSI> driver.  The definitions below "
"are from I</usr/include/linux/mtio.h>:"
msgstr ""
"ドライバは 3 つの B<ioctl>(2)  要求をサポートしている。 B<st> ドライバによっ"
"て認識されなかった要求は B<SCSI> ドライバにわたされる。 以下の定義は I</usr/"
"include/linux/mtio.h> による。"

#. type: SS
#: build/C/man4/st.4:240
#, no-wrap
msgid "MTIOCTOP \\(em perform a tape operation"
msgstr "MTIOCTOP \\(em テープ操作の実行"

#. type: Plain text
#: build/C/man4/st.4:248
msgid ""
"This request takes an argument of type I<(struct mtop\\ *)>.  Not all drives "
"support all operations.  The driver returns an B<EIO> error if the drive "
"rejects an operation."
msgstr ""
"この要求は I<(struct mtop\\ *)> 型の引数をとる。全てのドライブが全ての操作を"
"サポートしているわけではない。 ドライブが操作を拒否すると、ドライバは B<EIO> "
"エラーを返す。"

#. type: Plain text
#: build/C/man4/st.4:256
#, no-wrap
msgid ""
"/* Structure for MTIOCTOP - mag tape op command: */\n"
"struct mtop {\n"
"    short   mt_op;       /* operations defined below */\n"
"    int     mt_count;    /* how many of them */\n"
"};\n"
msgstr ""
"/* Structure for MTIOCTOP - mag tape op command: */\n"
"struct mtop {\n"
"    short   mt_op;       /* operations defined below */\n"
"    int     mt_count;    /* how many of them */\n"
"};\n"

#. type: Plain text
#: build/C/man4/st.4:260
msgid "Magnetic tape operations for normal tape use:"
msgstr "通常のテープ利用のための磁気テープ操作:"

#. type: TP
#: build/C/man4/st.4:260
#, no-wrap
msgid "B<MTBSF>"
msgstr "B<MTBSF>"

#. type: Plain text
#: build/C/man4/st.4:265
msgid "Backward space over I<mt_count> filemarks."
msgstr ""
"I<mt_count> 個のファイルマーク (filemark) 分の後方スペース (backward space)。"

#. type: TP
#: build/C/man4/st.4:265
#, no-wrap
msgid "B<MTBSFM>"
msgstr "B<MTBSFM>"

#. type: Plain text
#: build/C/man4/st.4:271
msgid ""
"Backward space over I<mt_count> filemarks.  Reposition the tape to the EOT "
"side of the last filemark."
msgstr ""
"I<mt_count> 個のファイルマーク分の後方スペース。 テープの位置を最後のファイル"
"マークの EOT 側に変更する。"

#. type: TP
#: build/C/man4/st.4:271
#, no-wrap
msgid "B<MTBSR>"
msgstr "B<MTBSR>"

#. type: Plain text
#: build/C/man4/st.4:276
msgid "Backward space over I<mt_count> records (tape blocks)."
msgstr "I<mt_count> 個のレコード (テープブロック) 分の後方スペース。"

#. type: TP
#: build/C/man4/st.4:276
#, no-wrap
msgid "B<MTBSS>"
msgstr "B<MTBSS>"

#. type: Plain text
#: build/C/man4/st.4:281
msgid "Backward space over I<mt_count> setmarks."
msgstr "I<mt_count> 個のセットマーク分の後方スペース。"

#. type: TP
#: build/C/man4/st.4:281
#, no-wrap
msgid "B<MTCOMPRESSION>"
msgstr "B<MTCOMPRESSION>"

#. type: Plain text
#: build/C/man4/st.4:289
msgid ""
"Enable compression of tape data within the drive if I<mt_count> is nonzero "
"and disable compression if I<mt_count> is zero.  This command uses the MODE "
"page 15 supported by most DATs."
msgstr ""
"I<mt_count> が 0 以外なら、ドライブのデータ圧縮を有効にする。 0 なら圧縮を無"
"効にする。このコマンドは MODE ページ 15 を用いる。 これはほとんどの DAT でサ"
"ポートされている。"

#. type: TP
#: build/C/man4/st.4:289
#, no-wrap
msgid "B<MTEOM>"
msgstr "B<MTEOM>"

#. type: Plain text
#: build/C/man4/st.4:292
msgid "Go to the end of the recorded media (for appending files)."
msgstr "(ファイルを追加するために) メディアの記録部分の最後まで進める。"

#. type: TP
#: build/C/man4/st.4:292
#, no-wrap
msgid "B<MTERASE>"
msgstr "B<MTERASE>"

#. type: Plain text
#: build/C/man4/st.4:298
msgid ""
"Erase tape.  With 2.6 kernel, short erase (mark tape empty) is performed if "
"the argument is zero.  Otherwise, long erase (erase all) is done."
msgstr ""
"テープの内容を消去する。 2.6 カーネルでは、引数が 0 ならば short erase (テー"
"プが空だと印をつける)  を行う。それ以外の場合は long erase (全体を消去する) "
"を行う。"

#. type: TP
#: build/C/man4/st.4:298
#, no-wrap
msgid "B<MTFSF>"
msgstr "B<MTFSF>"

#. type: Plain text
#: build/C/man4/st.4:303
msgid "Forward space over I<mt_count> filemarks."
msgstr "I<mt_count> 個のファイルマーク分の前方スペース (forward space)。"

#. type: TP
#: build/C/man4/st.4:303
#, no-wrap
msgid "B<MTFSFM>"
msgstr "B<MTFSFM>"

#. type: Plain text
#: build/C/man4/st.4:309
msgid ""
"Forward space over I<mt_count> filemarks.  Reposition the tape to the BOT "
"side of the last filemark."
msgstr ""
"I<mt_count> 個のファイルマーク分の前方スペース。 テープの位置は最後のファイル"
"マークの BOT 側変更される。"

#. type: TP
#: build/C/man4/st.4:309
#, no-wrap
msgid "B<MTFSR>"
msgstr "B<MTFSR>"

#. type: Plain text
#: build/C/man4/st.4:314
msgid "Forward space over I<mt_count> records (tape blocks)."
msgstr "I<mt_count> 個のレコード (テープブロック) 分の前方スペース。"

#. type: TP
#: build/C/man4/st.4:314
#, no-wrap
msgid "B<MTFSS>"
msgstr "B<MTFSS>"

#. type: Plain text
#: build/C/man4/st.4:319
msgid "Forward space over I<mt_count> setmarks."
msgstr "I<mt_count> 個のセットマーク分の前方スペース。"

#. type: TP
#: build/C/man4/st.4:319
#, no-wrap
msgid "B<MTLOAD>"
msgstr "B<MTLOAD>"

#. type: Plain text
#: build/C/man4/st.4:330
msgid ""
"Execute the SCSI load command.  A special case is available for some HP "
"autoloaders.  If I<mt_count> is the constant B<MT_ST_HPLOADER_OFFSET> plus a "
"number, the number is sent to the drive to control the autoloader."
msgstr ""
"SCSI ロードコマンドを実行する。 HP オートローダーに限って利用できる。 "
"I<mt_count> が定数 B<MT_ST_HPLOADER_OFFSET> とある数値の和である場合、 その数"
"値がドライブに送られ、オートローダーの制御に用いられる。"

#. type: TP
#: build/C/man4/st.4:330
#, no-wrap
msgid "B<MTLOCK>"
msgstr "B<MTLOCK>"

#. type: Plain text
#: build/C/man4/st.4:333
msgid "Lock the tape drive door."
msgstr "テープドライブの扉をロックする。"

#. type: TP
#: build/C/man4/st.4:333
#, no-wrap
msgid "B<MTMKPART>"
msgstr "B<MTMKPART>"

#.  commit 8038e6456a3e6f5c4759e0d73c4f9165b90c93e7
#. type: Plain text
#: build/C/man4/st.4:354
#, fuzzy
#| msgid ""
#| "Format the tape into one or two partitions.  If I<mt_count> is nonzero, "
#| "it gives the size of the first partition and the second partition "
#| "contains the rest of the tape.  If I<mt_count> is zero, the tape is "
#| "formatted into one partition.  This command is not allowed for a drive "
#| "unless the partition support is enabled for the drive (see "
#| "B<MT_ST_CAN_PARTITIONS> below)."
msgid ""
"Format the tape into one or two partitions.  If I<mt_count> is positive, it "
"gives the size of partition 1 and partition 0 contains the rest of the "
"tape.  If I<mt_count> is zero, the tape is formatted into one partition.  "
"From kernel version 4.6, a negative I<mt_count> specifies the size of "
"partition 0 and the rest of the tape contains partition 1.  The physical "
"ordering of partitions depends on the drive.  This command is not allowed "
"for a drive unless the partition support is enabled for the drive (see "
"B<MT_ST_CAN_PARTITIONS> below)."
msgstr ""
"テープを 1 または 2 パーティションにフォーマットする。 I<mt_count> が 0 でな"
"ければ、これが最初のパーティションのサイズを与え、 二番目のパーティションが"
"テープの残りになる。 I<mt_count> が 0 の場合は、テープは一つのパーティション"
"としてフォーマットされる。 このコマンドは、パーティションのサポートが有効にさ"
"れた ドライブでなければ使えない (以下の B<MT_ST_CAN_PARTITIONS> を見よ)。"

#. type: TP
#: build/C/man4/st.4:354
#, no-wrap
msgid "B<MTNOP>"
msgstr "B<MTNOP>"

#. type: Plain text
#: build/C/man4/st.4:359
msgid ""
"No op\\(emflushes the driver's buffer as a side effect.  Should be used "
"before reading status with B<MTIOCGET>."
msgstr ""
"何も操作を行わない。\\(em副次的な効果として、ドライバーのバッファー をフラッ"
"シュする。 B<MTIOCGET> を使って状態を読み出す前にはこの操作を行うべきである。"

#. type: TP
#: build/C/man4/st.4:359
#, no-wrap
msgid "B<MTOFFL>"
msgstr "B<MTOFFL>"

#. type: Plain text
#: build/C/man4/st.4:362
msgid "Rewind and put the drive off line."
msgstr "巻き戻し (rewind) を行い、ドライブをオフライン (off line) にする。"

#. type: TP
#: build/C/man4/st.4:362
#, no-wrap
msgid "B<MTRESET>"
msgstr "B<MTRESET>"

#. type: Plain text
#: build/C/man4/st.4:365
msgid "Reset drive."
msgstr "ドライブをリセットする。"

#. type: TP
#: build/C/man4/st.4:365
#, no-wrap
msgid "B<MTRETEN>"
msgstr "B<MTRETEN>"

#. type: Plain text
#: build/C/man4/st.4:368
msgid "Re-tension tape."
msgstr ""
"テープをリテンション (re-tension) する (テープを最後まで巻いた後、最初まで巻"
"き戻す)。"

#. type: TP
#: build/C/man4/st.4:368
#, no-wrap
msgid "B<MTREW>"
msgstr "B<MTREW>"

#. type: Plain text
#: build/C/man4/st.4:371
msgid "Rewind."
msgstr "巻き戻し。"

#. type: TP
#: build/C/man4/st.4:371
#, no-wrap
msgid "B<MTSEEK>"
msgstr "B<MTSEEK>"

#. type: Plain text
#: build/C/man4/st.4:383
msgid ""
"Seek to the tape block number specified in I<mt_count>.  This operation "
"requires either a SCSI-2 drive that supports the B<LOCATE> command (device-"
"specific address)  or a Tandberg-compatible SCSI-1 drive (Tandberg, Archive "
"Viper, Wangtek, ...).  The block number should be one that was previously "
"returned by B<MTIOCPOS> if device-specific addresses are used."
msgstr ""
"I<mt_count> で指定されたテープブロック番号をシークする。 この操作が行えるの"
"は、 \\s-1LOCATE\\s+1 コマンド (デバイス固有のアドレス)  をサポートする "
"SCSI-2 ドライブか、あるいは Tandberg 互換の SCSI-1 ドライブ (Tandberg, "
"Archive, Viper, Wangtek,…) である。 デバイス固有のアドレスが利用されている場"
"合は、ブロック番号は 以前に \\s-1MTIOCPOS\\s+1 によって返されたものにすべきで"
"ある。"

#. type: TP
#: build/C/man4/st.4:383
#, no-wrap
msgid "B<MTSETBLK>"
msgstr "B<MTSETBLK>"

#. type: Plain text
#: build/C/man4/st.4:388
msgid ""
"Set the drive's block length to the value specified in I<mt_count>.  A block "
"length of zero sets the drive to variable block size mode."
msgstr ""
"I<mt_count> の値をドライブのブロック長 (block length) としてセットする。 ブ"
"ロック長を 0 にするとドライブは可変長ブロックサイズモードにセッ トされる。"

#. type: TP
#: build/C/man4/st.4:388
#, no-wrap
msgid "B<MTSETDENSITY>"
msgstr "B<MTSETDENSITY>"

#. type: Plain text
#: build/C/man4/st.4:394
msgid ""
"Set the tape density to the code in I<mt_count>.  The density codes "
"supported by a drive can be found from the drive documentation."
msgstr ""
"テープ密度 (tape density) を I<mt_count> で示されるコードに変更する。ドライブ"
"でサポートされている密度コード については、ドライブの文書に書いてあるだろう。"

#. type: TP
#: build/C/man4/st.4:394
#, no-wrap
msgid "B<MTSETPART>"
msgstr "B<MTSETPART>"

#. type: Plain text
#: build/C/man4/st.4:403
msgid ""
"The active partition is switched to I<mt_count>.  The partitions are "
"numbered from zero.  This command is not allowed for a drive unless the "
"partition support is enabled for the drive (see B<MT_ST_CAN_PARTITIONS> "
"below)."
msgstr ""
"アクティブなパーティションを第 I<mt_count> 番目に切り替える。パーティション"
"は 0 から数える。 このコマンドは、パーティションのサポートが有効にされた ドラ"
"イブでなければ使えない (以下の B<MT_ST_CAN_PARTITIONS> を見よ)。"

#. type: TP
#: build/C/man4/st.4:403
#, no-wrap
msgid "B<MTUNLOAD>"
msgstr "B<MTUNLOAD>"

#. type: Plain text
#: build/C/man4/st.4:406
msgid "Execute the SCSI unload command (does not eject the tape)."
msgstr "SCSI unload コマンドを実行する (テープのイジェクトは行わない)。"

#. type: TP
#: build/C/man4/st.4:406
#, no-wrap
msgid "B<MTUNLOCK>"
msgstr "B<MTUNLOCK>"

#. type: Plain text
#: build/C/man4/st.4:409
msgid "Unlock the tape drive door."
msgstr "テープドライブの扉のロックを解除する。"

#. type: TP
#: build/C/man4/st.4:409
#, no-wrap
msgid "B<MTWEOF>"
msgstr "B<MTWEOF>"

#. type: Plain text
#: build/C/man4/st.4:414
msgid "Write I<mt_count> filemarks."
msgstr "I<mt_count> 個のファイルマークを書き込む。"

#. type: TP
#: build/C/man4/st.4:414
#, no-wrap
msgid "B<MTWSM>"
msgstr "B<MTWSM>"

#. type: Plain text
#: build/C/man4/st.4:419
msgid "Write I<mt_count> setmarks."
msgstr "I<mt_count> 個のセットマークを書き込む。"

#. type: Plain text
#: build/C/man4/st.4:421
msgid ""
"Magnetic tape operations for setting of device options (by the superuser):"
msgstr ""
"デバイスオプションの設定のための (スーパーユーザーによる) 磁気テープ操作:"

#. type: TP
#: build/C/man4/st.4:421
#, no-wrap
msgid "B<MTSETDRVBUFFER>"
msgstr "B<MTSETDRVBUFFER>"

#. type: Plain text
#: build/C/man4/st.4:430
msgid ""
"Set various drive and driver options according to bits encoded in "
"I<mt_count>.  These consist of the drive's buffering mode, a set of Boolean "
"driver options, the buffer write threshold, defaults for the block size and "
"density, and timeouts (only in kernels 2.1 and later).  A single operation "
"can affect only one item in the list below (the Booleans counted as one "
"item.)"
msgstr "いろいろなドライブとドライバーのオプションを I<mt_count> にエンコードされた各ビットに従って設定する。 オプションには、ドライブのバッファーリングモード、 ブール値のドライバオプションの集合、 バッファーの書き込み閾値 (デフォルトはブロックサイズと密度)、 タイムアウト値が含まれる (カーネル 2.1 以降)。 一回の操作で変えられるのは、下記のリストのどれか一つだけである (複数のブール値はまとめて一つと勘定される)。"

#. type: Plain text
#: build/C/man4/st.4:434
msgid ""
"A value having zeros in the high-order 4 bits will be used to set the "
"drive's buffering mode.  The buffering modes are:"
msgstr ""
"高位の4ビットがゼロである値は、 ドライブのバッファーリングモードの設定に使わ"
"れる。 バッファーリングモードは以下の通り:"

#. type: Plain text
#: build/C/man4/st.4:440
msgid ""
"The drive will not report B<GOOD> status on write commands until the data "
"blocks are actually written to the medium."
msgstr ""
"ドライブはライトコマンドに対し、 データブロックが実際に媒体に書き込まれるま"
"で B<GOOD> のステータスを返さない。"

#. type: Plain text
#: build/C/man4/st.4:445
msgid ""
"The drive may report B<GOOD> status on write commands as soon as all the "
"data has been transferred to the drive's internal buffer."
msgstr ""
"ドライブはライトコマンドに対し、 すべてのデータがドライブの内部バッファーに転"
"送されるとすぐに、 B<GOOD> のステータスを返すことができる。"

#. type: Plain text
#: build/C/man4/st.4:452
msgid ""
"The drive may report B<GOOD> status on write commands as soon as (a) all the "
"data has been transferred to the drive's internal buffer, and (b) all "
"buffered data from different initiators has been successfully written to the "
"medium."
msgstr ""
"ライトコマンドに対し、以下の 2 つの条件がそろった場合、 ドライブはすぐに "
"B<GOOD> ステータスを返す事ができる。 (a) すべてのデータがドライブの内部バッ"
"ファーに転送された。 (b) 別々のイニシエーターから来たバッファーデータが、 す"
"べて媒体へ問題なく書き込まれた。"

#. type: Plain text
#: build/C/man4/st.4:463
msgid ""
"To control the write threshold the value in I<mt_count> must include the "
"constant B<MT_ST_WRITE_THRESHOLD> bitwise ORed with a block count in the low "
"28 bits.  The block count refers to 1024-byte blocks, not the physical block "
"size on the tape.  The threshold cannot exceed the driver's internal buffer "
"size (see DESCRIPTION, above)."
msgstr ""
"書き込み閾値を制御するには、 I<mt_count> には、定数 B<MT_ST_WRITE_THRESHOLD> "
"とブロックカウントのビット毎の OR をとった値を 下位の 28ビットに含まねばなら"
"ない。 このブロックカウントは 1024 バイトブロックを単位としたもので、 テープ"
"の物理ブロックサイズを単位としたものではない。 また、閾値はドライバの内部バッ"
"ファー (上記の説明参照)  のサイズを越える事はできない。"

#. type: Plain text
#: build/C/man4/st.4:484
msgid ""
"To set and clear the Boolean options the value in I<mt_count> must include "
"one of the constants B<MT_ST_BOOLEANS>, B<MT_ST_SETBOOLEANS>, "
"B<MT_ST_CLEARBOOLEANS>, or B<MT_ST_DEFBOOLEANS> bitwise ORed with whatever "
"combination of the following options is desired.  Using B<MT_ST_BOOLEANS> "
"the options can be set to the values defined in the corresponding bits.  "
"With B<MT_ST_SETBOOLEANS> the options can be selectively set and with "
"B<MT_ST_DEFBOOLEANS> selectively cleared."
msgstr ""
"ブール値のフラグを設定・解除するには、 I<mt_count> の値は B<MT_ST_BOOLEANS>, "
"B<MT_ST_SETBOOLEANS>, B<MT_ST_CLEARBOOLEANS>, B<MT_ST_DEFBOOLEANS> のいずれか"
"一つの値に、以下のオプションの任意の組み合わせに対して ビット毎の OR を取った"
"ものを指定する。 B<MT_ST_BOOLEANS>を用いると、 オプションを対応するビットに対"
"して定義されている値に設定できる。 B<MT_ST_SETBOOLEANS>を用いると、 オプショ"
"ンは選択的に設定され、 B<MT_ST_DEFBOOLEANS>を用いると 選択的に解除される。"

#. type: Plain text
#: build/C/man4/st.4:492
msgid ""
"The default options for a tape device are set with B<MT_ST_DEFBOOLEANS>.  A "
"nonactive tape device (e.g., device with minor 32 or 160) is activated when "
"the default options for it are defined the first time.  An activated device "
"inherits from the device activated at start-up the options not set "
"explicitly."
msgstr ""
"テープデバイスのデフォルトのオプションは B<MT_ST_DEFBOOLEANS> によって設定さ"
"れる。 アクティブでないテープデバイス (例: マイナー番号 が 32 や 160 のデバイ"
"ス)  は、それらに対するデフォルトのオプションが最初に定義されたときに アク"
"ティブになる。アクティブにされたデバイスは、 起動時にアクティブにされたデバイ"
"スから、 明示的に指定されなかったオプションを継承する。"

#. type: Plain text
#: build/C/man4/st.4:494
msgid "The Boolean options are:"
msgstr "ブール値のオプションは以下の通り:"

#. type: TP
#: build/C/man4/st.4:495
#, no-wrap
msgid "B<MT_ST_BUFFER_WRITES> (Default: true)"
msgstr "B<MT_ST_BUFFER_WRITES> (デフォルト: 真)"

#. type: Plain text
#: build/C/man4/st.4:501
msgid ""
"Buffer all write operations in fixed-block mode.  If this option is false "
"and the drive uses a fixed block size, then all write operations must be for "
"a multiple of the block size.  This option must be set false to write "
"reliable multivolume archives."
msgstr ""
"固定長ブロックモードにおけるすべての書き込み操作をバッファーリングする。 この"
"オプションが偽であり、かつドライブが固定長ブロックサイズの時は、 すべての書き"
"込み操作はブロックサイズの倍数の大きさで行わなければならない。 信頼性のあるマ"
"ルチボリュームアーカイブを書き込むためには、 このオプションは偽に設定されてい"
"なければならない。"

#. type: TP
#: build/C/man4/st.4:501
#, no-wrap
msgid "B<MT_ST_ASYNC_WRITES> (Default: true)"
msgstr "B<MT_ST_ASYNC_WRITES> (デフォルト: 真)"

#. type: Plain text
#: build/C/man4/st.4:511
msgid ""
"When this option is true, write operations return immediately without "
"waiting for the data to be transferred to the drive if the data fits into "
"the driver's buffer.  The write threshold determines how full the buffer "
"must be before a new SCSI write command is issued.  Any errors reported by "
"the drive will be held until the next operation.  This option must be set "
"false to write reliable multivolume archives."
msgstr ""
"このオプションが真の時には、データがドライバのバッファーに収まる時には データ"
"がドライブに転送されるのを待たずに、すぐに書き込み操作が返って来る。 バッ"
"ファーがどのくらい空いたら次の SCSI write コマンドを発行できるかは、 書き込み"
"閾値によって決まる。 ドライブが返すすべてのエラーは、次の操作まで保存され"
"る。 信頼性のあるマルチボリュームアーカイブを書き込むためには、 このオプショ"
"ンは偽に設定されていなければならない。"

#. type: TP
#: build/C/man4/st.4:511
#, no-wrap
msgid "B<MT_ST_READ_AHEAD> (Default: true)"
msgstr "B<MT_ST_READ_AHEAD> (デフォルト: 真)"

#. type: Plain text
#: build/C/man4/st.4:517
msgid ""
"This option causes the driver to provide read buffering and read-ahead in "
"fixed-block mode.  If this option is false and the drive uses a fixed block "
"size, then all read operations must be for a multiple of the block size."
msgstr ""
"このオプションを指定すると、 ドライバは固定長ブロックモードで読み込みバッ"
"ファーリングと先読みをするようになる。 このオプションが偽であり、かつドライブ"
"が固定長ブロックサイズの時は、 すべての読み込み操作はブロックサイズの倍数の大"
"きさで行わなければならない。"

#. type: TP
#: build/C/man4/st.4:517
#, no-wrap
msgid "B<MT_ST_TWO_FM> (Default: false)"
msgstr "B<MT_ST_TWO_FM> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:523
msgid ""
"This option modifies the driver behavior when a file is closed.  The normal "
"action is to write a single filemark.  If the option is true, the driver "
"will write two filemarks and backspace over the second one."
msgstr ""
"このオプションはファイルがクローズされた時のドライバーの振舞いを変更する。 一"
"つのファイルマークを書き込むのが通常の動作である。 このオプションが真の時に"
"は、 ドライバーは 2 つのファイルマークを書き込んで、 2 つめのファイルマークの"
"ところに戻る。"

#. type: Plain text
#: build/C/man4/st.4:532
msgid ""
"Note: This option should not be set true for QIC tape drives since they are "
"unable to overwrite a filemark.  These drives detect the end of recorded "
"data by testing for blank tape rather than two consecutive filemarks.  Most "
"other current drives also detect the end of recorded data and using two "
"filemarks is usually necessary only when interchanging tapes with some other "
"systems."
msgstr ""
"注意： QICテープドライブはファイルマークに上書きすることができないので、 この"
"オプションを真にしてはならない。 これらのドライブは記録データの末尾の検知"
"に、 ファイルマークが 2つ続けてあるかではなく、 ブランクテープかどうかのテス"
"トを用いる。 現在の他のほとんどのドライブも、記録データの末尾を検知する。 2 "
"つのファイルマークが必要になるのは、 他のシステムとテープをやりとりする場合で"
"ある。"

#. type: TP
#: build/C/man4/st.4:532
#, no-wrap
msgid "B<MT_ST_DEBUGGING> (Default: false)"
msgstr "B<MT_ST_DEBUGGING> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:538
msgid ""
"This option turns on various debugging messages from the driver (effective "
"only if the driver was compiled with B<DEBUG> defined nonzero)."
msgstr ""
"このオプションを真にすると、 ドライバはいろいろなデバッグ用メッセージを出すよ"
"うになる (B<DEBUG> を非ゼロに定義してドライバをコンパイルしている時のみ有"
"効)。"

#. type: TP
#: build/C/man4/st.4:538
#, no-wrap
msgid "B<MT_ST_FAST_EOM> (Default: false)"
msgstr "B<MT_ST_FAST_EOM> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:552
msgid ""
"This option causes the B<MTEOM> operation to be sent directly to the drive, "
"potentially speeding up the operation but causing the driver to lose track "
"of the current file number normally returned by the B<MTIOCGET> request.  If "
"B<MT_ST_FAST_EOM> is false, the driver will respond to an B<MTEOM> request "
"by forward spacing over files."
msgstr ""
"このオプションを真にすると、 B<MTEOM> 操作が直接ドライブに送られるようにな"
"る。 操作が早くなるはずだが、 ドライバが現在のファイル番号を見失うことになる "
"(これは通常なら B<MTIOCGET> リクエストによって返される)。 B<MT_ST_FAST_EOM> "
"が偽の時には、ドライバは B<MTEOM> リクエストに応えるとき、前方にファイルを一"
"つ一つ進めていく。"

#. type: TP
#: build/C/man4/st.4:552
#, no-wrap
msgid "B<MT_ST_AUTO_LOCK> (Default: false)"
msgstr "B<MT_ST_AUTO_LOCK> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:556
msgid ""
"When this option is true, the drive door is locked when the device file is "
"opened and unlocked when it is closed."
msgstr "このオプションが真の時には、 デバイスファイルがオープンされるとドライブの扉がロックされ、 クローズされるとアンロックされる。"

#. type: TP
#: build/C/man4/st.4:556
#, no-wrap
msgid "B<MT_ST_DEF_WRITES> (Default: false)"
msgstr "B<MT_ST_DEF_WRITES> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:573
msgid ""
"The tape options (block size, mode, compression, etc.) may change when "
"changing from one device linked to a drive to another device linked to the "
"same drive depending on how the devices are defined.  This option defines "
"when the changes are enforced by the driver using SCSI-commands and when the "
"drives auto-detection capabilities are relied upon.  If this option is "
"false, the driver sends the SCSI-commands immediately when the device is "
"changed.  If the option is true, the SCSI-commands are not sent until a "
"write is requested.  In this case, the drive firmware is allowed to detect "
"the tape structure when reading and the SCSI-commands are used only to make "
"sure that a tape is written according to the correct specification."
msgstr ""
"テープオプション (ブロックサイズ、モード、圧縮など)  があるドライブにリンクさ"
"れたデバイスで変更されると、 その同じドライブにリンクされた他のデバイスでも変"
"更されることがある (そのデバイスの定義による)。このオプションは、 ドライバに"
"よる変更をいつ SCSI コマンドによって反映させるかと、 ドライブの自動検知機能が"
"いつ信頼して良いのかを定義する。 このオプションを偽にしておくと、 デバイスの"
"変更があるとドライバはすぐに SCSI コマンドを送る。 真にしておくと、 SCSI コマ"
"ンドは書き込みが要求されるまで送られない。 後者の場合は、読み込みの際にドライ"
"ブのファームウェアによって テープ構造の検知が行える。また SCSI コマンドは、 "
"テープが正しい指定に沿って書き込まれているかどうかの 確認のためだけに用いられ"
"る。"

#. type: TP
#: build/C/man4/st.4:573
#, no-wrap
msgid "B<MT_ST_CAN_BSR> (Default: false)"
msgstr "B<MT_ST_CAN_BSR> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:586
msgid ""
"When read-ahead is used, the tape must sometimes be spaced backward to the "
"correct position when the device is closed and the SCSI command to space "
"backward over records is used for this purpose.  Some older drives can't "
"process this command reliably and this option can be used to instruct the "
"driver not to use the command.  The end result is that, with read-ahead and "
"fixed-block mode, the tape may not be correctly positioned within a file "
"when the device is closed.  With 2.6 kernel, the default is true for drives "
"supporting SCSI-3."
msgstr ""
"先読みを使うと、テープをクローズするときに、 場合によってはテープを正しい位置"
"に逆戻ししなければならないことがある。 これには、レコードを越えて逆戻しする "
"SCSI コマンドが用いられる。 古いドライブでは、このコマンド処理の信頼性が低い"
"ことがあるが、 このオプションを指定すると、 ドライバにこのコマンドの利用を禁"
"止することができる。 先読みと固定長ブロックモードを用いていると、最終的な結果"
"として、 デバイスのクローズ時にテープが正しい位置にならないことがある。 2.6 "
"カーネルでは、SCSI-3 をサポートしているドライブに対して、 この値のデフォルト"
"は真となる。"

#. type: TP
#: build/C/man4/st.4:586
#, no-wrap
msgid "B<MT_ST_NO_BLKLIMS> (Default: false)"
msgstr "B<MT_ST_NO_BLKLIMS> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:595
msgid ""
"Some drives don't accept the B<READ BLOCK LIMITS> SCSI command.  If this is "
"used, the driver does not use the command.  The drawback is that the driver "
"can't check before sending commands if the selected block size is acceptable "
"to the drive."
msgstr ""
"ドライブによっては B<READ BLOCK LIMITS SCSI> コマンドを受けつけないことがあ"
"る。 このオプションを用いると、ドライバはこのコマンドを用いない。 欠点は、指"
"定したブロックサイズがドライブに受理されてしまうと、 ドライバのコマンド送信前"
"チェックができなくなる点である。"

#. type: TP
#: build/C/man4/st.4:595
#, no-wrap
msgid "B<MT_ST_CAN_PARTITIONS> (Default: false)"
msgstr "B<MT_ST_CAN_PARTITIONS> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:600
msgid ""
"This option enables support for several partitions within a tape.  The "
"option applies to all devices linked to a drive."
msgstr ""
"このオプションは、一つのテープに複数パーティションを置くことを サポートするか"
"どうかを決める。 このオプションはドライブにリンクされた全てのデバイスに適用さ"
"れる。"

#. type: TP
#: build/C/man4/st.4:600
#, no-wrap
msgid "B<MT_ST_SCSI2LOGICAL> (Default: false)"
msgstr "このオプションは、"

#. type: Plain text
#: build/C/man4/st.4:615
msgid ""
"This option instructs the driver to use the logical block addresses defined "
"in the SCSI-2 standard when performing the seek and tell operations (both "
"with B<MTSEEK> and B<MTIOCPOS> commands and when changing tape partition).  "
"Otherwise, the device-specific addresses are used.  It is highly advisable "
"to set this option if the drive supports the logical addresses because they "
"count also filemarks.  There are some drives that support only the logical "
"block addresses."
msgstr ""
"seek および tell 操作 (両者とも B<MTSEEK>・B<MTIOCPOS> コマンドを伴い、テープ"
"位置を変更するとき) の際に、 SCSI-2 の標準で定義されている論理ブロックアドレ"
"スを用いるかどうかを ドライバに伝える。 偽だとデバイス固有のアドレスが用いら"
"れる。 ドライブが論理アドレスをサポートしているときは、 このオプションをセッ"
"トすることを強く勧める。 このモードではファイルマークもカウントするからであ"
"る。 論理ブロックアドレスしかサポートしないドライブもいくつか存在している。"

#. type: TP
#: build/C/man4/st.4:615
#, no-wrap
msgid "B<MT_ST_SYSV> (Default: false)"
msgstr "B<MT_ST_SYSV> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:626
msgid ""
"When this option is enabled, the tape devices use the System V semantics.  "
"Otherwise, the BSD semantics are used.  The most important difference "
"between the semantics is what happens when a device used for reading is "
"closed: in System V semantics the tape is spaced forward past the next "
"filemark if this has not happened while using the device.  In BSD semantics "
"the tape position is not changed."
msgstr "このオプションが真になっていると、テープデバイスは System V のルールを用いる。偽だと BSD のルールを用いる。 これらのルール間の最も大きな違いは、読み込みを行っていた デバイスがクローズされたときの振舞いである。 System V のルールでは、テープは次のファイルマークを越えて移動する (デバイスの利用時にこれが行われなかった場合)。 BSD のルールではテープ位置は変更されない。"

#. type: TP
#: build/C/man4/st.4:626
#, no-wrap
msgid "B<MT_NO_WAIT> (Default: false)"
msgstr "B<MT_NO_WAIT> (デフォルト: 偽)"

#. type: Plain text
#: build/C/man4/st.4:630
msgid ""
"Enables immediate mode (i.e., don't wait for the command to finish) for some "
"commands (e.g., rewind)."
msgstr ""
"即時モード (immediate mode; コマンドの終了を待たない)  を、ある種のコマンド "
"(rewind など) に対して有効にする。"

#. type: Plain text
#: build/C/man4/st.4:632
msgid "An example:"
msgstr "例:"

#. type: Plain text
#: build/C/man4/st.4:640
#, no-wrap
msgid ""
"struct mtop mt_cmd;\n"
"mt_cmd.mt_op = MTSETDRVBUFFER;\n"
"mt_cmd.mt_count = MT_ST_BOOLEANS |\n"
"        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\n"
"ioctl(fd, MTIOCTOP, mt_cmd);\n"
msgstr ""
"struct mtop mt_cmd;\n"
"mt_cmd.mt_op = MTSETDRVBUFFER;\n"
"mt_cmd.mt_count = MT_ST_BOOLEANS |\n"
"        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\n"
"ioctl(fd, MTIOCTOP, mt_cmd);\n"

#. type: Plain text
#: build/C/man4/st.4:650
msgid ""
"The default block size for a device can be set with B<MT_ST_DEF_BLKSIZE> and "
"the default density code can be set with B<MT_ST_DEFDENSITY>.  The values "
"for the parameters are or'ed with the operation code."
msgstr ""
"デバイスのデフォルトのブロックサイズは B<MT_ST_DEF_BLKSIZE> によって設定で"
"き、デフォルトの密度コードは B<MT_ST_DEFDENSITY> によって設定できる。 これら"
"のパラメーターの値は操作コードと OR して与える。"

#. type: Plain text
#: build/C/man4/st.4:667
msgid ""
"With kernels 2.1.x and later, the timeout values can be set with the "
"subcommand B<MT_ST_SET_TIMEOUT> ORed with the timeout in seconds.  The long "
"timeout (used for rewinds and other commands that may take a long time) can "
"be set with B<MT_ST_SET_LONG_TIMEOUT>.  The kernel defaults are very long to "
"make sure that a successful command is not timed out with any drive.  "
"Because of this, the driver may seem stuck even if it is only waiting for "
"the timeout.  These commands can be used to set more practical values for a "
"specific drive.  The timeouts set for one device apply for all devices "
"linked to the same drive."
msgstr ""
"2.1.x 以降のカーネルでは、タイムアウト値の設定は、 サブコマンド "
"B<MT_ST_SET_TIMEOUT> に秒単位のタイムアウト値を OR して与えることによって行え"
"る。 long タイムアウト (巻き戻しなど、長い時間がかかるコマンドに対して用いら"
"れる) は B<MT_ST_SET_LONG_TIMEOUT> で設定できる。 カーネルのデフォルトは非常"
"に長く、どのドライブでも 成功しているコマンドが決してタイムアウトしないように"
"なっている。 したがって、ドライバはタイムアウトを待っているだけなのに、 刺"
"さった (stuck した) ように見えることがある。これらのコマンドを使えば、 特定の"
"ドライブに対してもう少し実際的な値に設定することができる。 一つのデバイスに設"
"定したタイムアウト値は、 それと同じドライブにリンクした全てのデバイスに適用さ"
"れる。"

#. type: Plain text
#: build/C/man4/st.4:688
msgid ""
"Starting from kernels 2.4.19 and 2.5.43, the driver supports a status bit "
"which indicates whether the drive requests cleaning.  The method used by the "
"drive to return cleaning information is set using the B<MT_ST_SEL_CLN> "
"subcommand.  If the value is zero, the cleaning bit is always zero.  If the "
"value is one, the TapeAlert data defined in the SCSI-3 standard is used (not "
"yet implemented).  Values 2\\(en17 are reserved.  If the lowest eight bits "
"are E<gt>= 18, bits from the extended sense data are used.  The bits "
"9\\(en16 specify a mask to select the bits to look at and the bits 17\\(en23 "
"specify the bit pattern to look for.  If the bit pattern is zero, one or "
"more bits under the mask indicate the cleaning request.  If the pattern is "
"nonzero, the pattern must match the masked sense data byte."
msgstr "2.4.19 および 2.5.43 以降のカーネルでは、 このドライバはドライブのクリーニングが必要かどうかを示す 状態ビットをサポートする。 ドライブがクリーニング情報を返させるかどうかは、 B<MT_ST_SEL_CLN> サブコマンドによって設定できる。 この値が 0 だと、クリーニングビットは常に 0 となる。 値を 1 にすると、SCSI-3 標準で規定されている TapeAlert データが用いられる (まだ実装されていない)  値としては 2 から 17 が予約されている。 低位側の 8 ビットが 18 以上だと、拡張状態データ (extended sense data)  が用いられる。第 9\\(en16 ビットは注目すべきビットを選択するためのマスクを指定し、 第 17\\(en23 ビットは探すべきビットパターンを指定する。 このビットパターンが 0 のときは、 マスク下のビット (群) がクリーニング要求を示す。パターンが 0 でなければ、 このパターンがマスク後の状態データバイトにマッチしなければならない。"

#. type: SS
#: build/C/man4/st.4:688
#, no-wrap
msgid "MTIOCGET \\(em get status"
msgstr "MTIOCGET \\(em ステータスの取得"

#. type: Plain text
#: build/C/man4/st.4:692
msgid "This request takes an argument of type I<(struct mtget\\ *)>."
msgstr "このリクエストは I<(struct mtget\\ *)> という型の引数をとる。"

#. type: Plain text
#: build/C/man4/st.4:707
#, no-wrap
msgid ""
"/* structure for MTIOCGET - mag tape get status command */\n"
"struct mtget {\n"
"    long     mt_type;\n"
"    long     mt_resid;\n"
"    /* the following registers are device dependent */\n"
"    long     mt_dsreg;\n"
"    long     mt_gstat;\n"
"    long     mt_erreg;\n"
"    /* The next two fields are not always used */\n"
"    daddr_t  mt_fileno;\n"
"    daddr_t  mt_blkno;\n"
"};\n"
msgstr ""
"/* structure for MTIOCGET - mag tape get status command */\n"
"struct mtget {\n"
"    long     mt_type;\n"
"    long     mt_resid;\n"
"    /* the following registers are device dependent */\n"
"    long     mt_dsreg;\n"
"    long     mt_gstat;\n"
"    long     mt_erreg;\n"
"    /* The next two fields are not always used */\n"
"    daddr_t  mt_fileno;\n"
"    daddr_t  mt_blkno;\n"
"};\n"

#. type: TP
#: build/C/man4/st.4:709
#, no-wrap
msgid "I<mt_type>"
msgstr "I<mt_type>"

#. type: Plain text
#: build/C/man4/st.4:719
msgid ""
"The header file defines many values for I<mt_type>, but the current driver "
"reports only the generic types B<MT_ISSCSI1> (Generic SCSI-1 tape)  and "
"B<MT_ISSCSI2> (Generic SCSI-2 tape)."
msgstr ""
"ヘッダーファイル中には多くの I<mt_type> の値が定義されているが、現行のドライ"
"バは汎用のタイプである B<MT_ISSCSI1> (汎用 SCSI-1 テープ) および "
"B<MT_ISSCSI2> (汎用 SCSI-2 テープ) のみを返す。"

#. type: TP
#: build/C/man4/st.4:719
#, no-wrap
msgid "I<mt_resid>"
msgstr "I<mt_resid>"

#. type: Plain text
#: build/C/man4/st.4:722
msgid "contains the current tape partition number."
msgstr "現在のテープ位置番号。"

#. type: TP
#: build/C/man4/st.4:722
#, no-wrap
msgid "I<mt_dsreg>"
msgstr "I<mt_dsreg>"

#. type: Plain text
#: build/C/man4/st.4:732
msgid ""
"reports the drive's current settings for block size (in the low 24 bits) and "
"density (in the high 8 bits).  These fields are defined by "
"B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT>, and "
"B<MT_ST_DENSITY_MASK>."
msgstr ""
"ドライブのブロックサイズと密度の現在の設定を報告する (下位 24 ビットがブロッ"
"クサイズ、上位 8 ビットが密度)。 これらのフィールドは、 "
"B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT>, "
"B<MT_ST_DENSITY_MASK> で定義されている。"

#. type: TP
#: build/C/man4/st.4:732
#, no-wrap
msgid "I<mt_gstat>"
msgstr "I<mt_gstat>"

#. type: Plain text
#: build/C/man4/st.4:736
msgid ""
"reports generic (device independent) status information.  The header file "
"defines macros for testing these status bits:"
msgstr ""
"汎用の (デバイスに依存しない) ステータスを報告する。 これらのステータスビット"
"をテストするためのマクロが ヘッダーファイルで定義されている。"

#. type: Plain text
#: build/C/man4/st.4:743
msgid ""
"B<GMT_EOF>(I<x>): The tape is positioned just after a filemark (always false "
"after an B<MTSEEK> operation)."
msgstr ""
"B<GMT_EOF>(I<x>): テープはファイルマークの直後に位置している。 (B<MTSEEK> 操"
"作の後では常に偽)"

#. type: Plain text
#: build/C/man4/st.4:749
msgid ""
"B<GMT_BOT>(I<x>): The tape is positioned at the beginning of the first file "
"(always false after an B<MTSEEK> operation)."
msgstr ""
"B<GMT_BOT>(I<x>): テープは最初のファイルの先頭に位置している。 (B<MTSEEK> 操"
"作の後では常に偽)"

#. type: Plain text
#: build/C/man4/st.4:752
msgid ""
"B<GMT_EOT>(I<x>): A tape operation has reached the physical End Of Tape."
msgstr "B<GMT_EOT>(I<x>): テープ操作はテープの物理的な終点に達した。"

#. type: Plain text
#: build/C/man4/st.4:758
msgid ""
"B<GMT_SM>(I<x>): The tape is currently positioned at a setmark (always false "
"after an B<MTSEEK> operation)."
msgstr ""
"\\s-1GMT_SM(\\s+1I<x>\\s-1)\\s+1: テープは現在セットマークに位置している。 "
"(B<MTSEEK> 操作の後では常に偽)"

#. type: Plain text
#: build/C/man4/st.4:761
msgid "B<GMT_EOD>(I<x>): The tape is positioned at the end of recorded data."
msgstr "B<GMT_EOD>(I<x>): テープは記録データの末尾に位置している。"

#. type: Plain text
#: build/C/man4/st.4:766
msgid ""
"B<GMT_WR_PROT>(I<x>): The drive is write-protected.  For some drives this "
"can also mean that the drive does not support writing on the current medium "
"type."
msgstr ""
"B<GMT_WR_PROT>(I<x>): ドライブはライトプロテクトされている。 これはドライブに"
"よっては、 ドライブが現在のメディアタイプへの書き込みを サポートしていない事"
"を意味する場合もある。"

#. type: Plain text
#: build/C/man4/st.4:771
msgid ""
"B<GMT_ONLINE>(I<x>): The last B<open>(2)  found the drive with a tape in "
"place and ready for operation."
msgstr ""
"B<GMT_ONLINE>(I<x>): もっとも最近の B<open>(2)  が、テープが入っていて操作の"
"準備ができているドライブを検知した。"

#. type: Plain text
#: build/C/man4/st.4:775
msgid ""
"B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): This "
"\\(lqgeneric\\(rq status information reports the current density setting for "
"9-track \\(12\" tape drives only."
msgstr ""
"B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): この「汎用」の"
"ステータス情報は、 9-トラック \\(12\" テープドライブの場合にのみ、 現在の密度"
"の設定を報告する。"

#. type: Plain text
#: build/C/man4/st.4:778
msgid "B<GMT_DR_OPEN>(I<x>): The drive does not have a tape in place."
msgstr "B<GMT_DR_OPEN>(I<x>): ドライブにテープが入っていない。"

#. type: Plain text
#: build/C/man4/st.4:786
msgid ""
"B<GMT_IM_REP_EN>(I<x>): Immediate report mode.  This bit is set if there are "
"no guarantees that the data has been physically written to the tape when the "
"write call returns.  It is set zero only when the driver does not buffer "
"data and the drive is set not to buffer data."
msgstr ""
"B<GMT_IM_REP_EN>(I<x>): 即時報告モード。 write コールが戻ったとき、 テープに"
"対して物理的な書き込みが行われたかどうかを保証できない場合に、 このビットが"
"セットされる。ドライバがデータをバッファーリングせず、 ドライブもデータをバッ"
"ファーリングしない場合に限って、 この値は 0 にセットされる。"

#. type: Plain text
#: build/C/man4/st.4:790
msgid ""
"B<GMT_CLN>(I<x>): The drive has requested cleaning.  Implemented in kernels "
"since 2.4.19 and 2.5.43."
msgstr ""
"B<GMT_CLN>(I<x>): ドライブがクリーニングを要求している。 カーネル 2.4.19 およ"
"び 2.5.43 以降で実装された。"

#. type: TP
#: build/C/man4/st.4:791
#, no-wrap
msgid "I<mt_erreg>"
msgstr "I<mt_erreg>"

#. type: Plain text
#: build/C/man4/st.4:802
msgid ""
"The only field defined in I<mt_erreg> is the recovered error count in the "
"low 16 bits (as defined by B<MT_ST_SOFTERR_SHIFT> and "
"B<MT_ST_SOFTERR_MASK>).  Due to inconsistencies in the way drives report "
"recovered errors, this count is often not maintained (most drives do not by "
"default report soft errors but this can be changed with a SCSI MODE SELECT "
"command)."
msgstr ""
"I<mt_erreg> で定義されているフィールドは一つだけで、 下位の 16 ビットがエラー"
"をリカバーした回数である (B<MT_ST_SOFTERR_SHIFT> と B<MT_ST_SOFTERR_MASK> で"
"定義されている)。 ドライブの報告するエラーリカバー数と矛盾することがあるの"
"で、 この数はほとんどの場合維持されない (ほとんどのドライブでは、デフォルトで"
"はソフトエラーを報告しない。 しかしこれは SCSI MODE SELECT コマンドによって変"
"更できる)。"

#. type: TP
#: build/C/man4/st.4:802
#, no-wrap
msgid "I<mt_fileno>"
msgstr "I<mt_fileno>"

#. type: Plain text
#: build/C/man4/st.4:809
msgid ""
"reports the current file number (zero-based).  This value is set to -1 when "
"the file number is unknown (e.g., after B<MTBSS> or B<MTSEEK>)."
msgstr ""
"(ゼロから数えた) 現在のファイル番号を報告する。 ファイル番号がわからない時 "
"(例えば B<MTBSS> や B<MTSEEK> の後など) には -1 にセットされる。"

#. type: TP
#: build/C/man4/st.4:809
#, no-wrap
msgid "I<mt_blkno>"
msgstr "I<mt_blkno>"

#. type: Plain text
#: build/C/man4/st.4:817
msgid ""
"reports the block number (zero-based) within the current file.  This value "
"is set to -1 when the block number is unknown (e.g., after B<MTBSF>, "
"B<MTBSS>, or B<MTSEEK>)."
msgstr ""
"現在のファイル中の(ゼロから数えた)ブロック番号を報告する。 ブロック番号がわか"
"らない時 (例えば B<MTBSF>, B<MTBSS>, B<MTSEEK> の後など) には -1 にセットされ"
"る。"

#. type: SS
#: build/C/man4/st.4:817
#, no-wrap
msgid "MTIOCPOS \\(em get tape position"
msgstr "MTIOCPOS \\(em テープ位置の取得"

#. type: Plain text
#: build/C/man4/st.4:831
msgid ""
"This request takes an argument of type I<(struct mtpos\\ *)> and reports the "
"drive's notion of the current tape block number, which is not the same as "
"I<mt_blkno> returned by B<MTIOCGET>.  This drive must be a SCSI-2 drive that "
"supports the B<READ POSITION> command (device-specific address)  or a "
"Tandberg-compatible SCSI-1 drive (Tandberg, Archive Viper, Wangtek, ... )."
msgstr ""
"このリクエストは I<(struct mtpos\\ *)> 型の引数をとり、ドライブが保持している"
"現在のテープブロック番号を報告する。 これは、 B<MTIOCGET> により返される "
"I<mt_blkno> と同じではない。 ドライブは B<READ POSITION> コマンド (デバイス固"
"有アドレス)  をサポートする SCSI-2ドライブか、 Tandberg 互換の SCSI-1 ドライ"
"ブ (Tandberg, Archive, Viper, Wangtek, ... ) でなければならない。"

#. type: Plain text
#: build/C/man4/st.4:838
#, no-wrap
msgid ""
"/* structure for MTIOCPOS - mag tape get position command */\n"
"struct mtpos {\n"
"    long mt_blkno;    /* current block number */\n"
"};\n"
msgstr ""
"/* structure for MTIOCPOS - mag tape get position command */\n"
"struct mtpos {\n"
"    long mt_blkno;    /* current block number */\n"
"};\n"

#. type: Plain text
#: build/C/man4/st.4:846
msgid ""
"An attempt was made to write or erase a write-protected tape.  (This error "
"is not detected during B<open>(2).)"
msgstr ""
"書き込み保護されているテープに書き込みまたは消去を行おうとした。 (このエラー"
"は B<open>(2)  中には検知されない。)"

#. type: TP
#: build/C/man4/st.4:846
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man4/st.4:850
msgid ""
"The device is already in use or the driver was unable to allocate a buffer."
msgstr ""
"デバイスがすでに使われているか、 ドライバがバッファーを割当てられなかった。"

#. type: Plain text
#: build/C/man4/st.4:854
msgid ""
"The command parameters point to memory not belonging to the calling process."
msgstr ""
"コマンドの引数が、 呼びだしプロセスに属していないメモリー位置を指している。"

#. type: Plain text
#: build/C/man4/st.4:859
msgid ""
"An B<ioctl>(2)  had an invalid argument, or a requested block size was "
"invalid."
msgstr "B<ioctl>(2)  の引数が不正であるか、要求したブロックサイズが不正。"

#. type: TP
#: build/C/man4/st.4:859
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO 14>"

#. type: Plain text
#: build/C/man4/st.4:862
msgid "The requested operation could not be completed."
msgstr "要求された操作が最後まで行えなかった。"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man4/st.4:870
msgid ""
"The byte count in B<read>(2)  is smaller than the next physical block on the "
"tape.  (Before 2.2.18 and 2.4.0 the extra bytes have been silently ignored.)"
msgstr "B<read>(2)  のバイト数が、テープにある次の物理ブロックより小さい (2.2.18 および 2.4.0 以前では、黙って余分のバイトを無視していた)。"

#. type: Plain text
#: build/C/man4/st.4:874
msgid ""
"A write operation could not be completed because the tape reached end-of-"
"medium."
msgstr "メディアの終点に達したため、書き込み操作が完了しなかった。"

#. type: TP
#: build/C/man4/st.4:874 build/C/man2/syslog.2:352
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man4/st.4:878
msgid "Unknown B<ioctl>(2)."
msgstr "不明な B<ioctl>(2)。"

#. type: TP
#: build/C/man4/st.4:878
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man4/st.4:881
msgid "During opening, the tape device does not exist."
msgstr "オープンする時にテープデバイスが存在しなかった。"

#. type: TP
#: build/C/man4/st.4:881
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man4/st.4:885
msgid ""
"An attempt was made to read or write a variable-length block that is larger "
"than the driver's internal buffer."
msgstr ""
"ドライバの内部バッファーより大きいサイズの可変長ブロックを 読み書きしようとし"
"た。"

#. type: Plain text
#: build/C/man4/st.4:892
msgid ""
"Open is attempted with B<O_WRONLY> or B<O_RDWR> when the tape in the drive "
"is write-protected."
msgstr ""
"ドライブに入っているテープがライトプロテクトされている場合に、 B<O_WRONLY> ま"
"たは B<O_RDWR> で open を行おうとした。"

#. type: TP
#: build/C/man4/st.4:893
#, no-wrap
msgid "I</dev/st*>"
msgstr "I</dev/st*>"

#. type: Plain text
#: build/C/man4/st.4:896
msgid "the auto-rewind SCSI tape devices"
msgstr "自動巻き戻しの SCSI テープデバイス。"

#. type: TP
#: build/C/man4/st.4:896
#, no-wrap
msgid "I</dev/nst*>"
msgstr "I</dev/nst*>"

#.  .SH AUTHOR
#.  The driver has been written by Kai M\(:akisara (Kai.Makisara@metla.fi)
#.  starting from a driver written by Dwayne Forsyth.
#.  Several other
#.  people have also contributed to the driver.
#. type: Plain text
#: build/C/man4/st.4:904
msgid "the nonrewind SCSI tape devices"
msgstr "巻き戻しをしない SCSI テープデバイス。"

#. type: Plain text
#: build/C/man4/st.4:925
msgid ""
"When exchanging data between systems, both systems have to agree on the "
"physical tape block size.  The parameters of a drive after startup are often "
"not the ones most operating systems use with these devices.  Most systems "
"use drives in variable-block mode if the drive supports that mode.  This "
"applies to most modern drives, including DATs, 8mm helical scan drives, "
"DLTs, etc.  It may be advisable to use these drives in variable-block mode "
"also in Linux (i.e., use B<MTSETBLK> or B<MTSETDEFBLK> at system startup to "
"set the mode), at least when exchanging data with a foreign system.  The "
"drawback of this is that a fairly large tape block size has to be used to "
"get acceptable data transfer rates on the SCSI bus."
msgstr ""
"異なるシステムでデータを相互にやりとりする場合、 両方のシステムで物理的なテー"
"プブロックサイズを一致させる必要がある。 起動直後のドライブのパラメーターは、"
"大多数の OS がそのデバイスに対して 用いている値と異なっていることもよくある。"
"多くのシステムは、 ドライブが対応していれば可変長ブロックモードを用いる。 "
"DAT、 8mm ヘリカルスキャンドライブ、 DLT などの最近のドライブの ほとんどは可"
"変長ブロックモードに対応しているから。 これらのドライブは (少なくとも他のシス"
"テムとのデータ交換が ある場合は)、 Linux でも可変長ブロックモードで使うほう"
"が 良いかもしれない (つまりシステムの起動時のモード設定に B<MTSETBLK> または "
"B<MTSETDEFBLK> を用いる)。 欠点としては、比較的大きなテープブロックサイズを用"
"いなければ、 SCSI バス上で満足のいく転送速度が得られないことである。"

#. type: Plain text
#: build/C/man4/st.4:932
msgid ""
"Many programs (e.g., B<tar>(1))  allow the user to specify the blocking "
"factor on the command line.  Note that this determines the physical block "
"size on tape only in variable-block mode."
msgstr ""
"多くのプログラム (B<tar>(1)  など) では、 コマンドラインからユーザーがブロッ"
"ク関連の値を指定できる。 この値によってテープ上の物理的なブロックサイズを決定"
"できるのは、 可変長ブロックモードに限られることに注意。"

#. type: Plain text
#: build/C/man4/st.4:939
msgid ""
"In order to use SCSI tape drives, the basic SCSI driver, a SCSI-adapter "
"driver and the SCSI tape driver must be either configured into the kernel or "
"loaded as modules.  If the SCSI-tape driver is not present, the drive is "
"recognized but the tape support described in this page is not available."
msgstr ""
"SCSI テープドライブを用いるには、基本の SCSI ドライバ、 SCSI アダプターのドラ"
"イバ、 SCSI テープドライバのすべてが カーネルに組み込まれているか、あるいはモ"
"ジュールとしてロードされている 必要がある。 SCSI テープドライバがないと、 ド"
"ライブは認識されるが、 このページで記述されているテープのサポートは利用できな"
"い。"

#. type: Plain text
#: build/C/man4/st.4:944
msgid ""
"The driver writes error messages to the console/log.  The SENSE codes "
"written into some messages are automatically translated to text if verbose "
"SCSI messages are enabled in kernel configuration."
msgstr ""
"ドライバはエラーメッセージをコンソールとログとに書き出す。 カーネル設定で "
"verbose SCSI messages が有効にされていると、 SENSE コードが自動的にテキストに"
"変換されて、 いくつかのメッセージに書きだされる。"

#. type: Plain text
#: build/C/man4/st.4:957
msgid ""
"The driver's internal buffering allows good throughput in fixed-block mode "
"also with small B<read>(2)  and B<write>(2)  byte counts.  With direct "
"transfers this is not possible and may cause a surprise when moving to the "
"2.6 kernel.  The solution is to tell the software to use larger transfers "
"(often telling it to use larger blocks).  If this is not possible, direct "
"transfers can be disabled."
msgstr ""
"このドライバの内部バッファーリングは、固定ブロックモードなら B<read>(2)  や "
"B<write>(2)  のバイト数が小さくても良いスループットを出す。 直接転送ではこれ"
"は不可能なので、2.6 カーネルに移行したときに驚くかもしれない。 解決法として"
"は、ソフトウェアにより大きな転送を行うよう伝える (たいていはより大きなブロッ"
"クを使わせる) ことである。 これが不可能なら、直接転送を無効にすることもでき"
"る。"

#. type: Plain text
#: build/C/man4/st.4:959
msgid "B<mt>(1)"
msgstr "B<mt>(1)"

#. type: Plain text
#: build/C/man4/st.4:967
msgid ""
"The file I<drivers/scsi/README.st> or I<Documentation/scsi/st.txt> (kernel "
"E<gt>= 2.6) in the Linux kernel source tree contains the most recent "
"information about the driver and its configuration possibilities"
msgstr ""
"Linux カーネルソースの I<drivers/scsi/README.st> や I<Documentation/scsi/st."
"txt> (カーネル 2.6 以降) の各ファイルには、 ドライバに関するより新しい情報"
"や、 その設定可能な範囲に関する内容が含まれている。"

#. type: TH
#: build/C/man3/stdarg.3:43
#, no-wrap
msgid "STDARG"
msgstr "STDARG"

#. type: Plain text
#: build/C/man3/stdarg.3:46
msgid "stdarg, va_start, va_arg, va_end, va_copy - variable argument lists"
msgstr "stdarg, va_start, va_arg, va_end, va_copy - 個数、型が可変な引数リスト"

#. type: Plain text
#: build/C/man3/stdarg.3:48
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#: build/C/man3/stdarg.3:50
msgid "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"
msgstr "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"

#. type: Plain text
#: build/C/man3/stdarg.3:52
msgid "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"
msgstr "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"

#. type: Plain text
#: build/C/man3/stdarg.3:54
msgid "B<void va_end(va_list >I<ap>B<);>"
msgstr "B<void va_end(va_list >I<ap>B<);>"

#. type: Plain text
#: build/C/man3/stdarg.3:56
msgid "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"
msgstr "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"

#. type: Plain text
#: build/C/man3/stdarg.3:65
msgid ""
"A function may be called with a varying number of arguments of varying "
"types.  The include file I<E<lt>stdarg.hE<gt>> declares a type I<va_list> "
"and defines three macros for stepping through a list of arguments whose "
"number and types are not known to the called function."
msgstr ""
"関数は呼び出しに際して、個数や型が可変な引数をとることができる。 インクルード"
"ファイル I<E<lt>stdarg.hE<gt>> では I<va_list> 型が宣言されており、3 つのマク"
"ロが定義されている。これらを用いると、 呼び出された関数側では個数や型を知らな"
"い引数のリストを、順に一 つづつ読み込むことができる。"

#. type: Plain text
#: build/C/man3/stdarg.3:73
msgid ""
"The called function must declare an object of type I<va_list> which is used "
"by the macros B<va_start>(), B<va_arg>(), and B<va_end>()."
msgstr ""
"呼び出される関数では、 I<va_list> 型のオブジェクトが宣言されていなければなら"
"ない。このオブジェクトが B<va_start>(), B<va_arg>(), B<va_end>()  の各マクロ"
"によって扱われる。"

#. type: SS
#: build/C/man3/stdarg.3:73
#, no-wrap
msgid "va_start()"
msgstr "va_start()"

#. type: Plain text
#: build/C/man3/stdarg.3:83
msgid ""
"The B<va_start>()  macro initializes I<ap> for subsequent use by "
"B<va_arg>()  and B<va_end>(), and must be called first."
msgstr ""
"B<va_start>()  マクロは最初に呼び出さなければならない。これは I<ap> を初期化"
"し、 B<va_arg>()  と B<va_end>()  で用いることができるようにする。"

#. type: Plain text
#: build/C/man3/stdarg.3:88
msgid ""
"The argument I<last> is the name of the last argument before the variable "
"argument list, that is, the last argument of which the calling function "
"knows the type."
msgstr ""
"引数 I<last> は引数リストのうち、可変な部分の直前に置かれる引数の名前で"
"あ る。つまり呼び出された関数が型を知っている最後の引数である。"

#. type: Plain text
#: build/C/man3/stdarg.3:93
msgid ""
"Because the address of this argument may be used in the B<va_start>()  "
"macro, it should not be declared as a register variable, or as a function or "
"an array type."
msgstr ""
"この引数はレジスター変数や関数、配列として 宣言してはならない。この引数の"
"アドレスが B<va_start>()  マクロで用いられるかもしれないからである。"

#. type: SS
#: build/C/man3/stdarg.3:93
#, no-wrap
msgid "va_arg()"
msgstr "va_arg()"

#. type: Plain text
#: build/C/man3/stdarg.3:115
msgid ""
"The B<va_arg>()  macro expands to an expression that has the type and value "
"of the next argument in the call.  The argument I<ap> is the I<va_list> "
"I<ap> initialized by B<va_start>().  Each call to B<va_arg>()  modifies "
"I<ap> so that the next call returns the next argument.  The argument I<type> "
"is a type name specified so that the type of a pointer to an object that has "
"the specified type can be obtained simply by adding a * to I<type>."
msgstr "B<va_arg>()  マクロは、呼び出し時に指定された引数のうち、 次の位置にあるものを指定した型 I<type> の値として取得する。 引数 I<ap> は I<va_list> I<ap> で、 B<va_start>()  によって初期化されている必要がある。 B<va_arg>()  を呼び出すごとに I<ap> は変更され、次回の呼び出しの際に、さらに次の引数を返すようになる。 引数 I<type> は型の名前で、 I<type> の後ろに * を付けるだけで、指定した型を持つオブジェクトへのポインターの型を取得できる必要がある。"

#. type: Plain text
#: build/C/man3/stdarg.3:123
msgid ""
"The first use of the B<va_arg>()  macro after that of the B<va_start>()  "
"macro returns the argument after I<last>.  Successive invocations return the "
"values of the remaining arguments."
msgstr ""
"B<va_start>()  マクロの直後に B<va_arg>()  を最初に実行すると、 I<last> の次"
"の引数が返る。続けて実行すると、残りの引数がそれぞれ返る。"

#. type: Plain text
#: build/C/man3/stdarg.3:128
msgid ""
"If there is no next argument, or if I<type> is not compatible with the type "
"of the actual next argument (as promoted according to the default argument "
"promotions), random errors will occur."
msgstr ""
"次の引数がなかったり、 I<type> が次の引数の実際の型と互換でない場合 (デ"
"フォルトの引数変換で扱 えなかった場合) には、予測できないエラーが起こる。"

#. type: Plain text
#: build/C/man3/stdarg.3:136
msgid ""
"If I<ap> is passed to a function that uses B<va_arg(>I<ap>B<,>I<type>B<),> "
"then the value of I<ap> is undefined after the return of that function."
msgstr ""
"I<ap> が B<va_arg(>I<ap>B<,>I<type>B<)> の形で関数に渡されると、 I<ap> の値は"
"関数から返って来た後は不定となる。"

#. type: SS
#: build/C/man3/stdarg.3:136
#, no-wrap
msgid "va_end()"
msgstr "va_end()"

#. type: Plain text
#: build/C/man3/stdarg.3:155
msgid ""
"Each invocation of B<va_start>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  After the call "
"B<va_end(>I<ap>B<)> the variable I<ap> is undefined.  Multiple traversals of "
"the list, each bracketed by B<va_start>()  and B<va_end>()  are possible.  "
"B<va_end>()  may be a macro or a function."
msgstr ""
"B<va_start>()  が実行される毎に、同じ関数内で対応する B<va_end>()  が実行され"
"なければならない。 B<va_end(>I<ap>B<)> が呼び出された後、変数 I<ap> の値は不"
"定となる。 B<va_start>()  と B<va_end>()  の組を何回も並べて使うことも可能で"
"ある。 B<va_end>()  はマクロかもしれないし関数かもしれない。"

#. type: SS
#: build/C/man3/stdarg.3:155
#, no-wrap
msgid "va_copy()"
msgstr "va_copy()"

#. type: Plain text
#: build/C/man3/stdarg.3:172
msgid ""
"The B<va_copy>()  macro copies the (previously initialized) variable "
"argument list I<src> to I<dest>.  The behavior is as if B<va_start>()  were "
"applied to I<dest> with the same I<last> argument, followed by the same "
"number of B<va_arg>()  invocations that was used to reach the current state "
"of I<src>."
msgstr ""
"B<va_copy>() マクロは (初期化済みの) 可変長引数リスト I<src> を I<dest> に"
"コピーする。動作は、 I<last> 引数に I<dest> を渡して B<va_start>() を "
"I<dest> に適用し、それから I<src> が現在の状態に達するまでに呼び出したのと同"
"じ回数だけ B<va_arg>() を呼び出す、のと同じことを行う。"

#.  Proposal from clive@demon.net, 1997-02-28
#. type: Plain text
#: build/C/man3/stdarg.3:179
msgid ""
"An obvious implementation would have a I<va_list> be a pointer to the stack "
"frame of the variadic function.  In such a setup (by far the most common) "
"there seems nothing against an assignment"
msgstr ""
"すぐ分かる I<va_list> の実装は、variadic な関数のスタックフレームのポインター"
"である。 このような場合(ほとんどはそうである)、 単に以下のようにすればいいよ"
"うに思える。"

#. type: Plain text
#: build/C/man3/stdarg.3:183
#, no-wrap
msgid "va_list aq = ap;\n"
msgstr "va_list aq = ap;\n"

#. type: Plain text
#: build/C/man3/stdarg.3:188
msgid ""
"Unfortunately, there are also systems that make it an array of pointers (of "
"length 1), and there one needs"
msgstr ""
"残念ながら、(長さ 1の)ポインターの配列として扱うシステムもある。 そのような場"
"合、以下のようにする必要がある。"

#. type: Plain text
#: build/C/man3/stdarg.3:193
#, no-wrap
msgid ""
"va_list aq;\n"
"*aq = *ap;\n"
msgstr ""
"va_list aq;\n"
"*aq = *ap;\n"

#. type: Plain text
#: build/C/man3/stdarg.3:209
msgid ""
"Finally, on systems where arguments are passed in registers, it may be "
"necessary for B<va_start>()  to allocate memory, store the arguments there, "
"and also an indication of which argument is next, so that B<va_arg>()  can "
"step through the list.  Now B<va_end>()  can free the allocated memory "
"again.  To accommodate this situation, C99 adds a macro B<va_copy>(), so "
"that the above assignment can be replaced by"
msgstr ""
"最後に、引数をレジスターで渡すシステムの場合、 B<va_start>()  でメモリーを"
"割り当て、引数を格納し、 次の引数がどれかを指し示すようにする必要があ"
"る。 そして B<va_arg>()  でリストを順番にたどり、 B<va_end>()  で割り当てたメ"
"モリーを開放する。 このような状況に対応するため、C99 では B<va_copy>()  マク"
"ロを追加し、 前述のような割り当ては以下のように置き換えられるようにした。"

#. type: Plain text
#: build/C/man3/stdarg.3:216
#, no-wrap
msgid ""
"va_list aq;\n"
"va_copy(aq, ap);\n"
"\\&...\n"
"va_end(aq);\n"
msgstr ""
"va_list aq;\n"
"va_copy(aq, ap);\n"
"\\&...\n"
"va_end(aq);\n"

#. type: Plain text
#: build/C/man3/stdarg.3:229
msgid ""
"Each invocation of B<va_copy>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  Some systems that do not "
"supply B<va_copy>()  have B<__va_copy> instead, since that was the name used "
"in the draft proposal."
msgstr ""
"B<va_copy>()  が実行されるごとに、 対応する B<va_end>()  を同じ関数内で実行し"
"なければならない。 この名前はまだ draft proposal なので、 B<va_copy>()  の代"
"わりに B<__va_copy> を用いるシステムもある。"

#. type: tbl table
#: build/C/man3/stdarg.3:241
#, no-wrap
msgid ""
"B<va_start>(),\n"
"B<va_end>(),\n"
"B<va_copy>()"
msgstr ""
"B<va_start>(),\n"
"B<va_end>(),\n"
"B<va_copy>()"

#. type: tbl table
#: build/C/man3/stdarg.3:244
#, no-wrap
msgid "B<va_arg>()"
msgstr "B<va_arg>()"

#. type: tbl table
#: build/C/man3/stdarg.3:244
#, no-wrap
msgid "MT-Safe race:ap"
msgstr "MT-Safe race:ap"

#. type: Plain text
#: build/C/man3/stdarg.3:256
msgid ""
"The B<va_start>(), B<va_arg>(), and B<va_end>()  macros conform to C89.  C99 "
"defines the B<va_copy>()  macro."
msgstr ""
"B<va_start>(), B<va_arg>(), B<va_end>()  マクロは C89 準拠である。 "
"B<va_copy>()  は C99 で定義されている。"

#. type: Plain text
#: build/C/man3/stdarg.3:272
#, fuzzy
#| msgid ""
#| "Unlike the B<varargs> macros, the B<stdarg> macros do not permit "
#| "programmers to code a function with no fixed arguments.  This problem "
#| "generates work mainly when converting B<varargs> code to B<stdarg> code, "
#| "but it also creates difficulties for variadic functions that wish to pass "
#| "all of their arguments on to a function that takes a I<va_list> argument, "
#| "such as B<vfprintf>(3)."
msgid ""
"Unlike the historical B<varargs> macros, the B<stdarg> macros do not permit "
"programmers to code a function with no fixed arguments.  This problem "
"generates work mainly when converting B<varargs> code to B<stdarg> code, but "
"it also creates difficulties for variadic functions that wish to pass all of "
"their arguments on to a function that takes a I<va_list> argument, such as "
"B<vfprintf>(3)."
msgstr ""
"B<varargs> マクロとは異なり、 B<stdarg> マクロでは固定引数なしで関数を指定"
"することが許されていない。 これは B<varargs> ベースのコードを B<stdarg> の"
"コードに書き換えるときに、面倒な作業のもとになる。 また、すべての引数を "
"I<va_list> として可変個指定したいような場合 (B<vfprintf>(3)  など) にも障害と"
"なる。"

#. type: Plain text
#: build/C/man3/stdarg.3:277
msgid ""
"The function I<foo> takes a string of format characters and prints out the "
"argument associated with each format character based on the type."
msgstr ""
"関数 I<foo> は書式文字からなる文字列を受け入れ、その書式文字に対応する型で可"
"変個の 引数を読み込み、印字する。"

#. type: Plain text
#: build/C/man3/stdarg.3:281
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: build/C/man3/stdarg.3:284
#, no-wrap
msgid ""
"void\n"
"foo(char *fmt, ...)   /* \\(aq...\\(aq is C syntax for a variadic function */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdarg.3:290
#, no-wrap
msgid ""
"{\n"
"    va_list ap;\n"
"    int d;\n"
"    char c;\n"
"    char *s;\n"
msgstr ""
" {\n"
"    va_list ap;\n"
"    int d;\n"
"    char c;\n"
"    char *s;\n"

#. type: Plain text
#: build/C/man3/stdarg.3:311
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    while (*fmt)\n"
"        switch (*fmt++) {\n"
"        case \\(aqs\\(aq:              /* string */\n"
"            s = va_arg(ap, char *);\n"
"            printf(\"string %s\\en\", s);\n"
"            break;\n"
"        case \\(aqd\\(aq:              /* int */\n"
"            d = va_arg(ap, int);\n"
"            printf(\"int %d\\en\", d);\n"
"            break;\n"
"        case \\(aqc\\(aq:              /* char */\n"
"            /* need a cast here since va_arg only\n"
"               takes fully promoted types */\n"
"            c = (char) va_arg(ap, int);\n"
"            printf(\"char %c\\en\", c);\n"
"            break;\n"
"        }\n"
"    va_end(ap);\n"
"}\n"
msgstr ""
"    va_start(ap, fmt);\n"
"    while (*fmt)\n"
"        switch (*fmt++) {\n"
"        case \\(aqs\\(aq:              /* string */\n"
"            s = va_arg(ap, char *);\n"
"            printf(\"string %s\\en\", s);\n"
"            break;\n"
"        case \\(aqd\\(aq:              /* int */\n"
"            d = va_arg(ap, int);\n"
"            printf(\"int %d\\en\", d);\n"
"            break;\n"
"        case \\(aqc\\(aq:              /* char */\n"
"            /* need a cast here since va_arg only\n"
"               takes fully promoted types */\n"
"            c = (char) va_arg(ap, int);\n"
"            printf(\"char %c\\en\", c);\n"
"            break;\n"
"        }\n"
"    va_end(ap);\n"
"}\n"

#. type: Plain text
#: build/C/man3/stdarg.3:316
msgid "B<vprintf>(3), B<vscanf>(3), B<vsyslog>(3)"
msgstr " B<vprintf>(3), B<vscanf>(3), B<vsyslog>(3)"

#. type: TH
#: build/C/man2/syslog.2:32 build/C/man3/syslog.3:37
#, no-wrap
msgid "SYSLOG"
msgstr "SYSLOG"

#. type: Plain text
#: build/C/man2/syslog.2:36
msgid ""
"syslog, klogctl - read and/or clear kernel message ring buffer; set "
"console_loglevel"
msgstr ""
"syslog, klogctl - カーネルのメッセージリングバッファーを読んだり消去したりす"
"る; console_loglevel の設定を行う"

#. type: Plain text
#: build/C/man2/syslog.2:40
#, no-wrap
msgid ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* No wrapper provided in glibc */>\n"
msgstr ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* glibc ではラッパー関数は提供されていない */>\n"

#. type: Plain text
#: build/C/man2/syslog.2:43
#, no-wrap
msgid ""
"/* The glibc interface */\n"
"B<#include E<lt>sys/klog.hE<gt>>\n"
msgstr ""
" /* glibc インターフェース */\n"
"B<#include E<lt>sys/klog.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/syslog.2:45
#, no-wrap
msgid "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
msgstr "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/syslog.2:55
msgid ""
"I<Note>: Probably, you are looking for the C library function B<syslog>(), "
"which talks to B<syslogd>(8); see B<syslog>(3)  for details."
msgstr ""
"I<注意>: おそらく、あなたが探しているのは、 B<syslogd>(8) と通信する C ライブ"
"ラリ関数の B<syslog>() でしょう。詳細は B<syslog>(3) を参照のこと。"

#. type: Plain text
#: build/C/man2/syslog.2:62
msgid ""
"This page describes the kernel B<syslog>()  system call, which is used to "
"control the kernel I<printk>()  buffer; the glibc wrapper function for the "
"system call is called B<klogctl>()."
msgstr ""
"このページはカーネルの B<syslog>() システムコールについて説明している。 "
"B<syslog>() システムコールはカーネルの I<printk>() バッファーを制御するために"
"使用される。 このシステムコールに対する glibc ラッパー関数は B<klogctl>() と"
"呼ばれている。"

#. type: SS
#: build/C/man2/syslog.2:62
#, no-wrap
msgid "The kernel log buffer"
msgstr "カーネルログバッファー (kernel log buffer)"

#.  Under "General setup" ==> "Kernel log buffer size"
#.  For 2.6, precisely the option seems to have appeared in 2.5.55.
#. type: Plain text
#: build/C/man2/syslog.2:79
msgid ""
"The kernel has a cyclic buffer of length B<LOG_BUF_LEN> in which messages "
"given as arguments to the kernel function B<printk>()  are stored "
"(regardless of their log level).  In early kernels, B<LOG_BUF_LEN> had the "
"value 4096; from kernel 1.3.54, it was 8192; from kernel 2.1.113, it was "
"16384; since kernel 2.4.23/2.6, the value is a kernel configuration option "
"(B<CONFIG_LOG_BUF_SHIFT>, default value dependent on the architecture).  "
"Since Linux 2.6.6, the size can be queried with command type 10 (see below)."
msgstr ""
"カーネルは長さ B<LOG_BUF_LEN> の巡回式のバッファーを持っており、 それにはカー"
"ネル関数の B<printk>()  の引数として与えられた メッセージが (そのログレベル"
"にかかわらず) 格納される。 初期のカーネルでは B<LOG_BUF_LEN> の値は 4096 で"
"あった。 カーネル 1.3.54 からは 8192、 カーネル 2.1.113 からは 16384 にな"
"り、 カーネル 2.4.23 以降および 2.6 以降ではカーネル設定オプション "
"(B<CONFIG_LOG_BUF_SHIFT>、 デフォルト値はアーキテクチャー依存) で値を設定でき"
"るようになっている。 Linux 2.6.6 以降では、コマンド 10 (下記参照) でバッ"
"ファーのサイズを問い合わせできる。"

#. type: SS
#: build/C/man2/syslog.2:79
#, no-wrap
msgid "Commands"
msgstr "コマンド"

#. type: Plain text
#: build/C/man2/syslog.2:86
msgid ""
"The I<type> argument determines the action taken by this function.  The list "
"below specifies the values for I<type>.  The symbolic names are defined in "
"the kernel source, but are not exported to user space; you will either need "
"to use the numbers, or define the names yourself."
msgstr ""
"I<type> 引数はこの関数が行う動作を決定する。 以下のリストに示す値を "
"I<type> に指定できる。 シンボル名はカーネルソースで定義されているが、ユーザー"
"空間には公開されていない。 したがって、数字を使うか、名前を自分で定義する必要"
"がある。"

#. type: TP
#: build/C/man2/syslog.2:86
#, no-wrap
msgid "B<SYSLOG_ACTION_CLOSE> (0)"
msgstr "B<SYSLOG_ACTION_CLOSE> (0)"

#. type: Plain text
#: build/C/man2/syslog.2:90
msgid "Close the log.  Currently a NOP."
msgstr "ログをクローズする。現在のところ NOP である。"

#. type: TP
#: build/C/man2/syslog.2:90
#, no-wrap
msgid "B<SYSLOG_ACTION_OPEN> (1)"
msgstr "B<SYSLOG_ACTION_OPEN> (1)"

#. type: Plain text
#: build/C/man2/syslog.2:94
msgid "Open the log.  Currently a NOP."
msgstr "ログをオープンする。現在のところ NOP である。"

#. type: TP
#: build/C/man2/syslog.2:94
#, no-wrap
msgid "B<SYSLOG_ACTION_READ> (2)"
msgstr "B<SYSLOG_ACTION_READ> (2)"

#. type: Plain text
#: build/C/man2/syslog.2:106
msgid ""
"Read from the log.  The call waits until the kernel log buffer is nonempty, "
"and then reads at most I<len> bytes into the buffer pointed to by I<bufp>.  "
"The call returns the number of bytes read.  Bytes read from the log "
"disappear from the log buffer: the information can be read only once.  This "
"is the function executed by the kernel when a user program reads I</proc/"
"kmsg>."
msgstr ""
"ログを読み出す。 この呼び出しは、 カーネルログバッファーが空でなくなるまで"
"待って、 最大 I<len> バイトまで I<bufp> が指すバッファーに読み込み、 読み込ん"
"だバイト数を返す。 ログから読まれたバイトはログバッファーから消える。 つま"
"り、情報は一度しか読むことができない。 これはユーザーのプログラムが I</proc/"
"kmsg> を読んだ時にカーネルによって実行される関数でもある。"

#. type: TP
#: build/C/man2/syslog.2:106
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_ALL> (3)"
msgstr "B<SYSLOG_ACTION_READ_ALL> (3)"

#. type: Plain text
#: build/C/man2/syslog.2:116
msgid ""
"Read all messages remaining in the ring buffer, placing them in the buffer "
"pointed to by I<bufp>.  The call reads the last I<len> bytes from the log "
"buffer (nondestructively), but will not read more than was written into the "
"buffer since the last \"clear ring buffer\" command (see command 5 below)).  "
"The call returns the number of bytes read."
msgstr ""
"リングバッファーに残っているメッセージをすべて読み出し、 I<bufp> が指すバッ"
"ファーに格納する。 この呼び出しログバッファーの最後の I<len> バイトを (非破壊"
"的に) 読み出すが、 最後の「リングバッファー消去」命令 (下記のコマンド 5 参"
"照) 以降にバッファーに書き込まれた情報しか読み出せない。 返り値は読み込んだバ"
"イト数である。"

#. type: TP
#: build/C/man2/syslog.2:116
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_CLEAR> (4)"
msgstr "B<SYSLOG_ACTION_READ_CLEAR> (4)"

#. type: Plain text
#: build/C/man2/syslog.2:122
msgid ""
"Read and clear all messages remaining in the ring buffer.  The call does "
"precisely the same as for a I<type> of 3, but also executes the \"clear ring "
"buffer\" command."
msgstr ""
"リングバッファーに残っているメッセージをすべて読み出し、クリアする。 この呼び"
"出しは I<type> 3 と全く同じことを行い、追加で「リングバッファー消去」 "
"(\"clear ring buffer\") コマンドも実行する。"

#. type: TP
#: build/C/man2/syslog.2:122
#, no-wrap
msgid "B<SYSLOG_ACTION_CLEAR> (5)"
msgstr "B<SYSLOG_ACTION_CLEAR> (5)"

#. type: Plain text
#: build/C/man2/syslog.2:130
msgid ""
"The call executes just the \"clear ring buffer\" command.  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""
"「リングバッファー消去」 (\\\"clear ring buffer\\\") コマンドのみを実行す"
"る。 引数 I<bufp> と I<len> は無視される。"

#. type: Plain text
#: build/C/man2/syslog.2:141
msgid ""
"This command does not really clear the ring buffer.  Rather, it sets a "
"kernel bookkeeping variable that determines the results returned by commands "
"3 (B<SYSLOG_ACTION_READ_ALL>)  and 4 (B<SYSLOG_ACTION_READ_CLEAR>).  This "
"command has no effect on commands 2 (B<SYSLOG_ACTION_READ>)  and 9 "
"(B<SYSLOG_ACTION_SIZE_UNREAD>)."
msgstr ""
"このコマンドは実際にリングバッファーをクリアするわけではなく、 コマンド 3 "
"(B<SYSLOG_ACTION_READ_ALL>) と 4 (B<SYSLOG_ACTION_READ_CLEAR> で返す内容を決"
"定するカーネルの管理変数を設定する。 このコマンドはコマンド 2 "
"(B<SYSLOG_ACTION_READ>) と 9 (B<SYSLOG_ACTION_SIZE_UNREAD>) には影響を与えな"
"い。"

#. type: TP
#: build/C/man2/syslog.2:141
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"
msgstr "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: build/C/man2/syslog.2:159
msgid ""
"The command saves the current value of I<console_loglevel> and then sets "
"I<console_loglevel> to I<minimum_console_loglevel>, so that no messages are "
"printed to the console.  Before Linux 2.6.32, the command simply sets "
"I<console_loglevel> to I<minimum_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""
"このコマンドは I<console_loglevel> の現在の値を保存し、それから "
"I<console_loglevel> を I<minimum_console_loglevel> に設定する。 これにより、"
"コンソールにメッセージが出力されなくなる。 Linux 2.6.32 より前では、 このコマ"
"ンドは I<console_loglevel> を I<minimum_console_loglevel> に設定するだけで"
"あった。 下記の I</proc/sys/kernel/printk> の議論を参照。"

#. type: Plain text
#: build/C/man2/syslog.2:165 build/C/man2/syslog.2:188
msgid "The I<bufp> and I<len> arguments are ignored."
msgstr "引数 I<bufp> と I<len> は無視される。"

#. type: TP
#: build/C/man2/syslog.2:165
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_ON> (7)"
msgstr "B<SYSLOG_ACTION_CONSOLE_ON> (7)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: build/C/man2/syslog.2:182
msgid ""
"If a previous B<SYSLOG_ACTION_CONSOLE_OFF> command has been performed, this "
"command restores I<console_loglevel> to the value that was saved by that "
"command.  Before Linux 2.6.32, this command simply sets I<console_loglevel> "
"to I<default_console_loglevel>.  See the discussion of I</proc/sys/kernel/"
"printk>, below."
msgstr ""
"直前に B<SYSLOG_ACTION_CONSOLE_OFF> コマンドがされた場合、 このコマンドは "
"I<console_loglevel> を前のコマンドが保存した値に戻す。 Linux 2.6.32 より前で"
"は、 このコマンドは単に I<console_loglevel> を I<default_console_loglevel> に"
"設定するだけであった。 下記の I</proc/sys/kernel/printk> の議論を参照。"

#. type: TP
#: build/C/man2/syslog.2:188
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"
msgstr "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"

#. type: Plain text
#: build/C/man2/syslog.2:205
msgid ""
"The call sets I<console_loglevel> to the value given in I<len>, which must "
"be an integer between 1 and 8 (inclusive).  The kernel silently enforces a "
"minimum value of I<minimum_console_loglevel> for I<len>.  See the I<log "
"level> section for details.  The I<bufp> argument is ignored."
msgstr ""
"I<console_loglevel> を I<len> で指定された値に設定する。 I<len> は 1 以上 8 "
"以下の整数でなければならない。 カーネルにより、暗黙のうちに I<len> に "
"I<minimum_console_loglevel> で指定される最小値が適用される。 詳細は「ログレベ"
"ル」の節を参照のこと。 引数 I<bufp> は無視される。"

#. type: TP
#: build/C/man2/syslog.2:205
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (since Linux 2.4.10)"
msgstr "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (Linux 2.4.10 以降)"

#. type: Plain text
#: build/C/man2/syslog.2:216
msgid ""
"The call returns the number of bytes currently available to be read from the "
"kernel log buffer via command 2 (B<SYSLOG_ACTION_READ>).  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""
"コマンド 2 (B<SYSLOG_ACTION_READ>) でカーネルログバッファーから読み出せるバイ"
"ト数を返す。 引数 I<bufp> と I<len> は無視される。"

#. type: TP
#: build/C/man2/syslog.2:216
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (since Linux 2.6.6)"
msgstr "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (Linux 2.6.6 以降)"

#. type: Plain text
#: build/C/man2/syslog.2:224
msgid ""
"This command returns the total size of the kernel log buffer.  The I<bufp> "
"and I<len> arguments are ignored."
msgstr ""
"カーネルログバッファーの全体のサイズを返す。 引数 I<bufp> と I<len> は無視"
"される。"

#. type: Plain text
#: build/C/man2/syslog.2:243
msgid ""
"All commands except 3 and 10 require privilege.  In Linux kernels before "
"2.6.37, command types 3 and 10 are allowed to unprivileged processes; since "
"Linux 2.6.37, these commands are allowed to unprivileged processes only if "
"I</proc/sys/kernel/dmesg_restrict> has the value 0.  Before Linux 2.6.37, "
"\"privileged\" means that the caller has the B<CAP_SYS_ADMIN> capability.  "
"Since Linux 2.6.37, \"privileged\" means that the caller has either the "
"B<CAP_SYS_ADMIN> capability (now deprecated for this purpose) or the (new)  "
"B<CAP_SYSLOG> capability."
msgstr ""
"コマンド種別 3 と 10 以外のコマンドは全て特権が必要である。\n"
"バージョン 2.6.37 より前の Linux カーネルでは、\n"
"コマンド種別 3 と 10 は非特権プロセスも呼び出すことができる。\n"
"Linux 2.6.37 以降では、I</proc/sys/kernel/dmesg_restrict> が値 0 の場合に限"
"り、\n"
"非特権プロセスはこれらのコマンドを呼び出すことができる。\n"
"Linux 2.6.37 より前では、「特権を持つ (privileged)」とは呼び出し者が\n"
"B<CAP_SYS_ADMIN> ケーパビリティを持つことを意味する。\n"
"Linux 2.6.37 以降では、「特権を持つ」とは呼び出し者が\n"
"B<CAP_SYS_ADMIN> ケーパビリティか\n"
"(新しい) B<CAP_SYSLOG> ケーパビリティのいずれかを持つことを意味する\n"
"(この目的で B<CAP_SYS_ADMIN> ケーパビリティを使うのは今は非推奨である)。"

#. type: SS
#: build/C/man2/syslog.2:243
#, no-wrap
msgid "/proc/sys/kernel/printk"
msgstr "/proc/sys/kernel/printk"

#. type: Plain text
#: build/C/man2/syslog.2:249
msgid ""
"I</proc/sys/kernel/printk> is a writable file containing four integer values "
"that influence kernel I<printk()> behavior when printing or logging error "
"messages.  The four values are:"
msgstr ""
"I</proc/sys/kernel/printk> は書き込み可能なファイルで、 エラーメッセージのロ"
"グ出力を行う際にカーネルの I<printk()> の動作に影響を持つ 4 つの整数値が入っ"
"ている。 4 つの値は以下のとおりである。"

#. type: TP
#: build/C/man2/syslog.2:249
#, no-wrap
msgid "I<console_loglevel>"
msgstr "I<console_loglevel>"

#.  since Linux 2.4
#. type: Plain text
#: build/C/man2/syslog.2:267
msgid ""
"Only messages with a log level lower than this value will be printed to the "
"console.  The default value for this field is B<DEFAULT_CONSOLE_LOGLEVEL> "
"(7), but it is set to 4 if the kernel command line contains the word \"quiet"
"\", 10 if the kernel command line contains the word \"debug\", and to 15 in "
"case of a kernel fault (the 10 and 15 are just silly, and equivalent to 8).  "
"The value of I<console_loglevel> can be set (to a value in the range "
"1\\(en8) by a B<syslog>()  call with a I<type> of 8."
msgstr "メッセージのログレベルがこの値よりも小さい場合のみ、メッセージだけがコンソールに出力される。 このフィールドのデフォルト値は B<DEFAULT_CONSOLE_LOGLEVEL> (7) だが、 カーネルのコマンドラインに \"quiet\" という単語が含まれている場合は 4 に設定され、 \"debug\" という単語が含まれている場合は 10 に設定され、 カーネルフォールトが発生した場合には 15 に設定される (但し、10 や 15 という数字に意味はなく、8 と同等である)。 I<console_loglevel> の値は I<type> が 8 の B<syslog>() の呼び出しによって設定でき、 設定できる値の範囲は 1\\(en8 である。"

#. type: TP
#: build/C/man2/syslog.2:267
#, no-wrap
msgid "I<default_message_loglevel>"
msgstr "I<default_message_loglevel>"

#.  commit 5af5bcb8d37f99ba415a1adc6da71051b84f93a5
#. type: Plain text
#: build/C/man2/syslog.2:280
msgid ""
"This value will be used as the log level for I<printk()> messages that do "
"not have an explicit level.  Up to and including Linux 2.6.38, the hard-"
"coded default value for this field was 4 (B<KERN_WARNING>); since Linux "
"2.6.39, the default value is a defined by the kernel configuration option "
"B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL>, which defaults to 4."
msgstr ""
"この値は、明示的にログレベルが指定されていない I<printk()> メッセージのログレ"
"ベルとして使用される。 Linux 2.6.38 以前では、 このフィールドのデフォルト値"
"は 4 (B<KERN_WARNING>) にハードコードされていた。 Linux 2.6.39 以降では、 デ"
"フォルト値はカーネルの設定オプション B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL> で定"
"義されており、 デフォルト値は 4 である。"

#. type: TP
#: build/C/man2/syslog.2:280
#, no-wrap
msgid "I<minimum_console_loglevel>"
msgstr "I<minimum_console_loglevel>"

#. type: Plain text
#: build/C/man2/syslog.2:285
msgid ""
"The value in this field is the minimum value to which I<console_loglevel> "
"can be set."
msgstr "このフィールドの値は I<console_loglevel> に設定できる最小値である。"

#. type: TP
#: build/C/man2/syslog.2:285
#, no-wrap
msgid "I<default_console_loglevel>"
msgstr "I<default_console_loglevel>"

#. type: Plain text
#: build/C/man2/syslog.2:291
msgid "This is the default value for I<console_loglevel>."
msgstr "I<console_loglevel> のデフォルト値である。"

#. type: SS
#: build/C/man2/syslog.2:291
#, no-wrap
msgid "The log level"
msgstr "ログレベル"

#. type: Plain text
#: build/C/man2/syslog.2:299
msgid ""
"Every I<printk>()  message has its own log level.  If the log level is not "
"explicitly specified as part of the message, it defaults to "
"I<default_message_loglevel>.  The conventional meaning of the log level is "
"as follows:"
msgstr ""
"すべての I<printk>() メッセージにはそれぞれログレベルがある。 ログレベルが"
"メッセージの一部として明示的に指定されなかった場合は、 ログレベルは "
"I<default_message_loglevel> になる。ログレベルの一般的な意味は以下のとおりで"
"ある。"

#. type: tbl table
#: build/C/man2/syslog.2:302
#, no-wrap
msgid "Kernel constant"
msgstr "カーネル定数"

#. type: tbl table
#: build/C/man2/syslog.2:302
#, no-wrap
msgid "Level value"
msgstr "レベル値"

#. type: tbl table
#: build/C/man2/syslog.2:302
#, no-wrap
msgid "Meaning"
msgstr "意味"

#. type: tbl table
#: build/C/man2/syslog.2:303
#, no-wrap
msgid "KERN_EMERG"
msgstr "KERN_EMERG"

#. type: tbl table
#: build/C/man2/syslog.2:303
#, no-wrap
msgid "System is unusable"
msgstr "システムが使用不可"

#. type: tbl table
#: build/C/man2/syslog.2:304
#, no-wrap
msgid "KERN_ALERT"
msgstr "KERN_ALERT"

#. type: tbl table
#: build/C/man2/syslog.2:304
#, no-wrap
msgid "Action must be taken immediately"
msgstr "直ちに対応しなければならない"

#. type: tbl table
#: build/C/man2/syslog.2:305
#, no-wrap
msgid "KERN_CRIT"
msgstr "KERN_CRIT"

#. type: tbl table
#: build/C/man2/syslog.2:305
#, no-wrap
msgid "Critical conditions"
msgstr "危険な状況"

#. type: tbl table
#: build/C/man2/syslog.2:306
#, no-wrap
msgid "KERN_ERR"
msgstr "KERN_ERR"

#. type: tbl table
#: build/C/man2/syslog.2:306
#, no-wrap
msgid "Error conditions"
msgstr "エラー状況"

#. type: tbl table
#: build/C/man2/syslog.2:307
#, no-wrap
msgid "KERN_WARNING"
msgstr "KERN_WARNING"

#. type: tbl table
#: build/C/man2/syslog.2:307
#, no-wrap
msgid "Warning conditions"
msgstr "警告状況"

#. type: tbl table
#: build/C/man2/syslog.2:308
#, no-wrap
msgid "KERN_NOTICE"
msgstr "KERN_NOTICE"

#. type: tbl table
#: build/C/man2/syslog.2:308
#, no-wrap
msgid "Normal but significant condition"
msgstr "通常だが重要な状況"

#. type: tbl table
#: build/C/man2/syslog.2:309
#, no-wrap
msgid "KERN_INFO"
msgstr "KERN_INFO"

#. type: tbl table
#: build/C/man2/syslog.2:309
#, no-wrap
msgid "6"
msgstr "6"

#. type: tbl table
#: build/C/man2/syslog.2:309
#, no-wrap
msgid "Informational"
msgstr "参考情報"

#. type: tbl table
#: build/C/man2/syslog.2:310
#, no-wrap
msgid "KERN_DEBUG"
msgstr "KERN_DEBUG"

#. type: tbl table
#: build/C/man2/syslog.2:310
#, no-wrap
msgid "Debug-level messages"
msgstr "デバッグレベルのメッセージ"

#. type: Plain text
#: build/C/man2/syslog.2:318
msgid ""
"The kernel I<printk()> routine will print a message on the console only if "
"it has a log level less than the value of I<console_loglevel>."
msgstr ""
"カーネルの I<printk()> ルーチンは、メッセージのログレベルが "
"I<console_loglevel> よりも小さい値の場合にのみ、 メッセージをコンソールに出力"
"する。"

#. type: Plain text
#: build/C/man2/syslog.2:331
msgid ""
"For I<type> equal to 2, 3, or 4, a successful call to B<syslog>()  returns "
"the number of bytes read.  For I<type> 9, B<syslog>()  returns the number of "
"bytes currently available to be read on the kernel log buffer.  For I<type> "
"10, B<syslog>()  returns the total size of the kernel log buffer.  For other "
"values of I<type>, 0 is returned on success."
msgstr ""
"I<type> が 2, 3, 4 の場合、成功すると B<syslog>()  は読み出したバイト数を返"
"す。 I<type> が 9 の場合、 カーネルログバッファーにある現在読み出し可能なバイ"
"ト数を返す。 I<type> が 10 の場合、 カーネルログバッファーの総量を返す。 "
"I<type> がそれ以外の値の場合、成功すると 0 が返される。"

#. type: Plain text
#: build/C/man2/syslog.2:334
msgid ""
"In case of error, -1 is returned, and I<errno> is set to indicate the error."
msgstr "エラーの場合は、-1\\ が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/syslog.2:352
msgid ""
"Bad arguments (e.g., bad I<type>; or for I<type> 2, 3, or 4, I<buf> is NULL, "
"or I<len> is less than zero; or for I<type> 8, the I<level> is outside the "
"range 1 to 8)."
msgstr ""
"不正な引数 (具体的には、 I<type> が正しくない、もしくは I<type> が 2, 3, 4 "
"の場合に I<buf> が NULL か I<len> が 0 未満である、もしくは I<type> が 8 の場"
"合に I<level> が 1 以上 8 以下の範囲に入っていない)。"

#. type: Plain text
#: build/C/man2/syslog.2:359
msgid ""
"This B<syslog>()  system call is not available, because the kernel was "
"compiled with the B<CONFIG_PRINTK> kernel-configuration option disabled."
msgstr ""
"カーネルの設定オプション B<CONFIG_PRINTK> を無効にしてカーネルがコンパイルさ"
"れているため、 B<syslog>()  システムコールが利用できない。"

#. type: Plain text
#: build/C/man2/syslog.2:370
msgid ""
"An attempt was made to change I<console_loglevel> or clear the kernel "
"message ring buffer by a process without sufficient privilege (more "
"precisely: without the B<CAP_SYS_ADMIN> or B<CAP_SYSLOG> capability)."
msgstr ""
"十分な権限を持たないプロセス (正確にはケーパビリティ B<CAP_SYS_ADMIN> も "
"B<CAP_SYSLOG> も持たないプロセス) が I<console_loglevel> を変更しようとした"
"か、 カーネルメッセージリングを消去しようとした。"

#. type: TP
#: build/C/man2/syslog.2:370
#, no-wrap
msgid "B<ERESTARTSYS>"
msgstr "B<ERESTARTSYS>"

#. type: Plain text
#: build/C/man2/syslog.2:374
msgid ""
"System call was interrupted by a signal; nothing was read.  (This can be "
"seen only during a trace.)"
msgstr ""
"システムコールがシグナルによって割り込まれ、何も読み出せなかった。 (トレース"
"中にしか発生することはない)"

#. type: Plain text
#: build/C/man2/syslog.2:377
msgid ""
"This system call is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"このシステムコールは Linux 特有であり、移植を意図したプログラムでは 使用して"
"はいけない。"

#.  In libc4 and libc5 the number of this call was defined by
#.  .BR SYS_klog .
#.  In glibc 2.0 the syscall is baptized
#.  .BR klogctl ().
#. type: Plain text
#: build/C/man2/syslog.2:385
msgid ""
"From the very start, people noted that it is unfortunate that a system call "
"and a library routine of the same name are entirely different animals."
msgstr ""
"かなり初期の頃から、同じ名前を持つシステムコールとライブラリルーチンが\n"
"全く異なる別物であるのは不幸なことだと指摘されてきた。"

#. type: Plain text
#: build/C/man2/syslog.2:389
msgid "B<dmesg>(1), B<syslog>(3), B<capabilities>(7)"
msgstr " B<dmesg>(1), B<syslog>(3), B<capabilities>(7)"

#. type: Plain text
#: build/C/man3/syslog.3:40
msgid "closelog, openlog, syslog, vsyslog - send messages to the system logger"
msgstr "closelog, openlog, syslog, vsyslog - システムロガーにメッセージを送る"

#. type: Plain text
#: build/C/man3/syslog.3:42
msgid "B<#include E<lt>syslog.hE<gt>>"
msgstr "B<#include E<lt>syslog.hE<gt>>"

#. type: Plain text
#: build/C/man3/syslog.3:44
msgid ""
"B<void openlog(const char *>I<ident>B<, int >I<option>B<, int "
">I<facility>B<);>"
msgstr ""
"B<void openlog(const char *>I<ident>B<, int >I<option>B<, int "
">I<facility>B<);>"

#. type: Plain text
#: build/C/man3/syslog.3:46
msgid "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"
msgstr "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/syslog.3:48
msgid "B<void closelog(void);>"
msgstr "B<void closelog(void);>"

#. type: Plain text
#: build/C/man3/syslog.3:50
msgid ""
"B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""
"B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"

#. type: Plain text
#: build/C/man3/syslog.3:61
#, no-wrap
msgid ""
"B<vsyslog>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: SS
#: build/C/man3/syslog.3:62
#, no-wrap
msgid "openlog()"
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:65
msgid "B<openlog>()  opens a connection to the system logger for a program."
msgstr "B<openlog>() は、プログラム用のシステムロガー (system logger) への接続をオープンする。"

#. type: Plain text
#: build/C/man3/syslog.3:75
msgid ""
"The string pointed to by I<ident> is prepended to every message, and is "
"typically set to the program name.  If I<ident> is NULL, the program name is "
"used.  (POSIX.1-2008 does not specify the behavior when I<ident> is NULL.)"
msgstr "I<ident> で指定した文字列は各メッセージの前に付与される。通常は I<ident> にはプログラム名が設定される。 I<ident> が NULL の場合、プログラムが I<ident> として使用される (POSIX.1-2008 では I<ident> が NULL の場合の動作は規定されていない)。"

#. type: Plain text
#: build/C/man3/syslog.3:92
msgid ""
"The I<option> argument specifies flags which control the operation of "
"B<openlog>()  and subsequent calls to B<syslog>().  The I<facility> argument "
"establishes a default to be used if none is specified in subsequent calls to "
"B<syslog>().  The values that may be specified for I<option> and I<facility> "
"are described below."
msgstr "I<option> 引数は、 B<openlog>() の動作とその後の B<syslog>() の呼び出しを制御するフラグを指定する。 I<facility> 引数は、後で B<syslog>() を呼び出す際に facility が指定されなかった場合に使用される デフォルト値を決定する。 I<option> と I<facility> に指定できる値については後述する。"

#. type: Plain text
#: build/C/man3/syslog.3:101
msgid ""
"The use of B<openlog>()  is optional; it will automatically be called by "
"B<syslog>()  if necessary, in which case I<ident> will default to NULL."
msgstr "B<openlog>() は必須ではなく、必要に応じて B<syslog>() から呼び出される。 B<syslog>() が呼び出した場合、 I<ident> のデフォルト値は NULL になる。"

#. type: SS
#: build/C/man3/syslog.3:101
#, no-wrap
msgid "syslog() and vsyslog()"
msgstr "syslog() と vsyslog()"

#. type: Plain text
#: build/C/man3/syslog.3:105
msgid ""
"B<syslog>()  generates a log message, which will be distributed by "
"B<syslogd>(8)."
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:124
msgid ""
"The I<priority> argument is formed by ORing together a I<facility> value and "
"a I<level> value (described below).  If no I<facility> value is ORed into "
"I<priority>, then the default value set by B<openlog>()  is used, or, if "
"there was no preceding B<openlog>()  call, a default of B<LOG_USER> is "
"employed."
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:137
msgid ""
"The remaining arguments are a I<format>, as in B<printf>(3), and any "
"arguments required by the I<format>, except that the two-character sequence "
"B<%m> will be replaced by the error message string I<strerror>(I<errno>).  "
"The format string need not include a terminating newline character."
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:147
msgid ""
"The function B<vsyslog>()  performs the same task as B<syslog>()  with the "
"difference that it takes a set of arguments which have been obtained using "
"the B<stdarg>(3)  variable argument list macros."
msgstr ""
"B<vsyslog>()  関数は B<syslog>()  と同じ機能を持つが、可変引数リストを指定"
"することができる点が異なる。 指定された引数は、 B<stdarg>(3)  可変引数リ"
"ストマクロを用いて取得される。"

#. type: SS
#: build/C/man3/syslog.3:147
#, no-wrap
msgid "closelog()"
msgstr " closelog()"

#. type: Plain text
#: build/C/man3/syslog.3:154
msgid ""
"B<closelog>()  closes the file descriptor being used to write to the system "
"logger.  The use of B<closelog>()  is optional."
msgstr "B<closelog>() は、システムロガーに書き込むのに使用されるファイルディスクリプターをクローズする。 B<closelog>() の使用は必須ではない。"

#. type: SS
#: build/C/man3/syslog.3:154
#, no-wrap
msgid "Values for I<option>"
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:160
#, fuzzy
#| msgid "The I<option> argument to B<openlog>()  is an OR of any of these:"
msgid ""
"The I<option> argument to B<openlog>()  is a bit mask constructed by ORing "
"together any of the following values:"
msgstr "下記の値を OR したものが B<openlog>()  の I<option> 引数になる:"

#. type: TP
#: build/C/man3/syslog.3:160
#, no-wrap
msgid "B<LOG_CONS>"
msgstr "B<LOG_CONS>"

#. type: Plain text
#: build/C/man3/syslog.3:164
msgid ""
"Write directly to the system console if there is an error while sending to "
"the system logger."
msgstr ""
"エラーがあれば、システムロガーに送る一方でシステムコンソールにも直接書く。"

#. type: TP
#: build/C/man3/syslog.3:164
#, no-wrap
msgid "B<LOG_NDELAY>"
msgstr "B<LOG_NDELAY>"

#. type: Plain text
#: build/C/man3/syslog.3:171
msgid ""
"Open the connection immediately (normally, the connection is opened when the "
"first message is logged).  This may be useful, for example, if a subsequent "
"B<chroot>(2)  would make the pathname used internally by the logging "
"facility unreachable."
msgstr ""

#. type: TP
#: build/C/man3/syslog.3:171
#, no-wrap
msgid "B<LOG_NOWAIT>"
msgstr "B<LOG_NOWAIT>"

#. type: Plain text
#: build/C/man3/syslog.3:177
msgid ""
"Don't wait for child processes that may have been created while logging the "
"message.  (The GNU C library does not create a child process, so this option "
"has no effect on Linux.)"
msgstr ""
"メッセージを記録する際に生成される子プロセスの終了を待たない。 (GNU C ライブ"
"ラリは子プロセスを生成しない。 したがって、このオプションは Linux では無効で"
"ある。)"

#. type: TP
#: build/C/man3/syslog.3:177
#, no-wrap
msgid "B<LOG_ODELAY>"
msgstr "B<LOG_ODELAY>"

#. type: Plain text
#: build/C/man3/syslog.3:185
msgid ""
"The converse of B<LOG_NDELAY>; opening of the connection is delayed until "
"B<syslog>()  is called.  (This is the default, and need not be specified.)"
msgstr ""
"B<LOG_NDELAY> の反対。 B<syslog>()  が呼ばれるまで、接続の開始を行わない。 "
"(このオプションはデフォルトであり、特に指定する必要はない。)"

#. type: TP
#: build/C/man3/syslog.3:185
#, no-wrap
msgid "B<LOG_PERROR>"
msgstr "B<LOG_PERROR>"

#. type: Plain text
#: build/C/man3/syslog.3:190
msgid ""
"(Not in POSIX.1-2001 or POSIX.1-2008.)  Also log the message to I<stderr>."
msgstr "メッセージを I<stderr> にも出力する。 (POSIX.1-2001 にも POSIX.1-2008 にも定義されていない)"

#. type: TP
#: build/C/man3/syslog.3:190
#, no-wrap
msgid "B<LOG_PID>"
msgstr "B<LOG_PID>"

#. type: Plain text
#: build/C/man3/syslog.3:194
msgid "Include the caller's PID with each message."
msgstr "個々のメッセージに呼び出し元の PID を含める。"

#. type: SS
#: build/C/man3/syslog.3:194
#, no-wrap
msgid "Values for I<facility>"
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:200
msgid ""
"The I<facility> argument is used to specify what type of program is logging "
"the message.  This lets the configuration file specify that messages from "
"different facilities will be handled differently."
msgstr ""
"I<facility> 引数はメッセージに記録されるプログラムのタイプを指定するために"
"使われる。 これによって異なるタイプのプログラムからのメッセージは異なる扱い"
"を するように設定ファイル( B<syslog.conf>(5))  に定義できる。"

#. type: TP
#: build/C/man3/syslog.3:200
#, no-wrap
msgid "B<LOG_AUTH>"
msgstr "B<LOG_AUTH>"

#. type: Plain text
#: build/C/man3/syslog.3:203
msgid "security/authorization messages"
msgstr "セキュリティ/認証 メッセージ"

#. type: TP
#: build/C/man3/syslog.3:203
#, no-wrap
msgid "B<LOG_AUTHPRIV>"
msgstr "B<LOG_AUTHPRIV>"

#. type: Plain text
#: build/C/man3/syslog.3:206
msgid "security/authorization messages (private)"
msgstr "セキュリティ/認証 メッセージ (プライベート)"

#. type: TP
#: build/C/man3/syslog.3:206
#, no-wrap
msgid "B<LOG_CRON>"
msgstr "B<LOG_CRON>"

#. type: Plain text
#: build/C/man3/syslog.3:210
msgid "clock daemon (B<cron> and B<at>)"
msgstr "クロックデーモン (B<cron> と atB<)>"

#. type: TP
#: build/C/man3/syslog.3:210
#, no-wrap
msgid "B<LOG_DAEMON>"
msgstr "B<LOG_DAEMON>"

#. type: Plain text
#: build/C/man3/syslog.3:213
msgid "system daemons without separate facility value"
msgstr "特定の facility 値を持たないシステムデーモン"

#. type: TP
#: build/C/man3/syslog.3:213
#, no-wrap
msgid "B<LOG_FTP>"
msgstr "B<LOG_FTP>"

#. type: Plain text
#: build/C/man3/syslog.3:216
msgid "ftp daemon"
msgstr "ftp デーモン"

#. type: TP
#: build/C/man3/syslog.3:216
#, no-wrap
msgid "B<LOG_KERN>"
msgstr "B<LOG_KERN>"

#.  LOG_KERN has the value 0; if used as a facility, zero translates to:
#.  "use the default facility".
#. type: Plain text
#: build/C/man3/syslog.3:221
msgid "kernel messages (these can't be generated from user processes)"
msgstr "カーネルメッセージ (ユーザープロセスから生成することはできない)"

#. type: TP
#: build/C/man3/syslog.3:221
#, no-wrap
msgid "B<LOG_LOCAL0> through B<LOG_LOCAL7>"
msgstr "B<LOG_LOCAL0> から B<LOG_LOCAL7>"

#. type: Plain text
#: build/C/man3/syslog.3:224
msgid "reserved for local use"
msgstr "ローカルな使用のためにリザーブされている"

#. type: TP
#: build/C/man3/syslog.3:224
#, no-wrap
msgid "B<LOG_LPR>"
msgstr "B<LOG_LPR>"

#. type: Plain text
#: build/C/man3/syslog.3:227
msgid "line printer subsystem"
msgstr "ラインプリンタサブシステム"

#. type: TP
#: build/C/man3/syslog.3:227
#, no-wrap
msgid "B<LOG_MAIL>"
msgstr "B<LOG_MAIL>"

#. type: Plain text
#: build/C/man3/syslog.3:230
msgid "mail subsystem"
msgstr "メールサブシステム"

#. type: TP
#: build/C/man3/syslog.3:230
#, no-wrap
msgid "B<LOG_NEWS>"
msgstr "B<LOG_NEWS>"

#. type: Plain text
#: build/C/man3/syslog.3:233
msgid "USENET news subsystem"
msgstr "USENET ニュースサブシステム"

#. type: TP
#: build/C/man3/syslog.3:233
#, no-wrap
msgid "B<LOG_SYSLOG>"
msgstr "B<LOG_SYSLOG>"

#. type: Plain text
#: build/C/man3/syslog.3:237
msgid "messages generated internally by B<syslogd>(8)"
msgstr "B<syslogd>(8)  によって内部的に発行されるメッセージ"

#. type: TP
#: build/C/man3/syslog.3:237
#, no-wrap
msgid "B<LOG_USER> (default)"
msgstr "B<LOG_USER> (デフォルト)"

#. type: Plain text
#: build/C/man3/syslog.3:240
msgid "generic user-level messages"
msgstr "一般的なユーザーレベルメッセージ"

#. type: TP
#: build/C/man3/syslog.3:240
#, no-wrap
msgid "B<LOG_UUCP>"
msgstr "B<LOG_UUCP>"

#. type: Plain text
#: build/C/man3/syslog.3:244
msgid "UUCP subsystem"
msgstr "UUCPサブシステム"

#. type: SS
#: build/C/man3/syslog.3:244
#, no-wrap
msgid "Values for I<level>"
msgstr ""

#. type: Plain text
#: build/C/man3/syslog.3:247
msgid ""
"This determines the importance of the message.  The levels are, in order of "
"decreasing importance:"
msgstr ""
"これはメッセージの優先度を指定する。 優先度の高いものから低いものの順で下記す"
"る。"

#. type: TP
#: build/C/man3/syslog.3:247
#, no-wrap
msgid "B<LOG_EMERG>"
msgstr "B<LOG_EMERG>"

#. type: Plain text
#: build/C/man3/syslog.3:250
msgid "system is unusable"
msgstr "システムが使用不可"

#. type: TP
#: build/C/man3/syslog.3:250
#, no-wrap
msgid "B<LOG_ALERT>"
msgstr "B<LOG_ALERT>"

#. type: Plain text
#: build/C/man3/syslog.3:253
msgid "action must be taken immediately"
msgstr "直ちに行動を起こさなければならない"

#. type: TP
#: build/C/man3/syslog.3:253
#, no-wrap
msgid "B<LOG_CRIT>"
msgstr "B<LOG_CRIT>"

#. type: Plain text
#: build/C/man3/syslog.3:256
msgid "critical conditions"
msgstr "危険な状態"

#. type: TP
#: build/C/man3/syslog.3:256
#, no-wrap
msgid "B<LOG_ERR>"
msgstr "B<LOG_ERR>"

#. type: Plain text
#: build/C/man3/syslog.3:259
msgid "error conditions"
msgstr "エラーの状態"

#. type: TP
#: build/C/man3/syslog.3:259
#, no-wrap
msgid "B<LOG_WARNING>"
msgstr "B<LOG_WARNING>"

#. type: Plain text
#: build/C/man3/syslog.3:262
msgid "warning conditions"
msgstr "ワーニングの状態"

#. type: TP
#: build/C/man3/syslog.3:262
#, no-wrap
msgid "B<LOG_NOTICE>"
msgstr "B<LOG_NOTICE>"

#. type: Plain text
#: build/C/man3/syslog.3:265
msgid "normal, but significant, condition"
msgstr "通常だが重要な状態"

#. type: TP
#: build/C/man3/syslog.3:265
#, no-wrap
msgid "B<LOG_INFO>"
msgstr "B<LOG_INFO>"

#. type: Plain text
#: build/C/man3/syslog.3:268
msgid "informational message"
msgstr "インフォメーションメッセージ"

#. type: TP
#: build/C/man3/syslog.3:268
#, no-wrap
msgid "B<LOG_DEBUG>"
msgstr "B<LOG_DEBUG>"

#. type: Plain text
#: build/C/man3/syslog.3:271
msgid "debug-level message"
msgstr "デバッグレベルのメッセージ"

#. type: Plain text
#: build/C/man3/syslog.3:275
msgid ""
"The function B<setlogmask>(3)  can be used to restrict logging to specified "
"levels only."
msgstr ""
"B<setlogmask>(3)  関数を使用して、 指定されたレベルのメッセージだけを記録する"
"ように 制限することができる。"

#. type: tbl table
#: build/C/man3/syslog.3:286
#, no-wrap
msgid ""
"B<openlog>(),\n"
"B<closelog>()"
msgstr ""
"B<openlog>(),\n"
"B<closelog>()"

#. type: tbl table
#: build/C/man3/syslog.3:290
#, no-wrap
msgid ""
"B<syslog>(),\n"
"B<vsyslog>()"
msgstr ""
"B<syslog>(),\n"
"B<vsyslog>()"

#. type: tbl table
#: build/C/man3/syslog.3:290
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: Plain text
#: build/C/man3/syslog.3:301
msgid ""
"The functions B<openlog>(), B<closelog>(), and B<syslog>()  (but not "
"B<vsyslog>())  are specified in SUSv2, POSIX.1-2001, and POSIX.1-2008."
msgstr "B<openlog>(), B<closelog>(), B<syslog>() は SUSv2, POSIX.1-2001, POSIX.1-2008 で規定されている (但し B<vsyslog>() は除く)。"

#. type: Plain text
#: build/C/man3/syslog.3:315
msgid ""
"POSIX.1-2001 specifies only the B<LOG_USER> and B<LOG_LOCAL*> values for "
"I<facility>.  However, with the exception of B<LOG_AUTHPRIV> and B<LOG_FTP>, "
"the other I<facility> values appear on most UNIX systems."
msgstr "POSIX.1-2001 では I<facility> として B<LOG_USER> と B<LOG_LOCAL*> の値が規定されているだけである。 しかしながら、 B<LOG_AUTHPRIV> と B<LOG_FTP> という例外はあるが、 それ以外の I<facility> の値は多くの UNIX システムで使われている。"

#.  .SH HISTORY
#.  A
#.  .BR syslog ()
#.  function call appeared in 4.2BSD.
#.  4.3BSD documents
#.  .BR openlog (),
#.  .BR syslog (),
#.  .BR closelog (),
#.  and
#.  .BR setlogmask ().
#.  4.3BSD-Reno also documents
#.  .BR vsyslog ().
#.  Of course early v* functions used the
#.  .I <varargs.h>
#.  mechanism, which is not compatible with
#.  .IR <stdarg.h> .
#. type: Plain text
#: build/C/man3/syslog.3:338
msgid ""
"The B<LOG_PERROR> value for I<option> is not specified by POSIX.1-2001 or "
"POSIX.1-2008, but is available in most versions of UNIX."
msgstr "I<option> の値の B<LOG_PERROR> の値は、 POSIX.1-2001 と POSIX.1-2008 では規定されていないが、 UNIX の多くのバージョンで使用可能である。"

#. type: Plain text
#: build/C/man3/syslog.3:350
msgid ""
"The argument I<ident> in the call of B<openlog>()  is probably stored as-"
"is.  Thus, if the string it points to is changed, B<syslog>()  may start "
"prepending the changed string, and if the string it points to ceases to "
"exist, the results are undefined.  Most portable is to use a string constant."
msgstr ""
"B<openlog>()  呼び出しの I<ident> 引数は、値がそのまま保持されていることを"
"前提にしている。 それゆえ、 I<ident> で指定された文字列が変更されると、 "
"B<syslog>()  は変更された文字列の追加するだろうし、 指定された文字列が存在し"
"なくなった場合、結果は未定義である。 最も移植性がある方法は、文字列定数を使用"
"することである。"

#. type: Plain text
#: build/C/man3/syslog.3:353
msgid ""
"Never pass a string with user-supplied data as a format, use the following "
"instead:"
msgstr ""
"ユーザーから与えられたデータを format として渡してはならない。 代わりに以下を"
"使うこと。"

#. type: Plain text
#: build/C/man3/syslog.3:357
#, no-wrap
msgid "syslog(priority, \"%s\", string);\n"
msgstr " syslog(priority, \"%s\", string);\n"

#. type: Plain text
#: build/C/man3/syslog.3:365
msgid ""
"B<journalctl>(1), B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), "
"B<syslogd>(8)"
msgstr " B<journalctl>(1), B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), B<syslogd>(8)"

#. type: TH
#: build/C/man4/ttyS.4:26
#, no-wrap
msgid "TTYS"
msgstr "TTYS"

#. type: TH
#: build/C/man4/ttyS.4:26
#, no-wrap
msgid "1992-12-19"
msgstr "1992-12-19"

#. type: Plain text
#: build/C/man4/ttyS.4:29
msgid "ttyS - serial terminal lines"
msgstr "ttyS - シリアルターミナルライン(serial terminal lines)"

#. type: Plain text
#: build/C/man4/ttyS.4:32
msgid "B<ttyS[0-3]> are character devices for the serial terminal lines."
msgstr ""
"B<ttyS[0-3]> はシリアルターミナルラインのためのキャラクターデバイス "
"(character device)である。"

#. type: Plain text
#: build/C/man4/ttyS.4:42
#, no-wrap
msgid ""
"mknod -m 660 /dev/ttyS0 c 4 64 # base address 0x3f8\n"
"mknod -m 660 /dev/ttyS1 c 4 65 # base address 0x2f8\n"
"mknod -m 660 /dev/ttyS2 c 4 66 # base address 0x3e8\n"
"mknod -m 660 /dev/ttyS3 c 4 67 # base address 0x2e8\n"
"chown root:tty /dev/ttyS[0-3]\n"
msgstr ""

#. type: Plain text
#: build/C/man4/ttyS.4:46
msgid "I</dev/ttyS[0-3]>"
msgstr " I</dev/ttyS[0-3]>"

#. type: Plain text
#: build/C/man4/ttyS.4:53
msgid ""
"B<chown>(1), B<mknod>(1), B<tty>(4), B<agetty>(8), B<mingetty>(8), "
"B<setserial>(8)"
msgstr ""
"B<chown>(1), B<mknod>(1), B<tty>(4), B<agetty>(8), B<mingetty>(8), "
"B<setserial>(8)"

#. type: TH
#: build/C/man7/uri.7:48
#, no-wrap
msgid "URI"
msgstr "URI"

#. type: Plain text
#: build/C/man7/uri.7:51
msgid ""
"uri, url, urn - uniform resource identifier (URI), including a URL or URN"
msgstr ""
"uri, url, urn - uniform resource identifier (URI) (URL と URN も含めて)"

#. type: Plain text
#: build/C/man7/uri.7:55
#, no-wrap
msgid "URI = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n"
msgstr "URI = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n"

#. type: Plain text
#: build/C/man7/uri.7:57
#, no-wrap
msgid "absoluteURI = scheme \":\" ( hierarchical_part | opaque_part )\n"
msgstr "absoluteURI = scheme \":\" ( hierarchical_part | opaque_part )\n"

#. type: Plain text
#: build/C/man7/uri.7:59
#, no-wrap
msgid "relativeURI = ( net_path | absolute_path | relative_path ) [ \"?\" query ]\n"
msgstr "relativeURI = ( net_path | absolute_path | relative_path ) [ \"?\" query ]\n"

#. type: Plain text
#: build/C/man7/uri.7:62
#, no-wrap
msgid ""
"scheme = \"http\" | \"ftp\" | \"gopher\" | \"mailto\" | \"news\" | \"telnet\" |\n"
"         \"file\" | \"man\" | \"info\" | \"whatis\" | \"ldap\" | \"wais\" | \\&...\n"
msgstr ""
"scheme = \"http\" | \"ftp\" | \"gopher\" | \"mailto\" | \"news\" | \"telnet\" |\n"
"         \"file\" | \"man\" | \"info\" | \"whatis\" | \"ldap\" | \"wais\" | \\&...\n"

#. type: Plain text
#: build/C/man7/uri.7:64
#, no-wrap
msgid "hierarchical_part = ( net_path | absolute_path ) [ \"?\" query ]\n"
msgstr "hierarchical_part = ( net_path | absolute_path ) [ \"?\" query ]\n"

#. type: Plain text
#: build/C/man7/uri.7:66
#, no-wrap
msgid "net_path = \"//\" authority [ absolute_path ]\n"
msgstr "net_path = \"//\" authority [ absolute_path ]\n"

#. type: Plain text
#: build/C/man7/uri.7:68
#, no-wrap
msgid "absolute_path = \"/\"  path_segments\n"
msgstr "absolute_path = \"/\"  path_segments\n"

#. type: Plain text
#: build/C/man7/uri.7:70
#, no-wrap
msgid "relative_path = relative_segment [ absolute_path ]\n"
msgstr "relative_path = relative_segment [ absolute_path ]\n"

#. type: Plain text
#: build/C/man7/uri.7:82
msgid ""
"A Uniform Resource Identifier (URI) is a short string of characters "
"identifying an abstract or physical resource (for example, a web page).  A "
"Uniform Resource Locator (URL) is a URI that identifies a resource through "
"its primary access mechanism (e.g., its network \"location\"), rather than "
"by name or some other attribute of that resource.  A Uniform Resource Name "
"(URN) is a URI that must remain globally unique and persistent even when the "
"resource ceases to exist or becomes unavailable."
msgstr ""
"Uniform Resource Identifier (URI)  は抽象的・物理的なリソース (web ページな"
"ど)  を識別するための短い文字列である。 Uniform Resource Locator (URL) は "
"URI の一種で、 リソースの名前などの属性でではなく、 そのリソースに対応するア"
"クセスメカニズムを通してリソースを指定する (つまりネットワーク上の「場所 "
"(location)」を指定する)。 Uniform Resource Name (URN) は URI の一種で、 これ"
"は対象のリソースが廃棄されたり利用できなくなった場合にも、 グローバルに他と重"
"なることなく永続しなければならない。"

#. type: Plain text
#: build/C/man7/uri.7:89
msgid ""
"URIs are the standard way to name hypertext link destinations for tools such "
"as web browsers.  The string \"http://www.kernel.org\" is a URL (and thus it "
"is also a URI).  Many people use the term URL loosely as a synonym for URI "
"(though technically URLs are a subset of URIs)."
msgstr "URI は、 web ブラウザなどのツールで ハイパーテキストリンクのリンク先を指定する時の標準的な方法である。 文字列 \"http://www.kernel.org\" は URL である (従って URI でもある)。多くの人々は、 URL という言葉をほぼ URI の 同義語として使っている (しかし技術的には URL は URI のサブセットである)。"

#. type: Plain text
#: build/C/man7/uri.7:105
msgid ""
"URIs can be absolute or relative.  An absolute identifier refers to a "
"resource independent of context, while a relative identifier refers to a "
"resource by describing the difference from the current context.  Within a "
"relative path reference, the complete path segments \".\" and \"..\" have "
"special meanings: \"the current hierarchy level\" and \"the level above this "
"hierarchy level\", respectively, just like they do in UNIX-like systems.  A "
"path segment which contains a colon character can't be used as the first "
"segment of a relative URI path (e.g., \"this:that\"), because it would be "
"mistaken for a scheme name; precede such segments with ./ (e.g., \"./this:"
"that\").  Note that descendants of MS-DOS (e.g., Microsoft Windows) replace "
"devicename colons with the vertical bar (\"|\") in URIs, so \"C:\" becomes "
"\"C|\"."
msgstr ""
"URI は絶対的にも相対的にも指定できる。 絶対的な指定は、リソースをコンテクスト"
"に依存しないかたちで参照する。 相対的な指定は、リソースを現在のコンテクストか"
"らの差異によって記述する。 相対パス参照では、 \".\" および \"..\" だけのパス"
"部分 (path segment)  は特別な意味を持ち、 それぞれ「現在の階層レベル」および"
"「現在の階層の一つ上のレベル」 として扱われる (UNIX 風のシステムと同様)。 コ"
"ロン文字を含むパス部分は相対 URI パスの先頭に用いることはできない (つまり "
"\"this:that\" はダメ)。スキーム名と区別できないからである。 このような場合に"
"は ./ を前置すること (つまり \"./this:that\" とする)。 MS-DOS の子孫 "
"(Microsoft Windows など) は、 デバイス名のコロンを URI では垂直バー (\"|\") "
"に置き換える。 したがって \"C:\" は \"C|\" となる。"

#. type: Plain text
#: build/C/man7/uri.7:109
msgid ""
"A fragment identifier, if included, refers to a particular named portion "
"(fragment) of a resource; text after a \\(aq#\\(aq identifies the fragment.  "
"A URI beginning with \\(aq#\\(aq refers to that fragment in the current "
"resource."
msgstr ""
"フラグメント指定子 (fragment identifier) は、(もし含まれていれば)  リソース中"
"の名前付けされた特定の部分 (フラグメント) を参照する。 \\(aq#\\(aq 指定子以降"
"の文字列がフラグメントを指定する。 \\(aq#\\(aq で始まる URI は現在のリソース"
"中のフラグメントを参照する。"

#. type: Plain text
#: build/C/man7/uri.7:117
msgid ""
"There are many different URI schemes, each with specific additional rules "
"and meanings, but they are intentionally made to be as similar as possible.  "
"For example, many URL schemes permit the authority to be the following "
"format, called here an I<ip_server> (square brackets show what's optional):"
msgstr ""
"URI のスキームには色々な種類があり、 それぞれ固有のルールや意味が追加されてい"
"る。 しかしできるだけ統一したものにしようという努力もなされている。 例えば、"
"多くの URL スキームは「機関 (authority)」に対して以下の書式 (ここでは "
"I<ip_server> と呼ぶことにする)  を許している (角括弧内部は省略可能)。"

#. type: Plain text
#: build/C/man7/uri.7:119
msgid "I<ip_server = >[I<user> [ : I<password> ] @ ] I<host> [ : I<port>]"
msgstr "I<ip_server = >[I<user> [ : I<password> ] @ ] I<host> [ : I<port>]"

#. type: Plain text
#: build/C/man7/uri.7:135
msgid ""
"This format allows you to optionally insert a username, a user plus "
"password, and/or a port number.  The I<host> is the name of the host "
"computer, either its name as determined by DNS or an IP address (numbers "
"separated by periods).  Thus the URI E<lt>http://fred:fredpassword@example."
"com:8080/E<gt> logs into a web server on host example.com as fred (using "
"fredpassword) using port 8080.  Avoid including a password in a URI if "
"possible because of the many security risks of having a password written "
"down.  If the URL supplies a username but no password, and the remote server "
"requests a password, the program interpreting the URL should request one "
"from the user."
msgstr "このフォーマットには、ユーザー名、ユーザー名+パスワードを指定できる。 ポート番号を追加することも可能である。 I<host> はホストコンピュータの名前で、 DNS で定義される名前か IP アドレス (ピリオドで区切られた数字) で指定する。したがって URI E<lt>http://fred:fredpassword@example.com:8080/E<gt> は、ホスト example.com に fred として (パスワードを使って)  ポート 8080 を使ってログインする。 パスワードは可能なら URI には含めないほうが良いだろう。 パスワードを直書きすると様々なセキュリティ上のリスクが生じるからである。 URL にユーザー名だけを与え、パスワードを与えない場合は、 リモートサーバはパスワードを要求してくる。 URL を解釈したプログラムが、ユーザーにこの入力を促すことになろう。"

#. type: Plain text
#: build/C/man7/uri.7:140
msgid ""
"Here are some of the most common schemes in use on UNIX-like systems that "
"are understood by many tools.  Note that many tools using URIs also have "
"internal schemes or specialized schemes; see those tools' documentation for "
"information on those schemes."
msgstr ""
"以下に、 UNIX 風のシステムで非常に良く用いられており、 多くのツールが理解する"
"スキームを示す。 URI を使うツールの多くでは、内部スキームや特殊なスキームも "
"使えることが多い。そのようなスキームに関してはツールのドキュメントを見るこ"
"と。"

#. type: Plain text
#: build/C/man7/uri.7:142
msgid "B<http - Web (HTTP) server>"
msgstr "B<http - Web (HTTP) サーバ>"

#. type: Plain text
#: build/C/man7/uri.7:144
msgid "http://I<ip_server>/I<path>"
msgstr "http://I<ip_server>/I<path>"

#. type: Plain text
#: build/C/man7/uri.7:146
msgid "http://I<ip_server>/I<path>?I<query>"
msgstr "http://I<ip_server>/I<path>?I<query>"

#. type: Plain text
#: build/C/man7/uri.7:154
msgid ""
"This is a URL accessing a web (HTTP) server.  The default port is 80.  If "
"the path refers to a directory, the web server will choose what to return; "
"usually if there is a file named \"index.html\" or \"index.htm\" its content "
"is returned, otherwise, a list of the files in the current directory (with "
"appropriate links) is generated and returned.  An example is E<lt>http://lwn."
"netE<gt>."
msgstr ""
"これは web (HTTP) サーバにアクセスするための URL である。 デフォルトのポート"
"は 80。パスがディレクトリを参照しているときは、 返される情報は web サーバが選"
"択する。通常は、 \"index.html\" や \"index.htm\" のようなファイルがあれば、そ"
"の内容が返される。 なければ、カレントディレクトリのリストが (適切なリンクとと"
"もに) 生成されて 返される。例としては E<lt>http://lwn.netE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:177
msgid ""
"A query can be given in the archaic \"isindex\" format, consisting of a word "
"or phrase and not including an equal sign (=).  A query can also be in the "
"longer \"GET\" format, which has one or more query entries of the form "
"I<key>=I<value> separated by the ampersand character (&).  Note that I<key> "
"can be repeated more than once, though it's up to the web server and its "
"application programs to determine if there's any meaning to that.  There is "
"an unfortunate interaction with HTML/XML/SGML and the GET query format; when "
"such URIs with more than one key are embedded in SGML/XML documents "
"(including HTML), the ampersand (&) has to be rewritten as &amp;.  Note that "
"not all queries use this format; larger forms may be too long to store as a "
"URI, so they use a different interaction mechanism (called POST) which does "
"not include the data in the URI.  See the Common Gateway Interface "
"specification at E<.UR http://www.w3.org\\:/CGI> E<.UE> for more information."
msgstr ""
"問い合わせ (query) を、古い \"isindex\" フォーマットによって送ることもでき"
"る。 このフォーマットは単語またはフレーズからなり、等号 (=) は含まない。 より"
"長い \"GET\" フォーマットでも問い合わせは行える。 このフォーマットには、一つ"
"以上の問い合わせエントリーが I<key>=I<value> という形式で含まれる。それぞれの"
"エントリーはアンパサンド (&) で区切られる。 I<key> は複数個指定することもでき"
"る。しかしそれに意味があるかどうかは web サーバとアプリケーションプログラムが"
"決める。 HTML/XML/SGML と GET 問い合わせ形式の間には、不幸な関係がある。 一つ"
"以上のキーの含まれる URI が SGML/XML 文書 (HTML もそう)  に埋めこまれる際に"
"は、アンパサンド (&) は &amp; と書かなければならない。 全ての問い合わせがこの"
"形式を使うわけではない。 フォームが長くなると URI に入れるには長すぎるから、 "
"別の通信メカニズム (POST と呼ばれる) が用いられる。 POST では URI にはデータ"
"は含まれない。 より詳しい情報は、 E<.UR http://www.w3.org\\:/CGIE> E<.UE> に"
"ある Common Gateway Interface の仕様書を見よ。"

#. type: Plain text
#: build/C/man7/uri.7:179
msgid "B<ftp - File Transfer Protocol (FTP)>"
msgstr "B<ftp - ファイル転送プロトコル (FTP)>"

#. type: Plain text
#: build/C/man7/uri.7:181
msgid "ftp://I<ip_server>/I<path>"
msgstr "ftp://I<ip_server>/I<path>"

#. type: Plain text
#: build/C/man7/uri.7:189
msgid ""
"This is a URL accessing a file through the file transfer protocol (FTP).  "
"The default port (for control) is 21.  If no username is included, the "
"username \"anonymous\" is supplied, and in that case many clients provide as "
"the password the requestor's Internet email address.  An example is "
"E<lt>ftp://ftp.is.co.za/rfc/rfc1808.txtE<gt>."
msgstr ""
"これはファイル転送プロトコル (FTP) を通してファイルにアクセスするための URL "
"である。デフォルトの (制御用) ポートは 21 である。 ユーザー名がない場合には、"
"ユーザー名 anonymous が与えられる。 そしてその場合には、クライアントの多くは"
"要求した人の インターネットメールアドレスをパスワードとして与える。 例として"
"は E<lt>ftp://ftp.is.co.za/rfc/rfc1808.txtE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:191
msgid "B<gopher - Gopher server>"
msgstr "B<gofer - Gofer サーバ>"

#. type: Plain text
#: build/C/man7/uri.7:193
msgid "gopher://I<ip_server>/I<gophertype selector>"
msgstr "gopher://I<ip_server>/I<gophertype selector>"

#. type: Plain text
#: build/C/man7/uri.7:195
msgid "gopher://I<ip_server>/I<gophertype selector>%09I<search>"
msgstr "gopher://I<ip_server>/I<gophertype selector>%09I<search>"

#. type: Plain text
#: build/C/man7/uri.7:197
msgid ""
"gopher://I<ip_server>/I<gophertype selector>%09I<search>%09I<gopher+_string>"
msgstr ""
"gopher://I<ip_server>/I<gophertype selector>%09I<search>%09I<gopher+_string>"

#. type: Plain text
#: build/C/man7/uri.7:207
msgid ""
"The default gopher port is 70.  I<gophertype> is a single-character field to "
"denote the Gopher type of the resource to which the URL refers.  The entire "
"path may also be empty, in which case the delimiting \"/\" is also optional "
"and the gophertype defaults to \"1\"."
msgstr ""
"デフォルトの gopher ポートは 70 である。 I<gophertype> は 1 文字からなる"
"フィールドで、 URL が参照している Gopher のリソースタイプを示す。 パス全体が"
"空であってもよく、その場合は区切りの \"/\" も省略できる。 このとき "
"gophertype のデフォルトは \"1\" になる。"

#. type: Plain text
#: build/C/man7/uri.7:214
msgid ""
"I<selector> is the Gopher selector string.  In the Gopher protocol, Gopher "
"selector strings are a sequence of octets which may contain any octets "
"except 09 hexadecimal (US-ASCII HT or tab), 0A hexadecimal (US-ASCII "
"character LF), and 0D (US-ASCII character CR)."
msgstr ""
"I<selector> は Gopher セレクタ文字列である。Gopher プロトコルでは、 Gopher セ"
"レクタ文字列はオクテット文字からなり、 16進数の 09 (US-ASCII の HT または "
"tab)、 0A (US-ASCII の LF 文字)、 0D (US-ASCII の CR 文字) 以外ならどんなオク"
"テットも指定できる。"

#. type: Plain text
#: build/C/man7/uri.7:216
msgid "B<mailto - Email address>"
msgstr "B<mailto - 電子メールアドレス>"

#. type: Plain text
#: build/C/man7/uri.7:218
msgid "mailto:I<email-address>"
msgstr "mailto:I<email-address>"

#. type: Plain text
#: build/C/man7/uri.7:226
msgid ""
"This is an email address, usually of the form I<name>@I<hostname>.  See "
"B<mailaddr>(7)  for more information on the correct format of an email "
"address.  Note that any % character must be rewritten as %25.  An example is "
"E<lt>mailto:dwheeler@dwheeler.comE<gt>."
msgstr ""
"これは電子メールアドレスで、通常 I<name>@I<hostname> という形式をとる。電子"
"メールアドレスの正しいフォーマットに関する より詳しい情報は B<mailaddr>(7)  "
"を見よ。 % 文字はすべて %25 と書き直さなければならないことに注意。 例として"
"は E<lt>mailto:dwheeler@dwheeler.comE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:228
msgid "B<news - Newsgroup or News message>"
msgstr "B<news - ニュースグループ、ニュースメッセージ>"

#. type: Plain text
#: build/C/man7/uri.7:230
msgid "news:I<newsgroup-name>"
msgstr "news:I<newsgroup-name>"

#. type: Plain text
#: build/C/man7/uri.7:232
msgid "news:I<message-id>"
msgstr "news:I<message-id>"

#. type: Plain text
#: build/C/man7/uri.7:240
msgid ""
"A I<newsgroup-name> is a period-delimited hierarchical name, such as \"comp."
"infosystems.www.misc\".  If E<lt>newsgroup-nameE<gt> is \"*\" (as in "
"E<lt>news:*E<gt>), it is used to refer to \"all available news groups\".  An "
"example is E<lt>news:comp.lang.adaE<gt>."
msgstr ""
"I<newsgroup-name> はピリオドで区切られた階層的な名前である。例えば \"comp."
"infosystems.www.misc\" など。 E<lt>newsgroup-nameE<gt> が \"*\" (つまり "
"E<lt>news:*E<gt>) の場合には、 「参照できる全てのニュースグループ」の意味にな"
"る。 例としては E<lt>news:comp.lang.adaE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:252
msgid ""
"A I<message-id> corresponds to the Message-ID of E<.UR http://www.ietf.org"
"\\:/rfc\\:/rfc1036.txt> IETF RFC\\ 1036, E<.UE> without the enclosing \"E<lt>"
"\" and \"E<gt>\"; it takes the form I<unique>@I<full_domain_name>.  A "
"message identifier may be distinguished from a news group name by the "
"presence of the \"@\" character."
msgstr ""
"I<message-id> は E<.UR http://www.ietf.org\\:/rfc\\:/rfc1036.txt> IETF RFC\\ "
"1036, E<.UE> の Message-ID から、囲みの \"E<lt>\" と \"E<gt>\" を取ったものに"
"対応する。 Message-ID は I<unique>@I<full_domain_name> という形式をとる。メッ"
"セージ ID には \"@\" 文字が含まれるので、 ニュースグループの名前と区別できる"
"だろう。"

#. type: Plain text
#: build/C/man7/uri.7:254
msgid "B<telnet - Telnet login>"
msgstr "B<telnet - telnet ログイン>"

#. type: Plain text
#: build/C/man7/uri.7:256
msgid "telnet://I<ip_server>/"
msgstr "telnet://I<ip_server>/"

#. type: Plain text
#: build/C/man7/uri.7:262
msgid ""
"The Telnet URL scheme is used to designate interactive text services that "
"may be accessed by the Telnet protocol.  The final \"/\" character may be "
"omitted.  The default port is 23.  An example is E<lt>telnet://melvyl.ucop."
"edu/E<gt>."
msgstr ""
"Telnet URL スキームは対話的なテキストサービスに Telnet プロトコルを 通してア"
"クセスするために用いられる。最後の \"/\" 文字は省略してよい。 例としては "
"E<lt>telnet://melvyl.ucop.edu/E<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:264
msgid "B<file - Normal file>"
msgstr "B<file - 通常のファイル>"

#. type: Plain text
#: build/C/man7/uri.7:266
msgid "file://I<ip_server>/I<path_segments>"
msgstr "file://I<ip_server>/I<path_segments>"

#. type: Plain text
#: build/C/man7/uri.7:268
msgid "file:I<path_segments>"
msgstr "file:I<path_segments>"

#. type: Plain text
#: build/C/man7/uri.7:285
msgid ""
"This represents a file or directory accessible locally.  As a special case, "
"I<ip_server> can be the string \"localhost\" or the empty string; this is "
"interpreted as \"the machine from which the URL is being interpreted\".  If "
"the path is to a directory, the viewer should display the directory's "
"contents with links to each containee; not all viewers currently do this.  "
"KDE supports generated files through the URL E<lt>file:/cgi-binE<gt>.  If "
"the given file isn't found, browser writers may want to try to expand the "
"filename via filename globbing (see B<glob>(7)  and B<glob>(3))."
msgstr ""
"これはローカルに直接アクセスできるファイルを示す。 特殊なケースとして、 "
"I<ip_server> には \"localhost\" という文字列を用いたり、空文字にしてもよい。 "
"これは「URI が解釈されたマシン」とみなされる。 path がディレクトリの場合は、"
"ビューアはディレクトリの内容を リンクを張ったかたちで表示するとよいだろう。 "
"しかし現在は、まだ全てのビューアがこの動作をするわけではない。 KDE は生成ファ"
"イル (generated file) を URL E<lt>file:/cgi-binE<gt> の形式でサポートしてい"
"る。 与えられたファイルが見付からなかった場合は、 ファイル名をグロブによって"
"展開すると良いかもしれない (B<glob>(7)  および B<glob>(3)  を見よ)。"

#. type: Plain text
#: build/C/man7/uri.7:299
msgid ""
"The second format (e.g., E<lt>file:/etc/passwdE<gt>)  is a correct format "
"for referring to a local file.  However, older standards did not permit this "
"format, and some programs don't recognize this as a URI.  A more portable "
"syntax is to use an empty string as the server name, for example, "
"E<lt>file:///etc/passwdE<gt>; this form does the same thing and is easily "
"recognized by pattern matchers and older programs as a URI.  Note that if "
"you really mean to say \"start from the current location,\" don't specify "
"the scheme at all; use a relative address like E<lt>../test.txtE<gt>, which "
"has the side-effect of being scheme-independent.  An example of this scheme "
"is E<lt>file:///etc/passwdE<gt>."
msgstr ""
"二つめの書式 (例えば E<lt>file:/etc/passwdE<gt>) もローカルファイルを参照す"
"る 正しいフォーマットである。しかし古い標準ではこの書式を許していなかったの"
"で、 これを URI として認識しないプログラムも存在する。 より汎用的な文法は、"
"サーバ名に空文字を用いるもの、 つまり E<lt>file:///etc/passwdE<gt> のようなも"
"のである。 この形式も指す内容は同じであり、パターンマッチやより古いプログラム"
"でも URI として認識されやすい。 もし意図するところが「現在の場所からスター"
"ト」なら、 スキームは一切用いるべきではない。 E<lt>../test.txtE<gt> のよう"
"な、スキームに依存しない相対リンクを用いること。 このスキームの例としては "
"E<lt>file:///etc/passwdE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:301
msgid "B<man - Man page documentation>"
msgstr "B<man - man ページ文書>"

#. type: Plain text
#: build/C/man7/uri.7:303
msgid "man:I<command-name>"
msgstr "man:I<command-name>"

#. type: Plain text
#: build/C/man7/uri.7:305
msgid "man:I<command-name>(I<section>)"
msgstr "man:I<command-name>(I<section>)"

#. type: Plain text
#: build/C/man7/uri.7:314
msgid ""
"This refers to local online manual (man) reference pages.  The command name "
"can optionally be followed by a parenthesis and section number; see "
"B<man>(7)  for more information on the meaning of the section numbers.  This "
"URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  An example is E<lt>man:ls(1)E<gt>."
msgstr ""
"これはローカルのオンラインマニュアル (man) リファレスページを参照する。 "
"command-name には括弧とセクション番号を追加してもよい。 セクション番号の意味"
"について詳しく知りたい場合は B<man>(7)  をみよ。この URI スキームは UNIX 風の"
"システム (Linux など)  に特有のものであり、現在はまだ IETF による登録はされて"
"いない。 例としては E<lt>man:ls(1)E<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:316
msgid "B<info - Info page documentation>"
msgstr "B<info - info ページ文書>"

#. type: Plain text
#: build/C/man7/uri.7:318
msgid "info:I<virtual-filename>"
msgstr "info:I<virtual-filename>"

#. type: Plain text
#: build/C/man7/uri.7:320
msgid "info:I<virtual-filename>#I<nodename>"
msgstr "info:I<virtual-filename>#I<nodename>"

#. type: Plain text
#: build/C/man7/uri.7:322
msgid "info:(I<virtual-filename>)"
msgstr "info:(I<virtual-filename>)"

#. type: Plain text
#: build/C/man7/uri.7:324
msgid "info:(I<virtual-filename>)I<nodename>"
msgstr "info:(I<virtual-filename>)I<nodename>"

#. type: Plain text
#: build/C/man7/uri.7:343
msgid ""
"This scheme refers to online info reference pages (generated from texinfo "
"files), a documentation format used by programs such as the GNU tools.  This "
"URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  As of this writing, GNOME and KDE differ "
"in their URI syntax and do not accept the other's syntax.  The first two "
"formats are the GNOME format; in nodenames all spaces are written as "
"underscores.  The second two formats are the KDE format; spaces in nodenames "
"must be written as spaces, even though this is forbidden by the URI "
"standards.  It's hoped that in the future most tools will understand all of "
"these formats and will always accept underscores for spaces in nodenames.  "
"In both GNOME and KDE, if the form without the nodename is used the nodename "
"is assumed to be \"Top\".  Examples of the GNOME format are E<lt>info:"
"gccE<gt> and E<lt>info:gcc#G++_and_GCCE<gt>.  Examples of the KDE format are "
"E<lt>info:(gcc)E<gt> and E<lt>info:(gcc)G++ and GCCE<gt>."
msgstr ""
"このスキームは、オンラインの info リファレンスページ (texinfo ファイルから生"
"成される) を参照する。 info ページは GNU ツールなどのプログラムで用いられてい"
"る文書フォーマットである。 この URI スキームは UNIX 風のシステム (Linux な"
"ど)  に特有のものであり、現在はまだ IETF による登録はされていない。 この文書"
"の執筆時において、 GNOME と KDE はそれぞれ異なる文法の URI を用いており、お互"
"い相手の文法を受け入れない。 最初の 2 つの書式は GNOME の書式である。ノード"
"名 (nodename)  のスペースはすべてアンダースコアに変換される。 3 つめと 4 つめ"
"は KDE の書式である。ノード名のスペースは そのままスペースで書かれる (URI の"
"標準では禁止されているのだが)。 将来は多くのツールがこれらの書式すべてを理解"
"するようになり、 ノード名のアンダースコア、スペースを両方とも理解できるよう"
"に なることを期待したい。 GNOME でも KDE でも、 ノード名が省略された場合は、"
"ノード名として \"Top\" が用いられる。 GNOME 書式の例としては E<lt>info:"
"gccE<gt> や E<lt>info:gcc#G++_and_GCCE<gt> など、 KDE 書式の例としては "
"E<lt>info:(gcc)E<gt> や E<lt>info:(gcc)G++ and GCCE<gt> など。"

#. type: Plain text
#: build/C/man7/uri.7:345
msgid "B<whatis - Documentation search>"
msgstr "B<whatis - 文書検索>"

#. type: Plain text
#: build/C/man7/uri.7:347
msgid "whatis:I<string>"
msgstr "whatis:I<string>"

#. type: Plain text
#: build/C/man7/uri.7:355
msgid ""
"This scheme searches the database of short (one-line) descriptions of "
"commands and returns a list of descriptions containing that string.  Only "
"complete word matches are returned.  See B<whatis>(1).  This URI scheme is "
"unique to UNIX-like systems (such as Linux)  and is not currently registered "
"by the IETF."
msgstr ""
"このスキームは、コマンドに関する短い (1 行の) 説明を集めた データベースを検索"
"し、 string を含む文字列をリストして返す。 単語が完全にマッチした結果だけが返"
"される。 B<whatis>(1)  を見よ。 この URI スキームは UNIX 風のシステム (Linux "
"など)  に特有のものであり、現在はまだ IETF による登録はされていない。"

#. type: Plain text
#: build/C/man7/uri.7:357
msgid "B<ghelp - GNOME help documentation>"
msgstr "B<ghelp - GNOME ヘルプ文書>"

#. type: Plain text
#: build/C/man7/uri.7:359
msgid "ghelp:I<name-of-application>"
msgstr "ghelp:I<name-of-application>"

#. type: Plain text
#: build/C/man7/uri.7:362
msgid ""
"This loads GNOME help for the given application.  Note that not much "
"documentation currently exists in this format."
msgstr ""
"与えられた application に対応する GNOME help をロードする。 この書式を用いた"
"文書はまだあまり多くない。"

#. type: Plain text
#: build/C/man7/uri.7:364
msgid "B<ldap - Lightweight Directory Access Protocol>"
msgstr "B<ldap - 軽量ディレクトリアクセスプロトコル>"

#. type: Plain text
#: build/C/man7/uri.7:366
msgid "ldap://I<hostport>"
msgstr "ldap://I<hostport>"

#. type: Plain text
#: build/C/man7/uri.7:368
msgid "ldap://I<hostport>/"
msgstr "ldap://I<hostport>/"

#. type: Plain text
#: build/C/man7/uri.7:370
msgid "ldap://I<hostport>/I<dn>"
msgstr "ldap://I<hostport>/I<dn>"

#. type: Plain text
#: build/C/man7/uri.7:372
msgid "ldap://I<hostport>/I<dn>?I<attributes>"
msgstr "ldap://I<hostport>/I<dn>?I<attributes>"

#. type: Plain text
#: build/C/man7/uri.7:374
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>"
msgstr "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>"

#. type: Plain text
#: build/C/man7/uri.7:376
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>"
msgstr "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>"

#. type: Plain text
#: build/C/man7/uri.7:378
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>?I<extensions>"
msgstr ""
"ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>?I<extensions>"

#. type: Plain text
#: build/C/man7/uri.7:389
msgid ""
"This scheme supports queries to the Lightweight Directory Access Protocol "
"(LDAP), a protocol for querying a set of servers for hierarchically "
"organized information (such as people and computing resources).  See E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc2255.txt> RFC\\ 2255 E<.UE> for more "
"information on the LDAP URL scheme.  The components of this URL are:"
msgstr ""
"このスキームは Lightweight Directory Access Protocol (LDAP) へのクエリーをサ"
"ポートする。 LDAP は、 複数のサーバに分散した、 階層化された情報 (人々や計算"
"資源など) に問い合わせるための プロトコルである。 LDAP の URL スキームに関す"
"るより詳しい情報は E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> RFC\\ "
"2255 E<.UE> を参照のこと。 この URL の構成要素の詳細は以下の通り。"

#. type: IP
#: build/C/man7/uri.7:389
#, no-wrap
msgid "hostport"
msgstr "hostport"

#. type: Plain text
#: build/C/man7/uri.7:394
msgid ""
"the LDAP server to query, written as a hostname optionally followed by a "
"colon and the port number.  The default LDAP port is TCP port 389.  If "
"empty, the client determines which the LDAP server to use."
msgstr ""
"クエリーを行う LDAP サーバ。ホスト名を書く。続けてコロンとポート番号を 追加す"
"ることもできる。 LDAP のデフォルトのポートは TCP ポート 389 である。 省略され"
"ると、どの LDAP サーバを用いるかはクライアントが決定する。"

#. type: IP
#: build/C/man7/uri.7:394
#, no-wrap
msgid "dn"
msgstr "dn"

#. type: Plain text
#: build/C/man7/uri.7:401
msgid ""
"the LDAP Distinguished Name, which identifies the base object of the LDAP "
"search (see E<.UR http://www.ietf.org\\:/rfc\\:/rfc2253.txt> RFC\\ 2253 E<."
"UE> section 3)."
msgstr ""
"LDAP の Distintuished Name (識別名)。 LDAP 検索の base オブジェクトを指定する"
"ものである (E<.UR http://www.ietf.org\\:/rfc\\:/rfc2253.txt> RFC\\ 2253 E<."
"UE> のセクション 3 を参照)。"

#. type: IP
#: build/C/man7/uri.7:401
#, no-wrap
msgid "attributes"
msgstr "attributes"

#. type: Plain text
#: build/C/man7/uri.7:405
msgid ""
"a comma-separated list of attributes to be returned; see RFC\\ 2251 section "
"4.1.5.  If omitted, all attributes should be returned."
msgstr ""
"コンマ区切りの、返される属性 (attribute) のリスト。 RFC\\ 2251 の section "
"4.1.5 を見よ。省略されると全ての属性が返される。"

#. type: IP
#: build/C/man7/uri.7:405
#, no-wrap
msgid "scope"
msgstr "scope"

#. type: Plain text
#: build/C/man7/uri.7:410
msgid ""
"specifies the scope of the search, which can be one of \"base\" (for a base "
"object search), \"one\" (for a one-level search), or \"sub\" (for a subtree "
"search).  If scope is omitted, \"base\" is assumed."
msgstr ""
"検索のスコープを指定する。 \"base\" (base オブジェクト検索), \"one\" (1 レベ"
"ル検索), \"sub\" (サブツリー検索) のいずれかを指定する。 省略すると \"base\" "
"が仮定される。"

#. type: IP
#: build/C/man7/uri.7:410
#, no-wrap
msgid "filter"
msgstr "filter"

#. type: Plain text
#: build/C/man7/uri.7:419
msgid ""
"specifies the search filter (subset of entries to return).  If omitted, all "
"entries should be returned.  See E<.UR http://www.ietf.org\\:/rfc\\:/rfc2254."
"txt> RFC\\ 2254 E<.UE> section 4."
msgstr ""
"検索フィルタ (返されるエントリーのサブセット) を指定する。 省略されると、全て"
"のエントリーが返される。 E<.UR http://www.ietf.org\\:/rfc\\:/rfc2254.txt> RFC"
"\\ 2254 E<.UE> のセクション 4 を参照。"

#. type: IP
#: build/C/man7/uri.7:419
#, no-wrap
msgid "extensions"
msgstr "extensions"

#. type: Plain text
#: build/C/man7/uri.7:425
msgid ""
"a comma-separated list of type=value pairs, where the =value portion may be "
"omitted for options not requiring it.  An extension prefixed with a \\(aq!"
"\\(aq is critical (must be supported to be valid), otherwise it is "
"noncritical (optional)."
msgstr ""
"コンマで区切られた type=value ペアのリスト。 ここで =value の部分は、それを要"
"求しないオプションに対しては 省略できる。 \\(aq!\\(aq が前置された extension "
"は critical (サポートしていなければならない) であり、 そうでなければ "
"critical ではない (省略できる)。"

#. type: Plain text
#: build/C/man7/uri.7:429
msgid ""
"LDAP queries are easiest to explain by example.  Here's a query that asks "
"ldap.itd.umich.edu for information about the University of Michigan in the U."
"S.:"
msgstr ""
"LDAP のクエリーは、例とともに説明するのが最も簡単である。 次の例は、 ldap."
"itd.umich.edu に、 U.S. にある University of Michigan の情報を尋ねる例であ"
"る。"

#. type: Plain text
#: build/C/man7/uri.7:432
#, no-wrap
msgid "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US\n"
msgstr "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US\n"

#. type: Plain text
#: build/C/man7/uri.7:435
msgid "To just get its postal address attribute, request:"
msgstr "郵便用の住所属性だけを取得する場合は、 次のようにリクエストする:"

#. type: Plain text
#: build/C/man7/uri.7:438
#, no-wrap
msgid "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress\n"
msgstr "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress\n"

#. type: Plain text
#: build/C/man7/uri.7:442
msgid ""
"To ask a host.com at port 6666 for information about the person with common "
"name (cn) \"Babs Jensen\" at University of Michigan, request:"
msgstr ""
"host.com のポート 6666 に、 University of Michigan にいる common name (cn) "
"が \"Babs Jenson\" の人の情報を尋ねる場合は、 次のようにリクエストする:"

#. type: Plain text
#: build/C/man7/uri.7:445
#, no-wrap
msgid "ldap://host.com:6666/o=University%20of%20Michigan,c=US??sub?(cn=Babs%20Jensen)\n"
msgstr "ldap://host.com:6666/o=University%20of%20Michigan,c=US??sub?(cn=Babs%20Jensen)\n"

#. type: Plain text
#: build/C/man7/uri.7:448
msgid "B<wais - Wide Area Information Servers>"
msgstr "B<wais - 広域情報サービス>"

#. type: Plain text
#: build/C/man7/uri.7:450
msgid "wais://I<hostport>/I<database>"
msgstr "wais://I<hostport>/I<database>"

#. type: Plain text
#: build/C/man7/uri.7:452
msgid "wais://I<hostport>/I<database>?I<search>"
msgstr "wais://I<hostport>/I<database>?I<search>"

#. type: Plain text
#: build/C/man7/uri.7:454
msgid "wais://I<hostport>/I<database>/I<wtype>/I<wpath>"
msgstr "wais://I<hostport>/I<database>/I<wtype>/I<wpath>"

#. type: Plain text
#: build/C/man7/uri.7:463
msgid ""
"This scheme designates a WAIS database, search, or document (see E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc1625.txt> IETF RFC\\ 1625 E<.UE> for more "
"information on WAIS).  Hostport is the hostname, optionally followed by a "
"colon and port number (the default port number is 210)."
msgstr ""
"このスキームは WAIS のデータベース、検索、文書を指定する (WAIS に関する詳しい"
"情報は E<.UR http://www.ietf.org\\:/rfc\\:/rfc1625.txt> IETF RFC\\ 1625 E<."
"UE> を参照)。 hostport は、ホスト名にコロンとポート番号を付加したものである "
"(コロン + ポート番号は省略可。デフォルトのポート番号は 210 である)。"

#. type: Plain text
#: build/C/man7/uri.7:473
msgid ""
"The first form designates a WAIS database for searching.  The second form "
"designates a particular search of the WAIS database I<database>.  The third "
"form designates a particular document within a WAIS database to be "
"retrieved.  I<wtype> is the WAIS designation of the type of the object and "
"I<wpath> is the WAIS document-id."
msgstr ""
"最初の書式は WAIS のデータベースに対する検索の指定である。 二つめの書式は特定"
"の WAIS データベース I<database> に対する検索の指定である。 三つめの書式は "
"WAIS データベースにある特定の文書を取出す指定である。 I<wtype> は WAIS のオブ"
"ジェクト形式指定であり、 I<wpath> は WAIS document-id である。"

#. type: Plain text
#: build/C/man7/uri.7:475
msgid "B<other schemes>"
msgstr "B<その他のスキーム>"

#. type: Plain text
#: build/C/man7/uri.7:489
msgid ""
"There are many other URI schemes.  Most tools that accept URIs support a set "
"of internal URIs (e.g., Mozilla has the about: scheme for internal "
"information, and the GNOME help browser has the toc: scheme for various "
"starting locations).  There are many schemes that have been defined but are "
"not as widely used at the current time (e.g., prospero).  The nntp: scheme "
"is deprecated in favor of the news: scheme.  URNs are to be supported by the "
"urn: scheme, with a hierarchical name space (e.g., urn:ietf:... would "
"identify IETF documents); at this time URNs are not widely implemented.  Not "
"all tools support all schemes."
msgstr ""
"他にも多くの URI スキームが存在する。 URI を受付けるほとんどのツールは、内部 "
"URI のセットをサポートする (例えば Mozilla は内部情報用の about: というスキー"
"ムを受付けるし、 GNOME ヘルプブラウザはいろいろな出発点用に toc: というスキー"
"ムを持っている)。 定義されたスキームはたくさんあるが、現時点で広く用いられて"
"はいない (例えば prospero とか)。 nntp: スキームは news: スキームが好んで用い"
"られるようになったので 使わないほうが良い。 URN は urn: スキームによって、階"
"層的な名前空間 (例えば urn:ietf:... は IETF 文書を示す)  としてサポートされる"
"べきであるが、現時点では URN はあまり用いられていない。 全てのツールが全ての"
"スキームをサポートしているわけではない。"

#. type: SS
#: build/C/man7/uri.7:489
#, no-wrap
msgid "Character encoding"
msgstr "文字エンコード"

#. type: Plain text
#: build/C/man7/uri.7:493
msgid ""
"URIs use a limited number of characters so that they can be typed in and "
"used in a variety of situations."
msgstr "URI では、色々な状況下で入力できるように、文字の種類を制限している。"

#. type: Plain text
#: build/C/man7/uri.7:497
msgid ""
"The following characters are reserved, that is, they may appear in a URI but "
"their use is limited to their reserved purpose (conflicting data must be "
"escaped before forming the URI):"
msgstr ""
"以下の文字は予約されている。すなわち、これらの文字は URI に登場することがある"
"が、それらの利用法 (解釈のされ方) は 予約された目的に制限されている (衝突する"
"データは URI にする前にエスケープしなければならない)。"

#. type: Plain text
#: build/C/man7/uri.7:499
#, no-wrap
msgid "   ; / ? : @ & = + $ ,\n"
msgstr "   ; / ? : @ & = + $ ,\n"

#. type: Plain text
#: build/C/man7/uri.7:505
msgid ""
"Unreserved characters may be included in a URI.  Unreserved characters "
"include uppercase and lowercase English letters, decimal digits, and the "
"following limited set of punctuation marks and symbols:"
msgstr ""
"未予約文字 (unreserved character) は URI に使ってよい。 これには英字の大文字"
"と小文字、10 進の数字、および 以下の句読文字、記号が含まれる"

#. type: Plain text
#: build/C/man7/uri.7:507
#, no-wrap
msgid " - _ . ! \\(ti * ' ( )\n"
msgstr "  - _ . ! \\(ti * ' ( )\n"

#. type: Plain text
#: build/C/man7/uri.7:522
msgid ""
"All other characters must be escaped.  An escaped octet is encoded as a "
"character triplet, consisting of the percent character \"%\" followed by the "
"two hexadecimal digits representing the octet code (you can use uppercase or "
"lowercase letters for the hexadecimal digits).  For example, a blank space "
"must be escaped as \"%20\", a tab character as \"%09\", and the \"&\" as "
"\"%26\".  Because the percent \"%\" character always has the reserved "
"purpose of being the escape indicator, it must be escaped as \"%25\".  It is "
"common practice to escape space characters as the plus symbol (+)  in query "
"text; this practice isn't uniformly defined in the relevant RFCs (which "
"recommend %20 instead) but any tool accepting URIs with query text should be "
"prepared for them.  A URI is always shown in its \"escaped\" form."
msgstr ""
"他の文字はすべてエスケープしなければならない。 エスケープされたオクテットは "
"3 文字からなる: 先頭にパーセント文字 \"%\"、それに続けてオクテットコードを表"
"す 2 文字の 16 進数字である (16 進数の英字は大文字小文字どちらでも良い)。 例"
"えば空白文字は \"%20\" のようにエスケープしなければならず、 タブ文字は "
"\"%09\"、 \"&\" は \"%26\" となる。 パーセント文字 \"%\" は常にエスケープを示"
"す予約された目的に用いられるので、 \"%\" 自身を表すには \"%25\" とエスケープ"
"しなければならない。 クエリーのテキストでは、スペース文字をプラス記号 (+) で"
"エスケープすることも 一般に良く行われる。この慣例は関連 RFC で実際に定義され"
"ているわけではない (代わりに %20 を推奨している) が、クエリーテキストを受付け"
"る ツールは、この書式への対応を用意しておくべきであろう。 URI は、常に「エス"
"ケープされた」かたちで表示される。"

#. type: Plain text
#: build/C/man7/uri.7:528
msgid ""
"Unreserved characters can be escaped without changing the semantics of the "
"URI, but this should not be done unless the URI is being used in a context "
"that does not allow the unescaped character to appear.  For example, \"%7e\" "
"is sometimes used instead of \"\\(ti\" in an HTTP URL path, but the two are "
"equivalent for an HTTP URL."
msgstr "未予約文字もエスケープすることができ、これによって URI の意味するところが変わるわけではない。 しかしURI にその非エスケープ文字が現れることが許されないような 特殊な場合を除いて、これは避けるべきである。 例えば、 HTTP URL の path において \"%7e\" が \"\\(ti\" の代わりに用いられることがあるが、 この二つは HTTP URL としては等価である。"

#. type: Plain text
#: build/C/man7/uri.7:532
msgid ""
"For URIs which must handle characters outside the US ASCII character set, "
"the HTML 4.01 specification (section B.2) and IETF RFC\\ 2718 (section "
"2.2.5) recommend the following approach:"
msgstr ""
"US ASCII キャラクターセット以外の文字を URI として扱う場合、 HTML 4.1 規格 "
"(section B.2) 及び IETF RFC\\ 2718 (section 2.2.5) は 以下の手法を用いるよう"
"推奨している。"

#. type: Plain text
#: build/C/man7/uri.7:536
msgid ""
"translate the character sequences into UTF-8 (IETF RFC\\ 2279)\\(emsee "
"B<utf-8>(7)\\(emand then"
msgstr "キャラクター列を UTF-8 (IETF RFC\\ 2279, B<utf-8>(7)  参照) に変換し、"

#. type: Plain text
#: build/C/man7/uri.7:539
msgid ""
"use the URI escaping mechanism, that is, use the %HH encoding for unsafe "
"octets."
msgstr ""
"URI エスケープ機構を用いる。 つまり、安全でないオクテットを %HH でエンコード"
"する。"

#. type: SS
#: build/C/man7/uri.7:539
#, no-wrap
msgid "Writing a URI"
msgstr "URI を書くには"

#. type: Plain text
#: build/C/man7/uri.7:562
msgid ""
"When written, URIs should be placed inside double quotes (e.g., \"http://www."
"kernel.org\"), enclosed in angle brackets (e.g., E<lt>http://lwn.netE<gt>), "
"or placed on a line by themselves.  A warning for those who use double-"
"quotes: B<never> move extraneous punctuation (such as the period ending a "
"sentence or the comma in a list)  inside a URI, since this will change the "
"value of the URI.  Instead, use angle brackets instead, or switch to a "
"quoting system that never includes extraneous characters inside quotation "
"marks.  This latter system, called the 'new' or 'logical' quoting system by "
"\"Hart's Rules\" and the \"Oxford Dictionary for Writers and Editors\", is "
"preferred practice in Great Britain and hackers worldwide (see the Jargon "
"File's section on Hacker Writing Style, E<.UR http://www.fwi.uva.nl\\:/"
"\\(times\\:/jargon\\:/h\\:/HackerWritingStyle.html> E<.UE ,> for more "
"information).  Older documents suggested inserting the prefix \"URL:\" just "
"before the URI, but this form has never caught on."
msgstr "URI を書く時には、ダブルクォートの内部に書く (例: \"http://www.kernel.org\") か、 angle ブラケットで囲む (例: E<lt>http://lwn.netE<gt>) か、 一行に URI だけを書くかする。 ダブルクォートを使う人に警告: B<絶対に>句読点 (文末のピリオドやリスト区切りのコンマ) を URI の内部に移動してはならない。 代わりに angle ブラケットを使うか、 外にある文字をクォーテーションマークの内部に 決して含めないような引用方式に切替えること。 後者の方式は \"Hart's Rules\" や \"Oxford Dictionary for Writers and Editors\" によれば 「新しい (new) 引用方式」あるいは「論理的 (logical) な引用方式」 と呼ばれており、 イギリス人や世界中のハッカー達はこちらの慣習を好んでいる (より詳しい情報は Hacker Writing Style の Jargon File のセクション E<.UR http://www.fwi.uva.nl\\:/\\(times\\:/jargon\\:/h\\:/HackerWritingStyle.html> E<.UE> を見よ)。 古い文書では、 \"URL:\" という文字列を URI の直前に挿入することを 勧めているものもあるが、しかしこの形式はまったく流行しなかった。"

#. type: Plain text
#: build/C/man7/uri.7:584
msgid ""
"The URI syntax was designed to be unambiguous.  However, as URIs have become "
"commonplace, traditional media (television, radio, newspapers, billboards, "
"etc.) have increasingly used abbreviated URI references consisting of only "
"the authority and path portions of the identified resource (e.g., E<lt>www."
"w3.org/AddressingE<gt>).  Such references are primarily intended for human "
"interpretation rather than machine, with the assumption that context-based "
"heuristics are sufficient to complete the URI (e.g., hostnames beginning "
"with \"www\" are likely to have a URI prefix of \"http://\" and hostnames "
"beginning with \"ftp\" likely to have a prefix of \"ftp://\").  Many client "
"implementations heuristically resolve these references.  Such heuristics may "
"change over time, particularly when new schemes are introduced.  Since an "
"abbreviated URI has the same syntax as a relative URL path, abbreviated URI "
"references cannot be used where relative URIs are permitted, and can be used "
"only when there is no defined base (such as in dialog boxes).  Don't use "
"abbreviated URIs as hypertext links inside a document; use the standard "
"format as described here."
msgstr ""
"URI の書式は曖昧さを排除するように設計されている。 しかし URI が広まるにつ"
"れ、昔ながらのメディア (TV、ラジオ、新聞、 看板などなど) は URI 参照を省略し"
"たかたち、すなわち 機関部とパス部だけでリソースを指定することが多くなってい"
"る (例: E<lt>www.w3.org/AddressingE<gt>)。 このような参照はマシンというよりは"
"人間向けのもので、 コンテキストベースの推測によって URI の補完が可能であるこ"
"とを あてにしているのである (例えば \"www\" ではじまるホスト名なら \"http://"
"\" がつくだろうし、 \"ftp\" ではじまるホスト名なら \"ftp://\" がつくだろ"
"う)。 多くのクライアントの実装では、この種の参照を推測によって解決する。 この"
"ような推測は時代とともに変わりうる。 特に新しいスキームが導入されるとそうであ"
"る。 URI の省略形では相対 URL パスの区別が付けられないので、 省略形 URI 参照"
"は相対 URI の利用できるところでは使えない。 つまり定義済みのベース (ダイアロ"
"グボックスなど)  がない場合に限って利用できる。 文書内部でのハイパーテキスト"
"リンクには省略形 URI を使ってはならない。 上述の標準フォーマットを使うこと。"

#. type: Plain text
#: build/C/man7/uri.7:592
msgid ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2396.txt> (IETF RFC\\ 2396)  E<.UE ,> "
"E<.UR http://www.w3.org\\:/TR\\:/REC-html40> (HTML 4.0)  E<.UE .>"
msgstr ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2396.txt> (IETF RFC\\ 2396)  E<.UE ,> "
"E<.UR http://www.w3.org\\:/TR\\:/REC-html40> (HTML 4.0)  E<.UE .>"

#. type: Plain text
#: build/C/man7/uri.7:598
msgid ""
"Any tool accepting URIs (e.g., a web browser) on a Linux system should be "
"able to handle (directly or indirectly) all of the schemes described here, "
"including the man: and info: schemes.  Handling them by invoking some other "
"program is fine and in fact encouraged."
msgstr ""
"Linux システムで URI を受付けるツール (例えば web ブラウザなど) は、 上にあげ"
"た全てのスキームを (直接または間接に) 扱えるべきである。 man: や info: も含め"
"て、である。 スキームの処理に他のプログラムを実行するのは良いことだし、 実は"
"すすんでそうすべきである。"

#. type: Plain text
#: build/C/man7/uri.7:600
msgid "Technically the fragment isn't part of the URI."
msgstr "技術的には、フラグメントは URI の一部ではない。"

#. type: Plain text
#: build/C/man7/uri.7:609
msgid ""
"For information on how to embed URIs (including URLs) in a data format, see "
"documentation on that format.  HTML uses the format E<lt>A HREF=\"I<uri>"
"\"E<gt> I<text> E<lt>/AE<gt>.  Texinfo files use the format @uref{I<uri>}.  "
"Man and mdoc have the recently added UR macro, or just include the URI in "
"the text (viewers should be able to detect :// as part of a URI)."
msgstr ""
"URI (URL も含む) をデータフォーマットに埋めこむ方法に関する情報は、 その"
"フォーマットのドキュメントを見よ。 HTML は E<lt>A HREF=\"I<uri>"
"\"E<gt>I<text>E<lt>/AE<gt> を用いる。 texinfo は @uref{I<uri>} という書式を用"
"いる。 man と mdoc は、最近追加された UR マクロを使う。 あるいは URI をそのま"
"まテキストに埋めこむ (ビューアが :// を URI の一部と解釈できなければならな"
"い)。"

#. type: Plain text
#: build/C/man7/uri.7:630
msgid ""
"The GNOME and KDE desktop environments currently vary in the URIs they "
"accept, in particular in their respective help browsers.  To list man pages, "
"GNOME uses E<lt>toc:manE<gt> while KDE uses E<lt>man:(index)E<gt>, and to "
"list info pages, GNOME uses E<lt>toc:infoE<gt> while KDE uses E<lt>info:"
"(dir)E<gt> (the author of this man page prefers the KDE approach here, "
"though a more regular format would be even better).  In general, KDE uses "
"E<lt>file:/cgi-bin/E<gt> as a prefix to a set of generated files.  KDE "
"prefers documentation in HTML, accessed via the E<lt>file:/cgi-bin/"
"helpindexE<gt>.  GNOME prefers the ghelp scheme to store and find "
"documentation.  Neither browser handles file: references to directories at "
"the time of this writing, making it difficult to refer to an entire "
"directory with a browsable URI.  As noted above, these environments differ "
"in how they handle the info: scheme, probably the most important variation.  "
"It is expected that GNOME and KDE will converge to common URI formats, and a "
"future version of this man page will describe the converged result.  Efforts "
"to aid this convergence are encouraged."
msgstr ""
"デスクトップ環境である GNOME と KDE は、 それぞれ受付ける URI が (特にそれぞ"
"れのヘルプブラウザにおいて)  異なっている。 man ページをリストするには、 "
"GNOME では E<lt>toc:manE<gt> を用い、 KDE では E<lt>man:(index)E<gt> を用い"
"る。 また info ページをリストするには、 GNOME では E<lt>toc:infoE<gt> を用"
"い、 KDE では E<lt>info:(dir)E<gt> を用いる (本 man ページの著者は KDE のアプ"
"ローチのほうが好みである。 しかしより標準的な書式の方が更に良いが)。 一般に "
"KDE は生成ファイル (generated file) のプレフィックスとして E<lt>file:/cgi-"
"bin/E<gt> を用いる。 KDE は HTML の文書を E<lt>file:/cgi-bin/helpindexE<gt> "
"経由でアクセスするのが好みなようである。 GNOME は文書の保管・検索に ghelp ス"
"キームを用いる方法を取っているようだ。 どちらのブラウザも、現時点では file: "
"によるディレクトリ参照を扱えない。 したがってディレクトリ全体をブラウズ可能"
"な URI で参照することが難しい。 先に述べたように、これら二つの環境では info: "
"スキームの 扱いが異なっている (おそらく最も重要な差異であろう)。 GNOME と "
"KDE が共通 URI フォーマットに収斂することが望ましい。 この man ページが、将来"
"はその収斂した結果を記述できることを望む。 この作業への助力を喚起したい。"

#. type: SS
#: build/C/man7/uri.7:630
#, no-wrap
msgid "Security"
msgstr "セキュリティ"

#. type: Plain text
#: build/C/man7/uri.7:640
msgid ""
"A URI does not in itself pose a security threat.  There is no general "
"guarantee that a URL, which at one time located a given resource, will "
"continue to do so.  Nor is there any guarantee that a URL will not locate a "
"different resource at some later point in time; such a guarantee can be "
"obtained only from the person(s) controlling that namespace and the resource "
"in question."
msgstr ""
"URI そのものはセキュリティの脅威を引き起こすものではない。 ある時点ではリソー"
"スの場所を与えていた URL が、 ずっとそうでありつづけるという保証は一般にはな"
"い。 またある URL が、将来には別のリソースを示さないとも限らない。 このような"
"保証は、その名前空間とリソースとを管理している個人に 帰するものに過ぎない。"

#. type: Plain text
#: build/C/man7/uri.7:655
msgid ""
"It is sometimes possible to construct a URL such that an attempt to perform "
"a seemingly harmless operation, such as the retrieval of an entity "
"associated with the resource, will in fact cause a possibly damaging remote "
"operation to occur.  The unsafe URL is typically constructed by specifying a "
"port number other than that reserved for the network protocol in question.  "
"The client unwittingly contacts a site that is in fact running a different "
"protocol.  The content of the URL contains instructions that, when "
"interpreted according to this other protocol, cause an unexpected "
"operation.  An example has been the use of a gopher URL to cause an "
"unintended or impersonating message to be sent via a SMTP server."
msgstr ""
"無害に見える操作 (リソースに関連づけられたエンティティの取得など)  によって、"
"実際にはリモートにダメージを与える動作を引き起こすような URL を記述することも"
"場合によっては可能である。 危険な URL の典型的なものは、そのネットワークプロ"
"トコルに 予約されているポート番号とは異なるポートを指定しているものである。 "
"URL の内容には命令が含まれていて、 そのプロトコルにしたがって解釈されたと"
"き、 予期されない動作を引起こすのである。 例をあげると、 gopher の URL によっ"
"て、意図しないメッセージや なりすましメッセージなどが SMTP サーバ経由で送信さ"
"れるようなことがあった。"

#. type: Plain text
#: build/C/man7/uri.7:659
msgid ""
"Caution should be used when using any URL that specifies a port number other "
"than the default for the protocol, especially when it is a number within the "
"reserved space."
msgstr ""
"そのプロトコルのデフォルト以外のポート番号を指定している URL を用いるときには"
"注意すべきである。 特にその番号が予約空間の内部にある場合には。"

#. type: Plain text
#: build/C/man7/uri.7:667
msgid ""
"Care should be taken when a URI contains escaped delimiters for a given "
"protocol (for example, CR and LF characters for telnet protocols) that these "
"are not unescaped before transmission.  This might violate the protocol, but "
"avoids the potential for such characters to be used to simulate an extra "
"operation or parameter in that protocol, which might lead to an unexpected "
"and possibly harmful remote operation to be performed."
msgstr ""
"URI に、そのプロトコルに対するデリミタがエスケープされたかたちで入っている 場"
"合も注意が必要である (例えば telnet プロトコルに対する CR 文字や LF 文字な"
"ど)。 なぜならこれらは転送前にエスケープが外されないからである。 これはプロト"
"コルに反しており、予期しない、おそらくは害になるような リモート動作を引起こす"
"結果となりかねない。"

#. type: Plain text
#: build/C/man7/uri.7:673
msgid ""
"It is clearly unwise to use a URI that contains a password which is intended "
"to be secret.  In particular, the use of a password within the \"userinfo\" "
"component of a URI is strongly recommended against except in those rare "
"cases where the \"password\" parameter is intended to be public."
msgstr ""
"秘密にしておくべきパスワードを含んだ URI を使うのが 賢くないのは明らかであ"
"る。特に、パスワードを URI の \"userinfo\" の部分に使うのは絶対に避けるべきで"
"ある。 ただしその \"password\" のパラメーターを意図的に公開したい場合は別であ"
"るが。"

#. type: Plain text
#: build/C/man7/uri.7:695
msgid ""
"Documentation may be placed in a variety of locations, so there currently "
"isn't a good URI scheme for general online documentation in arbitrary "
"formats.  References of the form E<lt>file:///usr/doc/ZZZE<gt> don't work "
"because different distributions and local installation requirements may "
"place the files in different directories (it may be in /usr/doc, or /usr/"
"local/doc, or /usr/share, or somewhere else).  Also, the directory ZZZ "
"usually changes when a version changes (though filename globbing could "
"partially overcome this).  Finally, using the file: scheme doesn't easily "
"support people who dynamically load documentation from the Internet (instead "
"of loading the files onto a local filesystem).  A future URI scheme may be "
"added (e.g., \"userdoc:\") to permit programs to include cross-references to "
"more detailed documentation without having to know the exact location of "
"that documentation.  Alternatively, a future version of the filesystem "
"specification may specify file locations sufficiently so that the file: "
"scheme will be able to locate documentation."
msgstr ""
"文書は様々な場所に置かれうる。したがって現時点では、 任意のフォーマットで書か"
"れた一般のオンライン文書に対する良い URI スキームが 存在しない。 "
"E<lt>file:///usr/doc/ZZZE<gt> 形式の参照は使えない。なぜなら ディストリビュー"
"ションやローカルへのインストールの際の条件によって、 ファイルは異なるディレク"
"トリに置かれることがあるからである (/usr/doc か /usr/local/doc か /usr/share "
"かその他の場所か、などなど)。 また、ディレクトリ ZZZ は通常バージョンが変わる"
"と異なったものになる (ファイル名のグロブによってある程度克服できるだろう"
"が)。 最後にもう一つ、文書をインターネットから (ローカルのファイルシステムに "
"ファイルをロードするのではなく) 動的にロードする人々は、 なかなか file: ス"
"キームを使ってくれない。 将来には新たな URI スキーム (例えば \"userdoc:\" の"
"ような) が追加され、 より詳しい文書へのクロスリファレンスが、 その文書の正確"
"な場所をプログラムが知らなくても可能になるかもしれない。 あるいは、ファイルシ"
"ステム規格の将来の版で ファイルの場所の指定をより厳密にして、 file: スキーム"
"による文書の位置指定が可能になるかもしれない。"

#. type: Plain text
#: build/C/man7/uri.7:698
msgid ""
"Many programs and file formats don't include a way to incorporate or "
"implement links using URIs."
msgstr ""
"プログラムやファイルフォーマットの多くでは、 URI を使ったリンクを取り込んだり"
"実装したりする方法がない。"

#.  .SH AUTHOR
#.  David A. Wheeler (dwheeler@dwheeler.com) wrote this man page.
#. type: Plain text
#: build/C/man7/uri.7:706
msgid ""
"Many programs can't handle all of these different URI formats; there should "
"be a standard mechanism to load an arbitrary URI that automatically detects "
"the users' environment (e.g., text or graphics, desktop environment, local "
"user preferences, and currently executing tools) and invokes the right tool "
"for any URI."
msgstr ""
"プログラムの多くは、これらの URI フォーマットをすべては扱えない。 ユーザーの"
"環境 (テキストかグラフィックか、 デスクトップ環境、ローカルユーザーの好み、 "
"現在実行されているツール) などを自動的に検知して、 任意の URI をロードし、そ"
"の URI に適したツールを起動するような 標準的な仕組みがあるといいのだろうが。"

#. type: Plain text
#: build/C/man7/uri.7:711
msgid "B<lynx>(1), B<man2html>(1), B<mailaddr>(7), B<utf-8>(7)"
msgstr "B<lynx>(1), B<man2html>(1), B<mailaddr>(7), B<utf-8>(7)"

#. type: Plain text
#: build/C/man7/uri.7:715
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> IETF RFC\\ 2255 E<.UE>"
msgstr ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> IETF RFC\\ 2255 E<.UE>"

#. type: TH
#: build/C/man4/vcs.4:29
#, no-wrap
msgid "VCS"
msgstr "VCS"

#. type: Plain text
#: build/C/man4/vcs.4:32
msgid "vcs, vcsa - virtual console memory"
msgstr "vcs, vcsa - 仮想コンソールメモリー (virtual console memory)"

#. type: Plain text
#: build/C/man4/vcs.4:38
msgid ""
"I</dev/vcs0> is a character device with major number 7 and minor number 0, "
"usually with mode 0644 and ownership root:tty.  It refers to the memory of "
"the currently displayed virtual console terminal."
msgstr "I</dev/vcs0> はメジャーナンバー (major number) 7、マイナーナンバー (minor number) 0 のキャラクターデバイス (character device) で、 通常、そのモードは 0644、所有権は root:tty である。 このデバイスファイル (device file) は 現在表示されている仮想コンソール端末のメモリーを参照する。"

#. type: Plain text
#: build/C/man4/vcs.4:58
msgid ""
"I</dev/vcs[1-63]> are character devices for virtual console terminals, they "
"have major number 7 and minor number 1 to 63, usually mode 0644 and "
"ownership root:tty.  I</dev/vcsa[0-63]> are the same, but using I<unsigned "
"short>s (in host byte order) that include attributes, and prefixed with four "
"bytes giving the screen dimensions and cursor position: I<lines>, "
"I<columns>, I<x>, I<y>.  (I<x> = I<y> = 0 at the top left corner of the "
"screen.)"
msgstr "B</dev/vcs[1-63]> は仮想コンソール端末のための キャラクターデバイスで、メジャーナンバーが 7、マイナーナンバーが 1 から 63、 通常はモードが 0644、所有権が root:tty である。 B</dev/vcsa[0-63]> は B</dev/vcs[1-63]> と同様であるが、 属性を格納するのに (ホストバイトオーダの)  I<unsigned short> を使用している点、スクリーンのサイズ・カーソルの位置を表す 4 バイトの情報 I<lines>, I<columns>, I<x>, I<y> (I<x> =I<y> = 0 が画面の左上) が先頭にある点が異なる。"

#. type: Plain text
#: build/C/man4/vcs.4:72
msgid ""
"When a 512-character font is loaded, the 9th bit position can be fetched by "
"applying the B<ioctl>(2)  B<VT_GETHIFONTMASK> operation (available in Linux "
"kernels 2.6.18 and above)  on I</dev/tty[1-63]>; the value is returned in "
"the I<unsigned short> pointed to by the third B<ioctl>(2)  argument."
msgstr ""
"512 文字から成るフォントをロードした場合、 9 ビット目の情報は I</dev/"
"tty[1-63]> に対して B<ioctl>(2)  B<VT_GETHIFONTMASK> 操作を行うことで取得でき"
"る (B<VT_GETHIFONTMASK> 操作はカーネル 2.6.18 以降の Linux で 利用可能であ"
"る)。 値は B<ioctl>(2)  の 3 番目の引数が指す I<unsigned short> に格納され"
"て返される。"

#. type: Plain text
#: build/C/man4/vcs.4:79
msgid ""
"These devices replace the screendump B<ioctl>(2)  operations of "
"B<ioctl_console>(2), so the system administrator can control access using "
"filesystem permissions."
msgstr "これらのデバイスは B<ioctl_console>(2)  の screendump B<ioctl>(2) を代替となる。 従って、システム管理者はファイルシステムパーミッション (filesystem permission) を使ってアクセスをコントロールできる。"

#. type: Plain text
#: build/C/man4/vcs.4:81
msgid "The devices for the first eight virtual consoles may be created by:"
msgstr "最初の 8 つの仮想端末のためのデバイスは、次のようにして作る事ができる:"

#. type: Plain text
#: build/C/man4/vcs.4:89
#, no-wrap
msgid ""
"for x in 0 1 2 3 4 5 6 7 8; do\n"
"    mknod -m 644 /dev/vcs$x c 7 $x;\n"
"    mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n"
"done\n"
"chown root:tty /dev/vcs*\n"
msgstr ""
" for x in 0 1 2 3 4 5 6 7 8; do\n"
"    mknod -m 644 /dev/vcs$x c 7 $x;\n"
"    mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n"
"done\n"
"chown root:tty /dev/vcs*\n"

#. type: Plain text
#: build/C/man4/vcs.4:95
msgid "No B<ioctl>(2)  requests are supported."
msgstr "B<ioctl>(2)  による要求はサポートされない。"

#. type: Plain text
#: build/C/man4/vcs.4:97
msgid "I</dev/vcs[0-63]>"
msgstr " I</dev/vcs[0-63]>"

#.  .SH AUTHOR
#.  Andries Brouwer <aeb@cwi.nl>
#. type: Plain text
#: build/C/man4/vcs.4:101
msgid "I</dev/vcsa[0-63]>"
msgstr " I</dev/vcsa[0-63]>"

#. type: Plain text
#: build/C/man4/vcs.4:103
msgid "Introduced with version 1.1.92 of the Linux kernel."
msgstr "Linux カーネルバージョン 1.1.92 で導入された。"

#. type: Plain text
#: build/C/man4/vcs.4:105
msgid "You may do a screendump on vt3 by switching to vt1 and typing"
msgstr ""
"vt1 に移って以下を実行すると、vt3 のスクリーンダンプを取ることができます。"

#. type: Plain text
#: build/C/man4/vcs.4:109
#, no-wrap
msgid "cat /dev/vcs3 E<gt>foo\n"
msgstr " cat /dev/vcs3 E<gt>foo\n"

#. type: Plain text
#: build/C/man4/vcs.4:115
msgid ""
"Note that the output does not contain newline characters, so some processing "
"may be required, like in"
msgstr ""
"主力には改行文字が含まれない点に注意して下さい。 そのため、 何らかの処理が必"
"要となるかもしれません。 例えば、"

#. type: Plain text
#: build/C/man4/vcs.4:119
#, no-wrap
msgid "fold -w 81 /dev/vcs3 | lpr\n"
msgstr " fold -w 81 /dev/vcs3 | lpr\n"

#. type: Plain text
#: build/C/man4/vcs.4:123
msgid "or (horrors)"
msgstr "(ひどい方法としては)"

#. type: Plain text
#: build/C/man4/vcs.4:127
#, no-wrap
msgid "setterm -dump 3 -file /proc/self/fd/1\n"
msgstr " setterm -dump 3 -file /proc/self/fd/1\n"

#. type: Plain text
#: build/C/man4/vcs.4:133
msgid "The I</dev/vcsa0> device is used for Braille support."
msgstr ""
"I</dev/vcsa0> デバイスを使うことで、 ブライユ点字をサポートすることができる。"

#. type: Plain text
#: build/C/man4/vcs.4:137
msgid ""
"This program displays the character and screen attributes under the cursor "
"of the second virtual console, then changes the background color there:"
msgstr ""
"以下のプログラムは、 二つ目の仮想コンソールのカーソル位置のスクリーン属性と文"
"字を表示した後、 カーソル位置の背景色を変更する。"

#. type: Plain text
#: build/C/man4/vcs.4:145
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/vt.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/vt.hE<gt>\n"

#. type: Plain text
#: build/C/man4/vcs.4:157
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd;\n"
"    char *device = \"/dev/vcsa2\";\n"
"    char *console = \"/dev/tty2\";\n"
"    struct {unsigned char lines, cols, x, y;} scrn;\n"
"    unsigned short s;\n"
"    unsigned short mask;\n"
"    unsigned char attrib;\n"
"    int ch;\n"
msgstr ""
" int\n"
"main(void)\n"
"{\n"
"    int fd;\n"
"    char *device = \"/dev/vcsa2\";\n"
"    char *console = \"/dev/tty2\";\n"
"    struct {unsigned char lines, cols, x, y;} scrn;\n"
"    unsigned short s;\n"
"    unsigned short mask;\n"
"    unsigned char attrib;\n"
"    int ch;\n"

#. type: Plain text
#: build/C/man4/vcs.4:186
#, no-wrap
msgid ""
"    fd = open(console, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(console);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (ioctl(fd, VT_GETHIFONTMASK, &mask) E<lt> 0) {\n"
"        perror(\"VT_GETHIFONTMASK\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) close(fd);\n"
"    fd = open(device, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(device);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) read(fd, &scrn, 4);\n"
"    (void) lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), SEEK_SET);\n"
"    (void) read(fd, &s, 2);\n"
"    ch = s & 0xff;\n"
"    if (s & mask)\n"
"        ch |= 0x100;\n"
"    attrib = ((s & \\(timask) E<gt>E<gt> 8);\n"
"    printf(\"ch=%#03x attrib=%#02x\\en\", ch, attrib);\n"
"    s \\(ha= 0x1000;\n"
"    (void) lseek(fd, -2, SEEK_CUR);\n"
"    (void) write(fd, &s, 2);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"     fd = open(console, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(console);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (ioctl(fd, VT_GETHIFONTMASK, &mask) E<lt> 0) {\n"
"        perror(\"VT_GETHIFONTMASK\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) close(fd);\n"
"    fd = open(device, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(device);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) read(fd, &scrn, 4);\n"
"    (void) lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), SEEK_SET);\n"
"    (void) read(fd, &s, 2);\n"
"    ch = s & 0xff;\n"
"    if (s & mask)\n"
"        ch |= 0x100;\n"
"    attrib = ((s & \\(timask) E<gt>E<gt> 8);\n"
"    printf(\"ch=%#03x attrib=%#02x\\en\", ch, attrib);\n"
"    s \\(ha= 0x1000;\n"
"    (void) lseek(fd, -2, SEEK_CUR);\n"
"    (void) write(fd, &s, 2);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man4/vcs.4:192
msgid "B<ioctl_console>(2), B<tty>(4), B<ttyS>(4), B<gpm>(8)"
msgstr " B<ioctl_console>(2), B<tty>(4), B<ttyS>(4), B<gpm>(8)"

#. type: TH
#: build/C/man4/wavelan.4:15
#, no-wrap
msgid "WAVELAN"
msgstr "WAVELAN"

#. type: Plain text
#: build/C/man4/wavelan.4:18
msgid "wavelan - AT&T GIS WaveLAN ISA device driver"
msgstr "wavelan - AT&T GIS WaveLAN ISA デバイスドライバ"

#. type: Plain text
#: build/C/man4/wavelan.4:20
msgid ""
"B<insmod wavelan_cs.o [io=>I<B,B..>B<] [ irq=>I<I,I..>B<] [name=>I<N,N..>B<]>"
msgstr ""
"B<insmod wavelan_cs.o [io=>I<B,B..>B<] [ irq=>I<I,I..>B<] [name=>I<N,N..>B<]>"

#. type: Plain text
#: build/C/man4/wavelan.4:23
msgid ""
"I<This driver is obsolete:> it was removed from the kernel in version 2.6.35."
msgstr ""
"B<このドライバーは時代遅れである>: このドライバーはカーネル 2.6.35 で削除され"
"た。"

#. type: Plain text
#: build/C/man4/wavelan.4:39
msgid ""
"B<wavelan> is the low-level device driver for the NCR / AT&T / Lucent "
"B<WaveLAN ISA> and Digital (DEC)  B<RoamAbout DS> wireless ethernet "
"adapter.  This driver is available as a module or might be compiled in the "
"kernel.  This driver supports multiple cards in both forms (up to 4) and "
"allocates the next available ethernet device (eth0..eth#) for each card "
"found, unless a device name is explicitly specified (see below).  This "
"device name will be reported in the kernel log file with the MAC address, "
"NWID and frequency used by the card."
msgstr "B<wavelan> は、NCR / AT&T / Lucent の B<WaveLan ISA> と Digital(DEC) の B<RoamAbout DS> というワイアレスイーサネット (wireless ethernet) アダプターのための ローレベルデバイスドライバである。このドライバはモジュールとしても、また、 カーネルに組み込んだ形でも利用できる。また、どちらの場合でも、複数カード (最大 4 枚まで) をサポートし、明示的にデバイスの名前を指定しない限り (これに関しては、下を見よ)、発見されたそれぞれのカードには、利用可能な 次のイーサネットデバイス(eth0..eth#)が割り当てられる。このデバイス名は MAC アドレス、NWID、カードによって利用される周波数とともに カーネルログファイルに報告される。"

#. type: Plain text
#: build/C/man4/wavelan.4:46
msgid ""
"This section applies to the module form (parameters passed on the "
"B<insmod>(8)  command line).  If the driver is included in the kernel, use "
"the I<ether=IRQ,IO,NAME> syntax on the kernel command line."
msgstr ""
"このセクションのパラメーターは、モジュールとして使用する場合 に適用され、 "
"B<insmod>(8)  のコマンドライン引数として用いる。 カーネルにドライバが含まれ"
"ている場合は、 I<ether=IRQ,IO,NAME> という形式のパラメーターをカーネルコマン"
"ドラインに渡す。"

#. type: TP
#: build/C/man4/wavelan.4:46
#, no-wrap
msgid "B<io>"
msgstr "B<io>"

#. type: Plain text
#: build/C/man4/wavelan.4:53
msgid ""
"Specify the list of base addresses where to search for wavelan cards "
"(setting by dip switch on the card).  If you don't specify any io address, "
"the driver will scan 0x390 and 0x3E0 addresses, which might conflict with "
"other hardware..."
msgstr ""
"wavelan カードを検出する時にどこのベースアドレスをサーチするかという リストを"
"指定する (カードが利用するベースアドレスはカードのディップ スイッチで設定す"
"る)。もし io アドレスが指定されなければドライバは 0x390 と 0x3E0 をスキャンす"
"る(このアドレスは他のハードと衝突することも考えられる)。"

#. type: TP
#: build/C/man4/wavelan.4:53
#, no-wrap
msgid "B<irq>"
msgstr "B<irq>"

#. type: Plain text
#: build/C/man4/wavelan.4:57
msgid ""
"Set the list of IRQs that each wavelan card should use (the value is saved "
"in permanent storage for future use)."
msgstr "それぞれの wavelan カードが利用する IRQ のリストをセットする (この値は 将来的な利用のために永続的ストレージに保存される)。"

#. type: TP
#: build/C/man4/wavelan.4:57
#, no-wrap
msgid "B<name>"
msgstr "B<name>"

#. type: Plain text
#: build/C/man4/wavelan.4:62
msgid ""
"Set the list of names to be used for each wavelan card device (name used by "
"B<ifconfig>(8))."
msgstr "それぞれの wavelan カードデバイスに (B<ifconfig>(8) が利用する) 名前のリストをセットする。"

#. type: SS
#: build/C/man4/wavelan.4:62
#, no-wrap
msgid "Wireless extensions"
msgstr "ワイアレス拡張 (Wireless Extentions)"

#. type: Plain text
#: build/C/man4/wavelan.4:66
msgid "Use B<iwconfig>(8)  to manipulate wireless extensions."
msgstr "ワイアレス拡張の操作には B<iwconfig>(8)  を使う。"

#. type: SS
#: build/C/man4/wavelan.4:66
#, no-wrap
msgid "NWID (or domain)"
msgstr "NWID (or ドメイン)"

#. type: Plain text
#: build/C/man4/wavelan.4:75
msgid ""
"Set the network ID [I<0> to I<FFFF>] or disable it [I<off>].  As the NWID is "
"stored in the card Permanent Storage Area, it will be reused at any further "
"invocation of the driver."
msgstr "ネットワーク IDを [I<0> から I<FFFF>] に設定するか、 [I<off>] その利用を無効にする。 NWID はカードの永続的ストレージエリア (Permanent Strage Area) に 格納されるので、NWID はドライバが呼び出されるたびに再利用できる。"

#. type: SS
#: build/C/man4/wavelan.4:75
#, no-wrap
msgid "Frequency & channels"
msgstr "周波数とチャネル"

#. type: Plain text
#: build/C/man4/wavelan.4:86
msgid ""
"For the 2.4\\ GHz 2.00 Hardware, you are able to set the frequency by "
"specifying one of the 10 defined channels (I<2.412,> I<2.422, 2.425, 2.4305, "
"2.432, 2.442, 2.452, 2.460, 2.462> or I<2.484>)  or directly as a numeric "
"value.  The frequency is changed immediately and permanently.  Frequency "
"availability depends on the regulations..."
msgstr "2.4\\ GHz 2.00 ハードウェアでは、10 の定義済みのチャネル (I<2.412> I<2.422, 2.425, 2.4305, 2.432, 2.442, 2.452, 2.460, 2.462> I<2.484>)  のうちの一つを指定するか、その数値を直接指定することによって周波数を設定 することができる。 周波数は直後に変更され、また、その変更は恒久的である。 どの周波数が利用できるかということは、(その国の) 法律に依存する…"

#. type: SS
#: build/C/man4/wavelan.4:86
#, no-wrap
msgid "Statistics spy"
msgstr "統計スパイ (Statics spy)"

#. type: Plain text
#: build/C/man4/wavelan.4:90
msgid ""
"Set a list of MAC addresses in the driver (up to 8) and get the last quality "
"of link for each of those (see B<iwspy>(8))."
msgstr ""
"(8 つまでの) MAC アドレスのリストをドライバに設定して、 それぞれのリンクの品"
"質を得る (B<iwspy>(8)  を参照)。"

#. type: SS
#: build/C/man4/wavelan.4:90
#, no-wrap
msgid "/proc/net/wireless"
msgstr "/proc/net/wireless"

#. type: Plain text
#: build/C/man4/wavelan.4:105
msgid ""
"I<status> is the status reported by the modem.  I<Link quality> reports the "
"quality of the modulation on the air (direct sequence spread spectrum) [max "
"= 16].  I<Level> and I<Noise> refer to the signal level and noise level [max "
"= 64].  The I<crypt discarded packet> and I<misc discarded packet> counters "
"are not implemented."
msgstr ""
"I<status> はモデムから報告されたステータスである。 I<link quality> は通信中の"
"(直接拡散スペクトラム通信方式における)変調の品質を報告する [最大 = 16]。 "
"I<Level> と I<Noise> は信号レベルとノイズのレベルを参照する [最大 = 64]。 I<"
"暗号化されていて廃棄されたパケット(crypt discarded packet)> と I<それ以外の廃"
"棄されたパケット(misc discarded packet)> のカウンターは実装されていない。"

#. type: SS
#: build/C/man4/wavelan.4:105
#, no-wrap
msgid "Private ioctl"
msgstr "ドライバ固有の IOCTL (private ioctl)"

#. type: Plain text
#: build/C/man4/wavelan.4:109
msgid "You may use B<iwpriv>(8)  to manipulate private ioctls."
msgstr "B<iwpriv>(8)  をドライバ固有の ioctl の操作のために利用できる。"

#. type: SS
#: build/C/man4/wavelan.4:109
#, no-wrap
msgid "Quality and level threshold"
msgstr "品質とレベルの閾値 (quality and level threshold)"

#. type: Plain text
#: build/C/man4/wavelan.4:112
msgid ""
"Enables you to define the quality and level threshold used by the modem "
"(packet below that level are discarded)."
msgstr ""
"モデムで使われる品質とレベルの閾値 (そのレベルを下回ったパケットは 破棄され"
"る) を定義することができる。"

#. type: SS
#: build/C/man4/wavelan.4:112
#, no-wrap
msgid "Histogram"
msgstr "ヒストグラム (Histogram)"

#. type: Plain text
#: build/C/man4/wavelan.4:119
msgid ""
"This functionality makes it possible to set a number of signal level "
"intervals and to count the number of packets received in each of those "
"defined intervals.  This distribution might be used to calculate the mean "
"value and standard deviation of the signal level."
msgstr ""
"この機能により、 シグナルレベル区間の数の設定と、設定したそれぞれの区間での "
"受信パケット数をカウントすることができる。 この分布はシグナルレベルの最瀕値標"
"準偏差の計算に役立つだろう。"

#. type: SS
#: build/C/man4/wavelan.4:119
#, no-wrap
msgid "Specific notes"
msgstr "特定のドライバでの注意"

#. type: Plain text
#: build/C/man4/wavelan.4:125
msgid ""
"This driver fails to detect some B<non-NCR/AT&T/Lucent> Wavelan cards.  If "
"this happens for you, you must look in the source code on how to add your "
"card to the detection routine."
msgstr "このドライバはいくつかの B<NCR/AT&T/Lucent ではない> Wavelan カードの検出に失敗するだろう。 これがあなたの持っているカードで起こった場合 、そのカードの検出処理をどのように加えればいいかと いうことについてソースコードを確認する必要がある。"

#.  .SH AUTHOR
#.  Bruce Janson \(em bruce@cs.usyd.edu.au
#.  .br
#.  Jean Tourrilhes \(em jt@hplb.hpl.hp.com
#.  .br
#.  (and others; see source code for details)
#.  SEE ALSO part
#. type: Plain text
#: build/C/man4/wavelan.4:138
msgid ""
"Some of the mentioned features are optional.  You may enable to disable them "
"by changing flags in the driver header and recompile."
msgstr ""
"ここまでで述べてきた機能のうちのいくつかは、選択可能である。 ドライバの先頭部"
"分のフラグを変更してコンパイルしなおすことによって、 その機能を無効にすること"
"も可能である。"

#. type: Plain text
#: build/C/man4/wavelan.4:145
msgid ""
"B<wavelan_cs>(4), B<ifconfig>(8), B<insmod>(8), B<iwconfig>(8), "
"B<iwpriv>(8), B<iwspy>(8)"
msgstr ""
"B<wavelan_cs>(4), B<ifconfig>(8), B<insmod>(8), B<iwconfig>(8), "
"B<iwpriv>(8), B<iwspy>(8)"

#. type: TH
#: build/C/man4/lirc.4:24
#, no-wrap
msgid "LIRC"
msgstr "LIRC"

#. type: Plain text
#: build/C/man4/lirc.4:27
msgid "lirc - lirc devices"
msgstr "lirc - lirc デバイス"

#. type: Plain text
#: build/C/man4/lirc.4:36
msgid ""
"The I</dev/lirc*> character devices provide a low-level bidirectional "
"interface to infra-red (IR) remotes.  Most of these devices can receive, and "
"some can send.  When receiving or sending data, the driver works in two "
"different modes depending on the underlying hardware."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:46
msgid ""
"Some hardware (typically TV-cards) decodes the IR signal internally and "
"provides decoded button presses as scancode values.  Drivers for this kind "
"of hardware work in B<LIRC_MODE_SCANCODE> mode.  Such hardware usually does "
"not support sending IR signals.  Furthermore, such hardware can only decode "
"a limited set of IR protocols, usually only the protocol of the specific "
"remote which is bundled with, for example, a TV-card."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:62
msgid ""
"Other hardware provides a stream of pulse/space durations.  Such drivers "
"work in B<LIRC_MODE_MODE2> mode.  Sometimes, this kind of hardware also "
"supports sending IR data.  Such hardware can be used with (almost) any kind "
"of remote.  This type of hardware can also be used in B<LIRC_MODE_SCANCODE> "
"mode, in which case the kernel IR decoders will decode the IR.  These "
"decoders can be written in extended BPF (see B<bpf>(2))  and attached to the "
"B<lirc> device."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:67
msgid ""
"The B<LIRC_GET_FEATURES> ioctl (see below) allows probing for whether "
"receiving and sending is supported, and in which modes, amongst other "
"features."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:67
#, no-wrap
msgid "Reading input with the LIRC_MODE_MODE2 mode"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:74
msgid ""
"In the B<LIRC_MODE_MODE2 mode>, the data returned by B<read>(2)  provides 32-"
"bit values representing a space or a pulse duration.  The time of the "
"duration (microseconds) is encoded in the lower 24 bits.  The upper 8 bits "
"indicate the type of package:"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:74
#, no-wrap
msgid "B<LIRC_MODE2_SPACE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:77
msgid "Value reflects a space duration (microseconds)."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:77
#, no-wrap
msgid "B<LIRC_MODE2_PULSE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:80
msgid "Value reflects a pulse duration (microseconds)."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:80
#, no-wrap
msgid "B<LIRC_MODE2_FREQUENCY>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:85
msgid ""
"Value reflects a frequency (Hz); see the B<LIRC_SET_MEASURE_CARRIER_MODE> "
"ioctl."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:85
#, no-wrap
msgid "B<LIRC_MODE2_TIMEOUT>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:92
msgid ""
"Value reflects a space duration (microseconds).  The package reflects a "
"timeout; see the B<LIRC_SET_REC_TIMEOUT_REPORTS> ioctl."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:92
#, no-wrap
msgid "Reading input with the LIRC_MODE_SCANCODE mode"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:102
msgid ""
"In the B<LIRC_MODE_SCANCODE> mode, the data returned by B<read>(2)  reflects "
"decoded button presses, in the struct I<lirc_scancode>.  The scancode is "
"stored in the I<scancode> field, and the IR protocol is stored in "
"I<rc_proto>.  This field has one the values of the I<enum rc_proto>."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:102
#, no-wrap
msgid "Writing output with the LIRC_MODE_PULSE mode"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:118
msgid ""
"The data written to the character device using B<write>(2)  is a pulse/space "
"sequence of integer values.  Pulses and spaces are only marked implicitly by "
"their position.  The data must start and end with a pulse, thus it must "
"always include an odd number of samples.  The B<write>(2)  function blocks "
"until the data has been transmitted by the hardware.  If more data is "
"provided than the hardware can send, the B<write>(2)  call fails with the "
"error B<EINVAL>."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:118
#, no-wrap
msgid "Writing output with the LIRC_MODE_SCANCODE mode"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:129
msgid ""
"The data written to the character devices must be a single struct "
"I<lirc_scancode>.  The I<scancode> and I<rc_proto> fields must filled in, "
"all other fields must be 0.  The kernel IR encoders will convert the "
"scancode to pulses and spaces.  The protocol or scancode is invalid, or the "
"B<lirc> device cannot transmit."
msgstr ""

#. type: SH
#: build/C/man4/lirc.4:129
#, no-wrap
msgid "IOCTL COMMANDS"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:141
msgid ""
"The LIRC device's ioctl definition is bound by the ioctl function definition "
"of I<struct file_operations>, leaving us with an I<unsigned int> for the "
"ioctl command and an I<unsigned long> for the argument.  For the purposes of "
"ioctl portability across 32-bit and 64-bit architectures, these values are "
"capped to their 32-bit sizes."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:145
#, no-wrap
msgid ""
"#include E<lt>linux/lirc.hE<gt>    /* But see BUGS */\n"
"int ioctl(int fd, int cmd, ...);\n"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:155
msgid ""
"The following ioctls can be used to probe or change specific B<lirc> "
"hardware settings.  Many require a third argument, usually an I<int>.  "
"referred to below as I<val>."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:155
#, no-wrap
msgid "Always Supported Commands"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:158
msgid "I</dev/lirc*> devices always support the following commands:"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:158
#, no-wrap
msgid "B<LIRC_GET_FEATURES> (I<void>)"
msgstr "B<LIRC_GET_FEATURES> (I<void>)"

#. type: Plain text
#: build/C/man4/lirc.4:161
msgid "Returns a bit mask of combined features bits; see FEATURES."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:168
msgid ""
"If a device returns an error code for B<LIRC_GET_FEATURES>, it is safe to "
"assume it is not a B<lirc> device."
msgstr ""

#. type: SS
#: build/C/man4/lirc.4:168
#, no-wrap
msgid "Optional Commands"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:179
msgid ""
"Some B<lirc> devices support the commands listed below.  Unless otherwise "
"stated, these fail with the error B<ENOTTY> if the operation isn't "
"supported, or with the error B<EINVAL> if the operation failed, or invalid "
"arguments were provided.  If a driver does not announce support of certain "
"features, invoking the corresponding ioctls will fail with the error "
"B<ENOTTY>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:179
#, no-wrap
msgid "B<LIRC_GET_REC_MODE> (I<void>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:186
msgid ""
"If the B<lirc> device has no receiver, this operation fails with the error "
"B<ENOTTY>.  Otherwise, it returns the receive mode, which will be one of:"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:187
#, no-wrap
msgid "B<LIRC_MODE_MODE2>"
msgstr " B<LIRC_MODE_MODE2>"

#. type: Plain text
#: build/C/man4/lirc.4:190
msgid "The driver returns a sequence of pulse/space durations."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:190
#, no-wrap
msgid "B<LIRC_MODE_SCANCODE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:196
msgid ""
"The driver returns struct I<lirc_scancode> values, each of which represents "
"a decoded button press."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:197
#, no-wrap
msgid "B<LIRC_SET_REC_MODE> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:209
msgid ""
"Set the receive mode.  I<val> is either B<LIRC_MODE_SCANCODE> or "
"B<LIRC_MODE_MODE2>.  If the B<lirc> device has no receiver, this operation "
"fails with the error B<ENOTTY.>"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:209
#, no-wrap
msgid "B<LIRC_GET_SEND_MODE> (I<void>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:220
msgid ""
"Return the send mode.  B<LIRC_MODE_PULSE> or B<LIRC_MODE_SCANCODE> is "
"supported.  If the B<lirc> device cannot send, this operation fails with the "
"error B<ENOTTY.>"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:220
#, no-wrap
msgid "B<LIRC_SET_SEND_MODE> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:232
msgid ""
"Set the send mode.  I<val> is either B<LIRC_MODE_SCANCODE> or "
"B<LIRC_MODE_PULSE>.  If the B<lirc> device cannot send, this operation fails "
"with the error B<ENOTTY>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:232
#, no-wrap
msgid "B<LIRC_SET_SEND_CARRIER> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:236
msgid "Set the modulation frequency.  The argument is the frequency (Hz)."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:236
#, no-wrap
msgid "B<LIRC_SET_SEND_DUTY_CYCLE> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:244
msgid ""
"Set the carrier duty cycle.  I<val> is a number in the range [0,100] which "
"describes the pulse width as a percentage of the total cycle.  Currently, no "
"special meaning is defined for 0 or 100, but the values are reserved for "
"future use."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:245
#, no-wrap
msgid "B<LIRC_GET_MIN_TIMEOUT> (I<void>)B<,> B<LIRC_GET_MAX_TIMEOUT> (I<void>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:264
msgid ""
"Some devices have internal timers that can be used to detect when there has "
"been no IR activity for a long time.  This can help B<lircd>(8)  in "
"detecting that an IR signal is finished and can speed up the decoding "
"process.  These operations return integer values with the minimum/maximum "
"timeout that can be set (microseconds).  Some devices have a fixed timeout.  "
"For such drivers, B<LIRC_GET_MIN_TIMEOUT> and B<LIRC_GET_MAX_TIMEOUT> will "
"fail with the error B<ENOTTY>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:264
#, no-wrap
msgid "B<LIRC_SET_REC_TIMEOUT> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:276
msgid ""
"Set the integer value for IR inactivity timeout (microseconds).  To be "
"accepted, the value must be within the limits defined by "
"B<LIRC_GET_MIN_TIMEOUT> and B<LIRC_GET_MAX_TIMEOUT>.  A value of 0 (if "
"supported by the hardware) disables all hardware timeouts and data should be "
"reported as soon as possible.  If the exact value cannot be set, then the "
"next possible value I<greater> than the given value should be set."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:276
#, no-wrap
msgid "B<LIRC_GET_REC_TIMEOUT> (I<void>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:280
msgid ""
"Return the current inactivity timeout (microseconds).  Available since Linux "
"4.18."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:280
#, no-wrap
msgid "B<LIRC_SET_REC_TIMEOUT_REPORTS> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:289
msgid ""
"Enable (I<val> is 1) or disable (I<val> is 0) timeout packages in "
"B<LIRC_MODE_MODE2>.  The behavior of this operation has varied across kernel "
"versions:"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:298
msgid ""
"Since Linux 4.16: each time the B<lirc device is opened,> timeout reports "
"are by default enabled for the resulting file descriptor.  The "
"B<LIRC_SET_REC_TIMEOUT> operation can be used to disable (and, if desired, "
"to later re-enable)  the timeout on the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:306
msgid ""
"In Linux 4.15 and earlier: timeout reports are disabled by default, and "
"enabling them (via B<LIRC_SET_REC_TIMEOUT>)  on any file descriptor "
"associated with the B<lirc> device has the effect of enabling timeouts for "
"all file descriptors referring to that device (until timeouts are disabled "
"again)."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:307
#, no-wrap
msgid "B<LIRC_SET_REC_CARRIER> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:312
msgid ""
"Set the upper bound of the receive carrier frequency (Hz).  See "
"B<LIRC_SET_REC_CARRIER_RANGE>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:312
#, no-wrap
msgid "B<LIRC_SET_REC_CARRIER_RANGE> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:320
msgid ""
"Sets the lower bound of the receive carrier frequency (Hz).  For this to "
"take affect, first set the lower bound using the "
"B<LIRC_SET_REC_CARRIER_RANGE> ioctl, and then the upper bound using the "
"B<LIRC_SET_REC_CARRIER> ioctl."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:320
#, no-wrap
msgid "B<LIRC_SET_MEASURE_CARRIER_MODE> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:331
msgid ""
"Enable (I<val> is 1) or disable (I<val> is 0) the measure mode.  If enabled, "
"from the next key press on, the driver will send B<LIRC_MODE2_FREQUENCY> "
"packets.  By default, this should be turned off."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:331
#, no-wrap
msgid "B<LIRC_GET_REC_RESOLUTION> (I<void>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:334
msgid "Return the driver resolution (microseconds)."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:334
#, no-wrap
msgid "B<LIRC_SET_TRANSMITTER_MASK> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:344
msgid ""
"Enable the set of transmitters specified in I<val>, which contains a bit "
"mask where each enabled transmitter is a 1.  The first transmitter is "
"encoded by the least significant bit, and so on.  When an invalid bit mask "
"is given, for example a bit is set even though the device does not have so "
"many transmitters, this operation returns the number of available "
"transmitters and does nothing otherwise."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:344
#, no-wrap
msgid "B<LIRC_SET_WIDEBAND_RECEIVER> (I<int>)"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:358
msgid ""
"Some devices are equipped with a special wide band receiver which is "
"intended to be used to learn the output of an existing remote.  This ioctl "
"can be used to enable (I<val> equals 1) or disable (I<val> equals 0) this "
"functionality.  This might be useful for devices that otherwise have narrow "
"band receivers that prevent them to be used with certain remotes.  Wide band "
"receivers may also be more precise.  On the other hand, their disadvantage "
"usually is reduced range of reception."
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:365
msgid ""
"Note: wide band receiver may be implicitly enabled if you enable carrier "
"reports.  In that case, it will be disabled as soon as you disable carrier "
"reports.  Trying to disable a wide band receiver while carrier reports are "
"active will do nothing."
msgstr ""

#. type: SH
#: build/C/man4/lirc.4:365
#, no-wrap
msgid "FEATURES"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:371
msgid ""
"the B<LIRC_GET_FEATURES> ioctl returns a bit mask describing features of the "
"driver.  The following bits may be returned in the mask:"
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:371
#, no-wrap
msgid "B<LIRC_CAN_REC_MODE2>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:375
msgid "The driver is capable of receiving using B<LIRC_MODE_MODE2>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:375
#, no-wrap
msgid "B<LIRC_CAN_REC_SCANCODE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:379
msgid "The driver is capable of receiving using B<LIRC_MODE_SCANCODE>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:379
#, no-wrap
msgid "B<LIRC_CAN_SET_SEND_CARRIER>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:383
msgid ""
"The driver supports changing the modulation frequency using "
"B<LIRC_SET_SEND_CARRIER>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:383
#, no-wrap
msgid "B<LIRC_CAN_SET_SEND_DUTY_CYCLE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:387
msgid ""
"The driver supports changing the duty cycle using "
"B<LIRC_SET_SEND_DUTY_CYCLE>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:387
#, no-wrap
msgid "B<LIRC_CAN_SET_TRANSMITTER_MASK>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:391
msgid ""
"The driver supports changing the active transmitter(s) using "
"B<LIRC_SET_TRANSMITTER_MASK>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:391
#, no-wrap
msgid "B<LIRC_CAN_SET_REC_CARRIER>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:403
msgid ""
"The driver supports setting the receive carrier frequency using "
"B<LIRC_SET_REC_CARRIER>.  Any B<lirc> device since the drivers were merged "
"in kernel release 2.6.36 must have B<LIRC_CAN_SET_REC_CARRIER_RANGE> set if "
"B<LIRC_CAN_SET_REC_CARRIER> feature is set."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:403
#, no-wrap
msgid "B<LIRC_CAN_SET_REC_CARRIER_RANGE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:412
msgid ""
"The driver supports B<LIRC_SET_REC_CARRIER_RANGE>.  The lower bound of the "
"carrier must first be set using the B<LIRC_SET_REC_CARRIER_RANGE> ioctl, "
"before using the B<LIRC_SET_REC_CARRIER> ioctl to set the upper bound."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:412
#, no-wrap
msgid "B<LIRC_CAN_GET_REC_RESOLUTION>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:416
msgid "The driver supports B<LIRC_GET_REC_RESOLUTION>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:416
#, no-wrap
msgid "B<LIRC_CAN_SET_REC_TIMEOUT>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:420
msgid "The driver supports B<LIRC_SET_REC_TIMEOUT>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:420
#, no-wrap
msgid "B<LIRC_CAN_MEASURE_CARRIER>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:424
msgid ""
"The driver supports measuring of the modulation frequency using "
"B<LIRC_SET_MEASURE_CARRIER_MODE>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:424
#, no-wrap
msgid "B<LIRC_CAN_USE_WIDEBAND_RECEIVER>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:428
msgid "The driver supports learning mode using B<LIRC_SET_WIDEBAND_RECEIVER>."
msgstr ""

#. type: TP
#: build/C/man4/lirc.4:428
#, no-wrap
msgid "B<LIRC_CAN_SEND_PULSE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:435
msgid ""
"The driver supports sending using B<LIRC_MODE_PULSE> or B<LIRC_MODE_SCANCODE>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:443
msgid ""
"Using these devices requires the kernel source header file I<lirc.h>.  This "
"file is not available before kernel release 4.6.  Users of older kernels "
"could use the file bundled in E<.UR http://www.lirc.org> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man4/lirc.4:445
msgid "B<ir-ctl>(1), B<lircd>(8),\\ B<bpf>(2)"
msgstr " B<ir-ctl>(1), B<lircd>(8),\\ B<bpf>(2)"

#. type: Plain text
#: build/C/man4/lirc.4:447
msgid "https://www.kernel.org/doc/html/latest/media/uapi/rc/lirc-dev.html"
msgstr ""

#. type: TH
#: build/C/man4/smartpqi.4:9
#, no-wrap
msgid "SMARTPQI"
msgstr ""

#. type: TH
#: build/C/man4/smartpqi.4:9
#, no-wrap
msgid "2019-10-10"
msgstr " 2019-10-10"

#. type: Plain text
#: build/C/man4/smartpqi.4:12
msgid "smartpqi - Microsemi Smart Family SCSI driver"
msgstr ""

#. type: SY
#: build/C/man4/smartpqi.4:13
#, no-wrap
msgid "modprobe smartpqi"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:20
msgid ""
"[B<disable_device_id_wildcards=>{B<0>|B<1>}] [B<disable_heartbeat=>{B<0>|"
"B<1>}] [B<disable_ctrl_shutdown=>{B<0>|B<1>}] [B<lockup_action=>{B<none>|"
"B<reboot>|B<panic>}] [B<expose_ld_first=>{B<0>|B<1>}] [B<hide_vsep=>{B<0>|"
"B<1>}]"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:24
msgid "B<smartpqi> is a SCSI driver for Microsemi Smart Family controllers."
msgstr ""

#. type: SS
#: build/C/man4/smartpqi.4:24
#, no-wrap
msgid "Supported \\f[BI]ioctl\\fB\\/() operations"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:39
msgid ""
"For compatibility with applications written for the B<cciss>(4)  and "
"B<hpsa>(4)  drivers, many, but not all of the B<ioctl>(2)  operations "
"supported by the B<hpsa> driver are also supported by the B<smartpqi> "
"driver.  The data structures used by these operations are described in the "
"Linux kernel source file I<include/linux/cciss_ioctl.h>."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:49
msgid ""
"These operations all do exactly the same thing, which is to cause the driver "
"to re-scan for new devices.  This does exactly the same thing as writing to "
"the B<smartpqi>-specific host I<rescan> attribute."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:53
msgid ""
"This operation Returns the PCI domain, bus, device and function and \"board "
"ID\" (PCI subsystem ID)."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:56
msgid "This operation returns the driver version in four bytes, encoded as:"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:61
#, no-wrap
msgid ""
"(major_version E<lt>E<lt> 28) | (minor_version E<lt>E<lt> 24) |\n"
"        (release E<lt>E<lt> 16) | revision\n"
msgstr ""
" (major_version E<lt>E<lt> 28) | (minor_version E<lt>E<lt> 24) |\n"
"        (release E<lt>E<lt> 16) | revision\n"

#. type: TP
#: build/C/man4/smartpqi.4:63
#, no-wrap
msgid "B<CCISS_PASSTHRU>"
msgstr " B<CCISS_PASSTHRU>"

#. type: Plain text
#: build/C/man4/smartpqi.4:66
msgid "Allows BMIC and CISS commands to be passed through to the controller."
msgstr ""

#. type: SS
#: build/C/man4/smartpqi.4:66
#, no-wrap
msgid "Boot options"
msgstr "ブートオプション"

#. type: TP
#: build/C/man4/smartpqi.4:67
#, no-wrap
msgid "B<disable_device_id_wildcards=>{B<0>|B<1>}"
msgstr "B<disable_device_id_wildcards=>{B<0>|B<1>}"

#. type: Plain text
#: build/C/man4/smartpqi.4:71
msgid "Disables support for device ID wildcards.  The default value is 0."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:71
#, no-wrap
msgid "B<disable_heartbeat=>{B<0>|B<1>}"
msgstr "B<disable_heartbeat=>{B<0>|B<1>}"

#. type: Plain text
#: build/C/man4/smartpqi.4:76
msgid ""
"Disables support for the controller's heartbeat check.  This parameter is "
"used for debugging purposes.  The default value is 0, leaving the "
"controller's heartbeat check active."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:76
#, no-wrap
msgid "B<disable_ctrl_shutdown=>{B<0>|B<1>}"
msgstr "B<disable_ctrl_shutdown=>{B<0>|B<1>}"

#. type: Plain text
#: build/C/man4/smartpqi.4:81
msgid ""
"Disables support for shutting down the controller in the event of a "
"controller lockup.  The default value is 0."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:81
#, no-wrap
msgid "B<lockup_action=>{B<none>|B<reboot>|B<panic>}"
msgstr "B<lockup_action=>{B<none>|B<reboot>|B<panic>}"

#. type: Plain text
#: build/C/man4/smartpqi.4:87
msgid ""
"Specifies the action the driver takes when a controller lockup is detected.  "
"The default action is B<none>."
msgstr ""

#. type: tbl table
#: build/C/man4/smartpqi.4:91
#, no-wrap
msgid "parameter"
msgstr "parameter"

#. type: tbl table
#: build/C/man4/smartpqi.4:91
#, no-wrap
msgid "action"
msgstr "アクション"

#. type: tbl table
#: build/C/man4/smartpqi.4:92
#, no-wrap
msgid "B<none>"
msgstr "B<none>"

#. type: tbl table
#: build/C/man4/smartpqi.4:92
#, no-wrap
msgid "take controller offline only"
msgstr ""

#. type: tbl table
#: build/C/man4/smartpqi.4:93
#, no-wrap
msgid "B<reboot>"
msgstr "B<reboot>"

#. type: tbl table
#: build/C/man4/smartpqi.4:93
#, no-wrap
msgid "reboot the system"
msgstr "システムを再起動する"

#. type: tbl table
#: build/C/man4/smartpqi.4:94
#, no-wrap
msgid "B<panic>"
msgstr "B<panic>"

#. type: tbl table
#: build/C/man4/smartpqi.4:94
#, no-wrap
msgid "panic the system"
msgstr "システムを panic 状態にする"

#. type: TP
#: build/C/man4/smartpqi.4:96
#, no-wrap
msgid "B<expose_ld_first=>{B<0>|B<1>}"
msgstr "B<expose_ld_first=>{B<0>|B<1>}"

#. type: Plain text
#: build/C/man4/smartpqi.4:101
#, fuzzy
#| msgid ""
#| "This option enables support for several partitions within a tape.  The "
#| "option applies to all devices linked to a drive."
msgid ""
"This option enables support for exposing logical devices to the operating "
"system before physical devices.  The default value is 0."
msgstr ""
"このオプションは、一つのテープに複数パーティションを置くことを サポートするか"
"どうかを決める。 このオプションはドライブにリンクされた全てのデバイスに適用さ"
"れる。"

#. type: TP
#: build/C/man4/smartpqi.4:101
#, no-wrap
msgid "B<hide_vsep=>{B<0>|B<1>}"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:106
msgid ""
"This option enables disabling exposure of the virtual SEP to the host.  This "
"is usually associated with direct attached drives.  The default value is 0."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:120
msgid ""
"Logical drives are accessed via the SCSI disk driver (I<sd>), tape drives "
"via the SCSI tape driver (I<st>), and the RAID controller via the SCSI "
"generic driver (I<sg>), with device nodes named I</dev/sd>*, I</dev/st>*, "
"and I</dev/sg>*, respectively."
msgstr ""

#. type: SS
#: build/C/man4/smartpqi.4:120
#, no-wrap
msgid "SmartPQI-specific host attribute files in \\f[BI]/sys\\fB"
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:121
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</rescan>"
msgstr " I</sys/class/scsi_host/host>*I</rescan>"

#. type: Plain text
#: build/C/man4/smartpqi.4:134
msgid ""
"The host I<rescan> attribute is a write-only attribute.  Writing to this "
"attribute will cause the driver to scan for new, changed, or removed devices "
"(e.g., hot-plugged tape drives, or newly configured or deleted logical "
"drives) and notify the SCSI mid-layer of any changes detected.  Usually this "
"action is triggered automatically by configuration changes, so the user "
"should not normally have to write to this file.  Doing so may be useful when "
"hot-plugging devices such as tape drives or entire storage boxes containing "
"pre-configured logical drives."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:134
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</version>"
msgstr " I</sys/class/scsi_host/host>*I</version>"

#. type: Plain text
#: build/C/man4/smartpqi.4:141
msgid ""
"The host I<version> attribute is a read-only attribute.  This attribute "
"contains the driver version and the controller firmware version."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:150
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/version>\n"
"driver: 1.1.2-126\n"
"firmware: 1.29-112\n"
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:152
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</lockup_action>"
msgstr " I</sys/class/scsi_host/host>*I</lockup_action>"

#. type: Plain text
#: build/C/man4/smartpqi.4:165
msgid ""
"The host I<lockup_action> attribute is a read/write attribute.  This "
"attribute will cause the driver to perform a specific action in the unlikely "
"event that a controller lockup has been detected.  See B<OPTIONS> above for "
"an explanation of the I<lockup_action> values."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:165
#, no-wrap
msgid "I</sys/class/scsi_host/host*/driver_version>"
msgstr " I</sys/class/scsi_host/host*/driver_version>"

#. type: Plain text
#: build/C/man4/smartpqi.4:171
msgid ""
"The I<driver_version> attribute is read-only.  This attribute contains the "
"smartpqi driver version."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:179
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/driver_version>\n"
"1.1.2-126\n"
msgstr ""
" $ B<cat /sys/class/scsi_host/host1/driver_version>\n"
"1.1.2-126\n"

#. type: TP
#: build/C/man4/smartpqi.4:181
#, no-wrap
msgid "I</sys/class/scsi_host/host*/firmware_version>"
msgstr " I</sys/class/scsi_host/host*/firmware_version>"

#. type: Plain text
#: build/C/man4/smartpqi.4:187
msgid ""
"The I<firmware_version> attribute is read-only.  This attribute contains the "
"controller firmware version."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:195
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/firmware_version>\n"
"1.29-112\n"
msgstr ""
" $ B<cat /sys/class/scsi_host/host1/firmware_version>\n"
"1.29-112\n"

#. type: TP
#: build/C/man4/smartpqi.4:197
#, no-wrap
msgid "I</sys/class/scsi_host/host*/model>"
msgstr " I</sys/class/scsi_host/host*/model>"

#. type: Plain text
#: build/C/man4/smartpqi.4:203
msgid ""
"The I<model> attribute is read-only.  This attribute contains the product "
"identification string of the controller."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:211
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/model>\n"
"1100-16i\n"
msgstr ""
" $ B<cat /sys/class/scsi_host/host1/model>\n"
"1100-16i\n"

#. type: TP
#: build/C/man4/smartpqi.4:213
#, no-wrap
msgid "I</sys/class/scsi_host/host*/serial_number>"
msgstr " I</sys/class/scsi_host/host*/serial_number>"

#. type: Plain text
#: build/C/man4/smartpqi.4:219
msgid ""
"The I<serial_number> attribute is read-only.  This attribute contains the "
"unique identification number of the controller."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:227
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/serial_number>\n"
"6A316373777\n"
msgstr ""
" $ B<cat /sys/class/scsi_host/host1/serial_number>\n"
"6A316373777\n"

#. type: TP
#: build/C/man4/smartpqi.4:229
#, no-wrap
msgid "I</sys/class/scsi_host/host*/vendor>"
msgstr " I</sys/class/scsi_host/host*/vendor>"

#. type: Plain text
#: build/C/man4/smartpqi.4:235
msgid ""
"The I<vendor> attribute is read-only.  This attribute contains the vendor "
"identification string of the controller."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:243
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/vendor>\n"
"Adaptec\n"
msgstr ""
" $ B<cat /sys/class/scsi_host/host1/vendor>\n"
"Adaptec\n"

#. type: SS
#: build/C/man4/smartpqi.4:245
#, no-wrap
msgid "SmartPQI-specific disk attribute files in \\f[BI]/sys\\fB"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:255
msgid ""
"In the file specifications below, I<c> stands for the number of the "
"appropriate SCSI controller, I<b> is the bus number, I<t> the target number, "
"and I<l> is the logical unit number (LUN)."
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:255
#, no-wrap
msgid "I</sys/class/scsi_disk/>cI<:>bI<:>tI<:>lI</device/raid_level>"
msgstr " I</sys/class/scsi_disk/>cI<:>bI<:>tI<:>lI</device/raid_level>"

#. type: Plain text
#: build/C/man4/smartpqi.4:261
msgid ""
"The I<raid_level> attribute is read-only.  This attribute contains the RAID "
"level of each logical drive."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:269
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/4:0:0:0/device/raid_level>\n"
"RAID 0\n"
msgstr ""
" $ B<cat /sys/class/scsi_disk/4:0:0:0/device/raid_level>\n"
"RAID 0\n"

#. type: TP
#: build/C/man4/smartpqi.4:271
#, no-wrap
msgid "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/sas_address>"
msgstr " I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/sas_address>"

#. type: Plain text
#: build/C/man4/smartpqi.4:277
msgid ""
"The I<sas_address> attribute is read-only.  This attribute contains the "
"unique identifier of the disk."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:285
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/sas_address>\n"
"0x5001173d028543a2\n"
msgstr ""

#. type: TP
#: build/C/man4/smartpqi.4:287
#, no-wrap
msgid "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/ssd_smart_path_enabled>"
msgstr " I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/ssd_smart_path_enabled>"

#. type: Plain text
#: build/C/man4/smartpqi.4:299
msgid ""
"The I<ssd_smart_path_enabled> attribute is read-only.  This attribute is for "
"ioaccel-enabled volumes.  (Ioaccel is an alternative driver submission path "
"that allows the driver to send I/O requests directly to backend SCSI "
"devices, bypassing the controller firmware.  This results in an increase in "
"performance.  This method is used for HBA disks and for logical volumes "
"comprised of SSDs.)  Contains 1 if ioaccel is enabled for the volume and 0 "
"otherwise."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:307
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/ssd_smart_path_enabled>\n"
"0\n"
msgstr ""
" $ B<cat /sys/class/scsi_disk/1:0:3:0/device/ssd_smart_path_enabled>\n"
"0\n"

#. type: Plain text
#: build/C/man4/smartpqi.4:313
msgid "The B<smartpqi> driver was added in Linux 4.9."
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:320
msgid ""
"To configure a Microsemi Smart Family controller, refer to the User Guide "
"for the controller, which can be found by searching for the specific "
"controller at E<.UR https://storage.microsemi.com/> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man4/smartpqi.4:325
msgid "B<cciss>(4), B<hpsa>(4), B<sd>(4), B<st>(4)"
msgstr " B<cciss>(4), B<hpsa>(4), B<sd>(4), B<st>(4)"

#. type: Plain text
#: build/C/man4/smartpqi.4:328
msgid ""
"I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss> in the Linux kernel "
"source tree."
msgstr "Linux カーネルのソースツリーの I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss>。"

#. type: TH
#: build/C/man4/veth.4:28
#, no-wrap
msgid "VETH"
msgstr "VETH"

#. type: Plain text
#: build/C/man4/veth.4:31
msgid "veth - Virtual Ethernet Device"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:38
msgid ""
"The B<veth> devices are virtual Ethernet devices.  They can act as tunnels "
"between network namespaces to create a bridge to a physical network device "
"in another namespace, but can also be used as standalone network devices."
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:42
msgid ""
"B<veth> devices are always created in interconnected pairs.  A pair can be "
"created using the command:"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:46
#, no-wrap
msgid "# ip link add E<lt>p1-nameE<gt> type veth peer name E<lt>p2-nameE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:54
msgid ""
"In the above, I<p1-name> and I<p2-name> are the names assigned to the two "
"connected end points."
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:58
msgid ""
"Packets transmitted on one device in the pair are immediately received on "
"the other device.  When either devices is down the link state of the pair is "
"down."
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:69
msgid ""
"B<veth> device pairs are useful for combining the network facilities of the "
"kernel together in interesting ways.  A particularly interesting use case is "
"to place one end of a B<veth> pair in one network namespace and the other "
"end in another network namespace, thus allowing communication between "
"network namespaces.  To do this, one can provide the B<netns> parameter when "
"creating the interfaces:"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:73
#, no-wrap
msgid "# ip link add E<lt>p1-nameE<gt> netns E<lt>p1-nsE<gt> type veth peer E<lt>p2-nameE<gt> netns E<lt>p2-nsE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:79
msgid "or, for an existing B<veth> pair, move one side to the other namespace:"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:83
#, no-wrap
msgid "# ip link set E<lt>p2-nameE<gt> netns E<lt>p2-nsE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:90
msgid ""
"B<ethtool>(8)  can be used to find the peer of a B<veth> network interface, "
"using commands something like:"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:99
#, no-wrap
msgid ""
"# B<ip link add ve_A type veth peer name ve_B>   # Create veth pair\n"
"# B<ethtool -S ve_A>         # Discover interface index of peer\n"
"NIC statistics:\n"
"     peer_ifindex: 16\n"
"# B<ip link | grep \\(aq\\(ha16:\\(aq>   # Look up interface\n"
"16: ve_B@ve_A: E<lt>BROADCAST,MULTICAST,M-DOWNE<gt> mtu 1500 qdisc ...\n"
msgstr ""

#. type: Plain text
#: build/C/man4/veth.4:108
msgid ""
"B<clone>(2), B<network_namespaces>(7), B<ip>(8), B<ip-link>(8), B<ip-"
"netns>(8)"
msgstr " B<clone>(2), B<network_namespaces>(7), B<ip>(8), B<ip-link>(8), B<ip-netns>(8)"

#~ msgid "console - console terminal and virtual consoles"
#~ msgstr ""
#~ "console - コンソール端末 (console terminal) と仮想コンソール (virtual "
#~ "console)"

#~ msgid ""
#~ "A Linux system has up to 63 I<virtual consoles> (character devices with "
#~ "major number 4 and minor number 1 to 63), usually called I</dev/ttyn> "
#~ "with 1 \\(E<lt>= I<n> \\(E<lt>= 63.  The current console is also "
#~ "addressed by I</dev/console> or I</dev/tty0>, the character device with "
#~ "major number 4 and minor number 0.  The device files I</dev/*> are "
#~ "usually created using the script MAKEDEV, or using B<mknod>(1), usually "
#~ "with mode 0622 and owner I<root.tty>."
#~ msgstr ""
#~ "Linux システムは普通、I</dev/ttyn> (n は 1 \\(E<lt>= I<n> \\(E<lt>= 63) と"
#~ "呼ばれるI<仮想コンソール> (メジャーナンバー (major number)  4 マイナーナン"
#~ "バー (minor number) 1 から 63 のキャラクターデバイス (character device)) "
#~ "を持つ。 現在のコンソールは I</dev/console> または I</dev/tty0> (メジャー "
#~ "ナンバー 4 マイナーナンバー 0 のキャラクターデバイス) によっても扱える。 "
#~ "デバイスファイル (device file) I</dev/*> は普通 MAKEDEV スクリプトまたは "
#~ "B<mknod>(1)  を使ってモード 0622、所有者 I<root.tty> として作成される。"

#~ msgid ""
#~ "Before kernel version 1.1.54 the number of virtual consoles was compiled "
#~ "into the kernel (in I<tty.h>: #define NR_CONSOLES 8)  and could be "
#~ "changed by editing and recompiling.  Since version 1.1.54 virtual "
#~ "consoles are created on the fly, as soon as they are needed."
#~ msgstr ""
#~ "カーネル (kernel) バージョン 1.1.54 以前は、仮想コンソールの数はコンパイル"
#~ "時に (I<tty.h> 中の : #define NR_CONSOLES 8 によって) カーネルに埋め込まれ"
#~ "ていた。 そして、それを変更してコンパイルし直すことで仮想コンソールの数を"
#~ "変更できた。 カーネルバージョン 1.1.54 以降では仮想コンソールが必要とされ"
#~ "る時は すぐに動作中に作成される。"

#~ msgid ""
#~ "Common ways to start a process on a console are: (a) tell B<init>(1)  (in "
#~ "B<inittab>(5))  to start a B<mingetty>(8)  (or B<agetty>(8))  on the "
#~ "console; (b) ask B<openvt>(1)  to start a process on the console; (c) "
#~ "start X\\(emit will find the first unused console, and display its output "
#~ "there.  (There is also the ancient B<doshell>(8).)"
#~ msgstr ""
#~ "コンソール上でプロセスを開始する一般的な方法は: (a) コンソール上で "
#~ "B<mingetty>(8)  (または B<agetty>(8))  をスタートさせることを "
#~ "(B<inittab>(5)  の中で)  B<init>(1)  に伝える。 (b) コンソール上でプロセス"
#~ "をスタートすることを B<openvt>(1)  に頼む。 (c) X を開始する - X は使われ"
#~ "ていないコンソールのうち最初のものを見付け、 そこに表示を出力する。(昔なが"
#~ "らの B<doshell>(8)  もある。)"

#~ msgid ""
#~ "Common ways to switch consoles are: (a) use Alt+FI<n> or Ctrl+Alt+FI<n> "
#~ "to switch to console I<n>; AltGr+FI<n> might bring you to console I<n>+12 "
#~ "[here Alt and AltGr refer to the left and right Alt keys, respectively]; "
#~ "(b) use Alt+RightArrow or Alt+LeftArrow to cycle through the presently "
#~ "allocated consoles; (c) use the program B<chvt>(1).  (The key mapping is "
#~ "user settable, see B<loadkeys>(1); the above mentioned key combinations "
#~ "are according to the default settings.)"
#~ msgstr ""
#~ "コンソールを切り替える一般的な方法は: (a)コンソール I<n> に切り替える ため"
#~ "に Alt+FI<n> または Ctrl+Alt+FI<n> を使う。 AltGr+FI<n> を使うと、おそらく"
#~ "コンソール I<n>+12 に切り替わる [ここでの Alt と AltGr はそれぞれ左右の "
#~ "Alt キーを示す]。 (b) 現在割り当てられているコンソールを循環するために "
#~ "Alt + 右矢印キー または Alt + 左矢印キーを使う。(c)  B<chvt>(1)  プログラ"
#~ "ムを使う (キーマッピングはユーザーがセットできる、 B<loadkeys>(1)  を見"
#~ "よ。 上で述べたキーバインドはデフォルトの設定によるものである)。"

#~ msgid ""
#~ "The command B<deallocvt>(1)  (formerly B<disalloc>)  will free the memory "
#~ "taken by the screen buffers for consoles that no longer have any "
#~ "associated process."
#~ msgstr ""
#~ "B<deallocvt>(1)  コマンド(以前は B<disalloc> という名前だった)は、 プロセ"
#~ "スに結びつけられていないコンソールの スクリーンバッファー (screen buffer) "
#~ "のために使われているメモリーを解放する。"

#~ msgid "Properties"
#~ msgstr "特性"

#~ msgid ""
#~ "Consoles carry a lot of state.  I hope to document that some other time.  "
#~ "The most important fact is that the consoles simulate vt100 terminals.  "
#~ "In particular, a console is reset to the initial state by printing the "
#~ "two characters ESC c.  All escape sequences can be found in "
#~ "B<console_codes>(4)."
#~ msgstr ""
#~ "コンソールは多くの状態をもっている。 私は、それについていつかドキュメント"
#~ "にしたいと考えている。 もっとも重要な事実はコンソールは vt100 端末を真似て"
#~ "いる (シミュレートしている) ということである。 コンソールは ESC c という二"
#~ "つの文字を印字する事によって、 初期状態にリセットされる。 エスケープシーケ"
#~ "ンス (escape sequences) については B<console_codes>(4)  で全て説明してあ"
#~ "る。"

#~ msgid "set normal intensity (ECMA-48 says \"doubly underlined\")"
#~ msgstr "通常の輝度にセット(ECMA-48 では \"doubly underlined\" と呼んでいる)。"

#~ msgid "set underscore on, set default foreground color"
#~ msgstr "下線表示に設定し、フォアグラウンドをデフォルトにセット。"

#~ msgid "console_ioctl - ioctls for console terminal and virtual consoles"
#~ msgstr "console_ioctl - コンソール端末と仮想コンソールの ioctl"

#~ msgid ""
#~ "The following Linux-specific B<ioctl>(2)  requests are supported.  Each "
#~ "requires a third argument, assumed here to be I<argp>."
#~ msgstr ""
#~ "次のような Linux 固有の B<ioctl>(2)  がサポートされている。 それぞれ3番目"
#~ "の引数が必要である、ここでは I<argp> とする。"

#~ msgid ""
#~ "Get state of LEDs.  I<argp> points to a I<char>.  The lower three bits of "
#~ "I<*argp> are set to the state of the LEDs, as follows:"
#~ msgstr ""
#~ "LED の状態を取得する。 I<argp> は I<char> のポインターである。 I<*argp> の"
#~ "下位 3 ビットに以下のように LED の状態がセットされる。"

#~ msgid "caps lock led"
#~ msgstr "キャピタルロック LED 点灯"

#~ msgid "num lock led"
#~ msgstr "ナンバーロック LED 点灯"

#~ msgid "scroll lock led"
#~ msgstr "スクロールロック LED 点灯"

#~ msgid ""
#~ "Set the LEDs.  The LEDs are set to correspond to the lower three bits of "
#~ "I<argp>.  However, if a higher order bit is set, the LEDs revert to "
#~ "normal: displaying the state of the keyboard functions of caps lock, num "
#~ "lock, and scroll lock."
#~ msgstr ""
#~ "LEDを点灯させる。LEDは I<argp> の下位 3 ビットに従い点灯される。 しかし、"
#~ "より高位のビットがセットされている時には、キャピタルロック、 ナンバーロッ"
#~ "ク、スクロールロックのキーボード機能の状態を表示する LED は 通常状態に戻"
#~ "る。"

#~ msgid ""
#~ "Before 1.1.54, the LEDs just reflected the state of the corresponding "
#~ "keyboard flags, and KDGETLED/KDSETLED would also change the keyboard "
#~ "flags.  Since 1.1.54 the LEDs can be made to display arbitrary "
#~ "information, but by default they display the keyboard flags.  The "
#~ "following two ioctls are used to access the keyboard flags."
#~ msgstr ""
#~ "カーネル 1.1.54 以前は、LED はそれぞれのキーボードフラグの状態を反映するだ"
#~ "けで、KDGETLED/KDSETLED もキーボードフラグを変更するだけであった。 カーネ"
#~ "ル 1.1.54 からは LED に任意の表示をすることができるようになったが、 デフォ"
#~ "ルトではキーボードフラグを表示する。 次に示す 2 つの ioctl はキーボードフ"
#~ "ラグにアクセスするのに用いられる。"

#~ msgid ""
#~ "Get keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> "
#~ "points to a char which is set to the flag state.  The low order three "
#~ "bits (mask 0x7) get the current flag state, and the low order bits of the "
#~ "next nibble (mask 0x70) get the default flag state.  (Since 1.1.54.)"
#~ msgstr ""
#~ "キャピタルロック、ナンバーロック、スクロールロックの(LED の表示では なく)"
#~ "キーボードフラグを得る。 I<argp> はフラグの状態がセットされる文字変数を指"
#~ "す。 (0x7)でマスクして得られる下位 3 ビットが現在のフラグの状態を示し、 "
#~ "(0x70)でマスクして得られる次の 3 ビットがデフォルトのフラグの状態を 示す。"
#~ "(カーネル 1.1.54以降)"

#~ msgid ""
#~ "Set keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> "
#~ "has the desired flag state.  The low order three bits (mask 0x7) have the "
#~ "flag state, and the low order bits of the next nibble (mask 0x70) have "
#~ "the default flag state.  (Since 1.1.54.)"
#~ msgstr ""
#~ "キャピタルロック、ナンバーロック、スクロールロックの(LED の表示ではなく)  "
#~ "キーボードフラグをセットする。 I<argp> がセットしたいフラグである。 (0x7)"
#~ "でマスクして得られる下位 3 ビットがフラグの状態で、(0x70)でマスクして 得ら"
#~ "れる次の 3 ビットがデフォルトのフラグの状態である。(カーネル 1.1.54以降)"

#~ msgid "Get keyboard type.  This returns the value KB_101, defined as 0x02."
#~ msgstr ""
#~ "キーボードの種類を得る。これは値 0x02 と定義されている KB_101を返す。"

#~ msgid "Add I/O port as valid.  Equivalent to I<ioperm(arg,1,1)>."
#~ msgstr ""
#~ "I/Oポートを有効な物として加える。これは I<ioperm(arg,1,1)> と等価である。"

#~ msgid "Delete I/O port as valid.  Equivalent to I<ioperm(arg,1,0)>."
#~ msgstr ""
#~ "I/Oポートを有効な物から外す。これは I<ioperm(arg,1,0)> と等価である。"

#~ msgid ""
#~ "Enable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, "
#~ "1)>."
#~ msgstr ""
#~ "ビデオボードへの I/O を可能にする。 これは I<ioperm(0x3b4, 0x3df-0x3b4+1, "
#~ "1)> と等価である。"

#~ msgid ""
#~ "Disable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, "
#~ "0)>."
#~ msgstr ""
#~ "ビデオボードへの I/O を不可能にする。 これは I<ioperm(0x3b4, "
#~ "0x3df-0x3b4+1, 0)> と等価である。"

#~ msgid "Set text/graphics mode.  I<argp> is one of these:"
#~ msgstr ""
#~ "テキスト/グラフィクスモードを設定する。 I<argp> は次のうちのどれか："

#~ msgid ""
#~ "Get text/graphics mode.  I<argp> points to a I<long> which is set to one "
#~ "of the above values."
#~ msgstr ""
#~ "テキスト/グラフィクスモードを取得する。 I<argp> が指す I<long> 型変数に 上"
#~ "述の値のどちらかがセットされる。"

#~ msgid ""
#~ "Generate tone of specified length.  The lower 16 bits of I<argp> specify "
#~ "the period in clock cycles, and the upper 16 bits give the duration in "
#~ "msec.  If the duration is zero, the sound is turned off.  Control returns "
#~ "immediately.  For example, I<argp> = (125E<lt>E<lt>16) + 0x637 would "
#~ "specify the beep normally associated with a ctrl-G.  (Thus since 0.99pl1; "
#~ "broken in 2.1.49-50.)"
#~ msgstr ""
#~ "指定された長さのトーンを発生する。 I<argp> の下位 16 ビットはクロックサイ"
#~ "クルを単位にして周期を指定し、 上位 16 ビットが msec の単位で表した、(トー"
#~ "ンを発生させる)時間を指定する。 トーンを発生させる時間がゼロのときは、サウ"
#~ "ンドはオフになる。 制御は直ちに戻る。 例えば、I<argp> = (125E<lt>E<lt>16) "
#~ "+ 0x637 とすれば、通常 ctrl-G を押した時に 発生する音になる。 (カーネル "
#~ "0.99pl1 以降;この機能は カーネル 2.1.49 から 2.1.50 ではバグのため動作しな"
#~ "い)"

#~ msgid ""
#~ "Start or stop sound generation.  The lower 16 bits of I<argp> specify the "
#~ "period in clock cycles (that is, I<argp> = 1193180/frequency).  I<argp> = "
#~ "0 turns sound off.  In either case, control returns immediately."
#~ msgstr ""
#~ "音の発生の開始や停止を行う。 I<argp> の下位 16 ビットはクロックサイクルを"
#~ "単位として周期を示す。 (つまり I<argp> = 1193180/周波数)。 I<argp> = 0 の"
#~ "場合、サウンドはオフになる。 どちらの場合でも、ただちに制御は戻る。"

#~ msgid ""
#~ "Get the current default color map from kernel.  I<argp> points to a 48-"
#~ "byte array.  (Since 1.3.3.)"
#~ msgstr "現在のデフォルトのカラーマップをカーネルより取得する。"

#~ msgid ""
#~ "Change the default text-mode color map.  I<argp> points to a 48-byte "
#~ "array which contains, in order, the Red, Green, and Blue values for the "
#~ "16 available screen colors: 0 is off, and 255 is full intensity.  The "
#~ "default colors are, in order: black, dark red, dark green, brown, dark "
#~ "blue, dark purple, dark cyan, light grey, dark grey, bright red, bright "
#~ "green, yellow, bright blue, bright purple, bright cyan and white.  (Since "
#~ "1.3.3.)"
#~ msgstr ""
#~ "デフォルトのテキストモードのカラーマップを変更する。 I<argp> が指す 48 バ"
#~ "イトの配列中には、16 の可能なスクリーンの色を、 赤、緑、青の順に 0 をオ"
#~ "フ、255を最大強度とした値として納める。 デフォルトの色は順に、黒、濃い赤、"
#~ "濃い緑、茶、濃い青、濃い紫、濃いシアン、 明るい灰色、濃い灰色、明るい赤、"
#~ "明るい緑、黄、明るい青、明るい紫、 明るいシアン、白である。(カーネル 1.3.3"
#~ "以降)"

#~ msgid ""
#~ "Gets 256-character screen font in expanded form.  I<argp> points to an "
#~ "8192 byte array.  Fails with error code B<EINVAL> if the currently loaded "
#~ "font is a 512-character font, or if the console is not in text mode."
#~ msgstr ""
#~ "拡張された形式で 256 文字のスクリーンフォントを得る。 I<argp> は 8192 バイ"
#~ "トの配列を指す。 現在ロードされているフォントが 512 文字のフォントである"
#~ "か、コンソールが テキストモードでない時には失敗し B<EINVAL> のエラーコード"
#~ "を返す。"

#~ msgid ""
#~ "Gets screen font and associated information.  I<argp> points to a "
#~ "I<struct consolefontdesc> (see B<PIO_FONTX>).  On call, the I<charcount> "
#~ "field should be set to the maximum number of characters that would fit in "
#~ "the buffer pointed to by I<chardata>.  On return, the I<charcount> and "
#~ "I<charheight> are filled with the respective data for the currently "
#~ "loaded font, and the I<chardata> array contains the font data if the "
#~ "initial value of I<charcount> indicated enough space was available; "
#~ "otherwise the buffer is untouched and I<errno> is set to B<ENOMEM>.  "
#~ "(Since 1.3.1.)"
#~ msgstr ""
#~ "スクリーンフォントとそれに関連した情報を取得する。 I<argp> は構造体 "
#~ "consolefontdesc (B<PIO_FONTX> を参照のこと)を指す。 関数呼び出しのときに"
#~ "は、I<charcount> には、I<chardata> が指す バッファーにおさまる最大の文字数"
#~ "をセットしなければならない。 関数呼び出しから戻った時には I<charcount> と "
#~ "I<charheight> には、 現在ロードされているフォントの該当するデータが収めら"
#~ "れている。 配列 I<chardata> には、最初に I<charcount> にいれた値によって "
#~ "フォントを収めるのに十分なスペースがあるとわかればフォントデータが収められ"
#~ "る。 そうでない時には、バッファーは変更されず、 I<errno> に B<ENOMEM> が "
#~ "セットされる(カーネル 1.3.1 以降)。"

#~ msgid ""
#~ "Sets 256-character screen font.  Load font into the EGA/VGA character "
#~ "generator.  I<argp> points to a 8192 byte map, with 32 bytes per "
#~ "character.  Only the first I<N> of them are used for an 8xI<N> font (0 "
#~ "E<lt> I<N> E<lt>= 32).  This call also invalidates the Unicode mapping."
#~ msgstr ""
#~ "256 文字のフォントをセットする。EGA/VGA キャラクタージェネレーター "
#~ "(character generator) にフォントをロードする。 I<argp> は、8192 バイト(一"
#~ "文字 32 バイト)のマップを指す。 マップのうち、最初の I<N> のみが 8xI<N> の"
#~ "フォントのために 用いられる(0 E<lt> I<N> E<lt>= 32)。 この呼び出しをする"
#~ "と Unicode のマッピングが無効になる。"

#~ msgid ""
#~ "Sets screen font and associated rendering information.  I<argp> points to "
#~ "a"
#~ msgstr ""
#~ "スクリーンフォントと、それに関連するレンダリング情報をセットする。 "
#~ "I<argp> は、以下の構造体を指す。"

#~ msgid ""
#~ "struct consolefontdesc {\n"
#~ "    unsigned short charcount;  /* characters in font\n"
#~ "                                  (256 or 512) */\n"
#~ "    unsigned short charheight; /* scan lines per\n"
#~ "                                  character (1-32) */\n"
#~ "    char          *chardata;   /* font data in\n"
#~ "                                  expanded form */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct consolefontdesc {\n"
#~ "    unsigned short charcount;  /* フォントの文字数\n"
#~ "                                  (256 または 512) */\n"
#~ "    unsigned short charheight; /* 一文字の走査線の数\n"
#~ "                                  (1-32) */\n"
#~ "    char          *chardata;   /* 展開されたフォントデータ */\n"
#~ "};\n"

#~ msgid ""
#~ "If necessary, the screen will be appropriately resized, and B<SIGWINCH> "
#~ "sent to the appropriate processes.  This call also invalidates the "
#~ "Unicode mapping.  (Since 1.3.1.)"
#~ msgstr ""
#~ "必要ならスクリーンは適当にサイズ変更され、B<SIGWINCH> が適切な プロセスに"
#~ "送られる。 このコールにより Unicode のマッピングが無効になる。"

#~ msgid ""
#~ "Resets the screen font, size and Unicode mapping to the bootup defaults.  "
#~ "I<argp> is unused, but should be set to NULL to ensure compatibility with "
#~ "future versions of Linux.  (Since 1.3.28.)"
#~ msgstr ""
#~ "スクリーンフォント、サイズ、 Unicode マッピングをブート時のデフォルト値に "
#~ "リセットする。I<argp> は用いられないが、将来のバージョンの Linux との互換"
#~ "性を保つために NULL にセットすべきである。"

#~ msgid ""
#~ "Get screen mapping from kernel.  I<argp> points to an area of size "
#~ "E_TABSZ, which is loaded with the font positions used to display each "
#~ "character.  This call is likely to return useless information if the "
#~ "currently loaded font is more than 256 characters."
#~ msgstr ""
#~ "スクリーンマッピングをカーネルより取得する。I<argp> はサイズ E_TABSZ の 領"
#~ "域を指す。その領域には各キャラクターを表示するのに用いられるフォントの 位"
#~ "置がロードされている。 この呼び出しは現在ロードされているフォントが 256 文"
#~ "字よりも多い時には 無意味な情報を返す事が多い。"

#~ msgid ""
#~ "Get full Unicode screen mapping from kernel.  I<argp> points to an area "
#~ "of size I<E_TABSZ*sizeof(unsigned short)>, which is loaded with the "
#~ "Unicodes each character represent.  A special set of Unicodes, starting "
#~ "at U+F000, are used to represent \"direct to font\" mappings.  (Since "
#~ "1.3.1.)"
#~ msgstr ""
#~ "フル Unicode スクリーンマッピングをカーネルより取得する。 I<argp> はサイ"
#~ "ズ I<E_TABSZ*sizeof(unsigned short)> の領域を指す。 その領域には各キャラク"
#~ "ターを示す Unicode がロードされている。 U+F000 に始まる Unicode の特別な集"
#~ "合は、「フォント直接な (direct to font)」 マッピングを示すのに用いられる "
#~ "(カーネル 1.3.1 以降)。"

#~ msgid ""
#~ "Loads the \"user definable\" (fourth) table in the kernel which maps "
#~ "bytes into console screen symbols.  I<argp> points to an area of size "
#~ "E_TABSZ."
#~ msgstr ""
#~ "「ユーザー定義可能な(user definable)」(4番目の)テーブルをカーネルに ロード"
#~ "する。そのテーブルは各バイトをスクリーンシンボルにマッピングする。 "
#~ "I<argp> はサイズE_TABSZの領域を指す。"

#~ msgid ""
#~ "Loads the \"user definable\" (fourth) table in the kernel which maps "
#~ "bytes into Unicodes, which are then translated into screen symbols "
#~ "according to the currently loaded Unicode-to-font map.  Special Unicodes "
#~ "starting at U+F000 can be used to map directly to the font symbols.  "
#~ "(Since 1.3.1.)"
#~ msgstr ""
#~ "「ユーザー定義可能な」(4番目の)テーブルをカーネルにロードする。 そのテーブ"
#~ "ルは各バイトをユニコードにマッピングし、その後、 現在ロードされているユニ"
#~ "コードからフォントへのマップに従い スクリーンシンボルに変換される。 U"
#~ "+F000 に始まるユニコードは直接フォントシンボルにマッピングするのに 使える"
#~ "(カーネル 1.3.1 以降)"

#~ msgid "Get Unicode-to-font mapping from kernel.  I<argp> points to a"
#~ msgstr ""
#~ "Unicode からフォントへのマッピングをカーネルから取得する。 I<argp> は、"

#~ msgid "where I<entries> points to an array of"
#~ msgstr ""
#~ "という構造体を指す。 ここで I<entries> は以下の構造体の配列へのポインター"
#~ "である。"

#~ msgid ""
#~ "Put unicode-to-font mapping in kernel.  I<argp> points to a I<struct "
#~ "unimapdesc>.  (Since 1.1.92)"
#~ msgstr ""
#~ "Unicode からフォントへのマッピングをカーネルにセットする。 I<argp> は構造"
#~ "体 I<struct unimapdesc> へのポインターである。 (カーネル 1.1.92 以降)"

#~ msgid "Clear table, possibly advise hash algorithm.  I<argp> points to a"
#~ msgstr "テーブルをクリアし、その事をハシュアルゴリズムに伝える。 I<argp>は"

#~ msgid ""
#~ "Gets current keyboard mode.  I<argp> points to a I<long> which is set to "
#~ "one of these:"
#~ msgstr ""
#~ "現在のキーボードモードを取得する。I<argp> の指す I<long> 型変数が、 次のう"
#~ "ちのどれかに設定される。"

#~ msgid ""
#~ "Sets current keyboard mode.  I<argp> is a I<long> equal to one of the "
#~ "above values."
#~ msgstr ""
#~ "現在のキーボードモードを設定する。 I<argp> は上記の値のうちのどれかに等し"
#~ "い I<long> にする。"

#~ msgid ""
#~ "Gets meta key handling mode.  I<argp> points to a I<long> which is set to "
#~ "one of these:"
#~ msgstr ""
#~ "メタキーハンドリングモード(meta key handling mode)を取得する。 I<argp> が"
#~ "指す I<long> 型変数は、次のうちのどれかに設定される。"

#~ msgid "set high order bit"
#~ msgstr "上位ビットをセット"

#~ msgid "escape prefix"
#~ msgstr "エスケーププレフィックス"

#~ msgid ""
#~ "Sets meta key handling mode.  I<argp> is a I<long> equal to one of the "
#~ "above values."
#~ msgstr ""
#~ "メタキーハンドリングモードを設定する。 I<argp> は上記の値のどれかに等しい "
#~ "I<long> にする。"

#~ msgid ""
#~ "Gets one entry in key translation table (keycode to action code).  "
#~ "I<argp> points to a"
#~ msgstr ""
#~ "キーコードをアクションコードに変換するキー変換表のエントリーの一つを 取得"
#~ "する。 I<argp> は、"

#~ msgid ""
#~ "with the first two members filled in: I<kb_table> selects the key table "
#~ "(0 E<lt>= I<kb_table> E<lt> MAX_NR_KEYMAPS), and I<kb_index> is the "
#~ "keycode (0 E<lt>= I<kb_index> E<lt> NR_KEYS).  I<kb_value> is set to the "
#~ "corresponding action code, or K_HOLE if there is no such key, or "
#~ "K_NOSUCHMAP if I<kb_table> is invalid."
#~ msgstr ""
#~ "へのポインターである。 最初の2つの要素、I<kb_table> には選択するキーテーブ"
#~ "ル (0 E<lt>= I<kb_table> E<lt> MAX_NR_KEYMAPS)、I<kb_index> にはキーコード"
#~ "(0 E<lt>= I<kb_index> E<lt> NR_KEYS)を設定する。 I<kb_value> は対応するア"
#~ "クションコード、または、そのようなキーが ないときには K_HOLE、I<kb_table> "
#~ "が無効な時には K_NOSUCHMAP に設定される。"

#~ msgid ""
#~ "Sets one entry in translation table.  I<argp> points to a I<struct "
#~ "kbentry>."
#~ msgstr ""
#~ "変換テーブルのエントリーの一つを設定する。I<argp> は 構造体 I<struct "
#~ "kbentry> へのポインターである。"

#~ msgid "Gets one function key string.  I<argp> points to a"
#~ msgstr ""
#~ "ファンクションキーの文字列を取得する。I<argp> は 以下の構造体へのポイン"
#~ "ターである。"

#~ msgid ""
#~ "I<kb_string> is set to the (null-terminated) string corresponding to the "
#~ "I<kb_func>th function key action code."
#~ msgstr ""
#~ "I<kb_func> 番目のファンクションキーのアクションコードに対応する (ヌルで終"
#~ "端された) 文字列が I<kb_string> に設定される。"

#~ msgid ""
#~ "Sets one function key string entry.  I<argp> points to a I<struct "
#~ "kbsentry>."
#~ msgstr ""
#~ "ファンクションキーの文字列のエントリーを設定する。I<argp> は、 構造体 "
#~ "I<struct kbsentry> へのポインターである。"

#~ msgid "Read kernel accent table.  I<argp> points to a"
#~ msgstr ""
#~ "カーネルのアクセントテーブル(accent table)を読み込む。I<argp>は、 次の構造"
#~ "体へのポインターである。"

#~ msgid ""
#~ "where I<kb_cnt> is the number of entries in the array, each of which is a"
#~ msgstr ""
#~ "ここで、I<kb_cnt> は配列中のエントリーの個数で、個々のエントリーは 以下の"
#~ "構造体である。"

#~ msgid ""
#~ "Read kernel keycode table entry (scan code to keycode).  I<argp> points "
#~ "to a"
#~ msgstr ""
#~ "カーネルの(スキャンコードからキーコードへ 変換する)キーコードテーブルエン"
#~ "トリーを読み込む。 I<argp> は、"

#~ msgid ""
#~ "I<keycode> is set to correspond to the given I<scancode>.  (89 E<lt>= "
#~ "I<scancode> E<lt>= 255 only.  For 1 E<lt>= I<scancode> E<lt>= 88, "
#~ "I<keycode>==I<scancode>.)  (Since 1.1.63.)"
#~ msgstr ""
#~ "へのポインターである。 I<keycode> は、I<scancode> に対応した値に設定され"
#~ "る。(ただし、89 E<lt>= I<scancode> E<lt>= 255 のみについて。1 E<lt>= "
#~ "I<scancode> E<lt>= 88 では I<keycode> == I<scancode> である。)  (カーネル "
#~ "1.1.63 以降)"

#~ msgid ""
#~ "Write kernel keycode table entry.  I<argp> points to a I<struct "
#~ "kbkeycode>.  (Since 1.1.63.)"
#~ msgstr ""
#~ "カーネルのキーコードテーブルエントリーを書き込む。I<argp> は構造体 "
#~ "I<struct kbkeycode> へのポインターである。 (カーネル 1.1.63 以降)"

#~ msgid ""
#~ "The calling process indicates its willingness to accept the signal "
#~ "I<argp> when it is generated by pressing an appropriate key combination.  "
#~ "(1 E<lt>= I<argp> E<lt>= NSIG).  (See I<spawn_console>()  in I<linux/"
#~ "drivers/char/keyboard.c>.)"
#~ msgstr ""
#~ "この関数呼び出しは、特別な組合せでキーを押した時に発生するシグナル "
#~ "I<argp> (1 E<lt>= I<argp> E<lt>= NSIG) を進んで受け付けるかどうかを示す。 "
#~ "(I<linux/drivers/char/keyboard.c> の I<spawn_console>() を見よ。)"

#~ msgid ""
#~ "Returns the first available (non-opened) console.  I<argp> points to an "
#~ "I<int> which is set to the number of the vt (1 E<lt>= I<*argp> E<lt>= "
#~ "MAX_NR_CONSOLES)."
#~ msgstr ""
#~ "最初の空いている(まだオープンされていない)コンソールを返す。 I<argp> の指"
#~ "す I<int> 型の整数には、vt の番号がセットされる (1 E<lt>= I<*argp> E<lt>= "
#~ "MAX_NR_CONSOLES)。"

#~ msgid "Get mode of active vt.  I<argp> points to a"
#~ msgstr "アクティブな vt のモードを取得する。 I<argp> は、"

#~ msgid ""
#~ "which is set to the mode of the active vt.  I<mode> is set to one of "
#~ "these values:"
#~ msgstr ""
#~ "という構造体を指すポインターであり、 アクティブな vt のモードがセットされ"
#~ "る。 I<mode> は次のどれかに設定される。"

#~ msgid "auto vt switching"
#~ msgstr "自動 vt 切替"

#~ msgid "process controls switching"
#~ msgstr "プロセス制御切替"

#~ msgid "acknowledge switch"
#~ msgstr "アクノリッジ切替"

#~ msgid "Set mode of active vt.  I<argp> points to a I<struct vt_mode>."
#~ msgstr ""
#~ "アクティブな vt のモードを設定する。I<argp> は構造体 I<struct vt_mode> へ"
#~ "の ポインターである。"

#~ msgid "Get global vt state info.  I<argp> points to a"
#~ msgstr "グローバルな vt の状態の情報を取得する。I<argp>は、"

#~ msgid ""
#~ "For each vt in use, the corresponding bit in the I<v_state> member is "
#~ "set.  (Kernels 1.0 through 1.1.92.)"
#~ msgstr ""
#~ "へのポインターである。 使用されているそれぞれの vt につき I<v_state> の対"
#~ "応するビットが セットされる。 (カーネルl 1.0 から 1.1.92 まで)"

#~ msgid "Release a display."
#~ msgstr "ディスプレーを解放する。"

#~ msgid "Switch to vt I<argp> (1 E<lt>= I<argp> E<lt>= MAX_NR_CONSOLES)."
#~ msgstr "I<argp> (1 E<lt>= I<argp> E<lt>= MAX_NR_CONSOLES)の vt に切替える。"

#~ msgid "Wait until vt I<argp> has been activated."
#~ msgstr "I<argp>の vt がアクティブになるまで待つ。"

#~ msgid "Deallocate the memory associated with vt I<argp>.  (Since 1.1.54.)"
#~ msgstr ""
#~ "I<argp> の vt に結びつけられたメモリーを解放する。 (カーネル 1.1.54 以降)"

#~ msgid "Set the kernel's idea of screensize.  I<argp> points to a"
#~ msgstr "カーネルが認識するスクリーンサイズを設定する。I<argp> は、"

#~ msgid ""
#~ "Note that this does not change the videomode.  See B<resizecons>(8).  "
#~ "(Since 1.1.54.)"
#~ msgstr ""
#~ "へのポインターである。 これはビデオモードを変更しない事に注意。 "
#~ "B<resizecons>(8)  を見よ(カーネル 1.1.54 以降)。"

#~ msgid ""
#~ "Set the kernel's idea of various screen parameters.  I<argp> points to a"
#~ msgstr ""
#~ "カーネルが認識する各種のスクリーンパラメーターを設定する。I<argp> は、 以"
#~ "下の構造体へのポインターである。"

#~ msgid ""
#~ "Any parameter may be set to zero, indicating \"no change\", but if "
#~ "multiple parameters are set, they must be self-consistent.  Note that "
#~ "this does not change the videomode.  See B<resizecons>(8).  (Since 1.3.3.)"
#~ msgstr ""
#~ "パラメーターはゼロであってもよい。そのときは「変更しないこと」を 意味する"
#~ "が、複数のパラメーターが設定された時にはそれらの間で矛盾が ないようにしな"
#~ "ければならない。 この関数呼び出しによってもビデオモードは変更されない事に"
#~ "注意。 B<resizecons>(8)  を参照の事(カーネル 1.3.3 以降)。"

#~ msgid ""
#~ "The action of the following ioctls depends on the first byte in the "
#~ "struct pointed to by I<argp>, referred to here as the I<subcode>.  These "
#~ "are legal only for the superuser or the owner of the current terminal."
#~ msgstr ""
#~ "以下の ioctl がどのように動作をするかは、I<argp> が指す構造体の 最初のバイ"
#~ "ト(ここでは I<subcode> と呼ぶ)に依存する。 これらの呼出しは、スーパーユー"
#~ "ザーか現在の端末のオーナにのみ許される。"

#~ msgid ""
#~ "Dump the screen.  Disappeared in 1.1.92.  (With kernel 1.1.92 or later, "
#~ "read from I</dev/vcsN> or I</dev/vcsaN> instead.)"
#~ msgstr ""
#~ "スクリーンをダンプ(dump)する カーネル 1.1.92 以降でなくなった(1.1.92 以降"
#~ "では、代わりに I</dev/vcsN> または I</dev/vcsaN> より読み込む)。"

#~ msgid "Get task information.  Disappeared in 1.1.92."
#~ msgstr "タスク情報を取得する。カーネル 1.1.92 でなくなった。"

#~ msgid "Set selection.  I<argp> points to a"
#~ msgstr "選択を設定する。 I<argp> が指すのは、"

#~ msgid ""
#~ "I<xs> and I<ys> are the starting column and row.  I<xe> and I<ye> are the "
#~ "ending column and row.  (Upper left corner is row=column=1.)  I<sel_mode> "
#~ "is 0 for character-by-character selection, 1 for word-by-word selection, "
#~ "or 2 for line-by-line selection.  The indicated screen characters are "
#~ "highlighted and saved in the static array sel_buffer in I<devices/char/"
#~ "console.c>."
#~ msgstr ""
#~ "であり、ここで I<xs> と I<ys> は始めの桁と行で、I<xe> と I<ye> は終りの桁"
#~ "と 行である。 (左上の隅が 桁=行=1 )  I<sel_mode> は 0 が文字毎の選択で、1"
#~ "は語毎の選択、2は行毎の選択を 意味する。 示されたスクリーン上の文字はハイ"
#~ "ライト表示され I<devices/char/console.c> の 静的配列 sel_buffer に保存され"
#~ "る。"

#~ msgid ""
#~ "Paste selection.  The characters in the selection buffer are written to "
#~ "I<fd>."
#~ msgstr ""
#~ "選択したものをペーストする。 選択バッファー中の文字 が I<fd> に書き出され"
#~ "る。"

#~ msgid ""
#~ "Sets contents of a 256-bit look up table defining characters in a \"word"
#~ "\", for word-by-word selection.  (Since 1.1.32.)"
#~ msgstr ""
#~ "語毎の選択のための「語」中の文字を規定している 256 ビットのルックアップ "
#~ "テーブルの内容を設定する(カーネル 1.1.32 以降)。"

#~ msgid ""
#~ "I<argp> points to a char which is set to the value of the kernel variable "
#~ "I<shift_state>.  (Since 1.1.32.)"
#~ msgstr ""
#~ "I<argp> は文字変数を指すポインターで、その内容がカーネル変数 "
#~ "I<shift_state>の値に設定される(カーネル 1.1.32 以降)。"

#~ msgid ""
#~ "I<argp> points to a char which is set to the value of the kernel variable "
#~ "I<report_mouse>.  (Since 1.1.33.)"
#~ msgstr ""
#~ "I<argp> は文字変数を指すポインターで、その内容がカーネル変数 "
#~ "I<report_mouse> の値に設定される(カーネル 1.1.33 以降)。"

#~ msgid ""
#~ "Dump screen width and height, cursor position, and all the character-"
#~ "attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With kernel "
#~ "1.1.92 or later, read from I</dev/vcsa*> instead.)"
#~ msgstr ""
#~ "スクリーン幅、スクリーン高さ、カーソル位置、全ての文字属性の組をダンプす"
#~ "る (カーネル 1.1.67 から 1.1.91までのみ。 カーネル 1.1.92 以降では I</dev/"
#~ "vcsa*> より読み込む)。"

#~ msgid ""
#~ "Restore screen width and height, cursor position, and all the character-"
#~ "attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With kernel "
#~ "1.1.92 or later, write to I</dev/vcsa*> instead.)"
#~ msgstr ""
#~ "スクリーン幅、スクリーン高さ、カーソル位置、全ての文字属性の組を復元する "
#~ "(カーネル 1.1.67 から 1.1.91 までのみ。 カーネル 1.1.92 以降では I</dev/"
#~ "vcsa*> に書き込む)。"

#~ msgid ""
#~ "Handles the Power Saving feature of the new generation of monitors.  VESA "
#~ "screen blanking mode is set to I<argp[1]>, which governs what screen "
#~ "blanking does:"
#~ msgstr ""
#~ "新世代モニターのパワーセーブ機能を制御する。 VESA スクリーンブランキング"
#~ "モードが I<argp[1]>に設定される。 その値はスクリーンブランキングがどのよう"
#~ "に行われるかを示す。以下がその 値である。"

#~ msgid "Screen blanking is disabled."
#~ msgstr "スクリーンブランキングなし。"

#~ msgid ""
#~ "The current video adapter register settings are saved, then the "
#~ "controller is programmed to turn off the vertical synchronization "
#~ "pulses.  This puts the monitor into \"standby\" mode.  If your monitor "
#~ "has an Off_Mode timer, then it will eventually power down by itself."
#~ msgstr ""
#~ "現在のビデオアダプターレジスターが保存されたあと、 コントローラーは垂直同"
#~ "期パルスをオフにするようプログラムされる。 これにより モニターは「スタンバ"
#~ "イ」モードに入る。 モニターに Off_Mode タイマーが備わっておれば、 最終的に"
#~ "はモニターが自分で電源を落とす。"

#~ msgid ""
#~ "The current settings are saved, then both the vertical and horizontal "
#~ "synchronization pulses are turned off.  This puts the monitor into \"off"
#~ "\" mode.  If your monitor has no Off_Mode timer, or if you want your "
#~ "monitor to power down immediately when the blank_timer times out, then "
#~ "you choose this option.  (I<Caution:> Powering down frequently will "
#~ "damage the monitor.)  (Since 1.1.76.)"
#~ msgstr ""
#~ "現在の設定を保存した後、垂直、水平同期パルスがオフになる。 これによりモニ"
#~ "ターは「オフ」モードになる。 モニターに Off_Mode タイマーがない時、また"
#~ "は、blank_timer がタイムアウトしたらすぐにモニターの電源を落したいときにこ"
#~ "の選択肢を選ぶ。 (I<注意>：頻繁にモニターの電源を切るとモニターを痛め"
#~ "る。) (1.1.76 以降)"

#~ msgid ""
#~ "The file descriptor is not associated with a character special device, or "
#~ "the specified request does not apply to it."
#~ msgstr ""
#~ "ファイルディスクリプターがキャラクタースペシャルデバイスと関連付けられて "
#~ "いない。または、要求されたものがそれに当てはまらない。"

#~ msgid "The file descriptor or I<argp> is invalid."
#~ msgstr "ファイルディスクリプターまたは I<argp> が無効。"

#~ msgid "Insufficient permission."
#~ msgstr "権限が不十分。"

#~ msgid ""
#~ "B<Warning>: Do not regard this man page as documentation of the Linux "
#~ "console ioctls.  This is provided for the curious only, as an alternative "
#~ "to reading the source.  Ioctl's are undocumented Linux internals, liable "
#~ "to be changed without warning.  (And indeed, this page more or less "
#~ "describes the situation as of kernel version 1.1.94; there are many minor "
#~ "and not-so-minor differences with earlier versions.)"
#~ msgstr ""
#~ "B<警告>: このマニュアルページを Linux のコンソール ioctl を文書化したもの"
#~ "と思わない事。 これは、興味がある人がソースを読むことの代わりになるように"
#~ "用意した物である。 ioctl は文書化されない Linux の内部機能であって、警告な"
#~ "しに 変更されることがある。 (そして、このページはカーネル 1.1.94 のときの"
#~ "状況を記述した物で、それは 以前のバージョンと比べれば、多くの違いがある)"

#~ msgid ""
#~ "Very often, ioctls are introduced for communication between the kernel "
#~ "and one particular well-known program (fdisk, hdparm, setserial, tunelp, "
#~ "loadkeys, selection, setfont, etc.), and their behavior will be changed "
#~ "when required by this particular program."
#~ msgstr ""
#~ "ioctl はカーネルと、ある特定のよく知られたプログラムとの情報交換のために "
#~ "導入される事が非常に多い(fdisk, hdparm, setserial,tunelp, loadkeys, "
#~ "selection, setfont など)。そのため ioctl の動作は、その特定のプログラムが "
#~ "必要とした時には変更になる。"

#~ msgid ""
#~ "Programs using these ioctls will not be portable to other versions of "
#~ "UNIX, will not work on older versions of Linux, and will not work on "
#~ "future versions of Linux."
#~ msgstr ""
#~ "これらの ioctl を使ったプログラムは他のバージョンの UNIX との互換性が ない"
#~ "し、古いバージョンの Linux では、走らない。さらに将来のバージョンの Linux "
#~ "では走らなくなるかも知れない。"

#~ msgid "Use POSIX functions."
#~ msgstr "POSIX 機能を使いなさい。"

#~ msgid ""
#~ "The binary being executed by the process does not have read permission "
#~ "enabled."
#~ msgstr ""
#~ "プロセスが実行したバイナリファイルの読み出し許可が有効になっていない場合。"

#~ msgid "executable filename (without path prefix)"
#~ msgstr "実行ファイル名 (パス名のプレフィックスは含まれない)"

#~ msgid ""
#~ "A read from the I</dev/urandom> device will not block waiting for more "
#~ "entropy.  If there is not sufficient entropy, a pseudorandom number "
#~ "generator is used to create the requested bytes.  As a result, in this "
#~ "case the returned values are theoretically vulnerable to a cryptographic "
#~ "attack on the algorithms used by the driver.  Knowledge of how to do this "
#~ "is not available in the current unclassified literature, but it is "
#~ "theoretically possible that such an attack may exist.  If this is a "
#~ "concern in your application, use I</dev/random> instead.  B<O_NONBLOCK> "
#~ "has no effect when opening I</dev/urandom>.  When calling B<read>(2)  for "
#~ "device I</dev/urandom> signals will not be handled until after the "
#~ "requested random bytes have been generated."
#~ msgstr ""
#~ "I</dev/urandom> デバイスから読み出しでは、 エントロピーがより高くなるのを"
#~ "待つためのブロックは行われない。 十分なエントロピーがない場合、 要求された"
#~ "バイトを作成するのに疑似乱数生成器が使用される。 その結果、 この場合の返り"
#~ "値はこのドライバで使われているアルゴリズムに基づく暗号攻撃に対して、 論理"
#~ "的には弱くなることになる。 この攻撃をどのように行うかという事については、"
#~ "現在研究論文などの 形で入手できる資料はない、しかし、そのような攻撃は論理"
#~ "的に存在可能である。 もし、この事が心配なら、(I</dev/urandom> ではなく)  "
#~ "I</dev/random> を利用すればいい。 B<O_NONBLOCK> は I</dev/urandom> をオー"
#~ "プンする際には効果がない。 デバイス I</dev/urandom> に対して B<read>(2) を"
#~ "呼び出した際、 要求されたランダムバイトが生成されるまでシグナルは処理され"
#~ "ない。"

#~ msgid ""
#~ "If you are unsure about whether you should use I</dev/random> or I</dev/"
#~ "urandom>, then probably you want to use the latter.  As a general rule, "
#~ "I</dev/urandom> should be used for everything except long-lived GPG/SSL/"
#~ "SSH keys."
#~ msgstr ""
#~ "I</dev/random> と I</dev/urandom> のどちらを使うべきか迷った場合、たいてい"
#~ "は I</dev/urandom> の方を使いたいと思っているはずだろう。 一般に、長期に"
#~ "渡って使われる GPG/SSL/SSH のキー以外の全てのものに I</dev/urandom> を使用"
#~ "すべきである。"

#~ msgid ""
#~ "The kernel random-number generator is designed to produce a small amount "
#~ "of high-quality seed material to seed a cryptographic pseudo-random "
#~ "number generator (CPRNG).  It is designed for security, not speed, and is "
#~ "poorly suited to generating large amounts of random data.  Users should "
#~ "be very economical in the amount of seed material that they read from I</"
#~ "dev/urandom> (and I</dev/random>); unnecessarily reading large quantities "
#~ "of data from this device will have a negative impact on other users of "
#~ "the device."
#~ msgstr ""
#~ "カーネルの乱数ジェネレーターは、暗号疑似乱数ジェネレーター (Cryptographic "
#~ "pseudo-random number generator; CPRNG) の種として使用できる 高品質な乱数種"
#~ "の材料を少し生成するために設計されている。 これは速度ではなく安全性を重視"
#~ "して設計されており、 ランダムなデータを大量に生成するのには全くもって適し"
#~ "ていない。 ユーザーは I</dev/urandom> (と I</dev/random>)  から読み出す乱"
#~ "数種の材料の量をできるだけ節約すべきである。 このデバイスから不必要に大量"
#~ "のデータを読み出すと、このデバイスを使う 他のユーザーにマイナスの影響を与"
#~ "えてしまうだろう。"

#~ msgid ""
#~ "The amount of seed material required to generate a cryptographic key "
#~ "equals the effective key size of the key.  For example, a 3072-bit RSA or "
#~ "Diffie-Hellman private key has an effective key size of 128 bits (it "
#~ "requires about 2^128 operations to break) so a key generator only needs "
#~ "128 bits (16 bytes) of seed material from I</dev/random>."
#~ msgstr ""
#~ "暗号鍵を生成するのに必要な乱数種の材料の量は、鍵の実効サイズと同じであ"
#~ "る。 例えば、3072 ビットの RSA および Diffie-Hellman の秘密鍵の実効サイズ"
#~ "は 128 ビット (この秘密鍵を破るには 2^128 回の操作が必要ということ) であ"
#~ "り、 そのため鍵生成器が I</dev/random> から読み出す必要がある乱数種の材料"
#~ "の量は 128 ビット (16 バイト) だけである。"

#~ msgid ""
#~ "While some safety margin above that minimum is reasonable, as a guard "
#~ "against flaws in the CPRNG algorithm, no cryptographic primitive "
#~ "available today can hope to promise more than 256 bits of security, so if "
#~ "any program reads more than 256 bits (32 bytes) from the kernel random "
#~ "pool per invocation, or per reasonable reseed interval (not less than one "
#~ "minute), that should be taken as a sign that its cryptography is I<not> "
#~ "skillfully implemented."
#~ msgstr ""
#~ "CPRNG アルゴリズムの欠陥に対する保護として、この最小値に対していくらかの "
#~ "安全上のマージンを取るのはもっともだが、現在利用可能な暗号プリミティブで "
#~ "256 ビットより多くの安全な乱数を必要とするようなものはない。 起動する度"
#~ "に、もしくは乱数種を変更する妥当な間隔 (1 分より短くなることはない)  の度"
#~ "に、カーネルの乱数プールから 256 ビット (32 バイト) よりたくさん読み出す "
#~ "ような場合には、そのプログラムの暗号処理がうまく実装されて「いない」可能性"
#~ "が あると考えるべきであろう。"

#~ msgid "POSIX.1-2001.  Note that the description in POSIX.1-2001 is flawed."
#~ msgstr ""
#~ "POSIX.1-2001.  POSIX.1-2001 での説明には欠陥があることに注意すること。"

#~ msgid ""
#~ "These macros are I<not> compatible with the historic macros they "
#~ "replace.  A backward-compatible version can be found in the include file "
#~ "I<E<lt>varargs.hE<gt>>."
#~ msgstr ""
#~ "これらのマクロは、以前から用いられてきた同等のマクロ群と 互換ではI<ない>。"
#~ "過去のものと互換なバージョンは、 インクルードファイル I<E<lt>varargs."
#~ "hE<gt>> に存在する。"

#~ msgid "The historic setup is:"
#~ msgstr "歴史的なセットアップは以下のとおりである。"

#~ msgid ""
#~ "On some systems, I<va_end> contains a closing \\(aq}\\(aq matching a "
#~ "\\(aq{\\(aq in I<va_start>, so that both macros must occur in the same "
#~ "function, and in a way that allows this."
#~ msgstr ""
#~ "I<va_start> マクロに \\(aq}\\(aq を含み、 I<va_end> マクロに対応する "
#~ "\\(aq{\\(aq を含むシステムもあるので、 この二つのマクロは同じ関数になけれ"
#~ "ばならない。"

#~ msgid "/* The glibc interface */\n"
#~ msgstr "/* glibc のインターフェース */\n"

#~ msgid ""
#~ "The subsections below list the parameters used to set the values of "
#~ "I<option>,I< facility>, and I<priority>."
#~ msgstr ""
#~ "以下のサブセクションでは、 I<option> と I<facility> と I<priority> の値を"
#~ "設定するのに使用されるパラメーターを説明する。"

#~ msgid ""
#~ "Open the connection immediately (normally, the connection is opened when "
#~ "the first message is logged)."
#~ msgstr ""
#~ "ログ記録用プログラムとの接続を即座に開始する (通常は、最初のメッセージが記"
#~ "録される時に接続を開く)。"
