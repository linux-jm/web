# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-03-12 21:46+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/add_key.2:12
#, no-wrap
msgid "ADD_KEY"
msgstr "ADD_KEY"

#. type: TH
#: build/C/man2/add_key.2:12 build/C/man2/keyctl.2:28
#: build/C/man2/request_key.2:12
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man2/add_key.2:12 build/C/man2/keyctl.2:28
#: build/C/man2/request_key.2:12 build/C/man7/keyrings.7:12
#: build/C/man7/persistent-keyring.7:11 build/C/man7/process-keyring.7:11
#: build/C/man7/session-keyring.7:11 build/C/man7/thread-keyring.7:11
#: build/C/man7/user-keyring.7:11 build/C/man7/user-session-keyring.7:11
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/add_key.2:12 build/C/man2/keyctl.2:28
#: build/C/man2/request_key.2:12
#, no-wrap
msgid "Linux Key Management Calls"
msgstr "Linux Key Management Calls"

#. type: SH
#: build/C/man2/add_key.2:13 build/C/man2/keyctl.2:29
#: build/C/man2/request_key.2:13 build/C/man7/keyrings.7:13
#: build/C/man7/persistent-keyring.7:12 build/C/man7/process-keyring.7:12
#: build/C/man7/session-keyring.7:12 build/C/man7/thread-keyring.7:12
#: build/C/man7/user-keyring.7:12 build/C/man7/user-session-keyring.7:12
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/add_key.2:15
msgid "add_key - add a key to the kernel's key management facility"
msgstr "add_key - カーネルの鍵管理機能に鍵を追加する"

#. type: SH
#: build/C/man2/add_key.2:15 build/C/man2/keyctl.2:31
#: build/C/man2/request_key.2:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/add_key.2:19 build/C/man2/keyctl.2:35
#: build/C/man2/request_key.2:19
#, fuzzy, no-wrap
#| msgid "B<#include E<lt>keyutils.hE<gt>>\n"
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>keyutils.hE<gt>>\n"
msgstr "B<#include E<lt>keyutils.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/add_key.2:23
#, no-wrap
msgid ""
"B<key_serial_t add_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                     const void *>I<payload>B<, size_t >I<plen>B<,>\n"
"B<                     key_serial_t >I<keyring>B<);>\n"
msgstr ""
"B<key_serial_t add_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                     const void *>I<payload>B<, size_t >I<plen>B<,>\n"
"B<                     key_serial_t >I<keyring>B<);>\n"

#. type: Plain text
#: build/C/man2/add_key.2:26 build/C/man2/keyctl.2:49
#: build/C/man2/request_key.2:26
msgid "No glibc wrapper is provided for this system call; see NOTES."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:26 build/C/man2/keyctl.2:49
#: build/C/man2/request_key.2:26 build/C/man7/keyrings.7:15
#: build/C/man7/persistent-keyring.7:14 build/C/man7/process-keyring.7:14
#: build/C/man7/session-keyring.7:14 build/C/man7/thread-keyring.7:14
#: build/C/man7/user-keyring.7:14 build/C/man7/user-session-keyring.7:14
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/add_key.2:39
#, fuzzy
#| msgid ""
#| "B<add_key>()  asks the kernel to create or update a key of the given "
#| "I<type> and I<description>, instantiate it with the I<payload> of length "
#| "I<plen>, and to attach it to the nominated I<keyring> and to return its "
#| "serial number."
msgid ""
"B<add_key>()  creates or updates a key of the given I<type> and "
"I<description>, instantiates it with the I<payload> of length I<plen>, "
"attaches it to the nominated I<keyring>, and returns the key's serial number."
msgstr ""
"B<add_key>() は、 指定した I<type> と I<description> を持つ鍵の作成、更新を行"
"うようにカーネルに指示し、 長さ I<plen> の I<payload> で鍵を生成し、 指定され"
"た I<keyring> にその鍵を追加し、 鍵リングのシリアル番号を返す。"

#. type: Plain text
#: build/C/man2/add_key.2:42
#, fuzzy
#| msgid ""
#| "The key type may reject the data if it's in the wrong format or in some "
#| "other way invalid."
msgid ""
"The key may be rejected if the provided data is in the wrong format or it is "
"invalid in some other way."
msgstr ""
"鍵タイプによっては、 フォーマットが違っていたり、その他にも無効なものがある"
"と、 指定したデータが拒否される場合もある。"

#.  FIXME The aforementioned phrases begs the question:
#.  which key types support this?
#.  FIXME Perhaps elaborate the implications here? Namely, the new
#.  key will have a new ID, and if the old key was a keyring that
#.  is consequently unlinked, then keys that it was anchoring
#.  will have their reference count decreased by one (and may
#.  consequently be garbage collected). Is this all correct?
#. type: Plain text
#: build/C/man2/add_key.2:60
#, fuzzy
#| msgid ""
#| "If the destination I<keyring> already contains a key that matches the "
#| "specified I<type> and I<description>, then, if the key type supports it, "
#| "that key will be updated rather than a new key being created; if not, a "
#| "new key will be created and it will displace the link to the extant key "
#| "from the keyring."
msgid ""
"If the destination I<keyring> already contains a key that matches the "
"specified I<type> and I<description>, then, if the key type supports it, "
"that key will be updated rather than a new key being created; if not, a new "
"key (with a different ID) will be created and it will displace the link to "
"the extant key from the keyring."
msgstr ""
"対象の I<keyring> に指定された I<type> と I<description> に合致する鍵がすでに"
"含まれる場合、 鍵タイプがサポートしていれば、 新しい鍵が作成されるのではな"
"く、 その鍵が更新される。 鍵タイプがサポートしていない場合、 新しい鍵が作成さ"
"れ、 鍵リングの現在の鍵のリンクはこの鍵で置き換えられる。"

#.  FIXME . Perhaps have a separate page describing special keyring IDs?
#. type: Plain text
#: build/C/man2/add_key.2:68
#, fuzzy
#| msgid ""
#| "The destination I<keyring> serial number may be that of a valid keyring "
#| "to which the caller has write permission, or it may be a special keyring "
#| "ID:"
msgid ""
"The destination I<keyring> serial number may be that of a valid keyring for "
"which the caller has I<write> permission.  Alternatively, it may be one of "
"the following special keyring IDs:"
msgstr ""
"対象の I<keyring> のシリアル番号には、 呼び出し元が書き込み許可を持つ有効な鍵"
"リングのシリアル番号か、 以下の特別な鍵リング ID を指定する。"

#. type: TP
#: build/C/man2/add_key.2:68 build/C/man2/keyctl.2:81
#: build/C/man2/request_key.2:82
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: build/C/man2/add_key.2:72
#, fuzzy
#| msgid "This specifies the caller's thread-specific keyring."
msgid ""
"This specifies the caller's thread-specific keyring (B<thread-keyring>(7))."
msgstr "この値は呼び出し元スレッド固有の鍵リングを指定する。"

#. type: TP
#: build/C/man2/add_key.2:72 build/C/man2/keyctl.2:86
#: build/C/man2/request_key.2:86
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: build/C/man2/add_key.2:76
#, fuzzy
#| msgid "This specifies the caller's process-specific keyring."
msgid ""
"This specifies the caller's process-specific keyring (B<process-keyring>(7))."
msgstr "この値は呼び出し元プロセス固有の鍵リングを指定する。"

#. type: TP
#: build/C/man2/add_key.2:76 build/C/man2/keyctl.2:91
#: build/C/man2/request_key.2:90
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man2/add_key.2:80
#, fuzzy
#| msgid "This specifies the caller's session-specific keyring."
msgid ""
"This specifies the caller's session-specific keyring (B<session-keyring>(7))."
msgstr "この値は呼び出し元セッション固有の鍵リングを指定する。"

#. type: TP
#: build/C/man2/add_key.2:80 build/C/man2/keyctl.2:96
#: build/C/man2/request_key.2:94
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: build/C/man2/add_key.2:84
#, fuzzy
#| msgid "This specifies the caller's UID-specific keyring."
msgid "This specifies the caller's UID-specific keyring (B<user-keyring>(7))."
msgstr "この値は呼び出し元の UID 固有の鍵リングを指定する。"

#. type: TP
#: build/C/man2/add_key.2:84 build/C/man2/keyctl.2:101
#: build/C/man2/request_key.2:98
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man2/add_key.2:88
#, fuzzy
#| msgid "This specifies the caller's UID-session keyring."
msgid ""
"This specifies the caller's UID-session keyring (B<user-session-keyring>(7))."
msgstr "この値は呼び出し元の UID のセッションの鍵リングを指定する。"

#. type: SS
#: build/C/man2/add_key.2:88 build/C/man7/keyrings.7:103
#, no-wrap
msgid "Key types"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:100
msgid ""
"The key I<type> is a string that specifies the key's type.  Internally, the "
"kernel defines a number of key types that are available in the core key "
"management code.  Among the types that are available for user-space use and "
"can be specified as the I<type> argument to B<add_key>()  are the following:"
msgstr ""

#. type: TP
#: build/C/man2/add_key.2:100 build/C/man7/keyrings.7:105
#: build/C/man7/keyrings.7:675
#, fuzzy, no-wrap
#| msgid "B<``keyring''>"
msgid "I<\"keyring\">"
msgstr "B<``keyring''>"

#. type: Plain text
#: build/C/man2/add_key.2:109
#, fuzzy
#| msgid ""
#| "Keyrings are special key types that may contain links to sequences of "
#| "other keys of any type.  If this interface is used to create a keyring, "
#| "then a NULL I<payload> should be specified, and I<plen> should be zero."
msgid ""
"Keyrings are special key types that may contain links to sequences of other "
"keys of any type.  If this interface is used to create a keyring, then "
"I<payload> should be NULL and I<plen> should be zero."
msgstr ""
"鍵リングは、 任意のタイプの他の鍵の列へのリンクを保持できる特別な鍵タイプであ"
"る。 このインターフェースを使って鍵リングを作成する場合、 I<payload> には "
"NULL を、 I<plen> には 0 を指定しなければならない。"

#. type: TP
#: build/C/man2/add_key.2:109 build/C/man7/keyrings.7:118
#, fuzzy, no-wrap
#| msgid "B<``user''>"
msgid "I<\"user\">"
msgstr "B<``user''>"

#. type: Plain text
#: build/C/man2/add_key.2:116
msgid ""
"This is a general purpose key type whose payload may be read and updated by "
"user-space applications.  The key is kept entirely within kernel memory.  "
"The payload for keys of this type is a blob of arbitrary data of up to "
"32,767 bytes."
msgstr ""

#. type: TP
#: build/C/man2/add_key.2:116 build/C/man7/keyrings.7:132
#, no-wrap
msgid "I<\"logon\"> (since Linux 3.3)"
msgstr ""

#.  commit 9f6ed2ca257fa8650b876377833e6f14e272848b
#. type: Plain text
#: build/C/man2/add_key.2:124
msgid ""
"This key type is essentially the same as I<\"user\">, but it does not permit "
"the key to read.  This is suitable for storing payloads that you do not want "
"to be readable from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:131
msgid ""
"This key type vets the I<description> to ensure that it is qualified by a "
"\"service\" prefix, by checking to ensure that the I<description> contains a "
"':' that is preceded by other characters."
msgstr ""

#. type: TP
#: build/C/man2/add_key.2:131 build/C/man7/keyrings.7:154
#, no-wrap
msgid "I<\"big_key\"> (since Linux 3.13)"
msgstr ""

#.  commit ab3c3587f8cda9083209a61dbe3a4407d3cada10
#. type: Plain text
#: build/C/man2/add_key.2:140
msgid ""
"This key type is similar to I<\"user\">, but may hold a payload of up to 1\\ "
"MiB.  If the key payload is large enough, then it may be stored encrypted in "
"tmpfs (which can be swapped out) rather than kernel memory."
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:143
msgid "For further details on these key types, see B<keyrings>(7)."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:143 build/C/man2/keyctl.2:1613
#: build/C/man2/request_key.2:374
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/add_key.2:150
#, fuzzy
#| msgid ""
#| "On success B<add_key>()  returns the serial number of the key it created "
#| "or updated.  On error, the value -1 will be returned and errno will have "
#| "been set to an appropriate error."
msgid ""
"On success, B<add_key>()  returns the serial number of the key it created or "
"updated.  On error, -1 is returned and I<errno> is set to indicate the cause "
"of the error."
msgstr ""
"成功すると B<add_key>() は、作成または更新した鍵のシリアル番号を返す。 エラー"
"の場合、値 -1 が返され I<errno> にエラーを示す値が設定される。"

#. type: SH
#: build/C/man2/add_key.2:150 build/C/man2/keyctl.2:1663
#: build/C/man2/request_key.2:381
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/add_key.2:151 build/C/man2/keyctl.2:1664
#: build/C/man2/request_key.2:382
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/add_key.2:154 build/C/man2/request_key.2:385
msgid "The keyring wasn't available for modification by the user."
msgstr "そのユーザーは指定された鍵リングを変更できない。"

#. type: TP
#: build/C/man2/add_key.2:154 build/C/man2/keyctl.2:1685
#: build/C/man2/request_key.2:385
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/add_key.2:158 build/C/man2/request_key.2:389
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""
"この鍵を作成するか、鍵を鍵リングに追加すると、 このユーザーの鍵リングのクォー"
"タを超過してしまう。"

#. type: TP
#: build/C/man2/add_key.2:158 build/C/man2/keyctl.2:1697
#: build/C/man2/request_key.2:389
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:166
msgid ""
"One or more of I<type>, I<description>, and I<payload> points outside "
"process's accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/add_key.2:166 build/C/man2/add_key.2:173
#: build/C/man2/add_key.2:176 build/C/man2/keyctl.2:1734
#: build/C/man2/keyctl.2:1741 build/C/man2/keyctl.2:1764
#: build/C/man2/keyctl.2:1770 build/C/man2/keyctl.2:1777
#: build/C/man2/keyctl.2:1790 build/C/man2/request_key.2:401
#: build/C/man2/request_key.2:408
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/add_key.2:173 build/C/man2/request_key.2:408
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<type> or I<description> exceeded the limit (32 bytes and 4096 bytes "
"respectively)."
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:176
msgid "The payload data was invalid."
msgstr "ペイロードデータが無効である。"

#. type: Plain text
#: build/C/man2/add_key.2:185
msgid ""
"I<type> was I<\"logon\"> and the I<description> was not qualified with a "
"prefix string of the form I<\"service:\">."
msgstr ""

#. type: TP
#: build/C/man2/add_key.2:185 build/C/man2/keyctl.2:1803
#: build/C/man2/request_key.2:413
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: build/C/man2/add_key.2:188
msgid "The keyring has expired."
msgstr "鍵リングが期限切れである。"

#. type: TP
#: build/C/man2/add_key.2:188 build/C/man2/keyctl.2:1809
#: build/C/man2/request_key.2:419
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: build/C/man2/add_key.2:191
msgid "The keyring has been revoked."
msgstr "鍵リングが廃止されている。"

#. type: TP
#: build/C/man2/add_key.2:191 build/C/man2/keyctl.2:1872
#: build/C/man2/keyctl.2:1875 build/C/man2/request_key.2:422
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: build/C/man2/add_key.2:194
msgid "The keyring doesn't exist."
msgstr "鍵リングが存在しない。"

#. type: TP
#: build/C/man2/add_key.2:194 build/C/man2/keyctl.2:1886
#: build/C/man2/request_key.2:425
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/add_key.2:197 build/C/man2/request_key.2:428
msgid "Insufficient memory to create a key."
msgstr "鍵を作成するのに十分なメモリーがない。"

#. type: TP
#: build/C/man2/add_key.2:197 build/C/man2/add_key.2:203
#: build/C/man2/keyctl.2:1919 build/C/man2/keyctl.2:1929
#: build/C/man2/request_key.2:428
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SETPERM>"
msgid "B<EPERM>"
msgstr "B<KEYCTL_SETPERM>"

#. type: Plain text
#: build/C/man2/add_key.2:203
msgid ""
"The I<type> started with a period (\\(aq.\\(aq).  Key types that begin with "
"a period are reserved to the implementation."
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:213
msgid ""
"I<type> was I<\"keyring\"> and the I<description> started with a period "
"(\\(aq.\\(aq).  Keyrings with descriptions (names)  that begin with a period "
"are reserved to the implementation."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:213 build/C/man2/keyctl.2:1950
#: build/C/man2/request_key.2:433
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:215 build/C/man2/keyctl.2:1952
msgid "This system call first appeared in Linux 2.6.10."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:215 build/C/man2/keyctl.2:1952
#: build/C/man2/request_key.2:438
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:217 build/C/man2/keyctl.2:1954
#: build/C/man2/request_key.2:440
msgid "This system call is a nonstandard Linux extension."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:217 build/C/man2/keyctl.2:1954
#: build/C/man2/request_key.2:440 build/C/man7/persistent-keyring.7:99
#: build/C/man7/user-session-keyring.7:79
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:224 build/C/man2/request_key.2:447
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided "
"in the I<libkeyutils> package.  When employing the wrapper in that library, "
"link with I<-lkeyutils>."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:224 build/C/man2/keyctl.2:1964
#: build/C/man2/request_key.2:447
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:229
msgid ""
"The program below creates a key with the type, description, and payload "
"specified in its command-line arguments, and links that key into the session "
"keyring.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:236
#, no-wrap
msgid ""
"$ B<./a.out user mykey \"Some payload\">\n"
"Key ID is 64a4dca\n"
"$ B<grep \\(aq64a4dca\\(aq /proc/keys>\n"
"064a4dca I--Q---    1 perm 3f010000  1000  1000 user    mykey: 12\n"
msgstr ""

#. type: SS
#: build/C/man2/add_key.2:238 build/C/man2/keyctl.2:2074
#: build/C/man2/request_key.2:511
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:247 build/C/man2/request_key.2:522
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:252 build/C/man2/request_key.2:527
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    key_serial_t key;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:258
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description payload\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:265
#, no-wrap
msgid ""
"    key = add_key(argv[1], argv[2], argv[3], strlen(argv[3]),\n"
"                KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"add_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:267 build/C/man2/request_key.2:542
#, no-wrap
msgid "    printf(\"Key ID is %jx\\en\", (uintmax_t) key);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/add_key.2:270 build/C/man2/keyctl.2:2234
#: build/C/man2/request_key.2:545
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:271 build/C/man2/keyctl.2:2235
#: build/C/man2/request_key.2:546 build/C/man7/keyrings.7:859
#: build/C/man7/persistent-keyring.7:114 build/C/man7/process-keyring.7:50
#: build/C/man7/session-keyring.7:102 build/C/man7/thread-keyring.7:45
#: build/C/man7/user-keyring.7:75 build/C/man7/user-session-keyring.7:87
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/add_key.2:286
msgid ""
"B<keyctl>(1), B<keyctl>(2), B<request_key>(2), B<keyctl>(3), B<keyrings>(7), "
"B<keyutils>(7), B<persistent-keyring>(7), B<process-keyring>(7), B<session-"
"keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-session-"
"keyring>(7)"
msgstr ""

#.  commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
#.  commit 3db38ed76890565772fcca3279cc8d454ea6176b
#. type: Plain text
#: build/C/man2/add_key.2:297 build/C/man2/request_key.2:574
msgid ""
"The kernel source files I<Documentation/security/keys/core.rst> and "
"I<Documentation/keys/request-key.rst> (or, before Linux 4.13, in the files "
"I<Documentation/security/keys.txt> and I<Documentation/security/keys-request-"
"key.txt>)."
msgstr ""

#. type: SH
#: build/C/man2/add_key.2:297 build/C/man2/keyctl.2:2291
#: build/C/man2/request_key.2:574 build/C/man7/keyrings.7:883
#: build/C/man7/persistent-keyring.7:126 build/C/man7/process-keyring.7:61
#: build/C/man7/session-keyring.7:116 build/C/man7/thread-keyring.7:56
#: build/C/man7/user-keyring.7:87 build/C/man7/user-session-keyring.7:98
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/add_key.2:305 build/C/man2/keyctl.2:2299
#: build/C/man2/request_key.2:582 build/C/man7/keyrings.7:891
#: build/C/man7/persistent-keyring.7:134 build/C/man7/process-keyring.7:69
#: build/C/man7/session-keyring.7:124 build/C/man7/thread-keyring.7:64
#: build/C/man7/user-keyring.7:95 build/C/man7/user-session-keyring.7:106
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/keyctl.2:28
#, no-wrap
msgid "KEYCTL"
msgstr "KEYCTL"

#. type: Plain text
#: build/C/man2/keyctl.2:31
msgid "keyctl - manipulate the kernel's key management facility"
msgstr "keyctl - カーネルの鍵管理機能を操作する"

#. type: Plain text
#: build/C/man2/keyctl.2:37
#, fuzzy, no-wrap
#| msgid "B<long keyctl(int >I<cmd>B<, ...);>\n"
msgid "B<long keyctl(int >I<operation>B<, ...);>\n"
msgstr "B<long keyctl(int >I<cmd>B<, ...);>\n"

#. type: Plain text
#: build/C/man2/keyctl.2:42
#, no-wrap
msgid ""
"B</* For direct call via syscall(2): */>\n"
"B<#include E<lt>asm/unistd.hE<gt>>\n"
"B<#include E<lt>linux/keyctl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:46
#, no-wrap
msgid ""
"B<long syscall(__NR_keyctl, int >I<operation>B<, __kernel_ulong_t >I<arg2>B<,>\n"
"B<             __kernel_ulong_t >I<arg3>B<, __kernel_ulong_t >I<arg4>B<,>\n"
"B<             __kernel_ulong_t >I<arg5>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:52
msgid "B<keyctl>()  allows user-space programs to perform key manipulation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:64
msgid ""
"The operation performed by B<keyctl>()  is determined by the value of the "
"I<operation> argument.  Each of these operations is wrapped by the "
"I<libkeyutils> library (provided by the I<keyutils> package) into individual "
"functions (noted below)  to permit the compiler to check types."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:68
msgid "The permitted values for I<operation> are:"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:68
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_GET_KEYRING_ID>"
msgid "B<KEYCTL_GET_KEYRING_ID> (since Linux 2.6.10)"
msgstr "B<KEYCTL_GET_KEYRING_ID>"

#. type: Plain text
#: build/C/man2/keyctl.2:71
msgid "Map a special key ID to a real key ID for this process."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:80
msgid ""
"This operation looks up the special key whose ID is provided in I<arg2> "
"(cast to I<key_serial_t>).  If the special key is found, the ID of the "
"corresponding real key is returned as the function result.  The following "
"values may be specified in I<arg2>:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:86
#, fuzzy
#| msgid "This specifies the caller's thread-specific keyring."
msgid ""
"This specifies the calling thread's thread-specific keyring.  See B<thread-"
"keyring>(7)."
msgstr "この値は呼び出し元スレッド固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:91
#, fuzzy
#| msgid "This specifies the caller's process-specific keyring."
msgid ""
"This specifies the caller's process-specific keyring.  See B<process-"
"keyring>(7)."
msgstr "この値は呼び出し元プロセス固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:96
#, fuzzy
#| msgid "This specifies the caller's session-specific keyring."
msgid ""
"This specifies the caller's session-specific keyring.  See B<session-"
"keyring>(7)."
msgstr "この値は呼び出し元セッション固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:101
#, fuzzy
#| msgid "This specifies the caller's UID-specific keyring."
msgid ""
"This specifies the caller's UID-specific keyring.  See B<user-keyring>(7)."
msgstr "この値は呼び出し元の UID 固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:106
#, fuzzy
#| msgid "This specifies the caller's UID-session keyring."
msgid ""
"This specifies the caller's UID-session keyring.  See B<user-session-"
"keyring>(7)."
msgstr "この値は呼び出し元の UID のセッションの鍵リングを指定する。"

#. type: TP
#: build/C/man2/keyctl.2:106
#, no-wrap
msgid "B<KEY_SPEC_REQKEY_AUTH_KEY> (since Linux 2.6.16)"
msgstr ""

#.             commit b5f545c880a2a47947ba2118b2509644ab7a2969
#. type: Plain text
#: build/C/man2/keyctl.2:117
msgid ""
"This specifies the authorization key created by B<request_key>(2)  and "
"passed to the process it spawns to generate a key.  This key is available "
"only in a B<request-key>(8)-style program that was passed an authorization "
"key by the kernel and ceases to be available once the requested key has been "
"instantiated; see B<request_key>(2)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:117
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_KEYRING>"
msgid "B<KEY_SPEC_REQUESTOR_KEYRING> (since Linux 2.6.29)"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#.             commit 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#. type: Plain text
#: build/C/man2/keyctl.2:128
msgid ""
"This specifies the key ID for the B<request_key>(2)  destination keyring.  "
"This keyring is available only in a B<request-key>(8)-style program that was "
"passed an authorization key by the kernel and ceases to be available once "
"the requested key has been instantiated; see B<request_key>(2)."
msgstr ""

#.  The keyctl_get_keyring_ID.3 page says that a new key
#.  "will be created *if it is appropriate to do so**. What is the
#.  determiner for appropriate?
#.  David Howells: Some special keys such as KEY_SPEC_REQKEY_AUTH_KEY
#.  wouldn't get created but user/user-session/session keyring would
#.  be created.
#. type: Plain text
#: build/C/man2/keyctl.2:149
msgid ""
"The behavior if the key specified in I<arg2> does not exist depends on the "
"value of I<arg3> (cast to I<int>).  If I<arg3> contains a nonzero value, then"
"\\(emif it is appropriate to do so (e.g., when looking up the user, user-"
"session, or session key)\\(ema new key is created and its real key ID "
"returned as the function result.  Otherwise, the operation fails with the "
"error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:155
msgid ""
"If a valid key ID is specified in I<arg2>, and the key exists, then this "
"operation simply returns the key ID.  If the key does not exist, the call "
"fails with error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:159
msgid ""
"The caller must have I<search> permission on a keyring in order for it to be "
"found."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:165 build/C/man2/keyctl.2:677
#: build/C/man2/keyctl.2:709 build/C/man2/keyctl.2:1037
#: build/C/man2/keyctl.2:1412
msgid "The arguments I<arg4> and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:170
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_get_keyring_ID>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:170
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_JOIN_SESSION_KEYRING>"
msgid "B<KEYCTL_JOIN_SESSION_KEYRING> (since Linux 2.6.10)"
msgstr "B<KEYCTL_JOIN_SESSION_KEYRING>"

#.  This may be useful in conjunction with some sort of
#.  session management framework that is employed by the application.
#. type: Plain text
#: build/C/man2/keyctl.2:176
msgid ""
"Replace the session keyring this process subscribes to with a new session "
"keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:183
msgid ""
"If I<arg2> is NULL, an anonymous keyring with the description \"_ses\" is "
"created and the process is subscribed to that keyring as its session "
"keyring, displacing the previous session keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:190
msgid ""
"Otherwise, I<arg2> (cast to I<char\\ *>)  is treated as the description "
"(name) of a keyring, and the behavior is as follows:"
msgstr ""

#. type: IP
#: build/C/man2/keyctl.2:191 build/C/man2/keyctl.2:200
#: build/C/man2/keyctl.2:2034 build/C/man2/keyctl.2:2038
#: build/C/man2/keyctl.2:2043 build/C/man2/keyctl.2:2047
#: build/C/man2/request_key.2:233 build/C/man2/request_key.2:236
#: build/C/man2/request_key.2:239 build/C/man2/request_key.2:248
#: build/C/man2/request_key.2:252 build/C/man2/request_key.2:255
#: build/C/man2/request_key.2:306 build/C/man2/request_key.2:313
#: build/C/man2/request_key.2:322 build/C/man7/keyrings.7:356
#: build/C/man7/keyrings.7:358 build/C/man7/keyrings.7:360
#: build/C/man7/keyrings.7:362
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:200
msgid ""
"If a keyring with a matching description exists, the process will attempt to "
"subscribe to that keyring as its session keyring if possible; if that is not "
"possible, an error is returned.  In order to subscribe to the keyring, the "
"caller must have I<search> permission on the keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:204
msgid ""
"If a keyring with a matching description does not exist, then a new keyring "
"with the specified description is created, and the process is subscribed to "
"that keyring as its session keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:212 build/C/man2/keyctl.2:279
#: build/C/man2/keyctl.2:636 build/C/man2/keyctl.2:986
#: build/C/man2/keyctl.2:1111 build/C/man2/keyctl.2:1350
msgid "The arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:217
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_join_session_keyring>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:217
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_UPDATE>"
msgid "B<KEYCTL_UPDATE> (since Linux 2.6.10)"
msgstr "B<KEYCTL_UPDATE>"

#. type: Plain text
#: build/C/man2/keyctl.2:220
#, fuzzy
#| msgid "Update a key."
msgid "Update a key's data payload."
msgstr "鍵を更新する。"

#. type: Plain text
#: build/C/man2/keyctl.2:235
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  specifies the ID of the key "
"to be updated.  The I<arg3> argument (cast to I<void\\ *>)  points to the "
"new payload and I<arg4> (cast to I<size_t>)  contains the new payload size "
"in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:239
msgid ""
"The caller must have I<write> permission on the key specified and the key "
"type must support updating."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:243
msgid ""
"A negatively instantiated key (see the description of B<KEYCTL_REJECT>)  can "
"be positively instantiated with this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:247 build/C/man2/keyctl.2:322
#: build/C/man2/keyctl.2:605 build/C/man2/keyctl.2:836
#: build/C/man2/keyctl.2:899 build/C/man2/keyctl.2:1160
msgid "The I<arg5> argument is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:252
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_update>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:252
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_REVOKE>"
msgid "B<KEYCTL_REVOKE> (since Linux 2.6.10)"
msgstr "B<KEYCTL_REVOKE>"

#. type: Plain text
#: build/C/man2/keyctl.2:263
msgid ""
"Revoke the key with the ID provided in I<arg2> (cast to I<key_serial_t>).  "
"The key is scheduled for garbage collection; it will no longer be findable, "
"and will be unavailable for further operations.  Further attempts to use the "
"key will fail with the error B<EKEYREVOKED>."
msgstr ""

#.  Keys with the KEY_FLAG_KEEP bit set cause an EPERM
#.  error for KEYCTL_REVOKE. Does this need to be documented?
#.  David Howells: No significance for user space.
#. type: Plain text
#: build/C/man2/keyctl.2:272
msgid "The caller must have I<write> or I<setattr> permission on the key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:284
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_revoke>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:284
#, no-wrap
msgid "B<KEYCTL_CHOWN> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:287
#, fuzzy
#| msgid "Set ownership of a key."
msgid "Change the ownership (user and group ID) of a key."
msgstr "鍵の所有者を設定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:303
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  contains the key ID.  The "
"I<arg3> argument (cast to I<uid_t>)  contains the new user ID (or -1 in case "
"the user ID shouldn't be changed).  The I<arg4> argument (cast to I<gid_t>)  "
"contains the new group ID (or -1 in case the group ID shouldn't be changed)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:307
msgid "The key must grant the caller I<setattr> permission."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:313
msgid ""
"For the UID to be changed, or for the GID to be changed to a group the "
"caller is not a member of, the caller must have the B<CAP_SYS_ADMIN> "
"capability (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:318
msgid ""
"If the UID is to be changed, the new user must have sufficient quota to "
"accept the key.  The quota deduction will be removed from the old user to "
"the new user should the UID be changed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:327
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_chown>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:327
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SETPERM>"
msgid "B<KEYCTL_SETPERM> (since Linux 2.6.10)"
msgstr "B<KEYCTL_SETPERM>"

#. type: Plain text
#: build/C/man2/keyctl.2:337
msgid ""
"Change the permissions of the key with the ID provided in the I<arg2> "
"argument (cast to I<key_serial_t>)  to the permissions provided in the "
"I<arg3> argument (cast to I<key_perm_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:342
msgid ""
"If the caller doesn't have the B<CAP_SYS_ADMIN> capability, it can change "
"permissions only for the keys it owns.  (More precisely: the caller's "
"filesystem UID must match the UID of the key.)"
msgstr ""

#.  FIXME Above, is it really intended that a privileged process can't
#.  override the lack of the 'setattr' permission?
#. type: Plain text
#: build/C/man2/keyctl.2:350
msgid ""
"The key must grant I<setattr> permission to the caller I<regardless> of the "
"caller's capabilities."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:355
msgid ""
"The permissions in I<arg3> specify masks of available operations for each of "
"the following user categories:"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:356
#, no-wrap
msgid "I<possessor> (since Linux 2.6.14)"
msgstr ""

#.  commit 664cceb0093b755739e56572b836a99104ee8a75
#. type: Plain text
#: build/C/man2/keyctl.2:363
msgid ""
"This is the permission granted to a process that possesses the key (has it "
"attached searchably to one of the process's keyrings); see B<keyrings>(7)."
msgstr ""

#. type: IP
#: build/C/man2/keyctl.2:363 build/C/man7/keyrings.7:369
#, fuzzy, no-wrap
#| msgid "B<``user''>"
msgid "I<user>"
msgstr "B<``user''>"

#. type: Plain text
#: build/C/man2/keyctl.2:367
msgid ""
"This is the permission granted to a process whose filesystem UID matches the "
"UID of the key."
msgstr ""

#. type: IP
#: build/C/man2/keyctl.2:367 build/C/man7/keyrings.7:372
#, no-wrap
msgid "I<group>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:372
msgid ""
"This is the permission granted to a process whose filesystem GID or any of "
"its supplementary GIDs matches the GID of the key."
msgstr ""

#. type: IP
#: build/C/man2/keyctl.2:372 build/C/man7/keyrings.7:376
#, no-wrap
msgid "I<other>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:380
msgid ""
"This is the permission granted to other processes that do not match the "
"I<user> and I<group> categories."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:398
msgid ""
"The I<user>, I<group>, and I<other> categories are exclusive: if a process "
"matches the I<user> category, it will not receive permissions granted in the "
"I<group> category; if a process matches the I<user> or I<group> category, "
"then it will not receive permissions granted in the I<other> category."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:407
msgid ""
"The I<possessor> category grants permissions that are cumulative with the "
"grants from the I<user>, I<group>, or I<other> category."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:411
msgid ""
"Each permission mask is eight bits in size, with only six bits currently "
"used.  The available permissions are:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:412 build/C/man7/keyrings.7:391
#: build/C/man7/keyrings.7:628
#, no-wrap
msgid "I<view>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:415
msgid "This permission allows reading attributes of a key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:419
msgid "This permission is required for the B<KEYCTL_DESCRIBE> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:426
msgid ""
"The permission bits for each category are B<KEY_POS_VIEW>, B<KEY_USR_VIEW>, "
"B<KEY_GRP_VIEW>, and B<KEY_OTH_VIEW>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:426 build/C/man7/keyrings.7:396
#: build/C/man7/keyrings.7:631
#, no-wrap
msgid "I<read>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:429
msgid "This permission allows reading a key's payload."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:433
msgid "This permission is required for the B<KEYCTL_READ> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:440
msgid ""
"The permission bits for each category are B<KEY_POS_READ>, B<KEY_USR_READ>, "
"B<KEY_GRP_READ>, and B<KEY_OTH_READ>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:440 build/C/man7/keyrings.7:401
#: build/C/man7/keyrings.7:634
#, no-wrap
msgid "I<write>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:444
msgid ""
"This permission allows update or instantiation of a key's payload.  For a "
"keyring, it allows keys to be linked and unlinked from the keyring,"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:453
msgid ""
"This permission is required for the B<KEYCTL_UPDATE>, B<KEYCTL_REVOKE>, "
"B<KEYCTL_CLEAR>, B<KEYCTL_LINK>, and B<KEYCTL_UNLINK> operations."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:460
msgid ""
"The permission bits for each category are B<KEY_POS_WRITE>, "
"B<KEY_USR_WRITE>, B<KEY_GRP_WRITE>, and B<KEY_OTH_WRITE>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:460 build/C/man7/keyrings.7:406
#: build/C/man7/keyrings.7:637
#, no-wrap
msgid "I<search>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:466
msgid ""
"This permission allows keyrings to be searched and keys to be found.  "
"Searches can recurse only into nested keyrings that have I<search> "
"permission set."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:474
msgid ""
"This permission is required for the B<KEYCTL_GET_KEYRING_ID>, "
"B<KEYCTL_JOIN_SESSION_KEYRING>, B<KEYCTL_SEARCH>, and B<KEYCTL_INVALIDATE> "
"operations."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:481
msgid ""
"The permission bits for each category are B<KEY_POS_SEARCH>, "
"B<KEY_USR_SEARCH>, B<KEY_GRP_SEARCH>, and B<KEY_OTH_SEARCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:481 build/C/man7/keyrings.7:411
#: build/C/man7/keyrings.7:640
#, no-wrap
msgid "I<link>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:484
msgid "This permission allows a key or keyring to be linked to."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:490
msgid ""
"This permission is required for the B<KEYCTL_LINK> and "
"B<KEYCTL_SESSION_TO_PARENT> operations."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:497
msgid ""
"The permission bits for each category are B<KEY_POS_LINK>, B<KEY_USR_LINK>, "
"B<KEY_GRP_LINK>, and B<KEY_OTH_LINK>."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:497
#, no-wrap
msgid "I<setattr> (since Linux 2.6.15)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:500
msgid ""
"This permission allows a key's UID, GID, and permissions mask to be changed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:507
msgid ""
"This permission is required for the B<KEYCTL_REVOKE>, B<KEYCTL_CHOWN>, and "
"B<KEYCTL_SETPERM> operations."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:514
msgid ""
"The permission bits for each category are B<KEY_POS_SETATTR>, "
"B<KEY_USR_SETATTR>, B<KEY_GRP_SETATTR>, and B<KEY_OTH_SETATTR>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:523
msgid ""
"As a convenience, the following macros are defined as masks for all of the "
"permission bits in each of the user categories: B<KEY_POS_ALL>, "
"B<KEY_USR_ALL>, B<KEY_GRP_ALL>, and B<KEY_OTH_ALL>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:527
msgid "The I<arg4> and I<arg5> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:532
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_setperm>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:532
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_DESCRIBE>"
msgid "B<KEYCTL_DESCRIBE> (since Linux 2.6.10)"
msgstr "B<KEYCTL_DESCRIBE>"

#. type: Plain text
#: build/C/man2/keyctl.2:535
msgid "Obtain a string describing the attributes of a specified key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:548
msgid ""
"The ID of the key to be described is specified in I<arg2> (cast to "
"I<key_serial_t>).  The descriptive string is returned in the buffer pointed "
"to by I<arg3> (cast to I<char\\ *>); I<arg4> (cast to I<size_t>)  specifies "
"the size of that buffer in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:552
msgid "The key must grant the caller I<view> permission."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:555
msgid ""
"The returned string is null-terminated and contains the following "
"information about the key:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:558
msgid "I<type>;I<uid>;I<gid>;I<perm>;I<description>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:572
msgid ""
"In the above, I<type> and I<description> are strings, I<uid> and I<gid> are "
"decimal strings, and I<perm> is a hexadecimal permissions mask.  The "
"descriptive string is written with the following format:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:574
#, no-wrap
msgid "    %s;%d;%d;%08x;%s\n"
msgstr ""

#.  FIXME But, the kernel does not enforce the requirement
#.  that the key description contains no semicolons!
#.  So, user space has no guarantee here??
#.  Either something more needs to be said here,
#.  or a kernel fix is required.
#. type: Plain text
#: build/C/man2/keyctl.2:589
msgid ""
"B<Note: the intention is that the descriptive string should> B<be extensible "
"in future kernel versions>.  In particular, the I<description> field will "
"not contain semicolons; it should be parsed by working backwards from the "
"end of the string to find the last semicolon.  This allows future semicolon-"
"delimited fields to be inserted in the descriptive string in the future."
msgstr ""

#.  Function commentary says it copies up to buflen bytes, but see the
#.  (buffer && buflen >= ret) condition in keyctl_describe_key() in
#.  security/keyctl.c
#. type: Plain text
#: build/C/man2/keyctl.2:601
msgid ""
"Writing to the buffer is attempted only when I<arg3> is non-NULL and the "
"specified buffer size is large enough to accept the descriptive string "
"(including the terminating null byte).  In order to determine whether the "
"buffer size was too small, check to see if the return value of the operation "
"is greater than I<arg4>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:610
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_describe>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:610
#, no-wrap
msgid "B<KEYCTL_CLEAR>"
msgstr "B<KEYCTL_CLEAR>"

#. type: Plain text
#: build/C/man2/keyctl.2:613
#, fuzzy
#| msgid "Clear contents of a keyring."
msgid "Clear the contents of (i.e., unlink all keys from) a keyring."
msgstr "鍵リングの内容をクリアする。"

#.  or the error ENOTDIR results
#.  According to Documentation/security/keys.txt:
#.      This function can also be used to clear special kernel keyrings if they
#.      are appropriately marked if the user has CAP_SYS_ADMIN capability.  The
#.      DNS resolver cache keyring is an example of this.
#. type: Plain text
#: build/C/man2/keyctl.2:625
msgid ""
"The ID of the key (which must be of keyring type)  is provided in I<arg2> "
"(cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:629 build/C/man2/keyctl.2:1386
msgid "The caller must have I<write> permission on the keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:641
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_clear>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:641
#, no-wrap
msgid "B<KEYCTL_LINK> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:644
#, fuzzy
#| msgid "Link a key into a keyring."
msgid "Create a link from a keyring to a key."
msgstr "鍵を鍵リングに結びつける。"

#. type: Plain text
#: build/C/man2/keyctl.2:653
msgid ""
"The key to be linked is specified in I<arg2> (cast to I<key_serial_t>); the "
"keyring is specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:656
msgid ""
"If a key with the same type and description is already linked in the "
"keyring, then that key is displaced from the keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:665
msgid ""
"Before creating the link, the kernel checks the nesting of the keyrings and "
"returns appropriate errors if the link would produce a cycle or if the "
"nesting of keyrings would be too deep (The limit on the nesting of keyrings "
"is determined by the kernel constant B<KEYRING_SEARCH_MAX_DEPTH>, defined "
"with the value 6, and is necessary to prevent overflows on the kernel stack "
"when recursively searching keyrings)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:671
msgid ""
"The caller must have I<link> permission on the key being added and I<write> "
"permission on the keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:682
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_link>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:682
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_UNLINK>"
msgid "B<KEYCTL_UNLINK> (since Linux 2.6.10)"
msgstr "B<KEYCTL_UNLINK>"

#. type: Plain text
#: build/C/man2/keyctl.2:685
msgid "Unlink a key from a keyring."
msgstr "鍵の鍵リングへの結びつけを取り消す。"

#. type: Plain text
#: build/C/man2/keyctl.2:694
msgid ""
"The ID of the key to be unlinked is specified in I<arg2> (cast to "
"I<key_serial_t>); the ID of the keyring from which it is to be unlinked is "
"specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:696
msgid "If the key is not currently linked into the keyring, an error results."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:700
msgid ""
"The caller must have I<write> permission on the keyring from which the key "
"is being removed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:703
msgid ""
"If the last link to a key is removed, then that key will be scheduled for "
"destruction."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:714
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_unlink>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:714
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SEARCH>"
msgid "B<KEYCTL_SEARCH> (since Linux 2.6.10)"
msgstr "B<KEYCTL_SEARCH>"

#. type: Plain text
#: build/C/man2/keyctl.2:718
msgid ""
"Search for a key in a keyring tree, returning its ID and optionally linking "
"it to a specified keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:725
msgid ""
"The tree to be searched is specified by passing the ID of the head keyring "
"in I<arg2> (cast to I<key_serial_t>).  The search is performed breadth-first "
"and recursively."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:743
msgid ""
"The I<arg3> and I<arg4> arguments specify the key to be searched for: "
"I<arg3> (cast as I<char\\ *>)  contains the key type (a null-terminated "
"character string up to 32 bytes in size, including the terminating null "
"byte), and I<arg4> (cast as I<char\\ *>)  contains the description of the "
"key (a null-terminated character string up to 4096 bytes in size, including "
"the terminating null byte)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:753
msgid ""
"The source keyring must grant I<search> permission to the caller.  When "
"performing the recursive search, only keyrings that grant the caller "
"I<search> permission will be searched.  Only keys with for which the caller "
"has I<search> permission can be found."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:755
msgid "If the key is found, its ID is returned as the function result."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:769
msgid ""
"If the key is found and I<arg5> (cast to I<key_serial_t>)  is nonzero, then, "
"subject to the same constraints and rules as B<KEYCTL_LINK>, the key is "
"linked into the keyring whose ID is specified in I<arg5>.  If the "
"destination keyring specified in I<arg5> already contains a link to a key "
"that has the same type and description, then that link will be displaced by "
"a link to the key found by this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:776
msgid ""
"Instead of valid existing keyring IDs, the source (I<arg2>)  and destination "
"(I<arg5>)  keyrings can be one of the special keyring IDs listed under "
"B<KEYCTL_GET_KEYRING_ID>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:781
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_search>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:781
#, no-wrap
msgid "B<KEYCTL_READ> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:784
#, fuzzy
#| msgid "The payload data was invalid."
msgid "Read the payload data of a key."
msgstr "ペイロードデータが無効である。"

#.  including KEY_SPEC_REQKEY_AUTH_KEY
#. type: Plain text
#: build/C/man2/keyctl.2:793
msgid ""
"The ID of the key whose payload is to be read is specified in I<arg2> (cast "
"to I<key_serial_t>).  This can be the ID of an existing key, or any of the "
"special key IDs listed for B<KEYCTL_GET_KEYRING_ID>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:802
msgid ""
"The payload is placed in the buffer pointed by I<arg3> (cast to I<char\\ "
"*>); the size of that buffer must be specified in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:814
msgid ""
"The returned data will be processed for presentation according to the key "
"type.  For example, a keyring will return an array of I<key_serial_t> "
"entries representing the IDs of all the keys that are linked to it.  The "
"I<user> key type will return its data as is.  If a key type does not "
"implement this function, the operation fails with the error B<EOPNOTSUPP>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:825
msgid ""
"If I<arg3> is not NULL, as much of the payload data as will fit is copied "
"into the buffer.  On a successful return, the return value is always the "
"total size of the payload data.  To determine whether the buffer was of "
"sufficient size, check to see that the return value is less than or equal to "
"the value supplied in I<arg4>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:832
msgid ""
"The key must either grant the caller I<read> permission, or grant the caller "
"I<search> permission when searched for from the process keyrings (i.e., the "
"key is possessed)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:841
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_read>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:841
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_INSTANTIATE>"
msgid "B<KEYCTL_INSTANTIATE> (since Linux 2.6.10)"
msgstr "B<KEYCTL_INSTANTIATE>"

#. type: Plain text
#: build/C/man2/keyctl.2:844
msgid ""
"(Positively) instantiate an uninstantiated key with a specified payload."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:849
msgid ""
"The ID of the key to be instantiated is provided in I<arg2> (cast to "
"I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:858
msgid ""
"The key payload is specified in the buffer pointed to by I<arg3> (cast to "
"I<void\\ *>); the size of that buffer is specified in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:861
msgid ""
"The payload may be a NULL pointer and the buffer size may be 0 if this is "
"supported by the key type (e.g., it is a keyring)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:864
#, fuzzy
#| msgid ""
#| "The key type may reject the data if it's in the wrong format or in some "
#| "other way invalid."
msgid ""
"The operation may be fail if the payload data is in the wrong format or is "
"otherwise invalid."
msgstr ""
"鍵タイプによっては、 フォーマットが違っていたり、その他にも無効なものがある"
"と、 指定したデータが拒否される場合もある。"

#. type: Plain text
#: build/C/man2/keyctl.2:873
msgid ""
"If I<arg5> (cast to I<key_serial_t>)  is nonzero, then, subject to the same "
"constraints and rules as B<KEYCTL_LINK>, the instantiated key is linked into "
"the keyring whose ID specified in I<arg5>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:883 build/C/man2/keyctl.2:1266
msgid ""
"The caller must have the appropriate authorization key, and once the "
"uninstantiated key has been instantiated, the authorization key is revoked.  "
"In other words, this operation is available only from a B<request-key>(8)-"
"style program.  See B<request_key>(2)  for an explanation of uninstantiated "
"keys and key instantiation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:888
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_instantiate>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:888
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_NEGATE>"
msgid "B<KEYCTL_NEGATE> (since Linux 2.6.10)"
msgstr "B<KEYCTL_NEGATE>"

#. type: Plain text
#: build/C/man2/keyctl.2:891
msgid "Negatively instantiate an uninstantiated key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:893
msgid "This operation is equivalent to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:895
#, no-wrap
msgid "    keyctl(KEYCTL_REJECT, arg2, arg3, ENOKEY, arg4);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:904
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_negate>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:904
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SET_REQKEY_KEYRING>"
msgid "B<KEYCTL_SET_REQKEY_KEYRING> (since Linux 2.6.13)"
msgstr "B<KEYCTL_SET_REQKEY_KEYRING>"

#.  I.e., calls to the kernel's internal request_key() interface,
#.  which is distinct from the request_key(2) system call (which
#.  ultimately employs the kernel-internal interface).
#. type: Plain text
#: build/C/man2/keyctl.2:918
msgid ""
"Set the default keyring to which implicitly requested keys will be linked "
"for this thread, and return the previous setting.  Implicit key requests are "
"those made by internal kernel components, such as can occur when, for "
"example, opening files on an AFS or NFS filesystem.  Setting the default "
"keyring also has an effect when requesting a key from user space; see "
"B<request_key>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:925
msgid ""
"The I<arg2> argument (cast to I<int>)  should contain one of the following "
"values, to specify the new default keyring:"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:926
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SET_REQKEY_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_NO_CHANGE>"
msgstr "B<KEYCTL_SET_REQKEY_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:931
msgid ""
"Don't change the default keyring.  This can be used to discover the current "
"default keyring (without changing it)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:931
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:939
msgid ""
"This selects the default behaviour, which is to use the thread-specific "
"keyring if there is one, otherwise the process-specific keyring if there is "
"one, otherwise the session keyring if there is one, otherwise the UID-"
"specific session keyring, otherwise the user-specific keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:939
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_THREAD_KEYRING>"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:944
msgid ""
"Use the thread-specific keyring (B<thread-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:944
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_PROCESS_KEYRING>"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:949
msgid ""
"Use the process-specific keyring (B<process-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:949
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:954
msgid ""
"Use the session-specific keyring (B<session-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:954
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_USER_KEYRING>"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:959
msgid ""
"Use the UID-specific keyring (B<user-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:959
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgid "B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:964
msgid ""
"Use the UID-specific session keyring (B<user-session-keyring>(7))  as the "
"new default keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:964
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING> (since Linux 2.6.29)"
msgstr ""

#
#
#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME The preceding explanation needs to be expanded.
#.  Is the following correct:
#. 	The requestor keyring is the dest_keyring that
#. 	was supplied to a call to request_key(2)?
#.  David Howells said: to be checked
#. type: Plain text
#: build/C/man2/keyctl.2:975
msgid "Use the requestor keyring."
msgstr ""

#.  (including the still-unsupported KEY_REQKEY_DEFL_GROUP_KEYRING)
#. type: Plain text
#: build/C/man2/keyctl.2:979
msgid "All other values are invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:991
msgid ""
"The setting controlled by this operation is inherited by the child of "
"B<fork>(2)  and preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:996
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_set_reqkey_keyring>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:996
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SET_TIMEOUT>"
msgid "B<KEYCTL_SET_TIMEOUT> (since Linux 2.6.16)"
msgstr "B<KEYCTL_SET_TIMEOUT>"

#. type: Plain text
#: build/C/man2/keyctl.2:999
#, fuzzy
#| msgid "Set timeout on a key."
msgid "Set a timeout on a key."
msgstr "鍵にタイムアウトを設定する。"

#. type: Plain text
#: build/C/man2/keyctl.2:1010
msgid ""
"The ID of the key is specified in I<arg2> (cast to I<key_serial_t>).  The "
"timeout value, in seconds from the current time, is specified in I<arg3> "
"(cast to I<unsigned int>).  The timeout is measured against the realtime "
"clock."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1012
msgid ""
"Specifying the timeout value as 0 clears any existing timeout on the key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1017
msgid ""
"The I</proc/keys> file displays the remaining time until each key will "
"expire.  (This is the only method of discovering the timeout on a key.)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1023
msgid ""
"The caller must either have the I<setattr> permission on the key or hold an "
"instantiation authorization token for the key (see B<request_key>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1028
msgid ""
"The key and any links to the key will be automatically garbage collected "
"after the timeout expires.  Subsequent attempts to access the key will then "
"fail with the error B<EKEYEXPIRED>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1031
msgid ""
"This operation cannot be used to set timeouts on revoked, expired, or "
"negatively instantiated keys."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1042
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_set_timeout>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1042
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_ASSUME_AUTHORITY>"
msgid "B<KEYCTL_ASSUME_AUTHORITY> (since Linux 2.6.16)"
msgstr "B<KEYCTL_ASSUME_AUTHORITY>"

#. type: Plain text
#: build/C/man2/keyctl.2:1046
msgid ""
"Assume (or divest) the authority for the calling thread to instantiate a key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1053
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  specifies either a nonzero "
"key ID to assume authority, or the value 0 to divest authority."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1066
msgid ""
"If I<arg2> is nonzero, then it specifies the ID of an uninstantiated key for "
"which authority is to be assumed.  That key can then be instantiated using "
"one of B<KEYCTL_INSTANTIATE>, B<KEYCTL_INSTANTIATE_IOV>, B<KEYCTL_REJECT>, "
"or B<KEYCTL_NEGATE>.  Once the key has been instantiated, the thread is "
"automatically divested of authority to instantiate the key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1080
msgid ""
"Authority over a key can be assumed only if the calling thread has present "
"in its keyrings the authorization key that is associated with the specified "
"key.  (In other words, the B<KEYCTL_ASSUME_AUTHORITY> operation is available "
"only from a B<request-key>(8)-style program; see B<request_key>(2)  for an "
"explanation of how this operation is used.)  The caller must have I<search> "
"permission on the authorization key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1087
msgid ""
"If the specified key has a matching authorization key, then the ID of that "
"key is returned.  The authorization key can be read (B<KEYCTL_READ>)  to "
"obtain the callout information passed to B<request_key>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1092
msgid ""
"If the ID given in I<arg2> is 0, then the currently assumed authority is "
"cleared (divested), and the value 0 is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1104
msgid ""
"The B<KEYCTL_ASSUME_AUTHORITY> mechanism allows a program such as B<request-"
"key>(8)  to assume the necessary authority to instantiate a new "
"uninstantiated key that was created as a consequence of a call to "
"B<request_key>(2).  For further information, see B<request_key>(2)  and the "
"kernel source file I<Documentation/security/keys-request-key.txt>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1116
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_assume_authority>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1116
#, no-wrap
msgid "B<KEYCTL_GET_SECURITY> (since Linux 2.6.26)"
msgstr ""

#.  commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
#. type: Plain text
#: build/C/man2/keyctl.2:1120
msgid ""
"Get the LSM (Linux Security Module) security label of the specified key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1134
msgid ""
"The ID of the key whose security label is to be fetched is specified in "
"I<arg2> (cast to I<key_serial_t>).  The security label (terminated by a null "
"byte)  will be placed in the buffer pointed to by I<arg3> argument (cast to "
"I<char\\ *>); the size of the buffer must be provided in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1143
msgid ""
"If I<arg3> is specified as NULL or the buffer size specified in I<arg4> is "
"too small, the full size of the security label string (including the "
"terminating null byte)  is returned as the function result, and nothing is "
"copied to the buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1147
msgid "The caller must have I<view> permission on the specified key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1151
msgid ""
"The returned security label string will be rendered in a form appropriate to "
"the LSM in force.  For example, with SELinux, it may look like:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1153
#, no-wrap
msgid "    unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1156
msgid ""
"If no LSM is currently in force, then an empty string is placed in the "
"buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1167
msgid ""
"This operation is exposed by I<libkeyutils> via the functions "
"B<keyctl_get_security>(3)  and B<keyctl_get_security_alloc>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1167
#, no-wrap
msgid "B<KEYCTL_SESSION_TO_PARENT> (since Linux 2.6.32)"
msgstr ""

#.  commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
#.  What is the use case for KEYCTL_SESSION_TO_PARENT?
#.  David Howells: the Process Authentication Groups people requested this,
#.  but then didn't use it; maybe there are no users.
#. type: Plain text
#: build/C/man2/keyctl.2:1177
msgid ""
"Replace the session keyring to which the I<parent> of the calling process "
"subscribes with the session keyring of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1180
msgid ""
"The keyring will be replaced in the parent process at the point where the "
"parent next transitions from kernel space to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1190
msgid ""
"The keyring must exist and must grant the caller I<link> permission.  The "
"parent process must be single-threaded and have the same effective ownership "
"as this process and must not be set-user-ID or set-group-ID.  The UID of the "
"parent process's existing session keyring (f it has one), as well as the UID "
"of the caller's session keyring much match the caller's effective UID."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1198
msgid ""
"The fact that it is the parent process that is affected by this operation "
"allows a program such as the shell to start a child process that uses this "
"operation to change the shell's session keyring.  (This is what the "
"B<keyctl>(1)  B<new_session> command does.)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1206
msgid "The arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1211
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_session_to_parent>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1211
#, no-wrap
msgid "B<KEYCTL_REJECT> (since Linux 2.6.39)"
msgstr ""

#.  commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
#. type: Plain text
#: build/C/man2/keyctl.2:1219
msgid ""
"Mark a key as negatively instantiated and set an expiration timer on the "
"key.  This operation provides a superset of the functionality of the earlier "
"B<KEYCTL_NEGATE> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1239
msgid ""
"The ID of the key that is to be negatively instantiated is specified in "
"I<arg2> (cast to I<key_serial_t>).  The I<arg3> (cast to I<unsigned int>)  "
"argument specifies the lifetime of the key, in seconds.  The I<arg4> "
"argument (cast to I<unsigned int>)  specifies the error to be returned when "
"a search hits this key; typically, this is one of B<EKEYREJECTED>, "
"B<EKEYREVOKED>, or B<EKEYEXPIRED>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1249
msgid ""
"If I<arg5> (cast to I<key_serial_t>)  is nonzero, then, subject to the same "
"constraints and rules as B<KEYCTL_LINK>, the negatively instantiated key is "
"linked into the keyring whose ID is specified in I<arg5>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1256
msgid ""
"The caller must have the appropriate authorization key.  In other words, "
"this operation is available only from a B<request-key>(8)-style program.  "
"See B<request_key>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1271
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_reject>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1271
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_INSTANTIATE>"
msgid "B<KEYCTL_INSTANTIATE_IOV> (since Linux 2.6.39)"
msgstr "B<KEYCTL_INSTANTIATE>"

#.  commit ee009e4a0d4555ed522a631bae9896399674f063
#. type: Plain text
#: build/C/man2/keyctl.2:1276
msgid ""
"Instantiate an uninstantiated key with a payload specified via a vector of "
"buffers."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1282
msgid ""
"This operation is the same as B<KEYCTL_INSTANTIATE>, but the payload data is "
"specified as an array of I<iovec> structures:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1289
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address of buffer */\n"
"    size_t iov_len;     /* Size of buffer (in bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1300
msgid ""
"The pointer to the payload vector is specified in I<arg3> (cast as I<const "
"struct iovec\\ *>).  The number of items in the vector is specified in "
"I<arg4> (cast as I<unsigned int>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1309
msgid ""
"The I<arg2> (key ID)  and I<arg5> (keyring ID)  are interpreted as for "
"B<KEYCTL_INSTANTIATE>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1314
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_instantiate_iov>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1314
#, no-wrap
msgid "B<KEYCTL_INVALIDATE> (since Linux 3.5)"
msgstr ""

#.  commit fd75815f727f157a05f4c96b5294a4617c0557da
#. type: Plain text
#: build/C/man2/keyctl.2:1318
msgid "Mark a key as invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1323
msgid ""
"The ID of the key to be invalidated is specified in I<arg2> (cast to "
"I<key_serial_t>)."
msgstr ""

#.  CAP_SYS_ADMIN is permitted to invalidate certain special keys
#. type: Plain text
#: build/C/man2/keyctl.2:1329
msgid ""
"To invalidate a key, the caller must have I<search> permission on the key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1337
msgid ""
"This operation marks the key as invalid and schedules immediate garbage "
"collection.  The garbage collector removes the invalidated key from all "
"keyrings and deletes the key when its reference count reaches zero.  After "
"this operation, the key will be ignored by all searches, even if it is not "
"yet deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1343
msgid ""
"Keys that are marked invalid become invisible to normal key operations "
"immediately, though they are still visible in I</proc/keys> (marked with an "
"'i' flag)  until they are actually removed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1355
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_invalidate>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1355
#, no-wrap
msgid "B<KEYCTL_GET_PERSISTENT> (since Linux 3.13)"
msgstr ""

#.  commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
#. type: Plain text
#: build/C/man2/keyctl.2:1361
msgid ""
"Get the persistent keyring (B<persistent-keyring>(7))  for a specified user "
"and link it to a specified keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1371
msgid ""
"The user ID is specified in I<arg2> (cast to I<uid_t>).  If the value -1 is "
"specified, the caller's real user ID is used.  The ID of the destination "
"keyring is specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1377
msgid ""
"The caller must have the B<CAP_SETUID> capability in its user namespace in "
"order to fetch the persistent keyring for a user ID that does not match "
"either the real or effective user ID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1382
msgid ""
"If the call is successful, a link to the persistent keyring is added to the "
"keyring whose ID was specified in I<arg3>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1389
msgid ""
"The persistent keyring will be created by the kernel if it does not yet "
"exist."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1394
msgid ""
"Each time the B<KEYCTL_GET_PERSISTENT> operation is performed, the "
"persistent keyring will have its expiration timeout reset to the value in:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1398
#, no-wrap
msgid "/proc/sys/kernel/keys/persistent_keyring_expiry\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1404
msgid ""
"Should the timeout be reached, the persistent keyring will be removed and "
"everything it pins can then be garbage collected."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1406
msgid "Persistent keyrings were added to Linux in kernel version 3.13."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1417
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_get_persistent>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1417
#, no-wrap
msgid "B<KEYCTL_DH_COMPUTE> (since Linux 4.7)"
msgstr ""

#.  commit ddbb41148724367394d0880c516bfaeed127b52e
#. type: Plain text
#: build/C/man2/keyctl.2:1422
msgid ""
"Compute a Diffie-Hellman shared secret or public key, optionally applying "
"key derivation function (KDF) to the result."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1430
msgid ""
"The I<arg2> argument is a pointer to a set of parameters containing serial "
"numbers for three I<\"user\"> keys used in the Diffie-Hellman calculation, "
"packaged in a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1439
#, no-wrap
msgid ""
"struct keyctl_dh_params {\n"
"    int32_t private; /* The local private key */\n"
"    int32_t prime; /* The prime, known to both parties */\n"
"    int32_t base;  /* The base integer: either a shared\n"
"                      generator or the remote public key */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1447
msgid ""
"Each of the three keys specified in this structure must grant the caller "
"I<read> permission.  The payloads of these keys are used to calculate the "
"Diffie-Hellman result as:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1449
#, no-wrap
msgid "    base \\(ha private mod prime\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1452
msgid ""
"If the base is the shared generator, the result is the local public key.  If "
"the base is the remote public key, the result is the shared secret."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1462
msgid ""
"The I<arg3> argument (cast to I<char\\ *>)  points to a buffer where the "
"result of the calculation is placed.  The size of that buffer is specified "
"in I<arg4> (cast to I<size_t>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1471
msgid ""
"The buffer must be large enough to accommodate the output data, otherwise an "
"error is returned.  If I<arg4> is specified zero, in which case the buffer "
"is not used and the operation returns the minimum required buffer size (i."
"e., the length of the prime)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1477
msgid ""
"Diffie-Hellman computations can be performed in user space, but require a "
"multiple-precision integer (MPI) library.  Moving the implementation into "
"the kernel gives access to the kernel MPI implementation, and allows access "
"to secure or acceleration hardware."
msgstr ""

#.  commit f1c316a3ab9d24df6022682422fe897492f2c0c8
#. type: Plain text
#: build/C/man2/keyctl.2:1485
msgid ""
"Adding support for DH computation to the B<keyctl>()  system call was "
"considered a good fit due to the DH algorithm's use for deriving shared "
"keys; it also allows the type of the key to determine which DH "
"implementation (software or hardware) is appropriate."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1493
msgid ""
"If the I<arg5> argument is B<NULL>, then the DH result itself is returned.  "
"Otherwise (since Linux 4.12), it is a pointer to a structure which specifies "
"parameters of the KDF operation to be applied:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1502
#, no-wrap
msgid ""
"struct keyctl_kdf_params {\n"
"    char *hashname;     /* Hash algorithm name */\n"
"    char *otherinfo;    /* SP800-56A OtherInfo */\n"
"    __u32 otherinfolen; /* Length of otherinfo data */\n"
"    __u32 __spare[8];   /* Reserved */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1519
msgid ""
"The I<hashname> field is a null-terminated string which specifies a hash "
"name (available in the kernel's crypto API; the list of the hashes available "
"is rather tricky to observe; please refer to the E<.UR https://www.kernel.org"
"\\:/doc\\:/html\\:/latest\\:/crypto\\:/architecture.html> \"Kernel Crypto "
"API Architecture\" E<.UE> documentation for the information regarding how "
"hash names are constructed and your kernel's source and configuration "
"regarding what ciphers and templates with type B<CRYPTO_ALG_TYPE_SHASH> are "
"available)  to be applied to DH result in KDF operation."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1534
msgid ""
"The I<otherinfo> field is an I<OtherInfo> data as described in SP800-56A "
"section 5.8.1.2 and is algorithm-specific.  This data is concatenated with "
"the result of DH operation and is provided as an input to the KDF "
"operation.  Its size is provided in the I<otherinfolen> field and is limited "
"by B<KEYCTL_KDF_MAX_OI_LEN> constant that defined in I<security/keys/"
"internal.h> to a value of 64."
msgstr ""

#.  commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
#. type: Plain text
#: build/C/man2/keyctl.2:1542
msgid ""
"The B<__spare> field is currently unused.  It was ignored until Linux 4.13 "
"(but still should be user-addressable since it is copied to the kernel), and "
"should contain zeros since Linux 4.13."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1545
msgid ""
"The KDF implementation complies with SP800-56A as well as with SP800-108 "
"(the counter KDF)."
msgstr ""

#.  keyutils commit 742c9d7b94051d3b21f9f61a73ed6b5f3544cb82
#.  keyutils commit d68a981e5db41d059ac782071c35d1e8f3aaf61c
#. type: Plain text
#: build/C/man2/keyctl.2:1554
msgid ""
"This operation is exposed by I<libkeyutils> (from version 1.5.10 onwards) "
"via the functions B<keyctl_dh_compute>(3)  and B<keyctl_dh_compute_alloc>(3)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1554
#, no-wrap
msgid "B<KEYCTL_RESTRICT_KEYRING> (since Linux 4.12)"
msgstr ""

#.  commit 6563c91fd645556c7801748f15bc727c77fcd311
#.  commit 7228b66aaf723a623e578aa4db7d083bb39546c9
#. type: Plain text
#: build/C/man2/keyctl.2:1572
msgid ""
"Apply a key-linking restriction to the keyring with the ID provided in "
"I<arg2> (cast to I<key_serial_t>).  The caller must have I<setattr> "
"permission on the key.  If I<arg3> is NULL, any attempt to add a key to the "
"keyring is blocked; otherwise it contains a pointer to a string with a key "
"type name and I<arg4> contains a pointer to string that describes the type-"
"specific restriction.  As of Linux 4.12, only the type \"asymmetric\" has "
"restrictions defined:"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1573
#, no-wrap
msgid "B<builtin_trusted>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1577
msgid ""
"Allows only keys that are signed by a key linked to the built-in keyring (\"."
"builtin_trusted_keys\")."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1577
#, no-wrap
msgid "B<builtin_and_secondary_trusted>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1582
msgid ""
"Allows only keys that are signed by a key linked to the secondary keyring "
"(\".secondary_trusted_keys\") or, by extension, a key in a built-in keyring, "
"as the latter is linked to the former."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1582
#, no-wrap
msgid "B<key_or_keyring:>I<key>"
msgstr ""

#. type: TQ
#: build/C/man2/keyctl.2:1584
#, no-wrap
msgid "B<key_or_keyring:>I<key>B<:chain>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1590
msgid ""
"If I<key> specifies the ID of a key of type \"asymmetric\", then only keys "
"that are signed by this key are allowed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1596
msgid ""
"If I<key> specifies the ID of a keyring, then only keys that are signed by a "
"key linked to this keyring are allowed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1601
msgid ""
"If \":chain\" is specified, keys that are signed by a keys linked to the "
"destination keyring (that is, the keyring with the ID specified in the "
"I<arg2> argument) are also allowed."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1605
msgid ""
"Note that a restriction can be configured only once for the specified "
"keyring; once a restriction is set, it can't be overridden."
msgstr ""

#.  FIXME Document KEYCTL_RESTRICT_KEYRING, added in Linux 4.12
#.      commit 6563c91fd645556c7801748f15bc727c77fcd311
#.      Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
#.  See Documentation/security/keys.txt
#. type: Plain text
#: build/C/man2/keyctl.2:1613
msgid "The argument I<arg5> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1615
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1615
#, no-wrap
msgid "B<KEYCTL_GET_KEYRING_ID>"
msgstr "B<KEYCTL_GET_KEYRING_ID>"

#. type: Plain text
#: build/C/man2/keyctl.2:1618
msgid "The ID of the requested keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1618
#, no-wrap
msgid "B<KEYCTL_JOIN_SESSION_KEYRING>"
msgstr "B<KEYCTL_JOIN_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:1621
#, fuzzy
#| msgid "This specifies the caller's UID-session keyring."
msgid "The ID of the joined session keyring."
msgstr "この値は呼び出し元の UID のセッションの鍵リングを指定する。"

#. type: TP
#: build/C/man2/keyctl.2:1621
#, no-wrap
msgid "B<KEYCTL_DESCRIBE>"
msgstr "B<KEYCTL_DESCRIBE>"

#. type: Plain text
#: build/C/man2/keyctl.2:1625
msgid ""
"The size of the description (including the terminating null byte), "
"irrespective of the provided buffer size."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1625
#, no-wrap
msgid "B<KEYCTL_SEARCH>"
msgstr "B<KEYCTL_SEARCH>"

#. type: Plain text
#: build/C/man2/keyctl.2:1628
#, fuzzy
#| msgid "No matching key was found."
msgid "The ID of the key that was found."
msgstr "合致する鍵が見つからなかった。"

#. type: TP
#: build/C/man2/keyctl.2:1628
#, no-wrap
msgid "B<KEYCTL_READ>"
msgstr "B<KEYCTL_READ>"

#. type: Plain text
#: build/C/man2/keyctl.2:1632
msgid ""
"The amount of data that is available in the key, irrespective of the "
"provided buffer size."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1632
#, no-wrap
msgid "B<KEYCTL_SET_REQKEY_KEYRING>"
msgstr "B<KEYCTL_SET_REQKEY_KEYRING>"

#. type: Plain text
#: build/C/man2/keyctl.2:1638
msgid ""
"The ID of the previous default keyring to which implicitly requested keys "
"were linked (one of B<KEY_REQKEY_DEFL_USER_*>)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1638
#, no-wrap
msgid "B<KEYCTL_ASSUME_AUTHORITY>"
msgstr "B<KEYCTL_ASSUME_AUTHORITY>"

#. type: Plain text
#: build/C/man2/keyctl.2:1643
msgid ""
"Either 0, if the ID given was 0, or the ID of the authorization key matching "
"the specified key, if a nonzero key ID was provided."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1643
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_DESCRIBE>"
msgid "B<KEYCTL_GET_SECURITY>"
msgstr "B<KEYCTL_DESCRIBE>"

#. type: Plain text
#: build/C/man2/keyctl.2:1648
msgid ""
"The size of the LSM security label string (including the terminating null "
"byte), irrespective of the provided buffer size."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1648
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_GET_KEYRING_ID>"
msgid "B<KEYCTL_GET_PERSISTENT>"
msgstr "B<KEYCTL_GET_KEYRING_ID>"

#. type: Plain text
#: build/C/man2/keyctl.2:1651
msgid "The ID of the persistent keyring."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1651
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_UPDATE>"
msgid "B<KEYCTL_DH_COMPUTE>"
msgstr "B<KEYCTL_UPDATE>"

#. type: Plain text
#: build/C/man2/keyctl.2:1656
msgid ""
"The number of bytes copied to the buffer, or, if I<arg4> is 0, the required "
"buffer size."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1656
#, no-wrap
msgid "All other operations"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1659
msgid "Zero."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1663
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1667
#, fuzzy
#| msgid "A key operation wasn't permitted."
msgid "The requested operation wasn't permitted."
msgstr "鍵の操作が許可されていなかった。"

#. type: TP
#: build/C/man2/keyctl.2:1667
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1673
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and there was an error during crypto "
"module initialization."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1673 build/C/man2/keyctl.2:1679
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1679
msgid ""
"I<operation> was B<KEYCTL_LINK> and the requested link would result in a "
"cycle."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1685
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and the requested keyring "
"restriction would result in a cycle."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1689
msgid ""
"The key quota for the caller's user would be exceeded by creating a key or "
"linking it to the keyring."
msgstr ""
"鍵を作成するか、 鍵を鍵リングに結びつけると、 呼び出し元ユーザーの鍵のクォー"
"タを超過してしまう。"

#. type: TP
#: build/C/man2/keyctl.2:1689
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1697
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and keyring provided in I<arg2> "
"argument already has a restriction set."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1703
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and one of the following has failed:"
msgstr ""

#. type: IP
#: build/C/man2/keyctl.2:1704 build/C/man2/keyctl.2:1710
#: build/C/man2/keyctl.2:1717 build/C/man2/keyctl.2:1723
#: build/C/man2/keyctl.2:1731 build/C/man2/request_key.2:121
#: build/C/man2/request_key.2:131 build/C/man2/request_key.2:136
#: build/C/man2/request_key.2:141 build/C/man2/request_key.2:146
#: build/C/man2/request_key.2:152
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1710
msgid ""
"copying of the I<struct keyctl_dh_params>, provided in the I<arg2> argument, "
"from user space;"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1717
msgid ""
"copying of the I<struct keyctl_kdf_params>, provided in the non-NULL I<arg5> "
"argument, from user space (in case kernel supports performing KDF operation "
"on DH operation result);"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1723
msgid ""
"copying of data pointed by the I<hashname> field of the I<struct "
"keyctl_kdf_params> from user space;"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1731
msgid ""
"copying of data pointed by the I<otherinfo> field of the I<struct "
"keyctl_kdf_params> from user space if the I<otherinfolen> field was nonzero;"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1733
msgid "copying of the result to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1741
msgid ""
"I<operation> was B<KEYCTL_SETPERM> and an invalid permission bit was "
"specified in I<arg3>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1756
msgid ""
"I<operation> was B<KEYCTL_SEARCH> and the size of the description in I<arg4> "
"(including the terminating null byte) exceeded 4096 bytes.  size of the "
"string (including the terminating null byte) specified in I<arg3> (the key "
"type)  or I<arg4> (the key description)  exceeded the limit (32 bytes and "
"4096 bytes respectively)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1756
#, no-wrap
msgid "B<EINVAL> (Linux kernels before 4.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1764
msgid "I<operation> was B<KEYCTL_DH_COMPUTE>, argument I<arg5> was non-NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1770
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> And the digest size of the hashing "
"algorithm supplied is zero."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1777
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the buffer size provided is not "
"enough to hold the result.  Provide 0 as a buffer size in order to obtain "
"the minimum buffer size."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1790
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the hash name provided in the "
"I<hashname> field of the I<struct keyctl_kdf_params> pointed by I<arg5> "
"argument is too big (the limit is implementation-specific and varies between "
"kernel versions, but it is deemed big enough for all valid algorithm names)."
msgstr ""

#.  commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
#. type: Plain text
#: build/C/man2/keyctl.2:1803
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the I<__spare> field of the "
"I<struct keyctl_kdf_params> provided in the I<arg5> argument contains "
"nonzero values."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1806
msgid "An expired key was found or specified."
msgstr "期限切れの鍵が見つかったか指定された。"

#. type: TP
#: build/C/man2/keyctl.2:1806 build/C/man2/request_key.2:416
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr "B<EKEYREJECTED>"

#. type: Plain text
#: build/C/man2/keyctl.2:1809
msgid "A rejected key was found or specified."
msgstr "除外 (rejected) された鍵が見つかったか指定された。"

#. type: Plain text
#: build/C/man2/keyctl.2:1812
msgid "A revoked key was found or specified."
msgstr "廃止された鍵が見つかったか指定された。"

#. type: TP
#: build/C/man2/keyctl.2:1812
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1819
msgid ""
"I<operation> was B<KEYCTL_LINK> and the requested link would cause the "
"maximum nesting depth for keyrings to be exceeded."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1819
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1836
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the buffer length exceeds "
"B<KEYCTL_KDF_MAX_OUTPUT_LEN> (which is 1024 currently)  or the "
"I<otherinfolen> field of the I<struct keyctl_kdf_parms> passed in I<arg5> "
"exceeds B<KEYCTL_KDF_MAX_OI_LEN> (which is 64 currently)."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1836
#, no-wrap
msgid "B<ENFILE> (Linux kernels before 3.13)"
msgstr ""

#.  commit b2a4df200d570b2c33a57e1ebfa5896e4bc81b69
#. type: Plain text
#: build/C/man2/keyctl.2:1846
msgid ""
"I<operation> was B<KEYCTL_LINK> and the keyring is full.  (Before Linux "
"3.13, the available space for storing keyring links was limited to a single "
"page of memory; since Linux 3.13, there is no fixed limit.)"
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1846 build/C/man2/keyctl.2:1852
#: build/C/man2/keyctl.2:1864
#, fuzzy, no-wrap
#| msgid "B<ENOKEY>"
msgid "B<ENOENT>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: build/C/man2/keyctl.2:1852
msgid ""
"I<operation> was B<KEYCTL_UNLINK> and the key to be unlinked isn't linked to "
"the keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1864
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the hashing algorithm specified in "
"the I<hashname> field of the I<struct keyctl_kdf_params> pointed by I<arg5> "
"argument hasn't been found."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1872
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and the type provided in I<arg3> "
"argument doesn't support setting key linking restrictions."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1875
msgid "No matching key was found or an invalid key was specified."
msgstr "一致する鍵が見つからなかったか、 無効な鍵が指定された。"

#. type: Plain text
#: build/C/man2/keyctl.2:1886
msgid ""
"The value B<KEYCTL_GET_KEYRING_ID> was specified in I<operation>, the key "
"specified in I<arg2> did not exist, and I<arg3> was zero (meaning don't "
"create the key if it didn't exist)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1890
msgid ""
"One of kernel memory allocation routines failed during the execution of the "
"syscall."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1890
#, fuzzy, no-wrap
#| msgid "B<ENOKEY>"
msgid "B<ENOTDIR>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: build/C/man2/keyctl.2:1894
msgid ""
"A key of keyring type was expected but the ID of a key with a different type "
"was provided."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1894 build/C/man2/keyctl.2:1902
#: build/C/man2/keyctl.2:1908
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1902
msgid ""
"I<operation> was B<KEYCTL_READ> and the key type does not support reading (e."
"g., the type is I<\"login\">)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1908
msgid ""
"I<operation> was B<KEYCTL_UPDATE> and the key type does not support updating."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1919
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING>, the type provided in I<arg3> "
"argument was \"asymmetric\", and the key specified in the restriction "
"specification provided in I<arg4> has type other than \"asymmetric\" or "
"\"keyring\"."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1929
msgid ""
"I<operation> was B<KEYCTL_GET_PERSISTENT>, I<arg2> specified a UID other "
"than the calling thread's real or effective UID, and the caller did not have "
"the B<CAP_SETUID> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1944
msgid ""
"I<operation> was B<KEYCTL_SESSION_TO_PARENT> and either: all of the UIDs "
"(GIDs) of the parent process do not match the effective UID (GID) of the "
"calling process; the UID of the parent's existing session keyring or the UID "
"of the caller's session keyring did not match the effective UID of the "
"caller; the parent process is not single-thread; or the parent process is "
"B<init>(1)  or a kernel thread."
msgstr ""

#. type: TP
#: build/C/man2/keyctl.2:1944
#, fuzzy, no-wrap
#| msgid "B<KEYCTL_SET_TIMEOUT>"
msgid "B<ETIMEDOUT>"
msgstr "B<KEYCTL_SET_TIMEOUT>"

#. type: Plain text
#: build/C/man2/keyctl.2:1950
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the initialization of crypto "
"modules has timed out."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1964
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided "
"in the I<libkeyutils> library.  When employing the wrapper in that library, "
"link with I<-lkeyutils>.  However, rather than using this system call "
"directly, you probably want to use the various library functions mentioned "
"in the descriptions of individual operations above."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1972
msgid ""
"The program below provide subset of the functionality of the B<request-"
"key>(8)  program provided by the I<keyutils> package.  For informational "
"purposes, the program records various information in a log file."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1982
msgid ""
"As described in B<request_key>(2), the B<request-key>(8)  program is invoked "
"with command-line arguments that describe a key that is to be instantiated.  "
"The example program fetches and logs these arguments.  The program assumes "
"authority to instantiate the requested key, and then instantiates that key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:1995
msgid ""
"The following shell session demonstrates the use of this program.  In the "
"session, we compile the program and then use it to temporarily replace the "
"standard B<request-key>(8)  program.  (Note that temporarily disabling the "
"standard B<request-key>(8)  program may not be safe on some systems.)  While "
"our example program is installed, we use the example program shown in "
"B<request_key>(2)  to request a key."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2004
#, no-wrap
msgid ""
"$ B<cc -o key_instantiate key_instantiate.c -lkeyutils>\n"
"$ B<sudo mv /sbin/request-key /sbin/request-key.backup>\n"
"$ B<sudo cp key_instantiate /sbin/request-key>\n"
"$ B<./t_request_key user mykey somepayloaddata>\n"
"Key ID is 20d035bf\n"
"$ B<sudo mv /sbin/request-key.backup /sbin/request-key>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2009
msgid ""
"Looking at the log file created by this program, we can see the command-line "
"arguments supplied to our example program:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2014
#, no-wrap
msgid ""
"$ B<cat /tmp/key_instantiate.log>\n"
"Time: Mon Nov  7 13:06:47 2016\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2024
#, no-wrap
msgid ""
"Command line arguments:\n"
"  argv[0]:            /sbin/request-key\n"
"  operation:          create\n"
"  key_to_instantiate: 20d035bf\n"
"  UID:                1000\n"
"  GID:                1000\n"
"  thread_keyring:     0\n"
"  process_keyring:    0\n"
"  session_keyring:    256e6a6\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2029
#, no-wrap
msgid ""
"Key description:      user;1000;1000;3f010000;mykey\n"
"Auth key payload:     somepayloaddata\n"
"Destination keyring:  256e6a6\n"
"Auth key description: .request_key_auth;1000;1000;0b010000;20d035bf\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2034
msgid ""
"The last few lines of the above output show that the example program was "
"able to fetch:"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2038
msgid ""
"the description of the key to be instantiated, which included the name of "
"the key (I<mykey>);"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2043
msgid ""
"the payload of the authorization key, which consisted of the data "
"(I<somepayloaddata>)  passed to B<request_key>(2);"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2047
msgid ""
"the destination keyring that was specified in the call to B<request_key>(2); "
"and"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2052
msgid ""
"the description of the authorization key, where we can see that the name of "
"the authorization key matches the ID of the key that is to be instantiated "
"(I<20d035bf>)."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2066
msgid ""
"The example program in B<request_key>(2)  specified the destination keyring "
"as B<KEY_SPEC_SESSION_KEYRING>.  By examining the contents of I</proc/keys>, "
"we can see that this was translated to the ID of the destination keyring "
"(I<0256e6a6>)  shown in the log output above; we can also see the newly "
"created key with the name I<mykey> and ID I<20d035bf>."
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2072
#, no-wrap
msgid ""
"$ B<cat /proc/keys | egrep \\(aqmykey|256e6a6\\(aq>\n"
"0256e6a6 I--Q---  194 perm 3f030000  1000  1000 keyring  _ses: 3\n"
"20d035bf I--Q---    1 perm 3f010000  1000  1000 user     mykey: 16\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2078
#, no-wrap
msgid "/* key_instantiate.c */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2089
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2093
#, no-wrap
msgid ""
"#ifndef KEY_SPEC_REQUESTOR_KEYRING\n"
"#define KEY_SPEC_REQUESTOR_KEYRING      -8\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2108
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *fp;\n"
"    time_t t;\n"
"    char *operation;\n"
"    key_serial_t key_to_instantiate, dest_keyring;\n"
"    key_serial_t thread_keyring, process_keyring, session_keyring;\n"
"    uid_t uid;\n"
"    gid_t gid;\n"
"    char dbuf[256];\n"
"    char auth_key_payload[256];\n"
"    int akp_size;       /* Size of auth_key_payload */\n"
"    int auth_key;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2112
#, no-wrap
msgid ""
"    fp = fopen(\"/tmp/key_instantiate.log\", \"w\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2114
#, no-wrap
msgid "    setbuf(fp, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2117
#, no-wrap
msgid ""
"    t = time(NULL);\n"
"    fprintf(fp, \"Time: %s\\en\", ctime(&t));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2129
#, no-wrap
msgid ""
"    /*\n"
"     * The kernel passes a fixed set of arguments to the program\n"
"     * that it execs; fetch them.\n"
"     */\n"
"    operation = argv[1];\n"
"    key_to_instantiate = atoi(argv[2]);\n"
"    uid = atoi(argv[3]);\n"
"    gid = atoi(argv[4]);\n"
"    thread_keyring = atoi(argv[5]);\n"
"    process_keyring = atoi(argv[6]);\n"
"    session_keyring = atoi(argv[7]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2144
#, no-wrap
msgid ""
"    fprintf(fp, \"Command line arguments:\\en\");\n"
"    fprintf(fp, \"  argv[0]:            %s\\en\", argv[0]);\n"
"    fprintf(fp, \"  operation:          %s\\en\", operation);\n"
"    fprintf(fp, \"  key_to_instantiate: %jx\\en\",\n"
"            (uintmax_t) key_to_instantiate);\n"
"    fprintf(fp, \"  UID:                %jd\\en\", (intmax_t) uid);\n"
"    fprintf(fp, \"  GID:                %jd\\en\", (intmax_t) gid);\n"
"    fprintf(fp, \"  thread_keyring:     %jx\\en\",\n"
"            (uintmax_t) thread_keyring);\n"
"    fprintf(fp, \"  process_keyring:    %jx\\en\",\n"
"            (uintmax_t) process_keyring);\n"
"    fprintf(fp, \"  session_keyring:    %jx\\en\",\n"
"            (uintmax_t) session_keyring);\n"
"    fprintf(fp, \"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2153
#, no-wrap
msgid ""
"    /*\n"
"     * Assume the authority to instantiate the key named in argv[2]\n"
"     */\n"
"    if (keyctl(KEYCTL_ASSUME_AUTHORITY, key_to_instantiate) == -1) {\n"
"        fprintf(fp, \"KEYCTL_ASSUME_AUTHORITY failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2162
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the description of the key that is to be instantiated\n"
"     */\n"
"    if (keyctl(KEYCTL_DESCRIBE, key_to_instantiate,\n"
"                dbuf, sizeof(dbuf)) == -1) {\n"
"        fprintf(fp, \"KEYCTL_DESCRIBE failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2164
#, no-wrap
msgid "    fprintf(fp, \"Key description:      %s\\en\", dbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2175
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the payload of the authorization key, which is\n"
"     * actually the callout data given to request_key()\n"
"     */\n"
"    akp_size = keyctl(KEYCTL_READ, KEY_SPEC_REQKEY_AUTH_KEY,\n"
"                      auth_key_payload, sizeof(auth_key_payload));\n"
"    if (akp_size == -1) {\n"
"        fprintf(fp, \"KEYCTL_READ failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2178
#, no-wrap
msgid ""
"    auth_key_payload[akp_size] = \\(aq\\e0\\(aq;\n"
"    fprintf(fp, \"Auth key payload:     %s\\en\", auth_key_payload);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2190
#, no-wrap
msgid ""
"    /*\n"
"     * For interest, get the ID of the authorization key and\n"
"     * display it.\n"
"     */\n"
"    auth_key = keyctl(KEYCTL_GET_KEYRING_ID,\n"
"            KEY_SPEC_REQKEY_AUTH_KEY);\n"
"    if (auth_key == -1) {\n"
"        fprintf(fp, \"KEYCTL_GET_KEYRING_ID failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2192
#, no-wrap
msgid "    fprintf(fp, \"Auth key ID:          %jx\\en\", (uintmax_t) auth_key);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2203
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch key ID for the request_key(2) destination keyring.\n"
"     */\n"
"    dest_keyring = keyctl(KEYCTL_GET_KEYRING_ID,\n"
"                          KEY_SPEC_REQUESTOR_KEYRING);\n"
"    if (dest_keyring == -1) {\n"
"        fprintf(fp, \"KEYCTL_GET_KEYRING_ID failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2205
#, no-wrap
msgid "    fprintf(fp, \"Destination keyring:  %jx\\en\", (uintmax_t) dest_keyring);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2218
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the description of the authorization key. This\n"
"     * allows us to see the key type, UID, GID, permissions,\n"
"     * and description (name) of the key. Among other things,\n"
"     * we will see that the name of the key is a hexadecimal\n"
"     * string representing the ID of the key to be instantiated.\n"
"     */\n"
"    if (keyctl(KEYCTL_DESCRIBE, KEY_SPEC_REQKEY_AUTH_KEY,\n"
"                dbuf, sizeof(dbuf)) == -1) {\n"
"        fprintf(fp, \"KEYCTL_DESCRIBE failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2220
#, no-wrap
msgid "    fprintf(fp, \"Auth key description: %s\\en\", dbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/keyctl.2:2231
#, no-wrap
msgid ""
"    /*\n"
"     * Instantiate the key using the callout data that was supplied\n"
"     * in the payload of the authorization key.\n"
"     */\n"
"    if (keyctl(KEYCTL_INSTANTIATE, key_to_instantiate,\n"
"               auth_key_payload, akp_size + 1, dest_keyring) == -1) {\n"
"        fprintf(fp, \"KEYCTL_INSTANTIATE failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#.      .BR find_key_by_type_and_name (3)
#.      There is a man page, but this function seems not to exist
#. type: Plain text
#: build/C/man2/keyctl.2:2286
#, fuzzy
#| msgid ""
#| "B<keyctl>(1), B<add_key>(2), B<request_key>(2), B<keyctl_set_timeout>(3), "
#| "B<keyctl_chown>(3), B<keyctl_clear>(3), B<keyctl_describe>(3), "
#| "B<keyctl_describe_alloc>(3), B<keyctl_get_keyring_ID>(3), "
#| "B<keyctl_instantiate>(3), B<keyctl_join_session_keyring>(3), "
#| "B<keyctl_link>(3), B<keyctl_negate>(3), B<keyctl_revoke>(3), "
#| "B<keyctl_search>(3), B<keyctl_setperm>(3), "
#| "B<keyctl_set_reqkey_keyring>(3), B<keyctl_set_timeout>(3), "
#| "B<keyctl_read>(3), B<keyctl_read_alloc>(3), B<keyctl_unlink>(3), "
#| "B<keyctl_update>(3), B<request-key>(8)"
msgid ""
"B<keyctl>(1), B<add_key>(2), B<request_key>(2), B<keyctl>(3), "
"B<keyctl_assume_authority>(3), B<keyctl_chown>(3), B<keyctl_clear>(3), "
"B<keyctl_describe>(3), B<keyctl_describe_alloc>(3), B<keyctl_dh_compute>(3), "
"B<keyctl_dh_compute_alloc>(3), B<keyctl_get_keyring_ID>(3), "
"B<keyctl_get_persistent>(3), B<keyctl_get_security>(3), "
"B<keyctl_get_security_alloc>(3), B<keyctl_instantiate>(3), "
"B<keyctl_instantiate_iov>(3), B<keyctl_invalidate>(3), "
"B<keyctl_join_session_keyring>(3), B<keyctl_link>(3), B<keyctl_negate>(3), "
"B<keyctl_read>(3), B<keyctl_read_alloc>(3), B<keyctl_reject>(3), "
"B<keyctl_revoke>(3), B<keyctl_search>(3), B<keyctl_session_to_parent>(3), "
"B<keyctl_set_reqkey_keyring>(3), B<keyctl_set_timeout>(3), "
"B<keyctl_setperm>(3), B<keyctl_unlink>(3), B<keyctl_update>(3), "
"B<recursive_key_scan>(3), B<recursive_session_key_scan>(3), "
"B<capabilities>(7), B<credentials>(7), B<keyrings>(7), B<keyutils>(7), "
"B<persistent-keyring>(7), B<process-keyring>(7), B<session-keyring>(7), "
"B<thread-keyring>(7), B<user-keyring>(7), B<user_namespaces>(7), B<user-"
"session-keyring>(7), B<request-key>(8)"
msgstr ""
"B<keyctl>(1), B<add_key>(2), B<request_key>(2), B<keyctl_set_timeout>(3), "
"B<keyctl_chown>(3), B<keyctl_clear>(3), B<keyctl_describe>(3), "
"B<keyctl_describe_alloc>(3), B<keyctl_get_keyring_ID>(3), "
"B<keyctl_instantiate>(3), B<keyctl_join_session_keyring>(3), "
"B<keyctl_link>(3), B<keyctl_negate>(3), B<keyctl_revoke>(3), "
"B<keyctl_search>(3), B<keyctl_setperm>(3), B<keyctl_set_reqkey_keyring>(3), "
"B<keyctl_set_timeout>(3), B<keyctl_read>(3), B<keyctl_read_alloc>(3), "
"B<keyctl_unlink>(3), B<keyctl_update>(3), B<request-key>(8)"

#. type: Plain text
#: build/C/man2/keyctl.2:2291
#, fuzzy
#| msgid "The kernel source file I<Documentation/security/keys.txt>."
msgid ""
"The kernel source files under I<Documentation/security/keys/> (or, before "
"Linux 4.13, in the file I<Documentation/security/keys.txt>)."
msgstr "カーネルのソースファイル I<Documentation/security/keys.txt>"

#. type: TH
#: build/C/man2/request_key.2:12
#, no-wrap
msgid "REQUEST_KEY"
msgstr "REQUEST_KEY"

#. type: Plain text
#: build/C/man2/request_key.2:15
msgid "request_key - request a key from the kernel's key management facility"
msgstr "request_key - カーネルの鍵管理機能から鍵を取得する"

#. type: Plain text
#: build/C/man2/request_key.2:23
#, fuzzy, no-wrap
#| msgid ""
#| "B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
#| "B<                         const char *>I<callout_info>B<,>\n"
#| "B<                         key_serial_t >I<keyring>B<);>\n"
msgid ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<dest_keyring>B<);>\n"
msgstr ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<keyring>B<);>\n"

#. type: Plain text
#: build/C/man2/request_key.2:38
msgid ""
"B<request_key>()  attempts to find a key of the given I<type> with a "
"description (name) that matches the specified I<description>.  If such a key "
"could not be found, then the key is optionally created.  If the key is found "
"or created, B<request_key>()  attaches it to the keyring whose ID is "
"specified in I<dest_keyring> and returns the key's serial number."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:44
msgid ""
"B<request_key>()  first recursively searches for a matching key in all of "
"the keyrings attached to the calling process.  The keyrings are searched in "
"the order: thread-specific keyring, process-specific keyring, and then "
"session keyring."
msgstr ""

#.  David Howells: we can then have an arbitrarily long sequence
#.  of "recursive" request-key upcalls. There is no limit, other
#.  than number of PIDs, etc.
#. type: Plain text
#: build/C/man2/request_key.2:56
msgid ""
"If B<request_key>()  is called from a program invoked by B<request_key>()  "
"on behalf of some other process to generate a key, then the keyrings of that "
"other process will be searched next, using that other process's user ID, "
"group ID, supplementary group IDs, and security context to determine access."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:65
msgid ""
"The search of the keyring tree is breadth-first: the keys in each keyring "
"searched are checked for a match before any child keyrings are recursed "
"into.  Only keys for which the caller has I<search> permission be found, and "
"only keyrings for which the caller has I<search> permission may be searched."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:70
msgid ""
"If the key is not found and I<callout> is NULL, then the call fails with the "
"error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:76
msgid ""
"If the key is not found and I<callout> is not NULL, then the kernel attempts "
"to invoke a user-space program to instantiate the key.  The details are "
"given below."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:82
#, fuzzy
#| msgid ""
#| "The destination I<keyring> serial number may be that of a valid keyring "
#| "to which the caller has write permission, or it may be a special keyring "
#| "ID:"
msgid ""
"The I<dest_keyring> serial number may be that of a valid keyring for which "
"the caller has I<write> permission, or it may be one of the following "
"special keyring IDs:"
msgstr ""
"対象の I<keyring> のシリアル番号には、 呼び出し元が書き込み許可を持つ有効な鍵"
"リングのシリアル番号か、 以下の特別な鍵リング ID を指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:86
#, fuzzy
#| msgid "This specifies the caller's thread-specific keyring."
msgid ""
"This specifies the caller's thread-specific keyring (see B<thread-"
"keyring>(7))."
msgstr "この値は呼び出し元スレッド固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:90
#, fuzzy
#| msgid "This specifies the caller's process-specific keyring."
msgid ""
"This specifies the caller's process-specific keyring (see B<process-"
"keyring>(7))."
msgstr "この値は呼び出し元プロセス固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:94
#, fuzzy
#| msgid "This specifies the caller's session-specific keyring."
msgid ""
"This specifies the caller's session-specific keyring (see B<session-"
"keyring>(7))."
msgstr "この値は呼び出し元セッション固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:98
#, fuzzy
#| msgid "This specifies the caller's UID-specific keyring."
msgid ""
"This specifies the caller's UID-specific keyring (see B<user-keyring>(7))."
msgstr "この値は呼び出し元の UID 固有の鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:102
#, fuzzy
#| msgid "This specifies the caller's UID-session keyring."
msgid ""
"This specifies the caller's UID-session keyring (see B<user-session-"
"keyring>(7))."
msgstr "この値は呼び出し元の UID のセッションの鍵リングを指定する。"

#. type: Plain text
#: build/C/man2/request_key.2:108
msgid ""
"When the I<dest_keyring> is specified as 0 and no key construction has been "
"performed, then no additional linking is done."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:121
msgid ""
"Otherwise, if I<dest_keyring> is 0 and a new key is constructed, the new key "
"will be linked to the \"default\" keyring.  More precisely, when the kernel "
"tries to determine to which keyring the newly constructed key should be "
"linked, it tries the following keyrings, beginning with the keyring set via "
"the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation and continuing in "
"the order shown below until it finds the first keyring that exists:"
msgstr ""

#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME
#.  Actually, is the preceding point correct?
#.  If I understand correctly, we'll only get here if
#.  'dest_keyring' is zero, in which case KEY_REQKEY_DEFL_REQUESTOR_KEYRING
#.  won't refer to a keyring. Have I misunderstood?
#. type: Plain text
#: build/C/man2/request_key.2:131
msgid ""
"The requestor keyring (B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING>, since Linux "
"2.6.29)."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:136
msgid ""
"The thread-specific keyring (B<KEY_REQKEY_DEFL_THREAD_KEYRING>; see B<thread-"
"keyring>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:141
msgid ""
"The process-specific keyring (B<KEY_REQKEY_DEFL_PROCESS_KEYRING>; see "
"B<process-keyring>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:146
msgid ""
"The session-specific keyring (B<KEY_REQKEY_DEFL_SESSION_KEYRING>; see "
"B<session-keyring>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:152
msgid ""
"The session keyring for the process's user ID "
"(B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>; see B<user-session-keyring>(7)).  "
"This keyring is expected to always exist."
msgstr ""

#
#
#
#
#
#.  mtk: Are there circumstances where the user sessions and UID-specific
#.  keyrings do not exist?
#.  David Howells:
#.      The uid keyrings don't exist until someone tries to access them -
#.      at which point they're both created.  When you log in, pam_keyinit
#.      creates a link to your user keyring in the session keyring it just
#.      created, thereby creating the user and user-session keyrings.
#.  and David elaborated that "access" means:
#.      It means lookup_user_key() was passed KEY_LOOKUP_CREATE.  So:
#.          add_key() - destination keyring
#.          request_key() - destination keyring
#.          KEYCTL_GET_KEYRING_ID - if create arg is true
#.          KEYCTL_CLEAR
#.          KEYCTL_LINK - both args
#.          KEYCTL_SEARCH - destination keyring
#.          KEYCTL_CHOWN
#.          KEYCTL_SETPERM
#.          KEYCTL_SET_TIMEOUT
#.          KEYCTL_INSTANTIATE - destination keyring
#.          KEYCTL_INSTANTIATE_IOV - destination keyring
#.          KEYCTL_NEGATE - destination keyring
#.          KEYCTL_REJECT - destination keyring
#.          KEYCTL_GET_PERSISTENT - destination keyring
#.      will all create a keyring under some circumstances.  Whereas the rest,
#.      such as KEYCTL_GET_SECURITY, KEYCTL_READ and KEYCTL_REVOKE, won't.
#. type: Plain text
#: build/C/man2/request_key.2:188
msgid ""
"The UID-specific keyring (B<KEY_REQKEY_DEFL_USER_KEYRING>; see B<user-"
"keyring>(7)).  This keyring is also expected to always exist."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:200
msgid ""
"If the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation specifies "
"B<KEY_REQKEY_DEFL_DEFAULT> (or no B<KEYCTL_SET_REQKEY_KEYRING> operation is "
"performed), then the kernel looks for a keyring starting from the beginning "
"of the list."
msgstr ""

#. type: SS
#: build/C/man2/request_key.2:200
#, no-wrap
msgid "Requesting user-space instantiation of a key"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:213
msgid ""
"If the kernel cannot find a key matching I<type> and I<description>, and "
"I<callout> is not NULL, then the kernel attempts to invoke a user-space "
"program to instantiate a key with the given I<type> and I<description>.  In "
"this case, the following steps are performed:"
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:213
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:218
msgid ""
"The kernel creates an uninstantiated key, U, with the requested I<type> and "
"I<description>."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:218
#, no-wrap
msgid "b)"
msgstr ""

#.  struct request_key_auth, defined in security/keys/internal.h
#. type: Plain text
#: build/C/man2/request_key.2:224
msgid ""
"The kernel creates an authorization key, V, that refers to the key U and "
"records the facts that the caller of B<request_key>()  is:"
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:225 build/C/man7/keyrings.7:317
#: build/C/man7/keyrings.7:448
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:227
msgid "the context in which the key U should be instantiated and secured, and"
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:227 build/C/man7/keyrings.7:321
#: build/C/man7/keyrings.7:458
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:229
msgid "the context from which associated key requests may be satisfied."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:232
msgid "The authorization key is constructed as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:236
msgid "The key type is I<\".request_key_auth\">."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:239
msgid ""
"The key's UID and GID are the same as the corresponding filesystem IDs of "
"the requesting process."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:248
msgid ""
"The key grants I<view>, I<read>, and I<search> permissions to the key "
"possessor as well as I<view> permission for the key user."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:252
msgid ""
"The description (name) of the key is the hexadecimal string representing the "
"ID of the key that is to be instantiated in the requesting program."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:255
msgid ""
"The payload of the key is taken from the data specified in I<callout_info>."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:258
msgid ""
"Internally, the kernel also records the PID of the process that called "
"B<request_key>()."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:259
#, no-wrap
msgid "c)"
msgstr ""

#.  The request\-key(8) program can be invoked in circumstances *other* than
#.  when triggered by request_key(2). For example, upcalls from places such
#.  as the DNS resolver.
#. type: Plain text
#: build/C/man2/request_key.2:266
msgid ""
"The kernel creates a process that executes a user-space service such as "
"B<request-key>(8)  with a new session keyring that contains a link to the "
"authorization key, V."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:268
msgid "This program is supplied with the following command-line arguments:"
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:269
#, no-wrap
msgid "[0]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:272
msgid "The string I<\"/sbin/request-key\">."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:272
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:276
msgid "The string I<\"create\"> (indicating that a key is to be created)."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:276
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:278
msgid "The ID of the key that is to be instantiated."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:278
#, no-wrap
msgid "[3]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:281
msgid "The filesystem UID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:281
#, no-wrap
msgid "[4]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:284
msgid "The filesystem GID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:284
#, no-wrap
msgid "[5]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:288
msgid ""
"The ID of the thread keyring of the caller of B<request_key>().  This may be "
"zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:288
#, no-wrap
msgid "[6]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:292
msgid ""
"The ID of the process keyring of the caller of B<request_key>().  This may "
"be zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:292
#, no-wrap
msgid "[7]"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:295
msgid "The ID of the session keyring of the caller of B<request_key>()."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:303
msgid ""
"I<Note>: each of the command-line arguments that is a key ID is encoded in "
"I<decimal> (unlike the key IDs shown in I</proc/keys>, which are shown as "
"hexadecimal values)."
msgstr ""

#. type: IP
#: build/C/man2/request_key.2:303
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:305
msgid "The program spawned in the previous step:"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:313
msgid ""
"Assumes the authority to instantiate the key U using the B<keyctl>(2)  "
"B<KEYCTL_ASSUME_AUTHORITY> operation (typically via the "
"B<keyctl_assume_authority>(3)  function)."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:322
msgid ""
"Obtains the callout data from the payload of the authorization key V (using "
"the B<keyctl>(2)  B<KEYCTL_READ> operation (or, more commonly, the "
"B<keyctl_read>(3)  function) with a key ID value of "
"B<KEY_SPEC_REQKEY_AUTH_KEY>)."
msgstr ""

#.  Should an instantiating program be using KEY_SPEC_REQUESTOR_KEYRING?
#.  I couldn't find a use in the keyutils git repo.
#.  According to David Howells:
#.  * This feature is provided, but not used at the moment.
#.  * A key added to that ring is then owned by the requester
#. type: Plain text
#: build/C/man2/request_key.2:344
msgid ""
"Instantiates the key (or execs another program that performs that task), "
"specifying the payload and destination keyring.  (The destination keyring "
"that the requestor specified when calling B<request_key>()  can be accessed "
"using the special key ID B<KEY_SPEC_REQUESTOR_KEYRING>.)  Instantiation is "
"performed using the B<keyctl>(2)  B<KEYCTL_INSTANTIATE> operation (or, more "
"commonly, the B<keyctl_instantiate>(3)  function).  At this point, the "
"B<request_key>()  call completes, and the requesting program can continue "
"execution."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:361
msgid ""
"If these steps are unsuccessful, then an B<ENOKEY> error will be returned to "
"the caller of B<request_key>()  and a temporary, negatively instantiated key "
"will be installed in the keyring specified by I<dest_keyring>.  This will "
"expire after a few seconds, but will cause subsequent calls to "
"B<request_key>()  to fail until it does.  The purpose of this negatively "
"instantiated key is to prevent (possibly different) processes making "
"repeated requests (that require expensive B<request-key>(8)  upcalls) for a "
"key that can't (at the moment) be positively instantiated."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:369
msgid ""
"Once the key has been instantiated, the authorization key "
"(B<KEY_SPEC_REQKEY_AUTH_KEY>)  is revoked, and the destination keyring "
"(B<KEY_SPEC_REQUESTOR_KEYRING>)  is no longer accessible from the B<request-"
"key>(8)  program."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:374
msgid ""
"If a key is created, then\\(emregardless of whether it is a valid key or a "
"negatively instantiated key\\(emit will displace any other key with the same "
"type and description from the keyring specified in I<dest_keyring>."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:381
#, fuzzy
#| msgid ""
#| "On success B<request_key>()  returns the serial number of the key it "
#| "found.  On error, the value -1 will be returned and errno will have been "
#| "set to an appropriate error."
msgid ""
"On success, B<request_key>()  returns the serial number of the key it found "
"or caused to be created.  On error, -1 is returned and I<errno> is set to "
"indicate the cause of the error."
msgstr ""
"成功すると B<request_key>() は見つかった鍵のシリアル番号を返す。 エラーの場"
"合、 値 -1 が返され、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/request_key.2:397
msgid ""
"One of I<type>, I<description>, or I<callout_info> points outside the "
"process's accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/request_key.2:397
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/request_key.2:401
#, fuzzy
#| msgid "The request was interrupted by a signal."
msgid "The request was interrupted by a signal; see B<signal>(7)."
msgstr "要求がシングルで中断された。"

#. type: Plain text
#: build/C/man2/request_key.2:413
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<callout_info> exceeded the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:416
msgid "An expired key was found, but no replacement could be obtained."
msgstr "期限切れの鍵が見つかったが、 新しい代わりの鍵が取得できなかった。"

#. type: Plain text
#: build/C/man2/request_key.2:419
msgid "The attempt to generate a new key was rejected."
msgstr "新しい鍵の生成が拒否された。"

#. type: Plain text
#: build/C/man2/request_key.2:422
msgid "A revoked key was found, but no replacement could be obtained."
msgstr "廃止された鍵が見つかったが、 新しい代わりの鍵が取得できなかった。"

#. type: Plain text
#: build/C/man2/request_key.2:425
msgid "No matching key was found."
msgstr "合致する鍵が見つからなかった。"

#. type: Plain text
#: build/C/man2/request_key.2:433
msgid "The I<type> argument started with a period (\\(aq.\\(aq)."
msgstr ""

#.  commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
#. type: Plain text
#: build/C/man2/request_key.2:438
msgid ""
"This system call first appeared in Linux 2.6.10.  The ability to instantiate "
"keys upon request was added in Linux 2.6.13."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:458
msgid ""
"The program below demonstrates the use of B<request_key>().  The I<type>, "
"I<description>, and I<callout_info> arguments for the system call are taken "
"from the values supplied in the command-line arguments.  The call specifies "
"the session keyring as the target keyring."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:462
msgid ""
"In order to demonstrate this program, we first create a suitable entry in "
"the file I</etc/request-key.conf>."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:469
#, no-wrap
msgid ""
"$ sudo sh\n"
"# B<echo \\(aqcreate user mtk:* *   /bin/keyctl instantiate %k %c %S\\(aq \\e>\n"
"          B<E<gt> /etc/request-key.conf>\n"
"# B<exit>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:496
msgid ""
"This entry specifies that when a new \"user\" key with the prefix \"mtk:\" "
"must be instantiated, that task should be performed via the B<keyctl>(1)  "
"command's B<instantiate> operation.  The arguments supplied to the "
"B<instantiate> operation are: the ID of the uninstantiated key (I<%k>); the "
"callout data supplied to the B<request_key>()  call (I<%c>); and the session "
"keyring (I<%S>)  of the requestor (i.e., the caller of B<request_key>()).  "
"See B<request-key.conf>(5)  for details of these I<%> specifiers."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:500
msgid ""
"Then we run the program and check the contents of I</proc/keys> to verify "
"that the requested key has been instantiated:"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:506
#, no-wrap
msgid ""
"$ B<./t_request_key user mtk:key1 \"Payload data\">\n"
"$ B<grep \\(aq2dddaf50\\(aq /proc/keys>\n"
"2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12\n"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:511
msgid "For another example of the use of this program, see B<keyctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:515
#, no-wrap
msgid "/* t_request_key.c */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:533
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description callout-data\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:540
#, no-wrap
msgid ""
"    key = request_key(argv[1], argv[2], argv[3],\n"
"                      KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"request_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/request_key.2:563
msgid ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<keyctl>(3), B<capabilities>(7), "
"B<keyrings>(7), B<keyutils>(7), B<persistent-keyring>(7), B<process-"
"keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7), B<request-key>(8)"
msgstr ""

#. type: TH
#: build/C/man7/keyrings.7:12
#, no-wrap
msgid "KEYRINGS"
msgstr ""

#. type: TH
#: build/C/man7/keyrings.7:12 build/C/man7/persistent-keyring.7:11
#: build/C/man7/process-keyring.7:11 build/C/man7/session-keyring.7:11
#: build/C/man7/thread-keyring.7:11 build/C/man7/user-keyring.7:11
#: build/C/man7/user-session-keyring.7:11
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: TH
#: build/C/man7/keyrings.7:12 build/C/man7/persistent-keyring.7:11
#: build/C/man7/process-keyring.7:11 build/C/man7/session-keyring.7:11
#: build/C/man7/thread-keyring.7:11 build/C/man7/user-keyring.7:11
#: build/C/man7/user-session-keyring.7:11
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:15
#, fuzzy
#| msgid "keyctl - manipulate the kernel's key management facility"
msgid "keyrings - in-kernel key management and retention facility"
msgstr "keyctl - カーネルの鍵管理機能を操作する"

#. type: Plain text
#: build/C/man7/keyrings.7:20
msgid ""
"The Linux key-management facility is primarily a way for various kernel "
"components to retain or cache security data, authentication keys, encryption "
"keys, and other data in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:27
msgid ""
"System call interfaces are provided so that user-space programs can manage "
"those objects and also use the facility for their own purposes; see "
"B<add_key>(2), B<request_key>(2), and B<keyctl>(2)."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:37
msgid ""
"A library and some user-space utilities are provided to allow access to the "
"facility.  See B<keyctl>(1), B<keyctl>(3), and B<keyutils>(7)  for more "
"information."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:37
#, no-wrap
msgid "Keys"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:39
msgid "A key has the following attributes:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:39
#, no-wrap
msgid "Serial number (ID)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:45
msgid ""
"This is a unique integer handle by which a key is referred to in system "
"calls.  The serial number is sometimes synonymously referred as the key ID.  "
"Programmatically, key serial numbers are represented using the type "
"I<key_serial_t>."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:45
#, no-wrap
msgid "Type"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:50
msgid ""
"A key's type defines what sort of data can be held in the key, how the "
"proposed content of the key will be parsed, and how the payload will be used."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:53
msgid ""
"There are a number of general-purpose types available, plus some specialist "
"types defined by specific kernel components."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:53
#, no-wrap
msgid "Description (name)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:58
msgid ""
"The key description is a printable string that is used as the search term "
"for the key (in conjunction with the key type) as well as a display name.  "
"During searches, the description may be partially matched or exactly matched."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:58
#, no-wrap
msgid "Payload (data)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:67
msgid ""
"The payload is the actual content of a key.  This is usually set when a key "
"is created, but it is possible for the kernel to upcall to user space to "
"finish the instantiation of a key if that key wasn't already known to the "
"kernel when it was requested.  For further details, see B<request_key>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:70
msgid ""
"A key's payload can be read and updated if the key type supports it and if "
"suitable permission is granted to the caller."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:70 build/C/man7/keyrings.7:354
#, no-wrap
msgid "Access rights"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:80
msgid ""
"Much as files do, each key has an owning user ID, an owning group ID, and a "
"security label.  Each key also has a set of permissions, though there are "
"more than for a normal UNIX file, and there is an additional category"
"\\(empossessor\\(embeyond the usual user, group, and other (see "
"I<Possession>, below)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:84
msgid ""
"Note that keys are quota controlled, since they require unswappable kernel "
"memory.  The owning user ID specifies whose quota is to be debited."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:84
#, no-wrap
msgid "Expiration time"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:95
msgid ""
"Each key can have an expiration time set.  When that time is reached, the "
"key is marked as being expired and accesses to it fail with the error "
"B<EKEYEXPIRED>.  If not deleted, updated, or replaced, then, after a set "
"amount of time, an expired key is automatically removed (garbage collected)  "
"along with all links to it, and attempts to access the key fail with the "
"error B<ENOKEY>."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:95
#, no-wrap
msgid "Reference count"
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:103
msgid ""
"Each key has a reference count.  Keys are referenced by keyrings, by "
"currently active users, and by a process's credentials.  When the reference "
"count reaches zero, the key is scheduled for garbage collection."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:105
msgid "The kernel provides several basic types of key:"
msgstr ""

#.  Note that keyrings use different fields in struct key in order to store
#.  their data - index_key instead of type/description and name_link/keys
#.  instead of payload.
#. type: Plain text
#: build/C/man7/keyrings.7:115
msgid ""
"Keyrings are special keys which store a set of links to other keys "
"(including other keyrings), analogous to a directory holding links to "
"files.  The main purpose of a keyring is to prevent other keys from being "
"garbage collected because nothing refers to them."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:118
msgid ""
"Keyrings with descriptions (names)  that begin with a period (\\(aq.\\(aq) "
"are reserved to the implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:123
msgid ""
"This is a general-purpose key type.  The key is kept entirely within kernel "
"memory.  The payload may be read and updated by user-space applications."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:126
msgid ""
"The payload for keys of this type is a blob of arbitrary data of up to "
"32,767 bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:132
#, fuzzy
#| msgid ""
#| "Keys of the user-defined key type may contain a blob of arbitrary data, "
#| "and the I<description> may be any valid string, though it is preferred "
#| "that the description be prefixed with a string representing the service "
#| "to which the key is of interest and a colon (for instance ``B<afs:"
#| "mykey>'').  The I<payload> may be empty or NULL for keys of this type."
msgid ""
"The description may be any valid string, though it is preferred that it "
"start with a colon-delimited prefix representing the service to which the "
"key is of interest (for instance I<\"afs:mykey\">)."
msgstr ""
"ユーザー定義の鍵タイプの鍵には、 任意のデータの blob を入れることができ、 "
"I<description> には任意の有効な文字列を指定できるが、 鍵が対象とするサービス"
"を表す文字列とコロンをプレフィックスに指定するのが推奨される方法である (例え"
"ば ``B<afs:mykey>'')。 このタイプの鍵には I<payload> に空文字列つまり NULL を"
"指定する。"

#.  commit 9f6ed2ca257fa8650b876377833e6f14e272848b
#. type: Plain text
#: build/C/man7/keyrings.7:144
msgid ""
"This key type is essentially the same as I<\"user\">, but it does not "
"provide reading (i.e., the B<keyctl>(2)  B<KEYCTL_READ> operation), meaning "
"that the key payload is never visible from user space.  This is suitable for "
"storing username-password pairs that should not be readable from user space."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:154
msgid ""
"The description of a I<\"logon\"> key I<must> start with a non-empty colon-"
"delimited prefix whose purpose is to identify the service to which the key "
"belongs.  (Note that this differs from keys of the I<\"user\"> type, where "
"the inclusion of a prefix is recommended but is not enforced.)"
msgstr ""

#.  commit ab3c3587f8cda9083209a61dbe3a4407d3cada10
#. type: Plain text
#: build/C/man7/keyrings.7:161
msgid ""
"This key type is similar to the I<\"user\"> key type, but it may hold a "
"payload of up to 1\\ MiB in size.  This key type is useful for purposes such "
"as holding Kerberos ticket caches."
msgstr ""

#.  commit 13100a72f40f5748a04017e0ab3df4cf27c809ef
#. type: Plain text
#: build/C/man7/keyrings.7:173
msgid ""
"The payload data may be stored in a tmpfs filesystem, rather than in kernel "
"memory, if the data size exceeds the overhead of storing the data in the "
"filesystem.  (Storing the data in a filesystem requires filesystem "
"structures to be allocated in the kernel.  The size of these structures "
"determines the size threshold above which the tmpfs storage method is "
"used.)  Since Linux 4.8, the payload data is encrypted when stored in tmpfs, "
"thereby preventing it from being written unencrypted into swap space."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:177
msgid ""
"There are more specialized key types available also, but they aren't "
"discussed here because they aren't intended for normal user-space use."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:181
msgid ""
"Key type names that begin with a period (\\(aq.\\(aq) are reserved to the "
"implementation."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:181
#, no-wrap
msgid "Keyrings"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:187
msgid ""
"As previously mentioned, keyrings are a special type of key that contain "
"links to other keys (which may include other keyrings).  Keys may be linked "
"to by multiple keyrings.  Keyrings may be considered as analogous to UNIX "
"directories where each directory contains a set of hard links to files."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:189
msgid "Various operations (system calls) may be applied only to keyrings:"
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:189
#, no-wrap
msgid "Adding"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:193
msgid ""
"A key may be added to a keyring by system calls that create keys.  This "
"prevents the new key from being immediately deleted when the system call "
"releases its last reference to the key."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:193
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:196
msgid ""
"A link may be added to a keyring pointing to a key that is already known, "
"provided this does not create a self-referential cycle."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:196
#, no-wrap
msgid "Unlinking"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:200
msgid ""
"A link may be removed from a keyring.  When the last link to a key is "
"removed, that key will be scheduled for deletion by the garbage collector."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:200
#, no-wrap
msgid "Clearing"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:202
#, fuzzy
#| msgid "Unlink a key from a keyring."
msgid "All the links may be removed from a keyring."
msgstr "鍵の鍵リングへの結びつけを取り消す。"

#. type: IP
#: build/C/man7/keyrings.7:202
#, no-wrap
msgid "Searching"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:207
msgid ""
"A keyring may be considered the root of a tree or subtree in which keyrings "
"form the branches and non-keyrings the leaves.  This tree may be searched "
"for a key matching a particular type and description."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:216
msgid ""
"See B<keyctl_clear>(3), B<keyctl_link>(3), B<keyctl_search>(3), and "
"B<keyctl_unlink>(3)  for more information."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:216
#, no-wrap
msgid "Anchoring keys"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:220
msgid ""
"To prevent a key from being garbage collected, it must be anchored to keep "
"its reference count elevated when it is not in active use by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:226
msgid ""
"Keyrings are used to anchor other keys: each link is a reference on a key.  "
"Note that keyrings themselves are just keys and are also subject to the same "
"anchoring requirement to prevent them being garbage collected."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:229
msgid ""
"The kernel makes available a number of anchor keyrings.  Note that some of "
"these keyrings will be created only when first accessed."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:229
#, no-wrap
msgid "Process keyrings"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:234
msgid ""
"Process credentials themselves reference keyrings with specific semantics.  "
"These keyrings are pinned as long as the set of credentials exists, which is "
"usually as long as the process exists."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:245
msgid ""
"There are three keyrings with different inheritance/sharing rules: the "
"B<session-keyring>(7)  (inherited and shared by all child processes), the "
"B<process-keyring>(7)  (shared by all threads in a process) and the B<thread-"
"keyring>(7)  (specific to a particular thread)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:258
msgid ""
"As an alternative to using the actual keyring IDs, in calls to "
"B<add_key>(2), B<keyctl>(2), and B<request_key>(2), the special keyring "
"values B<KEY_SPEC_SESSION_KEYRING>, B<KEY_SPEC_PROCESS_KEYRING>, and "
"B<KEY_SPEC_THREAD_KEYRING> can be used to refer to the caller's own "
"instances of these keyrings."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:258
#, fuzzy, no-wrap
#| msgid "Ask for a keyring's ID."
msgid "User keyrings"
msgstr "鍵リングの ID を取得する。"

#. type: Plain text
#: build/C/man7/keyrings.7:265
msgid ""
"Each UID known to the kernel has a record that contains two keyrings: the "
"B<user-keyring>(7)  and the B<user-session-keyring>(7).  These exist for as "
"long as the UID record in the kernel exists."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:277
msgid ""
"As an alternative to using the actual keyring IDs, in calls to "
"B<add_key>(2), B<keyctl>(2), and B<request_key>(2), the special keyring "
"values B<KEY_SPEC_USER_KEYRING> and B<KEY_SPEC_USER_SESSION_KEYRING> can be "
"used to refer to the caller's own instances of these keyrings."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:281
msgid ""
"A link to the user keyring is placed in a new session keyring by "
"B<pam_keyinit>(8)  when a new login session is initiated."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:281
#, no-wrap
msgid "Persistent keyrings"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:293
msgid ""
"There is a B<persistent-keyring>(7)  available to each UID known to the "
"system.  It may persist beyond the life of the UID record previously "
"mentioned, but has an expiration time set such that it is automatically "
"cleaned up after a set time.  The persistent keyring permits, for example, "
"B<cron>(8)  scripts to use credentials that are left in the persistent "
"keyring after the user logs out."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:296
msgid ""
"Note that the expiration time of the persistent keyring is reset every time "
"the persistent key is requested."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:296
#, no-wrap
msgid "Special keyrings"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:302
msgid ""
"There are special keyrings owned by the kernel that can anchor keys for "
"special purposes.  An example of this is the I<system keyring> used for "
"holding encryption keys for module signature verification."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:305
msgid ""
"These special keyrings are usually closed to direct alteration by user space."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:313
msgid ""
"An originally planned \"group keyring\", for storing keys associated with "
"each GID known to the kernel, is not so far implemented, is unlikely to be "
"implemented.  Nevertheless, the constant B<KEY_SPEC_GROUP_KEYRING> has been "
"defined for this keyring."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:313
#, no-wrap
msgid "Possession"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:317
msgid ""
"The concept of possession is important to understanding the keyrings "
"security model.  Whether a thread possesses a key is determined by the "
"following rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:321
msgid ""
"Any key or keyring that does not grant I<search> permission to the caller is "
"ignored in all the following rules."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:328
msgid ""
"A thread possesses its B<session-keyring>(7), B<process-keyring>(7), and "
"B<thread-keyring>(7)  directly because those keyrings are referred to by its "
"credentials."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:328 build/C/man7/keyrings.7:464
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:330
msgid "If a keyring is possessed, then any key it links to is also possessed."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:330 build/C/man7/keyrings.7:468
#, no-wrap
msgid "(4)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:333
msgid ""
"If any key a keyring links to is itself a keyring, then rule (3) applies "
"recursively."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:333 build/C/man7/keyrings.7:471
#, no-wrap
msgid "(5)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:338
msgid ""
"If a process is upcalled from the kernel to instantiate a key (see "
"B<request_key>(2)), then it also possesses the requester's keyrings as in "
"rule (1) as if it were the requester."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:341
msgid ""
"Note that possession is not a fundamental property of a key, but must rather "
"be calculated each time the key is needed."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:347
msgid ""
"Possession is designed to allow set-user-ID programs run from, say a user's "
"shell to access the user's keys.  Granting permissions to the key possessor "
"while denying them to the key owner and group allows the prevention of "
"access to keys on the basis of UID and GID matches."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:354
msgid ""
"When it creates the session keyring, B<pam_keyinit>(8)  adds a link to the "
"B<user-keyring>(7), thus making the user keyring and anything it contains "
"possessed by default."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:356
msgid "Each key has the following security-related attributes:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:358
msgid "The owning user ID"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:360
msgid "The ID of a group that is permitted to access the key"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:362
msgid "A security label"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:364
msgid "A permissions mask"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:369
msgid ""
"The permissions mask contains four sets of rights.  The first three sets are "
"mutually exclusive.  One and only one will be in force for a particular "
"access check.  In order of descending priority, these three sets are:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:372
msgid ""
"The set specifies the rights granted if the key's user ID matches the "
"caller's filesystem user ID."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:376
msgid ""
"The set specifies the rights granted if the user ID didn't match and the "
"key's group ID matches the caller's filesystem GID or one of the caller's "
"supplementary group IDs."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:379
msgid ""
"The set specifies the rights granted if neither the key's user ID nor group "
"ID matched."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:381
msgid "The fourth set of rights is:"
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:381
#, no-wrap
msgid "I<possessor>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:384
msgid ""
"The set specifies the rights granted if a key is determined to be possessed "
"by the caller."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:388
msgid ""
"The complete set of rights for a key is the union of whichever of the first "
"three sets is applicable plus the fourth set if the key is possessed."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:391
msgid ""
"The set of rights that may be granted in each of the four masks is as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:396
msgid ""
"The attributes of the key may be read.  This includes the type, description, "
"and access rights (excluding the security label)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:401
msgid ""
"For a key: the payload of the key may be read.  For a keyring: the list of "
"serial numbers (keys) to which the keyring has links may be read."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:406
msgid ""
"The payload of the key may be updated and the key may be revoked.  For a "
"keyring, links may be added to or removed from the keyring, and the keyring "
"may be cleared completely (all links are removed),"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:411
msgid ""
"For a key (or a keyring): the key may be found by a search.  For a keyring: "
"keys and keyrings that are linked to by the keyring may be searched."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:416
msgid ""
"Links may be created from keyrings to the key.  The initial link to a key "
"that is established when the key is created doesn't require this permission."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:416 build/C/man7/keyrings.7:643
#, no-wrap
msgid "I<setattr>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:420
msgid ""
"The ownership details and security label of the key may be changed, the "
"key's expiration time may be set, and the key may be revoked."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:427
msgid ""
"In addition to access rights, any active Linux Security Module (LSM) may "
"prevent access to a key if its policy so dictates.  A key may be given a "
"security label or other attribute by the LSM; this label is retrievable via "
"B<keyctl_get_security>(3)."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:437
msgid ""
"See B<keyctl_chown>(3), B<keyctl_describe>(3), B<keyctl_get_security>(3), "
"B<keyctl_setperm>(3), and B<selinux>(8)  for more information."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:437
#, no-wrap
msgid "Searching for keys"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:446
msgid ""
"One of the key features of the Linux key-management facility is the ability "
"to find a key that a process is retaining.  The B<request_key>(2)  system "
"call is the primary point of access for user-space applications to find a "
"key.  (Internally, the kernel has something similar available for use by "
"internal components that make use of keys.)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:448
msgid "The search algorithm works as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:458
msgid ""
"The process keyrings are searched in the following order: the thread "
"B<thread-keyring>(7)  if it exists, the B<process-keyring>(7)  if it exists, "
"and then either the B<session-keyring>(7)  if it exists or the B<user-"
"session-keyring>(7)  if that exists."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:464
msgid ""
"If the caller was a process that was invoked by the B<request_key>(2)  "
"upcall mechanism, then the keyrings of the original caller of "
"B<request_key>(2)  will be searched as well."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:468
msgid ""
"The search of a keyring tree is in breadth-first order: each keyring is "
"searched first for a match, then the keyrings referred to by that keyring "
"are searched."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:471
msgid ""
"If a matching key is found that is valid, then the search terminates and "
"that key is returned."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:474
msgid ""
"If a matching key is found that has an error state attached, that error "
"state is noted and the search continues."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:474
#, no-wrap
msgid "(6)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:479
msgid ""
"If no valid matching key is found, then the first noted error state is "
"returned; otherwise, an B<ENOKEY> error is returned."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:482
msgid ""
"It is also possible to search a specific keyring, in which case only steps "
"(3) to (6) apply."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:489
msgid "See B<request_key>(2)  and B<keyctl_search>(3)  for more information."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:489
#, no-wrap
msgid "On-demand key creation"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:497
msgid ""
"If a key cannot be found, B<request_key>(2)  will, if given a "
"I<callout_info> argument, create a new key and then upcall to user space to "
"instantiate the key.  This allows keys to be created on an as-needed basis."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:503
msgid ""
"Typically, this will involve the kernel creating a new process that executes "
"the B<request-key>(8)  program, which will then execute the appropriate "
"handler based on its configuration."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:508
msgid ""
"The handler is passed a special authorization key that allows it and only it "
"to instantiate the new key.  This is also used to permit searches performed "
"by the handler program to also search the requester's keyrings."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:520
msgid ""
"See B<request_key>(2), B<keyctl_assume_authority>(3), "
"B<keyctl_instantiate>(3), B<keyctl_negate>(3), B<keyctl_reject>(3), "
"B<request-key>(8), and B<request-key.conf>(5)  for more information."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:520
#, no-wrap
msgid "/proc files"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:524
msgid ""
"The kernel provides various I</proc> files that expose information about "
"keys or define limits on key usage."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:524
#, no-wrap
msgid "I</proc/keys> (since Linux 2.6.10)"
msgstr ""

#
#
#.  David Howells, Dec 2016 linux-man@:
#.  This [The thread need not possess the key for it to be visible in
#.  this file.] is correct.  See proc_keys_show() in security/keys/proc.c:
#. 	rc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);
#. 	if (rc < 0)
#. 		return 0;
#. Possibly it shouldn't be, but for now it is.
#. type: Plain text
#: build/C/man7/keyrings.7:540
msgid ""
"This file exposes a list of the keys for which the reading thread has "
"I<view> permission, providing various information about each key.  The "
"thread need not possess the key for it to be visible in this file."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:547
msgid ""
"The only keys included in the list are those that grant I<view> permission "
"to the reading process (regardless of whether or not it possesses them).  "
"LSM security checks are still performed, and may filter out further keys "
"that the process is not authorized to view."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:551
msgid ""
"An example of the data that one might see in this file (with the columns "
"numbered for easy reference below)  is the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:563
#, no-wrap
msgid ""
"  (1)     (2)     (3)(4)    (5)     (6)   (7)   (8)        (9)\n"
"009a2028 I--Q---   1 perm 3f010000  1000  1000 user     krb_ccache:primary: 12\n"
"1806c4ba I--Q---   1 perm 3f010000  1000  1000 keyring  _pid: 2\n"
"25d3a08f I--Q---   1 perm 1f3f0000  1000 65534 keyring  _uid_ses.1000: 1\n"
"28576bd8 I--Q---   3 perm 3f010000  1000  1000 keyring  _krb: 1\n"
"2c546d21 I--Q--- 190 perm 3f030000  1000  1000 keyring  _ses: 2\n"
"30a4e0be I------   4   2d 1f030000  1000 65534 keyring  _persistent.1000: 1\n"
"32100fab I--Q---   4 perm 1f3f0000  1000 65534 keyring  _uid.1000: 2\n"
"32a387ea I--Q---   1 perm 3f010000  1000  1000 keyring  _pid: 2\n"
"3ce56aea I--Q---   5 perm 3f030000  1000  1000 keyring  _ses: 1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:566
msgid "The fields shown in each line of this file are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:567
#, no-wrap
msgid "ID (1)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:570
msgid "The ID (serial number) of the key, expressed in hexadecimal."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:570
#, no-wrap
msgid "Flags (2)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:573
msgid "A set of flags describing the state of the key:"
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:574
#, no-wrap
msgid "I"
msgstr ""

#.  KEY_FLAG_INSTANTIATED
#. type: Plain text
#: build/C/man7/keyrings.7:577
#, fuzzy
#| msgid "The keyring has been revoked."
msgid "The key has been instantiated."
msgstr "鍵リングが廃止されている。"

#. type: IP
#: build/C/man7/keyrings.7:577
#, no-wrap
msgid "R"
msgstr ""

#.  KEY_FLAG_REVOKED
#. type: Plain text
#: build/C/man7/keyrings.7:580
#, fuzzy
#| msgid "The keyring has been revoked."
msgid "The key has been revoked."
msgstr "鍵リングが廃止されている。"

#. type: IP
#: build/C/man7/keyrings.7:580
#, no-wrap
msgid "D"
msgstr ""

#.  KEY_FLAG_DEAD
#.  unregister_key_type() in the kernel source
#. type: Plain text
#: build/C/man7/keyrings.7:585
msgid ""
"The key is dead (i.e., the key type has been unregistered).  (A key may be "
"briefly in this state during garbage collection.)"
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:585
#, no-wrap
msgid "Q"
msgstr ""

#.  KEY_FLAG_IN_QUOTA
#. type: Plain text
#: build/C/man7/keyrings.7:588
msgid "The key contributes to the user's quota."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:588
#, no-wrap
msgid "U"
msgstr ""

#.  KEY_FLAG_USER_CONSTRUCT
#. type: Plain text
#: build/C/man7/keyrings.7:593
msgid ""
"The key is under construction via a callback to user space; see B<request-"
"key>(2)."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:593
#, no-wrap
msgid "N"
msgstr ""

#.  KEY_FLAG_NEGATIVE
#. type: Plain text
#: build/C/man7/keyrings.7:596
msgid "The key is negatively instantiated."
msgstr ""

#. type: IP
#: build/C/man7/keyrings.7:596
#, no-wrap
msgid "i"
msgstr ""

#.  KEY_FLAG_INVALIDATED
#. type: Plain text
#: build/C/man7/keyrings.7:599
#, fuzzy
#| msgid "The keyring has been revoked."
msgid "The key has been invalidated."
msgstr "鍵リングが廃止されている。"

#. type: TP
#: build/C/man7/keyrings.7:600
#, no-wrap
msgid "Usage (3)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:606
msgid ""
"This is a count of the number of kernel credential structures that are "
"pinning the key (approximately: the number of threads and open file "
"references that refer to this key)."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:606
#, no-wrap
msgid "Timeout (4)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:617
msgid ""
"The amount of time until the key will expire, expressed in human-readable "
"form (weeks, days, hours, minutes, and seconds).  The string I<perm> here "
"means that the key is permanent (no timeout).  The string I<expd> means that "
"the key has already expired, but has not yet been garbage collected."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:617
#, no-wrap
msgid "Permissions (5)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:622
msgid ""
"The key permissions, expressed as four hexadecimal bytes containing, from "
"left to right, the possessor, user, group, and other permissions.  Within "
"each byte, the permission bits are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:625
#, no-wrap
msgid "0x01"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:628
#, no-wrap
msgid "Ox02"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:631
#, no-wrap
msgid "0x04"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:634
#, no-wrap
msgid "0x08"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:637
#, no-wrap
msgid "0x10"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:640
#, no-wrap
msgid "0x20"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:645
#, no-wrap
msgid "UID (6)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:648
msgid "The user ID of the key owner."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:648
#, no-wrap
msgid "GID (7)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:653
msgid ""
"The group ID of the key.  The value -1 here means that the key has no group "
"ID; this can occur in certain circumstances for keys created by the kernel."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:653
#, no-wrap
msgid "Type (8)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:656
msgid "The key type (user, keyring, etc.)"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:656
#, no-wrap
msgid "Description (9)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:661
msgid ""
"The key description (name).  This field contains descriptive information "
"about the key.  For most key types, it has the form"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:663
#, no-wrap
msgid "     name[: extra-info]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:671
msgid ""
"The I<name> subfield is the key's description (name).  The optional I<extra-"
"info> field provides some further information about the key.  The "
"information that appears here depends on the key type, as follows:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:672
#, no-wrap
msgid "I<\"user\"> and I<\"logon\">"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:675
msgid "The size in bytes of the key payload (expressed in decimal)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:681
msgid ""
"The number of keys linked to the keyring, or the string I<empty> if there "
"are no keys linked to the keyring."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:681
#, no-wrap
msgid "I<\"big_key\">"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:692
msgid ""
"The payload size in bytes, followed either by the string I<[file]>, if the "
"key payload exceeds the threshold that means that the payload is stored in a "
"(swappable)  B<tmpfs>(5)  filesystem, or otherwise the string I<[buff]>, "
"indicating that the key is small enough to reside in kernel memory."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:700
msgid ""
"For the I<\".request_key_auth\"> key type (authorization key; see "
"B<request_key>(2)), the description field has the form shown in the "
"following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:702
#, no-wrap
msgid "    key:c9a9b19 pid:28880 ci:10\n"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:704
msgid "The three subfields are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:705
#, no-wrap
msgid "I<key>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:708
msgid ""
"The hexadecimal ID of the key being instantiated in the requesting program."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:708
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:711
msgid "The PID of the requesting program."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:711
#, no-wrap
msgid "I<ci>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:716
msgid ""
"The length of the callout data with which the requested key should be "
"instantiated (i.e., the length of the payload associated with the "
"authorization key)."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:718
#, no-wrap
msgid "I</proc/key-users> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:723
msgid ""
"This file lists various information for each user ID that has at least one "
"key on the system.  An example of the data that one might see in this file "
"is the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:729
#, no-wrap
msgid ""
"   0:    10 9/9 2/1000000 22/25000000\n"
"  42:     9 9/9 8/200 106/20000\n"
"1000:    11 11/11 10/200 271/20000\n"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:733
msgid "The fields shown in each line are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:734
#, no-wrap
msgid "I<uid>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:737
msgid "The user ID."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:737
#, no-wrap
msgid "I<usage>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:741
msgid ""
"This is a kernel-internal usage count for the kernel structure used to "
"record key users."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:741
#, no-wrap
msgid "I<nkeys>/I<nikeys>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:745
msgid ""
"The total number of keys owned by the user, and the number of those keys "
"that have been instantiated."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:745
#, no-wrap
msgid "I<qnkeys>/I<maxkeys>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:749
msgid ""
"The number of keys owned by the user, and the maximum number of keys that "
"the user may own."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:749
#, no-wrap
msgid "I<qnbytes>/I<maxbytes>"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:753
msgid ""
"The number of bytes consumed in payloads of the keys owned by this user, and "
"the upper limit on the number of bytes in key payloads for that user."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:754
#, no-wrap
msgid "I</proc/sys/kernel/keys/gc_delay> (since Linux 2.6.32)"
msgstr ""

#.  commit 5d135440faf7db8d566de0c6fab36b16cf9cfc3b
#. type: Plain text
#: build/C/man7/keyrings.7:765
msgid ""
"The value in this file specifies the interval, in seconds, after which "
"revoked and expired keys will be garbage collected.  The purpose of having "
"such an interval is so that there is a window of time where user space can "
"see an error (respectively B<EKEYREVOKED> and B<EKEYEXPIRED>)  that "
"indicates what happened to the key."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:767
msgid "The default value in this file is 300 (i.e., 5 minutes)."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:767
#, no-wrap
msgid "I</proc/sys/kernel/keys/persistent_keyring_expiry> (since Linux 3.13)"
msgstr ""

#.  commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
#. type: Plain text
#: build/C/man7/keyrings.7:778
msgid ""
"This file defines an interval, in seconds, to which the persistent keyring's "
"expiration timer is reset each time the keyring is accessed (via "
"B<keyctl_get_persistent>(3)  or the B<keyctl>(2)  B<KEYCTL_GET_PERSISTENT> "
"operation.)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:780
msgid "The default value in this file is 259200 (i.e., 3 days)."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:784
msgid ""
"The following files (which are writable by privileged processes)  are used "
"to enforce quotas on the number of keys and number of bytes of data that can "
"be stored in key payloads:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:784
#, no-wrap
msgid "I</proc/sys/kernel/keys/maxbytes> (since Linux 2.6.26)"
msgstr ""

#.  commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
#.  Previously: KEYQUOTA_MAX_BYTES      10000
#. type: Plain text
#: build/C/man7/keyrings.7:790
msgid ""
"This is the maximum number of bytes of data that a nonroot user can hold in "
"the payloads of the keys owned by the user."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:792
msgid "The default value in this file is 20,000."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:792
#, no-wrap
msgid "I</proc/sys/kernel/keys/maxkeys> (since Linux 2.6.26)"
msgstr ""

#.  commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
#.  Previously: KEYQUOTA_MAX_KEYS       100
#. type: Plain text
#: build/C/man7/keyrings.7:797
msgid "This is the maximum number of keys that a nonroot user may own."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:799
msgid "The default value in this file is 200."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:799
#, no-wrap
msgid "I</proc/sys/kernel/keys/root_maxbytes> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:804
msgid ""
"This is the maximum number of bytes of data that the root user (UID 0 in the "
"root user namespace)  can hold in the payloads of the keys owned by root."
msgstr ""

#. 738c5d190f6540539a04baf36ce21d46b5da04bd
#.  commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
#. type: Plain text
#: build/C/man7/keyrings.7:808
msgid ""
"The default value in this file is 25,000,000 (20,000 before Linux 3.17)."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:808
#, no-wrap
msgid "I</proc/sys/kernel/keys/root_maxkeys> (since Linux 2.6.26)"
msgstr ""

#.  commit 0b77f5bfb45c13e1e5142374f9d6ca75292252a4
#. type: Plain text
#: build/C/man7/keyrings.7:814
msgid ""
"This is the maximum number of keys that the root user (UID 0 in the root "
"user namespace)  may own."
msgstr ""

#. 738c5d190f6540539a04baf36ce21d46b5da04bd
#. type: Plain text
#: build/C/man7/keyrings.7:817
msgid "The default value in this file is 1,000,000 (200 before Linux 3.17)."
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:821
msgid ""
"With respect to keyrings, note that each link in a keyring consumes 4 bytes "
"of the keyring payload."
msgstr ""

#. type: SS
#: build/C/man7/keyrings.7:821
#, no-wrap
msgid "Users"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:824
msgid ""
"The Linux key-management facility has a number of users and usages, but is "
"not limited to those that already exist."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:826
msgid "In-kernel users of this facility include:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:826
#, no-wrap
msgid "Network filesystems - DNS"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:830
msgid ""
"The kernel uses the upcall mechanism provided by the keys to upcall to user "
"space to do DNS lookups and then to cache the results."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:830
#, no-wrap
msgid "AF_RXRPC and kAFS - Authentication"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:836
msgid ""
"The AF_RXRPC network protocol and the in-kernel AFS filesystem use keys to "
"store the ticket needed to do secured or encrypted traffic.  These are then "
"looked up by network operations on AF_RXRPC and filesystem operations on "
"kAFS."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:836
#, no-wrap
msgid "NFS - User ID mapping"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:840
msgid ""
"The NFS filesystem uses keys to store mappings of foreign user IDs to local "
"user IDs."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:840
#, no-wrap
msgid "CIFS - Password"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:843
msgid ""
"The CIFS filesystem uses keys to store passwords for accessing remote shares."
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:843
#, no-wrap
msgid "Module verification"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:847
msgid ""
"The kernel build process can be made to cryptographically sign modules.  "
"That signature is then checked when a module is loaded."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:849
msgid "User-space users of this facility include:"
msgstr ""

#. type: TP
#: build/C/man7/keyrings.7:849
#, no-wrap
msgid "Kerberos key storage"
msgstr ""

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man7/keyrings.7:859
msgid ""
"The MIT Kerberos 5 facility (libkrb5) can use keys to store authentication "
"tokens which can be made to be automatically cleaned up a set time after the "
"user last uses them, but until then permits them to hang around after the "
"user has logged out so that B<cron>(8)  scripts can use them."
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:876
msgid ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<request_key>(2), B<keyctl>(3), "
"B<keyutils>(7), B<persistent-keyring>(7), B<process-keyring>(7), B<session-"
"keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-session-"
"keyring>(7), B<pam_keyinit>(8), B<request-key>(8)"
msgstr ""

#. type: Plain text
#: build/C/man7/keyrings.7:883
msgid ""
"The kernel source files I<Documentation/crypto/asymmetric-keys.txt> and "
"under I<Documentation/security/keys> (or, before Linux 4.13, in the file "
"I<Documentation/security/keys.txt>)."
msgstr ""

#. type: TH
#: build/C/man7/persistent-keyring.7:11
#, no-wrap
msgid "PERSISTENT-KEYRING"
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:14
msgid "persistent-keyring - per-user persistent keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:23
msgid ""
"The persistent keyring is a keyring used to anchor keys on behalf of a "
"user.  Each UID the kernel deals with has its own persistent keyring that is "
"shared between all threads owned by that UID.  The persistent keyring has a "
"name (description) of the form I<_persistent.E<lt>UIDE<gt>> where "
"I<E<lt>UIDE<gt>> is the user ID of the corresponding user."
msgstr ""

#.  FIXME The meaning of the preceding sentence isn't clear. What is meant?
#. type: Plain text
#: build/C/man7/persistent-keyring.7:33
msgid ""
"The persistent keyring may not be accessed directly, even by processes with "
"the appropriate UID.  Instead, it must first be linked to one of a process's "
"keyrings, before that keyring can access the persistent keyring by virtue of "
"its possessor permits.  This linking is done with the "
"B<keyctl_get_persistent>(3)  function."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:37
msgid ""
"If a persistent keyring does not exist when it is accessed by the "
"B<keyctl_get_persistent>(3)  operation, it will be automatically created."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:42
msgid ""
"Each time the B<keyctl_get_persistent>(3)  operation is performed, the "
"persistent key's expiration timer is reset to the value in:"
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:44
#, no-wrap
msgid "    /proc/sys/kernel/keys/persistent_keyring_expiry\n"
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:50
msgid ""
"Should the timeout be reached, the persistent keyring will be removed and "
"everything it pins can then be garbage collected.  The key will then be re-"
"created on a subsequent call to B<keyctl_get_persistent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:56
msgid ""
"The persistent keyring is not directly searched by B<request_key>(2); it is "
"searched only if it is linked into one of the keyrings that is searched by "
"B<request_key>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:76
msgid ""
"The persistent keyring is independent of B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2), and B<_exit>(2).  It persists until its "
"expiration timer triggers, at which point it is garbage collected.  This "
"allows the persistent keyring to carry keys beyond the life of the kernel's "
"record of the corresponding UID (the destruction of which results in the "
"destruction of the B<user-keyring>(7)  and the B<user-session-keyring>(7)).  "
"The persistent keyring can thus be used to hold authentication tokens for "
"processes that run without user interaction, such as programs started by "
"B<cron>(8)."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:84
msgid ""
"The persistent keyring is used to store UID-specific objects that themselves "
"have limited lifetimes (e.g., kerberos tokens).  If those tokens cease to be "
"used (i.e., the persistent keyring is not accessed), then the timeout of the "
"persistent keyring ensures that the corresponding objects are automatically "
"discarded."
msgstr ""

#. type: SS
#: build/C/man7/persistent-keyring.7:84 build/C/man7/session-keyring.7:55
#, no-wrap
msgid "Special operations"
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:99
msgid ""
"The I<keyutils> library provides the B<keyctl_get_persistent>(3)  function "
"for manipulating persistent keyrings.  (This function is an interface to the "
"B<keyctl>(2)  B<KEYCTL_GET_PERSISTENT> operation.)  This operation allows "
"the calling thread to get the persistent keyring corresponding to its own "
"UID or, if the thread has the B<CAP_SETUID> capability, the persistent "
"keyring corresponding to some other UID in the same user namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:114
msgid ""
"Each user namespace owns a keyring called I<.persistent_register> that "
"contains links to all of the persistent keys in that namespace.  (The I<."
"persistent_register> keyring can be seen when reading the contents of the I</"
"proc/keys> file for the UID 0 in the namespace.)  The "
"B<keyctl_get_persistent>(3)  operation looks for a key with a name of the "
"form I<_persistent.E<lt>UIDE<gt>> in that keyring, creates the key if it "
"does not exist, and links it into the keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/persistent-keyring.7:126
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_get_persistent>(3), B<keyrings>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7)"
msgstr ""

#. type: TH
#: build/C/man7/process-keyring.7:11
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgid "PROCESS-KEYRING"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: build/C/man7/process-keyring.7:14
msgid "process-keyring - per-process shared keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:19
msgid ""
"The process keyring is a keyring used to anchor keys on behalf of a "
"process.  It is created only when a process requests it.  The process "
"keyring has the name (description)  I<_pid>."
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:24
msgid ""
"A special serial number value, B<KEY_SPEC_PROCESS_KEYRING>, is defined that "
"can be used in lieu of the actual serial number of the calling process's "
"process keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:31
msgid ""
"From the B<keyctl>(1)  utility, 'B<@p>' can be used instead of a numeric key "
"ID in much the same way, but since B<keyctl>(1)  is a program run after "
"forking, this is of no utility."
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:44
msgid ""
"A thread created using the B<clone>(2)  B<CLONE_THREAD> flag has the same "
"process keyring as the caller of B<clone>(2).  When a new process is created "
"using B<fork>()  it initially has no process keyring.  A process's process "
"keyring is cleared on B<execve>(2).  The process keyring is destroyed when "
"the last thread that refers to it terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:50
msgid ""
"If a process doesn't have a process keyring when it is accessed, then the "
"process keyring will be created if the keyring is to be modified; otherwise, "
"the error B<ENOKEY> results."
msgstr ""

#. type: Plain text
#: build/C/man7/process-keyring.7:61
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<session-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7)"
msgstr ""

#. type: TH
#: build/C/man7/session-keyring.7:11
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgid "SESSION-KEYRING"
msgstr "B<KEY_SPEC_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man7/session-keyring.7:14
msgid "session-keyring - session shared process keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:24
msgid ""
"The session keyring is a keyring used to anchor keys on behalf of a "
"process.  It is typically created by B<pam_keyinit>(8)  when a user logs in "
"and a link will be added that refers to the B<user-keyring>(7).  Optionally, "
"PAM may revoke the session keyring on logout.  (In typical configurations, "
"PAM does do this revocation.)  The session keyring has the name "
"(description)  I<_ses>."
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:29
msgid ""
"A special serial number value, B<KEY_SPEC_SESSION_KEYRING>, is defined that "
"can be used in lieu of the actual serial number of the calling process's "
"session keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:34
msgid ""
"From the B<keyctl>(1)  utility, 'B<@s>' can be used instead of a numeric key "
"ID in much the same way."
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:46
msgid ""
"A process's session keyring is inherited across B<clone>(2), B<fork>(2), and "
"B<vfork>(2).  The session keyring is preserved across B<execve>(2), even "
"when the executable is set-user-ID or set-group-ID or has capabilities.  The "
"session keyring is destroyed when the last process that refers to it exits."
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:55
msgid ""
"If a process doesn't have a session keyring when it is accessed, then, under "
"certain circumstances, the B<user-session-keyring>(7)  will be attached as "
"the session keyring and under others a new session keyring will be created.  "
"(See B<user-session-keyring>(7)  for further details.)"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:60
msgid ""
"The I<keyutils> library provides the following special operations for "
"manipulating session keyrings:"
msgstr ""

#. type: TP
#: build/C/man7/session-keyring.7:60
#, no-wrap
msgid "B<keyctl_join_session_keyring>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:72
msgid ""
"This operation allows the caller to change the session keyring that it "
"subscribes to.  The caller can join an existing keyring with a specified "
"name (description), create a new keyring with a given name, or ask the "
"kernel to create a new \"anonymous\" session keyring with the name \"_ses"
"\".  (This function is an interface to the B<keyctl>(2)  "
"B<KEYCTL_JOIN_SESSION_KEYRING> operation.)"
msgstr ""

#. type: TP
#: build/C/man7/session-keyring.7:72
#, no-wrap
msgid "B<keyctl_session_to_parent>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:82
msgid ""
"This operation allows the caller to make the parent process's session "
"keyring to the same as its own.  For this to succeed, the parent process "
"must have identical security attributes and must be single threaded.  (This "
"function is an interface to the B<keyctl>(2)  B<KEYCTL_SESSION_TO_PARENT> "
"operation.)"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:86
msgid "These operations are also exposed through the B<keyctl>(1)  utility as:"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:92
#, no-wrap
msgid ""
"keyctl session\n"
"keyctl session - [E<lt>progE<gt> E<lt>arg1E<gt> E<lt>arg2E<gt> ...]\n"
"keyctl session E<lt>nameE<gt> [E<lt>progE<gt> E<lt>arg1E<gt> E<lt>arg2E<gt> ...]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:96
msgid "and:"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:100
#, no-wrap
msgid "keyctl new_session\n"
msgstr ""

#. type: Plain text
#: build/C/man7/session-keyring.7:116
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_join_session_keyring>(3), "
"B<keyctl_session_to_parent>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"
msgstr ""

#. type: TH
#: build/C/man7/thread-keyring.7:11
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgid "THREAD-KEYRING"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: build/C/man7/thread-keyring.7:14
msgid "thread-keyring - per-thread keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:19
msgid ""
"The thread keyring is a keyring used to anchor keys on behalf of a process.  "
"It is created only when a thread requests it.  The thread keyring has the "
"name (description)  I<_tid>."
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:24
msgid ""
"A special serial number value, B<KEY_SPEC_THREAD_KEYRING>, is defined that "
"can be used in lieu of the actual serial number of the calling thread's "
"thread keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:31
msgid ""
"From the B<keyctl>(1)  utility, 'B<@t>' can be used instead of a numeric key "
"ID in much the same way, but as B<keyctl>(1)  is a program run after "
"forking, this is of no utility."
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:39
msgid ""
"Thread keyrings are not inherited across B<clone>(2)  and B<fork>(2)  and "
"are cleared by B<execve>(2).  A thread keyring is destroyed when the thread "
"that refers to it terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:45
msgid ""
"Initially, a thread does not have a thread keyring.  If a thread doesn't "
"have a thread keyring when it is accessed, then it will be created if it is "
"to be modified; otherwise the operation fails with the error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: build/C/man7/thread-keyring.7:56
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7)"
msgstr ""

#. type: TH
#: build/C/man7/user-keyring.7:11
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_KEYRING>"
msgid "USER-KEYRING"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: build/C/man7/user-keyring.7:14
msgid "user-keyring - per-user keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:23
msgid ""
"The user keyring is a keyring used to anchor keys on behalf of a user.  Each "
"UID the kernel deals with has its own user keyring that is shared by all "
"processes with that UID.  The user keyring has a name (description) of the "
"form I<_uid.E<lt>UIDE<gt>> where I<E<lt>UIDE<gt>> is the user ID of the "
"corresponding user."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:35
msgid ""
"The user keyring is associated with the record that the kernel maintains for "
"the UID.  It comes into existence upon the first attempt to access either "
"the user keyring, the B<user-session-keyring>(7), or the B<session-"
"keyring>(7).  The keyring remains pinned in existence so long as there are "
"processes running with that real UID or files opened by those processes "
"remain open.  (The keyring can also be pinned indefinitely by linking it "
"into another keyring.)"
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:39
msgid ""
"Typically, the user keyring is created by B<pam_keyinit>(8)  when a user "
"logs in."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:46
msgid ""
"The user keyring is not searched by default by B<request_key>(2).  When "
"B<pam_keyinit>(8)  creates a session keyring, it adds to it a link to the "
"user keyring so that the user keyring will be searched when the session "
"keyring is."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:51
msgid ""
"A special serial number value, B<KEY_SPEC_USER_KEYRING>, is defined that can "
"be used in lieu of the actual serial number of the calling process's user "
"keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:56
msgid ""
"From the B<keyctl>(1)  utility, 'B<@u>' can be used instead of a numeric key "
"ID in much the same way."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:66
msgid ""
"User keyrings are independent of B<clone>(2), B<fork>(2), B<vfork>(2), "
"B<execve>(2), and B<_exit>(2)  excepting that the keyring is destroyed when "
"the UID record is destroyed when the last process pinning it exits."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:73
msgid ""
"If it is necessary for a key associated with a user to exist beyond the UID "
"record being garbage collected\\(emfor example, for use by a B<cron>(8)  "
"script\\(emthen the B<persistent-keyring>(7)  should be used instead."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:75
msgid ""
"If a user keyring does not exist when it is accessed, it will be created."
msgstr ""

#. type: Plain text
#: build/C/man7/user-keyring.7:87
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"
msgstr ""

#. type: TH
#: build/C/man7/user-session-keyring.7:11
#, fuzzy, no-wrap
#| msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgid "USER-SESSION-KEYRING"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: build/C/man7/user-session-keyring.7:14
msgid "user-session-keyring - per-user default session keyring"
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:23
msgid ""
"The user session keyring is a keyring used to anchor keys on behalf of a "
"user.  Each UID the kernel deals with has its own user session keyring that "
"is shared by all processes with that UID.  The user session keyring has a "
"name (description) of the form I<_uid_ses.E<lt>UIDE<gt>> where "
"I<E<lt>UIDE<gt>> is the user ID of the corresponding user."
msgstr ""

#.  Davis Howells: the user and user-session keyrings are managed as a pair.
#. type: Plain text
#: build/C/man7/user-session-keyring.7:36
msgid ""
"The user session keyring is associated with the record that the kernel "
"maintains for the UID.  It comes into existence upon the first attempt to "
"access either the user session keyring, the B<user-keyring>(7), or the "
"B<session-keyring>(7).  The keyring remains pinned in existence so long as "
"there are processes running with that real UID or files opened by those "
"processes remain open.  (The keyring can also be pinned indefinitely by "
"linking it into another keyring.)"
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:44
msgid ""
"The user session keyring is created on demand when a thread requests it or "
"when a thread asks for its B<session-keyring>(7)  and that keyring doesn't "
"exist.  In the latter case, a user session keyring will be created and, if "
"the session keyring wasn't to be created, the user session keyring will be "
"set as the process's actual session keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:48
msgid ""
"The user session keyring is searched by B<request_key>(2)  if the actual "
"session keyring does not exist and is ignored otherwise."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:54
msgid ""
"A special serial number value, B<KEY_SPEC_USER_SESSION_KEYRING>, is defined "
"that can be used in lieu of the actual serial number of the calling "
"process's user session keyring."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:59
msgid ""
"From the B<keyctl>(1)  utility, 'B<@us>' can be used instead of a numeric "
"key ID in much the same way."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:69
msgid ""
"User session keyrings are independent of B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2), and B<_exit>(2)  excepting that the keyring is "
"destroyed when the UID record is destroyed when the last process pinning it "
"exits."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:72
msgid ""
"If a user session keyring does not exist when it is accessed, it will be "
"created."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:79
msgid ""
"Rather than relying on the user session keyring, it is strongly recommended"
"\\(emespecially if the process is running as root\\(emthat a B<session-"
"keyring>(7)  be set explicitly, for example by B<pam_keyinit>(8)."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:87
msgid ""
"The user session keyring was added to support situations where a process "
"doesn't have a session keyring, perhaps because it was created via a pathway "
"that didn't involve PAM (e.g., perhaps it was a daemon started by "
"B<inetd>(8)).  In such a scenario, the user session keyring acts as a "
"substitute for the B<session-keyring>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/user-session-keyring.7:98
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7)"
msgstr ""

#~ msgid "2010-02-25"
#~ msgstr "2010-02-25"

#~ msgid "KEY TYPES"
#~ msgstr "鍵タイプ"

#~ msgid ""
#~ "There are a number of key types available in the core key management "
#~ "code, and these can be specified to this function:"
#~ msgstr ""
#~ "コアの鍵管理コードには様々な鍵タイプがあり、 この関数でこれらを指定するこ"
#~ "とができる。"

#~ msgid "LINKING"
#~ msgstr "LINKING"

#~ msgid ""
#~ "Although this is a Linux system call, it is not present in I<libc> but "
#~ "can be found rather in I<libkeyutils>.  When linking, B<-lkeyutils> "
#~ "should be specified to the linker."
#~ msgstr ""
#~ "これは Linux のシステムコールだが、 I<libc> には存在せず、 代わりに "
#~ "I<libkeyutils> に存在する。 リンクする際には、 リンカーに B<-lkeyutils> を"
#~ "指定する必要がある。"

#~ msgid "B<keyctl>(1), B<keyctl>(2), B<request_key>(2)"
#~ msgstr "B<keyctl>(1), B<keyctl>(2), B<request_key>(2)"

#~ msgid "2014-01-22"
#~ msgstr "2014-01-22"

#~ msgid "Revoke a key."
#~ msgstr "鍵を廃止する。"

#~ msgid "B<KEYCTL_CHOWN>"
#~ msgstr "B<KEYCTL_CHOWN>"

#~ msgid "Set perms on a key."
#~ msgstr "鍵のアクセス許可を設定する。"

#~ msgid "B<KEYCTL_LINK>"
#~ msgstr "B<KEYCTL_LINK>"

#~ msgid "Search for a key in a keyring."
#~ msgstr "鍵リングから鍵を検索する。"

#~ msgid "Read a key or keyring's contents."
#~ msgstr "鍵や鍵リングの内容を読み出す。"

#~ msgid ""
#~ "On success B<keyctl>()  returns the serial number of the key it found.  "
#~ "On error, the value -1 will be returned and errno will have been set to "
#~ "an appropriate error."
#~ msgstr ""
#~ "成功すると B<keyctl>() は見つかった鍵のシリアル番号を返す。 エラーの場"
#~ "合、 値 -1 が返され、 I<errno> にエラーを示す値が設定される。"

#~ msgid "B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<request-key>(8)"
#~ msgstr "B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<request-key>(8)"
