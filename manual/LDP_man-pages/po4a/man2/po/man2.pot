# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/arch_prctl.2:25
#, no-wrap
msgid "ARCH_PRCTL"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/quotactl.2:27
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/copy_file_range.2:25 build/C/man2/futex.2:22 build/C/man2/get_robust_list.2:30 build/C/man2/getunwind.2:27 build/C/man2/kexec_load.2:27 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:5 build/C/man2/outb.2:26 build/C/man2/pciconfig_read.2:8 build/C/man2/perf_event_open.2:27 build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:33 build/C/man2/pivot_root.2:27 build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:105 build/C/man2/quotactl.2:27 build/C/man2/sendfile.2:19 build/C/man2/set_tid_address.2:25 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26 build/C/man2/userfaultfd.2:27
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/copy_file_range.2:25 build/C/man2/futex.2:22 build/C/man2/getunwind.2:27 build/C/man2/kexec_load.2:27 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:5 build/C/man2/outb.2:26 build/C/man2/pciconfig_read.2:8 build/C/man2/perf_event_open.2:27 build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:33 build/C/man2/pivot_root.2:27 build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:105 build/C/man2/quotactl.2:27 build/C/man2/sendfile.2:19 build/C/man2/set_tid_address.2:25 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26 build/C/man2/userfaultfd.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:26 build/C/man2/copy_file_range.2:26 build/C/man2/futex.2:23 build/C/man2/get_robust_list.2:31 build/C/man2/getunwind.2:28 build/C/man2/kexec_load.2:28 build/C/man2/lookup_dcookie.2:28 build/C/man2/modify_ldt.2:26 build/C/man2/nfsservctl.2:6 build/C/man2/outb.2:27 build/C/man2/pciconfig_read.2:9 build/C/man2/perf_event_open.2:28 build/C/man2/perfmonctl.2:28 build/C/man2/personality.2:34 build/C/man2/pivot_root.2:28 build/C/man2/process_vm_readv.2:30 build/C/man2/ptrace.2:106 build/C/man2/quotactl.2:28 build/C/man2/sendfile.2:20 build/C/man2/set_tid_address.2:26 build/C/man2/splice.2:27 build/C/man2/tee.2:27 build/C/man2/vm86.2:27 build/C/man2/vmsplice.2:27 build/C/man2/userfaultfd.2:28
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:28
msgid "arch_prctl - set architecture-specific thread state"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:28 build/C/man2/copy_file_range.2:28 build/C/man2/futex.2:25 build/C/man2/get_robust_list.2:33 build/C/man2/getunwind.2:30 build/C/man2/kexec_load.2:30 build/C/man2/lookup_dcookie.2:30 build/C/man2/modify_ldt.2:28 build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:31 build/C/man2/pciconfig_read.2:11 build/C/man2/perf_event_open.2:30 build/C/man2/perfmonctl.2:30 build/C/man2/personality.2:36 build/C/man2/pivot_root.2:30 build/C/man2/process_vm_readv.2:32 build/C/man2/ptrace.2:108 build/C/man2/quotactl.2:30 build/C/man2/sendfile.2:22 build/C/man2/set_tid_address.2:28 build/C/man2/splice.2:29 build/C/man2/tee.2:29 build/C/man2/vm86.2:29 build/C/man2/vmsplice.2:29 build/C/man2/userfaultfd.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:32
#, no-wrap
msgid ""
"B<#include E<lt>asm/prctl.hE<gt>>\n"
"B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:35
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:36 build/C/man2/copy_file_range.2:37 build/C/man2/futex.2:40 build/C/man2/get_robust_list.2:46 build/C/man2/getunwind.2:40 build/C/man2/kexec_load.2:46 build/C/man2/lookup_dcookie.2:32 build/C/man2/modify_ldt.2:37 build/C/man2/nfsservctl.2:15 build/C/man2/outb.2:62 build/C/man2/pciconfig_read.2:22 build/C/man2/perf_event_open.2:42 build/C/man2/perfmonctl.2:39 build/C/man2/personality.2:40 build/C/man2/pivot_root.2:35 build/C/man2/process_vm_readv.2:65 build/C/man2/ptrace.2:115 build/C/man2/quotactl.2:38 build/C/man2/sendfile.2:47 build/C/man2/set_tid_address.2:37 build/C/man2/splice.2:39 build/C/man2/tee.2:38 build/C/man2/vm86.2:35 build/C/man2/vmsplice.2:39 build/C/man2/userfaultfd.2:40
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:50
msgid ""
"B<arch_prctl>()  sets architecture-specific process or thread state.  "
"I<code> selects a subfunction and passes argument I<addr> to it; I<addr> is "
"interpreted as either an I<unsigned long> for the \"set\" operations, or as "
"an I<unsigned long\\ *>, for the \"get\" operations."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:52
msgid "Subfunctions for both x86 and x86-64 are:"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:52
#, no-wrap
msgid "B<ARCH_SET_CPUID> (since Linux 4.12)"
msgstr ""

#.  commit e9ea1e7f53b852147cbd568b0568c7ad97ec21a3
#. type: Plain text
#: build/C/man2/arch_prctl.2:72
msgid ""
"Enable (I<addr != 0>)  or disable (I<addr == 0>)  the I<cpuid> instruction "
"for the calling thread.  The instruction is enabled by default.  If "
"disabled, any execution of a I<cpuid> instruction will instead generate a "
"B<SIGSEGV> signal.  This feature can be used to emulate I<cpuid> results "
"that differ from what the underlying hardware would have produced (e.g., in "
"a paravirtualization setting)."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:83
msgid ""
"The B<ARCH_SET_CPUID> setting is preserved across B<fork>(2)  and "
"B<clone>(2)  but reset to the default (i.e., I<cpuid> enabled) on "
"B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:83
#, no-wrap
msgid "B<ARCH_GET_CPUID> (since Linux 4.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:90
msgid ""
"Return the setting of the flag manipulated by B<ARCH_SET_CPUID> as the "
"result of the system call (1 for enabled, 0 for disabled).  I<addr> is "
"ignored."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:90
#, no-wrap
msgid "Subfunctions for x86-64 only are:"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:92
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:98
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:98
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:106
msgid ""
"Return the 64-bit base value for the I<FS> register of the calling thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:106
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:112
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:112
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:120
msgid ""
"Return the 64-bit base value for the I<GS> register of the calling thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:120 build/C/man2/copy_file_range.2:88 build/C/man2/futex.2:1316 build/C/man2/get_robust_list.2:101 build/C/man2/getunwind.2:83 build/C/man2/kexec_load.2:242 build/C/man2/lookup_dcookie.2:43 build/C/man2/modify_ldt.2:137 build/C/man2/nfsservctl.2:56 build/C/man2/pciconfig_read.2:49 build/C/man2/perf_event_open.2:3466 build/C/man2/perfmonctl.2:190 build/C/man2/personality.2:249 build/C/man2/pivot_root.2:94 build/C/man2/process_vm_readv.2:216 build/C/man2/ptrace.2:2324 build/C/man2/quotactl.2:689 build/C/man2/sendfile.2:108 build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:135 build/C/man2/tee.2:83 build/C/man2/vm86.2:54 build/C/man2/vmsplice.2:131 build/C/man2/userfaultfd.2:420
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:126
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:126 build/C/man2/copy_file_range.2:104 build/C/man2/futex.2:1401 build/C/man2/get_robust_list.2:108 build/C/man2/getunwind.2:90 build/C/man2/kexec_load.2:247 build/C/man2/lookup_dcookie.2:50 build/C/man2/modify_ldt.2:147 build/C/man2/pciconfig_read.2:76 build/C/man2/perf_event_open.2:3472 build/C/man2/personality.2:256 build/C/man2/pivot_root.2:98 build/C/man2/process_vm_readv.2:236 build/C/man2/ptrace.2:2342 build/C/man2/quotactl.2:696 build/C/man2/sendfile.2:121 build/C/man2/set_tid_address.2:94 build/C/man2/splice.2:153 build/C/man2/tee.2:98 build/C/man2/vm86.2:59 build/C/man2/vmsplice.2:140 build/C/man2/userfaultfd.2:427
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:127 build/C/man2/futex.2:1465 build/C/man2/get_robust_list.2:121 build/C/man2/lookup_dcookie.2:51 build/C/man2/modify_ldt.2:148 build/C/man2/perf_event_open.2:3525 build/C/man2/process_vm_readv.2:237 build/C/man2/process_vm_readv.2:242 build/C/man2/ptrace.2:2346 build/C/man2/quotactl.2:715 build/C/man2/sendfile.2:131 build/C/man2/vm86.2:60
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:131
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:131 build/C/man2/copy_file_range.2:137 build/C/man2/copy_file_range.2:142 build/C/man2/copy_file_range.2:148 build/C/man2/futex.2:1483 build/C/man2/futex.2:1494 build/C/man2/futex.2:1504 build/C/man2/futex.2:1511 build/C/man2/futex.2:1518 build/C/man2/futex.2:1524 build/C/man2/futex.2:1537 build/C/man2/futex.2:1552 build/C/man2/futex.2:1567 build/C/man2/futex.2:1579 build/C/man2/futex.2:1591 build/C/man2/futex.2:1601 build/C/man2/futex.2:1607 build/C/man2/get_robust_list.2:112 build/C/man2/kexec_load.2:279 build/C/man2/kexec_load.2:283 build/C/man2/kexec_load.2:292 build/C/man2/kexec_load.2:298 build/C/man2/kexec_load.2:301 build/C/man2/kexec_load.2:306 build/C/man2/lookup_dcookie.2:54 build/C/man2/modify_ldt.2:152 build/C/man2/pciconfig_read.2:77 build/C/man2/perf_event_open.2:3530 build/C/man2/personality.2:257 build/C/man2/pivot_root.2:127 build/C/man2/pivot_root.2:131 build/C/man2/pivot_root.2:134 build/C/man2/pivot_root.2:139 build/C/man2/pivot_root.2:142 build/C/man2/pivot_root.2:149 build/C/man2/process_vm_readv.2:248 build/C/man2/process_vm_readv.2:259 build/C/man2/process_vm_readv.2:263 build/C/man2/ptrace.2:2357 build/C/man2/quotactl.2:721 build/C/man2/quotactl.2:727 build/C/man2/sendfile.2:134 build/C/man2/sendfile.2:143 build/C/man2/splice.2:166 build/C/man2/splice.2:169 build/C/man2/splice.2:174 build/C/man2/splice.2:177 build/C/man2/splice.2:180 build/C/man2/tee.2:107 build/C/man2/vmsplice.2:151 build/C/man2/userfaultfd.2:392 build/C/man2/userfaultfd.2:428
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:135
msgid "I<code> is not a valid subcommand."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:135 build/C/man2/copy_file_range.2:175 build/C/man2/futex.2:1645 build/C/man2/futex.2:1657 build/C/man2/get_robust_list.2:125 build/C/man2/kexec_load.2:323 build/C/man2/lookup_dcookie.2:65 build/C/man2/pciconfig_read.2:104 build/C/man2/perf_event_open.2:3611 build/C/man2/pivot_root.2:157 build/C/man2/process_vm_readv.2:274 build/C/man2/ptrace.2:2367 build/C/man2/quotactl.2:758 build/C/man2/vm86.2:68
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:139
msgid "I<addr> is outside the process address space."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:139 build/C/man2/pciconfig_read.2:86 build/C/man2/perf_event_open.2:3566
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: build/C/man2/arch_prctl.2:145
msgid ""
"B<ARCH_SET_CPUID> was requested, but the underlying hardware does not "
"support CPUID faulting."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:145 build/C/man2/copy_file_range.2:205 build/C/man2/futex.2:1695 build/C/man2/getunwind.2:98 build/C/man2/kexec_load.2:335 build/C/man2/lookup_dcookie.2:78 build/C/man2/modify_ldt.2:169 build/C/man2/nfsservctl.2:64 build/C/man2/outb.2:87 build/C/man2/pciconfig_read.2:111 build/C/man2/perf_event_open.2:3637 build/C/man2/perfmonctl.2:199 build/C/man2/personality.2:266 build/C/man2/pivot_root.2:165 build/C/man2/process_vm_readv.2:286 build/C/man2/ptrace.2:2385 build/C/man2/sendfile.2:174 build/C/man2/set_tid_address.2:100 build/C/man2/splice.2:201 build/C/man2/tee.2:125 build/C/man2/vm86.2:73 build/C/man2/vmsplice.2:167 build/C/man2/userfaultfd.2:458
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:149
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:149 build/C/man2/copy_file_range.2:209 build/C/man2/futex.2:1697 build/C/man2/get_robust_list.2:140 build/C/man2/getunwind.2:101 build/C/man2/kexec_load.2:337 build/C/man2/lookup_dcookie.2:81 build/C/man2/modify_ldt.2:172 build/C/man2/perf_event_open.2:3642 build/C/man2/perfmonctl.2:202 build/C/man2/pivot_root.2:168 build/C/man2/process_vm_readv.2:288 build/C/man2/ptrace.2:2387 build/C/man2/quotactl.2:789 build/C/man2/sendfile.2:181 build/C/man2/set_tid_address.2:102 build/C/man2/splice.2:203 build/C/man2/tee.2:127 build/C/man2/vmsplice.2:169 build/C/man2/userfaultfd.2:462
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:152
msgid ""
"B<arch_prctl>()  is supported only on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:154
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:157
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:169
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  As an "
"optimization, if a 32-bit TLS base address is used, B<arch_prctl>()  may use "
"a real TLS entry as if B<set_thread_area>(2)  had been called, instead of "
"manipulating the segment base register directly.  Memory in the first 2\\ GB "
"of address space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> "
"flag."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:176
msgid ""
"Because of the aforementioned optimization, using B<arch_prctl>()  and "
"B<set_thread_area>(2)  in the same thread is dangerous, as they may "
"overwrite each other's TLS entries."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:181
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:187
msgid ""
"I<FS> may be already used by the threading library.  Programs that use "
"B<ARCH_SET_FS> directly are very likely to crash."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:187 build/C/man2/copy_file_range.2:296 build/C/man2/futex.2:1886 build/C/man2/get_robust_list.2:164 build/C/man2/getunwind.2:109 build/C/man2/kexec_load.2:341 build/C/man2/lookup_dcookie.2:90 build/C/man2/modify_ldt.2:207 build/C/man2/nfsservctl.2:66 build/C/man2/outb.2:96 build/C/man2/pciconfig_read.2:113 build/C/man2/perf_event_open.2:3796 build/C/man2/perfmonctl.2:205 build/C/man2/personality.2:270 build/C/man2/pivot_root.2:411 build/C/man2/process_vm_readv.2:338 build/C/man2/ptrace.2:2904 build/C/man2/quotactl.2:817 build/C/man2/sendfile.2:238 build/C/man2/set_tid_address.2:105 build/C/man2/splice.2:267 build/C/man2/tee.2:214 build/C/man2/vmsplice.2:188 build/C/man2/userfaultfd.2:761
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:192
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:194
msgid "AMD X86-64 Programmer's manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:194 build/C/man2/copy_file_range.2:300 build/C/man2/futex.2:1936 build/C/man2/get_robust_list.2:173 build/C/man2/getunwind.2:111 build/C/man2/kexec_load.2:350 build/C/man2/lookup_dcookie.2:92 build/C/man2/modify_ldt.2:211 build/C/man2/nfsservctl.2:68 build/C/man2/outb.2:99 build/C/man2/pciconfig_read.2:115 build/C/man2/perf_event_open.2:3806 build/C/man2/perfmonctl.2:209 build/C/man2/personality.2:272 build/C/man2/pivot_root.2:420 build/C/man2/process_vm_readv.2:341 build/C/man2/ptrace.2:2921 build/C/man2/quotactl.2:822 build/C/man2/sendfile.2:244 build/C/man2/set_tid_address.2:109 build/C/man2/splice.2:273 build/C/man2/tee.2:218 build/C/man2/vm86.2:76 build/C/man2/vmsplice.2:192 build/C/man2/userfaultfd.2:770
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:202 build/C/man2/copy_file_range.2:308 build/C/man2/futex.2:1944 build/C/man2/get_robust_list.2:181 build/C/man2/getunwind.2:119 build/C/man2/kexec_load.2:358 build/C/man2/lookup_dcookie.2:100 build/C/man2/modify_ldt.2:219 build/C/man2/nfsservctl.2:76 build/C/man2/outb.2:107 build/C/man2/pciconfig_read.2:123 build/C/man2/perf_event_open.2:3814 build/C/man2/perfmonctl.2:217 build/C/man2/personality.2:280 build/C/man2/pivot_root.2:428 build/C/man2/process_vm_readv.2:349 build/C/man2/ptrace.2:2929 build/C/man2/quotactl.2:830 build/C/man2/sendfile.2:252 build/C/man2/set_tid_address.2:117 build/C/man2/splice.2:281 build/C/man2/tee.2:226 build/C/man2/vm86.2:84 build/C/man2/vmsplice.2:200 build/C/man2/userfaultfd.2:778
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/copy_file_range.2:25
#, no-wrap
msgid "COPY_FILE_RANGE"
msgstr ""

#. type: TH
#: build/C/man2/copy_file_range.2:25 build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:105 build/C/man2/splice.2:26 build/C/man2/tee.2:26
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:28
msgid "copy_file_range - Copy a range of data from one file to another"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:36
#, no-wrap
msgid ""
"B<ssize_t copy_file_range(int >I<fd_in>B<, loff_t *>I<off_in>B<,>\n"
"B<                        int >I<fd_out>B<, loff_t *>I<off_out>B<,>\n"
"B<                        size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:50
msgid ""
"The B<copy_file_range>()  system call performs an in-kernel copy between two "
"file descriptors without the additional cost of transferring data from the "
"kernel to user space and then back into the kernel.  It copies up to I<len> "
"bytes of data from the source file descriptor I<fd_in> to the target file "
"descriptor I<fd_out>, overwriting any data that exists within the requested "
"range of the target file."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:55
msgid ""
"The following semantics apply for I<off_in>, and similar statements apply to "
"I<off_out>:"
msgstr ""

#. type: IP
#: build/C/man2/copy_file_range.2:55 build/C/man2/copy_file_range.2:62 build/C/man2/futex.2:597 build/C/man2/futex.2:604 build/C/man2/futex.2:610 build/C/man2/futex.2:869 build/C/man2/futex.2:871 build/C/man2/futex.2:877 build/C/man2/futex.2:961 build/C/man2/futex.2:972 build/C/man2/futex.2:1895 build/C/man2/futex.2:1897 build/C/man2/futex.2:1899 build/C/man2/futex.2:1901 build/C/man2/futex.2:1903 build/C/man2/kexec_load.2:145 build/C/man2/kexec_load.2:156 build/C/man2/kexec_load.2:163 build/C/man2/perf_event_open.2:1498 build/C/man2/perf_event_open.2:1516 build/C/man2/ptrace.2:2156 build/C/man2/ptrace.2:2166 build/C/man2/ptrace.2:2174 build/C/man2/ptrace.2:2180 build/C/man2/ptrace.2:2316 build/C/man2/ptrace.2:2675 build/C/man2/ptrace.2:2682 build/C/man2/splice.2:55 build/C/man2/splice.2:61 build/C/man2/splice.2:70
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:62
msgid ""
"If I<off_in> is NULL, then bytes are read from I<fd_in> starting from the "
"file offset, and the file offset is adjusted by the number of bytes copied."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:76
msgid ""
"If I<off_in> is not NULL, then I<off_in> must point to a buffer that "
"specifies the starting offset where bytes from I<fd_in> will be read.  The "
"file offset of I<fd_in> is not changed, but I<off_in> is adjusted "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:83
msgid ""
"I<fd_in> and I<fd_out> can refer to the same file.  If they refer to the "
"same file, then the source and target ranges are not allowed to overlap."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:88
msgid ""
"The I<flags> argument is provided to allow for future extensions and "
"currently must be set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:98
msgid ""
"Upon successful completion, B<copy_file_range>()  will return the number of "
"bytes copied between files.  This could be less than the length originally "
"requested.  If the file offset of I<fd_in> is at or past the end of file, no "
"bytes are copied, and B<copy_file_range>()  returns zero."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:104
msgid ""
"On error, B<copy_file_range>()  returns -1 and I<errno> is set to indicate "
"the error."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:105 build/C/man2/copy_file_range.2:108 build/C/man2/copy_file_range.2:114 build/C/man2/kexec_load.2:269 build/C/man2/perf_event_open.2:3510 build/C/man2/sendfile.2:127 build/C/man2/splice.2:162 build/C/man2/vmsplice.2:147
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:108
msgid "One or more file descriptors are not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:114
msgid "I<fd_in> is not open for reading; or I<fd_out> is not open for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:122
msgid ""
"The B<O_APPEND> flag is set for the open file description (see B<open>(2))  "
"referred to by the file descriptor I<fd_out>."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:122 build/C/man2/copy_file_range.2:126 build/C/man2/copy_file_range.2:131
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:126
msgid ""
"An attempt was made to write at a position past the maximum file offset the "
"kernel supports."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:131
msgid ""
"An attempt was made to write a range that exceeds the allowed maximum file "
"size.  The maximum file size differs between filesystem implementations and "
"can be different from the maximum allowed file offset."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:137
msgid ""
"An attempt was made to write beyond the process's file size resource limit.  "
"This may also result in the process receiving a B<SIGXFSZ> signal."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:142
msgid "The I<flags> argument is not 0."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:148
msgid ""
"I<fd_in> and I<fd_out> refer to the same file and the source and target "
"ranges overlap."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:155
msgid "Either I<fd_in> or I<fd_out> is not a regular file."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:155 build/C/man2/pciconfig_read.2:83 build/C/man2/ptrace.2:2360 build/C/man2/sendfile.2:151
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:158
msgid "A low-level I/O error occurred while copying."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:158
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:165
msgid "Either I<fd_in> or I<fd_out> refers to a directory."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:165 build/C/man2/futex.2:1614 build/C/man2/kexec_load.2:320 build/C/man2/lookup_dcookie.2:61 build/C/man2/process_vm_readv.2:269 build/C/man2/sendfile.2:155 build/C/man2/splice.2:186 build/C/man2/tee.2:117 build/C/man2/vmsplice.2:159 build/C/man2/userfaultfd.2:440
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:168 build/C/man2/splice.2:189 build/C/man2/tee.2:120 build/C/man2/vmsplice.2:162
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:168 build/C/man2/perf_event_open.2:3577
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:171
msgid "There is not enough space on the target filesystem to complete the copy."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:171 build/C/man2/sendfile.2:159
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:175
msgid ""
"The requested source or destination range is too large to represent in the "
"specified data types."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:179
msgid "I<fd_out> refers to an immutable file."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:179
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:186
msgid "Either I<fd_in> or I<fd_out> refers to an active swap file."
msgstr ""

#. type: TP
#: build/C/man2/copy_file_range.2:186
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:191
msgid ""
"The files referred to by I<fd_in> and I<fd_out> are not on the same mounted "
"filesystem (pre Linux 5.3)."
msgstr ""

#. type: SH
#: build/C/man2/copy_file_range.2:191 build/C/man2/futex.2:1685 build/C/man2/get_robust_list.2:138 build/C/man2/getunwind.2:96 build/C/man2/kexec_load.2:328 build/C/man2/lookup_dcookie.2:73 build/C/man2/nfsservctl.2:61 build/C/man2/perfmonctl.2:196 build/C/man2/personality.2:260 build/C/man2/pivot_root.2:162 build/C/man2/process_vm_readv.2:283 build/C/man2/sendfile.2:168 build/C/man2/set_tid_address.2:97 build/C/man2/splice.2:196 build/C/man2/tee.2:120 build/C/man2/vmsplice.2:162 build/C/man2/userfaultfd.2:451
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  https://sourceware.org/git/?p=glibc.git;a=commit;f=posix/unistd.h;h=bad7a0c81f501fbbcc79af9eaa4b8254441c4a1f
#. type: Plain text
#: build/C/man2/copy_file_range.2:197
msgid ""
"The B<copy_file_range>()  system call first appeared in Linux 4.5, but glibc "
"2.27 provides a user-space emulation when it is not available."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:202
msgid ""
"A major rework of the kernel implementation occurred in 5.3.  Areas of the "
"API that weren't clearly defined were clarified and the API bounds are much "
"more strictly checked than on earlier kernels.  Applications should target "
"the behaviour and requirements of 5.3 kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:205
msgid ""
"First support for cross-filesystem copies was introduced in Linux 5.3.  "
"Older kernels will return -EXDEV when cross-filesystem copies are attempted."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:209
msgid ""
"The B<copy_file_range>()  system call is a nonstandard Linux and GNU "
"extension."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:223
msgid ""
"If I<fd_in> is a sparse file, then B<copy_file_range>()  may expand any "
"holes existing in the requested range.  Users may benefit from calling "
"B<copy_file_range>()  in a loop, and using the B<lseek>(2)  B<SEEK_DATA> and "
"B<SEEK_HOLE> operations to find the locations of data segments."
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:229
msgid ""
"B<copy_file_range>()  gives filesystems an opportunity to implement \"copy "
"acceleration\" techniques, such as the use of reflinks (i.e., two or more "
"inodes that share pointers to the same copy-on-write disk blocks)  or "
"server-side-copy (in the case of NFS)."
msgstr ""

#. type: SH
#: build/C/man2/copy_file_range.2:229 build/C/man2/futex.2:1711 build/C/man2/perf_event_open.2:3737 build/C/man2/pivot_root.2:273 build/C/man2/process_vm_readv.2:302 build/C/man2/splice.2:264 build/C/man2/tee.2:136 build/C/man2/userfaultfd.2:486
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:238
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:241
#, no-wrap
msgid ""
"/* On versions of glibc before 2.27, we must invoke copy_file_range()\n"
"   using syscall(2) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:249
#, no-wrap
msgid ""
"static loff_t\n"
"copy_file_range(int fd_in, loff_t *off_in, int fd_out,\n"
"                loff_t *off_out, size_t len, unsigned int flags)\n"
"{\n"
"    return syscall(__NR_copy_file_range, fd_in, off_in, fd_out,\n"
"                   off_out, len, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:256
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd_in, fd_out;\n"
"    struct stat stat;\n"
"    loff_t len, ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:261
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sourceE<gt> "
"E<lt>destinationE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:267
#, no-wrap
msgid ""
"    fd_in = open(argv[1], O_RDONLY);\n"
"    if (fd_in == -1) {\n"
"        perror(\"open (argv[1])\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:272
#, no-wrap
msgid ""
"    if (fstat(fd_in, &stat) == -1) {\n"
"        perror(\"fstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:274
#, no-wrap
msgid "    len = stat.st_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:280
#, no-wrap
msgid ""
"    fd_out = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, 0644);\n"
"    if (fd_out == -1) {\n"
"        perror(\"open (argv[2])\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:287
#, no-wrap
msgid ""
"    do {\n"
"        ret = copy_file_range(fd_in, NULL, fd_out, NULL, len, 0);\n"
"        if (ret == -1) {\n"
"            perror(\"copy_file_range\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:290
#, no-wrap
msgid ""
"        len -= ret;\n"
"    } while (len E<gt> 0 && ret E<gt> 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:295
#, no-wrap
msgid ""
"    close(fd_in);\n"
"    close(fd_out);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/copy_file_range.2:300
msgid "B<lseek>(2), B<sendfile>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/futex.2:22
#, no-wrap
msgid "FUTEX"
msgstr ""

#. type: TH
#: build/C/man2/futex.2:22 build/C/man2/nfsservctl.2:5 build/C/man2/outb.2:26 build/C/man2/perf_event_open.2:27 build/C/man2/pivot_root.2:27 build/C/man2/userfaultfd.2:27
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:25
msgid "futex - fast user-space locking"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:31
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>stdint.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:36
#, no-wrap
msgid ""
"B<long futex(uint32_t *>I<uaddr>B<, int >I<futex_op>B<, uint32_t "
">I<val>B<,>\n"
"B<          const struct timespec *>I<timeout>B<,>I< >  /* or: B<uint32_t "
">I<val2>B< */>\n"
"B<          uint32_t *>I<uaddr2>B<, uint32_t >I<val3>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:40 build/C/man2/getunwind.2:40 build/C/man2/modify_ldt.2:37 build/C/man2/perf_event_open.2:42 build/C/man2/perfmonctl.2:39 build/C/man2/pivot_root.2:35 build/C/man2/set_tid_address.2:37 build/C/man2/userfaultfd.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:57
msgid ""
"The B<futex>()  system call provides a method for waiting until a certain "
"condition becomes true.  It is typically used as a blocking construct in the "
"context of shared-memory synchronization.  When using futexes, the majority "
"of the synchronization operations are performed in user space.  A user-space "
"program employs the B<futex>()  system call only when it is likely that the "
"program has to block for a longer time until the condition becomes true.  "
"Other B<futex>()  operations can be used to wake any processes or threads "
"waiting for a particular condition."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:76
msgid ""
"A futex is a 32-bit value\\(emreferred to below as a I<futex word>\\(emwhose "
"address is supplied to the B<futex>()  system call.  (Futexes are 32 bits in "
"size on all platforms, including 64-bit systems.)  All futex operations are "
"governed by this value.  In order to share a futex between processes, the "
"futex is placed in a region of shared memory, created using (for example)  "
"B<mmap>(2)  or B<shmat>(2).  (Thus, the futex word may have different "
"virtual addresses in different processes, but these addresses all refer to "
"the same location in physical memory.)  In a multithreaded program, it is "
"sufficient to place the futex word in a global variable shared by all "
"threads."
msgstr ""

#.  Notes from Darren Hart (Dec 2015):
#.      Totally ordered with respect futex operations refers to semantics
#.      of the ACQUIRE/RELEASE operations and how they impact ordering of
#.      memory reads and writes. The kernel futex operations are protected
#.      by spinlocks, which ensure that all operations are serialized
#.      with respect to one another.
#
#.      This is a lot to attempt to define in this document. Perhaps a
#.      reference to linux/Documentation/memory-barriers.txt as a footnote
#.      would be sufficient? Or perhaps for this manual, "serialized" would
#.      be sufficient, with a footnote regarding "totally ordered" and a
#.      pointer to the memory-barrier documentation?
#.  FIXME(Torvald Riegel):
#.  Eventually we want to have some text in NOTES to satisfy
#.  the reference in the following sentence
#.      See NOTES for a detailed specification of
#.      the synchronization semantics.
#. type: Plain text
#: build/C/man2/futex.2:109
msgid ""
"When executing a futex operation that requests to block a thread, the kernel "
"will block only if the futex word has the value that the calling thread "
"supplied (as one of the arguments of the B<futex>()  call) as the expected "
"value of the futex word.  The loading of the futex word's value, the "
"comparison of that value with the expected value, and the actual blocking "
"will happen atomically and will be totally ordered with respect to "
"concurrent operations performed by other threads on the same futex word.  "
"Thus, the futex word is used to connect the synchronization in user space "
"with the implementation of blocking by the kernel.  Analogously to an atomic "
"compare-and-exchange operation that potentially changes shared memory, "
"blocking via a futex is an atomic compare-and-block operation."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:136
msgid ""
"One use of futexes is for implementing locks.  The state of the lock (i.e., "
"acquired or not acquired)  can be represented as an atomically accessed flag "
"in shared memory.  In the uncontended case, a thread can access or modify "
"the lock state with atomic instructions, for example atomically changing it "
"from not acquired to acquired using an atomic compare-and-exchange "
"instruction.  (Such instructions are performed entirely in user mode, and "
"the kernel maintains no information about the lock state.)  On the other "
"hand, a thread may be unable to acquire a lock because it is already "
"acquired by another thread.  It then may pass the lock's flag as a futex "
"word and the value representing the acquired state as the expected value to "
"a B<futex>()  wait operation.  This B<futex>()  operation will block if and "
"only if the lock is still acquired (i.e., the value in the futex word still "
"matches the \"acquired state\").  When releasing the lock, a thread has to "
"first reset the lock state to not acquired and then execute a futex "
"operation that wakes threads blocked on the lock flag used as a futex word "
"(this can be further optimized to avoid unnecessary wake-ups).  See "
"B<futex>(7)  for more detail on how to use futexes."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:139
msgid ""
"Besides the basic wait and wake-up futex functionality, there are further "
"futex operations aimed at supporting more complex use cases."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:148
msgid ""
"Note that no explicit initialization or destruction is necessary to use "
"futexes; the kernel maintains a futex (i.e., the kernel-internal "
"implementation artifact)  only while operations such as B<FUTEX_WAIT>, "
"described below, are being performed on a particular futex word."
msgstr ""

#. type: SS
#: build/C/man2/futex.2:148 build/C/man2/perf_event_open.2:76
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:160
msgid ""
"The I<uaddr> argument points to the futex word.  On all platforms, futexes "
"are four-byte integers that must be aligned on a four-byte boundary.  The "
"operation to perform on the futex is specified in the I<futex_op> argument; "
"I<val> is a value whose meaning and purpose depends on I<futex_op>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:168
msgid ""
"The remaining arguments (I<timeout>, I<uaddr2>, and I<val3>)  are required "
"only for certain of the futex operations described below.  Where one of "
"these arguments is not required, it is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:186
msgid ""
"For several blocking operations, the I<timeout> argument is a pointer to a "
"I<timespec> structure that specifies a timeout for the operation.  However, "
"notwithstanding the prototype shown above, for some operations, the least "
"significant four bytes of this argument are instead used as an integer whose "
"meaning is determined by the operation.  For these operations, the kernel "
"casts the I<timeout> value first to I<unsigned long>, then to I<uint32_t>, "
"and in the remainder of this page, this argument is referred to as I<val2> "
"when interpreted in this fashion."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:191
msgid ""
"Where it is required, the I<uaddr2> argument is a pointer to a second futex "
"word that is employed by the operation."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:198
msgid ""
"The interpretation of the final integer argument, I<val3>, depends on the "
"operation."
msgstr ""

#. type: SS
#: build/C/man2/futex.2:198
#, no-wrap
msgid "Futex operations"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:208
msgid ""
"The I<futex_op> argument consists of two parts: a command that specifies the "
"operation to be performed, bitwise ORed with zero or more options that "
"modify the behaviour of the operation.  The options that may be included in "
"I<futex_op> are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:208
#, no-wrap
msgid "B<FUTEX_PRIVATE_FLAG> (since Linux 2.6.22)"
msgstr ""

#.  commit 34f01cc1f512fa783302982776895c73714ebbc2
#.  I.e., It allows the kernel choose the fast path for validating
#.  the user-space address and avoids expensive VMA lookups,
#.  taking reference counts on file backing store, and so on.
#. type: Plain text
#: build/C/man2/futex.2:219
msgid ""
"This option bit can be employed with all futex operations.  It tells the "
"kernel that the futex is process-private and not shared with another process "
"(i.e., it is being used for synchronization only between threads of the same "
"process).  This allows the kernel to make some additional performance "
"optimizations."
msgstr ""

#.  except the obsolete FUTEX_FD, for which the "private" flag was
#.  meaningless
#. type: Plain text
#: build/C/man2/futex.2:234
msgid ""
"As a convenience, I<E<lt>linux/futex.hE<gt>> defines a set of constants with "
"the suffix B<_PRIVATE> that are equivalents of all of the operations listed "
"below, but with the B<FUTEX_PRIVATE_FLAG> ORed into the constant value.  "
"Thus, there are B<FUTEX_WAIT_PRIVATE>, B<FUTEX_WAKE_PRIVATE>, and so on."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:234
#, no-wrap
msgid "B<FUTEX_CLOCK_REALTIME> (since Linux 2.6.28)"
msgstr ""

#.  commit 1acdac104668a0834cfa267de9946fac7764d486
#.  commit 337f13046ff03717a9e99675284a817527440a49
#. type: Plain text
#: build/C/man2/futex.2:245
msgid ""
"This option bit can be employed only with the B<FUTEX_WAIT_BITSET>, "
"B<FUTEX_WAIT_REQUEUE_PI>, and (since Linux 4.5)  B<FUTEX_WAIT> operations."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:251
msgid ""
"If this option is set, the kernel measures the I<timeout> against the "
"B<CLOCK_REALTIME> clock."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:257
msgid ""
"If this option is not set, the kernel measures the I<timeout> against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:264
msgid "The operation specified in I<futex_op> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:264
#, no-wrap
msgid "B<FUTEX_WAIT> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since some time in 2.5.x
#.  FIXME: Torvald, I think we may need to add some explanation of
#.  "totally ordered" here.
#. type: Plain text
#: build/C/man2/futex.2:290
msgid ""
"This operation tests that the value at the futex word pointed to by the "
"address I<uaddr> still contains the expected value I<val>, and if so, then "
"sleeps waiting for a B<FUTEX_WAKE> operation on the futex word.  The load of "
"the value of the futex word is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with the expected value, and starting to sleep are performed "
"atomically and totally ordered with respect to other futex operations on the "
"same futex word.  If the thread starts to sleep, it is considered a waiter "
"on this futex word.  If the futex value does not match I<val>, then the call "
"fails immediately with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:301
msgid ""
"The purpose of the comparison with the expected value is to prevent lost "
"wake-ups.  If another thread changed the value of the futex word after the "
"calling thread decided to block based on the prior value, and if the other "
"thread executed a B<FUTEX_WAKE> operation (or similar wake-up) after the "
"value change and before this B<FUTEX_WAIT> operation, then the calling "
"thread will observe the value change and will not start to sleep."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:319
msgid ""
"If the I<timeout> is not NULL, the structure it points to specifies a "
"timeout for the wait.  (This interval will be rounded up to the system clock "
"granularity, and is guaranteed not to expire early.)  The timeout is by "
"default measured according to the B<CLOCK_MONOTONIC> clock, but, since Linux "
"4.5, the B<CLOCK_REALTIME> clock can be selected by specifying "
"B<FUTEX_CLOCK_REALTIME> in I<futex_op>.  If I<timeout> is NULL, the call "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:338
msgid ""
"I<Note>: for B<FUTEX_WAIT>, I<timeout> is interpreted as a I<relative> "
"value.  This differs from other futex operations, where I<timeout> is "
"interpreted as an absolute value.  To obtain the equivalent of B<FUTEX_WAIT> "
"with an absolute timeout, employ B<FUTEX_WAIT_BITSET> with I<val3> specified "
"as B<FUTEX_BITSET_MATCH_ANY>."
msgstr ""

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to a
#.  different example.
#
#.      For
#.      .BR futex (7),
#.      this call is executed if decrementing the count gave a negative value
#.      (indicating contention),
#.      and will sleep until another process or thread releases
#.      the futex and executes the
#.      .B FUTEX_WAKE
#.      operation.
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:358
msgid "The arguments I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:358
#, no-wrap
msgid "B<FUTEX_WAKE> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since Linux 2.5.x
#. type: Plain text
#: build/C/man2/futex.2:375
msgid ""
"This operation wakes at most I<val> of the waiters that are waiting (e.g., "
"inside B<FUTEX_WAIT>)  on the futex word at the address I<uaddr>.  Most "
"commonly, I<val> is specified as either 1 (wake up a single waiter) or "
"B<INT_MAX> (wake up all waiters).  No guarantee is provided about which "
"waiters are awoken (e.g., a waiter with a higher scheduling priority is not "
"guaranteed to be awoken in preference to a waiter with a lower priority)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:396 build/C/man2/futex.2:424
msgid "The arguments I<timeout>, I<uaddr2>, and I<val3> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:396
#, no-wrap
msgid "B<FUTEX_FD> (from Linux 2.6.0 up to and including Linux 2.6.25)"
msgstr ""

#.  Strictly speaking, from Linux 2.5.x to 2.6.25
#. type: Plain text
#: build/C/man2/futex.2:410
msgid ""
"This operation creates a file descriptor that is associated with the futex "
"at I<uaddr>.  The caller must close the returned file descriptor after use.  "
"When another process or thread performs a B<FUTEX_WAKE> on the futex word, "
"the file descriptor indicates as being readable with B<select>(2), "
"B<poll>(2), and B<epoll>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:417
msgid ""
"The file descriptor can be used to obtain asynchronous notifications: if "
"I<val> is nonzero, then, when another process or thread executes a "
"B<FUTEX_WAKE>, the caller will receive the signal number that was passed in "
"I<val>."
msgstr ""

#.  commit 82af7aca56c67061420d618cc5a30f0fd4106b80
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:433
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:433
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.6.0)"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:445
msgid ""
"This operation performs the same task as B<FUTEX_CMP_REQUEUE> (see below), "
"except that no check is made using the value in I<val3>.  (The argument "
"I<val3> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:445
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:469
msgid ""
"This operation first checks whether the location I<uaddr> still contains the "
"value I<val3>.  If not, the operation fails with the error B<EAGAIN>.  "
"Otherwise, the operation wakes up a maximum of I<val> waiters that are "
"waiting on the futex at I<uaddr>.  If there are more than I<val> waiters, "
"then the remaining waiters are removed from the wait queue of the source "
"futex at I<uaddr> and added to the wait queue of the target futex at "
"I<uaddr2>.  The I<val2> argument specifies an upper limit on the number of "
"waiters that are requeued to the futex at I<uaddr2>."
msgstr ""

#.  FIXME(Torvald) Is the following correct?  Or is just the decision
#.  which threads to wake or requeue part of the atomic operation?
#.  Notes from a f2f conversation with Thomas Gleixner (Aug 2015): ###
#. 	The operation is serialized with respect to operations on both
#. 	source and target futex. No other waiter can enqueue itself
#. 	for waiting and no other waiter can dequeue itself because of
#. 	a timeout or signal.
#. type: Plain text
#: build/C/man2/futex.2:485
msgid ""
"The load from I<uaddr> is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with I<val3>, and the requeueing of any waiters are performed "
"atomically and totally ordered with respect to other operations on the same "
"futex word."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:503
msgid ""
"Typical values to specify for I<val> are 0 or 1.  (Specifying B<INT_MAX> is "
"not useful, because it would make the B<FUTEX_CMP_REQUEUE> operation "
"equivalent to B<FUTEX_WAKE>.)  The limit value specified via I<val2> is "
"typically either 1 or B<INT_MAX>.  (Specifying the argument as 0 is not "
"useful, because it would make the B<FUTEX_CMP_REQUEUE> operation equivalent "
"to B<FUTEX_WAIT>.)"
msgstr ""

#.  But, as Rich Felker points out, there remain valid use cases for
#.  FUTEX_REQUEUE, for example, when the calling thread is requeuing
#.  the target(s) to a lock that the calling thread owns
#.      From: Rich Felker <dalias@libc.org>
#.      Date: Wed, 29 Oct 2014 22:43:17 -0400
#.      To: Darren Hart <dvhart@infradead.org>
#.      CC: libc-alpha@sourceware.org, ...
#.      Subject: Re: Add futex wrapper to glibc?
#. type: Plain text
#: build/C/man2/futex.2:520
msgid ""
"The B<FUTEX_CMP_REQUEUE> operation was added as a replacement for the "
"earlier B<FUTEX_REQUEUE>.  The difference is that the check of the value at "
"I<uaddr> can be used to ensure that requeueing happens only under certain "
"conditions, which allows race conditions to be avoided in certain use cases."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:532
msgid ""
"Both B<FUTEX_REQUEUE> and B<FUTEX_CMP_REQUEUE> can be used to avoid "
"\"thundering herd\" wake-ups that could occur when using B<FUTEX_WAKE> in "
"cases where all of the waiters that are woken need to acquire another "
"futex.  Consider the following scenario, where multiple waiter threads are "
"waiting on B, a wait queue implemented using a futex:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:542
#, no-wrap
msgid ""
"lock(A)\n"
"while (!check_value(V)) {\n"
"    unlock(A);\n"
"    block_on(B);\n"
"    lock(A);\n"
"};\n"
"unlock(A);\n"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:557
msgid ""
"If a waker thread used B<FUTEX_WAKE>, then all waiters waiting on B would be "
"woken up, and they would all try to acquire lock A.  However, waking all of "
"the threads in this manner would be pointless because all except one of the "
"threads would immediately block on lock A again.  By contrast, a requeue "
"operation wakes just one waiter and moves the other waiters to lock A, and "
"when the woken waiter unlocks A then the next waiter can proceed."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:557
#, no-wrap
msgid "B<FUTEX_WAKE_OP> (since Linux 2.6.14)"
msgstr ""

#.  commit 4732efbeb997189d9f9b04708dc26bf8613ed721
#. 	Author: Jakub Jelinek <jakub@redhat.com>
#. 	Date:   Tue Sep 6 15:16:25 2005 -0700
#.  FIXME. (Torvald) The glibc condvar implementation is currently being
#.      revised (e.g., to not use an internal lock anymore).
#.      It is probably more future-proof to remove this paragraph.
#.  [Torvald, do you have an update here?]
#. type: Plain text
#: build/C/man2/futex.2:576
msgid ""
"This operation was added to support some user-space use cases where more "
"than one futex must be handled at the same time.  The most notable example "
"is the implementation of B<pthread_cond_signal>(3), which requires "
"operations on two futexes, the one used to implement the mutex and the one "
"used in the implementation of the wait queue associated with the condition "
"variable.  B<FUTEX_WAKE_OP> allows such cases to be implemented without "
"leading to high rates of contention and context switching."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:582
msgid ""
"The B<FUTEX_WAKE_OP> operation is equivalent to executing the following code "
"atomically and totally ordered with respect to other futex operations on any "
"of the two supplied futex words:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:590
#, no-wrap
msgid ""
"uint32_t oldval = *(uint32_t *) uaddr2;\n"
"*(uint32_t *) uaddr2 = oldval I<op> I<oparg>;\n"
"futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);\n"
"if (oldval I<cmp> I<cmparg>)\n"
"    futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:596
msgid "In other words, B<FUTEX_WAKE_OP> does the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:604
msgid ""
"saves the original value of the futex word at I<uaddr2> and performs an "
"operation to modify the value of the futex at I<uaddr2>; this is an atomic "
"read-modify-write memory access (i.e., using atomic machine instructions of "
"the respective architecture)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:610
msgid ""
"wakes up a maximum of I<val> waiters on the futex for the futex word at "
"I<uaddr>; and"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:618
msgid ""
"dependent on the results of a test of the original value of the futex word "
"at I<uaddr2>, wakes up a maximum of I<val2> waiters on the futex for the "
"futex word at I<uaddr2>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:624
msgid ""
"The operation and comparison that are to be performed are encoded in the "
"bits of the argument I<val3>.  Pictorially, the encoding is:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:631
#, no-wrap
msgid ""
"+---+---+-----------+-----------+\n"
"|op |cmp|   oparg   |  cmparg   |\n"
"+---+---+-----------+-----------+\n"
"  4   4       12          12    E<lt>== # of bits\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:635
msgid "Expressed in code, the encoding is:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:643
#, no-wrap
msgid ""
"#define FUTEX_OP(op, oparg, cmp, cmparg) \\e\n"
"                (((op & 0xf) E<lt>E<lt> 28) | \\e\n"
"                ((cmp & 0xf) E<lt>E<lt> 24) | \\e\n"
"                ((oparg & 0xfff) E<lt>E<lt> 12) | \\e\n"
"                (cmparg & 0xfff))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:656
msgid ""
"In the above, I<op> and I<cmp> are each one of the codes listed below.  The "
"I<oparg> and I<cmparg> components are literal numeric values, except as "
"noted below."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:660
msgid "The I<op> component has one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:668
#, no-wrap
msgid ""
"FUTEX_OP_SET        0  /* uaddr2 = oparg; */\n"
"FUTEX_OP_ADD        1  /* uaddr2 += oparg; */\n"
"FUTEX_OP_OR         2  /* uaddr2 |= oparg; */\n"
"FUTEX_OP_ANDN       3  /* uaddr2 &= \\(tioparg; */\n"
"FUTEX_OP_XOR        4  /* uaddr2 \\(ha= oparg; */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:676
msgid ""
"In addition, bitwise ORing the following value into I<op> causes I<(1\\ "
"E<lt>E<lt>\\ oparg)> to be used as the operand:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:680
#, no-wrap
msgid "FUTEX_OP_ARG_SHIFT  8  /* Use (1 E<lt>E<lt> oparg) as operand */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:686
msgid "The I<cmp> field is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:695
#, no-wrap
msgid ""
"FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */\n"
"FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */\n"
"FUTEX_OP_CMP_LT     2  /* if (oldval E<lt> cmparg) wake */\n"
"FUTEX_OP_CMP_LE     3  /* if (oldval E<lt>= cmparg) wake */\n"
"FUTEX_OP_CMP_GT     4  /* if (oldval E<gt> cmparg) wake */\n"
"FUTEX_OP_CMP_GE     5  /* if (oldval E<gt>= cmparg) wake */\n"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:707
msgid ""
"The return value of B<FUTEX_WAKE_OP> is the sum of the number of waiters "
"woken on the futex I<uaddr> plus the number of waiters woken on the futex "
"I<uaddr2>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:707
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: build/C/man2/futex.2:720
msgid ""
"This operation is like B<FUTEX_WAIT> except that I<val3> is used to provide "
"a 32-bit bit mask to the kernel.  This bit mask, in which at least one bit "
"must be set, is stored in the kernel-internal state of the waiter.  See the "
"description of B<FUTEX_WAKE_BITSET> for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:728 build/C/man2/futex.2:1268
msgid ""
"If I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout for the wait operation.  If I<timeout> is NULL, the operation can "
"block indefinitely."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:735
msgid "The I<uaddr2> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:735
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: build/C/man2/futex.2:753
msgid ""
"This operation is the same as B<FUTEX_WAKE> except that the I<val3> argument "
"is used to provide a 32-bit bit mask to the kernel.  This bit mask, in which "
"at least one bit must be set, is used to select which waiters should be "
"woken up.  The selection is done by a bitwise AND of the \"wake\" bit mask "
"(i.e., the value in I<val3>)  and the bit mask which is stored in the "
"kernel-internal state of the waiter (the \"wait\" bit mask that is set using "
"B<FUTEX_WAIT_BITSET>).  All of the waiters for which the result of the AND "
"is nonzero are woken up; the remaining waiters are left sleeping."
msgstr ""

#.  According to http://locklessinc.com/articles/futex_cheat_sheet/:
#
#.     "The original reason for the addition of these extensions
#.      was to improve the performance of pthread read-write locks
#.      in glibc. However, the pthreads library no longer uses the
#.      same locking algorithm, and these extensions are not used
#.      without the bitset parameter being all ones.
#
#.  The page goes on to note that the FUTEX_WAIT_BITSET operation
#.  is nevertheless used (with a bit mask of all ones) in order to
#.  obtain the absolute timeout functionality that is useful
#.  for efficiently implementing Pthreads APIs (which use absolute
#.  timeouts); FUTEX_WAIT provides only relative timeouts.
#. type: Plain text
#: build/C/man2/futex.2:780
msgid ""
"The effect of B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET> is to allow "
"selective wake-ups among multiple waiters that are blocked on the same "
"futex.  However, note that, depending on the use case, employing this "
"bit-mask multiplexing feature on a futex can be less efficient than simply "
"using multiple futexes, because employing bit-mask multiplexing requires the "
"kernel to check all waiters on a futex, including those that are not "
"interested in being woken up (i.e., they do not have the relevant bit set in "
"their \"wait\" bit mask)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:809
msgid ""
"The constant B<FUTEX_BITSET_MATCH_ANY>, which corresponds to all 32 bits set "
"in the bit mask, can be used as the I<val3> argument for "
"B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET>.  Other than differences in "
"the handling of the I<timeout> argument, the B<FUTEX_WAIT> operation is "
"equivalent to B<FUTEX_WAIT_BITSET> with I<val3> specified as "
"B<FUTEX_BITSET_MATCH_ANY>; that is, allow a wake-up by any waker.  The "
"B<FUTEX_WAKE> operation is equivalent to B<FUTEX_WAKE_BITSET> with I<val3> "
"specified as B<FUTEX_BITSET_MATCH_ANY>; that is, wake up any waiter(s)."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:818
msgid "The I<uaddr2> and I<timeout> arguments are ignored."
msgstr ""

#. type: SS
#: build/C/man2/futex.2:818
#, no-wrap
msgid "Priority-inheritance futexes"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:828
msgid ""
"Linux supports priority-inheritance (PI) futexes in order to handle "
"priority-inversion problems that can be encountered with normal futex "
"locks.  Priority inversion is the problem that occurs when a high-priority "
"task is blocked waiting to acquire a lock held by a low-priority task, while "
"tasks at an intermediate priority continuously preempt the low-priority task "
"from the CPU.  Consequently, the low-priority task makes no progress toward "
"releasing the lock, and the high-priority task remains blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:845
msgid ""
"Priority inheritance is a mechanism for dealing with the priority-inversion "
"problem.  With this mechanism, when a high-priority task becomes blocked by "
"a lock held by a low-priority task, the priority of the low-priority task is "
"temporarily raised to that of the high-priority task, so that it is not "
"preempted by any intermediate level tasks, and can thus make progress toward "
"releasing the lock.  To be effective, priority inheritance must be "
"transitive, meaning that if a high-priority task blocks on a lock held by a "
"lower-priority task that is itself blocked by a lock held by another "
"intermediate-priority task (and so on, for chains of arbitrary length), then "
"both of those tasks (or more generally, all of the tasks in a lock chain)  "
"have their priorities raised to be the same as the high-priority task."
msgstr ""

#
#.  Quoting Darren Hart:
#.      These opcodes paired with the PI futex value policy (described below)
#.      defines a "futex" as PI aware. These were created very specifically
#.      in support of PI pthread_mutexes, so it makes a lot more sense to
#.      talk about a PI aware pthread_mutex, than a PI aware futex, since
#.      there is a lot of policy and scaffolding that has to be built up
#.      around it to use it properly (this is what a PI pthread_mutex is).
#. type: Plain text
#: build/C/man2/futex.2:861
msgid ""
"From a user-space perspective, what makes a futex PI-aware is a policy "
"agreement (described below)  between user space and the kernel about the "
"value of the futex word, coupled with the use of the PI-futex operations "
"described below.  (Unlike the other futex operations described above, the "
"PI-futex operations are designed for the implementation of very specific IPC "
"mechanisms.)"
msgstr ""

#.        mtk: The following text is drawn from the Hart/Guniguntala paper
#.        (listed in SEE ALSO), but I have reworded some pieces
#.        significantly.
#. type: Plain text
#: build/C/man2/futex.2:869
msgid ""
"The PI-futex operations described below differ from the other futex "
"operations in that they impose policy on the use of the value of the futex "
"word:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:871
msgid "If the lock is not acquired, the futex word's value shall be 0."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:877
msgid ""
"If the lock is acquired, the futex word's value shall be the thread ID (TID; "
"see B<gettid>(2))  of the owning thread."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:882
msgid ""
"If the lock is owned and there are threads contending for the lock, then the "
"B<FUTEX_WAITERS> bit shall be set in the futex word's value; in other words, "
"this value is:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:884
#, no-wrap
msgid "    FUTEX_WAITERS | TID\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:888
msgid ""
"(Note that is invalid for a PI futex word to have no owner and "
"B<FUTEX_WAITERS> set.)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:899
msgid ""
"With this policy in place, a user-space application can acquire an "
"unacquired lock or release a lock using atomic instructions executed in user "
"mode (e.g., a compare-and-swap operation such as I<cmpxchg> on the x86 "
"architecture).  Acquiring a lock simply consists of using compare-and-swap "
"to atomically set the futex word's value to the caller's TID if its previous "
"value was 0.  Releasing a lock requires using compare-and-swap to set the "
"futex word's value to 0 if the previous value was the expected TID."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:910
msgid ""
"If a futex is already acquired (i.e., has a nonzero value), waiters must "
"employ the B<FUTEX_LOCK_PI> operation to acquire the lock.  If other threads "
"are waiting for the lock, then the B<FUTEX_WAITERS> bit is set in the futex "
"value; in this case, the lock owner must employ the B<FUTEX_UNLOCK_PI> "
"operation to release the lock."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:920
msgid ""
"In the cases where callers are forced into the kernel (i.e., required to "
"perform a B<futex>()  call), they then deal directly with a so-called "
"RT-mutex, a kernel locking mechanism which implements the required "
"priority-inheritance semantics.  After the RT-mutex is acquired, the futex "
"value is updated accordingly, before the calling thread returns to user "
"space."
msgstr ""

#.  tglx (July 2015):
#.      If there are multiple waiters on a pi futex then a wake pi operation
#.      will wake the first waiter and hand over the lock to this waiter. This
#.      includes handing over the rtmutex which represents the futex in the
#.      kernel. The strict requirement is that the futex owner and the rtmutex
#.      owner must be the same, except for the update period which is
#.      serialized by the futex internal locking. That means the kernel must
#.      update the user-space value prior to returning to user space
#. type: Plain text
#: build/C/man2/futex.2:937
msgid ""
"It is important to note that the kernel will update the futex word's value "
"prior to returning to user space.  (This prevents the possibility of the "
"futex word's value ending up in an invalid state, such as having an owner "
"but the value being 0, or having waiters but not having the B<FUTEX_WAITERS> "
"bit set.)"
msgstr ""

#.  tglx (July 2015):
#.      The FUTEX_OWNER_DIED bit can also be set on uncontended futexes, where
#.      the kernel has no state associated. This happens via the robust futex
#.      mechanism. In that case the futex value will be set to
#.      FUTEX_OWNER_DIED. The robust futex mechanism is also available for non
#.      PI futexes.
#. type: Plain text
#: build/C/man2/futex.2:956
msgid ""
"If a futex has an associated RT-mutex in the kernel (i.e., there are blocked "
"waiters)  and the owner of the futex/RT-mutex dies unexpectedly, then the "
"kernel cleans up the RT-mutex and hands it over to the next waiter.  This in "
"turn requires that the user-space value is updated accordingly.  To indicate "
"that this is required, the kernel sets the B<FUTEX_OWNER_DIED> bit in the "
"futex word along with the thread ID of the new owner.  User space can detect "
"this situation via the presence of the B<FUTEX_OWNER_DIED> bit and is then "
"responsible for cleaning up the stale state left over by the dead owner."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:961
msgid ""
"PI futexes are operated on by specifying one of the values listed below in "
"I<futex_op>.  Note that the PI futex operations must be used as paired "
"operations and are subject to some additional requirements:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:972
msgid ""
"B<FUTEX_LOCK_PI> and B<FUTEX_TRYLOCK_PI> pair with B<FUTEX_UNLOCK_PI>.  "
"B<FUTEX_UNLOCK_PI> must be called only on a futex owned by the calling "
"thread, as defined by the value policy, otherwise the error B<EPERM> "
"results."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:986
msgid ""
"B<FUTEX_WAIT_REQUEUE_PI> pairs with B<FUTEX_CMP_REQUEUE_PI>.  This must be "
"performed from a non-PI futex to a distinct PI futex (or the error B<EINVAL> "
"results).  Additionally, I<val> (the number of waiters to be woken) must be "
"1 (or the error B<EINVAL> results)."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:991
msgid "The PI futex operations are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:991
#, no-wrap
msgid "B<FUTEX_LOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: build/C/man2/futex.2:998
msgid ""
"This operation is used after an attempt to acquire the lock via an atomic "
"user-mode instruction failed because the futex word has a nonzero "
"value\\(emspecifically, because it contained the (PID-namespace-specific) "
"TID of the lock owner."
msgstr ""

#.  tglx (July 2015):
#.      The operation here is similar to the FUTEX_WAIT logic. When the user
#.      space atomic acquire does not succeed because the futex value was non
#.      zero, then the waiter goes into the kernel, takes the kernel internal
#.      lock and retries the acquisition under the lock. If the acquisition
#.      does not succeed either, then it sets the FUTEX_WAITERS bit, to signal
#.      the lock owner that it needs to go into the kernel. Here is the pseudo
#.      code:
#
#.      	lock(kernel_lock);
#.      retry:
#
#.      	/*
#.      	 * Owner might have unlocked in userspace before we
#.      	 * were able to set the waiter bit.
#.               */
#.              if (atomic_acquire(futex) == SUCCESS) {
#.      	   unlock(kernel_lock());
#.      	   return 0;
#.      	}
#
#.      	/*
#.      	 * Owner might have unlocked after the above atomic_acquire()
#.      	 * attempt.
#.      	 */
#.      	if (atomic_set_waiters_bit(futex) != SUCCESS)
#.      	   goto retry;
#
#.      	queue_waiter();
#.      	unlock(kernel_lock);
#.      	block();
#. type: Plain text
#: build/C/man2/futex.2:1041
msgid ""
"The operation checks the value of the futex word at the address I<uaddr>.  "
"If the value is 0, then the kernel tries to atomically set the futex value "
"to the caller's TID.  If the futex word's value is nonzero, the kernel "
"atomically sets the B<FUTEX_WAITERS> bit, which signals the futex owner that "
"it cannot unlock the futex in user space atomically by setting the futex "
"value to 0.  After that, the kernel:"
msgstr ""

#. type: IP
#: build/C/man2/futex.2:1042 build/C/man2/ptrace.2:2560
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1044
msgid "Tries to find the thread which is associated with the owner TID."
msgstr ""

#. type: IP
#: build/C/man2/futex.2:1044 build/C/man2/ptrace.2:2563
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1050
msgid ""
"Creates or reuses kernel state on behalf of the owner.  (If this is the "
"first waiter, there is no kernel state for this futex, so kernel state is "
"created by locking the RT-mutex and the futex owner is made the owner of the "
"RT-mutex.  If there are existing waiters, then the existing state is "
"reused.)"
msgstr ""

#. type: IP
#: build/C/man2/futex.2:1050 build/C/man2/ptrace.2:2580
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1053
msgid ""
"Attaches the waiter to the futex (i.e., the waiter is enqueued on the "
"RT-mutex waiter list)."
msgstr ""

#.  August 2015:
#.      mtk: If the realm is restricted purely to SCHED_OTHER (SCHED_NORMAL)
#.           processes, does the nice value come into play also?
#
#.      tglx: No. SCHED_OTHER/NORMAL tasks are handled in FIFO order
#.  (i.e., task 1 blocks on lock A, held by task 2,
#.  while task 2 blocks on lock B, held by task 3)
#. type: Plain text
#: build/C/man2/futex.2:1081
msgid ""
"If more than one waiter exists, the enqueueing of the waiter is in "
"descending priority order.  (For information on priority ordering, see the "
"discussion of the B<SCHED_DEADLINE>, B<SCHED_FIFO>, and B<SCHED_RR> "
"scheduling policies in B<sched>(7).)  The owner inherits either the waiter's "
"CPU bandwidth (if the waiter is scheduled under the B<SCHED_DEADLINE> "
"policy) or the waiter's priority (if the waiter is scheduled under the "
"B<SCHED_RR> or B<SCHED_FIFO> policy).  This inheritance follows the lock "
"chain in the case of nested locking and performs deadlock detection."
msgstr ""

#.  2016-07-07 response from Thomas Gleixner on LKML:
#.  From: Thomas Gleixner <tglx@linutronix.de>
#.  Date: 6 July 2016 at 20:57
#.  Subject: Re: futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
#
#.  On Thu, 23 Jun 2016, Michael Kerrisk (man-pages) wrote:
#.  > On 06/23/2016 08:28 PM, Darren Hart wrote:
#.  > > And as a follow-on, what is the reason for FUTEX_LOCK_PI only using
#.  > > CLOCK_REALTIME? It seems reasonable to me that a user may want to wait a
#.  > > specific amount of time, regardless of wall time.
#.  >
#.  > Yes, that's another weird inconsistency.
#
#.  The reason is that phtread_mutex_timedlock() uses absolute timeouts based on
#.  CLOCK_REALTIME. glibc folks asked to make that the default behaviour back
#.  then when we added LOCK_PI.
#. type: Plain text
#: build/C/man2/futex.2:1110
msgid ""
"The I<timeout> argument provides a timeout for the lock attempt.  If "
"I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout, measured against the B<CLOCK_REALTIME> clock.  If I<timeout> is "
"NULL, the operation will block indefinitely."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1120
msgid "The I<uaddr2>, I<val>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1120
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: build/C/man2/futex.2:1127
msgid ""
"This operation tries to acquire the lock at I<uaddr>.  It is invoked when a "
"user-space atomic acquire did not succeed because the futex word was not 0."
msgstr ""

#.  Paraphrasing a f2f conversation with Thomas Gleixner about the
#.  above point (Aug 2015): ###
#. 	There is a rare possibility of a race condition involving an
#. 	uncontended futex with no owner, but with waiters.  The
#. 	kernel-user-space contract is that if a futex is nonzero, you must
#. 	go into kernel.  The futex was owned by a task, and that task dies
#. 	but there are no waiters, so the futex value is non zero.
#. 	Therefore, the next locker has to go into the kernel,
#. 	so that the kernel has a chance to clean up. (CMXCH on zero
#. 	in user space would fail, so kernel has to clean up.)
#.  Darren Hart (Oct 2015):
#.      The trylock in the kernel has more state, so it can independently
#.      verify the  flags that userspace must trust implicitly.
#. type: Plain text
#: build/C/man2/futex.2:1151
msgid ""
"Because the kernel has access to more state information than user space, "
"acquisition of the lock might succeed if performed by the kernel in cases "
"where the futex word (i.e., the state information accessible to use-space) "
"contains stale state (B<FUTEX_WAITERS> and/or B<FUTEX_OWNER_DIED>).  This "
"can happen when the owner of the futex died.  User space cannot handle this "
"condition in a race-free manner, but the kernel can fix this up and acquire "
"the futex."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1162 build/C/man2/futex.2:1185
msgid "The I<uaddr2>, I<val>, I<timeout>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1162
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: build/C/man2/futex.2:1170
msgid ""
"This operation wakes the top priority waiter that is waiting in "
"B<FUTEX_LOCK_PI> on the futex address provided by the I<uaddr> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1174
msgid ""
"This is called when the user-space value at I<uaddr> cannot be changed "
"atomically from a TID (of the owner) to 0."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1185
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: build/C/man2/futex.2:1198
msgid ""
"This operation is a PI-aware variant of B<FUTEX_CMP_REQUEUE>.  It requeues "
"waiters that are blocked via B<FUTEX_WAIT_REQUEUE_PI> on I<uaddr> from a "
"non-PI source futex (I<uaddr>)  to a PI target futex (I<uaddr2>)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1214
msgid ""
"As with B<FUTEX_CMP_REQUEUE>, this operation wakes up a maximum of I<val> "
"waiters that are waiting on the futex at I<uaddr>.  However, for "
"B<FUTEX_CMP_REQUEUE_PI>, I<val> is required to be 1 (since the main point is "
"to avoid a thundering herd).  The remaining waiters are removed from the "
"wait queue of the source futex at I<uaddr> and added to the wait queue of "
"the target futex at I<uaddr2>."
msgstr ""

#.  val2 is the cap on the number of requeued waiters.
#.  In the glibc pthread_cond_broadcast() implementation, this argument
#.  is specified as INT_MAX, and for pthread_cond_signal() it is 0.
#
#.        The page at http://locklessinc.com/articles/futex_cheat_sheet/
#.        notes that "priority-inheritance Futex to priority-inheritance
#.        Futex requeues are currently unsupported". However, probably
#.        the page does not need to say nothing about this, since
#.        Thomas Gleixner commented (July 2015): "they never will be
#.        supported because they make no sense at all"
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1234
msgid ""
"The I<val2> and I<val3> arguments serve the same purposes as for "
"B<FUTEX_CMP_REQUEUE>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1234
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: build/C/man2/futex.2:1248
msgid ""
"Wait on a non-PI futex at I<uaddr> and potentially be requeued (via a "
"B<FUTEX_CMP_REQUEUE_PI> operation in another task) onto a PI futex at "
"I<uaddr2>.  The wait operation on I<uaddr> is the same as for B<FUTEX_WAIT>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1260
msgid ""
"The waiter can be removed from the wait on I<uaddr> without requeueing on "
"I<uaddr2> via a B<FUTEX_WAKE> operation in another task.  In this case, the "
"B<FUTEX_WAIT_REQUEUE_PI> operation fails with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1272
msgid "The I<val3> argument is ignored."
msgstr ""

#
#.  Darren Hart notes that a patch to allow glibc to fully support
#.  PI-aware pthreads condition variables has not yet been accepted into
#.  glibc. The story is complex, and can be found at
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11588
#.  Darren notes that in the meantime, the patch is shipped with various
#.  PREEMPT_RT-enabled Linux systems.
#
#.  Related to the preceding, Darren proposed that somewhere, man-pages
#.  should document the following point:
#
#.      While the Linux kernel, since 2.6.31, supports requeueing of
#.      priority-inheritance (PI) aware mutexes via the
#.      FUTEX_WAIT_REQUEUE_PI and FUTEX_CMP_REQUEUE_PI futex operations,
#.      the glibc implementation does not yet take full advantage of this.
#.      Specifically, the condvar internal data lock remains a non-PI aware
#.      mutex, regardless of the type of the pthread_mutex associated with
#.      the condvar. This can lead to an unbounded priority inversion on
#.      the internal data lock even when associating a PI aware
#.      pthread_mutex with a condvar during a pthread_cond*_wait
#.      operation. For this reason, it is not recommended to rely on
#.      priority inheritance when using pthread condition variables.
#
#.  The problem is that the obvious location for this text is
#.  the pthread_cond*wait(3) man page. However, such a man page
#.  does not currently exist.
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1316
msgid ""
"The B<FUTEX_WAIT_REQUEUE_PI> and B<FUTEX_CMP_REQUEUE_PI> were added to "
"support a fairly specific use case: support for priority-inheritance-aware "
"POSIX threads condition variables.  The idea is that these operations should "
"always be paired, in order to ensure that user space and the kernel remain "
"in sync.  Thus, in the B<FUTEX_WAIT_REQUEUE_PI> operation, the user-space "
"application pre-specifies the target of the requeue that takes place in the "
"B<FUTEX_CMP_REQUEUE_PI> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1324
msgid ""
"In the event of an error (and assuming that B<futex>()  was invoked via "
"B<syscall>(2)), all operations return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1327
msgid ""
"The return value on success depends on the operation, as described in the "
"following list:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1327
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1338
msgid ""
"Returns 0 if the caller was woken up.  Note that a wake-up can also be "
"caused by common futex usage patterns in unrelated code that happened to "
"have previously used the futex word's memory location (e.g., typical "
"futex-based implementations of Pthreads mutexes can cause this under some "
"conditions).  Therefore, callers should always conservatively assume that a "
"return value of 0 can mean a spurious wake-up, and use the futex word's "
"value (i.e., the user-space synchronization scheme)  to decide whether to "
"continue to block or not."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1338
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1341 build/C/man2/futex.2:1347 build/C/man2/futex.2:1374
msgid "Returns the number of waiters that were woken up."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1341
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1344
msgid "Returns the new file descriptor associated with the futex."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1344
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1347
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1357
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then the difference is the number of waiters requeued to the futex "
"for the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1357
#, no-wrap
msgid "B<FUTEX_WAKE_OP>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1365
msgid ""
"Returns the total number of waiters that were woken up.  This is the sum of "
"the woken waiters on the two futexes for the futex words at I<uaddr> and "
"I<uaddr2>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1365
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1371
msgid ""
"Returns 0 if the caller was woken up.  See B<FUTEX_WAIT> for how to "
"interpret this correctly in practice."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1371
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1374
#, no-wrap
msgid "B<FUTEX_LOCK_PI>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1377 build/C/man2/futex.2:1380
msgid "Returns 0 if the futex was successfully locked."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1377
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1380
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1383
msgid "Returns 0 if the futex was successfully unlocked."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1383
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1393
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then difference is the number of waiters requeued to the futex for "
"the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1393
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI>"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1401
msgid ""
"Returns 0 if the caller was successfully requeued to the futex for the futex "
"word at I<uaddr2>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1402 build/C/man2/perf_event_open.2:3494 build/C/man2/quotactl.2:697
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1405
msgid "No read access to the memory of a futex word."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1405 build/C/man2/futex.2:1423 build/C/man2/futex.2:1431 build/C/man2/sendfile.2:122 build/C/man2/splice.2:154 build/C/man2/tee.2:99 build/C/man2/vmsplice.2:141
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1415
msgid ""
"(B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI>)  The value "
"pointed to by I<uaddr> was not equal to the expected value I<val> at the "
"time of the call."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1423
msgid ""
"B<Note>: on Linux, the symbolic names B<EAGAIN> and B<EWOULDBLOCK> (both of "
"which appear in different parts of the kernel futex code)  have the same "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1431
msgid ""
"(B<FUTEX_CMP_REQUEUE>, B<FUTEX_CMP_REQUEUE_PI>)  The value pointed to by "
"I<uaddr> is not equal to the expected value I<val3>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1444
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"owner thread ID of I<uaddr> (for B<FUTEX_CMP_REQUEUE_PI>: I<uaddr2>)  is "
"about to exit, but has not yet handled the internal state cleanup.  Try "
"again."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1444 build/C/man2/futex.2:1452
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1452
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"word at I<uaddr> is already locked by the caller."
msgstr ""

#.  FIXME . I see that kernel/locking/rtmutex.c uses EDEADLK in some
#.        places, and EDEADLOCK in others. On almost all architectures
#.        these constants are synonymous. Is there a reason that both
#.        names are used?
#
#.        tglx (July 2015): "No. We should probably fix that."
#. type: Plain text
#: build/C/man2/futex.2:1465
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  While requeueing a waiter to the PI futex for the "
"futex word at I<uaddr2>, the kernel detected a deadlock."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1473
msgid ""
"A required pointer argument (i.e., I<uaddr>, I<uaddr2>, or I<timeout>)  did "
"not point to a valid user-space address."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1473 build/C/man2/perf_event_open.2:3556
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1483
msgid ""
"A B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> operation was interrupted by a "
"signal (see B<signal>(7)).  In kernels before Linux 2.6.22, this error could "
"also be returned for a spurious wakeup; since Linux 2.6.22, this no longer "
"happens."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1494
msgid ""
"The operation in I<futex_op> is one of those that employs a timeout, but the "
"supplied I<timeout> argument was invalid (I<tv_sec> was less than zero, or "
"I<tv_nsec> was not less than 1,000,000,000)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1504
msgid ""
"The operation specified in I<futex_op> employs one or both of the pointers "
"I<uaddr> and I<uaddr2>, but one of these does not point to a valid "
"object\\(emthat is, the address is not four-byte-aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1511
msgid ""
"(B<FUTEX_WAIT_BITSET>, B<FUTEX_WAKE_BITSET>)  The bit mask supplied in "
"I<val3> is zero."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1518
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  I<uaddr> equals I<uaddr2> (i.e., an attempt was "
"made to requeue to the same futex)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1524
msgid "(B<FUTEX_FD>)  The signal number supplied in I<val> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1537
msgid ""
"(B<FUTEX_WAKE>, B<FUTEX_WAKE_OP>, B<FUTEX_WAKE_BITSET>, B<FUTEX_REQUEUE>, "
"B<FUTEX_CMP_REQUEUE>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state\\(emthat is, it detected a "
"waiter which waits in B<FUTEX_LOCK_PI> on I<uaddr>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1552
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>)  The kernel "
"detected an inconsistency between the user-space state at I<uaddr> and the "
"kernel state.  This indicates either state corruption or that the kernel "
"found a waiter on I<uaddr> which is waiting via B<FUTEX_WAIT> or "
"B<FUTEX_WAIT_BITSET>."
msgstr ""

#.  From a conversation with Thomas Gleixner (Aug 2015): ###
#. 	The kernel sees: I have non PI state for a futex you tried to
#.      tell me was PI
#. type: Plain text
#: build/C/man2/futex.2:1567
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr2> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> on "
"I<uaddr2>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1579
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITESET> on "
"I<uaddr>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1591
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits on I<uaddr> via B<FUTEX_LOCK_PI> (instead of "
"B<FUTEX_WAIT_REQUEUE_PI>)."
msgstr ""

#.  This deals with the case:
#.      wait_requeue_pi(A, B);
#.      requeue_pi(A, C);
#. type: Plain text
#: build/C/man2/futex.2:1601
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  An attempt was made to requeue a waiter to a "
"futex other than that specified by the matching B<FUTEX_WAIT_REQUEUE_PI> "
"call for that waiter."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1607
msgid "(B<FUTEX_CMP_REQUEUE_PI>)  The I<val> argument is not 1."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1610
msgid "Invalid argument."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1610 build/C/man2/userfaultfd.2:436
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1614
msgid ""
"(B<FUTEX_FD>)  The system-wide limit on the total number of open files has "
"been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1620
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The kernel "
"could not allocate memory to hold state information."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1620 build/C/man2/futex.2:1624 build/C/man2/futex.2:1635 build/C/man2/modify_ldt.2:165 build/C/man2/pciconfig_read.2:92 build/C/man2/perf_event_open.2:3588 build/C/man2/quotactl.2:749 build/C/man2/vm86.2:64
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1624
msgid "Invalid operation specified in I<futex_op>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1635
msgid ""
"The B<FUTEX_CLOCK_REALTIME> option was specified in I<futex_op>, but the "
"accompanying operation was neither B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, nor "
"B<FUTEX_WAIT_REQUEUE_PI>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1645
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>, "
"B<FUTEX_CMP_REQUEUE_PI>, B<FUTEX_WAIT_REQUEUE_PI>)  A run-time check "
"determined that the operation is not available.  The PI-futex operations are "
"not implemented on all architectures and are not supported on some CPU "
"variants."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1657
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The caller "
"is not allowed to attach itself to the futex at I<uaddr> (for "
"B<FUTEX_CMP_REQUEUE_PI>: the futex at I<uaddr2>).  (This may be caused by a "
"state corruption in user space.)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1661
msgid ""
"(B<FUTEX_UNLOCK_PI>)  The caller does not own the lock represented by the "
"futex word."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1661 build/C/man2/futex.2:1669 build/C/man2/get_robust_list.2:133 build/C/man2/perf_event_open.2:3627 build/C/man2/process_vm_readv.2:278 build/C/man2/ptrace.2:2380 build/C/man2/quotactl.2:769 build/C/man2/quotactl.2:773 build/C/man2/quotactl.2:779
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1669
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The thread "
"ID in the futex word at I<uaddr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1675
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The thread ID in the futex word at I<uaddr2> does "
"not exist."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:1675
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1685
msgid ""
"The operation in I<futex_op> employed the timeout specified in I<timeout>, "
"and the timeout expired before the operation completed."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1688
msgid ""
"Futexes were first made available in a stable kernel release with Linux "
"2.6.0."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1695
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A four-argument system call with the "
"semantics described in this page was introduced in Linux 2.5.40.  A fifth "
"argument was added in Linux 2.5.70, and a sixth argument was added in Linux "
"2.6.7."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1697 build/C/man2/set_tid_address.2:102 build/C/man2/splice.2:203 build/C/man2/tee.2:127 build/C/man2/vmsplice.2:169
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1700 build/C/man2/modify_ldt.2:175 build/C/man2/perfmonctl.2:205 build/C/man2/pivot_root.2:171 build/C/man2/set_tid_address.2:105 build/C/man2/userfaultfd.2:465
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#.  TODO FIXME(Torvald) Above, we cite this section and claim it contains
#.  details on the synchronization semantics; add the C11 equivalents
#.  here (or whatever we find consensus for).
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/futex.2:1711
msgid ""
"Several higher-level programming abstractions are implemented via futexes, "
"including POSIX semaphores and various POSIX threads synchronization "
"mechanisms (mutexes, condition variables, read-write locks, and barriers)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1722
msgid ""
"The program below demonstrates use of futexes in a program where a parent "
"process and a child process use a pair of futexes located inside a shared "
"anonymous mapping to synchronize access to a shared resource: the terminal.  "
"The two processes each write I<nloops> (a command-line argument that "
"defaults to 5 if omitted)  messages to the terminal and employ a "
"synchronization protocol that ensures that they alternate in writing "
"messages.  Upon running this program we see output such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1736
#, no-wrap
msgid ""
"$ B<./futex_demo>\n"
"Parent (18534) 0\n"
"Child  (18535) 0\n"
"Parent (18534) 1\n"
"Child  (18535) 1\n"
"Parent (18534) 2\n"
"Child  (18535) 2\n"
"Parent (18534) 3\n"
"Child  (18535) 3\n"
"Parent (18534) 4\n"
"Child  (18535) 4\n"
msgstr ""

#. type: SS
#: build/C/man2/futex.2:1738 build/C/man2/pivot_root.2:310 build/C/man2/tee.2:152 build/C/man2/userfaultfd.2:561
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1742
#, no-wrap
msgid "/* futex_demo.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1745
#, no-wrap
msgid ""
"   Usage: futex_demo [nloops]\n"
"                    (Default: 5)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1765
#, no-wrap
msgid ""
"   Demonstrate the use of futexes in a program where parent and child\n"
"   use a pair of futexes located inside a shared anonymous mapping to\n"
"   synchronize access to a shared resource: the terminal. The two\n"
"   processes each write \\(aqnum-loops\\(aq messages to the terminal and "
"employ\n"
"   a synchronization protocol that ensures that they alternate in\n"
"   writing messages.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdatomic.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/futex.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1768 build/C/man2/pivot_root.2:330 build/C/man2/userfaultfd.2:588
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1770
#, no-wrap
msgid "static uint32_t *futex1, *futex2, *iaddr;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1778
#, no-wrap
msgid ""
"static int\n"
"futex(uint32_t *uaddr, int futex_op, uint32_t val,\n"
"      const struct timespec *timeout, uint32_t *uaddr2, uint32_t val3)\n"
"{\n"
"    return syscall(SYS_futex, uaddr, futex_op, val,\n"
"                   timeout, uaddr2, val3);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1781
#, no-wrap
msgid ""
"/* Acquire the futex pointed to by \\(aqfutexp\\(aq: wait for its value to\n"
"   become 1, and then set the value to 0. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1786
#, no-wrap
msgid ""
"static void\n"
"fwait(uint32_t *futexp)\n"
"{\n"
"    long s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1789
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong(ptr, oldval, newval)\n"
"       atomically performs the equivalent of:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1792
#, no-wrap
msgid ""
"           if (*ptr == *oldval)\n"
"               *ptr = newval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1794
#, no-wrap
msgid "       It returns true if the test yielded true and *ptr was updated. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1796
#, no-wrap
msgid "    while (1) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1801
#, no-wrap
msgid ""
"        /* Is the futex available? */\n"
"        const uint32_t one = 1;\n"
"        if (atomic_compare_exchange_strong(futexp, &one, 0))\n"
"            break;      /* Yes */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1803
#, no-wrap
msgid "        /* Futex is not available; wait */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1809
#, no-wrap
msgid ""
"        s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);\n"
"        if (s == -1 && errno != EAGAIN)\n"
"            errExit(\"futex-FUTEX_WAIT\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1813
#, no-wrap
msgid ""
"/* Release the futex pointed to by \\(aqfutexp\\(aq: if the futex "
"currently\n"
"   has the value 0, set its value to 1 and the wake any futex waiters,\n"
"   so that if the peer is blocked in fwait(), it can proceed. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1818
#, no-wrap
msgid ""
"static void\n"
"fpost(uint32_t *futexp)\n"
"{\n"
"    long s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1821
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong() was described\n"
"       in comments above */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1829
#, no-wrap
msgid ""
"    const uint32_t zero = 0;\n"
"    if (atomic_compare_exchange_strong(futexp, &zero, 1)) {\n"
"        s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
"        if (s  == -1)\n"
"            errExit(\"futex-FUTEX_WAKE\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1835
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t childPid;\n"
"    int nloops;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1837
#, no-wrap
msgid "    setbuf(stdout, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1839
#, no-wrap
msgid "    nloops = (argc E<gt> 1) ? atoi(argv[1]) : 5;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1844
#, no-wrap
msgid ""
"    /* Create a shared anonymous mapping that will hold the futexes.\n"
"       Since the futexes are being shared between processes, we\n"
"       subsequently use the \"shared\" futex operations (i.e., not the\n"
"       ones suffixed \"_PRIVATE\") */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1849
#, no-wrap
msgid ""
"    iaddr = mmap(NULL, sizeof(*iaddr) * 2, PROT_READ | PROT_WRITE,\n"
"                MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n"
"    if (iaddr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1852
#, no-wrap
msgid ""
"    futex1 = &iaddr[0];\n"
"    futex2 = &iaddr[1];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1855
#, no-wrap
msgid ""
"    *futex1 = 0;        /* State: unavailable */\n"
"    *futex2 = 1;        /* State: available */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1858
#, no-wrap
msgid ""
"    /* Create a child process that inherits the shared anonymous\n"
"       mapping */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1862
#, no-wrap
msgid ""
"    childPid = fork();\n"
"    if (childPid == -1)\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1869
#, no-wrap
msgid ""
"    if (childPid == 0) {        /* Child */\n"
"        for (int j = 0; j E<lt> nloops; j++) {\n"
"            fwait(futex1);\n"
"            printf(\"Child  (%jd) %d\\en\", (intmax_t) getpid(), j);\n"
"            fpost(futex2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1872
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1874
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1880
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> nloops; j++) {\n"
"        fwait(futex2);\n"
"        printf(\"Parent (%jd) %d\\en\", (intmax_t) getpid(), j);\n"
"        fpost(futex1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1882
#, no-wrap
msgid "    wait(NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1885 build/C/man2/pivot_root.2:410 build/C/man2/userfaultfd.2:760
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1893
msgid ""
"B<get_robust_list>(2), B<restart_syscall>(2), "
"B<pthread_mutexattr_getprotocol>(3), B<futex>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1895
msgid "The following kernel source files:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1897
msgid "I<Documentation/pi-futex.txt>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1899
msgid "I<Documentation/futex-requeue-pi.txt>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1901
msgid "I<Documentation/locking/rt-mutex.txt>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1903
msgid "I<Documentation/locking/rt-mutex-design.txt>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1905
msgid "I<Documentation/robust-futex-ABI.txt>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1909
msgid ""
"Franke, H., Russell, R., and Kirwood, M., 2002.  I<Fuss, Futexes and "
"Furwocks: Fast Userlevel Locking in Linux> (from proceedings of the Ottawa "
"Linux Symposium 2002),"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1912
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1916
msgid ""
"Hart, D., 2009. I<A futex overview and update>, E<.UR "
"http://lwn.net/Articles/360699/> E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1922
msgid ""
"Hart, D.\\& and Guniguntala, D., 2009.  I<Requeue-PI: Making Glibc Condvars "
"PI-Aware> (from proceedings of the 2009 Real-Time Linux Workshop), E<.UR "
"http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1926
msgid ""
"Drepper, U., 2011. I<Futexes Are Tricky>, E<.UR "
"http://www.akkadia.org/drepper/futex.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:1928
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr ""

#
#.  FIXME(Torvald) We should probably refer to the glibc code here, in
#.  particular the glibc-internal futex wrapper functions that are
#.  WIP, and the generic pthread_mutex_t and perhaps condvar
#.  implementations.
#. type: Plain text
#: build/C/man2/futex.2:1936
msgid ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE>"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:30
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:30
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:30
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:33
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:38
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:42
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head "
"**>I<head_ptr>B<,>\n"
"B<                     size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:46 build/C/man2/kexec_load.2:46
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:54
msgid ""
"These system calls deal with per-thread robust futex lists.  These lists are "
"managed in user space: the kernel knows only about the location of the head "
"of the list.  A thread can inform the kernel of the location of its robust "
"futex list using B<set_robust_list>().  The address of a thread's robust "
"futex list can be obtained using B<get_robust_list>()."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:66
msgid ""
"The purpose of the robust futex list is to ensure that if a thread "
"accidentally fails to unlock a futex before terminating or calling "
"B<execve>(2), another thread that is waiting on that futex is notified that "
"the former owner of the futex has died.  This notification consists of two "
"pieces: the B<FUTEX_OWNER_DIED> bit is set in the futex word, and the kernel "
"performs a B<futex>(2)  B<FUTEX_WAKE> operation on one of the threads "
"waiting on the futex."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:82
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:89
msgid ""
"Permission to employ B<get_robust_list>()  is governed by a ptrace access "
"mode B<PTRACE_MODE_READ_REALCREDS> check; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:101
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head "
"of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:108
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero "
"when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:112
msgid "The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:117
msgid "I<len> does not equal I<sizeof(struct\\ robust_list_head)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:121
msgid "The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:125
msgid "The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:133
msgid ""
"The calling process does not have permission to see the robust futex list of "
"the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:138
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:140
msgid "These system calls were added in Linux 2.6.17."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:145
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them "
"directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:149
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  commit 8141c7f3e7aee618312fa1c15109e1219de784a7
#. type: Plain text
#: build/C/man2/get_robust_list.2:157
msgid ""
"In the initial implementation, a thread waiting on a futex was notified that "
"the owner had died only if the owner terminated.  Starting with Linux "
"2.6.28, notification was extended to include the case where the owner "
"performs an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:164
msgid ""
"The thread IDs mentioned in the main text are I<kernel> thread IDs of the "
"kind returned by B<clone>(2)  and B<gettid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:167
msgid "B<futex>(2), B<pthread_mutexattr_setrobust>(3)"
msgstr ""

#.  http://lwn.net/Articles/172149/
#. type: Plain text
#: build/C/man2/get_robust_list.2:173
msgid ""
"I<Documentation/robust-futexes.txt> and "
"I<Documentation/robust-futex-ABI.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27 build/C/man2/lookup_dcookie.2:27 build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:33 build/C/man2/sendfile.2:19
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:74
#, no-wrap
msgid ""
"u64 start;      (64-bit address of start of function)\n"
"u64 end;        (64-bit address of end of function)\n"
"u64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:83
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:90
msgid ""
"On success, B<getunwind>()  returns the size of the unwind data.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:96
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:98
msgid "This system call is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:101
msgid ""
"This system call is Linux-specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:105
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's "
"unwind data is via the B<vdso>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:109
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event "
"that you want to call it, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:111
msgid "B<getauxval>(3)"
msgstr ""

#. type: TH
#: build/C/man2/kexec_load.2:27
#, no-wrap
msgid "KEXEC_LOAD"
msgstr ""

#. type: TH
#: build/C/man2/kexec_load.2:27 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:30
msgid "kexec_load, kexec_file_load - load a new kernel for later execution"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:33
#, no-wrap
msgid "B<#include E<lt>linux/kexec.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:37
#, no-wrap
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long "
">I<nr_segments>B<,>\n"
"B<                struct kexec_segment *>I<segments>B<, unsigned long "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:42
#, no-wrap
msgid ""
"B<long kexec_file_load(int >I<kernel_fd>B<, int >I<initrd_fd>B<,>\n"
"B<                    unsigned long >I<cmdline_len>B<, const char "
"*>I<cmdline>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:51
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:57
msgid ""
"The I<flags> argument is a bit mask that controls the operation of the "
"call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:57
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:73
msgid ""
"Execute the new kernel automatically on a system crash.  This \"crash "
"kernel\" is loaded into an area of reserved memory that is determined at "
"boot time using the I<crashkernel> kernel command-line parameter.  The "
"location of this reserved memory is exported to user space via the "
"I</proc/iomem> file, in an entry labeled \"Crash kernel\".  A user-space "
"application can parse this file and prepare a list of segments (see below) "
"that specify this reserved memory as destination.  If this flag is "
"specified, the kernel checks that the target segments specified in "
"I<segments> fall within the reserved region."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:73
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:83
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is available only "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is effective "
"only if I<nr_segments> is greater than 0."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:104
msgid ""
"The high-order bits (corresponding to the mask 0xffff0000) of I<flags> "
"contain the architecture of the to-be-executed kernel.  Specify (OR) the "
"constant B<KEXEC_ARCH_DEFAULT> to use the current architecture, or one of "
"the following architecture constants B<KEXEC_ARCH_386>, B<KEXEC_ARCH_68K>, "
"B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, B<KEXEC_ARCH_PPC64>, "
"B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, B<KEXEC_ARCH_S390>, "
"B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and B<KEXEC_ARCH_MIPS_LE>.  The "
"architecture must be executable on the CPU of the system."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:119
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer; the kernel imposes an (arbitrary) limit of 16 on the "
"number of segments.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:128
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:145
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into the kernel either in regular memory or in reserved memory (if "
"B<KEXEC_ON_CRASH> is set).  The kernel first performs various sanity checks "
"on the information passed in I<segments>.  If these checks pass, the kernel "
"copies the segment data to kernel memory.  Each segment specified in "
"I<segments> is copied as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:156
msgid ""
"I<buf> and I<bufsz> identify a memory region in the caller's virtual address "
"space that is the source of the copy.  The value in I<bufsz> may not exceed "
"the value in the I<memsz> field."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:163
msgid ""
"I<mem> and I<memsz> specify a physical address range that is the target of "
"the copy.  The values specified in both fields must be multiples of the "
"system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:171
msgid ""
"I<bufsz> bytes are copied from the source buffer to the target kernel "
"buffer.  If I<bufsz> is less than I<memsz>, then the excess bytes in the "
"kernel buffer are zeroed out."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:180
msgid ""
"In case of a normal kexec (i.e., the B<KEXEC_ON_CRASH> flag is not set), the "
"segment data is loaded in any available memory and is moved to the final "
"destination at kexec reboot time (e.g., when the B<kexec>(8)  command is "
"executed with the I<-e> option)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:186
msgid ""
"In case of kexec on panic (i.e., the B<KEXEC_ON_CRASH> flag is set), the "
"segment data is loaded to reserved memory at the time of the call, and, "
"after a crash, the kexec mechanism simply passes control to that kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:191
msgid ""
"The B<kexec_load>()  system call is available only if the kernel was "
"configured with B<CONFIG_KEXEC>."
msgstr ""

#. type: SS
#: build/C/man2/kexec_load.2:191
#, no-wrap
msgid "kexec_file_load()"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:211
msgid ""
"The B<kexec_file_load>()  system call is similar to B<kexec_load>(), but it "
"takes a different set of arguments.  It reads the kernel to be loaded from "
"the file referred to by the file descriptor I<kernel_fd>, and the initrd "
"(initial RAM disk)  to be loaded from file referred to by the file "
"descriptor I<initrd_fd>.  The I<cmdline> argument is a pointer to a buffer "
"containing the command line for the new kernel.  The I<cmdline_len> argument "
"specifies size of the buffer.  The last byte in the buffer must be a null "
"byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:217
msgid ""
"The I<flags> argument is a bit mask which modifies the behavior of the "
"call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:217
#, no-wrap
msgid "B<KEXEC_FILE_UNLOAD>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:220
msgid "Unload the currently loaded kernel."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:220
#, no-wrap
msgid "B<KEXEC_FILE_ON_CRASH>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:226
msgid ""
"Load the new kernel in the memory region reserved for the crash kernel (as "
"for B<KEXEC_ON_CRASH>).  This kernel is booted if the currently running "
"kernel crashes."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:226
#, no-wrap
msgid "B<KEXEC_FILE_NO_INITRAMFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:233
msgid ""
"Loading initrd/initramfs is optional.  Specify this flag if no initramfs is "
"being loaded.  If this flag is set, the value passed in I<initrd_fd> is "
"ignored."
msgstr ""

#.  See also http://lwn.net/Articles/603116/
#. type: Plain text
#: build/C/man2/kexec_load.2:242
msgid ""
"The B<kexec_file_load>()  system call was added to provide support for "
"systems where \"kexec\" loading should be restricted to only kernels that "
"are signed.  This system call is available only if the kernel was configured "
"with B<CONFIG_KEXEC_FILE>."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:247
msgid ""
"On success, these system calls returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:248 build/C/man2/kexec_load.2:260
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#.  See kernel/kexec.::sanity_check_segment_list in the 3.19 kernel source
#. type: Plain text
#: build/C/man2/kexec_load.2:260
msgid ""
"The B<KEXEC_ON_CRASH> flags was specified, but the region specified by the "
"I<mem> and I<memsz> fields of one of the I<segments> entries lies outside "
"the range of memory reserved for the crash kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:269
msgid ""
"The value in a I<mem> or I<memsz> field in one of the I<segments> entries is "
"not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:275
msgid "I<kernel_fd> or I<initrd_fd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:275 build/C/man2/pivot_root.2:103 build/C/man2/ptrace.2:2343 build/C/man2/quotactl.2:707
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:279
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:283
msgid "I<flags> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:292
msgid ""
"The value of a I<bufsz> field in one of the I<segments> entries exceeds the "
"value in the corresponding I<memsz> field."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:298
msgid "I<nr_segments> exceeds B<KEXEC_SEGMENT_MAX> (16)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:301
msgid "Two or more of the kernel target buffers overlap."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:306
msgid "The value in I<cmdline[cmdline_len-1]> is not \\(aq\\e0\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:313
msgid "The file referred to by I<kernel_fd> or I<initrd_fd> is empty (length zero)."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:313
#, no-wrap
msgid "B<ENOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:320
msgid ""
"I<kernel_fd> does not refer to an open file, or the kernel can't load this "
"file.  Currently, the file must be a bzImage and contain an x86 kernel that "
"is loadable above 4\\ GiB in memory (see the kernel source file "
"I<Documentation/x86/boot.txt>)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:323
msgid "Could not allocate memory."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:328
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:335
msgid ""
"The B<kexec_load>()  system call first appeared in Linux 2.6.13.  The "
"B<kexec_file_load>()  system call first appeared in Linux 3.17."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:337
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:341
msgid ""
"Currently, there is no glibc support for these system calls.  Call them "
"using B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:345
msgid "B<reboot>(2), B<syscall>(2), B<kexec>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:350
msgid ""
"The kernel source files I<Documentation/kdump/kdump.txt> and "
"I<Documentation/admin-guide/kernel-parameters.txt>"
msgstr ""

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t "
">I<len>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:58
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:70 build/C/man2/quotactl.2:763
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:73
msgid "The buffer was not large enough to hold the path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:87
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the B<oprofile>(1)  profiler.  It relies on a kernel driver to register "
"cookies for directory entries."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:90
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:92
msgid "B<oprofile>(1)"
msgstr ""

#. type: TH
#: build/C/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr ""

#. type: TH
#: build/C/man2/modify_ldt.2:25
#, no-wrap
msgid "2020-02-09"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:28
msgid "modify_ldt - get or set a per-process LDT entry"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:33
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:45
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (LDT) for a "
"process.  The LDT is an array of segment descriptors that can be referenced "
"by user code.  Linux allows processes to configure a per-process (actually "
"per-mm) LDT.  For more information about the LDT, see the Intel Software "
"Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:59
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the LDT into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the LDT, although the kernel may act as though the LDT is "
"padded with additional trailing zero bytes.  On success, B<modify_ldt>()  "
"will return the number of bytes read."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:73
msgid ""
"When I<func> is 1 or 0x11, B<modify_ldt>()  modifies the LDT entry indicated "
"by I<ptr-E<gt>entry_number>.  I<ptr> points to a I<user_desc> structure and "
"I<bytecount> must equal the size of this structure."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:77
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:91
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned int  base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:96
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:104
msgid ""
"The I<contents> field is the segment type (data, expand-down data, "
"non-conforming code, or conforming code).  The other fields match their "
"descriptions in the CPU manual, although B<modify_ldt>()  cannot set the "
"hardware-defined \"accessed\" bit described in the CPU manual."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:121
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  An LDT "
"entry can be cleared by setting it to an \"empty\" I<user_desc> or, if "
"I<func> is 1, by setting both I<base> and I<limit> to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:130
msgid ""
"A conforming code segment (i.e., one with I<contents==3>)  will be rejected "
"if I<func> is 1 or if I<seg_not_present> is 0."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:137
msgid ""
"When I<func> is 2, B<modify_ldt>()  will read zeros.  This appears to be a "
"leftover from Linux 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:147
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:152
msgid "I<ptr> points outside the address space."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:165
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<user_desc>, or I<func> is 1 or 0x11 and the new LDT entry "
"has invalid values."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:169
msgid "I<func> is neither 0, 1, 2, nor 0x11."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:172
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:185
msgid ""
"B<modify_ldt>()  should not be used for thread-local storage, as it slows "
"down context switches and only supports a limited number of threads.  "
"Threading libraries should use B<set_thread_area>(2)  or B<arch_prctl>(2)  "
"instead, except on extremely old kernels that do not support those system "
"calls."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:190
msgid ""
"The normal use for B<modify_ldt>()  is to run legacy 16-bit or segmented "
"32-bit code.  Not all kernels allow 16-bit segments to be installed, "
"however."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:198
msgid ""
"Even on 64-bit kernels, B<modify_ldt>()  cannot be used to create a long "
"mode (i.e., 64-bit) code segment.  The undocumented field \"lm\" in "
"I<user_desc> is not useful, and, despite its name, does not result in a long "
"mode segment."
msgstr ""

#. type: SH
#: build/C/man2/modify_ldt.2:198 build/C/man2/perf_event_open.2:3668 build/C/man2/ptrace.2:2772 build/C/man2/userfaultfd.2:476
#, no-wrap
msgid "BUGS"
msgstr ""

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: build/C/man2/modify_ldt.2:207
msgid ""
"On 64-bit kernels before Linux 3.19, setting the \"lm\" bit in I<user_desc> "
"prevents the descriptor from being considered empty.  Keep in mind that the "
"\"lm\" bit does not exist in the 32-bit headers, but these buggy kernels "
"will still notice the bit even when set in a 32-bit process."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:211
msgid "B<arch_prctl>(2), B<set_thread_area>(2), B<vm86>(2)"
msgstr ""

#. type: TH
#: build/C/man2/nfsservctl.2:5
#, no-wrap
msgid "NFSSERVCTL"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:8
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:11
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:14
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:22
msgid ""
"I<Note>: Since Linux 3.1, this system call no longer exists.  It has been "
"replaced by a set of files in the I<nfsd> filesystem; see B<nfsd>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:37
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC        0  /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT  1  /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT  2  /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT     3  /* Export a filesystem. */\n"
"#define NFSCTL_UNEXPORT   4  /* Unexport a filesystem. */\n"
"#define NFSCTL_UGIDUPDATE 5  /* Update a client\\(aqs UID/GID map\n"
"                                (only in Linux 2.4.x and earlier). */\n"
"#define NFSCTL_GETFH      6  /* Get a file handle (used by mountd)\n"
"                                (only in Linux 2.4.x and earlier). */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:49
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:54
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:61 build/C/man2/pivot_root.2:98 build/C/man2/vm86.2:59
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:64
msgid ""
"This system call was removed from the Linux kernel in version 3.1.  Library "
"support was removed from glibc in version 2.28."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:66
msgid "This call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:68
msgid "B<nfsd>(7)"
msgstr ""

#. type: TH
#: build/C/man2/outb.2:26
#, no-wrap
msgid "OUTB"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:31
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:34
#, no-wrap
msgid "B<#include E<lt>sys/io.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:41
#, no-wrap
msgid ""
"B<unsigned char inb(unsigned short >I<port>B<);>\n"
"B<unsigned char inb_p(unsigned short >I<port>B<);>\n"
"B<unsigned short inw(unsigned short >I<port>B<);>\n"
"B<unsigned short inw_p(unsigned short >I<port>B<);>\n"
"B<unsigned int inl(unsigned short >I<port>B<);>\n"
"B<unsigned int inl_p(unsigned short >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:48
#, no-wrap
msgid ""
"B<void outb(unsigned char >I<value>B<, unsigned short >I<port>B<);>\n"
"B<void outb_p(unsigned char >I<value>B<, unsigned short >I<port>B<);>\n"
"B<void outw(unsigned short >I<value>B<, unsigned short >I<port>B<);>\n"
"B<void outw_p(unsigned short >I<value>B<, unsigned short >I<port>B<);>\n"
"B<void outl(unsigned int >I<value>B<, unsigned short >I<port>B<);>\n"
"B<void outl_p(unsigned int >I<value>B<, unsigned short >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:61
#, no-wrap
msgid ""
"B<void insb(unsigned short >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
"B<void insw(unsigned short >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
"B<void insl(unsigned short >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
"B<void outsb(unsigned short >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
"B<void outsw(unsigned short >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
"B<void outsl(unsigned short >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:67
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the "
"_p-suffix functions pause until the I/O completes."
msgstr ""

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: build/C/man2/outb.2:73
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:78
msgid ""
"You must compile with B<-O> or B<-O2> or similar.  The functions are defined "
"as inline macros, and will not be substituted in without optimization "
"enabled, causing unresolved references at link time."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:87
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:96
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:99
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "2016-07-17"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:26
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"user space."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:26 build/C/man2/pciconfig_read.2:50
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:35
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:35 build/C/man2/pciconfig_read.2:56
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:44
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:44 build/C/man2/pciconfig_read.2:62
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:49
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:56 build/C/man2/pciconfig_read.2:62
msgid ""
"On success, zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:76
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:83
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:86
msgid "I/O error."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:92
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:97
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:97 build/C/man2/perf_event_open.2:3595
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:104
msgid ""
"This return value is valid only for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:111
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:113
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:115
msgid "B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor, "
"for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2).  When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In "
"general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then "
"be accessed via B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:82
msgid ""
"The I<pid> and I<cpu> arguments allow specifying which process and CPU to "
"monitor:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:82
#, no-wrap
msgid "B<pid == 0> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:85
msgid "This measures the calling process/thread on any CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:85
#, no-wrap
msgid "B<pid == 0> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:89
msgid ""
"This measures the calling process/thread only when running on the specified "
"CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:89
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:92
msgid "This measures the specified process/thread on any CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:92
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:96
msgid ""
"This measures the specified process/thread only when running on the "
"specified CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:96
#, no-wrap
msgid "B<pid == -1> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:106
msgid ""
"This measures all processes/threads on the specified CPU.  This requires "
"B<CAP_PERFMON> (since Linux 5.8) or B<CAP_SYS_ADMIN> capability or a "
"I</proc/sys/kernel/perf_event_paranoid> value of less than 1."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:106
#, no-wrap
msgid "B<pid == -1> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:109
msgid "This setting is invalid and will return an error."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:119
msgid ""
"When I<pid> is greater than zero, permission to perform this system call is "
"governed by B<CAP_PERFMON> (since Linux 5.9) and a ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> check on older Linux versions; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:141
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent "
"B<perf_event_open>()  calls with I<group_fd> being set to the file "
"descriptor of the group leader.  (A single event on its own is created with "
"I<group_fd> = -1 and is considered to be a group with only 1 member.)  An "
"event group is scheduled onto the CPU as a unit: it will be put onto the CPU "
"only if all of the events in the group can be put onto the CPU.  This means "
"that the values of the member events can be meaningfully compared\\(emadded, "
"divided (to get ratios), and so on\\(emwith each other, since they have "
"counted events for the same set of executed instructions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:145
msgid ""
"The I<flags> argument is formed by ORing together zero or more of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:145
#, no-wrap
msgid "B<PERF_FLAG_FD_CLOEXEC> (since Linux 3.14)"
msgstr ""

#.  commit a21b0b354d4ac39be691f51c53562e2c24443d9e
#. type: Plain text
#: build/C/man2/perf_event_open.2:162
msgid ""
"This flag enables the close-on-exec flag for the created event file "
"descriptor, so that the file descriptor is automatically closed on "
"B<execve>(2).  Setting the close-on-exec flags at creation time, rather than "
"later with B<fcntl>(2), avoids potential race conditions where the calling "
"thread invokes B<perf_event_open>()  and B<fcntl>(2)  at the same time as "
"another thread calls B<fork>(2)  then B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:162
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:170
msgid ""
"This flag tells the event to ignore the I<group_fd> parameter except for the "
"purpose of setting up output redirection using the B<PERF_FLAG_FD_OUTPUT> "
"flag."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:170
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT> (broken since Linux 2.6.35)"
msgstr ""

#.  commit ac9721f3f54b27a16c7e1afb2481e7ee95a70318
#. type: Plain text
#: build/C/man2/perf_event_open.2:176
msgid ""
"This flag re-routes the event's sampled output to instead be included in the "
"mmap buffer of the event specified by I<group_fd>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:176
#, no-wrap
msgid "B<PERF_FLAG_PID_CGROUP> (since Linux 2.6.39)"
msgstr ""

#.  commit e5d1367f17ba6a6fed5fd8b74e4d5720923e0c25
#. type: Plain text
#: build/C/man2/perf_event_open.2:200
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an "
"abstraction that isolates a set of resources for finer-grained control "
"(CPUs, memory, etc.).  In this mode, the event is measured only if the "
"thread running on the monitored CPU belongs to the designated container "
"(cgroup).  The cgroup is identified by passing a file descriptor opened on "
"its directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on "
"I</dev/cgroup/test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must "
"be passed as the I<pid> parameter.  cgroup monitoring is available only for "
"system-wide events and may therefore require extra permissions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:205
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information "
"for the event being created."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:212
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32 type;                 /* Type of event */\n"
"    __u32 size;                 /* Size of attribute structure */\n"
"    __u64 config;               /* Type-specific configuration */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:217
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:220
#, no-wrap
msgid ""
"    __u64 sample_type;  /* Specifies values included in sample */\n"
"    __u64 read_format;  /* Specifies values returned in read */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:259
#, no-wrap
msgid ""
"    __u64 disabled       : 1,   /* off by default */\n"
"          inherit        : 1,   /* children inherit it */\n"
"          pinned         : 1,   /* must always be on PMU */\n"
"          exclusive      : 1,   /* only group on PMU */\n"
"          exclude_user   : 1,   /* don\\(aqt count user */\n"
"          exclude_kernel : 1,   /* don\\(aqt count kernel */\n"
"          exclude_hv     : 1,   /* don\\(aqt count hypervisor */\n"
"          exclude_idle   : 1,   /* don\\(aqt count when idle */\n"
"          mmap           : 1,   /* include mmap data */\n"
"          comm           : 1,   /* include comm data */\n"
"          freq           : 1,   /* use freq, not period */\n"
"          inherit_stat   : 1,   /* per task counts */\n"
"          enable_on_exec : 1,   /* next exec enables */\n"
"          task           : 1,   /* trace fork/exit */\n"
"          watermark      : 1,   /* wakeup_watermark */\n"
"          precise_ip     : 2,   /* skid constraint */\n"
"          mmap_data      : 1,   /* non-exec mmap data */\n"
"          sample_id_all  : 1,   /* sample_type all events */\n"
"          exclude_host   : 1,   /* don\\(aqt count in host */\n"
"          exclude_guest  : 1,   /* don\\(aqt count in guest */\n"
"          exclude_callchain_kernel : 1,\n"
"                                /* exclude kernel callchains */\n"
"          exclude_callchain_user   : 1,\n"
"                                /* exclude user callchains */\n"
"          mmap2          :  1,  /* include mmap with inode data */\n"
"          comm_exec      :  1,  /* flag comm events that are\n"
"                                   due to exec */\n"
"          use_clockid    :  1,  /* use clockid for time fields */\n"
"          context_switch :  1,  /* context switch data */\n"
"          write_backward :  1,  /* Write ring buffer from end\n"
"                                   to beginning */\n"
"          namespaces     :  1,  /* include namespaces data */\n"
"          ksymbol        :  1,  /* include ksymbol events */\n"
"          bpf_event      :  1,  /* include bpf events */\n"
"          aux_output     :  1,  /* generate AUX records\n"
"                                   instead of events */\n"
"          cgroup         :  1,  /* include cgroup events */\n"
"          text_poke      :  1,  /* include text poke events */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:261
#, no-wrap
msgid "          __reserved_1   : 30;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:266
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:268
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:275
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 kprobe_func;      /* for perf_kprobe */\n"
"        __u64 uprobe_path;      /* for perf_uprobe */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:291
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 kprobe_addr;      /* with kprobe_func == NULL */\n"
"        __u64 probe_offset;     /* for perf_[k,u]probe */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64 branch_sample_type;   /* enum perf_branch_sample_type */\n"
"    __u64 sample_regs_user;     /* user regs to dump on samples */\n"
"    __u32 sample_stack_user;    /* size of stack to dump on\n"
"                                   samples */\n"
"    __s32 clockid;              /* clock to use for time fields */\n"
"    __u64 sample_regs_intr;     /* regs to dump on samples */\n"
"    __u32 aux_watermark;        /* aux bytes before wakeup */\n"
"    __u16 sample_max_stack;     /* max frames in callchain */\n"
"    __u16 __reserved_2;         /* align to u64 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:293
#, no-wrap
msgid "};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:299
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:299 build/C/man2/perf_event_open.2:2024 build/C/man2/perf_event_open.2:2976
#, no-wrap
msgid "I<type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:303
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:304
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:311
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:311
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:315
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:315
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:319
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint "
"infrastructure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:319
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:325
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:325
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:329
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:329
#, no-wrap
msgid "B<PERF_TYPE_BREAKPOINT> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: build/C/man2/perf_event_open.2:335
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:335
#, no-wrap
msgid "dynamic PMU"
msgstr ""

#.  commit 2e80a82a49c4c7eca4e35734380f28298ba5db19
#. type: Plain text
#: build/C/man2/perf_event_open.2:355
msgid ""
"Since Linux 2.6.38, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field "
"to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under "
"I</sys/bus/event_source/devices>.  In each subdirectory there is a I<type> "
"file whose content is an integer that can be used in the I<type> field.  For "
"instance, I</sys/bus/event_source/devices/cpu/type> contains the value for "
"the core CPU PMU, which is usually 4."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:355
#, no-wrap
msgid "B<kprobe> and B<uprobe> (since Linux 4.17)"
msgstr ""

#.  commit 65074d43fc77bcae32776724b7fa2696923c78e4
#.  commit e12f03d7031a977356e3d7b75a68c2185ff8d155
#.  commit 33ea4b24277b06dbc55d7f5772a46f029600255e
#. type: Plain text
#: build/C/man2/perf_event_open.2:370
msgid ""
"These two dynamic PMUs create a kprobe/uprobe and attach it to the file "
"descriptor generated by perf_event_open.  The kprobe/uprobe will be "
"destroyed on the destruction of the file descriptor.  See fields "
"I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset> for more "
"details."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:371 build/C/man2/perf_event_open.2:1936
#, no-wrap
msgid "I<size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:380
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""

#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  this was added much later when PERF_ATTR_SIZE_VER2 happened
#.  but the actual attr_size had increased in 2.6.33
#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  commit 1659d129ed014b715b0b2120e6fd929bdd33ed03
#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: build/C/man2/perf_event_open.2:410
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of "
"the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to "
"the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATTR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7.  "
"B<PERF_ATTR_SIZE_VER4> is 104 corresponding to the addition of "
"I<sample_regs_intr> in Linux 3.19.  B<PERF_ATTR_SIZE_VER5> is 112 "
"corresponding to the addition of I<aux_watermark> in Linux 4.1."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:410
#, no-wrap
msgid "I<config>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:423
msgid ""
"This specifies which event you want, in conjunction with the I<type> field.  "
"The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:434
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:444
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized "
"hardware CPU events.  Not all of these are available on all platforms.  Set "
"I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:445
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:449
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:449
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:454
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:454
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:461
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:461
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:468
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:468
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr ""

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: build/C/man2/perf_event_open.2:474
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.35, this used the wrong "
"event on AMD processors."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:474
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:477
msgid "Mispredicted branch instructions."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:477
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:480
msgid "Bus cycles, which can be different from total cycles."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:480
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (since Linux 3.0)"
msgstr ""

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: build/C/man2/perf_event_open.2:484
msgid "Stalled cycles during issue."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:484
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (since Linux 3.0)"
msgstr ""

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: build/C/man2/perf_event_open.2:488
msgid "Stalled cycles during retirement."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:488
#, no-wrap
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (since Linux 3.3)"
msgstr ""

#.  commit c37e17497e01fc0f5d2d6feb5723b210b3ab8890
#. type: Plain text
#: build/C/man2/perf_event_open.2:492
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:502
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:503
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:506
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:506
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:509
msgid "This reports a clock count specific to the task that is running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:509
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:512
msgid "This reports the number of page faults."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:512
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr ""

#.  commit e49a5bd38159dfb1928fd25b173bc9de4bbadb21
#. type: Plain text
#: build/C/man2/perf_event_open.2:518
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:518
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:522
msgid "This reports the number of times the process has migrated to a new CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:522
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:526
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O "
"to handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:526
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:530
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:530
#, no-wrap
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (since Linux 2.6.33)"
msgstr ""

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: build/C/man2/perf_event_open.2:537
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This happens only on some architectures (never on x86)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:537
#, no-wrap
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (since Linux 2.6.33)"
msgstr ""

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: build/C/man2/perf_event_open.2:544
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:544
#, no-wrap
msgid "B<PERF_COUNT_SW_DUMMY> (since Linux 3.12)"
msgstr ""

#.  commit fa0097ee690693006ab1aea6c01ad3c851b65c77
#. type: Plain text
#: build/C/man2/perf_event_open.2:552
msgid ""
"This is a placeholder event that counts nothing.  Informational sample "
"record types such as mmap or comm must be associated with an active event.  "
"This dummy event allows gathering such records without requiring a counting "
"event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:565
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:576
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value, use the "
"following equation:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:583
#, no-wrap
msgid ""
"config = (perf_hw_cache_id) |\n"
"         (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"         (perf_hw_cache_op_result_id E<lt>E<lt> 16);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:589
msgid "where I<perf_hw_cache_id> is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:590
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:593
msgid "for measuring Level 1 Data Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:593
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:596
msgid "for measuring Level 1 Instruction Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:596
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:599
msgid "for measuring Last-Level Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:599
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:602
msgid "for measuring the Data TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:602
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:605
msgid "for measuring the Instruction TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:605
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:608
msgid "for measuring the branch prediction unit"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:608
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_NODE> (since Linux 3.1)"
msgstr ""

#.  commit 89d6c0b5bdbb1927775584dcf532d98b3efe1477
#. type: Plain text
#: build/C/man2/perf_event_open.2:612
msgid "for measuring local memory accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:617
msgid "and I<perf_hw_cache_op_id> is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:618
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:621
msgid "for read accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:621
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:624
msgid "for write accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:624
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:627
msgid "for prefetch accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:632
msgid "and I<perf_hw_cache_op_result_id> is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:633
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:636
msgid "to measure accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:636
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:639
msgid "to measure misses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:657
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the "
"\"generalized\" events.  These are implementation defined; see your CPU "
"manual (for example the Intel Volume 3B documentation or the AMD BIOS and "
"Kernel Developer Guide).  The libpfm4 library can be used to translate from "
"the name in the architectural manuals to the raw hex value "
"B<perf_event_open>()  expects in this field."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:666
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:687
msgid ""
"If I<type> is B<kprobe> or B<uprobe>, set I<retprobe> (bit 0 of I<config>, "
"see I</sys/bus/event_source/devices/[k,u]probe/format/retprobe>)  for "
"kretprobe/uretprobe.  See fields I<kprobe_func>, I<uprobe_path>, "
"I<kprobe_addr>, and I<probe_offset> for more details."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:688
#, no-wrap
msgid "I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:711
msgid ""
"These fields describe the kprobe/uprobe for dynamic PMUs B<kprobe> and "
"B<uprobe>.  For B<kprobe>: use I<kprobe_func> and I<probe_offset>, or use "
"I<kprobe_addr> and leave I<kprobe_func> as NULL.  For B<uprobe>: use "
"I<uprobe_path> and I<probe_offset>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:711
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:723
msgid ""
"A \"sampling\" event is one that generates an overflow notification every N "
"events, where N is given by I<sample_period>.  A sampling event has "
"I<sample_period> E<gt> 0.  When an overflow occurs, requested data is "
"recorded in the mmap buffer.  The I<sample_type> field controls what data is "
"recorded on each overflow."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:733
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period.  "
"In this case, you set the I<freq> flag.  The kernel will adjust the sampling "
"period to try and achieve the desired rate.  The rate of adjustment is a "
"timer tick."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:733
#, no-wrap
msgid "I<sample_type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:745
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:746
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:749
msgid "Records instruction pointer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:749
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:752
msgid "Records the process and thread IDs."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:752
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:755
msgid "Records a timestamp."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:755
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:758
msgid "Records an address, if applicable."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:758
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:761
msgid "Record counter values for all events in a group, not just the group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:761
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:764
msgid "Records the callchain (stack backtrace)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:764
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:767
msgid "Records a unique ID for the opened event's group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:767
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:770
msgid "Records CPU number."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:770
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:773
msgid "Records the current sampling period."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:773
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:781
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one "
"returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:781
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:785
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:785
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_STACK> (since Linux 3.4)"
msgstr ""

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: build/C/man2/perf_event_open.2:791
msgid ""
"This provides a record of recent branches, as provided by CPU branch "
"sampling hardware (such as Intel Last Branch Record).  Not all hardware "
"supports this feature."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:795
msgid ""
"See the I<branch_sample_type> field for how to filter which branches are "
"reported."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:795
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_USER> (since Linux 3.7)"
msgstr ""

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: build/C/man2/perf_event_open.2:800
msgid ""
"Records the current user-level CPU register state (the values in the process "
"before the kernel was called)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:800
#, no-wrap
msgid "B<PERF_SAMPLE_STACK_USER> (since Linux 3.7)"
msgstr ""

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: build/C/man2/perf_event_open.2:804
msgid "Records the user level stack, allowing stack unwinding."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:804
#, no-wrap
msgid "B<PERF_SAMPLE_WEIGHT> (since Linux 3.10)"
msgstr ""

#.  commit c3feedf2aaf9ac8bad6f19f5d21e4ee0b4b87e9c
#. type: Plain text
#: build/C/man2/perf_event_open.2:811
msgid ""
"Records a hardware provided weight value that expresses how costly the "
"sampled event was.  This allows the hardware to highlight expensive events "
"in a profile."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:811
#, no-wrap
msgid "B<PERF_SAMPLE_DATA_SRC> (since Linux 3.10)"
msgstr ""

#.  commit d6be9ad6c960f43800a6f118932bc8a5a4eadcd1
#. type: Plain text
#: build/C/man2/perf_event_open.2:818
msgid ""
"Records the data source: where in the memory hierarchy the data associated "
"with the sampled instruction came from.  This is available only if the "
"underlying hardware supports this feature."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:818
#, no-wrap
msgid "B<PERF_SAMPLE_IDENTIFIER> (since Linux 3.12)"
msgstr ""

#.  commit ff3d527cebc1fa3707c617bfe9e74f53fcfb0955
#. type: Plain text
#: build/C/man2/perf_event_open.2:826
msgid ""
"Places the B<SAMPLE_ID> value in a fixed position in the record, either at "
"the beginning (for sample events) or at the end (if a non-sample event)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:838
msgid ""
"This was necessary because a sample stream may have records from various "
"different event sources with different I<sample_type> settings.  Parsing the "
"event stream properly was not possible because the format of the record was "
"needed to find B<SAMPLE_ID>, but the format could not be found without "
"knowing what event the sample belonged to (causing a circular dependency)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:848
msgid ""
"The B<PERF_SAMPLE_IDENTIFIER> setting makes the event stream always parsable "
"by putting B<SAMPLE_ID> in a fixed location, even though it means having "
"duplicate B<SAMPLE_ID> values in records."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:848
#, no-wrap
msgid "B<PERF_SAMPLE_TRANSACTION> (since Linux 3.13)"
msgstr ""

#.  commit fdfbbd07e91f8fe387140776f3fd94605f0c89e5
#. type: Plain text
#: build/C/man2/perf_event_open.2:853
msgid ""
"Records reasons for transactional memory abort events (for example, from "
"Intel TSX transactional memory support)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:861
msgid ""
"The I<precise_ip> setting must be greater than 0 and a transactional memory "
"abort event must be measured or no values will be recorded.  Also note that "
"some perf_event measurements, such as sampled cycle counting, may cause "
"extraneous aborts (by causing an interrupt during a transaction)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:861
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_INTR> (since Linux 3.19)"
msgstr ""

#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#. type: Plain text
#: build/C/man2/perf_event_open.2:879
msgid ""
"Records a subset of the current CPU register state as specified by "
"I<sample_regs_intr>.  Unlike B<PERF_SAMPLE_REGS_USER> the register values "
"will return kernel register state if the overflow happened while kernel code "
"is running.  If the CPU supports hardware sampling of register state (i.e., "
"PEBS on Intel x86) and I<precise_ip> is set higher than zero then the "
"register values returned are those captured by hardware at the time of the "
"sampled instruction's retirement."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:879
#, no-wrap
msgid "B<PERF_SAMPLE_PHYS_ADDR> (since Linux 4.13)"
msgstr ""

#.  commit fc7ce9c74c3ad232b084d80148654f926d01ece7
#. type: Plain text
#: build/C/man2/perf_event_open.2:884
msgid "Records physical address of data like in B<PERF_SAMPLE_ADDR>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:884
#, no-wrap
msgid "B<PERF_SAMPLE_CGROUP> (since Linux 5.7)"
msgstr ""

#.  commit 96aaab686505c449e24d76e76507290dcc30e008
#. type: Plain text
#: build/C/man2/perf_event_open.2:893
msgid ""
"Records (perf_event) cgroup ID of the process.  This corresponds to the "
"I<id> field in the B<PERF_RECORD_CGROUP> event."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:894
#, no-wrap
msgid "I<read_format>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:901
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:902
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:909
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:909
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:916
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:916
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:919
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:919
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:922
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:923
#, no-wrap
msgid "I<disabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:933
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:944
msgid ""
"When creating an event group, typically the group leader is initialized with "
"I<disabled> set to 1 and any child events are initialized with I<disabled> "
"set to 0.  Despite I<disabled> being 0, the child events will not start "
"until the group leader is enabled."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:944
#, no-wrap
msgid "I<inherit>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:953
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This applies only to new children, not "
"to any existing children at the time the counter is created (nor to any new "
"children of existing children)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:958
msgid ""
"Inherit does not work for some combinations of I<read_format> values, such "
"as B<PERF_FORMAT_GROUP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:958
#, no-wrap
msgid "I<pinned>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:971
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It applies only to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:971
#, no-wrap
msgid "I<exclusive>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:980
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU, "
"it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone "
"so that they do not disrupt other hardware counters."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:987
msgid ""
"Note that many unexpected situations may prevent events with the "
"I<exclusive> bit set from ever running.  This includes any users running a "
"system-wide measurement as well as any kernel use of the performance "
"counters (including the commonly enabled NMI Watchdog Timer interface)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:987
#, no-wrap
msgid "I<exclude_user>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:990
msgid "If this bit is set, the count excludes events that happen in user space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:990
#, no-wrap
msgid "I<exclude_kernel>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:993
msgid "If this bit is set, the count excludes events that happen in kernel space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:993
#, no-wrap
msgid "I<exclude_hv>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1001
msgid ""
"If this bit is set, the count excludes events that happen in the "
"hypervisor.  This is mainly for PMUs that have built-in support for handling "
"this (such as POWER).  Extra support is needed for handling hypervisor "
"measurements on most machines."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1001
#, no-wrap
msgid "I<exclude_idle>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1006
msgid ""
"If set, don't count when the CPU is running the idle task.  While you can "
"currently enable this for any event type, it is ignored for all but software "
"events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1006
#, no-wrap
msgid "I<mmap>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1020
msgid ""
"The I<mmap> bit enables generation of B<PERF_RECORD_MMAP> samples for every "
"B<mmap>(2)  call that has B<PROT_EXEC> set.  This allows tools to notice new "
"executable code being mapped into a program (dynamic shared libraries for "
"example)  so that addresses can be mapped back to the original code."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1020 build/C/man2/perf_event_open.2:2115
#, no-wrap
msgid "I<comm>"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: build/C/man2/perf_event_open.2:1039
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"B<exec>(2)  and B<prctl>(PR_SET_NAME)  system calls as well as writing to "
"I</proc/self/comm>.  If the I<comm_exec> flag is also successfully set "
"(possible since Linux 3.16), then the misc flag "
"B<PERF_RECORD_MISC_COMM_EXEC> can be used to differentiate the B<exec>(2)  "
"case from the others."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1039
#, no-wrap
msgid "I<freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1046
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1046
#, no-wrap
msgid "I<inherit_stat>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1053
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is meaningful only if the I<inherit> field is set."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1053
#, no-wrap
msgid "I<enable_on_exec>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1058
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1058
#, no-wrap
msgid "I<task>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1062
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1062
#, no-wrap
msgid "I<watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1070
msgid ""
"If set, have an overflow notification happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise, overflow notifications happen "
"after I<wakeup_events> samples."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1070
#, no-wrap
msgid "I<precise_ip> (since Linux 2.6.35)"
msgstr ""

#.  commit ab608344bcbde4f55ec4cd911b686b0ce3eae076
#. type: Plain text
#: build/C/man2/perf_event_open.2:1081
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and "
"record the event.  Smaller skid is better and allows more accurate reporting "
"of which events correspond to which instructions, but hardware is often "
"limited with how small this can be."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1083
msgid "The possible values of this field are the following:"
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:1084 build/C/man2/perf_event_open.2:3352
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1087
msgid "B<SAMPLE_IP> can have arbitrary skid."
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:1087 build/C/man2/perf_event_open.2:3350
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1090
msgid "B<SAMPLE_IP> must have constant skid."
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:1090 build/C/man2/perf_event_open.2:3347
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1093
msgid "B<SAMPLE_IP> requested to have 0 skid."
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:1093
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1098
msgid ""
"B<SAMPLE_IP> must have 0 skid.  See also the description of "
"B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1099
#, no-wrap
msgid "I<mmap_data> (since Linux 2.6.36)"
msgstr ""

#.  commit 3af9e859281bda7eb7c20b51879cf43aa788ac2e
#. type: Plain text
#: build/C/man2/perf_event_open.2:1112
msgid ""
"This is the counterpart of the I<mmap> field.  This enables generation of "
"B<PERF_RECORD_MMAP> samples for B<mmap>(2)  calls that do not have "
"B<PROT_EXEC> set (for example data and SysV shared memory)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1112
#, no-wrap
msgid "I<sample_id_all> (since Linux 2.6.38)"
msgstr ""

#.  commit c980d1091810df13f21aabbce545fd98f545bbf7
#. type: Plain text
#: build/C/man2/perf_event_open.2:1121
msgid ""
"If set, then TID, TIME, ID, STREAM_ID, and CPU can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1129
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is specified, then an additional ID value is "
"included as the last value to ease parsing the record stream.  This may lead "
"to the I<id> value appearing twice."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1131
msgid "The layout is described by this pseudo-structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1142
#, no-wrap
msgid ""
"struct sample_id {\n"
"    { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */\n"
"    { u64 time;     }   /* if PERF_SAMPLE_TIME set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_ID set */\n"
"    { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */\n"
"    { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1144
#, no-wrap
msgid "I<exclude_host> (since Linux 3.2)"
msgstr ""

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: build/C/man2/perf_event_open.2:1155
msgid ""
"When conducting measurements that include processes running VM instances "
"(i.e., have executed a B<KVM_RUN> B<ioctl>(2)), only measure events "
"happening inside a guest instance.  This is only meaningful outside the "
"guests; this setting does not change counts gathered inside of a guest.  "
"Currently, this functionality is x86 only."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1155
#, no-wrap
msgid "I<exclude_guest> (since Linux 3.2)"
msgstr ""

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: build/C/man2/perf_event_open.2:1166
msgid ""
"When conducting measurements that include processes running VM instances "
"(i.e., have executed a B<KVM_RUN> B<ioctl>(2)), do not measure events "
"happening inside guest instances.  This is only meaningful outside the "
"guests; this setting does not change counts gathered inside of a guest.  "
"Currently, this functionality is x86 only."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1166
#, no-wrap
msgid "I<exclude_callchain_kernel> (since Linux 3.7)"
msgstr ""

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: build/C/man2/perf_event_open.2:1170
msgid "Do not include kernel callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1170
#, no-wrap
msgid "I<exclude_callchain_user> (since Linux 3.7)"
msgstr ""

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: build/C/man2/perf_event_open.2:1174
msgid "Do not include user callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1174
#, no-wrap
msgid "I<mmap2> (since Linux 3.16)"
msgstr ""

#.  commit 13d7a2410fa637f450a29ecb515ac318ee40c741
#.  This is tricky; was committed during 3.12 development
#.  but right before release was disabled.
#.  So while you could select mmap2 starting with 3.12
#.  it did not work until 3.16
#.  commit a5a5ba72843dd05f991184d6cb9a4471acce1005
#. type: Plain text
#: build/C/man2/perf_event_open.2:1187
msgid ""
"Generate an extended executable mmap record that contains enough additional "
"information to uniquely identify shared mappings.  The I<mmap> flag must "
"also be set for this to work."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1187
#, no-wrap
msgid "I<comm_exec> (since Linux 3.16)"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: build/C/man2/perf_event_open.2:1203
msgid ""
"This is purely a feature-detection flag, it does not change kernel "
"behavior.  If this flag can successfully be set, then, when I<comm> is "
"enabled, the B<PERF_RECORD_MISC_COMM_EXEC> flag will be set in the I<misc> "
"field of a comm record header if the rename event being reported was caused "
"by a call to B<exec>(2).  This allows tools to distinguish between the "
"various types of process renaming."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1203
#, no-wrap
msgid "I<use_clockid> (since Linux 4.1)"
msgstr ""

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: build/C/man2/perf_event_open.2:1212
msgid ""
"This allows selecting which internal Linux clock to use when generating "
"timestamps via the I<clockid> field.  This can make it easier to correlate "
"perf sample times with timestamps generated by other tools."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1212
#, no-wrap
msgid "I<context_switch> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: build/C/man2/perf_event_open.2:1227
msgid ""
"This enables the generation of B<PERF_RECORD_SWITCH> records when a context "
"switch occurs.  It also enables the generation of "
"B<PERF_RECORD_SWITCH_CPU_WIDE> records when sampling in CPU-wide mode.  This "
"functionality is in addition to existing tracepoint and software events for "
"measuring context switches.  The advantage of this method is that it will "
"give full information even with strict I<perf_event_paranoid> settings."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1227
#, no-wrap
msgid "I<write_backward> (since Linux 4.6)"
msgstr ""

#.  commit 9ecda41acb971ebd07c8fb35faf24005c0baea12
#. type: Plain text
#: build/C/man2/perf_event_open.2:1232
msgid ""
"This causes the ring buffer to be written from the end to the beginning.  "
"This is to support reading from overwritable ring buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1232
#, no-wrap
msgid "I<namespaces> (since Linux 4.11)"
msgstr ""

#.  commit e422267322cd319e2695a535e47c5b1feeac45eb
#. type: Plain text
#: build/C/man2/perf_event_open.2:1239
msgid ""
"This enables the generation of B<PERF_RECORD_NAMESPACES> records when a task "
"enters a new namespace.  Each namespace has a combination of device and "
"inode numbers."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1239
#, no-wrap
msgid "I<ksymbol> (since Linux 5.0)"
msgstr ""

#.  commit 76193a94522f1d4edf2447a536f3f796ce56343b
#. type: Plain text
#: build/C/man2/perf_event_open.2:1246
msgid ""
"This enables the generation of B<PERF_RECORD_KSYMBOL> records when new "
"kernel symbols are registered or unregistered.  This is analyzing dynamic "
"kernel functions like eBPF."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1246
#, no-wrap
msgid "I<bpf_event> (since Linux 5.0)"
msgstr ""

#.  commit 6ee52e2a3fe4ea35520720736e6791df1fb67106
#. type: Plain text
#: build/C/man2/perf_event_open.2:1252
msgid ""
"This enables the generation of B<PERF_RECORD_BPF_EVENT> records when an eBPF "
"program is loaded or unloaded."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1252
#, no-wrap
msgid "I<auxevent> (since Linux 5.4)"
msgstr ""

#.  commit ab43762ef010967e4ccd53627f70a2eecbeafefb
#. type: Plain text
#: build/C/man2/perf_event_open.2:1257
msgid ""
"This allows normal (non-AUX) events to generate data for AUX events if the "
"hardware supports it."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1257
#, no-wrap
msgid "I<cgroup> (since Linux 5.7)"
msgstr ""

#.  commit 96aaab686505c449e24d76e76507290dcc30e008
#. type: Plain text
#: build/C/man2/perf_event_open.2:1263
msgid ""
"This enables the generation of B<PERF_RECORD_CGROUP> records when a new "
"cgroup is created (and activated)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1263
#, no-wrap
msgid "I<text_poke> (since Linux 5.8)"
msgstr ""

#.  commit e17d43b93e544f5016c0251d2074c15568d5d963
#. type: Plain text
#: build/C/man2/perf_event_open.2:1270
msgid ""
"This enables the generation of B<PERF_RECORD_TEXT_POKE> records when there's "
"a changes to the kernel text (i.e., self-modifying code)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1270
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1280
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow notification happens.  "
"Which one is used is selected by the I<watermark> bit flag."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1290
msgid ""
"I<wakeup_events> counts only B<PERF_RECORD_SAMPLE> record types.  To receive "
"overflow notification for all B<PERF_RECORD> types choose watermark and set "
"I<wakeup_watermark> to 1."
msgstr ""

#.  commit f506b3dc0ec454a16d40cab9ee5d75435b39dc50
#. type: Plain text
#: build/C/man2/perf_event_open.2:1296
msgid ""
"Prior to Linux 3.0, setting I<wakeup_events> to 0 resulted in no overflow "
"notifications; more recent kernels treat 0 the same as 1."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1296
#, no-wrap
msgid "I<bp_type> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: build/C/man2/perf_event_open.2:1301
msgid "This chooses the breakpoint type.  It is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1302
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1305
msgid "No breakpoint."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1305
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1308
msgid "Count when we read the memory location."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1308
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1311
msgid "Count when we write the memory location."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1311
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1314
msgid "Count when we read or write the memory location."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1314
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1317
msgid "Count when we execute code at the memory location."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1326
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1327
#, no-wrap
msgid "I<bp_addr> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: build/C/man2/perf_event_open.2:1334
msgid ""
"This is the address of the breakpoint.  For execution breakpoints, this is "
"the memory address of the instruction of interest; for read and write "
"breakpoints, it is the memory address of the memory location of interest."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1334
#, no-wrap
msgid "I<config1> (since Linux 2.6.39)"
msgstr ""

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: build/C/man2/perf_event_open.2:1342
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and later kernels."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1342
#, no-wrap
msgid "I<bp_len> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: build/C/man2/perf_event_open.2:1358
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, and B<HW_BREAKPOINT_LEN_8>.  "
"For an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1358
#, no-wrap
msgid "I<config2> (since Linux 2.6.39)"
msgstr ""

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: build/C/man2/perf_event_open.2:1365
msgid "I<config2> is a further extension of the I<config1> field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1365
#, no-wrap
msgid "I<branch_sample_type> (since Linux 3.4)"
msgstr ""

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: build/C/man2/perf_event_open.2:1372
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then this specifies what branches "
"to include in the branch record."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1378
msgid ""
"The first part of the value is the privilege level, which is a combination "
"of one of the values listed below.  If the user does not set privilege level "
"explicitly, the kernel will use the event's privilege level.  Event and "
"branch privilege levels do not have to match."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1379
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1382
msgid "Branch target is in user space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1382
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1385
msgid "Branch target is in kernel space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1385
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1388
msgid "Branch target is in hypervisor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1388
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1391
msgid "A convenience value that is the three preceding values ORed together."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1394
msgid ""
"In addition to the privilege value, at least one or more of the following "
"bits must be set."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1394
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1397
msgid "Any branch type."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1397
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1400
msgid "Any call branch (includes direct calls, indirect calls, and far jumps)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1400
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1403
msgid "Indirect calls."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1403
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_CALL> (since Linux 4.4)"
msgstr ""

#.  commit c229bf9dc179d2023e185c0f705bdf68484c1e73
#. type: Plain text
#: build/C/man2/perf_event_open.2:1407
msgid "Direct calls."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1407
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1410
msgid "Any return branch."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1410
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_JUMP> (since Linux 4.2)"
msgstr ""

#.  commit c9fdfa14c3792c0160849c484e83aa57afd80ccc
#. type: Plain text
#: build/C/man2/perf_event_open.2:1414
msgid "Indirect jumps."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1414
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_COND> (since Linux 3.16)"
msgstr ""

#.  commit bac52139f0b7ab31330e98fd87fc5a2664951050
#. type: Plain text
#: build/C/man2/perf_event_open.2:1418
msgid "Conditional branches."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1418
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ABORT_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: build/C/man2/perf_event_open.2:1422
msgid "Transactional memory aborts."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1422
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IN_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: build/C/man2/perf_event_open.2:1426
msgid "Branch in transactional memory transaction."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1426
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_NO_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#.  commit 2c44b1936bb3b135a3fac8b3493394d42e51cf70
#. type: Plain text
#: build/C/man2/perf_event_open.2:1435
msgid ""
"Branch not in transactional memory transaction.  "
"B<PERF_SAMPLE_BRANCH_CALL_STACK> (since Linux 4.1)  Branch is part of a "
"hardware-generated call stack.  This requires hardware support, currently "
"only found on Intel x86 Haswell or newer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1436
#, no-wrap
msgid "I<sample_regs_user> (since Linux 3.7)"
msgstr ""

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: build/C/man2/perf_event_open.2:1443
msgid ""
"This bit mask defines the set of user CPU registers to dump on samples.  The "
"layout of the register mask is architecture-specific and is described in the "
"kernel header file I<arch/ARCH/include/uapi/asm/perf_regs.h>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1443
#, no-wrap
msgid "I<sample_stack_user> (since Linux 3.7)"
msgstr ""

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: build/C/man2/perf_event_open.2:1449
msgid ""
"This defines the size of the user stack to dump if B<PERF_SAMPLE_STACK_USER> "
"is specified."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1449
#, no-wrap
msgid "I<clockid> (since Linux 4.1)"
msgstr ""

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: build/C/man2/perf_event_open.2:1466
msgid ""
"If I<use_clockid> is set, then this field selects which internal Linux timer "
"to use for timestamps.  The available timers are defined in I<linux/time.h>, "
"with B<CLOCK_MONOTONIC>, B<CLOCK_MONOTONIC_RAW>, B<CLOCK_REALTIME>, "
"B<CLOCK_BOOTTIME>, and B<CLOCK_TAI> currently supported."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1466
#, no-wrap
msgid "I<aux_watermark> (since Linux 4.1)"
msgstr ""

#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: build/C/man2/perf_event_open.2:1472
msgid ""
"This specifies how much data is required to trigger a B<PERF_RECORD_AUX> "
"sample."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1472
#, no-wrap
msgid "I<sample_max_stack> (since Linux 4.8)"
msgstr ""

#.  commit 97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: build/C/man2/perf_event_open.2:1481
msgid ""
"When I<sample_type> includes B<PERF_SAMPLE_CALLCHAIN>, this field specifies "
"how many stack frames to report when generating the callchain."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1481
#, no-wrap
msgid "Reading results"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1491
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1496
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the "
"data, the error B<ENOSPC> results."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1498
msgid "Here is the layout of the data returned by a read:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1502
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group "
"at once:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1514
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct {\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1522
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1531
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1535
msgid "The values read are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1535
#, no-wrap
msgid "I<nr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1541
msgid ""
"The number of events in this file descriptor.  Available only if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1541
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1552
msgid ""
"Total time the event was enabled and running.  Normally these values are the "
"same.  Multiplexing happens if the number of events is more than the number "
"of available PMU counter slots.  In that case the events run only part of "
"the time and the I<time_enabled> and I<time running> values can be used to "
"scale an estimated value for the count."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1552
#, no-wrap
msgid "I<value>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1555
msgid "An unsigned 64-bit value containing the counter result."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1555 build/C/man2/perf_event_open.2:2086 build/C/man2/perf_event_open.2:2260 build/C/man2/perf_event_open.2:2987 build/C/man2/perf_event_open.2:3013
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1561
msgid ""
"A globally unique value for this particular event; only present if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1561
#, no-wrap
msgid "MMAP layout"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1571
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a "
"ring-buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1577
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page "
"(I<struct perf_event_mmap_page>)  that contains various bits of information "
"such as where the ring-buffer head is."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1580
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate an mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1582
msgid "The structure of the first metadata mmap page is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1616
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;        /* version number of this structure */\n"
"    __u32 compat_version; /* lowest version this is compat with */\n"
"    __u32 lock;           /* seqlock for synchronization */\n"
"    __u32 index;          /* hardware counter identifier */\n"
"    __s64 offset;         /* add to hardware counter value */\n"
"    __u64 time_enabled;   /* time event active */\n"
"    __u64 time_running;   /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        struct {\n"
"            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,\n"
"                  cap_bit0_is_deprecated : 1,\n"
"                  cap_user_rdpmc         : 1,\n"
"                  cap_user_time          : 1,\n"
"                  cap_user_time_zero     : 1,\n"
"        };\n"
"    };\n"
"    __u16 pmc_width;\n"
"    __u16 time_shift;\n"
"    __u32 time_mult;\n"
"    __u64 time_offset;\n"
"    __u64 __reserved[120];   /* Pad to 1 k */\n"
"    __u64 data_head;         /* head in the data section */\n"
"    __u64 data_tail;         /* user-space written tail */\n"
"    __u64 data_offset;       /* where the buffer starts */\n"
"    __u64 data_size;         /* data buffer size */\n"
"    __u64 aux_head;\n"
"    __u64 aux_tail;\n"
"    __u64 aux_offset;\n"
"    __u64 aux_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1618
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1624
msgid ""
"The following list describes the fields in the I<perf_event_mmap_page> "
"structure in more detail:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1624
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1627
msgid "Version number of this structure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1627
#, no-wrap
msgid "I<compat_version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1630
msgid "The lowest version this is compatible with."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1630
#, no-wrap
msgid "I<lock>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1633
msgid "A seqlock for synchronization."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1633
#, no-wrap
msgid "I<index>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1636
msgid "A unique hardware counter identifier."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1636
#, no-wrap
msgid "I<offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1641
msgid ""
"When using rdpmc for reads this offset value must be added to the one "
"returned by rdpmc to get the current total event count."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1641
#, no-wrap
msgid "I<time_enabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1644
msgid "Time the event was active."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1644
#, no-wrap
msgid "I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1647
msgid "Time the event was running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1647
#, no-wrap
msgid "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (since Linux 3.4)"
msgstr ""

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: build/C/man2/perf_event_open.2:1661
msgid ""
"There was a bug in the definition of I<cap_usr_time> and I<cap_usr_rdpmc> "
"from Linux 3.4 until Linux 3.11.  Both bits were defined to point to the "
"same location, so it was impossible to know if I<cap_usr_time> or "
"I<cap_usr_rdpmc> were actually set."
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:1670
msgid ""
"Starting with Linux 3.12, these are renamed to I<cap_bit0> and you should "
"use the I<cap_user_time> and I<cap_user_rdpmc> fields instead."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1670
#, no-wrap
msgid "I<cap_bit0_is_deprecated> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:1679
msgid ""
"If set, this bit indicates that the kernel supports the properly separated "
"I<cap_user_time> and I<cap_user_rdpmc> bits."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1686
msgid ""
"If not-set, it indicates an older kernel where I<cap_usr_time> and "
"I<cap_usr_rdpmc> map to the same bit and thus both features should be used "
"with caution."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1686
#, no-wrap
msgid "I<cap_user_rdpmc> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:1692
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1698
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1704
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1711
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1714
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1719
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        count += rdpmc(idx - 1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1722
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1724
#, no-wrap
msgid "I<cap_user_time> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:1729
msgid ""
"This bit indicates the hardware has a constant, nonstop timestamp counter "
"(TSC on x86)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1729
#, no-wrap
msgid "I<cap_user_time_zero> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:1736
msgid ""
"Indicates the presence of I<time_zero> which allows mapping timestamp values "
"to the hardware clock."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1736
#, no-wrap
msgid "I<pmc_width>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1743
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1749
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1751
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1760
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since "
"I<time_enabled> (in nanoseconds) using rdtsc or similar."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1765
#, no-wrap
msgid ""
"u64 quot, rem;\n"
"u64 delta;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1770
#, no-wrap
msgid ""
"quot  = cyc E<gt>E<gt> time_shift;\n"
"rem   = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"delta = time_offset + quot * time_mult +\n"
"        ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1783
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1792
#, no-wrap
msgid ""
"enabled += delta;\n"
"if (idx)\n"
"    running += delta;\n"
"quot  = count / running;\n"
"rem   = count % running;\n"
"count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1794
#, no-wrap
msgid "I<time_zero> (since Linux 3.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1807
msgid ""
"If I<cap_usr_time_zero> is set, then the hardware clock (the TSC timestamp "
"counter on x86)  can be calculated from the I<time_zero>, I<time_mult>, and "
"I<time_shift> values:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1814
#, no-wrap
msgid ""
"time = timestamp - time_zero;\n"
"quot = time / time_mult;\n"
"rem  = time % time_mult;\n"
"cyc  = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / "
"time_mult;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1818
msgid "And vice versa:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1825
#, no-wrap
msgid ""
"quot = cyc E<gt>E<gt> time_shift;\n"
"rem  = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"timestamp = time_zero + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1827
#, no-wrap
msgid "I<data_head>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1833
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1838
msgid ""
"On SMP-capable platforms, after reading the I<data_head> value, user space "
"should issue an rmb()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1838
#, no-wrap
msgid "I<data_tail>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1846
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case, the kernel will "
"not overwrite unread data."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1846
#, no-wrap
msgid "I<data_offset> (since Linux 4.1)"
msgstr ""

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: build/C/man2/perf_event_open.2:1851
msgid ""
"Contains the offset of the location in the mmap buffer where perf sample "
"data begins."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1851
#, no-wrap
msgid "I<data_size> (since Linux 4.1)"
msgstr ""

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: build/C/man2/perf_event_open.2:1856
msgid "Contains the size of the perf sample region within the mmap buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1856
#, no-wrap
msgid "I<aux_head>, I<aux_tail>, I<aux_offset>, I<aux_size> (since Linux 4.1)"
msgstr ""

#.  commit 45bfb2e50471abbbfd83d40d28c986078b0d24ff
#. type: Plain text
#: build/C/man2/perf_event_open.2:1865
msgid ""
"The AUX region allows B<mmap>(2)-ing a separate sample buffer for "
"high-bandwidth data streams (separate from the main perf sample buffer).  An "
"example of a high-bandwidth stream is instruction tracing support, as is "
"found in newer Intel processors."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1883
msgid ""
"To set up an AUX area, first I<aux_offset> needs to be set with an offset "
"greater than I<data_offset>+I<data_size> and I<aux_size> needs to be set to "
"the desired buffer size.  The desired offset and size must be page aligned, "
"and the size must be a power of two.  These values are then passed to mmap "
"in order to map the AUX buffer.  Pages in the AUX buffer are included as "
"part of the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2)), and also "
"as part of the I<perf_event_mlock_kb> allowance."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1892
msgid ""
"By default, the AUX buffer will be truncated if it will not fit in the "
"available space in the ring buffer.  If the AUX buffer is mapped as a read "
"only buffer, then it will operate in ring buffer mode where old data will be "
"overwritten by new.  In overwrite mode, it might not be possible to infer "
"where the new data began, and it is the consumer's job to disable "
"measurement while reading to avoid possible data races."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1902
msgid ""
"The I<aux_head> and I<aux_tail> ring buffer pointers have the same behavior "
"and ordering rules as the previous described I<data_head> and I<data_tail>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1904
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1918
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields, "
"that is, at the end of the payload.  This allows a newer perf.data file to "
"be supported by older perf tools, with the new optional fields being "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1920
msgid "The mmap values start with a header:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1928
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1936
msgid ""
"Below, we describe the I<perf_event_header> fields in more detail.  For ease "
"of reading, the fields with shorter descriptions are presented first."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1939
msgid "This indicates the size of the record."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1939
#, no-wrap
msgid "I<misc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1944
msgid "The I<misc> field contains additional information about the sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1949
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1950
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1953
msgid "Unknown CPU mode."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1953
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1956
msgid "Sample happened in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1956
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1959
msgid "Sample happened in user code."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1959
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1962
msgid "Sample happened in the hypervisor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1962
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL> (since Linux 2.6.35)"
msgstr ""

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: build/C/man2/perf_event_open.2:1966
msgid "Sample happened in the guest kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1966
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)>"
msgstr ""

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: build/C/man2/perf_event_open.2:1970
msgid "Sample happened in guest user code."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1975
msgid ""
"Since the following three statuses are generated by different record types, "
"they alias to the same bit:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1975
#, no-wrap
msgid "B<PERF_RECORD_MISC_MMAP_DATA> (since Linux 3.10)"
msgstr ""

#.  commit 2fe85427e3bf65d791700d065132772fc26e4d75
#. type: Plain text
#: build/C/man2/perf_event_open.2:1980
msgid ""
"This is set when the mapping is not executable; otherwise the mapping is "
"executable."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1980
#, no-wrap
msgid "B<PERF_RECORD_MISC_COMM_EXEC> (since Linux 3.16)"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: build/C/man2/perf_event_open.2:1989
msgid ""
"This is set for a B<PERF_RECORD_COMM> record on kernels more recent than "
"Linux 3.16 if a process name change was caused by an B<exec>(2)  system "
"call."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1989
#, no-wrap
msgid "B<PERF_RECORD_MISC_SWITCH_OUT> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: build/C/man2/perf_event_open.2:1999
msgid ""
"When a B<PERF_RECORD_SWITCH> or B<PERF_RECORD_SWITCH_CPU_WIDE> record is "
"generated, this bit indicates that the context switch is away from the "
"current process (instead of into the current process)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2003
msgid "In addition, the following bits can be set:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2003
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2011
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also "
"I<perf_event_attr.precise_ip>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2011
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED> (since Linux 2.6.35)"
msgstr ""

#.  commit 1676b8a077c352085d52578fb4f29350b58b6e74
#. type: Plain text
#: build/C/man2/perf_event_open.2:2015
msgid "This indicates there is extended data available (currently not used)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2015
#, no-wrap
msgid "B<PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT>"
msgstr ""

#.  commit 930e6fcd2bcce9bcd9d4aa7e755678d33f3fe6f4
#. type: Plain text
#: build/C/man2/perf_event_open.2:2023
msgid ""
"This bit is not set by the kernel.  It is reserved for the user-space perf "
"utility to indicate that I</proc/i[pid]/maps> parsing was taking too long "
"and was stopped, and thus the mmap records may be truncated."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2033
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2034
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2041
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2052
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2055 build/C/man2/perf_event_open.2:2109 build/C/man2/perf_event_open.2:2686 build/C/man2/perf_event_open.2:2778 build/C/man2/perf_event_open.2:2878
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2058 build/C/man2/perf_event_open.2:2112 build/C/man2/perf_event_open.2:2689
msgid "is the process ID."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2058 build/C/man2/perf_event_open.2:2112 build/C/man2/perf_event_open.2:2689 build/C/man2/perf_event_open.2:2781 build/C/man2/perf_event_open.2:2881
#, no-wrap
msgid "I<tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2061 build/C/man2/perf_event_open.2:2115 build/C/man2/perf_event_open.2:2692
msgid "is the thread ID."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2061 build/C/man2/perf_event_open.2:2253 build/C/man2/perf_event_open.2:2692 build/C/man2/perf_event_open.2:2937 build/C/man2/perf_event_open.2:3043
#, no-wrap
msgid "I<addr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2070
msgid ""
"is the address of the allocated memory.  I<len> is the length of the "
"allocated memory.  I<pgoff> is the page offset of the allocated memory.  "
"I<filename> is a string describing the backing of the allocated memory."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2071
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2074
msgid "This record indicates when events are lost."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2083
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    id;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2089
msgid "is the unique event ID for the samples that were lost."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2089 build/C/man2/perf_event_open.2:2801
#, no-wrap
msgid "I<lost>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2092
msgid "is the number of events that were lost."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2093
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2096
msgid "This record indicates a change in the process name."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2106
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    char   comm[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2118
msgid "is a string containing the new name of the process."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2119
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2122
msgid "This record indicates a process exit event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2132 build/C/man2/perf_event_open.2:2162
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, ppid;\n"
"    u32    tid, ptid;\n"
"    u64    time;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2134
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2137
msgid "This record indicates a throttle/unthrottle event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2147
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    time;\n"
"    u64    id;\n"
"    u64    stream_id;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2149
#, no-wrap
msgid "B<PERF_RECORD_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2152
msgid "This record indicates a fork event."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2164
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2167
msgid "This record indicates a read event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2176
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    struct read_format values;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2178
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2181
msgid "This record indicates a sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2220
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */\n"
"    u64    ip;          /* if PERF_SAMPLE_IP */\n"
"    u32    pid, tid;    /* if PERF_SAMPLE_TID */\n"
"    u64    time;        /* if PERF_SAMPLE_TIME */\n"
"    u64    addr;        /* if PERF_SAMPLE_ADDR */\n"
"    u64    id;          /* if PERF_SAMPLE_ID */\n"
"    u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32    cpu, res;    /* if PERF_SAMPLE_CPU */\n"
"    u64    period;      /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v;\n"
"                        /* if PERF_SAMPLE_READ */\n"
"    u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32    size;        /* if PERF_SAMPLE_RAW */\n"
"    char   data[size];  /* if PERF_SAMPLE_RAW */\n"
"    u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    size;        /* if PERF_SAMPLE_STACK_USER */\n"
"    char   data[size];  /* if PERF_SAMPLE_STACK_USER */\n"
"    u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &&\n"
"                           size != 0 */\n"
"    u64    weight;      /* if PERF_SAMPLE_WEIGHT */\n"
"    u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */\n"
"    u64    transaction; /* if PERF_SAMPLE_TRANSACTION */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_INTR */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_INTR */\n"
"    u64    phys_addr;   /* if PERF_SAMPLE_PHYS_ADDR */\n"
"    u64    cgroup;      /* if PERF_SAMPLE_CGROUP */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2223
#, no-wrap
msgid "I<sample_id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2233
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is enabled, a 64-bit unique ID is included.  "
"This is a duplication of the B<PERF_SAMPLE_ID> I<id> value, but included at "
"the beginning of the sample so parsers can easily obtain the value."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2233
#, no-wrap
msgid "I<ip>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2239
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2239
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2245
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread "
"ID are included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2245
#, no-wrap
msgid "I<time>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2253
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2260
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2268
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2268
#, no-wrap
msgid "I<stream_id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2278
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2278
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2285
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2285
#, no-wrap
msgid "I<period>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2291
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2291
#, no-wrap
msgid "I<v>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2302
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2302
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2310
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow.  "
"This is the current callchain."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2310
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2317
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2322
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2322
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2331
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures which each include the fields:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2332
#, no-wrap
msgid "I<from>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2335
msgid "This indicates the source instruction (may not be a branch)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2335
#, no-wrap
msgid "I<to>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2338
msgid "The branch target."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2338
#, no-wrap
msgid "I<mispred>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2341
msgid "The branch target was mispredicted."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2341
#, no-wrap
msgid "I<predicted>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2344
msgid "The branch target was predicted."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2344
#, no-wrap
msgid "I<in_tx> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: build/C/man2/perf_event_open.2:2348
msgid "The branch was in a transactional memory transaction."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2348
#, no-wrap
msgid "I<abort> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: build/C/man2/perf_event_open.2:2352
msgid "The branch was in an aborted transactional memory transaction."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2352
#, no-wrap
msgid "I<cycles> (since Linux 4.3)"
msgstr ""

#.  commit 71ef3c6b9d4665ee7afbbe4c208a98917dcfc32f
#. type: Plain text
#: build/C/man2/perf_event_open.2:2357
msgid ""
"This reports the number of cycles elapsed since the previous branch stack "
"update."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2360
msgid ""
"The entries are from most to least recent, so the first entry has the most "
"recent branch."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2368
msgid ""
"Support for I<mispred>, I<predicted>, and I<cycles> is optional; if not "
"supported, those values will be 0."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2372
msgid ""
"The type of branches recorded is specified by the I<branch_sample_type> "
"field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2373 build/C/man2/perf_event_open.2:2618
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2378
msgid ""
"If B<PERF_SAMPLE_REGS_USER> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2386 build/C/man2/perf_event_open.2:2631
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32>, or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2396
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_user> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_user> bit mask."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2396
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2417
msgid ""
"If B<PERF_SAMPLE_STACK_USER> is enabled, then the user stack is recorded.  "
"This can be used to generate stack backtraces.  I<size> is the size "
"requested by the user in I<sample_stack_user> or else the maximum record "
"size.  I<data> is the stack data (a raw dump of the memory pointed to by the "
"stack pointer at the time of sampling).  I<dyn_size> is the amount of data "
"actually dumped (can be less than I<size>).  Note that I<dyn_size> is "
"omitted if I<size> is 0."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2417
#, no-wrap
msgid "I<weight>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2425
msgid ""
"If B<PERF_SAMPLE_WEIGHT> is enabled, then a 64-bit value provided by the "
"hardware is recorded that indicates how costly the event was.  This allows "
"expensive events to stand out more clearly in profiles."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2425
#, no-wrap
msgid "I<data_src>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2431
msgid ""
"If B<PERF_SAMPLE_DATA_SRC> is enabled, then a 64-bit value is recorded that "
"is made up of the following fields:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2432
#, no-wrap
msgid "I<mem_op>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2435
msgid "Type of opcode, a bitwise combination of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2438
#, no-wrap
msgid "B<PERF_MEM_OP_NA>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2441 build/C/man2/perf_event_open.2:2466 build/C/man2/perf_event_open.2:2517 build/C/man2/perf_event_open.2:2541 build/C/man2/perf_event_open.2:2557
msgid "Not available"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2441
#, no-wrap
msgid "B<PERF_MEM_OP_LOAD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2444
msgid "Load instruction"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2444
#, no-wrap
msgid "B<PERF_MEM_OP_STORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2447
msgid "Store instruction"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2447
#, no-wrap
msgid "B<PERF_MEM_OP_PFETCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2450
msgid "Prefetch"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2450
#, no-wrap
msgid "B<PERF_MEM_OP_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2453
msgid "Executable code"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2455
#, no-wrap
msgid "I<mem_lvl>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2460
msgid ""
"Memory hierarchy level hit or miss, a bitwise combination of the following, "
"shifted left by B<PERF_MEM_LVL_SHIFT>:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2463
#, no-wrap
msgid "B<PERF_MEM_LVL_NA>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2466
#, no-wrap
msgid "B<PERF_MEM_LVL_HIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2469 build/C/man2/perf_event_open.2:2560
msgid "Hit"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2469
#, no-wrap
msgid "B<PERF_MEM_LVL_MISS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2472 build/C/man2/perf_event_open.2:2563
msgid "Miss"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2472
#, no-wrap
msgid "B<PERF_MEM_LVL_L1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2475
msgid "Level 1 cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2475
#, no-wrap
msgid "B<PERF_MEM_LVL_LFB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2478
msgid "Line fill buffer"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2478
#, no-wrap
msgid "B<PERF_MEM_LVL_L2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2481
msgid "Level 2 cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2481
#, no-wrap
msgid "B<PERF_MEM_LVL_L3>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2484
msgid "Level 3 cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2484
#, no-wrap
msgid "B<PERF_MEM_LVL_LOC_RAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2487
msgid "Local DRAM"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2487
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2490
msgid "Remote DRAM 1 hop"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2490
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2493
msgid "Remote DRAM 2 hops"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2493
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2496
msgid "Remote cache 1 hop"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2496
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2499
msgid "Remote cache 2 hops"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2499
#, no-wrap
msgid "B<PERF_MEM_LVL_IO>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2502
msgid "I/O memory"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2502
#, no-wrap
msgid "B<PERF_MEM_LVL_UNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2505
msgid "Uncached memory"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2507
#, no-wrap
msgid "I<mem_snoop>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2511
msgid ""
"Snoop mode, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_SNOOP_SHIFT>:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2514
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NA>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2517
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2520
msgid "No snoop"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2520
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2523
msgid "Snoop hit"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2523
#, no-wrap
msgid "B<PERF_MEM_SNOOP_MISS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2526
msgid "Snoop miss"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2526
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HITM>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2529
msgid "Snoop hit modified"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2531
#, no-wrap
msgid "I<mem_lock>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2535
msgid ""
"Lock instruction, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_LOCK_SHIFT>:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2538
#, no-wrap
msgid "B<PERF_MEM_LOCK_NA>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2541
#, no-wrap
msgid "B<PERF_MEM_LOCK_LOCKED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2544
msgid "Locked transaction"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2546
#, no-wrap
msgid "I<mem_dtlb>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2551
msgid ""
"TLB access hit or miss, a bitwise combination of the following, shifted left "
"by B<PERF_MEM_TLB_SHIFT>:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2554
#, no-wrap
msgid "B<PERF_MEM_TLB_NA>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2557
#, no-wrap
msgid "B<PERF_MEM_TLB_HIT>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2560
#, no-wrap
msgid "B<PERF_MEM_TLB_MISS>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2563
#, no-wrap
msgid "B<PERF_MEM_TLB_L1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2566
msgid "Level 1 TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2566
#, no-wrap
msgid "B<PERF_MEM_TLB_L2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2569
msgid "Level 2 TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2569
#, no-wrap
msgid "B<PERF_MEM_TLB_WK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2572
msgid "Hardware walker"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2572
#, no-wrap
msgid "B<PERF_MEM_TLB_OS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2575
msgid "OS fault handler"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2578
#, no-wrap
msgid "I<transaction>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2584
msgid ""
"If the B<PERF_SAMPLE_TRANSACTION> flag is set, then a 64-bit field is "
"recorded describing the sources of any transactional memory aborts."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2586
msgid "The field is a bitwise combination of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2587
#, no-wrap
msgid "B<PERF_TXN_ELISION>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2590
msgid "Abort from an elision type transaction (Intel-CPU-specific)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2590
#, no-wrap
msgid "B<PERF_TXN_TRANSACTION>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2593
msgid "Abort from a generic transaction."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2593
#, no-wrap
msgid "B<PERF_TXN_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2596
msgid "Synchronous abort (related to the reported instruction)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2596
#, no-wrap
msgid "B<PERF_TXN_ASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2599
msgid "Asynchronous abort (not related to the reported instruction)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2599
#, no-wrap
msgid "B<PERF_TXN_RETRY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2602
msgid "Retryable abort (retrying the transaction may have succeeded)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2602
#, no-wrap
msgid "B<PERF_TXN_CONFLICT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2605
msgid "Abort due to memory conflicts with other threads."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2605
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2608
msgid "Abort due to write capacity overflow."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2608
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2611
msgid "Abort due to read capacity overflow."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2618
msgid ""
"In addition, a user-specified abort code can be obtained from the high 32 "
"bits of the field by shifting right by B<PERF_TXN_ABORT_SHIFT> and masking "
"with the value B<PERF_TXN_ABORT_MASK>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2623
msgid ""
"If B<PERF_SAMPLE_REGS_INTR> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2641
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_intr> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_intr> bit mask."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2641
#, no-wrap
msgid "I<phys_addr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2646
msgid ""
"If the B<PERF_SAMPLE_PHYS_ADDR> flag is set, then the 64-bit physical "
"address is recorded."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2646
#, no-wrap
msgid "I<cgroup>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2654
msgid ""
"If the B<PERF_SAMPLE_CGROUP> flag is set, then the 64-bit cgroup ID (for the "
"perf_event subsystem) is recorded.  To get the pathname of the cgroup, the "
"ID should match to one in a B<PERF_RECORD_CGROUP .>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2655
#, no-wrap
msgid "B<PERF_RECORD_MMAP2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2664
msgid ""
"This record includes extended information on B<mmap>(2)  calls returning "
"executable mappings.  The format is similar to that of the "
"B<PERF_RECORD_MMAP> record, but includes extra values that allow uniquely "
"identifying shared mappings."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2683
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    u32    maj;\n"
"    u32    min;\n"
"    u64    ino;\n"
"    u64    ino_generation;\n"
"    u32    prot;\n"
"    u32    flags;\n"
"    char   filename[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2695
msgid "is the address of the allocated memory."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2695 build/C/man2/perf_event_open.2:2940
#, no-wrap
msgid "I<len>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2698
msgid "is the length of the allocated memory."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2698
#, no-wrap
msgid "I<pgoff>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2701
msgid "is the page offset of the allocated memory."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2701
#, no-wrap
msgid "I<maj>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2704
msgid "is the major ID of the underlying device."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2704
#, no-wrap
msgid "I<min>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2707
msgid "is the minor ID of the underlying device."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2707
#, no-wrap
msgid "I<ino>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2710
msgid "is the inode number."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2710
#, no-wrap
msgid "I<ino_generation>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2713
msgid "is the inode generation."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2713
#, no-wrap
msgid "I<prot>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2716
msgid "is the protection information."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2716 build/C/man2/perf_event_open.2:2747 build/C/man2/perf_event_open.2:2952
#, no-wrap
msgid "I<flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2719
msgid "is the flags information."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2719
#, no-wrap
msgid "I<filename>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2722
msgid "is a string describing the backing of the allocated memory."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2723
#, no-wrap
msgid "B<PERF_RECORD_AUX> (since Linux 4.1)"
msgstr ""

#.  commit 68db7e98c3a6ebe7284b6cf14906ed7c55f3f7f0
#. type: Plain text
#: build/C/man2/perf_event_open.2:2728
msgid ""
"This record reports that new data is available in the separate AUX buffer "
"region."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2738
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    aux_offset;\n"
"    u64    aux_size;\n"
"    u64    flags;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2741
#, no-wrap
msgid "I<aux_offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2744
msgid "offset in the AUX mmap region where the new data begins."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2744
#, no-wrap
msgid "I<aux_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2747
msgid "size of the data made available."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2750
msgid "describes the AUX update."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2751
#, no-wrap
msgid "B<PERF_AUX_FLAG_TRUNCATED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2755
msgid ""
"if set, then the data returned was truncated to fit the available buffer "
"size."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2755
#, no-wrap
msgid "B<PERF_AUX_FLAG_OVERWRITE>"
msgstr ""

#.  commit 2023a0d2829e521fe6ad6b9907f3f90bfbf57142
#. type: Plain text
#: build/C/man2/perf_event_open.2:2759
msgid "if set, then the data returned has overwritten previous data."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2761
#, no-wrap
msgid "B<PERF_RECORD_ITRACE_START> (since Linux 4.1)"
msgstr ""

#.  ec0d7729bbaed4b9d2d3fada693278e13a3d1368
#. type: Plain text
#: build/C/man2/perf_event_open.2:2767
msgid ""
"This record indicates which process has initiated an instruction trace "
"event, allowing tools to properly correlate the instruction addresses in the "
"AUX buffer with the proper executable."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2775
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2781
msgid "process ID of the thread starting an instruction trace."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2784
msgid "thread ID of the thread starting an instruction trace."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2785
#, no-wrap
msgid "B<PERF_RECORD_LOST_SAMPLES> (since Linux 4.2)"
msgstr ""

#.  f38b0dbb491a6987e198aa6b428db8692a6480f8
#. type: Plain text
#: build/C/man2/perf_event_open.2:2790
msgid ""
"When using hardware sampling (such as Intel PEBS) this record indicates some "
"number of samples that may have been lost."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2798
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2804
msgid "the number of potentially lost samples."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2805
#, no-wrap
msgid "B<PERF_RECORD_SWITCH> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: build/C/man2/perf_event_open.2:2815
msgid ""
"This record indicates a context switch has happened.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2822
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2824
#, no-wrap
msgid "B<PERF_RECORD_SWITCH_CPU_WIDE> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: build/C/man2/perf_event_open.2:2839
msgid ""
"As with B<PERF_RECORD_SWITCH> this record indicates a context switch has "
"happened, but it only occurs when sampling in CPU-wide mode and provides "
"additional information on the process being switched to/from.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2848
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 next_prev_pid;\n"
"    u32 next_prev_tid;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2851
#, no-wrap
msgid "I<next_prev_pid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2855
msgid ""
"The process ID of the previous (if switching in)  or next (if switching out) "
"process on the CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2855
#, no-wrap
msgid "I<next_prev_tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2859
msgid ""
"The thread ID of the previous (if switching in)  or next (if switching out) "
"thread on the CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2860
#, no-wrap
msgid "B<PERF_RECORD_NAMESPACES> (since Linux 4.11)"
msgstr ""

#.  commit e422267322cd319e2695a535e47c5b1feeac45eb
#. type: Plain text
#: build/C/man2/perf_event_open.2:2864
msgid "This record includes various namespace information of a process."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2875
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    u64    nr_namespaces;\n"
"    struct { u64 dev, inode } [nr_namespaces];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2881
msgid "is the process ID"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2884
msgid "is the thread ID"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2884
#, no-wrap
msgid "I<nr_namespace>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2887
msgid "is the number of namespaces in this record"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2895
msgid ""
"Each namespace has I<dev> and I<inode> fields and is recorded in the fixed "
"position like below:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2896
#, no-wrap
msgid "B<NET_NS_INDEX>=B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2899
msgid "Network namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2899
#, no-wrap
msgid "B<UTS_NS_INDEX>=B<1>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2902
msgid "UTS namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2902
#, no-wrap
msgid "B<IPC_NS_INDEX>=B<2>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2905
msgid "IPC namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2905
#, no-wrap
msgid "B<PID_NS_INDEX>=B<3>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2908
msgid "PID namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2908
#, no-wrap
msgid "B<USER_NS_INDEX>=B<4>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2911
msgid "User namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2911
#, no-wrap
msgid "B<MNT_NS_INDEX>=B<5>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2914
msgid "Mount namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2914
#, no-wrap
msgid "B<CGROUP_NS_INDEX>=B<6>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2917
msgid "Cgroup namespace"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2918
#, no-wrap
msgid "B<PERF_RECORD_KSYMBOL> (since Linux 5.0)"
msgstr ""

#.  commit 76193a94522f1d4edf2447a536f3f796ce56343b
#. type: Plain text
#: build/C/man2/perf_event_open.2:2922
msgid "This record indicates kernel symbol register/unregister events."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2934
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    addr;\n"
"    u32    len;\n"
"    u16    ksym_type;\n"
"    u16    flags;\n"
"    char   name[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2940
msgid "is the address of the kernel symbol."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2943
msgid "is the length of the kernel symbol."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2943
#, no-wrap
msgid "I<ksym_type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2947
msgid ""
"is the type of the kernel symbol.  Currently the following types are "
"available:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2948
#, no-wrap
msgid "B<PERF_RECORD_KSYMBOL_TYPE_BPF>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2951
msgid "The kernel symbol is a BPF function."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2957
msgid ""
"If the B<PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER> is set, then this event is "
"for unregistering the kernel symbol."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2958
#, no-wrap
msgid "B<PERF_RECORD_BPF_EVENT> (since Linux 5.0)"
msgstr ""

#.  commit 6ee52e2a3fe4ea35520720736e6791df1fb67106
#. type: Plain text
#: build/C/man2/perf_event_open.2:2962
msgid "This record indicates BPF program is loaded or unloaded."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2973
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u16 type;\n"
"    u16 flags;\n"
"    u32 id;\n"
"    u8 tag[BPF_TAG_SIZE];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2979
msgid "is one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2980
#, no-wrap
msgid "B<PERF_BPF_EVENT_PROG_LOAD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2983
msgid "A BPF program is loaded"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2983
#, no-wrap
msgid "B<PERF_BPF_EVENT_PROG_UNLOAD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2986
msgid "A BPF program is unloaded"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2990
msgid "is the ID of the BPF program."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2990
#, no-wrap
msgid "I<tag>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2996
msgid "is the tag of the BPF program.  Currently, B<BPF_TAG_SIZE> is defined as 8."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:2997
#, no-wrap
msgid "B<PERF_RECORD_CGROUP> (since Linux 5.7)"
msgstr ""

#.  commit 96aaab686505c449e24d76e76507290dcc30e008
#. type: Plain text
#: build/C/man2/perf_event_open.2:3001
msgid "This record indicates a new cgroup is created and activated."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3010
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    id;\n"
"    char   path[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3019
msgid ""
"is the cgroup identifier.  This can be also retrieved by "
"B<name_to_handle_at>(2)  on the cgroup path (as a file handle)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3019
#, no-wrap
msgid "I<path>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3022
msgid "is the path of the cgroup from the root."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3023
#, no-wrap
msgid "B<PERF_RECORD_TEXT_POKE> (since Linux 5.8)"
msgstr ""

#.  commit e17d43b93e544f5016c0251d2074c15568d5d963
#. type: Plain text
#: build/C/man2/perf_event_open.2:3029
msgid ""
"This record indicates a change in the kernel text.  This includes addition "
"and removal of the text and the corresponding length is zero in this case."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3040
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    addr;\n"
"    u16    old_len;\n"
"    u16    new_len;\n"
"    u8     bytes[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3046
msgid "is the address of the change"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3046
#, no-wrap
msgid "I<old_len>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3049
msgid "is the old length"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3049
#, no-wrap
msgid "I<new_len>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3052
msgid "is the new length"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3052
#, no-wrap
msgid "I<bytes>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3055
msgid "contains old bytes immediately followed by new bytes."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:3057
#, no-wrap
msgid "Overflow handling"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3073
msgid ""
"Events can be set to notify when a threshold is crossed, indicating an "
"overflow.  Overflow conditions can be captured by monitoring the event file "
"descriptor with B<poll>(2), B<select>(2), or B<epoll>(7).  Alternatively, "
"the overflow events can be captured via sa signal handler, by enabling I/O "
"signaling on the file descriptor; see the discussion of the B<F_SETOWN> and "
"B<F_SETSIG> operations in B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3077
msgid ""
"Overflows are generated only by sampling events (I<sample_period> must have "
"a nonzero value)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3079
msgid "There are two ways to generate overflow notifications."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3089
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will trigger if a certain number of samples or bytes have been written to "
"the mmap ring buffer.  In this case, B<POLL_IN> is indicated."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3101
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When "
"nonzero, B<POLL_IN> is indicated, but once the counter reaches 0 B<POLL_HUP> "
"is indicated and the underlying event is disabled."
msgstr ""

#.  See https://lkml.org/lkml/2011/5/24/337
#. type: Plain text
#: build/C/man2/perf_event_open.2:3107
msgid ""
"Refreshing an event group leader refreshes all siblings and refreshing with "
"a parameter of 0 currently enables infinite refreshes; these behaviors are "
"unsupported and should not be relied on."
msgstr ""

#.  commit 179033b3e064d2cd3f5f9945e76b0a0f0fbf4883
#. type: Plain text
#: build/C/man2/perf_event_open.2:3113
msgid ""
"Starting with Linux 3.18, B<POLL_HUP> is indicated if the event being "
"monitored is attached to a different process and that process exits."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:3113
#, no-wrap
msgid "rdpmc instruction"
msgstr ""

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: build/C/man2/perf_event_open.2:3121
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3126
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap "
"page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""

#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: build/C/man2/perf_event_open.2:3136
msgid ""
"Originally, when rdpmc support was enabled, any process (not just ones with "
"an active perf event) could use the rdpmc instruction to access the "
"counters.  Starting with Linux 4.0, rdpmc support is only allowed if an "
"event is currently enabled in a process's context.  To restore the old "
"behavior, write the value 2 to I</sys/devices/cpu/rdpmc>."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:3136
#, no-wrap
msgid "perf_event ioctl calls"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3140
msgid "Various ioctls act on B<perf_event_open>()  file descriptors:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3140
#, no-wrap
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3144
msgid ""
"This enables the individual event or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3150
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are enabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3150
#, no-wrap
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3154
msgid ""
"This disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3161
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader affects only that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3167
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are disabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3167
#, no-wrap
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3181
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count.  "
"An overflow notification with B<POLL_IN> set will happen on each overflow "
"until the count reaches 0; when that happens a notification with B<POLL_HUP> "
"set is sent and the event is disabled.  Using an argument of 0 is considered "
"undefined behavior."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3181
#, no-wrap
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3191
msgid ""
"Reset the event count specified by the file descriptor argument to zero.  "
"This resets only the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3197
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are reset, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3197
#, no-wrap
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3200
msgid "This updates the overflow period for the event."
msgstr ""

#.  commit 3581fe0ef37ce12ac7a4f74831168352ae848edc
#.  commit bad7192b842c83e580747ca57104dd51fe08c223
#. type: Plain text
#: build/C/man2/perf_event_open.2:3208
msgid ""
"Since Linux 3.7 (on ARM)  and Linux 3.14 (all other architectures), the new "
"period takes effect immediately.  On older kernels, the new period did not "
"take effect until after the next overflow."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3211
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""

#.  commit ad0cf3478de8677f720ee06393b3147819568d6a
#. type: Plain text
#: build/C/man2/perf_event_open.2:3216
msgid "Prior to Linux 2.6.36, this ioctl always failed due to a bug in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3216
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3221
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on "
"the same CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3224
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3224
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_FILTER> (since Linux 2.6.33)"
msgstr ""

#.  commit 6fb2915df7f0747d9044da9dbff5b46dc2e20830
#. type: Plain text
#: build/C/man2/perf_event_open.2:3228
msgid "This adds an ftrace filter to this event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3230
msgid "The argument is a pointer to the desired ftrace filter."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3230
#, no-wrap
msgid "B<PERF_EVENT_IOC_ID> (since Linux 3.12)"
msgstr ""

#.  commit cf4957f17f2a89984915ea808876d9c82225b862
#. type: Plain text
#: build/C/man2/perf_event_open.2:3234
msgid "This returns the event ID value for the given event file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3237
msgid "The argument is a pointer to a 64-bit unsigned integer to hold the result."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3237
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_BPF> (since Linux 4.1)"
msgstr ""

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: build/C/man2/perf_event_open.2:3247
msgid ""
"This allows attaching a Berkeley Packet Filter (BPF)  program to an existing "
"kprobe tracepoint event.  You need B<CAP_PERFMON> (since Linux 5.8) or "
"B<CAP_SYS_ADMIN> privileges to use this ioctl."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3252
msgid ""
"The argument is a BPF program file descriptor that was created by a previous "
"B<bpf>(2)  system call."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3252
#, no-wrap
msgid "B<PERF_EVENT_IOC_PAUSE_OUTPUT> (since Linux 4.7)"
msgstr ""

#.  commit 86e7972f690c1017fd086cdfe53d8524e68c661c
#. type: Plain text
#: build/C/man2/perf_event_open.2:3263
msgid ""
"This allows pausing and resuming the event's ring-buffer.  A paused "
"ring-buffer does not prevent generation of samples, but simply discards "
"them.  The discarded samples are considered lost, and cause a "
"B<PERF_RECORD_LOST> sample to be generated when possible.  An overflow "
"signal may still be triggered by the discarded sample even though the "
"ring-buffer remains empty."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3267
msgid ""
"The argument is an unsigned 32-bit integer.  A nonzero value pauses the "
"ring-buffer, while a zero value resumes the ring-buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3267
#, no-wrap
msgid "B<PERF_EVENT_MODIFY_ATTRIBUTES> (since Linux 4.17)"
msgstr ""

#.  commit 32ff77e8cc9e66cc4fb38098f64fd54cc8f54573
#. type: Plain text
#: build/C/man2/perf_event_open.2:3273
msgid ""
"This allows modifying an existing event without the overhead of closing and "
"reopening a new event.  Currently this is supported only for breakpoint "
"events."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3277
msgid ""
"The argument is a pointer to a I<perf_event_attr> structure containing the "
"updated event settings."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3277
#, no-wrap
msgid "B<PERF_EVENT_IOC_QUERY_BPF> (since Linux 4.16)"
msgstr ""

#.  commit f371b304f12e31fe30207c41ca7754564e0ea4dc
#. type: Plain text
#: build/C/man2/perf_event_open.2:3291
msgid ""
"This allows querying which Berkeley Packet Filter (BPF)  programs are "
"attached to an existing kprobe tracepoint.  You can only attach one BPF "
"program per event, but you can have multiple events attached to a "
"tracepoint.  Querying this value on one tracepoint event returns the ID of "
"all BPF programs in all events attached to the tracepoint.  You need "
"B<CAP_PERFMON> (since Linux 5.8) or B<CAP_SYS_ADMIN> privileges to use this "
"ioctl."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3293
msgid "The argument is a pointer to a structure"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3300
#, no-wrap
msgid ""
"struct perf_event_query_bpf {\n"
"    __u32    ids_len;\n"
"    __u32    prog_cnt;\n"
"    __u32    ids[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3322
msgid ""
"The I<ids_len> field indicates the number of ids that can fit in the "
"provided I<ids> array.  The I<prog_cnt> value is filled in by the kernel "
"with the number of attached BPF programs.  The I<ids> array is filled with "
"the ID of each attached BPF program.  If there are more programs than will "
"fit in the array, then the kernel will return B<ENOSPC> and I<ids_len> will "
"indicate the number of program IDs that were successfully copied."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:3322
#, no-wrap
msgid "Using prctl(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3335
msgid ""
"A process can enable or disable all currently open event groups using the "
"B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies only to events "
"created locally by the calling process.  This does not apply to events "
"created by other processes attached to the calling process or inherited "
"events from a parent process.  Only group leaders are enabled and disabled, "
"not any other members of the groups."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:3335
#, no-wrap
msgid "perf_event related configuration files"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3338
msgid "Files in I</proc/sys/kernel/>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3339
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3344
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""

#.  default changed in commit 0161028b7c8aebef64194d3d73e43bc3b53b5c66
#. type: Plain text
#: build/C/man2/perf_event_open.2:3350
msgid "allow only user-space measurements (default since Linux 4.6)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3352
msgid "allow both kernel and user measurements (default before Linux 4.6)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3354
msgid "allow access to CPU-specific data but not raw tracepoint samples."
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:3354
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3356
msgid "no restrictions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3363
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3363
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3371
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to "
"sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3371
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_stack>"
msgstr ""

#.  Introduced in c5dfd78eb79851e278b7973031b9ca363da87a7e
#. type: Plain text
#: build/C/man2/perf_event_open.2:3376
msgid ""
"This file sets the maximum depth of stack frame entries reported when "
"generating a call trace."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3376
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3381
msgid ""
"Maximum number of pages an unprivileged user can B<mlock>(2).  The default "
"is 516 (kB)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3385
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3392
msgid ""
"Since Linux 2.6.34, the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under "
"I</sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3392
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type> (since Linux 2.6.38)"
msgstr ""

#.  commit abe43400579d5de0078c2d3a760e6598e183f871
#. type: Plain text
#: build/C/man2/perf_event_open.2:3400
msgid ""
"This contains an integer that can be used in the I<type> field of "
"I<perf_event_attr> to indicate that you wish to use this PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3400
#, no-wrap
msgid "I</sys/bus/event_source/devices/cpu/rdpmc> (since Linux 3.4)"
msgstr ""

#.  commit 0c9d42ed4cee2aa1dfc3a260b741baae8615744f
#. type: Plain text
#: build/C/man2/perf_event_open.2:3406
msgid ""
"If this file is 1, then direct user-space access to the performance counter "
"registers is allowed via the rdpmc instruction.  This can be disabled by "
"echoing 0 to the file."
msgstr ""

#.  a66734297f78707ce39d756b656bfae861d53f62
#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: build/C/man2/perf_event_open.2:3413
msgid ""
"As of Linux 4.0 the behavior has changed, so that 1 now means only allow "
"access to processes with active perf events, with 2 indicating the old "
"allow-anyone-access behavior."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3413
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/> (since Linux 3.4)"
msgstr ""

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: build/C/man2/perf_event_open.2:3422
msgid ""
"This subdirectory contains information on the architecture-specific "
"subfields available for programming the various I<config> fields in the "
"I<perf_event_attr> struct."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3433
msgid ""
"The content of each file is the name of the config field, followed by a "
"colon, followed by a series of integer bit ranges separated by commas.  For "
"example, the file I<event> may contain the value I<config1:1,6-10,44> which "
"indicates that event is an attribute that occupies bits 1,6\\(en10, and 44 "
"of I<perf_event_attr::config1>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3433
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/> (since Linux 3.4)"
msgstr ""

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: build/C/man2/perf_event_open.2:3443
msgid ""
"This subdirectory contains files with predefined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found "
"in the previously mentioned I<./format/> directory.  These are not "
"necessarily complete lists of all events supported by a PMU, but usually a "
"subset of events deemed useful or interesting."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3451
msgid ""
"The content of each file is a list of attribute names separated by commas.  "
"Each entry has an optional value (either hex or decimal).  If no value is "
"specified, then it is assumed to be a single-bit field with a value of 1.  "
"An example entry may look like this: I<event=0x2,inv,ldlat=3>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3451
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3455
msgid ""
"This file is the standard kernel device interface for injecting hotplug "
"events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3455
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/cpumask> (since Linux 3.7)"
msgstr ""

#.  commit 314d9f63f385096580e9e2a06eaa0745d92fe4ac
#. type: Plain text
#: build/C/man2/perf_event_open.2:3465
msgid ""
"The I<cpumask> file contains a comma-separated list of integers that "
"indicate a representative CPU number for each socket (package)  on the "
"motherboard.  This is needed when setting up uncore or northbridge events, "
"as those PMUs present socket-wide events."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3472
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3477
msgid ""
"The errors returned by B<perf_event_open>()  can be inconsistent, and may "
"vary across processor architectures and performance monitoring units."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3477
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3494
msgid ""
"Returned if the I<perf_event_attr> I<size> value is too small (smaller than "
"B<PERF_ATTR_SIZE_VER0>), too big (larger than the page size), or larger than "
"the kernel supports and the extra bytes are not zero.  When B<E2BIG> is "
"returned, the I<perf_event_attr> I<size> field is overwritten by the kernel "
"to be the size of the structure it was expecting."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3510
msgid ""
"Returned when the requested event requires B<CAP_PERFMON> (since Linux 5.8) "
"or B<CAP_SYS_ADMIN> permissions (or a more permissive perf_event paranoid "
"setting).  Some common cases where an unprivileged process may encounter "
"this error: attaching to a process owned by a different user; monitoring all "
"processes on a given CPU (i.e., specifying the I<pid> argument as -1); and "
"not setting I<exclude_kernel> when the paranoid setting requires it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3520
msgid ""
"Returned if the I<group_fd> file descriptor is not valid, or, if "
"B<PERF_FLAG_PID_CGROUP> is set, the cgroup file descriptor in I<pid> is not "
"valid."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3520
#, no-wrap
msgid "B<EBUSY> (since Linux 4.1)"
msgstr ""

#.  bed5b25ad9c8a2f5d735ef0bc746ec870c01c1b0
#. type: Plain text
#: build/C/man2/perf_event_open.2:3525
msgid "Returned if another event already has exclusive access to the PMU."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3530
msgid "Returned if the I<attr> pointer points at an invalid memory address."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3556
msgid ""
"Returned if the specified event is invalid.  There are many possible reasons "
"for this.  A not-exhaustive list: I<sample_freq> is higher than the maximum "
"setting; the I<cpu> to monitor does not exist; I<read_format> is out of "
"range; I<sample_type> is out of range; the I<flags> value is out of range; "
"I<exclusive> or I<pinned> set and the event is not a group leader; the event "
"I<config> values are out of range or set reserved bits; the generic event "
"selected is not supported; or there is not enough room to add the selected "
"event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3560
msgid "Returned when trying to mix perf and ftrace handling for a uprobe."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3560 build/C/man2/userfaultfd.2:432
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3566
msgid ""
"Each opened event uses one file descriptor.  If a large number of events are "
"opened, the per-process limit on the number of open file descriptors will be "
"reached, and no more events can be created."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3570
msgid "Returned when the event involves a feature not supported by the current CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3570 build/C/man2/quotactl.2:742
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3577
msgid ""
"Returned if the I<type> setting is not valid.  This error is also returned "
"for some unsupported generic events."
msgstr ""

#.  commit aa2bc1ade59003a379ffc485d6da2d92ea3370a6
#. type: Plain text
#: build/C/man2/perf_event_open.2:3588
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  In Linux 3.3, this was changed to B<EINVAL>.  B<ENOSPC> is "
"still returned if you try to add more breakpoint events than supported by "
"the hardware."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3595
msgid ""
"Returned if B<PERF_SAMPLE_STACK_USER> is set in I<sample_type> and it is not "
"supported by hardware."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3602
msgid ""
"Returned if an event requiring a specific hardware feature is requested but "
"there is no hardware support.  This includes requesting low-skid events if "
"not supported, branch tracing if it is not available, sampling if no PMU "
"interrupt is available, and branch stacks for software events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:3602
#, no-wrap
msgid "B<EOVERFLOW> (since Linux 4.8)"
msgstr ""

#.  97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: build/C/man2/perf_event_open.2:3611
msgid ""
"Returned if B<PERF_SAMPLE_CALLCHAIN> is requested and I<sample_max_stack> is "
"larger than the maximum specified in "
"I</proc/sys/kernel/perf_event_max_stack>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3616
msgid ""
"Returned on many (but not all) architectures when an unsupported "
"I<exclude_hv>, I<exclude_idle>, I<exclude_user>, or I<exclude_kernel> "
"setting is specified."
msgstr ""

#.  commit a4e95fc2cbb31d70a65beffeaf8773f881328c34
#. type: Plain text
#: build/C/man2/perf_event_open.2:3627
msgid ""
"It can also happen, as with B<EACCES>, when the requested event requires "
"B<CAP_PERFMON> (since Linux 5.8) or B<CAP_SYS_ADMIN> permissions (or a more "
"permissive perf_event paranoid setting).  This includes setting a breakpoint "
"on a kernel address, and (since Linux 3.13) setting a kernel function-trace "
"tracepoint."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3630
msgid "Returned if attempting to attach to a process that does not exist."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:3630
#, no-wrap
msgid "VERSION"
msgstr ""

#.  commit 0793a61d4df8daeac6492dbf8d2f3e5713caae5e
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: build/C/man2/perf_event_open.2:3637
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>().  It was renamed in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3642
msgid ""
"This B<perf_event_open>()  system call Linux-specific and should not be used "
"in programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3646
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3652
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file "
"I</proc/sys/kernel/perf_event_paranoid>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3668
msgid ""
"B<CAP_PERFMON> capability (since Linux 5.8) provides secure approach to "
"performance monitoring and observability operations in a system according to "
"the principal of least privilege (POSIX IEEE 1003.1e).  Accessing system "
"performance monitoring and observability operations using B<CAP_PERFMON> "
"rather than the much more powerful B<CAP_SYS_ADMIN> excludes chances to "
"misuse credentials and makes operations more secure.  B<CAP_SYS_ADMIN> usage "
"for secure system performance monitoring and observability is discouraged in "
"favor of the B<CAP_PERFMON> capability."
msgstr ""

#.  commit ba0a6c9f6fceed11c6a99e8326f0477fe383e6b5
#. type: Plain text
#: build/C/man2/perf_event_open.2:3676
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow "
"signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""

#.  commit b690081d4d3f6a23541493f1682835c3cd5c54a1
#. type: Plain text
#: build/C/man2/perf_event_open.2:3686
msgid ""
"Prior to Linux 2.6.33 (at least for x86), the kernel did not check if events "
"could be scheduled together until read time.  The same happens on all known "
"kernels if the NMI watchdog is enabled.  This means to see if a given set of "
"events works you have to B<perf_event_open>(), start, then read before you "
"know for sure you can get valid measurements."
msgstr ""

#.  FIXME . cannot find a kernel commit for this one
#. type: Plain text
#: build/C/man2/perf_event_open.2:3692
msgid ""
"Prior to Linux 2.6.34, event constraints were not enforced by the kernel.  "
"In that case, some events would silently return \"0\" if the kernel "
"scheduled them in an improper counter slot."
msgstr ""

#.  commit 45e16a6834b6af098702e5ea6c9a40de42ff77d8
#. type: Plain text
#: build/C/man2/perf_event_open.2:3696
msgid ""
"Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""

#.  commit 38b435b16c36b0d863efcf3f07b34a6fac9873fd
#. type: Plain text
#: build/C/man2/perf_event_open.2:3700
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""

#.  commit 050735b08ca8a016bbace4445fa025b88fee770b
#. type: Plain text
#: build/C/man2/perf_event_open.2:3705
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""

#.  commit 4ec8363dfc1451f8c8f86825731fe712798ada02
#. type: Plain text
#: build/C/man2/perf_event_open.2:3712
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a nonzero value in it."
msgstr ""

#.  commit 724b6daa13e100067c30cfc4d1ad06629609dc4e
#. type: Plain text
#: build/C/man2/perf_event_open.2:3719
msgid ""
"From Linux 2.6.31 to Linux 3.4, the B<PERF_IOC_FLAG_GROUP> ioctl argument "
"was broken and would repeatedly operate on the event specified rather than "
"iterating across all sibling events in a group."
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: build/C/man2/perf_event_open.2:3731
msgid ""
"From Linux 3.4 to Linux 3.11, the mmap I<cap_usr_rdpmc> and I<cap_usr_time> "
"bits mapped to the same location.  Code should migrate to the new "
"I<cap_user_rdpmc> and I<cap_user_time> fields instead."
msgstr ""

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: build/C/man2/perf_event_open.2:3737
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3741
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3750
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3756
#, no-wrap
msgid ""
"static long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3761
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3768
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3776
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(pe));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(pe);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3782
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3785
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3787
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3790
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(count));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3792
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3795
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3803
msgid "B<perf>(1), B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:3806
msgid "I<Documentation/admin-guide/perf-security.rst> in the kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:36
#, no-wrap
msgid ""
"B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int "
">I<narg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the "
"PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:65
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in "
"I<ctxt-E<gt>ctx_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using "
"B<read>(2).  The file descriptor is pollable using B<select>(2), B<poll>(2), "
"and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:90
msgid "The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:95
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:101
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#.  pfm_write_pmds()
#. type: Plain text
#: build/C/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:109
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr ""

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: build/C/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:131
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:152
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_FEATURES, pfarg_features_t *>I<arg>B<, "
"1);>\n"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:167
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t *>I<req>B<, "
"n);>\n"
msgstr ""

#
#
#.  .TP
#.  .B PFM_CREATE_EVTSETS
#
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info, n);
#.  .fi
#. type: Plain text
#: build/C/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:196
msgid ""
"B<perfmonctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:199
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux-specific and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:209
msgid "The perfmon2 interface specification"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:33
#, no-wrap
msgid "PERSONALITY"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:36
msgid "personality - set the process execution domain"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:38
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:40
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:48
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:60
msgid ""
"If I<persona> is not 0xffffffff, then B<personality>()  sets the caller's "
"execution domain to the value specified by I<persona>.  Specifying "
"I<persona> as 0xffffffff provides a way of retrieving the current persona "
"without changing it."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:70
msgid ""
"A list of the available execution domains can be found in "
"I<E<lt>sys/personality.hE<gt>>.  The execution domain is a 32-bit value in "
"which the top three bytes are set aside for flags that cause the kernel to "
"modify the behavior of certain system calls so as to emulate historical or "
"architectural quirks.  The least significant byte is a value defining the "
"personality the kernel should assume.  The flag values are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:70
#, no-wrap
msgid "B<ADDR_COMPAT_LAYOUT> (since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:73
msgid "With this flag set, provide legacy virtual address space layout."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:73
#, no-wrap
msgid "B<ADDR_NO_RANDOMIZE> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:76
msgid "With this flag set, disable address-space-layout randomization."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:76
#, no-wrap
msgid "B<ADDR_LIMIT_32BIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:79
msgid "Limit the address space to 32 bits."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:79
#, no-wrap
msgid "B<ADDR_LIMIT_3GB> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:85
msgid ""
"With this flag set, use 0xc0000000 as the offset at which to search a "
"virtual memory chunk on B<mmap>(2); otherwise use 0xffffe000."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:85
#, no-wrap
msgid "B<FDPIC_FUNCPTRS> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:89
msgid ""
"User-space function pointers to signal handlers point (on certain "
"architectures) to descriptors."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:89
#, no-wrap
msgid "B<MMAP_PAGE_ZERO> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:93
msgid ""
"Map page 0 as read-only (to support binaries that depend on this SVr4 "
"behavior)."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:93
#, no-wrap
msgid "B<READ_IMPLIES_EXEC> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:101
msgid "With this flag set, B<PROT_READ> implies B<PROT_EXEC> for B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:101
#, no-wrap
msgid "B<SHORT_INODE> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:104 build/C/man2/personality.2:123
msgid "No effects(?)."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:104
#, no-wrap
msgid "B<STICKY_TIMEOUTS> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:113
msgid ""
"With this flag set, B<select>(2), B<pselect>(2), and B<ppoll>(2)  do not "
"modify the returned timeout argument when interrupted by a signal handler."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:113
#, no-wrap
msgid "B<UNAME26> (since Linux 3.1)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:120
msgid ""
"Have B<uname>(2)  report a 2.6.40+ version number rather than a 3.x version "
"number.  Added as a stopgap measure to support broken applications that "
"could not handle the kernel version-numbering switch from 2.6.x to 3.x."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:120
#, no-wrap
msgid "B<WHOLE_SECONDS> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:125
msgid "The available execution domains are:"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:125
#, no-wrap
msgid "B<PER_BSD> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:128
msgid "BSD. (No effects.)"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:128
#, no-wrap
msgid "B<PER_HPUX> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:133
msgid ""
"Support for 32-bit HP/UX.  This support was never complete, and was dropped "
"so that since Linux 4.0, this value has no effect."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:133
#, no-wrap
msgid "B<PER_IRIX32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:139
msgid ""
"IRIX 5 32-bit.  Never fully functional; support dropped in Linux 2.6.27.  "
"Implies B<STICKY_TIMEOUTS>."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:139
#, no-wrap
msgid "B<PER_IRIX64> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:145
msgid "IRIX 6 64-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:145
#, no-wrap
msgid "B<PER_IRIXN32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:151
msgid "IRIX 6 new 32-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:151
#, no-wrap
msgid "B<PER_ISCR4> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:156 build/C/man2/personality.2:206
msgid "Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:156
#, no-wrap
msgid "B<PER_LINUX> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:159
msgid "Linux."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:159
#, no-wrap
msgid "B<PER_LINUX32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:162 build/C/man2/personality.2:193
msgid "[To be documented.]"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:162
#, no-wrap
msgid "B<PER_LINUX32_3GB> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:166
msgid "Implies B<ADDR_LIMIT_3GB>."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:166
#, no-wrap
msgid "B<PER_LINUX_32BIT> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:170
msgid "Implies B<ADDR_LIMIT_32BIT>."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:170
#, no-wrap
msgid "B<PER_LINUX_FDPIC> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:174
msgid "Implies B<FDPIC_FUNCPTRS>."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:174
#, no-wrap
msgid "B<PER_OSF4> (since Linux 2.4)"
msgstr ""

#.  Following is from a comment in arch/alpha/kernel/osf_sys.c
#. type: Plain text
#: build/C/man2/personality.2:183
msgid ""
"OSF/1 v4.  On alpha, clear top 32 bits of iov_len in the user's buffer for "
"compatibility with old versions of OSF/1 where iov_len was defined as.  "
"I<int>."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:183
#, no-wrap
msgid "B<PER_OSR5> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:190
msgid "Implies B<STICKY_TIMEOUTS> and B<WHOLE_SECONDS>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:190
#, no-wrap
msgid "B<PER_RISCOS> (since Linux 2.2)"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:193
#, no-wrap
msgid "B<PER_SCOSVR3> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:201
msgid ""
"Implies B<STICKY_TIMEOUTS>, B<WHOLE_SECONDS>, and B<SHORT_INODE>; otherwise "
"no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:201
#, no-wrap
msgid "B<PER_SOLARIS> (since Linux 2.4)"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:206
#, no-wrap
msgid "B<PER_SUNOS> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:214
msgid ""
"Implies B<STICKY_TIMEOUTS>.  Divert library and dynamic linker searches to "
"I</usr/gnemul>.  Buggy, largely unmaintained, and almost entirely unused; "
"support was removed in Linux 2.6.26."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:214
#, no-wrap
msgid "B<PER_SVR3> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:221 build/C/man2/personality.2:242 build/C/man2/personality.2:249
msgid "Implies B<STICKY_TIMEOUTS> and B<SHORT_INODE>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:221
#, no-wrap
msgid "B<PER_SVR4> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:228 build/C/man2/personality.2:235
msgid "Implies B<STICKY_TIMEOUTS> and B<MMAP_PAGE_ZERO>; otherwise no effects."
msgstr ""

#. type: TP
#: build/C/man2/personality.2:228
#, no-wrap
msgid "B<PER_UW7> (since Linux 2.4)"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:235
#, no-wrap
msgid "B<PER_WYSEV386> (since Linux 1.2.0)"
msgstr ""

#. type: TP
#: build/C/man2/personality.2:242
#, no-wrap
msgid "B<PER_XENIX> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:256
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:260
msgid "The kernel was unable to change the personality."
msgstr ""

#.  personality wrapper first appeared in glibc 1.90,
#.  <sys/personality.h> was added later in 2.2.91.
#. type: Plain text
#: build/C/man2/personality.2:266
msgid ""
"This system call first appeared in Linux 1.1.20 (and thus first in a stable "
"kernel release with Linux 1.2.0); library support was added in glibc 2.3."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:270
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:272
msgid "B<setarch>(8)"
msgstr ""

#. type: TH
#: build/C/man2/pivot_root.2:27
#, no-wrap
msgid "PIVOT_ROOT"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:30
msgid "pivot_root - change the root mount"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:32
msgid "B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:43
msgid ""
"B<pivot_root>()  changes the root mount in the mount namespace of the "
"calling process.  More precisely, it moves the root mount to the directory "
"I<put_old> and makes I<new_root> the new root mount.  The calling process "
"must have the B<CAP_SYS_ADMIN> capability in the user namespace that owns "
"the caller's mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:56
msgid ""
"B<pivot_root>()  changes the root directory and the current working "
"directory of each process or thread in the same mount namespace to "
"I<new_root> if they point to the old root directory.  (See also NOTES.)  On "
"the other hand, B<pivot_root>()  does not change the caller's current "
"working directory (unless it is on the old root directory), and thus it "
"should be followed by a B<chdir(\"/\")> call."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:58
msgid "The following restrictions apply:"
msgstr ""

#. type: IP
#: build/C/man2/pivot_root.2:58 build/C/man2/pivot_root.2:63 build/C/man2/pivot_root.2:68 build/C/man2/pivot_root.2:74 build/C/man2/pivot_root.2:80 build/C/man2/pivot_root.2:92
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:63
msgid "I<new_root> and I<put_old> must be directories."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:68
msgid ""
"I<new_root> and I<put_old> must not be on the same mount as the current "
"root."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:74
msgid ""
"I<put_old> must be at or underneath I<new_root>; that is, adding some "
"nonnegative number of \"I</..>\" prefixes to the pathname pointed to by "
"I<put_old> must yield the same directory as I<new_root>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:80
msgid ""
"I<new_root> must be a path to a mount point, but can't be I<\"/\">.  A path "
"that is not already a mount point can be converted into one by bind mounting "
"the path onto itself."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:92
msgid ""
"The propagation type of the parent mount of I<new_root> and the parent mount "
"of the current root directory must not be B<MS_SHARED>; similarly, if "
"I<put_old> is an existing mount point, its propagation type must not be "
"B<MS_SHARED>.  These restrictions ensure that B<pivot_root>()  never "
"propagates any changes to another mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:94
msgid "The current root directory must be a mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:103
msgid ""
"B<pivot_root>()  may fail with any of the same errors as B<stat>(2).  "
"Additionally, it may fail with the following errors:"
msgstr ""

#.  Reconfirmed that the following error occurs on Linux 5.0 by
#.  specifying 'new_root' as "/rootfs" and 'put_old' as
#.  "/rootfs/oldrootfs", and *not* bind mounting "/rootfs" on top of
#.  itself. Of course, this is an odd situation, since a later check
#.  in the kernel code will in any case yield EINVAL if 'new_root' is
#.  not a mount point. However, when the system call was first added,
#.  'new_root' was not required to be a mount point. So, this
#.  error is nowadays probably just the result of crufty accumulation.
#.  This error can also occur if we bind mount "/" on top of itself
#.  and try to specify "/" as the 'new' (again, an odd situation). So,
#.  the EBUSY check in the kernel does still seem necessary to prevent
#.  that case.  Furthermore, the "or put_old" piece is probably
#.  redundant text (although the check is in the kernel), since,
#.  in another check, 'put_old' is required to be under 'new_root'.
#. type: Plain text
#: build/C/man2/pivot_root.2:127
msgid ""
"I<new_root> or I<put_old> is on the current root mount.  (This error covers "
"the pathological case where I<new_root> is I<\"/\">.)"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:131
msgid "I<new_root> is not a mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:134
msgid "I<put_old> is not at or underneath I<new_root>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:139
msgid ""
"The current root directory is not a mount point (because of an earlier "
"B<chroot>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:142
msgid "The current root is on the rootfs (initial ramfs) mount; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:149
msgid ""
"Either the mount point at I<new_root>, or the parent mount of that mount "
"point, has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:154
msgid "I<put_old> is a mount point and has the propagation type B<MS_SHARED>."
msgstr ""

#. type: TP
#: build/C/man2/pivot_root.2:154
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:157
msgid "I<new_root> or I<put_old> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:162
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:165
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:168
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:174
msgid ""
"A command-line interface for this system call is provided by "
"B<pivot_root>(8)."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:184
msgid ""
"B<pivot_root>()  allows the caller to switch to a new root filesystem while "
"at the same time placing the old root mount at a location under I<new_root> "
"from where it can subsequently be unmounted.  (The fact that it moves all "
"processes that have a root directory or current working directory on the old "
"root directory to the new root frees the old root directory of users, "
"allowing the old root mount to be unmounted more easily.)"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:194
msgid ""
"One use of B<pivot_root>()  is during system startup, when the system mounts "
"a temporary root filesystem (e.g., an B<initrd>(4)), then mounts the real "
"root filesystem, and eventually turns the latter into the root directory of "
"all relevant processes and threads.  A modern use is to set up a root "
"filesystem during the creation of a container."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:203
msgid ""
"The fact that B<pivot_root>()  modifies process root and current working "
"directories in the manner noted in DESCRIPTION is necessary in order to "
"prevent kernel threads from keeping the old root mount busy with their root "
"and current working directories, even if they never access the filesystem in "
"any way."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:216
msgid ""
"The rootfs (initial ramfs) cannot be B<pivot_root>()ed.  The recommended "
"method of changing the root filesystem in this case is to delete everything "
"in rootfs, overmount rootfs with the new root, attach "
"I<stdin>/I<stdout>/I<stderr> to the new I</dev/console>, and exec the new "
"B<init>(1).  Helper programs for this process exist; see B<switch_root>(8)."
msgstr ""

#. type: SS
#: build/C/man2/pivot_root.2:216
#, no-wrap
msgid "pivot_root(\".\", \".\")"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:223
msgid ""
"I<new_root> and I<put_old> may be the same directory.  In particular, the "
"following sequence allows a pivot-root operation without needing to create "
"and remove a temporary directory:"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:229
#, no-wrap
msgid ""
"chdir(new_root);\n"
"pivot_root(\".\", \".\");\n"
"umount2(\".\", MNT_DETACH);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:250
msgid ""
"This sequence succeeds because the B<pivot_root>()  call stacks the old root "
"mount point on top of the new root mount point at I</>.  At that point, the "
"calling process's root directory and current working directory refer to the "
"new root mount point (I<new_root>).  During the subsequent B<umount>()  "
"call, resolution of I<\".\"> starts with I<new_root> and then moves up the "
"list of mounts stacked at I</>, with the result that old root mount point is "
"unmounted."
msgstr ""

#. type: SS
#: build/C/man2/pivot_root.2:250
#, no-wrap
msgid "Historical notes"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:252
msgid "For many years, this manual page carried the following text:"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:265
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:273
msgid ""
"This text, written before the system call implementation was even finalized "
"in the kernel, was probably intended to warn users at that time that the "
"implementation might change before final release.  However, the behavior "
"stated in DESCRIPTION has remained consistent since this system call was "
"first implemented and will not change now."
msgstr ""

#.  FIXME
#.  Would it be better, because simpler, to use unshare(2)
#.  rather than clone(2) in the example below?
#. type: Plain text
#: build/C/man2/pivot_root.2:285
msgid ""
"The program below demonstrates the use of B<pivot_root>()  inside a mount "
"namespace that is created using B<clone>(2).  After pivoting to the root "
"directory named in the program's first command-line argument, the child "
"created by B<clone>(2)  then executes the program named in the remaining "
"command-line arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:290
msgid ""
"We demonstrate the program by creating a directory that will serve as the "
"new root filesystem and placing a copy of the (statically linked)  "
"B<busybox>(1)  executable in that directory."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:308
#, no-wrap
msgid ""
"$ B<mkdir /tmp/rootfs>\n"
"$ B<ls -id /tmp/rootfs>    # Show inode number of new root directory\n"
"319459 /tmp/rootfs\n"
"$ B<cp $(which busybox) /tmp/rootfs>\n"
"$ B<PS1=\\(aqbbsh$ \\(aq sudo ./pivot_root_demo /tmp/rootfs /busybox sh>\n"
"bbsh$ B<PATH=/>\n"
"bbsh$ B<busybox ln busybox ln>\n"
"bbsh$ B<ln busybox echo>\n"
"bbsh$ B<ln busybox ls>\n"
"bbsh$ B<ls>\n"
"busybox  echo     ln       ls\n"
"bbsh$ B<ls -id />          # Compare with inode number above\n"
"319459 /\n"
"bbsh$ B<echo \\(aqhello world\\(aq>\n"
"hello world\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:315
#, no-wrap
msgid "/* pivot_root_demo.c */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:327
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/mount.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:336
#, no-wrap
msgid ""
"static int\n"
"pivot_root(const char *new_root, const char *put_old)\n"
"{\n"
"    return syscall(SYS_pivot_root, new_root, put_old);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:338
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:346
#, no-wrap
msgid ""
"static int              /* Startup function for cloned child */\n"
"child(void *arg)\n"
"{\n"
"    char **args = arg;\n"
"    char *new_root = args[0];\n"
"    const char *put_old = \"/oldrootfs\";\n"
"    char path[PATH_MAX];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:351
#, no-wrap
msgid ""
"    /* Ensure that \\(aqnew_root\\(aq and its parent mount don\\(aqt have\n"
"       shared propagation (which would cause pivot_root() to\n"
"       return an error), and prevent propagation of mount\n"
"       events to the initial mount namespace */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:354
#, no-wrap
msgid ""
"    if (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) == -1)\n"
"        errExit(\"mount-MS_PRIVATE\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:356
#, no-wrap
msgid "    /* Ensure that \\(aqnew_root\\(aq is a mount point */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:359
#, no-wrap
msgid ""
"    if (mount(new_root, new_root, NULL, MS_BIND, NULL) == -1)\n"
"        errExit(\"mount-MS_BIND\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:361
#, no-wrap
msgid "    /* Create directory to which old root will be pivoted */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:365
#, no-wrap
msgid ""
"    snprintf(path, sizeof(path), \"%s/%s\", new_root, put_old);\n"
"    if (mkdir(path, 0777) == -1)\n"
"        errExit(\"mkdir\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:367
#, no-wrap
msgid "    /* And pivot the root filesystem */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:370
#, no-wrap
msgid ""
"    if (pivot_root(new_root, path) == -1)\n"
"        errExit(\"pivot_root\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:372
#, no-wrap
msgid "    /* Switch the current working directory to \"/\" */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:375
#, no-wrap
msgid ""
"    if (chdir(\"/\") == -1)\n"
"        errExit(\"chdir\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:377
#, no-wrap
msgid "    /* Unmount old root and remove mount point */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:382
#, no-wrap
msgid ""
"    if (umount2(put_old, MNT_DETACH) == -1)\n"
"        perror(\"umount2\");\n"
"    if (rmdir(put_old) == -1)\n"
"        perror(\"rmdir\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:384
#, no-wrap
msgid "    /* Execute the command specified in argv[1]... */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:388
#, no-wrap
msgid ""
"    execv(args[1], &args[1]);\n"
"    errExit(\"execv\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:393
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    /* Create a child process in a new mount namespace */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:398
#, no-wrap
msgid ""
"    char *stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,\n"
"                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n"
"    if (stack == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:402
#, no-wrap
msgid ""
"    if (clone(child, stack + STACK_SIZE,\n"
"                CLONE_NEWNS | SIGCHLD, &argv[1]) == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:404
#, no-wrap
msgid "    /* Parent falls through to here; wait for child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:407
#, no-wrap
msgid ""
"    if (wait(NULL) == -1)\n"
"        errExit(\"wait\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:420
msgid ""
"B<chdir>(2), B<chroot>(2), B<mount>(2), B<stat>(2), B<initrd>(4), "
"B<mount_namespaces>(7), B<pivot_root>(8), B<switch_root>(8)"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:54
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:58
msgid "B<process_vm_readv>(), B<process_vm_writev>():"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:62
msgid "B<_GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:72
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:97
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:111
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:121
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:128
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:144
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>()  "
"completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, and "
"so on.  Likewise, I<remote_iov[0]> is completely read before proceeding to "
"I<remote_iov[1]>, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:155
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:163
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:167
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: build/C/man2/process_vm_readv.2:180
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:190
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:210
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4\\ KiB) in a single remote I<iovec> "
"element.  (Instead, split the remote read into two I<remote_iov> elements "
"and have them merge back into a single write I<local_iov> entry.  The first "
"read entry goes up to the page boundary, while the second starts on the next "
"page boundary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:216
msgid ""
"Permission to read from or write to another process is governed by a ptrace "
"access mode B<PTRACE_MODE_ATTACH_REALCREDS> check; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:232
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:236
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:242
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:248
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:259
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:263
msgid "I<flags> is not 0."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:269
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:274
msgid "Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:278
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:283
msgid "No process with ID I<pid> exists."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:286
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:288
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:294
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: build/C/man2/process_vm_readv.2:302
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:310
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:313
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:323
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:330
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[0].iov_len = 20;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:337
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:341
msgid "B<readv>(2), B<writev>(2)"
msgstr ""

#. type: TH
#: build/C/man2/ptrace.2:105
#, no-wrap
msgid "PTRACE"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:108
msgid "ptrace - process trace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:111
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:114
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<,>\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:123
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:134
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:136
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:140
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:146
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:157
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:174
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:184
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:188
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:192
msgid "The value of I<request> determines the action to be performed:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:192
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:202
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:217
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT>, and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:217
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:228
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored; but see NOTES.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:228
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr ""

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: build/C/man2/ptrace.2:246
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see "
"I<E<lt>sys/user.hE<gt>>).  The word is returned as the result of the "
"B<ptrace>()  call.  Typically, the offset must be word-aligned, though this "
"might vary by architecture.  See NOTES.  (I<data> is ignored; but see "
"NOTES.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:246
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:258
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:258
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr ""

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:274
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:274
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:297
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:297
#, no-wrap
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:318
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an "
"architecture-dependent way, the type of registers to be read.  "
"B<NT_PRSTATUS> (with numerical value 1)  usually results in reading of "
"general-purpose registers.  If the CPU has, for example, floating-point "
"and/or vector registers, they can be retrieved by setting I<addr> to the "
"corresponding B<NT_foo> constant.  I<data> points to a B<struct iovec>, "
"which describes the destination buffer's location and length.  On return, "
"the kernel modifies B<iov.len> to indicate the actual number of bytes "
"returned."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:318
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr ""

#.  FIXME . In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:343
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning "
"of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:343
#, no-wrap
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:352
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:352
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:364
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:364
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:380
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:380
#, no-wrap
msgid "B<PTRACE_PEEKSIGINFO> (since Linux 3.10)"
msgstr ""

#.  commit 84c751bd4aebbaae995fe32279d3dba48327bad4
#. type: Plain text
#: build/C/man2/ptrace.2:406
msgid ""
"Retrieve I<siginfo_t> structures without removing signals from a queue.  "
"I<addr> points to a I<ptrace_peeksiginfo_args> structure that specifies the "
"ordinal position from which copying of signals should start, and the number "
"of signals to copy.  I<siginfo_t> structures are copied into the buffer "
"pointed to by I<data>.  The return value contains the number of copied "
"signals (zero indicates that there is no signal corresponding to the "
"specified ordinal position).  Within the returned I<siginfo> structures, the "
"I<si_code> field includes information (B<__SI_CHLD>, B<__SI_FAULT>, etc.) "
"that are not otherwise exposed to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:415
#, no-wrap
msgid ""
"struct ptrace_peeksiginfo_args {\n"
"    u64 off;    /* Ordinal position in queue at which\n"
"                   to start copying signals */\n"
"    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */\n"
"    s32 nr;     /* Number of signals to copy */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:423
msgid ""
"Currently, there is only one flag, B<PTRACE_PEEKSIGINFO_SHARED>, for dumping "
"signals from the process-wide signal queue.  If this flag is not set, "
"signals are read from the per-thread queue of the specified thread."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:424
#, no-wrap
msgid "B<PTRACE_GETSIGMASK> (since Linux 3.11)"
msgstr ""

#.  commit 29000caecbe87b6b66f144f72111f0d02fbbf0c1
#. type: Plain text
#: build/C/man2/ptrace.2:439
msgid ""
"Place a copy of the mask of blocked signals (see B<sigprocmask>(2))  in the "
"buffer pointed to by I<data>, which should be a pointer to a buffer of type "
"I<sigset_t>.  The I<addr> argument contains the size of the buffer pointed "
"to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:439
#, no-wrap
msgid "B<PTRACE_SETSIGMASK> (since Linux 3.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:453
msgid ""
"Change the mask of blocked signals (see B<sigprocmask>(2))  to the value "
"specified in the buffer pointed to by I<data>, which should be a pointer to "
"a buffer of type I<sigset_t>.  The I<addr> argument contains the size of the "
"buffer pointed to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:453
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:462
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:463
#, no-wrap
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr ""

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: build/C/man2/ptrace.2:471
msgid ""
"Send a B<SIGKILL> signal to the tracee if the tracer exits.  This option is "
"useful for ptrace jailers that want to ensure that tracees can never escape "
"the tracer's control."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:471
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:488
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:491
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:495 build/C/man2/ptrace.2:581 build/C/man2/ptrace.2:612
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:516
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:516
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:525
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:528
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:534
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:534
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:542
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:545
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:549
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:557
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:557
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:574
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:577
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:581
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:588
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:588
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:605
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:608
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:612
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:621
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:624
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:628
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:628
#, no-wrap
msgid "B<PTRACE_O_TRACESECCOMP> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:639
msgid ""
"Stop the tracee when a B<seccomp>(2)  B<SECCOMP_RET_TRACE> rule is "
"triggered.  A B<waitpid>(2)  by the tracer will return a I<status> value "
"such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:642
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMPE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:654
msgid ""
"While this triggers a B<PTRACE_EVENT> stop, it is similar to a "
"syscall-enter-stop.  For details, see the note on B<PTRACE_EVENT_SECCOMP> "
"below.  The seccomp event message data (from the B<SECCOMP_RET_DATA> portion "
"of the seccomp filter rule) can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:654
#, no-wrap
msgid "B<PTRACE_O_SUSPEND_SECCOMP> (since Linux 4.3)"
msgstr ""

#.  commit 13c4a90119d28cfcb6b5bdd820c233b86c2b0237
#. type: Plain text
#: build/C/man2/ptrace.2:670
msgid ""
"Suspend the tracee's seccomp protections.  This applies regardless of mode, "
"and can be used when the tracee has not yet installed seccomp filters.  That "
"is, a valid use case is to suspend a tracee's seccomp protections before "
"they are installed by the tracee, let the tracee install the filters, and "
"then clear this flag when the filters should be resumed.  Setting this "
"option requires that the tracer have the B<CAP_SYS_ADMIN> capability, not "
"have any seccomp protections installed, and not have "
"B<PTRACE_O_SUSPEND_SECCOMP> set on itself."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:671
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:698
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  For "
"B<PTRACE_EVENT_SECCOMP>, this is the B<seccomp>(2)  filter's "
"B<SECCOMP_RET_DATA> associated with the triggered rule.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:698
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:710
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:710
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:734
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:734
#, no-wrap
msgid "B<PTRACE_SET_SYSCALL> (since Linux 2.6.16)"
msgstr ""

#.  commit 3f471126ee53feb5e9b210ea2f525ed3bb9b7a7f
#.  As of 4.19-rc2
#.  commit 27aa55c5e5123fa8b8ad0156559d34d7edff58ca
#.  see change_syscall in tools/testing/selftests/seccomp/seccomp_bpf.c
#.  and also strace's linux/*/set_scno.c files.
#. type: Plain text
#: build/C/man2/ptrace.2:754
msgid ""
"When in syscall-enter-stop, change the number of the system call that is "
"about to be executed to the number specified in the I<data> argument.  The "
"I<addr> argument is ignored.  This request is currently supported only on "
"arm (and arm64, though only for backwards compatibility), but most other "
"architectures have other means of accomplishing this (usually by changing "
"the register that the userland code passed the system call number in)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:754
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr ""

#.  As at 3.7
#. type: Plain text
#: build/C/man2/ptrace.2:776
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  See the documentation on syscall-stops below.  "
"For B<PTRACE_SYSEMU_SINGLESTEP>, do the same but also singlestep if not a "
"system call.  This call is used by programs like User Mode Linux that want "
"to emulate all the tracee's system calls.  The I<data> argument is treated "
"as for B<PTRACE_CONT>.  The I<addr> argument is ignored.  These requests are "
"currently supported only on x86."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:776
#, no-wrap
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:787
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> works only on tracees attached "
"by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:787
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:796
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: build/C/man2/ptrace.2:815
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:815
#, no-wrap
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:843
msgid ""
"Stop a tracee.  If the tracee is running or sleeping in kernel space and "
"B<PTRACE_SYSCALL> is in effect, the system call is interrupted and "
"syscall-exit-stop is reported.  (The interrupted system call is restarted "
"when the tracee is restarted.)  If the tracee was already stopped by a "
"signal and B<PTRACE_LISTEN> was sent to it, the tracee stops with "
"B<PTRACE_EVENT_STOP> and I<WSTOPSIG(status)> returns the stop signal.  If "
"any other ptrace-stop is generated at the same time (for example, if a "
"signal is sent to the tracee), this ptrace-stop happens.  If none of the "
"above applies (for example, if the tracee is running in user space), it "
"stops with B<PTRACE_EVENT_STOP> with I<WSTOPSIG(status)> == B<SIGTRAP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:843
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr ""

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: build/C/man2/ptrace.2:871
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:877
msgid ""
"Permission to perform a B<PTRACE_ATTACH> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:877
#, no-wrap
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr ""

#
#.  Noted by Dmitry Levin:
#
#.      PTRACE_SEIZE was introduced by commit v3.1-rc1~308^2~28, but
#.      it had to be used along with a temporary flag PTRACE_SEIZE_DEVEL,
#.      which was removed later by commit v3.4-rc1~109^2~20.
#
#.      That is, [before] v3.4 we had a test mode of PTRACE_SEIZE API,
#.      which was not compatible with the current PTRACE_SEIZE API introduced
#.      in Linux 3.4.
#. type: Plain text
#: build/C/man2/ptrace.2:931
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Group-stops are reported as B<PTRACE_EVENT_STOP> and "
"I<WSTOPSIG(status)> returns the stop signal.  Automatically attached "
"children stop with B<PTRACE_EVENT_STOP> and I<WSTOPSIG(status)> returns "
"B<SIGTRAP> instead of having B<SIGSTOP> signal delivered to them.  "
"B<execve>(2)  does not deliver an extra B<SIGTRAP>.  Only a B<PTRACE_SEIZE>d "
"process can accept B<PTRACE_INTERRUPT> and B<PTRACE_LISTEN> commands.  The "
"\"seized\" behavior just described is inherited by children that are "
"automatically attached using B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, "
"and B<PTRACE_O_TRACECLONE>.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:938
msgid ""
"Permission to perform a B<PTRACE_SEIZE> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:938
#, no-wrap
msgid "B<PTRACE_SECCOMP_GET_FILTER> (since Linux 4.4)"
msgstr ""

#.  commit f8e529ed941ba2bbcbf310b575d968159ce7e895
#. type: Plain text
#: build/C/man2/ptrace.2:943
msgid "This operation allows the tracer to dump the tracee's classic BPF filters."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:952
msgid ""
"I<addr> is an integer specifying the index of the filter to be dumped.  The "
"most recently installed filter has the index 0.  If I<addr> is greater than "
"the number of installed filters, the operation fails with the error "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:958
msgid ""
"I<data> is either a pointer to a I<struct sock_filter> array that is large "
"enough to store the BPF program, or NULL if the program is not to be stored."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:966
msgid ""
"Upon success, the return value is the number of instructions in the BPF "
"program.  If I<data> was NULL, then this return value can be used to "
"correctly size the I<struct sock_filter> array passed in a subsequent call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:976
msgid ""
"This operation fails with the error B<EACCES> if the caller does not have "
"the B<CAP_SYS_ADMIN> capability or if the caller is in strict or filter "
"seccomp mode.  If the filter referred to by I<addr> is not a classic BPF "
"filter, the operation fails with the error B<EMEDIUMTYPE>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:982
msgid ""
"This operation is available if the kernel was configured with both the "
"B<CONFIG_SECCOMP_FILTER> and the B<CONFIG_CHECKPOINT_RESTORE> options."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:982
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:992
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:992
#, no-wrap
msgid "B<PTRACE_GET_THREAD_AREA> (since Linux 2.6.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1009
msgid ""
"This operation performs a similar task to B<get_thread_area>(2).  It reads "
"the TLS entry in the GDT whose index is given in I<addr>, placing a copy of "
"the entry into the I<struct user_desc> pointed to by I<data>.  (By contrast "
"with B<get_thread_area>(2), the I<entry_number> of the I<struct user_desc> "
"is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1009
#, no-wrap
msgid "B<PTRACE_SET_THREAD_AREA> (since Linux 2.6.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1027
msgid ""
"This operation performs a similar task to B<set_thread_area>(2).  It sets "
"the TLS entry in the GDT whose index is given in I<addr>, assigning it the "
"data supplied in the I<struct user_desc> pointed to by I<data>.  (By "
"contrast with B<set_thread_area>(2), the I<entry_number> of the I<struct "
"user_desc> is ignored; in other words, this ptrace operation can't be used "
"to allocate a free TLS entry.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1027
#, no-wrap
msgid "B<PTRACE_GET_SYSCALL_INFO> (since Linux 5.3)"
msgstr ""

#.  commit 201766a20e30f982ccfe36bebfad9602c3ff574a
#. type: Plain text
#: build/C/man2/ptrace.2:1048
msgid ""
"Retrieve information about the system call that caused the stop.  The "
"information is placed into the buffer pointed by the I<data> argument, which "
"should be a pointer to a buffer of type I<struct ptrace_syscall_info>.  The "
"I<addr> argument contains the size of the buffer pointed to by the I<data> "
"argument (i.e., I<sizeof(struct ptrace_syscall_info)>).  The return value "
"contains the number of bytes available to be written by the kernel.  If the "
"size of the data to be written by the kernel exceeds the size specified by "
"the I<addr> argument, the output data is truncated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1052
msgid "The I<ptrace_syscall_info> structure contains the following fields:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1081
#, no-wrap
msgid ""
"struct ptrace_syscal_info {\n"
"    __u8 op;        /* Type of system call stop */\n"
"    __u32 arch;     /* AUDIT_ARCH_* value; see seccomp(2) */\n"
"    __u64 instruction_pointer; /* CPU instruction pointer */\n"
"    __u64 stack_pointer;    /* CPU stack pointer */\n"
"    union {\n"
"        struct {    /* op == PTRACE_SYSCALL_INFO_ENTRY */\n"
"            __u64 nr;       /* System call number */\n"
"            __u64 args[6];  /* System call arguments */\n"
"        } entry;\n"
"        struct {    /* op == PTRACE_SYSCALL_INFO_EXIT */\n"
"            __s64 rval;     /* System call return value */\n"
"            __u8 is_error;  /* System call error flag;\n"
"                               Boolean: does rval contain\n"
"                               an error value (-ERRCODE) or\n"
"                               a nonerror return value? */\n"
"        } exit;\n"
"        struct {    /* op == PTRACE_SYSCALL_INFO_SECCOMP */\n"
"            __u64 nr;       /* System call number */\n"
"            __u64 args[6];  /* System call arguments */\n"
"            __u32 ret_data; /* SECCOMP_RET_DATA portion\n"
"                               of SECCOMP_RET_TRACE\n"
"                               return value */\n"
"        } seccomp;\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1095
msgid ""
"The I<op>, I<arch>, I<instruction_pointer>, and I<stack_pointer> fields are "
"defined for all kinds of ptrace system call stops.  The rest of the "
"structure is a union; one should read only those fields that are meaningful "
"for the kind of system call stop specified by the I<op> field."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1102
msgid ""
"The I<op> field has one of the following values (defined in "
"I<E<lt>linux/ptrace.hE<gt>)> indicating what type of stop occurred and which "
"part of the union is filled:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1103
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_ENTRY>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1109
msgid ""
"The I<entry> component of the union contains information relating to a "
"system call entry stop."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1109
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1115
msgid ""
"The I<exit> component of the union contains information relating to a system "
"call exit stop."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1115
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_SECCOMP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1122
msgid ""
"The I<seccomp> component of the union contains information relating to a "
"B<PTRACE_EVENT_SECCOMP> stop."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1122
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1125
msgid "No component of the union contains relevant information."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1127
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1136
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1145
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term "
"\"signal-delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1157
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls "
"(syscall-exit-stop is not generated prior to death by B<SIGKILL>).  The net "
"effect is that B<SIGKILL> always kills the process (all its threads), even "
"if some threads of the process are ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1162
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1166
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1181
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>, depending on the "
"kernel version; see BUGS below), and when threads are torn down on "
"B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1206
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  "
"I<waitpid(WNOHANG)> may return 0 instead.  In other words, the tracee may be "
"\"not yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1220
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1220
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1242
msgid ""
"A tracee can be in two states: running or stopped.  For the purposes of "
"ptrace, a tracee which is blocked in a system call (such as B<read>(2), "
"B<pause>(2), etc.)  is nevertheless considered to be running, even if the "
"tracee is blocked for a long time.  The state of the tracee after "
"B<PTRACE_LISTEN> is somewhat of a gray area: it is not in any ptrace-stop "
"(ptrace commands won't work on it, and it will deliver B<waitpid>(2)  "
"notifications), but it also may be considered \"stopped\" because it is not "
"executing instructions (is not scheduled), and if it was in group-stop "
"before B<PTRACE_LISTEN>, it will not respond to signals until B<SIGCONT> is "
"received."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1246
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1258
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  "
"Ptrace-stops can be further subdivided into I<signal-delivery-stop>, "
"I<group-stop>, I<syscall-stop>, I<PTRACE_EVENT stops>, and so on.  These "
"stopped states are described in detail below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1263
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1265
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: build/C/man2/ptrace.2:1277
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1285
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1292
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1300
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1310
#, no-wrap
msgid ""
"errno = 0;\n"
"ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"if (errno == ESRCH) {\n"
"    /* tracee is dead */\n"
"    r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"    /* r can still be 0 here! */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1334
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, "
"group-stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because "
"it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1334
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1354
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1368
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below "
"for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be "
"a group-stop; see below."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1368
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1371
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1373
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1386
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1392
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1408
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case, system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few system calls which use a "
"different mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  "
"Even system calls (such as B<poll>(2))  which are not restartable after "
"signal are restarted after signal is suppressed; however, kernel bugs exist "
"which cause some system calls to fail with B<EINTR> even though no "
"observable signal is injected to the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1419
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than "
"signal-delivery-stop are not guaranteed to inject a signal, even if I<sig> "
"is nonzero.  No error is reported; a nonzero I<sig> may simply be ignored.  "
"Ptrace users should not try to \"create a new signal\" this way: use "
"B<tgkill>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1426
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1428
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1434
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1454
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before "
"signal-delivery-stop.  The tracer can't suppress this side effect (it can "
"only suppress signal injection, which only causes the B<SIGCONT> handler to "
"not be executed in the tracee, if such a handler is installed).  In fact, "
"waking up from group-stop may be followed by signal-delivery-stop for "
"signal(s)  I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> "
"was delivered.  In other words, B<SIGCONT> may be not the first signal "
"observed by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1458
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: build/C/man2/ptrace.2:1468
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1485
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1485
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1497
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1506
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1508
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1529
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1539
msgid ""
"If tracee was attached using B<PTRACE_SEIZE>, group-stop is indicated by "
"B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == PTRACE_EVENT_STOP>.  This "
"allows detection of group-stops without requiring an extra "
"B<PTRACE_GETSIGINFO> call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1548
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1562
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1573
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1573
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1579
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter "
"ptrace-stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1596
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP> (or "
"for B<PTRACE_EVENT_STOP>, returns the stopping signal if tracee is in a "
"group-stop).  An additional bit is set in the higher byte of the status "
"word: the value I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1598
#, no-wrap
msgid "    ((PTRACE_EVENT_fooE<lt>E<lt>8) | SIGTRAP).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1600
msgid "The following events exist:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1600
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1613
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1613
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1621
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1621
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1625
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1625
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1635
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1641
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1641
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1648
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1648
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1664
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1664
#, no-wrap
msgid "B<PTRACE_EVENT_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1671
msgid ""
"Stop induced by B<PTRACE_INTERRUPT> command, or group-stop, or initial "
"ptrace-stop when a new child is attached (only if attached using "
"B<PTRACE_SEIZE>)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1671
#, no-wrap
msgid "B<PTRACE_EVENT_SECCOMP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1684
msgid ""
"Stop triggered by a B<seccomp>(2)  rule on tracee syscall entry when "
"B<PTRACE_O_TRACESECCOMP> has been set by the tracer.  The seccomp event "
"message data (from the B<SECCOMP_RET_DATA> portion of the seccomp filter "
"rule) can be retrieved with B<PTRACE_GETEVENTMSG>.  The semantics of this "
"stop are described in detail in a separate section below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1696
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1696
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1723
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL> or B<PTRACE_SYSEMU>, the "
"tracee enters syscall-enter-stop just prior to entering any system call "
"(which will not be executed if the restart was using B<PTRACE_SYSEMU>, "
"regardless of any change made to registers at this point or how the tracee "
"is restarted after this stop).  No matter which method caused the "
"syscall-entry-stop, if the tracer restarts the tracee with "
"B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when the system call "
"is finished, or if it is interrupted by a signal.  (That is, "
"signal-delivery-stop never happens between syscall-enter-stop and "
"syscall-exit-stop; it happens I<after> syscall-exit-stop.).  If the tracee "
"is continued using any other method (including B<PTRACE_SYSEMU>), no "
"syscall-exit-stop occurs.  Note that all mentions B<PTRACE_SYSEMU> apply "
"equally to B<PTRACE_SYSEMU_SINGLESTEP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1740
msgid ""
"However, even if the tracee was continued using B<PTRACE_SYSCALL>, it is not "
"guaranteed that the next stop will be a syscall-exit-stop.  Other "
"possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop "
"(including seccomp stops), exit (if it entered B<_exit>(2)  or "
"B<exit_group>(2)), be killed by B<SIGKILL>, or die silently (if it is a "
"thread group leader, the B<execve>(2)  happened in another thread, and that "
"thread is not traced by the same tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1755
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1761
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1761
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1773
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1773
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1777
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1777
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1780
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1785
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1808
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in "
"syscall-enter-stop.  Since B<SIGTRAP> (like any other signal) always happens "
"I<after> syscall-exit-stop, and at this point I<rax> almost never contains "
"-B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not "
"syscall-enter-stop\"; in other words, it looks like a \"stray "
"syscall-exit-stop\" and can be detected this way.  But such detection is "
"fragile and is best avoided."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1814
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1829
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as "
"syscall-exit-stop or vice versa.  In general, a syscall-enter-stop is always "
"followed by syscall-exit-stop, B<PTRACE_EVENT> stop, or the tracee's death; "
"no other kinds of ptrace-stop can occur in between.  However, note that "
"seccomp stops (see below) can cause syscall-exit-stops, without preceding "
"syscall-entry-stops.  If seccomp is in use, care needs to be taken not to "
"misinterpret such stops as syscall-entry-stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1834
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1847
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1847
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (Linux 3.5 to 4.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1855
msgid ""
"The behavior of B<PTRACE_EVENT_SECCOMP> stops and their interaction with "
"other kinds of ptrace stops has changed between kernel versions.  This "
"documents the behavior from their introduction until Linux 4.7 (inclusive).  "
"The behavior in later kernel versions is documented in the next section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1865
msgid ""
"A B<PTRACE_EVENT_SECCOMP> stop occurs whenever a B<SECCOMP_RET_TRACE> rule "
"is triggered.  This is independent of which methods was used to restart the "
"system call.  Notably, seccomp still runs even if the tracee was restarted "
"using B<PTRACE_SYSEMU> and this system call is unconditionally skipped."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1884
msgid ""
"Restarts from this stop will behave as if the stop had occurred right before "
"the system call in question.  In particular, both B<PTRACE_SYSCALL> and "
"B<PTRACE_SYSEMU> will normally cause a subsequent syscall-entry-stop.  "
"However, if after the B<PTRACE_EVENT_SECCOMP> the system call number is "
"negative, both the syscall-entry-stop and the system call itself will be "
"skipped.  This means that if the system call number is negative after a "
"B<PTRACE_EVENT_SECCOMP> and the tracee is restarted using B<PTRACE_SYSCALL>, "
"the next observed stop will be a syscall-exit-stop, rather than the "
"syscall-entry-stop that might have been expected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1884
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (since Linux 4.8)"
msgstr ""

#.  commit 93e35efb8de45393cf61ed07f7b407629bf698ea
#. type: Plain text
#: build/C/man2/ptrace.2:1895
msgid ""
"Starting with Linux 4.8, the B<PTRACE_EVENT_SECCOMP> stop was reordered to "
"occur between syscall-entry-stop and syscall-exit-stop.  Note that seccomp "
"no longer runs (and no B<PTRACE_EVENT_SECCOMP> will be reported) if the "
"system call is skipped due to B<PTRACE_SYSEMU>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1906
msgid ""
"Functionally, a B<PTRACE_EVENT_SECCOMP> stop functions comparably to a "
"syscall-entry-stop (i.e., continuations using B<PTRACE_SYSCALL> will cause "
"syscall-exit-stops, the system call number may be changed and any other "
"modified registers are visible to the to-be-executed system call as well).  "
"Note that there may be, but need not have been a preceding "
"syscall-entry-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1917
msgid ""
"After a B<PTRACE_EVENT_SECCOMP> stop, seccomp will be rerun, with a "
"B<SECCOMP_RET_TRACE> rule now functioning the same as a "
"B<SECCOMP_RET_ALLOW>.  Specifically, this means that if registers are not "
"modified during the B<PTRACE_EVENT_SECCOMP> stop, the system call will then "
"be allowed."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1917
#, no-wrap
msgid "PTRACE_SINGLESTEP stops"
msgstr ""

#
#.  FIXME .
#.  document stops occurring with PTRACE_SINGLESTEP
#. type: Plain text
#: build/C/man2/ptrace.2:1923
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1923
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1933
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1938
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1951
#, no-wrap
msgid ""
"ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1964
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1966
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1968
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1977
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1980
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1982
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2003
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2003
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2005
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2007
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2009 build/C/man2/ptrace.2:2862
msgid "or"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2011
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#
#.  FIXME Describe how to attach to a thread which is already group-stopped.
#. type: Plain text
#: build/C/man2/ptrace.2:2035
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2042
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2054
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process.  If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2056
msgid "The request"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2058
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2064
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2066
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2069
msgid ""
"and allow the parent (which is our tracer now) to observe our "
"signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2093
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2095
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2097
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2105
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME Describe how to detach from a group-stopped tracee so that it
#.  doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: build/C/man2/ptrace.2:2129
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2137
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from "
"signal-delivery-stop, the pending signal is injected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2137
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: build/C/man2/ptrace.2:2156
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2166
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2174
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2180
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2201
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2204
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2224
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0.)  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2230
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2238
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2240
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2244
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2255
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2283
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, and if the tracee was B<PTRACE_ATTACH>ed rather that "
"B<PTRACE_SEIZE>d, the kernel delivers an extra B<SIGTRAP> to the tracee "
"after B<execve>(2)  returns.  This is an ordinary signal (similar to one "
"which can be generated by I<kill -TRAP>), not a special kind of "
"ptrace-stop.  Employing B<PTRACE_GETSIGINFO> for this signal returns "
"I<si_code> set to 0 (I<SI_USER>).  This signal may be blocked by signal "
"mask, and thus may be delivered (much) later."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2304
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option or using B<PTRACE_SEIZE> and thus "
"suppressing this extra B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2304
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2311
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2314
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2316
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2324
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2332
msgid ""
"On success, the B<PTRACE_PEEK*> requests return the requested data (but see "
"NOTES), the B<PTRACE_SECCOMP_GET_FILTER> request returns the number of "
"instructions in the BPF program, and other requests return zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2342
msgid ""
"On error, all requests return -1, and I<errno> is set appropriately.  Since "
"the value returned by a successful B<PTRACE_PEEK*> request may be -1, the "
"caller must clear I<errno> before the call, and then check it afterward to "
"determine whether or not an error occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2346
msgid "(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2357
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2360
msgid "An attempt was made to set an invalid option."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2367
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a "
"word-alignment violation, or an invalid signal was specified during a "
"restart request."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2380
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(1)  (PID 1)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2385
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2387
msgid "SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2402
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr ""

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: build/C/man2/ptrace.2:2407
msgid ""
"In Linux kernels before 2.6.26, B<init>(1), the process with PID 1, may not "
"be traced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2410
msgid ""
"A tracees parent continues to be the tracer even if that tracer calls "
"B<execve>(2)."
msgstr ""

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: build/C/man2/ptrace.2:2417
msgid ""
"The layout of the contents of memory and the USER area are quite "
"operating-system- and architecture-specific.  The offset supplied, and the "
"data returned, might not entirely match with the definition of I<struct "
"user>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2420
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/ptrace.2:2431
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs significantly on other flavors of UNIX.  In any case, "
"use of B<ptrace>()  is highly specific to the operating system and "
"architecture."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2431
#, no-wrap
msgid "Ptrace access mode checking"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2446
msgid ""
"Various parts of the kernel-user-space API (not just B<ptrace>()  "
"operations), require so-called \"ptrace access mode\" checks, whose outcome "
"determines whether an operation is permitted (or, in a few cases, causes a "
"\"read\" operation to return sanitized data).  These checks are performed in "
"cases where one process can inspect sensitive information about, or in some "
"cases modify the state of, another process.  The checks are based on factors "
"such as the credentials and capabilities of the two processes, whether or "
"not the \"target\" process is dumpable, and the results of checks performed "
"by any enabled Linux Security Module (LSM)\\(emfor example, SELinux, Yama, "
"or Smack\\(emand by the commoncap LSM (which is always invoked)."
msgstr ""

#.  commit 006ebb40d3d65338bd74abb03b945f8d60e362bd
#. type: Plain text
#: build/C/man2/ptrace.2:2451
msgid ""
"Prior to Linux 2.6.27, all access checks were of a single type.  Since Linux "
"2.6.27, two access mode levels are distinguished:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2451
#, no-wrap
msgid "B<PTRACE_MODE_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2467
msgid ""
"For \"read\" operations or other operations that are less dangerous, such "
"as: B<get_robust_list>(2); B<kcmp>(2); reading I</proc/[pid]/auxv>, "
"I</proc/[pid]/environ>, or I</proc/[pid]/stat>; or B<readlink>(2)  of a "
"I</proc/[pid]/ns/*> file."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2467
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH>"
msgstr ""

#
#.  Regarding the above description of the distinction between
#.  PTRACE_MODE_READ and PTRACE_MODE_ATTACH, Stephen Smalley notes:
#
#.      That was the intent when the distinction was introduced, but it doesn't
#.      appear to have been properly maintained, e.g. there is now a common
#.      helper lock_trace() that is used for
#.      /proc/pid/{stack,syscall,personality} but checks PTRACE_MODE_ATTACH, and
#.      PTRACE_MODE_ATTACH is also used in timerslack_ns_write/show().  Likely
#.      should review and make them consistent.  There was also some debate
#.      about proper handling of /proc/pid/fd.  Arguably that one might belong
#.      back in the _ATTACH camp.
#. type: Plain text
#: build/C/man2/ptrace.2:2490
msgid ""
"For \"write\" operations, or other operations that are more dangerous, such "
"as: ptrace attaching (B<PTRACE_ATTACH>)  to another process or calling "
"B<process_vm_writev>(2).  (B<PTRACE_MODE_ATTACH> was effectively the default "
"before Linux 2.6.27.)"
msgstr ""

#.  commit caaee6234d05a58c5b4d05e7bf766131b810a657
#. type: Plain text
#: build/C/man2/ptrace.2:2495
msgid ""
"Since Linux 4.5, the above access mode checks are combined (ORed) with one "
"of the following modifiers:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2495
#, no-wrap
msgid "B<PTRACE_MODE_FSCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2500
msgid ""
"Use the caller's filesystem UID and GID (see B<credentials>(7))  or "
"effective capabilities for LSM checks."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2500
#, no-wrap
msgid "B<PTRACE_MODE_REALCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2504
msgid ""
"Use the caller's real UID and GID or permitted capabilities for LSM checks.  "
"This was effectively the default before Linux 4.5."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2508
msgid ""
"Because combining one of the credential modifiers with one of the "
"aforementioned access modes is typical, some macros are defined in the "
"kernel sources for the combinations:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2508
#, no-wrap
msgid "B<PTRACE_MODE_READ_FSCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2512
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_FSCREDS>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2512
#, no-wrap
msgid "B<PTRACE_MODE_READ_REALCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2516
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_REALCREDS>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2516
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_FSCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2520
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2520
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_REALCREDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2524
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2526
msgid "One further modifier can be ORed with the access mode:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2526
#, no-wrap
msgid "B<PTRACE_MODE_NOAUDIT> (since Linux 3.3)"
msgstr ""

#.  commit 69f594a38967f4540ce7a29b3fd214e68a8330bd
#.  Just for /proc/pid/stat
#. type: Plain text
#: build/C/man2/ptrace.2:2540
msgid ""
"Don't audit this access mode check.  This modifier is employed for ptrace "
"access mode checks (such as checks when reading I</proc/[pid]/stat>)  that "
"merely cause the output to be filtered or sanitized, rather than causing an "
"error to be returned to the caller.  In these cases, accessing the file is "
"not a security violation and there is no reason to generate a security audit "
"record.  This modifier suppresses the generation of such an audit record for "
"the particular access check."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2551
msgid ""
"Note that all of the B<PTRACE_MODE_*> constants described in this subsection "
"are kernel-internal, and not visible to user space.  The constant names are "
"mentioned here in order to label the various kinds of ptrace access mode "
"checks that are performed for various system calls and accesses to various "
"pseudofiles (e.g., under I</proc>).  These names are used in other manual "
"pages to provide a simple shorthand for labeling the different kernel "
"checks."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2560
msgid ""
"The algorithm employed for ptrace access mode checking determines whether "
"the calling process is allowed to perform the corresponding action on the "
"target process.  (In the case of opening I</proc/[pid]> files, the \"calling "
"process\" is the one opening the file, and the process with the "
"corresponding PID is the \"target process\".)  The algorithm is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2563
msgid ""
"If the calling thread and the target thread are in the same thread group, "
"access is always allowed."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2572
msgid ""
"If the access mode specifies B<PTRACE_MODE_FSCREDS>, then, for the check in "
"the next step, employ the caller's filesystem UID and GID.  (As noted in "
"B<credentials>(7), the filesystem UID and GID almost always have the same "
"values as the corresponding effective IDs.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2580
msgid ""
"Otherwise, the access mode specifies B<PTRACE_MODE_REALCREDS>, so use the "
"caller's real UID and GID for the checks in the next step.  (Most APIs that "
"check the caller's UID and GID use the effective IDs.  For historical "
"reasons, the B<PTRACE_MODE_REALCREDS> check uses the real IDs instead.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2584 build/C/man2/ptrace.2:2631
msgid "Deny access if I<neither> of the following is true:"
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2585 build/C/man2/ptrace.2:2591 build/C/man2/ptrace.2:2632 build/C/man2/ptrace.2:2637 build/C/man2/quotactl.2:795 build/C/man2/quotactl.2:800 build/C/man2/quotactl.2:805 build/C/man2/splice.2:213 build/C/man2/splice.2:217 build/C/man2/splice.2:220
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2591
msgid ""
"The real, effective, and saved-set user IDs of the target match the caller's "
"user ID, I<and> the real, effective, and saved-set group IDs of the target "
"match the caller's group ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2595
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the user namespace of the "
"target."
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2596
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2606
msgid ""
"Deny access if the target process \"dumpable\" attribute has a value other "
"than 1 (B<SUID_DUMP_USER>; see the discussion of B<PR_SET_DUMPABLE> in "
"B<prctl>(2)), and the caller does not have the B<CAP_SYS_PTRACE> capability "
"in the user namespace of the target process."
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2606
#, no-wrap
msgid "5."
msgstr ""

#.  (in cap_ptrace_access_check()):
#. type: Plain text
#: build/C/man2/ptrace.2:2614
msgid ""
"The kernel LSM I<security_ptrace_access_check>()  interface is invoked to "
"see if ptrace access is permitted.  The results depend on the LSM(s).  The "
"implementation of this interface in the commoncap LSM performs the following "
"steps:"
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2615
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2627
msgid ""
"If the access mode includes B<PTRACE_MODE_FSCREDS>, then use the caller's "
"I<effective> capability set in the following check; otherwise (the access "
"mode specifies B<PTRACE_MODE_REALCREDS>, so) use the caller's I<permitted> "
"capability set."
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2627
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2637
msgid ""
"The caller and the target process are in the same user namespace, and the "
"caller's capabilities are a superset of the target process's I<permitted> "
"capabilities."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2641
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the target process's user "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2647
msgid ""
"Note that the commoncap LSM does not distinguish between B<PTRACE_MODE_READ> "
"and B<PTRACE_MODE_ATTACH>."
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:2648
#, no-wrap
msgid "6."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/ptrace.2:2654
msgid ""
"If access has not been denied by any of the preceding steps, then access is "
"allowed."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2654
#, no-wrap
msgid "/proc/sys/kernel/yama/ptrace_scope"
msgstr ""

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#. type: Plain text
#: build/C/man2/ptrace.2:2673
msgid ""
"On systems with the Yama Linux Security Module (LSM) installed (i.e., the "
"kernel was configured with B<CONFIG_SECURITY_YAMA>), the "
"I</proc/sys/kernel/yama/ptrace_scope> file (available since Linux 3.4)  can "
"be used to restrict the ability to trace a process with B<ptrace>()  (and "
"thus also the ability to use tools such as B<strace>(1)  and B<gdb>(1)).  "
"The goal of such restrictions is to prevent attack escalation whereby a "
"compromised process can ptrace-attach to other sensitive processes (e.g., a "
"GPG agent or an SSH session) owned by the user in order to gain additional "
"credentials that may exist in memory and thus expand the scope of the "
"attack."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2675
msgid "More precisely, the Yama LSM limits two types of operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2682
msgid ""
"Any operation that performs a ptrace access mode B<PTRACE_MODE_ATTACH> "
"check\\(emfor example, B<ptrace>()  B<PTRACE_ATTACH>.  (See the \"Ptrace "
"access mode checking\" discussion above.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2685
msgid "B<ptrace>()  B<PTRACE_TRACEME>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2691
msgid ""
"A process that has the B<CAP_SYS_PTRACE> capability can update the "
"I</proc/sys/kernel/yama/ptrace_scope> file with one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2691
#, no-wrap
msgid "0 (\"classic ptrace permissions\")"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2696
msgid ""
"No additional restrictions on operations that perform B<PTRACE_MODE_ATTACH> "
"checks (beyond those imposed by the commoncap and other LSMs)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2700 build/C/man2/ptrace.2:2729
msgid "The use of B<PTRACE_TRACEME> is unchanged."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2700
#, no-wrap
msgid "1 (\"restricted ptrace\") [default value]"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2711
msgid ""
"When performing an operation that requires a B<PTRACE_MODE_ATTACH> check, "
"the calling process must either have the B<CAP_SYS_PTRACE> capability in the "
"user namespace of the target process or it must have a predefined "
"relationship with the target process.  By default, the predefined "
"relationship is that the target process must be a descendant of the caller."
msgstr ""

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#. type: Plain text
#: build/C/man2/ptrace.2:2725
msgid ""
"A target process can employ the B<prctl>(2)  B<PR_SET_PTRACER> operation to "
"declare an additional PID that is allowed to perform B<PTRACE_MODE_ATTACH> "
"operations on the target.  See the kernel source file "
"I<Documentation/admin-guide/LSM/Yama.rst> (or "
"I<Documentation/security/Yama.txt> before Linux 4.13)  for further details."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2729
#, no-wrap
msgid "2 (\"admin-only attach\")"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2737
msgid ""
"Only processes with the B<CAP_SYS_PTRACE> capability in the user namespace "
"of the target process may perform B<PTRACE_MODE_ATTACH> operations or trace "
"children that employ B<PTRACE_TRACEME>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:2737
#, no-wrap
msgid "3 (\"no attach\")"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2743
msgid ""
"No process may perform B<PTRACE_MODE_ATTACH> operations or trace children "
"that employ B<PTRACE_TRACEME>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2745
msgid "Once this value has been written to the file, it cannot be changed."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: build/C/man2/ptrace.2:2760
msgid ""
"With respect to values 1 and 2, note that creating a new user namespace "
"effectively removes the protection offered by Yama.  This is because a "
"process in the parent user namespace whose effective UID matches the UID of "
"the creator of a child namespace has all capabilities (including "
"B<CAP_SYS_PTRACE>)  when performing operations within the child user "
"namespace (and further-removed descendants of that namespace).  "
"Consequently, when a process tries to use user namespaces to sandbox itself, "
"it inadvertently weakens the protections offered by the Yama LSM."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:2760
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2772
msgid ""
"At the system call level, the B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>, and "
"B<PTRACE_PEEKUSER> requests have a different API: they store the result at "
"the address specified by the I<data> parameter, and the return value is the "
"error flag.  The glibc wrapper function provides the API given in "
"DESCRIPTION above, with the result being returned via the function return "
"value."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2783
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2786
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME . need to test/verify this scenario
#. type: Plain text
#: build/C/man2/ptrace.2:2817
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2827
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on Linux "
"3.13."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2845
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2849
#, no-wrap
msgid "strace -p E<lt>process-IDE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2854
msgid "then, instead of the usual and expected one-line output such as"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2858
#, no-wrap
msgid "restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2866
#, no-wrap
msgid "select(6, [5], NULL, [5], NULL_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2871
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2876
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2898
msgid ""
"What is not visible here is that the process was blocked in B<epoll_wait>(2)  "
"before B<strace>(1)  has attached to it.  Attaching caused B<epoll_wait>(2)  "
"to return to user space with the error B<EINTR>.  In this particular case, "
"the program reacted to B<EINTR> by checking the current time, and then "
"executing B<epoll_wait>(2)  again.  (Programs which do not expect such "
"\"stray\" B<EINTR> errors may behave in an unintended way upon an "
"B<strace>(1)  attach.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2904
msgid ""
"Contrary to the normal rules, the glibc wrapper for B<ptrace>()  can set "
"I<errno> to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:2921
msgid ""
"B<gdb>(1), B<ltrace>(1), B<strace>(1), B<clone>(2), B<execve>(2), "
"B<fork>(2), B<gettid>(2), B<prctl>(2), B<seccomp>(2), B<sigaction>(2), "
"B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), B<capabilities>(7), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/quotactl.2:27
#, no-wrap
msgid "QUOTACTL"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:30
msgid "quotactl - manipulate disk quotas"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt> /* for XFS quotas */>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:37
#, no-wrap
msgid ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:48
msgid ""
"The quota system can be used to set per-user, per-group, and per-project "
"limits on the amount of disk space used on a filesystem.  For each user "
"and/or group, a soft limit and a hard limit can be set for each filesystem.  "
"The hard limit can't be exceeded.  The soft limit can be exceeded, but "
"warnings will ensue.  Moreover, the user can't exceed the soft limit for "
"more than grace period duration (one week by default) at a time; after this, "
"the soft limit counts as a hard limit."
msgstr ""

#.  847aac644e92e5624f2c153bab409bf713d5ff9a
#. type: Plain text
#: build/C/man2/quotactl.2:75
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, "
"B<GRPQUOTA>, for group quotas, or (since Linux 4.1)  B<PRJQUOTA>, for "
"project quotas.  The I<subcmd> value is described below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:80
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the filesystem being "
"manipulated."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:88
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each operation below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:92
msgid "The I<subcmd> value is one of the following operations:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:92
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:99
msgid ""
"Turn on quotas for a filesystem.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:100
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:103
msgid "The original quota format."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:103
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:107
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:107
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:111
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:120
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the filesystem.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:137
msgid ""
"Quota information can be also stored in hidden system inodes for ext4, XFS, "
"and other filesystems if the filesystem is configured so.  In this case, "
"there are no visible quota files and there is no need to use "
"B<quotacheck>(8).  Quota information is always kept consistent by the "
"filesystem and the B<Q_QUOTAON> operation serves only to enable enforcement "
"of quota limits.  The presence of hidden system inodes with quota "
"information is indicated by the B<DQF_SYS_FILE> flag in the I<dqi_flags> "
"field returned by the B<Q_GETINFO> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:140
msgid "This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:140
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:150
msgid ""
"Turn off quotas for a filesystem.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:150
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:161
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:166 build/C/man2/quotactl.2:289
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:186
#, no-wrap
msgid ""
"struct dqblk {      /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;  /* Absolute limit on disk\n"
"                                 quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;  /* Preferred limit on\n"
"                                 disk quota blocks */\n"
"    uint64_t dqb_curspace;    /* Current occupied space\n"
"                                 (in bytes) */\n"
"    uint64_t dqb_ihardlimit;  /* Maximum number of\n"
"                                 allocated inodes */\n"
"    uint64_t dqb_isoftlimit;  /* Preferred inode limit */\n"
"    uint64_t dqb_curinodes;   /* Current number of\n"
"                                 allocated inodes */\n"
"    uint64_t dqb_btime;       /* Time limit for excessive\n"
"                                 disk use */\n"
"    uint64_t dqb_itime;       /* Time limit for excessive\n"
"                                 files */\n"
"    uint32_t dqb_valid;       /* Bit mask of QIF_*\n"
"                                 constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:189
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:200
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:217
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:217
#, no-wrap
msgid "B<Q_GETNEXTQUOTA> (since Linux 4.6)"
msgstr ""

#.  commit 926132c0257a5a8d149a6a395cc3405e55420566
#. type: Plain text
#: build/C/man2/quotactl.2:225
msgid ""
"This operation is the same as B<Q_GETQUOTA>, but it returns quota "
"information for the next ID greater than or equal to I<id> that has a quota "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:236
msgid ""
"The I<addr> argument is a pointer to a I<nextdqblk> structure whose fields "
"are as for the I<dqblk>, except for the addition of a I<dqb_id> field that "
"is used to return the ID for which quota information is being returned:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:251
#, no-wrap
msgid ""
"struct nextdqblk {\n"
"    uint64_t dqb_bhardlimit;\n"
"    uint64_t dqb_bsoftlimit;\n"
"    uint64_t dqb_curspace;\n"
"    uint64_t dqb_ihardlimit;\n"
"    uint64_t dqb_isoftlimit;\n"
"    uint64_t dqb_curinodes;\n"
"    uint64_t dqb_btime;\n"
"    uint64_t dqb_itime;\n"
"    uint32_t dqb_valid;\n"
"    uint32_t dqb_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:253
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:273
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:273
#, no-wrap
msgid "B<Q_GETINFO> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:284
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:299
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;  /* Time before block soft limit\n"
"                             becomes hard limit */\n"
"    uint64_t dqi_igrace;  /* Time before inode soft limit\n"
"                             becomes hard limit */\n"
"    uint32_t dqi_flags;   /* Flags for quotafile\n"
"                             (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:301
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:303
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:307
#, no-wrap
msgid ""
"#define DQF_ROOT_SQUASH (1 E<lt>E<lt> 0) /* Root squash enabled */\n"
"              /* Before Linux v4.0, this had been defined\n"
"                 privately as V1_DQF_RSQUASH */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:309
#, no-wrap
msgid "/* Quota format QFMT_VFS_V0 / QFMT_VFS_V1 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:312
#, no-wrap
msgid ""
"#define DQF_SYS_FILE    (1 E<lt>E<lt> 16)   /* Quota stored in\n"
"                                       a system file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:315
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:320
#, no-wrap
msgid ""
"#define IIF_BGRACE  1\n"
"#define IIF_IGRACE  2\n"
"#define IIF_FLAGS   4\n"
"#define IIF_ALL     (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:336
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:336
#, no-wrap
msgid "B<Q_SETINFO> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:360
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:360
#, no-wrap
msgid "B<Q_GETFMT> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:367
msgid ""
"Get quota format used on the specified filesystem.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:367
#, no-wrap
msgid "B<Q_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:378
msgid ""
"Update the on-disk copy of quota usages for a filesystem.  If I<special> is "
"NULL, then all filesystems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:378
#, no-wrap
msgid "B<Q_GETSTATS> (supported up to Linux 2.4.21)"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:393
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>>.  "
"The I<special> and I<id> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:398
msgid ""
"This operation is obsolete and was removed in Linux 2.4.22.  Files in "
"I</proc/sys/fs/quota/> carry the information instead."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:401
msgid ""
"For XFS filesystems making use of the XFS Quota Manager (XQM), the above "
"operations are bypassed and the following operations are used:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:401
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:412
msgid ""
"Turn on quotas for an XFS filesystem.  XFS provides the ability to turn "
"on/off quota limit enforcement with quota accounting.  Therefore, XFS "
"expects I<addr> to be a pointer to an I<unsigned int> that contains a "
"bitwise combination of the following flags (defined in "
"I<E<lt>xfs/xqm.hE<gt>>):"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:421
#, no-wrap
msgid ""
"XFS_QUOTA_UDQ_ACCT  /* User quota accounting */\n"
"XFS_QUOTA_UDQ_ENFD  /* User quota limits enforcement */\n"
"XFS_QUOTA_GDQ_ACCT  /* Group quota accounting */\n"
"XFS_QUOTA_GDQ_ENFD  /* Group quota limits enforcement */\n"
"XFS_QUOTA_PDQ_ACCT  /* Project quota accounting */\n"
"XFS_QUOTA_PDQ_ENFD  /* Project quota limits enforcement */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:429
msgid ""
"This operation requires privilege (B<CAP_SYS_ADMIN>).  The I<id> argument is "
"ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:429
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:445
msgid ""
"Turn off quotas for an XFS filesystem.  As with B<Q_QUOTAON>, XFS "
"filesystems expect a pointer to an I<unsigned int> that specifies whether "
"quota accounting and/or limit enforcement need to be turned off (using the "
"same flags as for B<Q_XQUOTAON> operation).  This operation requires "
"privilege (B<CAP_SYS_ADMIN>).  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:445
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:456
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure, which is defined in "
"I<E<lt>xfs/xqm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:461
#, no-wrap
msgid ""
"/* All the blk units are in BBs (Basic Blocks) of\n"
"   512 bytes. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:463
#, no-wrap
msgid "#define FS_DQUOT_VERSION  1  /* fs_disk_quota.d_version */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:467
#, no-wrap
msgid ""
"#define XFS_USER_QUOTA    (1E<lt>E<lt>0)  /* User quota type */\n"
"#define XFS_PROJ_QUOTA    (1E<lt>E<lt>1)  /* Project quota type */\n"
"#define XFS_GROUP_QUOTA   (1E<lt>E<lt>2)  /* Group quota type */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:504
#, no-wrap
msgid ""
"struct fs_disk_quota {\n"
"    int8_t   d_version;   /* Version of this structure */\n"
"    int8_t   d_flags;     /* XFS_{USER,PROJ,GROUP}_QUOTA */\n"
"    uint16_t d_fieldmask; /* Field specifier */\n"
"    uint32_t d_id;        /* User, project, or group ID */\n"
"    uint64_t d_blk_hardlimit; /* Absolute limit on\n"
"                                 disk blocks */\n"
"    uint64_t d_blk_softlimit; /* Preferred limit on\n"
"                                 disk blocks */\n"
"    uint64_t d_ino_hardlimit; /* Maximum # allocated\n"
"                                 inodes */\n"
"    uint64_t d_ino_softlimit; /* Preferred inode limit */\n"
"    uint64_t d_bcount;    /* # disk blocks owned by\n"
"                             the user */\n"
"    uint64_t d_icount;    /* # inodes owned by the user */\n"
"    int32_t  d_itimer;    /* Zero if within inode limits */\n"
"                          /* If not, we refuse service */\n"
"    int32_t  d_btimer;    /* Similar to above; for\n"
"                             disk blocks */\n"
"    uint16_t d_iwarns;    /* # warnings issued with\n"
"                             respect to # of inodes */\n"
"    uint16_t d_bwarns;    /* # warnings issued with\n"
"                             respect to disk blocks */\n"
"    int32_t  d_padding2;  /* Padding - for future use */\n"
"    uint64_t d_rtb_hardlimit; /* Absolute limit on realtime\n"
"                                 (RT) disk blocks */\n"
"    uint64_t d_rtb_softlimit; /* Preferred limit on RT\n"
"                                 disk blocks */\n"
"    uint64_t d_rtbcount;  /* # realtime blocks owned */\n"
"    int32_t  d_rtbtimer;  /* Similar to above; for RT\n"
"                             disk blocks */\n"
"    uint16_t d_rtbwarns;  /* # warnings issued with\n"
"                             respect to RT disk blocks */\n"
"    int16_t  d_padding3;  /* Padding - for future use */\n"
"    char     d_padding4[8];   /* Yet more padding */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:511
msgid ""
"Unprivileged users may retrieve only their own quotas; a privileged user "
"(B<CAP_SYS_ADMIN>)  may retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:511
#, no-wrap
msgid "B<Q_XGETNEXTQUOTA> (since Linux 4.6)"
msgstr ""

#.  commit 8b37524962b9c54423374717786198f5c0820a28
#. type: Plain text
#: build/C/man2/quotactl.2:532
msgid ""
"This operation is the same as B<Q_XGETQUOTA>, but it returns (in the "
"I<fs_disk_quota> structure pointed by I<addr>)  quota information for the "
"next ID greater than or equal to I<id> that has a quota set.  Note that "
"since I<fs_disk_quota> already has I<q_id> field, no separate structure type "
"is needed (in contrast with B<Q_GETQUOTA> and B<Q_GETNEXTQUOTA> operations)"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:532
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:543
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:543
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:555
msgid ""
"Returns XFS filesystem-specific quota information in the I<fs_quota_stat> "
"structure pointed by I<addr>.  This is useful for finding out how much space "
"is used to store quota information, and also to get the quota on/off status "
"of a given local XFS filesystem.  The I<fs_quota_stat> structure itself is "
"defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:559
#, no-wrap
msgid "#define FS_QSTAT_VERSION 1  /* fs_quota_stat.qs_version */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:566
#, no-wrap
msgid ""
"struct fs_qfilestat {\n"
"    uint64_t qfs_ino;       /* Inode number */\n"
"    uint64_t qfs_nblks;     /* Number of BBs\n"
"                               512-byte-blocks */\n"
"    uint32_t qfs_nextents;  /* Number of extents */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:584
#, no-wrap
msgid ""
"struct fs_quota_stat {\n"
"    int8_t   qs_version; /* Version number for\n"
"                            future changes */\n"
"    uint16_t qs_flags; /* XFS_QUOTA_{U,P,G}DQ_{ACCT,ENFD} */\n"
"    int8_t   qs_pad;   /* Unused */\n"
"    struct fs_qfilestat qs_uquota;  /* User quota storage\n"
"                                       information */\n"
"    struct fs_qfilestat qs_gquota;  /* Group quota storage\n"
"                                       information */\n"
"    uint32_t qs_incoredqs;   /* Number of dquots in core */\n"
"    int32_t  qs_btimelimit;  /* Limit for blocks timer */\n"
"    int32_t  qs_itimelimit;  /* Limit for inodes timer */\n"
"    int32_t  qs_rtbtimelimit;/* Limit for RT\n"
"                                blocks timer */\n"
"    uint16_t qs_bwarnlimit;  /* Limit for # of warnings */\n"
"    uint16_t qs_iwarnlimit;  /* Limit for # of warnings */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:590
msgid "The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:590
#, no-wrap
msgid "B<Q_XGETQSTATV>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:604
msgid ""
"Returns XFS filesystem-specific quota information in the I<fs_quota_statv> "
"pointed to by I<addr>.  This version of the operation uses a structure with "
"proper versioning support, along with appropriate layout (all fields are "
"naturally aligned) and padding to avoiding special compat handling; it also "
"provides the ability to get statistics regarding the project quota file.  "
"The I<fs_quota_statv> structure itself is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:608
#, no-wrap
msgid "#define FS_QSTATV_VERSION1 1 /* fs_quota_statv.qs_version */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:616
#, no-wrap
msgid ""
"struct fs_qfilestatv {\n"
"    uint64_t qfs_ino;       /* Inode number */\n"
"    uint64_t qfs_nblks;     /* Number of BBs\n"
"                               512-byte-blocks */\n"
"    uint32_t qfs_nextents;  /* Number of extents */\n"
"    uint32_t qfs_pad;       /* Pad for 8-byte alignment */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:637
#, no-wrap
msgid ""
"struct fs_quota_statv {\n"
"    int8_t   qs_version;    /* Version for future\n"
"                               changes */\n"
"    uint8_t  qs_pad1;       /* Pad for 16-bit alignment */\n"
"    uint16_t qs_flags;      /* XFS_QUOTA_.* flags */\n"
"    uint32_t qs_incoredqs;  /* Number of dquots incore */\n"
"    struct fs_qfilestatv qs_uquota;  /* User quota\n"
"                                        information */\n"
"    struct fs_qfilestatv qs_gquota;  /* Group quota\n"
"                                        information */\n"
"    struct fs_qfilestatv qs_pquota;  /* Project quota\n"
"                                        information */\n"
"    int32_t  qs_btimelimit;   /* Limit for blocks timer */\n"
"    int32_t  qs_itimelimit;   /* Limit for inodes timer */\n"
"    int32_t  qs_rtbtimelimit; /* Limit for RT blocks\n"
"                                 timer */\n"
"    uint16_t qs_bwarnlimit;   /* Limit for # of warnings */\n"
"    uint16_t qs_iwarnlimit;   /* Limit for # of warnings */\n"
"    uint64_t qs_pad2[8];      /* For future proofing */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:651
msgid ""
"The I<qs_version> field of the structure should be filled with the version "
"of the structure supported by the callee (for now, only I<FS_QSTAT_VERSION1> "
"is supported).  The kernel will fill the structure in accordance with "
"version provided.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:651
#, no-wrap
msgid "B<Q_XQUOTARM  (since Linux 3.16)>"
msgstr ""

#.  9da93f9b7cdf8ab28da6b364cdc1fafc8670b4dc
#. type: Plain text
#: build/C/man2/quotactl.2:670
msgid ""
"Free the disk space taken by disk quotas.  The I<addr> argument should be a "
"pointer to an I<unsigned int> value containing flags (the same as in "
"I<d_flags> field of I<fs_disk_quota> structure)  which identify what types "
"of quota should be removed.  (Note that the quota type passed in the I<cmd> "
"argument is ignored, but should remain valid in order to pass preliminary "
"quotactl syscall handler checks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:675
msgid "Quotas must have already been turned off.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:675
#, no-wrap
msgid "B<Q_XQUOTASYNC> (since Linux 2.6.15; no-op since Linux 3.4)"
msgstr ""

#.  Added in commit ee34807a65aa0c5911dc27682863afca780a003e
#.  4b217ed9e30f94b6e8e5e262020ef0ceab6113af
#. type: Plain text
#: build/C/man2/quotactl.2:689
msgid ""
"This operation was an XFS quota equivalent to B<Q_SYNC>, but it is no-op "
"since Linux 3.4, as B<sync>(1)  writes quota information to disk now (in "
"addition to the other filesystem metadata that it writes out).  The "
"I<special>, I<id> and I<addr> arguments are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:696
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:707
msgid ""
"I<cmd> is B<Q_QUOTAON>, and the quota file pointed to by I<addr> exists, but "
"is not a regular file or is not on the filesystem pointed to by I<special>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:715
msgid "I<cmd> is B<Q_QUOTAON>, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:721
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:727
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:733
msgid "I<cmd> is B<Q_QUOTAON>, but the specified quota file is corrupted."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:733
#, no-wrap
msgid "B<EINVAL> (since Linux 5.5)"
msgstr ""

#.  3dd4d40b420846dd35869ccc8f8627feef2cff32
#. type: Plain text
#: build/C/man2/quotactl.2:742
msgid "I<cmd> is B<Q_XQUOTARM>, but I<addr> does not point to valid quota types."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:749
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:754
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:754
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:758
msgid "I<special> is not a block device."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:763
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:769
msgid ""
"I<cmd> is B<Q_SETQUOTA>, but the specified limits are out of the range "
"allowed by the quota format."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:773
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:779
msgid "I<cmd> is B<Q_QUOTAON>, but the specified quota format was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:789
msgid ""
"I<cmd> is B<Q_GETNEXTQUOTA> or B<Q_XGETNEXTQUOTA>, but there is no ID "
"greater than or equal to I<id> that has an active quota."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:795
msgid ""
"Instead of I<E<lt>xfs/xqm.hE<gt>> one can use "
"I<E<lt>linux/dqblk_xfs.hE<gt>>, taking into account that there are several "
"naming discrepancies:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:800
msgid ""
"Quota enabling flags (of format B<XFS_QUOTA_[UGP]DQ_{ACCT,ENFD}>)  are "
"defined without a leading \"X\", as B<FS_QUOTA_[UGP]DQ_{ACCT,ENFD}>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:805
msgid ""
"The same is true for B<XFS_{USER,GROUP,PROJ}_QUOTA> quota type flags, which "
"are defined as B<FS_{USER,GROUP,PROJ}_QUOTA>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:817
msgid ""
"The I<dqblk_xfs.h> header file defines its own B<XQM_USRQUOTA>, "
"B<XQM_GRPQUOTA>, and B<XQM_PRJQUOTA> constants for the available quota "
"types, but their values are the same as for constants without the B<XQM_> "
"prefix."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:822
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr ""

#. type: TH
#: build/C/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr ""

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
#.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: build/C/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the file offset of I<in_fd>; otherwise the "
"file offset is adjusted to reflect the number of bytes read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"file offset, and the file offset will be updated by the call."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports "
"B<mmap>(2)-like operations (i.e., it cannot be a socket)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:117
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  Note that a successful call to B<sendfile>()  may write fewer "
"bytes than requested; the caller should be prepared to retry the call if "
"there were unsent bytes.  See also NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:121
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:127
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:131
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:134
msgid "Bad address."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:143
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>, or I<count> is negative."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:151
msgid ""
"I<out_fd> has the B<O_APPEND> flag set.  This is not currently supported by "
"B<sendfile>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:155
msgid "Unspecified error while reading from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:159
msgid "Insufficient memory to read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:164
msgid ""
"I<count> is too large, the operation would result in exceeding the maximum "
"size of either the input file or the output file."
msgstr ""

#. type: TP
#: build/C/man2/sendfile.2:164 build/C/man2/splice.2:189
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:168
msgid "I<offset> is not NULL but the input file is not seekable."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:174
msgid ""
"B<sendfile>()  first appeared in Linux 2.2.  The include file "
"I<E<lt>sys/sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:176
msgid "Not specified in POSIX.1-2001, nor in other standards."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:181
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: build/C/man2/sendfile.2:187
msgid ""
"B<sendfile>()  will transfer at most 0x7ffff000 (2,147,479,552) bytes, "
"returning the number of bytes actually transferred.  (This is true on both "
"32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:197
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:203
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file; this "
"possibility went away in the Linux 2.6.x kernel series, but was restored in "
"Linux 2.6.33."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:215
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:224
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:233
msgid ""
"If I<out_fd> refers to a socket or pipe with zero-copy support, callers must "
"ensure the transferred portions of the file referred to by I<in_fd> remain "
"unmodified until the reader on the other end of I<out_fd> has consumed the "
"transferred data."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:238
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary file descriptors provided one (or both) of them is a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:244
msgid "B<copy_file_range>(2), B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "2020-12-21"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:33
#, no-wrap
msgid "B<pid_t set_tid_address(int *>I<tidptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:43
msgid ""
"For each thread, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""

#. type: TP
#: build/C/man2/set_tid_address.2:43
#, no-wrap
msgid "I<set_child_tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:54
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of "
"that system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:59
msgid ""
"When I<set_child_tid> is set, the very first thing the new thread does is to "
"write its thread ID at this address."
msgstr ""

#. type: TP
#: build/C/man2/set_tid_address.2:59
#, no-wrap
msgid "I<clear_child_tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:70
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:77
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling thread to I<tidptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:85
msgid ""
"When a thread whose I<clear_child_tid> is not NULL terminates, then, if the "
"thread is sharing memory with other threads, then 0 is written at the "
"address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:87
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:91
msgid ""
"The effect of this operation is to wake a single thread that is performing a "
"futex wait on the memory location.  Errors from the futex wake operation are "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always returns the caller's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:97
msgid "B<set_tid_address>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:100
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:109
msgid "B<clone>(2), B<futex>(2), B<gettid>(2)"
msgstr ""

#. type: TH
#: build/C/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:33 build/C/man2/tee.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: Plain text
#: build/C/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the file descriptors must refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:55
msgid "The following semantics apply for I<fd_in> and I<off_in>:"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:61
msgid "If I<fd_in> refers to a pipe, then I<off_in> must be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:70
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is NULL, then bytes are "
"read from I<fd_in> starting from the file offset, and the file offset is "
"adjusted appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:83
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is not NULL, then "
"I<off_in> must point to a buffer which specifies the starting offset from "
"which bytes will be read from I<fd_in>; in this case, the file offset of "
"I<fd_in> is not changed."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:88
msgid "Analogous statements apply for I<fd_out> and I<off_out>."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:93 build/C/man2/vmsplice.2:92
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:93 build/C/man2/tee.2:60 build/C/man2/vmsplice.2:92
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:106
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:106 build/C/man2/tee.2:66 build/C/man2/vmsplice.2:98
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:115
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:115 build/C/man2/tee.2:71 build/C/man2/vmsplice.2:105
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:129
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:129 build/C/man2/tee.2:77 build/C/man2/vmsplice.2:111
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:135
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:140
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:147
msgid ""
"A return value of 0 means end of input.  If I<fd_in> refers to a pipe, then "
"this means that there was no data to transfer, and it would not make sense "
"to block because there are no writers connected to the write end of the "
"pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:153
msgid "On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:162 build/C/man2/tee.2:107
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags> or one of the file "
"descriptors had been marked as nonblocking (B<O_NONBLOCK>)B<,> and the "
"operation would block."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:166
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:169
msgid "The target filesystem doesn't support splicing."
msgstr ""

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: build/C/man2/splice.2:174
msgid "The target file is opened in append mode."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:177
msgid "Neither of the file descriptors refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:180
msgid "An offset was given for nonseekable device (e.g., a pipe)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:186
msgid "I<fd_in> and I<fd_out> refer to the same pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:196
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:201
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:213
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:217
msgid ""
"B<splice>()  moves data from the buffer to an arbitrary file descriptor, or "
"vice versa, or from one buffer to another."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:220
msgid "B<tee>(2)  \"copies\" the data from one buffer to another."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:223
msgid "B<vmsplice>(2)  \"copies\" data from user space into the buffer."
msgstr ""

#
#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: build/C/man2/splice.2:254
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""

#.  commit 7c77f0b3f9208c339a4b40737bb2cb0f0319bb8d
#. type: Plain text
#: build/C/man2/splice.2:264
msgid ""
"In Linux 2.6.30 and earlier, exactly one of I<fd_in> and I<fd_out> was "
"required to be a pipe.  Since Linux 2.6.31, both arguments may refer to "
"pipes."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:267
msgid "See B<tee>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:273
msgid "B<copy_file_range>(2), B<sendfile>(2), B<tee>(2), B<vmsplice>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: build/C/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:36
#, no-wrap
msgid ""
"B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned "
"int >I<flags>B<);>\n"
msgstr ""

#.  Example programs http://brick.kernel.dk/snaps
#
#
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: build/C/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:60
msgid ""
"I<flags> is a bit mask that is composed by ORing together zero or more of "
"the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:66
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr ""

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: build/C/man2/tee.2:71 build/C/man2/vmsplice.2:105
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:77
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:83
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:92
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:98
msgid "On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:117
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:125
msgid ""
"The B<tee>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:136
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data to the output by merely grabbing a reference to the input."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:143
msgid ""
"The example below implements a basic B<tee>(1)  program using the B<tee>()  "
"system call.  Here is an example of its use:"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:150
#, no-wrap
msgid ""
"$ B<date |./a.out out.log | cat>\n"
"Tue Oct 28 10:06:00 CET 2014\n"
"$ B<cat out.log>\n"
"Tue Oct 28 10:06:00 CET 2014\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:162
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:168
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:173
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:179
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:186
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:195
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:209
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:213
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:218
msgid "B<splice>(2), B<vmsplice>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:48
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28, it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:52
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:54
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:64
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:68
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:73
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should exist only within vm86 mode itself.)"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:76
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: TH
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:29
msgid "vmsplice - splice user pages to/from a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#.  Since Linux 2.6.23
#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: build/C/man2/vmsplice.2:71
msgid ""
"If I<fd> is opened for writing, the B<vmsplice>()  system call maps "
"I<nr_segs> ranges of user memory described by I<iov> into a pipe.  If I<fd> "
"is opened for reading, the B<vmsplice>()  system call fills I<nr_segs> "
"ranges of user memory described by I<iov> from a pipe.  The file descriptor "
"I<fd> must refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:78
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:85
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;        /* Starting address */\n"
"    size_t iov_len;         /* Number of bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:98
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:111
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""

#.  FIXME . Explain the following line in a little more detail:
#.  FIXME
#.  It looks like the page-alignment requirement went away with
#.  commit bd1a68b59c8e3bce45fb76632c64e1e063c3962d
#
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: build/C/man2/vmsplice.2:131
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, otherwise the page cache and on-disk data may differ.  "
"Gifting pages to the kernel means that a subsequent B<splice>(2)  "
"B<SPLICE_F_MOVE> can successfully move the pages; if this flag is not "
"specified, then a subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the "
"pages.  Data must also be properly page aligned, both in memory and length."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:140
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:147
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags>, and the operation would "
"block."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:151
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:159
msgid ""
"I<nr_segs> is greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:167
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""

#.  UIO_MAXIOV in kernel source
#. type: Plain text
#: build/C/man2/vmsplice.2:180
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on the number of segments being passed in.  This "
"limit is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  Currently, this "
"limit is 1024."
msgstr ""

#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: build/C/man2/vmsplice.2:188
msgid ""
"B<vmsplice>()  really supports true splicing only from user memory to a "
"pipe.  In the opposite direction, it actually just copies the data to "
"userspace.  But this makes the interface nice and symmetric and enables "
"people to build on B<vmsplice>()  with room for future improvement in "
"performance."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:192
msgid "B<splice>(2), B<tee>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: build/C/man2/userfaultfd.2:27
#, no-wrap
msgid "USERFAULTFD"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:30
msgid ""
"userfaultfd - create a file descriptor for handling page faults in user "
"space"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>linux/userfaultfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:36
#, no-wrap
msgid "B<int userfaultfd(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:47
msgid ""
"B<userfaultfd>()  creates a new userfaultfd object that can be used for "
"delegation of page-fault handling to a user-space application, and returns a "
"file descriptor that refers to the new object.  The new userfaultfd object "
"is configured using B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:56
msgid ""
"Once the userfaultfd object is configured, the application can use "
"B<read>(2)  to receive userfaultfd notifications.  The reads from "
"userfaultfd may be blocking or non-blocking, depending on the value of "
"I<flags> used for the creation of the userfaultfd or subsequent calls to "
"B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:61
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<userfaultfd>():"
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:61
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:68
msgid ""
"Enable the close-on-exec flag for the new userfaultfd file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:68
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:75
msgid ""
"Enables non-blocking operation for the userfaultfd object.  See the "
"description of the B<O_NONBLOCK> flag in B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:80
msgid ""
"When the last file descriptor referring to a userfaultfd object is closed, "
"all memory ranges that were registered with the object are unregistered and "
"unread events are flushed."
msgstr ""

#. type: SS
#: build/C/man2/userfaultfd.2:80
#, no-wrap
msgid "Usage"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:92
msgid ""
"The userfaultfd mechanism is designed to allow a thread in a multithreaded "
"program to perform user-space paging for the other threads in the process.  "
"When a page fault occurs for one of the regions registered to the "
"userfaultfd object, the faulting thread is put to sleep and an event is "
"generated that can be read via the userfaultfd file descriptor.  The "
"fault-handling thread reads events from this file descriptor and services "
"them using the operations described in B<ioctl_userfaultfd>(2).  When "
"servicing the page fault events, the fault-handling thread can trigger a "
"wake-up for the sleeping thread."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:102
msgid ""
"It is possible for the faulting threads and the fault-handling threads to "
"run in the context of different processes.  In this case, these threads may "
"belong to different programs, and the program that executes the faulting "
"threads will not necessarily cooperate with the program that handles the "
"page faults.  In such non-cooperative mode, the process that monitors "
"userfaultfd and handles page faults needs to be aware of the changes in the "
"virtual memory layout of the faulting process to avoid memory corruption."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:126
msgid ""
"Starting from Linux 4.11, userfaultfd can also notify the fault-handling "
"threads about changes in the virtual memory layout of the faulting process.  "
"In addition, if the faulting process invokes B<fork>(2), the userfaultfd "
"objects associated with the parent may be duplicated into the child process "
"and the userfaultfd monitor will be notified (via the B<UFFD_EVENT_FORK> "
"described below)  about the file descriptor associated with the userfault "
"objects created for the child process, which allows the userfaultfd monitor "
"to perform user-space paging for the child process.  Unlike page faults "
"which have to be synchronous and require an explicit or implicit wakeup, all "
"other events are delivered asynchronously and the non-cooperative process "
"resumes execution as soon as the userfaultfd manager executes B<read>(2).  "
"The userfaultfd manager should carefully synchronize calls to B<UFFDIO_COPY> "
"with the processing of events."
msgstr ""

#.  Regarding the preceding sentence, Mike Rapoport says:
#.      The major point here is that current events delivery model could be
#.      problematic for multi-threaded monitor. I even suspect that it would be
#.      impossible to ensure synchronization between page faults and non-page
#.      fault events in multi-threaded monitor.
#.  .PP
#.  FIXME elaborate about non-cooperating mode, describe its limitations
#.  for kernels before 4.11, features added in 4.11
#.  and limitations remaining in 4.11
#.  Maybe it's worth adding a dedicated sub-section...
#. type: Plain text
#: build/C/man2/userfaultfd.2:140
msgid ""
"The current asynchronous model of the event delivery is optimal for single "
"threaded non-cooperative userfaultfd manager implementations."
msgstr ""

#. type: SS
#: build/C/man2/userfaultfd.2:140
#, no-wrap
msgid "Userfaultfd operation"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:154
msgid ""
"After the userfaultfd object is created with B<userfaultfd>(), the "
"application must enable it using the B<UFFDIO_API> B<ioctl>(2)  operation.  "
"This operation allows a handshake between the kernel and user space to "
"determine the API version and supported features.  This operation must be "
"performed before any of the other B<ioctl>(2)  operations described below "
"(or those operations fail with the B<EINVAL> error)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:174
msgid ""
"After a successful B<UFFDIO_API> operation, the application then registers "
"memory address ranges using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"After successful completion of a B<UFFDIO_REGISTER> operation, a page fault "
"occurring in the requested memory range, and satisfying the mode defined at "
"the registration time, will be forwarded by the kernel to the user-space "
"application.  The application can then use the B<UFFDIO_COPY> or "
"B<UFFDIO_ZEROPAGE> B<ioctl>(2)  operations to resolve the page fault."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:193
msgid ""
"Starting from Linux 4.14, if the application sets the B<UFFD_FEATURE_SIGBUS> "
"feature bit using the B<UFFDIO_API> B<ioctl>(2), no page-fault notification "
"will be forwarded to user space.  Instead a B<SIGBUS> signal is delivered to "
"the faulting process.  With this feature, userfaultfd can be used for "
"robustness purposes to simply catch any access to areas within the "
"registered address range that do not have pages allocated, without having to "
"listen to userfaultfd events.  No userfaultfd monitor will be required for "
"dealing with such memory accesses.  For example, this feature can be useful "
"for applications that want to prevent the kernel from automatically "
"allocating pages and filling holes in sparse files when the hole is accessed "
"through a memory mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:200
msgid ""
"The B<UFFD_FEATURE_SIGBUS> feature is implicitly inherited through "
"B<fork>(2)  if used in combination with B<UFFD_FEATURE_FORK>."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:205
msgid ""
"Details of the various B<ioctl>(2)  operations can be found in "
"B<ioctl_userfaultfd>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:209
msgid ""
"Since Linux 4.11, events other than page-fault may enabled during "
"B<UFFDIO_API> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:214
msgid ""
"Up to Linux 4.11, userfaultfd can be used only with anonymous private memory "
"mappings.  Since Linux 4.11, userfaultfd can be also used with hugetlbfs and "
"shared memory mappings."
msgstr ""

#. type: SS
#: build/C/man2/userfaultfd.2:216
#, no-wrap
msgid "Reading from the userfaultfd structure"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:223
msgid ""
"Each B<read>(2)  from the userfaultfd file descriptor returns one or more "
"I<uffd_msg> structures, each of which describes a page-fault event or an "
"event required for the non-cooperative userfaultfd usage:"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:234
#, no-wrap
msgid ""
"struct uffd_msg {\n"
"    __u8  event;            /* Type of event */\n"
"    ...\n"
"    union {\n"
"        struct {\n"
"            __u64 flags;    /* Flags describing fault */\n"
"            __u64 address;  /* Faulting address */\n"
"        } pagefault;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:239
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u32 ufd;      /* Userfault file descriptor\n"
"                               of the child process */\n"
"        } fork;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:245
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 from;     /* Old address of remapped area */\n"
"            __u64 to;       /* New address of remapped area */\n"
"            __u64 len;      /* Original mapping length */\n"
"        } remap;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:252
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 start;    /* Start address of removed area */\n"
"            __u64 end;      /* End address of removed area */\n"
"        } remove;\n"
"        ...\n"
"    } arg;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:255
#, no-wrap
msgid ""
"    /* Padding fields omitted */\n"
"} __packed;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:269
msgid ""
"If multiple events are available and the supplied buffer is large enough, "
"B<read>(2)  returns as many events as will fit in the supplied buffer.  If "
"the buffer supplied to B<read>(2)  is smaller than the size of the "
"I<uffd_msg> structure, the B<read>(2)  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:273
msgid "The fields set in the I<uffd_msg> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:273
#, no-wrap
msgid "I<event>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:284
msgid ""
"The type of event.  Depending of the event type, different fields of the "
"I<arg> union represent details required for the event processing.  The "
"non-page-fault events are generated only when appropriate feature is enabled "
"during API handshake with B<UFFDIO_API> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:288
msgid "The following values can appear in the I<event> field:"
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:289
#, no-wrap
msgid "B<UFFD_EVENT_PAGEFAULT> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:295
msgid ""
"A page-fault event.  The page-fault details are available in the "
"I<pagefault> field."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:295
#, no-wrap
msgid "B<UFFD_EVENT_FORK> (since Linux 4.11)"
msgstr ""

#.  FIXME describe duplication of userfault file descriptor during fork
#. type: Plain text
#: build/C/man2/userfaultfd.2:308
msgid ""
"Generated when the faulting process invokes B<fork>(2)  (or B<clone>(2)  "
"without the B<CLONE_VM> flag).  The event details are available in the "
"I<fork> field."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:308
#, no-wrap
msgid "B<UFFD_EVENT_REMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:315
msgid ""
"Generated when the faulting process invokes B<mremap>(2).  The event details "
"are available in the I<remap> field."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:315
#, no-wrap
msgid "B<UFFD_EVENT_REMOVE> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:327
msgid ""
"Generated when the faulting process invokes B<madvise>(2)  with "
"B<MADV_DONTNEED> or B<MADV_REMOVE> advice.  The event details are available "
"in the I<remove> field."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:327
#, no-wrap
msgid "B<UFFD_EVENT_UNMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:339
msgid ""
"Generated when the faulting process unmaps a memory range, either explicitly "
"using B<munmap>(2)  or implicitly during B<mmap>(2)  or B<mremap>(2).  The "
"event details are available in the I<remove> field."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:340
#, no-wrap
msgid "I<pagefault.address>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:343
msgid "The address that triggered the page fault."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:343
#, no-wrap
msgid "I<pagefault.flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:349
msgid ""
"A bit mask of flags that describe the event.  For B<UFFD_EVENT_PAGEFAULT>, "
"the following flag may appear:"
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:350
#, no-wrap
msgid "B<UFFD_PAGEFAULT_FLAG_WRITE>"
msgstr ""

#
#.  UFFD_PAGEFAULT_FLAG_WP is not yet supported.
#. type: Plain text
#: build/C/man2/userfaultfd.2:360
msgid ""
"If the address is in a range that was registered with the "
"B<UFFDIO_REGISTER_MODE_MISSING> flag (see B<ioctl_userfaultfd>(2))  and this "
"flag is set, this a write fault; otherwise it is a read fault."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:361
#, no-wrap
msgid "I<fork.ufd>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:366
msgid ""
"The file descriptor associated with the userfault object created for the "
"child created by B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:366
#, no-wrap
msgid "I<remap.from>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:370
msgid ""
"The original address of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:370
#, no-wrap
msgid "I<remap.to>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:374
msgid "The new address of the memory range that was remapped using B<mremap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:374
#, no-wrap
msgid "I<remap.len>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:378
msgid ""
"The original length of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:378
#, no-wrap
msgid "I<remove.start>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:383
msgid ""
"The start address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:383
#, no-wrap
msgid "I<remove.end>"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:388
msgid ""
"The end address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:392
msgid ""
"A B<read>(2)  on a userfaultfd file descriptor can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:398
msgid ""
"The userfaultfd object has not yet been enabled using the B<UFFDIO_API> "
"B<ioctl>(2)  operation"
msgstr ""

#.  FIXME What is the reason for this seemingly odd behavior with respect
#.  to the O_NONBLOCK flag? (see userfaultfd_poll() in fs/userfaultfd.c).
#.  Something needs to be said about this.
#. type: Plain text
#: build/C/man2/userfaultfd.2:420
msgid ""
"If the B<O_NONBLOCK> flag is enabled in the associated open file "
"description, the userfaultfd file descriptor can be monitored with "
"B<poll>(2), B<select>(2), and B<epoll>(7).  When events are available, the "
"file descriptor indicates as readable.  If the B<O_NONBLOCK> flag is not "
"enabled, then B<poll>(2)  (always) indicates the file as having a B<POLLERR> "
"condition, and B<select>(2)  indicates the file descriptor as both readable "
"and writable."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:427
msgid ""
"On success, B<userfaultfd>()  returns a new file descriptor that refers to "
"the userfaultfd object.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:432
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:436
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:440
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:443
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/userfaultfd.2:443
#, no-wrap
msgid "B<EPERM> (since Linux 5.2)"
msgstr ""

#.  cefdca0a86be517bc390fc4541e3674b8e7803b0
#. type: Plain text
#: build/C/man2/userfaultfd.2:451
msgid ""
"The caller is not privileged (does not have the B<CAP_SYS_PTRACE> capability "
"in the initial user namespace), and I</proc/sys/vm/unprivileged_userfaultfd> "
"has the value 0."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:455
msgid "The B<userfaultfd>()  system call first appeared in Linux 4.3."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:458
msgid ""
"The support for hugetlbfs and shared memory areas and non-page-fault events "
"was added in Linux 4.11"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:462
msgid ""
"B<userfaultfd>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:476
msgid ""
"The userfaultfd mechanism can be used as an alternative to traditional "
"user-space paging techniques based on the use of the B<SIGSEGV> signal and "
"B<mmap>(2).  It can also be used to implement lazy restore for "
"checkpoint/restore mechanisms, as well as post-copy migration to allow "
"(nearly) uninterrupted execution when transferring virtual machines and "
"Linux containers from one host to another."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:486
msgid ""
"If the B<UFFD_FEATURE_EVENT_FORK> is enabled and a system call from the "
"B<fork>(2)  family is interrupted by a signal or failed, a stale userfaultfd "
"descriptor might be created.  In this case, a spurious B<UFFD_EVENT_FORK> "
"will be delivered to the userfaultfd monitor."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:492
msgid ""
"The program below demonstrates the use of the userfaultfd mechanism.  The "
"program creates two threads, one of which acts as the page-fault handler for "
"the process, for the pages in a demand-page zero region created using "
"B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:504
msgid ""
"The program takes one command-line argument, which is the number of pages "
"that will be created in a mapping whose page faults will be handled via "
"userfaultfd.  After creating a userfaultfd object, the program then creates "
"an anonymous private mapping of the specified size and registers the address "
"range of that mapping using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"The program then creates a second thread that will perform the task of "
"handling page faults."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:510
msgid ""
"The main thread then walks through the pages of the mapping fetching bytes "
"from successive pages.  Because the pages have not yet been accessed, the "
"first access of a byte in each page will trigger a page-fault event on the "
"userfaultfd file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:525
msgid ""
"Each of the page-fault events is handled by the second thread, which sits in "
"a loop processing input from the userfaultfd file descriptor.  In each loop "
"iteration, the second thread first calls B<poll>(2)  to check the state of "
"the file descriptor, and then reads an event from the file descriptor.  All "
"such events should be B<UFFD_EVENT_PAGEFAULT> events, which the thread "
"handles by copying a page of data into the faulting region using the "
"B<UFFDIO_COPY> B<ioctl>(2)  operation."
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:527
msgid "The following is an example of what we see when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:532
#, no-wrap
msgid ""
"$ B<./userfaultfd_demo 3>\n"
"Address returned by mmap() = 0x7fd30106c000\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:541
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106c00f in main(): A\n"
"Read address 0x7fd30106c40f in main(): A\n"
"Read address 0x7fd30106c80f in main(): A\n"
"Read address 0x7fd30106cc0f in main(): A\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:550
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106d00f in main(): B\n"
"Read address 0x7fd30106d40f in main(): B\n"
"Read address 0x7fd30106d80f in main(): B\n"
"Read address 0x7fd30106dc0f in main(): B\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:559
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106e00f in main(): C\n"
"Read address 0x7fd30106e40f in main(): C\n"
"Read address 0x7fd30106e80f in main(): C\n"
"Read address 0x7fd30106ec0f in main(): C\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:565
#, no-wrap
msgid "/* userfaultfd_demo.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:585
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License version 2 or later.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>inttypes.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>linux/userfaultfd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:590
#, no-wrap
msgid "static int page_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:600
#, no-wrap
msgid ""
"static void *\n"
"fault_handler_thread(void *arg)\n"
"{\n"
"    static struct uffd_msg msg;   /* Data read from userfaultfd */\n"
"    static int fault_cnt = 0;     /* Number of faults so far handled */\n"
"    long uffd;                    /* userfaultfd file descriptor */\n"
"    static char *page = NULL;\n"
"    struct uffdio_copy uffdio_copy;\n"
"    ssize_t nread;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:602
#, no-wrap
msgid "    uffd = (long) arg;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:604
#, no-wrap
msgid "    /* Create a page that will be copied into the faulting region */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:611
#, no-wrap
msgid ""
"    if (page == NULL) {\n"
"        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n"
"                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"        if (page == MAP_FAILED)\n"
"            errExit(\"mmap\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:614
#, no-wrap
msgid ""
"    /* Loop, handling incoming events on the userfaultfd\n"
"       file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:616
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:618
#, no-wrap
msgid "        /* See what poll() tells us about the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:626
#, no-wrap
msgid ""
"        struct pollfd pollfd;\n"
"        int nready;\n"
"        pollfd.fd = uffd;\n"
"        pollfd.events = POLLIN;\n"
"        nready = poll(&pollfd, 1, -1);\n"
"        if (nready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:632
#, no-wrap
msgid ""
"        printf(\"\\enfault_handler_thread():\\en\");\n"
"        printf(\"    poll() returns: nready = %d; \"\n"
"                \"POLLIN = %d; POLLERR = %d\\en\", nready,\n"
"                (pollfd.revents & POLLIN) != 0,\n"
"                (pollfd.revents & POLLERR) != 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:634
#, no-wrap
msgid "        /* Read an event from the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:640
#, no-wrap
msgid ""
"        nread = read(uffd, &msg, sizeof(msg));\n"
"        if (nread == 0) {\n"
"            printf(\"EOF on userfaultfd!\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:643
#, no-wrap
msgid ""
"        if (nread == -1)\n"
"            errExit(\"read\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:645
#, no-wrap
msgid "        /* We expect only one kind of event; verify that assumption */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:650
#, no-wrap
msgid ""
"        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n"
"            fprintf(stderr, \"Unexpected event on userfaultfd\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:652
#, no-wrap
msgid "        /* Display info about the page-fault event */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:656
#, no-wrap
msgid ""
"        printf(\"    UFFD_EVENT_PAGEFAULT event: \");\n"
"        printf(\"flags = %\"PRIx64\"; \", msg.arg.pagefault.flags);\n"
"        printf(\"address = %\"PRIx64\"\\en\", msg.arg.pagefault.address);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:660
#, no-wrap
msgid ""
"        /* Copy the page pointed to by \\(aqpage\\(aq into the faulting\n"
"           region. Vary the contents that are copied in, so that it\n"
"           is more obvious that each fault is handled separately. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:663
#, no-wrap
msgid ""
"        memset(page, \\(aqA\\(aq + fault_cnt % 20, page_size);\n"
"        fault_cnt++;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:665
#, no-wrap
msgid "        uffdio_copy.src = (unsigned long) page;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:668
#, no-wrap
msgid ""
"        /* We need to handle page faults in units of pages(!).\n"
"           So, round faulting address down to page boundary */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:676
#, no-wrap
msgid ""
"        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n"
"                                           \\(ti(page_size - 1);\n"
"        uffdio_copy.len = page_size;\n"
"        uffdio_copy.mode = 0;\n"
"        uffdio_copy.copy = 0;\n"
"        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n"
"            errExit(\"ioctl-UFFDIO_COPY\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:681
#, no-wrap
msgid ""
"        printf(\"        (uffdio_copy.copy returned %\"PRId64\")\\en\",\n"
"                uffdio_copy.copy);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:692
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    long uffd;          /* userfaultfd file descriptor */\n"
"    char *addr;         /* Start of region handled by userfaultfd */\n"
"    uint64_t len;       /* Length of region handled by userfaultfd */\n"
"    pthread_t thr;      /* ID of thread that handles page faults */\n"
"    struct uffdio_api uffdio_api;\n"
"    struct uffdio_register uffdio_register;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:697
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s num-pages\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:700
#, no-wrap
msgid ""
"    page_size = sysconf(_SC_PAGE_SIZE);\n"
"    len = strtoull(argv[1], NULL, 0) * page_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:702
#, no-wrap
msgid "    /* Create and enable userfaultfd object */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:706
#, no-wrap
msgid ""
"    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n"
"    if (uffd == -1)\n"
"        errExit(\"userfaultfd\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:711
#, no-wrap
msgid ""
"    uffdio_api.api = UFFD_API;\n"
"    uffdio_api.features = 0;\n"
"    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n"
"        errExit(\"ioctl-UFFDIO_API\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:716
#, no-wrap
msgid ""
"    /* Create a private anonymous mapping. The memory will be\n"
"       demand-zero paged--that is, not yet allocated. When we\n"
"       actually touch the memory, it will be allocated via\n"
"       the userfaultfd. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:721
#, no-wrap
msgid ""
"    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n"
"                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"    if (addr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:723
#, no-wrap
msgid "    printf(\"Address returned by mmap() = %p\\en\", addr);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:727
#, no-wrap
msgid ""
"    /* Register the memory range of the mapping we just created for\n"
"       handling by the userfaultfd object. In mode, we request to track\n"
"       missing pages (i.e., pages that have not yet been faulted in). */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:733
#, no-wrap
msgid ""
"    uffdio_register.range.start = (unsigned long) addr;\n"
"    uffdio_register.range.len = len;\n"
"    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n"
"    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n"
"        errExit(\"ioctl-UFFDIO_REGISTER\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:735
#, no-wrap
msgid "    /* Create a thread that will process the userfaultfd events */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:741
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n"
"    if (s != 0) {\n"
"        errno = s;\n"
"        errExit(\"pthread_create\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:745
#, no-wrap
msgid ""
"    /* Main thread now touches memory in the mapping, touching\n"
"       locations 1024 bytes apart. This will trigger userfaultfd\n"
"       events for all pages in the region. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:757
#, no-wrap
msgid ""
"    int l;\n"
"    l = 0xf;    /* Ensure that faulting address is not on a page\n"
"                   boundary, in order to test that we correctly\n"
"                   handle that case in fault_handling_thread() */\n"
"    while (l E<lt> len) {\n"
"        char c = addr[l];\n"
"        printf(\"Read address %p in main(): \", addr + l);\n"
"        printf(\"%c\\en\", c);\n"
"        l += 1024;\n"
"        usleep(100000);         /* Slow things down a little */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:767
msgid "B<fcntl>(2), B<ioctl>(2), B<ioctl_userfaultfd>(2), B<madvise>(2), B<mmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/userfaultfd.2:770
msgid ""
"I<Documentation/admin-guide/mm/userfaultfd.rst> in the Linux kernel source "
"tree"
msgstr ""
