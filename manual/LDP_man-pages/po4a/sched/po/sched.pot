# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "CPU_SET"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28 build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setattr.2:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28 build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26 build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setattr.2:26 build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:26 build/C/man2/sched_yield.2:29 build/C/man7/sched.7:32 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28 build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26 build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setattr.2:26 build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:26 build/C/man2/sched_yield.2:29 build/C/man7/sched.7:32 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:28 build/C/man2/clone.2:43 build/C/man2/kcmp.2:29 build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:27 build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35 build/C/man2/sched_setattr.2:27 build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:27 build/C/man2/sched_yield.2:30 build/C/man7/sched.7:33 build/C/man2/setns.2:9 build/C/man2/unshare.2:21
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:35
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:35 build/C/man2/clone.2:45 build/C/man2/kcmp.2:31 build/C/man2/sched_get_priority_max.2:32 build/C/man3/sched_getcpu.3:29 build/C/man2/sched_rr_get_interval.2:32 build/C/man2/sched_setaffinity.2:38 build/C/man2/sched_setattr.2:30 build/C/man2/sched_setparam.2:33 build/C/man2/sched_setscheduler.2:30 build/C/man2/sched_yield.2:32 build/C/man2/setns.2:11 build/C/man2/unshare.2:23
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:39 build/C/man2/sched_setaffinity.2:42 build/C/man2/setns.2:15
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:41
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:47
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:56
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:62
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:68
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:75
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:78
#, no-wrap
msgid ""
"B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t "
"*>I<set2>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:79 build/C/man2/clone.2:66 build/C/man2/kcmp.2:41 build/C/man2/sched_get_priority_max.2:38 build/C/man3/sched_getcpu.3:55 build/C/man2/sched_rr_get_interval.2:36 build/C/man2/sched_setaffinity.2:49 build/C/man2/sched_setattr.2:41 build/C/man2/sched_setparam.2:47 build/C/man2/sched_setscheduler.2:39 build/C/man2/sched_yield.2:36 build/C/man7/sched.7:35 build/C/man2/setns.2:18 build/C/man2/unshare.2:30
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:86
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:93
msgid ""
"The I<cpu_set_t> data type is implemented as a bit mask.  However, the data "
"structure should be treated as opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:96
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:96
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:101
msgid "Clears I<set>, so that it contains no CPUs."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:101
#, no-wrap
msgid "B<CPU_SET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:107
msgid "Add CPU I<cpu> to I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:107
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:113
msgid "Remove CPU I<cpu> from I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:113
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:119
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:119
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:123
msgid "Return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:128
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:142
msgid ""
"The first CPU on the system corresponds to a I<cpu> value of 0, the next CPU "
"corresponds to a I<cpu> value of 1, and so on.  No assumptions should be "
"made about particular CPUs being available, or the set of CPUs being "
"contiguous, since CPUs can be taken offline dynamically or be otherwise "
"absent.  The constant B<CPU_SETSIZE> (currently 1024) specifies a value one "
"greater than the maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:144
msgid "The following macros perform logical operations on CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:144
#, no-wrap
msgid "B<CPU_AND>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:153
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:153
#, no-wrap
msgid "B<CPU_OR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:162
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:162
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:176
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:176
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:179
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr ""

#. type: SS
#: build/C/man3/CPU_SET.3:179
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:185
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:187
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:187
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:192
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to "
"I<num_cpus-1>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:192
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:202
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described "
"below."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:202
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:206
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:213
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:213 build/C/man2/clone.2:1193 build/C/man2/kcmp.2:208 build/C/man2/sched_get_priority_max.2:98 build/C/man3/sched_getcpu.3:58 build/C/man2/sched_rr_get_interval.2:73 build/C/man2/sched_setaffinity.2:107 build/C/man2/sched_setattr.2:299 build/C/man2/sched_setparam.2:87 build/C/man2/sched_setscheduler.2:133 build/C/man2/sched_yield.2:41 build/C/man2/setns.2:245 build/C/man2/unshare.2:286
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:222
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:228
msgid "B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:233
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise they return 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:238
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:242
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:244
msgid "The other functions do not return a value."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:244 build/C/man2/clone.2:1523 build/C/man2/kcmp.2:298 build/C/man3/sched_getcpu.3:70 build/C/man2/sched_setaffinity.2:154 build/C/man2/sched_setattr.2:386 build/C/man2/setns.2:304 build/C/man2/unshare.2:421
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:252
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:255
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:273
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), "
"B<CPU_XOR_S>(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:273 build/C/man2/clone.2:1533 build/C/man2/kcmp.2:302 build/C/man2/sched_get_priority_max.2:114 build/C/man3/sched_getcpu.3:84 build/C/man2/sched_rr_get_interval.2:94 build/C/man2/sched_setaffinity.2:165 build/C/man2/sched_setattr.2:389 build/C/man2/sched_setparam.2:119 build/C/man2/sched_setscheduler.2:168 build/C/man2/sched_yield.2:52 build/C/man2/setns.2:309 build/C/man2/unshare.2:425
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:275
msgid "These interfaces are Linux-specific."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:275 build/C/man2/clone.2:1537 build/C/man2/kcmp.2:305 build/C/man3/sched_getcpu.3:87 build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setaffinity.2:167 build/C/man2/sched_setattr.2:391 build/C/man2/sched_setscheduler.2:171 build/C/man2/sched_yield.2:54 build/C/man7/sched.7:951 build/C/man2/setns.2:313 build/C/man2/unshare.2:429
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:278
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:285
msgid ""
"Since CPU sets are bit masks allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:297
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of the bits in the bit mask), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:303
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:303 build/C/man2/clone.2:1732 build/C/man2/sched_setattr.2:407 build/C/man2/sched_setscheduler.2:217
#, no-wrap
msgid "BUGS"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:315
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:315 build/C/man2/clone.2:1780 build/C/man2/kcmp.2:322 build/C/man2/sched_setaffinity.2:306 build/C/man2/setns.2:324 build/C/man2/unshare.2:463
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:318
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:326
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:333
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:338
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:340
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:346
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:348
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:352
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (int cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:354
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:358
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:359 build/C/man2/clone.2:1903 build/C/man2/kcmp.2:429 build/C/man2/sched_get_priority_max.2:116 build/C/man3/sched_getcpu.3:107 build/C/man2/sched_rr_get_interval.2:132 build/C/man2/sched_setaffinity.2:416 build/C/man2/sched_setattr.2:433 build/C/man2/sched_setparam.2:121 build/C/man2/sched_setscheduler.2:225 build/C/man2/sched_yield.2:90 build/C/man7/sched.7:966 build/C/man2/setns.2:415 build/C/man2/unshare.2:553
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:364
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:364 build/C/man2/clone.2:1920 build/C/man2/kcmp.2:432 build/C/man2/sched_get_priority_max.2:126 build/C/man3/sched_getcpu.3:110 build/C/man2/sched_rr_get_interval.2:134 build/C/man2/sched_setaffinity.2:440 build/C/man2/sched_setattr.2:456 build/C/man2/sched_setparam.2:137 build/C/man2/sched_setscheduler.2:245 build/C/man2/sched_yield.2:92 build/C/man7/sched.7:1009 build/C/man2/setns.2:423 build/C/man2/unshare.2:568
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:372 build/C/man2/clone.2:1928 build/C/man2/kcmp.2:440 build/C/man2/sched_get_priority_max.2:134 build/C/man3/sched_getcpu.3:118 build/C/man2/sched_rr_get_interval.2:142 build/C/man2/sched_setaffinity.2:448 build/C/man2/sched_setattr.2:464 build/C/man2/sched_setparam.2:145 build/C/man2/sched_setscheduler.2:253 build/C/man2/sched_yield.2:100 build/C/man7/sched.7:1017 build/C/man2/setns.2:431 build/C/man2/unshare.2:576
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/clone.2:42
#, no-wrap
msgid "CLONE"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:45
msgid "clone, __clone2, clone3 - create a child process"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:48
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:51 build/C/man2/unshare.2:27
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:56
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<stack>B<, int >I<flags>B<, "
"void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, void *>I<tls>B<, pid_t "
"*>I<child_tid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:58
#, no-wrap
msgid "/* For the prototype of the raw clone() system call, see NOTES */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:60
#, no-wrap
msgid "B<long clone3(struct clone_args *>I<cl_args>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:66
msgid "I<Note>: There is not yet a glibc wrapper for B<clone3>(); see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:70
msgid ""
"These system calls create a new (\"child\") process, in a manner similar to "
"B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:81
msgid ""
"By contrast with B<fork>(2), these system calls provide more precise control "
"over what pieces of execution context are shared between the calling process "
"and the child process.  For example, using these system calls, the caller "
"can control whether or not the two processes share the virtual address "
"space, the table of file descriptors, and the table of signal handlers.  "
"These system calls also allow the new child process to be placed in separate "
"B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:89
msgid ""
"Note that in this manual page, \"calling process\" normally corresponds to "
"\"parent process\".  But see the descriptions of B<CLONE_PARENT> and "
"B<CLONE_THREAD> below."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:91
msgid "This page describes the following interfaces:"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:91 build/C/man2/clone.2:98 build/C/man2/clone.2:565 build/C/man2/clone.2:576 build/C/man2/clone.2:584 build/C/man2/clone.2:866 build/C/man2/clone.2:871 build/C/man2/clone.2:1797 build/C/man2/clone.2:1805 build/C/man7/sched.7:510 build/C/man7/sched.7:519 build/C/man7/sched.7:542 build/C/man7/sched.7:550 build/C/man7/sched.7:589 build/C/man7/sched.7:597 build/C/man7/sched.7:602 build/C/man7/sched.7:607 build/C/man7/sched.7:851 build/C/man7/sched.7:855 build/C/man7/sched.7:863 build/C/man7/sched.7:867 build/C/man7/sched.7:870
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:98
msgid ""
"The glibc B<clone>()  wrapper function and the underlying system call on "
"which it is based.  The main text describes the wrapper function; the "
"differences for the raw system call are described toward the end of this "
"page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:102
msgid "The newer B<clone3>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:106
msgid ""
"In the remainder of this page, the terminology \"the clone call\" is used "
"when noting details that apply to all of these interfaces,"
msgstr ""

#. type: SS
#: build/C/man2/clone.2:106
#, no-wrap
msgid "The clone() wrapper function"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:122
msgid ""
"When the child process is created with the B<clone>()  wrapper function, it "
"commences execution by calling the function pointed to by the argument "
"I<fn>.  (This differs from B<fork>(2), where execution continues in the "
"child from the point of the B<fork>(2)  call.)  The I<arg> argument is "
"passed as the argument of the function I<fn>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:132
msgid ""
"When the I<fn>(I<arg>)  function returns, the child process terminates.  The "
"integer returned by I<fn> is the exit status for the child process.  The "
"child process may also terminate explicitly by calling B<exit>(2)  or after "
"receiving a fatal signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:152
msgid ""
"The I<stack> argument specifies the location of the stack used by the child "
"process.  Since the child and calling process may share memory, it is not "
"possible for the child process to execute in the same stack as the calling "
"process.  The calling process must therefore set up memory space for the "
"child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<stack> usually points to the topmost address of the memory space set up "
"for the child stack.  Note that B<clone>()  does not provide a means whereby "
"the caller can inform the kernel of the size of the stack area."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:157
msgid "The remaining arguments to B<clone>()  are discussed below."
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:157 build/C/man2/clone.2:258
#, no-wrap
msgid "clone3()"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:167
msgid ""
"The B<clone3>()  system call provides a superset of the functionality of the "
"older B<clone>()  interface.  It also provides a number of API improvements, "
"including: space for additional flags bits; cleaner separation in the use of "
"various arguments; and the ability to specify the size of the child's stack "
"area."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:174
msgid ""
"As with B<fork>(2), B<clone3>()  returns in both the parent and the child.  "
"It returns 0 in the child process and returns the PID of the child in the "
"parent."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:180
msgid ""
"The I<cl_args> argument of B<clone3>()  is a structure of the following "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:203
#, no-wrap
msgid ""
"struct clone_args {\n"
"    u64 flags;        /* Flags bit mask */\n"
"    u64 pidfd;        /* Where to store PID file descriptor\n"
"                         (I<pid_t *>) */\n"
"    u64 child_tid;    /* Where to store child TID,\n"
"                         in child\\(aqs memory (I<pid_t *>) */\n"
"    u64 parent_tid;   /* Where to store child TID,\n"
"                         in parent\\(aqs memory (I<int *>) */\n"
"    u64 exit_signal;  /* Signal to deliver to parent on\n"
"                         child termination */\n"
"    u64 stack;        /* Pointer to lowest byte of stack */\n"
"    u64 stack_size;   /* Size of stack */\n"
"    u64 tls;          /* Location of new TLS */\n"
"    u64 set_tid;      /* Pointer to a I<pid_t> array\n"
"                         (since Linux 5.5) */\n"
"    u64 set_tid_size; /* Number of elements in I<set_tid>\n"
"                         (since Linux 5.5) */\n"
"    u64 cgroup;       /* File descriptor for target cgroup\n"
"                         of child (since Linux 5.7) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:216
msgid ""
"The I<size> argument that is supplied to B<clone3>()  should be initialized "
"to the size of this structure.  (The existence of the I<size> argument "
"permits future extensions to the I<clone_args> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:230
msgid ""
"The stack for the child process is specified via I<cl_args.stack>, which "
"points to the lowest byte of the stack area, and I<cl_args.stack_size>, "
"which specifies the size of the stack in bytes.  In the case where the "
"B<CLONE_VM> flag (see below) is specified, a stack must be explicitly "
"allocated and specified.  Otherwise, these two fields can be specified as "
"NULL and 0, which causes the child to use the same stack area as the parent "
"(in the child's own virtual address space)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:235
msgid "The remaining fields in the I<cl_args> argument are discussed below."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:235
#, no-wrap
msgid "Equivalence between clone() and clone3() arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:246
msgid ""
"Unlike the older B<clone>()  interface, where arguments are passed "
"individually, in the newer B<clone3>()  interface the arguments are packaged "
"into the I<clone_args> structure shown above.  This structure allows for a "
"superset of the information passed via the B<clone>()  arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:253
msgid ""
"The following table shows the equivalence between the arguments of "
"B<clone>()  and the fields in the I<clone_args> argument supplied to "
"B<clone3>():"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:258
#, no-wrap
msgid "clone()"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:258 build/C/man2/clone.2:332
#, no-wrap
msgid "Notes"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:259
#, no-wrap
msgid "I<cl_args> field"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "flags & \\(ti0xff"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "flags"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "For most flags; details below"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:261 build/C/man2/clone.2:263
#, no-wrap
msgid "parent_tid"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:261
#, no-wrap
msgid "pidfd"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:261
#, no-wrap
msgid "See CLONE_PIDFD"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:262
#, no-wrap
msgid "child_tid"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:262
#, no-wrap
msgid "See CLONE_CHILD_SETTID"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:263
#, no-wrap
msgid "See CLONE_PARENT_SETTID"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:264
#, no-wrap
msgid "flags & 0xff"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:264
#, no-wrap
msgid "exit_signal"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:265
#, no-wrap
msgid "stack"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:266 build/C/man2/clone.2:268 build/C/man2/clone.2:269 build/C/man2/clone.2:270
#, no-wrap
msgid "I<--->"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:266
#, no-wrap
msgid "stack_size"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:267
#, no-wrap
msgid "tls"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:267
#, no-wrap
msgid "See CLONE_SETTLS"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:268
#, no-wrap
msgid "set_tid"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:268
#, no-wrap
msgid "See below for details"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:269
#, no-wrap
msgid "set_tid_size"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:270
#, no-wrap
msgid "cgroup"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:270
#, no-wrap
msgid "See CLONE_INTO_CGROUP"
msgstr ""

#. type: SS
#: build/C/man2/clone.2:274
#, no-wrap
msgid "The child termination signal"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:293
msgid ""
"When the child process terminates, a signal may be sent to the parent.  The "
"termination signal is specified in the low byte of I<flags> (B<clone>())  or "
"in I<cl_args.exit_signal> (B<clone3>()).  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal (i.e., zero) is specified, then the parent process "
"is not signaled when the child terminates."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:293
#, no-wrap
msgid "The set_tid array"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:313
msgid ""
"By default, the kernel chooses the next sequential PID for the new process "
"in each of the PID namespaces where it is present.  When creating a process "
"with B<clone3>(), the I<set_tid> array (available since Linux 5.5)  can be "
"used to select specific PIDs for the process in some or all of the PID "
"namespaces where it is present.  If the PID of the newly created process "
"should be set only for the current PID namespace or in the newly created PID "
"namespace (if I<flags> contains B<CLONE_NEWPID>)  then the first element in "
"the I<set_tid> array has to be the desired PID and I<set_tid_size> needs to "
"be 1."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:326
msgid ""
"If the PID of the newly created process should have a certain value in "
"multiple PID namespaces, then the I<set_tid> array can have multiple "
"entries.  The first entry defines the PID in the most deeply nested PID "
"namespace and each of the following entries contains the PID in the "
"corresponding ancestor PID namespace.  The number of PID namespaces in which "
"a PID should be set is defined by I<set_tid_size> which cannot be larger "
"than the number of currently nested PID namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:328
msgid "To create a process with the following PIDs in a PID namespace hierarchy:"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:332
#, no-wrap
msgid "PID NS level"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:332
#, no-wrap
msgid "Requested PID"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:333 build/C/man2/kcmp.2:223
#, no-wrap
msgid "0"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:333
#, no-wrap
msgid "31496"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:333
#, no-wrap
msgid "Outermost PID namespace"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:334 build/C/man2/kcmp.2:228
#, no-wrap
msgid "1"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:334
#, no-wrap
msgid "42"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:335 build/C/man2/kcmp.2:232
#, no-wrap
msgid "2"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:335
#, no-wrap
msgid "7"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:335
#, no-wrap
msgid "Innermost PID namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:340
msgid "Set the array to:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:347
#, no-wrap
msgid ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid[2] = 31496;\n"
"set_tid_size = 3;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:352
msgid ""
"If only the PIDs in the two innermost PID namespaces need to be specified, "
"set the array to:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:358
#, no-wrap
msgid ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid_size = 2;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:363
msgid ""
"The PID in the PID namespaces outside the two innermost PID namespaces will "
"be selected the same way as any other PID is selected."
msgstr ""

#.  commit 124ea650d3072b005457faed69909221c2905a1f
#.  commit 1caef81da05a84a40dbf02110e967ce6d1135ff6
#. type: Plain text
#: build/C/man2/clone.2:374
msgid ""
"The I<set_tid> feature requires B<CAP_SYS_ADMIN> or (since Linux 5.9)  "
"B<CAP_CHECKPOINT_RESTORE> in all owning user namespaces of the target PID "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:382
msgid ""
"Callers may only choose a PID greater than 1 in a given PID namespace if an "
"B<init> process (i.e., a process with PID 1) already exists in that "
"namespace.  Otherwise the PID entry for this PID namespace must be 1."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:382
#, no-wrap
msgid "The flags mask"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:401
msgid ""
"Both B<clone>()  and B<clone3>()  allow a flags bit mask that modifies their "
"behavior and allows the caller to specify what is shared between the calling "
"process and the child process.  This bit mask\\(emthe I<flags> argument of "
"B<clone>()  or the I<cl_args.flags> field passed to B<clone3>()\\(emis "
"referred to as the I<flags> mask in the remainder of this page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:411
msgid ""
"The I<flags> mask is specified as a bitwise-OR of zero or more of the "
"constants listed below.  Except as noted below, these flags are available "
"(and have the same effect) in both B<clone>()  and B<clone3>()."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:411
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:425
msgid ""
"Clear (zero) the child thread ID at the location pointed to by I<child_tid> "
"(B<clone>())  or I<cl_args.child_tid> (B<clone3>())  in child memory when "
"the child exits, and do a wakeup on the futex at that address.  The address "
"involved may be changed by the B<set_tid_address>(2)  system call.  This is "
"used by threading libraries."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:425
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:440
msgid ""
"Store the child thread ID at the location pointed to by I<child_tid> "
"(B<clone>())  or I<cl_args.child_tid> (B<clone3>())  in the child's memory.  "
"The store operation completes before the clone call returns control to user "
"space in the child process.  (Note that the store operation may not have "
"completed before the clone call returns in the parent process, which will be "
"relevant if the B<CLONE_VM> flag is also employed.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:440
#, no-wrap
msgid "B<CLONE_CLEAR_SIGHAND> (since Linux 5.5)"
msgstr ""

#.  commit b612e5df4587c934bd056bf05f4a1deca4de4f75
#. type: Plain text
#: build/C/man2/clone.2:450
msgid ""
"By default, signal dispositions in the child thread are the same as in the "
"parent.  If this flag is specified, then all signals that are handled in the "
"parent are reset to their default dispositions (B<SIG_DFL>)  in the child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:454
msgid ""
"Specifying this flag together with B<CLONE_SIGHAND> is nonsensical and "
"disallowed."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:454
#, no-wrap
msgid "B<CLONE_DETACHED> (historical)"
msgstr ""

#.  added in 2.5.32; removed in 2.6.0-test4
#. type: Plain text
#: build/C/man2/clone.2:468
msgid ""
"For a while (during the Linux 2.5 development series)  there was a "
"B<CLONE_DETACHED> flag, which caused the parent not to receive a signal when "
"the child terminated.  Ultimately, the effect of this flag was subsumed "
"under the B<CLONE_THREAD> flag and by the time Linux 2.6.0 was released, "
"this flag had no effect.  Starting in Linux 2.6.2, the need to give this "
"flag together with B<CLONE_THREAD> disappeared."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:474
msgid ""
"This flag is still defined, but it is usually ignored when calling "
"B<clone>().  However, see the description of B<CLONE_PIDFD> for some "
"exceptions."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:474
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:490
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected.  If a process sharing a file descriptor table "
"calls B<execve>(2), its file descriptor table is duplicated (unshared)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:505
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of the clone call.  "
"Subsequent operations that open or close file descriptors, or change file "
"descriptor flags, performed by either the calling process or the child "
"process do not affect the other process.  Note, however, that the duplicated "
"file descriptors in the child refer to the same open file descriptions as "
"the corresponding file descriptors in the calling process, and thus share "
"file offsets and file status flags (see B<open>(2))."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:505
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:520
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same "
"filesystem information.  This includes the root of the filesystem, the "
"current working directory, and the umask.  Any call to B<chroot>(2), "
"B<chdir>(2), or B<umask>(2)  performed by the calling process or the child "
"process also affects the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:531
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the "
"filesystem information of the calling process at the time of the clone "
"call.  Calls to B<chroot>(2), B<chdir>(2), or B<umask>(2)  performed later "
"by one of the processes do not affect the other process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:531
#, no-wrap
msgid "B<CLONE_INTO_CGROUP> (since Linux 5.7)"
msgstr ""

#.  commit ef2c41cf38a7559bbf91af42d5b6a4429db8fc68
#. type: Plain text
#: build/C/man2/clone.2:542
msgid ""
"By default, a child process is placed in the same version 2 cgroup as its "
"parent.  The B<CLONE_INTO_CGROUP> flag allows the child process to be "
"created in a different version 2 cgroup.  (Note that B<CLONE_INTO_CGROUP> "
"has effect only for version 2 cgroups.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:560
msgid ""
"In order to place the child process in a different cgroup, the caller "
"specifies B<CLONE_INTO_CGROUP> in I<cl_args.flags> and passes a file "
"descriptor that refers to a version 2 cgroup in the I<cl_args.cgroup> "
"field.  (This file descriptor can be obtained by opening a cgroup v2 "
"directory using either the B<O_RDONLY> or the B<O_PATH> flag.)  Note that "
"all of the usual restrictions (described in B<cgroups>(7))  on placing a "
"process into a version 2 cgroup apply."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:564
msgid "Among the possible use cases for B<CLONE_INTO_CGROUP> are the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:576
msgid ""
"Spawning a process into a cgroup different from the parent's cgroup makes it "
"possible for a service manager to directly spawn new services into dedicated "
"cgroups.  This eliminates the accounting jitter that would be caused if the "
"child process was first created in the same cgroup as the parent and then "
"moved into the target cgroup.  Furthermore, spawning the child process "
"directly into a target cgroup is significantly cheaper than moving the child "
"process into the target cgroup after it has been created."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:584
msgid ""
"The B<CLONE_INTO_CGROUP> flag also allows the creation of frozen child "
"processes by spawning them into a frozen cgroup.  (See B<cgroups>(7)  for a "
"description of the freezer controller.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:589
msgid ""
"For threaded applications (or even thread implementations which make use of "
"cgroups to limit individual threads), it is possible to establish a fixed "
"cgroup layout before spawning each thread directly into its target cgroup."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:590
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:599
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:616
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:620
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:620 build/C/man2/setns.2:62 build/C/man2/unshare.2:76
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:626
msgid ""
"Create the process in a new cgroup namespace.  If this flag is not set, then "
"(as with B<fork>(2))  the process is created in the same cgroup namespaces "
"as the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:629
msgid "For further information on cgroup namespaces, see B<cgroup_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:635
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWCGROUP>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:635 build/C/man2/unshare.2:88
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:644
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:647
msgid "For further information on IPC namespaces, see B<ipc_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:654
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWIPC>.  "
"This flag can't be specified in conjunction with B<CLONE_SYSVSEM>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:654 build/C/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:658
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:666
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same network namespace as the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:669
msgid "For further information on network namespaces, see B<network_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:674
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNET>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:674
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:684
msgid ""
"If B<CLONE_NEWNS> is set, the cloned child is started in a new mount "
"namespace, initialized with a copy of the namespace of the parent.  If "
"B<CLONE_NEWNS> is not set, the child lives in the same mount namespace as "
"the parent."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:689
msgid ""
"For further information on mount namespaces, see B<namespaces>(7)  and "
"B<mount_namespaces>(7)."
msgstr ""

#.  See https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/clone.2:700
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNS>.  It "
"is not permitted to specify both B<CLONE_NEWNS> and B<CLONE_FS> in the same "
"clone call."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:700
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr ""

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:716
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2))  the process is created "
"in the same PID namespace as the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:721
msgid ""
"For further information on PID namespaces, see B<namespaces>(7)  and "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:730
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWPID>.  "
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:730
#, no-wrap
msgid "B<CLONE_NEWUSER>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:740
msgid ""
"(This flag first became meaningful for B<clone>()  in Linux 2.6.23, the "
"current B<clone>()  semantics were merged in Linux 3.5, and the final pieces "
"to make the user namespaces completely usable were merged in Linux 3.8.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:747
msgid ""
"If B<CLONE_NEWUSER> is set, then create the process in a new user "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same user namespace as the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:752
msgid ""
"For further information on user namespaces, see B<namespaces>(7)  and "
"B<user_namespaces>(7)."
msgstr ""

#.  Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
#. type: Plain text
#: build/C/man2/clone.2:763
msgid ""
"Before Linux 3.8, use of B<CLONE_NEWUSER> required that the caller have "
"three capabilities: B<CAP_SYS_ADMIN>, B<CAP_SETUID>, and B<CAP_SETGID>.  "
"Starting with Linux 3.8, no privileges are needed to create a user "
"namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#.  The fix actually went into 3.9 and into 3.8.3. However, user namespaces
#.  were, for practical purposes, unusable in earlier 3.8.x because of the
#.  various filesystems that didn't support userns.
#. type: Plain text
#: build/C/man2/clone.2:777
msgid ""
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>.  For security reasons, B<CLONE_NEWUSER> cannot be specified "
"in conjunction with B<CLONE_FS>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:777 build/C/man2/unshare.2:218
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:788
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2))  the process is created in the same UTS namespace as the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:791
msgid "For further information on UTS namespaces, see B<uts_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:796
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWUTS>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:796
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:803
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:809
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:817
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:825
msgid ""
"The B<CLONE_PARENT> flag can't be used in clone calls by the global init "
"process (PID 1 in the initial PID namespace)  and init processes in other "
"PID namespaces.  This restriction prevents the creation of multi-rooted "
"process trees as well as the creation of unreapable zombies in the initial "
"PID namespace."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:825
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:839
msgid ""
"Store the child thread ID at the location pointed to by I<parent_tid> "
"(B<clone>())  or I<cl_args.parent_tid> (B<clone3>())  in the parent's "
"memory.  (In Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did "
"this.)  The store operation completes before the clone call returns control "
"to user space."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:839
#, no-wrap
msgid "B<CLONE_PID> (Linux 2.0 to 2.5.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:856
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  From Linux 2.3.21 onward, this flag could be "
"specified only by the system boot process (PID 0).  The flag disappeared "
"completely from the kernel sources in Linux 2.5.16.  Subsequently, the "
"kernel silently ignored this bit if it was specified in the I<flags> mask.  "
"Much later, the same bit was recycled for use as the B<CLONE_PIDFD> flag."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:856
#, no-wrap
msgid "B<CLONE_PIDFD> (since Linux 5.2)"
msgstr ""

#.  commit b3e5838252665ee4cfa76b82bdf1198dca81e5be
#. type: Plain text
#: build/C/man2/clone.2:865
msgid ""
"If this flag is specified, a PID file descriptor referring to the child "
"process is allocated and placed at a specified location in the parent's "
"memory.  The close-on-exec flag is set on this new file descriptor.  PID "
"file descriptors can be used for the purposes described in B<pidfd_open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:871
msgid ""
"When using B<clone3>(), the PID file descriptor is placed at the location "
"pointed to by I<cl_args.pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:884
msgid ""
"When using B<clone>(), the PID file descriptor is placed at the location "
"pointed to by I<parent_tid>.  Since the I<parent_tid> argument is used to "
"return the PID file descriptor, B<CLONE_PIDFD> cannot be used with "
"B<CLONE_PARENT_SETTID> when calling B<clone>()."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:890
msgid ""
"It is currently not possible to use this flag together with B<CLONE_THREAD.> "
"This means that the process identified by the PID file descriptor will "
"always be a thread group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:905
msgid ""
"If the obsolete B<CLONE_DETACHED> flag is specified alongside B<CLONE_PIDFD> "
"when calling B<clone>(), an error is returned.  An error also results if "
"B<CLONE_DETACHED> is specified when calling B<clone3>().  This error "
"behavior ensures that the bit corresponding to B<CLONE_DETACHED> can be "
"reused for further PID file descriptor features in the future."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:905
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:912
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:912
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:916
msgid "The TLS (Thread Local Storage) descriptor is set to I<tls>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:933
msgid ""
"The interpretation of I<tls> and the resulting effect is architecture "
"dependent.  On x86, I<tls> is interpreted as a I<struct user_desc\\ *> (see "
"B<set_thread_area>(2)).  On x86-64 it is the new value to be set for the %fs "
"base register (see the B<ARCH_SET_FS> argument to B<arch_prctl>(2)).  On "
"architectures with a dedicated TLS register, it is the new value of that "
"register."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:936
msgid ""
"Use of this flag requires detailed knowledge and generally it should not be "
"used except in libraries implementing threading."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:936
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:952
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:961
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time of the clone call.  Calls "
"to B<sigaction>(2)  performed later by one of the processes have no effect "
"on the other process."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:971
msgid ""
"Since Linux 2.6.0, the I<flags> mask must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:971
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test2
#. type: Plain text
#: build/C/man2/clone.2:981
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:993
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38.  Since then, the kernel silently ignores it "
"without error.  Starting with Linux 4.6, the same bit was reused for the "
"B<CLONE_NEWCGROUP> flag."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:993
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1011
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore adjustment (I<semadj>)  values (see "
"B<semop>(2)).  In this case, the shared list accumulates I<semadj> values "
"across all processes sharing the list, and semaphore adjustments are "
"performed only when the last process that is sharing the list terminates (or "
"ceases sharing the list using B<unshare>(2)).  If this flag is not set, then "
"the child has a separate I<semadj> list that is initially empty."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1011
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test8
#. type: Plain text
#: build/C/man2/clone.2:1021
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1029
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1037
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller, and a thread can obtain its own TID using "
"B<gettid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1045
msgid ""
"When a clone call is made without specifying B<CLONE_THREAD>, then the "
"resulting thread is placed in a new thread group whose TGID is the same as "
"the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1064
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"process that made the clone call (i.e., like B<CLONE_PARENT>), so that calls "
"to B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"is not sent a B<SIGCHLD> (or other termination) signal; nor can the status "
"of such a thread be obtained using B<wait>(2).  (The thread is said to be "
"I<detached>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1069
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1074
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1080
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:1094
msgid ""
"Since Linux 2.5.35, the I<flags> mask must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified (and note that, since Linux 2.6.0, "
"B<CLONE_SIGHAND> also requires B<CLONE_VM> to be included)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1099
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1102
msgid "Each thread has its own signal mask, as set by B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1124
msgid ""
"A signal may be process-directed or thread-directed.  A process-directed "
"signal is targeted at a thread group (i.e., a TGID), and is delivered to an "
"arbitrarily selected thread from among those that are not blocking the "
"signal.  A signal may be process-directed because it was generated by the "
"kernel for reasons other than a hardware exception, or because it was sent "
"using B<kill>(2)  or B<sigqueue>(3).  A thread-directed signal is targeted "
"at (i.e., delivered to)  a specific thread.  A signal may be thread directed "
"because it was sent using B<tgkill>(2)  or B<pthread_sigqueue>(3), or "
"because the thread executed a machine language instruction that triggered a "
"hardware exception (e.g., invalid memory access triggering B<SIGSEGV> or a "
"floating-point exception triggering B<SIGFPE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1129
msgid ""
"A call to B<sigpending>(2)  returns a signal set that is the union of the "
"pending process-directed signals and the signals that are pending for the "
"calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1138
msgid ""
"If a process-directed signal is delivered to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive the signal."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1138
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1145
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1145
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1157
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1163
msgid ""
"If B<CLONE_VFORK> is not set, then both the calling process and the child "
"are schedulable after the call, and an application should not rely on "
"execution occurring in any particular order."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1163
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1176
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1184
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of the clone call.  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1193
msgid ""
"If the B<CLONE_VM> flag is specified and the B<CLONE_VM> flag is not "
"specified, then any alternate signal stack that was established by "
"B<sigaltstack>(2)  is cleared in the child process."
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:1202
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/clone.2:1202 build/C/man2/kcmp.2:251 build/C/man2/sched_get_priority_max.2:108 build/C/man3/sched_getcpu.3:65 build/C/man2/sched_rr_get_interval.2:80 build/C/man2/sched_setaffinity.2:119 build/C/man2/sched_setattr.2:308 build/C/man2/sched_setparam.2:96 build/C/man2/sched_setscheduler.2:143 build/C/man2/sched_yield.2:48 build/C/man2/setns.2:252 build/C/man2/unshare.2:291
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1203
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1207
msgid "Too many processes are already running; see B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1207
#, no-wrap
msgid "B<EBUSY> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1215
msgid ""
"B<CLONE_INTO_CGROUP> was specified in I<cl_args.flags>, but the file "
"descriptor specified in I<cl_args.cgroup> refers to a version 2 cgroup in "
"which a domain controller is enabled."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1215
#, no-wrap
msgid "B<EEXIST> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1220
msgid ""
"One (or more) of the PIDs specified in I<set_tid> already exists in the "
"corresponding PID namespace."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1220 build/C/man2/clone.2:1229 build/C/man2/clone.2:1239 build/C/man2/clone.2:1256 build/C/man2/clone.2:1268 build/C/man2/clone.2:1287 build/C/man2/clone.2:1296 build/C/man2/clone.2:1314 build/C/man2/clone.2:1323 build/C/man2/clone.2:1334 build/C/man2/clone.2:1343 build/C/man2/clone.2:1352 build/C/man2/clone.2:1361 build/C/man2/clone.2:1370 build/C/man2/clone.2:1391 build/C/man2/kcmp.2:267 build/C/man2/sched_get_priority_max.2:109 build/C/man2/sched_rr_get_interval.2:84 build/C/man2/sched_setaffinity.2:123 build/C/man2/sched_setaffinity.2:133 build/C/man2/sched_setattr.2:313 build/C/man2/sched_setattr.2:337 build/C/man2/sched_setattr.2:360 build/C/man2/sched_setparam.2:97 build/C/man2/sched_setparam.2:104 build/C/man2/sched_setscheduler.2:144 build/C/man2/sched_setscheduler.2:151 build/C/man2/sched_setscheduler.2:156 build/C/man2/setns.2:257 build/C/man2/setns.2:262 build/C/man2/setns.2:266 build/C/man2/setns.2:271 build/C/man2/setns.2:275 build/C/man2/setns.2:282 build/C/man2/setns.2:286 build/C/man2/unshare.2:292 build/C/man2/unshare.2:296 build/C/man2/unshare.2:305 build/C/man2/unshare.2:315 build/C/man2/unshare.2:323 build/C/man2/unshare.2:331 build/C/man2/unshare.2:339 build/C/man2/unshare.2:347
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1229
msgid ""
"Both B<CLONE_SIGHAND> and B<CLONE_CLEAR_SIGHAND> were specified in the "
"I<flags> mask."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:1239
msgid ""
"B<CLONE_SIGHAND> was specified in the I<flags> mask, but B<CLONE_VM> was "
"not.  (Since Linux 2.6.0.)"
msgstr ""

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:1256
msgid ""
"B<CLONE_THREAD> was specified in the I<flags> mask, but B<CLONE_SIGHAND> was "
"not.  (Since Linux 2.5.35.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1268
msgid ""
"B<CLONE_THREAD> was specified in the I<flags> mask, but the current process "
"previously called B<unshare>(2)  with the B<CLONE_NEWPID> flag or used "
"B<setns>(2)  to reassociate itself with a PID namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: build/C/man2/clone.2:1278
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in the I<flags> mask."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1278
#, no-wrap
msgid "B<EINVAL> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1287
msgid "Both B<CLONE_NEWUSER> and B<CLONE_FS> were specified in the I<flags> mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1296
msgid ""
"Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in the I<flags> "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1309
msgid ""
"One (or both) of B<CLONE_NEWPID> or B<CLONE_NEWUSER> and one (or both) of "
"B<CLONE_THREAD> or B<CLONE_PARENT> were specified in the I<flags> mask."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1309
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.32)"
msgstr ""

#.  commit 123be07b0b399670a7cc3d82fef0cb4f93ef885c
#. type: Plain text
#: build/C/man2/clone.2:1314
msgid "B<CLONE_PARENT> was specified, and the caller is an init process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1323
msgid ""
"Returned by the glibc B<clone>()  wrapper function when I<fn> or I<stack> is "
"specified as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1334
msgid ""
"B<CLONE_NEWIPC> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1343
msgid ""
"B<CLONE_NEWNET> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1352
msgid ""
"B<CLONE_NEWPID> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1361
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1370
msgid ""
"B<CLONE_NEWUTS> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_UTS_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1377
msgid ""
"I<stack> is not aligned to a suitable boundary for this architecture.  For "
"example, on aarch64, I<stack> must be a multiple of 16."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1377 build/C/man2/clone.2:1407 build/C/man2/clone.2:1411
#, no-wrap
msgid "B<EINVAL> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1383
msgid "B<CLONE_DETACHED> was specified in the I<flags> mask."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1383
#, no-wrap
msgid "B<EINVAL> (B<clone>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1391
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_DETACHED> in the I<flags> "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1399
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_THREAD> in the I<flags> "
"mask."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1399
#, no-wrap
msgid "B<EINVAL >(B<clone>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1407
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_PARENT_SETTID> in the "
"I<flags> mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1411
msgid "I<set_tid_size> is greater than the number of nested PID namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1416
msgid "One of the PIDs specified in I<set_tid> was an invalid."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1416
#, no-wrap
msgid "B<EINVAL> (AArch64 only, Linux 4.6 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1420
msgid "I<stack> was not aligned to a 126-bit boundary."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1420 build/C/man2/setns.2:292 build/C/man2/unshare.2:357
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1425
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be "
"copied."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1425 build/C/man2/unshare.2:361
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: build/C/man2/clone.2:1435
msgid ""
"B<CLONE_NEWPID> was specified in the I<flags> mask, but the limit on the "
"nesting depth of PID namespaces would have been exceeded; see "
"B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1435 build/C/man2/unshare.2:369
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1444
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, and the call would "
"cause the limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1447 build/C/man2/unshare.2:381
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was "
"B<EUSERS>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1447 build/C/man2/unshare.2:381
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1457
msgid ""
"One of the values in the I<flags> mask specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1457
#, no-wrap
msgid "B<EOPNOTSUPP> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1467
msgid ""
"B<CLONE_INTO_CGROUP> was specified in I<cl_args.flags>, but the file "
"descriptor specified in I<cl_args.cgroup> refers to a version 2 cgroup that "
"is in the I<domain invalid> state."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1467 build/C/man2/clone.2:1477 build/C/man2/clone.2:1482 build/C/man2/kcmp.2:276 build/C/man2/sched_setaffinity.2:140 build/C/man2/sched_setattr.2:376 build/C/man2/sched_setattr.2:379 build/C/man2/sched_setparam.2:109 build/C/man2/sched_setscheduler.2:162 build/C/man2/setns.2:295 build/C/man2/unshare.2:391 build/C/man2/unshare.2:394
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1477
msgid ""
"B<CLONE_NEWCGROUP>, B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, "
"B<CLONE_NEWPID>, or B<CLONE_NEWUTS> was specified by an unprivileged process "
"(process without B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1482
msgid ""
"B<CLONE_PID> was specified by a process other than process 0.  (This error "
"occurs only on Linux 2.5.15 and earlier.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1491
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, but either the "
"effective user ID or the effective group ID of the caller does not have a "
"mapping in the parent namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1491 build/C/man2/unshare.2:402
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr ""

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: build/C/man2/clone.2:1501
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask and the caller is in a "
"chroot environment (i.e., the caller's root directory does not match the "
"root directory of the mount namespace in which it resides)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1501
#, no-wrap
msgid "B<EPERM> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1508
msgid ""
"I<set_tid_size> was greater than zero, and the caller lacks the "
"B<CAP_SYS_ADMIN> capability in one or more of the user namespaces that own "
"the corresponding PID namespaces."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1508
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr ""

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: build/C/man2/clone.2:1513
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1513
#, no-wrap
msgid "B<EUSERS> (Linux 3.11 to Linux 4.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1523
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, and the limit on the "
"number of nested user namespaces would be exceeded.  See the discussion of "
"the B<ENOSPC> error above."
msgstr ""

#.  There is no entry for
#.  .BR clone ()
#.  in libc5.
#.  glibc2 provides
#.  .BR clone ()
#.  as described in this manual page.
#. type: Plain text
#: build/C/man2/clone.2:1533
msgid "The B<clone3>()  system call first appeared in Linux 5.3."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1537
msgid ""
"These system calls are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1541
msgid ""
"One use of these systems calls is to implement threads: multiple flows of "
"control in a program that run concurrently in a shared address space."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1546
msgid ""
"Glibc does not provide a wrapper for B<clone3>(); call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1562
msgid ""
"Note that the glibc B<clone>()  wrapper function makes some changes in the "
"memory pointed to by I<stack> (changes required to set the stack up "
"correctly for the child)  I<before> invoking the B<clone>()  system call.  "
"So, in cases where B<clone>()  is used to recursively create children, do "
"not use the buffer employed for the parent's stack as the stack of the "
"child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1568
msgid ""
"The B<kcmp>(2)  system call can be used to test whether two processes share "
"various resources such as a file descriptor table, System V semaphore undo "
"operations, or a virtual address space."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1572
msgid ""
"Handlers registered using B<pthread_atfork>(3)  are not executed during a "
"clone call."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1582
msgid ""
"In the Linux 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in Linux 2.6.0 and later)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1588
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1588 build/C/man2/sched_setaffinity.2:236
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1602
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1624
msgid ""
"In contrast to the glibc wrapper, the raw B<clone>()  system call accepts "
"NULL as a I<stack> argument (and B<clone3>()  likewise allows "
"I<cl_args.stack> to be NULL).  In this case, the child uses a duplicate of "
"the parent's stack.  (Copy-on-write semantics ensure that the child gets "
"separate copies of stack pages when either process modifies the stack.)  In "
"this case, for correct operation, the B<CLONE_VM> option should not be "
"specified.  (If the child I<shares> the parent's memory because of the use "
"of the B<CLONE_VM> flag, then no copy-on-write duplication occurs and chaos "
"is likely to result.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1628
msgid ""
"The order of the arguments also differs in the raw system call, and there "
"are variations in the arguments across architectures, as detailed in the "
"following paragraphs."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1631
msgid ""
"The raw system call interface on x86-64 and some other architectures "
"(including sh, tile, and alpha) is:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1637
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS
#. type: Plain text
#: build/C/man2/clone.2:1645
msgid ""
"On x86-32, and several other common architectures (including score, ARM, ARM "
"64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order of the last two "
"arguments is reversed:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1651
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<          int *>I<parent_tid>B<, unsigned long >I<tls>B<,>\n"
"B<          int *>I<child_tid>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS2
#. type: Plain text
#: build/C/man2/clone.2:1657
msgid ""
"On the cris and s390 architectures, the order of the first two arguments is "
"reversed:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1663
#, no-wrap
msgid ""
"B<long clone(void *>I<stack>B<, unsigned long >I<flags>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS3
#. type: Plain text
#: build/C/man2/clone.2:1669
msgid "On the microblaze architecture, an additional argument is supplied:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1676
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int >I<stack_size>B<,>         /* Size of stack */\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1679
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr ""

#.  Mike Frysinger noted in a 2013 mail:
#.      these arches don't define __ARCH_WANT_SYS_CLONE:
#.      blackfin ia64 m68k sparc
#. type: Plain text
#: build/C/man2/clone.2:1686
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from the descriptions above.  For details, see the kernel (and glibc) "
"source."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1686
#, no-wrap
msgid "ia64"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1688
msgid "On ia64, a different interface is used:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1696
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *),>\n"
"B<             void *>I<stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, struct user_desc *>I<tls>B<,>\n"
"B<             pid_t *>I<child_tid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1704
msgid ""
"The prototype shown above is for the glibc wrapper function; for the system "
"call itself, the prototype can be described as follows (it is identical to "
"the B<clone>()  prototype on microblaze):"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1711
#, no-wrap
msgid ""
"B<long clone2(unsigned long >I<flags>B<, void *>I<stack_base>B<,>\n"
"B<            int >I<stack_size>B<,>         /* Size of stack */\n"
"B<            int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<            unsigned long >I<tls>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1724
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<stack_base> points to the lowest address of the child's stack area, and "
"I<stack_size> specifies the size of the stack pointed to by I<stack_base>."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1724
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1732
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<parent_tid>, "
"I<tls>, and I<child_tid>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1763
msgid ""
"GNU C library versions 2.3.4 up to and including 2.24 contained a wrapper "
"function for B<getpid>(2)  that performed caching of PIDs.  This caching "
"relied on support in the glibc wrapper for B<clone>(), but limitations in "
"the implementation meant that the cache was not up to date in some "
"circumstances.  In particular, if a signal was delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal could return the PID of the calling process (\"the "
"parent\"), if the clone wrapper had not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it was sometimes necessary to use code such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1767
#, no-wrap
msgid "#include E<lt>syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1769
#, no-wrap
msgid "pid_t mypid;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1771
#, no-wrap
msgid "mypid = syscall(SYS_getpid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1780
msgid ""
"Because of the stale-cache problem, as well as other problems noted in "
"B<getpid>(2), the PID caching feature was removed in glibc 2.25."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1790
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1797
msgid ""
"Within the sample program, we allocate the memory that is to be used for the "
"child's stack using B<mmap>(2)  rather than B<malloc>(3)  for the following "
"reasons:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1805
msgid ""
"B<mmap>(2)  allocates a block of memory that starts on a page boundary and "
"is a multiple of the page size.  This is useful if we want to establish a "
"guard page (a page with protection B<PROT_NONE>)  at the end of the stack "
"using B<mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1812
msgid ""
"We can specify the B<MAP_STACK> flag to request a mapping that is suitable "
"for a stack.  For the moment, this flag is a no-op on Linux, but it exists "
"and has effect on some other systems, so we should include it for "
"portability."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1812 build/C/man2/kcmp.2:348 build/C/man2/sched_setaffinity.2:355 build/C/man2/setns.2:378 build/C/man2/unshare.2:486
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1824
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1827 build/C/man2/kcmp.2:364 build/C/man2/sched_setaffinity.2:367 build/C/man2/setns.2:389 build/C/man2/unshare.2:505
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1832
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1834
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1837
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1839
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1843
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1847
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1849
#, no-wrap
msgid "    sleep(200);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1852
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1854
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1862
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1867
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1869
#, no-wrap
msgid "    /* Allocate memory to be used for the stack of the child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1874
#, no-wrap
msgid ""
"    stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,\n"
"                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n"
"    if (stack == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1876
#, no-wrap
msgid "    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1879
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1884
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %jd\\en\", (intmax_t) pid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1886
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1888
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1891
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1895
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1899
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1902 build/C/man2/kcmp.2:428
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1920
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), B<mmap>(2), "
"B<pidfd_open>(2), B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), "
"B<tkill>(2), B<unshare>(2), B<wait>(2), B<capabilities>(7), "
"B<namespaces>(7), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man2/kcmp.2:28
#, no-wrap
msgid "KCMP"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:31
msgid "kcmp - compare two processes to determine if they share a kernel resource"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:34
#, no-wrap
msgid "B<#include E<lt>linux/kcmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:37
#, no-wrap
msgid ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:50
msgid ""
"The B<kcmp>()  system call can be used to check whether the two processes "
"identified by I<pid1> and I<pid2> share a kernel resource such as virtual "
"memory, file descriptors, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:61
msgid ""
"Permission to employ B<kcmp>()  is governed by ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> checks against both I<pid1> and I<pid2>; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:66
msgid ""
"The I<type> argument specifies which resource is to be compared in the two "
"processes.  It has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:66
#, no-wrap
msgid "B<KCMP_FILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:85
msgid ""
"Check whether a file descriptor I<idx1> in the process I<pid1> refers to the "
"same open file description (see B<open>(2))  as file descriptor I<idx2> in "
"the process I<pid2>.  The existence of two file descriptors that refer to "
"the same open file description can occur as a result of B<dup>(2)  (and "
"similar)  B<fork>(2), or passing file descriptors via a domain socket (see "
"B<unix>(7))."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:85
#, no-wrap
msgid "B<KCMP_FILES>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:97
msgid ""
"Check whether the processes share the same set of open file descriptors.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FILES> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:97
#, no-wrap
msgid "B<KCMP_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:110
msgid ""
"Check whether the processes share the same filesystem information (i.e., "
"file mode creation mask, working directory, and filesystem root).  The "
"arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FS> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:110
#, no-wrap
msgid "B<KCMP_IO>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:122
msgid ""
"Check whether the processes share I/O context.  The arguments I<idx1> and "
"I<idx2> are ignored.  See the discussion of the B<CLONE_IO> flag in "
"B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:122
#, no-wrap
msgid "B<KCMP_SIGHAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:134
msgid ""
"Check whether the processes share the same table of signal dispositions.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_SIGHAND> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:134
#, no-wrap
msgid "B<KCMP_SYSVSEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:147
msgid ""
"Check whether the processes share the same list of System\\ V semaphore undo "
"operations.  The arguments I<idx1> and I<idx2> are ignored.  See the "
"discussion of the B<CLONE_SYSVSEM> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:147
#, no-wrap
msgid "B<KCMP_VM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:159
msgid ""
"Check whether the processes share the same address space.  The arguments "
"I<idx1> and I<idx2> are ignored.  See the discussion of the B<CLONE_VM> flag "
"in B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:159
#, no-wrap
msgid "B<KCMP_EPOLL_TFD> (since Linux 4.13)"
msgstr ""

#.  commit 0791e3644e5ef21646fe565b9061788d05ec71d4
#. type: Plain text
#: build/C/man2/kcmp.2:176
msgid ""
"Check whether the file descriptor I<idx1> of the process I<pid1> is present "
"in the B<epoll>(7)  instance described by I<idx2> of the process I<pid2>.  "
"The argument I<idx2> is a pointer to a structure where the target file is "
"described.  This structure has the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:184
#, no-wrap
msgid ""
"struct kcmp_epoll_slot {\n"
"    __u32 efd;\n"
"    __u32 tfd;\n"
"    __u64 toff;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:198
msgid ""
"Within this structure, I<efd> is an epoll file descriptor returned from "
"B<epoll_create>(2), I<tfd> is a target file descriptor number, and I<toff> "
"is a target file offset counted from zero.  Several different targets may be "
"registered with the same file descriptor number and setting a specific "
"offset helps to investigate each of them."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:208
msgid ""
"Note the B<kcmp>()  is not protected against false positives which may occur "
"if the processes are currently running.  One should stop the processes by "
"sending B<SIGSTOP> (see B<signal>(7))  prior to inspection with this system "
"call to obtain meaningful results."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:214
msgid ""
"The return value of a successful call to B<kcmp>()  is simply the result of "
"arithmetic comparison of kernel pointers (when the kernel compares "
"resources, it uses their memory addresses)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:222
msgid ""
"The easiest way to explain is to consider an example.  Suppose that I<v1> "
"and I<v2> are the addresses of appropriate resources, then the return value "
"is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:228
msgid ""
"I<v1> is equal to I<v2>; in other words, the two processes share the "
"resource."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:232
msgid "I<v1> is less than I<v2>."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:236
msgid "I<v1> is greater than I<v2>."
msgstr ""

#. type: IP
#: build/C/man2/kcmp.2:236
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:241
msgid "I<v1> is not equal to I<v2>, but ordering information is unavailable."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:246
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:251
msgid ""
"B<kcmp>()  was designed to return values suitable for sorting.  This is "
"particularly handy if one needs to compare a large number of file "
"descriptors."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:252 build/C/man2/setns.2:253
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:262
msgid "I<type> is B<KCMP_FILE> and I<fd1> or I<fd2> is not an open file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:262 build/C/man2/sched_rr_get_interval.2:81 build/C/man2/sched_setaffinity.2:120
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:267
msgid "The epoll slot addressed by I<idx2> is outside of the user's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:271
msgid "I<type> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:271
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:276
msgid "The target file is not present in B<epoll>(7)  instance."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:291
msgid ""
"Insufficient permission to inspect process resources.  The B<CAP_SYS_PTRACE> "
"capability is required to inspect processes that you do not own.  Other "
"ptrace limitations may also apply, such as B<CONFIG_SECURITY_YAMA>, which, "
"when I</proc/sys/kernel/yama/ptrace_scope> is 2, limits B<kcmp>()  to child "
"processes; see B<ptrace>(2)."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:291 build/C/man2/sched_rr_get_interval.2:90 build/C/man2/sched_setaffinity.2:151 build/C/man2/sched_setattr.2:321 build/C/man2/sched_setparam.2:116 build/C/man2/sched_setscheduler.2:165 build/C/man2/setns.2:299
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:298
msgid "Process I<pid1> or I<pid2> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:302
msgid "The B<kcmp>()  system call first appeared in Linux 3.5."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:305
msgid ""
"B<kcmp>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:308
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:317
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>.  The main use of the system call is for the "
"checkpoint/restore in user space (CRIU) feature.  The alternative to this "
"system call would have been to expose suitable process information via the "
"B<proc>(5)  filesystem; this was deemed to be unsuitable for security "
"reasons."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:322
msgid ""
"See B<clone>(2)  for some background information on the shared resources "
"referred to on this page."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:330
msgid ""
"The program below uses B<kcmp>()  to test whether pairs of file descriptors "
"refer to the same open file description.  The program tests different cases "
"for the file descriptor pairs, as described in the program output.  An "
"example run of the program is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:336
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Parent PID is 1144\n"
"Parent opened file on FD 3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:346
#, no-wrap
msgid ""
"PID of child of fork() is 1145\n"
"\tCompare duplicate FDs from different processes:\n"
"\t\tkcmp(1145, 1144, KCMP_FILE, 3, 3) ==E<gt> same\n"
"Child opened file on FD 4\n"
"\tCompare FDs from distinct open()s in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 4) ==E<gt> different\n"
"Child duplicated FD 3 to create FD 5\n"
"\tCompare duplicated FDs in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 5) ==E<gt> same\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:361
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/kcmp.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:371
#, no-wrap
msgid ""
"static int\n"
"kcmp(pid_t pid1, pid_t pid2, int type,\n"
"     unsigned long idx1, unsigned long idx2)\n"
"{\n"
"    return syscall(SYS_kcmp, pid1, pid2, type, idx1, idx2);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:381
#, no-wrap
msgid ""
"static void\n"
"test_kcmp(char *msg, pid_t pid1, pid_t pid2, int fd_a, int fd_b)\n"
"{\n"
"    printf(\"\\et%s\\en\", msg);\n"
"    printf(\"\\et\\etkcmp(%jd, %jd, KCMP_FILE, %d, %d) ==E<gt> %s\\en\",\n"
"            (intmax_t) pid1, (intmax_t) pid2, fd_a, fd_b,\n"
"            (kcmp(pid1, pid2, KCMP_FILE, fd_a, fd_b) == 0) ?\n"
"                        \"same\" : \"different\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:387
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd1, fd2, fd3;\n"
"    char pathname[] = \"/tmp/kcmp.test\";\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:391
#, no-wrap
msgid ""
"    fd1 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"    if (fd1 == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:394
#, no-wrap
msgid ""
"    printf(\"Parent PID is %jd\\en\", (intmax_t) getpid());\n"
"    printf(\"Parent opened file on FD %d\\en\\en\", fd1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:398
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:401
#, no-wrap
msgid ""
"    case 0:\n"
"        printf(\"PID of child of fork() is %jd\\en\", (intmax_t) "
"getpid());\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:404
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicate FDs from different processes:\",\n"
"                getpid(), getppid(), fd1, fd1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:409
#, no-wrap
msgid ""
"        fd2 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"        if (fd2 == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"Child opened file on FD %d\\en\", fd2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:412
#, no-wrap
msgid ""
"        test_kcmp(\"Compare FDs from distinct open()s in same process:\",\n"
"                getpid(), getpid(), fd1, fd2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:417
#, no-wrap
msgid ""
"        fd3 = dup(fd1);\n"
"        if (fd3 == -1)\n"
"            errExit(\"dup\");\n"
"        printf(\"Child duplicated FD %d to create FD %d\\en\", fd1, fd3);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:421
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicated FDs in same process:\",\n"
"                getpid(), getpid(), fd1, fd3);\n"
"        break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:425
#, no-wrap
msgid ""
"    default:\n"
"        wait(NULL);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:432
msgid "B<clone>(2), B<unshare>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26 build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setscheduler.2:26 build/C/man2/sched_yield.2:29
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:32
msgid "sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:34 build/C/man2/sched_rr_get_interval.2:34 build/C/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:59
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, B<SCHED_IDLE>, and B<SCHED_DEADLINE>.  Further details about "
"these policies can be found in B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:68
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:76
msgid ""
"Linux allows the static priority range 1 to 99 for the B<SCHED_FIFO> and "
"B<SCHED_RR> policies, and the priority 0 for the remaining policies.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008 (XBD 2.8.4)
#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:89
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min> POSIX.1 requires a spread of at least 32 between "
"the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:98
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:108
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:114
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:116 build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setparam.2:121 build/C/man2/sched_yield.2:54
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:126
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:32 build/C/man2/sched_setattr.2:33 build/C/man2/sched_setparam.2:36 build/C/man2/sched_setscheduler.2:33
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:39
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr ""

#. type: TP
#: build/C/man3/sched_getcpu.3:45
#, no-wrap
msgid "Since glibc 2.14:"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:48
msgid "_GNU_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/sched_getcpu.3:48
#, no-wrap
msgid "Before glibc 2.14:"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:52
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/sched_getcpu.3:66 build/C/man2/sched_rr_get_interval.2:87
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr ""

#. type: SH
#: build/C/man3/sched_getcpu.3:72
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:75
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "B<sched_getcpu>()"
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:87
msgid "B<sched_getcpu>()  is glibc-specific."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:89
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:93
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:99
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:105
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:110
msgid "B<getcpu>(2), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:36
msgid "B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:103
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the "
"round-robin time quantum.  Older Linux kernels provide a (nonportable) "
"method of doing this.  The quantum can be controlled by adjusting the "
"process's nice value (see B<setpriority>(2)).  Assigning a negative (i.e., "
"high) nice value results in a longer quantum; assigning a positive (i.e., "
"low) nice value results in a shorter quantum.  The default quantum is 0.1 "
"seconds; the degree to which changing the nice value affects the quantum has "
"varied somewhat across kernel versions.  This method of adjusting the "
"quantum was removed starting with Linux 2.6.24."
msgstr ""

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:134 build/C/man2/sched_yield.2:92
msgid "B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU "
"set\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is "
"I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes) "
"of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:119
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0 "
"(but see \"C library/kernel differences\" below, which notes that the "
"underlying B<sched_getaffinity>()  differs in its return value).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:123
msgid "A supplied memory address was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:133
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by I<cpuset> cgroups or the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:140
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:151
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the thread identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability in the user namespace of the thread I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:154 build/C/man2/sched_setattr.2:326 build/C/man2/sched_setparam.2:119 build/C/man2/sched_setscheduler.2:168
msgid "The thread whose ID is I<pid> could not be found."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:165
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:167
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:180
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the thread runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:192
msgid ""
"There are various ways of determining the number of CPUs available on the "
"system, including: inspecting the contents of I</proc/cpuinfo>; using "
"B<sysconf>(3)  to obtain the values of the B<_SC_NPROCESSORS_CONF> and "
"B<_SC_NPROCESSORS_ONLN> parameters; and inspecting the list of CPU "
"directories under I</sys/devices/system/cpu/>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:195
msgid "B<sched>(7)  has a description of the Linux scheduling scheme."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:212
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:230
msgid ""
"The I<isolcpus> boot option can be used to isolate one or more CPUs at boot "
"time, so that no processes are scheduled onto those CPUs.  Following the use "
"of this boot option, the only way to schedule processes onto the isolated "
"CPUs is via B<sched_setaffinity>()  or the B<cpuset>(7)  mechanism.  For "
"further information, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>.  As noted in that file, "
"I<isolcpus> is the preferred mechanism of isolating CPUs (versus the "
"alternative of manually setting the CPU affinity of all processes on the "
"system)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:236
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:244
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:256
msgid ""
"On success, the raw B<sched_getaffinity>()  system call returns the number "
"of bytes placed copied into the I<mask> buffer; this will be the minimum of "
"I<cpusetsize> and the size (in bytes) of the I<cpumask_t> data type that is "
"used internally by the kernel to represent the CPU set bit mask."
msgstr ""

#. type: SS
#: build/C/man2/sched_setaffinity.2:256
#, no-wrap
msgid "Handling systems with large CPU affinity masks"
msgstr ""

#.  FIXME . See https://sourceware.org/bugzilla/show_bug.cgi?id=15630
#.  and https://sourceware.org/ml/libc-alpha/2013-07/msg00288.html
#. type: Plain text
#: build/C/man2/sched_setaffinity.2:268
msgid ""
"The underlying system calls (which represent CPU masks as bit masks of type "
"I<unsigned long\\ *>)  impose no restriction on the size of the CPU mask.  "
"However, the I<cpu_set_t> data type used by glibc has a fixed size of 128 "
"bytes, meaning that the maximum CPU number that can be represented is 1023.  "
"If the kernel CPU affinity mask is larger than 1024, then calls of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:270
#, no-wrap
msgid "    sched_getaffinity(pid, sizeof(cpu_set_t), &mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:280
msgid ""
"fail with the error B<EINVAL>, the error produced by the underlying system "
"call for the case where the I<mask> size specified in I<cpusetsize> is "
"smaller than the size of the affinity mask used by the kernel.  (Depending "
"on the system CPU topology, the kernel affinity mask can be substantially "
"larger than the number of active CPUs in the system.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:291
msgid ""
"When working on systems with large kernel CPU affinity masks, one must "
"dynamically allocate the I<mask> argument (see B<CPU_ALLOC>(3)).  Currently, "
"the only way to do this is by probing for the size of the required mask "
"using B<sched_getaffinity>()  calls with increasing mask sizes (until the "
"call does not fail with the error B<EINVAL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:306
msgid ""
"Be aware that B<CPU_ALLOC>(3)  may allocate a slightly larger CPU set than "
"requested (because CPU sets are implemented as bit masks allocated in units "
"of I<sizeof(long)>).  Consequently, B<sched_getaffinity>()  can set bits "
"beyond the requested allocation size, because the kernel sees a few "
"additional bits.  Therefore, the caller should iterate over the bits in the "
"returned set, counting those which are set, and stop upon reaching the value "
"returned by B<CPU_COUNT>(3)  (rather than iterating over the number of bits "
"requested to be allocated)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:315
msgid ""
"The program below creates a child process.  The parent and child then each "
"assign themselves to a specified CPU and execute identical loops that "
"consume some CPU time.  Before terminating, the parent waits for the child "
"to complete.  The program takes three command-line arguments: the CPU number "
"for the parent, the CPU number for the child, and the number of loop "
"iterations that both processes should perform."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:319
msgid ""
"As the sample runs below demonstrate, the amount of real and CPU time "
"consumed when running the program will depend on intra-core caching effects "
"and whether the processes are using the same CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:324
msgid ""
"We first employ B<lscpu>(1)  to determine that this (x86)  system has two "
"cores, each with two CPUs:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:331
#, no-wrap
msgid ""
"$ B<lscpu | egrep -i \\(aqcore.*:|socket\\(aq>\n"
"Thread(s) per core:    2\n"
"Core(s) per socket:    2\n"
"Socket(s):             1\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:338
msgid ""
"We then time the operation of the example program for three cases: both "
"processes running on the same CPU; both processes running on different CPUs "
"on the same core; and both processes running on different CPUs on different "
"cores."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:353
#, no-wrap
msgid ""
"$ B<time -p ./a.out 0 0 100000000>\n"
"real 14.75\n"
"user 3.02\n"
"sys 11.73\n"
"$ B<time -p ./a.out 0 1 100000000>\n"
"real 11.52\n"
"user 3.98\n"
"sys 19.06\n"
"$ B<time -p ./a.out 0 3 100000000>\n"
"real 7.89\n"
"user 3.29\n"
"sys 12.07\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:364
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:374
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:380
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:384
#, no-wrap
msgid ""
"    parentCPU = atoi(argv[1]);\n"
"    childCPU = atoi(argv[2]);\n"
"    nloops = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:386
#, no-wrap
msgid "    CPU_ZERO(&set);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:390
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:            /* Error */\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:393
#, no-wrap
msgid ""
"    case 0:             /* Child */\n"
"        CPU_SET(childCPU, &set);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:396 build/C/man2/sched_setaffinity.2:407
#, no-wrap
msgid ""
"        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:399 build/C/man2/sched_setaffinity.2:410
#, no-wrap
msgid ""
"        for (int j = 0; j E<lt> nloops; j++)\n"
"            getppid();\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:401
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:404
#, no-wrap
msgid ""
"    default:            /* Parent */\n"
"        CPU_SET(parentCPU, &set);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:415
#, no-wrap
msgid ""
"        wait(NULL);     /* Wait for child to terminate */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:440
msgid ""
"B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), "
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), "
"B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setattr.2:26
#, no-wrap
msgid "SCHED_SETATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:30
msgid "sched_setattr, sched_getattr - set and get scheduling policy and attributes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:36
#, no-wrap
msgid ""
"B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:39
#, no-wrap
msgid ""
"B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man2/sched_setattr.2:42
#, no-wrap
msgid "sched_setattr()"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:52
msgid ""
"The B<sched_setattr>()  system call sets the scheduling policy and "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be set."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:56 build/C/man2/sched_setscheduler.2:71
msgid ""
"Currently, Linux supports the following \"normal\" (i.e., non-real-time) "
"scheduling policies as values that may be specified in I<policy>:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:56 build/C/man2/sched_setscheduler.2:71
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr ""

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setattr.2:61 build/C/man2/sched_setscheduler.2:76
msgid "the standard round-robin time-sharing policy;"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:61 build/C/man2/sched_setscheduler.2:76
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:64 build/C/man2/sched_setscheduler.2:79
msgid "for \"batch\" style execution of processes; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:64 build/C/man2/sched_setscheduler.2:79
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:69 build/C/man2/sched_setscheduler.2:84
msgid "for running I<very> low priority background jobs."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:78 build/C/man2/sched_setscheduler.2:97
msgid ""
"Various \"real-time\" policies are also supported, for special time-critical "
"applications that need precise control over the way in which runnable "
"threads are selected for execution.  For the rules governing when a process "
"may use these policies, see B<sched>(7).  The real-time policies that may be "
"specified in I<policy> are:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:78 build/C/man2/sched_setscheduler.2:97
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:81 build/C/man2/sched_setscheduler.2:100
msgid "a first-in, first-out policy; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:81 build/C/man2/sched_setscheduler.2:100
#, no-wrap
msgid "B<SCHED_RR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:84 build/C/man2/sched_setscheduler.2:103
msgid "a round-robin policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:86
msgid "Linux also provides the following policy:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:86
#, no-wrap
msgid "B<SCHED_DEADLINE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:91
msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:97
msgid ""
"The I<attr> argument is a pointer to a structure that defines the new "
"scheduling policy and attributes for the specified thread.  This structure "
"has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:113
#, no-wrap
msgid ""
"struct sched_attr {\n"
"    u32 size;              /* Size of this structure */\n"
"    u32 sched_policy;      /* Policy (SCHED_*) */\n"
"    u64 sched_flags;       /* Flags */\n"
"    s32 sched_nice;        /* Nice value (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* Static priority (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* Remaining fields are for SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:119
msgid "The fields of the I<sched_attr> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:119
#, no-wrap
msgid "B<size>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:134
msgid ""
"This field should be set to the size of the structure in bytes, as in "
"I<sizeof(struct sched_attr)>.  If the provided structure is smaller than the "
"kernel structure, any additional fields are assumed to be '0'.  If the "
"provided structure is larger than the kernel structure, the kernel verifies "
"that all additional fields are 0; if they are not, B<sched_setattr>()  fails "
"with the error B<E2BIG> and updates I<size> to contain the size of the "
"kernel structure."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:148
msgid ""
"The above behavior when the size of the user-space I<sched_attr> structure "
"does not match the size of the kernel structure allows for future "
"extensibility of the interface.  Malformed applications that pass oversize "
"structures won't break in the future if the size of the kernel I<sched_attr> "
"structure is increased.  In the future, it could also allow applications "
"that know about a larger user-space I<sched_attr> structure to determine "
"whether they are running on an older kernel that does not support the larger "
"structure."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:148
#, no-wrap
msgid "I<sched_policy>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:153
msgid ""
"This field specifies the scheduling policy, as one of the B<SCHED_*> values "
"listed above."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:153
#, no-wrap
msgid "I<sched_flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:157
msgid ""
"This field contains zero or more of the following flags that are ORed "
"together to control scheduling behavior:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:158
#, no-wrap
msgid "B<SCHED_FLAG_RESET_ON_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:166
msgid ""
"Children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:166
#, no-wrap
msgid "B<SCHED_FLAG_RECLAIM> (since Linux 4.13)"
msgstr ""

#.  2d4283e9d583a3ee8cfb1cbb9c1270614df4c29d
#.  Bandwidth reclaim is done via the GRUB algorithm; see
#.  Documentation/scheduler/sched-deadline.txt
#. type: Plain text
#: build/C/man2/sched_setattr.2:174
msgid ""
"This flag allows a B<SCHED_DEADLINE> thread to reclaim bandwidth unused by "
"other real-time threads."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:174
#, no-wrap
msgid "B<SCHED_FLAG_DL_OVERRUN> (since Linux 4.16)"
msgstr ""

#.  commit 34be39305a77b8b1ec9f279163c7cdb6cc719b91
#. type: Plain text
#: build/C/man2/sched_setattr.2:185
msgid ""
"This flag allows an application to get informed about run-time overruns in "
"B<SCHED_DEADLINE> threads.  Such overruns may be caused by (for example) "
"coarse execution time accounting or incorrect parameter assignment.  "
"Notification takes the form of a B<SIGXCPU> signal which is generated on "
"each overrun."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:200
msgid ""
"This B<SIGXCPU> signal is I<process-directed> (see B<signal>(7))  rather "
"than thread-directed.  This is probably a bug.  On the one hand, "
"B<sched_setattr>()  is being used to set a per-thread attribute.  On the "
"other hand, if the process-directed signal is delivered to a thread inside "
"the process other than the one that had a run-time overrun, the application "
"has no way of knowing which thread overran."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:201
#, no-wrap
msgid "I<sched_nice>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:212
msgid ""
"This field specifies the nice value to be set when specifying "
"I<sched_policy> as B<SCHED_OTHER> or B<SCHED_BATCH>.  The nice value is a "
"number in the range -20 (high priority)  to +19 (low priority); see "
"B<sched>(7)."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:212
#, no-wrap
msgid "I<sched_priority>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:225
msgid ""
"This field specifies the static priority to be set when specifying "
"I<sched_policy> as B<SCHED_FIFO> or B<SCHED_RR>.  The allowed range of "
"priorities for these policies can be determined using "
"B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2).  For other "
"policies, this field must be specified as 0."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:225
#, no-wrap
msgid "I<sched_runtime>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:234
msgid ""
"This field specifies the \"Runtime\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds.  This field, and the next two fields, are "
"used only for B<SCHED_DEADLINE> scheduling; for further details, see "
"B<sched>(7)."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:234
#, no-wrap
msgid "I<sched_deadline>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:238
msgid ""
"This field specifies the \"Deadline\" parameter for deadline scheduling.  "
"The value is expressed in nanoseconds."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:238
#, no-wrap
msgid "I<sched_period>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:242
msgid ""
"This field specifies the \"Period\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:249 build/C/man2/sched_setattr.2:299
msgid ""
"The I<flags> argument is provided to allow for future extensions to the "
"interface; in the current implementation it must be specified as 0."
msgstr ""

#. type: SS
#: build/C/man2/sched_setattr.2:249
#, no-wrap
msgid "sched_getattr()"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:260
msgid ""
"The B<sched_getattr>()  system call fetches the scheduling policy and the "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:270
msgid ""
"The I<size> argument should be set to the size of the I<sched_attr> "
"structure as known to user space.  The value must be at least as large as "
"the size of the initially published I<sched_attr> structure, or the call "
"fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:280
msgid ""
"The retrieved scheduling attributes are placed in the fields of the "
"I<sched_attr> structure pointed to by I<attr>.  The kernel sets I<attr.size> "
"to the size of its I<sched_attr> structure."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:294
msgid ""
"If the caller-provided I<attr> buffer is larger than the kernel's "
"I<sched_attr> structure, the additional bytes in the user-space structure "
"are not touched.  If the caller-provided structure is smaller than the "
"kernel I<sched_attr> structure, the kernel will silently not return any "
"values which would be stored outside the provided space.  As with "
"B<sched_setattr>(), these semantics allow for future extensibility of the "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:308
msgid ""
"On success, B<sched_setattr>()  and B<sched_getattr>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:313
msgid ""
"B<sched_getattr>()  and B<sched_setattr>()  can both fail for the following "
"reasons:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:321
msgid "I<attr> is NULL; or I<pid> is negative; or I<flags> is not zero."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:330
msgid "In addition, B<sched_getattr>()  can fail for the following reasons:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:330 build/C/man2/sched_setattr.2:347
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:337
msgid "The buffer specified by I<size> and I<attr> is too small."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:343
msgid ""
"I<size> is invalid; that is, it is smaller than the initial version of the "
"I<sched_attr> structure (48 bytes) or larger than the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:347
msgid "In addition, B<sched_setattr>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:355
msgid ""
"The buffer specified by I<size> and I<attr> is larger than the kernel "
"structure, and one or more of the excess bytes is nonzero."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:355
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:360
msgid "B<SCHED_DEADLINE> admission control failure, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:376
msgid ""
"I<attr.sched_policy> is not one of the recognized policies; "
"I<attr.sched_flags> contains a flag other than B<SCHED_FLAG_RESET_ON_FORK>; "
"or I<attr.sched_priority> is invalid; or I<attr.sched_policy> is "
"B<SCHED_DEADLINE> and the deadline scheduling parameters in I<attr> are "
"invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:379
msgid "The caller does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:386
msgid ""
"The CPU affinity mask of the thread specified by I<pid> does not include all "
"CPUs in the system (see B<sched_setaffinity>(2))."
msgstr ""

#.  FIXME . Add glibc version
#. type: Plain text
#: build/C/man2/sched_setattr.2:389
msgid "These system calls first appeared in Linux 3.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:391
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:407
msgid ""
"B<sched_setattr>()  provides a superset of the functionality of "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2), and (other than "
"the ability to set the priority of all processes belonging to a specified "
"user or all processes in a specified group)  B<setpriority>(2).  "
"Analogously, B<sched_getattr>()  provides a superset of the functionality of "
"B<sched_getscheduler>(2), B<sched_getparam>(2), and (partially)  "
"B<getpriority>(2)."
msgstr ""

#.  FIXME . patch sent to Peter Zijlstra
#. type: Plain text
#: build/C/man2/sched_setattr.2:417
msgid ""
"In Linux versions up to 3.15, B<sched_setattr>()  failed with the error "
"B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgstr ""

#.  In Linux versions up to up 3.15,
#.  FIXME . patch from Peter Zijlstra pending
#.  .BR sched_setattr ()
#.  allowed a negative
#.  .I attr.sched_policy
#.  value.
#. type: Plain text
#: build/C/man2/sched_setattr.2:433
msgid ""
"In Linux versions up to 5.3, B<sched_getattr>()  failed with the error "
"B<EFBIG> if the in-kernel I<sched_attr> structure was larger than the "
"I<size> passed by user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:455
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), "
"B<cpuset>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr ""

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:38
#, no-wrap
msgid ""
"B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param "
"*>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:46
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the thread whose thread ID is specified in I<pid>.  If "
"I<pid> is zero, then the parameters of the calling thread are set.  The "
"interpretation of the argument I<param> depends on the scheduling policy of "
"the thread identified by I<pid>.  See B<sched>(7)  for a description of the "
"scheduling policies supported under Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the thread "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"thread are retrieved."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:104
msgid "Invalid arguments: I<param> is NULL or I<pid> is negative"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:109
msgid ""
"(B<sched_setparam>())  The argument I<param> does not make sense for the "
"current scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:116
msgid ""
"(B<sched_setparam>())  The caller does not have appropriate privileges "
"(Linux: does not have the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:137
msgid ""
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setscheduler.2:26
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:30
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling "
"policy/parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:36
#, no-wrap
msgid ""
"B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:38
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:47
msgid ""
"The B<sched_setscheduler>()  system call sets both the scheduling policy and "
"parameters for the thread whose ID is specified in I<pid>.  If I<pid> equals "
"zero, the scheduling policy and parameters of the calling thread will be "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:51
msgid ""
"The scheduling parameters are specified in the I<param> argument, which is a "
"pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:59
#, no-wrap
msgid ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:67
msgid ""
"In the current implementation, the structure contains only one field, "
"I<sched_priority>.  The interpretation of I<param> depends on the selected "
"policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:88
msgid "For each of the above policies, I<param-E<gt>sched_priority> must be 0."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:114
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> specifies a "
"scheduling priority for the thread.  This is a number in the range returned "
"by calling B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2)  "
"with the specified I<policy>.  On Linux, these system calls return, "
"respectively, 1 and 99."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:127
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:133
msgid ""
"B<sched_getscheduler>()  returns the current scheduling policy of the thread "
"identified by I<pid>.  If I<pid> equals zero, the policy of the calling "
"thread will be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:143
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, both calls return -1, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:151
msgid "Invalid arguments: I<pid> is negative or I<param> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:156
msgid "(B<sched_setscheduler>())  I<policy> is not one of the recognized policies."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:162
msgid ""
"(B<sched_setscheduler>())  I<param> does not make sense for the specified "
"I<policy>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:165
msgid "The calling thread does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The B<SCHED_BATCH> and "
"B<SCHED_IDLE> policies are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:180
msgid ""
"Further details of the semantics of all of the above \"normal\" and "
"\"real-time\" scheduling policies can be found in the B<sched>(7)  manual "
"page.  That page also describes an additional policy, B<SCHED_DEADLINE>, "
"which is settable only via B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:188
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:196
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires "
"in order to call B<sched_setscheduler>(), and details vary across systems.  "
"For example, the Solaris 7 manual page says that the real or effective user "
"ID of the caller must match the real user ID or the save set-user-ID of the "
"target."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:217
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attributes of "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attributes of the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:225
msgid ""
"POSIX.1 says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:244
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources "
"(e.g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:90
msgid ""
"B<sched_yield>()  is intended for use with real-time scheduling policies "
"(i.e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<sched_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""

#. type: TH
#: build/C/man7/sched.7:32
#, no-wrap
msgid "SCHED"
msgstr ""

#. type: TH
#: build/C/man7/sched.7:32
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:35
msgid "sched - overview of CPU scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:40
msgid ""
"Since Linux 2.6.23, the default scheduler is CFS, the \"Completely Fair "
"Scheduler\".  The CFS scheduler replaced the earlier \"O(1)\" scheduler."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:40
#, no-wrap
msgid "API summary"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:44
msgid ""
"Linux provides the following system calls for controlling the CPU scheduling "
"behavior, policy, and priority of processes (or, more precisely, threads)."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:44
#, no-wrap
msgid "B<nice>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:48
msgid "Set a new nice value for the calling thread, and return the new nice value."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:48
#, no-wrap
msgid "B<getpriority>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:52
msgid ""
"Return the nice value of a thread, a process group, or the set of threads "
"owned by a specified user."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:52
#, no-wrap
msgid "B<setpriority>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:56
msgid ""
"Set the nice value of a thread, a process group, or the set of threads owned "
"by a specified user."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:56
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:59
msgid "Set the scheduling policy and parameters of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:59
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:62
msgid "Return the scheduling policy of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:62
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:65
msgid "Set the scheduling parameters of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:65
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:68
msgid "Fetch the scheduling parameters of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:68
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:71
msgid "Return the maximum priority available in a specified scheduling policy."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:71
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:74
msgid "Return the minimum priority available in a specified scheduling policy."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:74
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:78
msgid ""
"Fetch the quantum used for threads that are scheduled under the "
"\"round-robin\" scheduling policy."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:78
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:82
msgid ""
"Cause the caller to relinquish the CPU, so that some other thread be "
"executed."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:82
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:86
msgid "(Linux-specific)  Set the CPU affinity of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:86
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:90
msgid "(Linux-specific)  Get the CPU affinity of a specified thread."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:90
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:97
msgid ""
"Set the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:97
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:105
msgid ""
"Fetch the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_getscheduler>(2)  and B<sched_getparam>(2)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:105
#, no-wrap
msgid "Scheduling policies"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:113
msgid ""
"The scheduler is the kernel component that decides which runnable thread "
"will be executed by the CPU next.  Each thread has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>.  The "
"scheduler makes its decisions based on knowledge of the scheduling policy "
"and static priority of all threads on the system."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:118
msgid ""
"For threads scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:132
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time threads always have higher "
"priority than normal threads.)  Note well: POSIX.1 requires an "
"implementation to support only a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:138
msgid ""
"Conceptually, the scheduler maintains a list of runnable threads for each "
"possible I<sched_priority> value.  In order to determine which thread runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the thread at the head of this list."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:142
msgid ""
"A thread's scheduling policy determines where it will be inserted into the "
"list of threads with equal static priority and how it will move inside this "
"list."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:150
msgid ""
"All scheduling is preemptive: if a thread with a higher static priority "
"becomes ready to run, the currently running thread will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable threads with "
"equal static priority."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:150
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:159
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> thread becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> thread.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For threads scheduled under the B<SCHED_FIFO> policy, "
"the following rules apply:"
msgstr ""

#. type: IP
#: build/C/man7/sched.7:159
#, no-wrap
msgid "1)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:164
msgid ""
"A running B<SCHED_FIFO> thread that has been preempted by another thread of "
"higher priority will stay at the head of the list for its priority and will "
"resume execution as soon as all threads of higher priority are blocked "
"again."
msgstr ""

#. type: IP
#: build/C/man7/sched.7:164
#, no-wrap
msgid "2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:167
msgid ""
"When a blocked B<SCHED_FIFO> thread becomes runnable, it will be inserted at "
"the end of the list for its priority."
msgstr ""

#. type: IP
#: build/C/man7/sched.7:167
#, no-wrap
msgid "3)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:181
msgid ""
"If a call to B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_setattr>(2), B<pthread_setschedparam>(3), or "
"B<pthread_setschedprio>(3)  changes the priority of the running or runnable "
"B<SCHED_FIFO> thread identified by I<pid> the effect on the thread's "
"position in the list depends on the direction of the change to threads "
"priority:"
msgstr ""

#. type: IP
#: build/C/man7/sched.7:182 build/C/man7/sched.7:187 build/C/man7/sched.7:190 build/C/man2/setns.2:25 build/C/man2/setns.2:29
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:187
msgid ""
"If the thread's priority is raised, it is placed at the end of the list for "
"its new priority.  As a consequence, it may preempt a currently running "
"thread with the same priority."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:190
msgid ""
"If the thread's priority is unchanged, its position in the run list is "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:193
msgid ""
"If the thread's priority is lowered, it is placed at the front of the list "
"for its new priority."
msgstr ""

#.  In 2.2.x and 2.4.x, the thread is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
#. type: Plain text
#: build/C/man7/sched.7:202
msgid ""
"According to POSIX.1-2008, changes to a thread's priority (or policy) using "
"any mechanism other than B<pthread_setschedprio>(3)  should result in the "
"thread being placed at the end of the list for its priority."
msgstr ""

#. type: IP
#: build/C/man7/sched.7:202
#, no-wrap
msgid "4)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:206
msgid "A thread calling B<sched_yield>(2)  will be put at the end of the list."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:210
msgid ""
"No other events will move a thread scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable threads with equal static priority."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:215
msgid ""
"A B<SCHED_FIFO> thread runs until either it is blocked by an I/O request, it "
"is preempted by a higher priority thread, or it calls B<sched_yield>(2)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:215
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr ""

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man7/sched.7:234
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each thread "
"is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> thread "
"has been running for a time period equal to or longer than the time quantum, "
"it will be put at the end of the list for its priority.  A B<SCHED_RR> "
"thread that has been preempted by a higher priority thread and subsequently "
"resumes execution as a running thread will complete the unexpired portion of "
"its round-robin time quantum.  The length of the time quantum can be "
"retrieved using B<sched_rr_get_interval>(2)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:234
#, no-wrap
msgid "SCHED_DEADLINE: Sporadic task model deadline scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:246
msgid ""
"Since version 3.14, Linux provides a deadline scheduling policy "
"(B<SCHED_DEADLINE>).  This policy is currently implemented using GEDF "
"(Global Earliest Deadline First)  in conjunction with CBS (Constant "
"Bandwidth Server).  To set and fetch this policy and associated attributes, "
"one must use the Linux-specific B<sched_setattr>(2)  and B<sched_getattr>(2)  "
"system calls."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:264
msgid ""
"A sporadic task is one that has a sequence of jobs, where each job is "
"activated at most once per period.  Each job also has a I<relative "
"deadline>, before which it should finish execution, and a I<computation "
"time>, which is the CPU time necessary for executing the job.  The moment "
"when a task wakes up because a new job has to be executed is called the "
"I<arrival time> (also referred to as the request time or release time).  The "
"I<start time> is the time at which a task starts its execution.  The "
"I<absolute deadline> is thus obtained by adding the relative deadline to the "
"arrival time."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:266
msgid "The following diagram clarifies these terms:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:277
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- relative deadline ------E<gt>|\n"
"     |E<lt>-------------- period -------------------E<gt>|\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:296
msgid ""
"When setting a B<SCHED_DEADLINE> policy for a thread using "
"B<sched_setattr>(2), one can specify three parameters: I<Runtime>, "
"I<Deadline>, and I<Period>.  These parameters do not necessarily correspond "
"to the aforementioned terms: usual practice is to set Runtime to something "
"bigger than the average computation time (or worst-case execution time for "
"hard real-time tasks), Deadline to the relative deadline, and Period to the "
"period of the task.  Thus, for B<SCHED_DEADLINE> scheduling, we have:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:307
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"
msgstr ""

#.  FIXME It looks as though specifying sched_period as 0 means
#.  "make sched_period the same as sched_deadline".
#.  This needs to be documented.
#. type: Plain text
#: build/C/man7/sched.7:327
msgid ""
"The three deadline-scheduling parameters correspond to the I<sched_runtime>, "
"I<sched_deadline>, and I<sched_period> fields of the I<sched_attr> "
"structure; see B<sched_setattr>(2).  These fields express values in "
"nanoseconds.  If I<sched_period> is specified as 0, then it is made the same "
"as I<sched_deadline>."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:329
msgid "The kernel requires that:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:331
#, no-wrap
msgid "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"
msgstr ""

#.  See __checkparam_dl in kernel/sched/core.c
#. type: Plain text
#: build/C/man7/sched.7:341
msgid ""
"In addition, under the current implementation, all of the parameter values "
"must be at least 1024 (i.e., just over one microsecond, which is the "
"resolution of the implementation), and less than 2^63.  If any of these "
"checks fails, B<sched_setattr>(2)  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:344
msgid ""
"The CBS guarantees non-interference between tasks, by throttling threads "
"that attempt to over-run their specified Runtime."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:357
msgid ""
"To ensure deadline scheduling guarantees, the kernel must prevent situations "
"where the set of B<SCHED_DEADLINE> threads is not feasible (schedulable) "
"within the given constraints.  The kernel thus performs an admittance test "
"when setting or changing B<SCHED_DEADLINE> policy and attributes.  This "
"admission test calculates whether the change is feasible; if it is not, "
"B<sched_setattr>(2)  fails with the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:363
msgid ""
"For example, it is required (but not necessarily sufficient) for the total "
"utilization to be less than or equal to the total number of CPUs available, "
"where, since each thread can maximally run for Runtime per Period, that "
"thread's utilization is its Runtime divided by its Period."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:374
msgid ""
"In order to fulfill the guarantees that are made when a thread is admitted "
"to the B<SCHED_DEADLINE> policy, B<SCHED_DEADLINE> threads are the highest "
"priority (user controllable) threads in the system; if any B<SCHED_DEADLINE> "
"thread is runnable, it will preempt any thread scheduled under one of the "
"other policies."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:382
msgid ""
"A call to B<fork>(2)  by a thread scheduled under the B<SCHED_DEADLINE> "
"policy fails with the error B<EAGAIN>, unless the thread has its "
"reset-on-fork flag set (see below)."
msgstr ""

#
#.  FIXME Calling sched_getparam() on a SCHED_DEADLINE thread
#.  fails with EINVAL, but sched_getscheduler() succeeds.
#.  Is that intended? (Why?)
#. type: Plain text
#: build/C/man7/sched.7:393
msgid ""
"A B<SCHED_DEADLINE> thread that calls B<sched_yield>(2)  will yield the "
"current job and wait for a new period to begin."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:393
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:401
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0 (i.e., threads under "
"real-time policies always have priority over B<SCHED_OTHER> processes).  "
"B<SCHED_OTHER> is the standard Linux time-sharing scheduler that is intended "
"for all threads that do not require the special real-time mechanisms."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:409
msgid ""
"The thread to run is chosen from the static priority 0 list based on a "
"I<dynamic> priority that is determined only inside this list.  The dynamic "
"priority is based on the nice value (see below)  and is increased for each "
"time quantum the thread is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> threads."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:415
msgid ""
"In the Linux kernel source code, the B<SCHED_OTHER> policy is actually named "
"B<SCHED_NORMAL>."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:415
#, no-wrap
msgid "The nice value"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:429
msgid ""
"The nice value is an attribute that can be used to influence the CPU "
"scheduler to favor or disfavor a process in scheduling decisions.  It "
"affects the scheduling of B<SCHED_OTHER> and B<SCHED_BATCH> (see below) "
"processes.  The nice value can be modified using B<nice>(2), "
"B<setpriority>(2), or B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:434
msgid ""
"According to POSIX.1, the nice value is a per-process attribute; that is, "
"the threads in a process should share a nice value.  However, on Linux, the "
"nice value is a per-thread attribute: different threads in the same process "
"may have different nice values."
msgstr ""

#.  Linux before 1.3.36 had \-infinity..15.
#.  Since kernel 1.3.43, Linux has the range \-20..19.
#. type: Plain text
#: build/C/man7/sched.7:442
msgid ""
"The range of the nice value varies across UNIX systems.  On modern Linux, "
"the range is -20 (high priority) to +19 (low priority).  On some other "
"systems, the range is -20..20.  Very early Linux kernels (Before Linux 2.0) "
"had the range -infinity..15."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:447
msgid ""
"The degree to which the nice value affects the relative scheduling of "
"B<SCHED_OTHER> processes likewise varies across UNIX systems and across "
"Linux kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:459
msgid ""
"With the advent of the CFS scheduler in kernel 2.6.23, Linux adopted an "
"algorithm that causes relative differences in nice values to have a much "
"stronger effect.  In the current implementation, each unit of difference in "
"the nice values of two processes results in a factor of 1.25 in the degree "
"to which the scheduler favors the higher priority process.  This causes very "
"low nice values (+19) to truly provide little CPU to a process whenever "
"there is any other higher priority load on the system, and makes high nice "
"values (-20) deliver most of the CPU to applications that require it (e.g., "
"some audio applications)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:466
msgid ""
"On Linux, the B<RLIMIT_NICE> resource limit can be used to define a limit to "
"which an unprivileged process's nice value can be raised; see "
"B<setrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:470
msgid ""
"For further details on the nice value, see the subsections on the autogroup "
"feature and group scheduling, below."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:470
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:482
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the thread "
"according to its dynamic priority (based on the nice value).  The difference "
"is that this policy will cause the scheduler to always assume that the "
"thread is CPU-intensive.  Consequently, the scheduler will apply a small "
"scheduling penalty with respect to wakeup behavior, so that this thread is "
"mildly disfavored in scheduling decisions."
msgstr ""

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#.  commit b0a9499c3dd50d333e2aedb7e894873c58da3785
#. type: Plain text
#: build/C/man7/sched.7:492
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:492
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:496
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:504
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:504
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:510
msgid ""
"Each thread has a reset-on-fork scheduling flag.  When this flag is set, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  The reset-on-fork flag can be set by either:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:519
msgid ""
"ORing the B<SCHED_RESET_ON_FORK> flag into the I<policy> argument when "
"calling B<sched_setscheduler>(2)  (since Linux 2.6.32); or"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:526
msgid ""
"specifying the B<SCHED_FLAG_RESET_ON_FORK> flag in I<attr.sched_flags> when "
"calling B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:532
msgid ""
"Note that the constants used with these two APIs have different names.  The "
"state of the reset-on-fork flag can analogously be retrieved using "
"B<sched_getscheduler>(2)  and B<sched_getattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:539
msgid ""
"The reset-on-fork feature is intended for media-playback applications, and "
"can be used to prevent applications evading the B<RLIMIT_RTTIME> resource "
"limit (see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:542
msgid ""
"More precisely, if the reset-on-fork flag is set, the following rules apply "
"for subsequently created children:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:550
msgid ""
"If the calling thread has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:553
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:561
msgid ""
"After the reset-on-fork flag has been enabled, it can be reset only if the "
"thread has the B<CAP_SYS_NICE> capability.  This flag is disabled in child "
"processes created by B<fork>(2)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:561
#, no-wrap
msgid "Privileges and resource limits"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:573
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  threads "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged thread can make is to set the "
"B<SCHED_OTHER> policy, and this can be done only if the effective user ID of "
"the caller matches the real or effective user ID of the target thread (i.e., "
"the thread specified by I<pid>)  whose policy is being changed."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:579
msgid ""
"A thread must be privileged (B<CAP_SYS_NICE>)  in order to set or modify a "
"B<SCHED_DEADLINE> policy."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:589
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged thread's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:597
msgid ""
"If an unprivileged thread has a nonzero B<RLIMIT_RTPRIO> soft limit, then it "
"can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:602
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:607
msgid ""
"Subject to the same rules, another unprivileged thread can also make these "
"changes, as long as the effective user ID of the thread making the change "
"matches the real or effective user ID of the target thread."
msgstr ""

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man7/sched.7:626
msgid ""
"Special rules apply for the B<SCHED_IDLE> policy.  In Linux kernels before "
"2.6.39, an unprivileged thread operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged thread can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_OTHER> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:637
msgid ""
"Privileged (B<CAP_SYS_NICE>)  threads ignore the B<RLIMIT_RTPRIO> limit; as "
"with older kernels, they can make arbitrary changes to scheduling policy and "
"priority.  See B<getrlimit>(2)  for further information on B<RLIMIT_RTPRIO>."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:637
#, no-wrap
msgid "Limiting the CPU usage of real-time and deadline processes"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:650
msgid ""
"A nonblocking infinite loop in a thread scheduled under the B<SCHED_FIFO>, "
"B<SCHED_RR>, or B<SCHED_DEADLINE> policy can potentially block all other "
"threads from accessing the CPU forever.  Prior to Linux 2.6.25, the only way "
"of preventing a runaway real-time process from freezing the system was to "
"run (at the console)  a shell scheduled under a higher static priority than "
"the tested application.  This allows an emergency kill of tested real-time "
"applications that do not block or terminate as expected."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:660
msgid ""
"Since Linux 2.6.25, there are other techniques for dealing with runaway "
"real-time and deadline processes.  One of these is to use the "
"B<RLIMIT_RTTIME> resource limit to set a ceiling on the CPU time that a "
"real-time process may consume.  See B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:668
msgid ""
"Since version 2.6.25, Linux also provides two I</proc> files that can be "
"used to reserve a certain amount of CPU time to be used by non-real-time "
"processes.  Reserving CPU time in this fashion allows some CPU time to be "
"allocated to (say) a root shell that can be used to kill a runaway process.  "
"Both of these files specify time values in microseconds:"
msgstr ""

#. type: TP
#: build/C/man7/sched.7:668
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us>"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:676
msgid ""
"This file specifies a scheduling period that is equivalent to 100% CPU "
"bandwidth.  The value in this file can range from 1 to B<INT_MAX>, giving an "
"operating range of 1 microsecond to around 35 minutes.  The default value in "
"this file is 1,000,000 (1 second)."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:676
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us>"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:689
msgid ""
"The value in this file specifies how much of the \"period\" time can be used "
"by all real-time and deadline scheduled processes on the system.  The value "
"in this file can range from -1 to B<INT_MAX>-1.  Specifying -1 makes the run "
"time the same as the period; that is, no CPU time is set aside for "
"non-real-time processes (which was the Linux behavior before kernel "
"2.6.25).  The default value in this file is 950,000 (0.95 seconds), meaning "
"that 5% of the CPU time is reserved for processes that don't run under a "
"real-time or deadline scheduling policy."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:690
#, no-wrap
msgid "Response time"
msgstr ""

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man7/sched.7:698
msgid ""
"A blocked high priority thread waiting for I/O has a certain response time "
"before it is scheduled again.  The device driver writer can greatly reduce "
"this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:698
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:703
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:710
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:710
#, no-wrap
msgid "The autogroup feature"
msgstr ""

#.  commit 5091faa449ee0b7d73bc296a93bca9540fc51d0a
#. type: Plain text
#: build/C/man7/sched.7:720
msgid ""
"Since Linux 2.6.38, the kernel provides a feature known as autogrouping to "
"improve interactive desktop performance in the face of multiprocess, "
"CPU-intensive workloads such as building the Linux kernel with large numbers "
"of parallel build processes (i.e., the B<make>(1)  B<-j> flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:730
msgid ""
"This feature operates in conjunction with the CFS scheduler and requires a "
"kernel that is configured with B<CONFIG_SCHED_AUTOGROUP>.  On a running "
"system, this feature is enabled or disabled via the file "
"I</proc/sys/kernel/sched_autogroup_enabled>; a value of 0 disables the "
"feature, while a value of 1 enables it.  The default value in this file is "
"1, unless the kernel was booted with the I<noautogroup> parameter."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:740
msgid ""
"A new autogroup is created when a new session is created via B<setsid>(2); "
"this happens, for example, when a new terminal window is started.  A new "
"process created by B<fork>(2)  inherits its parent's autogroup membership.  "
"Thus, all of the processes in a session are members of the same autogroup.  "
"An autogroup is automatically destroyed when the last process in the group "
"terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:747
msgid ""
"When autogrouping is enabled, all of the members of an autogroup are placed "
"in the same kernel scheduler \"task group\".  The CFS scheduler employs an "
"algorithm that equalizes the distribution of CPU cycles across task groups.  "
"The benefits of this for interactive desktop performance can be described "
"via the following example."
msgstr ""

#.  Mike Galbraith, 25 Nov 2016:
#.      I'd say something more wishy-washy here, like cycles are
#.      distributed fairly across groups and leave it at that, as your
#.      detailed example is incorrect due to SMP fairness (which I don't
#.      like much because [very unlikely] worst case scenario
#.      renders a box sized group incapable of utilizing more that
#.      a single CPU total).  For example, if a group of NR_CPUS
#.      size competes with a singleton, load balancing will try to give
#.      the singleton a full CPU of its very own.  If groups intersect for
#.      whatever reason on say my quad lappy, distribution is 80/20 in
#.      favor of the singleton.
#. type: Plain text
#: build/C/man7/sched.7:778
msgid ""
"Suppose that there are two autogroups competing for the same CPU (i.e., "
"presume either a single CPU system or the use of B<taskset>(1)  to confine "
"all the processes to the same CPU on an SMP system).  The first group "
"contains ten CPU-bound processes from a kernel build started with I<make\\ "
"-j10>.  The other contains a single CPU-bound process: a video player.  The "
"effect of autogrouping is that the two groups will each receive half of the "
"CPU cycles.  That is, the video player will receive 50% of the CPU cycles, "
"rather than just 9% of the cycles, which would likely lead to degraded video "
"playback.  The situation on an SMP system is more complex, but the general "
"effect is the same: the scheduler distributes CPU cycles across task groups "
"such that an autogroup that contains a large number of CPU-bound processes "
"does not end up hogging CPU cycles at the expense of the other jobs on the "
"system."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:781
msgid ""
"A process's autogroup (task group) membership can be viewed via the file "
"I</proc/[pid]/autogroup>:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:786
#, no-wrap
msgid ""
"$ B<cat /proc/1/autogroup>\n"
"/autogroup-1 nice 0\n"
msgstr ""

#.  FIXME .
#.  Because of a bug introduced in Linux 4.7
#.  (commit 2159197d66770ec01f75c93fb11dc66df81fd45b made changes
#.  that exposed the fact that autogroup didn't call scale_load()),
#.  it happened that *all* values in this range caused a task group
#.  to be further disfavored by the scheduler, with \-20 resulting
#.  in the scheduler mildly disfavoring the task group and +19 greatly
#.  disfavoring it.
#
#.  A patch was posted on 23 Nov 2016
#.  ("sched/autogroup: Fix 64bit kernel nice adjustment";
#.  check later to see in which kernel version it lands.
#. type: Plain text
#: build/C/man7/sched.7:810
msgid ""
"This file can also be used to modify the CPU bandwidth allocated to an "
"autogroup.  This is done by writing a number in the \"nice\" range to the "
"file to set the autogroup's nice value.  The allowed range is from +19 (low "
"priority) to -20 (high priority).  (Writing values outside of this range "
"causes B<write>(2)  to fail with the error B<EINVAL>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:819
msgid ""
"The autogroup nice setting has the same meaning as the process nice value, "
"but applies to distribution of CPU cycles to the autogroup as a whole, based "
"on the relative nice values of other autogroups.  For a process inside an "
"autogroup, the CPU cycles that it receives will be a product of the "
"autogroup's nice value (compared to other autogroups)  and the process's "
"nice value (compared to other processes in the same autogroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:824
msgid ""
"The use of the B<cgroups>(7)  CPU controller to place processes in cgroups "
"other than the root CPU cgroup overrides the effect of autogrouping."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:835
msgid ""
"The autogroup feature groups only processes scheduled under non-real-time "
"policies (B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE>).  It does not "
"group processes scheduled under real-time and deadline policies.  Those "
"processes are scheduled according to the rules described earlier."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:835
#, no-wrap
msgid "The nice value and group scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:845
msgid ""
"When scheduling non-real-time processes (i.e., those scheduled under the "
"B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE> policies), the CFS "
"scheduler employs a technique known as \"group scheduling\", if the kernel "
"was configured with the B<CONFIG_FAIR_GROUP_SCHED> option (which is "
"typical)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:851
msgid ""
"Under group scheduling, threads are scheduled in \"task groups\".  Task "
"groups have a hierarchical relationship, rooted under the initial task group "
"on the system, known as the \"root task group\".  Task groups are formed in "
"the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:855
msgid ""
"All of the threads in a CPU cgroup form a task group.  The parent of this "
"task group is the task group of the corresponding parent cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:863
msgid ""
"If autogrouping is enabled, then all of the threads that are (implicitly) "
"placed in an autogroup (i.e., the same session, as created by B<setsid>(2))  "
"form a task group.  Each new autogroup is thus a separate task group.  The "
"root task group is the parent of all such autogroups."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:867
msgid ""
"If autogrouping is enabled, then the root task group consists of all "
"processes in the root CPU cgroup that were not otherwise implicitly placed "
"into a new autogroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:870
msgid ""
"If autogrouping is disabled, then the root task group consists of all "
"processes in the root CPU cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:875
msgid ""
"If group scheduling was disabled (i.e., the kernel was configured without "
"B<CONFIG_FAIR_GROUP_SCHED>), then all of the processes on the system are "
"notionally placed in a single task group."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:889
msgid ""
"Under group scheduling, a thread's nice value has an effect for scheduling "
"decisions I<only relative to other threads in the same task group>.  This "
"has some surprising consequences in terms of the traditional semantics of "
"the nice value on UNIX systems.  In particular, if autogrouping is enabled "
"(which is the default in various distributions), then employing "
"B<setpriority>(2)  or B<nice>(1)  on a process has an effect only for "
"scheduling relative to other processes executed in the same session "
"(typically: the same terminal window)."
msgstr ""

#.  More succinctly: the nice(1) command is in many cases a no-op since
#.  Linux 2.6.38.
#. type: Plain text
#: build/C/man7/sched.7:905
msgid ""
"Conversely, for two processes that are (for example)  the sole CPU-bound "
"processes in different sessions (e.g., different terminal windows, each of "
"whose jobs are tied to different autogroups), I<modifying the nice value of "
"the process in one of the sessions> I<has no effect> in terms of the "
"scheduler's decisions relative to the process in the other session.  A "
"possibly useful workaround here is to use a command such as the following to "
"modify the autogroup nice value for I<all> of the processes in a terminal "
"session:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:909
#, no-wrap
msgid "$ B<echo 10 E<gt> /proc/self/autogroup>\n"
msgstr ""

#. type: SS
#: build/C/man7/sched.7:911
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr ""

#.  FIXME . Probably this text will need some minor tweaking
#.  ask Carsten Emde about this.
#. type: Plain text
#: build/C/man7/sched.7:923
msgid ""
"Since kernel version 2.6.18, Linux is gradually becoming equipped with "
"real-time capabilities, most of which are derived from the former "
"I<realtime-preempt> patch set.  Until the patches have been completely "
"merged into the mainline kernel, they must be installed to achieve the best "
"real-time performance.  These patches are named:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:927
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:933
msgid ""
"and can be downloaded from E<.UR "
"http://www.kernel.org\\:/pub\\:/linux\\:/kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:942
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:951
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular "
"real-time operating system.  The FIFO and RR scheduling policies are then "
"used to run a thread with true real-time priority and a minimum worst-case "
"scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:956
msgid ""
"The B<cgroups>(7)  CPU controller can be used to limit the CPU consumption "
"of groups of processes."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:966
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:998
msgid ""
"B<chcpu>(1), B<chrt>(1), B<lscpu>(1), B<ps>(1), B<taskset>(1), B<top>(1), "
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getaffinity_np>(3), "
"B<pthread_getschedparam>(3), B<pthread_setaffinity_np>(3), "
"B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:1002
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O.\\& Gallmeister, "
"O'Reilly & Associates, Inc., ISBN 1-56592-074-0."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:1009
msgid ""
"The Linux kernel source files I<Documentation/scheduler/sched-deadline.txt>, "
"I<Documentation/scheduler/sched-rt-group.txt>, "
"I<Documentation/scheduler/sched-design-CFS.txt>, and "
"I<Documentation/scheduler/sched-nice-design.txt>"
msgstr ""

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr ""

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:25
msgid ""
"The B<setns>()  system call allows the calling thread to move into different "
"namespaces.  The I<fd> argument is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:29
msgid ""
"a file descriptor referring to one of the magic links in a "
"I</proc/[pid]/ns/> directory (or a bind mount to such a link);"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:32
msgid "a PID file descriptor (see B<pidfd_open>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:37
msgid "The I<nstype> argument is interpreted differently in each case."
msgstr ""

#. type: SS
#: build/C/man2/setns.2:37
#, no-wrap
msgid "fd refers to a /proc/[pid]/ns/ link"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:51
msgid ""
"If I<fd> refers to a I</proc/[pid]/ns/> link, then B<setns>()  reassociates "
"the calling thread with the namespace associated with that link, subject to "
"any constraints imposed by the I<nstype> argument.  In this usage, each call "
"to B<setns>()  changes just one of the caller's namespace memberships."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:59
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have I<one> of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/setns.2:59
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:62
msgid "Allow any type of namespace to be joined."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:66
msgid "I<fd> must refer to a cgroup namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:66
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:70
msgid "I<fd> must refer to an IPC namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:70
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:74
msgid "I<fd> must refer to a network namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:74
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:78
msgid "I<fd> must refer to a mount namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:78 build/C/man2/unshare.2:143
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:82
msgid "I<fd> must refer to a descendant PID namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:82
#, no-wrap
msgid "B<CLONE_NEWTIME> (since Linux 5.8)"
msgstr ""

#.  commit 76c12881a38aaa83e1eb4ce2fada36c3a732bad4
#. type: Plain text
#: build/C/man2/setns.2:87
msgid "I<fd> must refer to a time namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:87 build/C/man2/unshare.2:185
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:91
msgid "I<fd> must refer to a user namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:91
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:95
msgid "I<fd> must refer to a UTS namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:111
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""

#. type: SS
#: build/C/man2/setns.2:111
#, no-wrap
msgid "fd is a PID file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:123
msgid ""
"Since Linux 5.8, I<fd> may refer to a PID file descriptor obtained from "
"B<pidfd_open>(2)  or B<clone>(3).  In this usage, B<setns>()  atomically "
"moves the calling thread into one or more of the same namespaces as the "
"thread referred to by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:135
msgid ""
"The I<nstype> argument is a bit mask specified by ORing together I<one or "
"more> of the B<CLONE_NEW*> namespace constants listed above.  The caller is "
"moved into each of the target thread's namespaces that is specified in "
"I<nstype>; the caller's memberships in the remaining namespaces are left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:139
msgid ""
"For example, the following code would move the caller into the same user, "
"network, and UTS namespaces as PID 1234, but would leave the caller's other "
"namespace memberships unchanged:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:144
#, no-wrap
msgid ""
"int fd = pidfd_open(1234, 0);\n"
"setns(fd, CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWUTS);\n"
msgstr ""

#. type: SS
#: build/C/man2/setns.2:147
#, no-wrap
msgid "Details for specific namespace types"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:150
msgid ""
"Note the following details and restrictions when reassociating with specific "
"namespace types:"
msgstr ""

#. type: TP
#: build/C/man2/setns.2:150
#, no-wrap
msgid "User namespaces"
msgstr ""

#.  See kernel/user_namespace.c:userns_install() [3.8 source]
#. type: Plain text
#: build/C/man2/setns.2:161
msgid ""
"A process reassociating itself with a user namespace must have the "
"B<CAP_SYS_ADMIN> capability in the target user namespace.  (This necessarily "
"implies that it is only possible to join a descendant user namespace.)  Upon "
"successfully joining a user namespace, a process is granted all capabilities "
"in that namespace, regardless of its user and group IDs."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:164
msgid "A multithreaded process may not change user namespace with B<setns>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:171
msgid ""
"It is not permitted to use B<setns>()  to reenter the caller's current user "
"namespace.  This prevents a caller that has dropped capabilities from "
"regaining those capabilities via a call to B<setns>()."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/setns.2:181
msgid ""
"For security reasons, a process can't join a new user namespace if it is "
"sharing filesystem-related attributes (the attributes whose sharing is "
"controlled by the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:184
msgid "For further details on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:184
#, no-wrap
msgid "Mount namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:193
msgid ""
"Changing the mount namespace requires that the caller possess both "
"B<CAP_SYS_CHROOT> and B<CAP_SYS_ADMIN> capabilities in its own user "
"namespace and B<CAP_SYS_ADMIN> in the user namespace that owns the target "
"mount namespace."
msgstr ""

#.  Above check is in fs/namespace.c:mntns_install() [3.8 source]
#. type: Plain text
#: build/C/man2/setns.2:201
msgid ""
"A process can't join a new mount namespace if it is sharing "
"filesystem-related attributes (the attributes whose sharing is controlled by "
"the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:205
msgid ""
"See B<user_namespaces>(7)  for details on the interaction of user namespaces "
"and mount namespaces."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:205
#, no-wrap
msgid "PID namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:212
msgid ""
"In order to reassociate itself with a new PID namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target PID namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:219
msgid ""
"Reassociating the PID namespace has somewhat different from other namespace "
"types.  Reassociating the calling thread with a PID namespace changes only "
"the PID namespace that subsequently created child processes of the caller "
"will be placed in; it does not change the PID namespace of the caller "
"itself."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:223
msgid ""
"Reassociating with a PID namespace is allowed only if the target PID "
"namespace is a descendant (child, grandchild, etc.)  of, or is the same as, "
"the current PID namespace of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:226
msgid "For further details on PID namespaces, see B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:226
#, no-wrap
msgid "Cgroup namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:233
msgid ""
"In order to reassociate itself with a new cgroup namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target cgroup namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:238
msgid ""
"Using B<setns>()  to change the caller's cgroup namespace does not change "
"the caller's cgroup memberships."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:238
#, no-wrap
msgid "Network, IPC, time, and UTS namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:245
msgid ""
"In order to reassociate itself with a new network, IPC, time, or UTS "
"namespace, the caller must have the B<CAP_SYS_ADMIN> capability both in its "
"own user namespace and in the user namespace that owns the target namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:252
msgid ""
"On success, B<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:257
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:262
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:266
msgid "There is problem with reassociating the thread with the specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:271
msgid ""
"The caller tried to join an ancestor (parent, grandparent, and so on)  PID "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:275
msgid ""
"The caller attempted to join the user namespace in which it is already a "
"member."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: build/C/man2/setns.2:282
msgid ""
"The caller shares filesystem (B<CLONE_FS>)  state (in particular, the root "
"directory)  with other processes and tried to join a new user namespace."
msgstr ""

#.  See kernel/user_namespace.c::userns_install() [kernel 3.15 sources]
#. type: Plain text
#: build/C/man2/setns.2:286
msgid "The caller is multithreaded and tried to join a new user namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:292
msgid "I<fd> is a PID file descriptor and I<nstype> is invalid (e.g., it is 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:295
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:299
msgid "The calling thread did not have the required capability for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:304
msgid ""
"I<fd> is a PID file descriptor but the process it refers to no longer exists "
"(i.e., it has terminated and been waited on)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:309
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:313
msgid "The B<setns>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:318
msgid ""
"For further information on the I</proc/[pid]/ns/> magic links, see "
"B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:324
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:333
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:343
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:351
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:363
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:370
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:376
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:386
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:394
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:399
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:403
#, no-wrap
msgid ""
"    /* Get file descriptor for namespace; the file descriptor is opened\n"
"       with O_CLOEXEC so as to ensure that it is not inherited by the\n"
"       program that is later executed. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:407
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY | O_CLOEXEC);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:410
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)       /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:414
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);    /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:423
msgid ""
"B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), "
"B<namespaces>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr ""

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:29
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:42
msgid ""
"B<unshare>()  allows a process (or thread) to disassociate parts of its "
"execution context that are currently being shared with other processes (or "
"threads).  Part of the execution context, such as the mount namespace, is "
"shared implicitly when a new process is created using B<fork>(2)  or "
"B<vfork>(2), while other parts, such as virtual memory, may be shared by "
"explicit request when creating a process or thread using B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:47
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:54
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:54
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:62
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:62
#, no-wrap
msgid "B<CLONE_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:76
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem "
"attributes, so that the calling process no longer shares its root directory "
"(B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:88
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWCGROUP> flag.  "
"Unshare the cgroup namespace.  Use of B<CLONE_NEWCGROUP> requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the IPC namespace, so that the calling process has a private copy of "
"the IPC namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_SYSVSEM> as well.  Use of "
"B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:120
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:120
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr ""

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:143
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<mount_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:170
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
"Unshare the PID namespace, so that the calling process has a new PID "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  The "
"first child created by the calling process will have the process ID 1 and "
"will assume the role of B<init>(1)  in the new namespace.  B<CLONE_NEWPID> "
"automatically implies B<CLONE_THREAD> as well.  Use of B<CLONE_NEWPID> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:170
#, no-wrap
msgid "B<CLONE_NEWTIME> (since Linux 5.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:185
msgid ""
"Unshare the time namespace, so that the calling process has a new time "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  Use "
"of B<CLONE_NEWTIME> requires the B<CAP_SYS_ADMIN> capability.  For further "
"information, see B<time_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:199
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUSER> flag.  "
"Unshare the user namespace, so that the calling process is moved into a new "
"user namespace which is not shared with any previously existing process.  As "
"with the child process created by B<clone>(2)  with the B<CLONE_NEWUSER> "
"flag, the caller obtains a full set of capabilities in the new namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/unshare.2:215
msgid ""
"B<CLONE_NEWUSER> requires that the calling process is not threaded; "
"specifying B<CLONE_NEWUSER> automatically implies B<CLONE_THREAD>.  Since "
"Linux 3.9, B<CLONE_NEWUSER> also automatically implies B<CLONE_FS>.  "
"B<CLONE_NEWUSER> requires that the user ID and group ID of the calling "
"process are mapped to user IDs and group IDs in the user namespace of the "
"calling process at the time of the call."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:218
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:232
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:232
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr ""

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  CLONE_NEWNS If CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#. type: Plain text
#: build/C/man2/unshare.2:252
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System\\ V semaphore adjustment (I<semadj>)  values, so that the "
"calling process has a new empty I<semadj> list that is not shared with any "
"other process.  If this is the last process that has a reference to the "
"process's current I<semadj> list, then the adjustments in that list are "
"applied to the corresponding semaphores, as described in B<semop>(2)."
msgstr ""

#.  As at 3.9, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#
#.  See kernel/fork.c::check_unshare_flags()
#. type: Plain text
#: build/C/man2/unshare.2:279
msgid ""
"In addition, B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> can be "
"specified in I<flags> if the caller is single threaded (i.e., it is not "
"sharing its address space with another process or thread).  In this case, "
"these flags have no effect.  (Note also that specifying B<CLONE_THREAD> "
"automatically implies B<CLONE_VM>, and specifying B<CLONE_VM> automatically "
"implies B<CLONE_SIGHAND>.)  If the process is multithreaded, then the use of "
"these flags results in an error."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:286
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:291
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:296
msgid "An invalid bit was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:305
msgid ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, or B<CLONE_VM> was specified in I<flags>, "
"and the caller is multithreaded."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:315
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:323
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:331
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:339
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:347
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:357
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the process has previously "
"called B<unshare>()  with the B<CLONE_NEWPID> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:361
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: build/C/man2/unshare.2:369
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:378
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:391
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:394
msgid "The calling process did not have the required privileges for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:402
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID "
"or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: build/C/man2/unshare.2:412
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:412
#, no-wrap
msgid "B<EUSERS> (from Linux 3.11 to Linux 4.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:421
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:425
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:429
msgid "The B<unshare>()  system call is Linux-specific."
msgstr ""

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:463
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:472
msgid ""
"The program below provides a simple implementation of the B<unshare>(1)  "
"command, which unshares one or more namespaces and executes the command "
"supplied in its command-line arguments.  Here's an example of the use of "
"this program, running a shell in a new mount namespace, and verifying that "
"the original shell and the new shell are in separate mount namespaces:"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:480
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:486
msgid ""
"The differing output of the two B<readlink>(1)  commands shows that the two "
"shells are in different mount namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:490
#, no-wrap
msgid "/* unshare.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:499
#, no-wrap
msgid ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:502
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:521
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -C   unshare cgroup namespace\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -t   unshare time namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:526
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:528
#, no-wrap
msgid "    flags = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:542
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"CimnptuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqC\\(aq: flags |= CLONE_NEWCGROUP;      break;\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqt\\(aq: flags |= CLONE_NEWTIME;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:545
#, no-wrap
msgid ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:548
#, no-wrap
msgid ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:552
#, no-wrap
msgid ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:561
msgid ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"
msgstr ""

#.  commit f504d47be5e8fa7ecf2bf660b18b42e6960c0eb2
#. type: Plain text
#: build/C/man2/unshare.2:568
msgid ""
"I<Documentation/userspace-api/unshare.rst> in the Linux kernel source tree "
"(or I<Documentation/unshare.txt> before Linux 4.12)"
msgstr ""
