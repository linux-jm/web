# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:38+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "CPU_SET"
msgstr "CPU_SET"

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28
#: build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setattr.2:26
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26
#: build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34
#: build/C/man2/sched_setattr.2:26 build/C/man2/sched_setparam.2:30
#: build/C/man2/sched_setscheduler.2:26 build/C/man2/sched_yield.2:29
#: build/C/man7/sched.7:32 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:42 build/C/man2/kcmp.2:28
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26
#: build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34
#: build/C/man2/sched_setattr.2:26 build/C/man2/sched_setparam.2:30
#: build/C/man2/sched_setscheduler.2:26 build/C/man2/sched_yield.2:29
#: build/C/man7/sched.7:32 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/CPU_SET.3:28 build/C/man2/clone.2:43 build/C/man2/kcmp.2:29
#: build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:27
#: build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35
#: build/C/man2/sched_setattr.2:27 build/C/man2/sched_setparam.2:31
#: build/C/man2/sched_setscheduler.2:27 build/C/man2/sched_yield.2:30
#: build/C/man7/sched.7:33 build/C/man2/setns.2:9 build/C/man2/unshare.2:21
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/CPU_SET.3:35
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - CPU 集合を操作するためのマクロ"

#. type: SH
#: build/C/man3/CPU_SET.3:35 build/C/man2/clone.2:45 build/C/man2/kcmp.2:31
#: build/C/man2/sched_get_priority_max.2:32 build/C/man3/sched_getcpu.3:29
#: build/C/man2/sched_rr_get_interval.2:32 build/C/man2/sched_setaffinity.2:38
#: build/C/man2/sched_setattr.2:30 build/C/man2/sched_setparam.2:33
#: build/C/man2/sched_setscheduler.2:30 build/C/man2/sched_yield.2:32
#: build/C/man2/setns.2:11 build/C/man2/unshare.2:23
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/CPU_SET.3:39 build/C/man2/sched_setaffinity.2:42
#: build/C/man2/setns.2:15
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:41
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:47
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:56
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:62
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:68
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:75
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:78
#, no-wrap
msgid "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: SH
#: build/C/man3/CPU_SET.3:79 build/C/man2/clone.2:66 build/C/man2/kcmp.2:41
#: build/C/man2/sched_get_priority_max.2:38 build/C/man3/sched_getcpu.3:55
#: build/C/man2/sched_rr_get_interval.2:36 build/C/man2/sched_setaffinity.2:49
#: build/C/man2/sched_setattr.2:41 build/C/man2/sched_setparam.2:47
#: build/C/man2/sched_setscheduler.2:39 build/C/man2/sched_yield.2:36
#: build/C/man7/sched.7:35 build/C/man2/setns.2:18 build/C/man2/unshare.2:30
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/CPU_SET.3:86
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""
"I<cpu_set_t> データ構造体は CPU 集合を表現している。 CPU 集合は "
"B<sched_setaffinity>(2) や同様のインターフェースで使用されている。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:93
msgid ""
"The I<cpu_set_t> data type is implemented as a bit mask.  However, the data "
"structure should be treated as opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr "I<cpu_set_t> データ型はビットマスクとして実装されている。 しかし、 データ構造体はその実装を意識せずに扱うべきであり、 CPU 集合のすべての操作は、 このページで説明されているマクロを通して行うべきである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:96
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr "以下のマクロが CPU 集合 I<set> を操作するために提供されている。"

#. type: TP
#: build/C/man3/CPU_SET.3:96
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr "B<CPU_ZERO>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:101
msgid "Clears I<set>, so that it contains no CPUs."
msgstr "I<set> をクリアする。 集合には何も CPU が含まれない状態となる。"

#. type: TP
#: build/C/man3/CPU_SET.3:101
#, no-wrap
msgid "B<CPU_SET>()"
msgstr "B<CPU_SET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:107
msgid "Add CPU I<cpu> to I<set>."
msgstr "I<set> に I<cpu> を追加する。"

#. type: TP
#: build/C/man3/CPU_SET.3:107
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr "B<CPU_CLR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:113
msgid "Remove CPU I<cpu> from I<set>."
msgstr "I<set> から I<cpu> を削除する。"

#. type: TP
#: build/C/man3/CPU_SET.3:113
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr "B<CPU_ISSET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:119
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr "CPU I<cpu> が I<set> のメンバーであるかを検査する。"

#. type: TP
#: build/C/man3/CPU_SET.3:119
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr "B<CPU_COUNT>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:123
msgid "Return the number of CPUs in I<set>."
msgstr "I<set> に含まれる CPU 数を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:128
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""
"I<cpu> 引数が指定する場合、 その引数は副作用を伴うべきではない。 上記のマ"
"クロは引数を複数回評価する可能性があるからである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:142
#, fuzzy
#| msgid ""
#| "The first available CPU on the system corresponds to a I<cpu> value of 0, "
#| "the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
#| "B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
#| "maximum CPU number that can be stored in I<cpu_set_t>."
msgid ""
"The first CPU on the system corresponds to a I<cpu> value of 0, the next CPU "
"corresponds to a I<cpu> value of 1, and so on.  No assumptions should be "
"made about particular CPUs being available, or the set of CPUs being "
"contiguous, since CPUs can be taken offline dynamically or be otherwise "
"absent.  The constant B<CPU_SETSIZE> (currently 1024) specifies a value one "
"greater than the maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""
"そのシステムで利用可能な最初の CPU が I<cpu> 値 0 に対応し、 次の CPU が "
"I<cpu> 値 1 に対応し、 以降も同様である。 定数 B<CPU_SETSIZE> (現在のところ "
"1024) は I<cpu_set_t> に格納できる最大 CPU 数よりも大きな値である。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:144
msgid "The following macros perform logical operations on CPU sets:"
msgstr "以下のマクロは CPU 集合どうしの論理操作を行う。"

#. type: TP
#: build/C/man3/CPU_SET.3:144
#, no-wrap
msgid "B<CPU_AND>()"
msgstr "B<CPU_AND>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:153
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""
"集合 I<srcset1> と I<srcset2> の積集合を I<destset> に格納する (元の集合のい"
"ずれかが I<destset> として使用される場合もある)。"

#. type: TP
#: build/C/man3/CPU_SET.3:153
#, no-wrap
msgid "B<CPU_OR>()"
msgstr "B<CPU_OR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:162
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""
"集合 I<srcset1> と I<srcset2> の和集合を I<destset> に格納する (元の集合のい"
"ずれかが I<destset> として使用される場合もある)。"

#. type: TP
#: build/C/man3/CPU_SET.3:162
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr "B<CPU_XOR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:176
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""
"集合 I<srcset1> と I<srcset2> の XOR を I<destset> に格納する (元の集合のいず"
"れかが I<destset> として使用される場合もある)。 XOR とは、 I<srcset1> か "
"I<srcset2> のいずれかに含まれるが、両方には含まれない集合のことである。"

#. type: TP
#: build/C/man3/CPU_SET.3:176
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr "B<CPU_EQUAL>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:179
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr "二つの CPU 集合が全く同じ CPU を含んでいるかを検査する。"

#. type: SS
#: build/C/man3/CPU_SET.3:179
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr "動的に大きさが決まる CPU 集合"

#. type: Plain text
#: build/C/man3/CPU_SET.3:185
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""
"いくつかのアプリケーションでは CPU 集合の大きさを動的に決める能力 (例えば、 "
"標準の I<cpu_set_t> データ型で定義されたよりも大きい集合を割り当てるなど) が"
"必要となることがあるため、 現在 glibc はこれに対応するためにいくつかのマクロ"
"を提供している。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:187
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr "以下のマクロを使うと CPU 集合の割り当てと解放ができる。"

#. type: TP
#: build/C/man3/CPU_SET.3:187
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr "B<CPU_ALLOC>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:192
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to I<num_cpus-1>."
msgstr ""
"0 から I<num_cpus-1> までの範囲の CPU を保持するのに十分な大きさの CPU 集合を"
"割り当てる。"

#. type: TP
#: build/C/man3/CPU_SET.3:192
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr "B<CPU_ALLOC_SIZE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:202
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described below."
msgstr ""
"0 から I<num_cpus-1> までの範囲の CPU を保持するのに必要な CPU 集合の大きさを"
"バイト数で返す。 このマクロが返す値は、 後述の B<CPU_*_S>() マクロの "
"I<setsize> 引数として使用できる。"

#. type: TP
#: build/C/man3/CPU_SET.3:202
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr "B<CPU_FREE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:206
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr "以前に B<CPU_ALLOC>() で割り当てられた CPU 集合を解放する。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:213
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""
"名前が \"_S\" で終わるマクロは \"_S\" なしの同じ名前のマクロと同等である。 こ"
"れらのマクロは \"_S\" なしのものと同じ動作をするが、 動的に割り当てられた、 "
"大きさが I<setsize> バイトの CPU 集合に対して操作を行う点が異なる。"

#. type: SH
#: build/C/man3/CPU_SET.3:213 build/C/man2/clone.2:1193 build/C/man2/kcmp.2:208
#: build/C/man2/sched_get_priority_max.2:98 build/C/man3/sched_getcpu.3:58
#: build/C/man2/sched_rr_get_interval.2:73 build/C/man2/sched_setaffinity.2:107
#: build/C/man2/sched_setattr.2:299 build/C/man2/sched_setparam.2:87
#: build/C/man2/sched_setscheduler.2:133 build/C/man2/sched_yield.2:41
#: build/C/man2/setns.2:245 build/C/man2/unshare.2:286
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/CPU_SET.3:222
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""
"B<CPU_ISSET>() と B<CPU_ISSET_S>() は、 I<cpu> が I<set> に含まれていれば 0 "
"以外を返し、含まれない場合 0 を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:228
msgid ""
"B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr "B<CPU_COUNT>() と B<CPU_COUNT_S>() は I<set> に含まれる CPU 数を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:233
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise they return 0."
msgstr ""
"B<CPU_EQUAL>() と B<CPU_EQUAL_S>() は、 二つの CPU 集合が等しければ 0 以外を"
"返し、 等しくない場合 0 を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:238
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""
"B<CPU_ALLOC>() は成功するとポインターを返し、 失敗すると NULL を返す (エラー"
"は B<malloc>(3) と同じである)。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:242
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""
"B<CPU_ALLOC_SIZE>() は指定された大きさの CPU 集合を格納するのに必要なバイト数"
"を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:244
msgid "The other functions do not return a value."
msgstr "他の関数は値を返さない。"

#. type: SH
#: build/C/man3/CPU_SET.3:244 build/C/man2/clone.2:1523 build/C/man2/kcmp.2:298
#: build/C/man3/sched_getcpu.3:70 build/C/man2/sched_setaffinity.2:154
#: build/C/man2/sched_setattr.2:386 build/C/man2/setns.2:304
#: build/C/man2/unshare.2:421
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/CPU_SET.3:252
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""
"マクロ B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), B<CPU_ISSET>() は glibc "
"2.3.3 で追加された。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:255
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr "B<CPU_COUNT>() は glibc 2.6 で初めて登場した。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:273
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), "
"B<CPU_XOR_S>(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), "
"B<CPU_XOR_S>(), B<CPU_EQUAL_S>() は glibc 2.7 で初めて登場した。"

#. type: SH
#: build/C/man3/CPU_SET.3:273 build/C/man2/clone.2:1533 build/C/man2/kcmp.2:302
#: build/C/man2/sched_get_priority_max.2:114 build/C/man3/sched_getcpu.3:84
#: build/C/man2/sched_rr_get_interval.2:94 build/C/man2/sched_setaffinity.2:165
#: build/C/man2/sched_setattr.2:389 build/C/man2/sched_setparam.2:119
#: build/C/man2/sched_setscheduler.2:168 build/C/man2/sched_yield.2:52
#: build/C/man2/setns.2:309 build/C/man2/unshare.2:425
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/CPU_SET.3:275
msgid "These interfaces are Linux-specific."
msgstr "これらのインターフェースは Linux 固有である。"

#. type: SH
#: build/C/man3/CPU_SET.3:275 build/C/man2/clone.2:1537 build/C/man2/kcmp.2:305
#: build/C/man3/sched_getcpu.3:87 build/C/man2/sched_rr_get_interval.2:96
#: build/C/man2/sched_setaffinity.2:167 build/C/man2/sched_setattr.2:391
#: build/C/man2/sched_setscheduler.2:171 build/C/man2/sched_yield.2:54
#: build/C/man7/sched.7:951 build/C/man2/setns.2:313 build/C/man2/unshare.2:429
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/CPU_SET.3:278
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr "CPU 集合を複製するには、 B<memcpy>(3) を使用する。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:285
msgid ""
"Since CPU sets are bit masks allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr "CPU 集合はロングワード単位に割り当てられるビットマスクなので、 動的に割り当てられた CPU 集合の実際の CPU 数は I<sizeof(unsigned long)> の次の倍数に切り上げられることになる。 アプリケーションは、 これらの余分なビットの内容は不定と考えるべきである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:297
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of the bits in the bit mask), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr "名前は似ているが、 定数 B<CPU_SETSIZE> は I<cpu_set_t> データ型に含まれる CPU 数 (つまり、事実上ビットマスク内のビットカウント) を示すのに対して、 マクロ B<CPU_*_S>() の I<setsize> 引数はバイト単位のサイズである点に注意すること。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:303
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""
"「書式」に書かれている引数と返り値のデータ型は、それぞれの場合でどんな型が"
"期待されるかのヒントである。 しかしながら、 これらのインターフェースはマクロ"
"として実装されているため、 このヒントを守らなかった場合に、 コンパイラが必ず"
"しも全ての型エラーを捕捉できるとは限らない。"

#. type: SH
#: build/C/man3/CPU_SET.3:303 build/C/man2/clone.2:1732
#: build/C/man2/sched_setattr.2:407 build/C/man2/sched_setscheduler.2:217
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:315
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""
"glibc 2.8 以前の 32 ビットプラットフォームでは、 B<CPU_ALLOC>() は必要な空間"
"の割り当てを二度行い、 B<CPU_ALLOC_SIZE>() は本来あるべき値の二倍の値を返"
"す。 このバグはプログラムの動作には影響を与えないはずだが、 無駄にメモリーを"
"消費し、 動的に割り当てられた CPU 集合に対して操作を行うマクロの動作の効率が"
"下がる結果となる。 これらのバグは glibc 2.9 で修正された。"

#. type: SH
#: build/C/man3/CPU_SET.3:315 build/C/man2/clone.2:1780 build/C/man2/kcmp.2:322
#: build/C/man2/sched_setaffinity.2:306 build/C/man2/setns.2:324
#: build/C/man2/unshare.2:463
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/CPU_SET.3:318
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""
"以下のプログラムは、動的に割り当てた CPU 集合に対していくつかのマクロを使用す"
"る例を示している。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:326
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:333
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus;\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:338
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:340
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr "    num_cpus = atoi(argv[1]);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:346
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:348
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr "    size = CPU_ALLOC_SIZE(num_cpus);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:352
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (int cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (int cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:354
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:358
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/CPU_SET.3:359 build/C/man2/clone.2:1903 build/C/man2/kcmp.2:429
#: build/C/man2/sched_get_priority_max.2:116 build/C/man3/sched_getcpu.3:107
#: build/C/man2/sched_rr_get_interval.2:132
#: build/C/man2/sched_setaffinity.2:416 build/C/man2/sched_setattr.2:433
#: build/C/man2/sched_setparam.2:121 build/C/man2/sched_setscheduler.2:225
#: build/C/man2/sched_yield.2:90 build/C/man7/sched.7:966
#: build/C/man2/setns.2:415 build/C/man2/unshare.2:553
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/CPU_SET.3:364
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"

#. type: SH
#: build/C/man3/CPU_SET.3:364 build/C/man2/clone.2:1920 build/C/man2/kcmp.2:432
#: build/C/man2/sched_get_priority_max.2:126 build/C/man3/sched_getcpu.3:110
#: build/C/man2/sched_rr_get_interval.2:134
#: build/C/man2/sched_setaffinity.2:440 build/C/man2/sched_setattr.2:456
#: build/C/man2/sched_setparam.2:137 build/C/man2/sched_setscheduler.2:245
#: build/C/man2/sched_yield.2:92 build/C/man7/sched.7:1009
#: build/C/man2/setns.2:423 build/C/man2/unshare.2:568
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/CPU_SET.3:372 build/C/man2/clone.2:1928 build/C/man2/kcmp.2:440
#: build/C/man2/sched_get_priority_max.2:134 build/C/man3/sched_getcpu.3:118
#: build/C/man2/sched_rr_get_interval.2:142
#: build/C/man2/sched_setaffinity.2:448 build/C/man2/sched_setattr.2:464
#: build/C/man2/sched_setparam.2:145 build/C/man2/sched_setscheduler.2:253
#: build/C/man2/sched_yield.2:100 build/C/man7/sched.7:1017
#: build/C/man2/setns.2:431 build/C/man2/unshare.2:576
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/clone.2:42
#, no-wrap
msgid "CLONE"
msgstr "CLONE"

#. type: Plain text
#: build/C/man2/clone.2:45
msgid "clone, __clone2, clone3 - create a child process"
msgstr "clone, __clone2, clone3 - 子プロセスを作成する"

#. type: Plain text
#: build/C/man2/clone.2:48
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr "/* glibc ラッパー関数のプロトタイプ */\n"

#. type: Plain text
#: build/C/man2/clone.2:51 build/C/man2/unshare.2:27
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/clone.2:56
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<stack>B<, int >I<flags>B<, void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, void *>I<tls>B<, pid_t *>I<child_tid>B< */ );>\n"
msgstr ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<stack>B<, int >I<flags>B<, void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, void *>I<tls>B<, pid_t *>I<child_tid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:58
#, no-wrap
msgid "/* For the prototype of the raw clone() system call, see NOTES */\n"
msgstr "/* 生の clone() システムコールのプロトタイプについては「注意」の節を参照 */\n"

#. type: Plain text
#: build/C/man2/clone.2:60
#, no-wrap
msgid "B<long clone3(struct clone_args *>I<cl_args>B<, size_t >I<size>B<);>\n"
msgstr "B<long clone3(struct clone_args *>I<cl_args>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/clone.2:66
msgid "I<Note>: There is not yet a glibc wrapper for B<clone3>(); see NOTES."
msgstr "I<注>: B<clone3>() に対する glibc のラッパー関数は存在しない。「注意」を参照。"

#. type: Plain text
#: build/C/man2/clone.2:70
msgid ""
"These system calls create a new (\"child\") process, in a manner similar to "
"B<fork>(2)."
msgstr "これらのシステムコールは、 B<fork>(2) と似た方法で新しい (「子」) プロセスを作成する。"

#. type: Plain text
#: build/C/man2/clone.2:81
msgid ""
"By contrast with B<fork>(2), these system calls provide more precise control "
"over what pieces of execution context are shared between the calling process "
"and the child process.  For example, using these system calls, the caller "
"can control whether or not the two processes share the virtual address "
"space, the table of file descriptors, and the table of signal handlers.  "
"These system calls also allow the new child process to be placed in separate "
"B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:89
msgid ""
"Note that in this manual page, \"calling process\" normally corresponds to "
"\"parent process\".  But see the descriptions of B<CLONE_PARENT> and "
"B<CLONE_THREAD> below."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:91
msgid "This page describes the following interfaces:"
msgstr "このページでは以下のインターフェースについて説明する。"

#. type: IP
#: build/C/man2/clone.2:91 build/C/man2/clone.2:98 build/C/man2/clone.2:565
#: build/C/man2/clone.2:576 build/C/man2/clone.2:584 build/C/man2/clone.2:866
#: build/C/man2/clone.2:871 build/C/man2/clone.2:1797 build/C/man2/clone.2:1805
#: build/C/man7/sched.7:510 build/C/man7/sched.7:519 build/C/man7/sched.7:542
#: build/C/man7/sched.7:550 build/C/man7/sched.7:589 build/C/man7/sched.7:597
#: build/C/man7/sched.7:602 build/C/man7/sched.7:607 build/C/man7/sched.7:851
#: build/C/man7/sched.7:855 build/C/man7/sched.7:863 build/C/man7/sched.7:867
#: build/C/man7/sched.7:870
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/clone.2:98
msgid ""
"The glibc B<clone>()  wrapper function and the underlying system call on "
"which it is based.  The main text describes the wrapper function; the "
"differences for the raw system call are described toward the end of this "
"page."
msgstr "glibc の B<clone>() ラッパー関数とその裏で呼ばれるシステムコール。メインの説明はラッパー関数に関するものである。素のシステムコールにおける差分はこのページの最後の方で説明する。"

#. type: Plain text
#: build/C/man2/clone.2:102
msgid "The newer B<clone3>()  system call."
msgstr "新しい B<clone3>() システムコール。"

#. type: Plain text
#: build/C/man2/clone.2:106
msgid ""
"In the remainder of this page, the terminology \"the clone call\" is used "
"when noting details that apply to all of these interfaces,"
msgstr ""

#. type: SS
#: build/C/man2/clone.2:106
#, no-wrap
msgid "The clone() wrapper function"
msgstr "clone() ラッパー関数"

#. type: Plain text
#: build/C/man2/clone.2:122
msgid ""
"When the child process is created with the B<clone>()  wrapper function, it "
"commences execution by calling the function pointed to by the argument "
"I<fn>.  (This differs from B<fork>(2), where execution continues in the "
"child from the point of the B<fork>(2)  call.)  The I<arg> argument is "
"passed as the argument of the function I<fn>."
msgstr "B<clone>() ラッパー関数で子プロセスが作成された時に、引数 I<fn> が指す関数を呼び出して実行を開始する (この点が B<fork>(2) とは異なり、 B<fork>(2) の場合、子プロセスは B<fork>(2) が呼び出された場所から実行を続ける)。 I<arg> 引数は、関数 I<fn> の引数として渡される。"

#. type: Plain text
#: build/C/man2/clone.2:132
msgid ""
"When the I<fn>(I<arg>)  function returns, the child process terminates.  The "
"integer returned by I<fn> is the exit status for the child process.  The "
"child process may also terminate explicitly by calling B<exit>(2)  or after "
"receiving a fatal signal."
msgstr "I<fn>(I<arg>) 関数が終了すると、子プロセスは終了する。 I<fn> によって返された整数が子プロセスの終了ステータスとなる。 子プロセスは、 B<exit>(2)  を呼んで明示的に終了することもあるし、致命的なシグナルを受信した 場合に終了することもある。"

#. type: Plain text
#: build/C/man2/clone.2:152
msgid ""
"The I<stack> argument specifies the location of the stack used by the child "
"process.  Since the child and calling process may share memory, it is not "
"possible for the child process to execute in the same stack as the calling "
"process.  The calling process must therefore set up memory space for the "
"child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<stack> usually points to the topmost address of the memory space set up "
"for the child stack.  Note that B<clone>()  does not provide a means whereby "
"the caller can inform the kernel of the size of the stack area."
msgstr "I<stack> 引数は、子プロセスによって使用されるスタックの位置を指定する。 子プロセスと呼び出し元のプロセスはメモリーを共有することがあるため、 子プロセスは呼び出し元のプロセスと同じスタックで実行することができない。 このため、呼び出し元のプロセスは子プロセスのスタックのためのメモリー空間を 用意して、この空間へのポインターを B<clone>() へ渡さなければならない。 (HP PA プロセッサ以外の) Linux が動作する全てのプロセッサでは、 スタックは下方 (アドレスが小さい方向) へと伸びる。このため、普通は I<stack> は子プロセスのスタックのために用意したメモリー空間の一番大きい アドレスを指すようにする。 B<clone>() は呼び出し元がカーネルにスタック領域のサイズをカーネルに知らせる方法を提供していない点に注意すること。"

#. type: Plain text
#: build/C/man2/clone.2:157
msgid "The remaining arguments to B<clone>()  are discussed below."
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:157 build/C/man2/clone.2:258
#, no-wrap
msgid "clone3()"
msgstr "clone3()"

#. type: Plain text
#: build/C/man2/clone.2:167
msgid ""
"The B<clone3>()  system call provides a superset of the functionality of the "
"older B<clone>()  interface.  It also provides a number of API improvements, "
"including: space for additional flags bits; cleaner separation in the use of "
"various arguments; and the ability to specify the size of the child's stack "
"area."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:174
msgid ""
"As with B<fork>(2), B<clone3>()  returns in both the parent and the child.  "
"It returns 0 in the child process and returns the PID of the child in the "
"parent."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:180
msgid ""
"The I<cl_args> argument of B<clone3>()  is a structure of the following form:"
msgstr "B<clone3>() の I<cl_args> 引数は、以下の形式の構造体である。"

#. type: Plain text
#: build/C/man2/clone.2:203
#, no-wrap
msgid ""
"struct clone_args {\n"
"    u64 flags;        /* Flags bit mask */\n"
"    u64 pidfd;        /* Where to store PID file descriptor\n"
"                         (I<pid_t *>) */\n"
"    u64 child_tid;    /* Where to store child TID,\n"
"                         in child\\(aqs memory (I<pid_t *>) */\n"
"    u64 parent_tid;   /* Where to store child TID,\n"
"                         in parent\\(aqs memory (I<int *>) */\n"
"    u64 exit_signal;  /* Signal to deliver to parent on\n"
"                         child termination */\n"
"    u64 stack;        /* Pointer to lowest byte of stack */\n"
"    u64 stack_size;   /* Size of stack */\n"
"    u64 tls;          /* Location of new TLS */\n"
"    u64 set_tid;      /* Pointer to a I<pid_t> array\n"
"                         (since Linux 5.5) */\n"
"    u64 set_tid_size; /* Number of elements in I<set_tid>\n"
"                         (since Linux 5.5) */\n"
"    u64 cgroup;       /* File descriptor for target cgroup\n"
"                         of child (since Linux 5.7) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:216
msgid ""
"The I<size> argument that is supplied to B<clone3>()  should be initialized "
"to the size of this structure.  (The existence of the I<size> argument "
"permits future extensions to the I<clone_args> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:230
msgid ""
"The stack for the child process is specified via I<cl_args.stack>, which "
"points to the lowest byte of the stack area, and I<cl_args.stack_size>, "
"which specifies the size of the stack in bytes.  In the case where the "
"B<CLONE_VM> flag (see below) is specified, a stack must be explicitly "
"allocated and specified.  Otherwise, these two fields can be specified as "
"NULL and 0, which causes the child to use the same stack area as the parent "
"(in the child's own virtual address space)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:235
msgid "The remaining fields in the I<cl_args> argument are discussed below."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:235
#, no-wrap
msgid "Equivalence between clone() and clone3() arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:246
msgid ""
"Unlike the older B<clone>()  interface, where arguments are passed "
"individually, in the newer B<clone3>()  interface the arguments are packaged "
"into the I<clone_args> structure shown above.  This structure allows for a "
"superset of the information passed via the B<clone>()  arguments."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:253
msgid ""
"The following table shows the equivalence between the arguments of "
"B<clone>()  and the fields in the I<clone_args> argument supplied to "
"B<clone3>():"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:258
#, no-wrap
msgid "clone()"
msgstr "clone()"

#. type: tbl table
#: build/C/man2/clone.2:258 build/C/man2/clone.2:332
#, no-wrap
msgid "Notes"
msgstr "備考"

#. type: tbl table
#: build/C/man2/clone.2:259
#, no-wrap
msgid "I<cl_args> field"
msgstr "I<cl_args> フィールド"

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "flags & \\(ti0xff"
msgstr "flags & \\(ti0xff"

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "flags"
msgstr "flags"

#. type: tbl table
#: build/C/man2/clone.2:260
#, no-wrap
msgid "For most flags; details below"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:261 build/C/man2/clone.2:263
#, no-wrap
msgid "parent_tid"
msgstr "parent_tid"

#. type: tbl table
#: build/C/man2/clone.2:261
#, no-wrap
msgid "pidfd"
msgstr "pidfd"

#. type: tbl table
#: build/C/man2/clone.2:261
#, no-wrap
msgid "See CLONE_PIDFD"
msgstr "CLONE_PIDFD 参照"

#. type: tbl table
#: build/C/man2/clone.2:262
#, no-wrap
msgid "child_tid"
msgstr "child_tid"

#. type: tbl table
#: build/C/man2/clone.2:262
#, no-wrap
msgid "See CLONE_CHILD_SETTID"
msgstr "CLONE_CHILD_SETTID 参照"

#. type: tbl table
#: build/C/man2/clone.2:263
#, no-wrap
msgid "See CLONE_PARENT_SETTID"
msgstr "CLONE_PARENT_SETTID 参照"

#. type: tbl table
#: build/C/man2/clone.2:264
#, no-wrap
msgid "flags & 0xff"
msgstr "flags & 0xff"

#. type: tbl table
#: build/C/man2/clone.2:264
#, no-wrap
msgid "exit_signal"
msgstr "exit_signal"

#. type: tbl table
#: build/C/man2/clone.2:265
#, no-wrap
msgid "stack"
msgstr "stack"

#. type: tbl table
#: build/C/man2/clone.2:266 build/C/man2/clone.2:268 build/C/man2/clone.2:269
#: build/C/man2/clone.2:270
#, no-wrap
msgid "I<--->"
msgstr "I<--->"

#. type: tbl table
#: build/C/man2/clone.2:266
#, no-wrap
msgid "stack_size"
msgstr "stack_size"

#. type: tbl table
#: build/C/man2/clone.2:267
#, no-wrap
msgid "tls"
msgstr "tls"

#. type: tbl table
#: build/C/man2/clone.2:267
#, no-wrap
msgid "See CLONE_SETTLS"
msgstr "CLONE_SETTLS 参照"

#. type: tbl table
#: build/C/man2/clone.2:268
#, no-wrap
msgid "set_tid"
msgstr "set_tid"

#. type: tbl table
#: build/C/man2/clone.2:268
#, no-wrap
msgid "See below for details"
msgstr "詳細は下記を参照"

#. type: tbl table
#: build/C/man2/clone.2:269
#, no-wrap
msgid "set_tid_size"
msgstr "set_tid_size"

#. type: tbl table
#: build/C/man2/clone.2:270
#, no-wrap
msgid "cgroup"
msgstr "cgroup"

#. type: tbl table
#: build/C/man2/clone.2:270
#, no-wrap
msgid "See CLONE_INTO_CGROUP"
msgstr "CLONE_INTO_CGROUP 参照"

#. type: SS
#: build/C/man2/clone.2:274
#, no-wrap
msgid "The child termination signal"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:293
msgid ""
"When the child process terminates, a signal may be sent to the parent.  The "
"termination signal is specified in the low byte of I<flags> (B<clone>())  or "
"in I<cl_args.exit_signal> (B<clone3>()).  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal (i.e., zero) is specified, then the parent process "
"is not signaled when the child terminates."
msgstr ""
"子プロセスが終了した場合、シグナルが親プロセスに送信される。終了シグナル (termination signal) は (B<clone>() の) I<flags> の下位 1 バイトまたは (B<clone3>() の) I<cl_args.exit_signal> で指定される。\n"
"このシグナルとして B<SIGCHLD> 以外が指定された場合、親プロセスは、 B<wait>(2) で子プロセスを待つ際に、オプションとして B<__WALL> または B<__WCLONE> を指定しなければならない。どのシグナルも指定されなかった場合 (つまり 0 が指定された場合)、子プロセスが終了した時に親プロセスにシグナルは送られない。"

#. type: SS
#: build/C/man2/clone.2:293
#, no-wrap
msgid "The set_tid array"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:313
msgid ""
"By default, the kernel chooses the next sequential PID for the new process "
"in each of the PID namespaces where it is present.  When creating a process "
"with B<clone3>(), the I<set_tid> array (available since Linux 5.5)  can be "
"used to select specific PIDs for the process in some or all of the PID "
"namespaces where it is present.  If the PID of the newly created process "
"should be set only for the current PID namespace or in the newly created PID "
"namespace (if I<flags> contains B<CLONE_NEWPID>)  then the first element in "
"the I<set_tid> array has to be the desired PID and I<set_tid_size> needs to "
"be 1."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:326
msgid ""
"If the PID of the newly created process should have a certain value in "
"multiple PID namespaces, then the I<set_tid> array can have multiple "
"entries.  The first entry defines the PID in the most deeply nested PID "
"namespace and each of the following entries contains the PID in the "
"corresponding ancestor PID namespace.  The number of PID namespaces in which "
"a PID should be set is defined by I<set_tid_size> which cannot be larger "
"than the number of currently nested PID namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:328
msgid ""
"To create a process with the following PIDs in a PID namespace hierarchy:"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:332
#, no-wrap
msgid "PID NS level"
msgstr ""

#. type: tbl table
#: build/C/man2/clone.2:332
#, no-wrap
msgid "Requested PID"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:333 build/C/man2/kcmp.2:223
#, no-wrap
msgid "0"
msgstr "0"

#. type: tbl table
#: build/C/man2/clone.2:333
#, no-wrap
msgid "31496"
msgstr "31496"

#. type: tbl table
#: build/C/man2/clone.2:333
#, no-wrap
msgid "Outermost PID namespace"
msgstr ""

#. type: IP
#: build/C/man2/clone.2:334 build/C/man2/kcmp.2:228
#, no-wrap
msgid "1"
msgstr "1"

#. type: tbl table
#: build/C/man2/clone.2:334
#, no-wrap
msgid "42"
msgstr "42"

#. type: IP
#: build/C/man2/clone.2:335 build/C/man2/kcmp.2:232
#, no-wrap
msgid "2"
msgstr "2"

#. type: tbl table
#: build/C/man2/clone.2:335
#, no-wrap
msgid "7"
msgstr "7"

#. type: tbl table
#: build/C/man2/clone.2:335
#, no-wrap
msgid "Innermost PID namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:340
msgid "Set the array to:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:347
#, no-wrap
msgid ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid[2] = 31496;\n"
"set_tid_size = 3;\n"
msgstr ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid[2] = 31496;\n"
"set_tid_size = 3;\n"

#. type: Plain text
#: build/C/man2/clone.2:352
msgid ""
"If only the PIDs in the two innermost PID namespaces need to be specified, "
"set the array to:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:358
#, no-wrap
msgid ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid_size = 2;\n"
msgstr ""
"set_tid[0] = 7;\n"
"set_tid[1] = 42;\n"
"set_tid_size = 2;\n"

#. type: Plain text
#: build/C/man2/clone.2:363
msgid ""
"The PID in the PID namespaces outside the two innermost PID namespaces will "
"be selected the same way as any other PID is selected."
msgstr ""

#.  commit 124ea650d3072b005457faed69909221c2905a1f
#.  commit 1caef81da05a84a40dbf02110e967ce6d1135ff6
#. type: Plain text
#: build/C/man2/clone.2:374
msgid ""
"The I<set_tid> feature requires B<CAP_SYS_ADMIN> or (since Linux 5.9)  "
"B<CAP_CHECKPOINT_RESTORE> in all owning user namespaces of the target PID "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:382
msgid ""
"Callers may only choose a PID greater than 1 in a given PID namespace if an "
"B<init> process (i.e., a process with PID 1) already exists in that "
"namespace.  Otherwise the PID entry for this PID namespace must be 1."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:382
#, no-wrap
msgid "The flags mask"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:401
msgid ""
"Both B<clone>()  and B<clone3>()  allow a flags bit mask that modifies their "
"behavior and allows the caller to specify what is shared between the calling "
"process and the child process.  This bit mask\\(emthe I<flags> argument of "
"B<clone>()  or the I<cl_args.flags> field passed to B<clone3>()\\(emis "
"referred to as the I<flags> mask in the remainder of this page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:411
msgid ""
"The I<flags> mask is specified as a bitwise-OR of zero or more of the "
"constants listed below.  Except as noted below, these flags are available "
"(and have the same effect) in both B<clone>()  and B<clone3>()."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:411
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_CLEARTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:425
msgid ""
"Clear (zero) the child thread ID at the location pointed to by I<child_tid> "
"(B<clone>())  or I<cl_args.child_tid> (B<clone3>())  in child memory when "
"the child exits, and do a wakeup on the futex at that address.  The address "
"involved may be changed by the B<set_tid_address>(2)  system call.  This is "
"used by threading libraries."
msgstr "子プロセスが終了したときに、子プロセスのメモリー内の (B<clone>() の) I<child_tid> や (B<clone3>() の) I<cl_args.child_tid> が指す場所にある子プロセスのスレッド ID をクリアし (ゼロに設定し)、そのアドレスで futex を wake (起床) させる。 このアドレスは B<set_tid_address>(2) システムコールで変更することができる。 この機能はスレッドライブラリで使用される。"

#. type: TP
#: build/C/man2/clone.2:425
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:440
msgid ""
"Store the child thread ID at the location pointed to by I<child_tid> "
"(B<clone>())  or I<cl_args.child_tid> (B<clone3>())  in the child's memory.  "
"The store operation completes before the clone call returns control to user "
"space in the child process.  (Note that the store operation may not have "
"completed before the clone call returns in the parent process, which will be "
"relevant if the B<CLONE_VM> flag is also employed.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:440
#, no-wrap
msgid "B<CLONE_CLEAR_SIGHAND> (since Linux 5.5)"
msgstr "B<CLONE_CLEAR_SIGHAND> (Linux 5.5 以降)"

#.  commit b612e5df4587c934bd056bf05f4a1deca4de4f75
#. type: Plain text
#: build/C/man2/clone.2:450
msgid ""
"By default, signal dispositions in the child thread are the same as in the "
"parent.  If this flag is specified, then all signals that are handled in the "
"parent are reset to their default dispositions (B<SIG_DFL>)  in the child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:454
msgid ""
"Specifying this flag together with B<CLONE_SIGHAND> is nonsensical and "
"disallowed."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:454
#, no-wrap
msgid "B<CLONE_DETACHED> (historical)"
msgstr ""

#.  added in 2.5.32; removed in 2.6.0-test4
#. type: Plain text
#: build/C/man2/clone.2:468
msgid ""
"For a while (during the Linux 2.5 development series)  there was a "
"B<CLONE_DETACHED> flag, which caused the parent not to receive a signal when "
"the child terminated.  Ultimately, the effect of this flag was subsumed "
"under the B<CLONE_THREAD> flag and by the time Linux 2.6.0 was released, "
"this flag had no effect.  Starting in Linux 2.6.2, the need to give this "
"flag together with B<CLONE_THREAD> disappeared."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:474
msgid ""
"This flag is still defined, but it is usually ignored when calling "
"B<clone>().  However, see the description of B<CLONE_PIDFD> for some "
"exceptions."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:474
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr "B<CLONE_FILES> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:490
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected.  If a process sharing a file descriptor table "
"calls B<execve>(2), its file descriptor table is duplicated (unshared)."
msgstr "B<CLONE_FILES> が設定された場合、呼び出し元のプロセスと子プロセスはファイルディスクリプターの テーブルを共有する。 呼び出し元プロセスとその子プロセスの一方が作成した ファイルディスクリプターは、もう一方においても有効である。 同じように、一方のプロセスがファイルディスクリプターを閉じたり、 (B<fcntl>(2)  B<F_SETFD> 操作を使って) ディスクリプターに関連するフラグを変更したりすると、 もう一方のプロセスにも影響する。ファイルディスクリプターテーブルを共有するプロセスが B<execve>(2) を呼び出した場合、そのファイルディスクリプターテーブルは複製される (共有はされない)。"

#. type: Plain text
#: build/C/man2/clone.2:505
#, fuzzy
#| msgid ""
#| "If B<CLONE_FILES> is not set, the child process inherits a copy of all "
#| "file descriptors opened in the calling process at the time of "
#| "B<clone>().  (The duplicated file descriptors in the child refer to the "
#| "same open file descriptions (see B<open>(2))  as the corresponding file "
#| "descriptors in the calling process.)  Subsequent operations that open or "
#| "close file descriptors, or change file descriptor flags, performed by "
#| "either the calling process or the child process do not affect the other "
#| "process."
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of the clone call.  "
"Subsequent operations that open or close file descriptors, or change file "
"descriptor flags, performed by either the calling process or the child "
"process do not affect the other process.  Note, however, that the duplicated "
"file descriptors in the child refer to the same open file descriptions as "
"the corresponding file descriptors in the calling process, and thus share "
"file offsets and file status flags (see B<open>(2))."
msgstr ""
"B<CLONE_FILES> が設定されていない場合、子プロセスは、 B<clone>()  が実行され"
"た時点で、呼び出し元のプロセスがオープンしている全ての ファイルディスクリプ"
"ターのコピーを継承する (子プロセスの複製されたファイルディスクリプターは、 対"
"応する呼び出し元のプロセスのファイルディスクリプターと 同じファイル記述 "
"(B<open>(2)  参照) を参照する)。 これ以降に、呼び出し元のプロセスと子プロセス"
"の一方が ファイルディスクリプターの操作 (ファイルディスクリプターの オープ"
"ン・クローズや、ファイルディスクリプターフラグの変更)  を行っても、もう一方の"
"プロセスには影響を与えない。"

#. type: TP
#: build/C/man2/clone.2:505
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr "B<CLONE_FS> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:520
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same "
"filesystem information.  This includes the root of the filesystem, the "
"current working directory, and the umask.  Any call to B<chroot>(2), "
"B<chdir>(2), or B<umask>(2)  performed by the calling process or the child "
"process also affects the other process."
msgstr ""
"B<CLONE_FS> が設定された場合、呼び出し元のプロセスと子プロセスが同じファイル"
"システム 情報を共有する。ファイルシステム情報は、ファイルシステムのルート "
"(root)、 カレントワーキングディレクトリ (current working directory)  や "
"umask などである。 呼び出し元のプロセスや子プロセスのどちらか一方によって "
"B<chroot>(2), B<chdir>(2), B<umask>(2)  が呼び出されると、もう一方のプロセス"
"にも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:531
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the "
"filesystem information of the calling process at the time of the clone "
"call.  Calls to B<chroot>(2), B<chdir>(2), or B<umask>(2)  performed later "
"by one of the processes do not affect the other process."
msgstr ""
"B<CLONE_FS> が設定されていない場合、子プロセスは、 B<clone>()  が実行された時"
"点での、呼び出し元のプロセスのファイルシステム情報のコピーを 使用する。 これ"
"以降は、呼び出し元のプロセスと子プロセスの一方が B<chroot>(2), B<chdir>(2), "
"B<umask>(2)  を呼び出しても、もう一方のプロセスには影響を与えない。"

#. type: TP
#: build/C/man2/clone.2:531
#, no-wrap
msgid "B<CLONE_INTO_CGROUP> (since Linux 5.7)"
msgstr "B<CLONE_INTO_CGROUP> (Linux 5.7 以降)"

#.  commit ef2c41cf38a7559bbf91af42d5b6a4429db8fc68
#. type: Plain text
#: build/C/man2/clone.2:542
msgid ""
"By default, a child process is placed in the same version 2 cgroup as its "
"parent.  The B<CLONE_INTO_CGROUP> flag allows the child process to be "
"created in a different version 2 cgroup.  (Note that B<CLONE_INTO_CGROUP> "
"has effect only for version 2 cgroups.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:560
msgid ""
"In order to place the child process in a different cgroup, the caller "
"specifies B<CLONE_INTO_CGROUP> in I<cl_args.flags> and passes a file "
"descriptor that refers to a version 2 cgroup in the I<cl_args.cgroup> "
"field.  (This file descriptor can be obtained by opening a cgroup v2 "
"directory using either the B<O_RDONLY> or the B<O_PATH> flag.)  Note that "
"all of the usual restrictions (described in B<cgroups>(7))  on placing a "
"process into a version 2 cgroup apply."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:564
msgid ""
"Among the possible use cases for B<CLONE_INTO_CGROUP> are the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:576
msgid ""
"Spawning a process into a cgroup different from the parent's cgroup makes it "
"possible for a service manager to directly spawn new services into dedicated "
"cgroups.  This eliminates the accounting jitter that would be caused if the "
"child process was first created in the same cgroup as the parent and then "
"moved into the target cgroup.  Furthermore, spawning the child process "
"directly into a target cgroup is significantly cheaper than moving the child "
"process into the target cgroup after it has been created."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:584
msgid ""
"The B<CLONE_INTO_CGROUP> flag also allows the creation of frozen child "
"processes by spawning them into a frozen cgroup.  (See B<cgroups>(7)  for a "
"description of the freezer controller.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:589
msgid ""
"For threaded applications (or even thread implementations which make use of "
"cgroups to limit individual threads), it is possible to establish a fixed "
"cgroup layout before spawning each thread directly into its target cgroup."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:590
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr "B<CLONE_IO> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/clone.2:599
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""
"B<CLONE_IO> が設定された場合、新しいプロセスは呼び出し元のプロセスと I/O コン"
"テキストを共有する。 このフラグが設定されていない場合には、 (B<fork>(2)  の場"
"合と同様) 新しいプロセスは自分専用の I/O コンテキストを持つ。"

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:616
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""
"I/O コンテキストは、ディスクスケジュールの I/O スコープである (言い換えると、"
"I/O コンテキストは I/O スケジューラがプロセス I/O の スケジューリングをモデル"
"化するのに使用される)。 複数のプロセスが同じ I/O コンテキストを共有する場"
"合、 これらのプロセスは I/O スケジューラからは一つとして扱われる。 結果とし"
"て、これらのプロセスはディスクアクセスの時間を共有するようになる。 いくつか"
"の I/O スケジューラでは、 二つのプロセスが I/O コンテキストを共有している場"
"合、 これらのプロセスはディスクアクセスを交互に行うことができる。 同じプロセ"
"スの複数のスレッドが I/O を実行している場合 (例えば B<aio_read>(3))、 "
"B<CLONE_IO> を利用することで I/O 性能を良くすることができる。"

#. type: Plain text
#: build/C/man2/clone.2:620
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""
"カーネルの設定が B<CONFIG_BLOCK> オプション付きでない場合、 このフラグは何の"
"意味も持たない。"

#. type: TP
#: build/C/man2/clone.2:620 build/C/man2/setns.2:62 build/C/man2/unshare.2:76
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr "B<CLONE_NEWCGROUP> (Linux 4.6 以降)"

#. type: Plain text
#: build/C/man2/clone.2:626
#, fuzzy
#| msgid ""
#| "If B<CLONE_NEWUSER> is set, then create the process in a new user "
#| "namespace.  If this flag is not set, then (as with B<fork>(2))  the "
#| "process is created in the same user namespace as the calling process."
msgid ""
"Create the process in a new cgroup namespace.  If this flag is not set, then "
"(as with B<fork>(2))  the process is created in the same cgroup namespaces "
"as the calling process."
msgstr ""
"B<CLONE_NEWUSER> がセットされている場合、新しいユーザー名前空間でプロセスを作"
"成する。 このフラグがセットされていない場合、 (B<fork>(2)  の場合と同様に) 呼"
"び出し元のプロセスと同じユーザー名前空間でプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:629
msgid ""
"For further information on cgroup namespaces, see B<cgroup_namespaces>(7)."
msgstr "cgroup 名前空間の詳細は B<cgroup_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:635
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWCGROUP>."
msgstr "特権プロセス (B<CAP_SYS_ADMIN>) だけが B<CLONE_NEWCGROUP> を使用できる。"

#. type: TP
#: build/C/man2/clone.2:635 build/C/man2/unshare.2:88
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWIPC> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:644
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process."
msgstr "B<CLONE_NEWIPC> がセットされている場合、新しい IPC 名前空間でプロセスを作成する。 このフラグがセットされていない場合、 (B<fork>(2)  の場合と同様に) 呼び出し元のプロセスと同じ IPC 名前空間でプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:647
msgid "For further information on IPC namespaces, see B<ipc_namespaces>(7)."
msgstr "IPC 名前空間の詳細は B<ipc_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:654
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWIPC>.  "
"This flag can't be specified in conjunction with B<CLONE_SYSVSEM>."
msgstr ""
"特権プロセス (B<CAP_SYS_ADMIN>) だけが B<CLONE_NEWIPC> を使用できる。 このフ"
"ラグは B<CLONE_SYSVSEM> と組み合わせて指定することはできない。"

#. type: TP
#: build/C/man2/clone.2:654 build/C/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWNET> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man2/clone.2:658
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr "(このフラグの実装は、Linux 2.6.29 あたりまでには完成した。)"

#. type: Plain text
#: build/C/man2/clone.2:666
#, fuzzy
#| msgid ""
#| "If B<CLONE_NEWUSER> is set, then create the process in a new user "
#| "namespace.  If this flag is not set, then (as with B<fork>(2))  the "
#| "process is created in the same user namespace as the calling process."
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same network namespace as the calling process."
msgstr ""
"B<CLONE_NEWUSER> がセットされている場合、新しいユーザー名前空間でプロセスを作"
"成する。 このフラグがセットされていない場合、 (B<fork>(2)  の場合と同様に) 呼"
"び出し元のプロセスと同じユーザー名前空間でプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:669
msgid ""
"For further information on network namespaces, see B<network_namespaces>(7)."
msgstr "ネットワーク名前空間の詳細は B<network_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:674
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNET>."
msgstr "特権プロセス (B<CAP_SYS_ADMIN>) だけが B<CLONE_NEWNET> を使用できる。"

#. type: TP
#: build/C/man2/clone.2:674
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr "B<CLONE_NEWNS> (Linux 2.4.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:684
msgid ""
"If B<CLONE_NEWNS> is set, the cloned child is started in a new mount "
"namespace, initialized with a copy of the namespace of the parent.  If "
"B<CLONE_NEWNS> is not set, the child lives in the same mount namespace as "
"the parent."
msgstr ""
"B<CLONE_NEWNS> がセットされている場合、 clone で作成された子プロセスは新しい"
"マウント名前空間で開始され、 新しい名前空間は親プロセスの名前空間のコピーで初"
"期化される。 B<CLONE_NEWNS> がセットされていない場合、 子プロセスは親プロセス"
"と同じマウント名前空間となる。"

#. type: Plain text
#: build/C/man2/clone.2:689
msgid ""
"For further information on mount namespaces, see B<namespaces>(7)  and "
"B<mount_namespaces>(7)."
msgstr "マウント名前空間の詳細は B<namespaces>(7) と B<mount_namespaces>(7) を参照。"

#.  See https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/clone.2:700
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNS>.  It "
"is not permitted to specify both B<CLONE_NEWNS> and B<CLONE_FS> in the same "
"clone call."
msgstr ""
"特権プロセス (B<CAP_SYS_ADMIN>) のみが B<CLONE_NEWNS> を指定することができ"
"る。 一つの B<clone>()  呼び出しで、 B<CLONE_NEWNS> と B<CLONE_FS> の両方を指"
"定することはできない。"

#. type: TP
#: build/C/man2/clone.2:700
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWPID> (Linux 2.6.24 以降)"

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:716
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2))  the process is created "
"in the same PID namespace as the calling process."
msgstr "B<CLONE_NEWPID> がセットされている場合、新しい PID 名前空間でプロセスを作成する。 このフラグがセットされていない場合、 (B<fork>(2)  の場合と同様に) 呼び出し元のプロセスと同じ PID 名前空間でプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:721
msgid ""
"For further information on PID namespaces, see B<namespaces>(7)  and "
"B<pid_namespaces>(7)."
msgstr "PID 名前空間の詳細は B<namespaces>(7) と B<pid_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:730
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWPID>.  "
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>."
msgstr ""
"特権プロセス (B<CAP_SYS_ADMIN>) だけが B<CLONE_NEWPID> を使用できる。 このフ"
"ラグは B<CLONE_THREAD> や B<CLONE_PARENT> と組み合わせて指定することはできな"
"い。"

#. type: TP
#: build/C/man2/clone.2:730
#, no-wrap
msgid "B<CLONE_NEWUSER>"
msgstr "B<CLONE_NEWUSER>"

#. type: Plain text
#: build/C/man2/clone.2:740
msgid ""
"(This flag first became meaningful for B<clone>()  in Linux 2.6.23, the "
"current B<clone>()  semantics were merged in Linux 3.5, and the final pieces "
"to make the user namespaces completely usable were merged in Linux 3.8.)"
msgstr ""
"(このフラグが B<clone>() で意味を持つようになったのは Linux 2.6.23 である。 "
"現在の B<clone>() の動作が取り込まれたのは Linux 3.5 であり、 ユーザー名前空"
"間が完全に機能するようにする最後の機能が取り込まれたのは Linux 3.8 である。)"

#. type: Plain text
#: build/C/man2/clone.2:747
msgid ""
"If B<CLONE_NEWUSER> is set, then create the process in a new user "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same user namespace as the calling process."
msgstr ""
"B<CLONE_NEWUSER> がセットされている場合、新しいユーザー名前空間でプロセスを作"
"成する。 このフラグがセットされていない場合、 (B<fork>(2)  の場合と同様に) 呼"
"び出し元のプロセスと同じユーザー名前空間でプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:752
msgid ""
"For further information on user namespaces, see B<namespaces>(7)  and "
"B<user_namespaces>(7)."
msgstr ""
"ユーザー名前空間の詳細は B<namespaces>(7) と B<user_namespaces>(7) を参照。"

#.  Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
#. type: Plain text
#: build/C/man2/clone.2:763
msgid ""
"Before Linux 3.8, use of B<CLONE_NEWUSER> required that the caller have "
"three capabilities: B<CAP_SYS_ADMIN>, B<CAP_SETUID>, and B<CAP_SETGID>.  "
"Starting with Linux 3.8, no privileges are needed to create a user namespace."
msgstr ""
"Linux 3.8 より前では、 B<CLONE_NEWUSER> を使用するには、 呼び出し元は "
"B<CAP_SYS_ADMIN>, B<CAP_SETUID>, B<CAP_SETGID> の 3 つのケーパリビティを持っ"
"ている必要があった。 Linux 3.8 以降では、 ユーザー名前空間を作成するのに特権"
"は必要なくなった。"

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#.  The fix actually went into 3.9 and into 3.8.3. However, user namespaces
#.  were, for practical purposes, unusable in earlier 3.8.x because of the
#.  various filesystems that didn't support userns.
#. type: Plain text
#: build/C/man2/clone.2:777
msgid ""
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>.  For security reasons, B<CLONE_NEWUSER> cannot be specified "
"in conjunction with B<CLONE_FS>."
msgstr ""
"このフラグは B<CLONE_THREAD> や B<CLONE_PARENT> と組み合わせて指定することは"
"できない。 セキュリティ上の理由から、 B<CLONE_NEWUSER> は B<CLONE_FS> と組み"
"合わせて指定することはできない。"

#. type: TP
#: build/C/man2/clone.2:777 build/C/man2/unshare.2:218
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWUTS> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:788
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2))  the process is created in the same UTS namespace as the "
"calling process."
msgstr "B<CLONE_NEWUTS> が設定された場合、新しい UTS 名前空間でプロセスを作成する。 新しい UTS 名前空間の識別子の初期値は、呼び出し元のプロセスの UTS 名前空間の識別子を複製したものとなる。 このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼び出し元のプロセスと同じ UTS 名前空間で プロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:791
msgid "For further information on UTS namespaces, see B<uts_namespaces>(7)."
msgstr "UTS 名前空間の詳細は B<uts_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:796
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWUTS>."
msgstr "特権プロセス (B<CAP_SYS_ADMIN>) だけが B<CLONE_NEWUTS> を使用できる。"

#. type: TP
#: build/C/man2/clone.2:796
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr "B<CLONE_PARENT> (Linux 2.3.12 以降)"

#. type: Plain text
#: build/C/man2/clone.2:803
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""
"B<CLONE_PARENT> が設定された場合、新しい子供の (B<getppid>(2)  で返される) 親"
"プロセスは呼び出し元のプロセスの親プロセスと同じになる。"

#. type: Plain text
#: build/C/man2/clone.2:809
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""
"B<CLONE_PARENT> が設定されていない場合、 (B<fork>(2)  と同様に) 呼び出し元の"
"プロセスがその子供の親になる。"

#. type: Plain text
#: build/C/man2/clone.2:817
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""
"子供が終了した時にシグナルが送られるのは B<getppid>(2)  が返す親プロセスであ"
"る点に注意すること。このため B<CLONE_PARENT> が設定された場合、呼び出し元のプ"
"ロセスではなく呼び出し元のプロセスの 親プロセスにシグナルが送られる。"

#. type: Plain text
#: build/C/man2/clone.2:825
msgid ""
"The B<CLONE_PARENT> flag can't be used in clone calls by the global init "
"process (PID 1 in the initial PID namespace)  and init processes in other "
"PID namespaces.  This restriction prevents the creation of multi-rooted "
"process trees as well as the creation of unreapable zombies in the initial "
"PID namespace."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:825
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_PARENT_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:839
#, fuzzy
#| msgid ""
#| "Store child thread ID at location I<ptid> in parent and child memory.  "
#| "(In Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgid ""
"Store the child thread ID at the location pointed to by I<parent_tid> "
"(B<clone>())  or I<cl_args.parent_tid> (B<clone3>())  in the parent's "
"memory.  (In Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did "
"this.)  The store operation completes before the clone call returns control "
"to user space."
msgstr ""
"親プロセスと子プロセスのメモリー内の I<ptid> が指す領域に子プロセスのスレッ"
"ド ID を格納する。 (Linux 2.5.32-2.5.48 では、 同じことをする "
"B<CLONE_SETTID> というフラグが存在した。)"

#. type: TP
#: build/C/man2/clone.2:839
#, no-wrap
msgid "B<CLONE_PID> (Linux 2.0 to 2.5.15)"
msgstr " B<CLONE_PID> (Linux 2.0 to 2.5.15)"

#. type: Plain text
#: build/C/man2/clone.2:856
#, fuzzy
#| msgid ""
#| "If B<CLONE_PID> is set, the child process is created with the same "
#| "process ID as the calling process.  This is good for hacking the system, "
#| "but otherwise of not much use.  Since 2.3.21 this flag can be specified "
#| "only by the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  From Linux 2.3.21 onward, this flag could be "
"specified only by the system boot process (PID 0).  The flag disappeared "
"completely from the kernel sources in Linux 2.5.16.  Subsequently, the "
"kernel silently ignored this bit if it was specified in the I<flags> mask.  "
"Much later, the same bit was recycled for use as the B<CLONE_PIDFD> flag."
msgstr ""
"B<CLONE_PID> が設定された場合、子プロセスは呼び出し元のプロセスと同じプロセ"
"ス ID で作成される。これはシステムをハッキングするのには便利だが、 それ以外に"
"はあまり使われない。 Linux 2.3.21 以降では、 システムのブートプロセス (PID "
"0) だけがこのフラグを指定できる。 Linux 2.5.16 で削除された。"

#. type: TP
#: build/C/man2/clone.2:856
#, no-wrap
msgid "B<CLONE_PIDFD> (since Linux 5.2)"
msgstr "B<CLONE_PIDFD> (Linux 5.2 以降)"

#.  commit b3e5838252665ee4cfa76b82bdf1198dca81e5be
#. type: Plain text
#: build/C/man2/clone.2:865
msgid ""
"If this flag is specified, a PID file descriptor referring to the child "
"process is allocated and placed at a specified location in the parent's "
"memory.  The close-on-exec flag is set on this new file descriptor.  PID "
"file descriptors can be used for the purposes described in B<pidfd_open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:871
msgid ""
"When using B<clone3>(), the PID file descriptor is placed at the location "
"pointed to by I<cl_args.pidfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:884
msgid ""
"When using B<clone>(), the PID file descriptor is placed at the location "
"pointed to by I<parent_tid>.  Since the I<parent_tid> argument is used to "
"return the PID file descriptor, B<CLONE_PIDFD> cannot be used with "
"B<CLONE_PARENT_SETTID> when calling B<clone>()."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:890
msgid ""
"It is currently not possible to use this flag together with B<CLONE_THREAD.> "
"This means that the process identified by the PID file descriptor will "
"always be a thread group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:905
msgid ""
"If the obsolete B<CLONE_DETACHED> flag is specified alongside B<CLONE_PIDFD> "
"when calling B<clone>(), an error is returned.  An error also results if "
"B<CLONE_DETACHED> is specified when calling B<clone3>().  This error "
"behavior ensures that the bit corresponding to B<CLONE_DETACHED> can be "
"reused for further PID file descriptor features in the future."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:905
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr "B<CLONE_PTRACE> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:912
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""
"B<CLONE_PTRACE> が指定され、かつ呼び出し元のプロセスが追跡 (trace) されていた"
"場合、子プロセスも 同様に追跡される。 (B<ptrace>(2)  を参照のこと)"

#. type: TP
#: build/C/man2/clone.2:912
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr "B<CLONE_SETTLS> (Linux 2.5.32 以降)"

#. type: Plain text
#: build/C/man2/clone.2:916
#, fuzzy
#| msgid ""
#| "The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
#| "(See B<set_thread_area>(2).)"
msgid "The TLS (Thread Local Storage) descriptor is set to I<tls>."
msgstr ""
"I<newtls> 引数は、新しい TLS (Thread Local Storage) ディスクリプターであ"
"る。 (B<set_thread_area>(2)  を参照のこと)"

#. type: Plain text
#: build/C/man2/clone.2:933
msgid ""
"The interpretation of I<tls> and the resulting effect is architecture "
"dependent.  On x86, I<tls> is interpreted as a I<struct user_desc\\ *> (see "
"B<set_thread_area>(2)).  On x86-64 it is the new value to be set for the %fs "
"base register (see the B<ARCH_SET_FS> argument to B<arch_prctl>(2)).  On "
"architectures with a dedicated TLS register, it is the new value of that "
"register."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:936
msgid ""
"Use of this flag requires detailed knowledge and generally it should not be "
"used except in libraries implementing threading."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:936
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr "B<CLONE_SIGHAND> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:952
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定された場合、呼び出し元のプロセスと子プロセスは同じシグ"
"ナルハン ドラのテーブルを共有する。呼び出し元のプロセスまたは子プロセスのどち"
"らかが B<sigaction>(2)  を呼び出してシグナルに対応する動作を変更した場合、 も"
"う一方のプロセスのシグナル動作も変更される。 但し、呼び出し元のプロセスと子プ"
"ロセスは、 プロセス毎に、シグナルマスク (signal mask) と処理待ちシグナルの集"
"合 を持っている。このため、あるプロセスは、 B<sigprocmask>(2)  を使用して、も"
"う一方のプロセスに影響を与えずに シグナルを禁止 (block) したり許可 (unblock) "
"したりできる。"

#. type: Plain text
#: build/C/man2/clone.2:961
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time of the clone call.  Calls "
"to B<sigaction>(2)  performed later by one of the processes have no effect "
"on the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定されていない場合、子プロセスは B<clone>()  が実行され"
"た時点での、呼び出し元のプロセスのシグナルハンドラーの コピーを継承する。これ"
"以降は、一方のプロセスが B<sigaction>(2)  を呼び出しても、もう一方のプロセス"
"には影響を与えない。"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:971
msgid ""
"Since Linux 2.6.0, the I<flags> mask must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr "Linux 2.6.0 以降では、 B<CLONE_SIGHAND> を指定する場合、 B<CLONE_VM> も I<flags> マスクに含めなければならない。"

#. type: TP
#: build/C/man2/clone.2:971
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0)"
msgstr "B<CLONE_STOPPED> (Linux 2.6.0 以降)"

#.  Precisely: Linux 2.6.0-test2
#. type: Plain text
#: build/C/man2/clone.2:981
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""
"B<CLONE_STOPPED> が設定されると、子プロセスは最初 (B<SIGSTOP> シグナルを送ら"
"れたかのように) 停止した状態となる。 子プロセスを再開させるには B<SIGCONT> シ"
"グナルを送信しなければならない。"

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:993
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38.  Since then, the kernel silently ignores it "
"without error.  Starting with Linux 4.6, the same bit was reused for the "
"B<CLONE_NEWCGROUP> flag."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:993
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.5.10 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1011
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore adjustment (I<semadj>)  values (see "
"B<semop>(2)).  In this case, the shared list accumulates I<semadj> values "
"across all processes sharing the list, and semaphore adjustments are "
"performed only when the last process that is sharing the list terminates (or "
"ceases sharing the list using B<unshare>(2)).  If this flag is not set, then "
"the child has a separate I<semadj> list that is initially empty."
msgstr ""
"B<CLONE_SYSVSEM> がセットされると、子プロセスと呼び出し元プロセスは一つの "
"System\\ V セマフォの調整値 (I<semadj>) (B<semop>(2)  参照) を共有する。 この"
"場合、共有されたリストはこのリストを共有する全プロセスの I<semadj> 値を積算"
"し、 セマフォ調整はこのリストを共有している最後のプロセスが終了した際 (また"
"は B<unshare>(2) を使ってリストの共有が中止された際) に実行される。 このフラ"
"グがセットされていなければ、 子プロセスは独自のセマフォ I<semadj> リストを持"
"つ (リストの初期値は空である)。"

#. type: TP
#: build/C/man2/clone.2:1011
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0)"
msgstr "B<CLONE_THREAD> (Linux 2.4.0 以降)"

#.  Precisely: Linux 2.6.0-test8
#. type: Plain text
#: build/C/man2/clone.2:1021
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""
"B<CLONE_THREAD> が設定された場合、子プロセスは呼び出し元のプロセスと同じス"
"レッドグループに 置かれる。 B<CLONE_THREAD> についての以降の議論を読みやすく"
"するため、 「スレッド」という用語はスレッドグループの中のプロセスを 参照する"
"のに使うこととする。"

#. type: Plain text
#: build/C/man2/clone.2:1029
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""
"スレッドグループは、 スレッド集合で一つの PID を共有するという POSIX スレッド"
"の概念をサポートするために Linux 2.4 に加えられた機能であった。 内部的には、"
"この共有 PID はいわゆるそのスレッドグループの スレッドグループ識別子 (TGID) "
"である。 Linux 2.4 以降では、 B<getpid>(2)  の呼び出しではそのプロセスのス"
"レッドグループ ID を返す。"

#. type: Plain text
#: build/C/man2/clone.2:1037
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller, and a thread can obtain its own TID using "
"B<gettid>(2)."
msgstr "あるグループに属するスレッドは (システム全体で) 一意なスレッド ID (TID)  で区別できる。新しいスレッドの TID は呼び出し元へ関数の結果として返され、 スレッドは自分自身の TID を B<gettid>(2)  で取得できる。"

#. type: Plain text
#: build/C/man2/clone.2:1045
msgid ""
"When a clone call is made without specifying B<CLONE_THREAD>, then the "
"resulting thread is placed in a new thread group whose TGID is the same as "
"the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr "B<CLONE_THREAD> を指定せずに clone の呼び出しが行われると、 生成されたスレッドはそのスレッドの TID と同じ値の TGID を持つ 新しいスレッドグループに置かれる。このスレッドは 新しいスレッドグループの「リーダー」である。"

#. type: Plain text
#: build/C/man2/clone.2:1064
#, fuzzy
#| msgid ""
#| "A new thread created with B<CLONE_THREAD> has the same parent process as "
#| "the caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
#| "B<getppid>(2)  return the same value for all of the threads in a thread "
#| "group.  When a B<CLONE_THREAD> thread terminates, the thread that created "
#| "it using B<clone>()  is not sent a B<SIGCHLD> (or other termination) "
#| "signal; nor can the status of such a thread be obtained using "
#| "B<wait>(2).  (The thread is said to be I<detached>.)"
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"process that made the clone call (i.e., like B<CLONE_PARENT>), so that calls "
"to B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"is not sent a B<SIGCHLD> (or other termination) signal; nor can the status "
"of such a thread be obtained using B<wait>(2).  (The thread is said to be "
"I<detached>.)"
msgstr ""
"B<CLONE_THREAD> を指定して作成された新しいスレッドは、 (B<CLONE_PARENT> の場"
"合と同様に)  B<clone>()  を呼び出し元と同じ親プロセスを持つ。 そのため、 "
"B<getppid>(2)  を呼ぶと、一つのスレッドグループに属すスレッドは全て同じ値を返"
"す。 B<CLONE_THREAD> で作られたスレッドが終了した際に、 そのスレッドを "
"B<clone>()  を使って生成したスレッドには B<SIGCHLD> (もしくは他の終了シグナ"
"ル) は送信されない。 また、 B<wait>(2)  を使って終了したスレッドの状態を取得"
"することもできない (そのようなスレッドは I<detached> (分離された) といわれ"
"る)。"

#. type: Plain text
#: build/C/man2/clone.2:1069
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""
"スレッドグループに属す全てのスレッドが終了した後、 そのスレッドグループの親プ"
"ロセスに B<SIGCHLD> (もしくは他の終了シグナル) が送られる。"

#. type: Plain text
#: build/C/man2/clone.2:1074
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""
"スレッドグループに属すいずれかのスレッドが B<execve>(2)  を実行すると、スレッ"
"ドグループリーダー以外の全てのスレッドは 終了され、新しいプロセスがそのスレッ"
"ドグループリーダーの下で 実行される。"

#. type: Plain text
#: build/C/man2/clone.2:1080
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""
"スレッドグループに属すスレッドの一つが B<fork>(2)  を使って子プロセスを作成し"
"た場合、 スレッドグループのどのスレッドであっても その子供を B<wait>(2)  でき"
"る。"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:1094
msgid ""
"Since Linux 2.5.35, the I<flags> mask must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified (and note that, since Linux 2.6.0, "
"B<CLONE_SIGHAND> also requires B<CLONE_VM> to be included)."
msgstr "Linux 2.5.35 以降では、 B<CLONE_THREAD> を指定する場合、 I<flags> マスクに B<CLONE_SIGHAND> も含まれていなければならない (Linux 2.6.0 以降では、 B<CLONE_SIGHAND> を指定する場合 B<CLONE_VM> も指定する必要がある点に注意すること)。"

#. type: Plain text
#: build/C/man2/clone.2:1099
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""
"シグナルの配送と処理はプロセス全体に影響する: ハンドラーを設定していないシグ"
"ナルがあるスレッドに配送されると、 そのシグナルはスレッドグループの全メンバー"
"に影響を及ぼす (終了したり、停止したり、動作を継続したり、無視されたりする)。"

#. type: Plain text
#: build/C/man2/clone.2:1102
msgid "Each thread has its own signal mask, as set by B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1124
msgid ""
"A signal may be process-directed or thread-directed.  A process-directed "
"signal is targeted at a thread group (i.e., a TGID), and is delivered to an "
"arbitrarily selected thread from among those that are not blocking the "
"signal.  A signal may be process-directed because it was generated by the "
"kernel for reasons other than a hardware exception, or because it was sent "
"using B<kill>(2)  or B<sigqueue>(3).  A thread-directed signal is targeted "
"at (i.e., delivered to)  a specific thread.  A signal may be thread directed "
"because it was sent using B<tgkill>(2)  or B<pthread_sigqueue>(3), or "
"because the thread executed a machine language instruction that triggered a "
"hardware exception (e.g., invalid memory access triggering B<SIGSEGV> or a "
"floating-point exception triggering B<SIGFPE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1129
msgid ""
"A call to B<sigpending>(2)  returns a signal set that is the union of the "
"pending process-directed signals and the signals that are pending for the "
"calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1138
#, fuzzy
#| msgid ""
#| "If B<kill>(2)  is used to send a signal to a thread group, and the thread "
#| "group has installed a handler for the signal, then the handler will be "
#| "invoked in exactly one, arbitrarily selected member of the thread group "
#| "that has not blocked the signal.  If multiple threads in a group are "
#| "waiting to accept the same signal using B<sigwaitinfo>(2), the kernel "
#| "will arbitrarily select one of these threads to receive a signal sent "
#| "using B<kill>(2)."
msgid ""
"If a process-directed signal is delivered to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive the signal."
msgstr ""
"B<kill>(2)  を使ってスレッドグループにシグナルが送られた場合で、 そのスレッド"
"グループがそのシグナルに対するシグナルハンドラーが 登録されていたときには、シ"
"グナルハンドラーはスレッドグループの メンバーのうち、ただ一つのスレッドでだけ"
"起動される。ハンドラーが 起動されるスレッドは、そのシグナルを禁止 (block) し"
"ていない メンバーの中から一つだけが勝手に (arbitrarily) 選ばれる。 スレッドグ"
"ループに属す複数のスレッドが B<sigwaitinfo>(2)  を使って同じシグナルを待って"
"いる場合、 これらのスレッドの中から一つをカーネルが勝手に選択し、 そのスレッ"
"ドが B<kill (2)> を使って送信されたシグナルを受信する。"

#. type: TP
#: build/C/man2/clone.2:1138
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr "B<CLONE_UNTRACED> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1145
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""
"B<CLONE_UNTRACED> が指定されると、 trace を行っているプロセスは この子プロセ"
"スに B<CLONE_PTRACE> を適用することができない。"

#. type: TP
#: build/C/man2/clone.2:1145
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr "B<CLONE_VFORK> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1157
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""
"B<CLONE_VFORK> が設定された場合、 (B<vfork>(2)  と同様に) 子プロセスが "
"B<execve>(2)  または B<_exit>(2)  によって仮想メモリーを解放するまで、呼び出"
"し元のプロセスの実行は停止される。"

#. type: Plain text
#: build/C/man2/clone.2:1163
msgid ""
"If B<CLONE_VFORK> is not set, then both the calling process and the child "
"are schedulable after the call, and an application should not rely on "
"execution occurring in any particular order."
msgstr ""
"B<CLONE_VFORK> が設定されていない場合、 B<clone>()  呼び出し後は、呼び出し元"
"のプロセスと子プロセスの 両方がスケジュール対象となり、アプリケーションはこれ"
"らのプロセスの 実行順序に依存しないようにすべきである。"

#. type: TP
#: build/C/man2/clone.2:1163
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr "B<CLONE_VM> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1176
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other process."
msgstr ""
"B<CLONE_VM> が設定された場合、呼び出し元のプロセスと子プロセスは同じメモリー"
"空間で 実行される。特に、呼び出し元のプロセスや子プロセスの一方がメモリーに "
"書き込んだ内容はもう一方のプロセスからも見ることができる。さらに、 子プロセス"
"や呼び出し元のプロセスの一方が B<mmap>(2)  や B<munmap>(2)  を使ってメモリー"
"をマップしたりアンマップした場合、 もう一方のプロセスにも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:1184
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of the clone call.  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr "B<CLONE_VM> が設定されていない場合、子プロセスは clone が呼ばれた時点での、親プロセスのメモリー空間をコピーした 別のメモリー空間で実行される。 一方のプロセスが行ったメモリーへの書き込みや ファイルのマップ/アンマップは、 B<fork>(2)  の場合と同様、もう一方のプロセスには影響しない。"

#. type: Plain text
#: build/C/man2/clone.2:1193
msgid ""
"If the B<CLONE_VM> flag is specified and the B<CLONE_VM> flag is not "
"specified, then any alternate signal stack that was established by "
"B<sigaltstack>(2)  is cleared in the child process."
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:1202
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""
"成功した場合、呼び出し元の実行スレッドには子プロセスのスレッドID が返され"
"る。 失敗した場合、 呼び出し元のコンテキストには -1 が返され、子プロセスは 作"
"成されず、 I<errno> が適切に設定される。"

#. type: SH
#: build/C/man2/clone.2:1202 build/C/man2/kcmp.2:251
#: build/C/man2/sched_get_priority_max.2:108 build/C/man3/sched_getcpu.3:65
#: build/C/man2/sched_rr_get_interval.2:80 build/C/man2/sched_setaffinity.2:119
#: build/C/man2/sched_setattr.2:308 build/C/man2/sched_setparam.2:96
#: build/C/man2/sched_setscheduler.2:143 build/C/man2/sched_yield.2:48
#: build/C/man2/setns.2:252 build/C/man2/unshare.2:291
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/clone.2:1203
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/clone.2:1207
msgid "Too many processes are already running; see B<fork>(2)."
msgstr "すでに実行中のプロセスが多すぎる。 B<fork>(2) 参照。"

#. type: TP
#: build/C/man2/clone.2:1207
#, no-wrap
msgid "B<EBUSY> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1215
msgid ""
"B<CLONE_INTO_CGROUP> was specified in I<cl_args.flags>, but the file "
"descriptor specified in I<cl_args.cgroup> refers to a version 2 cgroup in "
"which a domain controller is enabled."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1215
#, no-wrap
msgid "B<EEXIST> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1220
msgid ""
"One (or more) of the PIDs specified in I<set_tid> already exists in the "
"corresponding PID namespace."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1220 build/C/man2/clone.2:1229
#: build/C/man2/clone.2:1239 build/C/man2/clone.2:1256
#: build/C/man2/clone.2:1268 build/C/man2/clone.2:1287
#: build/C/man2/clone.2:1296 build/C/man2/clone.2:1314
#: build/C/man2/clone.2:1323 build/C/man2/clone.2:1334
#: build/C/man2/clone.2:1343 build/C/man2/clone.2:1352
#: build/C/man2/clone.2:1361 build/C/man2/clone.2:1370
#: build/C/man2/clone.2:1391 build/C/man2/kcmp.2:267
#: build/C/man2/sched_get_priority_max.2:109
#: build/C/man2/sched_rr_get_interval.2:84 build/C/man2/sched_setaffinity.2:123
#: build/C/man2/sched_setaffinity.2:133 build/C/man2/sched_setattr.2:313
#: build/C/man2/sched_setattr.2:337 build/C/man2/sched_setattr.2:360
#: build/C/man2/sched_setparam.2:97 build/C/man2/sched_setparam.2:104
#: build/C/man2/sched_setscheduler.2:144 build/C/man2/sched_setscheduler.2:151
#: build/C/man2/sched_setscheduler.2:156 build/C/man2/setns.2:257
#: build/C/man2/setns.2:262 build/C/man2/setns.2:266 build/C/man2/setns.2:271
#: build/C/man2/setns.2:275 build/C/man2/setns.2:282 build/C/man2/setns.2:286
#: build/C/man2/unshare.2:292 build/C/man2/unshare.2:296
#: build/C/man2/unshare.2:305 build/C/man2/unshare.2:315
#: build/C/man2/unshare.2:323 build/C/man2/unshare.2:331
#: build/C/man2/unshare.2:339 build/C/man2/unshare.2:347
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/clone.2:1229
msgid ""
"Both B<CLONE_SIGHAND> and B<CLONE_CLEAR_SIGHAND> were specified in the "
"I<flags> mask."
msgstr "B<CLONE_SIGHAND> と B<CLONE_CLEAR_SIGHAND> の両方が I<flags> マスクに指定された。"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: build/C/man2/clone.2:1239
msgid ""
"B<CLONE_SIGHAND> was specified in the I<flags> mask, but B<CLONE_VM> was "
"not.  (Since Linux 2.6.0.)"
msgstr "I<flags> マスクに B<CLONE_SIGHAND> が指定されていたが、 B<CLONE_VM> が指定されていなかった。 (Linux 2.6.0 以降)"

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:1256
msgid ""
"B<CLONE_THREAD> was specified in the I<flags> mask, but B<CLONE_SIGHAND> was "
"not.  (Since Linux 2.5.35.)"
msgstr "I<flags> マスクに B<CLONE_THREAD> が指定されていたが、 B<CLONE_SIGHAND> が指定されていなかった。 (Linux 2.5.35 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1268
msgid ""
"B<CLONE_THREAD> was specified in the I<flags> mask, but the current process "
"previously called B<unshare>(2)  with the B<CLONE_NEWPID> flag or used "
"B<setns>(2)  to reassociate itself with a PID namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: build/C/man2/clone.2:1278
msgid ""
"Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in the I<flags> mask."
msgstr "B<CLONE_FS> と B<CLONE_NEWNS> の両方が I<flags> マスクに指定された。"

#. type: TP
#: build/C/man2/clone.2:1278
#, no-wrap
msgid "B<EINVAL> (since Linux 3.9)"
msgstr "B<EINVAL> (Linux 3.9 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1287
msgid ""
"Both B<CLONE_NEWUSER> and B<CLONE_FS> were specified in the I<flags> mask."
msgstr "B<CLONE_NEWUSER> と B<CLONE_FS> の両方が I<flags> マスクに指定された。"

#. type: Plain text
#: build/C/man2/clone.2:1296
msgid ""
"Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in the I<flags> "
"mask."
msgstr "B<CLONE_NEWIPC> と B<CLONE_SYSVSEM> の両方が I<flags> マスクに指定された。"

#. type: Plain text
#: build/C/man2/clone.2:1309
msgid ""
"One (or both) of B<CLONE_NEWPID> or B<CLONE_NEWUSER> and one (or both) of "
"B<CLONE_THREAD> or B<CLONE_PARENT> were specified in the I<flags> mask."
msgstr "B<CLONE_NEWPID> と B<CLONE_NEWUSER> の一方 (もしくは両方) と、 B<CLONE_THREAD> と B<CLONE_PARENT>  の一方 (もしくは両方) が、 I<flags> マスクに指定された。"

#. type: TP
#: build/C/man2/clone.2:1309
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.32)"
msgstr "B<EINVAL> (Linux 2.6.32 以降)"

#.  commit 123be07b0b399670a7cc3d82fef0cb4f93ef885c
#. type: Plain text
#: build/C/man2/clone.2:1314
msgid "B<CLONE_PARENT> was specified, and the caller is an init process."
msgstr "B<CLONE_PARENT> が指定されたが、呼び出し元が init プロセスである。"

#. type: Plain text
#: build/C/man2/clone.2:1323
msgid ""
"Returned by the glibc B<clone>()  wrapper function when I<fn> or I<stack> is "
"specified as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1334
msgid ""
"B<CLONE_NEWIPC> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr "I<flags> マスクに B<CLONE_NEWIPC> が指定されたが、カーネルでオプション B<CONFIG_SYSVIPC> と B<CONFIG_IPC_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:1343
msgid ""
"B<CLONE_NEWNET> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_NET_NS> option."
msgstr "I<flags> マスクに B<CLONE_NEWNET> が指定されたが、カーネルでオプション B<CONFIG_NET_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:1352
msgid ""
"B<CLONE_NEWPID> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_PID_NS> option."
msgstr "I<flags> マスクに B<CLONE_NEWPID> が指定されたが、カーネルでオプション B<CONFIG_PID_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:1361
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr "I<flags> マスクに B<CLONE_NEWUSER> が指定されたが、カーネルでオプション B<CONFIG_USER_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:1370
msgid ""
"B<CLONE_NEWUTS> was specified in the I<flags> mask, but the kernel was not "
"configured with the B<CONFIG_UTS_NS> option."
msgstr "I<flags> マスクに B<CLONE_NEWUTS> が指定されたが、カーネルでオプション B<CONFIG_UTS_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:1377
msgid ""
"I<stack> is not aligned to a suitable boundary for this architecture.  For "
"example, on aarch64, I<stack> must be a multiple of 16."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1377 build/C/man2/clone.2:1407
#: build/C/man2/clone.2:1411
#, no-wrap
msgid "B<EINVAL> (B<clone3>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1383
msgid "B<CLONE_DETACHED> was specified in the I<flags> mask."
msgstr "B<CLONE_DETACHED> が I<flags> マスクに指定された。"

#. type: TP
#: build/C/man2/clone.2:1383
#, no-wrap
msgid "B<EINVAL> (B<clone>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1391
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_DETACHED> in the I<flags> "
"mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1399
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_THREAD> in the I<flags> "
"mask."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1399
#, no-wrap
msgid "B<EINVAL >(B<clone>() only)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1407
msgid ""
"B<CLONE_PIDFD> was specified together with B<CLONE_PARENT_SETTID> in the "
"I<flags> mask."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1411
msgid "I<set_tid_size> is greater than the number of nested PID namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1416
msgid "One of the PIDs specified in I<set_tid> was an invalid."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1416
#, no-wrap
msgid "B<EINVAL> (AArch64 only, Linux 4.6 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1420
msgid "I<stack> was not aligned to a 126-bit boundary."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1420 build/C/man2/setns.2:292
#: build/C/man2/unshare.2:357
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/clone.2:1425
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be copied."
msgstr ""
"子プロセスのために確保すべきタスク構造体や、呼び出し元のコンテキストの 一部を"
"コピーするのに必要なメモリーを十分に割り当てることができない。"

#. type: TP
#: build/C/man2/clone.2:1425 build/C/man2/unshare.2:361
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr "B<ENOSPC> (Linux 3.7 以降)"

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: build/C/man2/clone.2:1435
msgid ""
"B<CLONE_NEWPID> was specified in the I<flags> mask, but the limit on the "
"nesting depth of PID namespaces would have been exceeded; see "
"B<pid_namespaces>(7)."
msgstr "B<CLONE_NEWPID> が I<flags> に指定されたが、 PID 名前空間のネストの深さの上限に達してしまう。 B<pid_namespaces>(7) を参照。"

#. type: TP
#: build/C/man2/clone.2:1435 build/C/man2/unshare.2:369
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr "B<ENOSPC> (Linux 4.9 以降; 以前は B<EUSERS>)"

#. type: Plain text
#: build/C/man2/clone.2:1444
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, and the call would "
"cause the limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr "B<CLONE_NEWUSER> が I<flags> マスクに指定されており、 この呼び出しによりネストされたユーザー名前空間数の上限を超えてしまう。 B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:1447 build/C/man2/unshare.2:381
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was B<EUSERS>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1447 build/C/man2/unshare.2:381
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr "B<ENOSPC> (Linux 4.9 以降)"

#. type: Plain text
#: build/C/man2/clone.2:1457
msgid ""
"One of the values in the I<flags> mask specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1457
#, no-wrap
msgid "B<EOPNOTSUPP> (B<clone3>() only)"
msgstr "B<EOPNOTSUPP> (B<clone3>() のみ)"

#. type: Plain text
#: build/C/man2/clone.2:1467
msgid ""
"B<CLONE_INTO_CGROUP> was specified in I<cl_args.flags>, but the file "
"descriptor specified in I<cl_args.cgroup> refers to a version 2 cgroup that "
"is in the I<domain invalid> state."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1467 build/C/man2/clone.2:1477
#: build/C/man2/clone.2:1482 build/C/man2/kcmp.2:276
#: build/C/man2/sched_setaffinity.2:140 build/C/man2/sched_setattr.2:376
#: build/C/man2/sched_setattr.2:379 build/C/man2/sched_setparam.2:109
#: build/C/man2/sched_setscheduler.2:162 build/C/man2/setns.2:295
#: build/C/man2/unshare.2:391 build/C/man2/unshare.2:394
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/clone.2:1477
msgid ""
"B<CLONE_NEWCGROUP>, B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, "
"B<CLONE_NEWPID>, or B<CLONE_NEWUTS> was specified by an unprivileged process "
"(process without B<CAP_SYS_ADMIN>)."
msgstr "非特権プロセス (B<CAP_SYS_ADMIN> を持たないプロセス) が B<CLONE_NEWCGROUP>, B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, B<CLONE_NEWUTS> を指定した。"

#. type: Plain text
#: build/C/man2/clone.2:1482
msgid ""
"B<CLONE_PID> was specified by a process other than process 0.  (This error "
"occurs only on Linux 2.5.15 and earlier.)"
msgstr "PID が 0 以外のプロセスによって B<CLONE_PID> が指定された (このエラーは Linux 2.5.15 以前でのみ発生する)。"

#. type: Plain text
#: build/C/man2/clone.2:1491
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, but either the "
"effective user ID or the effective group ID of the caller does not have a "
"mapping in the parent namespace (see B<user_namespaces>(7))."
msgstr "B<CLONE_NEWUSER> が I<flags> マスクに指定されたが、 呼び出し元の実効ユーザー ID もしくは実効グループ ID が親名前空間にマッピングがない (B<user_namespaces>(7) 参照)。"

#. type: TP
#: build/C/man2/clone.2:1491 build/C/man2/unshare.2:402
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr "B<EPERM> (Linux 3.9 以降)"

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: build/C/man2/clone.2:1501
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask and the caller is in a "
"chroot environment (i.e., the caller's root directory does not match the "
"root directory of the mount namespace in which it resides)."
msgstr "B<CLONE_NEWUSER> が I<flags> マスクに指定され、 呼び出し元が chroot された環境にいる (すなわち、呼び出し元の root ディレクトリが呼び出し元が属するマウント名前空間の root ディレクトリに一致しない)。"

#. type: TP
#: build/C/man2/clone.2:1501
#, no-wrap
msgid "B<EPERM> (B<clone3>() only)"
msgstr "B<EPERM> (B<clone3>() のみ)"

#. type: Plain text
#: build/C/man2/clone.2:1508
msgid ""
"I<set_tid_size> was greater than zero, and the caller lacks the "
"B<CAP_SYS_ADMIN> capability in one or more of the user namespaces that own "
"the corresponding PID namespaces."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1508
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr "B<ERESTARTNOINTR> (Linux 2.6.17 以降)"

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: build/C/man2/clone.2:1513
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:1513
#, no-wrap
msgid "B<EUSERS> (Linux 3.11 to Linux 4.8)"
msgstr " B<EUSERS> (Linux 3.11 to Linux 4.8)"

#. type: Plain text
#: build/C/man2/clone.2:1523
msgid ""
"B<CLONE_NEWUSER> was specified in the I<flags> mask, and the limit on the "
"number of nested user namespaces would be exceeded.  See the discussion of "
"the B<ENOSPC> error above."
msgstr "B<CLONE_NEWUSER> が I<flags> マスクに指定されており、ネストされたユーザー名前空間の数が上限を超えてしまう。上記の B<ENOSPC> エラーの議論を参照。"

#.  There is no entry for
#.  .BR clone ()
#.  in libc5.
#.  glibc2 provides
#.  .BR clone ()
#.  as described in this manual page.
#. type: Plain text
#: build/C/man2/clone.2:1533
msgid "The B<clone3>()  system call first appeared in Linux 5.3."
msgstr "B<clone3>() システムコールは Linux 5.3 で初めて登場した。"

#. type: Plain text
#: build/C/man2/clone.2:1537
msgid ""
"These system calls are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr "これらのシステムコールは Linux 特有であり、移植を考慮したプログラムでは使用すべき ではない。"

#. type: Plain text
#: build/C/man2/clone.2:1541
msgid ""
"One use of these systems calls is to implement threads: multiple flows of "
"control in a program that run concurrently in a shared address space."
msgstr "これらのシステムコールの使用法のひとつは、スレッドを実装することである。スレッドは、一つのプログラムの中で共有されたアドレス空間で同時並行で実行される複数の制御フローである。"

#. type: Plain text
#: build/C/man2/clone.2:1546
msgid ""
"Glibc does not provide a wrapper for B<clone3>(); call it using "
"B<syscall>(2)."
msgstr "glibc は B<clone3>() に対するラッパー関数を提供していない。 B<syscall>(2) を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/clone.2:1562
msgid ""
"Note that the glibc B<clone>()  wrapper function makes some changes in the "
"memory pointed to by I<stack> (changes required to set the stack up "
"correctly for the child)  I<before> invoking the B<clone>()  system call.  "
"So, in cases where B<clone>()  is used to recursively create children, do "
"not use the buffer employed for the parent's stack as the stack of the child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1568
msgid ""
"The B<kcmp>(2)  system call can be used to test whether two processes share "
"various resources such as a file descriptor table, System V semaphore undo "
"operations, or a virtual address space."
msgstr "システムコール B<kcmp>() を使うと、 2つのプロセスが、 ファイルディスクリプター、 System V セマフォーの undo 操作、仮想アドレス空間などの様々なリソースを共有しているかを検査できる。"

#. type: Plain text
#: build/C/man2/clone.2:1572
msgid ""
"Handlers registered using B<pthread_atfork>(3)  are not executed during a "
"clone call."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1582
msgid ""
"In the Linux 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in Linux 2.6.0 and later)."
msgstr "Linux 2.4.x 系列では、一般的には B<CLONE_THREAD> フラグを指定しても新しいスレッドの親を 呼び出し元プロセスの親と同じにはしない。 しかし、バージョン 2.4.7〜2.4.18 のカーネルでは、 (カーネル 2.6 以降と同じように) CLONE_THREAD フラグを指定すると、 暗黙のうちに CLONE_PARENT フラグを指定したことになる。"

#. type: Plain text
#: build/C/man2/clone.2:1588
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""
"i386 上では、 B<clone>()  は vsyscall 経由ではなく、直接 I<int $0x80> 経由で"
"呼び出すべきである。"

#. type: SS
#: build/C/man2/clone.2:1588 build/C/man2/sched_setaffinity.2:236
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/clone.2:1602
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted."
msgstr "素の B<clone> システムコールは、より B<fork>(2) に近いかたちになっており、 子プロセスの実行が呼び出しが行われた場所から続けられる。 そのため、 B<clone>() ラッパー関数の引数 I<fn> と I<arg> は省略される。"

#. type: Plain text
#: build/C/man2/clone.2:1624
#, fuzzy
#| msgid ""
#| "Another difference for the raw system call is that the I<child_stack> "
#| "argument may be zero, in which case copy-on-write semantics ensure that "
#| "the child gets separate copies of stack pages when either process "
#| "modifies the stack.  In this case, for correct operation, the B<CLONE_VM> "
#| "option should not be specified."
msgid ""
"In contrast to the glibc wrapper, the raw B<clone>()  system call accepts "
"NULL as a I<stack> argument (and B<clone3>()  likewise allows I<cl_args."
"stack> to be NULL).  In this case, the child uses a duplicate of the "
"parent's stack.  (Copy-on-write semantics ensure that the child gets "
"separate copies of stack pages when either process modifies the stack.)  In "
"this case, for correct operation, the B<CLONE_VM> option should not be "
"specified.  (If the child I<shares> the parent's memory because of the use "
"of the B<CLONE_VM> flag, then no copy-on-write duplication occurs and chaos "
"is likely to result.)"
msgstr ""
"生のシステムコールのもう一つの違いは、 I<child_stack> 引数がゼロでも良いこ"
"とである。この場合には、どちらかのプロセスが スタックを変更した時に、書き込み"
"時コピー (copy-on-write) 方式により 子プロセスがスタックページの独立したコ"
"ピーを得られることが保証される。 この場合、正常に動作させるためには、 "
"B<CLONE_VM> オプションを指定してはならない。"

#. type: Plain text
#: build/C/man2/clone.2:1628
msgid ""
"The order of the arguments also differs in the raw system call, and there "
"are variations in the arguments across architectures, as detailed in the "
"following paragraphs."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1631
msgid ""
"The raw system call interface on x86-64 and some other architectures "
"(including sh, tile, and alpha) is:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1637
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""
" B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"

#.  CONFIG_CLONE_BACKWARDS
#. type: Plain text
#: build/C/man2/clone.2:1645
msgid ""
"On x86-32, and several other common architectures (including score, ARM, ARM "
"64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order of the last two "
"arguments is reversed:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1651
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<          int *>I<parent_tid>B<, unsigned long >I<tls>B<,>\n"
"B<          int *>I<child_tid>B<);>\n"
msgstr ""
" B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<          int *>I<parent_tid>B<, unsigned long >I<tls>B<,>\n"
"B<          int *>I<child_tid>B<);>\n"

#.  CONFIG_CLONE_BACKWARDS2
#. type: Plain text
#: build/C/man2/clone.2:1657
msgid ""
"On the cris and s390 architectures, the order of the first two arguments is "
"reversed:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1663
#, no-wrap
msgid ""
"B<long clone(void *>I<stack>B<, unsigned long >I<flags>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""
" B<long clone(void *>I<stack>B<, unsigned long >I<flags>B<,>\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"

#.  CONFIG_CLONE_BACKWARDS3
#. type: Plain text
#: build/C/man2/clone.2:1669
msgid "On the microblaze architecture, an additional argument is supplied:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1676
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int >I<stack_size>B<,>         /* Size of stack */\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"
msgstr ""
" B<long clone(unsigned long >I<flags>B<, void *>I<stack>B<,>\n"
"B<           int >I<stack_size>B<,>         /* Size of stack */\n"
"B<           int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<           unsigned long >I<tls>B<);>\n"

#. type: SS
#: build/C/man2/clone.2:1679
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr "blackfin, m68k, sparc"

#.  Mike Frysinger noted in a 2013 mail:
#.      these arches don't define __ARCH_WANT_SYS_CLONE:
#.      blackfin ia64 m68k sparc
#. type: Plain text
#: build/C/man2/clone.2:1686
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from the descriptions above.  For details, see the kernel (and glibc) source."
msgstr ""
"blackfin, m68k, sparc では引数渡しの規約が上記の説明とは異なる。 詳細は、"
"カーネル (と glibc) のソースを参照のこと。"

#. type: SS
#: build/C/man2/clone.2:1686
#, no-wrap
msgid "ia64"
msgstr "ia64"

#. type: Plain text
#: build/C/man2/clone.2:1688
msgid "On ia64, a different interface is used:"
msgstr "ia64 では、別のインターフェースが使用される:"

#. type: Plain text
#: build/C/man2/clone.2:1696
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *),>\n"
"B<             void *>I<stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, struct user_desc *>I<tls>B<,>\n"
"B<             pid_t *>I<child_tid>B< */ );>\n"
msgstr ""
" B<int __clone2(int (*>I<fn>B<)(void *),>\n"
"B<             void *>I<stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ...>\n"
"B<          /* pid_t *>I<parent_tid>B<, struct user_desc *>I<tls>B<,>\n"
"B<             pid_t *>I<child_tid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:1704
msgid ""
"The prototype shown above is for the glibc wrapper function; for the system "
"call itself, the prototype can be described as follows (it is identical to "
"the B<clone>()  prototype on microblaze):"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1711
#, no-wrap
msgid ""
"B<long clone2(unsigned long >I<flags>B<, void *>I<stack_base>B<,>\n"
"B<            int >I<stack_size>B<,>         /* Size of stack */\n"
"B<            int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<            unsigned long >I<tls>B<);>\n"
msgstr ""
" B<long clone2(unsigned long >I<flags>B<, void *>I<stack_base>B<,>\n"
"B<            int >I<stack_size>B<,>         /* Size of stack */\n"
"B<            int *>I<parent_tid>B<, int *>I<child_tid>B<,>\n"
"B<            unsigned long >I<tls>B<);>\n"

#. type: Plain text
#: build/C/man2/clone.2:1724
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<stack_base> points to the lowest address of the child's stack area, and "
"I<stack_size> specifies the size of the stack pointed to by I<stack_base>."
msgstr "B<__clone2>() は B<clone>() と同じように動作するが、以下の点が異なる: I<stack_base> は子プロセスのスタックエリアの最小のアドレスを指し、 I<stack_size> は I<stack_base> が指し示すスタックエリアの大きさを示す。"

#. type: SS
#: build/C/man2/clone.2:1724
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr "Linux 2.4 以前"

#. type: Plain text
#: build/C/man2/clone.2:1732
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<parent_tid>, "
"I<tls>, and I<child_tid>."
msgstr "Linux 2.4 以前では、 B<clone>()  は引数 I<parent_tid>, I<tls>, I<child_tid> を取らない。"

#. type: Plain text
#: build/C/man2/clone.2:1763
#, fuzzy
#| msgid ""
#| "Versions of the GNU C library that include the NPTL threading library "
#| "contain a wrapper function for B<getpid>(2)  that performs caching of "
#| "PIDs.  This caching relies on support in the glibc wrapper for "
#| "B<clone>(), but as currently implemented, the cache may not be up to date "
#| "in some circumstances.  In particular, if a signal is delivered to the "
#| "child immediately after the B<clone>()  call, then a call to "
#| "B<getpid>(2)  in a handler for the signal may return the PID of the "
#| "calling process (\"the parent\"), if the clone wrapper has not yet had a "
#| "chance to update the PID cache in the child.  (This discussion ignores "
#| "the case where the child was created using B<CLONE_THREAD>, when "
#| "B<getpid>(2)  I<should> return the same value in the child and in the "
#| "process that called B<clone>(), since the caller and the child are in the "
#| "same thread group.  The stale-cache problem also does not occur if the "
#| "I<flags> argument includes B<CLONE_VM>.)  To get the truth, it may be "
#| "necessary to use code such as the following:"
msgid ""
"GNU C library versions 2.3.4 up to and including 2.24 contained a wrapper "
"function for B<getpid>(2)  that performed caching of PIDs.  This caching "
"relied on support in the glibc wrapper for B<clone>(), but limitations in "
"the implementation meant that the cache was not up to date in some "
"circumstances.  In particular, if a signal was delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal could return the PID of the calling process (\"the "
"parent\"), if the clone wrapper had not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it was sometimes necessary to use code such as the following:"
msgstr ""
"NPTL スレッドライブラリを含んでいる GNU C ライブラリのいくつかのバージョン に"
"は、 B<getpid>(2)  のラッパー関数が含まれており、このラッパー関数は PID を"
"キャッシュする。 このキャッシュ処理が正しく動作するためには glibc の "
"B<clone>()  のラッパー関数での助けが必要だが、現状の実装では、 ある状況下にお"
"いてキャッシュが最新とならない可能性がある。 特に、 B<clone>()  の呼び出し直"
"後にシグナルが子プロセスに配送された場合に、 そのシグナルに対するハンドラー内"
"で B<getpid>(2)  を呼び出すと、それまでに clone のラッパー関数が子プロセスの "
"PID キャッシュを 更新する機会が得られていなければ、呼び出し元プロセス (\"親プ"
"ロセス\") の PID が 返される可能性がある。 (この議論では、子プロセスが "
"B<CLONE_THREAD> を使って作成された場合のことは無視している。 子プロセスが "
"B<CLONE_THREAD> を作って作成された場合には、 呼び出し元と子プロセスは同じス"
"レッドグループに属すので、 B<getpid>(2)  は子プロセスと B<clone>()  を呼び出"
"したプロセスで同じ値を返すのが「正しい」。 キャッシュが最新とならない問題 "
"(stale-cache problem) は、 I<flags> に B<CLONE_VM> が含まれている場合にも発生"
"しない。)  本当の値を得るためには、次のようなコードを使う必要があるかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/clone.2:1767
#, no-wrap
msgid "#include E<lt>syscall.hE<gt>\n"
msgstr " #include E<lt>syscall.hE<gt>\n"

#. type: Plain text
#: build/C/man2/clone.2:1769
#, no-wrap
msgid "pid_t mypid;\n"
msgstr " pid_t mypid;\n"

#. type: Plain text
#: build/C/man2/clone.2:1771
#, no-wrap
msgid "mypid = syscall(SYS_getpid);\n"
msgstr " mypid = syscall(SYS_getpid);\n"

#. type: Plain text
#: build/C/man2/clone.2:1780
msgid ""
"Because of the stale-cache problem, as well as other problems noted in "
"B<getpid>(2), the PID caching feature was removed in glibc 2.25."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1790
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""
"以下のプログラムは、 別の UTS 名前空間で動作する子プロセスを B<clone>() を"
"使って作成する例である。 子プロセスは、自分の UTS 名前空間においてホスト名を"
"変更する。 それから、親プロセスと子プロセスの両方でシステムのホスト名を表示"
"し、 親プロセスと子プロセスの UTS 名前空間でホスト名が異なることを確認する。 "
"このプログラムの使用方法については B<setns>(2) を参照。"

#. type: Plain text
#: build/C/man2/clone.2:1797
msgid ""
"Within the sample program, we allocate the memory that is to be used for the "
"child's stack using B<mmap>(2)  rather than B<malloc>(3)  for the following "
"reasons:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1805
msgid ""
"B<mmap>(2)  allocates a block of memory that starts on a page boundary and "
"is a multiple of the page size.  This is useful if we want to establish a "
"guard page (a page with protection B<PROT_NONE>)  at the end of the stack "
"using B<mprotect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1812
msgid ""
"We can specify the B<MAP_STACK> flag to request a mapping that is suitable "
"for a stack.  For the moment, this flag is a no-op on Linux, but it exists "
"and has effect on some other systems, so we should include it for "
"portability."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1812 build/C/man2/kcmp.2:348
#: build/C/man2/sched_setaffinity.2:355 build/C/man2/setns.2:378
#: build/C/man2/unshare.2:486
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/clone.2:1824
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""
" #define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: build/C/man2/clone.2:1827 build/C/man2/kcmp.2:364
#: build/C/man2/sched_setaffinity.2:367 build/C/man2/setns.2:389
#: build/C/man2/unshare.2:505
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/clone.2:1832
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""
"static int              /* clone された子プロセスの開始関数 */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"

#. type: Plain text
#: build/C/man2/clone.2:1834
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr "    /* 子プロセスの UTS 名前空間でホスト名を変更する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1837
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"

#. type: Plain text
#: build/C/man2/clone.2:1839
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr "    /* ホスト名を取得し表示する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1843
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"

#. type: Plain text
#: build/C/man2/clone.2:1847
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""
"    /* sleep を使ってしばらく名前空間をオープンされたままにする。\n"
"       これにより実験を行うことができる -- 例えば、\n"
"       別のプロセスがこの名前空間に参加するなど。 */\n"

#. type: Plain text
#: build/C/man2/clone.2:1849
#, no-wrap
msgid "    sleep(200);\n"
msgstr "    sleep(200);\n"

#. type: Plain text
#: build/C/man2/clone.2:1852
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""
"    return 0;           /* 子プロセスを終了する */\n"
"}\n"

#. type: Plain text
#: build/C/man2/clone.2:1854
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr "#define STACK_SIZE (1024 * 1024)    /* clone される子プロセスのスタックサイズ */\n"

#. type: Plain text
#: build/C/man2/clone.2:1862
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* スタックバッファーの先頭 */\n"
"    char *stackTop;                 /* スタックバッファーの末尾 */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"

#. type: Plain text
#: build/C/man2/clone.2:1867
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/clone.2:1869
#, fuzzy, no-wrap
#| msgid "    /* Allocate stack for child */\n"
msgid "    /* Allocate memory to be used for the stack of the child */\n"
msgstr "    /* 子プロセス用のスタックを割り当てる */\n"

#. type: Plain text
#: build/C/man2/clone.2:1874
#, no-wrap
msgid ""
"    stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,\n"
"                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n"
"    if (stack == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,\n"
"                 MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);\n"
"    if (stack == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: build/C/man2/clone.2:1876
#, no-wrap
msgid "    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr "    stackTop = stack + STACK_SIZE;  /* スタックは下方向に伸びるものとする */\n"

#. type: Plain text
#: build/C/man2/clone.2:1879
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""
"    /* 自分専用の UTS 名前空間を持つ子プロセスを作成する;\n"
"       子プロセスは childFunc() の実行を開始する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1884
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %jd\\en\", (intmax_t) pid);\n"
msgstr ""
"     pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %jd\\en\", (intmax_t) pid);\n"

#. type: Plain text
#: build/C/man2/clone.2:1886
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr "    /* 親プロセスの実行はここに来る */\n"

#. type: Plain text
#: build/C/man2/clone.2:1888
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr "    sleep(1);           /* 子プロセスがホスト名を変更する時間を与える */\n"

#. type: Plain text
#: build/C/man2/clone.2:1891
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""
"    /* 親プロセスの UTS 名前空間でのホスト名を表示する;\n"
"       これは子プロセスの UTS 名前空間でのホスト名とは異なる */\n"

#. type: Plain text
#: build/C/man2/clone.2:1895
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"

#. type: Plain text
#: build/C/man2/clone.2:1899
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""
"    if (waitpid(pid, NULL, 0) == -1)    /* 子プロセスを待つ */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"

#. type: Plain text
#: build/C/man2/clone.2:1902 build/C/man2/kcmp.2:428
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/clone.2:1920
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), B<mmap>(2), "
"B<pidfd_open>(2), B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), "
"B<tkill>(2), B<unshare>(2), B<wait>(2), B<capabilities>(7), "
"B<namespaces>(7), B<pthreads>(7)"
msgstr " B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), B<mmap>(2), B<pidfd_open>(2), B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), B<capabilities>(7), B<namespaces>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man2/kcmp.2:28
#, no-wrap
msgid "KCMP"
msgstr "KCMP"

#. type: Plain text
#: build/C/man2/kcmp.2:31
msgid ""
"kcmp - compare two processes to determine if they share a kernel resource"
msgstr "kcmp - 二つのプロセスが同じカーネルリソースを共有しているかを比較する"

#. type: Plain text
#: build/C/man2/kcmp.2:34
#, no-wrap
msgid "B<#include E<lt>linux/kcmp.hE<gt>>\n"
msgstr "B<#include E<lt>linux/kcmp.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/kcmp.2:37
#, no-wrap
msgid ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"
msgstr ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"

#. type: Plain text
#: build/C/man2/kcmp.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/kcmp.2:50
msgid ""
"The B<kcmp>()  system call can be used to check whether the two processes "
"identified by I<pid1> and I<pid2> share a kernel resource such as virtual "
"memory, file descriptors, and so on."
msgstr ""
"システムコール B<kcmp>() を使うと、 ID が I<pid1> と I<pid2> の二つのプロセス"
"が、 仮想メモリーやファイルディスクリプターなどの、 同じカーネルリソースを共"
"有しているかどうかを検査できる。"

#. type: Plain text
#: build/C/man2/kcmp.2:61
msgid ""
"Permission to employ B<kcmp>()  is governed by ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> checks against both I<pid1> and I<pid2>; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:66
msgid ""
"The I<type> argument specifies which resource is to be compared in the two "
"processes.  It has one of the following values:"
msgstr ""
"I<type> 引数は 2 つのプロセス間でどのリソースを比較するかを指定する。 以下"
"のいずれかの値を指定する。"

#. type: TP
#: build/C/man2/kcmp.2:66
#, no-wrap
msgid "B<KCMP_FILE>"
msgstr "B<KCMP_FILE>"

#. type: Plain text
#: build/C/man2/kcmp.2:85
#, fuzzy
#| msgid ""
#| "Check whether a file descriptor I<idx1> in the process I<pid1> refers to "
#| "the same open file description (see B<open>(2))  as file descriptor "
#| "I<idx2> in the process I<pid2>."
msgid ""
"Check whether a file descriptor I<idx1> in the process I<pid1> refers to the "
"same open file description (see B<open>(2))  as file descriptor I<idx2> in "
"the process I<pid2>.  The existence of two file descriptors that refer to "
"the same open file description can occur as a result of B<dup>(2)  (and "
"similar)  B<fork>(2), or passing file descriptors via a domain socket (see "
"B<unix>(7))."
msgstr ""
"プロセス I<pid1> のファイルディスクリプター I<idx1> が、 プロセス I<pid2> の"
"ファイルディスクリプター I<idx2> と同じオープンファイル記述 (open file "
"description) を参照しているかを検査する。"

#. type: TP
#: build/C/man2/kcmp.2:85
#, no-wrap
msgid "B<KCMP_FILES>"
msgstr "B<KCMP_FILES>"

#. type: Plain text
#: build/C/man2/kcmp.2:97
#, fuzzy
#| msgid ""
#| "Check whether the process share the same set of open file descriptors.  "
#| "The arguments I<idx1> and I<idx2> are ignored."
msgid ""
"Check whether the processes share the same set of open file descriptors.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FILES> flag in B<clone>(2)."
msgstr ""
"二つのプロセスが同じオープンファイル記述の集合を共有しているかを検査する。 引"
"き数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:97
#, no-wrap
msgid "B<KCMP_FS>"
msgstr "B<KCMP_FS>"

#. type: Plain text
#: build/C/man2/kcmp.2:110
#, fuzzy
#| msgid ""
#| "Check whether the processes share the same filesystem information (i.e., "
#| "file mode creation mask, working directory, and filesystem root).  The "
#| "arguments I<idx1> and I<idx2> are ignored."
msgid ""
"Check whether the processes share the same filesystem information (i.e., "
"file mode creation mask, working directory, and filesystem root).  The "
"arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FS> flag in B<clone>(2)."
msgstr ""
"二つのプロセスが同じファイルシステム情報 (すなわち、ファイルのモード作成マス"
"ク、作業ディレクトリ、ファイルシステムのルート) を共有しているかを検査する。 "
"引数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:110
#, no-wrap
msgid "B<KCMP_IO>"
msgstr "B<KCMP_IO>"

#. type: Plain text
#: build/C/man2/kcmp.2:122
#, fuzzy
#| msgid ""
#| "Check whether the processes share I/O context.  The arguments I<idx1> and "
#| "I<idx2> are ignored."
msgid ""
"Check whether the processes share I/O context.  The arguments I<idx1> and "
"I<idx2> are ignored.  See the discussion of the B<CLONE_IO> flag in "
"B<clone>(2)."
msgstr ""
"二つのプロセスが I/O コンテキストを共有しているかを検査する。 引数 I<idx1> "
"と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:122
#, no-wrap
msgid "B<KCMP_SIGHAND>"
msgstr "B<KCMP_SIGHAND>"

#. type: Plain text
#: build/C/man2/kcmp.2:134
#, fuzzy
#| msgid ""
#| "Check whether the processes share the same table of signal dispositions.  "
#| "The arguments I<idx1> and I<idx2> are ignored."
msgid ""
"Check whether the processes share the same table of signal dispositions.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_SIGHAND> flag in B<clone>(2)."
msgstr ""
"二つのプロセスがシグナル配送 (disposition) テーブルを共有しているかを検査す"
"る。 引数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:134
#, no-wrap
msgid "B<KCMP_SYSVSEM>"
msgstr "B<KCMP_SYSVSEM>"

#. type: Plain text
#: build/C/man2/kcmp.2:147
#, fuzzy
#| msgid ""
#| "Check whether the processes share the same list of System\\ V semaphore "
#| "undo operations.  The arguments I<idx1> and I<idx2> are ignored."
msgid ""
"Check whether the processes share the same list of System\\ V semaphore undo "
"operations.  The arguments I<idx1> and I<idx2> are ignored.  See the "
"discussion of the B<CLONE_SYSVSEM> flag in B<clone>(2)."
msgstr ""
"二つのプロセスが同じ System\\ V セマフォ undo 操作のリストを共有しているかを"
"検査する。 引数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:147
#, no-wrap
msgid "B<KCMP_VM>"
msgstr "B<KCMP_VM>"

#. type: Plain text
#: build/C/man2/kcmp.2:159
#, fuzzy
#| msgid ""
#| "Check whether the processes share the same address space.  The arguments "
#| "I<idx1> and I<idx2> are ignored."
msgid ""
"Check whether the processes share the same address space.  The arguments "
"I<idx1> and I<idx2> are ignored.  See the discussion of the B<CLONE_VM> flag "
"in B<clone>(2)."
msgstr ""
"二つのプロセスが同じアドレス空間を共有しているかを検査する。 引数 I<idx1> "
"と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:159
#, no-wrap
msgid "B<KCMP_EPOLL_TFD> (since Linux 4.13)"
msgstr "B<KCMP_EPOLL_TFD> (Linux 4.13 以降)"

#.  commit 0791e3644e5ef21646fe565b9061788d05ec71d4
#. type: Plain text
#: build/C/man2/kcmp.2:176
msgid ""
"Check whether the file descriptor I<idx1> of the process I<pid1> is present "
"in the B<epoll>(7)  instance described by I<idx2> of the process I<pid2>.  "
"The argument I<idx2> is a pointer to a structure where the target file is "
"described.  This structure has the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:184
#, no-wrap
msgid ""
"struct kcmp_epoll_slot {\n"
"    __u32 efd;\n"
"    __u32 tfd;\n"
"    __u64 toff;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:198
msgid ""
"Within this structure, I<efd> is an epoll file descriptor returned from "
"B<epoll_create>(2), I<tfd> is a target file descriptor number, and I<toff> "
"is a target file offset counted from zero.  Several different targets may be "
"registered with the same file descriptor number and setting a specific "
"offset helps to investigate each of them."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:208
msgid ""
"Note the B<kcmp>()  is not protected against false positives which may occur "
"if the processes are currently running.  One should stop the processes by "
"sending B<SIGSTOP> (see B<signal>(7))  prior to inspection with this system "
"call to obtain meaningful results."
msgstr "B<kcmp>() には、プロセスが現在実行されている場合に起こり得る誤判定 (false positive) に関する保護はない。 ということは、 意味のある結果を得るためには、 このシステムコールで検査を行う前に、 B<SIGSTOP> を送信してプロセスを停止すべきだということだ (B<signal>(7) 参照)。"

#. type: Plain text
#: build/C/man2/kcmp.2:214
msgid ""
"The return value of a successful call to B<kcmp>()  is simply the result of "
"arithmetic comparison of kernel pointers (when the kernel compares "
"resources, it uses their memory addresses)."
msgstr ""
"B<kcmp>() の呼び出しが成功した場合の返り値は、単にカーネルポインターを数値で"
"比較した結果となる (カーネルはリソースを比較する際、リソースのメモリーアドレ"
"スを使用する)。"

#. type: Plain text
#: build/C/man2/kcmp.2:222
msgid ""
"The easiest way to explain is to consider an example.  Suppose that I<v1> "
"and I<v2> are the addresses of appropriate resources, then the return value "
"is one of the following:"
msgstr ""
"これを説明するには、例を見るのが一番簡単である。 I<v1> と I<v2> を適切なリ"
"ソースのアドレスとすると、 返り値は以下のいずれか一つとなる。"

#. type: Plain text
#: build/C/man2/kcmp.2:228
msgid ""
"I<v1> is equal to I<v2>; in other words, the two processes share the "
"resource."
msgstr ""
"I<v1> は I<v2> と等しい。言い換えれば、二つのプロセスはそのリソースを共有して"
"いる。"

#. type: Plain text
#: build/C/man2/kcmp.2:232
msgid "I<v1> is less than I<v2>."
msgstr "I<v1> は I<v2> より小さい。"

#. type: Plain text
#: build/C/man2/kcmp.2:236
msgid "I<v1> is greater than I<v2>."
msgstr "I<v1> は I<v2> より大きい。"

#. type: IP
#: build/C/man2/kcmp.2:236
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: build/C/man2/kcmp.2:241
msgid "I<v1> is not equal to I<v2>, but ordering information is unavailable."
msgstr "I<v1> は I<v2> と等しくないが、順序情報がない。"

#. type: Plain text
#: build/C/man2/kcmp.2:246
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/kcmp.2:251
msgid ""
"B<kcmp>()  was designed to return values suitable for sorting.  This is "
"particularly handy if one needs to compare a large number of file "
"descriptors."
msgstr ""
"B<kcmp>() は、ソートに適した値を返すように設計された。 大量のファイルディスク"
"リプターを比較する必要がある場合に、特に役に立つ。"

#. type: TP
#: build/C/man2/kcmp.2:252 build/C/man2/setns.2:253
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/kcmp.2:262
msgid ""
"I<type> is B<KCMP_FILE> and I<fd1> or I<fd2> is not an open file descriptor."
msgstr ""
"I<type> が B<KCMP_FILE> で、かつ I<fd1> か I<fd2> がオープンファイル記述でな"
"い。"

#. type: TP
#: build/C/man2/kcmp.2:262 build/C/man2/sched_rr_get_interval.2:81
#: build/C/man2/sched_setaffinity.2:120
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/kcmp.2:267
msgid ""
"The epoll slot addressed by I<idx2> is outside of the user's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:271
msgid "I<type> is invalid."
msgstr "I<type> が無効である。"

#. type: TP
#: build/C/man2/kcmp.2:271
#, no-wrap
msgid "B<ENOENT>"
msgstr " B<ENOENT>"

#. type: Plain text
#: build/C/man2/kcmp.2:276
msgid "The target file is not present in B<epoll>(7)  instance."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:291
#, fuzzy
#| msgid ""
#| "Insufficient permission to inspect process resources.  The "
#| "B<CAP_SYS_PTRACE> capability is required to inspect processes that you do "
#| "not own."
msgid ""
"Insufficient permission to inspect process resources.  The B<CAP_SYS_PTRACE> "
"capability is required to inspect processes that you do not own.  Other "
"ptrace limitations may also apply, such as B<CONFIG_SECURITY_YAMA>, which, "
"when I</proc/sys/kernel/yama/ptrace_scope> is 2, limits B<kcmp>()  to child "
"processes; see B<ptrace>(2)."
msgstr ""
"プロセスのリソースを検査するのに十分な許可がない。 自分が所有していないプロセ"
"スを検査するためには B<CAP_SYS_PTRACE> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/kcmp.2:291 build/C/man2/sched_rr_get_interval.2:90
#: build/C/man2/sched_setaffinity.2:151 build/C/man2/sched_setattr.2:321
#: build/C/man2/sched_setparam.2:116 build/C/man2/sched_setscheduler.2:165
#: build/C/man2/setns.2:299
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/kcmp.2:298
msgid "Process I<pid1> or I<pid2> does not exist."
msgstr "プロセス I<pid1> か I<pid2> が存在しない。"

#. type: Plain text
#: build/C/man2/kcmp.2:302
msgid "The B<kcmp>()  system call first appeared in Linux 3.5."
msgstr "B<kcmp>() システムコールは Linux 3.5 で初めて登場した。"

#. type: Plain text
#: build/C/man2/kcmp.2:305
msgid ""
"B<kcmp>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""
"B<kcmp>() は Linux 特有であり、 移植を考慮したプログラムでは使用すべきではな"
"い。"

#. type: Plain text
#: build/C/man2/kcmp.2:308
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2) を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/kcmp.2:317
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>.  The main use of the system call is for the "
"checkpoint/restore in user space (CRIU) feature.  The alternative to this "
"system call would have been to expose suitable process information via the "
"B<proc>(5)  filesystem; this was deemed to be unsuitable for security "
"reasons."
msgstr ""
"このシステムコールが利用できるのは、 カーネルの B<CONFIG_CHECKPOINT_RESTORE> "
"オプションが有効になっている場合だけである。 このシステムコールの主な用途"
"は、 ユーザー空間でのチェックポイント/リストア (checkpoint/restore in user "
"space; CRIU) 機能である。 このシステムコールを使わないとすると、 B<proc>(5) "
"ファイルシステム経由で必要なプロセス情報を公開することになるが、 これはセキュ"
"リティ上の理由から不適切とみなされた。"

#. type: Plain text
#: build/C/man2/kcmp.2:322
msgid ""
"See B<clone>(2)  for some background information on the shared resources "
"referred to on this page."
msgstr ""
"このページで参照されている共有リソースに関する背景についての情報は "
"B<clone>(2) を参照のこと。"

#. type: Plain text
#: build/C/man2/kcmp.2:330
msgid ""
"The program below uses B<kcmp>()  to test whether pairs of file descriptors "
"refer to the same open file description.  The program tests different cases "
"for the file descriptor pairs, as described in the program output.  An "
"example run of the program is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:336
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Parent PID is 1144\n"
"Parent opened file on FD 3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:346
#, no-wrap
msgid ""
"PID of child of fork() is 1145\n"
"\tCompare duplicate FDs from different processes:\n"
"\t\tkcmp(1145, 1144, KCMP_FILE, 3, 3) ==E<gt> same\n"
"Child opened file on FD 4\n"
"\tCompare FDs from distinct open()s in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 4) ==E<gt> different\n"
"Child duplicated FD 3 to create FD 5\n"
"\tCompare duplicated FDs in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 5) ==E<gt> same\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:361
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/kcmp.hE<gt>\n"
msgstr ""
" #define _GNU_SOURCE\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/kcmp.hE<gt>\n"

#. type: Plain text
#: build/C/man2/kcmp.2:371
#, no-wrap
msgid ""
"static int\n"
"kcmp(pid_t pid1, pid_t pid2, int type,\n"
"     unsigned long idx1, unsigned long idx2)\n"
"{\n"
"    return syscall(SYS_kcmp, pid1, pid2, type, idx1, idx2);\n"
"}\n"
msgstr ""
" static int\n"
"kcmp(pid_t pid1, pid_t pid2, int type,\n"
"     unsigned long idx1, unsigned long idx2)\n"
"{\n"
"    return syscall(SYS_kcmp, pid1, pid2, type, idx1, idx2);\n"
"}\n"

#. type: Plain text
#: build/C/man2/kcmp.2:381
#, no-wrap
msgid ""
"static void\n"
"test_kcmp(char *msg, pid_t pid1, pid_t pid2, int fd_a, int fd_b)\n"
"{\n"
"    printf(\"\\et%s\\en\", msg);\n"
"    printf(\"\\et\\etkcmp(%jd, %jd, KCMP_FILE, %d, %d) ==E<gt> %s\\en\",\n"
"            (intmax_t) pid1, (intmax_t) pid2, fd_a, fd_b,\n"
"            (kcmp(pid1, pid2, KCMP_FILE, fd_a, fd_b) == 0) ?\n"
"                        \"same\" : \"different\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:387
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd1, fd2, fd3;\n"
"    char pathname[] = \"/tmp/kcmp.test\";\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd1, fd2, fd3;\n"
"    char pathname[] = \"/tmp/kcmp.test\";\n"

#. type: Plain text
#: build/C/man2/kcmp.2:391
#, no-wrap
msgid ""
"    fd1 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"    if (fd1 == -1)\n"
"        errExit(\"open\");\n"
msgstr ""
"     fd1 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"    if (fd1 == -1)\n"
"        errExit(\"open\");\n"

#. type: Plain text
#: build/C/man2/kcmp.2:394
#, no-wrap
msgid ""
"    printf(\"Parent PID is %jd\\en\", (intmax_t) getpid());\n"
"    printf(\"Parent opened file on FD %d\\en\\en\", fd1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:398
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:\n"
"        errExit(\"fork\");\n"
msgstr ""
"     switch (fork()) {\n"
"    case -1:\n"
"        errExit(\"fork\");\n"

#. type: Plain text
#: build/C/man2/kcmp.2:401
#, no-wrap
msgid ""
"    case 0:\n"
"        printf(\"PID of child of fork() is %jd\\en\", (intmax_t) getpid());\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:404
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicate FDs from different processes:\",\n"
"                getpid(), getppid(), fd1, fd1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:409
#, no-wrap
msgid ""
"        fd2 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"        if (fd2 == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"Child opened file on FD %d\\en\", fd2);\n"
msgstr ""
"         fd2 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"        if (fd2 == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"Child opened file on FD %d\\en\", fd2);\n"

#. type: Plain text
#: build/C/man2/kcmp.2:412
#, no-wrap
msgid ""
"        test_kcmp(\"Compare FDs from distinct open()s in same process:\",\n"
"                getpid(), getpid(), fd1, fd2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:417
#, no-wrap
msgid ""
"        fd3 = dup(fd1);\n"
"        if (fd3 == -1)\n"
"            errExit(\"dup\");\n"
"        printf(\"Child duplicated FD %d to create FD %d\\en\", fd1, fd3);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:421
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicated FDs in same process:\",\n"
"                getpid(), getpid(), fd1, fd3);\n"
"        break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:425
#, no-wrap
msgid ""
"    default:\n"
"        wait(NULL);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:432
msgid "B<clone>(2), B<unshare>(2)"
msgstr "B<clone>(2), B<unshare>(2)"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr "SCHED_GET_PRIORITY_MAX"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26
#: build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setscheduler.2:26
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "2017-09-15"
msgstr " 2017-09-15"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:32
msgid ""
"sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""
"sched_get_priority_max, sched_get_priority_min - 静的プライオリティの範囲を取"
"得する"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:34
#: build/C/man2/sched_rr_get_interval.2:34 build/C/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr "B<#include E<lt>sched.hE<gt>>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_max(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_min(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:59
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, B<SCHED_IDLE>, and B<SCHED_DEADLINE>.  Further details about "
"these policies can be found in B<sched>(7)."
msgstr ""
"B<sched_get_priority_max>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最大値を返す。 "
"B<sched_get_priority_min>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最小値を返す。 サポートされる "
"I<policy> の値は B<SCHED_FIFO>、 B<SCHED_RR>、 B<SCHED_OTHER>、 "
"B<SCHED_BATCH>, B<SCHED_IDLE>, B<SCHED_DEADLINE> である。これらのスケジューリ"
"ング方針に関する詳細は B<sched>(7)  に書かれている。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:68
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""
"数値的に大きなプライオリティ値を持つプロセスは小さな プライオリティ値を持つプ"
"ロセスより前にスケジュールされる。 このため B<sched_get_priority_max>()  が返"
"す値は B<sched_get_priority_min>()  が返す値よりも大きい。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:76
msgid ""
"Linux allows the static priority range 1 to 99 for the B<SCHED_FIFO> and "
"B<SCHED_RR> policies, and the priority 0 for the remaining policies.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""
"Linux では、 ポリシー B<SCHED_FIFO> と B<SCHED_RR> では 1 から 99 の範囲の静"
"的プライオリティーを持ち、それ以外のポリシーでは プライオリティとして 0 を持"
"つ。 それぞれの方針のスケジューリングプライオリティの範囲は 変更することがで"
"きない。"

#.  POSIX.1-2001, POSIX.1-2008 (XBD 2.8.4)
#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:89
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min> POSIX.1 requires a spread of at least 32 between "
"the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr "スケジューリングプライオリティの範囲は他の POSIX システムと 異なっているかもしれない。それで、移植性(portable)のある アプリケーションでは仮想的な範囲を用い B<sched_get_priority_max>()  と B<sched_get_priority_min> で与えられた間隔にマップして使用することはいい考えである。 POSIX.1 では B<SCHED_FIFO> と B<SCHED_RR> における 最大値と最小値の間隔を少なくとも 32 にすることを要求している。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:98
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは B<sched_get_priority_max>()  と "
"B<sched_get_priority_min>()  は I<E<lt>unistd.hE<gt>> に "
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:108
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_get_priority_max>()  と B<sched_get_priority_min>()  "
"は指定されたスケジューリング方針のプライオリティの最大値/最小値を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:114
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr "引数 I<policy> が定義されているスケジューリング方針と一致しない。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:116
#: build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setparam.2:121
#: build/C/man2/sched_yield.2:54
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr " POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:126
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"
msgstr ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"

#. type: TH
#: build/C/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr "SCHED_GETCPU"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr "sched_getcpu - 呼び出したスレッドが実行されている CPU を知る"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:32 build/C/man2/sched_setattr.2:33
#: build/C/man2/sched_setparam.2:36 build/C/man2/sched_setscheduler.2:33
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr "B<int sched_getcpu(void);>\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr "B<sched_getcpu>():"

#. type: TP
#: build/C/man3/sched_getcpu.3:45
#, no-wrap
msgid "Since glibc 2.14:"
msgstr "glibc 2.14 以降:"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:48
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: TP
#: build/C/man3/sched_getcpu.3:48
#, no-wrap
msgid "Before glibc 2.14:"
msgstr "glibc 2.14 より前:"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:52
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE も定義される */\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""
"B<sched_getcpu>()  は、呼び出したスレッドが現在実行されている CPU の番号を返"
"す。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sched_getcpu>()  は非負の CPU 番号を返す。 エラーの場合、-1 を"
"返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/sched_getcpu.3:66 build/C/man2/sched_rr_get_interval.2:87
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr "このカーネルでは B<getcpu>(2)  が実装されていない。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr "この関数は glibc 2.6 以降で利用可能である。"

#. type: SH
#: build/C/man3/sched_getcpu.3:72
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:75
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:79
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "B<sched_getcpu>()"
msgstr "B<sched_getcpu>()"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/sched_getcpu.3:82
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:87
msgid "B<sched_getcpu>()  is glibc-specific."
msgstr "B<sched_getcpu>()  は glibc 固有である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:89
msgid "The call"
msgstr "呼び出し"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:93
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr "cpu = sched_getcpu();\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:99
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr "は、以下の B<getcpu>(2)  呼び出しと等価である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:105
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:110
msgid "B<getcpu>(2), B<sched>(7)"
msgstr "B<getcpu>(2), B<sched>(7)"

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr "SCHED_RR_GET_INTERVAL"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr "sched_rr_get_interval - 指定されたプロセスの SCHED_RR 間隔を取得する"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:36
msgid ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"
msgstr " B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""
"B<sched_rr_get_interval>() は I<tp> で指定された I<timespec> 構造体に\n"
"I<pid> で指定されたプロセスのラウンドロビン時間量 (round robin time\n"
"quantum) を書き込む。指定されたプロセスは B<SCHED_RR> スケジューリング\n"
"ポリシーで動作しているはずである。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr "I<timespec> 構造体は以下の通りである:"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"

#
#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""
"I<pid> が 0 の場合、呼び出したプロセスの時間量 (time quantum) が\n"
"I<*tp> に書き込まれる。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_rr_get_interval>()  は 0 を返す。 エラーの場合は -1 が"
"返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr "情報をユーザー空間にコピーする時に問題が起きた。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr "PID が不正である。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""
"システムコールがまだ実装されていない (かなり古いカーネルにおいてのみ)。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr "プロセス ID が I<pid> のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムで B<sched_rr_get_interval>() は I<E<lt>unistd.hE<gt>> に\n"
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:103
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the round-"
"robin time quantum.  Older Linux kernels provide a (nonportable) method of "
"doing this.  The quantum can be controlled by adjusting the process's nice "
"value (see B<setpriority>(2)).  Assigning a negative (i.e., high) nice value "
"results in a longer quantum; assigning a positive (i.e., low) nice value "
"results in a shorter quantum.  The default quantum is 0.1 seconds; the "
"degree to which changing the nice value affects the quantum has varied "
"somewhat across kernel versions.  This method of adjusting the quantum was "
"removed starting with Linux 2.6.24."
msgstr ""
"POSIX ではラウンドロビン時間量の大きさを制御する仕組みが規定されていない。 古"
"い Linux カーネルではこれを変更する方法が提供されている (この方法に移植性はな"
"い)。 プロセスの nice 値を調整することで時間量を制御できる "
"(B<setpriority>(2) 参照)。 負の nice 値 (すなわち、高い nice 値) を割り当てる"
"と時間量は長くなり、 正の nice 値 (すなわち、低い nice 値) を割り当てると時間"
"量は短くなる。 デフォルトの時間量は 0.1 秒である。 nice 値の変更が時間量にど"
"の程度影響を与えるかは カーネルのバージョンにより多少異なる。時間量を調整する"
"このメソッドは Linux 2.6.24 以降で削除された。"

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""
"Linux 3.9 で、 B<SCHED_RR> の時間量の調整 (と参照) を行う新しい機構が追加され"
"た。 I</proc/sys/kernel/sched_rr_timeslice_ms> ファイルでミリ秒単位の時間量の"
"値が参照でき、 デフォルト値は 100 である。 このファイルに 0 を書き込むと、 時"
"間量をデフォルト値に戻すことができる。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:134 build/C/man2/sched_yield.2:92
msgid "B<sched>(7)"
msgstr "B<sched>(7)"

#. type: TH
#: build/C/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr "SCHED_SETAFFINITY"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr ""
"sched_setaffinity, sched_getaffinity - スレッドの CPU affinity マスクを設定・"
"取得する"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr ""
"スレッドの CPU affinity (親和度) マスクは、そのスレッドが 実行を許可されてい"
"る CPU の集合を決定する。 マルチプロセッサシステムでは、CPU affinity マスクを"
"設定することで 性能上のメリットを得られる可能性がある。 例えば、特定のスレッ"
"ドを一つの CPU に括り付け (すなわち、そのスレッドの affinity マスクを一つの "
"CPU に設定し)、 他の全てのスレッドの affinity マスクからその CPU を除外するこ"
"とで、 確実にそのスレッドの実行速度を最大にすることができる。 また、あるス"
"レッドの実行を一つの CPU に限定することで、 一つの CPU での実行を停止してから"
"別の CPU で実行を再開するときに発生する キャッシュ無効化 (cache "
"invalidation) による性能面の劣化を避けることもできる。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU set"
"\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""
"CPU affinity マスクは「CPU の集合」を表す I<cpu_set_t> 構造体で表現され、 "
"I<cpu_set_t> へのポインター I<mask> で指定される。 CPU 集合を操作するためのマ"
"クロ群については B<CPU_SET>(3)  で記載されている。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is "
"I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes) "
"of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""
"B<sched_setaffinity>()  は、スレッド ID が I<pid> のスレッドの CPU affinity "
"マスクを I<mask> で指定された値に設定する。 I<pid> が 0 の場合、呼び出し元ス"
"レッドが使われる。 I<cpusetsize> 引数には I<mask> が指すデータの長さ (バイ"
"ト単位) である。 通常は、この引数には I<sizeof(cpu_set_t)> を指定すればよ"
"い。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""
"I<pid> で指定されたスレッドが I<mask> で指定された CPU のいずれかで現在実行さ"
"れていない場合、 そのスレッドは I<mask> で指定された CPU のいずれかに移動され"
"る。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr ""
"B<sched_getaffinity>()  は、 スレッド ID が I<pid> のスレッドの affinity マス"
"クを I<mask> が指す I<cpu_set_t> 構造体に書き込む。 I<cpusetsize> 引数には "
"I<mask> の (バイト単位の) 大きさを指定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:119
#, fuzzy
#| msgid ""
#| "On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return "
#| "0.  On error, -1 is returned, and I<errno> is set appropriately."
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0 "
"(but see \"C library/kernel differences\" below, which notes that the "
"underlying B<sched_getaffinity>()  differs in its return value).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setaffinity>()  と B<sched_getaffinity>()  は 0 を返"
"す。 エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:123
msgid "A supplied memory address was invalid."
msgstr "指定されたメモリー番地が不正である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:133
#, fuzzy
#| msgid ""
#| "The affinity bit mask I<mask> contains no processors that are currently "
#| "physically on the system and permitted to the thread according to any "
#| "restrictions that may be imposed by the \"cpuset\" mechanism described in "
#| "B<cpuset>(7)."
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by I<cpuset> cgroups or the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""
"システム上に現在実際に存在し、かつ \"cpuset\" 機構が課す制限においてそのス"
"レッドに対して許可されている プロセッサが、 affinity ビットマスク I<mask> に"
"含まれていない。 \"cpuset\" 機構については B<cpuset>(7)  を参照。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:140
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""
"(B<sched_getaffinity>()  と、カーネル 2.6.9 以前の B<sched_setaffinity>())  "
"I<cpusetsize> がカーネルで使われている affinity マスクのサイズより小さい。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:151
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the thread identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability in the user namespace of the thread I<pid>."
msgstr "(B<sched_setaffinity>())  呼び出し元のスレッドに適切な特権がなかった。 呼び出し元は、実効ユーザー ID が I<pid> で識別されるスレッドの実ユーザー ID または実効ユーザー ID と同じであるか、スレッド I<pid> のユーザー名前空間で B<CAP_SYS_NICE> ケーパビリティ (capability) を持たなければならない。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:154 build/C/man2/sched_setattr.2:326
#: build/C/man2/sched_setparam.2:119 build/C/man2/sched_setscheduler.2:168
msgid "The thread whose ID is I<pid> could not be found."
msgstr "ID が I<pid> のスレッドが見つからなかった。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:165
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""
"CPU affinity システムコールは Linux kernel 2.5.8 で導入された。 これらのシス"
"テムコールのラッパー関数は glibc 2.3 で導入された。 最初は、glibc のインター"
"フェースには I<unsigned int> 型の I<cpusetsize> 引数が入っていた。 glibc "
"2.3.3 では I<cpusetsize> 引数が削除されたが、glibc 2.3.4 で I<size_t> 型で"
"復活した。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:167
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:180
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the thread runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr ""
"B<sched_setaffinity>()  を呼び出した後は、スレッドが実際に実行される CPU の集"
"合は、 I<mask> 引数で指定された集合と、システム上に実際に存在する CPU の集"
"合の 共通集合 (AND) となる。 \"cpuset\" 機構が使用されている場合には、スレッ"
"ドが動作する CPU 集合 に対してシステムはさらに制限を加えるかもしれない "
"(\"cpuset\" 機構については B<cpuset>(7)  を参照)。 スレッドが動作する実際の "
"CPU 集合に対する制限はカーネルにより 暗黙のうちに適用される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:192
msgid ""
"There are various ways of determining the number of CPUs available on the "
"system, including: inspecting the contents of I</proc/cpuinfo>; using "
"B<sysconf>(3)  to obtain the values of the B<_SC_NPROCESSORS_CONF> and "
"B<_SC_NPROCESSORS_ONLN> parameters; and inspecting the list of CPU "
"directories under I</sys/devices/system/cpu/>."
msgstr ""
"システムで利用可能な CPU 数を判定する方法はいくつかある。 I</proc/cpuinfo> の"
"内容を調べる、 B<sysconf>(3) を使って B<_SC_NPROCESSORS_CONF> と "
"B<_SC_NPROCESSORS_ONLN> の値を取得する、 I</sys/devices/system/cpu/> の CPU "
"ディレクトリの一覧を調べる、などがある。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:195
msgid "B<sched>(7)  has a description of the Linux scheduling scheme."
msgstr "B<sched>(7) に Linux のスケジューリング方式についての説明がある。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:212
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""
"affinity マスクはスレッド単位の属性で、スレッドグループの 各スレッド単位に独"
"立して調整することができる。 B<gettid>(2)  コールからの返り値をこのコールの "
"I<pid> 引数として渡すことができる。 I<pid> に 0 を指定すると呼び出し元のス"
"レッドの属性が設定され、 B<getpid>(2)  コールからの返り値を I<pid> に指定する"
"とスレッドグループのメインスレッドの属性が設定される (POSIX スレッド API を使"
"用している場合、 B<sched_setaffinity>()  の代わりに "
"B<pthread_setaffinity_np>(3)  を使用すること)。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:230
msgid ""
"The I<isolcpus> boot option can be used to isolate one or more CPUs at boot "
"time, so that no processes are scheduled onto those CPUs.  Following the use "
"of this boot option, the only way to schedule processes onto the isolated "
"CPUs is via B<sched_setaffinity>()  or the B<cpuset>(7)  mechanism.  For "
"further information, see the kernel source file I<Documentation/admin-guide/"
"kernel-parameters.txt>.  As noted in that file, I<isolcpus> is the preferred "
"mechanism of isolating CPUs (versus the alternative of manually setting the "
"CPU affinity of all processes on the system)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:236
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で生成された子プロセスは親プロセスの CPU affinity マスクを継"
"承する。 affinity マスクは B<execve>(2)  の前後で保存される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:244
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask."
msgstr "このマニュアルページでは CPU affinity コールの glibc インターフェースを 説明している。実際のシステムコールインターフェースは少し違っており、 実際の実装では CPU 集合は簡単なビットマスクであるという実状を反映し、 I<mask> の型が I<unsigned long\\ *> となっている。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:256
msgid ""
"On success, the raw B<sched_getaffinity>()  system call returns the number "
"of bytes placed copied into the I<mask> buffer; this will be the minimum of "
"I<cpusetsize> and the size (in bytes) of the I<cpumask_t> data type that is "
"used internally by the kernel to represent the CPU set bit mask."
msgstr ""

#. type: SS
#: build/C/man2/sched_setaffinity.2:256
#, no-wrap
msgid "Handling systems with large CPU affinity masks"
msgstr ""

#.  FIXME . See https://sourceware.org/bugzilla/show_bug.cgi?id=15630
#.  and https://sourceware.org/ml/libc-alpha/2013-07/msg00288.html
#. type: Plain text
#: build/C/man2/sched_setaffinity.2:268
msgid ""
"The underlying system calls (which represent CPU masks as bit masks of type "
"I<unsigned long\\ *>)  impose no restriction on the size of the CPU mask.  "
"However, the I<cpu_set_t> data type used by glibc has a fixed size of 128 "
"bytes, meaning that the maximum CPU number that can be represented is 1023.  "
"If the kernel CPU affinity mask is larger than 1024, then calls of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:270
#, no-wrap
msgid "    sched_getaffinity(pid, sizeof(cpu_set_t), &mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:280
msgid ""
"fail with the error B<EINVAL>, the error produced by the underlying system "
"call for the case where the I<mask> size specified in I<cpusetsize> is "
"smaller than the size of the affinity mask used by the kernel.  (Depending "
"on the system CPU topology, the kernel affinity mask can be substantially "
"larger than the number of active CPUs in the system.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:291
msgid ""
"When working on systems with large kernel CPU affinity masks, one must "
"dynamically allocate the I<mask> argument (see B<CPU_ALLOC>(3)).  Currently, "
"the only way to do this is by probing for the size of the required mask "
"using B<sched_getaffinity>()  calls with increasing mask sizes (until the "
"call does not fail with the error B<EINVAL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:306
msgid ""
"Be aware that B<CPU_ALLOC>(3)  may allocate a slightly larger CPU set than "
"requested (because CPU sets are implemented as bit masks allocated in units "
"of I<sizeof(long)>).  Consequently, B<sched_getaffinity>()  can set bits "
"beyond the requested allocation size, because the kernel sees a few "
"additional bits.  Therefore, the caller should iterate over the bits in the "
"returned set, counting those which are set, and stop upon reaching the value "
"returned by B<CPU_COUNT>(3)  (rather than iterating over the number of bits "
"requested to be allocated)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:315
msgid ""
"The program below creates a child process.  The parent and child then each "
"assign themselves to a specified CPU and execute identical loops that "
"consume some CPU time.  Before terminating, the parent waits for the child "
"to complete.  The program takes three command-line arguments: the CPU number "
"for the parent, the CPU number for the child, and the number of loop "
"iterations that both processes should perform."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:319
msgid ""
"As the sample runs below demonstrate, the amount of real and CPU time "
"consumed when running the program will depend on intra-core caching effects "
"and whether the processes are using the same CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:324
msgid ""
"We first employ B<lscpu>(1)  to determine that this (x86)  system has two "
"cores, each with two CPUs:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:331
#, no-wrap
msgid ""
"$ B<lscpu | egrep -i \\(aqcore.*:|socket\\(aq>\n"
"Thread(s) per core:    2\n"
"Core(s) per socket:    2\n"
"Socket(s):             1\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:338
msgid ""
"We then time the operation of the example program for three cases: both "
"processes running on the same CPU; both processes running on different CPUs "
"on the same core; and both processes running on different CPUs on different "
"cores."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:353
#, no-wrap
msgid ""
"$ B<time -p ./a.out 0 0 100000000>\n"
"real 14.75\n"
"user 3.02\n"
"sys 11.73\n"
"$ B<time -p ./a.out 0 1 100000000>\n"
"real 11.52\n"
"user 3.98\n"
"sys 19.06\n"
"$ B<time -p ./a.out 0 3 100000000>\n"
"real 7.89\n"
"user 3.29\n"
"sys 12.07\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:364
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
msgstr ""
" #define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:374
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops;\n"
msgstr ""
" int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops;\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:380
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"     if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:384
#, no-wrap
msgid ""
"    parentCPU = atoi(argv[1]);\n"
"    childCPU = atoi(argv[2]);\n"
"    nloops = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:386
#, no-wrap
msgid "    CPU_ZERO(&set);\n"
msgstr "     CPU_ZERO(&set);\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:390
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:            /* Error */\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:393
#, no-wrap
msgid ""
"    case 0:             /* Child */\n"
"        CPU_SET(childCPU, &set);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:396 build/C/man2/sched_setaffinity.2:407
#, no-wrap
msgid ""
"        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"
msgstr ""
"         if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:399 build/C/man2/sched_setaffinity.2:410
#, no-wrap
msgid ""
"        for (int j = 0; j E<lt> nloops; j++)\n"
"            getppid();\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:401
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "         exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:404
#, no-wrap
msgid ""
"    default:            /* Parent */\n"
"        CPU_SET(parentCPU, &set);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:415
#, no-wrap
msgid ""
"        wait(NULL);     /* Wait for child to terminate */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:440
msgid ""
"B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), "
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), "
"B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"
msgstr " B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"

#. type: TH
#: build/C/man2/sched_setattr.2:26
#, no-wrap
msgid "SCHED_SETATTR"
msgstr "SCHED_SETATTR"

#. type: Plain text
#: build/C/man2/sched_setattr.2:30
msgid ""
"sched_setattr, sched_getattr - set and get scheduling policy and attributes"
msgstr ""
"sched_setattr, sched_getattr - スケジューリングポリシーと属性の設定と取得を行"
"なう"

#. type: Plain text
#: build/C/man2/sched_setattr.2:36
#, no-wrap
msgid ""
"B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"
msgstr ""
" B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setattr.2:39
#, no-wrap
msgid ""
"B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
" B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"

#. type: SS
#: build/C/man2/sched_setattr.2:42
#, no-wrap
msgid "sched_setattr()"
msgstr "sched_setattr()"

#. type: Plain text
#: build/C/man2/sched_setattr.2:52
msgid ""
"The B<sched_setattr>()  system call sets the scheduling policy and "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be set."
msgstr ""
"B<sched_setattr>() システムコールは、 I<pid> で指定された ID を持つスレッドの"
"スケジューリングポリシーと関連する属性を設定する。 I<pid> が 0 の場合、呼び出"
"したスレッド自身のスケジューリングポリシーと属性が設定される。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:56 build/C/man2/sched_setscheduler.2:71
msgid ""
"Currently, Linux supports the following \"normal\" (i.e., non-real-time) "
"scheduling policies as values that may be specified in I<policy>:"
msgstr ""
"現在のところ、 Linux では、 以下の「通常」の (つまり、リアルタイムではない) "
"スケジューリングポリシーが、 I<policy> に指定できる値としてサポートされてい"
"る。"

#. type: TP
#: build/C/man2/sched_setattr.2:56 build/C/man2/sched_setscheduler.2:71
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr "B<SCHED_OTHER>"

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setattr.2:61 build/C/man2/sched_setscheduler.2:76
msgid "the standard round-robin time-sharing policy;"
msgstr "標準の、ラウンドロビンによる時分割型のスケジューリングポリシー。"

#. type: TP
#: build/C/man2/sched_setattr.2:61 build/C/man2/sched_setscheduler.2:76
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr "B<SCHED_BATCH>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:64 build/C/man2/sched_setscheduler.2:79
msgid "for \"batch\" style execution of processes; and"
msgstr "「バッチ」形式でのプロセスの実行用。"

#. type: TP
#: build/C/man2/sched_setattr.2:64 build/C/man2/sched_setscheduler.2:79
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr "B<SCHED_IDLE>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:69 build/C/man2/sched_setscheduler.2:84
msgid "for running I<very> low priority background jobs."
msgstr "「非常に」低い優先度で動作するバックグラウンドジョブ用。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:78 build/C/man2/sched_setscheduler.2:97
msgid ""
"Various \"real-time\" policies are also supported, for special time-critical "
"applications that need precise control over the way in which runnable "
"threads are selected for execution.  For the rules governing when a process "
"may use these policies, see B<sched>(7).  The real-time policies that may be "
"specified in I<policy> are:"
msgstr ""
"どの実行可能スレッドを選択するかについて、より正確な制御を必要とする 時間の制"
"約が厳しい特別なアプリケーション用として、 いろいろな「リアルタイム」ポリシー"
"もサポートされている。 プロセスがこれらのポリシーをいつ使用できるかを決める"
"ルールについては、B<sched>(7) を参照。 I<policy> には以下のリアルタイムポリ"
"シーを指定できる。"

#. type: TP
#: build/C/man2/sched_setattr.2:78 build/C/man2/sched_setscheduler.2:97
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr "B<SCHED_FIFO>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:81 build/C/man2/sched_setscheduler.2:100
msgid "a first-in, first-out policy; and"
msgstr "ファーストイン、ファーストアウト型のポリシー。"

#. type: TP
#: build/C/man2/sched_setattr.2:81 build/C/man2/sched_setscheduler.2:100
#, no-wrap
msgid "B<SCHED_RR>"
msgstr "B<SCHED_RR>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:84 build/C/man2/sched_setscheduler.2:103
msgid "a round-robin policy."
msgstr "ラウンドロビン型のポリシー。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:86
msgid "Linux also provides the following policy:"
msgstr "Linux では以下のポリシーも提供されている。"

#. type: TP
#: build/C/man2/sched_setattr.2:86
#, no-wrap
msgid "B<SCHED_DEADLINE>"
msgstr "B<SCHED_DEADLINE>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:91
msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgstr ""
"デッドライン (応答期限) ベースのスケジューリングポリシー。詳細は B<sched>(7) "
"を参照。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:97
msgid ""
"The I<attr> argument is a pointer to a structure that defines the new "
"scheduling policy and attributes for the specified thread.  This structure "
"has the following form:"
msgstr ""
"I<attr> 引数は、 指定したスレッドの新しいスケジューリングポリシーと属性を定"
"義した構造体へのポインターである。 この構造体は以下の形式である。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:113
#, no-wrap
msgid ""
"struct sched_attr {\n"
"    u32 size;              /* Size of this structure */\n"
"    u32 sched_policy;      /* Policy (SCHED_*) */\n"
"    u64 sched_flags;       /* Flags */\n"
"    s32 sched_nice;        /* Nice value (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* Static priority (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* Remaining fields are for SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"
msgstr ""
"struct sched_attr {\n"
"    u32 size;              /* この構造体のサイズ */\n"
"    u32 sched_policy;      /* ポリシー (SCHED_*) */\n"
"    u64 sched_flags;       /* フラグ */\n"
"    s32 sched_nice;        /* nice 値 (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* 静的優先度 (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* 残りのフィールドは SCHED_DEADLINE 用である */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"

#. type: Plain text
#: build/C/man2/sched_setattr.2:119
msgid "The fields of the I<sched_attr> structure are as follows:"
msgstr "構造体 I<sched_attr> のフィールドは以下の通りである。"

#. type: TP
#: build/C/man2/sched_setattr.2:119
#, no-wrap
msgid "B<size>"
msgstr "B<size>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:134
msgid ""
"This field should be set to the size of the structure in bytes, as in "
"I<sizeof(struct sched_attr)>.  If the provided structure is smaller than the "
"kernel structure, any additional fields are assumed to be '0'.  If the "
"provided structure is larger than the kernel structure, the kernel verifies "
"that all additional fields are 0; if they are not, B<sched_setattr>()  fails "
"with the error B<E2BIG> and updates I<size> to contain the size of the "
"kernel structure."
msgstr ""
"このフィールドには、 構造体のバイト単位のサイズを設定する。 I<sizeof(struct "
"sched_attr)> を指定すればよい。 指定された構造体がカーネル構造体よりも小さい"
"場合、 追加となるフィールドは 0 とみなされる。 指定された構造体がカーネル構造"
"体よりも大きい場合、 カーネルは追加のフィールドが 0 であるかを検査する。 0 で"
"ない場合は B<sched_setattr>() はエラー B<E2BIG> で失敗するので、 I<size> を"
"カーネル構造体のサイズに更新する必要がある。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:148
msgid ""
"The above behavior when the size of the user-space I<sched_attr> structure "
"does not match the size of the kernel structure allows for future "
"extensibility of the interface.  Malformed applications that pass oversize "
"structures won't break in the future if the size of the kernel I<sched_attr> "
"structure is increased.  In the future, it could also allow applications "
"that know about a larger user-space I<sched_attr> structure to determine "
"whether they are running on an older kernel that does not support the larger "
"structure."
msgstr ""
"ユーザー空間の I<sched_attr> 構造体のサイズがカーネル構造体のサイズと一致しな"
"かった場合の上記の動作は、 このインターフェースを将来拡張できるようにするため"
"である。 サイズが大きい構造体を渡す行儀の良くないアプリケーションも、 将来"
"カーネルの I<sched_attr> 構造体のサイズが大きくなったとしてもおかしくならな"
"い。 この仕組みにより、 将来的には、 大きなユーザー空間 I<sched_attr> 構造体"
"があることを知っているアプリケーションで、 大きいサイズの構造体に対応していな"
"い古いカーネル上で動作しているかを判定することができる。"

#. type: TP
#: build/C/man2/sched_setattr.2:148
#, no-wrap
msgid "I<sched_policy>"
msgstr "I<sched_policy>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:153
msgid ""
"This field specifies the scheduling policy, as one of the B<SCHED_*> values "
"listed above."
msgstr ""
"このフィールドはスケジューリングポリシーを指定する。 上記のリストにある "
"B<SCHED_*> 値のいずれかを指定する。"

#. type: TP
#: build/C/man2/sched_setattr.2:153
#, no-wrap
msgid "I<sched_flags>"
msgstr "I<sched_flags>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:157
msgid ""
"This field contains zero or more of the following flags that are ORed "
"together to control scheduling behavior:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:158
#, no-wrap
msgid "B<SCHED_FLAG_RESET_ON_FORK>"
msgstr " B<SCHED_FLAG_RESET_ON_FORK>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:166
#, fuzzy
#| msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgid ""
"Children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""
"デッドライン (応答期限) ベースのスケジューリングポリシー。詳細は B<sched>(7) "
"を参照。"

#. type: TP
#: build/C/man2/sched_setattr.2:166
#, no-wrap
msgid "B<SCHED_FLAG_RECLAIM> (since Linux 4.13)"
msgstr "B<SCHED_FLAG_RECLAIM> (Linux 4.13 以降)"

#.  2d4283e9d583a3ee8cfb1cbb9c1270614df4c29d
#.  Bandwidth reclaim is done via the GRUB algorithm; see
#.  Documentation/scheduler/sched-deadline.txt
#. type: Plain text
#: build/C/man2/sched_setattr.2:174
msgid ""
"This flag allows a B<SCHED_DEADLINE> thread to reclaim bandwidth unused by "
"other real-time threads."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:174
#, no-wrap
msgid "B<SCHED_FLAG_DL_OVERRUN> (since Linux 4.16)"
msgstr "B<SCHED_FLAG_DL_OVERRUN> (Linux 4.16 以降)"

#.  commit 34be39305a77b8b1ec9f279163c7cdb6cc719b91
#. type: Plain text
#: build/C/man2/sched_setattr.2:185
msgid ""
"This flag allows an application to get informed about run-time overruns in "
"B<SCHED_DEADLINE> threads.  Such overruns may be caused by (for example) "
"coarse execution time accounting or incorrect parameter assignment.  "
"Notification takes the form of a B<SIGXCPU> signal which is generated on "
"each overrun."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setattr.2:200
msgid ""
"This B<SIGXCPU> signal is I<process-directed> (see B<signal>(7))  rather "
"than thread-directed.  This is probably a bug.  On the one hand, "
"B<sched_setattr>()  is being used to set a per-thread attribute.  On the "
"other hand, if the process-directed signal is delivered to a thread inside "
"the process other than the one that had a run-time overrun, the application "
"has no way of knowing which thread overran."
msgstr ""

#. type: TP
#: build/C/man2/sched_setattr.2:201
#, no-wrap
msgid "I<sched_nice>"
msgstr "I<sched_nice>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:212
msgid ""
"This field specifies the nice value to be set when specifying "
"I<sched_policy> as B<SCHED_OTHER> or B<SCHED_BATCH>.  The nice value is a "
"number in the range -20 (high priority)  to +19 (low priority); see "
"B<sched>(7)."
msgstr "このフィールドは、 I<sched_policy> に B<SCHED_OTHER> か B<SCHED_BATCH> が指定された場合に設定される nice 値を指定する。 nice 値は -20 (高優先度) から +19 (低優先度) の範囲の数値である。 B<sched>(7) を参照。"

#. type: TP
#: build/C/man2/sched_setattr.2:212
#, no-wrap
msgid "I<sched_priority>"
msgstr "I<sched_priority>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:225
msgid ""
"This field specifies the static priority to be set when specifying "
"I<sched_policy> as B<SCHED_FIFO> or B<SCHED_RR>.  The allowed range of "
"priorities for these policies can be determined using "
"B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2).  For other "
"policies, this field must be specified as 0."
msgstr ""
"このフィールドは、 I<sched_policy> に B<SCHED_FIFO> か B<SCHED_RR> が指定され"
"た場合に設定される静的優先度を指定する。 これらのポリシーで指定できる優先度の"
"範囲は、 B<sched_get_priority_min>(2) と B<sched_get_priority_max>(2) を使っ"
"て判定できる。 他のポリシーでは、 このフィールドには 0 を指定しなければならな"
"い。"

#. type: TP
#: build/C/man2/sched_setattr.2:225
#, no-wrap
msgid "I<sched_runtime>"
msgstr "I<sched_runtime>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:234
msgid ""
"This field specifies the \"Runtime\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds.  This field, and the next two fields, are "
"used only for B<SCHED_DEADLINE> scheduling; for further details, see "
"B<sched>(7)."
msgstr ""
"このフィールドは、 デッドラインスケジューリングの \"Runtime\" パラメーターを"
"指定する。 この値はナノ秒単位で表現される。 このフィールドと次の 2 つのフィー"
"ルドは B<SCHED_DEADLINE> スケジューリングにおいてのみ使用される。 詳細は "
"B<sched>(7) を参照。"

#. type: TP
#: build/C/man2/sched_setattr.2:234
#, no-wrap
msgid "I<sched_deadline>"
msgstr "I<sched_deadline>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:238
msgid ""
"This field specifies the \"Deadline\" parameter for deadline scheduling.  "
"The value is expressed in nanoseconds."
msgstr ""
"このフィールドは、 デッドラインスケジューリングの \"Deadline\" パラメーターを"
"指定する。 この値はナノ秒単位で表現される。"

#. type: TP
#: build/C/man2/sched_setattr.2:238
#, no-wrap
msgid "I<sched_period>"
msgstr "I<sched_period>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:242
msgid ""
"This field specifies the \"Period\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds."
msgstr ""
"このフィールドは、 デッドラインスケジューリングの \"Period\" パラメーターを指"
"定する。 この値はナノ秒単位で表現される。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:249 build/C/man2/sched_setattr.2:299
msgid ""
"The I<flags> argument is provided to allow for future extensions to the "
"interface; in the current implementation it must be specified as 0."
msgstr ""
"I<flags> 引数は、このインターフェースの将来の拡張のために用意されている。 "
"現在の実装では 0 を指定しなければならない。"

#. type: SS
#: build/C/man2/sched_setattr.2:249
#, no-wrap
msgid "sched_getattr()"
msgstr "sched_getattr()"

#. type: Plain text
#: build/C/man2/sched_setattr.2:260
msgid ""
"The B<sched_getattr>()  system call fetches the scheduling policy and the "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be retrieved."
msgstr ""
"B<sched_getattr>() システムコールは、 I<pid> で指定された ID を持つスレッドの"
"スケジューリングポリシーと関連する属性を取得する。 I<pid> が 0 の場合、呼び出"
"したスレッド自身のスケジューリングポリシーと関連する属性を取得する。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:270
msgid ""
"The I<size> argument should be set to the size of the I<sched_attr> "
"structure as known to user space.  The value must be at least as large as "
"the size of the initially published I<sched_attr> structure, or the call "
"fails with the error B<EINVAL>."
msgstr ""
"I<size> 引数には、 ユーザー空間での I<sched_attr> 構造体の大きさを設定す"
"る。 この値は、 少なくとも初期バージョンの I<sched_attr> 構造体のサイズでなけ"
"ればならない。 そうでなかった場合、 エラー B<EINVAL> で呼び出しが失敗する。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:280
msgid ""
"The retrieved scheduling attributes are placed in the fields of the "
"I<sched_attr> structure pointed to by I<attr>.  The kernel sets I<attr.size> "
"to the size of its I<sched_attr> structure."
msgstr ""
"取得したスケジューリング属性は、 I<attr> が指す I<sched_attr> 構造体の各"
"フィールドに格納される。 カーネルは I<attr.size> に I<sched_attr> 構造体のサ"
"イズを設定する。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:294
#, fuzzy
#| msgid ""
#| "If the caller-provided I<attr> buffer is larger than the kernel's "
#| "I<sched_attr> structure, the additional bytes in the user-space structure "
#| "are not touched.  If the caller-provided structure is smaller than the "
#| "kernel I<sched_attr> structure and the kernel needs to return values "
#| "outside the provided space, B<sched_getattr>()  fails with the error "
#| "B<E2BIG>.  As with B<sched_setattr>(), these semantics allow for future "
#| "extensibility of the interface."
msgid ""
"If the caller-provided I<attr> buffer is larger than the kernel's "
"I<sched_attr> structure, the additional bytes in the user-space structure "
"are not touched.  If the caller-provided structure is smaller than the "
"kernel I<sched_attr> structure, the kernel will silently not return any "
"values which would be stored outside the provided space.  As with "
"B<sched_setattr>(), these semantics allow for future extensibility of the "
"interface."
msgstr ""
"呼び出し側が提供した I<attr> バッファーがカーネルの I<sched_attr> 構造体より"
"も大きい場合、 ユーザー空間構造体の残りのバイトは変更されない。 呼び出し側が"
"提供した構造体がカーネルの I<sched_attr> 構造体よりも小さく、 カーネルが値を"
"返すのにもっと大きな空間が必要な場合、 B<sched_getattr>() はエラー B<E2BIG> "
"で失敗する。 B<sched_setattr>() と同様、 この動作はこのインターフェースの将来"
"の拡張性を考慮してのものである。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:308
msgid ""
"On success, B<sched_setattr>()  and B<sched_getattr>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""
"成功した場合は B<sched_setattr>()  と B<sched_getattr>()  は 0 を返す。 エ"
"ラーの場合は -1 が返され、 エラーの原因を示す値が I<errno> に設定される。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:313
msgid ""
"B<sched_getattr>()  and B<sched_setattr>()  can both fail for the following "
"reasons:"
msgstr ""
"B<sched_getattr>() と B<sched_setattr>() の両方が以下の理由で失敗する。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:321
msgid "I<attr> is NULL; or I<pid> is negative; or I<flags> is not zero."
msgstr ""
"I<attr> が NULL である。 I<pid> が負である。 I<flags> が 0 以外である。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:330
msgid "In addition, B<sched_getattr>()  can fail for the following reasons:"
msgstr "さらに、 B<sched_getattr>() は以下の理由でも失敗する。"

#. type: TP
#: build/C/man2/sched_setattr.2:330 build/C/man2/sched_setattr.2:347
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:337
msgid "The buffer specified by I<size> and I<attr> is too small."
msgstr "I<size> と I<attr> で指定されたバッファーが小さすぎる。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:343
msgid ""
"I<size> is invalid; that is, it is smaller than the initial version of the "
"I<sched_attr> structure (48 bytes) or larger than the system page size."
msgstr ""
"I<size> が無効である。つまり、 最初のバージョンの I<sched_attr> 構造体 (48 バ"
"イト) よりも小さいか、 システムのページサイズよりも大きい。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:347
msgid "In addition, B<sched_setattr>()  can fail for the following reasons:"
msgstr "さらに、 B<sched_setattr>() は以下の理由でも失敗する。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:355
msgid ""
"The buffer specified by I<size> and I<attr> is larger than the kernel "
"structure, and one or more of the excess bytes is nonzero."
msgstr ""
"I<size> と I<attr> で指定されたバッファーがカーネル構造体よりも大きく、 一つ"
"以上の超過バイトが 0 でなかった。"

#. type: TP
#: build/C/man2/sched_setattr.2:355
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/sched_setattr.2:360
msgid "B<SCHED_DEADLINE> admission control failure, see B<sched>(7)."
msgstr "B<SCHED_DEADLINE> の流入制御の失敗については B<sched>(7) を参照。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:376
msgid ""
"I<attr.sched_policy> is not one of the recognized policies; I<attr."
"sched_flags> contains a flag other than B<SCHED_FLAG_RESET_ON_FORK>; or "
"I<attr.sched_priority> is invalid; or I<attr.sched_policy> is "
"B<SCHED_DEADLINE> and the deadline scheduling parameters in I<attr> are "
"invalid."
msgstr ""
"I<attr.sched_policy> が認識できるポリシーではない。 I<attr.sched_flags> に "
"B<SCHED_FLAG_RESET_ON_FORK> 以外のフラグが含まれている。 I<attr."
"sched_priority> が無効である。 I<attr.sched_policy> が B<SCHED_DEADLINE> "
"で、 I<attr> に指定されたデッドラインスケジューリングパラメーターが無効であ"
"る。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:379
msgid "The caller does not have appropriate privileges."
msgstr "呼び出した元が適切な特権を持っていない。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:386
msgid ""
"The CPU affinity mask of the thread specified by I<pid> does not include all "
"CPUs in the system (see B<sched_setaffinity>(2))."
msgstr "I<pid> で指定されたスレッドの CPU affinity マスクにシステムの全ての CPU のうち含まれていないものがある (B<sched_setaffinity>(2) を参照)。"

#.  FIXME . Add glibc version
#. type: Plain text
#: build/C/man2/sched_setattr.2:389
msgid "These system calls first appeared in Linux 3.14."
msgstr "これらのシステムコールは Linux 3.14 で初めて登場した。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:391
msgid "These system calls are nonstandard Linux extensions."
msgstr "これらのシステムコールは非標準の Linux による拡張である。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:407
msgid ""
"B<sched_setattr>()  provides a superset of the functionality of "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2), and (other than "
"the ability to set the priority of all processes belonging to a specified "
"user or all processes in a specified group)  B<setpriority>(2).  "
"Analogously, B<sched_getattr>()  provides a superset of the functionality of "
"B<sched_getscheduler>(2), B<sched_getparam>(2), and (partially)  "
"B<getpriority>(2)."
msgstr ""
"B<sched_setattr>() は、B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<nice>(2) の機能および B<setpriority> の一部機能を持つ (ただし、"
"B<setpriority>(2) の、指定されたユーザーに所属するすべてのプロセスまたは指定"
"されたグループのすべてのプロセスの優先度を設定する機能は除く)。 同様に、 "
"B<sched_getattr>() は B<sched_getscheduler>(2), B<sched_getparam>(2) の機能お"
"よび B<getpriority>(2) の一部機能を持つ。"

#.  FIXME . patch sent to Peter Zijlstra
#. type: Plain text
#: build/C/man2/sched_setattr.2:417
msgid ""
"In Linux versions up to 3.15, B<sched_setattr>()  failed with the error "
"B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgstr "バージョン 3.15 までの Linux では、 B<sched_setattr>() は、 エラーの節に書かれている B<E2BIG> の場合にエラーB<EFAULT> で失敗していた。"

#.  In Linux versions up to up 3.15,
#.  FIXME . patch from Peter Zijlstra pending
#.  .BR sched_setattr ()
#.  allowed a negative
#.  .I attr.sched_policy
#.  value.
#. type: Plain text
#: build/C/man2/sched_setattr.2:433
#, fuzzy
#| msgid ""
#| "In Linux versions up to 3.15, B<sched_settattr>()  failed with the error "
#| "B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgid ""
"In Linux versions up to 5.3, B<sched_getattr>()  failed with the error "
"B<EFBIG> if the in-kernel I<sched_attr> structure was larger than the "
"I<size> passed by user space."
msgstr ""
"バージョン 3.15 までの Linux では、 B<sched_settattr>() は、 エラーの節に書か"
"れている B<E2BIG> の場合にエラーB<EFAULT> で失敗していた。"

#. type: Plain text
#: build/C/man2/sched_setattr.2:455
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), "
"B<cpuset>(7), B<sched>(7)"
msgstr " B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr "SCHED_SETPARAM"

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "2019-10-10"
msgstr " 2019-10-10"

#. type: Plain text
#: build/C/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""
"sched_setparam, sched_getparam - スケジューリングパラメーターの設定と取得を行"
"なう"

#. type: Plain text
#: build/C/man2/sched_setparam.2:38
#, no-wrap
msgid "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:46
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:60
#, fuzzy
#| msgid ""
#| "B<sched_setparam>()  sets the scheduling parameters associated with the "
#| "scheduling policy for the process identified by I<pid>.  If I<pid> is "
#| "zero, then the parameters of the calling process are set.  The "
#| "interpretation of the argument I<param> depends on the scheduling policy "
#| "of the process identified by I<pid>.  See B<sched>(7)  for a description "
#| "of the scheduling policies supported under Linux."
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the thread whose thread ID is specified in I<pid>.  If "
"I<pid> is zero, then the parameters of the calling thread are set.  The "
"interpretation of the argument I<param> depends on the scheduling policy of "
"the thread identified by I<pid>.  See B<sched>(7)  for a description of the "
"scheduling policies supported under Linux."
msgstr ""
"B<sched_setparam>()  は I<pid> で指定されたプロセスのスケジューリング方針 "
"(scheduling policy) に 関連するスケジューリングパラメーターを設定する。 "
"I<pid> が 0 ならば、呼び出し元のプロセスのパラメーターが設定される。 引数 "
"I<param> の解釈は、 I<pid> で指定されたプロセスのスケジューリング方針によって"
"異なる。 Linux でサポートされているスケジューリング方針の説明は B<sched>(7)  "
"を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the thread "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"thread are retrieved."
msgstr "B<sched_getparam>()  は I<pid> で指定されたスレッドのスケジューリングパラメーターを取得する。 I<pid> が 0 ならば、呼び出し元のスレッドのパラメーターを取得する。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""
"B<sched_setparam>()  はスレッドのスケジューリング方針における I<param> の妥当"
"性をチェックする。 I<param-E<gt>sched_priority> の値は "
"B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  の範囲に入って"
"いなければならない。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched>(7)."
msgstr ""
"スケジューリングの優先度と方針に関連する特権とリソース制限の 議論に関しては "
"B<sched>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"B<sched_setparam>()  と B<sched_getparam>()  が使用できる POSIX システムで"
"は、 I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が定義されてい"
"る。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_setparam>()  と B<sched_getparam>()  は 0 を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:104
msgid "Invalid arguments: I<param> is NULL or I<pid> is negative"
msgstr "無効な引数: I<param> が NULL である、または I<pid> が負である。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:109
msgid ""
"(B<sched_setparam>())  The argument I<param> does not make sense for the "
"current scheduling policy."
msgstr ""
"(B<sched_setparam>()) 引数 I<param> が現在のスケジューリング方針においては "
"無意味である。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:116
msgid ""
"(B<sched_setparam>())  The caller does not have appropriate privileges "
"(Linux: does not have the B<CAP_SYS_NICE> capability)."
msgstr "(B<sched_setparam>()) 呼び出し元が適切な特権を持っていない (Linux では、 B<CAP_SYS_NICE> ケーパビリティを持っていない)。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:137
msgid ""
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr " B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"

#. type: TH
#: build/C/man2/sched_setscheduler.2:26
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr "SCHED_SETSCHEDULER"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:30
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling policy/"
"parameters"
msgstr ""
"sched_setscheduler, sched_getscheduler - スケジューリングポリシーとパラメー"
"ターを設定/取得する"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:36
#, no-wrap
msgid ""
"B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""
" B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:38
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:47
msgid ""
"The B<sched_setscheduler>()  system call sets both the scheduling policy and "
"parameters for the thread whose ID is specified in I<pid>.  If I<pid> equals "
"zero, the scheduling policy and parameters of the calling thread will be set."
msgstr ""
"B<sched_setscheduler>() システムコールは、 I<pid> で指定された ID を持つス"
"レッドのスケジューリングポリシーとスケジューリングパラメーターの両方を設定す"
"る。 I<pid> が 0 の場合、呼び出したスレッド自身のスケジューリングポリシーとス"
"ケジューリングパラメーターが設定される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:51
msgid ""
"The scheduling parameters are specified in the I<param> argument, which is a "
"pointer to a structure of the following form:"
msgstr ""
"スケジューリングパラメーターは I<param> 引数で、以下の形式の構造体へのポイ"
"ンターを指定する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:59
#, no-wrap
msgid ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"
msgstr ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:67
msgid ""
"In the current implementation, the structure contains only one field, "
"I<sched_priority>.  The interpretation of I<param> depends on the selected "
"policy."
msgstr ""
"現在の実装では、この構造体のフィールドは I<sched_priority> だけである。 "
"I<param> がどのように解釈されるかは選択されたポリシーによって変わる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:88
msgid "For each of the above policies, I<param-E<gt>sched_priority> must be 0."
msgstr ""
"上記のどのポリシーの場合でも、 I<param-E<gt>sched_priority> は 0 でなければな"
"らない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:114
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> specifies a "
"scheduling priority for the thread.  This is a number in the range returned "
"by calling B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2)  "
"with the specified I<policy>.  On Linux, these system calls return, "
"respectively, 1 and 99."
msgstr ""
"上記のどのポリシーの場合でも、 I<param-E<gt>sched_priority> はそのスレッドの"
"スケジューリングポリシーを指定する。 指定された I<policy> で "
"I<sched_get_priority_min>(2) と I<sched_get_priority_max>(2) を呼び出した返り"
"値の範囲の数字を指定する。 Linux では、これらのシステムコールはそれぞれ 1 と "
"99 を返す。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:127
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""
"Linux 2.6.32 以降では、 B<sched_setscheduler>() を呼び出す際に I<policy> に "
"B<SCHED_RESET_ON_FORK> フラグを OR で指定できる。このフラグが指定されると、 "
"B<fork>(2) で作成された子プロセスは特権が必要なスケジューリングポリシーを継承"
"しない。 詳細は B<sched>(7) を参照。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:133
msgid ""
"B<sched_getscheduler>()  returns the current scheduling policy of the thread "
"identified by I<pid>.  If I<pid> equals zero, the policy of the calling "
"thread will be retrieved."
msgstr ""
"B<sched_getscheduler>()  は I<pid> で識別されるスレッドの現在のスケジューリン"
"グポリシーを返す。I<pid> が 0 ならば、呼び出した スレッド自身のスケジューリン"
"グポリシーが返される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:143
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, both calls return -1, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setscheduler>()  は 0 を返す。 成功した場合、 "
"B<sched_getscheduler>()  は現在のそのスレッドのポリシー (非負の整数) を返"
"す。 エラーの場合、 どちらのコールも -1 を返し、 I<errno> が適切に設定され"
"る。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:151
msgid "Invalid arguments: I<pid> is negative or I<param> is NULL."
msgstr "無効な引数: I<pid> が負である、または I<param> が NULL である。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:156
msgid ""
"(B<sched_setscheduler>())  I<policy> is not one of the recognized policies."
msgstr "(B<sched_setscheduler>()) I<policy> が認識できるポリシーではない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:162
msgid ""
"(B<sched_setscheduler>())  I<param> does not make sense for the specified "
"I<policy>."
msgstr ""
"(B<sched_setscheduler>()) 引数 I<param> が指定された I<policy> では意味を持"
"たない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:165
msgid "The calling thread does not have appropriate privileges."
msgstr "呼び出したスレッドが適切な特権を持っていない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The B<SCHED_BATCH> and "
"B<SCHED_IDLE> policies are Linux-specific."
msgstr "POSIX.1-2001, POSIX.1-2008 (但し、下記のバグの節も参照)。 B<SCHED_BATCH> と B<SCHED_IDLE> ポリシーは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:180
#, fuzzy
#| msgid ""
#| "Further details of the semantics of all of the above \"normal\" and "
#| "\"real-time\" scheduling policies can be found in B<sched>(7)."
msgid ""
"Further details of the semantics of all of the above \"normal\" and \"real-"
"time\" scheduling policies can be found in the B<sched>(7)  manual page.  "
"That page also describes an additional policy, B<SCHED_DEADLINE>, which is "
"settable only via B<sched_setattr>(2)."
msgstr ""
"上記の「通常」および「リアルタイム」スケジューリングポリシーの動作の詳細な説"
"明は B<sched>(7) にある。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:188
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が"
"定義されている場合にのみ B<sched_setscheduler>()  と "
"B<sched_getscheduler>()  が使用できる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:196
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires "
"in order to call B<sched_setscheduler>(), and details vary across systems.  "
"For example, the Solaris 7 manual page says that the real or effective user "
"ID of the caller must match the real user ID or the save set-user-ID of the "
"target."
msgstr ""
"POSIX.1 は、非特権スレッドが B<sched_setscheduler>()  を呼び出すために必要な"
"権限の詳細を規定しておらず、 詳細はシステムにより異なる。 例えば、Solaris 7 "
"のマニュアルページでは、 呼び出し元の実ユーザー ID または実効ユーザー ID が "
"設定対象の実ユーザー ID か保存 (save) set-user-ID と 一致していなければならな"
"い、となっている。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:217
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attributes of "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attributes of the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr ""
"Linux では、 スケジューリングポリシーとスケジューリングパラメーターは、 実際"
"にはスレッド単位の属性である。 B<gettid>(2) の呼び出しの返り値をこのシステム"
"コールの I<pid> 引数として渡すことができる。 I<pid> に 0 を指定すると、 呼"
"び出し元のスレッドの属性が設定される。 B<getpid>(2) コールからの返り値を "
"I<pid> に指定すると、 スレッドグループのメインスレッドの属性が設定される "
"(POSIX スレッド API を使用している場合は、 B<sched_*>(2) システムコールの代わ"
"りに B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3) を使用すること)。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:225
msgid ""
"POSIX.1 says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr "POSIX.1 では、成功時に B<sched_setscheduler>()  は直前のスケジューリングポリシーを返すべきとされている。 Linux の B<sched_setscheduler>()  はこの要求仕様に準拠しておらず、 成功時には常に 0 を返す。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:244
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr "SCHED_YIELD"

#. type: Plain text
#: build/C/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr "sched_yield - プロセッサーを空け渡す(yield)"

#. type: Plain text
#: build/C/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr "B<int sched_yield(void);>"

#. type: Plain text
#: build/C/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""
"B<sched_yield>()  を呼び出すことで、呼び出したスレッドが CPU の使用権を手放す"
"ことができる。 そのスレッドは、そのスレッドの静的プライオリティのキューの末尾"
"に 移動し、新しいスレッドが走り始める。"

#. type: Plain text
#: build/C/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_yield>()  は 0 を返す。 エラーの場合は -1 が返され、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr "Linux の実装では、 B<sched_yield>()  は常に成功する。"

#. type: Plain text
#: build/C/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""
"B<sched_yield>()  を呼び出した時点で最大優先度のリストの中に呼び出し元のス"
"レッドしか 存在しなければ、そのスレッドは呼び出し後も走り続けることになる。"

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムで B<sched_yield>()  は I<E<lt>unistd.hE<gt>> に "
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources (e."
"g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""
"B<sched_yield>()  を戦略的に呼び出すことで、(極度に) 競合するリソース (mutex "
"など)  を呼び出し元が解放した際に他のスレッドやプロセスに実行機会を与えること"
"で、 性能を上げることができる。 B<sched_yield>()  を必要もないのに呼び出した"
"り、不適切な場面 (例えば、他のスケジューリング 対象となるスレッドが必要とする"
"リソースを呼び出し元が保持したままの状態)  で呼び出したりするのは避けること。"
"なぜなら、 B<sched_yield>()  の呼び出しより不必要なコンテキストスイッチが起こ"
"り、システム性能が 劣化する結果になるからである。"

#. type: Plain text
#: build/C/man2/sched_yield.2:90
msgid ""
"B<sched_yield>()  is intended for use with real-time scheduling policies (i."
"e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<sched_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""

#. type: TH
#: build/C/man7/sched.7:32
#, no-wrap
msgid "SCHED"
msgstr "SCHED"

#. type: TH
#: build/C/man7/sched.7:32
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: build/C/man7/sched.7:35
msgid "sched - overview of CPU scheduling"
msgstr "sched - CPU スケジューリングの概要"

#. type: Plain text
#: build/C/man7/sched.7:40
msgid ""
"Since Linux 2.6.23, the default scheduler is CFS, the \"Completely Fair "
"Scheduler\".  The CFS scheduler replaced the earlier \"O(1)\" scheduler."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:40
#, no-wrap
msgid "API summary"
msgstr "API の概要"

#. type: Plain text
#: build/C/man7/sched.7:44
msgid ""
"Linux provides the following system calls for controlling the CPU scheduling "
"behavior, policy, and priority of processes (or, more precisely, threads)."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:44
#, no-wrap
msgid "B<nice>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:48
msgid ""
"Set a new nice value for the calling thread, and return the new nice value."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:48
#, no-wrap
msgid "B<getpriority>(2)"
msgstr " B<getpriority>(2)"

#. type: Plain text
#: build/C/man7/sched.7:52
msgid ""
"Return the nice value of a thread, a process group, or the set of threads "
"owned by a specified user."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:52
#, no-wrap
msgid "B<setpriority>(2)"
msgstr " B<setpriority>(2)"

#. type: Plain text
#: build/C/man7/sched.7:56
msgid ""
"Set the nice value of a thread, a process group, or the set of threads owned "
"by a specified user."
msgstr ""

#. type: TP
#: build/C/man7/sched.7:56
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr "B<sched_setscheduler>(2)"

#. type: Plain text
#: build/C/man7/sched.7:59
msgid "Set the scheduling policy and parameters of a specified thread."
msgstr "指定されたスレッドのスケジューリングポリシーとパラメーターを設定する。"

#. type: TP
#: build/C/man7/sched.7:59
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr "B<sched_getscheduler>(2)"

#. type: Plain text
#: build/C/man7/sched.7:62
msgid "Return the scheduling policy of a specified thread."
msgstr "指定されたスレッドのスケジューリングポリシーを返す。"

#. type: TP
#: build/C/man7/sched.7:62
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr "B<sched_setparam>(2)"

#. type: Plain text
#: build/C/man7/sched.7:65
msgid "Set the scheduling parameters of a specified thread."
msgstr "指定されたスレッドのスケジューリングパラメーターを設定する。"

#. type: TP
#: build/C/man7/sched.7:65
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr "B<sched_getparam>(2)"

#. type: Plain text
#: build/C/man7/sched.7:68
msgid "Fetch the scheduling parameters of a specified thread."
msgstr "指定されたスレッドのスケジューリングパラメーターを取得する。"

#. type: TP
#: build/C/man7/sched.7:68
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr "B<sched_get_priority_max>(2)"

#. type: Plain text
#: build/C/man7/sched.7:71
msgid "Return the maximum priority available in a specified scheduling policy."
msgstr "指定されたスケジューリングポリシーで利用可能な最大の優先度を返す。"

#. type: TP
#: build/C/man7/sched.7:71
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr "B<sched_get_priority_min>(2)"

#. type: Plain text
#: build/C/man7/sched.7:74
msgid "Return the minimum priority available in a specified scheduling policy."
msgstr "指定されたスケジューリングポリシーで利用可能な最小の優先度を返す。"

#. type: TP
#: build/C/man7/sched.7:74
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr "B<sched_rr_get_interval>(2)"

#. type: Plain text
#: build/C/man7/sched.7:78
msgid ""
"Fetch the quantum used for threads that are scheduled under the \"round-robin"
"\" scheduling policy."
msgstr ""
"「ラウンドロビン」スケジューリングポリシーでスケジューリグされるスレッドで使"
"用される単位時間 (quantum) を取得する。"

#. type: TP
#: build/C/man7/sched.7:78
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr "B<sched_yield>(2)"

#. type: Plain text
#: build/C/man7/sched.7:82
msgid ""
"Cause the caller to relinquish the CPU, so that some other thread be "
"executed."
msgstr ""
"呼び出し元が CPU の使用権を明け渡して、 他のスレッドが実行できるようにする。"

#. type: TP
#: build/C/man7/sched.7:82
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr "B<sched_setaffinity>(2)"

#. type: Plain text
#: build/C/man7/sched.7:86
msgid "(Linux-specific)  Set the CPU affinity of a specified thread."
msgstr "(Linux 固有) 指定されたスレッドの CPU affinity を設定する。"

#. type: TP
#: build/C/man7/sched.7:86
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr "B<sched_getaffinity>(2)"

#. type: Plain text
#: build/C/man7/sched.7:90
msgid "(Linux-specific)  Get the CPU affinity of a specified thread."
msgstr "(Linux 固有) 指定されたスレッドの CPU affinity を取得する。"

#. type: TP
#: build/C/man7/sched.7:90
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr "B<sched_setattr>(2)"

#. type: Plain text
#: build/C/man7/sched.7:97
msgid ""
"Set the scheduling policy and parameters of a specified thread.  This (Linux-"
"specific) system call provides a superset of the functionality of "
"B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""
"指定されたスレッドのスケジューリングポリシーとパラメーターを設定する。 この "
"(Linux 固有の) システムコールは B<sched_setscheduler>(2) と "
"B<sched_setparam>(2) の両方の機能を持つ。"

#. type: TP
#: build/C/man7/sched.7:97
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr "B<sched_getattr>(2)"

#. type: Plain text
#: build/C/man7/sched.7:105
msgid ""
"Fetch the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_getscheduler>(2)  and B<sched_getparam>(2)."
msgstr ""
"指定されたスレッドのスケジューリングポリシーとパラメーターを取得する。 この "
"(Linux 固有の) システムコールは B<sched_getscheduler>(2) と "
"B<sched_getparam>(2) の両方の機能を持つ。"

#. type: SS
#: build/C/man7/sched.7:105
#, no-wrap
msgid "Scheduling policies"
msgstr "スケジューリングポリシー (scheduling policy)"

#. type: Plain text
#: build/C/man7/sched.7:113
msgid ""
"The scheduler is the kernel component that decides which runnable thread "
"will be executed by the CPU next.  Each thread has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>.  The "
"scheduler makes its decisions based on knowledge of the scheduling policy "
"and static priority of all threads on the system."
msgstr ""
"スケジューラ (scheduler) とはカーネルの構成要素で、 次に CPU で実行される実行"
"可能なスレッドを決定するものである。 各々のスレッドには、スケジューリングポリ"
"シーと 「静的」なスケジューリング優先度 I<sched_priority> が対応付けられる。 "
"スケジューラは、システム上の全スレッドのスケジューリングポリシーと 静的優先度"
"に関する知識に基づいて決定を行う。"

#. type: Plain text
#: build/C/man7/sched.7:118
msgid ""
"For threads scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""
"通常のスケジューリングポリシー (B<SCHED_OTHER>, B<SCHED_IDLE>, "
"B<SCHED_BATCH>)  の下でスケジューリングされるスレッドでは、 "
"I<sched_priority> はスケジューリングの決定に使用されない (I<sched_priority> "
"には 0 を指定しなければならない)。"

#. type: Plain text
#: build/C/man7/sched.7:132
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time threads always have higher "
"priority than normal threads.)  Note well: POSIX.1 requires an "
"implementation to support only a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr "リアルタイムスケジューリングポリシー (B<SCHED_FIFO>, B<SCHED_RR>)  の下でスケジューリングされるスレッドは、 I<sched_priority> の値は 1 (最低) から 99 (最高) の範囲となる (数字から分かるように、リアルタイムスレッドは常に通常のスレッドよりも 高い優先度を持つ)。 ここで注意すべきなのは、POSIX.1 が要求しているのは、 リアルタイムポリシーの実装において最低 32 種類の異なる優先度レベルが サポートされることだけであり、いくつかのシステムではこの最低限の数の 優先度しか提供されていない、ということである。 移植性が必要なプログラムでは、 B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  を使って、あるポリシーがサポートする優先度の範囲を調べるべきである。"

#. type: Plain text
#: build/C/man7/sched.7:138
msgid ""
"Conceptually, the scheduler maintains a list of runnable threads for each "
"possible I<sched_priority> value.  In order to determine which thread runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the thread at the head of this list."
msgstr ""
"概念としては、 スケジューラはその I<sched_priority> の値それぞれに対して 実行"
"可能なスレッドのリストを管理している。 どのスレッドを次に実行するかを決定する"
"ために、 スケジューラは静的優先度の最も高い空でないリストを探して、 そのリス"
"トの先頭のスレッドを選択する。"

#. type: Plain text
#: build/C/man7/sched.7:142
msgid ""
"A thread's scheduling policy determines where it will be inserted into the "
"list of threads with equal static priority and how it will move inside this "
"list."
msgstr ""
"各スレッドのスケジューリングポリシーは、 そのスレッドが同じ静的優先度を持つス"
"レッドのリストの中のどこに挿入され、 このリストの中をどのように移動するかを決"
"定する。"

#. type: Plain text
#: build/C/man7/sched.7:150
msgid ""
"All scheduling is preemptive: if a thread with a higher static priority "
"becomes ready to run, the currently running thread will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable threads with "
"equal static priority."
msgstr ""
"全てのスケジューリングはプリエンプティブ (preemptive) である: より高い優先度"
"のスレッドが実行可能になると、現在実行中のスレッドは実行権を 取り上げられ "
"(preempted)、そのスレッドの静的優先度レベルの待ちリストに 戻される。スケ"
"ジューリングポリシーは同じ静的優先度を持つ実行可能な スレッドのリストの中で順"
"番のみを決定する。"

#. type: SS
#: build/C/man7/sched.7:150
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr "SCHED_FIFO: ファーストインファーストアウトスケジューリング"

#. type: Plain text
#: build/C/man7/sched.7:159
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> thread becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> thread.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For threads scheduled under the B<SCHED_FIFO> policy, "
"the following rules apply:"
msgstr ""
"B<SCHED_FIFO> は 0 より大きな静的優先度でのみ使用できる。このポリシーでは、 "
"B<SCHED_FIFO> スレッドが実行可能になった場合、 そのポリシーが "
"B<SCHED_OTHER>、 B<SCHED_BATCH>、 B<SCHED_IDLE> の 現在実行中のスレッドは直ち"
"に実行権を取り上げられる。 B<SCHED_FIFO> は時分割のない単純なスケジューリング"
"アルゴリズムである。 B<SCHED_FIFO> ポリシーでスケジューリングされているスレッ"
"ドには以下の ルールが適用される:"

#. type: IP
#: build/C/man7/sched.7:159
#, no-wrap
msgid "1)"
msgstr " 1)"

#. type: Plain text
#: build/C/man7/sched.7:164
msgid ""
"A running B<SCHED_FIFO> thread that has been preempted by another thread of "
"higher priority will stay at the head of the list for its priority and will "
"resume execution as soon as all threads of higher priority are blocked again."
msgstr "より高い優先度の他のスレッドによって取って代わられた実行中の B<SCHED_FIFO> スレッドはその優先度のリストの先頭に留まり続け、 より高い優先度のスレッド全てが停止 (block) した場合に実行を再開する。"

#. type: IP
#: build/C/man7/sched.7:164
#, no-wrap
msgid "2)"
msgstr " 2)"

#. type: Plain text
#: build/C/man7/sched.7:167
msgid ""
"When a blocked B<SCHED_FIFO> thread becomes runnable, it will be inserted at "
"the end of the list for its priority."
msgstr "停止された B<SCHED_FIFO> スレッドが実行可能になった時、その優先度のリストの最後 に挿入される。"

#. type: IP
#: build/C/man7/sched.7:167
#, no-wrap
msgid "3)"
msgstr " 3)"

#. type: Plain text
#: build/C/man7/sched.7:181
msgid ""
"If a call to B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_setattr>(2), B<pthread_setschedparam>(3), or "
"B<pthread_setschedprio>(3)  changes the priority of the running or runnable "
"B<SCHED_FIFO> thread identified by I<pid> the effect on the thread's "
"position in the list depends on the direction of the change to threads "
"priority:"
msgstr ""

#. type: IP
#: build/C/man7/sched.7:182 build/C/man7/sched.7:187 build/C/man7/sched.7:190
#: build/C/man2/setns.2:25 build/C/man2/setns.2:29
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:187
msgid ""
"If the thread's priority is raised, it is placed at the end of the list for "
"its new priority.  As a consequence, it may preempt a currently running "
"thread with the same priority."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:190
msgid ""
"If the thread's priority is unchanged, its position in the run list is "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:193
#, fuzzy
#| msgid ""
#| "When a B<SCHED_FIFO> thread becomes runnable, it will be inserted at the "
#| "end of the list for its priority."
msgid ""
"If the thread's priority is lowered, it is placed at the front of the list "
"for its new priority."
msgstr ""
"B<SCHED_FIFO> スレッドが実行可能になった時、その優先度のリストの最後 に挿入さ"
"れる。"

#.  In 2.2.x and 2.4.x, the thread is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
#. type: Plain text
#: build/C/man7/sched.7:202
msgid ""
"According to POSIX.1-2008, changes to a thread's priority (or policy) using "
"any mechanism other than B<pthread_setschedprio>(3)  should result in the "
"thread being placed at the end of the list for its priority."
msgstr ""

#. type: IP
#: build/C/man7/sched.7:202
#, no-wrap
msgid "4)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:206
msgid "A thread calling B<sched_yield>(2)  will be put at the end of the list."
msgstr "B<sched_yield>(2)  を呼び出したスレッドはリストの最後に置かれる。"

#. type: Plain text
#: build/C/man7/sched.7:210
msgid ""
"No other events will move a thread scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable threads with equal static priority."
msgstr ""
"その他のイベントによって B<SCHED_FIFO> ポリシーでスケジューリングされるスレッ"
"ドが同じ優先度の実行可能なスレッドの待ちリストの中を移動することはない。"

#. type: Plain text
#: build/C/man7/sched.7:215
msgid ""
"A B<SCHED_FIFO> thread runs until either it is blocked by an I/O request, it "
"is preempted by a higher priority thread, or it calls B<sched_yield>(2)."
msgstr ""
"B<SCHED_FIFO> スレッドは I/O 要求によって停止するか、 より高い優先度のスレッ"
"ドによって置きかえられるか、 B<sched_yield>(2)  を呼び出すまで実行を続ける。"

#. type: SS
#: build/C/man7/sched.7:215
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr "SCHED_RR: ラウンドロビン (round-robin) スケジューリング"

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man7/sched.7:234
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each thread "
"is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> thread "
"has been running for a time period equal to or longer than the time quantum, "
"it will be put at the end of the list for its priority.  A B<SCHED_RR> "
"thread that has been preempted by a higher priority thread and subsequently "
"resumes execution as a running thread will complete the unexpired portion of "
"its round-robin time quantum.  The length of the time quantum can be "
"retrieved using B<sched_rr_get_interval>(2)."
msgstr ""
"B<SCHED_RR> は B<SCHED_FIFO> の単純な拡張である。 上述された\n"
"B<SCHED_FIFO> に関する記述は全て B<SCHED_RR> に 適用できる。異なるのは\n"
"それぞれのスレッドは最大時間単位までしか実行できない ということである。\n"
"B<SCHED_RR> スレッドが時間単位と同じかそれより 長い時間実行されると、\n"
"その優先度のリストの最後に置かれる。 より高い優先度のスレッドによって\n"
"置きかえられ、その後実行を再開した B<SCHED_RR> スレッドは、そのラウンド\n"
"ロビン時間単位を完全に使い切る まで実行される。その時間単位の長さは\n"
"B<sched_rr_get_interval>(2) を使って取得できる。"

#. type: SS
#: build/C/man7/sched.7:234
#, no-wrap
msgid "SCHED_DEADLINE: Sporadic task model deadline scheduling"
msgstr "SCHED_DEADLINE: 散発タスクモデルのデッドラインスケジューリング"

#. type: Plain text
#: build/C/man7/sched.7:246
msgid ""
"Since version 3.14, Linux provides a deadline scheduling policy "
"(B<SCHED_DEADLINE>).  This policy is currently implemented using GEDF "
"(Global Earliest Deadline First)  in conjunction with CBS (Constant "
"Bandwidth Server).  To set and fetch this policy and associated attributes, "
"one must use the Linux-specific B<sched_setattr>(2)  and "
"B<sched_getattr>(2)  system calls."
msgstr ""
"バージョン 3.14 以降では、 Linux はデッドラインスケジューリングポリシー "
"(B<SCHED_DEADLINE>) が提供される。 現在のところ、 このポリシーは GEDF "
"(Global Earliest Deadline First) を使って CBS (Constant Bandwidth Server) と"
"の組み合わせで実装されている。 このポリシーと関連する属性の設定、取得を行うに"
"は、 Linux 固有のシステムコール B<sched_setattr>(2) と B<sched_getattr>(2) を"
"使用する必要がある。"

#. type: Plain text
#: build/C/man7/sched.7:264
msgid ""
"A sporadic task is one that has a sequence of jobs, where each job is "
"activated at most once per period.  Each job also has a I<relative "
"deadline>, before which it should finish execution, and a I<computation "
"time>, which is the CPU time necessary for executing the job.  The moment "
"when a task wakes up because a new job has to be executed is called the "
"I<arrival time> (also referred to as the request time or release time).  The "
"I<start time> is the time at which a task starts its execution.  The "
"I<absolute deadline> is thus obtained by adding the relative deadline to the "
"arrival time."
msgstr ""
"散発タスク (sporadic task) はジョブ列を持つタスクで、 各ジョブは期間 "
"(period) あたり多くとも 1 回だけ有効化される。 各ジョブには I<relative "
"deadline> (相対デッドライン) と I<computation time> (計算時間) がある。 相対"
"デッドラインは、そのジョブがそのデッドラインより前に実行が終了すべきであるこ"
"とを示す。 計算時間は、このジョブを実行するのに必要な CPU 時間である。 新しい"
"ジョブを実行する必要が出てタスクが起こされる時点は I<arrival time> (到着時"
"刻) と呼ばれる (要求時刻 (request time) や解放時刻 (release time) と呼ばれる"
"こともある)。 I<start time> はタスクが実行を開始する時刻である。 したがっ"
"て、 I<absolute deadline> (絶対デッドライン) は到着時刻に相対デッドラインを加"
"算することで求められる。"

#. type: Plain text
#: build/C/man7/sched.7:266
msgid "The following diagram clarifies these terms:"
msgstr "以下の図はこれらの用語をまとめたものである。"

#. type: Plain text
#: build/C/man7/sched.7:277
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- relative deadline ------E<gt>|\n"
"     |E<lt>-------------- period -------------------E<gt>|\n"
msgstr ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- relative deadline ------E<gt>|\n"
"     |E<lt>-------------- period -------------------E<gt>|\n"

#. type: Plain text
#: build/C/man7/sched.7:296
msgid ""
"When setting a B<SCHED_DEADLINE> policy for a thread using "
"B<sched_setattr>(2), one can specify three parameters: I<Runtime>, "
"I<Deadline>, and I<Period>.  These parameters do not necessarily correspond "
"to the aforementioned terms: usual practice is to set Runtime to something "
"bigger than the average computation time (or worst-case execution time for "
"hard real-time tasks), Deadline to the relative deadline, and Period to the "
"period of the task.  Thus, for B<SCHED_DEADLINE> scheduling, we have:"
msgstr ""
"B<sched_setattr>(2) を使ってスレッドに B<SCHED_DEADLINE> ポリシーを設定する"
"際、 I<Runtime>, I<Deadline>, I<Period> の 3 つのパラメーターを指定することが"
"できる。 これらのパラメーターは必ずしも上で述べた用語に対応しているわけではな"
"い。 よくある方法としては、 Runtime に平均計算時間 (もしくはハードリアルタイ"
"ムタスクの場合は最悪ケースの実行時間) よりも大きな値を、 Deadline に相対デッ"
"ドラインを、 Period にタスクの期間 (period) を設定する。 したがって、 "
"B<SCHED_DEADLINE> スケジューリングでは、 以下のようになる。"

#. type: Plain text
#: build/C/man7/sched.7:307
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"
msgstr ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"

#.  FIXME It looks as though specifying sched_period as 0 means
#.  "make sched_period the same as sched_deadline".
#.  This needs to be documented.
#. type: Plain text
#: build/C/man7/sched.7:327
msgid ""
"The three deadline-scheduling parameters correspond to the I<sched_runtime>, "
"I<sched_deadline>, and I<sched_period> fields of the I<sched_attr> "
"structure; see B<sched_setattr>(2).  These fields express values in "
"nanoseconds.  If I<sched_period> is specified as 0, then it is made the same "
"as I<sched_deadline>."
msgstr ""
"3 つのデッドラインスケジューリングパラメーターは I<sched_attr> 構造体の "
"I<sched_runtime>, I<sched_deadline>, I<sched_period> フィールドに対応する。 "
"これらのフィールドはナノ秒単位の値である。 I<sched_period> に 0 が指定された"
"場合 I<sched_deadline> と同じ値になる。"

#. type: Plain text
#: build/C/man7/sched.7:329
msgid "The kernel requires that:"
msgstr "カーネルでは以下の関係が成り立つことが求められる。"

#. type: Plain text
#: build/C/man7/sched.7:331
#, no-wrap
msgid "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"
msgstr "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"

#.  See __checkparam_dl in kernel/sched/core.c
#. type: Plain text
#: build/C/man7/sched.7:341
msgid ""
"In addition, under the current implementation, all of the parameter values "
"must be at least 1024 (i.e., just over one microsecond, which is the "
"resolution of the implementation), and less than 2^63.  If any of these "
"checks fails, B<sched_setattr>(2)  fails with the error B<EINVAL>."
msgstr ""
"これに加えて、 現在の実装では、 すべてのパラメーター値は少なくとも 1024 (実装"
"の粒度である 1 マイクロ秒よりも少しだけ大きな値) で 2^63 よりも小さくなければ"
"ならない。 これらのチェックのいずれかが失敗すると、 B<sched_setattr>(2) はエ"
"ラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man7/sched.7:344
msgid ""
"The CBS guarantees non-interference between tasks, by throttling threads "
"that attempt to over-run their specified Runtime."
msgstr ""
"CBS によりタスク間の干渉がないことが保証される。 指定された Runtime を超えて"
"実行しようとしたスレッドは絞り込まれることになる。"

#. type: Plain text
#: build/C/man7/sched.7:357
msgid ""
"To ensure deadline scheduling guarantees, the kernel must prevent situations "
"where the set of B<SCHED_DEADLINE> threads is not feasible (schedulable) "
"within the given constraints.  The kernel thus performs an admittance test "
"when setting or changing B<SCHED_DEADLINE> policy and attributes.  This "
"admission test calculates whether the change is feasible; if it is not, "
"B<sched_setattr>(2)  fails with the error B<EBUSY>."
msgstr ""
"デッドラインスケジューリングの保証がきちんと機能するためには、 カーネルは "
"B<SCHEDULING> スレッドの集合が指定された制約条件におさまらない (スケジューリ"
"ングできない) 状況を防止しなければならない。 そのため、カーネルは "
"B<SCHED_DEADLINE> ポリシーと属性を設定、変更する際に、受け入れチェック "
"(admittance test) を実行する。 この受け入れチェックは、変更が実行可能かを計算"
"し、もし実行できないようであれば B<sched_setattr>(2) はエラー B<EBUSY> で失敗"
"する。"

#. type: Plain text
#: build/C/man7/sched.7:363
msgid ""
"For example, it is required (but not necessarily sufficient) for the total "
"utilization to be less than or equal to the total number of CPUs available, "
"where, since each thread can maximally run for Runtime per Period, that "
"thread's utilization is its Runtime divided by its Period."
msgstr ""
"例えば、 使用率の合計が利用可能な合計 CPU 数以下である必要がある (ただし、必"
"ずしも十分というわけではない)。 なお、 各スレッドは最大で Period あたり "
"Runtime だけ実行されることがあるので、 そのスレッドの使用率は Runtime を "
"Period で割ったものとなる。"

#. type: Plain text
#: build/C/man7/sched.7:374
msgid ""
"In order to fulfill the guarantees that are made when a thread is admitted "
"to the B<SCHED_DEADLINE> policy, B<SCHED_DEADLINE> threads are the highest "
"priority (user controllable) threads in the system; if any B<SCHED_DEADLINE> "
"thread is runnable, it will preempt any thread scheduled under one of the "
"other policies."
msgstr ""
"スレッドが B<SCHED_DEADLINE> ポリシーに受け入れられた場合に保証を実現するた"
"め、 B<SCHED_DEADLINE> スレッドはシステムで (ユーザーが制御可能な) 最高優先度"
"のスレッドとなる。 いずれかの B<SCHED_DEADLINE> スレッドが実行可能であれば、 "
"他のポリシーでスケジューリングされているスレッドはすべて横取りされる。"

#. type: Plain text
#: build/C/man7/sched.7:382
msgid ""
"A call to B<fork>(2)  by a thread scheduled under the B<SCHED_DEADLINE> "
"policy fails with the error B<EAGAIN>, unless the thread has its reset-on-"
"fork flag set (see below)."
msgstr ""
"B<SCHED_DEADLINE> ポリシーでスケジューリングされているスレッドが B<fork>(2) "
"を呼び出すと、 そのスレッドで reset-on-fork フラグがセットされている場合 (下"
"記参照) を除き、 エラー B<EAGAIN> で失敗する。"

#
#.  FIXME Calling sched_getparam() on a SCHED_DEADLINE thread
#.  fails with EINVAL, but sched_getscheduler() succeeds.
#.  Is that intended? (Why?)
#. type: Plain text
#: build/C/man7/sched.7:393
msgid ""
"A B<SCHED_DEADLINE> thread that calls B<sched_yield>(2)  will yield the "
"current job and wait for a new period to begin."
msgstr ""
"B<SCHED_DEADLINE> スレッドが B<sched_yield>(2) を呼び出すと、 現在のジョブが "
"CPU を明け渡し、新しい期間が開始するのを待つ。"

#. type: SS
#: build/C/man7/sched.7:393
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr "SCHED_OTHER: Linux のデフォルトの時分割スケジューリング"

#. type: Plain text
#: build/C/man7/sched.7:401
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0 (i.e., threads under "
"real-time policies always have priority over B<SCHED_OTHER> processes).  "
"B<SCHED_OTHER> is the standard Linux time-sharing scheduler that is intended "
"for all threads that do not require the special real-time mechanisms."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:409
#, fuzzy
#| msgid ""
#| "B<SCHED_OTHER> can be used at only static priority 0.  B<SCHED_OTHER> is "
#| "the standard Linux time-sharing scheduler that is intended for all "
#| "threads that do not require the special real-time mechanisms.  The thread "
#| "to run is chosen from the static priority 0 list based on a I<dynamic> "
#| "priority that is determined only inside this list.  The dynamic priority "
#| "is based on the nice value (set by B<nice>(2), B<setpriority>(2), or "
#| "B<sched_setattr>(2))  and increased for each time quantum the thread is "
#| "ready to run, but denied to run by the scheduler.  This ensures fair "
#| "progress among all B<SCHED_OTHER> threads."
msgid ""
"The thread to run is chosen from the static priority 0 list based on a "
"I<dynamic> priority that is determined only inside this list.  The dynamic "
"priority is based on the nice value (see below)  and is increased for each "
"time quantum the thread is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> threads."
msgstr ""
"B<SCHED_OTHER> は静的優先度 0 でのみ使用できる。 B<SCHED_OTHER> は Linux 標準"
"の時分割スケジューラで、 特別なリアルタイム機構を必要としていない全てのスレッ"
"ドで使用される。 実行するスレッドは、静的優先度 0 のリストから、このリストの"
"中だけで 決定される「動的な」優先度 (dynamic priority) に基いて決定される。 "
"動的な優先度は (B<nice>(2), B<setpriority>(2), B<sched_setattr>(2) により設定"
"される) nice 値に基づいて決定されるもので、 単位時間毎に、スレッドが実行可能"
"だが、スケジューラにより実行が拒否された 場合にインクリメントされる。 これに"
"より、全ての B<SCHED_OTHER> スレッドでの公平性が保証される。"

#. type: Plain text
#: build/C/man7/sched.7:415
msgid ""
"In the Linux kernel source code, the B<SCHED_OTHER> policy is actually named "
"B<SCHED_NORMAL>."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:415
#, no-wrap
msgid "The nice value"
msgstr "nice 値"

#. type: Plain text
#: build/C/man7/sched.7:429
msgid ""
"The nice value is an attribute that can be used to influence the CPU "
"scheduler to favor or disfavor a process in scheduling decisions.  It "
"affects the scheduling of B<SCHED_OTHER> and B<SCHED_BATCH> (see below) "
"processes.  The nice value can be modified using B<nice>(2), "
"B<setpriority>(2), or B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:434
msgid ""
"According to POSIX.1, the nice value is a per-process attribute; that is, "
"the threads in a process should share a nice value.  However, on Linux, the "
"nice value is a per-thread attribute: different threads in the same process "
"may have different nice values."
msgstr ""

#.  Linux before 1.3.36 had \-infinity..15.
#.  Since kernel 1.3.43, Linux has the range \-20..19.
#. type: Plain text
#: build/C/man7/sched.7:442
msgid ""
"The range of the nice value varies across UNIX systems.  On modern Linux, "
"the range is -20 (high priority) to +19 (low priority).  On some other "
"systems, the range is -20..20.  Very early Linux kernels (Before Linux 2.0) "
"had the range -infinity..15."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:447
msgid ""
"The degree to which the nice value affects the relative scheduling of "
"B<SCHED_OTHER> processes likewise varies across UNIX systems and across "
"Linux kernel versions."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:459
msgid ""
"With the advent of the CFS scheduler in kernel 2.6.23, Linux adopted an "
"algorithm that causes relative differences in nice values to have a much "
"stronger effect.  In the current implementation, each unit of difference in "
"the nice values of two processes results in a factor of 1.25 in the degree "
"to which the scheduler favors the higher priority process.  This causes very "
"low nice values (+19) to truly provide little CPU to a process whenever "
"there is any other higher priority load on the system, and makes high nice "
"values (-20) deliver most of the CPU to applications that require it (e.g., "
"some audio applications)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:466
msgid ""
"On Linux, the B<RLIMIT_NICE> resource limit can be used to define a limit to "
"which an unprivileged process's nice value can be raised; see "
"B<setrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:470
msgid ""
"For further details on the nice value, see the subsections on the autogroup "
"feature and group scheduling, below."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:470
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr "SCHED_BATCH: バッチプロセスのスケジューリング"

#. type: Plain text
#: build/C/man7/sched.7:482
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the thread "
"according to its dynamic priority (based on the nice value).  The difference "
"is that this policy will cause the scheduler to always assume that the "
"thread is CPU-intensive.  Consequently, the scheduler will apply a small "
"scheduling penalty with respect to wakeup behavior, so that this thread is "
"mildly disfavored in scheduling decisions."
msgstr ""
"(Linux 2.6.16 以降)  B<SCHED_BATCH> は静的優先度 0 でのみ使用できる。 このポ"
"リシーは (nice 値に基づく) 動的な優先度にしたがってスレッドの スケジューリン"
"グが行われるという点で、B<SCHED_OTHER> に似ている。 異なるのは、このポリシー"
"では、スレッドが常に CPU に負荷のかかる (CPU-intensive)  処理を行うと、スケ"
"ジューラが仮定する点である。 スケジューラはスレッドを呼び起こす毎にそのスレッ"
"ドにスケジューリング上の ペナルティを少し課し、その結果、このスレッドはスケ"
"ジューリングの決定で 若干冷遇されるようになる。"

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#.  commit b0a9499c3dd50d333e2aedb7e894873c58da3785
#. type: Plain text
#: build/C/man7/sched.7:492
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""
"このポリシーは、非対話的な処理だがその nice 値を下げたくない処理や、 (処理の"
"タスク間で) 余計なタスクの置き換えの原因とある対話的な処理なしで 確定的な "
"(deterministic) スケジューリングポリシーを適用したい処理に 対して有効である。"

#. type: SS
#: build/C/man7/sched.7:492
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr "SCHED_IDLE: 非常に優先度の低いジョブのスケジューリング"

#. type: Plain text
#: build/C/man7/sched.7:496
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""
"(Linux 2.6.23 以降)  B<SCHED_IDLE> は静的優先度 0 でのみ使用できる。 このポリ"
"シーではプロセスの nice 値はスケジューリングに影響を与えない。"

#. type: Plain text
#: build/C/man7/sched.7:504
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""
"非常に低い優先度でのジョブの実行を目的としたものである (非常に低い優先度と"
"は、ポリシー B<SCHED_OTHER> か B<SCHED_BATCH> での nice 値 +19 よりさらに低い"
"優先度である)。"

#. type: SS
#: build/C/man7/sched.7:504
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr "子プロセスでのスケジューリングポリシーのリセット"

#. type: Plain text
#: build/C/man7/sched.7:510
msgid ""
"Each thread has a reset-on-fork scheduling flag.  When this flag is set, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  The reset-on-fork flag can be set by either:"
msgstr ""
"各スレッドには reset-on-fork スケジューリングフラグがある。 このフラグがセッ"
"トされると、 B<fork>(2) で作成される子プロセスは特権スケジューリングポリシー"
"を継承しない。 reset-on-fork フラグは以下のいずれかの方法でセットできる。"

#. type: Plain text
#: build/C/man7/sched.7:519
msgid ""
"ORing the B<SCHED_RESET_ON_FORK> flag into the I<policy> argument when "
"calling B<sched_setscheduler>(2)  (since Linux 2.6.32); or"
msgstr ""
"B<sched_setscheduler>(2) を呼び出す際に B<SCHED_RESET_ON_FORK> フラグを "
"I<policy> 引数に論理和で指定する (Linux 2.6.32 以降)。"

#. type: Plain text
#: build/C/man7/sched.7:526
msgid ""
"specifying the B<SCHED_FLAG_RESET_ON_FORK> flag in I<attr.sched_flags> when "
"calling B<sched_setattr>(2)."
msgstr ""
"B<sched_setattr>(2) を呼び出し際に I<attr.sched_flags> に "
"B<SCHED_FLAG_RESET_ON_FORK> フラグを指定する。"

#. type: Plain text
#: build/C/man7/sched.7:532
msgid ""
"Note that the constants used with these two APIs have different names.  The "
"state of the reset-on-fork flag can analogously be retrieved using "
"B<sched_getscheduler>(2)  and B<sched_getattr>(2)."
msgstr ""
"これらの 2 つの API で使用される定数は名前が違っている点に注意すること。 同様"
"に reset-on-fork フラグの状態は B<sched_getscheduler>(2) と "
"B<sched_getattr>(2) を使って取得できる。"

#. type: Plain text
#: build/C/man7/sched.7:539
msgid ""
"The reset-on-fork feature is intended for media-playback applications, and "
"can be used to prevent applications evading the B<RLIMIT_RTTIME> resource "
"limit (see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""
"reset-on-fork 機能はメディア再生アプリケーションでの利用を意図したものであ"
"る。 複数の子プロセスを作成することで、 アプリケーションは B<RLIMIT_RTTIME> "
"リソース上限 (B<getrlimit>(2) を参照) を避けることができる。"

#. type: Plain text
#: build/C/man7/sched.7:542
msgid ""
"More precisely, if the reset-on-fork flag is set, the following rules apply "
"for subsequently created children:"
msgstr ""
"より正確には、 reset-on-fork フラグがセットされた場合、それ以降に作成される子"
"プロセスに以下のルールが適用される。"

#. type: Plain text
#: build/C/man7/sched.7:550
msgid ""
"If the calling thread has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""
"呼び出したスレッドのスケジューリングポリシーが B<SCHED_FIFO> か B<SCHED_RR> "
"の場合、子プロセスのポリシーは B<SCHED_OTHER> にリセットされる。"

#. type: Plain text
#: build/C/man7/sched.7:553
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""
"子プロセスが負の nice 値を持っている場合、子プロセスの nice 値は 0 にリセット"
"される。"

#. type: Plain text
#: build/C/man7/sched.7:561
msgid ""
"After the reset-on-fork flag has been enabled, it can be reset only if the "
"thread has the B<CAP_SYS_NICE> capability.  This flag is disabled in child "
"processes created by B<fork>(2)."
msgstr ""
"一度 reset-on-fork フラグが有効にされた後は、このフラグをリセットできるのは、"
"スレッドが B<CAP_SYS_NICE> ケーパビリティを持つ場合だけである。このフラグは "
"B<fork>(2) で作成された子プロセスでは無効になる。"

#. type: SS
#: build/C/man7/sched.7:561
#, no-wrap
msgid "Privileges and resource limits"
msgstr "特権とリソース制限"

#. type: Plain text
#: build/C/man7/sched.7:573
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  threads "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged thread can make is to set the "
"B<SCHED_OTHER> policy, and this can be done only if the effective user ID of "
"the caller matches the real or effective user ID of the target thread (i.e., "
"the thread specified by I<pid>)  whose policy is being changed."
msgstr ""
"2.6.12 より前のバージョンの Linux カーネルでは、 特権スレッド "
"(B<CAP_SYS_NICE> ケーパビリティを持つスレッド) だけが 0 以外の静的優先度を設"
"定する (すなわち、リアルタイムスケジューリングポリシーを設定する) ことができ"
"る。 非特権スレッドができる変更は B<SCHED_OTHER> ポリシーを設定することだけで"
"あり、さらに、 この変更を行えるのは、 呼び出し元の実効ユーザー ID がポリシー"
"の変更対象スレッド (I<pid> で指定されたスレッド) の実ユーザー ID か実効ユー"
"ザー ID と 一致する場合だけである。"

#. type: Plain text
#: build/C/man7/sched.7:579
msgid ""
"A thread must be privileged (B<CAP_SYS_NICE>)  in order to set or modify a "
"B<SCHED_DEADLINE> policy."
msgstr ""
"B<SCHED_DEADLINE> ポリシーを設定、変更するには、スレッドが特権 "
"(B<CAP_SYS_NICE>) を持っていなければならない。"

#. type: Plain text
#: build/C/man7/sched.7:589
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged thread's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""
"Linux 2.6.12 以降では、リソース制限 B<RLIMIT_RTPRIO> が定義されており、 スケ"
"ジューリングポリシーが B<SCHED_RR> と B<SCHED_FIFO> の場合の、非特権スレッド"
"の静的優先度の上限を定めている。 スケジューリングポリシーと優先度を変更する際"
"のルールは以下の通りである。"

#. type: Plain text
#: build/C/man7/sched.7:597
msgid ""
"If an unprivileged thread has a nonzero B<RLIMIT_RTPRIO> soft limit, then it "
"can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""
"非特権スレッドに 0 以外の B<RLIMIT_RTPRIO> ソフトリミットが設定されている場"
"合、 非特権スレッドはそのスレッドのスケジューリングポリシーと優先度を 変更で"
"きるが、優先度を現在の自身の優先度と B<RLIMIT_RTPRIO> ソフトリミットの大きい"
"方よりも高い値に設定できないという制限が課される。"

#. type: Plain text
#: build/C/man7/sched.7:602
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""
"B<RLIMIT_RTPRIO> ソフトリミットが 0 の場合、優先度を下げるか、 リアルタイムで"
"ないポリシーへ切り替えるかの変更だけが許可される。"

#. type: Plain text
#: build/C/man7/sched.7:607
msgid ""
"Subject to the same rules, another unprivileged thread can also make these "
"changes, as long as the effective user ID of the thread making the change "
"matches the real or effective user ID of the target thread."
msgstr ""
"ある非特権スレッドが別のスレッドに対してこれらの変更を行う際にも、 同じルール"
"が適用される。変更を行えるのは、変更を行おうとするスレッド の実効ユーザー ID "
"が変更対象のスレッドの実ユーザー ID か実効ユーザー ID と 一致している場合に限"
"られる。"

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man7/sched.7:626
msgid ""
"Special rules apply for the B<SCHED_IDLE> policy.  In Linux kernels before "
"2.6.39, an unprivileged thread operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged thread can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_OTHER> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr "B<SCHED_IDLE> ポリシーの場合には特別なルールが適用される。 2.6.39 より前の Linux カーネルでは、このポリシーで動作する非特権スレッドは、 B<RLIMIT_RTPRIO> リソース上限の値に関わらず、自分のポリシーを変更することができない。 2.6.39 以降の Linux カーネルでは、非特権スレッドは、自分の nice 値が B<RLIMIT_NICE> リソース上限 (B<getrlimit>(2) 参照) で許可された範囲である限りは、自分のスケジューリングポリシーを B<SCHED_BATCH> か B<SCHED_OTHER> ポリシーに切り替えることができる。"

#. type: Plain text
#: build/C/man7/sched.7:637
msgid ""
"Privileged (B<CAP_SYS_NICE>)  threads ignore the B<RLIMIT_RTPRIO> limit; as "
"with older kernels, they can make arbitrary changes to scheduling policy and "
"priority.  See B<getrlimit>(2)  for further information on B<RLIMIT_RTPRIO>."
msgstr ""
"特権スレッド (B<CAP_SYS_NICE> ケーパビリティを持つスレッド) の場合、 "
"B<RLIMIT_RTPRIO> の制限は無視される; 古いカーネルと同じように、スケジューリン"
"グポリシーと優先度に対し 任意の変更を行うことができる。 B<RLIMIT_RTPRIO> に関"
"するもっと詳しい情報は B<getrlimit>(2)  を参照のこと。"

#. type: SS
#: build/C/man7/sched.7:637
#, no-wrap
msgid "Limiting the CPU usage of real-time and deadline processes"
msgstr "リアルタイムプロセスとデッドラインプロセスの CPU 使用量を制限する"

#. type: Plain text
#: build/C/man7/sched.7:650
#, fuzzy
#| msgid ""
#| "A nonblocking infinite loop in a thread scheduled under the "
#| "B<SCHED_FIFO>, B<SCHED_RR>, or B<SCHED_DEADLINE> policy will block all "
#| "threads with lower priority forever.  Prior to Linux 2.6.25, the only way "
#| "of preventing a runaway real-time process from freezing the system was to "
#| "run (at the console)  a shell scheduled under a higher static priority "
#| "than the tested application.  This allows an emergency kill of tested "
#| "real-time applications that do not block or terminate as expected."
msgid ""
"A nonblocking infinite loop in a thread scheduled under the B<SCHED_FIFO>, "
"B<SCHED_RR>, or B<SCHED_DEADLINE> policy can potentially block all other "
"threads from accessing the CPU forever.  Prior to Linux 2.6.25, the only way "
"of preventing a runaway real-time process from freezing the system was to "
"run (at the console)  a shell scheduled under a higher static priority than "
"the tested application.  This allows an emergency kill of tested real-time "
"applications that do not block or terminate as expected."
msgstr ""
"B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_DEADLINE> でスケジューリングされる スレッ"
"ドが停止せずに無限ループに陥ると、 他の全てのより低い優先度のスレッドを永久に"
"停止 (block) させてしまう。 Linux 2.6.25 より前では、 リアルタイムプロセスが"
"暴走してしまい、システムが止まってしまうのを防止する唯一の方法は、 (コンソー"
"ルで) シェルをテスト対象のアプリケーションよりも高い静的優先度で実行すること"
"だけであった。 これによって期待通りに停止したり終了したりしないリアルタイム "
"アプリケーションを緊急終了させることが可能になる。"

#. type: Plain text
#: build/C/man7/sched.7:660
msgid ""
"Since Linux 2.6.25, there are other techniques for dealing with runaway real-"
"time and deadline processes.  One of these is to use the B<RLIMIT_RTTIME> "
"resource limit to set a ceiling on the CPU time that a real-time process may "
"consume.  See B<getrlimit>(2)  for details."
msgstr ""
"Linux 2.6.25 以降では、 暴走したリアルタイムプロセスやデッドラインプロセスを"
"扱う別の方法が提供されている。 一つは B<RLIMIT_RTTIME> リソース上限を使ってリ"
"アルタイムプロセスが消費できる CPU 時間の上限を設定する方法である。 詳細は "
"B<getrlimit>(2) を参照。"

#. type: Plain text
#: build/C/man7/sched.7:668
msgid ""
"Since version 2.6.25, Linux also provides two I</proc> files that can be "
"used to reserve a certain amount of CPU time to be used by non-real-time "
"processes.  Reserving CPU time in this fashion allows some CPU time to be "
"allocated to (say) a root shell that can be used to kill a runaway process.  "
"Both of these files specify time values in microseconds:"
msgstr ""
"Linux 2.6.25 以降では、 2 つの I</proc> ファイルを使って、リアルタイムでない"
"プロセスが使用できる CPU 時間を一定量予約することができる。 この方法で CPU 時"
"間をいくらか予約しておくことで、 CPU 時間が (例えば) root シェルに割り当てら"
"れ、このシェルから暴走したプロセスを殺すことができる。 これらのファイルでは両"
"方ともマイクロ秒で時間を指定する。"

#. type: TP
#: build/C/man7/sched.7:668
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us>"
msgstr "I</proc/sys/kernel/sched_rt_period_us>"

#. type: Plain text
#: build/C/man7/sched.7:676
msgid ""
"This file specifies a scheduling period that is equivalent to 100% CPU "
"bandwidth.  The value in this file can range from 1 to B<INT_MAX>, giving an "
"operating range of 1 microsecond to around 35 minutes.  The default value in "
"this file is 1,000,000 (1 second)."
msgstr ""
"このファイルは、 CPU 時間 100% にあたるスケジューリング間隔を指定する。 この"
"ファイルの値として 1 から B<INT_MAX> を指定できる。 この値は実際の時間として"
"は 1 マイクロ秒から約 35 分に相当する。 このファイルのデフォルト値は "
"1,000,000 (1 秒) である。"

#. type: TP
#: build/C/man7/sched.7:676
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us>"
msgstr "I</proc/sys/kernel/sched_rt_runtime_us>"

#. type: Plain text
#: build/C/man7/sched.7:689
msgid ""
"The value in this file specifies how much of the \"period\" time can be used "
"by all real-time and deadline scheduled processes on the system.  The value "
"in this file can range from -1 to B<INT_MAX>-1.  Specifying -1 makes the run "
"time the same as the period; that is, no CPU time is set aside for non-real-"
"time processes (which was the Linux behavior before kernel 2.6.25).  The "
"default value in this file is 950,000 (0.95 seconds), meaning that 5% of the "
"CPU time is reserved for processes that don't run under a real-time or "
"deadline scheduling policy."
msgstr ""
"このファイルの値は、 システム上のリアルタイムスケジューリングやデッドラインス"
"ケジューリングの全プロセスが使用できる「期間」を指定する。 このファイルの値と"
"して -1 から B<INT_MAX>-1 を指定できる。 -1 を指定すると、実行時間 (runtime) "
"はスケジューリング間隔 (period) と同じになる。 つまり、 CPU 時間はリアルタイ"
"ムでないプロセスには確保されない (カーネル 2.6.25 より前の Linux の動作であ"
"る)。 このファイルのデフォルト値は 950,000 (0.95 秒) である。 これは CPU 時間"
"の 5% がリアルタイムやデッドラインスケジューリングポリシー以外で動作するプロ"
"セスに確保されるという意味する。"

#. type: SS
#: build/C/man7/sched.7:690
#, no-wrap
msgid "Response time"
msgstr "応答時間 (response time)"

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man7/sched.7:698
msgid ""
"A blocked high priority thread waiting for I/O has a certain response time "
"before it is scheduled again.  The device driver writer can greatly reduce "
"this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""
"I/O 待ちで停止したより高い優先度のスレッドは再びスケジューリングされる 前にい"
"くらかの応答時間がかかる。デバイスドライバーを書く場合には \"slow interrupt"
"\" 割り込みハンドラーを使用することで この応答時間を劇的に減少させることがで"
"きる。"

#. type: SS
#: build/C/man7/sched.7:698
#, no-wrap
msgid "Miscellaneous"
msgstr "その他"

#. type: Plain text
#: build/C/man7/sched.7:703
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr ""
"子プロセスは B<fork>(2)  の際に親プロセスのスケジューリングポリシーとパラメー"
"ターを継承する。 B<execve>(2)  の前後で、スケジューリングポリシーとパラメー"
"ターは保持される。"

#. type: Plain text
#: build/C/man7/sched.7:710
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""
"リアルタイムプロセスは大抵、ページングの待ち時間を避けるために B<mlock>(2)  "
"や B<mlockall>(2)  を使ってメモリーロックをしなければならない。"

#. type: SS
#: build/C/man7/sched.7:710
#, no-wrap
msgid "The autogroup feature"
msgstr ""

#.  commit 5091faa449ee0b7d73bc296a93bca9540fc51d0a
#. type: Plain text
#: build/C/man7/sched.7:720
msgid ""
"Since Linux 2.6.38, the kernel provides a feature known as autogrouping to "
"improve interactive desktop performance in the face of multiprocess, CPU-"
"intensive workloads such as building the Linux kernel with large numbers of "
"parallel build processes (i.e., the B<make>(1)  B<-j> flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:730
msgid ""
"This feature operates in conjunction with the CFS scheduler and requires a "
"kernel that is configured with B<CONFIG_SCHED_AUTOGROUP>.  On a running "
"system, this feature is enabled or disabled via the file I</proc/sys/kernel/"
"sched_autogroup_enabled>; a value of 0 disables the feature, while a value "
"of 1 enables it.  The default value in this file is 1, unless the kernel was "
"booted with the I<noautogroup> parameter."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:740
msgid ""
"A new autogroup is created when a new session is created via B<setsid>(2); "
"this happens, for example, when a new terminal window is started.  A new "
"process created by B<fork>(2)  inherits its parent's autogroup membership.  "
"Thus, all of the processes in a session are members of the same autogroup.  "
"An autogroup is automatically destroyed when the last process in the group "
"terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:747
msgid ""
"When autogrouping is enabled, all of the members of an autogroup are placed "
"in the same kernel scheduler \"task group\".  The CFS scheduler employs an "
"algorithm that equalizes the distribution of CPU cycles across task groups.  "
"The benefits of this for interactive desktop performance can be described "
"via the following example."
msgstr ""

#.  Mike Galbraith, 25 Nov 2016:
#.      I'd say something more wishy-washy here, like cycles are
#.      distributed fairly across groups and leave it at that, as your
#.      detailed example is incorrect due to SMP fairness (which I don't
#.      like much because [very unlikely] worst case scenario
#.      renders a box sized group incapable of utilizing more that
#.      a single CPU total).  For example, if a group of NR_CPUS
#.      size competes with a singleton, load balancing will try to give
#.      the singleton a full CPU of its very own.  If groups intersect for
#.      whatever reason on say my quad lappy, distribution is 80/20 in
#.      favor of the singleton.
#. type: Plain text
#: build/C/man7/sched.7:778
msgid ""
"Suppose that there are two autogroups competing for the same CPU (i.e., "
"presume either a single CPU system or the use of B<taskset>(1)  to confine "
"all the processes to the same CPU on an SMP system).  The first group "
"contains ten CPU-bound processes from a kernel build started with I<make\\ -"
"j10>.  The other contains a single CPU-bound process: a video player.  The "
"effect of autogrouping is that the two groups will each receive half of the "
"CPU cycles.  That is, the video player will receive 50% of the CPU cycles, "
"rather than just 9% of the cycles, which would likely lead to degraded video "
"playback.  The situation on an SMP system is more complex, but the general "
"effect is the same: the scheduler distributes CPU cycles across task groups "
"such that an autogroup that contains a large number of CPU-bound processes "
"does not end up hogging CPU cycles at the expense of the other jobs on the "
"system."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:781
msgid ""
"A process's autogroup (task group) membership can be viewed via the file I</"
"proc/[pid]/autogroup>:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:786
#, no-wrap
msgid ""
"$ B<cat /proc/1/autogroup>\n"
"/autogroup-1 nice 0\n"
msgstr ""

#
#.  FIXME .
#.  Because of a bug introduced in Linux 4.7
#.  (commit 2159197d66770ec01f75c93fb11dc66df81fd45b made changes
#.  that exposed the fact that autogroup didn't call scale_load()),
#.  it happened that *all* values in this range caused a task group
#.  to be further disfavored by the scheduler, with \-20 resulting
#.  in the scheduler mildly disfavoring the task group and +19 greatly
#.  disfavoring it.
#.  A patch was posted on 23 Nov 2016
#.  ("sched/autogroup: Fix 64bit kernel nice adjustment";
#.  check later to see in which kernel version it lands.
#. type: Plain text
#: build/C/man7/sched.7:810
msgid ""
"This file can also be used to modify the CPU bandwidth allocated to an "
"autogroup.  This is done by writing a number in the \"nice\" range to the "
"file to set the autogroup's nice value.  The allowed range is from +19 (low "
"priority) to -20 (high priority).  (Writing values outside of this range "
"causes B<write>(2)  to fail with the error B<EINVAL>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:819
msgid ""
"The autogroup nice setting has the same meaning as the process nice value, "
"but applies to distribution of CPU cycles to the autogroup as a whole, based "
"on the relative nice values of other autogroups.  For a process inside an "
"autogroup, the CPU cycles that it receives will be a product of the "
"autogroup's nice value (compared to other autogroups)  and the process's "
"nice value (compared to other processes in the same autogroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:824
msgid ""
"The use of the B<cgroups>(7)  CPU controller to place processes in cgroups "
"other than the root CPU cgroup overrides the effect of autogrouping."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:835
msgid ""
"The autogroup feature groups only processes scheduled under non-real-time "
"policies (B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE>).  It does not "
"group processes scheduled under real-time and deadline policies.  Those "
"processes are scheduled according to the rules described earlier."
msgstr ""

#. type: SS
#: build/C/man7/sched.7:835
#, no-wrap
msgid "The nice value and group scheduling"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:845
msgid ""
"When scheduling non-real-time processes (i.e., those scheduled under the "
"B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE> policies), the CFS "
"scheduler employs a technique known as \"group scheduling\", if the kernel "
"was configured with the B<CONFIG_FAIR_GROUP_SCHED> option (which is typical)."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:851
msgid ""
"Under group scheduling, threads are scheduled in \"task groups\".  Task "
"groups have a hierarchical relationship, rooted under the initial task group "
"on the system, known as the \"root task group\".  Task groups are formed in "
"the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:855
msgid ""
"All of the threads in a CPU cgroup form a task group.  The parent of this "
"task group is the task group of the corresponding parent cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:863
msgid ""
"If autogrouping is enabled, then all of the threads that are (implicitly) "
"placed in an autogroup (i.e., the same session, as created by B<setsid>(2))  "
"form a task group.  Each new autogroup is thus a separate task group.  The "
"root task group is the parent of all such autogroups."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:867
msgid ""
"If autogrouping is enabled, then the root task group consists of all "
"processes in the root CPU cgroup that were not otherwise implicitly placed "
"into a new autogroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:870
msgid ""
"If autogrouping is disabled, then the root task group consists of all "
"processes in the root CPU cgroup."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:875
msgid ""
"If group scheduling was disabled (i.e., the kernel was configured without "
"B<CONFIG_FAIR_GROUP_SCHED>), then all of the processes on the system are "
"notionally placed in a single task group."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:889
msgid ""
"Under group scheduling, a thread's nice value has an effect for scheduling "
"decisions I<only relative to other threads in the same task group>.  This "
"has some surprising consequences in terms of the traditional semantics of "
"the nice value on UNIX systems.  In particular, if autogrouping is enabled "
"(which is the default in various distributions), then employing "
"B<setpriority>(2)  or B<nice>(1)  on a process has an effect only for "
"scheduling relative to other processes executed in the same session "
"(typically: the same terminal window)."
msgstr ""

#.  More succinctly: the nice(1) command is in many cases a no-op since
#.  Linux 2.6.38.
#. type: Plain text
#: build/C/man7/sched.7:905
msgid ""
"Conversely, for two processes that are (for example)  the sole CPU-bound "
"processes in different sessions (e.g., different terminal windows, each of "
"whose jobs are tied to different autogroups), I<modifying the nice value of "
"the process in one of the sessions> I<has no effect> in terms of the "
"scheduler's decisions relative to the process in the other session.  A "
"possibly useful workaround here is to use a command such as the following to "
"modify the autogroup nice value for I<all> of the processes in a terminal "
"session:"
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:909
#, no-wrap
msgid "$ B<echo 10 E<gt> /proc/self/autogroup>\n"
msgstr ""

#. type: SS
#: build/C/man7/sched.7:911
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr "本流の Linux カーネルでのリアルタイム機能"

#.  FIXME . Probably this text will need some minor tweaking
#.  ask Carsten Emde about this.
#. type: Plain text
#: build/C/man7/sched.7:923
#, fuzzy
#| msgid ""
#| "From kernel version 2.6.18 onward, however, Linux is gradually becoming "
#| "equipped with real-time capabilities, most of which are derived from the "
#| "former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
#| "Gleixner, Steven Rostedt, and others.  Until the patches have been "
#| "completely merged into the mainline kernel (this is expected to be around "
#| "kernel version 2.6.30), they must be installed to achieve the best real-"
#| "time performance.  These patches are named:"
msgid ""
"Since kernel version 2.6.18, Linux is gradually becoming equipped with real-"
"time capabilities, most of which are derived from the former I<realtime-"
"preempt> patch set.  Until the patches have been completely merged into the "
"mainline kernel, they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""
"カーネル 2.6.18 から現在まで、 Linux は徐々にリアルタイム機能を備えつつ\n"
"あるが、 これらの機能のほとんどは、 Ingo Molnar, Thomas Gleixner,\n"
"Steven Rostedt らによって開発された、 以前の I<realtime-preempt> パッチ\n"
"からのものである。 これらのパッチが本流のカーネルに完全にマージされるま\n"
"では (マージの完了はカーネル 2.6.30 あたりの予定)、 最高のリアルタイム\n"
"性能を達成するには realtime-preempt パッチを 組み込まなければならない。\n"
"これらのパッチは"

#. type: Plain text
#: build/C/man7/sched.7:927
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr "patch-I<kernelversion>-rtI<patchversion>\n"

#. type: Plain text
#: build/C/man7/sched.7:933
msgid ""
"and can be downloaded from E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/"
"kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""
"という名前で、 E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/kernel\\:/"
"projects\\:/rt/> E<.UE> からダウンロードできる。"

#. type: Plain text
#: build/C/man7/sched.7:942
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""
"このパッチが適用されず、かつパッチの内容の本流のカーネルへのマージが 完了する"
"までは、カーネルの設定では B<CONFIG_PREEMPT_NONE>, "
"B<CONFIG_PREEMPT_VOLUNTARY>, B<CONFIG_PREEMPT_DESKTOP> の 3つのプリエンプショ"
"ンクラス (preemption class) だけが提供される。 これらのクラスでは、最悪の場合"
"のスケジューリング遅延がそれぞれ 全く減らない、いくらか減る、かなり減る。"

#. type: Plain text
#: build/C/man7/sched.7:951
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular real-"
"time operating system.  The FIFO and RR scheduling policies are then used to "
"run a thread with true real-time priority and a minimum worst-case "
"scheduling latency."
msgstr ""
"パッチが適用された場合、またはパッチの内容の本流のカーネルへのマージが 完了し"
"た後では、上記に加えて設定項目として B<CONFIG_PREEMPT_RT> が利用可能になる。"
"この項目を選択すると、 Linux は通常のリアルタイムオペレーティングシステムに変"
"身する。 この場合には、 FIFO と RR のスケジューリングポリシーは、 真のリアル"
"タイム優先度を持つスレッドを最悪の場合のスケジューリング遅延が 最小となる環境"
"で動作させるために使われることになる。"

#. type: Plain text
#: build/C/man7/sched.7:956
msgid ""
"The B<cgroups>(7)  CPU controller can be used to limit the CPU consumption "
"of groups of processes."
msgstr ""

#. type: Plain text
#: build/C/man7/sched.7:966
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""
"もともとは、標準の Linux は一般目的のオペレーティングシステムとして 設計され"
"ており、バックグラウンドプロセスや対話的アプリケーション、 リアルタイム性の要"
"求が厳しくないリアルタイムアプリケーション (普通はタイミングの応答期限 "
"(deadline) を満たす必要があるアプリケーション)  を扱うことができた。 Linux "
"カーネル 2.6 では、 カーネルのプリエンプション (タスクの置き換え) が可能であ"
"り、 新たに導入された O(1) スケジューラにより、 アクティブなタスクの数に関わ"
"らずスケジューリングに必要な時間は 固定で確定的 (deterministic) であることが"
"保証されている。 それにも関わらず、カーネル 2.6.17 までは 真のリアルタイムコ"
"ンピューティングは実現できなかった。"

#. type: Plain text
#: build/C/man7/sched.7:998
msgid ""
"B<chcpu>(1), B<chrt>(1), B<lscpu>(1), B<ps>(1), B<taskset>(1), B<top>(1), "
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getaffinity_np>(3), "
"B<pthread_getschedparam>(3), B<pthread_setaffinity_np>(3), "
"B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7)"
msgstr " B<chcpu>(1), B<chrt>(1), B<lscpu>(1), B<ps>(1), B<taskset>(1), B<top>(1), B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<sched_yield>(2), B<setpriority>(2), B<pthread_getaffinity_np>(3), B<pthread_getschedparam>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7)"

#. type: Plain text
#: build/C/man7/sched.7:1002
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O.\\& Gallmeister, "
"O'Reilly & Associates, Inc., ISBN 1-56592-074-0."
msgstr "I<Programming for the real world - POSIX.4> by Bill O.\\& Gallmeister, O'Reilly & Associates, Inc., ISBN 1-56592-074-0."

#. type: Plain text
#: build/C/man7/sched.7:1009
msgid ""
"The Linux kernel source files I<Documentation/scheduler/sched-deadline.txt>, "
"I<Documentation/scheduler/sched-rt-group.txt>, I<Documentation/scheduler/"
"sched-design-CFS.txt>, and I<Documentation/scheduler/sched-nice-design.txt>"
msgstr ""
"Linux カーネルソースのファイル I<Documentation/scheduler/sched-deadline."
"txt>, I<Documentation/scheduler/sched-rt-group.txt>, I<Documentation/"
"scheduler/sched-design-CFS.txt>, I<Documentation/scheduler/sched-nice-design."
"txt>"

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr "SETNS"

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr "setns - スレッドに名前空間を関連付けしなおす"

#. type: Plain text
#: build/C/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"

#. type: Plain text
#: build/C/man2/setns.2:25
msgid ""
"The B<setns>()  system call allows the calling thread to move into different "
"namespaces.  The I<fd> argument is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:29
msgid ""
"a file descriptor referring to one of the magic links in a I</proc/[pid]/ns/"
"> directory (or a bind mount to such a link);"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:32
msgid "a PID file descriptor (see B<pidfd_open>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:37
msgid "The I<nstype> argument is interpreted differently in each case."
msgstr ""

#. type: SS
#: build/C/man2/setns.2:37
#, no-wrap
msgid "fd refers to a /proc/[pid]/ns/ link"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:51
msgid ""
"If I<fd> refers to a I</proc/[pid]/ns/> link, then B<setns>()  reassociates "
"the calling thread with the namespace associated with that link, subject to "
"any constraints imposed by the I<nstype> argument.  In this usage, each call "
"to B<setns>()  changes just one of the caller's namespace memberships."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:59
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have I<one> of the following "
"values:"
msgstr "I<nstype> 引数は、呼び出したスレッドがどのタイプの名前空間を関連付けしなおすことができるかを指定する。この引数には以下の「いずれか」の値を指定できる。"

#. type: TP
#: build/C/man2/setns.2:59
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man2/setns.2:62
msgid "Allow any type of namespace to be joined."
msgstr "どのタイプの名前空間も関連付けることができる。"

#. type: Plain text
#: build/C/man2/setns.2:66
msgid "I<fd> must refer to a cgroup namespace."
msgstr "I<fd> は cgroup 名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:66
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 3.0)"
msgstr "B<CLONE_NEWIPC> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man2/setns.2:70
msgid "I<fd> must refer to an IPC namespace."
msgstr "I<fd> は IPC 名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:70
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 3.0)"
msgstr "B<CLONE_NEWNET> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man2/setns.2:74
msgid "I<fd> must refer to a network namespace."
msgstr "I<fd> はネットワーク名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:74
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 3.8)"
msgstr "B<CLONE_NEWNS> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/setns.2:78
msgid "I<fd> must refer to a mount namespace."
msgstr "I<fd> はマウント名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:78 build/C/man2/unshare.2:143
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr "B<CLONE_NEWPID> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/setns.2:82
msgid "I<fd> must refer to a descendant PID namespace."
msgstr "I<fd> は子孫の PID 名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:82
#, no-wrap
msgid "B<CLONE_NEWTIME> (since Linux 5.8)"
msgstr "B<CLONE_NEWTIME> (Linux 5.8 以降)"

#.  commit 76c12881a38aaa83e1eb4ce2fada36c3a732bad4
#. type: Plain text
#: build/C/man2/setns.2:87
#, fuzzy
#| msgid "I<fd> must refer to a user namespace."
msgid "I<fd> must refer to a time namespace."
msgstr "I<fd> はユーザー名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:87 build/C/man2/unshare.2:185
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr "B<CLONE_NEWUSER> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/setns.2:91
msgid "I<fd> must refer to a user namespace."
msgstr "I<fd> はユーザー名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:91
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 3.0)"
msgstr "B<CLONE_NEWUTS> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man2/setns.2:95
msgid "I<fd> must refer to a UTS namespace."
msgstr "I<fd> は UTS 名前空間を参照していなければならない。"

#. type: Plain text
#: build/C/man2/setns.2:111
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""
"呼び出し側が I<fd> がどのタイプの名前空間を参照しているかを知っている\n"
"(もしくは気にする必要がない) 場合には、 I<nstype> に 0 を指定すれば十分\n"
"である。呼び出し側が I<fd> がどのタイプの名前空間を参照しているかを\n"
"知っておらず、かつ、特定のタイプの名前空間であることを保証したい場合、\n"
"I<nstype> に 0 以外の値を指定するとよい。 (ファイルディスクリプターが別の\n"
"プロセスによりオープンされ、例えば、UNIX ドメインソケット経由で呼び出し\n"
"側に渡された場合などでは、呼び出し側が I<fd> がどのタイプの名前空間を\n"
"参照しているかを知らない可能性がある。)"

#. type: SS
#: build/C/man2/setns.2:111
#, fuzzy, no-wrap
#| msgid "I<fd> is not a valid file descriptor."
msgid "fd is a PID file descriptor"
msgstr "I<fd> が有効なファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/setns.2:123
msgid ""
"Since Linux 5.8, I<fd> may refer to a PID file descriptor obtained from "
"B<pidfd_open>(2)  or B<clone>(3).  In this usage, B<setns>()  atomically "
"moves the calling thread into one or more of the same namespaces as the "
"thread referred to by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:135
msgid ""
"The I<nstype> argument is a bit mask specified by ORing together I<one or "
"more> of the B<CLONE_NEW*> namespace constants listed above.  The caller is "
"moved into each of the target thread's namespaces that is specified in "
"I<nstype>; the caller's memberships in the remaining namespaces are left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:139
msgid ""
"For example, the following code would move the caller into the same user, "
"network, and UTS namespaces as PID 1234, but would leave the caller's other "
"namespace memberships unchanged:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:144
#, no-wrap
msgid ""
"int fd = pidfd_open(1234, 0);\n"
"setns(fd, CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWUTS);\n"
msgstr ""

#. type: SS
#: build/C/man2/setns.2:147
#, no-wrap
msgid "Details for specific namespace types"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:150
msgid ""
"Note the following details and restrictions when reassociating with specific "
"namespace types:"
msgstr ""

#. type: TP
#: build/C/man2/setns.2:150
#, no-wrap
msgid "User namespaces"
msgstr ""

#.  See kernel/user_namespace.c:userns_install() [3.8 source]
#. type: Plain text
#: build/C/man2/setns.2:161
msgid ""
"A process reassociating itself with a user namespace must have the "
"B<CAP_SYS_ADMIN> capability in the target user namespace.  (This necessarily "
"implies that it is only possible to join a descendant user namespace.)  Upon "
"successfully joining a user namespace, a process is granted all capabilities "
"in that namespace, regardless of its user and group IDs."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:164
msgid "A multithreaded process may not change user namespace with B<setns>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:171
msgid ""
"It is not permitted to use B<setns>()  to reenter the caller's current user "
"namespace.  This prevents a caller that has dropped capabilities from "
"regaining those capabilities via a call to B<setns>()."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/setns.2:181
msgid ""
"For security reasons, a process can't join a new user namespace if it is "
"sharing filesystem-related attributes (the attributes whose sharing is "
"controlled by the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:184
msgid "For further details on user namespaces, see B<user_namespaces>(7)."
msgstr "ユーザー名前空間の詳細は B<user_namespaces>(7) を参照。"

#. type: TP
#: build/C/man2/setns.2:184
#, no-wrap
msgid "Mount namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:193
#, fuzzy
#| msgid ""
#| "A process may not be reassociated with a new mount namespace if it is "
#| "multithreaded.  Changing the mount namespace requires that the caller "
#| "possess both B<CAP_SYS_CHROOT> and B<CAP_SYS_ADMIN> capabilities in its "
#| "own user namespace and B<CAP_SYS_ADMIN> in the target mount namespace.  "
#| "See B<user_namespaces>(7)  for details on the interaction of user "
#| "namespaces and mount namespaces."
msgid ""
"Changing the mount namespace requires that the caller possess both "
"B<CAP_SYS_CHROOT> and B<CAP_SYS_ADMIN> capabilities in its own user "
"namespace and B<CAP_SYS_ADMIN> in the user namespace that owns the target "
"mount namespace."
msgstr ""
"プロセスがマルチスレッドの場合、そのプロセスを新しいマウント名前空間に関連付"
"けし直すことは許可されていない。 マウント名前空間を変更するには、呼び出し元の"
"プロセスが、 自分自身のユーザー名前空間において B<CAP_SYS_CHROOT> と "
"B<CAP_SYS_ADMIN> の両方のケーパビリティを持っており、 変更後のマウント名前空"
"間で B<CAP_SYS_ADMIN> ケーパビリティを持っていなければならない。 ユーザー名前"
"空間とマウント名前空間の関係の詳細は B<user_namespaces>(7) を参照。"

#.  Above check is in fs/namespace.c:mntns_install() [3.8 source]
#. type: Plain text
#: build/C/man2/setns.2:201
msgid ""
"A process can't join a new mount namespace if it is sharing filesystem-"
"related attributes (the attributes whose sharing is controlled by the "
"B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:205
msgid ""
"See B<user_namespaces>(7)  for details on the interaction of user namespaces "
"and mount namespaces."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:205
#, no-wrap
msgid "PID namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:212
msgid ""
"In order to reassociate itself with a new PID namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target PID namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:219
msgid ""
"Reassociating the PID namespace has somewhat different from other namespace "
"types.  Reassociating the calling thread with a PID namespace changes only "
"the PID namespace that subsequently created child processes of the caller "
"will be placed in; it does not change the PID namespace of the caller itself."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:223
msgid ""
"Reassociating with a PID namespace is allowed only if the target PID "
"namespace is a descendant (child, grandchild, etc.)  of, or is the same as, "
"the current PID namespace of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:226
msgid "For further details on PID namespaces, see B<pid_namespaces>(7)."
msgstr "PID 名前空間の詳細は B<pid_namespaces>(7) を参照。"

#. type: TP
#: build/C/man2/setns.2:226
#, no-wrap
msgid "Cgroup namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:233
msgid ""
"In order to reassociate itself with a new cgroup namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target cgroup namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:238
msgid ""
"Using B<setns>()  to change the caller's cgroup namespace does not change "
"the caller's cgroup memberships."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:238
#, no-wrap
msgid "Network, IPC, time, and UTS namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:245
msgid ""
"In order to reassociate itself with a new network, IPC, time, or UTS "
"namespace, the caller must have the B<CAP_SYS_ADMIN> capability both in its "
"own user namespace and in the user namespace that owns the target namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:252
msgid ""
"On success, B<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""
"成功すると B<setns>() は 0 を返す。 失敗すると、 -1 が返され、 I<errno> にエ"
"ラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/setns.2:257
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプターではない。"

#. type: Plain text
#: build/C/man2/setns.2:262
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>."
msgstr ""
"I<fd> が I<nstype> で指定されたタイプと一致しない名前空間を参照している。"

#. type: Plain text
#: build/C/man2/setns.2:266
msgid ""
"There is problem with reassociating the thread with the specified namespace."
msgstr "スレッドを指定された名前空間に関連付けし直す際に問題が発生した。"

#. type: Plain text
#: build/C/man2/setns.2:271
msgid ""
"The caller tried to join an ancestor (parent, grandparent, and so on)  PID "
"namespace."
msgstr "呼び出し元が先祖 (親や親の親など) の PID 名前空間に参加しようとした。"

#. type: Plain text
#: build/C/man2/setns.2:275
msgid ""
"The caller attempted to join the user namespace in which it is already a "
"member."
msgstr "自分がすでにメンバーとなっているユーザー名前空間に参加しようとした。"

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: build/C/man2/setns.2:282
msgid ""
"The caller shares filesystem (B<CLONE_FS>)  state (in particular, the root "
"directory)  with other processes and tried to join a new user namespace."
msgstr ""
"呼び出し元が他のプロセスとファイルシステム状態 (特に root ディレクトリ) を共"
"有していて (B<CLONE_FS>)、 新しいユーザー名前空間に参加しようとした。"

#.  See kernel/user_namespace.c::userns_install() [kernel 3.15 sources]
#. type: Plain text
#: build/C/man2/setns.2:286
msgid "The caller is multithreaded and tried to join a new user namespace."
msgstr ""
"呼び出し元プロセスがマルチスレッドで、新しいユーザー名前空間に参加しようとし"
"た。"

#. type: Plain text
#: build/C/man2/setns.2:292
msgid ""
"I<fd> is a PID file descriptor and I<nstype> is invalid (e.g., it is 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:295
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr "指定された名前空間に変更するのに必要なメモリーが割り当てられない。"

#. type: Plain text
#: build/C/man2/setns.2:299
msgid ""
"The calling thread did not have the required capability for this operation."
msgstr ""
"呼び出し元スレッドはこの操作を行うのに必要なケーパビリティを持っていなかっ"
"た。"

#. type: Plain text
#: build/C/man2/setns.2:304
msgid ""
"I<fd> is a PID file descriptor but the process it refers to no longer exists "
"(i.e., it has terminated and been waited on)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:309
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""
"B<setns>() システムコールはカーネル 3.0 で Linux に初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.14 を追加された。"

#. type: Plain text
#: build/C/man2/setns.2:313
msgid "The B<setns>()  system call is Linux-specific."
msgstr "B<setns>() システムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/setns.2:318
msgid ""
"For further information on the I</proc/[pid]/ns/> magic links, see "
"B<namespaces>(7)."
msgstr "マジックリング I</proc/[pid]/ns/> の詳細は B<namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/setns.2:324
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""
"新しいスレッドが B<clone>(2) を使って作成された際に共有できる全ての属性を、\n"
"B<setns>() を使って変更できるわけではない。"

#. type: Plain text
#: build/C/man2/setns.2:333
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""
"以下のプログラムは 2 つ以上の引数を取る。 最初の引数には、 既存の I</"
"proc/[pid]/ns/> ディレクトリの名前空間ファイルのパス名を指定する。 残りの引き"
"数は、コマンドとその引数を指定する。 このプログラムは名前空間ファイルをオー"
"プンし、 B<setns>() を使って名前空間に参加し、 指定されたコマンドをその名前空"
"間内で実行する。"

#. type: Plain text
#: build/C/man2/setns.2:343
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""
"以下のシェルセッションでは、 このプログラム (I<ns_exec> という名前のバイナリ"
"としてコンパイルされている)を、 B<clone>(2) のマニュアルページの "
"B<CLONE_NEWUTS> のサンプルプログラムと組み合わせて使っている。"

#. type: Plain text
#: build/C/man2/setns.2:351
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""
"まず、 B<clone>(2) のサンプルプログラムをバックグラウンドで実行する。 このプ"
"ログラムは、 別の UTS 名前空間で子プロセスを作成する。 子プロセスは自分の名前"
"空間内でホスト名を変更する。 それから、 親プロセスと子プロセスの両方でそれぞ"
"れの UTS 名前空間のホスト名を表示し、 2 つのホスト名が違うことが確認できる。"

#. type: Plain text
#: build/C/man2/setns.2:363
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""
"$ B<su>                   # 名前空間の操作には特権が必要\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # シェルでホスト名を確認\n"
"antero\n"

#. type: Plain text
#: build/C/man2/setns.2:370
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""
"次に、以下のプログラムを使ってシェルを実行する。 このシェルの中では、ホスト名"
"が最初のプログラムで作成された子プロセスが設定したホスト名になっていることを"
"確認できる。"

#. type: Plain text
#: build/C/man2/setns.2:376
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             #  ns_exec で起動されたシェル内で実行\n"
"bizarro\n"

#. type: Plain text
#: build/C/man2/setns.2:386
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/setns.2:394
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"

#. type: Plain text
#: build/C/man2/setns.2:399
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/setns.2:403
#, no-wrap
msgid ""
"    /* Get file descriptor for namespace; the file descriptor is opened\n"
"       with O_CLOEXEC so as to ensure that it is not inherited by the\n"
"       program that is later executed. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:407
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY | O_CLOEXEC);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY | O_CLOEXEC);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"

#. type: Plain text
#: build/C/man2/setns.2:410
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)       /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""
"    if (setns(fd, 0) == -1)       /* 名前空間に参加 */\n"
"        errExit(\"setns\");\n"

#. type: Plain text
#: build/C/man2/setns.2:414
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);    /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    execvp(argv[2], &argv[2]);     /* 名前空間内でコマンドを実行 */\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: build/C/man2/setns.2:423
msgid ""
"B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), "
"B<namespaces>(7), B<unix>(7)"
msgstr " B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), B<namespaces>(7), B<unix>(7)"

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr "UNSHARE"

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "2020-04-11"
msgstr " 2020-04-11"

#. type: Plain text
#: build/C/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr "unshare - プロセス実行コンテキストの一部を分離する"

#. type: Plain text
#: build/C/man2/unshare.2:29
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr "B<int unshare(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/unshare.2:42
msgid ""
"B<unshare>()  allows a process (or thread) to disassociate parts of its "
"execution context that are currently being shared with other processes (or "
"threads).  Part of the execution context, such as the mount namespace, is "
"shared implicitly when a new process is created using B<fork>(2)  or "
"B<vfork>(2), while other parts, such as virtual memory, may be shared by "
"explicit request when creating a process or thread using B<clone>(2)."
msgstr "B<unshare>() を使うと、プロセス (やスレッド) は他のプロセス (やスレッド) と現在共有している 実行コンテキストの一部を分離することができる。 実行コンテキストの一部、たとえばマウント名前空間 (mount namespace)  などは、新しいプロセスを B<fork>(2)  または B<vfork>(2)  を使って生成したときに、暗黙のうちに共有される。 一方、仮想メモリーなどは、 B<clone>(2) を使ってプロセスやスレッドを生成するときに、明示的に共有することを要求できる。"

#. type: Plain text
#: build/C/man2/unshare.2:47
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""
"B<unshare>()  の主な利用法は、プロセスが新しいプロセスを生成することなく、 共"
"有実行コンテキストを制御することである。"

#. type: Plain text
#: build/C/man2/unshare.2:54
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""
"I<flags> 引数はビットマスクであり、 実行コンテキストのどの部分の共有を解除"
"するかを表す。 この引数は、以下の定数の 0 個以上の OR で指定する:"

#. type: TP
#: build/C/man2/unshare.2:54
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr "B<CLONE_FILES>"

#. type: Plain text
#: build/C/man2/unshare.2:62
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""
"B<clone>(2)  B<CLONE_FILES> フラグの効果を取り消す。 ファイルディスクリプター"
"テーブルを共有させず、 呼び出し元プロセスは他のプロセスとファイルディスクリプ"
"ターを共有しなくなる。"

#. type: TP
#: build/C/man2/unshare.2:62
#, no-wrap
msgid "B<CLONE_FS>"
msgstr "B<CLONE_FS>"

#. type: Plain text
#: build/C/man2/unshare.2:76
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem "
"attributes, so that the calling process no longer shares its root directory "
"(B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""
"B<clone>(2)  B<CLONE_FS> フラグの効果を取り消す。ファイルシステム属性を共有さ"
"せず、呼び出し元プロセスは、ルートディレクトリ (B<chroot>(2))、カレントディレ"
"クトリ (B<chdir>(2))、 umask (B<umask>(2)) を他のプロセスと共有しなくなる。"

#. type: Plain text
#: build/C/man2/unshare.2:88
#, fuzzy
#| msgid ""
#| "This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
#| "Unshare the UTS IPC namespace, so that the calling process has a private "
#| "copy of the UTS namespace which is not shared with any other process.  "
#| "Use of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWCGROUP> flag.  "
"Unshare the cgroup namespace.  Use of B<CLONE_NEWCGROUP> requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWUTS> フラグと同じ効果を持つ。 UTS\n"
"IPC 名前空間を共有せず、呼び出し元プロセスは他のプロセスとは共有しない\n"
"固有の UTS IPC 名前空間のコピーを持つ。 このフラグを指定すると、\n"
"B<CLONE_FS> も暗黙のうちに指定される。B<CLONE_NEWUTS> を使用するには\n"
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the IPC namespace, so that the calling process has a private copy of "
"the IPC namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_SYSVSEM> as well.  Use of "
"B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr "このフラグは B<clone>(2) B<CLONE_NEWIPC> フラグと同じ効果を持つ。 IPC 名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の IPC 名前空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_SYSVSEM> も暗黙のうちに指定される。 B<CLONE_NEWIPC> を使用するには B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/unshare.2:120
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWNET> フラグと同じ効果を持つ。ネット\n"
"ワーク名前空間を共有せず、呼び出し元プロセスは他のプロセスとは共有しな\n"
"い固有のネットワーク名前空間のコピーを持つ。B<CLONE_NEWNET> を使用する\n"
"には B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/unshare.2:120
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr "B<CLONE_NEWNS>"

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:143
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<mount_namespaces>(7)."
msgstr "このフラグは B<clone>(2) B<CLONE_NEWNS> フラグと同じ効果を持つ。 マウント名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定される。 B<CLONE_NEWNS> を使用するには B<CAP_SYS_ADMIN> ケーパビリティが必要である。詳細は B<mount_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:170
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
"Unshare the PID namespace, so that the calling process has a new PID "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  The "
"first child created by the calling process will have the process ID 1 and "
"will assume the role of B<init>(1)  in the new namespace.  B<CLONE_NEWPID> "
"automatically implies B<CLONE_THREAD> as well.  Use of B<CLONE_NEWPID> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<pid_namespaces>(7)."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWPID> フラグと同じ効果を持つ。 PID 名前空"
"間を共有しない。 呼び出し元プロセスは、 すでに存在するどのプロセスとも共有さ"
"れない新しい PID 名前空間を、 自身の子プロセス用に持つことになる。 このプロセ"
"スにより作成される最初の子プロセスはプロセス ID 1 を持ち、 この新しい名前空間"
"において B<init>(1) の役割を持つとみなされる。 B<CLONE_NEWPID> を指定すると、"
"自動的に B<CLONE_THREAD> も指定されたものとみなされる。 B<CLONE_NEWPID> を使"
"用するには B<CAP_SYS_ADMIN> ケーパビリティが必要である。 詳細な情報は "
"B<pid_namespaces>(7) を参照。"

#. type: TP
#: build/C/man2/unshare.2:170
#, no-wrap
msgid "B<CLONE_NEWTIME> (since Linux 5.6)"
msgstr "B<CLONE_NEWTIME> (Linux 5.6 以降)"

#. type: Plain text
#: build/C/man2/unshare.2:185
#, fuzzy
#| msgid ""
#| "This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
#| "Unshare the PID namespace, so that the calling process has a new PID "
#| "namespace for its children which is not shared with any previously "
#| "existing process.  The calling process is I<not> moved into the new "
#| "namespace.  The first child created by the calling process will have the "
#| "process ID 1 and will assume the role of B<init>(1)  in the new "
#| "namespace.  B<CLONE_NEWPID> automatically implies B<CLONE_THREAD> as "
#| "well.  Use of B<CLONE_NEWPID> requires the B<CAP_SYS_ADMIN> capability.  "
#| "For further information, see B<pid_namespaces>(7)."
msgid ""
"Unshare the time namespace, so that the calling process has a new time "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  Use "
"of B<CLONE_NEWTIME> requires the B<CAP_SYS_ADMIN> capability.  For further "
"information, see B<time_namespaces>(7)."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWPID> フラグと同じ効果を持つ。 PID 名前空"
"間を共有しない。 呼び出し元プロセスは、 すでに存在するどのプロセスとも共有さ"
"れない新しい PID 名前空間を、 自身の子プロセス用に持つことになる。 このプロセ"
"スにより作成される最初の子プロセスはプロセス ID 1 を持ち、 この新しい名前空間"
"において B<init>(1) の役割を持つとみなされる。 B<CLONE_NEWPID> を指定すると、"
"自動的に B<CLONE_THREAD> も指定されたものとみなされる。 B<CLONE_NEWPID> を使"
"用するには B<CAP_SYS_ADMIN> ケーパビリティが必要である。 詳細な情報は "
"B<pid_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:199
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUSER> flag.  "
"Unshare the user namespace, so that the calling process is moved into a new "
"user namespace which is not shared with any previously existing process.  As "
"with the child process created by B<clone>(2)  with the B<CLONE_NEWUSER> "
"flag, the caller obtains a full set of capabilities in the new namespace."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWUSER> フラグと同じ効果を持つ。 ユーザー名"
"前空間を共有せず、 呼び出し元プロセスはすでに存在するどのプロセスとも共有され"
"ない新しいユーザー名前空間に移動される。 B<CLONE_NEWUSER> フラグを指定して "
"B<clone>(2) で作成された子プロセスと同様に、 呼び出し元は新しい名前空間ですべ"
"てのケーパビリティを獲得する。"

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: build/C/man2/unshare.2:215
msgid ""
"B<CLONE_NEWUSER> requires that the calling process is not threaded; "
"specifying B<CLONE_NEWUSER> automatically implies B<CLONE_THREAD>.  Since "
"Linux 3.9, B<CLONE_NEWUSER> also automatically implies B<CLONE_FS>.  "
"B<CLONE_NEWUSER> requires that the user ID and group ID of the calling "
"process are mapped to user IDs and group IDs in the user namespace of the "
"calling process at the time of the call."
msgstr ""
"B<CLONE_NEWUSER> を使うには、呼び出し元プロセスがスレッド化されていないことが"
"必要である。 B<CLONE_NEWUSER> を指定すると、自動的に B<CLONE_THREAD> が指定さ"
"れたものとみなされる。 Linux 3.9 以降では、 B<CLONE_NEWUSER> が指定された場"
"合 B<CLONE_FS> も指定されたとみなされる。 B<CLONE_NEWUSER> を使うには、呼び出"
"し元プロセスのユーザー ID とグループ ID が、 呼び出した時点で、 呼び出し元プ"
"ロセスのユーザー名前空間のユーザー ID とグループ ID にマッピングされている必"
"要がある。"

#. type: Plain text
#: build/C/man2/unshare.2:218
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr "ユーザー名前空間の詳細は B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:232
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWUTS> フラグと同じ効果を持つ。 UTS\n"
"IPC 名前空間を共有せず、呼び出し元プロセスは他のプロセスとは共有しない\n"
"固有の UTS IPC 名前空間のコピーを持つ。 このフラグを指定すると、\n"
"B<CLONE_FS> も暗黙のうちに指定される。B<CLONE_NEWUTS> を使用するには\n"
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/unshare.2:232
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.6.26 以降)"

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  CLONE_NEWNS If CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#. type: Plain text
#: build/C/man2/unshare.2:252
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System\\ V semaphore adjustment (I<semadj>)  values, so that the "
"calling process has a new empty I<semadj> list that is not shared with any "
"other process.  If this is the last process that has a reference to the "
"process's current I<semadj> list, then the adjustments in that list are "
"applied to the corresponding semaphores, as described in B<semop>(2)."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_SYSVSEM> フラグの効果を逆転させる。 System"
"\\ V セマフォの調整値 (I<semadj>) を共有せず、 呼び出し元プロセスは他のプロセ"
"スとは共有されない新しい空の I<semadj> リストを持つ。 そのプロセスが、自分の"
"現在の I<semadj> リストへの参照を持つ最後のプロセスであれば、 このリストの調"
"整値は対応するセマフォに適用される (B<semop>(2) に説明がある通り)。"

#
#.  As at 3.9, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  See kernel/fork.c::check_unshare_flags()
#. type: Plain text
#: build/C/man2/unshare.2:279
msgid ""
"In addition, B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> can be "
"specified in I<flags> if the caller is single threaded (i.e., it is not "
"sharing its address space with another process or thread).  In this case, "
"these flags have no effect.  (Note also that specifying B<CLONE_THREAD> "
"automatically implies B<CLONE_VM>, and specifying B<CLONE_VM> automatically "
"implies B<CLONE_SIGHAND>.)  If the process is multithreaded, then the use of "
"these flags results in an error."
msgstr ""
"上記に加えて、 呼び出し元がシングルスレッドの場合 (すなわち別のプロセスやス"
"レッドとアドレス空間を共有していない場合)、 B<CLONE_THREAD>, "
"B<CLONE_SIGHAND>, B<CLONE_VM> を指定することができる。 この場合、 これらのフ"
"ラグは効果を持たない。 (B<CLONE_THREAD> を指定すると自動的に B<CLONE_VM> が指"
"定されたとみなされ、 B<CLONE_VM> を指定すると自動的に B<CLONE_SIGHAND> が指定"
"されたとみなされる点に注意してほしい。) プロセスがマルチスレッドの場合、 これ"
"らのフラグを使用するとエラーとなる。"

#. type: Plain text
#: build/C/man2/unshare.2:286
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""
"I<flags> に 0 が指定された場合、 B<unshare>()  は何も行わないので、 呼び出し"
"元プロセスの実行コンテキストは、何も変更されない。"

#. type: Plain text
#: build/C/man2/unshare.2:291
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""
"成功した場合は 0 が返される。 失敗した場合は -1 が返されて、 I<errno> にはエ"
"ラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/unshare.2:296
msgid "An invalid bit was specified in I<flags>."
msgstr "I<flags> に不正なビットが指定された。"

#. type: Plain text
#: build/C/man2/unshare.2:305
msgid ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, or B<CLONE_VM> was specified in I<flags>, "
"and the caller is multithreaded."
msgstr ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, B<CLONE_VM> が I<flags> に指定されたが、 "
"呼び出したプロセスはマルチスレッドである。"

#. type: Plain text
#: build/C/man2/unshare.2:315
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""
"I<flags> に B<CLONE_NEWIPC> が指定されたが、カーネルでオプション "
"B<CONFIG_SYSVIPC> と B<CONFIG_IPC_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:323
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWNET> が指定されたが、カーネルでオプション "
"B<CONFIG_NET_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:331
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWPID> が指定されたが、カーネルでオプション "
"B<CONFIG_PID_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:339
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr "I<flags> に B<CLONE_NEWUSER> が指定されたが、カーネルでオプション B<CONFIG_USER_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:347
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS_NS> option."
msgstr "I<flags> に B<CLONE_NEWUTS> が指定されたが、カーネルでオプション B<CONFIG_UTS_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:357
#, fuzzy
#| msgid ""
#| "B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not "
#| "configured with the B<CONFIG_PID_NS> option."
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the process has previously "
"called B<unshare>()  with the B<CLONE_NEWPID> flag."
msgstr ""
"I<flags> に B<CLONE_NEWPID> が指定されたが、カーネルでオプション "
"B<CONFIG_PID_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:361
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""
"呼び出し元のコンテキストのうち共有を解除する必要がある部分をコピーするため"
"に、 十分なメモリーが確保できなかった。"

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: build/C/man2/unshare.2:369
#, fuzzy
#| msgid ""
#| "B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
#| "limit on the number of nested user namespaces to be exceeded.  See "
#| "B<user_namespaces>(7)."
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""
"B<CLONE_NEWUSER> が I<flags> に指定されており、 この呼び出しによりネストされ"
"たユーザー名前空間数の上限を超えてしまう。 B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:378
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""
"B<CLONE_NEWUSER> が I<flags> に指定されており、 この呼び出しによりネストされ"
"たユーザー名前空間数の上限を超えてしまう。 B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:391
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:394
msgid ""
"The calling process did not have the required privileges for this operation."
msgstr "呼び出し元プロセスはこの操作を行うのに必要な特権を持っていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:402
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID "
"or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""
"B<CLONE_NEWUSER> が I<flags> に指定されたが、 呼び出し元の実効ユーザー ID も"
"しくは実効グループ ID が親名前空間にマッピングがない (B<user_namespaces>(7) "
"参照)。"

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: build/C/man2/unshare.2:412
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""
"B<CLONE_NEWUSER> が I<flags> に指定され、 呼び出し元が chroot された環境にい"
"る (すなわち、呼び出し元の root ディレクトリが呼び出し元が属するマウント名前"
"空間の root ディレクトリに一致しない)。"

#. type: TP
#: build/C/man2/unshare.2:412
#, no-wrap
msgid "B<EUSERS> (from Linux 3.11 to Linux 4.8)"
msgstr " B<EUSERS> (from Linux 3.11 to Linux 4.8)"

#. type: Plain text
#: build/C/man2/unshare.2:421
#, fuzzy
#| msgid ""
#| "B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
#| "limit on the number of nested user namespaces to be exceeded.  See "
#| "B<user_namespaces>(7)."
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""
"B<CLONE_NEWUSER> が I<flags> に指定されており、 この呼び出しによりネストされ"
"たユーザー名前空間数の上限を超えてしまう。 B<user_namespaces>(7) を参照。"

#. type: Plain text
#: build/C/man2/unshare.2:425
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr "B<unshare>()  システムコールは Linux カーネル 2.6.16 で追加された。"

#. type: Plain text
#: build/C/man2/unshare.2:429
msgid "The B<unshare>()  system call is Linux-specific."
msgstr "B<unshare>()  システムコールは Linux 固有である。"

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:463
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""
"B<clone>(2)  で新しいプロセスを生成したときに共有される全てのプロセス属性"
"を、 B<unshare>()  によって共有の解除ができるわけではない。 特に、カーネル "
"3.8 時点では、 B<unshare>()  に B<CLONE_SIGHAND>, B<CLONE_THREAD>, "
"B<CLONE_VM> の効果を取り消すためのフラグが実装されていない。 これらの機能は、"
"必要であれば将来追加されるかもしれない。"

#. type: Plain text
#: build/C/man2/unshare.2:472
msgid ""
"The program below provides a simple implementation of the B<unshare>(1)  "
"command, which unshares one or more namespaces and executes the command "
"supplied in its command-line arguments.  Here's an example of the use of "
"this program, running a shell in a new mount namespace, and verifying that "
"the original shell and the new shell are in separate mount namespaces:"
msgstr ""
"以下のプログラムは B<unshare>(1) コマンドの簡単な実装である。 このコマンド"
"は、1 つ以上の名前空間の unshare を行ってから、 コマンドライン引数で指定さ"
"れたコマンドを実行する。 以下はこのプログラムの使用例である。 新しいマウント"
"名前空間でシェルを実行し、 元のシェルと新しいシェルが別のマウント名前空間にい"
"ることを確認している。"

#. type: Plain text
#: build/C/man2/unshare.2:480
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"
msgstr ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"

#. type: Plain text
#: build/C/man2/unshare.2:486
msgid ""
"The differing output of the two B<readlink>(1)  commands shows that the two "
"shells are in different mount namespaces."
msgstr ""
"2 つの B<readlink>(1) コマンドの出力が違うことから、 2 つのシェルは異なるマウ"
"ント名前空間にいることが分かる。"

#. type: Plain text
#: build/C/man2/unshare.2:490
#, no-wrap
msgid "/* unshare.c\n"
msgstr "/* unshare.c\n"

#. type: Plain text
#: build/C/man2/unshare.2:499
#, no-wrap
msgid ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/unshare.2:502
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"

#. type: Plain text
#: build/C/man2/unshare.2:521
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -C   unshare cgroup namespace\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -t   unshare time namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -C   unshare cgroup namespace\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -t   unshare time namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/unshare.2:526
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"

#. type: Plain text
#: build/C/man2/unshare.2:528
#, no-wrap
msgid "    flags = 0;\n"
msgstr "    flags = 0;\n"

#. type: Plain text
#: build/C/man2/unshare.2:542
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"CimnptuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqC\\(aq: flags |= CLONE_NEWCGROUP;      break;\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqt\\(aq: flags |= CLONE_NEWTIME;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"CimnptuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqC\\(aq: flags |= CLONE_NEWCGROUP;      break;\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqt\\(aq: flags |= CLONE_NEWTIME;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man2/unshare.2:545
#, no-wrap
msgid ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"
msgstr ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"

#. type: Plain text
#: build/C/man2/unshare.2:548
#, no-wrap
msgid ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"
msgstr ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"

#. type: Plain text
#: build/C/man2/unshare.2:552
#, no-wrap
msgid ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: build/C/man2/unshare.2:561
msgid ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"
msgstr ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"

#.  commit f504d47be5e8fa7ecf2bf660b18b42e6960c0eb2
#. type: Plain text
#: build/C/man2/unshare.2:568
msgid ""
"I<Documentation/userspace-api/unshare.rst> in the Linux kernel source tree "
"(or I<Documentation/unshare.txt> before Linux 4.12)"
msgstr "Linux カーネルソース内の I<Documentation/userspace-api/unshare.rst> (Linux 4.12 より前では I<Documentation/unshare.txt>)"

#~ msgid ""
#~ "Unlike B<fork>(2), B<clone>()  allows the child process to share parts of "
#~ "its execution context with the calling process, such as the memory space, "
#~ "the table of file descriptors, and the table of signal handlers.  (Note "
#~ "that on this manual page, \"calling process\" normally corresponds to "
#~ "\"parent process\".  But see the description of B<CLONE_PARENT> below.)"
#~ msgstr ""
#~ "B<fork>(2) とは異なり、B<clone>() では、子プロセス (child process)  と呼び"
#~ "出し元のプロセスとが、メモリー空間、ファイルディスクリプターのテーブル、シ"
#~ "グナルハンドラーのテーブルなどの 実行コンテキストの一部を共有できる。 (こ"
#~ "のマニュアルにおける「呼び出し元のプロセス」は、通常は 「親プロセス」と一"
#~ "致する。但し、後述の B<CLONE_PARENT> の項も参照のこと)"

#~ msgid ""
#~ "I<flags> may also be bitwise-or'ed with zero or more of the following "
#~ "constants, in order to specify what is shared between the calling process "
#~ "and the child process:"
#~ msgstr ""
#~ "I<flags> には、以下の定数のうち 0個以上をビット毎の論理和 (bitwise-or)  を"
#~ "とったものを指定できる。これらの定数は呼び出し元のプロセスと 子プロセスの"
#~ "間で何を共有するかを指定する:"

#~ msgid "Store child thread ID at location I<ctid> in child memory."
#~ msgstr ""
#~ "子プロセスのメモリー内の I<ctid> が指す場所に子プロセスのスレッド ID を格"
#~ "納する。"

#~ msgid ""
#~ "If B<CLONE_NEWIPC> is set, then create the process in a new IPC "
#~ "namespace.  If this flag is not set, then (as with B<fork>(2)), the "
#~ "process is created in the same IPC namespace as the calling process.  "
#~ "This flag is intended for the implementation of containers."
#~ msgstr ""
#~ "B<CLONE_NEWIPC> が設定された場合、新しい IPC 名前空間 (namespace) でプロセ"
#~ "スを作成する。 このフラグが設定されていない場合、 (B<fork>(2)  の場合と同"
#~ "様) 呼び出し元のプロセスと同じ IPC 名前空間でプロセスが 作成される。 この"
#~ "フラグは、コンテナの実装での使用を意図して用意されたものである。"

#~ msgid ""
#~ "An IPC namespace provides an isolated view of System\\ V IPC objects (see "
#~ "B<svipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
#~ "B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
#~ "that IPC objects are identified by mechanisms other than filesystem "
#~ "pathnames."
#~ msgstr ""
#~ "IPC 名前空間は、独立の System\\ V IPC オブジェクト空間 (B<svipc>(7) 参照) "
#~ "を提供する 。 (Linux 2.6.30 以降では) 独立した POSIX メッセージキュー空間 "
#~ "(B<mq_overview>(7) 参照) も提供される。 これらの IPC 機構に共通の特徴とし"
#~ "て、 IPC オブジェクトはファイルシステムのパス名とは違った仕組みで識別され"
#~ "るという点がある。"

#~ msgid ""
#~ "Objects created in an IPC namespace are visible to all other processes "
#~ "that are members of that namespace, but are not visible to processes in "
#~ "other IPC namespaces."
#~ msgstr ""
#~ "ある IPC 名前空間に作成されたオブジェクトは、 その名前空間のメンバーである"
#~ "他のすべてのプロセスからも見えるが、 違う IPC 名前空間のプロセスからは見え"
#~ "ない。"

#~ msgid ""
#~ "When an IPC namespace is destroyed (i.e., when the last process that is a "
#~ "member of the namespace terminates), all IPC objects in the namespace are "
#~ "automatically destroyed."
#~ msgstr ""
#~ "IPC 名前空間が破棄される時 (すなわち、その名前空間のメンバーの最後のプロセ"
#~ "スが終了する時)、 その名前空間の全ての IPC オブジェクトは自動的に破棄され"
#~ "る。"

#~ msgid ""
#~ "If B<CLONE_NEWNET> is set, then create the process in a new network "
#~ "namespace.  If this flag is not set, then (as with B<fork>(2))  the "
#~ "process is created in the same network namespace as the calling process.  "
#~ "This flag is intended for the implementation of containers."
#~ msgstr ""
#~ "B<CLONE_NEWNET> が設定された場合、新しいネットワーク名前空間 (network "
#~ "namaspace)  でプロセスを作成する。 このフラグが設定されていない場合、 "
#~ "(B<fork>(2)  の場合と同様) 呼び出し元のプロセスと同じネットワーク名前空間"
#~ "でプロセスが 作成される。 このフラグは、コンテナの実装での使用を意図して用"
#~ "意されたものである。"

#~ msgid ""
#~ "A network namespace provides an isolated view of the networking stack "
#~ "(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
#~ "tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
#~ "trees, sockets, etc.).  A physical network device can live in exactly one "
#~ "network namespace.  A virtual network device (\"veth\") pair provides a "
#~ "pipe-like abstraction that can be used to create tunnels between network "
#~ "namespaces, and can be used to create a bridge to a physical network "
#~ "device in another namespace."
#~ msgstr ""
#~ "ネットワーク名前空間は、分離されたネットワークスタックを提供するものであ"
#~ "る (ネットワークスタックとは、 ネットワークデバイスインターフェース、IPv4 "
#~ "や IPv6 プロトコルスタック、 I</proc/net>、 I</sys/class/net> ディレクトリ"
#~ "ツリー、ソケットなどである)。 物理ネットワークデバイスが所属できるネット"
#~ "ワーク名前空間は一つだけである。 仮想ネットワークデバイス (\"veth\") のペ"
#~ "アにより パイプ風の抽象化 (abstraction) が実現されており、 これを使うこと"
#~ "で、ネットワーク名前空間間のトンネルを作成したり、 別の名前空間の物理ネッ"
#~ "トワークデバイスへのブリッジを作成したり することができる。"

#~ msgid ""
#~ "When a network namespace is freed (i.e., when the last process in the "
#~ "namespace terminates), its physical network devices are moved back to the "
#~ "initial network namespace (not to the parent of the process).  For "
#~ "further information on network namespaces, see B<namespaces>(7)."
#~ msgstr ""
#~ "ネットワーク名前空間が解放される時 (すなわち、その名前空間の最後のプロセス"
#~ "が終了する時)、 物理ネットワークデバイスは初期ネットワーク名前空間 "
#~ "(initial network namespace) に戻される (親プロセスのネットワーク名前空間に"
#~ "戻される訳ではない)。 ネットワーク名前空間のさらなる情報は "
#~ "B<namespaces>(7) を参照。"

#~ msgid ""
#~ "If B<CLONE_NEWPID> is set, then create the process in a new PID "
#~ "namespace.  If this flag is not set, then (as with B<fork>(2))  the "
#~ "process is created in the same PID namespace as the calling process.  "
#~ "This flag is intended for the implementation of containers."
#~ msgstr ""
#~ "B<CLONE_NEWPID> が設定された場合、新しい PID 名前空間でプロセスを作成す"
#~ "る。 このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼び出"
#~ "し元のプロセスと同じ PID 名前空間で プロセスが作成される。 このフラグは、"
#~ "コンテナの実装での使用を意図して用意されたものである。"

#~ msgid ""
#~ "A UTS namespace is the set of identifiers returned by B<uname>(2); among "
#~ "these, the domain name and the hostname can be modified by "
#~ "B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made "
#~ "to the identifiers in a UTS namespace are visible to all other processes "
#~ "in the same namespace, but are not visible to processes in other UTS "
#~ "namespaces."
#~ msgstr ""
#~ "UTS 名前空間は、 B<uname>(2)  が返す識別子の集合である。 識別子としてはド"
#~ "メイン名とホスト名があり、 それぞれ B<setdomainname>(2), "
#~ "B<sethostname>(2)  で修正することができる。 ある UTS 名前空間における識別"
#~ "子の変更は同じ名前空間の他のすべての プロセスに見えるが、別の UTS 名前空間"
#~ "のプロセスには見えない。"

#~ msgid ""
#~ "This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
#~ "altogether in Linux 2.6.38."
#~ msgstr ""
#~ "このフラグは Linux 2.6.25 以降ではI<非推奨>であり、\n"
#~ "Linux 2.6.38 で完全にI<削除>された。"

#~ msgid ""
#~ "Signals may be sent to a thread group as a whole (i.e., a TGID) using "
#~ "B<kill>(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
#~ msgstr ""
#~ "B<kill>(2)  を使ってスレッドグループ全体 (つまり TGID) にシグナルを送るこ"
#~ "ともできれば、 B<tgkill>(2)  を使って特定のスレッド (つまり TID) にシグナ"
#~ "ルを送ることもできる。"

#~ msgid ""
#~ "Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
#~ "signals can be pending either: for the whole process (i.e., deliverable "
#~ "to any member of the thread group), when sent with B<kill>(2); or for an "
#~ "individual thread, when sent with B<tgkill>(2).  A call to "
#~ "B<sigpending>(2)  returns a signal set that is the union of the signals "
#~ "pending for the whole process and the signals that are pending for the "
#~ "calling thread."
#~ msgstr ""
#~ "各々のスレッドは独自のシグナルマスクを持っており、 B<sigprocmask>(2)  で設"
#~ "定できる。 だが、処理待ちのシグナルには、 B<kill>(2)  で送信されるプロセス"
#~ "全体に対するもの (つまり、スレッドグループの どのメンバーにも配送できるも"
#~ "の) と、 B<tgkill>(2)  で送信される個々のスレッドに対するものがありえる。 "
#~ "B<sigpending>(2)  を呼び出すと、プロセス全体に対する処理待ちシグナルと呼び"
#~ "出し元の スレッドに対する処理待ちシグナルを結合したシグナル集合が返され"
#~ "る。"

#~ msgid ""
#~ "For some architectures, the order of the arguments for the system call "
#~ "differs from that shown above.  On the score, microblaze, ARM, ARM 64, PA-"
#~ "RISC, arc, Power PC, xtensa, and MIPS architectures, the order of the "
#~ "fourth and fifth arguments is reversed.  On the cris and s390 "
#~ "architectures, the order of the first and second arguments is reversed."
#~ msgstr ""
#~ "いくつかのアーキテクチャーでは、システムコールの引数の順序は上記とは異"
#~ "なっている。 microblaze, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa, "
#~ "MIPS アーキテクチャーでは、 4 番目と 5 番目の引数の順番が逆である。 "
#~ "cris と s390 アーキテクチャーでは、最初と 2 番目の引数の順番が逆である。"

#~ msgid ""
#~ "The prototype shown above is for the glibc wrapper function; the raw "
#~ "system call interface has no I<fn> or I<arg> argument, and changes the "
#~ "order of the arguments so that I<flags> is the first argument, and I<tls> "
#~ "is the last argument."
#~ msgstr ""
#~ "上記のプロトタイプは glibc ラッパー関数用のものである。 素のシステムコール"
#~ "のインターフェースには引数 I<fn> と I<arg> がない。 また、引数の順序が"
#~ "変わり、 I<flags> が最初の引数で、 I<tls> が最後の引数である。"

#~ msgid ""
#~ "Returned by B<clone>()  when a zero value is specified for I<child_stack>."
#~ msgstr "I<child_stack> にゼロを指定した場合に B<clone>()  が返す。"

#~ msgid ""
#~ "There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  "
#~ "as described in this manual page."
#~ msgstr ""
#~ "libc5 には B<clone>()  はない。glibc2 では B<clone>()  が提供されており、"
#~ "このマニュアルページに記載の通りである。"

#~ msgid ""
#~ "For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent "
#~ "wants no child-exit signal.  In 2.6.2 the need to give this together with "
#~ "B<CLONE_THREAD> disappeared.  This flag is still defined, but has no "
#~ "effect."
#~ msgstr ""
#~ "B<CLONE_DETACHED> というフラグが、2.5.32 で導入されて以来しばらくの間存在"
#~ "した。 このフラグは親プロセスが子プロセス終了のシグナルを必要としないこと"
#~ "を 表すものである。 2.6.2 で、 CLONE_DETATCHED を CLONE_THREAD と一緒に指"
#~ "定する必要はなくなった。 このフラグはまだ定義されているが、何の効果もな"
#~ "い。"

#~ msgid ""
#~ "This field contains flags controlling scheduling behavior.  Only one such "
#~ "flag is currently defined: B<SCHED_FLAG_RESET_ON_FORK>.  As a result of "
#~ "including this flag, children created by B<fork>(2)  do not inherit "
#~ "privileged scheduling policies.  See B<sched>(7)  for details."
#~ msgstr ""
#~ "このフィールドはスケジューリング動作の制御を行う。 現在のところ、サポート"
#~ "されているフラグは B<SCHED_FLAG_RESET_ON_FORK> の一つだけである。 このフラ"
#~ "グが指定されると、 B<fork>(2) で作成された子プロセスは特権が必要なスケ"
#~ "ジューリングポリシーを継承しない。 詳細は B<sched>(7) を参照。"

#~ msgid ""
#~ "A call to B<sched_setscheduler>(2), B<sched_setparam>(2), or "
#~ "B<sched_setattr>(2)  will put the B<SCHED_FIFO> (or B<SCHED_RR>) thread "
#~ "identified by I<pid> at the start of the list if it was runnable.  As a "
#~ "consequence, it may preempt the currently running thread if it has the "
#~ "same priority.  (POSIX.1-2001 specifies that the thread should go to the "
#~ "end of the list.)"
#~ msgstr ""
#~ "B<sched_setscheduler>(2), B<sched_setparam>(2), B<sched_setattr>(2) は "
#~ "I<pid> で指定された B<SCHED_FIFO> (または B<SCHED_RR>) スレッドが 実行可能"
#~ "な場合、リストの最初に置く。 結果として、もし優先度が同じだった場合、 現在"
#~ "実行中のスレッドに先んじるかもしれない。 (POSIX.1-2001 ではスレッドはリス"
#~ "トの最後に行くべきと規定されている。)"

#~ msgid ""
#~ "Given a file descriptor referring to a namespace, reassociate the calling "
#~ "thread with that namespace."
#~ msgstr ""
#~ "名前空間を参照するファイルディスクリプターを指定すると、\n"
#~ "呼び出したスレッドにその名前空間を関連付けしなおす。"

#~ msgid ""
#~ "The I<fd> argument is a file descriptor referring to one of the namespace "
#~ "entries in a I</proc/[pid]/ns/> directory; see B<namespaces>(7)  for "
#~ "further information on I</proc/[pid]/ns/>.  The calling thread will be "
#~ "reassociated with the corresponding namespace, subject to any constraints "
#~ "imposed by the I<nstype> argument."
#~ msgstr ""
#~ "I<fd> 引数は、 I</proc/[pid]/ns/> ディレクトリ内の名前空間エントリー\n"
#~ "のいずれかを参照するファイルディスクリプターである。\n"
#~ "I</proc/[pid]/ns/> の詳細は B<namespaces>(7) を参照。\n"
#~ "I<nstype> 引数で指定された制限の範囲内で、\n"
#~ "呼び出したスレッドに I<fd> に対応する名前空間を関連付けしなおす。"

#~ msgid ""
#~ "B<CLONE_NEWPID> behaves somewhat differently from the other I<nstype> "
#~ "values: reassociating the calling thread with a PID namespace changes "
#~ "only the PID namespace that child processes of the caller will be created "
#~ "in; it does not change the PID namespace of the caller itself.  "
#~ "Reassociating with a PID namespace is allowed only if the PID namespace "
#~ "specified by I<fd> is a descendant (child, grandchild, etc.)  of the PID "
#~ "namespace of the caller.  For further details on PID namespaces, see "
#~ "B<pid_namespaces>(7)."
#~ msgstr ""
#~ "B<CLONE_NEWPID> は他の I<nstype> 値の場合と少し違った動作をする。 呼び出し"
#~ "元スレッドを PID 名前空間に関連付けし直すと、 呼び出し元の子プロセスが作成"
#~ "される PID 名前空間が変更されるだけである。 呼び出し元自身の PID 名前空間"
#~ "は変更されない。 PID 名前空間を関連付けし直すことができるのは、 I<fd> で指"
#~ "定された PID 名前空間が呼び出し元の PID 名前空間の子孫 (子プロセス、孫プロ"
#~ "セスなど) の場合だけである。 PID 名前空間の詳細は B<pid_namespaces>(7) を"
#~ "参照。"

#~ msgid ""
#~ "A process reassociating itself with a user namespace must have the "
#~ "B<CAP_SYS_ADMIN> capability in the target user namespace.  Upon "
#~ "successfully joining a user namespace, a process is granted all "
#~ "capabilities in that namespace, regardless of its user and group IDs.  A "
#~ "multithreaded process may not change user namespace with B<setns>().  It "
#~ "is not permitted to use B<setns>()  to reenter the caller's current user "
#~ "namespace.  This prevents a caller that has dropped capabilities from "
#~ "regaining those capabilities via a call to B<setns>().  For security "
#~ "reasons, a process can't join a new user namespace if it is sharing "
#~ "filesystem-related attributes (the attributes whose sharing is controlled "
#~ "by the B<clone>(2)  B<CLONE_FS> flag) with another process.  For further "
#~ "details on user namespaces, see B<user_namespaces>(7)."
#~ msgstr ""
#~ "プロセスが自分自身をユーザー名前空間に再関連付けするには、 そのプロセスは"
#~ "変更後のユーザー名前空間において B<CAP_SYS_ADMIN> ケーパビリティを持ってい"
#~ "なければならない。 ユーザー名前空間への参加に成功すると、 そのユーザー ID "
#~ "やグループ ID に関わらず、 プロセスにはその名前空間におけるすべてのケーパ"
#~ "ビリティが認められる。 マルチスレッドのプロセスは B<setns>() でユーザー名"
#~ "前空間を変更できない。 B<setns>() を使って、呼び出し元が現在のユーザー名前"
#~ "空間に再度入ることは認められていない。 これにより、 いくつかのケーパビリ"
#~ "ティを外した呼び出し元が B<setns>() を呼び出すことでそれらのケーパビリティ"
#~ "を再度得ることを防ぐことができる。 セキュリティ上の理由から、 ファイルシス"
#~ "テム関連の属性 (共有が B<clone>(2) B<CLONE_FS> フラグで制御される属性) を"
#~ "別のプロセスと共有している場合、 プロセスは新しいユーザー名前空間に参加で"
#~ "きない。 ユーザー名前空間の詳細は B<user_namespaces>(7) を参照。"
