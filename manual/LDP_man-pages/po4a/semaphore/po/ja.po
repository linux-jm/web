# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:40+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/sem_close.3:25
#, no-wrap
msgid "SEM_CLOSE"
msgstr "SEM_CLOSE"

#. type: TH
#: build/C/man3/sem_close.3:25 build/C/man3/sem_destroy.3:25
#: build/C/man3/sem_init.3:25 build/C/man3/sem_open.3:25
#: build/C/man3/sem_post.3:25 build/C/man3/sem_unlink.3:25
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: TH
#: build/C/man3/sem_close.3:25 build/C/man3/sem_destroy.3:25
#: build/C/man3/sem_getvalue.3:25 build/C/man3/sem_init.3:25
#: build/C/man3/sem_open.3:25 build/C/man7/sem_overview.7:25
#: build/C/man3/sem_post.3:25 build/C/man3/sem_unlink.3:25
#: build/C/man3/sem_wait.3:25 build/C/man2/semctl.2:42 build/C/man2/semget.2:37
#: build/C/man2/semop.2:35
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/sem_close.3:25 build/C/man3/sem_destroy.3:25
#: build/C/man3/sem_getvalue.3:25 build/C/man3/sem_init.3:25
#: build/C/man3/sem_open.3:25 build/C/man7/sem_overview.7:25
#: build/C/man3/sem_post.3:25 build/C/man3/sem_unlink.3:25
#: build/C/man3/sem_wait.3:25 build/C/man2/semctl.2:42 build/C/man2/semget.2:37
#: build/C/man2/semop.2:35
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/sem_close.3:26 build/C/man3/sem_destroy.3:26
#: build/C/man3/sem_getvalue.3:26 build/C/man3/sem_init.3:26
#: build/C/man3/sem_open.3:26 build/C/man7/sem_overview.7:26
#: build/C/man3/sem_post.3:26 build/C/man3/sem_unlink.3:26
#: build/C/man3/sem_wait.3:26 build/C/man2/semctl.2:43 build/C/man2/semget.2:38
#: build/C/man2/semop.2:36
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/sem_close.3:28
msgid "sem_close - close a named semaphore"
msgstr "sem_close - 名前付きセマフォをクローズする"

#. type: SH
#: build/C/man3/sem_close.3:28 build/C/man3/sem_destroy.3:28
#: build/C/man3/sem_getvalue.3:28 build/C/man3/sem_init.3:28
#: build/C/man3/sem_open.3:28 build/C/man3/sem_post.3:28
#: build/C/man3/sem_unlink.3:28 build/C/man3/sem_wait.3:28
#: build/C/man2/semctl.2:45 build/C/man2/semget.2:40 build/C/man2/semop.2:38
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/sem_close.3:31 build/C/man3/sem_destroy.3:31
#: build/C/man3/sem_getvalue.3:31 build/C/man3/sem_init.3:31
#: build/C/man3/sem_post.3:31 build/C/man3/sem_unlink.3:31
#: build/C/man3/sem_wait.3:31
#, no-wrap
msgid "B<#include E<lt>semaphore.hE<gt>>\n"
msgstr "B<#include E<lt>semaphore.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/sem_close.3:33
#, no-wrap
msgid "B<int sem_close(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_close(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_close.3:36 build/C/man3/sem_destroy.3:36
#: build/C/man3/sem_getvalue.3:36 build/C/man3/sem_init.3:36
#: build/C/man3/sem_open.3:40 build/C/man3/sem_post.3:36
#: build/C/man3/sem_unlink.3:36 build/C/man3/sem_wait.3:40
msgid "Link with I<-pthread>."
msgstr "I<-pthread> とリンクする。"

#. type: SH
#: build/C/man3/sem_close.3:36 build/C/man3/sem_destroy.3:36
#: build/C/man3/sem_getvalue.3:36 build/C/man3/sem_init.3:36
#: build/C/man3/sem_open.3:40 build/C/man7/sem_overview.7:28
#: build/C/man3/sem_post.3:36 build/C/man3/sem_unlink.3:36
#: build/C/man3/sem_wait.3:48 build/C/man2/semctl.2:53 build/C/man2/semget.2:50
#: build/C/man2/semop.2:57
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/sem_close.3:42
msgid ""
"B<sem_close>()  closes the named semaphore referred to by I<sem>, allowing "
"any resources that the system has allocated to the calling process for this "
"semaphore to be freed."
msgstr ""
"B<sem_close>()  は I<sem> が参照する名前付きセマフォをクローズし、 このセマ"
"フォ用に呼び出し元プロセスにシステムが割り当てていた リソースを解放できるよう"
"にする。"

#. type: SH
#: build/C/man3/sem_close.3:42 build/C/man3/sem_destroy.3:54
#: build/C/man3/sem_getvalue.3:53 build/C/man3/sem_init.3:76
#: build/C/man3/sem_open.3:103 build/C/man3/sem_post.3:44
#: build/C/man3/sem_unlink.3:43 build/C/man3/sem_wait.3:107
#: build/C/man2/semctl.2:397 build/C/man2/semget.2:157 build/C/man2/semop.2:298
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/sem_close.3:48
msgid ""
"On success B<sem_close>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<sem_close>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値をセットする。"

#. type: SH
#: build/C/man3/sem_close.3:48 build/C/man3/sem_destroy.3:60
#: build/C/man3/sem_getvalue.3:59 build/C/man3/sem_init.3:82
#: build/C/man3/sem_open.3:115 build/C/man3/sem_post.3:51
#: build/C/man3/sem_unlink.3:49 build/C/man3/sem_wait.3:113
#: build/C/man2/semctl.2:450 build/C/man2/semget.2:163 build/C/man2/semop.2:308
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/sem_close.3:49 build/C/man3/sem_destroy.3:61
#: build/C/man3/sem_getvalue.3:60 build/C/man3/sem_init.3:83
#: build/C/man3/sem_open.3:131 build/C/man3/sem_open.3:136
#: build/C/man3/sem_post.3:52 build/C/man3/sem_wait.3:118
#: build/C/man3/sem_wait.3:132 build/C/man2/semctl.2:484
#: build/C/man2/semget.2:187 build/C/man2/semget.2:193 build/C/man2/semop.2:356
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/sem_close.3:53 build/C/man3/sem_destroy.3:65
#: build/C/man3/sem_post.3:56 build/C/man3/sem_wait.3:122
msgid "I<sem> is not a valid semaphore."
msgstr "I<sem> は有効なセマフォではない。"

#. type: SH
#: build/C/man3/sem_close.3:53 build/C/man3/sem_destroy.3:65
#: build/C/man3/sem_getvalue.3:67 build/C/man3/sem_init.3:94
#: build/C/man3/sem_open.3:169 build/C/man3/sem_post.3:60
#: build/C/man3/sem_unlink.3:61 build/C/man3/sem_wait.3:142
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/sem_close.3:56 build/C/man3/sem_destroy.3:68
#: build/C/man3/sem_getvalue.3:70 build/C/man3/sem_init.3:97
#: build/C/man3/sem_open.3:172 build/C/man3/sem_post.3:63
#: build/C/man3/sem_unlink.3:64 build/C/man3/sem_wait.3:145
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/sem_close.3:60 build/C/man3/sem_destroy.3:72
#: build/C/man3/sem_getvalue.3:74 build/C/man3/sem_init.3:101
#: build/C/man3/sem_open.3:176 build/C/man3/sem_post.3:67
#: build/C/man3/sem_unlink.3:68 build/C/man3/sem_wait.3:149
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/sem_close.3:60 build/C/man3/sem_destroy.3:72
#: build/C/man3/sem_getvalue.3:74 build/C/man3/sem_init.3:101
#: build/C/man3/sem_open.3:176 build/C/man3/sem_post.3:67
#: build/C/man3/sem_unlink.3:68 build/C/man3/sem_wait.3:149
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/sem_close.3:60 build/C/man3/sem_destroy.3:72
#: build/C/man3/sem_getvalue.3:74 build/C/man3/sem_init.3:101
#: build/C/man3/sem_open.3:176 build/C/man3/sem_post.3:67
#: build/C/man3/sem_unlink.3:68 build/C/man3/sem_wait.3:149
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/sem_close.3:63
#, no-wrap
msgid "B<sem_close>()"
msgstr "B<sem_close>()"

#. type: tbl table
#: build/C/man3/sem_close.3:63 build/C/man3/sem_destroy.3:75
#: build/C/man3/sem_getvalue.3:77 build/C/man3/sem_init.3:104
#: build/C/man3/sem_open.3:179 build/C/man3/sem_post.3:70
#: build/C/man3/sem_unlink.3:71 build/C/man3/sem_wait.3:154
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/sem_close.3:63 build/C/man3/sem_destroy.3:75
#: build/C/man3/sem_getvalue.3:77 build/C/man3/sem_init.3:104
#: build/C/man3/sem_open.3:179 build/C/man3/sem_post.3:70
#: build/C/man3/sem_unlink.3:71 build/C/man3/sem_wait.3:154
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/sem_close.3:66 build/C/man3/sem_destroy.3:77
#: build/C/man3/sem_getvalue.3:79 build/C/man3/sem_init.3:106
#: build/C/man3/sem_open.3:182 build/C/man3/sem_post.3:72
#: build/C/man3/sem_unlink.3:73 build/C/man3/sem_wait.3:156
#: build/C/man2/semctl.2:526 build/C/man2/semget.2:220 build/C/man2/semop.2:386
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/sem_close.3:68 build/C/man3/sem_destroy.3:79
#: build/C/man3/sem_getvalue.3:81 build/C/man3/sem_open.3:184
#: build/C/man3/sem_unlink.3:75 build/C/man3/sem_wait.3:158
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: SH
#: build/C/man3/sem_close.3:68 build/C/man3/sem_destroy.3:79
#: build/C/man3/sem_getvalue.3:81 build/C/man3/sem_init.3:108
#: build/C/man7/sem_overview.7:137 build/C/man3/sem_post.3:74
#: build/C/man2/semctl.2:541 build/C/man2/semget.2:224 build/C/man2/semop.2:389
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/sem_close.3:72
msgid ""
"All open named semaphores are automatically closed on process termination, "
"or upon B<execve>(2)."
msgstr ""
"オープンされたすべての名前付きセマフォは、プロセス終了時、もしくは "
"B<execve>(2)  実行時に自動的にクローズされる。"

#. type: SH
#: build/C/man3/sem_close.3:72 build/C/man3/sem_destroy.3:85
#: build/C/man3/sem_getvalue.3:85 build/C/man3/sem_init.3:118
#: build/C/man3/sem_open.3:184 build/C/man7/sem_overview.7:149
#: build/C/man3/sem_post.3:83 build/C/man3/sem_unlink.3:75
#: build/C/man3/sem_wait.3:266 build/C/man2/semctl.2:648
#: build/C/man2/semget.2:460 build/C/man2/semop.2:552
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/sem_close.3:79
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"

#. type: SH
#: build/C/man3/sem_close.3:79 build/C/man3/sem_destroy.3:90
#: build/C/man3/sem_getvalue.3:89 build/C/man3/sem_init.3:123
#: build/C/man3/sem_open.3:191 build/C/man7/sem_overview.7:160
#: build/C/man3/sem_post.3:88 build/C/man3/sem_unlink.3:81
#: build/C/man3/sem_wait.3:272 build/C/man2/semctl.2:655
#: build/C/man2/semget.2:467 build/C/man2/semop.2:561
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/sem_close.3:87 build/C/man3/sem_destroy.3:98
#: build/C/man3/sem_getvalue.3:97 build/C/man3/sem_init.3:131
#: build/C/man3/sem_open.3:199 build/C/man7/sem_overview.7:168
#: build/C/man3/sem_post.3:96 build/C/man3/sem_unlink.3:89
#: build/C/man3/sem_wait.3:280 build/C/man2/semctl.2:663
#: build/C/man2/semget.2:475 build/C/man2/semop.2:569
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/sem_destroy.3:25
#, no-wrap
msgid "SEM_DESTROY"
msgstr "SEM_DESTROY"

#. type: Plain text
#: build/C/man3/sem_destroy.3:28
msgid "sem_destroy - destroy an unnamed semaphore"
msgstr "sem_destroy - 名前なしセマフォを破棄する"

#. type: Plain text
#: build/C/man3/sem_destroy.3:33
#, no-wrap
msgid "B<int sem_destroy(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_destroy(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_destroy.3:40
msgid ""
"B<sem_destroy>()  destroys the unnamed semaphore at the address pointed to "
"by I<sem>."
msgstr ""
"B<sem_destroy>()  は I<sem> が指すアドレスにある名前なしセマフォを破棄する。"

#. type: Plain text
#: build/C/man3/sem_destroy.3:45
msgid ""
"Only a semaphore that has been initialized by B<sem_init>(3)  should be "
"destroyed using B<sem_destroy>()."
msgstr ""
"B<sem_destroy>()  を使って破棄するのは、 B<sem_init>(3)  で初期化したセマフォ"
"だけにすべきである。"

#. type: Plain text
#: build/C/man3/sem_destroy.3:50
msgid ""
"Destroying a semaphore that other processes or threads are currently blocked "
"on (in B<sem_wait>(3))  produces undefined behavior."
msgstr ""
"他のプロセスやスレッドが (B<sem_wait>(3)  で) 待ち状態になっているセマフォを"
"破棄した場合の挙動は定義されていない。"

#. type: Plain text
#: build/C/man3/sem_destroy.3:54
msgid ""
"Using a semaphore that has been destroyed produces undefined results, until "
"the semaphore has been reinitialized using B<sem_init>(3)."
msgstr ""
"すでに破棄されたセマフォを、 B<sem_init>(3)  を使って再初期化される前に使用し"
"た場合、その結果は未定義である。"

#. type: Plain text
#: build/C/man3/sem_destroy.3:60
msgid ""
"B<sem_destroy>()  returns 0 on success; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sem_destroy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値をセットする。"

#. type: tbl table
#: build/C/man3/sem_destroy.3:75
#, no-wrap
msgid "B<sem_destroy>()"
msgstr "B<sem_destroy>()"

#.  But not on NPTL, where sem_destroy () is a no-op..
#. type: Plain text
#: build/C/man3/sem_destroy.3:85
msgid ""
"An unnamed semaphore should be destroyed with B<sem_destroy>()  before the "
"memory in which it is located is deallocated.  Failure to do this can result "
"in resource leaks on some implementations."
msgstr ""
"名前なしセマフォは、そのセマフォが置かれているメモリーが解放される前に、 "
"B<sem_destroy>()  を使って破棄しておくべきである。これを行わなかった場合、実"
"装によっては リソースのリークが起こりえる。"

#. type: Plain text
#: build/C/man3/sem_destroy.3:90
msgid "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man3/sem_getvalue.3:25
#, no-wrap
msgid "SEM_GETVALUE"
msgstr "SEM_GETVALUE"

#. type: TH
#: build/C/man3/sem_getvalue.3:25 build/C/man7/sem_overview.7:25
#: build/C/man3/sem_wait.3:25
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:28
msgid "sem_getvalue - get the value of a semaphore"
msgstr "sem_getvalue - セマフォの値を取得する"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:33
#, no-wrap
msgid "B<int sem_getvalue(sem_t *>I<sem>B<, int *>I<sval>B<);>\n"
msgstr "B<int sem_getvalue(sem_t *>I<sem>B<, int *>I<sval>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:42
msgid ""
"B<sem_getvalue>()  places the current value of the semaphore pointed to "
"I<sem> into the integer pointed to by I<sval>."
msgstr ""
"B<sem_getvalue>()  は、 I<sem> が指すセマフォの現在の値を I<sval> で指す整数"
"に格納する。"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:53
msgid ""
"If one or more processes or threads are blocked waiting to lock the "
"semaphore with B<sem_wait>(3), POSIX.1 permits two possibilities for the "
"value returned in I<sval>: either 0 is returned; or a negative number whose "
"absolute value is the count of the number of processes and threads currently "
"blocked in B<sem_wait>(3).  Linux adopts the former behavior."
msgstr "POSIX.1 によると、 1つ以上のプロセスかスレッドが B<sem_wait>(3)  でセマフォのロック待ちで停止している場合、 I<sval> で返される値は 0 もしくは負の値のいずれかとなる。 負の値の場合、その絶対値は B<sem_wait>(3)  で現在停止しているプロセスかスレッドの合計数に等しい。 Linux は前者の動作 (0 を返す動作) を採用している。"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:59
msgid ""
"B<sem_getvalue>()  returns 0 on success; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sem_getvalue>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:67
msgid ""
"I<sem> is not a valid semaphore.  (The glibc implementation currently does "
"not check whether I<sem> is valid.)"
msgstr ""

#. type: tbl table
#: build/C/man3/sem_getvalue.3:77
#, no-wrap
msgid "B<sem_getvalue>()"
msgstr "B<sem_getvalue>()"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:85
msgid ""
"The value of the semaphore may already have changed by the time "
"B<sem_getvalue>()  returns."
msgstr ""
"B<sem_getvalue>()  が返るときには、すでにセマフォの値は変化している可能性があ"
"る。"

#. type: Plain text
#: build/C/man3/sem_getvalue.3:89
msgid "B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man3/sem_init.3:25
#, no-wrap
msgid "SEM_INIT"
msgstr "SEM_INIT"

#. type: Plain text
#: build/C/man3/sem_init.3:28
msgid "sem_init - initialize an unnamed semaphore"
msgstr "sem_init - 名前なしセマフォを初期化する"

#. type: Plain text
#: build/C/man3/sem_init.3:33
#, no-wrap
msgid "B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int >I<value>B<);>\n"
msgstr "B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_init.3:43
msgid ""
"B<sem_init>()  initializes the unnamed semaphore at the address pointed to "
"by I<sem>.  The I<value> argument specifies the initial value for the "
"semaphore."
msgstr ""
"B<sem_init>()  は、 I<sem> が指すアドレスにある名前なしセマフォを初期化す"
"る。 I<value> 引数はそのセマフォの初期値を指定する。"

#. type: Plain text
#: build/C/man3/sem_init.3:48
msgid ""
"The I<pshared> argument indicates whether this semaphore is to be shared "
"between the threads of a process, or between processes."
msgstr ""
"I<pshared> 引数は、このセマフォがプロセス内のスレッド間で共有されるのか、 "
"プロセス間で共有されるのか、を示す。"

#. type: Plain text
#: build/C/man3/sem_init.3:56
msgid ""
"If I<pshared> has the value 0, then the semaphore is shared between the "
"threads of a process, and should be located at some address that is visible "
"to all threads (e.g., a global variable, or a variable allocated dynamically "
"on the heap)."
msgstr ""
"I<pshared> が 0 の場合、セマフォはプロセス内のスレッド間で共有される。 セマ"
"フォはすべてのスレッドから参照可能なアドレスに配置すべきである (例えば、大域"
"変数や、ヒープ上に動的に割り当てられた変数など)。"

#. type: Plain text
#: build/C/man3/sem_init.3:73
msgid ""
"If I<pshared> is nonzero, then the semaphore is shared between processes, "
"and should be located in a region of shared memory (see B<shm_open>(3), "
"B<mmap>(2), and B<shmget>(2)).  (Since a child created by B<fork>(2)  "
"inherits its parent's memory mappings, it can also access the semaphore.)  "
"Any process that can access the shared memory region can operate on the "
"semaphore using B<sem_post>(3), B<sem_wait>(3), and so on."
msgstr ""
"I<pshared> が 0 以外の場合、セマフォはプロセス間で共有される。セマフォは 共有"
"メモリー領域に配置すべきである (B<shm_open>(3), B<mmap>(2), B<shmget>(2)  参"
"照)。 (B<fork>(2)  で生成された子プロセスは親プロセスのメモリーマッピングを継"
"承するため、 子プロセスもセマフォにアクセスできる。)  共有メモリー領域にアク"
"セスできるプロセスならば、どのプロセスでも B<sem_post>(3)  や "
"B<sem_wait>(3)  などを使ってセマフォを操作できる。"

#. type: Plain text
#: build/C/man3/sem_init.3:76
msgid ""
"Initializing a semaphore that has already been initialized results in "
"undefined behavior."
msgstr "すでに初期化済のセマフォを初期化した場合の挙動は定義されていない。"

#. type: Plain text
#: build/C/man3/sem_init.3:82
msgid ""
"B<sem_init>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"成功すると、 B<sem_init>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sem_init.3:88
msgid "I<value> exceeds B<SEM_VALUE_MAX>."
msgstr "I<value> が B<SEM_VALUE_MAX> を超えている。"

#. type: TP
#: build/C/man3/sem_init.3:88
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/sem_init.3:94
msgid ""
"I<pshared> is nonzero, but the system does not support process-shared "
"semaphores (see B<sem_overview>(7))."
msgstr ""
"I<pshared> が 0 以外だが、システムがプロセス共有セマフォをサポートしていない "
"(B<sem_overview>(7)  参照)。"

#. type: tbl table
#: build/C/man3/sem_init.3:104
#, no-wrap
msgid "B<sem_init>()"
msgstr "B<sem_init>()"

#. type: Plain text
#: build/C/man3/sem_init.3:108 build/C/man3/sem_post.3:74
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/sem_init.3:113
msgid ""
"Bizarrely, POSIX.1-2001 does not specify the value that should be returned "
"by a successful call to B<sem_init>().  POSIX.1-2008 rectifies this, "
"specifying the zero return on success."
msgstr ""
"妙なことに、POSIX.1-2001 は B<sem_init>()  が成功した場合に返すべき値を規定し"
"ていない。 POSIX.1-2008 ではこれが修正され、成功時には 0 を返すことが規定され"
"た。"

#. type: SH
#: build/C/man3/sem_init.3:113 build/C/man7/sem_overview.7:146
#: build/C/man3/sem_post.3:78 build/C/man3/sem_wait.3:158
#: build/C/man2/semctl.2:645 build/C/man2/semget.2:316 build/C/man2/semop.2:520
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/sem_init.3:118
msgid "See B<shm_open>(3)  and B<sem_wait>(3)."
msgstr "B<sem_open>(3) と B<sem_wait>(3) を参照。"

#. type: Plain text
#: build/C/man3/sem_init.3:123
msgid "B<sem_destroy>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_destroy>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man3/sem_open.3:25
#, no-wrap
msgid "SEM_OPEN"
msgstr "SEM_OPEN"

#. type: Plain text
#: build/C/man3/sem_open.3:28
msgid "sem_open - initialize and open a named semaphore"
msgstr "sem_open - 名前付きセマフォを初期化し、オープンする"

#. type: Plain text
#: build/C/man3/sem_open.3:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>semaphore.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>semaphore.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/sem_open.3:37
#, no-wrap
msgid ""
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<,>\n"
"B<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"
msgstr ""
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<,>\n"
"B<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_open.3:49
msgid ""
"B<sem_open>()  creates a new POSIX semaphore or opens an existing "
"semaphore.  The semaphore is identified by I<name>.  For details of the "
"construction of I<name>, see B<sem_overview>(7)."
msgstr ""
"B<sem_open>()  は、新規の POSIX セマフォを作成するか、既存のセマフォのオープ"
"ンを行う。 セマフォは I<name> で識別される。 I<name> の構成の詳細は "
"B<sem_overview>(7)  を参照。"

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: build/C/man3/sem_open.3:75
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  If B<O_CREAT> is specified in I<oflag>, then the "
"semaphore is created if it does not already exist.  The owner (user ID) of "
"the semaphore is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process.  If both B<O_CREAT> and B<O_EXCL> are specified in I<oflag>, then "
"an error is returned if a semaphore with the given I<name> already exists."
msgstr ""
"I<oflag> 引数には、 B<sem_open>()  の動作を制御するフラグを指定する (oflag "
"の値の定義は I<E<lt>fcntl.hE<gt>> のインクルードにより得られる)。 I<oflag> "
"に B<O_CREAT> が指定されると、まだ存在しない場合にはそのセマフォが作成され"
"る。 セマフォの所有者 (ユーザー ID)、グループ所有権 (グループ ID) には、 それ"
"ぞれ呼び出し元プロセスの実効 UID、実効 GID が設定される。 I<oflag> に "
"B<O_CREAT> と B<O_EXCL> の両方が指定された場合、指定された名前 I<name> のセマ"
"フォがすでに存在するとエラーが返される。"

#. type: Plain text
#: build/C/man3/sem_open.3:103
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on "
"the new semaphore, as for B<open>(2).  (Symbolic definitions for the "
"permissions bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The "
"permissions settings are masked against the process umask.  Both read and "
"write permission should be granted to each class of user that will access "
"the semaphore.  The I<value> argument specifies the initial value for the "
"new semaphore.  If B<O_CREAT> is specified, and a semaphore with the given "
"I<name> already exists, then I<mode> and I<value> are ignored."
msgstr ""
"I<oflag> に B<O_CREAT> を指定する場合、さらに引数が 2 つ必要である。 "
"I<mode> 引数は、 B<open>(2)  と同じように、新しいセマフォに設定されるアクセ"
"ス許可 (permission) を 指定する。許可設定はプロセスの umask でマスクされる "
"(許可ビットのシンボル定義は I<E<lt>sys/stat.hE<gt>> のインクルードにより得ら"
"れる)。 セマフォにアクセスしようとするユーザーは、読み出し許可と書き込み許可"
"の 両方を得る必要がある。 I<value> 引数は新しいセマフォの初期値を指定す"
"る。 B<O_CREAT> が指定され、指定した名前 I<name> のセマフォがすでに存在する場"
"合、 I<mode> と I<value> は無視される。"

#. type: Plain text
#: build/C/man3/sem_open.3:115
msgid ""
"On success, B<sem_open>()  returns the address of the new semaphore; this "
"address is used when calling other semaphore-related functions.  On error, "
"B<sem_open>()  returns B<SEM_FAILED>, with I<errno> set to indicate the "
"error."
msgstr ""
"成功すると、 B<sem_open>()  は新しいセマフォのアドレスを返す。 このアドレスは"
"他のセマフォ関連の関数を呼び出す際に使用される。 エラーの場合、 "
"B<sem_open>()  は B<SEM_FAILED> を返し、 I<errno> にエラーを示す値をセットす"
"る。"

#. type: TP
#: build/C/man3/sem_open.3:116 build/C/man3/sem_unlink.3:50
#: build/C/man2/semctl.2:454 build/C/man2/semget.2:167 build/C/man2/semop.2:320
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/sem_open.3:120
msgid ""
"The semaphore exists, but the caller does not have permission to open it."
msgstr ""
"そのセマフォが存在するが、呼び出し元にはそのセマフォをオープンする 許可がな"
"い。"

#. type: TP
#: build/C/man3/sem_open.3:120 build/C/man2/semget.2:175
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man3/sem_open.3:131
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a semaphore "
"with this I<name> already exists."
msgstr ""
"I<oflag> に B<O_CREAT> と B<O_EXCL> の両方が指定されたが、 I<name> という名前"
"のセマフォはすでに存在する。"

#. type: Plain text
#: build/C/man3/sem_open.3:136
msgid "I<value> was greater than B<SEM_VALUE_MAX>."
msgstr "I<value> が B<SEM_VALUE_MAX> よりも大きい。"

#. type: Plain text
#: build/C/man3/sem_open.3:140
msgid "I<name> consists of just \"/\", followed by no other characters."
msgstr ""
"I<name> が \"/\" だけで構成され、その後ろに他の文字が続いていなかった。"

#. type: TP
#: build/C/man3/sem_open.3:140
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man3/sem_open.3:143
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "オープンされたファイルディスクリプターの総数がプロセス単位の上限に達している。"

#. type: TP
#: build/C/man3/sem_open.3:143 build/C/man3/sem_unlink.3:53
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/sem_open.3:147 build/C/man3/sem_unlink.3:57
msgid "I<name> was too long."
msgstr "I<name> が長すぎる。"

#. type: TP
#: build/C/man3/sem_open.3:147
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man3/sem_open.3:150
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイル総数がシステム全体での上限に達している。"

#. type: TP
#: build/C/man3/sem_open.3:150 build/C/man3/sem_unlink.3:57
#: build/C/man2/semget.2:200
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#.  this error can occur if we have a name of the (nonportable) form
#.  /dir/name, and the directory /dev/shm/dir does not exist.
#. type: Plain text
#: build/C/man3/sem_open.3:166
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag> and no semaphore with this "
"I<name> exists; or, B<O_CREAT> was specified, but I<name> wasn't well formed."
msgstr ""
"I<oflag> に B<O_CREAT> フラグが指定されておらず、 I<name> という名前のセマ"
"フォも存在しない。 または、 B<O_CREAT> が指定されたが、 I<name> が適切な形式"
"ではなかった。"

#. type: TP
#: build/C/man3/sem_open.3:166 build/C/man2/semget.2:208
#: build/C/man2/semop.2:363
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/sem_open.3:169
msgid "Insufficient memory."
msgstr "十分なメモリーがない。"

#. type: tbl table
#: build/C/man3/sem_open.3:179
#, no-wrap
msgid "B<sem_open>()"
msgstr "B<sem_open>()"

#. type: Plain text
#: build/C/man3/sem_open.3:191
msgid ""
"B<sem_close>(3), B<sem_getvalue>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""
"B<sem_close>(3), B<sem_getvalue>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man7/sem_overview.7:25
#, no-wrap
msgid "SEM_OVERVIEW"
msgstr "SEM_OVERVIEW"

#. type: Plain text
#: build/C/man7/sem_overview.7:28
msgid "sem_overview - overview of POSIX semaphores"
msgstr "sem_overview - POSIX セマフォの概要"

#. type: Plain text
#: build/C/man7/sem_overview.7:30
msgid ""
"POSIX semaphores allow processes and threads to synchronize their actions."
msgstr ""
"POSIX セマフォを使用すると、プロセスやスレッド間でその動作を 同期させることが"
"できる。"

#. type: Plain text
#: build/C/man7/sem_overview.7:40
msgid ""
"A semaphore is an integer whose value is never allowed to fall below zero.  "
"Two operations can be performed on semaphores: increment the semaphore value "
"by one (B<sem_post>(3)); and decrement the semaphore value by one "
"(B<sem_wait>(3)).  If the value of a semaphore is currently zero, then a "
"B<sem_wait>(3)  operation will block until the value becomes greater than "
"zero."
msgstr ""
"セマフォは整数であり、その値は決して 0 未満になることは許されない。 セマフォ"
"に対してできる操作は 2 つである: セマフォ値を 1 増やす (B<sem_post>(3)); セマ"
"フォ値を 1 減らす (B<sem_wait>(3))。 セマフォの値がすでに 0 の場合、セマフォ"
"値が 0 より大きくなるまで B<sem_wait>(3)  操作は停止 (block) する。"

#. type: Plain text
#: build/C/man7/sem_overview.7:43
msgid ""
"POSIX semaphores come in two forms: named semaphores and unnamed semaphores."
msgstr ""
"POSIX セマフォには、名前付きセマフォ (named semaphore) と 名前なしセマフォ "
"(unnamed semaphore) の 2つの形がある。"

#. type: TP
#: build/C/man7/sem_overview.7:43
#, no-wrap
msgid "B<Named semaphores>"
msgstr "B<名前付きセマフォ>"

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory tree must exist under /dev/shm, and
#.  the fist subdirectory component must exist as the name
#.  sem.name, and all of the subdirectory components must allow the
#.  required permissions if a user wants to create a semaphore
#.  object in a subdirectory.
#. type: Plain text
#: build/C/man7/sem_overview.7:63
msgid ""
"A named semaphore is identified by a name of the form I</somename>; that is, "
"a null-terminated string of up to B<NAME_MAX>I<-4> (i.e., 251) characters "
"consisting of an initial slash, followed by one or more characters, none of "
"which are slashes.  Two processes can operate on the same named semaphore by "
"passing the same name to B<sem_open>(3)."
msgstr ""
"名前付きセマフォは I</somename> という形式の名前で識別される。 その名前は、最"
"大で B<NAME_MAX>I<-4> (すなわち 251) 文字のヌル終端された文字列で、 スラッ"
"シュで始まり、スラッシュ以外の文字が 1 文字以上続く形式である。 "
"B<sem_open>(3)  に同じ名前を渡すことにより、2 つのプロセス間で同じ名前のセマ"
"フォ に対し操作を行うことができる。"

#. type: Plain text
#: build/C/man7/sem_overview.7:78
msgid ""
"The B<sem_open>(3)  function creates a new named semaphore or opens an "
"existing named semaphore.  After the semaphore has been opened, it can be "
"operated on using B<sem_post>(3)  and B<sem_wait>(3).  When a process has "
"finished using the semaphore, it can use B<sem_close>(3)  to close the "
"semaphore.  When all processes have finished using the semaphore, it can be "
"removed from the system using B<sem_unlink>(3)."
msgstr ""
"B<sem_open>(3)  関数は、新しい名前付きセマフォを作成するか、既に存在する名前"
"付き セマフォをオープンする。 セマフォをオープンした後は、 B<sem_post>(3)  "
"と B<sem_wait>(3)  を使ってセマフォを操作できる。 プロセスがセマフォの使用を"
"終えた際は、 B<sem_close>(3)  を使ってセマフォをクローズできる。 あるセマフォ"
"をどのプロセスも使用しなくなると、 B<sem_unlink>(3)  を使ってそのセマフォをシ"
"ステムから削除することができる。"

#. type: TP
#: build/C/man7/sem_overview.7:78
#, no-wrap
msgid "B<Unnamed semaphores (memory-based semaphores)>"
msgstr "B<名前なしセマフォ (メモリーベースセマフォ)>"

#. type: Plain text
#: build/C/man7/sem_overview.7:93
msgid ""
"An unnamed semaphore does not have a name.  Instead the semaphore is placed "
"in a region of memory that is shared between multiple threads (a I<thread-"
"shared semaphore>)  or processes (a I<process-shared semaphore>).  A thread-"
"shared semaphore is placed in an area of memory shared between the threads "
"of a process, for example, a global variable.  A process-shared semaphore "
"must be placed in a shared memory region (e.g., a System V shared memory "
"segment created using B<shmget>(2), or a POSIX shared memory object built "
"created using B<shm_open>(3))."
msgstr ""
"名前なしセマフォは名前を持たない。その代わり、セマフォは、 複数スレッド間で共"
"有されるメモリー領域、もしくは複数プロセス間で 共有されたメモリー領域に置かれ"
"る (前者を I<スレッド共有セマフォ (thread-shared semaphore)>、 後者を I<プロ"
"セス共有セマフォ (process-shared semaphore)> と呼ぶ)。スレッド共有セマフォ"
"は、同じプロセス内のスレッド間で共有される メモリー領域、例えば大域変数 "
"(global variable) に配置される。 プロセス共有セマフォは、共有メモリー領域 (例"
"えば、 B<shmget>(2)  を使って作成できる System V 共有メモリーセグメントや "
"B<shm_open>(3)  を使って作成できる POSIX 共有メモリーオブジェクト)  内に配置"
"しなければならない。"

#. type: Plain text
#: build/C/man7/sem_overview.7:104
msgid ""
"Before being used, an unnamed semaphore must be initialized using "
"B<sem_init>(3).  It can then be operated on using B<sem_post>(3)  and "
"B<sem_wait>(3).  When the semaphore is no longer required, and before the "
"memory in which it is located is deallocated, the semaphore should be "
"destroyed using B<sem_destroy>(3)."
msgstr ""
"名前なしセマフォは、使用する前に B<sem_init>(3)  を使って初期化しなければなら"
"ない。 セマフォは B<sem_post>(3)  と B<sem_wait>(3)  を使って操作できる。 セ"
"マフォがもはや必要なくなったときや、 セマフォが置かれているメモリーを解放する"
"前には、 B<sem_destroy>(3)  を使ってセマフォを破棄すべきである。"

#. type: Plain text
#: build/C/man7/sem_overview.7:107
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX semaphores."
msgstr ""
"この節の残りでは、POSIX セマフォの Linux の実装の詳細 について説明する。"

#. type: SS
#: build/C/man7/sem_overview.7:107
#, no-wrap
msgid "Versions"
msgstr "Versions"

#. type: Plain text
#: build/C/man7/sem_overview.7:113
msgid ""
"Prior to kernel 2.6, Linux supported only unnamed, thread-shared "
"semaphores.  On a system with Linux 2.6 and a glibc that provides the NPTL "
"threading implementation, a complete implementation of POSIX semaphores is "
"provided."
msgstr ""
"バージョン 2.6 より前のカーネルでは、Linux は 名前なしのスレッド共有セマフォ"
"のみをサポートしていた。 Linux 2.6 と NPTL スレッド実装を提供している glibc "
"が入った システムでは、POSIX セマフォの完全な実装が提供される。"

#. type: SS
#: build/C/man7/sem_overview.7:113
#, no-wrap
msgid "Persistence"
msgstr "持続性"

#. type: Plain text
#: build/C/man7/sem_overview.7:118
msgid ""
"POSIX named semaphores have kernel persistence: if not removed by "
"B<sem_unlink>(3), a semaphore will exist until the system is shut down."
msgstr ""
"POSIX 名前付きセマフォはカーネル内で保持される。 B<sem_unlink>(3)  で削除され"
"なければ、セマフォは システムがシャットダウンされるまで存在し続ける。"

#. type: SS
#: build/C/man7/sem_overview.7:118
#, no-wrap
msgid "Linking"
msgstr "リンク"

#. type: Plain text
#: build/C/man7/sem_overview.7:123
msgid ""
"Programs using the POSIX semaphores API must be compiled with I<cc -pthread> "
"to link against the real-time library, I<librt>."
msgstr ""
"POSIX セマフォ API を使用したプログラムは I<cc -pthread> でコンパイルし、リア"
"ルタイムライブラリ I<librt> とリンクしなければならない。"

#. type: SS
#: build/C/man7/sem_overview.7:123
#, no-wrap
msgid "Accessing named semaphores via the filesystem"
msgstr "ファイルシステム経由での名前付きセマフォへのアクセス"

#. type: Plain text
#: build/C/man7/sem_overview.7:134
msgid ""
"On Linux, named semaphores are created in a virtual filesystem, normally "
"mounted under I</dev/shm>, with names of the form B<sem.>I<somename>.  (This "
"is the reason that semaphore names are limited to B<NAME_MAX>I<-4> rather "
"than B<NAME_MAX> characters.)"
msgstr ""
"Linux では、名前付きセマフォは仮想ファイルシステム (virtual file system) 内"
"に B<sem.>I<somename> という形の名前で作成される。仮想ファイルシステムは通常 "
"I</dev/shm> 以下にマウントされる。 (これが、セマフォの名前の文字数の上限が "
"B<NAME_MAX> ではなく B<NAME_MAX>I<-4> となっている理由である。)"

#. type: Plain text
#: build/C/man7/sem_overview.7:137
msgid ""
"Since Linux 2.6.19, ACLs can be placed on files under this directory, to "
"control object permissions on a per-user and per-group basis."
msgstr ""
"Linux 2.6.19 以降では、このディレクトリ配下のファイルに対して ACL を 設定で"
"き、オブジェクトへの許可をユーザー単位、グループ単位で制御することが できる。"

#. type: Plain text
#: build/C/man7/sem_overview.7:146
msgid ""
"System V semaphores (B<semget>(2), B<semop>(2), etc.) are an older semaphore "
"API.  POSIX semaphores provide a simpler, and better designed interface than "
"System V semaphores; on the other hand POSIX semaphores are less widely "
"available (especially on older systems) than System V semaphores."
msgstr ""
"System V セマフォ (B<semget>(2), B<semop>(2)  など) は古いセマフォ API であ"
"る。 POSIX セマフォは System V よりも 簡単で、うまく設計されたインターフェー"
"スを提供している。 一方で、POSIX セマフォは System V セマフォと比べると 利用"
"できるシステムが少ない (特に、古いシステムでは少ない)。"

#. type: Plain text
#: build/C/man7/sem_overview.7:149
msgid ""
"An example of the use of various POSIX semaphore functions is shown in "
"B<sem_wait>(3)."
msgstr ""
"各種の POSIX セマフォ関数を使用した例が B<sem_wait>(3)  に記載されている。"

#. type: Plain text
#: build/C/man7/sem_overview.7:160
msgid ""
"B<sem_close>(3), B<sem_destroy>(3), B<sem_getvalue>(3), B<sem_init>(3), "
"B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), "
"B<pthreads>(7), B<shm_overview>(7)"
msgstr "B<sem_close>(3), B<sem_destroy>(3), B<sem_getvalue>(3), B<sem_init>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), B<pthreads>(7), B<shm_overview>(7)"

#. type: TH
#: build/C/man3/sem_post.3:25
#, no-wrap
msgid "SEM_POST"
msgstr "SEM_POST"

#. type: Plain text
#: build/C/man3/sem_post.3:28
msgid "sem_post - unlock a semaphore"
msgstr "sem_post - セマフォのロックを解除する"

#. type: Plain text
#: build/C/man3/sem_post.3:33
#, no-wrap
msgid "B<int sem_post(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_post(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_post.3:44
msgid ""
"B<sem_post>()  increments (unlocks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value consequently becomes greater than zero, then another "
"process or thread blocked in a B<sem_wait>(3)  call will be woken up and "
"proceed to lock the semaphore."
msgstr ""
"B<sem_post>()  は、 I<sem> が指すセマフォの値を 1 増やす (ロックを解除する)。"
"その結果、 セマフォの値は 0 より大きな値に変化し、 B<sem_wait>(3)  で停止して"
"いる別のプロセスやスレッドが呼び起こされ、 セマフォをロックできるようになる。"

#. type: Plain text
#: build/C/man3/sem_post.3:51
msgid ""
"B<sem_post>()  returns 0 on success; on error, the value of the semaphore is "
"left unchanged, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sem_post>()  は 0 を返す。エラーの場合、セマフォの値は変更せず"
"に、 -1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: TP
#: build/C/man3/sem_post.3:56
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#.  Added in POSIX.1-2008 TC1 (Austin Interpretation 213)
#. type: Plain text
#: build/C/man3/sem_post.3:60
msgid "The maximum allowable value for a semaphore would be exceeded."
msgstr "一つのセマフォで使用できる最大値を超えてしまうところであった。"

#. type: tbl table
#: build/C/man3/sem_post.3:70
#, no-wrap
msgid "B<sem_post>()"
msgstr "B<sem_post>()"

#. type: Plain text
#: build/C/man3/sem_post.3:78
msgid ""
"B<sem_post>()  is async-signal-safe: it may be safely called within a signal "
"handler."
msgstr ""
"B<sem_post>()  は async-signal-safe である。 つまり、シグナルハンドラーの中で"
"も安全に呼び出すことができる。"

#. type: Plain text
#: build/C/man3/sem_post.3:83
msgid "See B<sem_wait>(3)  and B<shm_open>(3)."
msgstr "B<sem_wait>(3) と B<sem_open>(3) を参照。"

#. type: Plain text
#: build/C/man3/sem_post.3:88
msgid ""
"B<sem_getvalue>(3), B<sem_wait>(3), B<sem_overview>(7), B<signal-safety>(7)"
msgstr "B<sem_getvalue>(3), B<sem_wait>(3), B<sem_overview>(7), B<signal-safety>(7)"

#. type: TH
#: build/C/man3/sem_unlink.3:25
#, no-wrap
msgid "SEM_UNLINK"
msgstr "SEM_UNLINK"

#. type: Plain text
#: build/C/man3/sem_unlink.3:28
msgid "sem_unlink - remove a named semaphore"
msgstr "sem_unlink - 名前付きセマフォを削除する"

#. type: Plain text
#: build/C/man3/sem_unlink.3:33
#, no-wrap
msgid "B<int sem_unlink(const char *>I<name>B<);>\n"
msgstr "B<int sem_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_unlink.3:43
msgid ""
"B<sem_unlink>()  removes the named semaphore referred to by I<name>.  The "
"semaphore name is removed immediately.  The semaphore is destroyed once all "
"other processes that have the semaphore open close it."
msgstr ""
"B<sem_unlink>()  は、 I<name> で参照される名前付きセマフォを削除する。 セマ"
"フォの名前は直ちに削除される。 このセマフォをオープンしている他のすべてのプロ"
"セスがセマフォを 閉じて初めてセマフォの削除が行われる。"

#. type: Plain text
#: build/C/man3/sem_unlink.3:49
msgid ""
"On success B<sem_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<sem_unlink>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sem_unlink.3:53
msgid "The caller does not have permission to unlink this semaphore."
msgstr "呼び出し元にはこのセマフォを削除する許可がない。"

#. type: Plain text
#: build/C/man3/sem_unlink.3:61
msgid "There is no semaphore with the given I<name>."
msgstr "指定された名前 I<name> のセマフォが存在しない。"

#. type: tbl table
#: build/C/man3/sem_unlink.3:71
#, no-wrap
msgid "B<sem_unlink>()"
msgstr "B<sem_unlink>()"

#. type: Plain text
#: build/C/man3/sem_unlink.3:81
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), "
"B<sem_overview>(7)"
msgstr ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), "
"B<sem_overview>(7)"

#. type: TH
#: build/C/man3/sem_wait.3:25
#, no-wrap
msgid "SEM_WAIT"
msgstr "SEM_WAIT"

#. type: Plain text
#: build/C/man3/sem_wait.3:28
msgid "sem_wait, sem_timedwait, sem_trywait - lock a semaphore"
msgstr "sem_wait, sem_timedwait, sem_trywait - セマフォをロックする"

#. type: Plain text
#: build/C/man3/sem_wait.3:33
#, no-wrap
msgid "B<int sem_wait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_wait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:35
#, no-wrap
msgid "B<int sem_trywait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_trywait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:37
#, no-wrap
msgid "B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec *>I<abs_timeout>B<);>\n"
msgstr "B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:44 build/C/man2/semop.2:53
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/sem_wait.3:48
msgid "B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/sem_wait.3:58
msgid ""
"B<sem_wait>()  decrements (locks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value is greater than zero, then the decrement proceeds, and "
"the function returns, immediately.  If the semaphore currently has the value "
"zero, then the call blocks until either it becomes possible to perform the "
"decrement (i.e., the semaphore value rises above zero), or a signal handler "
"interrupts the call."
msgstr ""
"B<sem_wait>()  は I<sem> が指すセマフォの値を 1 減らす (ロックする)。 セマ"
"フォの値が 0 より大きい場合、減算が実行され、関数は直ちに復帰する。 セマフォ"
"の現在値が 0 の場合には、減算を実行できるようになる (つまり、セマフォの値が "
"0 より大きな値になる) まで、もしくは シグナルハンドラーによって呼び出しが中断"
"されるまで、 関数呼び出しは停止 (block) する。"

#. type: Plain text
#: build/C/man3/sem_wait.3:68
msgid ""
"B<sem_trywait>()  is the same as B<sem_wait>(), except that if the decrement "
"cannot be immediately performed, then call returns an error (I<errno> set to "
"B<EAGAIN>)  instead of blocking."
msgstr ""
"B<sem_trywait>()  は B<sem_wait>()  と同じだが、セマフォ値の減算をすぐに実行"
"できなかった場合に、 停止 (block) するのではなくエラーで復帰する (I<errno> "
"に B<EAGAIN> がセットされる) 点が異なる。"

#. type: Plain text
#: build/C/man3/sem_wait.3:81
msgid ""
"B<sem_timedwait>()  is the same as B<sem_wait>(), except that I<abs_timeout> "
"specifies a limit on the amount of time that the call should block if the "
"decrement cannot be immediately performed.  The I<abs_timeout> argument "
"points to a structure that specifies an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"structure is defined as follows:"
msgstr ""
"B<sem_timedwait>()  は B<sem_wait>()  と同じだが、セマフォ値の減算をすぐに実"
"行できなかった場合に 関数呼び出しが停止する時間の上限を I<abs_timeout> で指定"
"する点が異なる。 I<abs_timeout> 引数は、タイムアウト時刻を指定する構造体へ"
"のポインターである。 この構造体には、タイムアウト時刻を時刻紀元 (Epoch; "
"1970-01-01 00:00:00 +0000 (UTC)) からの 経過時間 (秒＋ナノ秒) で指定する。 構"
"造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/sem_wait.3:88
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;      /* Seconds */\n"
"    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;      /* Seconds */\n"
"    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */\n"
"};\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:99
msgid ""
"If the timeout has already expired by the time of the call, and the "
"semaphore could not be locked immediately, then B<sem_timedwait>()  fails "
"with a timeout error (I<errno> set to B<ETIMEDOUT>)."
msgstr ""
"関数呼び出し時点ですでにタイムアウトに指定した時刻が過ぎており、 かつセマフォ"
"をすぐにロックできなかった場合は、 B<sem_timedwait>()  はタイムアウトエラー "
"(I<errno> に B<ETIMEDOUT> がセットされる) で失敗する。"

#. type: Plain text
#: build/C/man3/sem_wait.3:107
msgid ""
"If the operation can be performed immediately, then B<sem_timedwait>()  "
"never fails with a timeout error, regardless of the value of "
"I<abs_timeout>.  Furthermore, the validity of I<abs_timeout> is not checked "
"in this case."
msgstr ""
"セマフォ操作がすぐに実行できるときは、 I<abs_timeout> がどんな値であっても "
"B<sem_timedwait>()  が失敗することは決してない。さらにいうと、この場合には "
"I<abs_timeout> の正当性の検査は行われない。"

#. type: Plain text
#: build/C/man3/sem_wait.3:113
msgid ""
"All of these functions return 0 on success; on error, the value of the "
"semaphore is left unchanged, -1 is returned, and I<errno> is set to indicate "
"the error."
msgstr ""
"成功すると、これらの関数は 0 を返す。 エラーの場合、セマフォの値を変更せず"
"に、-1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: TP
#: build/C/man3/sem_wait.3:114 build/C/man2/semop.2:352
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man3/sem_wait.3:118
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr "呼び出しはシグナルハンドラーにより中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/sem_wait.3:125
msgid "The following additional error can occur for B<sem_trywait>():"
msgstr "B<sem_trywait>()  の場合には、上記に加えて以下のエラーも起こる。"

#. type: TP
#: build/C/man3/sem_wait.3:125 build/C/man2/semop.2:327
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/sem_wait.3:129
msgid ""
"The operation could not be performed without blocking (i.e., the semaphore "
"currently has the value zero)."
msgstr ""
"停止 (block) せずにロック操作を完了できなかった (つまり、 セマフォの現在の値"
"が 0 であった)。"

#. type: Plain text
#: build/C/man3/sem_wait.3:132
msgid "The following additional errors can occur for B<sem_timedwait>():"
msgstr "B<sem_timedwait>()  の場合、以下のエラーも起こる。"

#. type: Plain text
#: build/C/man3/sem_wait.3:137
msgid ""
"The value of I<abs_timeout.tv_nsecs> is less than 0, or greater than or "
"equal to 1000 million."
msgstr ""
"I<abs_timeout.tv_nsecs> の値が 0 未満、もしくは 1,000,000,000 以上である。"

#. type: TP
#: build/C/man3/sem_wait.3:137
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#.  POSIX.1-2001 also allows EDEADLK -- "A deadlock condition
#.  was detected", but this does not occur on Linux(?).
#. type: Plain text
#: build/C/man3/sem_wait.3:142
msgid "The call timed out before the semaphore could be locked."
msgstr "セマフォのロックに成功する前に時間切れとなった。"

#. type: tbl table
#: build/C/man3/sem_wait.3:154
#, no-wrap
msgid ""
"B<sem_wait>(),\n"
"B<sem_trywait>(),\n"
"B<sem_timedwait>()"
msgstr ""
"B<sem_wait>(),\n"
"B<sem_trywait>(),\n"
"B<sem_timedwait>()"

#. type: Plain text
#: build/C/man3/sem_wait.3:176
msgid ""
"The (somewhat trivial) program shown below operates on an unnamed "
"semaphore.  The program expects two command-line arguments.  The first "
"argument specifies a seconds value that is used to set an alarm timer to "
"generate a B<SIGALRM> signal.  This handler performs a B<sem_post>(3)  to "
"increment the semaphore that is being waited on in I<main()> using "
"B<sem_timedwait>().  The second command-line argument specifies the length "
"of the timeout, in seconds, for B<sem_timedwait>().  The following shows "
"what happens on two different runs of the program:"
msgstr ""
"以下に示す (ちょっとした) プログラムは名前なしセマフォの操作を行う。 プログラ"
"ムはコマンドライン引数を 2 つ取る。 最初の引数には、 B<SIGALRM> シグナル"
"を生成するためのアラームタイマーの設定に使われる値を 秒単位で指定する。このシ"
"グナルハンドラーは、 I<main()> 内で B<sem_timedwait>()  を使って待っているセ"
"マフォを、 B<sem_post>(3)  を使って加算する。 2番目の引数には、 "
"B<sem_timedwait>()  に渡すタイムアウトまでの時間を秒単位で指定する。"

#. type: Plain text
#: build/C/man3/sem_wait.3:186
#, no-wrap
msgid ""
"$B< ./a.out 2 3>\n"
"About to call sem_timedwait()\n"
"sem_post() from handler\n"
"sem_timedwait() succeeded\n"
"$B< ./a.out 2 1>\n"
"About to call sem_timedwait()\n"
"sem_timedwait() timed out\n"
msgstr ""
"$B< ./a.out 2 3>\n"
"About to call sem_timedwait()\n"
"sem_post() from handler\n"
"sem_timedwait() succeeded\n"
"$B< ./a.out 2 1>\n"
"About to call sem_timedwait()\n"
"sem_timedwait() timed out\n"

#. type: SS
#: build/C/man3/sem_wait.3:188 build/C/man2/semget.2:398
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/sem_wait.3:199
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:201
#, no-wrap
msgid "sem_t sem;\n"
msgstr "sem_t sem;\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:204
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:214
#, no-wrap
msgid ""
"static void\n"
"handler(int sig)\n"
"{\n"
"    write(STDOUT_FILENO, \"sem_post() from handler\\en\", 24);\n"
"    if (sem_post(&sem) == -1) {\n"
"        write(STDERR_FILENO, \"sem_post() failed\\en\", 18);\n"
"        _exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""
"static void\n"
"handler(int sig)\n"
"{\n"
"    write(STDOUT_FILENO, \"sem_post() from handler\\en\", 24);\n"
"    if (sem_post(&sem) == -1) {\n"
"        write(STDERR_FILENO, \"sem_post() failed\\en\", 18);\n"
"        _exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:221
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    struct timespec ts;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    struct timespec ts;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:227
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:230
#, no-wrap
msgid ""
"    if (sem_init(&sem, 0, 0) == -1)\n"
"        handle_error(\"sem_init\");\n"
msgstr ""
"    if (sem_init(&sem, 0, 0) == -1)\n"
"        handle_error(\"sem_init\");\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:232
#, no-wrap
msgid "    /* Establish SIGALRM handler; set alarm timer using argv[1] */\n"
msgstr "    /* Establish SIGALRM handler; set alarm timer using argv[1] */\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:238
#, no-wrap
msgid ""
"    sa.sa_handler = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_flags = 0;\n"
"    if (sigaction(SIGALRM, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""
"    sa.sa_handler = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_flags = 0;\n"
"    if (sigaction(SIGALRM, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:240
#, no-wrap
msgid "    alarm(atoi(argv[1]));\n"
msgstr "    alarm(atoi(argv[1]));\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:243
#, no-wrap
msgid ""
"    /* Calculate relative interval as current time plus\n"
"       number of seconds given argv[2] */\n"
msgstr ""
"    /* Calculate relative interval as current time plus\n"
"       number of seconds given argv[2] */\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:246
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:248
#, no-wrap
msgid "    ts.tv_sec += atoi(argv[2]);\n"
msgstr "    ts.tv_sec += atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:252
#, no-wrap
msgid ""
"    printf(\"main() about to call sem_timedwait()\\en\");\n"
"    while ((s = sem_timedwait(&sem, &ts)) == -1 && errno == EINTR)\n"
"        continue;       /* Restart if interrupted by handler */\n"
msgstr ""
"    printf(\"main() about to call sem_timedwait()\\en\");\n"
"    while ((s = sem_timedwait(&sem, &ts)) == -1 && errno == EINTR)\n"
"        continue;       /* Restart if interrupted by handler */\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:254
#, no-wrap
msgid "    /* Check what happened */\n"
msgstr "    /* Check what happened */\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:262
#, no-wrap
msgid ""
"    if (s == -1) {\n"
"        if (errno == ETIMEDOUT)\n"
"            printf(\"sem_timedwait() timed out\\en\");\n"
"        else\n"
"            perror(\"sem_timedwait\");\n"
"    } else\n"
"        printf(\"sem_timedwait() succeeded\\en\");\n"
msgstr ""
"    if (s == -1) {\n"
"        if (errno == ETIMEDOUT)\n"
"            printf(\"sem_timedwait() timed out\\en\");\n"
"        else\n"
"            perror(\"sem_timedwait\");\n"
"    } else\n"
"        printf(\"sem_timedwait() succeeded\\en\");\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:265
#, no-wrap
msgid ""
"    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/sem_wait.3:272
msgid ""
"B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7), "
"B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7), "
"B<time>(7)"

#. type: TH
#: build/C/man2/semctl.2:42
#, no-wrap
msgid "SEMCTL"
msgstr "SEMCTL"

#. type: TH
#: build/C/man2/semctl.2:42
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: Plain text
#: build/C/man2/semctl.2:45
msgid "semctl - System V semaphore control operations"
msgstr "semctl - System V セマフォの制御操作を行なう"

#. type: Plain text
#: build/C/man2/semctl.2:50 build/C/man2/semget.2:45 build/C/man2/semop.2:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/semctl.2:52
#, no-wrap
msgid "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"
msgstr "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"

#. type: Plain text
#: build/C/man2/semctl.2:63
msgid ""
"B<semctl>()  performs the control operation specified by I<cmd> on the System"
"\\ V semaphore set identified by I<semid>, or on the I<semnum>-th semaphore "
"of that set.  (The semaphores in a set are numbered starting at 0.)"
msgstr ""
"B<semctl>()  は、 I<semid> で指定された System\\ V セマフォ集合 (semaphore "
"set)  またはセマフォ集合の I<semnun> 番目のセマフォに対して、 I<cmd> で指定さ"
"れた制御操作を行なう (集合内のセマフォの番号は 0 から始まる)。"

#. type: Plain text
#: build/C/man2/semctl.2:69
msgid ""
"This function has three or four arguments, depending on I<cmd>.  When there "
"are four, the fourth has the type I<union semun>.  The I<calling program> "
"must define this union as follows:"
msgstr ""
"この関数は、 I<cmd> の値に依存して、3 個または 4 個の引数を持つ。 引数が "
"4 個の場合、第 4 引数の型は I<union semun> である。 I<呼び出し元プログラム>"
"は、 この共用体 (union) を以下のように定義しなければならない。"

#. type: Plain text
#: build/C/man2/semctl.2:79
#, no-wrap
msgid ""
"union semun {\n"
"    int              val;    /* Value for SETVAL */\n"
"    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n"
"    unsigned short  *array;  /* Array for GETALL, SETALL */\n"
"    struct seminfo  *__buf;  /* Buffer for IPC_INFO\n"
"                                (Linux-specific) */\n"
"};\n"
msgstr ""
"union semun {\n"
"    int              val;    /* SETVAL の値 */\n"
"    struct semid_ds *buf;    /* IPC_STAT, IPC_SET 用のバッファー */\n"
"    unsigned short  *array;  /* GETALL, SETALL 用の配列 */\n"
"    struct seminfo  *__buf;  /* IPC_INFO 用のバッファー\n"
"                                (Linux 固有) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/semctl.2:85
msgid ""
"The I<semid_ds> data structure is defined in I<E<lt>sys/sem.hE<gt>> as "
"follows:"
msgstr ""
"I<semid_ds> データ構造体は I<E<lt>sys/sem.hE<gt>> で以下のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man2/semctl.2:95
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* Ownership and permissions */\n"
"    time_t          sem_otime; /* Last semop time */\n"
"    time_t          sem_ctime; /* Creation time/time of last\n"
"                                  modification via semctl() */\n"
"    unsigned long   sem_nsems; /* No. of semaphores in set */\n"
"};\n"
msgstr ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* 所有権と許可 */\n"
"    time_t          sem_otime; /* 最後の semop の時刻 */\n"
"    time_t          sem_ctime; /* 作成時刻/semctl() により\n"
"                                  最後に変更が行われた時刻 */\n"
"    unsigned long   sem_nsems; /* 集合内のセマフォの数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/semctl.2:101
msgid "The fields of the I<semid_ds> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:101
#, no-wrap
msgid "I<sem_perm>"
msgstr "I<sem_perm>"

#. type: Plain text
#: build/C/man2/semctl.2:107
msgid ""
"This is an I<ipc_perm> structure (see below) that specifies the access "
"permissions on the semaphore set."
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:107
#, no-wrap
msgid "I<sem_otime>"
msgstr "I<sem_otime>"

#. type: Plain text
#: build/C/man2/semctl.2:112
msgid "Time of last B<semop>(2)  system call."
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:112
#, no-wrap
msgid "I<sem_ctime>"
msgstr "I<sem_ctime>"

#. type: Plain text
#: build/C/man2/semctl.2:121
msgid ""
"Time of creation of semaphore set or time of last B<semctl>()  B<IPCSET>, "
"B<SETVAL>, or B<SETALL> operation."
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:121
#, no-wrap
msgid "I<sem_nsems>"
msgstr "I<sem_nsems>"

#. type: Plain text
#: build/C/man2/semctl.2:129
msgid ""
"Number of semaphores in the set.  Each semaphore of the set is referenced by "
"a nonnegative integer ranging from B<0> to I<sem_nsems-1>."
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:135
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"I<ipc_perm> 構造体は以下のように定義されている (強調されたフィールドは "
"B<IPC_SET> を使って設定可能である):"

#. type: Plain text
#: build/C/man2/semctl.2:147
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key; /* Key supplied to semget(2) */\n"
"    uid_t          B<uid>;   /* Effective UID of owner */\n"
"    gid_t          B<gid>;   /* Effective GID of owner */\n"
"    uid_t          cuid;  /* Effective UID of creator */\n"
"    gid_t          cgid;  /* Effective GID of creator */\n"
"    unsigned short B<mode>;  /* Permissions */\n"
"    unsigned short __seq; /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key; /* semget(2) に与えられるキー */\n"
"    uid_t          B<uid>;   /* 所有者 (owner) の実効 UID */\n"
"    gid_t          B<gid>;   /* 所有者の実効 GID */\n"
"    uid_t          cuid;  /* 作成者 (creator) の実効 UID */\n"
"    gid_t          cgid;  /* 作成者の実効 GID */\n"
"    unsigned short B<mode>;  /* 許可 */\n"
"    unsigned short __seq; /* シーケンス番号 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/semctl.2:156
msgid ""
"The least significant 9 bits of the I<mode> field of the I<ipc_perm> "
"structure define the access permissions for the shared memory segment.  The "
"permission bits are as follows:"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:158
#, no-wrap
msgid "0400"
msgstr "0400"

#. type: tbl table
#: build/C/man2/semctl.2:158
#, no-wrap
msgid "Read by user"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:159
#, no-wrap
msgid "0200"
msgstr "0200"

#. type: tbl table
#: build/C/man2/semctl.2:159
#, no-wrap
msgid "Write by user"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:160
#, no-wrap
msgid "0040"
msgstr "0040"

#. type: tbl table
#: build/C/man2/semctl.2:160
#, no-wrap
msgid "Read by group"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:161
#, no-wrap
msgid "0020"
msgstr "0020"

#. type: tbl table
#: build/C/man2/semctl.2:161
#, no-wrap
msgid "Write by group"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:162
#, no-wrap
msgid "0004"
msgstr "0004"

#. type: tbl table
#: build/C/man2/semctl.2:162
#, no-wrap
msgid "Read by others"
msgstr ""

#. type: tbl table
#: build/C/man2/semctl.2:163
#, no-wrap
msgid "0002"
msgstr "0002"

#. type: tbl table
#: build/C/man2/semctl.2:163
#, no-wrap
msgid "Write by others"
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:168
msgid ""
"In effect, \"write\" means \"alter\" for a semaphore set.  Bits 0100, 0010, "
"and 0001 (the execute bits) are unused by the system."
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:172
msgid "Valid values for I<cmd> are:"
msgstr "I<cmd> として有効な値は次の通りである。"

#. type: TP
#: build/C/man2/semctl.2:172
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man2/semctl.2:184
msgid ""
"Copy information from the kernel data structure associated with I<semid> "
"into the I<semid_ds> structure pointed to by I<arg.buf>.  The argument "
"I<semnum> is ignored.  The calling process must have read permission on the "
"semaphore set."
msgstr ""
"I<semid> に関連づけられたカーネルデータ構造体の情報を I<arg.buf> で指された "
"I<semid_ds> 構造体へコピーする。 I<semnum> 引数は無視される。 呼び出したプ"
"ロセスはそのセマフォ集合に対する 読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:184
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man2/semctl.2:194
msgid ""
"Write the values of some members of the I<semid_ds> structure pointed to by "
"I<arg.buf> to the kernel data structure associated with this semaphore set, "
"updating also its I<sem_ctime> member."
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:200
msgid ""
"The following members of the structure are updated: I<sem_perm.uid>, "
"I<sem_perm.gid>, and (the least significant 9 bits of)  I<sem_perm.mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:209
msgid ""
"The effective UID of the calling process must match the owner (I<sem_perm."
"uid>)  or creator (I<sem_perm.cuid>)  of the semaphore set, or the caller "
"must be privileged.  The argument I<semnum> is ignored."
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:209
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man2/semctl.2:224
msgid ""
"Immediately remove the semaphore set, awakening all processes blocked in "
"B<semop>(2)  calls on the set (with an error return and I<errno> set to "
"B<EIDRM>).  The effective user ID of the calling process must match the "
"creator or owner of the semaphore set, or the caller must be privileged.  "
"The argument I<semnum> is ignored."
msgstr ""
"セマフォ集合をただちに削除し、その集合上の B<semop>(2)  コールでブロックされ"
"ている全てのプロセスを目覚めさせる (エラー値が返されて、 I<errno> に "
"B<EIDRM> が設定される)。 呼び出したプロセスの実効ユーザー ID が そのセマフォ"
"集合の作成者または所有者と一致するか、 呼び出した人が特権を持たなければならな"
"い。 I<semnum> 引数は無視される。"

#. type: TP
#: build/C/man2/semctl.2:224
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/semctl.2:236
msgid ""
"Return information about system-wide semaphore limits and parameters in the "
"structure pointed to by I<arg.__buf>.  This structure is of type I<seminfo>, "
"defined in I<E<lt>sys/sem.hE<gt>> if the B<_GNU_SOURCE> feature test macro "
"is defined:"
msgstr ""
"システム全体でのセマフォの制限とパラメーターに関する情報を、 I<arg.__buf> が"
"指す構造体に入れて返す。 この構造体は I<seminfo> 型である。 I<seminfo> は "
"B<_GNU_SOURCE> 機能検査マクロが定義された場合に I<E<lt>sys/sem.hE<gt>> で以下"
"のように定義される:"

#. type: Plain text
#: build/C/man2/semctl.2:258
#, no-wrap
msgid ""
"struct  seminfo {\n"
"    int semmap;  /* Number of entries in semaphore\n"
"                    map; unused within kernel */\n"
"    int semmni;  /* Maximum number of semaphore sets */\n"
"    int semmns;  /* Maximum number of semaphores in all\n"
"                    semaphore sets */\n"
"    int semmnu;  /* System-wide maximum number of undo\n"
"                    structures; unused within kernel */\n"
"    int semmsl;  /* Maximum number of semaphores in a\n"
"                    set */\n"
"    int semopm;  /* Maximum number of operations for\n"
"                    semop(2) */\n"
"    int semume;  /* Maximum number of undo entries per\n"
"                    process; unused within kernel */\n"
"    int semusz;  /* Size of struct sem_undo */\n"
"    int semvmx;  /* Maximum semaphore value */\n"
"    int semaem;  /* Max. value that can be recorded for\n"
"                    semaphore adjustment (SEM_UNDO) */\n"
"};\n"
msgstr ""
"struct  seminfo {\n"
"    int semmap;  /* セマフォマップの最大エントリー数;\n"
"                    カーネル内では未使用 */\n"
"    int semmni;  /* セマフォ集合の最大数 */\n"
"    int semmns;  /* 全セマフォ集合中のセマフォの\n"
"                    最大数 */\n"
"    int semmnu;  /* アンドゥ構造体のシステム全体での\n"
"                    最大数; カーネル内では未使用 */\n"
"    int semmsl;  /* 一つのセマフォ集合の最大セマフォ数 */\n"
"    int semopm;  /* semop(2) に渡す操作の最大数 */\n"
"    int semume;  /* プロセスあたりのアンドゥエントリー\n"
"                    の最大数; カーネル内では未使用 */\n"
"    int semusz;  /* 構造体 sem_undo のサイズ */\n"
"    int semvmx;  /* セマフォの最大値 */\n"
"    int semaem;  /* セマフォの調整 (semaphore adjustment;\n"
"                     SEM_UNDO) のために記録される最大値 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/semctl.2:272
msgid ""
"The I<semmsl>, I<semmns>, I<semopm>, and I<semmni> settings can be changed "
"via I</proc/sys/kernel/sem>; see B<proc>(5)  for details."
msgstr ""
"設定 I<semmsl>, I<semmns>, I<semopm>, I<semmni> は I</proc/sys/kernel/sem> 経"
"由で変更可能である。 詳しくは B<proc>(5)  を参照。"

#. type: TP
#: build/C/man2/semctl.2:272
#, no-wrap
msgid "B<SEM_INFO> (Linux-specific)"
msgstr "B<SEM_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/semctl.2:286
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by semaphores: the I<semusz> field returns "
"the number of semaphore sets that currently exist on the system; and the "
"I<semaem> field returns the total number of semaphores in all semaphore sets "
"on the system."
msgstr ""
"B<IPC_INFO> のときと同じ情報を格納した I<seminfo> 構造体を返す。 但し、以下の"
"フィールドにはセマフォが消費しているシステム資源に 関する情報が格納される点が"
"異なる。 I<semusz> フィールドは現在システム上に存在するセマフォ集合の数を返"
"す。 I<semaem> フィールドはシステム上の全てのセマフォ集合に含まれる セマフォ"
"の総数を返す。"

#. type: TP
#: build/C/man2/semctl.2:286
#, no-wrap
msgid "B<SEM_STAT> (Linux-specific)"
msgstr "B<SEM_STAT> (Linux 固有)"

#. type: Plain text
#: build/C/man2/semctl.2:297
msgid ""
"Return a I<semid_ds> structure as for B<IPC_STAT>.  However, the I<semid> "
"argument is not a semaphore identifier, but instead an index into the "
"kernel's internal array that maintains information about all semaphore sets "
"on the system."
msgstr ""
"B<IPC_STAT> と同じく I<semid_ds> 構造体を返す。 但し、 I<semid> 引数は、セ"
"マフォ識別子ではなく、システム上の全てのセマフォ集合 に関する情報を管理する"
"カーネルの内部配列へのインデックスである。"

#. type: TP
#: build/C/man2/semctl.2:297
#, no-wrap
msgid "B<SEM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<SEM_STAT_ANY> (Linux 固有, Linux 4.17 以降)"

#. type: Plain text
#: build/C/man2/semctl.2:310
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<SEM_STAT>.  However, I<sem_perm.mode> is not checked for read access for "
"I<semid> meaning that any user can employ this operation (just as any user "
"may read I</proc/sysvipc/sem> to obtain the same information)."
msgstr ""

#. type: TP
#: build/C/man2/semctl.2:310
#, no-wrap
msgid "B<GETALL>"
msgstr "B<GETALL>"

#. type: Plain text
#: build/C/man2/semctl.2:321
msgid ""
"Return B<semval> (i.e., the current value)  for all semaphores of the set "
"into I<arg.array>.  The argument I<semnum> is ignored.  The calling process "
"must have read permission on the semaphore set."
msgstr ""
"集合の全てのセマフォの B<semval> の値 (現在の値) を I<arg.array> に返す。 "
"I<semnum> 引数は無視される。 呼び出したプロセスはそのセマフォ集合に読み込み"
"許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:321 build/C/man2/semctl.2:408
#, no-wrap
msgid "B<GETNCNT>"
msgstr "B<GETNCNT>"

#. type: Plain text
#: build/C/man2/semctl.2:330
#, fuzzy
#| msgid ""
#| "Return the value of B<semzcnt> for the I<semnum>-th semaphore of the set "
#| "(i.e., the number of processes waiting for B<semval> of the I<semnum>-th "
#| "semaphore of the set to become 0).  The calling process must have read "
#| "permission on the semaphore set."
msgid ""
"Return the B<semncnt> value for the I<semnum>-th semaphore of the set (i.e., "
"the number of processes waiting for the semaphore's value to increase).  The "
"calling process must have read permission on the semaphore set."
msgstr ""
"集合の I<semnum> 番目のセマフォの B<semzcnt> の値を返す (集合の I<semnum> 番"
"目のセマフォの B<semval> の値が 0 になるのを待っているプロセスの数を返す)。 "
"呼び出したプロセスはそのセマフォ集合に読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:330 build/C/man2/semctl.2:412
#, no-wrap
msgid "B<GETPID>"
msgstr "B<GETPID>"

#. type: Plain text
#: build/C/man2/semctl.2:340
msgid ""
"Return the B<sempid> value for the I<semnum>-th semaphore of the set.  This "
"is the PID of the process that last performed an operation on that semaphore "
"(but see NOTES).  The calling process must have read permission on the "
"semaphore set."
msgstr "集合の I<semnum> 番目のセマフォの B<sempid> の値を返す。この値は、そのセマフォに対して最後に操作を行ったプロセスの PID である (ただし「バグ」を参照)。呼び出したプロセスはそのセマフォ集合に読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:340 build/C/man2/semctl.2:416
#, no-wrap
msgid "B<GETVAL>"
msgstr "B<GETVAL>"

#. type: Plain text
#: build/C/man2/semctl.2:348
msgid ""
"Return B<semval> (i.e., the semaphore value) for the I<semnum>-th semaphore "
"of the set.  The calling process must have read permission on the semaphore "
"set."
msgstr "集合の I<semnum> 番目のセマフォの B<semval> (セマフォの値) を返す。 呼び出したプロセスはそのセマフォ集合に読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:348 build/C/man2/semctl.2:420
#, no-wrap
msgid "B<GETZCNT>"
msgstr "B<GETZCNT>"

#. type: Plain text
#: build/C/man2/semctl.2:357
msgid ""
"Return the B<semzcnt> value for the I<semnum>-th semaphore of the set (i.e., "
"the number of processes waiting for the semaphore value to become 0).  The "
"calling process must have read permission on the semaphore set."
msgstr "集合の I<semnum> 番目のセマフォの B<semzcnt> の値 (つまり、そのセマフォの値が 0 になるのを待っているプロセスの数) を返す。呼び出したプロセスはそのセマフォ集合に読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:357
#, no-wrap
msgid "B<SETALL>"
msgstr "B<SETALL>"

#. type: Plain text
#: build/C/man2/semctl.2:379
msgid ""
"Set the B<semval> values for all semaphores of the set using I<arg.array>, "
"updating also the I<sem_ctime> member of the I<semid_ds> structure "
"associated with the set.  Undo entries (see B<semop>(2))  are cleared for "
"altered semaphores in all processes.  If the changes to semaphore values "
"would permit blocked B<semop>(2)  calls in other processes to proceed, then "
"those processes are woken up.  The argument I<semnum> is ignored.  The "
"calling process must have alter (write) permission on the semaphore set."
msgstr "集合の全てのセマフォの B<semval> 値に I<arg.array> で指定された値を設定する。 その集合に関連する I<semid_ds> 構造体の I<sem_ctime> メンバーの値も更新する。 全てのプロセスのセマフォの変更についてのアンドゥエントリー (B<semop>(2)  を参照) は消去 (clear) される。 セマフォの値の変更により、他のプロセス内でブロックされている B<semop>(2)  コールの続行が許可されると、それらのプロセスは起こされる (wake up)。 I<semnum> 引数は無視される。 呼び出したプロセスはそのセマフォ集合に 変更 (書き込み) 許可を持たなければならない。"

#. type: TP
#: build/C/man2/semctl.2:379
#, no-wrap
msgid "B<SETVAL>"
msgstr "B<SETVAL>"

#. type: Plain text
#: build/C/man2/semctl.2:397
msgid ""
"Set the semaphore value B<(>semvalB<)> to I<arg.val> for the I<semnum>-th "
"semaphore of the set, updating also the I<sem_ctime> member of the "
"I<semid_ds> structure associated with the set.  Undo entries are cleared for "
"altered semaphores in all processes.  If the changes to semaphore values "
"would permit blocked B<semop>(2)  calls in other processes to proceed, then "
"those processes are woken up.  The calling process must have alter "
"permission on the semaphore set."
msgstr "集合の I<semnum> 番目のセマフォのセマフォ地 (B<semval>) に I<arg.val> の値を設定する。その集合に関連する I<semid_ds> 構造体の I<sem_ctime> メンバーの値も更新する。 全てのプロセスのセマフォの変更についてのアンドゥエントリーは消去される。 セマフォの値の変更により、他のプロセス内でブロックされている B<semop>(2)  コールの続行が許可されると、それらのプロセスは起こされる (wake up)。 呼び出したプロセスはそのセマフォ集合に 変更 (書き込み) 許可を持たなければならない。"

#. type: Plain text
#: build/C/man2/semctl.2:404
msgid "On failure, B<semctl>()  returns -1 with I<errno> indicating the error."
msgstr ""
"失敗した場合、 B<semctl>()  は -1 を返し、 I<errno> にそのエラーを示す。"

#. type: Plain text
#: build/C/man2/semctl.2:408
msgid ""
"Otherwise, the system call returns a nonnegative value depending on I<cmd> "
"as follows:"
msgstr "そうでなければシステムコールは I<cmd> によって以下の負でない値を返す:"

#. type: Plain text
#: build/C/man2/semctl.2:412
msgid "the value of B<semncnt>."
msgstr "B<semncnt> の値"

#. type: Plain text
#: build/C/man2/semctl.2:416
msgid "the value of B<sempid>."
msgstr "B<sempid> の値"

#. type: Plain text
#: build/C/man2/semctl.2:420
msgid "the value of B<semval>."
msgstr "B<semval> の値"

#. type: Plain text
#: build/C/man2/semctl.2:424
msgid "the value of B<semzcnt>."
msgstr "B<semzcnt> の値"

#. type: TP
#: build/C/man2/semctl.2:424
#, no-wrap
msgid "B<IPC_INFO>"
msgstr "B<IPC_INFO>"

#. type: Plain text
#: build/C/man2/semctl.2:434
msgid ""
"the index of the highest used entry in the kernel's internal array recording "
"information about all semaphore sets.  (This information can be used with "
"repeated B<SEM_STAT> or B<SEM_STAT_ANY> operations to obtain information "
"about all semaphore sets on the system.)"
msgstr "全てのセマフォ集合に関する情報を管理しているカーネルの内部配列の使用中 エントリーのインデックスの最大値 (この情報は、システムの全てのセマフォ集合に関する情報を取得するために操作 B<SEM_STAT> や B<SEM_STAT_ANY> を繰り返し実行する際に使用できる)"

#. type: TP
#: build/C/man2/semctl.2:434
#, no-wrap
msgid "B<SEM_INFO>"
msgstr "B<SEM_INFO>"

#. type: Plain text
#: build/C/man2/semctl.2:438
msgid "as for B<IPC_INFO>."
msgstr "B<IPC_INFO> と同じ"

#. type: TP
#: build/C/man2/semctl.2:438
#, no-wrap
msgid "B<SEM_STAT>"
msgstr "B<SEM_STAT>"

#. type: Plain text
#: build/C/man2/semctl.2:442
msgid "the identifier of the semaphore set whose index was given in I<semid>."
msgstr "I<semid> で指定されたインデックスを持つセマフォ集合の識別子"

#. type: TP
#: build/C/man2/semctl.2:442
#, no-wrap
msgid "B<SEM_STAT_ANY>"
msgstr "B<SEM_STAT_ANY>"

#. type: Plain text
#: build/C/man2/semctl.2:446
msgid "as for B<SEM_STAT>."
msgstr "B<SEM_STAT> と同じ。"

#. type: Plain text
#: build/C/man2/semctl.2:450
msgid "All other I<cmd> values return 0 on success."
msgstr "I<cmd> の値がそれ以外の場合、成功すると 0 が返される。"

#. type: Plain text
#: build/C/man2/semctl.2:454 build/C/man2/semget.2:167
msgid "On failure, I<errno> will be set to one of the following:"
msgstr "失敗した場合は I<errno> には以下の値のどれかが設定される:"

#. type: Plain text
#: build/C/man2/semctl.2:474
#, fuzzy
#| msgid ""
#| "The argument I<cmd> has one of the values B<GETALL>, B<GETPID>, "
#| "B<GETVAL>, B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SETALL>, "
#| "or B<SETVAL> and the calling process does not have the required "
#| "permissions on the semaphore set and does not have the B<CAP_IPC_OWNER> "
#| "capability."
msgid ""
"The argument I<cmd> has one of the values B<GETALL>, B<GETPID>, B<GETVAL>, "
"B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SEM_STAT_ANY>, "
"B<SETALL>, or B<SETVAL> and the calling process does not have the required "
"permissions on the semaphore set and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"I<cmd> 引数が B<GETALL>, B<GETPID>, B<GETVAL>, B<GETNCNT>, B<GETZCNT>, "
"B<IPC_STAT>, B<SEM_STAT>, B<SETALL>, B<SETVAL> のうちの何れかの値を持ち、 呼"
"び出したプロセスがセマフォに対して必要とされる許可と B<CAP_IPC_OWNER> ケーパ"
"ビリティ (capability) を持っていない。"

#. type: TP
#: build/C/man2/semctl.2:474 build/C/man2/semop.2:336
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/semctl.2:481
msgid "The address pointed to by I<arg.buf> or I<arg.array> isn't accessible."
msgstr ""
"I<arg.buf> または I<arg.array> で指されているアドレスにアクセスすることができ"
"ない。"

#. type: TP
#: build/C/man2/semctl.2:481 build/C/man2/semop.2:349
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: build/C/man2/semctl.2:484 build/C/man2/semop.2:352
msgid "The semaphore set was removed."
msgstr "セマフォ集合が削除された。"

#. type: Plain text
#: build/C/man2/semctl.2:495
msgid ""
"Invalid value for I<cmd> or I<semid>.  Or: for a B<SEM_STAT> operation, the "
"index value specified in I<semid> referred to an array slot that is "
"currently unused."
msgstr ""
"I<cmd> または I<semid> に無効な値が指定された。 もしくは、 B<SEM_STAT> 操作の"
"場合に、 I<semid> で指定されたインデックス値が現在未使用の配列のスロットを参"
"照いていた。"

#. type: TP
#: build/C/man2/semctl.2:495
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/semctl.2:513
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID> but the "
"effective user ID of the calling process is not the creator (as found in "
"I<sem_perm.cuid>)  or the owner (as found in I<sem_perm.uid>)  of the "
"semaphore set, and the process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""
"I<cmd> 引数に B<IPC_SET> または B<IPC_RMID> が指定され、呼び出したプロセス"
"の実効ユーザー ID がセマフォの (I<sem_perm.cuid> で見つかる) 作成者または "
"(I<sem_perm.uid> で見つかる) 所有者でもなく、 プロセスが B<CAP_SYS_ADMIN> "
"ケーパビリティを持たない。"

#. type: TP
#: build/C/man2/semctl.2:513 build/C/man2/semop.2:371
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/semctl.2:526
msgid ""
"The argument I<cmd> has the value B<SETALL> or B<SETVAL> and the value to "
"which B<semval> is to be set (for some semaphore of the set) is less than 0 "
"or greater than the implementation limit B<SEMVMX>."
msgstr ""
"I<cmd> 引数に B<SETALL> または B<SETVAL> が指定され、(集合のセマフォのどれ"
"かの)  B<semval> に設定される値が 0 より小さいか、実装の制限 B<SEMVMX> よりも"
"大きい。"

#.  SVr4 documents additional error conditions EINVAL, EFBIG, ENOSPC.
#. type: Plain text
#: build/C/man2/semctl.2:529 build/C/man2/semop.2:389
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man2/semctl.2:541
msgid ""
"POSIX.1 specifies the I<sem_nsems> field of the I<semid_ds> structure as "
"having the type I<unsigned\\ short>, and the field is so defined on most "
"other systems.  It was also so defined on Linux 2.2 and earlier, but, since "
"Linux 2.4, the field has the type I<unsigned\\ long>."
msgstr "POSIX.1 では I<semid_ds> 構造体の I<sem_nsems> フィールドは I<unsigned\\ short> 型を持つと規定されており、 他のほとんどのシステムでこのフィールドは I<unsigned\\ short> 型になっている。 Linux 2.4 以前ではそうなっていたが、 Linux 2.4 以降ではこのフィールドは I<unsigned\\ long> 型である。"

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/semctl.2:554 build/C/man2/semget.2:237 build/C/man2/semop.2:402
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""
"Linux や POSIX の全てのバージョンでは、 I<E<lt>sys/types.hE<gt>> と "
"I<E<lt>sys/ipc.hE<gt>> のインクルードは必要ない。しかしながら、いくつかの古い"
"実装ではこれらのヘッダーファイルのインクルードが必要であり、 SVID でもこれら"
"のインクルードをするように記載されている。このような古いシステムへの移植性を"
"意図したアプリケーションではこれらのファイルをインクルードする必要があるかも"
"しれない。"

#. type: Plain text
#: build/C/man2/semctl.2:566
msgid ""
"The B<IPC_INFO>, B<SEM_STAT>, and B<SEM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"B<IPC_INFO>, B<SEM_STAT>, B<SEM_INFO> 操作は B<ipcs>(1)  プログラムによって割"
"当られた資源について情報を提供するために使用される。 将来的にはこれらは変更さ"
"れるか、 I</proc> ファイルシステムインターフェースに移動されるかもしれない。"

#. type: Plain text
#: build/C/man2/semctl.2:579
msgid ""
"Various fields in a I<struct semid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"I<構造体 semid_ds> 内の多くのフィールドは、 Linux 2.2 では I<short> 型だった"
"が、Linux 2.4 では I<long> 型になった。 この利点を生かすには、glibc-2.1.91 以"
"降の環境下で 再コンパイルすれば十分である。 カーネルは新しい形式の呼び出しと"
"古い形式の呼び出しを I<cmd> 内の B<IPC_64> フラグで区別する。"

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man2/semctl.2:589
msgid ""
"In some earlier versions of glibc, the I<semun> union was defined in "
"I<E<lt>sys/sem.hE<gt>>, but POSIX.1 requires that the caller define this "
"union.  On versions of glibc where this union is I<not> defined, the macro "
"B<_SEM_SEMUN_UNDEFINED> is defined in I<E<lt>sys/sem.hE<gt>>."
msgstr "初期のバージョンの glibc では、 I<semun> 共用体は I<E<lt>sys/sem.hE<gt>> で定義されていたが、 POSIX.1 では呼び出し側がこの共用体を定義する必要がある。 この共用体が定義されてI<いない> glibc のバージョンでは、 マクロ B<_SEM_SEMUN_UNDEFINED> が I<E<lt>sys/sem.hE<gt>> で定義されている。"

#. type: Plain text
#: build/C/man2/semctl.2:593
msgid ""
"The following system limit on semaphore sets affects a B<semctl>()  call:"
msgstr "以下は B<semctl>()  コールに影響するセマフォ集合のシステム制限:"

#. type: TP
#: build/C/man2/semctl.2:593 build/C/man2/semop.2:478
#, no-wrap
msgid "B<SEMVMX>"
msgstr "B<SEMVMX>"

#. type: Plain text
#: build/C/man2/semctl.2:598
msgid "Maximum value for B<semval>: implementation dependent (32767)."
msgstr "B<semval> の最大値 : 実装依存 (32767)。"

#. type: Plain text
#: build/C/man2/semctl.2:603
msgid ""
"For greater portability, it is best to always call B<semctl>()  with four "
"arguments."
msgstr ""
"移植性を高めるための一番良い方法は、常に 4 個の引数で B<semctl>()  を呼び出"
"すことである。"

#. type: SS
#: build/C/man2/semctl.2:603
#, no-wrap
msgid "The sempid value"
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:612
msgid ""
"POSIX.1 defines I<sempid> as the \"process ID of [the] last operation\" on a "
"semaphore, and explicitly notes that this value is set by a successful "
"B<semop>(2)  call, with the implication that no other interface affects the "
"I<sempid> value."
msgstr ""

#.  At least OpenSolaris (and, one supposes, older Solaris) and Darwin
#. type: Plain text
#: build/C/man2/semctl.2:630
msgid ""
"While some implementations conform to the behavior specified in POSIX.1, "
"others do not.  (The fault here probably lies with POSIX.1 inasmuch as it "
"likely failed to capture the full range of existing implementation "
"behaviors.)  Various other implementations also update I<sempid> for the "
"other operations that update the value of a semaphore: the B<SETVAL> and "
"B<SETALL> operations, as well as the semaphore adjustments performed on "
"process termination as a consequence of the use of the B<SEM_UNDO> flag (see "
"B<semop>(2))."
msgstr ""

#.  commit a5f4db877177d2a3d7ae62a7bac3a5a27e083d7f
#. type: Plain text
#: build/C/man2/semctl.2:645
msgid ""
"Linux also updates I<sempid> for B<SETVAL> operations and semaphore "
"adjustments.  However, somewhat inconsistently, up to and including Linux "
"4.5, the kernel did not update I<sempid> for B<SETALL> operations.  This was "
"rectified in Linux 4.6."
msgstr ""

#. type: Plain text
#: build/C/man2/semctl.2:648
msgid "See B<shmop>(2)."
msgstr "B<shmop>(2) 参照。"

#. type: Plain text
#: build/C/man2/semctl.2:655
msgid ""
"B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr "B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/semget.2:37
#, no-wrap
msgid "SEMGET"
msgstr "SEMGET"

#. type: TH
#: build/C/man2/semget.2:37 build/C/man2/semop.2:35
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man2/semget.2:40
msgid "semget - get a System V semaphore set identifier"
msgstr "semget - System V セマフォ集合の識別子を取得する"

#. type: Plain text
#: build/C/man2/semget.2:50
msgid ""
"B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"
msgstr ""
"B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"

#. type: Plain text
#: build/C/man2/semget.2:64
#, fuzzy
#| msgid ""
#| "The B<semget>()  system call returns the System\\ V semaphore set "
#| "identifier associated with the argument I<key>.  A new set of I<nsems> "
#| "semaphores is created if I<key> has the value B<IPC_PRIVATE> or if no "
#| "existing semaphore set is associated with I<key> and B<IPC_CREAT> is "
#| "specified in I<semflg>."
msgid ""
"The B<semget>()  system call returns the System\\ V semaphore set identifier "
"associated with the argument I<key>.  It may be used either to obtain the "
"identifier of a previously created semaphore set (when I<semflg> is zero and "
"I<key> does not have the value B<IPC_PRIVATE>), or to create a new set."
msgstr ""
"B<semget>()  システムコールは、引数 I<key> に対応する System\\ V セマフォ集"
"合 (semaphore set) の 識別子 (identifier) を返す。 I<key> の値が "
"B<IPC_PRIVATE> の場合、もしくは I<semflg> に B<IPC_CREAT> が指定されていて、 "
"I<key> に対応するセマフォ集合が存在しない場合、 I<nsems> 個のセマフォからなる"
"新しい集合が作成される。"

#. type: Plain text
#: build/C/man2/semget.2:77
msgid ""
"A new set of I<nsems> semaphores is created if I<key> has the value "
"B<IPC_PRIVATE> or if no existing semaphore set is associated with I<key> and "
"B<IPC_CREAT> is specified in I<semflg>."
msgstr "I<key> の値が B<IPC_PRIVATE> の場合、もしくは I<semflg> に B<IPC_CREAT> が指定されていて、 I<key> に対応するセマフォ集合が存在しない場合、 I<nsems> 個のセマフォからなる新しい集合が作成される。"

#. type: Plain text
#: build/C/man2/semget.2:96
msgid ""
"If I<semflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a semaphore set "
"already exists for I<key>, then B<semget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""
"I<semflg> に B<IPC_CREAT> と B<IPC_EXCL> の両方が指定された場合、 I<key> に対"
"応するセマフォ集合が既に存在すると、 B<semget>()  は失敗し、 I<errno> に "
"B<EEXIST> が設定される (これは B<open>(2)  に B<O_CREAT | O_EXCL> が指定され"
"た場合の動作と同じである)。"

#. type: Plain text
#: build/C/man2/semget.2:109
msgid ""
"Upon creation, the least significant 9 bits of the argument I<semflg> define "
"the permissions (for owner, group and others)  for the semaphore set.  These "
"bits have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2)  (though the execute permissions are not meaningful for "
"semaphores, and write permissions mean permission to alter semaphore values)."
msgstr ""
"セマフォ集合作成時に、引数 I<semflg> の下位 9 ビットは、そのセマフォ集合の "
"(所有者 (owner)、グループ (group)、 他人 (others) に対する) アクセス許可の定"
"義として使用される。 これらのビットは B<open>(2)  の引数 I<mode> と同じ形式"
"で同じ意味である (但し、実行 (execute) 許可はセマフォでは意味を持たず、 書き"
"込み (write) 許可はセマフォ値の変更 (alter) 許可として機能する)。"

#. type: Plain text
#: build/C/man2/semget.2:117
msgid ""
"When creating a new semaphore set, B<semget>()  initializes the set's "
"associated data structure, I<semid_ds> (see B<semctl>(2)), as follows:"
msgstr ""
"新規のセマフォ集合を作成する際、 B<semget>()  はセマフォ集合の情報を保持する"
"データ構造体 I<semid_ds> を次のように初期化する (I<semid_ds> については "
"B<semctl>(2)  を参照):"

#. type: IP
#: build/C/man2/semget.2:117 build/C/man2/semget.2:122
#: build/C/man2/semget.2:127 build/C/man2/semget.2:132
#: build/C/man2/semget.2:136 build/C/man2/semget.2:139 build/C/man2/semop.2:162
#: build/C/man2/semop.2:167 build/C/man2/semop.2:175 build/C/man2/semop.2:227
#: build/C/man2/semop.2:232 build/C/man2/semop.2:239
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man2/semget.2:122
msgid ""
"I<sem_perm.cuid> and I<sem_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"I<sem_perm.cuid> と I<sem_perm.uid> に、呼び出し元のプロセスの実効 "
"(effective) ユーザー ID を設定する。"

#. type: Plain text
#: build/C/man2/semget.2:127
msgid ""
"I<sem_perm.cgid> and I<sem_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"I<sem_perm.cgid> と I<sem_perm.gid> に、呼び出し元のプロセスの実効 "
"(effective) グループ ID を設定する。"

#. type: Plain text
#: build/C/man2/semget.2:132
msgid ""
"The least significant 9 bits of I<sem_perm.mode> are set to the least "
"significant 9 bits of I<semflg>."
msgstr ""
"I<sem_perm.mode> の下位 9 ビットに I<semflg> の下位 9 ビットを設定する。"

#. type: Plain text
#: build/C/man2/semget.2:136
msgid "I<sem_nsems> is set to the value of I<nsems>."
msgstr "I<sem_nsems> に I<nsems> の値を設定する。"

#. type: Plain text
#: build/C/man2/semget.2:139
msgid "I<sem_otime> is set to 0."
msgstr "I<sem_otime> に 0 を設定する。"

#. type: Plain text
#: build/C/man2/semget.2:142
msgid "I<sem_ctime> is set to the current time."
msgstr "I<sem_ctime> に現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/semget.2:153
msgid ""
"The argument I<nsems> can be 0 (a don't care)  when a semaphore set is not "
"being created.  Otherwise, I<nsems> must be greater than 0 and less than or "
"equal to the maximum number of semaphores per semaphore set (B<SEMMSL>)."
msgstr ""
"セマフォ集合の作成を行わない場合は、引数 I<nsems> に (don't care を意味す"
"る) 0 を指定してもよい。 そうでない場合は、 I<nsems> は 0 より大きい値でなけ"
"ればならず、セマフォ集合あたりのセマフォの最大数 (B<SEMMSL>)  以下でなければ"
"ならない。"

#.  and a check is made to see if it is marked for destruction.
#. type: Plain text
#: build/C/man2/semget.2:157
msgid "If the semaphore set already exists, the permissions are verified."
msgstr "セマフォ集合が既に存在した場合は、アクセス許可の検査が行われる。"

#. type: Plain text
#: build/C/man2/semget.2:163
msgid ""
"If successful, the return value will be the semaphore set identifier (a "
"nonnegative integer), otherwise, -1 is returned, with I<errno> indicating "
"the error."
msgstr ""
"成功した場合、セマフォ集合の識別子 (非負の整数) が返り値となる。 失敗した場合"
"は -1 が返され、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/semget.2:175
#, fuzzy
#| msgid ""
#| "A semaphore set exists for I<key>, but the calling process does not have "
#| "permission to access the set, and does not have the B<CAP_IPC_OWNER> "
#| "capability."
msgid ""
"A semaphore set exists for I<key>, but the calling process does not have "
"permission to access the set, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"I<key> に対応するセマフォ集合は存在するが、 呼び出し元のプロセスはその集合へ"
"のアクセス許可がなく、 B<CAP_IPC_OWNER> ケーパビリティも持っていない。"

#.  .TP
#.  .B EIDRM
#.  The semaphore set is marked to be deleted.
#. type: Plain text
#: build/C/man2/semget.2:187
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<semflg>, but a semaphore "
"set already exists for I<key>."
msgstr ""
"I<semflg> に B<IPC_CREAT> と B<IPC_EXCL> が指定されたが、 I<key> に対応するセ"
"マフォ集合はすでに存在する。"

#. type: Plain text
#: build/C/man2/semget.2:193
msgid ""
"I<nsems> is less than 0 or greater than the limit on the number of "
"semaphores per semaphore set (B<SEMMSL>)."
msgstr ""
"I<nsems> が 0 より小さいか、 セマフォ集合あたりのセマフォの最大数 "
"(B<SEMMSL>) より大きい。"

#. type: Plain text
#: build/C/man2/semget.2:200
msgid ""
"A semaphore set corresponding to I<key> already exists, but I<nsems> is "
"larger than the number of semaphores in that set."
msgstr ""
"I<key> に対応するセマフォ集合が既に存在するが、 I<nsems> がその集合のセマフォ"
"数よりも大きい。"

#. type: Plain text
#: build/C/man2/semget.2:208
msgid ""
"No semaphore set exists for I<key> and I<semflg> did not specify "
"B<IPC_CREAT>."
msgstr ""
"I<key> に対応するセマフォ集合が存在せず、 I<semflg> に B<IPC_CREAT> が指定さ"
"れてもいない。"

#. type: Plain text
#: build/C/man2/semget.2:212
msgid ""
"A semaphore set has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""
"セマフォ集合を作成しようとしたが、新しいデータ構造体を 作成するのに十分なメモ"
"リーがシステムに存在しない。"

#. type: TP
#: build/C/man2/semget.2:212
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/semget.2:220
msgid ""
"A semaphore set has to be created but the system limit for the maximum "
"number of semaphore sets (B<SEMMNI>), or the system wide maximum number of "
"semaphores (B<SEMMNS>), would be exceeded."
msgstr ""
"セマフォ集合を作成しようとすると、システムのセマフォ集合の 最大数 "
"(B<SEMMNI>)  か、システム全体のセマフォの最大数 (B<SEMMNS>)  のいずれかを超え"
"てしまう。"

#.  SVr4 documents additional error conditions EFBIG, E2BIG, EAGAIN,
#.  ERANGE, EFAULT.
#. type: Plain text
#: build/C/man2/semget.2:224
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/semget.2:248
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<semflg> and creates a new semaphore set (on success)."
msgstr ""
"B<IPC_PRIVATE> はフラグフィールドに指定するものではなく、 I<key_t> 型であ"
"る。 この特別な値が I<key> に指定されると、 B<semget>()  I<semflg> の下位 9 "
"ビット以外は全て無視し、 (成功した場合は) 新しいセマフォ集合を作成する。"

#. type: SS
#: build/C/man2/semget.2:248
#, no-wrap
msgid "Semaphore initialization"
msgstr "セマフォの初期化"

#.  In truth, every one of the many implementations that I've tested sets
#.  the values to zero, but I suppose there is/was some obscure
#.  implementation out there that does not.
#. type: Plain text
#: build/C/man2/semget.2:260
msgid ""
"The values of the semaphores in a newly created set are indeterminate.  "
"(POSIX.1-2001 and POSIX.1-2008 are explicit on this point, although "
"POSIX.1-2008 notes that a future version of the standard may require an "
"implementation to initialize the semaphores to 0.)  Although Linux, like "
"many other implementations, initializes the semaphore values to 0, a "
"portable application cannot rely on this: it should explicitly initialize "
"the semaphores to the desired values."
msgstr ""
"新しく作成されたセマフォ集合の各セマフォの値は不定である。 (この点は "
"POSIX.1-2001 と POSIX.1-2008 に明記されている。ただし、POSIX.1-2008 では "
"POSIX の将来のバージョンではセマフォを 0 に初期化するように実装に要求する可能"
"性が注記されている。) Linux は他の多くの実装と同様にセマフォ値を 0 に初期化す"
"るが、 移植性を考慮したアプリケーションではこの動作を前提にすべきではない。 "
"アプリケーションは明示的にセマフォを希望の値で初期化すべきである。"

#. type: Plain text
#: build/C/man2/semget.2:275
msgid ""
"Initialization can be done using B<semctl>(2)  B<SETVAL> or B<SETALL> "
"operation.  Where multiple peers do not know who will be the first to "
"initialize the set, checking for a nonzero I<sem_otime> in the associated "
"data structure retrieved by a B<semctl>(2)  B<IPC_STAT> operation can be "
"used to avoid races."
msgstr ""
"B<semctl>(2) の B<SETVAL> か B<SETALL> 操作を使って初期化することができる。 "
"複数箇所からセマフォ集合の操作が行われる場面では、 誰が最初に集合を初期化すれ"
"ばよいか分からない。 この状況を避けるには、 B<semctl>(2)  の B<IPC_STAT> 操作"
"で取得できるセマフォのデータ構造体の I<sem_otime> が 0 以外になっているかを"
"チェックすればよい。"

#. type: SS
#: build/C/man2/semget.2:275 build/C/man2/semop.2:454
#, no-wrap
msgid "Semaphore limits"
msgstr "セマフォの上限"

#. type: Plain text
#: build/C/man2/semget.2:279
msgid ""
"The following limits on semaphore set resources affect the B<semget>()  call:"
msgstr ""
"セマフォ集合のリソースに関する上限のうち、 B<semget>()  に影響を及ぼすものを"
"以下に挙げる:"

#. type: TP
#: build/C/man2/semget.2:279
#, no-wrap
msgid "B<SEMMNI>"
msgstr "B<SEMMNI>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/semget.2:290
#, fuzzy
#| msgid ""
#| "System-wide limit on the number of semaphore sets: policy dependent (on "
#| "Linux, this limit can be read and modified via the fourth field of I</"
#| "proc/sys/kernel/sem>)."
msgid ""
"System-wide limit on the number of semaphore sets.  On Linux systems before "
"version 3.19, the default value for this limit was 128.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the fourth field of I</proc/sys/kernel/sem>."
msgstr ""
"システム全体のセマフォ集合の上限数: 方針依存 (Linux では、この制限値は I</"
"proc/sys/kernel/sem> の第4フィールドに対応し、読み出しも変更もできる)。"

#. type: TP
#: build/C/man2/semget.2:290
#, no-wrap
msgid "B<SEMMSL>"
msgstr "B<SEMMSL>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#. type: Plain text
#: build/C/man2/semget.2:300
#, fuzzy
#| msgid ""
#| "Maximum number of semaphores per semaphore ID: implementation dependent "
#| "(on Linux, this limit can be read and modified via the first field of I</"
#| "proc/sys/kernel/sem>)."
msgid ""
"Maximum number of semaphores per semaphore ID.  On Linux systems before "
"version 3.19, the default value for this limit was 250.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the first field of I</proc/sys/kernel/sem>."
msgstr ""
"セマフォ ID あたりのセマフォの最大数: 実装依存 (Linux では、この制限値は I</"
"proc/sys/kernel/sem> の第1フィールドに対応し、読み出しも変更もできる)。"

#. type: TP
#: build/C/man2/semget.2:300
#, no-wrap
msgid "B<SEMMNS>"
msgstr "B<SEMMNS>"

#. type: Plain text
#: build/C/man2/semget.2:310
msgid ""
"System-wide limit on the number of semaphores: policy dependent (on Linux, "
"this limit can be read and modified via the second field of I</proc/sys/"
"kernel/sem>).  Note that the number of semaphores system-wide is also "
"limited by the product of B<SEMMSL> and B<SEMMNI>."
msgstr ""
"システム全体のセマフォ数の上限値: 方針依存 (Linux では、この上限値は I</proc/"
"sys/kernel/sem> の第 2 フィールドであり、読み出しも変更もできる)。 システム全"
"体のセマフォ数には、 B<SEMMSL> と B<SEMMNI> の積という上限もある。"

#. type: SH
#: build/C/man2/semget.2:310 build/C/man2/semop.2:490
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/semget.2:316
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"B<IPC_PRIVATE> という名前を選んだのはおそらく失敗であろう。 B<IPC_NEW> の方が"
"より明確にその機能を表しているだろう。"

#. type: Plain text
#: build/C/man2/semget.2:345
msgid ""
"The program shown below uses B<semget>()  to create a new semaphore set or "
"retrieve the ID of an existing set.  It generates the I<key> for "
"B<semget>()  using B<ftok>(3).  The first two command-line arguments are "
"used as the I<pathname> and I<proj_id> arguments for B<ftok>(3).  The third "
"command-line argument is an integer that specifies the I<nsems> argument for "
"B<semget>().  Command-line options can be used to specify the B<IPC_CREAT> "
"(I<-c>)  and B<IPC_EXCL> (I<-x>)  flags for the call to B<semget>().  The "
"usage of this program is demonstrated below."
msgstr ""

#. type: Plain text
#: build/C/man2/semget.2:350
msgid ""
"We first create two files that will be used to generate keys using "
"B<ftok>(3), create two semaphore sets using those files, and then list the "
"sets using B<ipcs>(1):"
msgstr ""

#. type: Plain text
#: build/C/man2/semget.2:359
#, no-wrap
msgid ""
"$ B<touch mykey mykey2>\n"
"$ B<./t_semget -c mykey p 1>\n"
"ID = 9\n"
"$ B<./t_semget -c mykey2 p 2>\n"
"ID = 10\n"
"$ B<ipcs -s>\n"
msgstr ""
"$ B<touch mykey mykey2>\n"
"$ B<./t_semget -c mykey p 1>\n"
"ID = 9\n"
"$ B<./t_semget -c mykey2 p 2>\n"
"ID = 10\n"
"$ B<ipcs -s>\n"

#. type: Plain text
#: build/C/man2/semget.2:364
#, no-wrap
msgid ""
"------ Semaphore Arrays --------\n"
"key        semid      owner      perms      nsems\n"
"0x7004136d 9          mtk        600        1\n"
"0x70041368 10         mtk        600        2\n"
msgstr ""
"------ Semaphore Arrays --------\n"
"key        semid      owner      perms      nsems\n"
"0x7004136d 9          mtk        600        1\n"
"0x70041368 10         mtk        600        2\n"

#. type: Plain text
#: build/C/man2/semget.2:374
msgid ""
"Next, we demonstrate that when B<semctl>(2)  is given the same I<key> (as "
"generated by the same arguments to B<ftok>(3)), it returns the ID of the "
"already existing semaphore set:"
msgstr ""

#. type: Plain text
#: build/C/man2/semget.2:379
#, no-wrap
msgid ""
"$ B<./t_semget -c mykey p 1>\n"
"ID = 9\n"
msgstr ""
"$ B<./t_semget -c mykey p 1>\n"
"ID = 9\n"

#. type: Plain text
#: build/C/man2/semget.2:387
msgid ""
"Finally, we demonstrate the kind of collision that can occur when "
"B<ftok>(3)  is given different I<pathname> arguments that have the same "
"inode number:"
msgstr ""

#. type: Plain text
#: build/C/man2/semget.2:396
#, no-wrap
msgid ""
"$ B<ln mykey link>\n"
"$ B<ls -i1 link mykey>\n"
"2233197 link\n"
"2233197 mykey\n"
"$ B<./t_semget link p 1>       # Generates same key as \\(aqmykey\\(aq\n"
"ID = 9\n"
msgstr ""
"$ B<ln mykey link>\n"
"$ B<ls -i1 link mykey>\n"
"2233197 link\n"
"2233197 mykey\n"
"$ B<./t_semget link p 1>       # Generates same key as \\(aqmykey\\(aq\n"
"ID = 9\n"

#. type: Plain text
#: build/C/man2/semget.2:402
#, no-wrap
msgid "/* t_semget.c\n"
msgstr "/* t_semget.c\n"

#. type: Plain text
#: build/C/man2/semget.2:412
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/sem.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/sem.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/semget.2:422
#, no-wrap
msgid ""
"static void\n"
"usage(const char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [-cx] pathname proj-id num-sems\\en\",\n"
"            pname);\n"
"    fprintf(stderr, \"    -c           Use IPC_CREAT flag\\en\");\n"
"    fprintf(stderr, \"    -x           Use IPC_EXCL flag\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(const char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [-cx] pathname proj-id num-sems\\en\",\n"
"            pname);\n"
"    fprintf(stderr, \"    -c           Use IPC_CREAT flag\\en\");\n"
"    fprintf(stderr, \"    -x           Use IPC_EXCL flag\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/semget.2:428
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, nsems, flags, opt;\n"
"    key_t key;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int semid, nsems, flags, opt;\n"
"    key_t key;\n"

#. type: Plain text
#: build/C/man2/semget.2:437
#, no-wrap
msgid ""
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"cx\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq: flags |= IPC_CREAT;   break;\n"
"        case \\(aqx\\(aq: flags |= IPC_EXCL;    break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"cx\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq: flags |= IPC_CREAT;   break;\n"
"        case \\(aqx\\(aq: flags |= IPC_EXCL;    break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man2/semget.2:440
#, no-wrap
msgid ""
"    if (argc != optind + 3)\n"
"        usage(argv[0]);\n"
msgstr ""
"    if (argc != optind + 3)\n"
"        usage(argv[0]);\n"

#. type: Plain text
#: build/C/man2/semget.2:446
#, no-wrap
msgid ""
"    key = ftok(argv[optind], argv[optind + 1][0]);\n"
"    if (key == -1) {\n"
"        perror(\"ftok\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    key = ftok(argv[optind], argv[optind + 1][0]);\n"
"    if (key == -1) {\n"
"        perror(\"ftok\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/semget.2:448
#, no-wrap
msgid "    nsems = atoi(argv[optind + 2]);\n"
msgstr "    nsems = atoi(argv[optind + 2]);\n"

#. type: Plain text
#: build/C/man2/semget.2:454
#, no-wrap
msgid ""
"    semid = semget(key, nsems, flags | 0600);\n"
"    if (semid == -1) {\n"
"        perror(\"semget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    semid = semget(key, nsems, flags | 0600);\n"
"    if (semid == -1) {\n"
"        perror(\"semget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/semget.2:456
#, no-wrap
msgid "    printf(\"ID = %d\\en\", semid);\n"
msgstr "    printf(\"ID = %d\\en\", semid);\n"

#. type: Plain text
#: build/C/man2/semget.2:459
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/semget.2:467
msgid ""
"B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr "B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7)"

#. type: TH
#: build/C/man2/semop.2:35
#, no-wrap
msgid "SEMOP"
msgstr "SEMOP"

#. type: Plain text
#: build/C/man2/semop.2:38
msgid "semop, semtimedop - System V semaphore operations"
msgstr "semop, semtimedop - System V セマフォの操作"

#. type: Plain text
#: build/C/man2/semop.2:45
#, no-wrap
msgid "B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<);>\n"
msgstr "B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<);>\n"

#. type: Plain text
#: build/C/man2/semop.2:48
#, no-wrap
msgid ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/semop.2:57
msgid "B<semtimedop>(): _GNU_SOURCE"
msgstr "B<semtimedop>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man2/semop.2:60
msgid ""
"Each semaphore in a System\\ V semaphore set has the following associated "
"values:"
msgstr ""
"System\\ V セマフォ集合 (semaphore set) のメンバーの各セマフォは 以下の関連情"
"報を持っている:"

#. type: Plain text
#: build/C/man2/semop.2:67
#, fuzzy, no-wrap
#| msgid ""
#| "unsigned short  semval;   /* semaphore value */\n"
#| "unsigned short  semzcnt;  /* # waiting for zero */\n"
#| "unsigned short  semncnt;  /* # waiting for increase */\n"
#| "pid_t           sempid;   /* ID of process that did last op */\n"
msgid ""
"unsigned short  semval;   /* semaphore value */\n"
"unsigned short  semzcnt;  /* # waiting for zero */\n"
"unsigned short  semncnt;  /* # waiting for increase */\n"
"pid_t           sempid;   /* PID of process that last\n"
msgstr ""
"unsigned short  semval;   /* セマフォ値 */\n"
"unsigned short  semzcnt;  /* ゼロを待つプロセス数 */\n"
"unsigned short  semncnt;  /* 増加を待つプロセス数 */\n"
"pid_t           sempid;   /* 最後に操作を行なったプロセスの ID */\n"

#. type: Plain text
#: build/C/man2/semop.2:82
msgid ""
"B<semop>()  performs operations on selected semaphores in the set indicated "
"by I<semid>.  Each of the I<nsops> elements in the array pointed to by "
"I<sops> is a structure that specifies an operation to be performed on a "
"single semaphore.  The elements of this structure are of type I<struct "
"sembuf>, containing the following members:"
msgstr ""
"B<semop>()  は I<semid> で指定されたセマフォ集合の選択されたセマフォに対して"
"操作を行う。 I<sops> は I<nsops> 個の要素の配列を指し、配列の各要素は個々のセ"
"マフォに対する操作を示す構造体である。その型は I<struct sembuf> で、次のメン"
"バを持つ:"

#. type: Plain text
#: build/C/man2/semop.2:88
#, no-wrap
msgid ""
"unsigned short sem_num;  /* semaphore number */\n"
"short          sem_op;   /* semaphore operation */\n"
"short          sem_flg;  /* operation flags */\n"
msgstr ""
"unsigned short sem_num;  /* セマフォ番号 */\n"
"short          sem_op;   /* セマフォ操作 */\n"
"short          sem_flg;  /* 操作フラグ */\n"

#. type: Plain text
#: build/C/man2/semop.2:100
msgid ""
"Flags recognized in I<sem_flg> are B<IPC_NOWAIT> and B<SEM_UNDO>.  If an "
"operation specifies B<SEM_UNDO>, it will be automatically undone when the "
"process terminates."
msgstr ""
"I<sem_flg> には B<IPC_NOWAIT> と B<SEM_UNDO> が設定できる。 B<SEM_UNDO> が指"
"定された操作は、そのプロセスが終了した時に自動的に取り消される。"

#. type: Plain text
#: build/C/man2/semop.2:115
msgid ""
"The set of operations contained in I<sops> is performed in I<array order>, "
"and I<atomically>, that is, the operations are performed either as a "
"complete unit, or not at all.  The behavior of the system call if not all "
"operations can be performed immediately depends on the presence of the "
"B<IPC_NOWAIT> flag in the individual I<sem_flg> fields, as noted below."
msgstr ""
"I<sops> に含まれる操作の集合は、 I<配列の順序> で、 I<アトミックに> 実行され"
"る。 すなわち、全ての操作が完全に実行されるか、全く実行されないかの どちらか"
"となる。 全ての操作が直ちに実行できない場合のこのシステムコールの振る舞いは "
"個々の操作の I<sem_flg> フィールドに B<IPC_NOWAIT> が存在するかによって決ま"
"り、後述のようになる。"

#. type: Plain text
#: build/C/man2/semop.2:122
msgid ""
"Each operation is performed on the I<sem_num>-th semaphore of the semaphore "
"set, where the first semaphore of the set is numbered 0.  There are three "
"types of operation, distinguished by the value of I<sem_op>."
msgstr ""
"それぞれの操作はセマフォ集合の I<sem_num>番目 のセマフォに対して実行される。"
"セマフォ集合の最初のセマフォには 番号 0 が振られる。 そして操作は三種類あ"
"り、 I<sem_op> の値で区別される。"

#. type: Plain text
#: build/C/man2/semop.2:137
msgid ""
"If I<sem_op> is a positive integer, the operation adds this value to the "
"semaphore value (I<semval>).  Furthermore, if B<SEM_UNDO> is specified for "
"this operation, the system subtracts the value I<sem_op> from the semaphore "
"adjustment (I<semadj>)  value for this semaphore.  This operation can always "
"proceed\\(emit never forces a thread to wait.  The calling process must have "
"alter permission on the semaphore set."
msgstr ""
"I<sem_op> が正の整数の場合、その値をセマフォの値 (I<semval>) に加算する。 さ"
"らに、この操作で B<SEM_UNDO> が指定されていた場合は、 システムはこのセマフォ"
"のの調整値 (I<semadj>) から値 I<sem_op> を減算する。 この操作は必ず実行で"
"き、 スレッドの停止は起こらない。 呼び出し元プロセスは対象のセマフォ集合を変"
"更する許可がなければならない。"

#. type: Plain text
#: build/C/man2/semop.2:162
msgid ""
"If I<sem_op> is zero, the process must have read permission on the semaphore "
"set.  This is a \"wait-for-zero\" operation: if I<semval> is zero, the "
"operation can immediately proceed.  Otherwise, if B<IPC_NOWAIT> is specified "
"in I<sem_flg>, B<semop>()  fails with I<errno> set to B<EAGAIN> (and none of "
"the operations in I<sops> is performed).  Otherwise, I<semzcnt> (the count "
"of threads waiting until this semaphore's value becomes zero)  is "
"incremented by one and the thread sleeps until one of the following occurs:"
msgstr ""
"I<sem_op> が 0 の場合、「ゼロまで待つ」操作である。この場合、プロセスは その"
"セマフォ集合に対する読み込み許可がなければならない。 I<semval> が 0 ならば、"
"操作は直ちに行われる。 I<semval> が 0 でない場合、 I<sem_flg> に "
"B<IPC_NOWAIT> が指定されていれば、 B<semop>()  は失敗し、 B<errno> に "
"B<EAGAIN> が設定される (このとき I<sops> に対する操作は全く実行されない)。 "
"I<sem_flg> に B<IPC_NOWAIT> が指定されていない場合、 I<semzcnt> (セマフォ値"
"が 0 になるのを待っているスレッドの数) を 1 増加させて、 以下のいずれかが起こ"
"るまでスレッドを停止 (sleep) する。"

#. type: Plain text
#: build/C/man2/semop.2:167
msgid ""
"I<semval> becomes 0, at which time the value of I<semzcnt> is decremented."
msgstr "I<semval> が 0 になった: このとき I<semzcnt> の値は 1 減算される。"

#. type: Plain text
#: build/C/man2/semop.2:175
msgid ""
"The semaphore set is removed: B<semop>()  fails, with I<errno> set to "
"B<EIDRM>."
msgstr ""
"セマフォ集合が削除された: このとき B<semop>()  は失敗し、 I<errno> に "
"B<EIDRM> が設定される。"

#. type: Plain text
#: build/C/man2/semop.2:185
msgid ""
"The calling thread catches a signal: the value of I<semzcnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""
"呼び出し元スレッドがシグナルを捕獲した: このとき I<semzcnt> の値は 1 減算さ"
"れ、 B<semop>()  は失敗し I<errno> に B<EINTR> が設定される。"

#. type: Plain text
#: build/C/man2/semop.2:227
msgid ""
"If I<sem_op> is less than zero, the process must have alter permission on "
"the semaphore set.  If I<semval> is greater than or equal to the absolute "
"value of I<sem_op>, the operation can proceed immediately: the absolute "
"value of I<sem_op> is subtracted from I<semval>, and, if B<SEM_UNDO> is "
"specified for this operation, the system adds the absolute value of "
"I<sem_op> to the semaphore adjustment (I<semadj>)  value for this "
"semaphore.  If the absolute value of I<sem_op> is greater than I<semval>, "
"and B<IPC_NOWAIT> is specified in I<sem_flg>, B<semop>()  fails, with "
"I<errno> set to B<EAGAIN> (and none of the operations in I<sops> is "
"performed).  Otherwise, I<semncnt> (the counter of threads waiting for this "
"semaphore's value to increase)  is incremented by one and the thread sleeps "
"until one of the following occurs:"
msgstr ""
"I<sem_op> が 0 未満の場合、プロセスにはそのセマフォ集合を変更する許可がなけれ"
"ば ならない。 I<semval> が I<sem_op> の絶対値以上の場合は、操作は直ちに実行さ"
"れる: I<semval> から I<sem_op> の絶対値を減算し、さらに、この操作に "
"B<SEM_UNDO> が指定されている場合は、このセマフォの調整値 (I<semadj>) に "
"I<sem_op> の絶対値を加算する。 I<semval> が I<sem_op> の絶対値より小さく、 "
"I<sem_flg> に B<IPC_NOWAIT> が指定された場合は、 B<semop>()  は失敗し、 "
"I<errno> に B<EAGAIN> が設定される (このとき I<sops> の操作は全く実行されな"
"い)。 I<semval> が I<sem_op> の絶対値より小さく、 B<IPC_WAIT> が指定されてい"
"ない場合は、 I<semncnt> (このセマフォの値が増加するのを待っているスレッド数の"
"カウンター)  を 1 増加させて、以下のいずれかが起こるまでスレッドを停止 "
"(sleep) する。"

#. type: Plain text
#: build/C/man2/semop.2:232
msgid ""
"I<semval> becomes greater than or equal to the absolute value of I<sem_op>: "
"the operation now proceeds, as described above."
msgstr ""
"I<semval> が I<sem_op> の絶対値以上になった。この時点で、操作は上述の通り実行"
"される。"

#. type: Plain text
#: build/C/man2/semop.2:239
msgid ""
"The semaphore set is removed from the system: B<semop>()  fails, with "
"I<errno> set to B<EIDRM>."
msgstr ""
"セマフォ集合がシステムから削除された: このとき B<semop>()  は失敗し I<errno> "
"に B<EIDRM> が設定される。"

#. type: Plain text
#: build/C/man2/semop.2:249
msgid ""
"The calling thread catches a signal: the value of I<semncnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""
"呼び出したスレッドがシグナルを捕獲した: このとき I<semncnt> が 1 減算され、 "
"B<semop>()  は失敗し I<errno> に B<EINTR> が設定される。"

#.  and
#.  .I sem_ctime
#. type: Plain text
#: build/C/man2/semop.2:260
msgid ""
"On successful completion, the I<sempid> value for each semaphore specified "
"in the array pointed to by I<sops> is set to the caller's process ID.  In "
"addition, the I<sem_otime> is set to the current time."
msgstr ""
"操作が成功した場合、 I<sops> が指す配列によって操作対象となった各セマフォの "
"I<sempid> メンバーには呼び出し元のプロセス ID が設定される。さらに "
"I<sem_otime> に現在時刻が設定される。"

#. type: SS
#: build/C/man2/semop.2:260
#, no-wrap
msgid "semtimedop()"
msgstr "semtimedop()"

#. type: Plain text
#: build/C/man2/semop.2:290
msgid ""
"B<semtimedop>()  behaves identically to B<semop>()  except that in those "
"cases where the calling thread would sleep, the duration of that sleep is "
"limited by the amount of elapsed time specified by the I<timespec> structure "
"whose address is passed in the I<timeout> argument.  (This sleep interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the interval may overrun by a small amount.)  If the "
"specified time limit has been reached, B<semtimedop>()  fails with I<errno> "
"set to B<EAGAIN> (and none of the operations in I<sops> is performed).  If "
"the I<timeout> argument is NULL, then B<semtimedop>()  behaves exactly like "
"B<semop>()."
msgstr ""
"B<semtimedop>() 関数の振る舞いは B<semop>() と全く同じだが、呼び出し元\n"
"スレッドが停止する場合、停止期間の上限が I<timeout> 引数の指す\n"
"I<timespec> 構造体で指定された時間となる点だけが異なる (この停止期間は\n"
"システムクロックの粒度に切り上げられ、カーネルのスケジューリング遅延に\n"
"より、この停止期間は少しだけ長くなる可能性がある)。\n"
"指定した制限時間に達した場合は、 B<semtimedop>() は失敗し、 I<errno> に\n"
"B<EAGAIN> が設定される (このとき I<sops> の操作は実行されない)。\n"
"I<timeout> 引数が NULL の場合、 B<semtimedop>() 関数の振る舞いは\n"
"B<semop>() 関数と全く同じになる。"

#. type: Plain text
#: build/C/man2/semop.2:298
msgid ""
"Note that if B<semtimedop>()  is interrupted by a signal, causing the call "
"to fail with the error B<EINTR>, the contents of I<timeout> are left "
"unchanged."
msgstr "B<semtimedop>() がシグナルにより割り込まれた場合、呼び出しはエラー B<EINTR> で失敗し、 I<timeout> の内容は変更されないままとなる点に注意すること。"

#. type: Plain text
#: build/C/man2/semop.2:308
msgid ""
"If successful, B<semop>()  and B<semtimedop>()  return 0; otherwise they "
"return -1 with I<errno> indicating the error."
msgstr ""
"成功した場合、 B<semop>()  と B<semtimedop>()  は 0 を返す。そうでなければ "
"-1 を返し、 エラーを示す I<errno> を設定する。"

#. type: Plain text
#: build/C/man2/semop.2:312
msgid "On failure, I<errno> is set to one of the following:"
msgstr "失敗した場合、 I<errno> に以下のどれかが設定される:"

#. type: TP
#: build/C/man2/semop.2:312
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/semop.2:320
msgid ""
"The argument I<nsops> is greater than B<SEMOPM>, the maximum number of "
"operations allowed per system call."
msgstr ""
"I<nsops> 引数が B<SEMOPM> より大きい。 B<SEMOPM> は一回のシステムコールで許"
"される操作の最大個数である。"

#. type: Plain text
#: build/C/man2/semop.2:327
#, fuzzy
#| msgid ""
#| "The calling process does not have the permissions required to perform the "
#| "specified semaphore operations, and does not have the B<CAP_IPC_OWNER> "
#| "capability."
msgid ""
"The calling process does not have the permissions required to perform the "
"specified semaphore operations, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"呼び出し元プロセスには指定されたセマフォ操作を行うのに 必要なアクセス許可がな"
"く、 B<CAP_IPC_OWNER> ケーパビリティもない。"

#. type: Plain text
#: build/C/man2/semop.2:336
msgid ""
"An operation could not proceed immediately and either B<IPC_NOWAIT> was "
"specified in I<sem_flg> or the time limit specified in I<timeout> expired."
msgstr ""
"操作を直ちに処理することができず、かつ I<sem_flg> に B<IPC_NOWAIT> が指定され"
"ているか I<timeout> で指定された制限時間が経過した。"

#. type: Plain text
#: build/C/man2/semop.2:343
msgid ""
"An address specified in either the I<sops> or the I<timeout> argument isn't "
"accessible."
msgstr "引数 I<sops> か I<timeout> が指しているアドレスにアクセスできない。"

#. type: TP
#: build/C/man2/semop.2:343
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/semop.2:349
msgid ""
"For some operation the value of I<sem_num> is less than 0 or greater than or "
"equal to the number of semaphores in the set."
msgstr ""
"ある操作で、 I<sem_num> の値が 0 未満か、集合内のセマフォの数以上である。"

#. type: Plain text
#: build/C/man2/semop.2:356
msgid ""
"While blocked in this system call, the thread caught a signal; see "
"B<signal>(7)."
msgstr ""
"このシステムコールで停止している時にスレッドがシグナルを捕獲した。 "
"B<single>(7) 参照。"

#. type: Plain text
#: build/C/man2/semop.2:363
msgid ""
"The semaphore set doesn't exist, or I<semid> is less than zero, or I<nsops> "
"has a nonpositive value."
msgstr ""
"セマフォ集合が存在しないか、 I<semid> が 0 未満であるか、 I<nsops> が正の数で"
"ない。"

#. type: Plain text
#: build/C/man2/semop.2:371
msgid ""
"The I<sem_flg> of some operation specified B<SEM_UNDO> and the system does "
"not have enough memory to allocate the undo structure."
msgstr ""
"ある操作で I<sem_flg> に B<SEM_UNDO> が指定されたが、システムにアンドゥ構造体"
"に割り当てる十分なメモリーがない。"

#. type: Plain text
#: build/C/man2/semop.2:379
msgid ""
"For some operation I<sem_op+semval> is greater than B<SEMVMX>, the "
"implementation dependent maximum value for I<semval>."
msgstr ""
"ある操作で I<sem_op+semval> が B<SEMVMX> より大きい。 B<SEMVMX> は I<semval> "
"の最大値で、その値は実装依存である。"

#. type: SH
#: build/C/man2/semop.2:379
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/semop.2:386
msgid ""
"B<semtimedop>()  first appeared in Linux 2.5.52, and was subsequently "
"backported into kernel 2.4.22.  Glibc support for B<semtimedop>()  first "
"appeared in version 2.3.3."
msgstr ""
"B<semtimedop>()  は Linux 2.5.52 で初めて登場し、 それからカーネル 2.4.22 に"
"も移植された。 B<semtimedop>()  の glibc でのサポートはバージョン 2.3.3 で初"
"めて登場した。"

#. type: Plain text
#: build/C/man2/semop.2:410
msgid ""
"The I<sem_undo> structures of a process aren't inherited by the child "
"produced by B<fork>(2), but they are inherited across an B<execve>(2)  "
"system call."
msgstr ""
"あるプロセスの I<sem_undo> 構造体は B<fork>(2)  で生成された子プロセスには継"
"承されないが、 B<execve>(2)  システムコールの場合は継承される。"

#. type: Plain text
#: build/C/man2/semop.2:416
msgid ""
"B<semop>()  is never automatically restarted after being interrupted by a "
"signal handler, regardless of the setting of the B<SA_RESTART> flag when "
"establishing a signal handler."
msgstr ""
"B<semop>()  はシグナルハンドラーによって中断された後に、 決して自動的に再開す"
"ることはない。 たとえシグナルハンドラーの設定時に B<SA_RESTART> フラグがセッ"
"トされていても再開することはない"

#. type: Plain text
#: build/C/man2/semop.2:449
msgid ""
"A semaphore adjustment (I<semadj>)  value is a per-process, per-semaphore "
"integer that is the negated sum of all operations performed on a semaphore "
"specifying the B<SEM_UNDO> flag.  Each process has a list of I<semadj> values"
"\\(emone value for each semaphore on which it has operated using "
"B<SEM_UNDO>.  When a process terminates, each of its per-semaphore I<semadj> "
"values is added to the corresponding semaphore, thus undoing the effect of "
"that process's operations on the semaphore (but see BUGS below).  When a "
"semaphore's value is directly set using the B<SETVAL> or B<SETALL> request "
"to B<semctl>(2), the corresponding I<semadj> values in all processes are "
"cleared.  The B<clone>(2)  B<CLONE_SYSVSEM> flag allows more than one "
"process to share a I<semadj> list; see B<clone>(2)  for details."
msgstr ""
"セマフォの調整値 (I<semadj>) は、プロセス毎のセマフォ毎の整数で、 "
"B<SEM_UNDO> フラグを指定して行われた、セマフォに対するすべての操作の合計値を"
"反転したものである。 各プロセスは I<semadj> の値のリストを保持する \\(em リス"
"トのそれぞれの値は B<SEM_UNDO> を使って操作が行われた個々のセマフォに対応す"
"る。 プロセスが終了する際、 セマフォ毎の I<semadj> の各々の値が対応するセマ"
"フォに加算される。 これにより、そのプロセスがそのセマフォに対して行った操作の"
"影響が取り消される (ただし、下記の「バグ」を参照)。 B<semctl>(2) の "
"B<SETVAL> や B<SETALL> を使ってセマフォの値が直接設定された場合、 すべてのプ"
"ロセスの対応する I<semadj> の値がクリアされる。 B<clone>(2) の "
"B<CLONE_SYSVSEM> フラグを使うと、 複数のプロセスがひとつの I<semadj> リストを"
"共有できる。 詳細は B<clone>(2) を参照。"

#. type: Plain text
#: build/C/man2/semop.2:454
msgid ""
"The I<semval>, I<sempid>, I<semzcnt>, and I<semnct> values for a semaphore "
"can all be retrieved using appropriate B<semctl>(2)  calls."
msgstr ""
"あるセマフォの I<semval>, I<sempid>, I<semzcnt>, I<semnct> の値はいずれも、適"
"切な操作を指定して B<semctl>(2)  を呼び出すことで取得できる。"

#. type: Plain text
#: build/C/man2/semop.2:458
msgid ""
"The following limits on semaphore set resources affect the B<semop>()  call:"
msgstr ""
"セマフォ集合のリソースに関する制限のうち、 B<semop>()  に影響を及ぼすものを以"
"下に挙げる:"

#. type: TP
#: build/C/man2/semop.2:458
#, no-wrap
msgid "B<SEMOPM>"
msgstr "B<SEMOPM>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#.  See comment in Linux 3.19 source file include/uapi/linux/sem.h
#. type: Plain text
#: build/C/man2/semop.2:478
msgid ""
"Maximum number of operations allowed for one B<semop>()  call.  Before Linux "
"3.19, the default value for this limit was 32.  Since Linux 3.19, the "
"default value is 500.  On Linux, this limit can be read and modified via the "
"third field of I</proc/sys/kernel/sem>.  I<Note>: this limit should not be "
"raised above 1000, because of the risk of that B<semop>()  fails due to "
"kernel memory fragmentation when allocating memory to copy the I<sops> array."
msgstr ""

#. type: Plain text
#: build/C/man2/semop.2:483
msgid ""
"Maximum allowable value for I<semval>: implementation dependent (32767)."
msgstr "I<semval> が取り得る最大値: 実装依存 (32767)。"

#. type: Plain text
#: build/C/man2/semop.2:490
msgid ""
"The implementation has no intrinsic limits for the adjust on exit maximum "
"value (B<SEMAEM>), the system wide maximum number of undo structures "
"(B<SEMMNU>)  and the per-process maximum number of undo entries system "
"parameters."
msgstr ""
"以下の値に関しては実装依存の制限はない。 終了時の調整 (adjust on exit) の最大"
"値 (B<SEMAEM>)、 システム全体のアンドゥ構造体の最大数 (B<SEMMNU>)、 プロセス"
"あたりのアンドゥ構造体の最大数。"

#. type: Plain text
#: build/C/man2/semop.2:511
msgid ""
"When a process terminates, its set of associated I<semadj> structures is "
"used to undo the effect of all of the semaphore operations it performed with "
"the B<SEM_UNDO> flag.  This raises a difficulty: if one (or more) of these "
"semaphore adjustments would result in an attempt to decrease a semaphore's "
"value below zero, what should an implementation do? One possible approach "
"would be to block until all the semaphore adjustments could be performed.  "
"This is however undesirable since it could force process termination to "
"block for arbitrarily long periods.  Another possibility is that such "
"semaphore adjustments could be ignored altogether (somewhat analogously to "
"failing when B<IPC_NOWAIT> is specified for a semaphore operation).  Linux "
"adopts a third approach: decreasing the semaphore value as far as possible "
"(i.e., to zero) and allowing process termination to proceed immediately."
msgstr ""
"プロセスが終了する際、プロセスに対応する I<semadj> の集合を使って、 "
"B<SEM_UNDO> フラグ付きで実行された全てのセマフォ操作の影響を取り消す。 これに"
"よりある問題が発生する: これらのセマフォの調整を行っていると、 中にはセマフォ"
"の値が 0 未満の値にしようとする場合が出てくる。 このような場合、どのように実"
"装するべきか? ひとつの考えられる手法は、全てのセマフォ調整が実行されるまで 停"
"止することである。しかし、この方法ではプロセスの終了が 長時間にわたって停止さ"
"れることがあるので望ましくない。 しかもどれくらい長時間になるかは分からな"
"い。 別の選択肢として、このようなセマフォ調整を完全に無視してしまう方法があ"
"る (これはセマフォ操作として B<IPC_NOWAIT> が指定するのと少し似ている)。 "
"Linux は第三の手法を採用している: セマフォの値を出来るだけ (つまり 0 まで) 減"
"少させて、プロセスの終了を直ちに続行できるようにしている。"

#.  The bug report:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110260821123863&w=2
#.  the fix:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110261701025794&w=2
#. type: Plain text
#: build/C/man2/semop.2:520
msgid ""
"In kernels 2.6.x, x E<lt>= 10, there is a bug that in some circumstances "
"prevents a thread that is waiting for a semaphore value to become zero from "
"being woken up when the value does actually become zero.  This bug is fixed "
"in kernel 2.6.11."
msgstr ""
"カーネル 2.6.x (x E<lt>= 10) には、ある状況においてセマフォ値が 0 になるのを "
"待っているスレッドが、セマフォ値が実際に 0 になったときに起床 (wake up)  され"
"ない、というバグがある。このバグはカーネル 2.6.11 で修正されている。"

#. type: Plain text
#: build/C/man2/semop.2:525
msgid ""
"The following code segment uses B<semop>()  to atomically wait for the value "
"of semaphore 0 to become zero, and then increment the semaphore value by one."
msgstr ""
"以下の部分的なコードは、 セマフォ 0 の値が 0 になるのを待ってから、 セマフォ"
"の値を 1 加算する処理を、 B<semop>()  を使ってアトミック (atomically) に行"
"う。"

#. type: Plain text
#: build/C/man2/semop.2:530
#, no-wrap
msgid ""
"struct sembuf sops[2];\n"
"int semid;\n"
msgstr ""
"struct sembuf sops[2];\n"
"int semid;\n"

#. type: Plain text
#: build/C/man2/semop.2:532
#, no-wrap
msgid "/* Code to set I<semid> omitted */\n"
msgstr "/* Code to set I<semid> omitted */\n"

#. type: Plain text
#: build/C/man2/semop.2:536
#, no-wrap
msgid ""
"sops[0].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[0].sem_op = 0;         /* Wait for value to equal 0 */\n"
"sops[0].sem_flg = 0;\n"
msgstr ""
"sops[0].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[0].sem_op = 0;         /* Wait for value to equal 0 */\n"
"sops[0].sem_flg = 0;\n"

#. type: Plain text
#: build/C/man2/semop.2:540
#, no-wrap
msgid ""
"sops[1].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[1].sem_op = 1;         /* Increment value by one */\n"
"sops[1].sem_flg = 0;\n"
msgstr ""
"sops[1].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[1].sem_op = 1;         /* Increment value by one */\n"
"sops[1].sem_flg = 0;\n"

#. type: Plain text
#: build/C/man2/semop.2:545
#, no-wrap
msgid ""
"if (semop(semid, sops, 2) == -1) {\n"
"    perror(\"semop\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"if (semop(semid, sops, 2) == -1) {\n"
"    perror(\"semop\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/semop.2:552
msgid ""
"A further example of the use of B<semop>()  can be found in B<shmop>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/semop.2:561
msgid ""
"B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), "
"B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7), B<time>(7)"
msgstr "B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7), B<time>(7)"

#~ msgid ""
#~ "A signal handler always interrupts a blocked call to one of these "
#~ "functions, regardless of the use of the B<sigaction>(2)  B<SA_RESTART> "
#~ "flag."
#~ msgstr ""
#~ "シグナルハンドラーは、 B<sigaction>(2)  の B<SA_RESTART> フラグを使用して"
#~ "いるかどうかに関わらず、これらの関数の呼び出しが 停止している場合、シグナ"
#~ "ルハンドラーにより常に中断される。"

#~ msgid ""
#~ "Write the values of some members of the I<semid_ds> structure pointed to "
#~ "by I<arg.buf> to the kernel data structure associated with this semaphore "
#~ "set, updating also its I<sem_ctime> member.  The following members of the "
#~ "structure are updated: I<sem_perm.uid>, I<sem_perm.gid>, and (the least "
#~ "significant 9 bits of)  I<sem_perm.mode>.  The effective UID of the "
#~ "calling process must match the owner (I<sem_perm.uid>)  or creator "
#~ "(I<sem_perm.cuid>)  of the semaphore set, or the caller must be "
#~ "privileged.  The argument I<semnum> is ignored."
#~ msgstr ""
#~ "I<arg.buf> で指定された I<semid_ds> 構造体のメンバーのいくつかの値を、 こ"
#~ "のセマフォに関連づけられたカーネルデータ構造体に書き込み、 I<sem_ctime> メ"
#~ "ンバーの値も更新する。 構造体の以下のメンバーが更新される: I<sem_perm."
#~ "uid>, I<sem_perm.gid>, I<sem_perm.mode> (の最下位 9 ビット)。 呼び出したプ"
#~ "ロセスの実効 UID が所有者 (I<sem_perm.uid>)  または作成者 (I<sem_perm."
#~ "cuid>)  と一致するか、呼び出した人が特権を持たなければならない。 "
#~ "I<semnum> 引数は無視される。"

#~ msgid ""
#~ "Return the value of B<semncnt> for the I<semnum>-th semaphore of the set "
#~ "(i.e., the number of processes waiting for an increase of B<semval> for "
#~ "the I<semnum>-th semaphore of the set).  The calling process must have "
#~ "read permission on the semaphore set."
#~ msgstr ""
#~ "集合の I<semnum> 番目のセマフォの B<semncnt> の値を返す (集合の I<semnum> "
#~ "番目のセマフォの B<semval> の増加を待っているプロセスの数を返す)。 呼び出"
#~ "したプロセスはそのセマフォ集合に読み込み許可を持たなければならない。"

#~ msgid ""
#~ "Maximum number of operations allowed for one B<semop>()  call (32)  (on "
#~ "Linux, this limit can be read and modified via the third field of I</proc/"
#~ "sys/kernel/sem>)."
#~ msgstr ""
#~ "一回の B<semop>()  で許される操作の最大数 (32)。 (Linux では、この制限値"
#~ "は I</proc/sys/kernel/sem> の第3フィールドに対応し、読み出しも変更もでき"
#~ "る)。"
