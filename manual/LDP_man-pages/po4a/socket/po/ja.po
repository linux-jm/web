# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:43+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/accept.2:41
#, no-wrap
msgid "ACCEPT"
msgstr "ACCEPT"

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/connect.2:67
#: build/C/man2/getsockopt.2:44 build/C/man2/select_tut.2:32
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:69 build/C/man2/bpf.2:26
#: build/C/man2/connect.2:67 build/C/man2/getsockname.2:40
#: build/C/man2/getsockopt.2:44 build/C/man2/listen.2:45 build/C/man2/recv.2:41
#: build/C/man2/recvmmsg.2:31 build/C/man2/select.2:40
#: build/C/man2/select_tut.2:32 build/C/man2/send.2:40
#: build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25
#: build/C/man2/socket.2:42 build/C/man7/socket.7:54
#: build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42
#: build/C/man7/address_families.7:26 build/C/man7/sock_diag.7:24
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:69
#: build/C/man3/bindresvport.3:30 build/C/man2/bpf.2:26
#: build/C/man2/connect.2:67 build/C/man3/getifaddrs.3:36
#: build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44
#: build/C/man3/if_nameindex.3:26 build/C/man3/if_nametoindex.3:25
#: build/C/man2/listen.2:45 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31
#: build/C/man2/select.2:40 build/C/man2/select_tut.2:32 build/C/man2/send.2:40
#: build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25
#: build/C/man2/socket.2:42 build/C/man7/socket.7:54
#: build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42
#: build/C/man7/address_families.7:26 build/C/man7/sock_diag.7:24
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/accept.2:42 build/C/man2/bind.2:70
#: build/C/man3/bindresvport.3:31 build/C/man2/bpf.2:27
#: build/C/man2/connect.2:68 build/C/man3/getifaddrs.3:37
#: build/C/man2/getsockname.2:41 build/C/man2/getsockopt.2:45
#: build/C/man3/if_nameindex.3:27 build/C/man3/if_nametoindex.3:26
#: build/C/man2/listen.2:46 build/C/man2/recv.2:42 build/C/man2/recvmmsg.2:32
#: build/C/man2/select.2:41 build/C/man2/select_tut.2:33 build/C/man2/send.2:41
#: build/C/man2/sendmmsg.2:29 build/C/man3/sockatmark.3:26
#: build/C/man2/socket.2:43 build/C/man7/socket.7:55
#: build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:43
#: build/C/man7/bpf-helpers.7:4 build/C/man7/address_families.7:27
#: build/C/man7/sock_diag.7:25 build/C/man7/vsock.7:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/accept.2:44
msgid "accept, accept4 - accept a connection on a socket"
msgstr "accept, accept4 - ソケットへの接続を受ける"

#. type: SH
#: build/C/man2/accept.2:44 build/C/man2/bind.2:72
#: build/C/man3/bindresvport.3:33 build/C/man2/bpf.2:29
#: build/C/man2/connect.2:70 build/C/man3/getifaddrs.3:39
#: build/C/man2/getsockname.2:43 build/C/man2/getsockopt.2:47
#: build/C/man3/if_nameindex.3:29 build/C/man3/if_nametoindex.3:29
#: build/C/man2/listen.2:48 build/C/man2/recv.2:44 build/C/man2/recvmmsg.2:34
#: build/C/man2/select.2:44 build/C/man2/select_tut.2:35 build/C/man2/send.2:43
#: build/C/man2/sendmmsg.2:31 build/C/man3/sockatmark.3:28
#: build/C/man2/socket.2:45 build/C/man7/socket.7:57
#: build/C/man2/socketcall.2:28 build/C/man2/socketpair.2:45
#: build/C/man7/address_families.7:29 build/C/man7/sock_diag.7:27
#: build/C/man7/vsock.7:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/accept.2:48 build/C/man2/bind.2:76 build/C/man2/connect.2:74
#: build/C/man2/getsockopt.2:51 build/C/man2/listen.2:52
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>          /* 「注意」参照 */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/accept.2:50
#, no-wrap
msgid "B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr "B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/accept.2:53
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/accept.2:56
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"

#. type: SH
#: build/C/man2/accept.2:57 build/C/man2/bind.2:80
#: build/C/man3/bindresvport.3:40 build/C/man2/bpf.2:35
#: build/C/man2/connect.2:78 build/C/man3/getifaddrs.3:48
#: build/C/man2/getsockname.2:50 build/C/man2/getsockopt.2:57
#: build/C/man3/if_nameindex.3:36 build/C/man3/if_nametoindex.3:37
#: build/C/man2/listen.2:55 build/C/man2/recv.2:58 build/C/man2/recvmmsg.2:43
#: build/C/man2/select.2:68 build/C/man2/select_tut.2:38 build/C/man2/send.2:58
#: build/C/man2/sendmmsg.2:40 build/C/man3/sockatmark.3:42
#: build/C/man2/socket.2:51 build/C/man7/socket.7:61
#: build/C/man2/socketcall.2:32 build/C/man2/socketpair.2:52
#: build/C/man7/bpf-helpers.7:91 build/C/man7/address_families.7:35
#: build/C/man7/sock_diag.7:36 build/C/man7/vsock.7:36
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/accept.2:72
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""
"B<accept>()  システムコールは、接続指向のソケット型 (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  で用いられる。 この関数は、接続待ちソケット I<socket> 宛"
"ての保留状態の接続要求が入っているキューから 先頭の接続要求を取り出し、接続済"
"みソケットを新規に生成し、 そのソケットを参照する新しいファイルディスクリプ"
"ターを返す。 新規に生成されたソケットは、接続待ち (listen) 状態ではない。 も"
"ともとのソケット I<sockfd> はこの呼び出しによって影響を受けない。"

#. type: Plain text
#: build/C/man2/accept.2:81
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""
"引数 I<sockfd> は、 B<socket>(2)  によって生成され、 B<bind>(2)  によって"
"ローカルアドレスにバインドされ、 B<listen>(2)  を経て接続を待っているソケット"
"である。"

#. type: Plain text
#: build/C/man2/accept.2:99
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""
"I<addr> 引数は I<sockaddr> 構造体へのポインターである。 この構造体には接続"
"相手のソケットのアドレスが入っている。 I<addr> 引数で返されるアドレスの正確"
"なフォーマットは、 ソケットのアドレス種別によって変わる (B<socket>(2)  および"
"それぞれのプロトコルの man ページを参照)。 I<addr> が NULL の場合、 I<addr> "
"には何も入らない。この場合、 I<addrlen> は使用されず、この引数は NULL にし"
"ておくべきである。"

#. type: Plain text
#: build/C/man2/accept.2:107
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""
"I<addrlen> 引数は入出力両用の引数である。呼び出し時には、呼び出し元が "
"I<addr> が指す構造体のサイズ (バイト単位) で初期化しておかなければならない。 "
"返ってくる時には、接続相手のアドレスの実際の大きさが格納される。"

#. type: Plain text
#: build/C/man2/accept.2:112 build/C/man2/getsockname.2:67
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""
"渡されたバッファーが小さ過ぎた場合は、返されるアドレスの末尾が切り詰められ"
"る。\n"
"この場合には、 I<addrlen> には、呼び出し時に指定された値よりも大きな値が格納"
"される。"

#. type: Plain text
#: build/C/man2/accept.2:125
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""
"キューに保留となっている接続要求がなく、 かつソケットが非停止になっていないと"
"きは、 B<accept>()  は接続が発生するまで呼び出し元を停止 (block) する。 ソ"
"ケットが非停止になっていて、 待ち状態の接続要求がキューに無いときは、 "
"B<accept>()  はエラー B<EAGAIN> か B<EWOULDBLOCK> で失敗する。"

#. type: Plain text
#: build/C/man2/accept.2:140
#, fuzzy
#| msgid ""
#| "In order to be notified of incoming connections on a socket, you can use "
#| "B<select>(2)  or B<poll>(2).  A readable event will be delivered when a "
#| "new connection is attempted and you may then call B<accept>()  to get a "
#| "socket for that connection.  Alternatively, you can set the socket to "
#| "deliver B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for "
#| "details."
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2), B<poll>(2), or B<epoll>(7).  A readable event will be "
"delivered when a new connection is attempted and you may then call "
"B<accept>()  to get a socket for that connection.  Alternatively, you can "
"set the socket to deliver B<SIGIO> when activity occurs on a socket; see "
"B<socket>(7)  for details."
msgstr ""
"ソケットへの接続到着を知るには、 B<select>(2)  または B<poll>(2)  を用いれば"
"よい。 新しい接続要求が来るとソケットは読み込み可能になるので、 そうしたら "
"B<accept>()  を呼んでその接続に対するソケットを取得すればよい。 あるいはソ"
"ケットに設定を行い、何らかのアクションがあったときに B<SIGIO> を配送 "
"(deliver) させるようにすることもできる。詳細は B<socket>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/accept.2:150
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""
"I<flags> が 0 の場合、 B<accept4>()  は B<accept>()  と同じである。 I<flags> "
"に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさせることが"
"できる。"

#. type: TP
#: build/C/man2/accept.2:150 build/C/man2/socket.2:264
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<SOCK_NONBLOCK>"

#. type: Plain text
#: build/C/man2/accept.2:160 build/C/man2/socket.2:274
#, fuzzy
#| msgid ""
#| "Set the B<O_NONBLOCK> file status flag on the new open file description.  "
#| "Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
#| "result."
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: TP
#: build/C/man2/accept.2:160 build/C/man2/socket.2:274
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr "B<SOCK_CLOEXEC>"

#. type: Plain text
#: build/C/man2/accept.2:170 build/C/man2/socket.2:284
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプターに対して close-on-exec (B<FD_CLOEXEC>)  フラグ"
"をセットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: SH
#: build/C/man2/accept.2:170 build/C/man2/bind.2:153
#: build/C/man3/bindresvport.3:69 build/C/man2/bpf.2:974
#: build/C/man2/connect.2:136 build/C/man3/getifaddrs.3:142
#: build/C/man2/getsockname.2:67 build/C/man2/getsockopt.2:130
#: build/C/man3/if_nameindex.3:71 build/C/man3/if_nametoindex.3:54
#: build/C/man2/listen.2:81 build/C/man2/recv.2:434 build/C/man2/recvmmsg.2:147
#: build/C/man2/select.2:388 build/C/man2/select_tut.2:318
#: build/C/man2/send.2:318 build/C/man2/sendmmsg.2:119
#: build/C/man3/sockatmark.3:51 build/C/man2/socket.2:416
#: build/C/man2/socketpair.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/accept.2:179
#, fuzzy
#| msgid ""
#| "On success, these system calls return a nonnegative integer that is a "
#| "descriptor for the accepted socket.  On error, -1 is returned, and "
#| "I<errno> is set appropriately."
msgid ""
"On success, these system calls return a file descriptor for the accepted "
"socket (a nonnegative integer).  On error, -1 is returned, I<errno> is set "
"appropriately, and I<addrlen> is left unchanged."
msgstr ""
"成功した場合、これらのシステムコールは 受け付けたソケットのディスクリプターで"
"ある非負の整数値を返す。 エラーが発生した場合は -1 を返し、 I<errno> を適切に"
"設定する。"

#. type: SS
#: build/C/man2/accept.2:179
#, no-wrap
msgid "Error handling"
msgstr "エラー処理"

#. type: Plain text
#: build/C/man2/accept.2:206
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of TCP/"
"IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""
"Linux の B<accept>()  (と B<accept4>())  は、新しいソケットにおける、発生済み"
"のネットワークエラーを B<accept>()  からのエラーコードとして渡す。 この振舞い"
"は BSD ソケットの実装とは異なる。 信頼性の高い動作を行うためには、 アプリケー"
"ションはプロトコルで定義されているネットワークエラーの検知を B<accept>()  の"
"あとに行い、それらのエラーを B<EAGAIN> と同じように扱い、再試行 (retry) を行"
"うべきである。 TCP/IP では、以下のエラーが該当する: B<ENETDOWN>, B<EPROTO>, "
"B<ENOPROTOOPT>, B<EHOSTDOWN>, B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, "
"B<ENETUNREACH>"

#. type: SH
#: build/C/man2/accept.2:206 build/C/man2/bind.2:158
#: build/C/man3/bindresvport.3:74 build/C/man2/bpf.2:989
#: build/C/man2/connect.2:141 build/C/man3/getifaddrs.3:149
#: build/C/man2/getsockname.2:72 build/C/man2/getsockopt.2:139
#: build/C/man3/if_nameindex.3:78 build/C/man3/if_nametoindex.3:69
#: build/C/man2/listen.2:86 build/C/man2/recv.2:450 build/C/man2/recvmmsg.2:155
#: build/C/man2/select.2:408 build/C/man2/send.2:323
#: build/C/man2/sendmmsg.2:133 build/C/man3/sockatmark.3:58
#: build/C/man2/socket.2:421 build/C/man2/socketpair.2:84
#: build/C/man7/vsock.7:177
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/accept.2:207 build/C/man2/recv.2:455 build/C/man2/send.2:339
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> または B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/accept.2:216
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 and POSIX.1-2008 allow either error to be returned "
"for this case, and do not require these constants to have the same value, so "
"a portable application should check for both possibilities."
msgstr "ソケットが非停止になっていて、 かつ受付け対象の接続が存在しない。 POSIX.1-2001 と POSIX.1-2008 は、この場合にどちらのエラーを返すことも認めており、 これら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性が必要なアプリケーションでは、両方の可能性を 確認すべきである。"

#. type: TP
#: build/C/man2/accept.2:216 build/C/man2/bind.2:176 build/C/man2/bpf.2:1012
#: build/C/man2/connect.2:194 build/C/man2/getsockname.2:73
#: build/C/man2/getsockopt.2:140 build/C/man2/listen.2:103
#: build/C/man2/recv.2:464 build/C/man2/select.2:409 build/C/man2/send.2:363
#: build/C/man3/sockatmark.3:59
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/accept.2:220
msgid "I<sockfd> is not an open file descriptor."
msgstr "I<sockfd> がオープンされたファイルディスクリプターでない。"

#. type: TP
#: build/C/man2/accept.2:220
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: build/C/man2/accept.2:223
msgid "A connection has been aborted."
msgstr "接続が中止された。"

#. type: TP
#: build/C/man2/accept.2:223 build/C/man2/bind.2:209 build/C/man2/bpf.2:1016
#: build/C/man2/connect.2:203 build/C/man2/getsockname.2:78
#: build/C/man2/getsockopt.2:145 build/C/man2/recv.2:473
#: build/C/man2/send.2:373 build/C/man2/socketpair.2:88
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/accept.2:228
msgid ""
"The I<addr> argument is not in a writable part of the user address space."
msgstr "I<addr> 引数がユーザーアドレス空間の書き込み可能領域にない。"

#. type: TP
#: build/C/man2/accept.2:228 build/C/man2/connect.2:233 build/C/man2/recv.2:477
#: build/C/man2/select.2:415 build/C/man2/send.2:376
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/accept.2:233
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""
"有効な接続が到着する前に捕捉されたシグナルによって システムコールが中断され"
"た。 B<signal>(7)  参照。"

#. type: TP
#: build/C/man2/accept.2:233 build/C/man2/accept.2:238 build/C/man2/bind.2:180
#: build/C/man2/bind.2:185 build/C/man2/bpf.2:1027 build/C/man2/bpf.2:1032
#: build/C/man2/bpf.2:1039 build/C/man2/bpf.2:1048
#: build/C/man2/getsockname.2:84 build/C/man2/getsockopt.2:155
#: build/C/man2/recv.2:482 build/C/man2/recvmmsg.2:159
#: build/C/man2/select.2:419 build/C/man2/select.2:426 build/C/man2/send.2:380
#: build/C/man3/sockatmark.3:63 build/C/man2/socket.2:429
#: build/C/man2/socket.2:432 build/C/man7/vsock.7:189
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/accept.2:238
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""
"ソケットが接続待ち状態ではない。もしくは、 I<addrlen> が不正である (例えば、"
"負の場合など)。"

#. type: Plain text
#: build/C/man2/accept.2:243
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr "(B<accept4>())  I<flags> に不正な値が指定されている。"

#. type: TP
#: build/C/man2/accept.2:243 build/C/man2/socket.2:437
#: build/C/man2/socketpair.2:93
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/accept.2:246 build/C/man2/socket.2:440
#: build/C/man2/socketpair.2:96
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "1プロセスがオープンできるファイルディスクリプター数の上限に達した。"

#. type: TP
#: build/C/man2/accept.2:246 build/C/man2/socket.2:440
#: build/C/man2/socketpair.2:96
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/accept.2:249 build/C/man2/socket.2:443
#: build/C/man2/socketpair.2:99
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: TP
#: build/C/man2/accept.2:249
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr "B<ENOBUFS>, B<ENOMEM>"

#. type: Plain text
#: build/C/man2/accept.2:254
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""
"メモリーが足りない。 多くの場合は、システムメモリーが足りないわけではなく、 "
"ソケットバッファーの大きさによるメモリー割り当ての制限である。"

#. type: TP
#: build/C/man2/accept.2:254 build/C/man2/bind.2:191 build/C/man2/connect.2:245
#: build/C/man2/getsockname.2:92 build/C/man2/getsockopt.2:169
#: build/C/man2/listen.2:108 build/C/man2/recv.2:497 build/C/man2/send.2:409
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: build/C/man2/accept.2:259 build/C/man2/bind.2:196 build/C/man2/connect.2:250
#: build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:174
#: build/C/man2/listen.2:113 build/C/man2/recv.2:502 build/C/man2/send.2:414
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr "ファイルディスクリプター I<sockfd> がソケットを参照していない。"

#. type: TP
#: build/C/man2/accept.2:259 build/C/man2/listen.2:113 build/C/man2/send.2:414
#: build/C/man2/socketpair.2:99 build/C/man7/vsock.7:205
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/accept.2:263
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr "参照しているソケットの型が B<SOCK_STREAM> でない。"

#. type: TP
#: build/C/man2/accept.2:263
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: build/C/man2/accept.2:266
msgid "Protocol error."
msgstr "プロトコルエラー。"

#. type: Plain text
#: build/C/man2/accept.2:270
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr "上記に加えて、Linux の B<accept>()  は以下のエラーで失敗する:"

#. type: TP
#: build/C/man2/accept.2:270 build/C/man2/bpf.2:1068
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/accept.2:273
msgid "Firewall rules forbid connection."
msgstr "ファイアウォールのルールにより接続が禁止された。"

#. type: Plain text
#: build/C/man2/accept.2:285
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""
"この他に、新しいソケットに対するネットワークエラーが返されることもある。 これ"
"らはそれぞれのプロトコルで定義されている。 いろいろな Linux カーネルでは、 以"
"下に示すようなエラーを返すこともある。 B<ENOSR>, B<ESOCKTNOSUPPORT>, "
"B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  B<ERESTARTSYS> がトレースの最中に現れるこ"
"ともある。"

#. type: SH
#: build/C/man2/accept.2:285 build/C/man2/bpf.2:1074
#: build/C/man3/getifaddrs.3:162 build/C/man3/if_nameindex.3:97
#: build/C/man2/recvmmsg.2:165 build/C/man2/select.2:434
#: build/C/man2/sendmmsg.2:146 build/C/man3/sockatmark.3:70
#: build/C/man7/socket.7:1207 build/C/man7/sock_diag.7:621
#: build/C/man7/vsock.7:231
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/accept.2:290
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""
"B<accept4>()  システムコールは Linux 2.6.28 以降で利用可能である。 glibc での"
"サポートはバージョン 2.10 以降で利用可能である。"

#. type: SH
#: build/C/man2/accept.2:290 build/C/man2/bind.2:233
#: build/C/man3/bindresvport.3:117 build/C/man2/bpf.2:1078
#: build/C/man2/connect.2:262 build/C/man3/getifaddrs.3:184
#: build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:174
#: build/C/man3/if_nameindex.3:119 build/C/man3/if_nametoindex.3:106
#: build/C/man2/listen.2:118 build/C/man2/recv.2:502
#: build/C/man2/recvmmsg.2:170 build/C/man2/select.2:440
#: build/C/man2/send.2:428 build/C/man2/sendmmsg.2:151
#: build/C/man3/sockatmark.3:85 build/C/man2/socket.2:454
#: build/C/man2/socketcall.2:150 build/C/man2/socketpair.2:105
#: build/C/man7/sock_diag.7:638
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: build/C/man2/accept.2:302
msgid ""
"B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<accept>()  first "
"appeared in 4.2BSD)."
msgstr "B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (B<accept>()  は 4.2BSD で初めて実装された)."

#. type: Plain text
#: build/C/man2/accept.2:305
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr "B<accept4>()  は非標準の Linux による拡張である。"

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: build/C/man2/accept.2:320
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""
"Linux では、 B<accept>()  が返す新しいソケットは listen を行っているソケット"
"の ファイル状態フラグ (B<O_NONBLOCK> や B<O_ASYNC> など) を継承「しない」。 "
"この動作は標準的な BSD ソケットの実装とは異なっている。 移植性を考慮したプロ"
"グラムではファイル状態フラグが継承されるかどうかは 前提にせず、常に "
"B<accept>()  が返したソケットに対して全ての必要なフラグを明示的に設定するよう"
"に すべきである。"

#. type: SH
#: build/C/man2/accept.2:320 build/C/man2/bind.2:245
#: build/C/man3/bindresvport.3:120 build/C/man2/bpf.2:1082
#: build/C/man2/connect.2:278 build/C/man3/getifaddrs.3:204
#: build/C/man2/getsockname.2:103 build/C/man2/getsockopt.2:181
#: build/C/man2/listen.2:122 build/C/man2/recv.2:512 build/C/man2/select.2:455
#: build/C/man2/select_tut.2:321 build/C/man2/send.2:442
#: build/C/man2/sendmmsg.2:154 build/C/man3/sockatmark.3:87
#: build/C/man2/socket.2:468 build/C/man7/socket.7:1221
#: build/C/man2/socketcall.2:153 build/C/man2/socketpair.2:112
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/accept.2:326
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""
"POSIX.1-2001 では I<E<lt>sys/types.hE<gt>> のインクルードは必須とされておら"
"ず、 Linux ではこのヘッダーファイルは必要ではない。 しかし、歴史的には、いく"
"つかの実装 (BSD 系) でこのヘッダーファイルが 必要であり、移植性が必要なアプリ"
"ケーションではこのファイルを インクルードするのが賢明であろう。"

#. type: Plain text
#: build/C/man2/accept.2:348
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2), B<poll>(2), or B<epoll>(7)  return a readability event "
"because the connection might have been removed by an asynchronous network "
"error or another thread before B<accept>()  is called.  If this happens, "
"then the call will block waiting for the next connection to arrive.  To "
"ensure that B<accept>()  never blocks, the passed socket I<sockfd> needs to "
"have the B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr "B<SIGIO> が届けられた後や、 B<select>(2), B<poll>(2), B<epoll>(7) が読み込み可能イベントを返した後に、 必ずしも待機中の接続があるとは限らない。 なぜならその接続は、 B<accept>()  が呼ばれる前に、非同期的なネットワークエラーや 他のスレッドから呼ばれた (別の) accept によって 削除されているかもしれないからである。 この場合、その B<accept>()  呼び出しは停止 (block) し、次の接続の到着を待ちつづける。 B<accept>()  に停止を行わせないようにするには、引数に渡すソケット I<sockfd> に B<O_NONBLOCK> フラグをセットしておく必要がある (B<socket>(7)  を見よ)。"

#. type: Plain text
#: build/C/man2/accept.2:359
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECnet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently, only DECnet has these "
"semantics on Linux."
msgstr "明示的な接続確認 (confirmation) を必要とするようなプロトコル (DECnet など) では、 B<accept>()  は単に次の接続要求をキューから取り出すだけであり、 接続確認は行わないことに注意せよ。接続確認は、 新しいファイルディスクリプターに対する 通常の読み取り/書き込みによってなされ、接続拒否 (rejection)  は新しいソケットをクローズすることによってなされる。 現在のところ、 Linux 上でこれらのセマンティクスを持つのは DECnet だけである。"

#. type: SS
#: build/C/man2/accept.2:359
#, no-wrap
msgid "The socklen_t type"
msgstr "socklen_t 型"

#.  such as Linux libc4 and libc5, SunOS 4, SGI
#.  SunOS 5 has 'size_t *'
#. type: Plain text
#: build/C/man2/accept.2:370
msgid ""
"In the original BSD sockets implementation (and on other older systems)  the "
"third argument of B<accept>()  was declared as an I<int\\ *>.  A POSIX.1g "
"draft standard wanted to change it into a I<size_t\\ *>C; later POSIX "
"standards and glibc 2.x have I<socklen_t\\ * >."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:370 build/C/man2/bind.2:259 build/C/man2/bpf.2:1204
#: build/C/man2/connect.2:295 build/C/man3/getifaddrs.3:221
#: build/C/man3/if_nameindex.3:123 build/C/man2/listen.2:178
#: build/C/man2/recv.2:557 build/C/man2/recvmmsg.2:192
#: build/C/man2/select.2:709 build/C/man2/select_tut.2:347
#: build/C/man2/send.2:471 build/C/man2/sendmmsg.2:177
#: build/C/man3/sockatmark.3:111 build/C/man2/socket.2:487
#: build/C/man7/bpf-helpers.7:3595 build/C/man7/sock_diag.7:640
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man2/accept.2:373 build/C/man2/listen.2:181
msgid "See B<bind>(2)."
msgstr "B<bind>(2)  参照。"

#. type: SH
#: build/C/man2/accept.2:373 build/C/man2/bind.2:324
#: build/C/man3/bindresvport.3:126 build/C/man2/bpf.2:1273
#: build/C/man2/connect.2:300 build/C/man3/getifaddrs.3:324
#: build/C/man2/getsockname.2:108 build/C/man2/getsockopt.2:195
#: build/C/man3/if_nameindex.3:162 build/C/man3/if_nametoindex.3:110
#: build/C/man2/listen.2:181 build/C/man2/recv.2:562
#: build/C/man2/recvmmsg.2:286 build/C/man2/select.2:746
#: build/C/man2/select_tut.2:639 build/C/man2/send.2:476
#: build/C/man2/sendmmsg.2:245 build/C/man3/sockatmark.3:146
#: build/C/man2/socket.2:492 build/C/man7/socket.7:1241
#: build/C/man2/socketcall.2:174 build/C/man2/socketpair.2:138
#: build/C/man7/bpf-helpers.7:3674 build/C/man7/address_families.7:407
#: build/C/man7/sock_diag.7:837 build/C/man7/vsock.7:241
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/accept.2:380
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"

#. type: SH
#: build/C/man2/accept.2:380 build/C/man2/bind.2:337
#: build/C/man3/bindresvport.3:129 build/C/man2/bpf.2:1282
#: build/C/man2/connect.2:308 build/C/man3/getifaddrs.3:330
#: build/C/man2/getsockname.2:115 build/C/man2/getsockopt.2:206
#: build/C/man3/if_nameindex.3:169 build/C/man3/if_nametoindex.3:114
#: build/C/man2/listen.2:187 build/C/man2/recv.2:578
#: build/C/man2/recvmmsg.2:293 build/C/man2/select.2:761
#: build/C/man2/select_tut.2:652 build/C/man2/send.2:493
#: build/C/man2/sendmmsg.2:250 build/C/man3/sockatmark.3:151
#: build/C/man2/socket.2:523 build/C/man7/socket.7:1259
#: build/C/man2/socketcall.2:192 build/C/man2/socketpair.2:145
#: build/C/man7/bpf-helpers.7:3686 build/C/man7/address_families.7:410
#: build/C/man7/sock_diag.7:842 build/C/man7/vsock.7:249
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/accept.2:388 build/C/man2/bind.2:345
#: build/C/man3/bindresvport.3:137 build/C/man2/bpf.2:1290
#: build/C/man2/connect.2:316 build/C/man3/getifaddrs.3:338
#: build/C/man2/getsockname.2:123 build/C/man2/getsockopt.2:214
#: build/C/man3/if_nameindex.3:177 build/C/man3/if_nametoindex.3:122
#: build/C/man2/listen.2:195 build/C/man2/recv.2:586
#: build/C/man2/recvmmsg.2:301 build/C/man2/select.2:769
#: build/C/man2/select_tut.2:660 build/C/man2/send.2:501
#: build/C/man2/sendmmsg.2:258 build/C/man3/sockatmark.3:159
#: build/C/man2/socket.2:531 build/C/man7/socket.7:1267
#: build/C/man2/socketcall.2:200 build/C/man2/socketpair.2:153
#: build/C/man7/bpf-helpers.7:3694 build/C/man7/address_families.7:418
#: build/C/man7/sock_diag.7:850 build/C/man7/vsock.7:257
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/bind.2:69
#, no-wrap
msgid "BIND"
msgstr "BIND"

#. type: TH
#: build/C/man2/bind.2:69 build/C/man2/bpf.2:26 build/C/man3/getifaddrs.3:36
#: build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:40
#: build/C/man2/send.2:40 build/C/man7/sock_diag.7:24
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man2/bind.2:72
msgid "bind - bind a name to a socket"
msgstr "bind - ソケットに名前をつける"

#. type: Plain text
#: build/C/man2/bind.2:79
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/bind.2:93
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""
"B<socket>(2)  でソケットが作成されたとき、そのソケットは名前空間 (アドレス"
"ファミリー) に 存在するが、アドレスは割り当てられていない。 B<bind>()  は、"
"ファイルディスクリプター I<sockfd> で参照されるソケットに I<addr> で指定され"
"たアドレスを割り当てる。 I<addrlen> には I<addr> が指すアドレス構造体のサイズ"
"をバイト単位で指定する。 伝統的にこの操作は 「ソケットに名前をつける」 と呼ば"
"れる。"

#. type: Plain text
#: build/C/man2/bind.2:100
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""
"B<SOCK_STREAM> ソケットが接続を受け付けられるようにするには (B<accept>(2)  を"
"参照)、通常その前に B<bind>()  を使用してローカルアドレスを割り当てる必要があ"
"る。"

#. type: Plain text
#: build/C/man2/bind.2:131
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET>, see "
"B<ip>(7); for B<AF_INET6>, see B<ipv6>(7); for B<AF_UNIX>, see B<unix>(7); "
"for B<AF_APPLETALK>, see B<ddp>(7); for B<AF_PACKET>, see B<packet>(7); for "
"B<AF_X25>, see B<x25>(7); and for B<AF_NETLINK>, see B<netlink>(7)."
msgstr ""
"名前付けのルールはアドレスファミリーごとに異なっている。詳細な情報は 第 7 章"
"の各マニュアルを参照すること。 B<AF_INET> は B<ip>(7)  を、 B<AF_INET6> は "
"B<ipv6>(7)  を、 B<AF_UNIX> は B<unix>(7)  を、 B<AF_APPLETALK> は "
"B<ddp>(7)  を、 B<AF_PACKET> は B<packet>(7)  を、 B<AF_X25> は B<x25>(7)  "
"を、 B<AF_NETLINK> は B<netlink>(7)  を参照。"

#. type: Plain text
#: build/C/man2/bind.2:138
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""
"I<addr> 引数に実際にどのような構造体が渡されるかは、 アドレスファミリーに依"
"存する。 I<sockaddr> 構造体は以下のような感じで定義されている:"

#. type: Plain text
#: build/C/man2/bind.2:145
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"

#. type: Plain text
#: build/C/man2/bind.2:153
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLES below."
msgstr ""
"この構造体は、 I<addr> に渡される構造体へのポインターをキャストし、 コンパイ"
"ラの警告メッセージを抑えるためだけに存在する。 下記の「例」を参照。"

#. type: Plain text
#: build/C/man2/bind.2:158 build/C/man2/getsockname.2:72
#: build/C/man2/listen.2:86
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合にはゼロが返される。エラー時には -1 が返され、 I<errno> が適切に"
"設定される。"

#. type: TP
#: build/C/man2/bind.2:159 build/C/man2/bind.2:200
#: build/C/man3/bindresvport.3:79 build/C/man2/bpf.2:995
#: build/C/man2/connect.2:144 build/C/man2/send.2:328 build/C/man2/socket.2:422
#: build/C/man7/vsock.7:178
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: build/C/man2/bind.2:163
msgid "The address is protected, and the user is not the superuser."
msgstr "そのアドレスは保護されていて、かつユーザーがスーパーユーザーではない。"

#. type: TP
#: build/C/man2/bind.2:163 build/C/man2/bind.2:166
#: build/C/man3/bindresvport.3:85 build/C/man2/connect.2:164
#: build/C/man2/listen.2:87 build/C/man2/listen.2:90 build/C/man7/vsock.7:183
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: build/C/man2/bind.2:166
msgid "The given address is already in use."
msgstr "指定されたアドレスが既に使用中である。"

#. type: Plain text
#: build/C/man2/bind.2:176
msgid ""
"(Internet domain sockets)  The port number was specified as zero in the "
"socket address structure, but, upon attempting to bind to an ephemeral port, "
"it was determined that all port numbers in the ephemeral port range are "
"currently in use.  See the discussion of I</proc/sys/net/ipv4/"
"ip_local_port_range> B<ip>(7)."
msgstr ""
"(インターネットドメインソケットの場合) ソケットアドレス構造体でポート番号に "
"0 が指定されたが、 一時ポート (ephemeral port) を割り当てようとした際に、 一"
"時ポートとして使用する範囲のすべてのポート番号が使用中であった。 B<ip>(7) の "
"I</proc/sys/net/ipv4/ip_local_port_range> の説明を参照。"

#. type: Plain text
#: build/C/man2/bind.2:180 build/C/man3/sockatmark.3:63
msgid "I<sockfd> is not a valid file descriptor."
msgstr "I<sockfd> が有効なファイルディスクリプターでない。"

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: build/C/man2/bind.2:185
msgid "The socket is already bound to an address."
msgstr "ソケットがすでにアドレスに結びつけ (bind) られている。"

#. type: Plain text
#: build/C/man2/bind.2:191
msgid ""
"I<addrlen> is wrong, or I<addr> is not a valid address for this socket's "
"domain."
msgstr ""
"I<addrlen> が間違っているか、 I<addr> がこのソケットのドメインで有効なアドレ"
"スではない。"

#. type: Plain text
#: build/C/man2/bind.2:200
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr "以下のエラーは UNIXドメイン (B<AF_UNIX>)  のソケット特有である:"

#. type: Plain text
#: build/C/man2/bind.2:205
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"パス名の構成要素に検索許可 (search permission) がない "
"(B<path_resolution>(7)  も参照すること)。"

#. type: TP
#: build/C/man2/bind.2:205 build/C/man2/connect.2:167 build/C/man7/vsock.7:186
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: build/C/man2/bind.2:209
msgid ""
"A nonexistent interface was requested or the requested address was not local."
msgstr ""
"存在しないインターフェースが要求されたか、要求されたアドレスが ローカルではな"
"かった。"

#. type: Plain text
#: build/C/man2/bind.2:213
msgid "I<addr> points outside the user's accessible address space."
msgstr "I<addr> がユーザーのアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/bind.2:213
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/bind.2:217
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr "I<addr> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: TP
#: build/C/man2/bind.2:217
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/bind.2:221
msgid "I<addr> is too long."
msgstr "I<addr> が長過ぎる。"

#. type: TP
#: build/C/man2/bind.2:221 build/C/man2/bpf.2:1056
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/bind.2:224
msgid ""
"A component in the directory prefix of the socket pathname does not exist."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:224 build/C/man2/bpf.2:1065 build/C/man2/recv.2:486
#: build/C/man2/select.2:431 build/C/man2/send.2:403
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/bind.2:227
msgid "Insufficient kernel memory was available."
msgstr "カーネルに、利用可能なメモリーが十分にない。"

#. type: TP
#: build/C/man2/bind.2:227
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/bind.2:230
msgid "A component of the path prefix is not a directory."
msgstr "パス名の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/bind.2:230
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/bind.2:233
msgid "The socket inode would reside on a read-only filesystem."
msgstr "ソケット inode が読み込み専用のファイルシステム上にある。"

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: build/C/man2/bind.2:245
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<bind>()  first appeared in "
"4.2BSD)."
msgstr "B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (B<bind>() は 4.2BSD で初めて実装された)."

#. type: Plain text
#: build/C/man2/bind.2:251 build/C/man2/connect.2:284
#: build/C/man2/getsockopt.2:187 build/C/man2/listen.2:148
#: build/C/man2/socket.2:474 build/C/man2/socketpair.2:138
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this "
"header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr "POSIX.1 では I<E<lt>sys/types.hE<gt>> のインクルードは必須とされておらず、 Linux ではこのヘッダーファイルは必要ではない。 しかし、歴史的には、いくつかの実装 (BSD 系) でこのヘッダーファイルが 必要であり、移植性が必要なアプリケーションではこのファイルを インクルードするのが賢明であろう。"

#. type: Plain text
#: build/C/man2/bind.2:256 build/C/man2/connect.2:289
#: build/C/man2/getsockname.2:108 build/C/man2/getsockopt.2:192
#, fuzzy
#| msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr "I<socklen_t> 型は POSIX で発案された。 B<accept>(2) も参照。"

#. type: SH
#: build/C/man2/bind.2:256 build/C/man2/getsockopt.2:192
#: build/C/man2/recvmmsg.2:173 build/C/man2/select.2:635
#: build/C/man2/send.2:466 build/C/man2/sendmmsg.2:169
#: build/C/man3/sockatmark.3:107
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  FIXME Document transparent proxy options
#. type: Plain text
#: build/C/man2/bind.2:259
msgid "The transparent proxy options are not described."
msgstr "透過的プロキシ (transparent proxy) オプションについて記述していない。"

#. type: Plain text
#: build/C/man2/bind.2:264
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""
"インターネットドメインソケットでの B<bind>()  の利用例が B<getaddrinfo>(3)  "
"に記載されている。"

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: build/C/man2/bind.2:271
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""
"以下の例は、UNIX ドメイン (B<AF_UNIX>)  でストリームソケットを bind する方法"
"を示したものである。"

#. type: Plain text
#: build/C/man2/bind.2:278
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/bind.2:281
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"

#. type: Plain text
#: build/C/man2/bind.2:284
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/bind.2:291
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"

#. type: Plain text
#: build/C/man2/bind.2:295
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"

#. type: Plain text
#: build/C/man2/bind.2:301
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(my_addr));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""
"    memset(&my_addr, 0, sizeof(my_addr));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"

#. type: Plain text
#: build/C/man2/bind.2:305
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(my_addr)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(my_addr)) == -1)\n"
"        handle_error(\"bind\");\n"

#. type: Plain text
#: build/C/man2/bind.2:308
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"

#. type: Plain text
#: build/C/man2/bind.2:311
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"

#. type: Plain text
#: build/C/man2/bind.2:317
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(peer_addr);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""
"    peer_addr_size = sizeof(peer_addr);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"

#. type: Plain text
#: build/C/man2/bind.2:319
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr "    /* Code to deal with incoming connection(s)... */\n"

#. type: Plain text
#: build/C/man2/bind.2:323
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"

#. type: Plain text
#: build/C/man2/bind.2:337
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: build/C/man3/bindresvport.3:30
#, no-wrap
msgid "BINDRESVPORT"
msgstr "BINDRESVPORT"

#. type: TH
#: build/C/man3/bindresvport.3:30 build/C/man2/getsockname.2:40
#: build/C/man3/if_nametoindex.3:25 build/C/man2/socketcall.2:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/bindresvport.3:33
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr "bindresvport - ソケットを特権 IP ポートにバインドする"

#. type: Plain text
#: build/C/man3/bindresvport.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bindresvport.3:39
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: build/C/man3/bindresvport.3:48
#, fuzzy
#| msgid ""
#| "B<bindresvport>()  is used to bind a socket descriptor to a privileged "
#| "anonymous IP port, that is, a port number arbitrarily selected from the "
#| "range 512 to 1023."
msgid ""
"B<bindresvport>()  is used to bind the socket referred to by the file "
"descriptor I<sockfd> to a privileged anonymous IP port, that is, a port "
"number arbitrarily selected from the range 512 to 1023."
msgstr ""
"B<bindresvport>()  は、ソケットディスクリプターを特権無名 (privileged "
"anonymous) IP ポートに バインドするのに使う。特権無名 IP ポートとは、 ポート"
"番号が 512 から 1023 の範囲から任意に選択されるポートである。"

#. type: Plain text
#: build/C/man3/bindresvport.3:58
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin> "
"is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""
"B<bindresvport>()  によって実行された B<bind>(2)  が成功し、 I<sin> が NULL "
"以外の場合、実際に割り当てられたポート番号が I<sin-E<gt>sin_port> に入れて返"
"される。"

#. type: Plain text
#: build/C/man3/bindresvport.3:69
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken "
"to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""
"I<sin> には NULL を指定することもでき、その場合には I<sin-E<gt>sin_family> は"
"暗黙のうちに B<AF_INET> とみなされる。 しかし、この場合には、 "
"B<bindresvport>()  は実際に割り当てられたポート番号を返す手段を持たない (割り"
"当てられたポート番号は、後で B<getsockname>(2)  を使って取得できる)。"

#. type: Plain text
#: build/C/man3/bindresvport.3:74
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""
"B<bindresvport>()  は成功すると 0 を返す。それ以外の場合、-1 を返し、 "
"I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/bindresvport.3:79
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""
"B<bindresvport>()  は B<bind>(2)  と同じ原因で失敗する可能性がある。 さらに、"
"以下のエラーが発生することがある:"

#. type: Plain text
#: build/C/man3/bindresvport.3:85
msgid ""
"The calling process was not privileged (on Linux: the calling process did "
"not have the B<CAP_NET_BIND_SERVICE> capability in the user namespace "
"governing its network namespace)."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:88
msgid "All privileged ports are in use."
msgstr "全ての特権ポートが使用中である。"

#. type: TP
#: build/C/man3/bindresvport.3:88
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr "B<EAFNOSUPPORT> (glibc 2.7 以前では B<EPFNOSUPPORT>)"

#. type: Plain text
#: build/C/man3/bindresvport.3:95
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""
"I<sin> が NULL 以外で、かつ I<sin-E<gt>sin_family> が B<AF_INET> でなかった。"

#. type: SH
#: build/C/man3/bindresvport.3:95 build/C/man3/getifaddrs.3:170
#: build/C/man3/if_nameindex.3:104 build/C/man3/if_nametoindex.3:93
#: build/C/man3/sockatmark.3:73
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/bindresvport.3:98 build/C/man3/getifaddrs.3:173
#: build/C/man3/if_nameindex.3:107 build/C/man3/if_nametoindex.3:96
#: build/C/man3/sockatmark.3:76
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177
#: build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100
#: build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177
#: build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100
#: build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177
#: build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100
#: build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/bindresvport.3:105
#, no-wrap
msgid "B<bindresvport>()"
msgstr "B<bindresvport>()"

#. type: tbl table
#: build/C/man3/bindresvport.3:105 build/C/man3/getifaddrs.3:181
#: build/C/man3/if_nameindex.3:116 build/C/man3/if_nametoindex.3:104
#: build/C/man3/sockatmark.3:83
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#.  commit f6da27e53695ad1cc0e2a9490358decbbfdff5e5
#. type: tbl table
#: build/C/man3/bindresvport.3:108
#, no-wrap
msgid "glibc E<gt>= 2.17: MT-Safe\n"
msgstr "glibc E<gt>= 2.17: MT-Safe\n"

#. type: tbl table
#: build/C/man3/bindresvport.3:108 build/C/man3/if_nameindex.3:114
#: build/C/man2/socket.2:147 build/C/man7/socket.7:188
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/bindresvport.3:110
#, no-wrap
msgid "glibc E<lt> 2.17: MT-Unsafe"
msgstr "glibc E<lt> 2.17: MT-Unsafe"

#. type: Plain text
#: build/C/man3/bindresvport.3:117
#, fuzzy
#| msgid ""
#| "Before glibc 2.17, the B<bindresvport>()  function uses a static variable "
#| "that is not protected, so it is not thread-safe."
msgid ""
"The B<bindresvport>()  function uses a static variable that was not "
"protected by a lock before glibc 2.17, rendering the function MT-Unsafe."
msgstr ""
"glibc 2.17 より前のバージョンでは、 B<bindresvport>() 関数は保護されていない"
"静的変数を使用しているため、スレッドセーフではない。"

#. type: Plain text
#: build/C/man3/bindresvport.3:120
#, fuzzy
#| msgid ""
#| "Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other "
#| "systems."
msgid "Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems."
msgstr ""
"POSIX.1-2001 にはない。 BSD, Solaris およびその他の多くのシステムに存在する。"

#. type: Plain text
#: build/C/man3/bindresvport.3:126
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""
"B<bindresvport>()  のいくつかの実装と異なり、glibc の実装では呼び出し元が "
"I<sin-E<gt>sin_port> で渡した値はどんな値であっても無視される。"

#. type: Plain text
#: build/C/man3/bindresvport.3:129
msgid "B<bind>(2), B<getsockname>(2)"
msgstr "B<bind>(2), B<getsockname>(2)"

#. type: TH
#: build/C/man2/bpf.2:26
#, no-wrap
msgid "BPF"
msgstr "BPF"

#. type: Plain text
#: build/C/man2/bpf.2:29
msgid "bpf - perform a command on an extended BPF map or program"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:32
#, no-wrap
msgid "B<#include E<lt>linux/bpf.hE<gt>>\n"
msgstr "B<#include E<lt>linux/bpf.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/bpf.2:34
#, no-wrap
msgid "B<int bpf(int >I<cmd>B<, union bpf_attr *>I<attr>B<, unsigned int >I<size>B<);>\n"
msgstr "B<int bpf(int >I<cmd>B<, union bpf_attr *>I<attr>B<, unsigned int >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/bpf.2:45
msgid ""
"The B<bpf>()  system call performs a range of operations related to extended "
"Berkeley Packet Filters.  Extended BPF (or eBPF) is similar to the original "
"(\"classic\") BPF (cBPF) used to filter network packets.  For both cBPF and "
"eBPF programs, the kernel statically analyzes the programs before loading "
"them, in order to ensure that they cannot harm the running system."
msgstr ""

#.  See 'enum bpf_func_id' in include/uapi/linux/bpf.h
#. type: Plain text
#: build/C/man2/bpf.2:54
msgid ""
"eBPF extends cBPF in multiple ways, including the ability to call a fixed "
"set of in-kernel helper functions (via the B<BPF_CALL> opcode extension "
"provided by eBPF)  and access shared data structures such as eBPF maps."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:54
#, no-wrap
msgid "Extended BPF Design/Architecture"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:59
msgid ""
"eBPF maps are a generic data structure for storage of different data types.  "
"Data types are generally treated as binary blobs, so a user just specifies "
"the size of the key and the size of the value at map-creation time.  In "
"other words, a key/value for a given map can have an arbitrary structure."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:65
msgid ""
"A user process can create multiple maps (with key/value-pairs being opaque "
"bytes of data) and access them via file descriptors.  Different eBPF "
"programs can access the same maps in parallel.  It's up to the user process "
"and eBPF program to decide what they store inside maps."
msgstr ""

#.  Defined by the kernel constant MAX_TAIL_CALL_CNT in include/linux/bpf.h
#. type: Plain text
#: build/C/man2/bpf.2:83
msgid ""
"There's one special map type, called a program array.  This type of map "
"stores file descriptors referring to other eBPF programs.  When a lookup in "
"the map is performed, the program flow is redirected in-place to the "
"beginning of another eBPF program and does not return back to the calling "
"program.  The level of nesting has a fixed limit of 32, so that infinite "
"loops cannot be crafted.  At run time, the program file descriptors stored "
"in the map can be modified, so program functionality can be altered based on "
"specific requirements.  All programs referred to in a program-array map must "
"have been previously loaded into the kernel via B<bpf>().  If a map lookup "
"fails, the current program continues its execution.  See "
"B<BPF_MAP_TYPE_PROG_ARRAY> below for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:97
msgid ""
"Generally, eBPF programs are loaded by the user process and automatically "
"unloaded when the process exits.  In some cases, for example, B<tc-bpf>(8), "
"the program will continue to stay alive inside the kernel even after the "
"process that loaded the program exits.  In that case, the tc subsystem holds "
"a reference to the eBPF program after the file descriptor has been closed by "
"the user-space program.  Thus, whether a specific program continues to live "
"inside the kernel depends on how it is further attached to a given kernel "
"subsystem after it was loaded via B<bpf>()."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:105
msgid ""
"Each eBPF program is a set of instructions that is safe to run until its "
"completion.  An in-kernel verifier statically determines that the eBPF "
"program terminates and is safe to execute.  During verification, the kernel "
"increments reference counts for each of the maps that the eBPF program uses, "
"so that the attached maps can't be removed until the program is unloaded."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:116
msgid ""
"eBPF programs can be attached to different events.  These events can be the "
"arrival of network packets, tracing events, classification events by network "
"queueing disciplines (for eBPF programs attached to a B<tc>(8)  classifier), "
"and other types that may be added in the future.  A new event triggers "
"execution of the eBPF program, which may store information about the event "
"in eBPF maps.  Beyond storing data, eBPF programs may call a fixed set of in-"
"kernel helper functions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:119
msgid ""
"The same eBPF program can be attached to multiple events and different eBPF "
"programs can access the same map:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:131
#, no-wrap
msgid ""
"tracing     tracing    tracing    packet      packet     packet\n"
"event A     event B    event C    on eth0     on eth1    on eth2\n"
" |             |         |          |           |          \\(ha\n"
" |             |         |          |           v          |\n"
" --E<gt> tracing E<lt>--     tracing      socket    tc ingress   tc egress\n"
"      prog_1          prog_2      prog_3    classifier    action\n"
"      |  |              |           |         prog_4      prog_5\n"
"   |---  -----|  |------|          map_3        |           |\n"
" map_1       map_2                              --| map_4 |--\n"
msgstr ""
"tracing     tracing    tracing    packet      packet     packet\n"
"event A     event B    event C    on eth0     on eth1    on eth2\n"
" |             |         |          |           |          \\(ha\n"
" |             |         |          |           v          |\n"
" --E<gt> tracing E<lt>--     tracing      socket    tc ingress   tc egress\n"
"      prog_1          prog_2      prog_3    classifier    action\n"
"      |  |              |           |         prog_4      prog_5\n"
"   |---  -----|  |------|          map_3        |           |\n"
" map_1       map_2                              --| map_4 |--\n"

#. type: SS
#: build/C/man2/bpf.2:134 build/C/man2/select.2:155
#, no-wrap
msgid "Arguments"
msgstr "引数"

#. type: Plain text
#: build/C/man2/bpf.2:150
msgid ""
"The operation to be performed by the B<bpf>()  system call is determined by "
"the I<cmd> argument.  Each operation takes an accompanying argument, "
"provided via I<attr>, which is a pointer to a union of type I<bpf_attr> (see "
"below).  The I<size> argument is the size of the union pointed to by I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:154
msgid "The value provided in I<cmd> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:154 build/C/man2/bpf.2:248 build/C/man2/bpf.2:976
#, no-wrap
msgid "B<BPF_MAP_CREATE>"
msgstr "B<BPF_MAP_CREATE>"

#. type: Plain text
#: build/C/man2/bpf.2:160
msgid ""
"Create a map and return a file descriptor that refers to the map.  The close-"
"on-exec file descriptor flag (see B<fcntl>(2))  is automatically enabled for "
"the new file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:160 build/C/man2/bpf.2:395
#, no-wrap
msgid "B<BPF_MAP_LOOKUP_ELEM>"
msgstr "B<BPF_MAP_LOOKUP_ELEM>"

#. type: Plain text
#: build/C/man2/bpf.2:163
msgid "Look up an element by key in a specified map and return its value."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:163 build/C/man2/bpf.2:431
#, no-wrap
msgid "B<BPF_MAP_UPDATE_ELEM>"
msgstr "B<BPF_MAP_UPDATE_ELEM>"

#. type: Plain text
#: build/C/man2/bpf.2:166
msgid "Create or update an element (key/value pair) in a specified map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:166 build/C/man2/bpf.2:503
#, no-wrap
msgid "B<BPF_MAP_DELETE_ELEM>"
msgstr "B<BPF_MAP_DELETE_ELEM>"

#. type: Plain text
#: build/C/man2/bpf.2:169
msgid "Look up and delete an element by key in a specified map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:169 build/C/man2/bpf.2:533
#, no-wrap
msgid "B<BPF_MAP_GET_NEXT_KEY>"
msgstr "B<BPF_MAP_GET_NEXT_KEY>"

#. type: Plain text
#: build/C/man2/bpf.2:173
msgid ""
"Look up an element by key in a specified map and return the key of the next "
"element."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:173 build/C/man2/bpf.2:979
#, no-wrap
msgid "B<BPF_PROG_LOAD>"
msgstr "B<BPF_PROG_LOAD>"

#. type: Plain text
#: build/C/man2/bpf.2:180
msgid ""
"Verify and load an eBPF program, returning a new file descriptor associated "
"with the program.  The close-on-exec file descriptor flag (see B<fcntl>(2))  "
"is automatically enabled for the new file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:186
msgid ""
"The I<bpf_attr> union consists of various anonymous structures that are used "
"by different B<bpf>()  commands:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:197
#, no-wrap
msgid ""
"union bpf_attr {\n"
"    struct {    /* Used by BPF_MAP_CREATE */\n"
"        __u32         map_type;\n"
"        __u32         key_size;    /* size of key in bytes */\n"
"        __u32         value_size;  /* size of value in bytes */\n"
"        __u32         max_entries; /* maximum number of entries\n"
"                                      in a map */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:208
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY\n"
"                   commands */\n"
"        __u32         map_fd;\n"
"        __aligned_u64 key;\n"
"        union {\n"
"            __aligned_u64 value;\n"
"            __aligned_u64 next_key;\n"
"        };\n"
"        __u64         flags;\n"
"    };\n"
msgstr ""

#.                  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: build/C/man2/bpf.2:224
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_PROG_LOAD */\n"
"        __u32         prog_type;\n"
"        __u32         insn_cnt;\n"
"        __aligned_u64 insns;      /* \\(aqconst struct bpf_insn *\\(aq */\n"
"        __aligned_u64 license;    /* \\(aqconst char *\\(aq */\n"
"        __u32         log_level;  /* verbosity level of verifier */\n"
"        __u32         log_size;   /* size of user buffer */\n"
"        __aligned_u64 log_buf;    /* user supplied \\(aqchar *\\(aq\n"
"                                     buffer */\n"
"        __u32         kern_version;\n"
"                                  /* checked when prog_type=kprobe\n"
"                                     (since Linux 4.1) */\n"
"    };\n"
"} __attribute__((aligned(8)));\n"
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:227
#, no-wrap
msgid "eBPF maps"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:231
msgid ""
"Maps are a generic data structure for storage of different types of data.  "
"They allow sharing of data between eBPF kernel programs, and also between "
"kernel and user-space applications."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:233
msgid "Each map type has the following attributes:"
msgstr ""

#. type: IP
#: build/C/man2/bpf.2:233 build/C/man2/bpf.2:235 build/C/man2/bpf.2:237
#: build/C/man2/bpf.2:239 build/C/man2/bpf.2:600 build/C/man2/bpf.2:604
#: build/C/man2/bpf.2:606 build/C/man2/bpf.2:613 build/C/man2/bpf.2:625
#: build/C/man2/bpf.2:638 build/C/man2/bpf.2:640 build/C/man2/bpf.2:642
#: build/C/man2/bpf.2:647 build/C/man2/bpf.2:666 build/C/man2/bpf.2:670
#: build/C/man2/bpf.2:672 build/C/man2/bpf.2:797 build/C/man2/bpf.2:802
#: build/C/man2/bpf.2:806 build/C/man2/bpf.2:813 build/C/man2/bpf.2:821
#: build/C/man2/bpf.2:830 build/C/man2/bpf.2:1097 build/C/man2/bpf.2:1100
#: build/C/man2/bpf.2:1102 build/C/man2/bpf.2:1104 build/C/man2/bpf.2:1170
#: build/C/man2/bpf.2:1174 build/C/man2/bpf.2:1177 build/C/man2/bpf.2:1180
#: build/C/man2/bpf.2:1183 build/C/man2/bpf.2:1186 build/C/man2/bpf.2:1190
#: build/C/man2/bpf.2:1193 build/C/man2/bpf.2:1196 build/C/man2/bpf.2:1200
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/bpf.2:235
msgid "type"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:237
msgid "maximum number of elements"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:239
msgid "key size in bytes"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:241
msgid "value size in bytes"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:248
msgid ""
"The following wrapper functions demonstrate how various B<bpf>()  commands "
"can be used to access the maps.  The functions use the I<cmd> argument to "
"invoke different operations."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:254
msgid ""
"The B<BPF_MAP_CREATE> command creates a new map, returning a new file "
"descriptor that refers to the map."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:269
#, no-wrap
msgid ""
"int\n"
"bpf_create_map(enum bpf_map_type map_type,\n"
"               unsigned int key_size,\n"
"               unsigned int value_size,\n"
"               unsigned int max_entries)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_type    = map_type,\n"
"        .key_size    = key_size,\n"
"        .value_size  = value_size,\n"
"        .max_entries = max_entries\n"
"    };\n"
msgstr ""
"int\n"
"bpf_create_map(enum bpf_map_type map_type,\n"
"               unsigned int key_size,\n"
"               unsigned int value_size,\n"
"               unsigned int max_entries)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_type    = map_type,\n"
"        .key_size    = key_size,\n"
"        .value_size  = value_size,\n"
"        .max_entries = max_entries\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:272
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:290
msgid ""
"The new map has the type specified by I<map_type>, and attributes as "
"specified in I<key_size>, I<value_size>, and I<max_entries>.  On success, "
"this operation returns a file descriptor.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, or B<ENOMEM>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:307
msgid ""
"The I<key_size> and I<value_size> attributes will be used by the verifier "
"during program loading to check that the program is calling "
"B<bpf_map_*_elem>()  helper functions with a correctly initialized I<key> "
"and to check that the program doesn't access the map element I<value> beyond "
"the specified I<value_size>.  For example, when a map is created with a "
"I<key_size> of 8 and the eBPF program calls"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:311
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, fp - 4)\n"
msgstr "bpf_map_lookup_elem(map_fd, fp - 4)\n"

#. type: Plain text
#: build/C/man2/bpf.2:316
msgid "the program will be rejected, since the in-kernel helper function"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:320
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, void *key)\n"
msgstr "bpf_map_lookup_elem(map_fd, void *key)\n"

#. type: Plain text
#: build/C/man2/bpf.2:331
msgid ""
"expects to read 8 bytes from the location pointed to by I<key>, but the I<fp"
"\\ -\\ 4> (where I<fp> is the top of the stack)  starting address will cause "
"out-of-bounds stack access."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:335
msgid ""
"Similarly, when a map is created with a I<value_size> of 1 and the eBPF "
"program contains"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:340
#, no-wrap
msgid ""
"value = bpf_map_lookup_elem(...);\n"
"*(u32 *) value = 1;\n"
msgstr ""
"value = bpf_map_lookup_elem(...);\n"
"*(u32 *) value = 1;\n"

#. type: Plain text
#: build/C/man2/bpf.2:348
msgid ""
"the program will be rejected, since it accesses the I<value> pointer beyond "
"the specified 1 byte I<value_size> limit."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:351
msgid "Currently, the following values are supported for I<map_type>:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:381
#, no-wrap
msgid ""
"enum bpf_map_type {\n"
"    BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */\n"
"    BPF_MAP_TYPE_HASH,\n"
"    BPF_MAP_TYPE_ARRAY,\n"
"    BPF_MAP_TYPE_PROG_ARRAY,\n"
"    BPF_MAP_TYPE_PERF_EVENT_ARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_PERCPU_ARRAY,\n"
"    BPF_MAP_TYPE_STACK_TRACE,\n"
"    BPF_MAP_TYPE_CGROUP_ARRAY,\n"
"    BPF_MAP_TYPE_LRU_HASH,\n"
"    BPF_MAP_TYPE_LRU_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_LPM_TRIE,\n"
"    BPF_MAP_TYPE_ARRAY_OF_MAPS,\n"
"    BPF_MAP_TYPE_HASH_OF_MAPS,\n"
"    BPF_MAP_TYPE_DEVMAP,\n"
"    BPF_MAP_TYPE_SOCKMAP,\n"
"    BPF_MAP_TYPE_CPUMAP,\n"
"    BPF_MAP_TYPE_XSKMAP,\n"
"    BPF_MAP_TYPE_SOCKHASH,\n"
"    BPF_MAP_TYPE_CGROUP_STORAGE,\n"
"    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,\n"
"    BPF_MAP_TYPE_QUEUE,\n"
"    BPF_MAP_TYPE_STACK,\n"
"    /* See /usr/include/linux/bpf.h for the full list. */\n"
"};\n"
msgstr ""

#.  FIXME We need an explanation of why one might choose each of
#.  these map implementations
#. type: Plain text
#: build/C/man2/bpf.2:395
msgid ""
"I<map_type> selects one of the available map implementations in the kernel.  "
"For all map types, eBPF programs access maps with the same "
"B<bpf_map_lookup_elem>()  and B<bpf_map_update_elem>()  helper functions.  "
"Further details of the various map types are given below."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:403
msgid ""
"The B<BPF_MAP_LOOKUP_ELEM> command looks up an element with a given I<key> "
"in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:414
#, no-wrap
msgid ""
"int\n"
"bpf_lookup_elem(int fd, const void *key, void *value)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"    };\n"
msgstr ""
"int\n"
"bpf_lookup_elem(int fd, const void *key, void *value)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:417
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:426
msgid ""
"If an element is found, the operation returns zero and stores the element's "
"value into I<value>, which must point to a buffer of I<value_size> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:431
msgid ""
"If no element is found, the operation returns -1 and sets I<errno> to "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:440
msgid ""
"The B<BPF_MAP_UPDATE_ELEM> command creates or updates an element with a "
"given I<key/value> in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:453
#, no-wrap
msgid ""
"int\n"
"bpf_update_elem(int fd, const void *key, const void *value,\n"
"                uint64_t flags)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"        .flags  = flags,\n"
"    };\n"
msgstr ""
"int\n"
"bpf_update_elem(int fd, const void *key, const void *value,\n"
"                uint64_t flags)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"        .flags  = flags,\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:456
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:462
msgid "The I<flags> argument should be specified as one of the following:"
msgstr "I<flags> 引数には、以下のいずれかを指定する。"

#. type: TP
#: build/C/man2/bpf.2:463 build/C/man7/bpf-helpers.7:144
#: build/C/man7/bpf-helpers.7:1480 build/C/man7/bpf-helpers.7:2029
#, no-wrap
msgid "B<BPF_ANY>"
msgstr "B<BPF_ANY>"

#. type: Plain text
#: build/C/man2/bpf.2:466
msgid "Create a new element or update an existing element."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:466 build/C/man7/bpf-helpers.7:138
#: build/C/man7/bpf-helpers.7:1474 build/C/man7/bpf-helpers.7:2023
#, no-wrap
msgid "B<BPF_NOEXIST>"
msgstr "B<BPF_NOEXIST>"

#. type: Plain text
#: build/C/man2/bpf.2:469
msgid "Create a new element only if it did not exist."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:469 build/C/man7/bpf-helpers.7:141
#: build/C/man7/bpf-helpers.7:1477 build/C/man7/bpf-helpers.7:2026
#: build/C/man7/bpf-helpers.7:2444
#, no-wrap
msgid "B<BPF_EXIST>"
msgstr "B<BPF_EXIST>"

#. type: Plain text
#: build/C/man2/bpf.2:472
msgid "Update an existing element."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:503
msgid ""
"On success, the operation returns zero.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, B<ENOMEM>, or B<E2BIG>.  B<E2BIG> "
"indicates that the number of elements in the map reached the I<max_entries> "
"limit specified at map creation time.  B<EEXIST> will be returned if "
"I<flags> specifies B<BPF_NOEXIST> and the element with I<key> already exists "
"in the map.  B<ENOENT> will be returned if I<flags> specifies B<BPF_EXIST> "
"and the element with I<key> doesn't exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:512
msgid ""
"The B<BPF_MAP_DELETE_ELEM> command deletes the element whose key is I<key> "
"from the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:522
#, no-wrap
msgid ""
"int\n"
"bpf_delete_elem(int fd, const void *key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"    };\n"
msgstr ""
"int\n"
"bpf_delete_elem(int fd, const void *key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:525
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:533
#, fuzzy
#| msgid ""
#| "On success, zero is returned.  On error, -1 is returned, and I<errno> is "
#| "set appropriately."
msgid ""
"On success, zero is returned.  If the element is not found, -1 is returned "
"and I<errno> is set to B<ENOENT>."
msgstr ""
"成功した場合にはゼロが返される。エラー時には -1 が返され、 I<errno> が適切に"
"設定される。"

#. type: Plain text
#: build/C/man2/bpf.2:544
msgid ""
"The B<BPF_MAP_GET_NEXT_KEY> command looks up an element by I<key> in the map "
"referred to by the file descriptor I<fd> and sets the I<next_key> pointer to "
"the key of the next element."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:555
#, no-wrap
msgid ""
"int\n"
"bpf_get_next_key(int fd, const void *key, void *next_key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd   = fd,\n"
"        .key      = ptr_to_u64(key),\n"
"        .next_key = ptr_to_u64(next_key),\n"
"    };\n"
msgstr ""
"int\n"
"bpf_get_next_key(int fd, const void *key, void *next_key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd   = fd,\n"
"        .key      = ptr_to_u64(key),\n"
"        .next_key = ptr_to_u64(next_key),\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:558
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:586
msgid ""
"If I<key> is found, the operation returns zero and sets the I<next_key> "
"pointer to the key of the next element.  If I<key> is not found, the "
"operation returns zero and sets the I<next_key> pointer to the key of the "
"first element.  If I<key> is the last element, -1 is returned and I<errno> "
"is set to B<ENOENT>.  Other possible I<errno> values are B<ENOMEM>, "
"B<EFAULT>, B<EPERM>, and B<EINVAL>.  This method can be used to iterate over "
"all elements in the map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:586
#, no-wrap
msgid "B<close(map_fd)>"
msgstr "B<close(map_fd)>"

#. type: Plain text
#: build/C/man2/bpf.2:593
msgid ""
"Delete the map referred to by the file descriptor I<map_fd>.  When the user-"
"space program that created a map exits, all maps will be deleted "
"automatically (but see NOTES)."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:593
#, no-wrap
msgid "eBPF map types"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:595
msgid "The following map types are supported:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:595
#, no-wrap
msgid "B<BPF_MAP_TYPE_HASH>"
msgstr "B<BPF_MAP_TYPE_HASH>"

#.  commit 0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475
#. type: Plain text
#: build/C/man2/bpf.2:599
msgid "Hash-table maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:604
msgid ""
"Maps are created and destroyed by user-space programs.  Both user-space and "
"eBPF programs can perform lookup, update, and delete operations."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:606
msgid "The kernel takes care of allocating and freeing key/value pairs."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:613
msgid ""
"The B<map_update_elem>()  helper will fail to insert new element when the "
"I<max_entries> limit is reached.  (This ensures that eBPF programs cannot "
"exhaust memory.)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:616
msgid "B<map_update_elem>()  replaces existing elements atomically."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:620
msgid "Hash-table maps are optimized for speed of lookup."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:620
#, no-wrap
msgid "B<BPF_MAP_TYPE_ARRAY>"
msgstr "B<BPF_MAP_TYPE_ARRAY>"

#.  commit 28fbcfa08d8ed7c5a50d41a0433aad222835e8e3
#. type: Plain text
#: build/C/man2/bpf.2:624
msgid "Array maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:638
msgid ""
"Optimized for fastest possible lookup.  In the future the verifier/JIT "
"compiler may recognize lookup() operations that employ a constant key and "
"optimize it into constant pointer.  It is possible to optimize a non-"
"constant key into direct pointer arithmetic as well, since pointers and "
"I<value_size> are constant for the life of the eBPF program.  In other "
"words, B<array_map_lookup_elem>()  may be 'inlined' by the verifier/JIT "
"compiler while preserving concurrent access to this map from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:640
msgid "All array elements pre-allocated and zero initialized at init time"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:642
msgid "The key is an array index, and must be exactly four bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:647
msgid ""
"B<map_delete_elem>()  fails with the error B<EINVAL>, since elements cannot "
"be deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:662
msgid ""
"B<map_update_elem>()  replaces elements in a B<nonatomic> fashion; for "
"atomic updates, a hash-table map should be used instead.  There is however "
"one special case that can also be used with arrays: the atomic built-in "
"B<__sync_fetch_and_add()> can be used on 32 and 64 bit atomic counters.  For "
"example, it can be applied on the whole value itself if it represents a "
"single counter, or in case of a structure containing multiple counters, it "
"could be used on individual counters.  This is quite often useful for "
"aggregation and accounting of events."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:665
msgid "Among the uses for array maps are the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:670
msgid ""
"As \"global\" eBPF variables: an array of 1 element whose key is (index) 0 "
"and where the value is a collection of 'global' variables which eBPF "
"programs can use to keep state between events."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:672
msgid "Aggregation of tracing events into a fixed set of buckets."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:675
msgid ""
"Accounting of networking events, for example, number of packets and packet "
"sizes."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:676
#, no-wrap
msgid "B<BPF_MAP_TYPE_PROG_ARRAY> (since Linux 4.2)"
msgstr "B<BPF_MAP_TYPE_PROG_ARRAY> (Linux 4.2 以降)"

#. type: Plain text
#: build/C/man2/bpf.2:688
msgid ""
"A program array map is a special kind of array map whose map values contain "
"only file descriptors referring to other eBPF programs.  Thus, both the "
"I<key_size> and I<value_size> must be exactly four bytes.  This map is used "
"in conjunction with the B<bpf_tail_call>()  helper."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:691
msgid ""
"This means that an eBPF program with a program array map attached to it can "
"call from kernel side into"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:696
#, no-wrap
msgid ""
"void bpf_tail_call(void *context, void *prog_map,\n"
"                   unsigned int index);\n"
msgstr ""
"void bpf_tail_call(void *context, void *prog_map,\n"
"                   unsigned int index);\n"

#. type: Plain text
#: build/C/man2/bpf.2:705
msgid ""
"and therefore replace its own program flow with the one from the program at "
"the given program array slot, if present.  This can be regarded as kind of a "
"jump table to a different eBPF program.  The invoked program will then reuse "
"the same stack.  When a jump into the new program has been performed, it "
"won't return to the old program anymore."
msgstr ""

#.  MAX_TAIL_CALL_CNT
#. type: Plain text
#: build/C/man2/bpf.2:714
msgid ""
"If no eBPF program is found at the given index of the program array (because "
"the map slot doesn't contain a valid program file descriptor, the specified "
"lookup index/key is out of bounds, or the limit of 32 nested calls has been "
"exceed), execution continues with the current eBPF program.  This can be "
"used as a fall-through for default cases."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:726
msgid ""
"A program array map is useful, for example, in tracing or networking, to "
"handle individual system calls or protocols in their own subprograms and use "
"their identifiers as an individual map index.  This approach may result in "
"performance benefits, and also makes it possible to overcome the maximum "
"instruction limit of a single eBPF program.  In dynamic environments, a user-"
"space daemon might atomically replace individual subprograms at run-time "
"with newer versions to alter overall program behavior, for instance, if "
"global policies change."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:726
#, no-wrap
msgid "eBPF programs"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:732
msgid ""
"The B<BPF_PROG_LOAD> command is used to load an eBPF program into the "
"kernel.  The return value for this command is a new file descriptor "
"associated with this eBPF program."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:736
#, no-wrap
msgid "char bpf_log_buf[LOG_BUF_SIZE];\n"
msgstr "char bpf_log_buf[LOG_BUF_SIZE];\n"

#. type: Plain text
#: build/C/man2/bpf.2:751
#, no-wrap
msgid ""
"int\n"
"bpf_prog_load(enum bpf_prog_type type,\n"
"              const struct bpf_insn *insns, int insn_cnt,\n"
"              const char *license)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .prog_type = type,\n"
"        .insns     = ptr_to_u64(insns),\n"
"        .insn_cnt  = insn_cnt,\n"
"        .license   = ptr_to_u64(license),\n"
"        .log_buf   = ptr_to_u64(bpf_log_buf),\n"
"        .log_size  = LOG_BUF_SIZE,\n"
"        .log_level = 1,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:754
#, no-wrap
msgid ""
"    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));\n"
"}\n"
msgstr ""
"    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:759
msgid "I<prog_type> is one of the available program types:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:789
#, no-wrap
msgid ""
"enum bpf_prog_type {\n"
"    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid\n"
"                                    program type */\n"
"    BPF_PROG_TYPE_SOCKET_FILTER,\n"
"    BPF_PROG_TYPE_KPROBE,\n"
"    BPF_PROG_TYPE_SCHED_CLS,\n"
"    BPF_PROG_TYPE_SCHED_ACT,\n"
"    BPF_PROG_TYPE_TRACEPOINT,\n"
"    BPF_PROG_TYPE_XDP,\n"
"    BPF_PROG_TYPE_PERF_EVENT,\n"
"    BPF_PROG_TYPE_CGROUP_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK,\n"
"    BPF_PROG_TYPE_LWT_IN,\n"
"    BPF_PROG_TYPE_LWT_OUT,\n"
"    BPF_PROG_TYPE_LWT_XMIT,\n"
"    BPF_PROG_TYPE_SOCK_OPS,\n"
"    BPF_PROG_TYPE_SK_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_DEVICE,\n"
"    BPF_PROG_TYPE_SK_MSG,\n"
"    BPF_PROG_TYPE_RAW_TRACEPOINT,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n"
"    BPF_PROG_TYPE_LWT_SEG6LOCAL,\n"
"    BPF_PROG_TYPE_LIRC_MODE2,\n"
"    BPF_PROG_TYPE_SK_REUSEPORT,\n"
"    BPF_PROG_TYPE_FLOW_DISSECTOR,\n"
"    /* See /usr/include/linux/bpf.h for the full list. */\n"
"};\n"
msgstr ""
"enum bpf_prog_type {\n"
"    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid\n"
"                                    program type */\n"
"    BPF_PROG_TYPE_SOCKET_FILTER,\n"
"    BPF_PROG_TYPE_KPROBE,\n"
"    BPF_PROG_TYPE_SCHED_CLS,\n"
"    BPF_PROG_TYPE_SCHED_ACT,\n"
"    BPF_PROG_TYPE_TRACEPOINT,\n"
"    BPF_PROG_TYPE_XDP,\n"
"    BPF_PROG_TYPE_PERF_EVENT,\n"
"    BPF_PROG_TYPE_CGROUP_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK,\n"
"    BPF_PROG_TYPE_LWT_IN,\n"
"    BPF_PROG_TYPE_LWT_OUT,\n"
"    BPF_PROG_TYPE_LWT_XMIT,\n"
"    BPF_PROG_TYPE_SOCK_OPS,\n"
"    BPF_PROG_TYPE_SK_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_DEVICE,\n"
"    BPF_PROG_TYPE_SK_MSG,\n"
"    BPF_PROG_TYPE_RAW_TRACEPOINT,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n"
"    BPF_PROG_TYPE_LWT_SEG6LOCAL,\n"
"    BPF_PROG_TYPE_LIRC_MODE2,\n"
"    BPF_PROG_TYPE_SK_REUSEPORT,\n"
"    BPF_PROG_TYPE_FLOW_DISSECTOR,\n"
"    /* See /usr/include/linux/bpf.h for the full list. */\n"
"};\n"

#. type: Plain text
#: build/C/man2/bpf.2:793
msgid "For further details of eBPF program types, see below."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:797
msgid "The remaining fields of I<bpf_attr> are set as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:802
msgid "I<insns> is an array of I<struct bpf_insn> instructions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:806
msgid ""
"I<insn_cnt> is the number of instructions in the program referred to by "
"I<insns>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:813
msgid ""
"I<license> is a license string, which must be GPL compatible to call helper "
"functions marked I<gpl_only>.  (The licensing rules are the same as for "
"kernel modules, so that also dual licenses, such as \"Dual BSD/GPL\", may be "
"used.)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:821
msgid ""
"I<log_buf> is a pointer to a caller-allocated buffer in which the in-kernel "
"verifier can store the verification log.  This log is a multi-line string "
"that can be checked by the program author in order to understand how the "
"verifier came to the conclusion that the eBPF program is unsafe.  The format "
"of the output can change at any time as the verifier evolves."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:830
msgid ""
"I<log_size> size of the buffer pointed to by I<log_buf>.  If the size of the "
"buffer is not large enough to store all verifier messages, -1 is returned "
"and I<errno> is set to B<ENOSPC>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:839
msgid ""
"I<log_level> verbosity level of the verifier.  A value of zero means that "
"the verifier will not provide a log; in this case, I<log_buf> must be a NULL "
"pointer, and I<log_size> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:845
msgid ""
"Applying B<close>(2)  to the file descriptor returned by B<BPF_PROG_LOAD> "
"will unload the eBPF program (but see NOTES)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:857
msgid ""
"Maps are accessible from eBPF programs and are used to exchange data between "
"eBPF programs and between eBPF programs and user-space programs.  For "
"example, eBPF programs can process various events (like kprobe, packets) and "
"store their data into a map, and user-space programs can then fetch data "
"from the map.  Conversely, user-space programs can use a map as a "
"configuration mechanism, populating the map with values checked by the eBPF "
"program, which then modifies its behavior on the fly according to those "
"values."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:857
#, no-wrap
msgid "eBPF program types"
msgstr ""

#
#.  FIXME
#.  Somewhere in this page we need a general introduction to the
#.  bpf_context. For example, how does a BPF program access the
#.  context?
#. type: Plain text
#: build/C/man2/bpf.2:871
msgid ""
"The eBPF program type (I<prog_type>)  determines the subset of kernel helper "
"functions that the program may call.  The program type also determines the "
"program input (context)\\(emthe format of I<struct bpf_context> (which is "
"the data blob passed into the eBPF program as the first argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:878
msgid ""
"For example, a tracing program does not have the exact same subset of helper "
"functions as a socket filter program (though they may have some helpers in "
"common).  Similarly, the input (context) for a tracing program is a set of "
"register values, while for a socket filter it is a network packet."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:881
msgid ""
"The set of functions available to eBPF programs of a given type may increase "
"in the future."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:883
msgid "The following program types are supported:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:883
#, no-wrap
msgid "B<BPF_PROG_TYPE_SOCKET_FILTER> (since Linux 3.19)"
msgstr "B<BPF_PROG_TYPE_SOCKET_FILTER> (Linux 3.19 以降)"

#. type: Plain text
#: build/C/man2/bpf.2:888
msgid "Currently, the set of functions for B<BPF_PROG_TYPE_SOCKET_FILTER> is:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:897
#, no-wrap
msgid ""
"bpf_map_lookup_elem(map_fd, void *key)\n"
"                    /* look up key in a map_fd */\n"
"bpf_map_update_elem(map_fd, void *key, void *value)\n"
"                    /* update key/value */\n"
"bpf_map_delete_elem(map_fd, void *key)\n"
"                    /* delete key in a map_fd */\n"
msgstr ""

#
#.  FIXME: We need some text here to explain how the program
#.  accesses __sk_buff.
#.  See 'struct __sk_buff' and commit 9bac3d6d548e5
#.  Alexei commented:
#.  Actually now in case of SOCKET_FILTER, SCHED_CLS, SCHED_ACT
#.  the program can now access skb fields.
#. type: Plain text
#: build/C/man2/bpf.2:912
msgid "The I<bpf_context> argument is a pointer to a I<struct __sk_buff>."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:912
#, no-wrap
msgid "B<BPF_PROG_TYPE_KPROBE> (since Linux 4.1)"
msgstr "B<BPF_PROG_TYPE_KPROBE> (Linux 4.1 以降)"

#.  commit 94caee8c312d96522bcdae88791aaa9ebcd5f22c
#.  commit a8cb5f556b567974d75ea29c15181c445c541b1f
#.  FIXME Document this program type
#. 	  Describe allowed helper functions for this program type
#. 	  Describe bpf_context for this program type
#. type: Plain text
#: build/C/man2/bpf.2:921 build/C/man2/bpf.2:929 build/C/man2/bpf.2:937
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:921
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_CLS> (since Linux 4.1)"
msgstr "B<BPF_PROG_TYPE_SCHED_CLS> (Linux 4.1 以降)"

#. type: TP
#: build/C/man2/bpf.2:929
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_ACT> (since Linux 4.1)"
msgstr "B<BPF_PROG_TYPE_SCHED_ACT> (Linux 4.1 以降)"

#. type: SS
#: build/C/man2/bpf.2:937
#, no-wrap
msgid "Events"
msgstr "イベント"

#. type: Plain text
#: build/C/man2/bpf.2:940
msgid ""
"Once a program is loaded, it can be attached to an event.  Various kernel "
"subsystems have different ways to do so."
msgstr ""

#.  commit 89aa075832b0da4402acebd698d0411dcc82d03e
#. type: Plain text
#: build/C/man2/bpf.2:949
msgid ""
"Since Linux 3.19, the following call will attach the program I<prog_fd> to "
"the socket I<sockfd>, which was created by an earlier call to B<socket>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:954
#, no-wrap
msgid ""
"setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,\n"
"           &prog_fd, sizeof(prog_fd));\n"
msgstr ""
"setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,\n"
"           &prog_fd, sizeof(prog_fd));\n"

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: build/C/man2/bpf.2:966
msgid ""
"Since Linux 4.1, the following call may be used to attach the eBPF program "
"referred to by the file descriptor I<prog_fd> to a perf event file "
"descriptor, I<event_fd>, that was created by a previous call to "
"B<perf_event_open>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:970
#, no-wrap
msgid "ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n"
msgstr "ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n"

#. type: Plain text
#: build/C/man2/bpf.2:976
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:979
#, fuzzy
#| msgid "The file descriptor is not associated with a socket."
msgid "The new file descriptor associated with the eBPF map."
msgstr "ファイルディスクリプターがソケットと関連付けられていない。"

#. type: Plain text
#: build/C/man2/bpf.2:982
#, fuzzy
#| msgid "The file descriptor is not associated with a socket."
msgid "The new file descriptor associated with the eBPF program."
msgstr "ファイルディスクリプターがソケットと関連付けられていない。"

#. type: TP
#: build/C/man2/bpf.2:982
#, no-wrap
msgid "All other commands"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:985
msgid "Zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:989
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合、 -1 が返り、 I<errno> が適切に設定される。"

#. type: TP
#: build/C/man2/bpf.2:990
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/bpf.2:995
msgid ""
"The eBPF program is too large or a map reached the I<max_entries> limit "
"(maximum number of elements)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1012
msgid ""
"For B<BPF_PROG_LOAD>, even though all program instructions are valid, the "
"program has been rejected because it was deemed unsafe.  This may be because "
"it may have accessed a disallowed memory region or an uninitialized stack/"
"register or because the function constraints don't match the actual types or "
"because there was a misaligned memory access.  In this case, it is "
"recommended to call B<bpf>()  again with I<log_level = 1> and examine "
"I<log_buf> for the specific reason provided by the verifier."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1016
msgid "I<fd> is not an open file descriptor."
msgstr "I<sockfd> がオープンされたファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/bpf.2:1027
msgid ""
"One of the pointers (I<key> or I<value> or I<log_buf> or I<insns>)  is "
"outside the accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1032
#, fuzzy
#| msgid "The specified protocol is not supported on this machine."
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr "このマシンでは指定されたプロトコルがサポートされていない。"

#. type: Plain text
#: build/C/man2/bpf.2:1039
msgid "For B<BPF_MAP_CREATE>, either I<map_type> or attributes are invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1048
msgid ""
"For B<BPF_MAP_*_ELEM> commands, some of the fields of I<union bpf_attr> that "
"are not used by this command are not set to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1056
msgid ""
"For B<BPF_PROG_LOAD>, indicates an attempt to load an invalid program.  eBPF "
"programs can be deemed invalid due to unrecognized instructions, the use of "
"reserved fields, jumps out of range, infinite loops or calls of unknown "
"functions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1065
msgid ""
"For B<BPF_MAP_LOOKUP_ELEM> or B<BPF_MAP_DELETE_ELEM>, indicates that the "
"element with the given I<key> was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1068
msgid "Cannot allocate sufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1074
msgid ""
"The call was made without sufficient privilege (without the B<CAP_SYS_ADMIN> "
"capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1078
msgid "The B<bpf>()  system call first appeared in Linux 3.18."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1082
msgid "The B<bpf>()  system call is Linux-specific."
msgstr "B<bpf>() システムコールは Linux 固有である。"

#.  commit 1be7f75d1668d6296b80bf35dcf6762393530afc
#.  [Linux 5.6] mtk: The list of available functions is, I think, governed
#.  by the check in net/core/filter.c::bpf_base_func_proto().
#. type: Plain text
#: build/C/man2/bpf.2:1097
msgid ""
"Prior to Linux 4.4, all B<bpf>()  commands require the caller to have the "
"B<CAP_SYS_ADMIN> capability.  From Linux 4.4 onwards, an unprivileged user "
"may create limited programs of type B<BPF_PROG_TYPE_SOCKET_FILTER> and "
"associated maps.  However they may not store kernel pointers within the maps "
"and are presently limited to the following helper functions:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1099
msgid "get_random"
msgstr "get_random"

#. type: Plain text
#: build/C/man2/bpf.2:1102
msgid "get_smp_processor_id"
msgstr "get_smp_processor_id"

#. type: Plain text
#: build/C/man2/bpf.2:1104
msgid "tail_call"
msgstr "tail_call"

#. type: Plain text
#: build/C/man2/bpf.2:1106
msgid "ktime_get_ns"
msgstr "ktime_get_ns"

#. type: Plain text
#: build/C/man2/bpf.2:1110
msgid ""
"Unprivileged access may be blocked by writing the value 1 to the file I</"
"proc/sys/kernel/unprivileged_bpf_disabled>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1123
msgid ""
"eBPF objects (maps and programs) can be shared between processes.  For "
"example, after B<fork>(2), the child inherits file descriptors referring to "
"the same eBPF objects.  In addition, file descriptors referring to eBPF "
"objects can be transferred over UNIX domain sockets.  File descriptors "
"referring to eBPF objects can be duplicated in the usual way, using "
"B<dup>(2)  and similar calls.  An eBPF object is deallocated only after all "
"file descriptors referring to the object have been closed."
msgstr ""

#.  There are also examples for the tc classifier, in the iproute2
#.  project, in examples/bpf
#. type: Plain text
#: build/C/man2/bpf.2:1135
msgid ""
"eBPF programs can be written in a restricted C that is compiled (using the "
"B<clang> compiler) into eBPF bytecode.  Various features are omitted from "
"this restricted C, such as loops, global variables, variadic functions, "
"floating-point numbers, and passing structures as function arguments.  Some "
"examples can be found in the I<samples/bpf/*_kern.c> files in the kernel "
"source tree."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1143
msgid ""
"The kernel contains a just-in-time (JIT) compiler that translates eBPF "
"bytecode into native machine code for better performance.  In kernels before "
"Linux 4.15, the JIT compiler is disabled by default, but its operation can "
"be controlled by writing one of the following integer strings to the file I</"
"proc/sys/net/core/bpf_jit_enable>:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1143 build/C/man7/bpf-helpers.7:1325
#: build/C/man7/bpf-helpers.7:1661 build/C/man7/bpf-helpers.7:1781
#: build/C/man7/bpf-helpers.7:1803 build/C/man7/bpf-helpers.7:2221
#: build/C/man7/bpf-helpers.7:2251 build/C/man7/bpf-helpers.7:2526
#: build/C/man7/bpf-helpers.7:2595 build/C/man7/bpf-helpers.7:2606
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man2/bpf.2:1145
msgid "Disable JIT compilation (default)."
msgstr ""

#. type: IP
#: build/C/man2/bpf.2:1145
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man2/bpf.2:1147
#, fuzzy
#| msgid "Local communication"
msgid "Normal compilation."
msgstr "ローカル通信"

#. type: IP
#: build/C/man2/bpf.2:1147
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man2/bpf.2:1153
msgid ""
"Debugging mode.  The generated opcodes are dumped in hexadecimal into the "
"kernel log.  These opcodes can then be disassembled using the program "
"I<tools/net/bpf_jit_disasm.c> provided in the kernel source tree."
msgstr ""

#.  commit 290af86629b25ffd1ed6232c4e9107da031705cb
#. type: Plain text
#: build/C/man2/bpf.2:1164
msgid ""
"Since Linux 4.15, the kernel may configured with the "
"B<CONFIG_BPF_JIT_ALWAYS_ON> option.  In this case, the JIT compiler is "
"always enabled, and the I<bpf_jit_enable> is initialized to 1 and is "
"immutable.  (This kernel configuration option was provided as a mitigation "
"for one of the Spectre attacks against the BPF interpreter.)"
msgstr ""

#.  Last reviewed in Linux 4.18-rc by grepping for BPF_ALU64 in arch/
#.  and by checking the documentation for bpf_jit_enable in
#.  Documentation/sysctl/net.txt
#. type: Plain text
#: build/C/man2/bpf.2:1170
msgid ""
"The JIT compiler for eBPF is currently available for the following "
"architectures:"
msgstr ""

#.  commit 0a14842f5a3c0e88a1e59fac5c3025db39721f74
#. type: Plain text
#: build/C/man2/bpf.2:1173
msgid "x86-64 (since Linux 3.18; cBPF since Linux 3.0);"
msgstr ""

#.  commit ddecdfcea0ae891f782ae853771c867ab51024c2
#. type: Plain text
#: build/C/man2/bpf.2:1177
msgid "ARM32 (since Linux 3.18; cBPF since Linux 3.4);"
msgstr ""

#.  commit 2809a2087cc44b55e4377d7b9be3f7f5d2569091
#. type: Plain text
#: build/C/man2/bpf.2:1180
msgid "SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);"
msgstr ""

#.  commit e54bcde3d69d40023ae77727213d14f920eb264a
#. type: Plain text
#: build/C/man2/bpf.2:1183
msgid "ARM-64 (since Linux 3.18);"
msgstr "ARM-64 (Linux 3.18 以降);"

#.  commit c10302efe569bfd646b4c22df29577a4595b4580
#. type: Plain text
#: build/C/man2/bpf.2:1186
msgid "s390 (since Linux 4.1; cBPF since Linux 3.7);"
msgstr ""

#.  commit 0ca87f05ba8bdc6791c14878464efc901ad71e99
#.  commit 156d0e290e969caba25f1851c52417c14d141b24
#. type: Plain text
#: build/C/man2/bpf.2:1190
msgid "PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);"
msgstr ""

#.  commit 7a12b5031c6b947cc13918237ae652b536243b76
#. type: Plain text
#: build/C/man2/bpf.2:1193
msgid "SPARC 64 (since Linux 4.12);"
msgstr "SPARC 64 (Linux 4.12 以降);"

#.  commit 03f5781be2c7b7e728d724ac70ba10799cc710d7
#. type: Plain text
#: build/C/man2/bpf.2:1196
msgid "x86-32 (since Linux 4.18);"
msgstr "x86-32 (Linux 4.18 以降);"

#.  commit c6610de353da5ca6eee5b8960e838a87a90ead0c
#.  commit f381bf6d82f032b7410185b35d000ea370ac706b
#. type: Plain text
#: build/C/man2/bpf.2:1200
msgid "MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);"
msgstr ""

#.  commit 2353ecc6f91fd15b893fa01bf85a1c7a823ee4f2
#. type: Plain text
#: build/C/man2/bpf.2:1203
msgid "riscv (since Linux 5.1)."
msgstr "riscv (Linux 5.1 以降)."

#. type: Plain text
#: build/C/man2/bpf.2:1219
#, no-wrap
msgid ""
"/* bpf+sockets example:\n"
" * 1. create array map of 256 elements\n"
" * 2. load program that counts number of packets received\n"
" *    r0 = skb-E<gt>data[ETH_HLEN + offsetof(struct iphdr, protocol)]\n"
" *    map[r0]++\n"
" * 3. attach prog_fd to raw socket via setsockopt()\n"
" * 4. print number of received TCP/UDP packets every second\n"
" */\n"
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int sock, map_fd, prog_fd, key;\n"
"    long long value = 0, tcp_cnt, udp_cnt;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1227
#, no-wrap
msgid ""
"    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),\n"
"                            sizeof(value), 256);\n"
"    if (map_fd E<lt> 0) {\n"
"        printf(\"failed to create map \\(aq%s\\(aq\\en\", strerror(errno));\n"
"        /* likely not run as root */\n"
"        return 1;\n"
"    }\n"
msgstr ""
"    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),\n"
"                            sizeof(value), 256);\n"
"    if (map_fd E<lt> 0) {\n"
"        printf(\"failed to create map \\(aq%s\\(aq\\en\", strerror(errno));\n"
"        /* likely not run as root */\n"
"        return 1;\n"
"    }\n"

#.                                 == atomic64_add
#. type: Plain text
#: build/C/man2/bpf.2:1248
#, no-wrap
msgid ""
"    struct bpf_insn prog[] = {\n"
"        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */\n"
"        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),\n"
"                                /* r0 = ip-E<gt>proto */\n"
"        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n"
"                                /* *(u32 *)(fp - 4) = r0 */\n"
"        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */\n"
"        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */\n"
"        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */\n"
"        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),\n"
"                                /* r0 = map_lookup(r1, r2) */\n"
"        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n"
"                                /* if (r0 == 0) goto pc+2 */\n"
"        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */\n"
"        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),\n"
"                                /* lock *(u64 *) r0 += r1 */\n"
"        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */\n"
"        BPF_EXIT_INSN(),                            /* return r0 */\n"
"    };\n"
msgstr ""
"    struct bpf_insn prog[] = {\n"
"        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */\n"
"        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),\n"
"                                /* r0 = ip-E<gt>proto */\n"
"        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n"
"                                /* *(u32 *)(fp - 4) = r0 */\n"
"        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */\n"
"        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */\n"
"        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */\n"
"        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),\n"
"                                /* r0 = map_lookup(r1, r2) */\n"
"        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n"
"                                /* if (r0 == 0) goto pc+2 */\n"
"        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */\n"
"        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),\n"
"                                /* lock *(u64 *) r0 += r1 */\n"
"        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */\n"
"        BPF_EXIT_INSN(),                            /* return r0 */\n"
"    };\n"

#. type: Plain text
#: build/C/man2/bpf.2:1251
#, no-wrap
msgid ""
"    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,\n"
"                            sizeof(prog) / sizeof(prog[0]), \"GPL\");\n"
msgstr ""
"    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,\n"
"                            sizeof(prog) / sizeof(prog[0]), \"GPL\");\n"

#. type: Plain text
#: build/C/man2/bpf.2:1253
#, no-wrap
msgid "    sock = open_raw_sock(\"lo\");\n"
msgstr "    sock = open_raw_sock(\"lo\");\n"

#. type: Plain text
#: build/C/man2/bpf.2:1256
#, no-wrap
msgid ""
"    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,\n"
"                      sizeof(prog_fd)) == 0);\n"
msgstr ""
"    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,\n"
"                      sizeof(prog_fd)) == 0);\n"

#. type: Plain text
#: build/C/man2/bpf.2:1265
#, no-wrap
msgid ""
"    for (;;) {\n"
"        key = IPPROTO_TCP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);\n"
"        key = IPPROTO_UDP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);\n"
"        printf(\"TCP %lld UDP %lld packets\\en\", tcp_cnt, udp_cnt);\n"
"        sleep(1);\n"
"    }\n"
msgstr ""
"    for (;;) {\n"
"        key = IPPROTO_TCP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);\n"
"        key = IPPROTO_UDP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);\n"
"        printf(\"TCP %lld UDP %lld packets\\en\", tcp_cnt, udp_cnt);\n"
"        sleep(1);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/bpf.2:1268
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man2/bpf.2:1273
msgid ""
"Some complete working code can be found in the I<samples/bpf> directory in "
"the kernel source tree."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1279
msgid "B<seccomp>(2), B<bpf-helpers>(7), B<socket>(7), B<tc>(8), B<tc-bpf>(8)"
msgstr "B<seccomp>(2), B<bpf-helpers>(7), B<socket>(7), B<tc>(8), B<tc-bpf>(8)"

#. type: Plain text
#: build/C/man2/bpf.2:1282
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>."
msgstr ""

#. type: TH
#: build/C/man2/connect.2:67
#, no-wrap
msgid "CONNECT"
msgstr "CONNECT"

#. type: Plain text
#: build/C/man2/connect.2:70
msgid "connect - initiate a connection on a socket"
msgstr "connect - ソケットの接続を行う"

#. type: Plain text
#: build/C/man2/connect.2:77
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/connect.2:96
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""
"B<connect>()  システムコールは、ファイルディスクリプター I<sockfd> が参照して"
"いるソケットを I<addr> で指定されたアドレスに接続する。 I<addrlen> 引数は "
"I<addr> の大きさを示す。 I<addr> のアドレスのフォーマットはソケット "
"I<sockfd> のアドレス空間により異なる。 さらなる詳細は B<socket>(2)  を参照の"
"こと。"

#. type: Plain text
#: build/C/man2/connect.2:112
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM>, then I<addr> is the "
"address to which datagrams are sent by default, and the only address from "
"which datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""
"ソケット I<sockfd> が B<SOCK_DGRAM> 型であれば、 I<addr> は、デフォルトのデー"
"タグラムの送信先のアドレスであり、 データグラムを受信する唯一のアドレスを示す"
"に過ぎない。 ソケットが B<SOCK_STREAM> 型もしくは B<SOCK_SEQPACKET> 型であれ"
"ば、このシステムコールは I<addr> で指定されたアドレスに結び付けられたソケット"
"に対する接続の 作成を試みる。"

#. type: Plain text
#: build/C/man2/connect.2:117
msgid ""
"Some protocol sockets (e.g., UNIX domain stream sockets)  may successfully "
"B<connect>()  only once."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:123
msgid ""
"Some protocol sockets (e.g., datagram sockets in the UNIX and Internet "
"domains)  may use B<connect>()  multiple times to change their association."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:136
#, fuzzy
#| msgid ""
#| "Generally, connection-based protocol sockets may successfully "
#| "B<connect>()  only once; connectionless protocol sockets may use "
#| "B<connect>()  multiple times to change their association.  Connectionless "
#| "sockets may dissolve the association by connecting to an address with the "
#| "I<sa_family> member of I<sockaddr> set to B<AF_UNSPEC> (supported on "
#| "Linux since kernel 2.2)."
msgid ""
"Some protocol sockets (e.g., TCP sockets as well as datagram sockets in the "
"UNIX and Internet domains)  may dissolve the association by connecting to an "
"address with the I<sa_family> member of I<sockaddr> set to B<AF_UNSPEC>; "
"thereafter, the socket can be connected to another address.  (B<AF_UNSPEC> "
"is supported on Linux since kernel 2.2.)"
msgstr ""
"一般的に、接続指向 (connection-oriented) プロトコルでは一度だけ "
"B<connect>()  が成功する。 コネクションレス (connectionless) プロトコルでは対"
"応を変更するために何度も B<connect>()  を使用できる。 非接続ソケットは "
"I<sockaddr> の I<sa_family> メンバに B<AF_UNSPEC> を設定することで、接続アド"
"レスの対応を解消することができる (B<AF_UNSPEC> はカーネル 2.2 以降の Linux で"
"サポート)。"

#. type: Plain text
#: build/C/man2/connect.2:141
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"接続または対応づけに成功するとゼロを返す。 失敗すると -1 を返し、 I<errno> に"
"適切な値を設定する。"

#. type: Plain text
#: build/C/man2/connect.2:144
msgid ""
"The following are general socket errors only.  There may be other domain-"
"specific error codes."
msgstr ""
"以下は一般的なソケットについてのエラーである。他にドメイン特有のエラー が発生"
"する可能性がある。"

#. type: Plain text
#: build/C/man2/connect.2:152
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""
"UNIX ドメインソケットはパス名で識別される。 ソケットファイルへの書き込み許可"
"がなかったか、パス名へ 到達するまでのディレクトリのいずれかに対する検索許可が"
"なかった。 (B<path_resolution>(7)  も参照のこと)"

#. type: TP
#: build/C/man2/connect.2:152
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES>, B<EPERM>"

#. type: Plain text
#: build/C/man2/connect.2:157
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""
"ソケットのブロードキャストフラグが有効になっていないのに ユーザーがブロード"
"キャストへ接続を試みた。または、ローカルのファイアウォールの 規則により接続の"
"要求が失敗した。"

#. type: Plain text
#: build/C/man2/connect.2:164
msgid ""
"B<EACCES> can also be returned if an SELinux policy denied a connection (for "
"example, if there is a policy saying that an HTTP proxy can only connect to "
"ports associated with HTTP servers, and the proxy tries to connect to a "
"different port).  dd"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:167
msgid "Local address is already in use."
msgstr "ローカルアドレスが既に使用されている。"

#. type: Plain text
#: build/C/man2/connect.2:180 build/C/man2/listen.2:103
msgid ""
"(Internet domain sockets)  The socket referred to by I<sockfd> had not "
"previously been bound to an address and, upon attempting to bind it to an "
"ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of I</proc/sys/net/ipv4/"
"ip_local_port_range> in B<ip>(7)."
msgstr ""
"(インターネットドメインソケットの場合) I<sockfd> が参照するソケットがそれ以前"
"にアドレスにバインドされておらず、 そのソケットに一時ポートをバインドしようと"
"した際に、 一時ポートとして使用する範囲のポート番号がすべて使用中であった。 "
"B<ip>(7) の I</proc/sys/net/ipv4/ip_local_port_range> の議論を参照のこと。"

#. type: TP
#: build/C/man2/connect.2:180 build/C/man2/socket.2:426
#: build/C/man2/socketpair.2:85
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: build/C/man2/connect.2:185
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""
"渡されたアドレスの I<sa_family> フィールドが正しいアドレスファミリーではな"
"い。"

#. type: TP
#: build/C/man2/connect.2:185 build/C/man2/send.2:347
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/connect.2:190
msgid ""
"For nonblocking UNIX domain sockets, the socket is nonblocking, and the "
"connection cannot be completed immediately.  For other socket families, "
"there are insufficient entries in the routing cache."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:190 build/C/man2/send.2:360
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: build/C/man2/connect.2:194
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""
"ソケットが非停止 (nonblocking) に設定されており、 前の接続が完了していない。"

#. type: Plain text
#: build/C/man2/connect.2:198 build/C/man2/send.2:367
msgid "I<sockfd> is not a valid open file descriptor."
msgstr "I<sockfd> が有効なオープンされたファイルディスクリプターでない。"

#. type: TP
#: build/C/man2/connect.2:198 build/C/man2/recv.2:469
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: build/C/man2/connect.2:203
#, fuzzy
#| msgid "No-one listening on the remote address."
msgid ""
"A B<connect>()  on a stream socket found no one listening on the remote "
"address."
msgstr "リモートアドレスで接続を待っているプログラムがない。"

#. type: Plain text
#: build/C/man2/connect.2:206
msgid "The socket structure address is outside the user's address space."
msgstr "ソケット構造体のアドレスがユーザーのアドレス空間外にある。"

#. type: TP
#: build/C/man2/connect.2:206
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr "B<EINPROGRESS>"

#. type: Plain text
#: build/C/man2/connect.2:233
#, fuzzy
#| msgid ""
#| "The socket is nonblocking and the connection cannot be completed "
#| "immediately.  It is possible to B<select>(2)  or B<poll>(2)  for "
#| "completion by selecting the socket for writing.  After B<select>(2)  "
#| "indicates writability, use B<getsockopt>(2)  to read the B<SO_ERROR> "
#| "option at level B<SOL_SOCKET> to determine whether B<connect>()  "
#| "completed successfully (B<SO_ERROR> is zero) or unsuccessfully "
#| "(B<SO_ERROR> is one of the usual error codes listed here, explaining the "
#| "reason for the failure)."
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  (UNIX domain sockets failed with B<EAGAIN> instead.)  It is "
"possible to B<select>(2)  or B<poll>(2)  for completion by selecting the "
"socket for writing.  After B<select>(2)  indicates writability, use "
"B<getsockopt>(2)  to read the B<SO_ERROR> option at level B<SOL_SOCKET> to "
"determine whether B<connect>()  completed successfully (B<SO_ERROR> is zero) "
"or unsuccessfully (B<SO_ERROR> is one of the usual error codes listed here, "
"explaining the reason for the failure)."
msgstr ""
"ソケットが非停止 (nonblocking) に設定されていて、接続をすぐに 完了することが"
"できない。その場合、 B<select>(2)  や B<poll>(2)  を使ってそのソケットが書き"
"込み可能になるのを待つことで、 接続の完了を知ることができる。 B<select>(2)  "
"で書き込み可能になった後に、 B<getsockopt>(2)  を使って B<SOL_SOCKET> レベル"
"で B<SO_ERROR> オプションを読み出すこ とにより、 B<connect>()  が成功したか、"
"失敗したかを判断できる。 成功の場合 B<SO_ERROR> が 0 であり、 失敗の場合 "
"B<SO_ERROR> がここのリストにあるいずれかのエラーコードであり、 それにより失敗"
"の原因が分かる。"

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: build/C/man2/connect.2:239
msgid ""
"The system call was interrupted by a signal that was caught; see "
"B<signal>(7)."
msgstr ""
"捕捉されたシグナルによりシステムコールが中断された。 B<signal>(7)  参照。"

#. type: TP
#: build/C/man2/connect.2:239 build/C/man2/send.2:383
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: build/C/man2/connect.2:242
msgid "The socket is already connected."
msgstr "ソケットは既に接続 (connect) されている。"

#. type: TP
#: build/C/man2/connect.2:242
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr "B<ENETUNREACH>"

#. type: Plain text
#: build/C/man2/connect.2:245
msgid "Network is unreachable."
msgstr "到達できないネットワークである。"

#. type: TP
#: build/C/man2/connect.2:250
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: build/C/man2/connect.2:255
msgid ""
"The socket type does not support the requested communications protocol.  "
"This error can occur, for example, on an attempt to connect a UNIX domain "
"datagram socket to a stream socket."
msgstr ""
"ソケットタイプが要求された通信プロトコルではサポートされていない。 このエラー"
"は、 例えば UNIX ドメインデータグラムソケットをストリームソケットに接続しよう"
"とした場合などに起こり得る。"

#. type: TP
#: build/C/man2/connect.2:255
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man2/connect.2:262
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""
"接続を試みている途中で時間切れ (timeout) になった。サーバーが混雑していて 新"
"たな接続を受け入れられないのかもしれない。 IP ソケットでは、 syncookie がサー"
"バーで有効になっている場合、 タイムアウトが非常に長くなる場合があるので注意す"
"ること。"

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: build/C/man2/connect.2:278
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (connectB<()> first appeared in "
"4.2BSD)."
msgstr "B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (B<connect>()  は 4.2BSD で初めて実装された)."

#. type: Plain text
#: build/C/man2/connect.2:295
msgid ""
"If B<connect>()  fails, consider the state of the socket as unspecified.  "
"Portable applications should close the socket and create a new one for "
"reconnecting."
msgstr ""
"B<connect>() が失敗した場合、そのソケットの状態は不定だと考えること。 移植性"
"を考慮したアプリケーションでは、そのソケットをクローズし、再接続用に新しいソ"
"ケットを作成すべきである。"

#. type: Plain text
#: build/C/man2/connect.2:300
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr "B<connect>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/connect.2:308
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7), B<selinux>(8)"
msgstr "B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), B<path_resolution>(7), B<selinux>(8)"

#. type: TH
#: build/C/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr "GETIFADDRS"

#. type: TH
#: build/C/man3/getifaddrs.3:36 build/C/man3/if_nameindex.3:26
#: build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr "getifaddrs, freeifaddrs - インターフェースのアドレスを取得する"

#. type: Plain text
#: build/C/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing "
"the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""
"B<getifaddrs>() 関数は、ローカルシステムのネットワークインターフェース情報を"
"表す構造体の連結リストを作成し、 リストの先頭の要素のアドレスを I<*ifap> に格"
"納する。 リストは I<ifaddrs> 構造体で構成される。 I<ifaddrs> 構造体は以下のよ"
"うに定義されている。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""
"I<ifa_next> フィールドにはリストの次の構造体へのポインターが格納される。 この"
"要素がリストの最後の場合には NULL が入る。"

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: build/C/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr "I<ifa_name> はヌル終端されたインターフェース名を指す。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""
"I<ifa_flags> フィールドには、 B<SIOCGIFFLAGS> B<ioctl>(2) 操作で返されるイン"
"ターフェースのフラグが格納される (これらのフラグのリストについては "
"B<netdevice>(7) を参照)。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a null pointer."
msgstr ""
"I<ifa_addr> フィールドは、インターフェースのアドレスを格納した構造体へのポイ"
"ンターである (I<sa_family> サブフィールドを参照して、アドレス構造体の形式を判"
"別すべきである)。 このフィールドはヌルポインターとなる場合がある。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a null pointer."
msgstr ""
"I<ifa_netmask> フィールドには、 ネットマスクがあるアドレスファミリーであれ"
"ば、 I<ifa_addr> に関連付けられたネットマスクを格納した構造体へのポインターが"
"入る。 このフィールドはヌルポインターとなる場合がある。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""
"I<ifa_flags> にビット B<IFF_BROADCAST> か B<IFF_POINTOPOINT> のどちらが設定さ"
"れているかにより (同時にはこれらのどちらか一方だけが設定される)、 "
"I<ifa_broadaddr> に I<ifa_addr> に対応するブロードキャストが入るか (そのアド"
"レスファミリーでブロードキャストがある場合)、 I<ifa_dstaddr> に point-to-"
"point インターフェースの宛先アドレスが入るかが決まる。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""
"I<ifa_data> フィールドは、 アドレスファミリー固有のデータが入ったバッファーへ"
"のポインターである。 そのインターフェースでこのようなデータがない場合には、 "
"このフィールドは NULL となる。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be "
"freed using B<freeifaddrs>()  when no longer needed."
msgstr ""
"B<getifaddrs>() が返すデータは動的に確保される。 必要なくなった際には "
"B<freeifaddrs>() を使って解放すべきである。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功すると、 B<getifaddrs> は 0 を返す。 エラーの場合、 -1 が返り、 I<errno> "
"が適切に設定される。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""
"B<getifaddrs>() は失敗する場合があり、その場合には I<errno> には "
"B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), B<sendto>(2), "
"B<malloc>(3), B<realloc>(3) に対して規定されているエラーのいずれかが設定され"
"る。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr ""
"B<getifaddrs>() 関数は glibc 2.3 で初めて登場したが、 glibc 2.3.3 より前の"
"バージョンの実装では IPv4 アドレスだけがサポートされていた。 IPv6 のサポート"
"は glibc 2.3.3 で追加された。 IPv4 以外のアドレスファミリーが B<getifaddrs> "
"で利用できるのは、 netlink をサポートするカーネルの場合だけである。"

#. type: tbl table
#: build/C/man3/getifaddrs.3:181
#, no-wrap
msgid ""
"B<getifaddrs>(),\n"
"B<freeifaddrs>()"
msgstr ""
"B<getifaddrs>(),\n"
"B<freeifaddrs>()"

#. type: tbl table
#: build/C/man3/getifaddrs.3:181 build/C/man3/if_nameindex.3:116
#: build/C/man3/if_nametoindex.3:104 build/C/man3/sockatmark.3:83
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: build/C/man3/getifaddrs.3:204
msgid ""
"Not in POSIX.1.  This function first appeared in BSDi and is present on the "
"BSD systems, but with slightly different semantics documented\\(emreturning "
"one entry per interface, not per address.  This means I<ifa_addr> and other "
"fields can actually be NULL if the interface has no address, and no link-"
"level address is returned if the interface has an IP address assigned.  "
"Also, the way of choosing either I<ifa_broadaddr> or I<ifa_dstaddr> differs "
"on various systems."
msgstr "POSIX.1 にはない。 この関数は BSDi で初めて登場し、 BSD 系のシステムに存在するが、 ドキュメント上はかなり動作が異なり、アドレス毎ではなくインターフェース毎に 1 エントリーを返す。 このことは、 インターフェースがアドレスを持たない場合には I<ifa_addr> や他のフィールドは実際に NULL になり、 インターフェースに IP アドレスが割り当てられている場合には リンクレベルのアドレスは返されない、ということを意味する。 また、 I<ifa_broadaddr> と I<ifa_dstaddr> のどちらを選択するかを決める方法は、 システムにより異なる。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:221
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in I<E<lt>linux/netdevice."
"hE<gt>>), which contains various interface attributes and statistics."
msgstr ""
"Linux では、 返されるアドレスは通常インターフェースに割り当てられた IPv4 アド"
"レスと IPv6 アドレスになるが、 これ以外にインターフェース毎に一つ "
"B<AF_PACKET> アドレスも返される。 B<AF_PACKET> アドレスには、 インターフェー"
"スとその物理層に関する低レベルの詳細が格納される。 この場合、 I<ifa_data> "
"フィールドには、 I<E<lt>linux/if_link.hE<gt>> で定義される I<struct "
"rtnl_link_stats> (Linux 2.4 以前では I<E<lt>linux/netdevice.hE<gt>> で定義さ"
"れる I<struct net_device_stats>) へのポインターが格納される。 この構造体に"
"は、インターフェースの様々な属性や統計情報が入る。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:228
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(), "
"and B<getnameinfo>(3).  Here is what we see when running this program on one "
"system:"
msgstr ""
"以下のプログラムは B<getifaddrs>(), B<freeifaddrs>(), B<getnameinfo>(3) の使"
"用例である。 以下はこのプログラムをあるシステムで実行した際の出力である。"

#. type: Plain text
#: build/C/man3/getifaddrs.3:249
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"
msgstr ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"

#. type: SS
#: build/C/man3/getifaddrs.3:251 build/C/man3/if_nameindex.3:136
#: build/C/man2/recvmmsg.2:224
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/getifaddrs.3:263
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:269
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:274
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:277
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:282
#, no-wrap
msgid ""
"    for (struct ifaddrs *ifa = ifaddr; ifa != NULL;\n"
"             ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""
"    for (struct ifaddrs *ifa = ifaddr; ifa != NULL;\n"
"             ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:284
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:287
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:294
#, no-wrap
msgid ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"
msgstr ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:296
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr "        /* For an AF_INET* interface address, display the address */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:307
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:309
#, no-wrap
msgid "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
msgstr "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:312
#, no-wrap
msgid ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"
msgstr ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:319
#, no-wrap
msgid ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"
msgstr ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:323
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:330
msgid ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"

#. type: TH
#: build/C/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr "GETSOCKNAME"

#. type: Plain text
#: build/C/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr "getsockname - ソケットの名前を取得する"

#. type: Plain text
#: build/C/man2/getsockname.2:46
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getsockname.2:49
#, no-wrap
msgid "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""
"B<getsockname>()  は、ソケット I<sockfd> に結び付けられている現在のアドレス"
"を、 I<addr> が指すバッファーに格納して返す。 I<addrlen> 引数は、 I<addr> "
"が指している領域のサイズ (バイト単位) に初期化しておかなければならない。 関数"
"が返る時には、 I<addrlen> にはソケットアドレスの実際のサイズ (バイト単位) が"
"格納される。"

#. type: Plain text
#: build/C/man2/getsockname.2:78 build/C/man2/getsockopt.2:145
#: build/C/man2/listen.2:108
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr "引数 I<sockfd> は有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/getsockname.2:84
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""
"引数 I<addr> の指しているメモリーがプロセスのアドレス空間の有効な部分ではな"
"い。"

#. type: Plain text
#: build/C/man2/getsockname.2:88
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "I<addrlen> が不正である (例えば、負で場合など)。"

#. type: TP
#: build/C/man2/getsockname.2:88 build/C/man3/if_nameindex.3:83
#: build/C/man2/send.2:395
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: build/C/man2/getsockname.2:92
msgid ""
"Insufficient resources were available in the system to perform the operation."
msgstr "処理をするだけの十分なリソースがシステムに無い。"

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: build/C/man2/getsockname.2:103
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>()  first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>() は 4.2BSD で初めて実装された)"

#. type: Plain text
#: build/C/man2/getsockname.2:115
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"

#. type: TH
#: build/C/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr "GETSOCKOPT"

#. type: Plain text
#: build/C/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr "getsockopt, setsockopt - ソケットのオプションの設定と取得を行なう"

#. type: Plain text
#: build/C/man2/getsockopt.2:56
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"

#. type: Plain text
#: build/C/man2/getsockopt.2:66
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""
"B<getsockopt>()  と B<setsockopt>()  は、ファイルディスクリプター I<socket> "
"で参照されるソケットに関連するオプションの操作を行う。 オプションは複数のプロ"
"トコル層(level)に存在するかもしれないが、 これらは常に最上位のソケット層へと"
"設定される。"

#. type: Plain text
#: build/C/man2/getsockopt.2:85
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""
"ソケットオプションを操作する際には、オプションの層 (level) と オプションの名"
"前を指定しなければならない。 ソケット API 層でオプションを操作する為には、 "
"I<level> を B<SOL_SOCKET> に指定する。 他の全ての層でオプションを操作する為に"
"は、与えられたオプションの 制御主体となるプロトコルのプロトコル番号を指定す"
"る。例えば、 オプションが B<TCP> プロトコルで解釈されるべきことを指示するに"
"は、 I<level> に B<TCP> のプロトコル番号を指定しなければならない。 "
"B<getprotoent>(3)  を参照すること。"

#. type: Plain text
#: build/C/man2/getsockopt.2:107
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""
"I<optval> と I<optlen> 引数は B<setsockopt>()  のオプションの値にアクセスす"
"るために用いられる。 B<getsockopt>()  では要求したオプションの値を返すための"
"バッファーを指定する。 B<getsockopt>()  では I<optlen> は値と結果両用の引数"
"で、最初に I<optval> の指しているバッファーのサイズを与え、実際に返される値の"
"サイズに 書き換えられる。もしオプション値を与えず、返されもしない場合には "
"I<optval> は NULL でも良い。"

#. type: Plain text
#: build/C/man2/getsockopt.2:117
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file I<E<lt>sys/"
"socket.hE<gt>> contains definitions for socket level options, described "
"below.  Options at other protocol levels vary in format and name; consult "
"the appropriate entries in section 4 of the manual."
msgstr ""
"I<optname> および指定されたオプションは解釈されずに、適切なプロトコルモジュー"
"ルに 渡されて解釈される。インクルードファイル I<E<lt>sys/socket.hE<gt>> には"
"後述のソケット層のオプションの定義が含まれている。 他のプロトコル層では名前や"
"形式は異なる。 マニュアルのセクション 4 の適切なエントリーを参照すること。"

#. type: Plain text
#: build/C/man2/getsockopt.2:126
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""
"ほとんどのソケット層のオプションは I<optval> に I<int> 引数を利用する。 "
"B<setsockopt>()  で、二値(boolean)オプションを有効(enable)にするにはゼロ以外"
"を指定し、 無効(disable)にするにはゼロを指定する。"

#. type: Plain text
#: build/C/man2/getsockopt.2:130
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""
"利用可能なソケットオプションの説明に関しては、 B<socket>(7)  と適切なプロトコ"
"ルの man ページを参照のこと。"

#. type: Plain text
#: build/C/man2/getsockopt.2:135
#, fuzzy
#| msgid ""
#| "On success, zero is returned.  On error, -1 is returned, and I<errno> is "
#| "set appropriately."
msgid ""
"On success, zero is returned for the standard options.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合にはゼロが返される。エラー時には -1 が返され、 I<errno> が適切に"
"設定される。"

#. type: Plain text
#: build/C/man2/getsockopt.2:139
msgid ""
"Netfilter allows the programmer to define custom socket options with "
"associated handlers; for such options, the return value on success is the "
"value returned by the handler."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:155
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""
"I<optval> で指定されたアドレスがプロセスのアドレス空間の有効な部分ではない。 "
"B<getsockopt>()  の場合、 I<optlen> がプロセスのアドレス空間の有効な部分でな"
"い場合にもこのエラーが返される。"

#. type: Plain text
#: build/C/man2/getsockopt.2:166
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""
"B<setsockopt>()  で I<option> が不正である。 I<optval> に無効な値が指定された"
"場合にも、このエラーが発生する可能性がある (例えば、 B<ip>(7)  に説明がある "
"B<IP_ADD_MEMBERSHIP> オプションなど)。"

#. type: TP
#: build/C/man2/getsockopt.2:166 build/C/man7/vsock.7:196
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: build/C/man2/getsockopt.2:169
msgid "The option is unknown at the level indicated."
msgstr "指定された層(level)にはこのオプションは存在しない。"

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: build/C/man2/getsockopt.2:181
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these system calls first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (これらのシステムコールは 4.2BSD で最初に現れた)"

#. type: Plain text
#: build/C/man2/getsockopt.2:195
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""
"ソケットのオプションのいくつかはシステムのより低い層で 処理されるべきである。"

#. type: Plain text
#: build/C/man2/getsockopt.2:206
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: build/C/man3/if_nameindex.3:26
#, no-wrap
msgid "IF_NAMEINDEX"
msgstr "IF_NAMEINDEX"

#. type: TH
#: build/C/man3/if_nameindex.3:26 build/C/man2/listen.2:45
#: build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25
#: build/C/man2/socket.2:42 build/C/man2/socketpair.2:42
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man3/if_nameindex.3:29
msgid ""
"if_nameindex, if_freenameindex - get network interface names and indexes"
msgstr ""
"if_nameindex, if_freenameindex - ネットワークインターフェースの名前とインデッ"
"クスを取得する"

#. type: Plain text
#: build/C/man3/if_nameindex.3:32 build/C/man3/if_nametoindex.3:32
#, no-wrap
msgid "B<#include E<lt>net/if.hE<gt>>\n"
msgstr "B<#include E<lt>net/if.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:35
#, no-wrap
msgid ""
"B<struct if_nameindex *if_nameindex(>I<void>B<);>\n"
"B<void if_freenameindex(struct if_nameindex *>I<ptr>B<);>\n"
msgstr ""
"B<struct if_nameindex *if_nameindex(>I<void>B<);>\n"
"B<void if_freenameindex(struct if_nameindex *>I<ptr>B<);>\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:46
msgid ""
"The B<if_nameindex>()  function returns an array of I<if_nameindex> "
"structures, each containing information about one of the network interfaces "
"on the local system.  The I<if_nameindex> structure contains at least the "
"following entries:"
msgstr ""
"B<if_nameindex>() 関数は I<if_nameindex> 構造体の配列を返す。 各構造体には"
"ローカルシステムのネットワークインターフェースのいずれかの情報が入る。 "
"I<if_nameindex> 構造体には少なくとも以下のフィールドがある。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:51
#, no-wrap
msgid ""
"unsigned int if_index; /* Index of interface (1, 2, ...) */\n"
"char        *if_name;  /* Null-terminated name (\"eth0\", etc.) */\n"
msgstr ""
"unsigned int if_index; /* インターフェースのインデックス (1, 2, ...) */\n"
"char        *if_name;  /*ヌル終端された名前 (\"eth0\" など) */\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:65
msgid ""
"The I<if_index> field contains the interface index.  The I<if_name> field "
"points to the null-terminated interface name.  The end of the array is "
"indicated by entry with I<if_index> set to zero and I<if_name> set to NULL."
msgstr "I<if_index> フィールドにはインターフェースのインデックスが入る。 I<if_name> フィールドはヌル終端されたインターフェース名を指す。 配列の最後は、 I<if_index> が 0 で I<if_name> が NULL のエントリーで示される。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:71
msgid ""
"The data structure returned by B<if_nameindex>()  is dynamically allocated "
"and should be freed using B<if_freenameindex>()  when no longer needed."
msgstr ""
"B<if_nameindex>() が返すデータ構造体は動的に確保される。 必要なくなった際に"
"は B<if_freenameindex>() で解放すべきである。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:78
msgid ""
"On success, B<if_nameindex>()  returns pointer to the array; on error, NULL "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合には B<if_nameindex>() は配列へのポインターを返す。エラー時には "
"NULL が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:83
msgid "B<if_nameindex>()  may fail and set I<errno> if:"
msgstr "B<if_nameindex>() が失敗した場合には以下の I<errno> が設定される。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:86
msgid "Insufficient resources available."
msgstr "利用可能なリソースが十分にない。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:97
msgid ""
"B<if_nameindex>()  may also fail for any of the errors specified for "
"B<socket>(2), B<bind>(2), B<ioctl>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), or B<malloc>(3)."
msgstr ""
"B<if_nameindex>() は、 B<socket>(2), B<bind>(2), B<ioctl>(2), "
"B<getsockname>(2), B<recvmsg>(2), B<sendto>(2), B<malloc>(3) に対して規定され"
"ているエラーのいずれかで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:104
msgid ""
"The B<if_nameindex>()  function first appeared in glibc 2.1, but before "
"glibc 2.3.4, the implementation supported only interfaces with IPv4 "
"addresses.  Support of interfaces that don't have IPv4 addresses is "
"available only on kernels that support netlink."
msgstr ""
"B<if_nameindex>() 関数は glibc 2.1 で初めて登場したが、 glibc 2.3.4 より前の"
"バージョンの実装では IPv4 アドレスを持つインターフェースのみをサポートしてい"
"た。 IPv4 アドレスを持たないインターフェースがサポートされているのは、 "
"netlink をサポートするカーネルにおいてのみである。"

#. type: tbl table
#: build/C/man3/if_nameindex.3:114
#, no-wrap
msgid "B<if_nameindex>(),\n"
msgstr "B<if_nameindex>(),\n"

#. type: tbl table
#: build/C/man3/if_nameindex.3:116
#, no-wrap
msgid "B<if_freenameindex>()"
msgstr "B<if_freenameindex>()"

#. type: Plain text
#: build/C/man3/if_nameindex.3:121 build/C/man3/if_nametoindex.3:108
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 3493."
msgstr "POSIX.1-2001, POSIX.1-2008, RFC\\ 3493."

#. type: Plain text
#: build/C/man3/if_nameindex.3:123 build/C/man3/if_nametoindex.3:110
msgid "This function first appeared in BSDi."
msgstr "この関数は BSDi 初めて登場した。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:127
msgid ""
"The program below demonstrates the use of the functions described on this "
"page.  An example of the output this program might produce is the following:"
msgstr ""
"以下のプログラムはこのページで説明した関数の使い方を示している。このプログラ"
"ムが生成する出力は以下のようになる。"

#. type: Plain text
#: build/C/man3/if_nameindex.3:134
#, no-wrap
msgid ""
"$ B<./a.out>I<\n"
"1: lo\n"
"2: wlan0\n"
"3: em1>\n"
msgstr ""
"$ B<./a.out>I<\n"
"1: lo\n"
"2: wlan0\n"
"3: em1>\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:142
#, no-wrap
msgid ""
"#include E<lt>net/if.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>net/if.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:147
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct if_nameindex *if_ni, *i;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct if_nameindex *if_ni, *i;\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:153
#, no-wrap
msgid ""
"    if_ni = if_nameindex();\n"
"    if (if_ni == NULL) {\n"
"        perror(\"if_nameindex\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if_ni = if_nameindex();\n"
"    if (if_ni == NULL) {\n"
"        perror(\"if_nameindex\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:156
#, no-wrap
msgid ""
"    for (i = if_ni; ! (i-E<gt>if_index == 0 && i-E<gt>if_name == NULL); i++)\n"
"        printf(\"%u: %s\\en\", i-E<gt>if_index, i-E<gt>if_name);\n"
msgstr ""
"    for (i = if_ni; ! (i-E<gt>if_index == 0 && i-E<gt>if_name == NULL); i++)\n"
"        printf(\"%u: %s\\en\", i-E<gt>if_index, i-E<gt>if_name);\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:158
#, no-wrap
msgid "    if_freenameindex(if_ni);\n"
msgstr "    if_freenameindex(if_ni);\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:161 build/C/man2/select.2:745
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/if_nameindex.3:169
msgid ""
"B<getsockopt>(2), B<setsockopt>(2), B<getifaddrs>(3), B<if_indextoname>(3), "
"B<if_nametoindex>(3), B<ifconfig>(8)"
msgstr ""
"B<getsockopt>(2), B<setsockopt>(2), B<getifaddrs>(3), B<if_indextoname>(3), "
"B<if_nametoindex>(3), B<ifconfig>(8)"

#. type: TH
#: build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "IF_NAMETOINDEX"
msgstr "IF_NAMETOINDEX"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:29
msgid ""
"if_nametoindex, if_indextoname - mappings between network interface names "
"and indexes"
msgstr ""
"if_nametoindex, if_indextoname - ネットワークインターフェースの名前とインデッ"
"クスのマッピングを行う"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:34
#, no-wrap
msgid "B<unsigned int if_nametoindex(const char *>I<ifname>B<);>\n"
msgstr "B<unsigned int if_nametoindex(const char *>I<ifname>B<);>\n"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:36
#, no-wrap
msgid "B<char *if_indextoname(unsigned int ifindex, char *>I<ifname>B<);>\n"
msgstr "B<char *if_indextoname(unsigned int ifindex, char *>I<ifname>B<);>\n"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:43
msgid ""
"The B<if_nametoindex>()  function returns the index of the network interface "
"corresponding to the name I<ifname>."
msgstr ""
"B<if_nametoindex>() 関数は、 名前が I<ifname> のネットワークインターフェース"
"のインデックスを返す。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:54
msgid ""
"The B<if_indextoname>()  function returns the name of the network interface "
"corresponding to the interface index I<ifindex>.  The name is placed in the "
"buffer pointed to by I<ifname>.  The buffer must allow for the storage of at "
"least B<IF_NAMESIZE> bytes."
msgstr ""
"B<if_indextoname>() 関数は、 インターフェースのインデックスが I<ifindex> に対"
"応するネットワークインターフェースの名前を返す。 名前は I<ifname> が指すバッ"
"ファーに格納される。 バッファーは少なくとも B<IF_NAMESIZE> バイトの領域が必要"
"である。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:61
msgid ""
"On success, B<if_nametoindex>()  returns the index number of the network "
"interface; on error, 0 is returned and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<if_nametoindex>() はネットワークインターフェースのインデック"
"ス番号を返す。エラーの場合、 0 を返し、 I<errno> を適切に設定にする。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:69
msgid ""
"On success, B<if_indextoname>()  returns I<ifname>; on error, NULL is "
"returned and I<errno> is set appropriately."
msgstr ""
"成功した場合には B<if_indextoname>() は I<ifname> を返す。エラー時には NULL "
"が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:74
msgid "B<if_nametoindex>()  may fail and set I<errno> if:"
msgstr "B<if_nametoindex>() が失敗した場合には以下の I<errno> が設定される。"

#. type: TP
#: build/C/man3/if_nametoindex.3:74
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:77
msgid "No interface found with given name."
msgstr "指定された名前を持つインターフェースがない。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:82
msgid "B<if_indextoname>()  may fail and set I<errno> if:"
msgstr "B<if_indextoname>() は以下の I<errno> で失敗する場合がある。"

#. type: TP
#: build/C/man3/if_nametoindex.3:82
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:85
msgid "No interface found for the index."
msgstr "インデックスに対応するインターフェースがない。"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:93
msgid ""
"B<if_nametoindex>()  and B<if_indextoname>()  may also fail for any of the "
"errors specified for B<socket>(2)  or B<ioctl>(2)."
msgstr ""
"B<if_nametoindex>() と B<if_indextoname>() は、 B<socket>(2) と B<ioctl>(2) "
"に対して規定されているエラーのいずれかで失敗する場合がある。"

#. type: tbl table
#: build/C/man3/if_nametoindex.3:104
#, no-wrap
msgid ""
"B<if_nametoindex>(),\n"
"B<if_indextoname>()"
msgstr ""
"B<if_nametoindex>(),\n"
"B<if_indextoname>()"

#. type: Plain text
#: build/C/man3/if_nametoindex.3:114
msgid "B<getifaddrs>(3), B<if_nameindex>(3), B<ifconfig>(8)"
msgstr "B<getifaddrs>(3), B<if_nameindex>(3), B<ifconfig>(8)"

#. type: TH
#: build/C/man2/listen.2:45
#, no-wrap
msgid "LISTEN"
msgstr "LISTEN"

#. type: Plain text
#: build/C/man2/listen.2:48
msgid "listen - listen for connections on a socket"
msgstr "listen - ソケット(socket)上の接続を待つ"

#. type: Plain text
#: build/C/man2/listen.2:54
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"

#. type: Plain text
#: build/C/man2/listen.2:62
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""
"B<listen>()  は I<sockfd> が参照するソケットを接続待ちソケット (passive "
"socket) として印をつける。 接続待ちソケットとは、 B<accept>(2)  を使って到着"
"した接続要求を受け付けるのに使用されるソケットである。"

#. type: Plain text
#: build/C/man2/listen.2:69
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""
"I<sockfd> 引数は、 B<SOCK_STREAM> 型か B<SOCK_SEQPACKET> 型のソケットを参照"
"するファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/listen.2:81
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""
"I<backlog> 引数は、 I<sockfd> についての保留中の接続のキューの最大長を指定"
"する。 キューがいっぱいの状態で接続要求が到着すると、クライアントは "
"B<ECONNREFUSED> というエラーを受け取る。下位層のプロトコルが再送信をサポート "
"していれば、要求は無視され、これ以降の接続要求の再送信が成功するかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/listen.2:90
msgid "Another socket is already listening on the same port."
msgstr "別のソケットが既に同じポートを listen している。"

#. type: Plain text
#: build/C/man2/listen.2:118
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr "ソケットは B<listen>()  がサポートしている型ではない。"

#. type: Plain text
#: build/C/man2/listen.2:122
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<listen>()  first appeared in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<listen>()  は 4.2BSD で初めて実装された)"

#. type: Plain text
#: build/C/man2/listen.2:124
msgid "To accept connections, the following steps are performed:"
msgstr "接続を受け付けるには、以下の処理が実行される。"

#. type: TP
#: build/C/man2/listen.2:125 build/C/man2/select_tut.2:192
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/listen.2:128
msgid "A socket is created with B<socket>(2)."
msgstr "B<socket>(2)  でソケットを作成する。"

#. type: TP
#: build/C/man2/listen.2:128 build/C/man2/select_tut.2:201
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/listen.2:134
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""
"B<bind>(2)  を使ってソケットにローカルアドレスを割り当てて、 他のソケットがこ"
"のソケットに B<connect>(2)  できるようにする。"

#. type: TP
#: build/C/man2/listen.2:134 build/C/man2/select_tut.2:205
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man2/listen.2:138
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""
"B<listen>()  を使って、接続要求を受け付ける意志と接続要求を入れるキュー長を指"
"定する。"

#. type: TP
#: build/C/man2/listen.2:138 build/C/man2/select_tut.2:212
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man2/listen.2:141
msgid "Connections are accepted with B<accept>(2)."
msgstr "B<accept>(2)  を使って接続を受け付ける。"

#. type: Plain text
#: build/C/man2/listen.2:164
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""
"TCP ソケットでの I<backlog> 引数の振る舞いは Linux 2.2 で変更された。 現在"
"ではこの引数は、 受け付けられるのを待っている、 I<完全に> 確立されたソケッ"
"トのキューの長さを指定する。 以前は不完全な接続要求の数であったが、これを置き"
"換えた。 不完全なソケットのキューの最大長は I</proc/sys/net/ipv4/"
"tcp_max_syn_backlog> を用いて設定できる。 syncookie が有効になっている場合、 "
"論理的な最大長は存在せず、この設定は無視される。"

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: build/C/man2/listen.2:178
#, fuzzy
#| msgid ""
#| "If the I<backlog> argument is greater than the value in I</proc/sys/net/"
#| "core/somaxconn>, then it is silently truncated to that value; the default "
#| "value in this file is 128.  In kernels before 2.4.25, this limit was a "
#| "hard coded value, B<SOMAXCONN>, with the value 128."
msgid ""
"If the I<backlog> argument is greater than the value in I</proc/sys/net/core/"
"somaxconn>, then it is silently truncated to that value.  Since Linux 5.4, "
"the default in this file is 4096; in earlier kernels, the default value is "
"128.  In kernels before 2.4.25, this limit was a hard coded value, "
"B<SOMAXCONN>, with the value 128."
msgstr ""
"I<backlog> 引数が I</proc/sys/net/core/somaxconn> の値よりも大きければ、 "
"I<backlog> の値は暗黙のうちにこの値に切り詰められる。 このファイルのデフォル"
"ト値は 128 である。 バージョン 2.4.5 以前のカーネルでは、この上限値は コード"
"埋め込みの固定値 B<SOMAXCONN> であり、その値は 128 であった。"

#. type: Plain text
#: build/C/man2/listen.2:187
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr "RECV"

#. type: Plain text
#: build/C/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr "recv, recvfrom, recvmsg - ソケットからメッセージを受け取る"

#. type: Plain text
#: build/C/man2/recv.2:50 build/C/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/recv.2:52
#, no-wrap
msgid "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:55
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:57
#, no-wrap
msgid "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:69
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""
"B<recv>(), B<recvfrom>(), B<recvmsg>() コールは、 ソケットからメッセージを受"
"け取るのに使用される。 これらはコネクションレス型のソケットにも接続指向 "
"(connection-oriened) 型のソケットにも使用できる。 このページでは、まずこれら "
"3 つのシステムコールすべてに共通の機能について説明し、 システムコール間の違い"
"について説明する。"

#. type: Plain text
#: build/C/man2/recv.2:84
#, fuzzy
#| msgid ""
#| "The B<send>()  call may be used only when the socket is in a I<connected> "
#| "state (so that the intended recipient is known).  The only difference "
#| "between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
#| "zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, "
#| "the following call"
msgid ""
"The only difference between B<recv>()  and B<read>(2)  is the presence of "
"I<flags>.  With a zero I<flags> argument, B<recv>()  is generally equivalent "
"to B<read>(2)  (but see NOTES).  Also, the following call"
msgstr ""
"B<send>()  は、ソケットが I<接続された (connected)> 状態にある場合にのみ使用"
"できる (つまり、どの相手に送信するかは既知である)。 B<send>()  と "
"B<write>(2)  の違いは、引数に I<flags> があるかどうかだけである。 引数 "
"I<flags> にフラグが指定されない場合、 B<send>()  は B<write>(2)  と等価であ"
"る。 また、"

#. type: Plain text
#: build/C/man2/recv.2:86
#, no-wrap
msgid "    recv(sockfd, buf, len, flags);\n"
msgstr "    recv(sockfd, buf, len, flags);\n"

#. type: Plain text
#: build/C/man2/recv.2:88 build/C/man2/send.2:88
msgid "is equivalent to"
msgstr "は以下と等価である。"

#. type: Plain text
#: build/C/man2/recv.2:90
#, no-wrap
msgid "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"
msgstr "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"

#. type: Plain text
#: build/C/man2/recv.2:96
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""
"これらの三つのシステムコールはいずれも、成功した場合にはメッセージの長さを返"
"す。 メッセージが長過ぎて指定されたバッファーに入り切らなかった場合には、 "
"メッセージを受信したソケットの種類によっては余分のバイトが捨てられる かもしれ"
"ない。"

#. type: Plain text
#: build/C/man2/recv.2:106
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""
"ソケットに受け取るメッセージが存在しなかった場合、 受信用のコールはメッセージ"
"が到着するまで待つ。 ただし、ソケットが非停止 (nonblocking)  に設定されていた"
"場合 (B<fcntl>(2)  を参照) は -1 を返し、外部変数 I<errno> に B<EAGAIN> か "
"B<EWOULDBLOCK> を設定する。 これらの受信用のコールは、受信したデータのサイズ"
"が要求したサイズに 達するまで待つのではなく、何らかのデータを受信すると復帰す"
"る (受信されるデータの最大サイズは要求したサイズである)。"

#. type: Plain text
#: build/C/man2/recv.2:113
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""
"アプリケーションは B<select>(2), B<poll>(2), B<epoll>(7) を使って、ソケットに"
"さらにデータが到着しているかを判定することができる。"

#. type: SS
#: build/C/man2/recv.2:113 build/C/man2/send.2:160
#, no-wrap
msgid "The flags argument"
msgstr "フラグ引数"

#. type: Plain text
#: build/C/man2/recv.2:117
msgid ""
"The I<flags> argument is formed by ORing one or more of the following values:"
msgstr ""
"I<flags> 引数には、以下の値を 1つ以上、ビット単位の論理和 を取ったものを指"
"定する:"

#. type: TP
#: build/C/man2/recv.2:117
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() のみ; Linux 2.6.23)"

#. type: Plain text
#: build/C/man2/recv.2:128
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""
"(B<unix>(7)  で説明されている)  B<SCM_RIGHTS> 操作を使って UNIX ドメインの"
"ファイルディスクリプター経由で受信した ファイルディスクリプターについて "
"close-on-exec フラグをセットする。 このフラグは、 B<open>(2)  の "
"B<O_CLOEXEC> フラグと同じ理由で有用である。"

#. type: TP
#: build/C/man2/recv.2:128 build/C/man2/send.2:188
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:147
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK>.  This provides similar behavior "
"to setting the B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> "
"operation), but differs in that B<MSG_DONTWAIT> is a per-call option, "
"whereas B<O_NONBLOCK> is a setting on the open file description (see "
"B<open>(2)), which will affect all threads in the calling process and as "
"well as other processes that hold file descriptors referring to the same "
"open file description."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:147
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr "B<MSG_ERRQUEUE> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:166
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""
"このフラグを指定すると、 キューに入れられたエラーをソケットのエラーキューから"
"取りだせるようになる。 このエラーは補助メッセージに組み込まれて渡され、 この"
"補助メッセージの種別はプロトコルに依存する (IPv4 の場合は B<IP_RECVERR>)。 "
"ユーザーは十分なサイズのバッファーを用意しなければならない。 補助メッセージに"
"関するより詳細な情報は B<cmsg>(3)  および B<ip>(7)  を参照のこと。 エラーの原"
"因となったオリジナルパケットのペイロードは、 I<msg_iovec> 経由で通常のデータ"
"として渡される。 エラーを起こしたデータグラムのオリジナルの宛先アドレスは、 "
"I<msg_name> 経由で参照できる。"

#. type: Plain text
#: build/C/man2/recv.2:170
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr "このエラーは I<sock_extended_err> 構造体で提供される:"

#. type: Plain text
#: build/C/man2/recv.2:177
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: build/C/man2/recv.2:189
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:191
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: build/C/man2/recv.2:215
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""
"I<ee_errno> にはキューに入れられたエラーの I<errno> が入っている。 "
"I<ee_origin> にはエラーが発生した場所のオリジンコード (origin code) が入って"
"いる。 他のフィールドはプロトコル依存である。 B<SO_EE_OFFENDER> マクロは、こ"
"の補助的なメッセージを引数に取って、 エラーの発生したネットワークオブジェク"
"トのアドレスへのポインターを返す。 アドレスが不明の場合には、 I<sockaddr> の "
"I<sa_family> メンバーが B<AF_UNSPEC> になっている。 I<sockaddr> の他のフィー"
"ルドは不定である。 エラーの発生したパケットのペイロードは通常のデータとして渡"
"される。"

#. type: Plain text
#: build/C/man2/recv.2:229
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> flag is set in the I<msghdr>.  After an error has been "
"passed, the pending socket error is regenerated based on the next queued "
"error and will be passed on the next socket operation."
msgstr "ローカルなエラーの場合はアドレスは渡されない (これは I<cmsghdr> の I<cmsg_len> メンバーでチェックできる)。受信エラーの場合は B<MSG_ERRQUIE> フラグが I<msghdr> にセットされる。エラーが渡された後には、キューに入っている次のエラーに基いて、処理待ちのソケットエラーが再生成され、次のソケット操作の際に渡される。"

#. type: TP
#: build/C/man2/recv.2:229 build/C/man2/recv.2:427 build/C/man2/send.2:249
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: build/C/man2/recv.2:236
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such protocols."
msgstr ""
"このフラグは、通常のデータストリームでは受信できない 帯域外 (out-of-band) "
"データの受信を要求する。 プロトコルによっては、 通常のデータキューの先頭に速"
"達データを置くものがあるが、 そのようなプロトコルではこのフラグは使用できな"
"い。"

#. type: TP
#: build/C/man2/recv.2:236
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr "B<MSG_PEEK>"

#. type: Plain text
#: build/C/man2/recv.2:243
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""
"このフラグを指定すると、 受信キューの最初のデータを返すとき、キューからデータ"
"を削除しない。 したがって、この後でもう一度受信コールを呼び出すと、同じデータ"
"が返ることになる。"

#. type: TP
#: build/C/man2/recv.2:243
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr "B<MSG_TRUNC> (Linux 2.2 以降)"

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: build/C/man2/recv.2:253
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""
"raw ソケット (B<AF_PACKET>)、 Internet datagram ソケット (Linux 2.4.27/2.6.8 "
"以降)、 netlink (Linux 2.6.22 以降) ソケット、 UNIX datagram ソケット (Linux "
"3.4 以降) の場合、パケットやデータグラムの長さが渡したバッファーよりも長かっ"
"た場合にも、 パケットやデータグラムの実際の長さを返す。"

#. type: Plain text
#: build/C/man2/recv.2:256
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr "Internet ストリームソケットでの利用については B<tcp>(7)  を参照。"

#. type: TP
#: build/C/man2/recv.2:256
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr "B<MSG_WAITALL> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:265
#, fuzzy
#| msgid ""
#| "This flag requests that the operation block until the full request is "
#| "satisfied.  However, the call may still return less data than requested "
#| "if a signal is caught, an error or disconnect occurs, or the next data to "
#| "be received is of a different type than that returned."
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned.  This flag has no effect "
"for datagram sockets."
msgstr ""
"このフラグは、要求した量いっぱいのデータが到着するまで、 操作を停止 (block) "
"するよう要求する。 但し、シグナルを受信したり、エラーや切断 (disconnect) が発"
"生したり、 次に受信されるデータが異なる型だったりした場合には、 要求した量よ"
"りデータが少なくても返ることがある。"

#. type: SS
#: build/C/man2/recv.2:265
#, no-wrap
msgid "recvfrom()"
msgstr "recvfrom()"

#. type: Plain text
#: build/C/man2/recv.2:271
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""
"B<recvfrom>() は受信したメッセージをバッファー I<buf> に格納する。 呼び出し元"
"はバッファーサイズを I<len> で指定しなければならない。"

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: build/C/man2/recv.2:299
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if "
"the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""
"I<src_addr> が NULL 以外で、下層のプロトコルからメッセージの送信元アドレスが"
"分かる場合、 この送信元アドレスが I<src_addr> が指すバッファーに格納される。 "
"この場合、 I<addrlen> は入出力両用の引数となる。 呼び出し前に、呼び出し元"
"は I<src_addr> に割り当てたバッファーの大きさで初期化しておくべきである。 "
"返ってくる時には、 I<addrlen> は送信元アドレスの実際の大きさに変更される。渡"
"されたバッファーが小さ過ぎる場合には、返されるアドレスの末尾は 切り詰められ"
"る。この場合には、 I<addrlen> では、呼び出し時に渡された値よりも大きな値が返"
"される。"

#. type: Plain text
#: build/C/man2/recv.2:306
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""
"呼び出し元が送信元アドレスを必要としない場合は、 I<src_addr> と I<addrlen> に"
"は NULL を指定すべきである。"

#. type: SS
#: build/C/man2/recv.2:306
#, no-wrap
msgid "recv()"
msgstr "recv()"

#. type: Plain text
#: build/C/man2/recv.2:314
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""
"B<recv>()  コールは通常 I<接続済みの (connected)> ソケットに対してのみ使用さ"
"れる (B<connect>(2) 参照)。次の呼び出しと等価である。"

#. type: Plain text
#: build/C/man2/recv.2:317
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0);\n"
msgstr "    recvfrom(fd, buf, len, flags, NULL, 0);\n"

#. type: SS
#: build/C/man2/recv.2:317
#, no-wrap
msgid "recvmsg()"
msgstr "recvmsg()"

#. type: Plain text
#: build/C/man2/recv.2:325
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""
"B<recvmsg>()  コールは、直接渡す引数の数を減らすために I<msghdr> 構造体を使"
"用する。この構造体は I<E<lt>sys/socket.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/recv.2:332
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:342
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags on received message */\n"
"};\n"
msgstr ""
"struct msghdr {\n"
"    void         *msg_name;       /* 追加のアドレス */\n"
"    socklen_t     msg_namelen;    /* アドレスのサイズ */\n"
"    struct iovec *msg_iov;        /* scatter/gather 配列 */\n"
"    size_t        msg_iovlen;     /* msg_iov の要素数 */\n"
"    void         *msg_control;    /* 補助データ (後述) */\n"
"    size_t        msg_controllen; /* 補助データバッファー長 */\n"
"    int           msg_flags;      /* 受信メッセージのフラグ */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:358
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_namelen> will contain the length of the "
"returned address.  If the application does not need to know the source "
"address, I<msg_name> can be specified as NULL."
msgstr ""
"フィールド I<msg_name> は、 ソケットが接続されていない場合に送信元アドレスを"
"返すのに使用されるバッファーを指す。 このバッファーは呼び出し元が確保する。 "
"呼び出し元は呼び出し前に I<msg_namelen> にこのバッファーの大きさを設定しなけ"
"ればならない。 呼び出しが成功した場合、呼び出しから返って来た際には "
"I<msg_namelen> には返されるアドレスの長さが入っている。 アプリケーションが送"
"信元アドレスを知る必要がない場合には、 I<msg_name> に NULL を指定することがで"
"きる。"

#. type: Plain text
#: build/C/man2/recv.2:365
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""
"I<msg_iov> と I<msg_iovlen> フィールドは scatter-gather 用の場所を指定する。 "
"B<readv>(2) に説明がある。"

#. type: Plain text
#: build/C/man2/recv.2:380
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""
"I<msg_control> フィールドは I<msg_controllen> の長さを持ち、他のプロトコル制"
"御メッセージや 種々の補助データのためのバッファーへのポインターである。 "
"B<recvmsg>()  を呼ぶ際には、 I<msg_controllen> に I<msg_control> のバッファー"
"の長さを入れておく必要がある。 コールが成功して返った場合、制御メッセージ列の"
"長さが入っている。"

#. type: Plain text
#: build/C/man2/recv.2:382
msgid "The messages are of the form:"
msgstr "メッセージの形式は以下の通り:"

#. type: Plain text
#: build/C/man2/recv.2:393
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:398
msgid ""
"Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""
"補助データは、 B<cmsg>(3)  に定義されたマクロ経由でのみアクセスすべきである。"

#. type: Plain text
#: build/C/man2/recv.2:406
#, fuzzy
#| msgid ""
#| "As an example, Linux uses this ancillary data mechanism to pass extended "
#| "errors, IP options, or file descriptors over UNIX domain sockets."
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets.  For "
"further information on the use of ancillary data in various socket domains, "
"see B<unix>(7)  and B<ip>(7)."
msgstr ""
"例をあげると、 Linux はこの補助データのメカニズムを、 UNIX ドメインソケット上"
"での拡張エラーや IP オプション、 ファイルディスクリプターの受け渡しに利用して"
"いる。"

#. type: Plain text
#: build/C/man2/recv.2:414
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""
"I<msghdr> の I<msg_flags> フィールドは B<recvmsg>()  からのリターン時に設定さ"
"れる。ここにはいくつかのフラグが入る。"

#. type: TP
#: build/C/man2/recv.2:414
#, no-wrap
msgid "B<MSG_EOR>"
msgstr "B<MSG_EOR>"

#. type: Plain text
#: build/C/man2/recv.2:419
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""
"これはレコードの終り (end-of-record) を示し、 返されたデータが完全なレコード"
"であることを示す (一般的には B<SOCK_SEQPACKET> 型のソケットで使用される)。"

#. type: TP
#: build/C/man2/recv.2:419
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr "B<MSG_TRUNC>"

#. type: Plain text
#: build/C/man2/recv.2:423
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""
"データグラムが与えられたバッファーより大きかったために、 データグラムのはみ出"
"した部分が捨てられたことを示す。"

#. type: TP
#: build/C/man2/recv.2:423
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr "B<MSG_CTRUNC>"

#. type: Plain text
#: build/C/man2/recv.2:427
msgid ""
"indicates that some control data was discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""
"補助データのためのバッファーが不足したために、 制御データの一部が捨てられたこ"
"とを示す。"

#. type: Plain text
#: build/C/man2/recv.2:430
msgid ""
"is returned to indicate that expedited or out-of-band data was received."
msgstr "速達データや帯域外データを受信したことを示す。"

#. type: TP
#: build/C/man2/recv.2:430
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr "B<MSG_ERRQUEUE>"

#. type: Plain text
#: build/C/man2/recv.2:434
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""
"データは受信しなかったが ソケットのエラーキューから拡張エラーを受信したことを"
"示す。"

#. type: Plain text
#: build/C/man2/recv.2:440
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  In the event of an error, I<errno> is set to indicate the error."
msgstr ""
"これらのコールは受信したバイト数を返す。 エラーの場合は -1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/recv.2:443
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""
"ストリームソケットの接続相手が正しくシャットダウンを実行した場合は、\n"
"返り値は 0 (昔ながらの \"end-of-file\" の戻り値) となる。"

#. type: Plain text
#: build/C/man2/recv.2:447
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""
"いくつかのドメインのデータグラムソケット (UNIX ドメインやインターネットドメイ"
"ンなど) では、長さ 0 のデータグラムが送信できる。 このようなデータグラムを受"
"信した場合、 返り値は 0 となる。"

#. type: Plain text
#: build/C/man2/recv.2:450
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive "
"from a stream socket was 0."
msgstr ""
"ストリームソケットに対する受信要求バイト数が 0 だった場合も、 値 0 が返され"
"る。"

#. type: Plain text
#: build/C/man2/recv.2:455
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""
"これらはソケット層で発生する一般的なエラーである。 他のエラーが下層のプロトコ"
"ルモジュールで生成され、 返されるかもしれない。 それらのマニュアルを参照する"
"こと。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/recv.2:464
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1 allows either error to be returned for this case, and "
"does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr "ソケットが非停止 (nonblocking) に設定されていて 受信操作が停止するような状況になったか、 受信に時間切れ (timeout) が設定されていて データを受信する前に時間切れになった。 POSIX.1 は、この場合にどちらのエラーを返すことも認めており、 これら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性が必要なアプリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/recv.2:469
msgid "The argument I<sockfd> is an invalid file descriptor."
msgstr "引数 I<sockfd> が不正なファイルディスクリプターである。"

#. type: Plain text
#: build/C/man2/recv.2:473
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""
"リモートのホストでネットワーク接続が拒否された (よくある理由としては、要求し"
"たサービスが起動されていないなどがある)。"

#. type: Plain text
#: build/C/man2/recv.2:477
msgid ""
"The receive buffer pointer(s) point outside the process's address space."
msgstr "受信バッファーへのポインターがプロセスのアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/recv.2:482
msgid ""
"The receive was interrupted by delivery of a signal before any data was "
"available; see B<signal>(7)."
msgstr ""
"データを受信する前に、シグナルが配送されて割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/recv.2:486 build/C/man2/send.2:383
msgid "Invalid argument passed."
msgstr "不正な引数が渡された。"

#. type: Plain text
#: build/C/man2/recv.2:490
msgid "Could not allocate memory for B<recvmsg>()."
msgstr "B<recvmsg>()  のためのメモリーが確保できなかった。"

#. type: TP
#: build/C/man2/recv.2:490 build/C/man2/send.2:406 build/C/man7/vsock.7:202
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: build/C/man2/recv.2:497
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""
"ソケットに接続指向プロトコルが割り当てられており、 まだ接続されていない "
"(B<connect>(2)  と B<accept>(2)  を参照のこと)。"

#. type: Plain text
#: build/C/man2/recv.2:505
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.4BSD (これらのインターフェースは 4.2BSD で初めて実装された)"

#. type: Plain text
#: build/C/man2/recv.2:512
msgid ""
"POSIX.1 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> flags."
msgstr "POSIX.1 では、 B<MSG_OOB>, B<MSG_PEEK>, B<MSG_WAITALL> フラグだけが記載されている。"

#. type: Plain text
#: build/C/man2/recv.2:525
msgid ""
"If a zero-length datagram is pending, B<read>(2)  and B<recv>()  with a "
"I<flags> argument of zero provide different behavior.  In this circumstance, "
"B<read>(2)  has no effect (the datagram remains pending), while B<recv>()  "
"consumes the pending datagram."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:531
msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgstr "I<socklen_t> 型は POSIX で発案された。 B<accept>(2) も参照。"

#.  POSIX.1-2001, POSIX.1-2008
#.  glibc bug for msg_controllen raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type these fields varies
#.  across architectures, but socklen_t is always 32 bits,
#.  as (at least with GCC) is int.
#. type: Plain text
#: build/C/man2/recv.2:552
#, fuzzy
#| msgid ""
#| "According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
#| "structure should be typed as I<socklen_t>, but glibc currently types it "
#| "as I<size_t>."
msgid ""
"According to POSIX.1, the I<msg_controllen> field of the I<msghdr> structure "
"should be typed as I<socklen_t>, and the I<msg_iovlen> field should be typed "
"as I<int>, but glibc currently types both as I<size_t>."
msgstr ""
"POSIX.1-2001 では、構造体 I<msghdr> のフィールド I<msg_controllen> は "
"I<socklen_t> 型であるべきだとされているが、 現在の glibc では I<size_t> 型で"
"ある。"

#. type: Plain text
#: build/C/man2/recv.2:557
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""
"B<recvmmsg>(2)  には、一度の呼び出しでの複数のデータグラムに使用できる Linux "
"固有の システムコールに関する情報が書かれている。"

#. type: Plain text
#: build/C/man2/recv.2:562
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr "B<recvfrom>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/recv.2:578
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr "B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: build/C/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr "RECVMMSG"

#. type: Plain text
#: build/C/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr "recvmmsg - 複数のメッセージをソケットから受信する"

#. type: Plain text
#: build/C/man2/recvmmsg.2:38 build/C/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:42
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:54
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""
"B<recvmmsg>() システムコールは B<recvmsg>(2) の拡張で、 このシステムコールを"
"使うと一度の呼び出しでソケットから複数のメッセージを受信することができる (ア"
"プリケーションによっては性能上のメリットがある)。 他に B<recvmsg>(2) から拡張"
"されている点としては、受信操作におけるタイムアウトのサポートがある。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:58
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""
"I<sockfd> 引数は、データを受信するソケットのファイルディスクリプターであ"
"る。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:66 build/C/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""
"I<msgvec> 引数は I<mmsghdr> 構造体の配列である。 この配列の大きさは "
"I<vlen> で指定する。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:72 build/C/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""
"I<mmsghdr> 構造体は I<E<lt>sys/socket.hE<gt>> で次のように定義されている。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:79
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* メッセージヘッダー */\n"
"    unsigned int  msg_len;  /* このヘッダーで受信されたバイト数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:94
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""
"I<msg_hdr> フィールドは、 B<recvmsg>(2) で説明されている I<msghdr> 構造体であ"
"る。 I<msg_len> フィールドは、 このエントリーで返されるメッセージのバイト数"
"で、 このヘッダーに対して B<recvmsg>(2) を呼び出した場合の返り値と同じ値が入"
"る。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:101
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""
"I<flags> 引数には複数のフラグを論理和 (OR) で指定できる。 フラグは、 "
"B<recvmsg>(2) で説明されているものに加えて、以下が使用できる。"

#. type: TP
#: build/C/man2/recvmmsg.2:101
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr "B<MSG_WAITFORONE> (Linux 2.6.34 以降)"

#. type: Plain text
#: build/C/man2/recvmmsg.2:106
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr "最初のメッセージを受信後に B<MSG_DONTWAIT> を有効にする。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:121
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""
"I<timeout> 引数は I<struct timespec> (B<clock_gettime>(2) 参照) へのポイン"
"ターで、 この構造体で受信操作のタイムアウト (秒とナノ秒) を指定する (I<ただ"
"し、バグを参照のこと>) (待ち時間はシステムクロックの粒度に切り上げられ、カー"
"ネルのスケジューリング遅延により少しだけ長くなる可能性がある)。 I<timeout>が "
"NULL の場合、 受信操作は無期限に停止 (block) する。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:132
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""
"停止 (blocking) モードの B<recvmmsg>() の呼び出しは、 I<vlen> 個のメッセージ"
"を受信するか、タイムアウトが満了するまで停止する。 非停止 (nonblocking) モー"
"ドの呼び出しでは、 読み出し可能なメッセージ (最大で I<vlen> 個) を読み出し、 "
"すぐに返る。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:147
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""
"B<recvmmsg>() が返った際には、 I<msgvec> のうちデータが受信された要素には、受"
"信したそれぞれのメッセージの情報が格納されている。 また、 I<msg_len> には受信"
"したメッセージの大きさが入り、 I<msg_hdr> の各フィールドは B<recvmsg>(2) に書"
"かれている通りに更新される。 呼び出しの返り値は、更新された I<msgvec> の要素"
"数である。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:155
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"成功すると、 B<recvmmsg>() は I<msgvec> に受信されたメッセージ数を返す。 エ"
"ラーの場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:159
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can occur:"
msgstr ""
"エラーは B<recvmsg>(2) と同じである。 これに加えて、以下のエラーが起こる場合"
"がある。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:163
msgid "I<timeout> is invalid."
msgstr "I<timeout> が無効である。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:165
msgid "See also BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""
"B<recvmmsg>() システムコールは Linux 2.6.33 で追加された。 glibc でのサポート"
"はバージョン 2.12 以降で利用可能である。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr "B<recvmmsg>() は Linux 固有である。"

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: build/C/man2/recvmmsg.2:184
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""
"I<timeout> 引数は意図した通りには動作しない。 タイムアウトは各データグラム"
"の受信後にのみチェックされる。 そのため、 タイムアウトが満了する前に "
"I<vlen-1> 個のデータグラムを受信し、 その後全くデータグラムを受信しなかった場"
"合、 呼び出しはずっと停止し続けてしまう。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:192
msgid ""
"If an error occurs after at least one message has been received, the call "
"succeeds, and returns the number of messages received.  The error code is "
"expected to be returned on a subsequent call to B<recvmmsg>().  In the "
"current implementation, however, the error code can be overwritten in the "
"meantime by an unrelated network event on a socket, for example an incoming "
"ICMP packet."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:199
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers "
"are filled or if the timeout specified has expired."
msgstr ""
"以下のプログラムは、 B<recvmmsg>() を使って複数のメッセージをソケットから受信"
"し、それらを複数のバッファーに格納する。 呼び出しは、すべてのバッファーにメッ"
"セージが格納されるか、 指定したタイムアウト時間が経過すると返る。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:202
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""
"以下のコマンドは、 ランダムな数字が入った UDP データグラムを定期的に生成す"
"る。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:207
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234;>\n"
"B<sleep 0.25; done>\n"
msgstr ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234;>\n"
"B<sleep 0.25; done>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:212
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr ""
"生成されたデータグラムをサンプルアプリケーションが読み出し、以下のような出力"
"が得られる。"

#. type: Plain text
#: build/C/man2/recvmmsg.2:222
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:233
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:246
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:252 build/C/man2/sendmmsg.2:210
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:260
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:268
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (int i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (int i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:271
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:277
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:285
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (int i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (int i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:293
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man2/select.2:40
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: Plain text
#: build/C/man2/select.2:44
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr "select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - 同期 I/O の多重化"

#. type: Plain text
#: build/C/man2/select.2:47
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/select.2:50
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:55
#, no-wrap
msgid ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:59
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:64 build/C/man3/sockatmark.3:36
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/select.2:68
msgid "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/select.2:79
msgid ""
"B<select>()  allows a program to monitor multiple file descriptors, waiting "
"until one or more of the file descriptors become \"ready\" for some class of "
"I/O operation (e.g., input possible).  A file descriptor is considered ready "
"if it is possible to perform a corresponding I/O operation (e.g., "
"B<read>(2), or a sufficiently small B<write>(2))  without blocking."
msgstr "B<select>() を使うと、プログラムで複数のファイルディスクリプターを監視し、 一つ以上のファイルディスクリプターがある種の I/O 操作の 「ready (準備ができた)」状態 (例えば、読み込み可能になった状態)  になるまで待つことができる。 ファイルディスクリプターが ready (準備ができた) とは、 (B<read>(2) や十分小さな B<write>(2) などの) 対応する I/O 操作が停止 (block) なしに実行できる状態にあることを意味する。"

#. type: Plain text
#: build/C/man2/select.2:89
msgid ""
"B<select>()  can monitor only file descriptors numbers that are less than "
"B<FD_SETSIZE>; B<poll>(2)  and B<epoll>(7)  do not have this limitation.  "
"See BUGS."
msgstr ""

#. type: SS
#: build/C/man2/select.2:89
#, fuzzy, no-wrap
#| msgid "a file descriptor becomes ready;"
msgid "File descriptor sets"
msgstr "ファイルディスクリプターが利用可能になる。"

#. type: Plain text
#: build/C/man2/select.2:100
msgid ""
"The principal arguments of B<select>()  are three \"sets\" of file "
"descriptors (declared with the type I<fd_set>), which allow the caller to "
"wait for three classes of events on the specified set of file descriptors.  "
"Each of the I<fd_set> arguments may be specified as NULL if no file "
"descriptors are to be watched for the corresponding class of events."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:113
msgid ""
"B<Note well>: Upon return, each of the file descriptor sets is modified in "
"place to indicate which file descriptors are currently \"ready\".  Thus, if "
"using B<select>()  within a loop, the sets I<must be reinitialized> before "
"each call.  The implementation of the I<fd_set> arguments as value-result "
"arguments is a design error that is avoided in B<poll>(2)  and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:116
msgid ""
"The contents of a file descriptor set can be manipulated using the following "
"macros:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:116
#, no-wrap
msgid "B<FD_ZERO>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:121
msgid ""
"This macro clears (removes all file descriptors from)  I<set>.  It should be "
"employed as the first step in initializing a file descriptor set."
msgstr ""

#. type: TP
#: build/C/man2/select.2:121
#, no-wrap
msgid "B<FD_SET>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:129
msgid ""
"This macro adds the file descriptor I<fd> to I<set>.  Adding a file "
"descriptor that is already present in the set is a no-op, and does not "
"produce an error."
msgstr ""

#. type: TP
#: build/C/man2/select.2:129
#, no-wrap
msgid "B<FD_CLR>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:137
msgid ""
"This macro removes the file descriptor I<fd> from I<set>.  Removing a file "
"descriptor that is not present in the set is a no-op, and does not produce "
"an error."
msgstr ""

#. type: TP
#: build/C/man2/select.2:137
#, no-wrap
msgid "B<FD_ISSET>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:155
msgid ""
"B<select>()  modifies the contents of the sets according to the rules "
"described below.  After calling B<select>(), the B<FD_ISSET>()  macro can be "
"used to test if a file descriptor is still present in a set.  B<FD_ISSET>()  "
"returns nonzero if the file descriptor I<fd> is present in I<set>, and zero "
"if it is not."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:159
msgid "The arguments of B<select>()  are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:159
#, no-wrap
msgid "I<readfds>"
msgstr "I<readfds>"

#. type: Plain text
#: build/C/man2/select.2:165
msgid ""
"The file descriptors in this set are watched to see if they are ready for "
"reading.  A file descriptor is ready for reading if a read operation will "
"not block; in particular, a file descriptor is also ready on end-of-file."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:170
#, fuzzy
#| msgid ""
#| "This set is watched to see if data is available for reading from any of "
#| "its file descriptors.  After B<select>()  has returned, I<readfds> will "
#| "be cleared of all file descriptors except for those that are immediately "
#| "available for reading."
msgid ""
"After B<select>()  has returned, I<readfds> will be cleared of all file "
"descriptors except for those that are ready for reading."
msgstr ""
"この集合に含まれるいずれかのファイルディスクリプターで、 データの読み込みが可"
"能になったかどうかを監視する。 B<select>()  から戻る時に、I<readfds> のう"
"ち、 直ちに読み込み可能なファイルディスクリプター以外は 集合から削除される。"

#. type: TP
#: build/C/man2/select.2:170
#, no-wrap
msgid "I<writefds>"
msgstr "I<writefds>"

#. type: Plain text
#: build/C/man2/select.2:177
msgid ""
"The file descriptors in this set are watched to see if they are ready for "
"writing.  A file descriptor is ready for writing if a write operation will "
"not block.  However, even if a file descriptor indicates as writable, a "
"large write may still block."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:182
msgid ""
"After B<select>()  has returned, I<writefds> will be cleared of all file "
"descriptors except for those that are ready for writing."
msgstr "B<select>() から戻る時に、I<writefds> のうち、 書き込みの準備ができたファイルディスクリプター以外は集合から削除される。"

#. type: TP
#: build/C/man2/select.2:182
#, no-wrap
msgid "I<exceptfds>"
msgstr "I<exceptfds>"

#. type: Plain text
#: build/C/man2/select.2:189
msgid ""
"The file descriptors in this set are watched for \"exceptional conditions"
"\".  For examples of some exceptional conditions, see the discussion of "
"B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:195
msgid ""
"After B<select>()  has returned, I<exceptfds> will be cleared of all file "
"descriptors except for those for which an exceptional condition has occurred."
msgstr ""

#. type: TP
#: build/C/man2/select.2:195
#, no-wrap
msgid "I<nfds>"
msgstr "I<nfds>"

#. type: Plain text
#: build/C/man2/select.2:201
msgid ""
"This argument should be set to the highest-numbered file descriptor in any "
"of the three sets, plus 1.  The indicated file descriptors in each set are "
"checked, up to this limit (but see BUGS)."
msgstr ""

#. type: TP
#: build/C/man2/select.2:201
#, no-wrap
msgid "I<timeout>"
msgstr "I<timeout>"

#. type: Plain text
#: build/C/man2/select.2:211
#, fuzzy
#| msgid ""
#| "The I<timeout> argument specifies the interval that B<select>()  should "
#| "block waiting for a file descriptor to become ready.  The call will block "
#| "until either:"
msgid ""
"The I<timeout> argument is a I<timeval> structure (shown below) that "
"specifies the interval that B<select>()  should block waiting for a file "
"descriptor to become ready.  The call will block until either:"
msgstr ""
"I<timeout> 引数は、 B<select>() がファイルディスクリプターが ready になるの"
"を待って停止する時間を指定する。 呼び出しは以下のいずれかになるまで停止する。"

#. type: IP
#: build/C/man2/select.2:212 build/C/man2/select.2:214
#: build/C/man2/select.2:216 build/C/man2/select.2:250
#: build/C/man2/select.2:259 build/C/man2/select.2:266
#: build/C/man7/bpf-helpers.7:225 build/C/man7/bpf-helpers.7:227
#: build/C/man7/bpf-helpers.7:229 build/C/man7/bpf-helpers.7:232
#: build/C/man7/bpf-helpers.7:239 build/C/man7/bpf-helpers.7:241
#: build/C/man7/bpf-helpers.7:244 build/C/man7/bpf-helpers.7:783
#: build/C/man7/bpf-helpers.7:785 build/C/man7/bpf-helpers.7:787
#: build/C/man7/bpf-helpers.7:883 build/C/man7/bpf-helpers.7:886
#: build/C/man7/bpf-helpers.7:889 build/C/man7/bpf-helpers.7:1016
#: build/C/man7/bpf-helpers.7:1018 build/C/man7/bpf-helpers.7:1020
#: build/C/man7/bpf-helpers.7:1086 build/C/man7/bpf-helpers.7:1088
#: build/C/man7/bpf-helpers.7:1090 build/C/man7/bpf-helpers.7:1339
#: build/C/man7/bpf-helpers.7:1341 build/C/man7/bpf-helpers.7:1349
#: build/C/man7/bpf-helpers.7:1354 build/C/man7/bpf-helpers.7:1360
#: build/C/man7/bpf-helpers.7:1362 build/C/man7/bpf-helpers.7:1381
#: build/C/man7/bpf-helpers.7:1388 build/C/man7/bpf-helpers.7:1391
#: build/C/man7/bpf-helpers.7:1398 build/C/man7/bpf-helpers.7:1401
#: build/C/man7/bpf-helpers.7:1406 build/C/man7/bpf-helpers.7:1410
#: build/C/man7/bpf-helpers.7:1611 build/C/man7/bpf-helpers.7:1613
#: build/C/man7/bpf-helpers.7:1621 build/C/man7/bpf-helpers.7:1624
#: build/C/man7/bpf-helpers.7:1626 build/C/man7/bpf-helpers.7:1683
#: build/C/man7/bpf-helpers.7:1685 build/C/man7/bpf-helpers.7:1687
#: build/C/man7/bpf-helpers.7:1689 build/C/man7/bpf-helpers.7:1705
#: build/C/man7/bpf-helpers.7:1707 build/C/man7/bpf-helpers.7:1709
#: build/C/man7/bpf-helpers.7:1711 build/C/man7/bpf-helpers.7:1713
#: build/C/man7/bpf-helpers.7:1751 build/C/man7/bpf-helpers.7:1755
#: build/C/man7/bpf-helpers.7:2005 build/C/man7/bpf-helpers.7:2007
#: build/C/man7/bpf-helpers.7:2009 build/C/man7/bpf-helpers.7:2541
#: build/C/man7/bpf-helpers.7:2545 build/C/man7/bpf-helpers.7:2547
#: build/C/man7/bpf-helpers.7:2550 build/C/man7/bpf-helpers.7:2552
#: build/C/man7/bpf-helpers.7:2555 build/C/man7/bpf-helpers.7:2558
#: build/C/man7/bpf-helpers.7:2561 build/C/man7/bpf-helpers.7:2566
#: build/C/man7/bpf-helpers.7:2571 build/C/man7/bpf-helpers.7:2574
#: build/C/man7/bpf-helpers.7:2577 build/C/man7/bpf-helpers.7:2580
#: build/C/man7/bpf-helpers.7:2583 build/C/man7/bpf-helpers.7:2585
#: build/C/man7/bpf-helpers.7:2589 build/C/man7/bpf-helpers.7:3249
#: build/C/man7/bpf-helpers.7:3253 build/C/man7/bpf-helpers.7:3264
#: build/C/man7/bpf-helpers.7:3267 build/C/man7/bpf-helpers.7:3271
#: build/C/man7/bpf-helpers.7:3273 build/C/man7/bpf-helpers.7:3277
#: build/C/man7/bpf-helpers.7:3442 build/C/man7/bpf-helpers.7:3444
#: build/C/man7/bpf-helpers.7:3446 build/C/man7/bpf-helpers.7:3448
#: build/C/man7/bpf-helpers.7:3481 build/C/man7/bpf-helpers.7:3484
#: build/C/man7/bpf-helpers.7:3487 build/C/man7/bpf-helpers.7:3490
#: build/C/man7/bpf-helpers.7:3600 build/C/man7/bpf-helpers.7:3602
#: build/C/man7/bpf-helpers.7:3636 build/C/man7/bpf-helpers.7:3640
#: build/C/man7/bpf-helpers.7:3643 build/C/man7/bpf-helpers.7:3646
#: build/C/man7/bpf-helpers.7:3649 build/C/man7/bpf-helpers.7:3652
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:214
msgid "a file descriptor becomes ready;"
msgstr "ファイルディスクリプターが利用可能になる。"

#. type: Plain text
#: build/C/man2/select.2:216
msgid "the call is interrupted by a signal handler; or"
msgstr "システムコールがシグナルハンドラーにより割り込まれた。"

#. type: Plain text
#: build/C/man2/select.2:218
msgid "the timeout expires."
msgstr "タイムアウト時間が満了した。"

#. type: Plain text
#: build/C/man2/select.2:225
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount."
msgstr "この I<timeout> 時間はシステムクロックの粒度に切り上げられ、カーネルのスケジューリング遅延により少しだけ長くなる可能性がある点に注意すること。"

#. type: Plain text
#: build/C/man2/select.2:232
msgid ""
"If both fields of the I<timeval> structure are zero, then B<select>()  "
"returns immediately.  (This is useful for polling.)"
msgstr " I<timeval> 構造体の両方のフィールドが 0 の場合、 B<select>() はすぐに復帰する (この機能はポーリング (polling) を行うのに便利である)。"

#. type: Plain text
#: build/C/man2/select.2:239
msgid ""
"If I<timeout> is specified as NULL, B<select>()  blocks indefinitely waiting "
"for a file descriptor to become ready."
msgstr " I<timeout> に NULL (タイムアウトなし) が指定されると、 B<select>() はファイルディスクリプターが ready になるまで無期限に停止 (block) する。"

#. type: SS
#: build/C/man2/select.2:239
#, no-wrap
msgid "pselect()"
msgstr "pselect()"

#. type: Plain text
#: build/C/man2/select.2:244
msgid ""
"The B<pselect>()  system call allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:250
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""
"B<select>()  と B<pselect>()  の動作は同じであるが、以下の 3 点が異なる:"

#. type: Plain text
#: build/C/man2/select.2:259
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""
"B<select>()  では、タイムアウト時間の指定に構造体 I<struct timeval> (秒・マイ"
"クロ秒単位) を用いる。 一方、 B<pselect>()  関数では、構造体 I<struct "
"timespec> (秒・ナノ秒単位) を用いる。"

#. type: Plain text
#: build/C/man2/select.2:266
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""
"B<select>()  は残り時間を示す I<timeout> 引数を更新することがある。 "
"B<pselect>()  はこの引数を変更しない。"

#. type: Plain text
#: build/C/man2/select.2:274
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""
"B<select>()  は I<sigmask> 引数を持たない。その動作は I<sigmask> に NULL を"
"指定した場合の B<pselect>()  と同じである。"

#. type: Plain text
#: build/C/man2/select.2:290
#, fuzzy
#| msgid ""
#| "I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it "
#| "is not NULL, then B<pselect>()  first replaces the current signal mask by "
#| "the one pointed to by I<sigmask>, then does the \"select\" function, and "
#| "then restores the original signal mask."
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask.  (If I<sigmask> is NULL, the signal mask "
"is not modified during the B<pselect>()  call.)"
msgstr ""
"I<sigmask> は、シグナルマスク (B<sigprocmask>(2)  を参照) へのポインターであ"
"る。 I<sigmask> が NULL でない場合、 B<pselect>()  は I<sigmask> が指している"
"シグナルマスクで現在のシグナルマスクを置き換えてから、 \"select\" 関数を実行"
"し、 終了後にシグナルマスクを元のシグナルマスクに戻す。"

#. type: Plain text
#: build/C/man2/select.2:296
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""
"I<timeout> 引数の精度の違いを除くと、以下の B<pselect>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/select.2:301
#, no-wrap
msgid ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"
msgstr ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"

#. type: Plain text
#: build/C/man2/select.2:307
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "次のコールを I<atomic> に実行するのと等価である。"

#. type: Plain text
#: build/C/man2/select.2:311
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr "sigset_t origmask;\n"

#. type: Plain text
#: build/C/man2/select.2:315
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/select.2:337
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""
"B<pselect>()  が必要になる理由は、シグナルやファイルディスクリプターの状態変"
"化を 待ちたいときには、競合状態を避けるために atomic なテストが必要になる か"
"らである。 (シグナルハンドラーが大域フラグを設定して戻る場合を考えてみよう。 "
"この大域フラグのテストに続けて B<select>()  を呼び出すと、 シグナルがテストの"
"直後かつ呼び出しの直前に届いた時には B<select>()  は永久にハングしてしまうか"
"もしれない。 一方、 B<pselect>()  を使うと、まずシグナルを禁止 (block) して、"
"入ってくるシグナルを操作し、 望みの I<sigmask> で B<pselect>()  を呼び出すこ"
"とで、前記の競合を避けることができる。)"

#. type: SS
#: build/C/man2/select.2:337
#, no-wrap
msgid "The timeout"
msgstr "タイムアウト"

#. type: Plain text
#: build/C/man2/select.2:343
#, fuzzy
#| msgid ""
#| "The I<flags> argument is formed by ORing one or more of the following "
#| "values:"
msgid ""
"The I<timeout> argument for B<select>()  is a structure of the following "
"type:"
msgstr ""
"I<flags> 引数には、以下の値を 1つ以上、ビット単位の論理和 を取ったものを指"
"定する:"

#. type: Plain text
#: build/C/man2/select.2:350
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t      tv_sec;         /* 秒 */\n"
"    suseconds_t tv_usec;        /* マイクロ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/select.2:356
msgid "The corresponding argument for B<pselect>()  has the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:363
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    long        tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t      tv_sec;         /* 秒 */\n"
"    long        tv_nsec;        /* ナノ秒 */\n"
"};\n"

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: build/C/man2/select.2:388
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1 permits either "
"behavior.)  This causes problems both when Linux code which reads I<timeout> "
"is ported to other operating systems, and when code is ported to Linux that "
"reuses a I<struct timeval> for multiple B<select>()s in a loop without "
"reinitializing it.  Consider I<timeout> to be undefined after B<select>()  "
"returns."
msgstr "Linux では、 B<select>()  は I<timeout> を変更し、残りの停止時間を反映するようになっているが、 他のほとんどの実装ではこのようになっていない (POSIX.1 はどちらの動作も認めている)。 このため、 I<timeout> を参照している Linux のコードを他のオペレーティングシステムへ 移植する場合、問題が起こる。 また、ループの中で I<timeval> 構造体を初期化せずにそのまま再利用して B<select>()  を複数回行なっているコードを Linux へ移植する場合にも、問題が起こる。 B<select>()  から復帰した後は I<timeout> は未定義であると考えるべきである。"

#. type: Plain text
#: build/C/man2/select.2:400
#, fuzzy
#| msgid ""
#| "On success, B<select>()  and B<pselect>()  return the number of file "
#| "descriptors contained in the three returned descriptor sets (that is, the "
#| "total number of bits that are set in I<readfds>, I<writefds>, "
#| "I<exceptfds>)  which may be zero if the timeout expires before anything "
#| "interesting happens.  On error, -1 is returned, and I<errno> is set to "
#| "indicate the error; the file descriptor sets are unmodified, and "
#| "I<timeout> becomes undefined."
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, "
"I<exceptfds>).  The return value may be zero if the timeout expired before "
"any file descriptors became ready."
msgstr ""
"成功した場合、 B<select>()  と B<pselect>()  は更新された 3 つのディスクリプ"
"ター集合に含まれている ファイルディスクリプターの数 (つまり、 I<readfds>, "
"I<writefds>, I<exceptfds> 中の 1 になっているビットの総数) を返す。 何も起こ"
"らずに時間切れになった場合、 ディスクリプターの数は 0 になることもある。 エ"
"ラーならば -1 を返し、 I<errno> にエラーを示す値が設定される; ファイルディス"
"クリプター集合は変更されず、 I<timeout> は不定となる。"

#. type: Plain text
#: build/C/man2/select.2:408
#, fuzzy
#| msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgid ""
"On error, -1 is returned, and I<errno> is set to indicate the error; the "
"file descriptor sets are unmodified, and I<timeout> becomes undefined."
msgstr "エラーの場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/select.2:415
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)  "
"However, see BUGS."
msgstr "いずれかの集合に無効なファイルディスクリプターが指定された (おそらくは、すでにクローズされたファイルディスクリプターか、 エラーが発生したファイルディスクリプターが指定された)。ただし、「バグ」を参照のこと。"

#. type: Plain text
#: build/C/man2/select.2:419
msgid "A signal was caught; see B<signal>(7)."
msgstr "シグナルを受信した。"

#. type: Plain text
#: build/C/man2/select.2:426
msgid ""
"I<nfds> is negative or exceeds the B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""
"I<nfds> が負、 またはリソース上限 B<RLIMIT_NOFILE> (B<getrlimit>(2) 参照) よ"
"り大きい。"

#. type: Plain text
#: build/C/man2/select.2:431
msgid "The value contained within I<timeout> is invalid."
msgstr "I<timeout> に入っている値が不正である。"

#. type: Plain text
#: build/C/man2/select.2:434
msgid "Unable to allocate memory for internal tables."
msgstr "内部テーブルにメモリーを割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/select.2:440
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""
"B<pselect>()  はカーネル 2.6.16 で Linux に追加された。 それ以前は、 "
"B<pselect>()  は glibc でエミュレートされていた (「バグ」の章を参照)。"

#. type: Plain text
#: build/C/man2/select.2:451
msgid ""
"B<select>()  conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD "
"(B<select>()  first appeared in 4.2BSD).  Generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants).  However, note that the System\\ V variant typically sets the "
"timeout variable before returning, but the BSD variant does not."
msgstr "B<select>()  は POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<select>()  は 4.2BSD で最初に登場した) に準拠する。 BSD ソケット層のクローンをサポートしている非 BSD システム (System\\ V 系も含む) との間でだいたい移植性がある。しかし System\\ V 系では たいがい timeout 変数を返る前にセットするが、 BSD 系ではそうでないので注意すること。"

#. type: Plain text
#: build/C/man2/select.2:455
msgid ""
"B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008."
msgstr "B<pselect>() は POSIX.1g および POSIX.1-2001, POSIX.1-2008 で定義されている。"

#. type: Plain text
#: build/C/man2/select.2:472
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"I<fd_set> は固定サイズのバッファーである。 負や B<FD_SETSIZE> 以上の値を持つ "
"I<fd> に対して B<FD_CLR>()  や B<FD_SET>()  を実行した場合、 どのような動作を"
"するかは定義されていない。 また、 POSIX では I<fd> は有効なファイルディスクリ"
"プターでなければならないと規定されている。"

#. type: Plain text
#: build/C/man2/select.2:480
#, fuzzy
#| msgid ""
#| "The operation of B<select>()  and B<pselect>()  is identical, other than "
#| "these three differences:"
msgid ""
"The operation of B<select>()  and B<pselect>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""
"B<select>()  と B<pselect>()  の動作は同じであるが、以下の 3 点が異なる:"

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: build/C/man2/select.2:498
msgid ""
"On some other UNIX systems, B<select>()  can fail with the error B<EAGAIN> "
"if the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX specifies this error for B<poll>(2), but not "
"for B<select>().  Portable programs may wish to check for B<EAGAIN> and "
"loop, just as with B<EINTR>."
msgstr ""

#. type: SS
#: build/C/man2/select.2:498
#, no-wrap
msgid "The self-pipe trick"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:512
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""
"B<pselect>() がないシステムにおいて、シグナルの捕捉を信頼性があり (移植\n"
"性も高い) 方法で行うには、 自己パイプ (self-pipe) という技を使うとよい。\n"
"この方法では、シグナルハンドラーはパイプへ 1 バイトのデータを書き込み、\n"
"同じパイプのもう一端をメインプログラムの B<select>() で監視する (一杯に\n"
"なったパイプへの書き込みや空のパイプから読み出しを行った際に起こるであ\n"
"ろう停止 (blocking) を避けるためには、パイプへの読み書きの際には 非停止\n"
"(nonblocking) I/O を使用するとよい)。"

#. type: SS
#: build/C/man2/select.2:512
#, no-wrap
msgid "Emulating usleep(3)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:523
#, fuzzy
#| msgid ""
#| "Some code calls B<select>()  with all three sets empty, I<nfds> zero, and "
#| "a non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
#| "precision."
msgid ""
"Before the advent of B<usleep>(3), some code employed a call to B<select>()  "
"with all three sets empty, I<nfds> zero, and a non-NULL I<timeout> as a "
"fairly portable way to sleep with subsecond precision."
msgstr ""
"秒単位以下の精度でスリープを実現する 移植性の高い方法として、 3 つの集合全て"
"を空、 I<nfds> を 0 、 I<timeout> を NULL でない値に設定して B<select>()  を"
"呼び出すという方法を使っているコードもある。"

#. type: SS
#: build/C/man2/select.2:523
#, no-wrap
msgid "Correspondence between select() and poll() notifications"
msgstr ""

#.  fs/select.c
#. type: Plain text
#: build/C/man2/select.2:533
msgid ""
"Within the Linux kernel source, we find the following definitions which show "
"the correspondence between the readable, writable, and exceptional condition "
"notifications of B<select>()  and the event notifications provided by "
"B<poll>(2)  and B<epoll>(7):"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:544
#, no-wrap
msgid ""
"#define POLLIN_SET  (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN |\n"
"                     EPOLLHUP | EPOLLERR)\n"
"                   /* Ready for reading */\n"
"#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT |\n"
"                     EPOLLERR)\n"
"                   /* Ready for writing */\n"
"#define POLLEX_SET  (EPOLLPRI)\n"
"                   /* Exceptional condition */\n"
msgstr ""

#. type: SS
#: build/C/man2/select.2:547
#, no-wrap
msgid "Multithreaded applications"
msgstr "マルチスレッドアプリケーション"

#. type: Plain text
#: build/C/man2/select.2:564
#, fuzzy
#| msgid ""
#| "If a file descriptor being monitored by B<select>()  is closed in another "
#| "thread, the result is unspecified.  On some UNIX systems, B<select>()  "
#| "unblocks and returns, with an indication that the file descriptor is "
#| "ready (a subsequent I/O operation will likely fail with an error, unless "
#| "another the file descriptor reopened between the time B<select>()  "
#| "returned and the I/O operations was performed).  On Linux (and some other "
#| "systems), closing the file descriptor in another thread has no effect on "
#| "B<select>().  In summary, any application that relies on a particular "
#| "behavior in this scenario must be considered buggy."
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"process reopens file descriptor between the time B<select>()  returned and "
"the I/O operation is performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""
"B<select>() で監視中のファイルディスクリプターが別のスレッドでクローズされた"
"場合、どのような結果になるかは規定されていない。いくつかの UNIX システムで"
"は、 B<select>() は停止 (block) せず、すぐ返り、ファイルディスクリプターが "
"ready だと報告される (B<select>() が返ってから I/O 操作が実行されるまでの間"
"に、 別のファイルディスクリプターが再度オープンされない限り、 それ以降の I/O "
"操作はおそらく失敗するだろう)。 Linux (や他のいくつかのシステム) では、 別の"
"スレッドでファイルディスクリプターがクローズされても B<select>() には影響を与"
"えない。 まとめると、このような場合に特定の動作に依存しているアプリケーション"
"は「バグっている」と考えなければならない。"

#. type: SS
#: build/C/man2/select.2:564
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/select.2:572
msgid ""
"The Linux kernel allows file descriptor sets of arbitrary size, determining "
"the length of the sets to be checked from the value of I<nfds>.  However, in "
"the glibc implementation, the I<fd_set> type is fixed in size.  See also "
"BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:580
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""
"このページで説明している B<pselect>() のインターフェースは、glibc に\n"
"実装されているものである。内部で呼び出される Linux のシステムコールは\n"
"B<pselect6>() という名前である。このシステムコールは glibc のラッパー\n"
"関数とは少し違った動作をする。"

#. type: Plain text
#: build/C/man2/select.2:595
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""
"Linux の B<pselect6>() システムコールは I<timeout> 引数を変更する。\n"
"しかし、glibc のラッパー関数は、システムコールに渡す timeout 引数と\n"
"してローカル変数を使うことでこの動作を隠蔽している。このため、glibc の\n"
"B<pselect>() 関数は I<timeout> 引数を変更しない。\n"
"これが POSIX.1-2001 が要求している動作である。"

#. type: Plain text
#: build/C/man2/select.2:601
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""
"B<pselect6>() システムコールの最後の引数は I<sigset_t\\ *> 型の\n"
"ポインターではなく、以下に示す構造体である。"

#. type: Plain text
#: build/C/man2/select.2:609
#, fuzzy, no-wrap
#| msgid ""
#| "struct {\n"
#| "    const sigset_t *ss;     /* Pointer to signal set */\n"
#| "    size_t          ss_len; /* Size (in bytes) of object pointed\n"
#| "                               to by 'ss' */\n"
#| "};\n"
msgid ""
"struct {\n"
"    const kernel_sigset_t *ss;   /* Pointer to signal set */\n"
"    size_t ss_len;               /* Size (in bytes) of object\n"
"                                    pointed to by \\(aqss\\(aq */\n"
"};\n"
msgstr ""
"struct {\n"
"    const sigset_t *ss;     /* シグナル集合へのポインター */\n"
"    size_t          ss_len; /* 'ss' が指すオブジェクトのサイズ\n"
"                               (バイト数) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/select.2:621
#, fuzzy
#| msgid ""
#| "This allows the system call to obtain both a pointer to the signal set "
#| "and its size, while allowing for the fact that most architectures support "
#| "a maximum of 6 arguments to a system call."
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call.  See B<sigprocmask>(2)  for a "
"discussion of the difference between the kernel and libc notion of the "
"signal set."
msgstr ""
"このようにすることで、ほとんどのアーキテクチャーがサポートしている\n"
"システムコールの引数が最大で 6 個という事実を満たしつつ、\n"
"B<pselect6>() システムコールがシグナル集合へのポインターとシグナル集合\n"
"のサイズの両方を取得することができるのである。"

#. type: SS
#: build/C/man2/select.2:621
#, no-wrap
msgid "Historical glibc details"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:627
msgid ""
"Glibc 2.0 provided an incorrect version of B<pselect>()  that did not take a "
"I<sigmask> argument."
msgstr "glibc 2.0 では、間違ったバージョンの B<pselect>() が提供されていた。このバージョンでは I<sigmask> 引数を取らなかった。"

#. type: Plain text
#: build/C/man2/select.2:635
msgid ""
"In glibc versions 2.1 to 2.2.1, one must define B<_GNU_SOURCE> in order to "
"obtain the declaration of B<pselect>()  from I<E<lt>sys/select.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:653
msgid ""
"POSIX allows an implementation to define an upper limit, advertised via the "
"constant B<FD_SETSIZE>, on the range of file descriptors that can be "
"specified in a file descriptor set.  The Linux kernel imposes no fixed "
"limit, but the glibc implementation makes I<fd_set> a fixed-size type, with "
"B<FD_SETSIZE> defined as 1024, and the B<FD_*>()  macros operating according "
"to that limit.  To monitor file descriptors greater than 1023, use "
"B<poll>(2)  or B<epoll>(7)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:665
msgid ""
"According to POSIX, B<select>()  should check all specified file descriptors "
"in the three file descriptor sets, up to the limit I<nfds-1>.  However, the "
"current implementation ignores any file descriptor in these sets that is "
"greater than the maximum file descriptor number that the process currently "
"has open.  According to POSIX, any such file descriptor that is specified in "
"one of the sets should result in the error B<EBADF>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:678
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""
"バージョン 2.1 以降の glibc では、 B<pselect>()  は B<sigprocmask>(2)  と "
"B<select>()  を使ってエミュレートされていた。 この実装にはきわどい競合条件に"
"おいて脆弱性が残っていた。 この競合条件における問題を防止するために "
"B<pselect>()  は設計されたのである。 最近のバージョンの glibc では、カーネル"
"がサポートしている場合には、 (競合が起こらない)  B<pselect>()  システムコール"
"が使用される。"

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: build/C/man2/select.2:694
msgid ""
"On Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has the wrong "
"checksum and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""
"Linux では、 B<select>()  がソケットファイルディスクリプターで \"読み込みの準"
"備ができた\" と報告した場合でも、 この後で read を行うと停止 (block) すること"
"がある。このような状況は、 例えば、データが到着したが、検査でチェックサム異常"
"が見つかり廃棄された時 などに起こりえる。他にもファイルディスクリプターが準備"
"できたと間違って 報告される状況が起こるかもしれない。 したがって、停止すべき"
"ではないソケットに対しては B<O_NONBLOCK> を使うとより安全であろう。"

#. type: Plain text
#: build/C/man2/select.2:709
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr "Linux では、 B<select>()  がシグナルハンドラーにより割り込まれた場合 (つまり B<EINTR> エラーが返る場合)、 I<timeout> も変更する。 これは POSIX.1 では認められていない挙動である。 Linux の B<pselect>()  システムコールも同じ挙動をするが、 glibc のラッパー関数がこの挙動を隠蔽している。 具体的には、glibc のラッパー関数の内部で、 I<timeout> をローカル変数にコピーし、 このローカル変数をシステムコールに渡している。"

#. type: Plain text
#: build/C/man2/select.2:714
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"

#. type: Plain text
#: build/C/man2/select.2:721
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#: build/C/man2/select.2:723
#, fuzzy, no-wrap
#| msgid ""
#| "    /* Watch stdin (fd 0) to see when it has input. */\n"
#| "    FD_ZERO(&rfds);\n"
#| "    FD_SET(0, &rfds);\n"
msgid "    /* Watch stdin (fd 0) to see when it has input. */\n"
msgstr ""
"    /* stdin (fd 0) を監視し、入力があった場合に表示する。*/\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#: build/C/man2/select.2:726
#, fuzzy, no-wrap
#| msgid ""
#| "    /* Watch stdin (fd 0) to see when it has input. */\n"
#| "    FD_ZERO(&rfds);\n"
#| "    FD_SET(0, &rfds);\n"
msgid ""
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    /* stdin (fd 0) を監視し、入力があった場合に表示する。*/\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#: build/C/man2/select.2:728
#, fuzzy, no-wrap
#| msgid ""
#| "    /* Wait up to five seconds. */\n"
#| "    tv.tv_sec = 5;\n"
#| "    tv.tv_usec = 0;\n"
msgid "    /* Wait up to five seconds. */\n"
msgstr ""
"    /* 5 秒間監視する。*/\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#: build/C/man2/select.2:731
#, no-wrap
msgid ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#: build/C/man2/select.2:734
#, fuzzy, no-wrap
#| msgid ""
#| "    retval = select(1, &rfds, NULL, NULL, &tv);\n"
#| "    /* Don't rely on the value of tv now! */\n"
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don\\(aqt rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* この時点での tv の値を信頼してはならない。*/\n"

#. type: Plain text
#: build/C/man2/select.2:742
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval == -1)\n"
"\tperror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"今、データが取得できました。\\en\");\n"
"        /* FD_ISSET(0, &rfds) が true になる。*/\n"
"    else\n"
"        printf(\"5 秒以内にデータが入力されませんでした。\\en\");\n"

#. type: Plain text
#: build/C/man2/select.2:758
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"

#. type: Plain text
#: build/C/man2/select.2:761
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""
"考察と使用例の書かれたチュートリアルとして、 B<select_tut>(2)  がある。"

#. type: TH
#: build/C/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr "SELECT_TUT"

#. type: Plain text
#: build/C/man2/select_tut.2:35
msgid "select, pselect - synchronous I/O multiplexing"
msgstr "select, pselect - 同期 I/O の多重化"

#. type: Plain text
#: build/C/man2/select_tut.2:38
msgid "See B<select>(2)"
msgstr "B<select>(2)  参照。"

#. type: Plain text
#: build/C/man2/select_tut.2:47
msgid ""
"The B<select>()  and B<pselect>()  system calls are used to efficiently "
"monitor multiple file descriptors, to see if any of them is, or becomes, "
"\"ready\"; that is, to see whether I/O becomes possible, or an \"exceptional "
"condition\" has occurred on any of the file descriptors."
msgstr "システムコール B<select>() や B<pselect>() を使うと、効率的に複数のファイルディスクリプターを監視し、 そのファイルディスクリプターのいずれかが 「ready (準備ができた)」状態、つまり I/O (入出力) が可能になっているかや、 ファイルディスクリプターのいずれかが 「例外状態 (exceptional condition)」が発生したか、を調べることができる。"

#. type: Plain text
#: build/C/man2/select_tut.2:57
msgid ""
"This page provides background and tutorial information on the use of these "
"system calls.  For details of the arguments and semantics of B<select>()  "
"and B<pselect>(), see B<select>(2)."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:57
#, no-wrap
msgid "Combining signal and data events"
msgstr "シグナルとデータイベントを組み合わせる"

#. type: Plain text
#: build/C/man2/select_tut.2:74
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely."
msgstr "ファイルディスクリプターが I/O 可能な状態になるのと同時に シグナルも待ちたい場合には、 B<pselect>()  が便利である。 シグナルを受信するプログラムは、通常は、 シグナルハンドラーをグローバルなフラグを立てるためだけに使う。 このグローバルなフラグは、 そのイベントをプログラムのメインループで 処理しなければならないことを示す。 シグナルを受けると B<select>()  (や B<pselect>())  は I<errno> に B<EINTR> をセットして戻ることになる。 シグナルがプログラムのメインループで処理されるためにはこの動作が不可欠で、 これがないと B<select>()  は永遠に停止し続けることになる。"

#. type: Plain text
#: build/C/man2/select_tut.2:102
msgid ""
"Now, somewhere in the main loop will be a conditional to check the global "
"flag.  So we must ask: what if a signal arrives after the conditional, but "
"before the B<select>()  call? The answer is that B<select>()  would block "
"indefinitely, even though an event is actually pending.  This race condition "
"is solved by the B<pselect>()  call.  This call can be used to set the "
"signal mask to a set of signals that are to be received only within the "
"B<pselect>()  call.  For instance, let us say that the event in question was "
"the exit of a child process.  Before the start of the main loop, we would "
"block B<SIGCHLD> using B<sigprocmask>(2).  Our B<pselect>()  call would "
"enable B<SIGCHLD> by using an empty signal mask.  Our program would look "
"like:"
msgstr "さて、メインループのどこかにこのグローバルフラグをチェックする 条件文があるとしよう。ここで少し考えてみないといけない。 「シグナルが条件文の後、しかし B<select>()  コールの前に到着したら どうなるのか？」 答えは「その B<select>()  は、たとえ解決待ちのイベントがあったとしても、 永遠に停止する」である。 この競合状態は B<pselect>()  コールによって解決できる。 このコールを使うと、 B<pselect>() でのみ受信したいシグナルの集合をシグナルマスクに設定することができる。 例えば、問題となっているイベントが子プロセスの終了の場合を考えよう。 メインループが始まる前に、 B<SIGCHLD> を B<sigprocmask>(2)  でブロックする。 B<pselect>()  コールでは B<SIGCHLD> を、もともとのシグナルマスクを使って有効にするのだ。 このプログラムは次のようになる。"

#. type: Plain text
#: build/C/man2/select_tut.2:105
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr "static volatile sig_atomic_t got_SIGCHLD = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:111
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:119
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:126
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:134
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:136
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr "    sigemptyset(&empty_mask);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:140
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:146
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:149
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:153
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:157
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""
"        /* main body of program */\n"
"    }\n"
"}\n"

#. type: SS
#: build/C/man2/select_tut.2:158
#, no-wrap
msgid "Practical"
msgstr "実例"

#. type: Plain text
#: build/C/man2/select_tut.2:179
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my file "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr "実際のところ B<select>()  の大事な点は何なのか？ ファイルディスクリプターは好きなときに読み書きできるんじゃないの？ B<select>()  の重要なところは、複数のディスクリプターを同時に監視でき、 なんの動きもなければプロセスを適切にスリープ状態に移行するところにあるのだ。 UNIX プログラマは、 複数のファイルディスクリプターの入出力を同時に扱わねばならず、 しかもデータの流れは間欠的である、という状況によく出会う。 単に B<read>(2)  や B<write>(2)  コールのシーケンスを作るだけでは、それらのコールのどれかが ファイルディスクリプターからのデータを待ってブロックしており、 別のファイルディスクリプターには I/O が可能なのに使えない、 ということになってしまうだろう。 B<select>()  を使うとこの状況に効果的に対処できる。"

#. type: SS
#: build/C/man2/select_tut.2:179
#, no-wrap
msgid "Select law"
msgstr "SELECT の掟"

#. type: Plain text
#: build/C/man2/select_tut.2:192
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""
"B<select>()  を使おうとした多くの人は、理解しにくい挙動に出くわし、結果的に "
"できたものは移植性がないか、よくてもギリギリのものになってしまう。 例えば、上"
"記のプログラムは、 集合に含まれるファイルディスクリプターを非停止 "
"(nonblocking) モード にしなくても、どこにもブロックが生じないよう注意して書か"
"れている。 微妙な間違いによって、 B<select>()  を使う利点は簡単に失われてしま"
"う。 そこで、 B<select>()  コールを使うときに注意すべき重要事項を列挙しておく"
"ことにする。"

#. type: Plain text
#: build/C/man2/select_tut.2:201
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""
"B<select>()  を使うときは、タイムアウトは設定すべきでない。 処理するデータが"
"無いときには、 あなたのプログラムには何もすることは無いはずである。 タイムア"
"ウトに依存したコードは通常移植性がなく、 デバッグも難しくなる。"

#. type: Plain text
#: build/C/man2/select_tut.2:205
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""
"上述したように、 効率的なプログラムを書くには I<nfds> の値を適切に計算して与"
"えなければならない。"

#. type: Plain text
#: build/C/man2/select_tut.2:212
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""
"B<select>()  コールの終了後に結果をチェックして、 適切に対応するつもりのない"
"ファイルディスクリプターは、 どの集合にも加えてはならない。 次のルールも参"
"照。"

#. type: Plain text
#: build/C/man2/select_tut.2:218
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""
"B<select>()  から返った後には、全ての集合の全てのファイルディスクリプターにつ"
"いて 読み書き可能な状態になっているかをチェックすべきである。"

#. type: TP
#: build/C/man2/select_tut.2:218
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man2/select_tut.2:233
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""
"B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  といった関数は、こちらが要求"
"した全データを読み書きする必要はI<ない>。 もし全データを読み書きするなら、そ"
"れはトラフィックの負荷が小さく、 ストリームが速い場合だろう。この条件は常に満"
"たされるとは限らない。 これらの関数が頑張っても 1 バイトしか送受信できないよ"
"うな場合も 考慮に入れてやらなければならない。"

#. type: TP
#: build/C/man2/select_tut.2:233
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: build/C/man2/select_tut.2:241
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""
"処理するデータ量が小さいことがはっきりとわかっている場合を除いて、 一度に 1 "
"バイトずつ読み書きするようなことはしてはならない。 バッファーの許すかぎりの"
"データをまとめて読み書きしないと、 非常に効率が悪い。下記の例ではバッファー"
"は 1024 バイトにしているが、 このサイズを大きくするのは簡単だろう。"

#. type: TP
#: build/C/man2/select_tut.2:241
#, no-wrap
msgid "7."
msgstr "7."

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: build/C/man2/select_tut.2:267
#, fuzzy
#| msgid ""
#| "The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  as "
#| "well as the B<select>()  call can return -1 with I<errno> set to "
#| "B<EINTR>, or with I<errno> set to B<EAGAIN> (B<EWOULDBLOCK>).  These "
#| "results must be properly managed (not done properly above).  If your "
#| "program is not going to receive any signals, then it is unlikely you will "
#| "get B<EINTR>.  If your program does not set nonblocking I/O, you will not "
#| "get B<EAGAIN>."
msgid ""
"Calls to B<read>(2), B<recv>(2), B<write>(2), B<send>(2), and B<select>()  "
"can fail with the error B<EINTR>, and calls to B<read>(2), B<recv>(2)  "
"B<write>(2), and B<send>(2)  can fail with I<errno> set to B<EAGAIN> "
"(B<EWOULDBLOCK>).  These results must be properly managed (not done properly "
"above).  If your program is not going to receive any signals, then it is "
"unlikely you will get B<EINTR>.  If your program does not set nonblocking I/"
"O, you will not get B<EAGAIN>."
msgstr ""
"B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  などの関数や B<select>()  "
"コールは、 I<errno> を B<EINTR や EAGAIN> (B<EWOULDBLOCK>)  にして -1 を返す"
"ことがある。 このような結果に対して適切に対応してやらなければならない (上記の"
"例ではしていない)。 書いているプログラムがシグナルを受ける予定がなければ、 "
"B<EINTR> が返されることはあまり考えられない。 書いているプログラムで非ブロッ"
"ク I/O をセットしていない場合は、 B<EAGAIN> が返されることはないだろう。"

#. type: TP
#: build/C/man2/select_tut.2:267
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: build/C/man2/select_tut.2:276
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""
"決して、引数に長さ 0 のバッファーを指定して B<read>(2), B<recv>(2), "
"B<write>(2), B<send>(2)  を呼び出してはならない。"

#. type: TP
#: build/C/man2/select_tut.2:276
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: build/C/man2/select_tut.2:292
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that file "
"descriptor to B<select>()  again.  In the example below, I close the file "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr "B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  が B<7.> に示した以外のエラーで失敗した場合や、 入力系の関数の一つがファイル末尾を表す 0 を返した場合は、 そのファイルディスクリプターをもう一度 select に渡してはI<ならない>。 下記の例では、そのファイルディスクリプターをただちにクローズし、 そこには -1 をセットして、 それが集合に含まれ続けるのを許さないようにしている。"

#. type: TP
#: build/C/man2/select_tut.2:292
#, no-wrap
msgid "10."
msgstr "10."

#. type: Plain text
#: build/C/man2/select_tut.2:299
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""
"タイムアウトの値は B<select>()  を呼ぶたびに初期化すべきである。 OS によって"
"は timeout 構造体が変更される場合があるからである。 但し、 B<pselect>()  は自"
"分の timeout 構造体を変更することはない。"

#. type: TP
#: build/C/man2/select_tut.2:299
#, no-wrap
msgid "11."
msgstr "11."

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: build/C/man2/select_tut.2:318
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""
"B<select>()  はファイルディスクリプター集合を変更するので、 B<select>()  が"
"ループの中で使用されている場合には、呼び出しを行う前に毎回 ディスクリプター集"
"合を初期化し直さなければならない。"

#. type: Plain text
#: build/C/man2/select_tut.2:321
msgid "See B<select>(2)."
msgstr "B<select>(2)  参照。"

#. type: Plain text
#: build/C/man2/select_tut.2:330
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""
"一般的に言って、ソケットをサポートする全てのオペレーティングシステムは "
"B<select>()  もサポートしている。 B<select>()  を使うと、プログラマがスレッ"
"ド、フォーク、IPC、シグナル、メモリー共有、 等々を使ってもっと複雑な方法で解"
"決しようとする多くの問題が、 移植性がありかつ効率的な方法で解決できる。"

#. type: Plain text
#: build/C/man2/select_tut.2:339
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""
"B<poll>(2)  システムコールは B<select>()  と同じ機能を持っており、 まばらな"
"ファイルディスクリプター集合を監視する場合に いくらか効率がよい。 現在では広"
"く利用可能であるが、以前は B<select>()  より移植性の面で劣っていた。"

#. type: Plain text
#: build/C/man2/select_tut.2:347
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""
"Linux 独自の B<epoll>(7)  API は、多数のファイルディスクリプターを監視する場"
"合に B<select>(2)  や B<poll>(2)  よりも効率的なインターフェースを提供してい"
"る。"

#. type: Plain text
#: build/C/man2/select_tut.2:352
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""
"B<select>()  の本当に便利な点を示す、よい例を紹介する。 以下のリストは、ある "
"TCP ポートから別のポートへ転送を行う TCP フォワードプログラムである。"

#. type: Plain text
#: build/C/man2/select_tut.2:364
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man2/select_tut.2:366
#, no-wrap
msgid "static int forward_port;\n"
msgstr "static int forward_port;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:369
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: build/C/man2/select_tut.2:376
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"
msgstr ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:382
#, no-wrap
msgid ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:390
#, no-wrap
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:399
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:404
#, no-wrap
msgid ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"
msgstr ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:410
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"
msgstr ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:416
#, no-wrap
msgid ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:420
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:426
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:435
#, no-wrap
msgid ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"
msgstr ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:443
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: build/C/man2/select_tut.2:451
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: build/C/man2/select_tut.2:453
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: build/C/man2/select_tut.2:462
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:468
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:470
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr "    signal(SIGPIPE, SIG_IGN);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:472
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr "    forward_port = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:476
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:481
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"
msgstr ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:487
#, no-wrap
msgid ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"
msgstr ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:494
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:499
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:508
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:510
#, no-wrap
msgid "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"
msgstr "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:513
#, no-wrap
msgid ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:518
#, no-wrap
msgid ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:523
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"
msgstr ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:541
#, no-wrap
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"
msgstr ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"

#. type: Plain text
#: build/C/man2/select_tut.2:544
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file\n"
"                   descriptors. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:548
#, no-wrap
msgid ""
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""
"                continue;\n"
"            }\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:550
#, fuzzy, no-wrap
#| msgid "        /* NB: read oob data before normal reads */\n"
msgid "        /* NB: read OOB data before normal reads */\n"
msgstr "        /* NB: read oob data before normal reads */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:553
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:562
#, no-wrap
msgid ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:601
#, no-wrap
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:603
#, fuzzy, no-wrap
#| msgid "        /* check if write data has caught read data */\n"
msgid "        /* Check if write data has caught read data */\n"
msgstr "        /* check if write data has caught read data */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:608
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:611
#, fuzzy, no-wrap
#| msgid ""
#| "        /* one side has closed the connection, keep\n"
#| "           writing to the other side until empty */\n"
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:619
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:633
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""
"上記のプログラムは、ほとんどの種類の TCP 接続をフォワードする。 B<telnet> "
"サーバによって中継される OOB シグナルデータも扱える。 このプログラムは、デー"
"タフローを双方向に同時に送るという、 ややこしい問題も処理できる。 "
"B<fork>(2)  コールを使って、各ストリームごとに専用のスレッドを用いるほうが効"
"率的だ、 という人もいるかもしれない。しかし、これは考えているよりずっとややこ"
"しい。 あるいは、 B<fcntl>(2)  を使って非ブロック I/O をセットすれば良い、と"
"いうアイデアもあるだろう。 これにも実際には問題があり、タイムアウトが非効率的"
"に起こってしまう。"

#. type: Plain text
#: build/C/man2/select_tut.2:639
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of buffers"
"\\(emone for each connection.  At the moment, new connections cause the "
"current connection to be dropped."
msgstr ""
"このプログラムは一度にひとつ以上の同時接続を扱うことはできないが、 その様に拡"
"張するのは簡単で、バッファーのリンクリストを (接続ごとにひとつずつ) 使えばよ"
"い。 現時点のものでは、新しい接続がくると古い接続は落ちてしまう。"

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: build/C/man2/select_tut.2:652
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7)"
msgstr "B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr "SEND"

#. type: Plain text
#: build/C/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr "send, sendto, sendmsg - ソケットへメッセージを送る"

#. type: Plain text
#: build/C/man2/send.2:50
#, no-wrap
msgid "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:57
#, no-wrap
msgid "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""
"システムコール B<send>(), B<sendto>(), B<sendmsg>()  は、もう一方のソケットへ"
"メッセージを転送するのに使用される。"

#. type: Plain text
#: build/C/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""
"B<send>()  は、ソケットが I<接続された (connected)> 状態にある場合にのみ使用"
"できる (つまり、どの相手に送信するかは既知である)。 B<send>()  と "
"B<write>(2)  の違いは、引数に I<flags> があるかどうかだけである。 引数 "
"I<flags> にフラグが指定されない場合、 B<send>()  は B<write>(2)  と等価であ"
"る。 また、"

#. type: Plain text
#: build/C/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr "    send(sockfd, buf, len, flags);\n"

#. type: Plain text
#: build/C/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr "    sendto(sockfd, buf, len, flags, NULL, 0);\n"

#. type: Plain text
#: build/C/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""
"引数 I<sockfd> は、データを送信するパケットのファイルディスクリプターであ"
"る。"

#. type: Plain text
#: build/C/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""
"B<sendto>()  は、接続型 (connection-mode) のソケット (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  で 使用された場合、引数 I<dest_addr> と I<addrlen> は無"
"視される (各々の引数が NULL と 0 でない場合は B<EISCONN> エラーも返され"
"る)。 また、ソケットが実際には接続されていなかった時には B<ENOTCONN> エラーが"
"返される。 接続型のソケット以外で使用された場合は、接続先のアドレスは "
"I<dest_addr> で与えられ、そのサイズは I<addrlen> で指定される。 "
"B<sendmsg>()  では、接続先のアドレスは I<msg.msg_name> で与えられ、そのサイズ"
"は I<msg.msg_namelen> で指定される。"

#. type: Plain text
#: build/C/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""
"B<send>()  と B<sendto>()  では、メッセージは I<buf> に格納されており、その長"
"さは I<len> であると解釈される。 B<sendmsg>()  では、メッセージは 配列 I<msg."
"msg_iov> の各要素が指す位置に格納されている。 B<sendmsg>()  では、補助データ "
"(制御情報とも呼ばれる) を送信することもできる。"

#. type: Plain text
#: build/C/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""
"メッセージ長が長過ぎるために、そのソケットが使用するプロトコルでは、 メッセー"
"ジをソケットに渡されたままの形で送信することができない場合、 B<EMSGSIZE> エ"
"ラーが返され、そのメッセージは転送されない。"

#. type: Plain text
#: build/C/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""
"B<send>()  では、配送の失敗の通知は明示的に行われる。 ローカル側でエラーが検"
"出された場合は、返り値 -1 として通知される。"

#. type: Plain text
#: build/C/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""
"メッセージがソケットの送信バッファーに入れることができない場合、 B<send>()  "
"は通常は停止 (block) する (ソケットが非停止 (nonblocking) I/O モード でない場"
"合)。非停止モードの場合にはエラー B<EAGAIN> か B<EWOULDBLOCK> で失敗する。 い"
"つデータをさらに送信できるようになるかを知るために、 B<select>(2)  コールを使"
"用することができる。"

#.  FIXME . ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: build/C/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""
"I<flags> 引数は、以下のフラグの (0 個以上の) ビット単位の論理和を とったも"
"のを指定する。"

#. type: TP
#: build/C/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (since Linux 2.3.15)"
msgstr "B<MSG_CONFIRM> (Linux 2.3.15 以降)"

#. type: Plain text
#: build/C/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""
"転送処理に進展があった、つまり相手側から成功の応答を受けたことをリンク層に 知"
"らせる。リンク層がこの通知を受け取らなかった場合には、通常どおり (ユニキャス"
"ト ARP を使うなどの方法で) 近傍 (neighbor) の再検索を行う。 B<SOCK_DGRAM> と "
"B<SOCK_RAW> のソケットに対してのみ有効で、現在のところ IPv4 と IPv6 のみ実装"
"されている。 詳しくは B<arp>(7)  参照のこと。"

#. type: TP
#: build/C/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr "B<MSG_DONTROUTE>"

#. type: Plain text
#: build/C/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr ""
"パケットを送り出すのにゲートウェイを使用せず、 直接接続されているネットワーク"
"上のホストだけに送る。 通常、このフラグは診断 (diagnostic) やルーティングプロ"
"グラムに よってのみ使用される。このフラグは、経路制御が行われるプロトコルファ"
"ミリー に対してのみ定義されている。パケットソケットには定義されていない。"

#. type: Plain text
#: build/C/man2/send.2:209
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned.  This provides similar behavior to setting the "
"B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> operation), but differs "
"in that B<MSG_DONTWAIT> is a per-call option, whereas B<O_NONBLOCK> is a "
"setting on the open file description (see B<open>(2)), which will affect all "
"threads in the calling process and as well as other processes that hold file "
"descriptors referring to the same open file description."
msgstr ""

#. type: TP
#: build/C/man2/send.2:209
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr "B<MSG_EOR> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/send.2:213
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""
"レコードの終了を指示する (B<SOCK_SEQPACKET> のようにこの概念に対応しているソ"
"ケット種別のときに有効)。"

#. type: TP
#: build/C/man2/send.2:213
#, no-wrap
msgid "B<MSG_MORE> (since Linux 2.4.4)"
msgstr "B<MSG_MORE> (Linux 2.4.4 以降)"

#. type: Plain text
#: build/C/man2/send.2:222
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""
"呼び出し元にさらに送るデータがあることを示す。 このフラグは TCP ソケットとと"
"もに使用され、 B<TCP_CORK> ソケットオプションと同じ効果が得られる "
"(B<tcp>(7)  を参照)。 B<TCP_CORK> との違いは、このフラグを使うと呼び出し単位"
"で この機能を有効にできる点である。"

#. type: Plain text
#: build/C/man2/send.2:231
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""
"Linux 2.6 以降では、このフラグは UDP ソケットでもサポートされており、 このフ"
"ラグ付きで送信された全てのデータを一つのデータグラムにまとめて 送信すること"
"を、カーネルに知らせる。まとめられたデータグラムは、 このフラグを指定せずにこ"
"のシステムコールが実行された際に初めて送信される (B<udp>(7)  に記載されている"
"ソケットオプション B<UDP_CORK> も参照)。"

#. type: TP
#: build/C/man2/send.2:231
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr "B<MSG_NOSIGNAL> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/send.2:249
msgid ""
"Don't generate a B<SIGPIPE> signal if the peer on a stream-oriented socket "
"has closed the connection.  The B<EPIPE> error is still returned.  This "
"provides similar behavior to using B<sigaction>(2)  to ignore B<SIGPIPE>, "
"but, whereas B<MSG_NOSIGNAL> is a per-call feature, ignoring B<SIGPIPE> sets "
"a process attribute that affects all threads in the process."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:258
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""
"I<帯域外 (out-of-band)> データをサポートするソケット (例えば "
"B<SOCK_STREAM>)  で I<帯域外> データを送る。下位プロトコルも I<帯域外> データ"
"をサポートしている必要がある。"

#. type: SS
#: build/C/man2/send.2:258
#, no-wrap
msgid "sendmsg()"
msgstr "sendmsg()"

#. type: Plain text
#: build/C/man2/send.2:264
msgid ""
"The definition of the I<msghdr> structure employed by B<sendmsg>()  is as "
"follows:"
msgstr "B<sendmsg>() で利用されている I<msghdr> 構造体は以下の通り。"

#. type: Plain text
#: build/C/man2/send.2:276
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags (unused) */\n"
"};\n"
msgstr ""
"struct msghdr {\n"
"    void         *msg_name;       /* 追加のアドレス */\n"
"    socklen_t     msg_namelen;    /* アドレスのサイズ */\n"
"    struct iovec *msg_iov;        /* scatter/gather 配列 */\n"
"    size_t        msg_iovlen;     /* msg_iov の要素数 */\n"
"    void         *msg_control;    /* 補助データ (後述) */\n"
"    size_t        msg_controllen; /* 補助データバッファー長 */\n"
"    int           msg_flags;      /* フラグ (未使用) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/send.2:288
msgid ""
"The I<msg_name> field is used on an unconnected socket to specify the target "
"address for a datagram.  It points to a buffer containing the address; the "
"I<msg_namelen> field should be set to the size of the address.  For a "
"connected socket, these fields should be specified as NULL and 0, "
"respectively."
msgstr ""
"フィールド I<msg_name> は、 未接続のソケットでデータグラムの宛先アドレスを指"
"定するのに使用される。 このフィールドはアドレスを格納したバッファーを指す。 "
"フィールド I<msg_namelen> にはアドレスの大きさを設定しなければならない。 接続"
"済のソケットについては、これらのフィールドにはそれぞれ NULL と 0 を指定しなけ"
"ればならない。"

#. type: Plain text
#: build/C/man2/send.2:295
msgid ""
"The I<msg_iov> and I<msg_iovlen> fields specify scatter-gather locations, as "
"for B<writev>(2)."
msgstr ""
"フィールド B<msg_iov> と I<msg_iovlen> は scatter-gather 用の場所を指定す"
"る。 B<writev>(2) と同じ。"

#. type: Plain text
#: build/C/man2/send.2:311
#, fuzzy
#| msgid ""
#| "You may send control information using the I<msg_control> and "
#| "I<msg_controllen> members.  The maximum control buffer length the kernel "
#| "can process is limited per socket by the value in I</proc/sys/net/core/"
#| "optmem_max>; see B<socket>(7)."
msgid ""
"You may send control information (ancillary data) using the I<msg_control> "
"and I<msg_controllen> members.  The maximum control buffer length the kernel "
"can process is limited per socket by the value in I</proc/sys/net/core/"
"optmem_max>; see B<socket>(7).  For further information on the use of "
"ancillary data in various socket domains, see B<unix>(7)  and B<ip>(7)."
msgstr ""
"フィールド I<msg_control> と I<msg_controllen> を使用して制御情報を送信するこ"
"とができる。 カーネルが処理できる制御バッファーのソケットあたりの最大長は、 "
"I</proc/sys/net/core/optmem_max> の値に制限されている。 B<socket>(7)  を参"
"照。"

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#. type: Plain text
#: build/C/man2/send.2:318
msgid "The I<msg_flags> field is ignored."
msgstr "フィールド I<msg_flags> は無視される。"

#. type: Plain text
#: build/C/man2/send.2:323
msgid ""
"On success, these calls return the number of bytes sent.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールは送信されたバイト数を返す。 エラーの場"
"合、 -1 を返し、 I<errno> を適切に設定にする。"

#. type: Plain text
#: build/C/man2/send.2:328
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""
"これらはソケット層で発生する一般的なエラーである。これ以外に、下層の プロトコ"
"ルモジュールで生成されたエラーが返されるかもしれない。 これらについては、それ"
"ぞれのマニュアルを参照すること。"

#. type: Plain text
#: build/C/man2/send.2:336
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""
"(UNIX ドメインソケットの場合; パス名で識別される。)\n"
"\n"
"ソケットファイルへの書き込み許可がなかったか、パス名へ到達するまでの\n"
"ディレクトリのいずれかに対する検索許可がなかった。\n"
"(B<path_resolution>(7) も参照のこと)"

#. type: Plain text
#: build/C/man2/send.2:339
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""
"(UDP ソケットの場合) ユニキャストアドレスであるかのように、\n"
"ネットワークアドレスやブロードキャストアドレスへの送信が試みられた。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/send.2:347
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""
"ソケットが非停止に設定されており、 要求された操作が停止した。 POSIX.1-2001 "
"は、この場合にどちらのエラーを返すことも認めており、 これら 2 つの定数が同じ"
"値を持つことも求めていない。 したがって、移植性が必要なアプリケーションでは、"
"両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/send.2:360
msgid ""
"(Internet domain datagram sockets)  The socket referred to by I<sockfd> had "
"not previously been bound to an address and, upon attempting to bind it to "
"an ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of I</proc/sys/net/ipv4/"
"ip_local_port_range> in B<ip>(7)."
msgstr ""
"(インターネットドメインデータグラムソケットの場合) I<sockfd> が参照するソケッ"
"トがそれ以前にアドレスにバインドされておらず、 そのソケットに一時ポートをバイ"
"ンドしようとした際に、 一時ポートとして使用する範囲のポート番号がすべて使用中"
"であった。 B<ip>(7) の I</proc/sys/net/ipv4/ip_local_port_range> の議論を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/send.2:363
msgid "Another Fast Open is in progress."
msgstr ""

#. type: TP
#: build/C/man2/send.2:367
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: build/C/man2/send.2:370
msgid "Connection reset by peer."
msgstr "接続が接続相手によりリセットされた。"

#. type: TP
#: build/C/man2/send.2:370
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: build/C/man2/send.2:373
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""
"ソケットが接続型 (connection-mode) ではなく、 かつ送信先のアドレスが設定され"
"ていない。"

#. type: Plain text
#: build/C/man2/send.2:376
msgid "An invalid user space address was specified for an argument."
msgstr "ユーザー空間として不正なアドレスがパラメーターとして指定された。"

#. type: Plain text
#: build/C/man2/send.2:380
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr "データが送信される前に、シグナルが発生した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/send.2:389
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""
"接続型ソケットの接続がすでに確立していたが、受信者が指定されていた。 (現在の"
"ところ、この状況では、このエラーが返されるか、 受信者の指定が無視されるか、の"
"いずれかとなる)"

#. type: TP
#: build/C/man2/send.2:389
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: build/C/man2/send.2:395
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""
"そのソケット種別 ではソケットに渡されたままの形でメッセージを送信する必要があ"
"るが、 メッセージが大き過ぎるため送信することができない。"

#. type: Plain text
#: build/C/man2/send.2:403
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""
"ネットワークインターフェースの出力キューが一杯である。 一般的には、一時的な輻"
"輳 (congestion) のためにインターフェースが 送信を止めていることを意味する。 "
"(通常、Linux ではこのようなことは起こらない。デバイスのキューが オーバーフ"
"ローした場合にはパケットは黙って捨てられる)"

#. type: Plain text
#: build/C/man2/send.2:406
msgid "No memory available."
msgstr "メモリーが足りない。"

#. type: Plain text
#: build/C/man2/send.2:409
msgid "The socket is not connected, and no target has been given."
msgstr "ソケットが接続されておらず、接続先も指定されていない。"

#. type: Plain text
#: build/C/man2/send.2:419
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""
"引数 I<flags> のいくつかのビットが、そのソケット種別では不適切なものであ"
"る。"

#. type: TP
#: build/C/man2/send.2:419
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man2/send.2:428
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case, the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""
"接続指向のソケットでローカル側が閉じられている。 この場合、 B<MSG_NOSIGNAL> "
"が設定されていなければ、プロセスには B<SIGPIPE> も同時に送られる。"

#. type: Plain text
#: build/C/man2/send.2:431
msgid "4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD."
msgstr "4.4BSD, SVr4, POSIX.1-2001.  (これらのインターフェースは 4.2BSD で最初に登場した)。"

#. type: Plain text
#: build/C/man2/send.2:442
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""
"POSIX.1-2001 には、 B<MSG_OOB> と B<MSG_EOR> フラグだけが記載されている。 "
"POSIX.1-2008 では B<MSG_NOSIGNAL> が規格に追加されている。 B<MSG_CONFIRM> フ"
"ラグは Linux での拡張である。"

#.  glibc bug for msg_controllen raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type these fields varies
#.  across architectures, but socklen_t is always 32 bits,
#.  as (at least with GCC) is int.
#. type: Plain text
#: build/C/man2/send.2:461
#, fuzzy
#| msgid ""
#| "According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
#| "structure should be typed as I<socklen_t>, but glibc currently types it "
#| "as I<size_t>."
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, and the I<msg_iovlen> field "
"should be typed as I<int>, but glibc currently types both as I<size_t>."
msgstr ""
"POSIX.1-2001 では、構造体 I<msghdr> のフィールド I<msg_controllen> は "
"I<socklen_t> 型であるべきだとされているが、 現在の glibc では I<size_t> 型で"
"ある。"

#. type: Plain text
#: build/C/man2/send.2:466
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""
"B<sendmmsg>(2)  には、一度の呼び出しでの複数のデータグラムの送信に使用でき"
"る\n"
"Linux 固有の システムコールに関する情報が書かれている。"

#. type: Plain text
#: build/C/man2/send.2:471
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr "Linux は B<ENOTCONN> を返す状況で B<EPIPE> を返すことがある。"

#. type: Plain text
#: build/C/man2/send.2:476
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr "B<sendto>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/send.2:493
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr "B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr "SENDMMSG"

#. type: Plain text
#: build/C/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr "sendmmsg - 複数のメッセージをソケットへ送信する"

#. type: Plain text
#: build/C/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"
msgstr ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: build/C/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""
"B<sendmmsg>() システムコールは B<sendmsg>(2) の拡張で、 このシステムコールを"
"使うと一度の呼び出しでソケットに複数のメッセージを送信できる (アプリケーショ"
"ンによっては性能上のメリットがある)。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""
"I<sockfd> 引数は、 データを送信するソケットのファイルディスクリプターであ"
"る。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* メッセージヘッダー */\n"
"    unsigned int  msg_len;  /* 送信されたバイト数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""
"I<msg_hdr> フィールドは、 B<sendmsg>(2) で説明されている I<msghdr> 構造体であ"
"る。 I<msg_len> フィールドは I<msg_hdr> から送信されたメッセージのバイト数を"
"返すのに使用される。 この値は B<sendmsg>(2) をこのヘッダーに対して呼び出した"
"場合の返り値と同じである。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""
"I<flags> 引数には複数のフラグを論理和 (OR) で指定できる。フラグは "
"B<sendmsg>(2) と同じである。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""
"停止 (blocking) モードの B<sendmmsg>() の呼び出しは、 I<vlen> 個のメッセージ"
"が送信されるまで停止する。 非停止 (nonblocking) モードの呼び出しでは、 送信で"
"きるだけのメッセージ (最大で I<vlen> 個) を送信し、 すぐに返る。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""
"B<sendmmsg>() が返った際には、 I<msgvec> の送信が行われた要素の I<msg_len> "
"フィールドは、対応する I<msg_hdr> から送信されたバイト数が入っている。 呼び出"
"しの返り値は、更新された I<msgvec> の要素数である。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""
"成功すると、 B<sendmmsg>() は I<msgvec> から送信されたメッセージ数を返す。 返"
"り値が I<vlen> よりも小さい場合、 呼び出した側では再度 B<sendmmsg> を呼び出し"
"て残りのメッセージを送信することができる。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr "エラーの場合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#
#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#.      This matches the behavior of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: build/C/man2/sendmmsg.2:146
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent.  See also BUGS."
msgstr "エラーは B<sendmsg>(2) と同じである。 エラーが返されるのは、 データグラムが全く送信できなかった場合のみである。「バグ」も参照のこと。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:151
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""
"B<sendmmsg>() システムコールは Linux 3.0 で追加された。 glibc でのサポートは"
"バージョン 2.14 で追加された。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:154
msgid "B<sendmmsg>()  is Linux-specific."
msgstr "B<sendmmsg>() は Linux 固有である。"

#
#
#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: build/C/man2/sendmmsg.2:169
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr "I<vlen> に指定できる値の最大値は B<UIO_MAXIOV> (1024) である。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:177
msgid ""
"If an error occurs after at least one message has been sent, the call "
"succeeds, and returns the number of messages sent.  The error code is lost.  "
"The caller can retry the transmission, starting at the first failed message, "
"but there is no guarantee that, if an error is returned, it will be the same "
"as the one that was lost on the previous call."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:186
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""
"以下の例では、 B<sendmmsg>() を使って、 一度のシステムコールで、 I<onetwo> "
"と I<three> を二つの別々の UDP データグラムで送信する。 一つ目のデータグラム"
"の内容は、二つのバッファーから取得される。"

#. type: Plain text
#: build/C/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:204
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:218
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:224
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:228
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:241
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:244
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr ""
"    exit(0);\n"
"}\n"

#. type: Plain text
#: build/C/man2/sendmmsg.2:250
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man3/sockatmark.3:25
#, no-wrap
msgid "SOCKATMARK"
msgstr "SOCKATMARK"

#. type: Plain text
#: build/C/man3/sockatmark.3:28
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""
"sockatmark - どのソケットに帯域外 (out-of-band) マークが付けられているかを調"
"べる"

#. type: Plain text
#: build/C/man3/sockatmark.3:30 build/C/man2/socket.2:49
#: build/C/man7/socket.7:59 build/C/man2/socketpair.2:49
#: build/C/man7/address_families.7:33 build/C/man7/vsock.7:30
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: build/C/man3/sockatmark.3:32
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr "B<int sockatmark(int >I<sockfd>B<);>"

#. type: Plain text
#: build/C/man3/sockatmark.3:41
msgid "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/sockatmark.3:51
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""
"B<sockatmark>()  はファイルディスクリプター I<sockfd> で参照されるソケットに"
"帯域外マークが付けられているか否かを返す。 ソケットにマークが付けられている場"
"合は、1 が返される。 ソケットにマークが付けられていない場合は、0 が返され"
"る。 この関数は帯域外マークを削除しない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:58
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the out-"
"of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"B<sockatmark>()  の呼び出しが成功した場合、ソケットに帯域外マークが 付けられ"
"ていれば 1 を返し、付けられていなければ 0 を返す。 エラーの場合は -1 が返さ"
"れ、エラーを表す I<errno> が設定される。"

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: build/C/man3/sockatmark.3:70
msgid ""
"I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""
"I<sockfd> は B<sockatmark>()  が適用できないファイルディスクリプターである。"

#. type: Plain text
#: build/C/man3/sockatmark.3:73
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr "B<sockatmark>()  は glibc バージョン 2.2.4 で追加された。"

#. type: tbl table
#: build/C/man3/sockatmark.3:83
#, no-wrap
msgid "B<sockatmark>()"
msgstr "B<sockatmark>()"

#. type: Plain text
#: build/C/man3/sockatmark.3:87
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/sockatmark.3:94
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""
"B<sockatmark>()  が 1 を返す場合、帯域外データは B<MSG_OOB> を指定した "
"B<recv>(2)  で読み込むことができる。"

#. type: Plain text
#: build/C/man3/sockatmark.3:96
msgid "Out-of-band data is supported only on some stream socket protocols."
msgstr ""
"帯域外データは、いくつかのストリームソケットプロトコルでしか サポートされてい"
"ない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:101
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""
"B<sockatmark>()  は B<SIGURG> シグナルのハンドラーから安全に呼び出すことがで"
"きる。"

#. type: Plain text
#: build/C/man3/sockatmark.3:107
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""
"B<sockatmark>()  は B<SIOCATMARK> B<ioctl>(2)  操作を使って実装されている。"

#. type: Plain text
#: build/C/man3/sockatmark.3:111
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr "glibc 2.4 より前のバージョンでは、 B<sockatmark>()  は動作しない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:116
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""
"以下のコードは、 B<SIGURG> シグナルを受け取った後にマークまでの全てのデータを"
"読み込んで (破棄し)、 マークされたデータのバイトを読み込むのに使用できる。"

#. type: Plain text
#: build/C/man3/sockatmark.3:121
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:128
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:131
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""
"        if (atmark)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:138
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""
"        s = read(sockfd, buf, BUF_LEN);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:145
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:151
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"

#. type: TH
#: build/C/man2/socket.2:42 build/C/man7/socket.7:54
#, no-wrap
msgid "SOCKET"
msgstr "SOCKET"

#. type: Plain text
#: build/C/man2/socket.2:45
msgid "socket - create an endpoint for communication"
msgstr "socket - 通信のための端点 (endpoint) を作成する"

#. type: Plain text
#: build/C/man2/socket.2:47 build/C/man2/socketpair.2:47
#: build/C/man7/address_families.7:31
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr "B<#include E<lt>sys/types.hE<gt>> /* 「注意」参照 */"

#. type: Plain text
#: build/C/man2/socket.2:51 build/C/man7/address_families.7:35
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"

#. type: Plain text
#: build/C/man2/socket.2:57
msgid ""
"B<socket>()  creates an endpoint for communication and returns a file "
"descriptor that refers to that endpoint.  The file descriptor returned by a "
"successful call will be the lowest-numbered file descriptor not currently "
"open for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:65
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The formats currently understood by "
"the Linux kernel include:"
msgstr "I<domain> 引数は通信を行なうドメインを指定する; これはどの プロトコルファミリー (protocol family) を通信に使用するかを指定する。 これらのファミリーは I<E<lt>sys/socket.hE<gt>> に定義されている。現在カーネルが理解できるフォーマットは以下の通り。"

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Name"
msgstr "名前"

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Purpose"
msgstr "目的"

#. type: tbl table
#: build/C/man2/socket.2:68 build/C/man2/socketcall.2:48
#, no-wrap
msgid "Man page"
msgstr "マニュアル"

#. type: tbl table
#: build/C/man2/socket.2:71
#, no-wrap
msgid "B<AF_UNIX>"
msgstr "B<AF_UNIX>"

#. type: SS
#: build/C/man2/socket.2:73 build/C/man7/vsock.7:167
#, no-wrap
msgid "Local communication"
msgstr "ローカル通信"

#. type: tbl table
#: build/C/man2/socket.2:75
#, no-wrap
msgid "B<unix>(7)"
msgstr "B<unix>(7)"

#. type: tbl table
#: build/C/man2/socket.2:78
#, no-wrap
msgid "B<AF_LOCAL>"
msgstr "B<AF_LOCAL>"

#. type: tbl table
#: build/C/man2/socket.2:81
#, no-wrap
msgid ""
"Synonym for\n"
"B<AF_UNIX>"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:85 build/C/man7/address_families.7:50
#, no-wrap
msgid "B<AF_INET>"
msgstr "B<AF_INET>"

#. type: tbl table
#: build/C/man2/socket.2:85
#, no-wrap
msgid "IPv4 Internet protocols"
msgstr "IPv4 インターネットプロトコル"

#. type: tbl table
#: build/C/man2/socket.2:87
#, no-wrap
msgid "B<ip>(7)"
msgstr "B<ip>(7)"

#. type: TP
#: build/C/man2/socket.2:90 build/C/man7/address_families.7:55
#, no-wrap
msgid "B<AF_AX25>"
msgstr "B<AF_AX25>"

#. type: tbl table
#: build/C/man2/socket.2:92
#, no-wrap
msgid "Amateur radio AX.25 protocol"
msgstr "アマチュア無線 AX.25 プロトコル"

#.  Part of ax25-tools
#. type: tbl table
#: build/C/man2/socket.2:95
#, no-wrap
msgid "B<ax25>(4)"
msgstr "B<ax25>(4)"

#. type: TP
#: build/C/man2/socket.2:98 build/C/man7/address_families.7:61
#, no-wrap
msgid "B<AF_IPX>"
msgstr "B<AF_IPX>"

#. type: tbl table
#: build/C/man2/socket.2:98
#, no-wrap
msgid "IPX - Novell protocols"
msgstr "IPX - Novell プロトコル"

#. type: TP
#: build/C/man2/socket.2:101 build/C/man7/address_families.7:64
#, no-wrap
msgid "B<AF_APPLETALK>"
msgstr "B<AF_APPLETALK>"

#. type: tbl table
#: build/C/man2/socket.2:101
#, no-wrap
msgid "AppleTalk"
msgstr "AppleTalk"

#. type: tbl table
#: build/C/man2/socket.2:103
#, no-wrap
msgid "B<ddp>(7)"
msgstr "B<ddp>(7)"

#. type: TP
#: build/C/man2/socket.2:106 build/C/man7/address_families.7:97
#, no-wrap
msgid "B<AF_X25>"
msgstr "B<AF_X25>"

#. type: tbl table
#: build/C/man2/socket.2:106
#, no-wrap
msgid "ITU-T X.25 / ISO-8208 protocol"
msgstr "ITU-T X.25 / ISO-8208 プロトコル"

#. type: tbl table
#: build/C/man2/socket.2:108
#, no-wrap
msgid "B<x25>(7)"
msgstr "B<x25>(7)"

#. type: TP
#: build/C/man2/socket.2:111 build/C/man7/address_families.7:102
#, no-wrap
msgid "B<AF_INET6>"
msgstr "B<AF_INET6>"

#. type: tbl table
#: build/C/man2/socket.2:111
#, no-wrap
msgid "IPv6 Internet protocols"
msgstr "IPv6 インターネットプロトコル"

#. type: tbl table
#: build/C/man2/socket.2:113
#, no-wrap
msgid "B<ipv6>(7)"
msgstr "B<ipv6>(7)"

#. type: TP
#: build/C/man2/socket.2:116 build/C/man7/address_families.7:113
#, no-wrap
msgid "B<AF_DECnet>"
msgstr "B<AF_DECnet>"

#. type: tbl table
#: build/C/man2/socket.2:118
#, no-wrap
msgid "DECet protocol sockets"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:121 build/C/man7/address_families.7:126
#, no-wrap
msgid "B<AF_KEY>"
msgstr "B<AF_KEY>"

#. type: tbl table
#: build/C/man2/socket.2:123
#, no-wrap
msgid "Key management protocol, originally developed for usage with IPsec"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:126 build/C/man7/address_families.7:139
#, no-wrap
msgid "B<AF_NETLINK>"
msgstr "B<AF_NETLINK>"

#. type: tbl table
#: build/C/man2/socket.2:128
#, no-wrap
msgid "Kernel user interface device"
msgstr "カーネルユーザーインターフェースデバイス"

#. type: tbl table
#: build/C/man2/socket.2:130
#, no-wrap
msgid "B<netlink>(7)"
msgstr "B<netlink>(7)"

#. type: TP
#: build/C/man2/socket.2:133 build/C/man7/address_families.7:144
#, no-wrap
msgid "B<AF_PACKET>"
msgstr "B<AF_PACKET>"

#. type: tbl table
#: build/C/man2/socket.2:135
#, no-wrap
msgid "Low-level packet interface"
msgstr "低レベルのパケットインターフェース"

#. type: tbl table
#: build/C/man2/socket.2:137
#, no-wrap
msgid "B<packet>(7)"
msgstr "B<packet>(7)"

#. type: TP
#: build/C/man2/socket.2:140 build/C/man7/address_families.7:185
#, no-wrap
msgid "B<AF_RDS>"
msgstr "B<AF_RDS>"

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#. type: tbl table
#: build/C/man2/socket.2:143
#, no-wrap
msgid "Reliable Datagram Sockets (RDS) protocol"
msgstr ""

#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: tbl table
#: build/C/man2/socket.2:147
#, no-wrap
msgid "B<rds>(7)\n"
msgstr "B<rds>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:149
#, no-wrap
msgid "B<rds-rdma>(7)"
msgstr "B<rds-rdma>(7)"

#. type: TP
#: build/C/man2/socket.2:152 build/C/man7/address_families.7:209
#, no-wrap
msgid "B<AF_PPPOX>"
msgstr "B<AF_PPPOX>"

#. type: tbl table
#: build/C/man2/socket.2:155
#, no-wrap
msgid ""
"Generic PPP transport layer, for setting up L2 tunnels\n"
"(L2TP and PPPoE)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:158 build/C/man7/address_families.7:222
#, no-wrap
msgid "B<AF_LLC>"
msgstr "B<AF_LLC>"

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: tbl table
#: build/C/man2/socket.2:161
#, no-wrap
msgid "Logical link control (IEEE 802.2 LLC) protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:164 build/C/man7/address_families.7:245
#, no-wrap
msgid "B<AF_IB>"
msgstr "B<AF_IB>"

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: build/C/man2/socket.2:167
#, no-wrap
msgid "InfiniBand native addressing"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:170 build/C/man7/address_families.7:249
#, no-wrap
msgid "B<AF_MPLS>"
msgstr "B<AF_MPLS>"

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: tbl table
#: build/C/man2/socket.2:173
#, no-wrap
msgid "Multiprotocol Label Switching"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:176 build/C/man7/address_families.7:256
#, no-wrap
msgid "B<AF_CAN>"
msgstr "B<AF_CAN>"

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: tbl table
#: build/C/man2/socket.2:179
#, no-wrap
msgid "Controller Area Network automotive bus protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:182 build/C/man7/address_families.7:263
#, no-wrap
msgid "B<AF_TIPC>"
msgstr "B<AF_TIPC>"

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: tbl table
#: build/C/man2/socket.2:185
#, no-wrap
msgid "TIPC, \"cluster domain sockets\" protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:188 build/C/man7/address_families.7:276
#, no-wrap
msgid "B<AF_BLUETOOTH>"
msgstr "B<AF_BLUETOOTH>"

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: build/C/man2/socket.2:191
#, no-wrap
msgid "Bluetooth low-level socket protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:194 build/C/man7/address_families.7:352
#, no-wrap
msgid "B<AF_ALG>"
msgstr "B<AF_ALG>"

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: build/C/man2/socket.2:197
#, no-wrap
msgid "Interface to kernel crypto API"
msgstr "カーネルの暗号 API へのインターフェース"

#. type: TP
#: build/C/man2/socket.2:200 build/C/man7/address_families.7:358
#, no-wrap
msgid "B<AF_VSOCK>"
msgstr "B<AF_VSOCK>"

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: tbl table
#: build/C/man2/socket.2:204
#, no-wrap
msgid ""
"VSOCK (originally \"VMWare VSockets\") protocol\n"
"for hypervisor-guest communication"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:206
#, no-wrap
msgid "B<vsock>(7)"
msgstr "B<vsock>(7)"

#. type: TP
#: build/C/man2/socket.2:209 build/C/man7/address_families.7:368
#, no-wrap
msgid "B<AF_KCM>"
msgstr "B<AF_KCM>"

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: build/C/man2/socket.2:212
#, no-wrap
msgid "KCM (kernel connection multiplexer) interface"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:215 build/C/man7/address_families.7:400
#, no-wrap
msgid "B<AF_XDP>"
msgstr "B<AF_XDP>"

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: tbl table
#: build/C/man2/socket.2:218
#, no-wrap
msgid "XDP (express data path) interface"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:224
msgid ""
"Further details of the above address families, as well as information on "
"several other address families, can be found in B<address_families>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:230
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""
"ソケットは I<type> で指定される型を持ち、それは通信方式 (semantics) を指定す"
"る。 定義されている型は現在以下の通り。"

#. type: TP
#: build/C/man2/socket.2:230
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr "B<SOCK_STREAM>"

#. type: Plain text
#: build/C/man2/socket.2:234
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""
"順序性と信頼性があり、双方向の、接続された バイトストリーム (byte stream) を"
"提供する。 帯域外 (out-of-band) データ転送メカニズムもサポートされる。"

#. type: TP
#: build/C/man2/socket.2:234
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr "B<SOCK_DGRAM>"

#. type: Plain text
#: build/C/man2/socket.2:238
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""
"データグラム (コネクションレス、信頼性無し、固定最大長メッセージ) をサポート"
"する。"

#. type: TP
#: build/C/man2/socket.2:238
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr "B<SOCK_SEQPACKET>"

#. type: Plain text
#: build/C/man2/socket.2:243
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""
"固定最大長のデータグラム転送パスに基づいた順序性、信頼性のある 双方向の接続に"
"基づいた通信を提供する。受け取り側ではそれぞれの入力 システムコールでパケット"
"全体を読み取ることが要求される。"

#. type: TP
#: build/C/man2/socket.2:243
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr "B<SOCK_RAW>"

#. type: Plain text
#: build/C/man2/socket.2:246
msgid "Provides raw network protocol access."
msgstr "生のネットワークプロトコルへのアクセスを提供する。"

#. type: TP
#: build/C/man2/socket.2:246
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr "B<SOCK_RDM>"

#. type: Plain text
#: build/C/man2/socket.2:249
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr "信頼性はあるが、順序は保証しないデータグラム層を提供する。"

#. type: TP
#: build/C/man2/socket.2:249
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr "B<SOCK_PACKET>"

#. type: Plain text
#: build/C/man2/socket.2:254
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""
"廃止されており新しいプログラムで使用してはいけない。 B<packet>(7)  を参照する"
"こと"

#. type: Plain text
#: build/C/man2/socket.2:256
msgid "Some socket types may not be implemented by all protocol families."
msgstr ""
"ある種のソケット型が全てのプロトコルファミリーで実装されているわけではない。"

#. type: Plain text
#: build/C/man2/socket.2:264
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""
"Linux 2.6.27 以降では、 I<type> 引数は二つ目の目的にも使用される。 ソケットの"
"型を指定するのに加えて、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<socket>()  の振舞いを変更することができる。"

#. type: Plain text
#: build/C/man2/socket.2:300
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""
"I<protocol> はソケットによって使用される固有のプロトコルを指定する。通常それ"
"ぞれの ソケットは、与えられたプロトコルファミリーの種類ごとに一つのプロトコル"
"のみを サポートする。 その場合は I<protocol> に 0 を指定できる。 しかし、多く"
"のプロトコルが存在してもかまわない。 この場合にはこの方法により固有のプロトコ"
"ルを指定する必要がある。 使用されるプロトコル番号は通信の行なわれる``通信ドメ"
"イン''に 固有である; B<protocols>(5)  を参照すること。 プロトコル名をどうやっ"
"てプロトコル番号に対応させるかについては B<getprotoent>(3)  を参照すること。"

#. type: Plain text
#: build/C/man2/socket.2:330
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams.  They do not "
"preserve record boundaries.  A stream socket must be in a I<connected> state "
"before any data may be sent or received on it.  A connection to another "
"socket is created with a B<connect>(2)  call.  Once connected, data may be "
"transferred using B<read>(2)  and B<write>(2)  calls or some variant of the "
"B<send>(2)  and B<recv>(2)  calls.  When a session has been completed a "
"B<close>(2)  may be performed.  Out-of-band data may also be transmitted as "
"described in B<send>(2)  and received as described in B<recv>(2)."
msgstr ""
"B<SOCK_STREAM> 型のソケットは全二重バイトストリームである。 これらはレコード"
"境界を保存しない。 ストリームは、ソケットがデータを送ったり受けたりする前に "
"I<接続された> 状態になってなければならない。他のソケットへの接続は "
"B<connect>(2)  コールによって行なわれる。一度接続したらデータは B<read>(2)  "
"と B<write>(2)  コールや B<send>(2)  と B<recv>(2)  コールの変種を使用して転"
"送できる。 セッションが完了したら B<close>(2)  が行なわれる。帯域外データの転"
"送も B<send>(2)  に記述されており、 受信も B<recv>(2)  に記述されている。"

#. type: Plain text
#: build/C/man2/socket.2:356
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""
"B<SOCK_STREAM> を実装した通信プロトコルはデータに損失や重複がないことを保証す"
"る。 もし相手のプロトコルがバッファー空間を持つ データの断片を適当な時間のう"
"ちに転送できなければ、 接続は断たれたとみなす。そのソケット B<SO_KEEPALIVE> "
"が有効になっている場合、プロトコル独自の方法で接続の相手側がまだ 有効であるか"
"をチェックする。 もしプロセスが、壊れたストリームでデータを送受信しようとした"
"場合には B<SIGPIPE> シグナルが送られる; これは通常のそのシグナルを扱っていな"
"いプロセスを 終了させる。 B<SOCK_SEQPACKET> ソケットは B<SOCK_STREAM> ソケッ"
"トと同じシステムコールを使用する。 唯一の違いは B<read>(2)  コールが要求され"
"た量のデータのみを返し、到着したパケットの残りの部分を 捨ててしまうことであ"
"る。同様に入ってくるデータグラムの全てのメッセージ境界は 保存される。"

#. type: Plain text
#: build/C/man2/socket.2:366
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""
"B<SOCK_DGRAM> と B<SOCK_RAW> ソケットは B<sendto>(2)  コールで指定された相手"
"へデータグラムを送ることが許されている。 データグラムは一般に "
"B<recvfrom>(2)  で受けとり、 このコールは次のデータグラムを送信者のアドレスと"
"一緒に返す。"

#. type: Plain text
#: build/C/man2/socket.2:373
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""
"B<SOCK_PACKET> は古いソケット型で、生(raw)のパケットをデバイスドライバから 直"
"接受信するためのものである。 今は代わりに B<packet>(7)  を用いること。"

#. type: Plain text
#: build/C/man2/socket.2:396
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""
"B<fcntl>(2)  の B<F_SETOWN> 操作を使って、シグナル B<SIGURG> や B<SIGPIPE> を"
"受けとるプロセスグループを指定できる。 B<SIGURG> シグナルは帯域外データが到着"
"した時に、 B<SIGPIPE> シグナルは B<SOCK_STREAM> 接続が予期せず切断された時に"
"送られる。 また、 B<F_SETOWN> 操作は、I/O や I/O イベントの非同期 "
"(asynchronous) 通知を B<SIGIO> を経由で受け取るプロセスやプロセスグループを設"
"定するのにも使用できる。 B<F_SETOWN> を使用することは B<FIOSETOWN> または "
"B<SIOCSPGRP> の引数で B<ioctl>(2)  を使用することと等価である。"

#. type: Plain text
#: build/C/man2/socket.2:406
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using an ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""
"ネットワークがプロトコルモジュールにエラー状態を伝えた場合 (例えば、IP の "
"ICMP メッセージを使用して)には、ソケットの ペンディングエラーフラグが設定され"
"る。次にこのソケットを操作した 時にペンディングされていたエラーコードが返され"
"る。プロトコルによっては エラーについてのより詳しい情報を受け取るためにソケッ"
"トごとのエラーキューを 受け取ることが可能である。 B<ip>(7)  の B<IP_RECVERR> "
"を参照すること。"

#. type: Plain text
#: build/C/man2/socket.2:416
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options."
msgstr ""
"ソケットの操作はソケットレベル I<options> によって制御される。 これらのオプ"
"ションは I<E<lt>sys/socket.hE<gt>> に定義されている。 B<setsockopt>(2)  と "
"B<getsockopt>(2)  関数はそれぞれオプションの設定と取得を行なう。"

#. type: Plain text
#: build/C/man2/socket.2:421
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、新しいソケットのファイルディスクリプターを返す。 エラーが発生し"
"た場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/socket.2:426
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""
"指定されたタイプまたはプロトコルのソケットを作成する許可が与えられていない。"

#. type: Plain text
#: build/C/man2/socket.2:429
msgid "The implementation does not support the specified address family."
msgstr "指定されたアドレスファミリーがサポートされていない。"

#. type: Plain text
#: build/C/man2/socket.2:432
msgid "Unknown protocol, or protocol family not available."
msgstr "知らないプロトコル、または利用できないプロトコルファミリーである。"

#.  Since Linux 2.6.27
#. type: Plain text
#: build/C/man2/socket.2:437
msgid "Invalid flags in I<type>."
msgstr "I<type> に無効なフラグが指定されている。"

#. type: TP
#: build/C/man2/socket.2:443
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr "B<ENOBUFS> または B<ENOMEM>"

#. type: Plain text
#: build/C/man2/socket.2:448
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""
"十分なメモリーがない。十分な資源が解放されるまではソケットを 作成することはで"
"きない。"

#. type: TP
#: build/C/man2/socket.2:448 build/C/man2/socketpair.2:102
#: build/C/man7/vsock.7:218
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: build/C/man2/socket.2:452
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""
"このドメインでは指定されたプロトコルまたはプロトコルタイプが サポートされてい"
"ない。"

#. type: Plain text
#: build/C/man2/socket.2:454
msgid "Other errors may be generated by the underlying protocol modules."
msgstr "下位のプロトコルモジュールから他のエラーが生成されるかもしれない。"

#. type: Plain text
#: build/C/man2/socket.2:456
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:462
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr "フラグ B<SOCK_NONBLOCK>, B<SOCK_CLOEXEC> は Linux 固有である。"

#. type: Plain text
#: build/C/man2/socket.2:468
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants)."
msgstr ""
"B<socket>()  は 4.2BSD で登場した。一般に、(System\\ V の変種を含めて)  BSD "
"のソケット層の互換性をサポートしている BSD 以外のシステムへの、 または、BSD "
"以外のシステムからの移植ができる。"

#. type: Plain text
#: build/C/man2/socket.2:487
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""
"4.x BSD において定数を使用する場合、プロトコルファミリーには\n"
"B<PF_UNIX>, B<PF_INET> 等を使用している。一方でアドレスファミリーには\n"
"B<AF_UNIX>, B<AF_INET> 等が使用されている。\n"
"しかしながら BSD のマニュアルでは 「一般にプロトコルファミリーは\n"
"アドレスファミリーと同じものである。」 と保証している。\n"
"それ以外の規格では全ての場所で AF_* が使用されている。"

#. type: Plain text
#: build/C/man2/socket.2:492
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr "B<socket>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/socket.2:517
msgid ""
"B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), "
"B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), "
"B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), "
"B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), "
"B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"
msgstr "B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: Plain text
#: build/C/man2/socket.2:523
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, (I<UNIX Programmer's "
"Supplementary Documents Volume 1.> として再版された)"

#. type: TH
#: build/C/man7/socket.7:54
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: Plain text
#: build/C/man7/socket.7:57
msgid "socket - Linux socket interface"
msgstr "socket - Linux のソケットインターフェース"

#. type: Plain text
#: build/C/man7/socket.7:61
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/socket.7:80
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> such as B<AF_INET>, B<AF_IPX>, "
"and B<AF_PACKET>, and I<socket types> such as B<SOCK_STREAM> or "
"B<SOCK_DGRAM>.  See B<socket>(2)  for more information on families and types."
msgstr ""
"このマニュアルページは Linux ネットワークのソケット層に対する ユーザーイン"
"ターフェースを記述するものである。 BSD 互換ソケットは、ユーザープロセスとカー"
"ネル内部の ネットワークプロトコルスタック群との間に、 統一的なインターフェー"
"スを提供するものである。 プロトコルモジュールは I<プロトコルファミリー "
"(protocol familiy)> (例： B<AF_INET>, B<AF_IPX>, B<AF_PACKET>)  と I<ソケット"
"タイプ (socket types)> (例： B<SOCK_STREAM>, B<SOCK_DGRAM>)  に分類できる。 "
"これらに関するより詳しい情報は B<socket>(2)  を参照のこと。"

#. type: SS
#: build/C/man7/socket.7:80
#, no-wrap
msgid "Socket-layer functions"
msgstr "ソケット層の関数群"

#. type: Plain text
#: build/C/man7/socket.7:84
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""
"これらの関数はユーザープロセスがパケットを送受信したり、その他のソケット操作"
"を 行ったりするために用いられる。詳細はそれぞれのマニュアルページを 見てほし"
"い。"

#. type: Plain text
#: build/C/man7/socket.7:100
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets "
"(implemented only for a few local families like B<AF_UNIX>)"
msgstr ""
"B<socket>(2)  はソケットを生成する。 B<connect>(2)  はソケットをリモートのソ"
"ケットアドレスに接続する。 B<bind>(2)  はソケットをローカルのソケットアドレス"
"にバインドする。 B<listen>(2)  はソケットに新しい接続が来たら受信するように伝"
"え、 B<accept>(2)  は外部からやってきた接続に対して新しいソケットを得るために"
"用いられる。 B<socketpair>(2)  は互いに接続された二つの名前無しソケット "
"(anonymous socket) を返す (B<AF_UNIX> のような、いくつかのローカルなファミ"
"リーでしか実装されていない)。"

#. type: Plain text
#: build/C/man7/socket.7:122
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr ""
"B<send>(2), B<sendto>(2), B<sendmsg>(2)  はソケットを通してデータを送信し、 "
"B<recv>(2)  B<recvfrom>(2), B<recvmsg>(2)  はソケットからデータを受信する。 "
"B<poll>(2)  と B<select>(2)  はデータの到着を待ったり、データ送信の準備ができ"
"るまで待ったりする。 さらに、 B<write>(2), B<writev>(2), B<sendfile>(2), "
"B<read>(2), B<readv>(2)  のような標準的な I/O 操作もデータの読み書きに用いる"
"ことができる。"

#. type: Plain text
#: build/C/man7/socket.7:133
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""
"B<getsockbyname>(2)  はローカルのソケットアドレスを返し、 B<getpeername>(2)  "
"はリモートのソケットアドレスを返す。 B<getsockopt>(2)  と B<setsockopt>(2)  "
"はソケット層のオプションやプロトコルオプションの取得・設定に用いられる。 他の"
"いくつかのオプションの取得・設定には B<ioctl>(2)  を使うことができる。"

#. type: Plain text
#: build/C/man7/socket.7:138
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""
"B<close>(2)  はソケットをクローズする。 B<shutdown>(2)  は全二重なソケット接"
"続を部分的にクローズする。"

#. type: Plain text
#: build/C/man7/socket.7:144
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""
"シーク動作や、 0 以外の位置に対する B<pread>(2)  や B<pwrite>(2)  はソケット"
"ではサポートされていない。"

#. type: Plain text
#: build/C/man7/socket.7:161
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""
"非ブロッキングな I/O をソケットで行うことは可能で、 B<fcntl>(2)  を使ってソ"
"ケットのファイルディスクリプターに B<O_NONBLOCK> フラグをセットすれば良い。 "
"こうするとブロックされる操作は、 (通常)  B<EAGAIN> エラーで戻ることになる (後"
"で処理が再試行されることが期待されている)。 B<connect>(2)  では "
"B<EINPROGRESS> エラーが返される。 この場合、ユーザーはさまざまなイベントを "
"B<poll>(2)  や B<select>(2)  を使って待つことができる。"

#. type: tbl table
#: build/C/man7/socket.7:165
#, no-wrap
msgid "I/O events"
msgstr "I/O イベント"

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Event"
msgstr "イベント"

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Poll flag"
msgstr "poll フラグ"

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Occurrence"
msgstr "内容"

#. type: tbl table
#: build/C/man7/socket.7:167 build/C/man7/socket.7:170
#: build/C/man7/socket.7:174 build/C/man7/socket.7:177
#, no-wrap
msgid "Read"
msgstr "Read"

#. type: tbl table
#: build/C/man7/socket.7:167 build/C/man7/socket.7:170
#, no-wrap
msgid "POLLIN"
msgstr "POLLIN"

#. type: tbl table
#: build/C/man7/socket.7:169
#, no-wrap
msgid "New data arrived."
msgstr "新しいデータが到着した。"

#. type: tbl table
#: build/C/man7/socket.7:173
#, no-wrap
msgid ""
"A connection setup has been completed\n"
"(for connection-oriented sockets)"
msgstr ""
"(接続志向のソケットで)\n"
"接続の設定が終了した。"

#. type: tbl table
#: build/C/man7/socket.7:174 build/C/man7/socket.7:177
#: build/C/man7/socket.7:196
#, no-wrap
msgid "POLLHUP"
msgstr "POLLHUP"

#. type: tbl table
#: build/C/man7/socket.7:176
#, no-wrap
msgid "A disconnection request has been initiated by the other end."
msgstr "接続先で切断要求が生成された。"

#. type: tbl table
#: build/C/man7/socket.7:182
#, no-wrap
msgid ""
"A connection is broken (only for connection-oriented protocols).\n"
"When the socket is written\n"
"B<SIGPIPE>\n"
"is also sent."
msgstr ""
"接続が壊れた (接続志向のプロトコルのみ)。\n"
"この場合、ソケットに書き込みが行われると\n"
"B<SIGPIPE>\n"
"も送信される。"

#. type: tbl table
#: build/C/man7/socket.7:183
#, no-wrap
msgid "Write"
msgstr "Write"

#. type: tbl table
#: build/C/man7/socket.7:183 build/C/man7/socket.7:190
#, no-wrap
msgid "POLLOUT"
msgstr "POLLOUT"

#. type: tbl table
#: build/C/man7/socket.7:185
#, no-wrap
msgid "Socket has enough send buffer space for writing new data."
msgstr "ソケットには新しいデータを書き込むのに十分なバッファーがある。"

#. type: tbl table
#: build/C/man7/socket.7:186 build/C/man7/socket.7:195
#: build/C/man7/socket.7:196
#, no-wrap
msgid "Read/Write"
msgstr "Read/Write"

#. type: tbl table
#: build/C/man7/socket.7:188
#, no-wrap
msgid "POLLIN |\n"
msgstr "POLLIN |\n"

#. type: tbl table
#: build/C/man7/socket.7:194
#, no-wrap
msgid ""
"An outgoing\n"
"B<connect>(2)\n"
"finished."
msgstr ""
"外部向けの\n"
"B<connect>(2)\n"
"が終了した。"

#. type: tbl table
#: build/C/man7/socket.7:195
#, no-wrap
msgid "POLLERR"
msgstr "POLLERR"

#. type: tbl table
#: build/C/man7/socket.7:195
#, no-wrap
msgid "An asynchronous error occurred."
msgstr "非同期的 (asynchronous) なエラーが起こった。"

#. type: tbl table
#: build/C/man7/socket.7:196
#, no-wrap
msgid "The other end has shut down one direction."
msgstr "接続先が片方向を切断した。"

#. type: tbl table
#: build/C/man7/socket.7:197
#, no-wrap
msgid "Exception"
msgstr "Exception"

#. type: tbl table
#: build/C/man7/socket.7:197
#, no-wrap
msgid "POLLPRI"
msgstr "POLLPRI"

#. type: tbl table
#: build/C/man7/socket.7:201
#, no-wrap
msgid ""
"Urgent data arrived.\n"
"B<SIGURG>\n"
"is sent then."
msgstr ""
"緊急データ (urgent data) が到着した。この場合は\n"
"B<SIGURG>\n"
"が送信される。"

#. type: Plain text
#: build/C/man7/socket.7:229
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""
"B<poll>(2)  や B<select>(2)  を使う代わりに、カーネルからアプリケーションに "
"イベントを通知させるのに B<SIGIO> シグナルを使う方法もある。 この方法を使うに"
"は、 B<fcntl>(2)  を用いてソケットのファイルディスクリプターに B<O_ASYNC> フ"
"ラグをセットし、 B<SIGIO> に対する有効なシグナルハンドラーを "
"B<sigaction>(2)  によって設定しておく必要がある。 後述の I<シグナル> に関する"
"議論も参考にすること。"

#. type: SS
#: build/C/man7/socket.7:229
#, no-wrap
msgid "Socket address structures"
msgstr "ソケットアドレス構造体"

#. type: Plain text
#: build/C/man7/socket.7:245
msgid ""
"Each socket domain has its own format for socket addresses, with a domain-"
"specific address structure.  Each of these structures begins with an integer "
"\"family\" field (typed as I<sa_family_t>)  that indicates the type of the "
"address structure.  This allows the various system calls (e.g., "
"B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2)), which are generic to all socket domains, to determine "
"the domain of a particular socket address."
msgstr ""
"各ソケットドメインにはそれぞれ独自のソケットアドレス形式があり、ドメイン固有"
"のアドレス構造体を持っている。 これらの構造体の先頭には、アドレス構造体の種類"
"を示す整数の \"family\" フィールド (型は I<sa_family_t>) がある。 このフィー"
"ルドにより、 すべてのソケットドメインで汎用的に使用されるシステムコール (例え"
"ば、 B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2) など) が、特定のソケットアドレスのドメインを判定することが"
"できる。"

#. type: Plain text
#: build/C/man7/socket.7:255
msgid ""
"To allow any type of socket address to be passed to interfaces in the "
"sockets API, the type I<struct sockaddr> is defined.  The purpose of this "
"type is purely to allow casting of domain-specific socket address types to a "
"\"generic\" type, so as to avoid compiler warnings about type mismatches in "
"calls to the sockets API."
msgstr ""
"任意の種類のソケットアドレスをソケット API のインターフェースに渡せるよう"
"に、 I<struct sockaddr> 型が定義されている。 この型の目的は、 純粋に、 ドメイ"
"ン固有のソケットアドレスを 「汎用的な」型にキャストできるようにする点にあ"
"る。 これにより、 ソケット API 呼び出しにおいて、 コンパイラが型の不一致の警"
"告を出すのを避けることができる。"

#. type: Plain text
#: build/C/man7/socket.7:265
msgid ""
"In addition, the sockets API provides the data type I<struct "
"sockaddr_storage>.  This type is suitable to accommodate all supported "
"domain-specific socket address structures; it is large enough and is aligned "
"properly.  (In particular, it is large enough to hold IPv6 socket "
"addresses.)  The structure includes the following field, which can be used "
"to identify the type of socket address actually stored in the structure:"
msgstr ""
"これに加えて、ソケット API ではデータ型 I<struct sockaddr_storage> が提供され"
"ている。 サポートしているすべてのドメイン固有のソケットアドレス構造体を収容す"
"るのに、この型を使うことができる。 この型は十分な大きさがあり、(メモリー境界"
"への) アラインも適切に行われている (特に、 IPv6 ソケットアドレスを収容するの"
"にも十分な大きさである)。 この構造体には次のフィールドがあり、 このフィールド"
"を使って、 この構造体に実際に格納されているソケットアドレスの型を特定すること"
"ができる。"

#. type: Plain text
#: build/C/man7/socket.7:269
#, no-wrap
msgid "    sa_family_t ss_family;\n"
msgstr "    sa_family_t ss_family;\n"

#. type: Plain text
#: build/C/man7/socket.7:277
msgid ""
"The I<sockaddr_storage> structure is useful in programs that must handle "
"socket addresses in a generic way (e.g., programs that must deal with both "
"IPv4 and IPv6 socket addresses)."
msgstr ""
"I<sockaddr_storage> 構造体は、 ソケットアドレスを汎用的な方法で扱う必要がある"
"プログラム (例えば、 IPv4 と IPv6 の両方のソケットアドレスを扱う必要があるプ"
"ログラム) で有用である。"

#. type: SS
#: build/C/man7/socket.7:277
#, no-wrap
msgid "Socket options"
msgstr "ソケットオプション"

#.  FIXME .
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: build/C/man7/socket.7:295
msgid ""
"The socket options listed below can be set by using B<setsockopt>(2)  and "
"read with B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for "
"all sockets.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""
"これらのソケットオプションは、 B<setsockopt>(2)  を用いれば設定でき、 "
"B<getsockopt>(2)  を用いれば取得できる。 但し、どのソケットの場合も ソケット"
"レベルには B<SOL_SOCKET> を指定すること。 注釈がない限り、 I<optval> は "
"I<int> へのポインターである。"

#. type: TP
#: build/C/man7/socket.7:295
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr "B<SO_ACCEPTCONN>"

#. type: Plain text
#: build/C/man7/socket.7:303
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""
"このソケットが B<listen>(2)  によって接続待ち受け状態に設定されているかどうか"
"を示す値を返す。 値 0 は listen 状態のソケットでないことを、 値 1 は listen "
"状態のソケットであることを示す。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:303
#, no-wrap
msgid "B<SO_ATTACH_FILTER> (since Linux 2.2), B<SO_ATTACH_BPF> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:316
msgid ""
"Attach a classic BPF (B<SO_ATTACH_FILTER>)  or an extended BPF "
"(B<SO_ATTACH_BPF>)  program to the socket for use as a filter of incoming "
"packets.  A packet will be dropped if the filter program returns zero.  If "
"the filter program returns a nonzero value which is less than the packet's "
"data length, the packet will be truncated to the length returned.  If the "
"value returned by the filter is greater than or equal to the packet's data "
"length, the packet is allowed to proceed unmodified."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:323
msgid ""
"The argument for B<SO_ATTACH_FILTER> is a I<sock_fprog> structure, defined "
"in I<E<lt>linux/filter.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:330
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;\n"
"    struct sock_filter *filter;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:339
msgid ""
"The argument for B<SO_ATTACH_BPF> is a file descriptor returned by the "
"B<bpf>(2)  system call and must refer to a program of type "
"B<BPF_PROG_TYPE_SOCKET_FILTER>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:345
msgid ""
"These options may be set multiple times for a given socket, each time "
"replacing the previous filter program.  The classic and extended versions "
"may be called on the same socket, but the previous filter will always be "
"replaced such that a socket never has more than one filter defined."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:348
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:348
#, no-wrap
msgid "B<SO_ATTACH_REUSEPORT_CBPF>, B<SO_ATTACH_REUSEPORT_EBPF>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:360
msgid ""
"For use with the B<SO_REUSEPORT> option, these options allow the user to set "
"a classic BPF (B<SO_ATTACH_REUSEPORT_CBPF>)  or an extended BPF "
"(B<SO_ATTACH_REUSEPORT_EBPF>)  program which defines how packets are "
"assigned to the sockets in the reuseport group (that is, all sockets which "
"have B<SO_REUSEPORT> set and are using the same local address to receive "
"packets)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:368
msgid ""
"The BPF program must return an index between 0 and N-1 representing the "
"socket which should receive the packet (where N is the number of sockets in "
"the group).  If the BPF program returns an invalid index, socket selection "
"will fall back to the plain B<SO_REUSEPORT> mechanism."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:380
msgid ""
"Sockets are numbered in the order in which they are added to the group (that "
"is, the order of B<bind>(2)  calls for UDP sockets or the order of "
"B<listen>(2)  calls for TCP sockets).  New sockets added to a reuseport "
"group will inherit the BPF program.  When a socket is removed from a "
"reuseport group (via B<close>(2)), the last socket in the group will be "
"moved into the closed socket's position."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:383
msgid ""
"These options may be set repeatedly at any time on any socket in the group "
"to replace the current BPF program used by all sockets in the group."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:391
msgid ""
"B<SO_ATTACH_REUSEPORT_CBPF> takes the same argument type as "
"B<SO_ATTACH_FILTER> and B<SO_ATTACH_REUSEPORT_EBPF> takes the same argument "
"type as B<SO_ATTACH_BPF>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:394
msgid ""
"UDP support for this feature is available since Linux 4.5; TCP support is "
"available since Linux 4.6."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:394
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr "B<SO_BINDTODEVICE>"

#. type: Plain text
#: build/C/man7/socket.7:413
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this works only for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""
"このソケットを、引数で渡したインターフェース名で指定される (\\(lqeth0\\(rq "
"のような) 特定のデバイスにバインドする。 名前が空文字列だったり、オプションの"
"長さ (optlen) が 0 の場合には、 ソケットのバインドが削除される。 渡すオプショ"
"ンは、インターフェース名が 入ったヌル文字で終端された可変長の文字列である。 "
"文字列の最大のサイズは B<IFNAMSIX> である。 ソケットがインターフェースにバイ"
"ンドされると、 その特定のインターフェースから受信されたパケットだけを処理す"
"る。 このオプションはいくつかのソケットタイプ、 特に B<AF_INET> に対してのみ"
"動作する点に注意すること。 パケットソケットではサポートされていない (通常の "
"B<bind>(2) を使うこと)。"

#. type: Plain text
#: build/C/man7/socket.7:427
msgid ""
"Before Linux 3.8, this socket option could be set, but could not retrieved "
"with B<getsockopt>(2).  Since Linux 3.8, it is readable.  The I<optlen> "
"argument should contain the buffer size available to receive the device name "
"and is recommended to be B<IFNAMSIZ> bytes.  The real device name length is "
"reported back in the I<optlen> argument."
msgstr ""
"Linux 3.8 より前のバージョンでは、このソケットオプションは B<getsockname>(2) "
"で設定することはできたが、取得することができなかった。 Linux 3.8 以降では、読"
"み出すことができる。 I<optlen> 引数には、 デバイス名を格納するのに十分な"
"バッファーサイズを渡すべきであり、 B<IFNAMSIZ> バイトにすることを推奨する。 "
"実際のデバイス名の長さは I<optlen> 引数に格納されて返される。"

#. type: TP
#: build/C/man7/socket.7:427
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr "B<SO_BROADCAST>"

#. type: Plain text
#: build/C/man7/socket.7:433
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on stream-"
"oriented sockets."
msgstr ""
"ブロードキャストフラグを設定・取得する。有効になっていると、データグラ\n"
"ムソケットはブロードキャストアドレスにパケットを送信できるようになる。\n"
"ストリーム指向のソケットには何の効果もない。"

#. type: TP
#: build/C/man7/socket.7:433
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr "B<SO_BSDCOMPAT>"

#. type: Plain text
#: build/C/man7/socket.7:445
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled, ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""
"BSD のバグに対して互換性を取るための機能を有効にする。 この機能は Linux 2.0 "
"と 2.2 の UDP プロトコルモジュールで使用されている。 有効になっていると、 "
"UDP ソケットで受信された ICMP エラーは ユーザープログラムに渡されない。 これ"
"以降のバージョンのカーネルでは、このオプションのサポートは 段階的に廃止されて"
"きた。 Linux 2.4 ではこのオプションは黙って無視され、 Linux 2.6 ではプログラ"
"ムがこのオプションを使用すると (printk() を使って)  カーネルの警告メッセージ"
"が出力される。 Linux 2.0 では、このオプションを指定すると、 raw ソケットにお"
"いても BSD のバグ (ランダムヘッダー変更、 ブロードキャストフラグのスキップ)  "
"に対する互換機能が有効になっていた。 しかし、こちらは Linux 2.2 で削除され"
"た。"

#. type: TP
#: build/C/man7/socket.7:445
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr "B<SO_DEBUG>"

#. type: Plain text
#: build/C/man7/socket.7:451
msgid ""
"Enable socket debugging.  Allowed only for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""
"ソケットのデバッグ機能を有効にする。 B<CAP_NET_ADMIN> 権限を持つプロセスか、"
"実効ユーザー ID が 0 のプロセスでしか 利用できない。"

#. type: TP
#: build/C/man7/socket.7:451
#, no-wrap
msgid "B<SO_DETACH_FILTER> (since Linux 2.2), B<SO_DETACH_BPF> (since Linux 3.19)"
msgstr "B<SO_DETACH_FILTER> (Linux 2.2 以降), B<SO_DETACH_BPF> (Linux 3.19 以降)"

#. type: Plain text
#: build/C/man7/socket.7:460
msgid ""
"These two options, which are synonyms, may be used to remove the classic or "
"extended BPF program attached to a socket with either B<SO_ATTACH_FILTER> or "
"B<SO_ATTACH_BPF>.  The option value is ignored."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:460
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr "B<SO_DOMAIN> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man7/socket.7:468
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"ソケットドメインを整数で取得する。 B<AF_INET6> のような値が返される。\n"
"詳細は B<socket>(2) を参照。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:468
#, no-wrap
msgid "B<SO_ERROR>"
msgstr "B<SO_ERROR>"

#. type: Plain text
#: build/C/man7/socket.7:473
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""
"保留になっていたソケットエラーを取得してクリアする。\n"
"このソケットオプションは読み込み専用である。整数値をとる。"

#. type: TP
#: build/C/man7/socket.7:473
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr "B<SO_DONTROUTE>"

#. type: Plain text
#: build/C/man7/socket.7:482
msgid ""
"Don't send via a gateway, send only to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""
"ゲートウェイを経由せず、直接接続されているホストにのみ送信する。 B<send>(2)  "
"操作で B<MSG_DONTROUTE> フラグをセットした場合も同じ効果が得られる。 ブール整"
"数のフラグを取る。"

#. type: TP
#: build/C/man7/socket.7:482
#, no-wrap
msgid "B<SO_INCOMING_CPU> (gettable since Linux 3.19, settable since Linux 4.4)"
msgstr ""

#.  getsockopt 2c8c56e15df3d4c2af3d656e44feb18789f75837
#.  setsockopt 70da268b569d32a9fddeea85dc18043de9d89f89
#. type: Plain text
#: build/C/man7/socket.7:488
msgid "Sets or gets the CPU affinity of a socket.  Expects an integer flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:494
#, no-wrap
msgid ""
"int cpu = 1;\n"
"setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu,\n"
"           sizeof(cpu));\n"
msgstr ""
"int cpu = 1;\n"
"setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu,\n"
"           sizeof(cpu));\n"

#
#
#
#.  From an email conversation with Eric Dumazet:
#.  >> Note that setting the option is not supported if SO_REUSEPORT is used.
#.  >
#.  > Please define "not supported". Does this yield an API diagnostic?
#.  > If so, what is it?
#.  >
#.  >> Socket will be selected from an array, either by a hash or BPF program
#.  >> that has no access to this information.
#.  >
#.  > Sorry -- I'm lost here. How does this comment relate to the proposed
#.  > man page text above?
#.  Simply that :
#.  If an application uses both SO_INCOMING_CPU and SO_REUSEPORT, then
#.  SO_REUSEPORT logic, selecting the socket to receive the packet, ignores
#.  SO_INCOMING_CPU setting.
#. type: Plain text
#: build/C/man7/socket.7:522
msgid ""
"Because all of the packets for a single stream (i.e., all packets for the "
"same 4-tuple)  arrive on the single RX queue that is associated with a "
"particular CPU, the typical use case is to employ one listening process per "
"RX queue, with the incoming flow being handled by a listener on the same CPU "
"that is handling the RX queue.  This provides optimal NUMA behavior and "
"keeps CPU caches hot."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:522
#, fuzzy, no-wrap
#| msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgid "B<SO_INCOMING_NAPI_ID> (gettable since Linux 4.12)"
msgstr "B<MSG_NOSIGNAL> (Linux 2.2 以降)"

#.  getsockopt 6d4339028b350efbf87c61e6d9e113e5373545c9
#. type: Plain text
#: build/C/man7/socket.7:528
msgid ""
"Returns a system-level unique ID called NAPI ID that is associated with a RX "
"queue on which the last packet associated with that socket is received."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:538
msgid ""
"This can be used by an application to split the incoming flows among worker "
"threads based on the RX queue on which the packets associated with the flows "
"are received.  It allows each worker thread to be associated with a NIC HW "
"receive queue and service all the connection requests received on that RX "
"queue.  This mapping between a app thread and a HW NIC queue streamlines the "
"flow of data from the NIC to the application."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:538
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr "B<SO_KEEPALIVE>"

#. type: Plain text
#: build/C/man7/socket.7:542
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""
"接続志向のソケットに対する keep-alive メッセージの送信を有効にする。 ブール値"
"の整数フラグをとる。"

#. type: TP
#: build/C/man7/socket.7:542
#, no-wrap
msgid "B<SO_LINGER>"
msgstr "B<SO_LINGER>"

#. type: Plain text
#: build/C/man7/socket.7:550
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> structure."
msgstr ""
"B<SO_LINGER> オプションを取得・設定する。引数には I<linger> 構造体を取る。"

#. type: Plain text
#: build/C/man7/socket.7:557
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"

#. type: Plain text
#: build/C/man7/socket.7:571
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""
"有効になっていると、 B<close>(2)  や B<shutdown>(2)  は、そのソケットにキュー"
"イングされたメッセージがすべて送信完了するか、 linger (居残り) タイムアウトに"
"なるまで返らない。無効になっていると、 これらのコールはただちに戻り、クローズ"
"動作はバックグラウンドで行われる。 ソケットのクローズを B<exit>(2)  の一部と"
"して行った場合には、残っているソケットの クローズ動作は必ずバックグラウンドに"
"送られる。"

#. type: TP
#: build/C/man7/socket.7:571
#, no-wrap
msgid "B<SO_LOCK_FILTER>"
msgstr "B<SO_LOCK_FILTER>"

#.  commit d59577b6ffd313d0ab3be39cb1ab47e29bdc9182
#. type: Plain text
#: build/C/man7/socket.7:582
msgid ""
"When set, this option will prevent changing the filters associated with the "
"socket.  These filters include any set using the socket options "
"B<SO_ATTACH_FILTER>, B<SO_ATTACH_BPF>, B<SO_ATTACH_REUSEPORT_CBPF>, and "
"B<SO_ATTACH_REUSEPORT_EBPF>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:591
msgid ""
"The typical use case is for a privileged process to set up a raw socket (an "
"operation that requires the B<CAP_NET_RAW> capability), apply a restrictive "
"filter, set the B<SO_LOCK_FILTER> option, and then either drop its "
"privileges or pass the socket file descriptor to an unprivileged process via "
"a UNIX domain socket."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:599
msgid ""
"Once the B<SO_LOCK_FILTER> option has been enabled, attempts to change or "
"remove the filter attached to a socket, or to disable the B<SO_LOCK_FILTER> "
"option will fail with the error B<EPERM>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:599
#, no-wrap
msgid "B<SO_MARK> (since Linux 2.6.25)"
msgstr "B<SO_MARK> (Linux 2.6.25 以降)"

#.  commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
#.  and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
#. type: Plain text
#: build/C/man7/socket.7:610
msgid ""
"Set the mark for each packet sent through this socket (similar to the "
"netfilter MARK target but socket-based).  Changing the mark can be used for "
"mark-based routing without netfilter or for packet filtering.  Setting this "
"option requires the B<CAP_NET_ADMIN> capability."
msgstr ""
"このソケットから送信される各パケットにマークをセットする (netfilter の MARK "
"ターゲットと似ているが、ソケット単位である点が異なる)。 マークの変更は、 "
"netfilter なしでのマークに基づいてのルーティングや、 パケットフィルタリングに"
"使うことができる。 このオプションを変更するには B<CAP_NET_ADMIN> ケーパビリ"
"ティが必要である。"

#. type: TP
#: build/C/man7/socket.7:610
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr "B<SO_OOBINLINE>"

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#.      The kernel has support for the SO_NO_CHECK socket
#.      option (boolean: 0 == default, calculate checksum on xmit,
#.      1 == do not calculate checksum on xmit).
#.  Additional note from Andi Kleen on SO_NO_CHECK (2010-08-30)
#.      On Linux UDP checksums are essentially free and there's no reason
#.      to turn them off and it would disable another safety line.
#.      That is why I didn't document the option.
#. type: Plain text
#: build/C/man7/socket.7:626
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise, out-of-band data is passed only when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""
"このオプションを有効にすると、帯域外データ (out-of-band data) は 受信データス"
"トリーム中に置かれる。有効にしなければ、 帯域外データは受信時に B<MSG_OOB> フ"
"ラグがセットされている場合に限って渡される。"

#. type: TP
#: build/C/man7/socket.7:626
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
#: build/C/man7/socket.7:633
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""
"B<SCM_CREDENTIALS> 制御メッセージの受信を有効/無効にする。詳細は B<unix>(7)  "
"を参照のこと。"

#. type: TP
#: build/C/man7/socket.7:633
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr "B<SO_PASSSEC>"

#. type: Plain text
#: build/C/man7/socket.7:640
msgid ""
"Enable or disable the receiving of the B<SCM_SECURITY> control message.  For "
"more information see B<unix>(7)."
msgstr "B<SCM_SECURITY> 制御メッセージの受信を有効/無効にする。詳細は B<unix>(7)  を参照のこと。"

#. type: TP
#: build/C/man7/socket.7:640
#, no-wrap
msgid "B<SO_PEEK_OFF> (since Linux 3.4)"
msgstr "B<SO_PEEK_OFF> (Linux 3.4 以降)"

#.  commit ef64a54f6e558155b4f149bb10666b9e914b6c54
#. type: Plain text
#: build/C/man7/socket.7:650
msgid ""
"This option, which is currently supported only for B<unix>(7)  sockets, sets "
"the value of the \"peek offset\" for the B<recv>(2)  system call when used "
"with B<MSG_PEEK> flag."
msgstr ""
"B<MSG_PEEK> フラグと一緒に使用された場合 B<recv>(2) システムコールの \"peek "
"offset\" にこのオプションの値が設定される。現在のところ、このオプションは "
"B<unix>(7) ソケットでのみサポートされている。"

#. type: Plain text
#: build/C/man7/socket.7:658
msgid ""
"When this option is set to a negative value (it is set to -1 for all new "
"sockets), traditional behavior is provided: B<recv>(2)  with the B<MSG_PEEK> "
"flag will peek data from the front of the queue."
msgstr ""
"このオプションが負の値に設定された場合、従来の動作となる。 つまり "
"B<MSG_PEEK> フラグが指定された B<recv>(2) は、キューの先頭のデータに対して "
"peek 処理を行う (データを読み出すが、キューからデータの削除を行わない)。 新規"
"のソケットではこのオプションの値は必ず -1 に設定される。"

#. type: Plain text
#: build/C/man7/socket.7:665
msgid ""
"When the option is set to a value greater than or equal to zero, then the "
"next peek at data queued in the socket will occur at the byte offset "
"specified by the option value.  At the same time, the \"peek offset\" will "
"be incremented by the number of bytes that were peeked from the queue, so "
"that a subsequent peek will return the next data in the queue."
msgstr ""
"このオプションに 0 以上の値が設定されると、 そのソケットのキュー上のオプショ"
"ン値で指定されたバイトオフセットにあるデータが次の peek 処理で返される。 同時"
"に、 \"peek offset\" がキューから peek 処理されたバイト数だけ加算される。した"
"がって、次の peek 処理ではキューのその次にあるデータが返される。"

#. type: Plain text
#: build/C/man7/socket.7:677
msgid ""
"If data is removed from the front of the queue via a call to B<recv>(2)  (or "
"similar) without the B<MSG_PEEK> flag, the \"peek offset\" will be decreased "
"by the number of bytes removed.  In other words, receiving data without the "
"B<MSG_PEEK> flag will cause the \"peek offset\" to be adjusted to maintain "
"the correct relative position in the queued data, so that a subsequent peek "
"will retrieve the data that would have been retrieved had the data not been "
"removed."
msgstr ""
"B<recv>(2) (や同様のシステムコール) の B<MSG_PEEK> フラグなしの呼び出しで"
"キューの先頭のデータが削除された場合、 \"peek offset\" は削除されたバイト数だ"
"け減算される。 言い換えると、 B<MSG_PEEK> フラグなしでデータを受信すると、 "
"\"peek offset\" が指すキュー内の相対的な位置が狂わないように調整され、この後"
"の peek では、 データ削除が行われなかった場合に返されたのと同じ値が返されると"
"いうことである。"

#. type: Plain text
#: build/C/man7/socket.7:682
msgid ""
"For datagram sockets, if the \"peek offset\" points to the middle of a "
"packet, the data returned will be marked with the B<MSG_TRUNC> flag."
msgstr ""
"データグラムソケットでは、 \"peek offset\" がパケットの途中を指している場合に"
"は、 返されるデータには B<MSG_TRUNC> フラグが付与される。"

#. type: Plain text
#: build/C/man7/socket.7:686
msgid ""
"The following example serves to illustrate the use of B<SO_PEEK_OFF>.  "
"Suppose a stream socket has the following queued input data:"
msgstr ""
"以下の例は B<SO_PEEK_OFF> の利用例を示している。ストリームソケットのキューに"
"以下の入力データが入っているものとする。"

#. type: Plain text
#: build/C/man7/socket.7:688
#, no-wrap
msgid "    aabbccddeeff\n"
msgstr "    aabbccddeeff\n"

#. type: Plain text
#: build/C/man7/socket.7:692
msgid ""
"The following sequence of B<recv>(2)  calls would have the effect noted in "
"the comments:"
msgstr ""
"以下の順序で B<recv>(2) の呼び出しを行うと、コメントに書かれた結果となる。"

#. type: Plain text
#: build/C/man7/socket.7:697
#, no-wrap
msgid ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"
msgstr ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"

#. type: Plain text
#: build/C/man7/socket.7:702
#, no-wrap
msgid ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"
msgstr ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"

#. type: TP
#: build/C/man7/socket.7:704
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: build/C/man7/socket.7:709
msgid ""
"Return the credentials of the peer process connected to this socket.  For "
"further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:709
#, no-wrap
msgid "B<SO_PEERSEC> (since Linux 2.6.2)"
msgstr "B<SO_PEERSEC> (Linux 2.6.2 以降)"

#. type: Plain text
#: build/C/man7/socket.7:716
msgid ""
"Return the security context of the peer socket connected to this socket.  "
"For further details, see B<unix>(7)  and B<ip>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:716
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr "B<SO_PRIORITY>"

#.  For
#.  .BR ip (7),
#.  this also sets the IP type-of-service (TOS) field for outgoing packets.
#. type: Plain text
#: build/C/man7/socket.7:729
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  Setting a priority outside the range 0 to 6 requires "
"the B<CAP_NET_ADMIN> capability."
msgstr "プロトコルで定義された優先度を、このソケットから 送信される全てのパケットにセットする。 Linux はネットワークキュー内部の 整列にこの値を用いる。高い優先度を持っているパケットは先に処理される。 ただしそのデバイスのキュー処理のやり方に依存する。 0 から 6 以外の優先度をセットするには B<CAP_NET_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man7/socket.7:729
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr "B<SO_PROTOCOL> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man7/socket.7:737
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"ソケットのプロトコルを整数で取得する。 B<IPPROTO_SCTP> のような値が返され"
"る。\n"
"詳細は B<socket>(2) を参照。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:737
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr "B<SO_RCVBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  The following thread on LMKL is quite informative:
#.  getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behavior
#.  17 July 2012
#.  http://thread.gmane.org/gmane.linux.kernel/1328935
#. type: Plain text
#: build/C/man7/socket.7:756
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""
"ソケットの受信バッファーの最大サイズを設定・取得する (バイト単位)。 "
"B<setsockopt>(2)  を使って値が設定されたときに (管理オーバヘッド用の領域を確"
"保するために)  カーネルはこの値を 2倍し、 B<getsockopt>(2)  はこの 2倍された"
"値を返す。 デフォルトの値は I</proc/sys/net/core/rmem_default> ファイルで設定"
"され、許容される最大の値は I</proc/sys/net/core/rmem_max> ファイルで設定され"
"る。 このオプションの最小値は (2倍した値で) 256 である。"

#. type: TP
#: build/C/man7/socket.7:756
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_RCVBUFFORCE> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/socket.7:765
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""
"このソケットオプションを使うと、特権プロセス (B<CAP_NET_ADMIN> を持つプロセ"
"ス) は B<SO_RCVBUF> と同じことを実行できる。 ただし、上限 I<rmem_max> を上書"
"きすることができる。"

#. type: TP
#: build/C/man7/socket.7:765
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr "B<SO_RCVLOWAT> と B<SO_SNDLOWAT>"

#. type: Plain text
#: build/C/man7/socket.7:781
#, fuzzy
#| msgid ""
#| "Specify the minimum number of bytes in the buffer until the socket layer "
#| "will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
#| "receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
#| "B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with "
#| "the error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux "
#| "2.4.  The B<select>(2)  and B<poll>(2)  system calls currently do not "
#| "respect the B<SO_RCVLOWAT> setting on Linux, and mark a socket readable "
#| "when even a single byte of data is available.  A subsequent read from the "
#| "socket will block until B<SO_RCVLOWAT> bytes are available."
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4."
msgstr ""
"バッファー中に溜めることのできるデータの最小値を指定する。 このサイズを越える"
"と、ソケット層はそのデータをプロトコルに渡し (B<SO_SNDLOWAT>)、 受信時には"
"ユーザーに渡す (B<SO_RCVLOWAT>)。 これら二つの値は 1 に初期化される。 "
"B<SO_SNDLOWAT> は Linux では変更できない (B<setsockopt>(2)  は "
"B<ENOPROTOOPT> エラーで失敗する)。 B<SO_RCVLOWAT> は Linux 2.4 以降でのみ変更"
"可能である。 現状、Linux ではシステムコール B<select>(2)  と B<poll>(2)  は "
"B<SO_RCVLOWAT> の設定を考慮に入れずに動作し、 データが1バイト利用可能になった"
"だけでも、 ソケットは読み出し可能とのマークをつける。 一方、それに続けて行う"
"ソケットからの read は B<SO_RCVLOWAT> バイトのデータが利用可能になるまで停止"
"してしまう。"

#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#.  commit c7004482e8dcb7c3c72666395cfa98a216a4fb70
#. type: Plain text
#: build/C/man7/socket.7:805
msgid ""
"Before Linux 2.6.28 B<select>(2), B<poll>(2), and B<epoll>(7)  did not "
"respect the B<SO_RCVLOWAT> setting on Linux, and indicated a socket as "
"readable when even a single byte of data was available.  A subsequent read "
"from the socket would then block until B<SO_RCVLOWAT> bytes are available.  "
"Since Linux 2.6.28, B<select>(2), B<poll>(2), and B<epoll>(7)  indicate a "
"socket as readable only if at least B<SO_RCVLOWAT> bytes are available."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:805
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr "B<SO_RCVTIMEO> と B<SO_SNDTIMEO>"

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: build/C/man7/socket.7:840
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached, then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK>, or B<EINPROGRESS> (for "
"B<connect>(2))  just as if the socket was specified to be nonblocking.  If "
"the timeout is set to zero (the default), then the operation will never "
"timeout.  Timeouts only have effect for system calls that perform socket I/O "
"(e.g., B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have "
"no effect for B<select>(2), B<poll>(2), B<epoll_wait>(2), and so on."
msgstr ""
"送信・受信のタイムアウトを指定する。これを越えるとエラーを報告する。 引数"
"は I<struct timeval> である。 入出力関数がタイムアウト時間の間ブロックされ、"
"かつデータの送信または 受信が行われていた場合は、転送されたデータ量が関数の返"
"り値となる。 何もデータが転送されずにタイムアウトに達した場合は、 -1 を返"
"し、 I<errno> に B<EAGAIN> か B<EWOULDBLOCK> か B<EINPROGRESS> "
"(B<connect>(2) の場合) が設定され、 あたかもソケットに非ブロッキングが指定さ"
"れたように見える。 タイムアウト値に (デフォルト値である) 0 に設定すると、 操"
"作は決してタイムアウトしなくなる。 タイムアウトが影響を及ぼすのは、 ソケット "
"I/O を実行するシステムコールだけ (例えば B<read>(2), B<recvmsg>(2), "
"B<send>(2), B<sendmsg>(2))  である。 B<select>(2), B<poll>(2), "
"B<epoll_wait>(2)  などにはタイムアウトは影響を及ぼさない。"

#. type: TP
#: build/C/man7/socket.7:840
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr "B<SO_REUSEADDR>"

#. 	commit c617f398edd4db2b8567a28e899a88f8f574798d
#. 	https://lwn.net/Articles/542629/
#. type: Plain text
#: build/C/man7/socket.7:857
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr ""
"B<bind>(2)  コールに与えられたアドレスが正しいかを判断するルールで、 ローカル"
"アドレスの再利用を可能にする。 つまり B<AF_INET> ソケットなら、そのアドレスに"
"バインドされたアクティブな listen 状態のソケットが存在しない限り、バインドが"
"行える。 listen 状態のソケットがアドレス B<INADDR_ANY> で特定のポートにバイン"
"ドされている場合には、 このポートに対しては、どんなローカルアドレスでもバイン"
"ドできない。 引数はブール整数のフラグである。"

#. type: TP
#: build/C/man7/socket.7:857
#, no-wrap
msgid "B<SO_REUSEPORT> (since Linux 3.9)"
msgstr "B<SO_REUSEPORT> (Linux 3.9 以降)"

#. type: Plain text
#: build/C/man7/socket.7:872
msgid ""
"Permits multiple B<AF_INET> or B<AF_INET6> sockets to be bound to an "
"identical socket address.  This option must be set on each socket (including "
"the first socket)  prior to calling B<bind>(2)  on the socket.  To prevent "
"port hijacking, all of the processes binding to the same address must have "
"the same effective UID.  This option can be employed with both TCP and UDP "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:884
msgid ""
"For TCP sockets, this option allows B<accept>(2)  load distribution in a "
"multi-threaded server to be improved by using a distinct listener socket for "
"each thread.  This provides improved load distribution as compared to "
"traditional techniques such using a single B<accept>(2)ing thread that "
"distributes connections, or having multiple threads that compete to "
"B<accept>(2)  from the same socket."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:890
msgid ""
"For UDP sockets, the use of this option can provide better distribution of "
"incoming datagrams to multiple processes (or threads) as compared to the "
"traditional technique of having multiple processes compete to receive "
"datagrams on the same socket."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:890
#, no-wrap
msgid "B<SO_RXQ_OVFL> (since Linux 2.6.33)"
msgstr "B<SO_RXQ_OVFL> (Linux 2.6.33 以降)"

#.  commit 3b885787ea4112eaa80945999ea0901bf742707f
#. type: Plain text
#: build/C/man7/socket.7:896
#, fuzzy
#| msgid ""
#| "Indicates that an unsigned 32-bit value ancillary message (cmsg)  should "
#| "be attached to received skbs indicating the number of packets dropped by "
#| "the socket between the last received packet and this received packet."
msgid ""
"Indicates that an unsigned 32-bit value ancillary message (cmsg)  should be "
"attached to received skbs indicating the number of packets dropped by the "
"socket since its creation."
msgstr ""
"最後の受信パケットとこの受信パケットの間にそのソケットで捨てられた (ドロップ"
"された) パケット数を示す、unsigned 32 ビット値の補助メッセージ (cmsg) を受信"
"した skb に付与することを指示する。"

#. type: TP
#: build/C/man7/socket.7:896
#, no-wrap
msgid "B<SO_SELECT_ERR_QUEUE> (since Linux 3.10)"
msgstr "B<SO_SELECT_ERR_QUEUE> (Linux 3.10 以降)"

#. 	commit 7d4c04fc170087119727119074e72445f2bb192b
#. 	Author: Keller, Jacob E <jacob.e.keller@intel.com>
#.  It does not affect wake up.
#. type: Plain text
#: build/C/man7/socket.7:913
msgid ""
"When this option is set on a socket, an error condition on a socket causes "
"notification not only via the I<exceptfds> set of B<select>(2).  Similarly, "
"B<poll>(2)  also returns a B<POLLPRI> whenever an B<POLLERR> event is "
"returned."
msgstr ""

#.  commit 6e5d58fdc9bedd0255a8
#.  ("skbuff: Fix not waking applications when errors are enqueued")
#. type: Plain text
#: build/C/man7/socket.7:932
msgid ""
"Background: this option was added when waking up on an error condition "
"occurred only via the I<readfds> and I<writefds> sets of B<select>(2).  The "
"option was added to allow monitoring for error conditions via the "
"I<exceptfds> argument without simultaneously having to receive notifications "
"(via I<readfds>)  for regular data that can be read from the socket.  After "
"changes in Linux 4.16, the use of this flag to achieve the desired "
"notifications is no longer necessary.  This option is nevertheless retained "
"for backwards compatibility."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:932
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr "B<SO_SNDBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
#. type: Plain text
#: build/C/man7/socket.7:948
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""
"ソケットの送信バッファーの最大サイズを設定・取得する (バイト単位)。 "
"B<setsockopt>(2)  を使って値が設定されたときに (管理オーバヘッド用の領域を確"
"保するために)  カーネルはこの値を 2倍し、 B<getsockopt>(2)  はこの 2倍された"
"値を返す。 デフォルトの値は I</proc/sys/net/core/wmem_default> ファイルで設定"
"され、許容される最大の値は I</proc/sys/net/core/wmem_max> ファイルで設定され"
"る。 このオプションの最小値は (2倍した値で) 2048 である。"

#. type: TP
#: build/C/man7/socket.7:948
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_SNDBUFFORCE> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/socket.7:957
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""
"このソケットオプションを使うと、特権プロセス (B<CAP_NET_ADMIN> を持つプロセ"
"ス) は B<SO_SNDBUF> と同じことを実行できる。 ただし、上限 I<wmem_max> を上書"
"きすることができる。"

#. type: TP
#: build/C/man7/socket.7:957
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr "B<SO_TIMESTAMP>"

#. type: Plain text
#: build/C/man7/socket.7:977
#, fuzzy
#| msgid ""
#| "Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  "
#| "The timestamp control message is sent with level B<SOL_SOCKET> and the "
#| "I<cmsg_data> field is a I<struct timeval> indicating the reception time "
#| "of the last packet passed to the user in this call.  See B<cmsg>(3)  for "
#| "details on control messages."
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and a "
"I<cmsg_type> of B<SCM_TIMESTAMP>.  The I<cmsg_data> field is a I<struct "
"timeval> indicating the reception time of the last packet passed to the user "
"in this call.  See B<cmsg>(3)  for details on control messages."
msgstr ""
"B<SO_TIMESTAMP> 制御メッセージの受信を有効/無効にする。 タイムスタンプ制御"
"メッセージはレベル B<SOL_SOCKET> で送信され、 I<cmsg_data> フィールドはこのシ"
"ステムコールでユーザーに渡した 最後のパケットの受信時刻を示す I<struct "
"timeval> である。 制御メッセージの詳細については B<cmsg>(3)  を参照。"

#. type: TP
#: build/C/man7/socket.7:977
#, no-wrap
msgid "B<SO_TIMESTAMPNS> (since Linux 2.6.22)"
msgstr "B<SO_TIMESTAMPNS> (Linux 2.6.22 以降)"

#.  commit 92f37fd2ee805aa77925c1e64fd56088b46094fc
#. type: Plain text
#: build/C/man7/socket.7:1000
#, fuzzy
#| msgid ""
#| "Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  "
#| "The timestamp control message is sent with level B<SOL_SOCKET> and the "
#| "I<cmsg_data> field is a I<struct timeval> indicating the reception time "
#| "of the last packet passed to the user in this call.  See B<cmsg>(3)  for "
#| "details on control messages."
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMPNS> control message.  "
"The timestamp control message is sent with level B<SOL_SOCKET> and a "
"I<cmsg_type> of B<SCM_TIMESTAMPNS>.  The I<cmsg_data> field is a I<struct "
"timespec> indicating the reception time of the last packet passed to the "
"user in this call.  The clock used for the timestamp is B<CLOCK_REALTIME>.  "
"See B<cmsg>(3)  for details on control messages."
msgstr ""
"B<SO_TIMESTAMP> 制御メッセージの受信を有効/無効にする。 タイムスタンプ制御"
"メッセージはレベル B<SOL_SOCKET> で送信され、 I<cmsg_data> フィールドはこのシ"
"ステムコールでユーザーに渡した 最後のパケットの受信時刻を示す I<struct "
"timeval> である。 制御メッセージの詳細については B<cmsg>(3)  を参照。"

#. type: Plain text
#: build/C/man7/socket.7:1006
msgid ""
"A socket cannot mix B<SO_TIMESTAMP> and B<SO_TIMESTAMPNS>: the two modes are "
"mutually exclusive."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1006
#, no-wrap
msgid "B<SO_TYPE>"
msgstr "B<SO_TYPE>"

#. type: Plain text
#: build/C/man7/socket.7:1011
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""
"ソケットのタイプを整数で取得する (例: B<SOCK_STREAM>)。\n"
"このソケットオプションは読み出し専用である。"

#. type: TP
#: build/C/man7/socket.7:1011
#, no-wrap
msgid "B<SO_BUSY_POLL> (since Linux 3.11)"
msgstr "B<SO_BUSY_POLL> (Linux 3.11 以降)"

#. type: Plain text
#: build/C/man7/socket.7:1020
msgid ""
"Sets the approximate time in microseconds to busy poll on a blocking receive "
"when there is no data.  Increasing this value requires B<CAP_NET_ADMIN>.  "
"The default for this option is controlled by the I</proc/sys/net/core/"
"busy_read> file."
msgstr ""
"データがなかった際にブロッキング受信での busy polling のおおよその時間をマイ"
"クロ秒単位で設定する。 この値を増やすには B<CAP_NET_ADMIN> ケーパビリティが必"
"要である。 このオプションのデフォルト値は I</proc/sys/net/core/busy_read> で"
"制御できる。"

#. type: Plain text
#: build/C/man7/socket.7:1030
msgid ""
"The value in the I</proc/sys/net/core/busy_poll> file determines how long "
"B<select>(2)  and B<poll>(2)  will busy poll when they operate on sockets "
"with B<SO_BUSY_POLL> set and no events to report are found."
msgstr ""
"I</proc/sys/net/core/busy_poll> の値により、 B<SO_BUSY_POLL> がセットされたソ"
"ケットに対して B<select>(2) や B<poll>(2) を行い、報告すべきイベントがない場"
"合に、 B<select>(2) や B<poll>(2) が busy polling をどのくらいの時間行うかが"
"決まる。"

#. type: Plain text
#: build/C/man7/socket.7:1034
msgid ""
"In both cases, busy polling will only be done when the socket last received "
"data from a network device that supports this option."
msgstr ""
"どちらの場合も、busy polling は、そのソケットが最後にデータを受信したネット"
"ワークデバイスがこのオプションに対応している場合のみ行われる。"

#. type: Plain text
#: build/C/man7/socket.7:1038
msgid ""
"While busy polling may improve latency of some applications, care must be "
"taken when using it since this will increase both CPU utilization and power "
"usage."
msgstr ""
"busy polling により遅延が改善されるはアプリケーションもあるが、 busy polling "
"は CPU 使用率と電力使用量をともに増加させることになるので、使用する際は注意し"
"て行うこと。"

#. type: SS
#: build/C/man7/socket.7:1038
#, no-wrap
msgid "Signals"
msgstr "シグナル"

#. type: Plain text
#: build/C/man7/socket.7:1049
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""
"(ローカルもしくはリモート側で) 切断された 接続指向 (connection-oriented) のソ"
"ケットに対して 書き込みを行うと、その書き込みを行ったプロセスに B<SIGPIPE> が"
"送られ、 B<EPIPE> が返される。 write 呼び出しに B<MSG_NOSIGNAL> フラグを指定"
"していた場合はシグナルは送られない。"

#. type: Plain text
#: build/C/man7/socket.7:1074
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of "
"its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""
"B<FIOSETOWN> B<fcntl>(2)  や B<SIOCSPGRP> B<ioctl>(2)  をプロセスまたはプロセ"
"スグループに指定しておくと、 I/O イベントが起きたときに B<SIGIO> が送られ"
"る。 B<poll>(2)  や B<select>(2)  をシグナルハンドラー内で用いれば、どのソ"
"ケットでイベントが起こったかを 知ることができる。 (Linux 2.2 における) 別の方"
"法としては、 B<F_SETSIG> B<fcntl>(2)  を用いてリアルタイムシグナルを設定する"
"やり方もある。 リアルタイムシグナルのハンドラーは、 I<siginfo_t> の I<si_fd> "
"フィールドにファイルディスクリプターが入った状態で呼び出される。 詳細は "
"B<fcntl>(2)  を参照のこと。"

#.  .SS Ancillary messages
#. type: Plain text
#: build/C/man7/socket.7:1082
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""
"状況によっては (例えば複数のプロセスが一つのソケットにアクセスしているな"
"ど)、 B<SIGIO> の原因となった状態は、プロセスがそのシグナルへの対応を行ったと"
"きには 消えてしまっているかもしれない。 この場合は、プロセスは再び待つように"
"すべきである。 Linux は同じシグナルを後で再送するからである。"

#. type: SS
#: build/C/man7/socket.7:1082
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man7/socket.7:1086
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""
"core のソケットのネットワーキングパラメーターには、 I</proc/sys/net/core/> "
"ディレクトリ内のファイルを通してアクセスできる。"

#. type: TP
#: build/C/man7/socket.7:1086
#, no-wrap
msgid "I<rmem_default>"
msgstr "I<rmem_default>"

#. type: Plain text
#: build/C/man7/socket.7:1089
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr "ソケットの受信バッファーサイズのデフォルト値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:1089
#, no-wrap
msgid "I<rmem_max>"
msgstr "I<rmem_max>"

#. type: Plain text
#: build/C/man7/socket.7:1095
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""
"B<SO_RCVBUF> ソケットオプションを用いてユーザーが設定できる ソケットの受信"
"バッファーサイズの最大値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:1095
#, no-wrap
msgid "I<wmem_default>"
msgstr "I<wmem_default>"

#. type: Plain text
#: build/C/man7/socket.7:1098
msgid "contains the default setting in bytes of the socket send buffer."
msgstr "ソケットの送信バッファーサイズのデフォルト値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:1098
#, no-wrap
msgid "I<wmem_max>"
msgstr "I<wmem_max>"

#. type: Plain text
#: build/C/man7/socket.7:1104
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""
"B<SO_SNDBUF> ソケットオプションを用いてユーザーが設定できる ソケットの送信"
"バッファーサイズの最大値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:1104
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr "I<message_cost> と I<message_burst>"

#. type: Plain text
#: build/C/man7/socket.7:1108
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""
"トークンバケットフィルターを設定する。 これは外部のネットワークイベントによっ"
"て引き起こされた 負荷限界の警告メッセージに用いられる。"

#. type: TP
#: build/C/man7/socket.7:1108
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr "I<netdev_max_backlog>"

#. type: Plain text
#: build/C/man7/socket.7:1111
msgid "Maximum number of packets in the global input queue."
msgstr "グローバルな入力キューにおける最大のパケット数。"

#. type: TP
#: build/C/man7/socket.7:1111
#, no-wrap
msgid "I<optmem_max>"
msgstr "I<optmem_max>"

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: build/C/man7/socket.7:1116
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""
"ソケットあたりの、補助データ (ancillary data) とユーザー制御データ (iovecs の"
"ようなもの) との和の最大長。"

#. type: SS
#: build/C/man7/socket.7:1116 build/C/man7/vsock.7:150
#, no-wrap
msgid "Ioctls"
msgstr "ioctl"

#. type: Plain text
#: build/C/man7/socket.7:1119
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr "以下に示す操作には B<ioctl>(2)  を用いてアクセスできる。"

#. type: Plain text
#: build/C/man7/socket.7:1123
#, no-wrap
msgid "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"
msgstr "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"

#. type: TP
#: build/C/man7/socket.7:1125
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr "B<SIOCGSTAMP>"

#. type: Plain text
#: build/C/man7/socket.7:1153
#, fuzzy
#| msgid ""
#| "Return a I<struct timeval> with the receive timestamp of the last packet "
#| "passed to the user.  This is useful for accurate round trip time "
#| "measurements.  See B<setitimer>(2)  for a description of I<struct "
#| "timeval>.  This ioctl should be used only if the socket option "
#| "B<SO_TIMESTAMP> is not set on the socket.  Otherwise, it returns the "
#| "timestamp of the last packet that was received while B<SO_TIMESTAMP> was "
#| "not set, or it fails if no such packet has been received, (i.e., "
#| "B<ioctl>(2)  returns -1 with I<errno> set to B<ENOENT>)."
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should be used only if the socket options B<SO_TIMESTAMP> and "
"B<SO_TIMESTAMPNS> are not set on the socket.  Otherwise, it returns the "
"timestamp of the last packet that was received while B<SO_TIMESTAMP> and "
"B<SO_TIMESTAMPNS> were not set, or it fails if no such packet has been "
"received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set to B<ENOENT>)."
msgstr ""
"最後にユーザーに渡されたパケットの受信タイムスタンプを I<struct timeval> に入"
"れて返す。 これは round trip 時間を正確に測りたいときに便利である。 I<struct "
"timeval> の説明は B<setitimer>(2)  を見てほしい。 この ioctl は、ソケットオプ"
"ション B<SO_TIMESTAMP> がソケットにセットされていない場合にのみ使用すべきであ"
"る。 さもなければ、この ioctl は B<SO_TIMESTAMP> がセットされていなかった間に"
"受信した最後のパケットの時刻を返すか、 そのようなパケットを受信していない場合"
"には失敗する (つまり、 B<ioctl>(2)  は -1 を返し、 I<errno> に B<ENOENT> を"
"セットする)。"

#. type: TP
#: build/C/man7/socket.7:1153
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr "B<SIOCSPGRP>"

#. type: Plain text
#: build/C/man7/socket.7:1166
msgid ""
"Set the process or process group that is to receive B<SIGIO> or B<SIGURG> "
"signals when I/O becomes possible or urgent data is available.  The argument "
"is a pointer to a I<pid_t>.  For further details, see the description of "
"B<F_SETOWN> in B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1166
#, no-wrap
msgid "B<FIOASYNC>"
msgstr "B<FIOASYNC>"

#. type: Plain text
#: build/C/man7/socket.7:1176
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""
"B<O_ASYNC> フラグを変更し、ソケットの非同期 (asynchronous) I/O モードを 有効/"
"無効にする。非同期 I/O モードでは、 新しい I/O イベントが起きたときに、 "
"B<SIGIO> シグナルや B<F_SETSIG> で設定されたシグナルセットが発行される。"

#. type: Plain text
#: build/C/man7/socket.7:1184
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""
"引数はブール整数のフラグである。 (この操作は B<fcntl>(2)  を使って "
"B<O_ASYNC> フラグをセットするのと同じ意味である。)"

#. type: TP
#: build/C/man7/socket.7:1184
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr "B<SIOCGPGRP>"

#. type: Plain text
#: build/C/man7/socket.7:1193
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""
"B<SIGIO> や B<SIGURG> を受信したカレントプロセスかプロセスグループを取得す"
"る。 ない場合は 0 が返る。"

#. type: Plain text
#: build/C/man7/socket.7:1197
msgid "Valid B<fcntl>(2)  operations:"
msgstr "有効な B<fcntl>(2)  操作:"

#. type: TP
#: build/C/man7/socket.7:1197
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr "B<FIOGETOWN>"

#. type: Plain text
#: build/C/man7/socket.7:1202
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr "B<SIOCGPGRP> B<ioctl>(2)  と同じ。"

#. type: TP
#: build/C/man7/socket.7:1202
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr "B<FIOSETOWN>"

#. type: Plain text
#: build/C/man7/socket.7:1207
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr "B<SIOCSPGRP> B<ioctl>(2)  と同じ。"

#. type: Plain text
#: build/C/man7/socket.7:1221
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces were introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""
"B<SO_BINDTODEVICE> は Linux 2.0.30 で導入された。 B<SO_PASSCRED> は Linux "
"2.2 で登場した。 I</proc> インターフェースは Linux 2.2 で導入された。 "
"B<SO_RCVTIMEO> と B<SO_SNDTIMEO> は Linux 2.3.41 以降でサポートされている。 "
"それ以前は、タイムアウトはプロトコル固有の固定の設定値で、 読み書きをすること"
"はできなかった。"

#. type: Plain text
#: build/C/man7/socket.7:1226
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""
"Linux は、送受信バッファーの半分を内部のカーネル構造体で用いると仮定してい"
"る。 したがって、対応する I</proc> ファイルはネットワーク回線上での大きさの "
"2 倍になる。"

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/socket.7:1241
msgid ""
"Linux will allow port reuse only with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""
"Linux では、 B<SO_REUSEADDR> オプションでポートの再利用が許可されるのは、 そ"
"のポートに対して B<bind>(2)  を前に実行したプログラムとそのポートを再利用 し"
"ようとするプログラムの両方で B<SO_REUSEADDR> がセットされた場合のみである。 "
"この動作は (FreeBSD などの) いくつかの実装とは異なる。これらでは、 後でポート"
"を再利用しようとするプログラムで B<SO_REUSEADDR> オプションをセットするだけで"
"よい。 たいていはこの違いは見えない。なぜなら、例えばサーバプログラムは 常に"
"このオプションをセットするように設計されるからである。"

#. type: Plain text
#: build/C/man7/socket.7:1259
msgid ""
"B<wireshark>(1), B<bpf>(2), B<connect>(2), B<getsockopt>(2), "
"B<setsockopt>(2), B<socket>(2), B<pcap>(3), B<address_families>(7), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<ipv6>(7), B<packet>(7), "
"B<tcp>(7), B<udp>(7), B<unix>(7), B<tcpdump>(8)"
msgstr "B<wireshark>(1), B<bpf>(2), B<connect>(2), B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), B<pcap>(3), B<address_families>(7), B<capabilities>(7), B<ddp>(7), B<ip>(7), B<ipv6>(7), B<packet>(7), B<tcp>(7), B<udp>(7), B<unix>(7), B<tcpdump>(8)"

#. type: TH
#: build/C/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr "SOCKETCALL"

#. type: Plain text
#: build/C/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr "socketcall - ソケットシステムコール"

#. type: Plain text
#: build/C/man2/socketcall.2:30
msgid "B<#include E<lt>linux/net.hE<gt>>"
msgstr "B<#include E<lt>linux/net.hE<gt>>"

#. type: Plain text
#: build/C/man2/socketcall.2:32
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"

#. type: Plain text
#: build/C/man2/socketcall.2:40
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""
"B<socketcall>()  はソケットシステムコールのための共通のカーネルエントリー ポ"
"イント(kernel entry point)である。 I<call> はどのソケット関数を呼び出すかを指"
"定する。 I<args> は適切なコールに渡すための実際の引数を含んでいるブロックを"
"指す。"

#. type: Plain text
#: build/C/man2/socketcall.2:44
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""
"ユーザープログラムは通常の名前を使用して適切な関数を呼び出すべきである。 標準"
"ライブラリの実装者やカーネルハッカーのみが B<socketcall>()  について知る必要"
"がある。"

#. type: tbl table
#: build/C/man2/socketcall.2:48
#, no-wrap
msgid "I<call>"
msgstr "I<call>"

#. type: tbl table
#: build/C/man2/socketcall.2:51
#, no-wrap
msgid "B<SYS_SOCKET>"
msgstr "B<SYS_SOCKET>"

#. type: tbl table
#: build/C/man2/socketcall.2:53
#, no-wrap
msgid "B<socket>(2)"
msgstr "B<socket>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:56
#, no-wrap
msgid "B<SYS_BIND>"
msgstr "B<SYS_BIND>"

#. type: tbl table
#: build/C/man2/socketcall.2:58
#, no-wrap
msgid "B<bind>(2)"
msgstr "B<bind>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:61
#, no-wrap
msgid "B<SYS_CONNECT>"
msgstr "B<SYS_CONNECT>"

#. type: tbl table
#: build/C/man2/socketcall.2:63
#, no-wrap
msgid "B<connect>(2)"
msgstr "B<connect>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:66
#, no-wrap
msgid "B<SYS_LISTEN>"
msgstr "B<SYS_LISTEN>"

#. type: tbl table
#: build/C/man2/socketcall.2:68
#, no-wrap
msgid "B<listen>(2)"
msgstr "B<listen>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:71
#, no-wrap
msgid "B<SYS_ACCEPT>"
msgstr "B<SYS_ACCEPT>"

#. type: tbl table
#: build/C/man2/socketcall.2:73
#, no-wrap
msgid "B<accept>(2)"
msgstr "B<accept>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:76
#, no-wrap
msgid "B<SYS_GETSOCKNAME>"
msgstr "B<SYS_GETSOCKNAME>"

#. type: tbl table
#: build/C/man2/socketcall.2:78
#, no-wrap
msgid "B<getsockname>(2)"
msgstr "B<getsockname>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:81
#, no-wrap
msgid "B<SYS_GETPEERNAME>"
msgstr "B<SYS_GETPEERNAME>"

#. type: tbl table
#: build/C/man2/socketcall.2:83
#, no-wrap
msgid "B<getpeername>(2)"
msgstr "B<getpeername>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:86
#, no-wrap
msgid "B<SYS_SOCKETPAIR>"
msgstr "B<SYS_SOCKETPAIR>"

#. type: tbl table
#: build/C/man2/socketcall.2:88
#, no-wrap
msgid "B<socketpair>(2)"
msgstr "B<socketpair>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:91
#, no-wrap
msgid "B<SYS_SEND>"
msgstr "B<SYS_SEND>"

#. type: tbl table
#: build/C/man2/socketcall.2:93
#, no-wrap
msgid "B<send>(2)"
msgstr "B<send>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:96
#, no-wrap
msgid "B<SYS_RECV>"
msgstr "B<SYS_RECV>"

#. type: tbl table
#: build/C/man2/socketcall.2:98
#, no-wrap
msgid "B<recv>(2)"
msgstr "B<recv>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:101
#, no-wrap
msgid "B<SYS_SENDTO>"
msgstr "B<SYS_SENDTO>"

#. type: tbl table
#: build/C/man2/socketcall.2:103
#, no-wrap
msgid "B<sendto>(2)"
msgstr "B<sendto>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:106
#, no-wrap
msgid "B<SYS_RECVFROM>"
msgstr "B<SYS_RECVFROM>"

#. type: tbl table
#: build/C/man2/socketcall.2:108
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr "B<recvfrom>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:111
#, no-wrap
msgid "B<SYS_SHUTDOWN>"
msgstr "B<SYS_SHUTDOWN>"

#. type: tbl table
#: build/C/man2/socketcall.2:113
#, no-wrap
msgid "B<shutdown>(2)"
msgstr "B<shutdown>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:116
#, no-wrap
msgid "B<SYS_SETSOCKOPT>"
msgstr "B<SYS_SETSOCKOPT>"

#. type: tbl table
#: build/C/man2/socketcall.2:118
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr "B<setsockopt>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:121
#, no-wrap
msgid "B<SYS_GETSOCKOPT>"
msgstr "B<SYS_GETSOCKOPT>"

#. type: tbl table
#: build/C/man2/socketcall.2:123
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr "B<getsockopt>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:126
#, no-wrap
msgid "B<SYS_SENDMSG>"
msgstr "B<SYS_SENDMSG>"

#. type: tbl table
#: build/C/man2/socketcall.2:128
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr "B<sendmsg>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:131
#, no-wrap
msgid "B<SYS_RECVMSG>"
msgstr "B<SYS_RECVMSG>"

#. type: tbl table
#: build/C/man2/socketcall.2:133
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr "B<recvmsg>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:136
#, no-wrap
msgid "B<SYS_ACCEPT4>"
msgstr "B<SYS_ACCEPT4>"

#. type: tbl table
#: build/C/man2/socketcall.2:138
#, no-wrap
msgid "B<accept4>(2)"
msgstr "B<accept4>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:141
#, no-wrap
msgid "B<SYS_RECVMMSG>"
msgstr "B<SYS_RECVMMSG>"

#. type: tbl table
#: build/C/man2/socketcall.2:143
#, no-wrap
msgid "B<recvmmsg>(2)"
msgstr "B<recvmmsg>(2)"

#. type: tbl table
#: build/C/man2/socketcall.2:146
#, no-wrap
msgid "B<SYS_SENDMMSG>"
msgstr "B<SYS_SENDMMSG>"

#. type: tbl table
#: build/C/man2/socketcall.2:148
#, no-wrap
msgid "B<sendmmsg>(2)"
msgstr "B<sendmmsg>(2)"

#. type: Plain text
#: build/C/man2/socketcall.2:153
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/socketcall.2:161
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr ""
"いくつかのアーキテクチャー\\\\(emfor 例えば x86-64 や ARM\\\\(emでは、システ"
"ムコール B<socketcall>()  が存在しない。実際には、その代わりに B<socket>(2), "
"B<accept>(2), B<bind>(2)  などが独立したシステムコールとして実装されている。"

#.  commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb
#. type: Plain text
#: build/C/man2/socketcall.2:174
msgid ""
"On x86-32, B<socketcall>()  was historically the only entry point for the "
"sockets API.  However, starting in Linux 4.3, direct system calls are "
"provided on x86-32 for the sockets API.  This facilitates the creation of "
"B<seccomp>(2)  filters that filter sockets system calls (for new user-space "
"binaries that are compiled to use the new entry points)  and also provides a "
"(very) small performance improvement."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:192
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"

#. type: TH
#: build/C/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr "SOCKETPAIR"

#. type: Plain text
#: build/C/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr "socketpair - 接続されたソケットのペアを作成する"

#. type: Plain text
#: build/C/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"

#. type: Plain text
#: build/C/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""
"B<socketpair>()  は、指定されたドメイン I<domain> に指定された種類 I<type> で"
"名前のないソケットの接続されたペアを作成する。 I<protocol> が指定されると、こ"
"のプロトコルを用いる。 これらの引数の詳細は B<socket>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/socketpair.2:69
#, fuzzy
#| msgid ""
#| "The descriptors used in referencing the new sockets are returned in "
#| "I<sv>[0] and I<sv>[1].  The two sockets are indistinguishable."
msgid ""
"The file descriptors used in referencing the new sockets are returned in "
"I<sv[0]> and I<sv[1]>.  The two sockets are indistinguishable."
msgstr ""
"新しいソケットの参照に使用するディスクリプター (descriptor) が I<sv>[0] と "
"I<sv>[1] に返される。 二つのソケットは全く同じである。"

#. type: Plain text
#: build/C/man2/socketpair.2:76
#, fuzzy
#| msgid ""
#| "On success, zero is returned.  On error, -1 is returned, and I<errno> is "
#| "set appropriately."
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<sv> is left unchanged"
msgstr ""
"成功した場合にはゼロが返される。エラー時には -1 が返され、 I<errno> が適切に"
"設定される。"

#.  http://austingroupbugs.net/view.php?id=483
#. type: Plain text
#: build/C/man2/socketpair.2:84
msgid ""
"On Linux (and other systems), B<socketpair>()  does not modify I<sv> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:88
msgid "The specified address family is not supported on this machine."
msgstr "このマシンでは指定されたアドレスファミリーがサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:93
msgid ""
"The address I<sv> does not specify a valid part of the process address space."
msgstr "アドレス I<sv> がこのプロセスで使えるアドレス空間を指定していない。"

#. type: Plain text
#: build/C/man2/socketpair.2:102
msgid "The specified protocol does not support creation of socket pairs."
msgstr "指定されたプロトコルではソケットのペアの作成がサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:105
msgid "The specified protocol is not supported on this machine."
msgstr "このマシンでは指定されたプロトコルがサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:112
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD.  B<socketpair>()  first appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System\\ V variants)."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.4BSD.  B<socketpair>() は 4.2BSD で登場した。一般に (System\\ V の変種を含めて)  BSD のソケット層のクローンをサポートしている、BSD 以外のシステムと、 互いに移植性がある。"

#.  commit: 70b03759e9ecfae400605fa34f3d7154cccbbba3
#. type: Plain text
#: build/C/man2/socketpair.2:121
#, fuzzy
#| msgid ""
#| "On Linux, the only supported domain for this call is B<AF_UNIX> (or "
#| "synonymously, B<AF_LOCAL>).  (Most implementations have the same "
#| "restriction.)"
msgid ""
"On Linux, the only supported domains for this call are B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>)  and B<AF_TIPC> (since Linux 4.12)."
msgstr ""
"Linux では、この関数でサポートされているドメインは B<AF_UNIX> (または同義語で"
"ある B<AF_LOCAL>)  だけである。 (ほとんどの実装で同じ制限がある)"

#. type: Plain text
#: build/C/man2/socketpair.2:132
#, fuzzy
#| msgid ""
#| "Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
#| "B<SOCK_CLOEXEC> flags described in B<socket>(2)."
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags in the I<type> argument, as described in B<socket>(2)."
msgstr ""
"Linux 2.6.27 以降では、 B<socketpair>()  は、フラグ B<SOCK_NONBLOCK> と "
"B<SOCK_CLOEXEC> に対応している。フラグの説明は B<socket>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/socketpair.2:145
msgid ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"

#. type: TH
#: build/C/man7/bpf-helpers.7:3
#, no-wrap
msgid "BPF-HELPERS"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:6
msgid "BPF-HELPERS - list of eBPF helper functions"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:17
msgid ""
"\\e$1 \\en[an-margin] level \\en[rst2man-indent-level] level margin: "
"\\en[rst2man-indent\\en[rst2man-indent-level]] - \\en[rst2man-indent0] "
"\\en[rst2man-indent1] \\en[rst2man-indent2]"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:100
msgid ""
"The extended Berkeley Packet Filter (eBPF) subsystem consists in programs "
"written in a pseudo-assembly language, then attached to one of the several "
"kernel hooks and run in reaction of specific events. This framework differs "
"from the older, \"classic\" BPF (or \"cBPF\") in several aspects, one of "
"them being the ability to call special functions (or \"helpers\") from "
"within a program.  These functions are restricted to a white-list of helpers "
"defined in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:107
msgid ""
"These helpers are used by eBPF programs to interact with the system, or with "
"the context in which they work. For instance, they can be used to print "
"debugging messages, to get the time since the system was booted, to interact "
"with eBPF maps, or to manipulate network packets. Since there are several "
"eBPF program types, and that they do not run in the same context, each "
"program type can only call a subset of those helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:109
msgid ""
"Due to eBPF conventions, a helper can not have more than five arguments."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:113
msgid ""
"Internally, eBPF programs call directly into the compiled helper functions "
"without requiring any foreign-function interface. As a result, calling "
"helpers introduces no overhead, thus offering excellent performance."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:117
msgid ""
"This document is an attempt to list and document the helpers available to "
"eBPF developers. They are sorted by chronological order (the oldest helpers "
"in the kernel at the top)."
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:117
#, no-wrap
msgid "HELPERS"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:119
#, no-wrap
msgid "B<void *bpf_map_lookup_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<)>"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:122 build/C/man7/bpf-helpers.7:133
#: build/C/man7/bpf-helpers.7:159 build/C/man7/bpf-helpers.7:169
#: build/C/man7/bpf-helpers.7:183 build/C/man7/bpf-helpers.7:195
#: build/C/man7/bpf-helpers.7:274 build/C/man7/bpf-helpers.7:290
#: build/C/man7/bpf-helpers.7:303 build/C/man7/bpf-helpers.7:323
#: build/C/man7/bpf-helpers.7:352 build/C/man7/bpf-helpers.7:388
#: build/C/man7/bpf-helpers.7:423 build/C/man7/bpf-helpers.7:469
#: build/C/man7/bpf-helpers.7:484 build/C/man7/bpf-helpers.7:514
#: build/C/man7/bpf-helpers.7:534 build/C/man7/bpf-helpers.7:550
#: build/C/man7/bpf-helpers.7:608 build/C/man7/bpf-helpers.7:658
#: build/C/man7/bpf-helpers.7:690 build/C/man7/bpf-helpers.7:716
#: build/C/man7/bpf-helpers.7:744 build/C/man7/bpf-helpers.7:797
#: build/C/man7/bpf-helpers.7:818 build/C/man7/bpf-helpers.7:872
#: build/C/man7/bpf-helpers.7:907 build/C/man7/bpf-helpers.7:929
#: build/C/man7/bpf-helpers.7:943 build/C/man7/bpf-helpers.7:973
#: build/C/man7/bpf-helpers.7:1008 build/C/man7/bpf-helpers.7:1027
#: build/C/man7/bpf-helpers.7:1054 build/C/man7/bpf-helpers.7:1077
#: build/C/man7/bpf-helpers.7:1097 build/C/man7/bpf-helpers.7:1125
#: build/C/man7/bpf-helpers.7:1165 build/C/man7/bpf-helpers.7:1181
#: build/C/man7/bpf-helpers.7:1192 build/C/man7/bpf-helpers.7:1207
#: build/C/man7/bpf-helpers.7:1232 build/C/man7/bpf-helpers.7:1251
#: build/C/man7/bpf-helpers.7:1268 build/C/man7/bpf-helpers.7:1285
#: build/C/man7/bpf-helpers.7:1296 build/C/man7/bpf-helpers.7:1318
#: build/C/man7/bpf-helpers.7:1329 build/C/man7/bpf-helpers.7:1372
#: build/C/man7/bpf-helpers.7:1428 build/C/man7/bpf-helpers.7:1453
#: build/C/man7/bpf-helpers.7:1468 build/C/man7/bpf-helpers.7:1495
#: build/C/man7/bpf-helpers.7:1528 build/C/man7/bpf-helpers.7:1585
#: build/C/man7/bpf-helpers.7:1600 build/C/man7/bpf-helpers.7:1636
#: build/C/man7/bpf-helpers.7:1665 build/C/man7/bpf-helpers.7:1726
#: build/C/man7/bpf-helpers.7:1744 build/C/man7/bpf-helpers.7:1785
#: build/C/man7/bpf-helpers.7:1807 build/C/man7/bpf-helpers.7:1841
#: build/C/man7/bpf-helpers.7:1863 build/C/man7/bpf-helpers.7:1881
#: build/C/man7/bpf-helpers.7:1901 build/C/man7/bpf-helpers.7:1945
#: build/C/man7/bpf-helpers.7:1974 build/C/man7/bpf-helpers.7:2017
#: build/C/man7/bpf-helpers.7:2044 build/C/man7/bpf-helpers.7:2062
#: build/C/man7/bpf-helpers.7:2080 build/C/man7/bpf-helpers.7:2125
#: build/C/man7/bpf-helpers.7:2144 build/C/man7/bpf-helpers.7:2164
#: build/C/man7/bpf-helpers.7:2202 build/C/man7/bpf-helpers.7:2225
#: build/C/man7/bpf-helpers.7:2255 build/C/man7/bpf-helpers.7:2283
#: build/C/man7/bpf-helpers.7:2305 build/C/man7/bpf-helpers.7:2318
#: build/C/man7/bpf-helpers.7:2340 build/C/man7/bpf-helpers.7:2384
#: build/C/man7/bpf-helpers.7:2428 build/C/man7/bpf-helpers.7:2440
#: build/C/man7/bpf-helpers.7:2456 build/C/man7/bpf-helpers.7:2466
#: build/C/man7/bpf-helpers.7:2476 build/C/man7/bpf-helpers.7:2496
#: build/C/man7/bpf-helpers.7:2512 build/C/man7/bpf-helpers.7:2530
#: build/C/man7/bpf-helpers.7:2599 build/C/man7/bpf-helpers.7:2610
#: build/C/man7/bpf-helpers.7:2622 build/C/man7/bpf-helpers.7:2634
#: build/C/man7/bpf-helpers.7:2648 build/C/man7/bpf-helpers.7:2660
#: build/C/man7/bpf-helpers.7:2683 build/C/man7/bpf-helpers.7:2702
#: build/C/man7/bpf-helpers.7:2722 build/C/man7/bpf-helpers.7:2745
#: build/C/man7/bpf-helpers.7:2766 build/C/man7/bpf-helpers.7:2787
#: build/C/man7/bpf-helpers.7:2815 build/C/man7/bpf-helpers.7:2842
#: build/C/man7/bpf-helpers.7:2874 build/C/man7/bpf-helpers.7:2886
#: build/C/man7/bpf-helpers.7:2905 build/C/man7/bpf-helpers.7:2935
#: build/C/man7/bpf-helpers.7:2963 build/C/man7/bpf-helpers.7:2974
#: build/C/man7/bpf-helpers.7:2985 build/C/man7/bpf-helpers.7:3036
#: build/C/man7/bpf-helpers.7:3048 build/C/man7/bpf-helpers.7:3059
#: build/C/man7/bpf-helpers.7:3077 build/C/man7/bpf-helpers.7:3087
#: build/C/man7/bpf-helpers.7:3110 build/C/man7/bpf-helpers.7:3126
#: build/C/man7/bpf-helpers.7:3154 build/C/man7/bpf-helpers.7:3171
#: build/C/man7/bpf-helpers.7:3193 build/C/man7/bpf-helpers.7:3228
#: build/C/man7/bpf-helpers.7:3285 build/C/man7/bpf-helpers.7:3297
#: build/C/man7/bpf-helpers.7:3330 build/C/man7/bpf-helpers.7:3344
#: build/C/man7/bpf-helpers.7:3362 build/C/man7/bpf-helpers.7:3384
#: build/C/man7/bpf-helpers.7:3398 build/C/man7/bpf-helpers.7:3409
#: build/C/man7/bpf-helpers.7:3423 build/C/man7/bpf-helpers.7:3437
#: build/C/man7/bpf-helpers.7:3463 build/C/man7/bpf-helpers.7:3504
#: build/C/man7/bpf-helpers.7:3514 build/C/man7/bpf-helpers.7:3524
#: build/C/man7/bpf-helpers.7:3534 build/C/man7/bpf-helpers.7:3544
#: build/C/man7/bpf-helpers.7:3554
#, no-wrap
msgid "B<Description>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:125
msgid "Perform a lookup in I<map> for an entry associated to I<key>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:125 build/C/man7/bpf-helpers.7:152
#: build/C/man7/bpf-helpers.7:162 build/C/man7/bpf-helpers.7:176
#: build/C/man7/bpf-helpers.7:188 build/C/man7/bpf-helpers.7:266
#: build/C/man7/bpf-helpers.7:283 build/C/man7/bpf-helpers.7:296
#: build/C/man7/bpf-helpers.7:316 build/C/man7/bpf-helpers.7:345
#: build/C/man7/bpf-helpers.7:381 build/C/man7/bpf-helpers.7:416
#: build/C/man7/bpf-helpers.7:444 build/C/man7/bpf-helpers.7:451
#: build/C/man7/bpf-helpers.7:461 build/C/man7/bpf-helpers.7:477
#: build/C/man7/bpf-helpers.7:507 build/C/man7/bpf-helpers.7:527
#: build/C/man7/bpf-helpers.7:543 build/C/man7/bpf-helpers.7:601
#: build/C/man7/bpf-helpers.7:651 build/C/man7/bpf-helpers.7:682
#: build/C/man7/bpf-helpers.7:706 build/C/man7/bpf-helpers.7:736
#: build/C/man7/bpf-helpers.7:790 build/C/man7/bpf-helpers.7:811
#: build/C/man7/bpf-helpers.7:864 build/C/man7/bpf-helpers.7:899
#: build/C/man7/bpf-helpers.7:922 build/C/man7/bpf-helpers.7:936
#: build/C/man7/bpf-helpers.7:966 build/C/man7/bpf-helpers.7:1001
#: build/C/man7/bpf-helpers.7:1012 build/C/man7/bpf-helpers.7:1040
#: build/C/man7/bpf-helpers.7:1047 build/C/man7/bpf-helpers.7:1070
#: build/C/man7/bpf-helpers.7:1082 build/C/man7/bpf-helpers.7:1118
#: build/C/man7/bpf-helpers.7:1158 build/C/man7/bpf-helpers.7:1173
#: build/C/man7/bpf-helpers.7:1200 build/C/man7/bpf-helpers.7:1225
#: build/C/man7/bpf-helpers.7:1244 build/C/man7/bpf-helpers.7:1259
#: build/C/man7/bpf-helpers.7:1277 build/C/man7/bpf-helpers.7:1289
#: build/C/man7/bpf-helpers.7:1300 build/C/man7/bpf-helpers.7:1307
#: build/C/man7/bpf-helpers.7:1322 build/C/man7/bpf-helpers.7:1365
#: build/C/man7/bpf-helpers.7:1421 build/C/man7/bpf-helpers.7:1445
#: build/C/man7/bpf-helpers.7:1461 build/C/man7/bpf-helpers.7:1488
#: build/C/man7/bpf-helpers.7:1521 build/C/man7/bpf-helpers.7:1578
#: build/C/man7/bpf-helpers.7:1593 build/C/man7/bpf-helpers.7:1629
#: build/C/man7/bpf-helpers.7:1658 build/C/man7/bpf-helpers.7:1716
#: build/C/man7/bpf-helpers.7:1737 build/C/man7/bpf-helpers.7:1778
#: build/C/man7/bpf-helpers.7:1800 build/C/man7/bpf-helpers.7:1834
#: build/C/man7/bpf-helpers.7:1856 build/C/man7/bpf-helpers.7:1874
#: build/C/man7/bpf-helpers.7:1894 build/C/man7/bpf-helpers.7:1937
#: build/C/man7/bpf-helpers.7:1967 build/C/man7/bpf-helpers.7:2002
#: build/C/man7/bpf-helpers.7:2037 build/C/man7/bpf-helpers.7:2055
#: build/C/man7/bpf-helpers.7:2073 build/C/man7/bpf-helpers.7:2118
#: build/C/man7/bpf-helpers.7:2137 build/C/man7/bpf-helpers.7:2157
#: build/C/man7/bpf-helpers.7:2195 build/C/man7/bpf-helpers.7:2218
#: build/C/man7/bpf-helpers.7:2248 build/C/man7/bpf-helpers.7:2268
#: build/C/man7/bpf-helpers.7:2275 build/C/man7/bpf-helpers.7:2298
#: build/C/man7/bpf-helpers.7:2311 build/C/man7/bpf-helpers.7:2333
#: build/C/man7/bpf-helpers.7:2374 build/C/man7/bpf-helpers.7:2418
#: build/C/man7/bpf-helpers.7:2433 build/C/man7/bpf-helpers.7:2449
#: build/C/man7/bpf-helpers.7:2459 build/C/man7/bpf-helpers.7:2469
#: build/C/man7/bpf-helpers.7:2489 build/C/man7/bpf-helpers.7:2505
#: build/C/man7/bpf-helpers.7:2523 build/C/man7/bpf-helpers.7:2592
#: build/C/man7/bpf-helpers.7:2603 build/C/man7/bpf-helpers.7:2614
#: build/C/man7/bpf-helpers.7:2626 build/C/man7/bpf-helpers.7:2640
#: build/C/man7/bpf-helpers.7:2652 build/C/man7/bpf-helpers.7:2673
#: build/C/man7/bpf-helpers.7:2694 build/C/man7/bpf-helpers.7:2712
#: build/C/man7/bpf-helpers.7:2732 build/C/man7/bpf-helpers.7:2754
#: build/C/man7/bpf-helpers.7:2776 build/C/man7/bpf-helpers.7:2802
#: build/C/man7/bpf-helpers.7:2829 build/C/man7/bpf-helpers.7:2864
#: build/C/man7/bpf-helpers.7:2877 build/C/man7/bpf-helpers.7:2890
#: build/C/man7/bpf-helpers.7:2916 build/C/man7/bpf-helpers.7:2956
#: build/C/man7/bpf-helpers.7:2967 build/C/man7/bpf-helpers.7:2978
#: build/C/man7/bpf-helpers.7:3027 build/C/man7/bpf-helpers.7:3040
#: build/C/man7/bpf-helpers.7:3052 build/C/man7/bpf-helpers.7:3062
#: build/C/man7/bpf-helpers.7:3080 build/C/man7/bpf-helpers.7:3093
#: build/C/man7/bpf-helpers.7:3114 build/C/man7/bpf-helpers.7:3147
#: build/C/man7/bpf-helpers.7:3164 build/C/man7/bpf-helpers.7:3186
#: build/C/man7/bpf-helpers.7:3209 build/C/man7/bpf-helpers.7:3260
#: build/C/man7/bpf-helpers.7:3290 build/C/man7/bpf-helpers.7:3314
#: build/C/man7/bpf-helpers.7:3335 build/C/man7/bpf-helpers.7:3355
#: build/C/man7/bpf-helpers.7:3377 build/C/man7/bpf-helpers.7:3391
#: build/C/man7/bpf-helpers.7:3401 build/C/man7/bpf-helpers.7:3416
#: build/C/man7/bpf-helpers.7:3430 build/C/man7/bpf-helpers.7:3456
#: build/C/man7/bpf-helpers.7:3494 build/C/man7/bpf-helpers.7:3507
#: build/C/man7/bpf-helpers.7:3517 build/C/man7/bpf-helpers.7:3527
#: build/C/man7/bpf-helpers.7:3537 build/C/man7/bpf-helpers.7:3547
#: build/C/man7/bpf-helpers.7:3589
#, no-wrap
msgid "B<Return>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:129
msgid "Map value associated to I<key>, or B<NULL> if no entry was found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:130
#, no-wrap
msgid "B<long bpf_map_update_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<, const void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:137
msgid ""
"Add or update the value of the entry associated to I<key> in I<map> with "
"I<value>\\&. I<flags> is one of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:141 build/C/man7/bpf-helpers.7:1477
#: build/C/man7/bpf-helpers.7:2026
msgid "The entry for I<key> must not exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:144 build/C/man7/bpf-helpers.7:1480
#: build/C/man7/bpf-helpers.7:2029
msgid "The entry for I<key> must already exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:147 build/C/man7/bpf-helpers.7:1483
#: build/C/man7/bpf-helpers.7:2032
msgid "No condition on the existence of the entry for I<key>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:152
msgid ""
"Flag value B<BPF_NOEXIST> cannot be used for maps of types "
"B<BPF_MAP_TYPE_ARRAY> or B<BPF_MAP_TYPE_PERCPU_ARRAY> (all elements always "
"exist), the helper would return an error."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:155 build/C/man7/bpf-helpers.7:165
#: build/C/man7/bpf-helpers.7:179 build/C/man7/bpf-helpers.7:319
#: build/C/man7/bpf-helpers.7:348 build/C/man7/bpf-helpers.7:384
#: build/C/man7/bpf-helpers.7:419 build/C/man7/bpf-helpers.7:447
#: build/C/man7/bpf-helpers.7:480 build/C/man7/bpf-helpers.7:530
#: build/C/man7/bpf-helpers.7:546 build/C/man7/bpf-helpers.7:604
#: build/C/man7/bpf-helpers.7:654 build/C/man7/bpf-helpers.7:793
#: build/C/man7/bpf-helpers.7:814 build/C/man7/bpf-helpers.7:939
#: build/C/man7/bpf-helpers.7:969 build/C/man7/bpf-helpers.7:1004
#: build/C/man7/bpf-helpers.7:1073 build/C/man7/bpf-helpers.7:1121
#: build/C/man7/bpf-helpers.7:1161 build/C/man7/bpf-helpers.7:1228
#: build/C/man7/bpf-helpers.7:1247 build/C/man7/bpf-helpers.7:1368
#: build/C/man7/bpf-helpers.7:1424 build/C/man7/bpf-helpers.7:1491
#: build/C/man7/bpf-helpers.7:1524 build/C/man7/bpf-helpers.7:1581
#: build/C/man7/bpf-helpers.7:1596 build/C/man7/bpf-helpers.7:1632
#: build/C/man7/bpf-helpers.7:1837 build/C/man7/bpf-helpers.7:1859
#: build/C/man7/bpf-helpers.7:1877 build/C/man7/bpf-helpers.7:1897
#: build/C/man7/bpf-helpers.7:1970 build/C/man7/bpf-helpers.7:2040
#: build/C/man7/bpf-helpers.7:2121 build/C/man7/bpf-helpers.7:2140
#: build/C/man7/bpf-helpers.7:2160 build/C/man7/bpf-helpers.7:2198
#: build/C/man7/bpf-helpers.7:2314 build/C/man7/bpf-helpers.7:2436
#: build/C/man7/bpf-helpers.7:2452 build/C/man7/bpf-helpers.7:2462
#: build/C/man7/bpf-helpers.7:2472 build/C/man7/bpf-helpers.7:2492
#: build/C/man7/bpf-helpers.7:2508 build/C/man7/bpf-helpers.7:2959
#: build/C/man7/bpf-helpers.7:2970 build/C/man7/bpf-helpers.7:2981
#: build/C/man7/bpf-helpers.7:3055 build/C/man7/bpf-helpers.7:3150
#: build/C/man7/bpf-helpers.7:3394
msgid "0 on success, or a negative error in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:156
#, no-wrap
msgid "B<long bpf_map_delete_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:162
msgid "Delete entry with I<key> from I<map>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:166
#, no-wrap
msgid "B<long bpf_probe_read(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:173
msgid ""
"For tracing programs, safely attempt to read I<size> bytes from kernel space "
"address I<unsafe_ptr> and store the data in I<dst>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:176
msgid ""
"Generally, use B<bpf_probe_read_user>() or B<bpf_probe_read_kernel>() "
"instead."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:180
#, no-wrap
msgid "B<u64 bpf_ktime_get_ns(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:188
msgid ""
"Return the time elapsed since system boot, in nanoseconds.  Does not include "
"time the system was suspended.  See: B<clock_gettime>(B<CLOCK_MONOTONIC>)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:191 build/C/man7/bpf-helpers.7:3293
msgid "Current I<ktime>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:192
#, no-wrap
msgid "B<long bpf_trace_printk(const char *>I<fmt>B<, u32 >I<fmt_size>B<, ...)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:203
msgid ""
"This helper is a \"printk()-like\" facility for debugging. It prints a "
"message defined by format I<fmt> (of size I<fmt_size>)  to file I</sys/"
"kernel/debug/tracing/trace> from DebugFS, if available. It can take up to "
"three additional B<u64> arguments (as an eBPF helpers, the total number of "
"arguments is limited to five)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:212
msgid ""
"Each time the helper is called, it appends a line to the trace.  Lines are "
"discarded while I</sys/kernel/debug/tracing/trace> is open, use I</sys/"
"kernel/debug/tracing/trace_pipe> to avoid this.  The format of the trace is "
"customizable, and the exact output one will get depends on the options set "
"in I</sys/kernel/debug/tracing/trace_options> (see also the I<README> file "
"under the same directory). However, it usually defaults to something like:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:217
#, no-wrap
msgid "telnet-470   [001] .N.. 419421.045894: 0x00000001: E<lt>formatted msgE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:222
msgid "In the above:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:227
msgid "B<telnet> is the name of the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:229
msgid "B<470> is the PID of the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:232
msgid "B<001> is the CPU number on which the task is running."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:239
msgid ""
"In B<\\&.N..>, each character refers to a set of options (whether irqs are "
"enabled, scheduling options, whether hard/softirqs are running, level of "
"preempt_disabled respectively). B<N> means that B<TIF_NEED_RESCHED> and "
"B<PREEMPT_NEED_RESCHED> are set."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:241
msgid "B<419421.045894> is a timestamp."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:244
msgid ""
"B<0x00000001> is a fake value used by BPF for the instruction pointer "
"register."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:247
msgid "B<E<lt>formatted msgE<gt>> is the message formatted with I<fmt>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:258
msgid ""
"The conversion specifiers supported by I<fmt> are similar, but more limited "
"than for printk(). They are B<%d>, B<%i>, B<%u>, B<%x>, B<%ld>, B<%li>, B<"
"%lu>, B<%lx>, B<%lld>, B<%lli>, B<%llu>, B<%llx>, B<%p>, B<%s>\\&. No "
"modifier (size of field, padding with zeroes, etc.) is available, and the "
"helper will return B<-EINVAL> (but print nothing) if it encounters an "
"unknown specifier."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:266
msgid ""
"Also, note that B<bpf_trace_printk>() is slow, and should only be used for "
"debugging purposes. For this reason, a notice block (spanning several lines) "
"is printed to kernel logs and states that the helper should not be used "
"\"for production use\" the first time this helper is used (or more "
"precisely, when B<trace_printk>() buffers are allocated). For passing values "
"to user space, perf events should be preferred."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:270
msgid ""
"The number of bytes written to the buffer, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:271
#, no-wrap
msgid "B<u32 bpf_get_prandom_u32(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:277
msgid "Get a pseudo-random number."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:283
msgid ""
"From a security point of view, this helper uses its own pseudo-random "
"internal state, and cannot be used to infer the seed of other random "
"functions in the kernel. However, it is essential to note that the generator "
"used by the helper is not cryptographically secure."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:286
msgid "A random 32-bit unsigned value."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:287
#, no-wrap
msgid "B<u32 bpf_get_smp_processor_id(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:296
msgid ""
"Get the SMP (symmetric multiprocessing) processor id. Note that all programs "
"run with preemption disabled, which means that the SMP processor id is "
"stable during all the execution of the program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:299
msgid "The SMP id of the processor running the program."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:300
#, no-wrap
msgid "B<long bpf_skb_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, const void *>I<from>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_skb_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, const void *>I<from>B<, u32 >I<len>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:310
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. I<flags> are a combination of "
"B<BPF_F_RECOMPUTE_CSUM> (automatically recompute the checksum for the packet "
"after storing the bytes) and B<BPF_F_INVALIDATE_HASH> (set I<skb>B<-"
"E<gt>hash>, I<skb>B<-E<gt>swhash> and I<skb>B<-E<gt>l4hash> to 0)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:316 build/C/man7/bpf-helpers.7:345
#: build/C/man7/bpf-helpers.7:381 build/C/man7/bpf-helpers.7:444
#: build/C/man7/bpf-helpers.7:527 build/C/man7/bpf-helpers.7:543
#: build/C/man7/bpf-helpers.7:966 build/C/man7/bpf-helpers.7:1118
#: build/C/man7/bpf-helpers.7:1158 build/C/man7/bpf-helpers.7:1225
#: build/C/man7/bpf-helpers.7:1244 build/C/man7/bpf-helpers.7:1421
#: build/C/man7/bpf-helpers.7:1521 build/C/man7/bpf-helpers.7:1831
#: build/C/man7/bpf-helpers.7:1874 build/C/man7/bpf-helpers.7:2118
#: build/C/man7/bpf-helpers.7:2137 build/C/man7/bpf-helpers.7:2157
#: build/C/man7/bpf-helpers.7:2195
msgid ""
"A call to this helper is susceptible to change the underlying packet buffer. "
"Therefore, at load time, all checks on pointers previously done by the "
"verifier are invalidated and must be performed again, if the helper is used "
"in combination with direct packet access."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:320
#, no-wrap
msgid "B<long bpf_l3_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 >I<from>B<, u64 >I<to>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:334
msgid ""
"Recompute the layer 3 (e.g. IP) checksum for the packet associated to I<skb>"
"\\&. Computation is incremental, so the helper must know the former value of "
"the header field that was modified (I<from>), the new value of this field "
"(I<to>), and the number of bytes (2 or 4) for this field, stored in I<size>"
"\\&.  Alternatively, it is possible to store the difference between the "
"previous and the new values of the header field in I<to>, by setting I<from> "
"and I<size> to 0. For both methods, I<offset> indicates the location of the "
"IP checksum within the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:339 build/C/man7/bpf-helpers.7:375
msgid ""
"This helper works in combination with B<bpf_csum_diff>(), which does not "
"update the checksum in-place, but offers more flexibility and can handle "
"sizes larger than 2 or 4 for the checksum to update."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:349
#, no-wrap
msgid "B<long bpf_l4_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 >I<from>B<, u64 >I<to>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:370
msgid ""
"Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet "
"associated to I<skb>\\&. Computation is incremental, so the helper must know "
"the former value of the header field that was modified (I<from>), the new "
"value of this field (I<to>), and the number of bytes (2 or 4) for this "
"field, stored on the lowest four bits of I<flags>\\&. Alternatively, it is "
"possible to store the difference between the previous and the new values of "
"the header field in I<to>, by setting I<from> and the four lowest bits of "
"I<flags> to 0. For both methods, I<offset> indicates the location of the IP "
"checksum within the packet. In addition to the size of the field, I<flags> "
"can be added (bitwise OR) actual flags. With B<BPF_F_MARK_MANGLED_0>, a null "
"checksum is left untouched (unless B<BPF_F_MARK_ENFORCE> is added as well), "
"and for updates resulting in a null checksum the value is set to "
"B<CSUM_MANGLED_0> instead. Flag B<BPF_F_PSEUDO_HDR> indicates the checksum "
"is to be computed against a pseudo-header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:385
#, no-wrap
msgid "B<long bpf_tail_call(void *>I<ctx>B<, struct bpf_map *>I<prog_array_map>B<, u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:399
msgid ""
"This special helper is used to trigger a \"tail call\", or in other words, "
"to jump into another eBPF program. The same stack frame is used (but values "
"on stack and in registers for the caller are not accessible to the callee). "
"This mechanism allows for program chaining, either for raising the maximum "
"number of available eBPF instructions, or to execute given programs in "
"conditional blocks. For security reasons, there is an upper limit to the "
"number of successive tail calls that can be performed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:404
msgid ""
"Upon call of this helper, the program attempts to jump into a program "
"referenced at index I<index> in I<prog_array_map>, a special map of type "
"B<BPF_MAP_TYPE_PROG_ARRAY>, and passes I<ctx>, a pointer to the context."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:416
msgid ""
"If the call succeeds, the kernel immediately runs the first instruction of "
"the new program. This is not a function call, and it never returns to the "
"previous program. If the call fails, then the helper has no effect, and the "
"caller continues to run its subsequent instructions. A call can fail if the "
"destination program for the jump does not exist (i.e. I<index> is superior "
"to the number of entries in I<prog_array_map>), or if the maximum number of "
"tail calls has been reached for this chain of programs. This limit is "
"defined in the kernel by the macro B<MAX_TAIL_CALL_CNT> (not accessible to "
"user space), which is currently set to 32."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:420
#, no-wrap
msgid "B<long bpf_clone_redirect(struct sk_buff *>I<skb>B<, u32 >I<ifindex>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:431
msgid ""
"Clone and redirect the packet associated to I<skb> to another net device of "
"index I<ifindex>\\&. Both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise).  This is the only flag supported for now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:438
msgid ""
"In comparison with B<bpf_redirect>() helper, B<bpf_clone_redirect>() has the "
"associated cost of duplicating the packet buffer, but this can be executed "
"out of the eBPF program. Conversely, B<bpf_redirect>() is more efficient, "
"but it is handled through an action code where the redirection happens only "
"after the eBPF program has returned."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:448
#, no-wrap
msgid "B<u64 bpf_get_current_pid_tgid(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:457
msgid ""
"A 64-bit integer containing the current tgid and pid, and created as such: "
"I<current_task>B<-E<gt>tgid E<lt>E<lt> 32 |> I<current_task>B<-E<gt>pid>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:458
#, no-wrap
msgid "B<u64 bpf_get_current_uid_gid(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:465
msgid ""
"A 64-bit integer containing the current GID and UID, and created as such: "
"I<current_gid> B<E<lt>E<lt> 32 |> I<current_uid>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:466
#, no-wrap
msgid "B<long bpf_get_current_comm(void *>I<buf>B<, u32 >I<size_of_buf>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:477
msgid ""
"Copy the B<comm> attribute of the current task into I<buf> of I<size_of_buf>"
"\\&. The B<comm> attribute contains the name of the executable (excluding "
"the path) for the current task. The I<size_of_buf> must be strictly "
"positive. On success, the helper makes sure that the I<buf> is NUL-"
"terminated. On failure, it is filled with zeroes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:481
#, no-wrap
msgid "B<u32 bpf_get_cgroup_classid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:488
msgid ""
"Retrieve the classid for the current task, i.e. for the net_cls cgroup to "
"which I<skb> belongs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:490
msgid "This helper can be used on TC egress path, but not on ingress."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:496
msgid ""
"The net_cls cgroup provides an interface to tag network packets based on a "
"user-provided identifier for all traffic coming from the tasks belonging to "
"the related cgroup. See also the related kernel documentation, available "
"from the Linux sources in file I<Documentation/admin-guide/cgroup-v1/net_cls."
"rst>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:503
msgid ""
"The Linux kernel has two versions for cgroups: there are cgroups v1 and "
"cgroups v2. Both are available to users, who can use a mixture of them, but "
"note that the net_cls cgroup is for cgroup v1 only. This makes it "
"incompatible with BPF programs run on cgroups, which is a cgroup-v2-only "
"feature (a socket can only hold data for one version of cgroups at a time)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:507
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_CGROUP_NET_CLASSID> configuration option set to \"B<y>\" or to "
"\"B<m>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:510
msgid "The classid, or 0 for the default unconfigured classid."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:511
#, no-wrap
msgid "B<long bpf_skb_vlan_push(struct sk_buff *>I<skb>B<, __be16 >I<vlan_proto>B<, u16 >I<vlan_tci>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:521
msgid ""
"Push a I<vlan_tci> (VLAN tag control information) of protocol I<vlan_proto> "
"to the packet associated to I<skb>, then update the checksum. Note that if "
"I<vlan_proto> is different from B<ETH_P_8021Q> and B<ETH_P_8021AD>, it is "
"considered to be B<ETH_P_8021Q>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:531
#, no-wrap
msgid "B<long bpf_skb_vlan_pop(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:537
msgid "Pop a VLAN header from the packet associated to I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:547
#, no-wrap
msgid "B<long bpf_skb_get_tunnel_key(struct sk_buff *>I<skb>B<, struct bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:558
msgid ""
"Get tunnel metadata. This helper takes a pointer I<key> to an empty B<struct "
"bpf_tunnel_key> of B<size>, that will be filled with tunnel metadata for the "
"packet associated to I<skb>\\&.  The I<flags> can be set to "
"B<BPF_F_TUNINFO_IPV6>, which indicates that the tunnel is based on IPv6 "
"protocol instead of IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:569
msgid ""
"The B<struct bpf_tunnel_key> is an object that generalizes the principal "
"parameters used by various tunneling protocols into a single struct. This "
"way, it can be used to easily make a decision based on the contents of the "
"encapsulation header, \"summarized\" in this struct. In particular, it holds "
"the IP address of the remote end (IPv4 or IPv6, depending on the case)  in "
"I<key>B<-E<gt>remote_ipv4> or I<key>B<-E<gt>remote_ipv6>\\&. Also, this "
"struct exposes the I<key>B<-E<gt>tunnel_id>, which is generally mapped to a "
"VNI (Virtual Network Identifier), making it programmable together with the "
"B<bpf_skb_set_tunnel_key>() helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:574
msgid ""
"Let\\(aqs imagine that the following code is part of a program attached to "
"the TC ingress interface, on one end of a GRE tunnel, and is supposed to "
"filter out all messages coming from remote ends with IPv4 address other than "
"10.0.0.1:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:580
#, no-wrap
msgid ""
"int ret;\n"
"struct bpf_tunnel_key key = {};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:584
#, no-wrap
msgid ""
"ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n"
"if (ret E<lt> 0)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:587
#, no-wrap
msgid ""
"if (key.remote_ipv4 != 0x0a000001)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:589
#, no-wrap
msgid "return TC_ACT_OK;               // accept packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:598
msgid ""
"This interface can also be used with all encapsulation devices that can "
"operate in \"collect metadata\" mode: instead of having one network device "
"per specific configuration, the \"collect metadata\" mode only requires a "
"single device where the configuration can be extracted from this helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:601
msgid ""
"This can be used together with various tunnels such as VXLan, Geneve, GRE or "
"IP in IP (IPIP)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:605
#, no-wrap
msgid "B<long bpf_skb_set_tunnel_key(struct sk_buff *>I<skb>B<, struct bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:613
msgid ""
"Populate tunnel metadata for packet associated to I<skb.> The tunnel "
"metadata is set to the contents of I<key>, of I<size>\\&. The I<flags> can "
"be set to a combination of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:614
#, no-wrap
msgid "B<BPF_F_TUNINFO_IPV6>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:618
msgid "Indicate that the tunnel is based on IPv6 protocol instead of IPv4."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:618
#, no-wrap
msgid "B<BPF_F_ZERO_CSUM_TX>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:623
msgid ""
"For IPv4 packets, add a flag to tunnel metadata indicating that checksum "
"computation should be skipped and checksum set to zeroes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:623
#, no-wrap
msgid "B<BPF_F_DONT_FRAGMENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:627
msgid ""
"Add a flag to tunnel metadata indicating that the packet should not be "
"fragmented."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:627
#, no-wrap
msgid "B<BPF_F_SEQ_NUMBER>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:634
msgid ""
"Add a flag to tunnel metadata indicating that a sequence number should be "
"added to tunnel header before sending the packet. This flag was added for "
"GRE encapsulation, but might be used with other protocols as well in the "
"future."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:637
msgid "Here is a typical usage on the transmit path:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:645
#, no-wrap
msgid ""
"struct bpf_tunnel_key key;\n"
"     populate key ...\n"
"bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n"
"bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:651
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_key>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:655
#, no-wrap
msgid "B<u64 bpf_perf_event_read(struct bpf_map *>I<map>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:670
msgid ""
"Read the value of a perf event counter. This helper relies on a I<map> of "
"type B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event "
"counter is selected when I<map> is updated with perf event file descriptors. "
"The I<map> is an array whose size is the number of available CPUs, and each "
"cell contains a value relative to one CPU. The value to retrieve is "
"indicated by I<flags>, that contains the index of the CPU to look up, masked "
"with B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be set to "
"B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU should "
"be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:673
msgid "Note that before Linux 4.13, only hardware perf event can be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:682
msgid ""
"Also, be aware that the newer helper B<bpf_perf_event_read_value>() is "
"recommended over B<bpf_perf_event_read>() in general. The latter has some "
"ABI quirks where error and counter value are used as a return code (which is "
"wrong to do since ranges may overlap). This issue is fixed with "
"B<bpf_perf_event_read_value>(), which at the same time provides more "
"features over the B<bpf_perf_event_read>() interface. Please refer to the "
"description of B<bpf_perf_event_read_value>() for details."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:686
msgid ""
"The value of the perf event counter read from the map, or a negative error "
"code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:687
#, no-wrap
msgid "B<long bpf_redirect(u32 >I<ifindex>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:695
msgid ""
"Redirect the packet to another net device of index I<ifindex>\\&.  This "
"helper is somewhat similar to B<bpf_clone_redirect>(), except that the "
"packet is not cloned, which provides increased performance."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:702
msgid ""
"Except for XDP, both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise). Currently, XDP only supports redirection to the egress "
"interface, and accepts no flag at all."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:706
msgid ""
"The same effect can also be attained with the more generic "
"B<bpf_redirect_map>(), which uses a BPF map to store the redirect target "
"instead of providing it directly to the helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:712
msgid ""
"For XDP, the helper returns B<XDP_REDIRECT> on success or B<XDP_ABORTED> on "
"error. For other program types, the values are B<TC_ACT_REDIRECT> on success "
"or B<TC_ACT_SHOT> on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:713
#, no-wrap
msgid "B<u32 bpf_get_route_realm(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:724
msgid ""
"Retrieve the realm or the route, that is to say the B<tclassid> field of the "
"destination for the I<skb>\\&. The identifier retrieved is a user-provided "
"tag, similar to the one used with the net_cls cgroup (see description for "
"B<bpf_get_cgroup_classid>() helper), but here this tag is held by a route (a "
"destination entry), not by a task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:733
msgid ""
"Retrieving this identifier works with the clsact TC egress hook (see also "
"B<tc-bpf(8)>), or alternatively on conventional classful egress qdiscs, but "
"not on TC ingress path. In case of clsact TC egress hook, this has the "
"advantage that, internally, the destination entry has not been dropped yet "
"in the transmit path. Therefore, the destination entry does not need to be "
"artificially held via B<netif_keep_dst>() for a classful qdisc until the "
"I<skb> is freed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:736
msgid ""
"This helper is available only if the kernel was compiled with "
"B<CONFIG_IP_ROUTE_CLASSID> configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:740
msgid ""
"The realm of the route for the packet associated to I<skb>, or 0 if none was "
"found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:741
#, no-wrap
msgid "B<long bpf_perf_event_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 >I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:751 build/C/man7/bpf-helpers.7:2942
#: build/C/man7/bpf-helpers.7:3133
msgid ""
"Write raw I<data> blob into a special BPF perf event held by I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. This perf event must have the following "
"attributes: B<PERF_SAMPLE_RAW> as B<sample_type>, B<PERF_TYPE_SOFTWARE> as "
"B<type>, and B<PERF_COUNT_SW_BPF_OUTPUT> as B<config>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:757 build/C/man7/bpf-helpers.7:2948
#: build/C/man7/bpf-helpers.7:3139
msgid ""
"The I<flags> are used to indicate the index in I<map> for which the value "
"must be put, masked with B<BPF_F_INDEX_MASK>\\&.  Alternatively, I<flags> "
"can be set to B<BPF_F_CURRENT_CPU> to indicate that the index of the current "
"CPU core should be used."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:760 build/C/man7/bpf-helpers.7:2951
#: build/C/man7/bpf-helpers.7:3142
msgid ""
"The value to write, of I<size>, is passed through eBPF stack and pointed by "
"I<data>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:763
msgid "The context of the program I<ctx> needs also be passed to the helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:772
msgid ""
"On user space, a program willing to read the values needs to call "
"B<perf_event_open>() on the perf event (either for one or for all CPUs) and "
"to store the file descriptor into the I<map>\\&. This must be done before "
"the eBPF program can send data into it. An example is available in file "
"I<samples/bpf/trace_output_user.c> in the Linux kernel source tree (the eBPF "
"program counterpart is in I<samples/bpf/trace_output_kern.c>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:777
msgid ""
"B<bpf_perf_event_output>() achieves better performance than "
"B<bpf_trace_printk>() for sharing data with user space, and is much better "
"suitable for streaming data from eBPF programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:782
msgid ""
"Note that this helper is not restricted to tracing use cases and can be used "
"with programs attached to TC or XDP as well, where it allows for passing "
"data to user space listeners. Data can be:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:785
msgid "Only custom structs,"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:787
msgid "Only the packet payload, or"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:789
msgid "A combination of both."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:794
#, no-wrap
msgid "B<long bpf_skb_load_bytes(const void *>I<skb>B<, u32 >I<offset>B<, void *>I<to>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:803
msgid ""
"This helper was provided as an easy way to load data from a packet. It can "
"be used to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:811
msgid ""
"Since Linux 4.7, usage of this helper has mostly been replaced by \"direct "
"packet access\", enabling packet data to be manipulated with I<skb>B<-"
"E<gt>data> and I<skb>B<-E<gt>data_end> pointing respectively to the first "
"byte of packet data and to the byte after the last byte of packet data. "
"However, it remains useful if one wishes to read large quantities of data at "
"once from a packet into the eBPF stack."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:815
#, no-wrap
msgid "B<long bpf_get_stackid(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_get_stackid(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:824
msgid ""
"Walk a user or a kernel stack and return its id. To achieve this, the helper "
"needs I<ctx>, which is a pointer to the context on which the tracing program "
"is executed, and a pointer to a I<map> of type B<BPF_MAP_TYPE_STACK_TRACE>"
"\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:829
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set a combination of the following flags:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:830 build/C/man7/bpf-helpers.7:1914
#: build/C/man7/bpf-helpers.7:3566
#, no-wrap
msgid "B<BPF_F_USER_STACK>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:833 build/C/man7/bpf-helpers.7:1917
#: build/C/man7/bpf-helpers.7:3569
msgid "Collect a user space stack instead of a kernel stack."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:833
#, no-wrap
msgid "B<BPF_F_FAST_STACK_CMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:836
msgid "Compare stacks by hash only."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:836
#, no-wrap
msgid "B<BPF_F_REUSE_STACKID>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:840
msgid ""
"If two different stacks hash into the same I<stackid>, discard the old one."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:847
msgid ""
"The stack id retrieved is a 32 bit long integer handle which can be further "
"combined with other data (including other stack ids) and used as a key into "
"maps. This can be useful for generating a variety of graphs (such as flame "
"graphs or off-cpu graphs)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:856
msgid ""
"For walking a stack, this helper is an improvement over B<bpf_probe_read>(), "
"which can be used with unrolled loops but is not efficient and consumes a "
"lot of eBPF instructions.  Instead, B<bpf_get_stackid>() can collect up to "
"B<PERF_MAX_STACK_DEPTH> both kernel and user frames. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually "
"increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:861 build/C/man7/bpf-helpers.7:1934
#: build/C/man7/bpf-helpers.7:3586
#, no-wrap
msgid "# sysctl kernel.perf_event_max_stack=E<lt>new valueE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:868
msgid ""
"The positive or null stack id on success, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:869
#, no-wrap
msgid "B<s64 bpf_csum_diff(__be32 *>I<from>B<, u32 >I<from_size>B<, __be32 *>I<to>B<, u32 >I<to_size>B<, __wsum >I<seed>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:880
msgid ""
"Compute a checksum difference, from the raw buffer pointed by I<from>, of "
"length I<from_size> (that must be a multiple of 4), towards the raw buffer "
"pointed by I<to>, of size I<to_size> (same remark). An optional I<seed> can "
"be added to the value (this can be cascaded, the seed may come from a "
"previous call to the helper)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:882
msgid "This is flexible enough to be used in several ways:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:886
msgid ""
"With I<from_size> == 0, I<to_size> E<gt> 0 and I<seed> set to checksum, it "
"can be used when pushing new data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:889
msgid ""
"With I<from_size> E<gt> 0, I<to_size> == 0 and I<seed> set to checksum, it "
"can be used when removing data from a packet."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:893
msgid ""
"With I<from_size> E<gt> 0, I<to_size> E<gt> 0 and I<seed> set to 0, it can "
"be used to compute a diff. Note that I<from_size> and I<to_size> do not need "
"to be equal."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:899
msgid ""
"This helper can be used in combination with B<bpf_l3_csum_replace>() and "
"B<bpf_l4_csum_replace>(), to which one can feed in the difference computed "
"with B<bpf_csum_diff>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:903
msgid "The checksum result, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:904
#, no-wrap
msgid "B<long bpf_skb_get_tunnel_opt(struct sk_buff *>I<skb>B<, void *>I<opt>B<, u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:912
msgid ""
"Retrieve tunnel options metadata for the packet associated to I<skb>, and "
"store the raw tunnel option data to the buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:922
msgid ""
"This helper can be used with encapsulation devices that can operate in "
"\"collect metadata\" mode (please refer to the related note in the "
"description of B<bpf_skb_get_tunnel_key>() for more details). A particular "
"example where this can be used is in combination with the Geneve "
"encapsulation protocol, where it allows for pushing (with "
"B<bpf_skb_get_tunnel_opt>() helper)  and retrieving arbitrary TLVs (Type-"
"Length-Value headers) from the eBPF program. This allows for full "
"customization of these headers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:925
msgid "The size of the option data retrieved."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:926
#, no-wrap
msgid "B<long bpf_skb_set_tunnel_opt(struct sk_buff *>I<skb>B<, void *>I<opt>B<, u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:933
msgid ""
"Set tunnel options metadata for the packet associated to I<skb> to the "
"option data contained in the raw buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:936
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_opt>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:940
#, no-wrap
msgid "B<long bpf_skb_change_proto(struct sk_buff *>I<skb>B<, __be16 >I<proto>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:953
msgid ""
"Change the protocol of the I<skb> to I<proto>\\&. Currently supported are "
"transition from IPv4 to IPv6, and from IPv6 to IPv4. The helper takes care "
"of the groundwork for the transition, including resizing the socket buffer. "
"The eBPF program is expected to fill the new headers, if any, via "
"B<skb_store_bytes>() and to recompute the checksums with "
"B<bpf_l3_csum_replace>() and B<bpf_l4_csum_replace>(). The main case for "
"this helper is to perform NAT64 operations out of an eBPF program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:957
msgid ""
"Internally, the GSO type is marked as dodgy so that headers are checked and "
"segments are recalculated by the GSO/GRO engine.  The size for GSO target is "
"adapted as well."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:960 build/C/man7/bpf-helpers.7:1219
#: build/C/man7/bpf-helpers.7:1834 build/C/man7/bpf-helpers.7:1891
#: build/C/man7/bpf-helpers.7:2371 build/C/man7/bpf-helpers.7:2415
msgid ""
"All values for I<flags> are reserved for future usage, and must be left at "
"zero."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:970
#, no-wrap
msgid "B<long bpf_skb_change_type(struct sk_buff *>I<skb>B<, u32 >I<type>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:979
msgid ""
"Change the packet type for the packet associated to I<skb>\\&. This comes "
"down to setting I<skb>B<-E<gt>pkt_type> to I<type>, except the eBPF program "
"does not have a write access to I<skb>B<-E<gt>pkt_type> beside this helper. "
"Using a helper here allows for graceful handling of errors."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:984
msgid ""
"The major use case is to change incoming I<skb*s to **PACKET_HOST*> in a "
"programmatic way instead of having to recirculate via B<redirect>(..., "
"B<BPF_F_INGRESS>), for example."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:987
msgid "Note that I<type> only allows certain values. At this time, they are:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:988
#, no-wrap
msgid "B<PACKET_HOST>"
msgstr "B<PACKET_HOST>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:991
msgid "Packet is for us."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:991
#, no-wrap
msgid "B<PACKET_BROADCAST>"
msgstr "B<PACKET_BROADCAST>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:994
msgid "Send packet to all."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:994
#, no-wrap
msgid "B<PACKET_MULTICAST>"
msgstr "B<PACKET_MULTICAST>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:997
msgid "Send packet to group."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:997
#, no-wrap
msgid "B<PACKET_OTHERHOST>"
msgstr "B<PACKET_OTHERHOST>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1000
msgid "Send packet to someone else."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1005
#, no-wrap
msgid "B<long bpf_skb_under_cgroup(struct sk_buff *>I<skb>B<, struct bpf_map *>I<map>B<, u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1012
msgid ""
"Check whether I<skb> is a descendant of the cgroup2 held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1015 build/C/man7/bpf-helpers.7:1085
msgid "The return value depends on the result of the test, and can be:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1018
msgid "0, if the I<skb> failed the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1020
msgid "1, if the I<skb> succeeded the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1022 build/C/man7/bpf-helpers.7:1092
msgid "A negative error code, if an error occurred."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1024
#, no-wrap
msgid "B<u32 bpf_get_hash_recalc(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1033
msgid ""
"Retrieve the hash of the packet, I<skb>B<-E<gt>hash>\\&. If it is not set, "
"in particular if the hash was cleared due to mangling, recompute this hash. "
"Later accesses to the hash can be done directly with I<skb>B<-E<gt>hash>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1040
msgid ""
"Calling B<bpf_set_hash_invalid>(), changing a packet prototype with "
"B<bpf_skb_change_proto>(), or calling B<bpf_skb_store_bytes>() with the "
"B<BPF_F_INVALIDATE_HASH> are actions susceptible to clear the hash and to "
"trigger a new computation for the next call to B<bpf_get_hash_recalc>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1043
msgid "The 32-bit hash."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1044
#, no-wrap
msgid "B<u64 bpf_get_current_task(void)>"
msgstr "B<u64 bpf_get_current_task(void)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1050
msgid "A pointer to the current task struct."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1051
#, no-wrap
msgid "B<long bpf_probe_write_user(void *>I<dst>B<, const void *>I<src>B<, u32 >I<len>B<)>"
msgstr "B<long bpf_probe_write_user(void *>I<dst>B<, const void *>I<src>B<, u32 >I<len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1059
msgid ""
"Attempt in a safe way to write I<len> bytes from the buffer I<src> to I<dst> "
"in memory. It only works for threads that are in user context, and I<dst> "
"must be a valid user space address."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1064
msgid ""
"This helper should not be used to implement any kind of security mechanism "
"because of TOC-TOU attacks, but rather to debug, divert, and manipulate "
"execution of semi-cooperative processes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1070
msgid ""
"Keep in mind that this feature is meant for experiments, and it has a risk "
"of crashing the system and running programs.  Therefore, when an eBPF "
"program using this helper is attached, a warning including PID and process "
"name is printed to kernel logs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1074
#, no-wrap
msgid "B<long bpf_current_task_under_cgroup(struct bpf_map *>I<map>B<, u32 >I<index>B<)>"
msgstr "B<long bpf_current_task_under_cgroup(struct bpf_map *>I<map>B<, u32 >I<index>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1082
msgid ""
"Check whether the probe is being run is the context of a given subset of the "
"cgroup2 hierarchy. The cgroup2 to test is held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1088
msgid "0, if the I<skb> task belongs to the cgroup2."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1090
msgid "1, if the I<skb> task does not belong to the cgroup2."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1094
#, no-wrap
msgid "B<long bpf_skb_change_tail(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_skb_change_tail(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1102
msgid ""
"Resize (trim or grow) the packet associated to I<skb> to the new I<len>\\&. "
"The I<flags> are reserved for future usage, and must be left at zero."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1112
msgid ""
"The basic idea is that the helper performs the needed work to change the "
"size of the packet, then the eBPF program rewrites the rest via helpers like "
"B<bpf_skb_store_bytes>(), B<bpf_l3_csum_replace>(), "
"B<bpf_l3_csum_replace>()  and others. This helper is a slow path utility "
"intended for replies with control messages. And because it is targeted for "
"slow path, the helper itself can afford to be slow: it implicitly "
"linearizes, unclones and drops offloads from the I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1122
#, no-wrap
msgid "B<long bpf_skb_pull_data(struct sk_buff *>I<skb>B<, u32 >I<len>B<)>"
msgstr "B<long bpf_skb_pull_data(struct sk_buff *>I<skb>B<, u32 >I<len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1131
msgid ""
"Pull in non-linear data in case the I<skb> is non-linear and not all of "
"I<len> are part of the linear section. Make I<len> bytes from I<skb> "
"readable and writable. If a zero value is passed for I<len>, then the whole "
"length of the I<skb> is pulled."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1134
msgid ""
"This helper is only needed for reading and writing with direct packet access."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1145
msgid ""
"For direct packet access, testing that offsets to access are within packet "
"boundaries (test on I<skb>B<-E<gt>data_end>) is susceptible to fail if "
"offsets are invalid, or if the requested data is in non-linear parts of the "
"I<skb>\\&. On failure the program can just bail out, or in the case of a non-"
"linear buffer, use a helper to make the data available. The "
"B<bpf_skb_load_bytes>() helper is a first solution to access the data. "
"Another one consists in using B<bpf_skb_pull_data> to pull in once the non-"
"linear parts, then retesting and eventually access the data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1152
msgid ""
"At the same time, this also makes sure the I<skb> is uncloned, which is a "
"necessary condition for direct write. As this needs to be an invariant for "
"the write part only, the verifier detects writes and adds a prologue that is "
"calling B<bpf_skb_pull_data()> to effectively unclone the I<skb> from the "
"very beginning in case it is indeed cloned."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1162
#, no-wrap
msgid "B<s64 bpf_csum_update(struct sk_buff *>I<skb>B<, __wsum >I<csum>B<)>"
msgstr "B<s64 bpf_csum_update(struct sk_buff *>I<skb>B<, __wsum >I<csum>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1173
msgid ""
"Add the checksum I<csum> into I<skb>B<-E<gt>csum> in case the driver has "
"supplied a checksum for the entire packet into that field. Return an error "
"otherwise. This helper is intended to be used in combination with "
"B<bpf_csum_diff>(), in particular when the checksum needs to be updated "
"after data has been written into the packet through direct packet access."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1177
msgid "The checksum on success, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1178
#, no-wrap
msgid "B<void bpf_set_hash_invalid(struct sk_buff *>I<skb>B<)>"
msgstr "B<void bpf_set_hash_invalid(struct sk_buff *>I<skb>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1188
msgid ""
"Invalidate the current I<skb>B<-E<gt>hash>\\&. It can be used after mangling "
"on headers through direct packet access, in order to indicate that the hash "
"is outdated and to trigger a recalculation the next time the kernel tries to "
"access this hash or when the B<bpf_get_hash_recalc>() helper is called."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1189
#, no-wrap
msgid "B<long bpf_get_numa_node_id(void)>"
msgstr "B<long bpf_get_numa_node_id(void)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1200
msgid ""
"Return the id of the current NUMA node. The primary use case for this helper "
"is the selection of sockets for the local NUMA node, when the program is "
"attached to sockets using the B<SO_ATTACH_REUSEPORT_EBPF> option (see also "
"B<socket(7)>), but the helper is also available to other eBPF program types, "
"similarly to B<bpf_get_smp_processor_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1203
msgid "The id of current NUMA node."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1204
#, no-wrap
msgid "B<long bpf_skb_change_head(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_skb_change_head(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1213
msgid ""
"Grows headroom of packet associated to I<skb> and adjusts the offset of the "
"MAC header accordingly, adding I<len> bytes of space. It automatically "
"extends and reallocates memory as required."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1216
msgid ""
"This helper can be used on a layer 3 I<skb> to push a MAC header for "
"redirection into a layer 2 device."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1229
#, no-wrap
msgid "B<long bpf_xdp_adjust_head(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr "B<long bpf_xdp_adjust_head(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1238
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data> by I<delta> bytes. Note that it is "
"possible to use a negative value for I<delta>\\&. This helper can be used to "
"prepare the packet for pushing or popping headers."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1248
#, no-wrap
msgid "B<long bpf_probe_read_str(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr "B<long bpf_probe_read_str(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1256
msgid ""
"Copy a NUL terminated string from an unsafe kernel address I<unsafe_ptr> to "
"I<dst>\\&. See B<bpf_probe_read_kernel_str>() for more details."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1259
msgid ""
"Generally, use B<bpf_probe_read_user_str>() or "
"B<bpf_probe_read_kernel_str>() instead."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1264 build/C/man7/bpf-helpers.7:3032
#: build/C/man7/bpf-helpers.7:3044
msgid ""
"On success, the strictly positive length of the string, including the "
"trailing NUL character. On error, a negative value."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1265
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct sk_buff *>I<skb>B<)>"
msgstr "B<u64 bpf_get_socket_cookie(struct sk_buff *>I<skb>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1277
msgid ""
"If the B<struct sk_buff> pointed by I<skb> has a known socket, retrieve the "
"cookie (generated by the kernel) of this socket.  If no cookie has been set "
"yet, generate a new cookie. Once generated, the socket cookie remains stable "
"for the life of the socket. This helper can be useful for monitoring per "
"socket networking traffic statistics as it provides a global socket "
"identifier that can be assumed unique."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1281
msgid ""
"A 8-byte long non-decreasing number on success, or 0 if the socket field is "
"missing inside I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1282
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_addr *>I<ctx>B<)>"
msgstr "B<u64 bpf_get_socket_cookie(struct bpf_sock_addr *>I<ctx>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1289
msgid ""
"Equivalent to bpf_get_socket_cookie() helper that accepts I<skb>, but gets "
"socket from B<struct bpf_sock_addr> context."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1292 build/C/man7/bpf-helpers.7:1303
msgid "A 8-byte long non-decreasing number."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1293
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_ops *>I<ctx>B<)>"
msgstr "B<u64 bpf_get_socket_cookie(struct bpf_sock_ops *>I<ctx>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1300
msgid ""
"Equivalent to B<bpf_get_socket_cookie>() helper that accepts I<skb>, but "
"gets socket from B<struct bpf_sock_ops> context."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1304
#, no-wrap
msgid "B<u32 bpf_get_socket_uid(struct sk_buff *>I<skb>B<)>"
msgstr "B<u32 bpf_get_socket_uid(struct sk_buff *>I<skb>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1314
msgid ""
"The owner UID of the socket associated to I<skb>\\&. If the socket is "
"B<NULL>, or if it is not a full socket (i.e. if it is a time-wait or a "
"request socket instead), B<overflowuid> value is returned (note that "
"B<overflowuid> might also be the actual UID value for the socket)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1315
#, no-wrap
msgid "B<long bpf_set_hash(struct sk_buff *>I<skb>B<, u32 >I<hash>B<)>"
msgstr "B<long bpf_set_hash(struct sk_buff *>I<skb>B<, u32 >I<hash>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1322
msgid ""
"Set the full hash for I<skb> (set the field I<skb>B<-E<gt>hash>)  to value "
"I<hash>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1326
#, no-wrap
msgid "B<long bpf_setsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int >I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"
msgstr "B<long bpf_setsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int >I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1336
msgid ""
"Emulate a call to B<setsockopt()> on the socket associated to I<bpf_socket>, "
"which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<setsockopt(2)> "
"for more information.  The option value of length I<optlen> is pointed by "
"I<optval>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1338 build/C/man7/bpf-helpers.7:1610
msgid "I<bpf_socket> should be one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1341 build/C/man7/bpf-helpers.7:1613
msgid "B<struct bpf_sock_ops> for B<BPF_PROG_TYPE_SOCK_OPS>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1344 build/C/man7/bpf-helpers.7:1616
msgid ""
"B<struct bpf_sock_addr> for B<BPF_CGROUP_INET4_CONNECT> and "
"B<BPF_CGROUP_INET6_CONNECT>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1348
msgid ""
"This helper actually implements a subset of B<setsockopt()>\\&.  It supports "
"the following I<level>s:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1354
msgid ""
"B<SOL_SOCKET>, which supports the following I<optname>s: B<SO_RCVBUF>, "
"B<SO_SNDBUF>, B<SO_MAX_PACING_RATE>, B<SO_PRIORITY>, B<SO_RCVLOWAT>, "
"B<SO_MARK>, B<SO_BINDTODEVICE>, B<SO_KEEPALIVE>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1360
msgid ""
"B<IPPROTO_TCP>, which supports the following I<optname>s: B<TCP_CONGESTION>, "
"B<TCP_BPF_IW>, B<TCP_BPF_SNDCWND_CLAMP>, B<TCP_SAVE_SYN>, B<TCP_KEEPIDLE>, "
"B<TCP_KEEPINTVL>, B<TCP_KEEPCNT>, B<TCP_SYNCNT>, B<TCP_USER_TIMEOUT>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1362 build/C/man7/bpf-helpers.7:1626
msgid "B<IPPROTO_IP>, which supports I<optname> B<IP_TOS>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1364 build/C/man7/bpf-helpers.7:1628
msgid "B<IPPROTO_IPV6>, which supports I<optname> B<IPV6_TCLASS>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1369
#, no-wrap
msgid "B<long bpf_skb_adjust_room(struct sk_buff *>I<skb>B<, s32 >I<len_diff>B<, u32 >I<mode>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_skb_adjust_room(struct sk_buff *>I<skb>B<, s32 >I<len_diff>B<, u32 >I<mode>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1376
msgid ""
"Grow or shrink the room for data in the packet associated to I<skb> by "
"I<len_diff>, and according to the selected I<mode>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1380
msgid ""
"By default, the helper will reset any offloaded checksum indicator of the "
"skb to CHECKSUM_NONE. This can be avoided by the following flag:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1384
msgid ""
"B<BPF_F_ADJ_ROOM_NO_CSUM_RESET>: Do not reset offloaded checksum data of the "
"skb to CHECKSUM_NONE."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1387
msgid "There are two supported modes at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1391
msgid ""
"B<BPF_ADJ_ROOM_MAC>: Adjust room at the mac layer (room space is added or "
"removed below the layer 2 header)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1394
msgid ""
"B<BPF_ADJ_ROOM_NET>: Adjust room at the network layer (room space is added "
"or removed below the layer 3 header)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1397
msgid "The following flags are supported at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1401
msgid ""
"B<BPF_F_ADJ_ROOM_FIXED_GSO>: Do not adjust gso_size.  Adjusting mss in this "
"way is not allowed for datagrams."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1406
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L3_IPV4>, B<BPF_F_ADJ_ROOM_ENCAP_L3_IPV6>: Any new "
"space is reserved to hold a tunnel header.  Configure skb offsets and other "
"fields accordingly."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1410
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L4_GRE>, B<BPF_F_ADJ_ROOM_ENCAP_L4_UDP>: Use with "
"ENCAP_L3 flags to further specify the tunnel type."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1414
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L2>(I<len>): Use with ENCAP_L3/L4 flags to further "
"specify the tunnel type; I<len> is the length of the inner MAC header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1425
#, no-wrap
msgid "B<long bpf_redirect_map(struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_redirect_map(struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1436
msgid ""
"Redirect the packet to the endpoint referenced by I<map> at index I<key>\\&. "
"Depending on its type, this I<map> can contain references to net devices "
"(for forwarding packets through other ports), or to CPUs (for redirecting "
"XDP frames to another CPU; but this is only implemented for native XDP (with "
"driver support) as of this writing)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1442
msgid ""
"The lower two bits of I<flags> are used as the return code if the map lookup "
"fails. This is so that the return value can be one of the XDP program return "
"codes up to B<XDP_TX>, as chosen by the caller. Any higher bits in the "
"I<flags> argument must be unset."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1445
msgid ""
"See also B<bpf_redirect>(), which only supports redirecting to an ifindex, "
"but doesn\\(aqt require a map to do so."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1449
msgid ""
"B<XDP_REDIRECT> on success, or the value of the two lower bits of the "
"I<flags> argument on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1450
#, no-wrap
msgid "B<long bpf_sk_redirect_map(struct sk_buff *>I<skb>B<, struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sk_redirect_map(struct sk_buff *>I<skb>B<, struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1461
msgid ""
"Redirect the packet to the socket referenced by I<map> (of type "
"B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1464 build/C/man7/bpf-helpers.7:1740
#: build/C/man7/bpf-helpers.7:2058 build/C/man7/bpf-helpers.7:2076
msgid "B<SK_PASS> on success, or B<SK_DROP> on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1465
#, no-wrap
msgid "B<long bpf_sock_map_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sock_map_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1473
msgid ""
"Add an entry to, or update a I<map> referencing sockets. The I<skops> is "
"used as a new value for the entry associated to I<key>\\&. I<flags> is one "
"of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1488 build/C/man7/bpf-helpers.7:2037
msgid ""
"If the I<map> has eBPF programs (parser and verdict), those will be "
"inherited by the socket being added. If the socket is already attached to "
"eBPF programs, this results in an error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1492
#, no-wrap
msgid "B<long bpf_xdp_adjust_meta(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr "B<long bpf_xdp_adjust_meta(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1502
msgid ""
"Adjust the address pointed by I<xdp_md>B<-E<gt>data_meta> by I<delta> (which "
"can be positive or negative). Note that this operation modifies the address "
"stored in I<xdp_md>B<-E<gt>data>, so the latter must be loaded only after "
"the helper has been called."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1515
msgid ""
"The use of I<xdp_md>B<-E<gt>data_meta> is optional and programs are not "
"required to use it. The rationale is that when the packet is processed with "
"XDP (e.g. as DoS filter), it is possible to push further meta data along "
"with it before passing to the stack, and to give the guarantee that an "
"ingress eBPF program attached as a TC classifier on the same device can pick "
"this up for further post-processing. Since TC works with socket buffers, it "
"remains possible to set from XDP the B<mark> or B<priority> pointers, or "
"other pointers for the socket buffer.  Having this scratch space generic and "
"programmable allows for more flexibility as the user is free to store "
"whatever meta data they need."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1525
#, no-wrap
msgid "B<long bpf_perf_event_read_value(struct bpf_map *>I<map>B<, u64 >I<flags>B<, struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr "B<long bpf_perf_event_read_value(struct bpf_map *>I<map>B<, u64 >I<flags>B<, struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1541
msgid ""
"Read the value of a perf event counter, and store it into I<buf> of size "
"I<buf_size>\\&. This helper relies on a I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event counter is "
"selected when I<map> is updated with perf event file descriptors. The I<map> "
"is an array whose size is the number of available CPUs, and each cell "
"contains a value relative to one CPU. The value to retrieve is indicated by "
"I<flags>, that contains the index of the CPU to look up, masked with "
"B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be set to "
"B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU should "
"be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1550
msgid ""
"This helper behaves in a way close to B<bpf_perf_event_read>() helper, save "
"that instead of just returning the value observed, it fills the I<buf> "
"structure. This allows for additional data to be retrieved: in particular, "
"the enabled and running times (in I<buf>B<-E<gt>enabled> and I<buf>B<-"
"E<gt>running>, respectively) are copied. In general, "
"B<bpf_perf_event_read_value>() is recommended over B<bpf_perf_event_read>(), "
"which has some ABI issues and provides fewer functionalities."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1562
msgid ""
"These values are interesting, because hardware PMU (Performance Monitoring "
"Unit) counters are limited resources. When there are more PMU based perf "
"events opened than available counters, kernel will multiplex these events so "
"each event gets certain percentage (but not all) of the PMU time. In case "
"that multiplexing happens, the number of samples or counter value will not "
"reflect the case compared to when no multiplexing occurs. This makes "
"comparison between different runs difficult.  Typically, the counter value "
"should be normalized before comparing to other experiments. The usual "
"normalization is done as follows."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1567
#, no-wrap
msgid "normalized_counter = counter * t_enabled / t_running\n"
msgstr "normalized_counter = counter * t_enabled / t_running\n"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1578
msgid ""
"Where t_enabled is the time enabled for event and t_running is the time "
"running for event since last normalization. The enabled and running times "
"are accumulated since the perf event open. To achieve scaling factor between "
"two invocations of an eBPF program, users can use CPU id as the key (which "
"is typical for perf array usage model) to remember the previous value and do "
"the calculation inside the eBPF program."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1582
#, no-wrap
msgid "B<long bpf_perf_prog_read_value(struct bpf_perf_event_data *>I<ctx>B<, struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr "B<long bpf_perf_prog_read_value(struct bpf_perf_event_data *>I<ctx>B<, struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1593
msgid ""
"For en eBPF program attached to a perf event, retrieve the value of the "
"event counter associated to I<ctx> and store it in the structure pointed by "
"I<buf> and of size I<buf_size>\\&. Enabled and running times are also stored "
"in the structure (see description of helper B<bpf_perf_event_read_value>() "
"for more details)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1597
#, no-wrap
msgid "B<long bpf_getsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int >I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"
msgstr "B<long bpf_getsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int >I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1608
msgid ""
"Emulate a call to B<getsockopt()> on the socket associated to I<bpf_socket>, "
"which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<getsockopt(2)> "
"for more information.  The retrieved value is stored in the structure "
"pointed by I<opval> and of length I<optlen>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1620
msgid ""
"This helper actually implements a subset of B<getsockopt()>\\&.  It supports "
"the following I<level>s:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1624
msgid "B<IPPROTO_TCP>, which supports I<optname> B<TCP_CONGESTION>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1633
#, no-wrap
msgid "B<long bpf_override_return(struct pt_regs *>I<regs>B<, u64 >I<rc>B<)>"
msgstr "B<long bpf_override_return(struct pt_regs *>I<regs>B<, u64 >I<rc>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1642
msgid ""
"Used for error injection, this helper uses kprobes to override the return "
"value of the probed function, and to set it to I<rc>\\&.  The first argument "
"is the context I<regs> on which the kprobe works."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1648
msgid ""
"This helper works by setting the PC (program counter)  to an override "
"function which is run in place of the original probed function. This means "
"the probed function is not run at all. The replacement function just returns "
"with the required value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1654
msgid ""
"This helper has security implications, and thus is subject to restrictions. "
"It is only available if the kernel was compiled with the "
"B<CONFIG_BPF_KPROBE_OVERRIDE> configuration option, and in this case it only "
"works on functions tagged with B<ALLOW_ERROR_INJECTION> in the kernel code."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1658
msgid ""
"Also, the helper is only available for the architectures having the "
"CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing, x86 architecture "
"is the only one to support this feature."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1662
#, no-wrap
msgid "B<long bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *>I<bpf_sock>B<, int >I<argval>B<)>"
msgstr "B<long bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *>I<bpf_sock>B<, int >I<argval>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1670
msgid ""
"Attempt to set the value of the B<bpf_sock_ops_cb_flags> field for the full "
"TCP socket associated to I<bpf_sock_ops> to I<argval>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1680
msgid ""
"The primary use of this field is to determine if there should be calls to "
"eBPF programs of type B<BPF_PROG_TYPE_SOCK_OPS> at various points in the TCP "
"code. A program of the same type can change its value, per connection and as "
"necessary, when the connection is established. This field is directly "
"accessible for reading, but this helper must be used for updates in order to "
"return an error if an eBPF program tries to set a callback that is not "
"supported in the current kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1682
msgid "I<argval> is a flag array which can combine these flags:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1685
msgid "B<BPF_SOCK_OPS_RTO_CB_FLAG> (retransmission time out)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1687
msgid "B<BPF_SOCK_OPS_RETRANS_CB_FLAG> (retransmission)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1689
msgid "B<BPF_SOCK_OPS_STATE_CB_FLAG> (TCP state change)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1691
msgid "B<BPF_SOCK_OPS_RTT_CB_FLAG> (every RTT)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1696
msgid ""
"Therefore, this function can be used to clear a callback flag by setting the "
"appropriate bit to zero. e.g. to disable the RTO callback:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1697
#, no-wrap
msgid "B<bpf_sock_ops_cb_flags_set(bpf_sock,>"
msgstr "B<bpf_sock_ops_cb_flags_set(bpf_sock,>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1700
msgid "B<bpf_sock-E<gt>bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)>"
msgstr "B<bpf_sock-E<gt>bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1704
msgid "Here are some examples of where one could call such eBPF program:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1707
msgid "When RTO fires."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1709
#, fuzzy
#| msgid "The socket is already connected."
msgid "When a packet is retransmitted."
msgstr "ソケットは既に接続 (connect) されている。"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1711
msgid "When the connection terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1713
msgid "When a packet is sent."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1715
#, fuzzy
#| msgid "The socket is already connected."
msgid "When a packet is received."
msgstr "ソケットは既に接続 (connect) されている。"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1722
msgid ""
"Code B<-EINVAL> if the socket is not a full TCP socket; otherwise, a "
"positive number containing the bits that could not be set is returned (which "
"comes down to 0 if all bits were set as required)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1723
#, no-wrap
msgid "B<long bpf_msg_redirect_map(struct sk_msg_buff *>I<msg>B<, struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_msg_redirect_map(struct sk_msg_buff *>I<msg>B<, struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1737
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message I<msg> is allowed to pass (i.e. if the verdict eBPF program "
"returns B<SK_PASS>), redirect it to the socket referenced by I<map> (of type "
"B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1741
#, no-wrap
msgid "B<long bpf_msg_apply_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr "B<long bpf_msg_apply_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1748
msgid ""
"For socket policies, apply the verdict of the eBPF program to the next "
"I<bytes> (number of bytes) of message I<msg>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1750
msgid "For example, this helper can be used in the following cases:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1755
msgid ""
"A single B<sendmsg>() or B<sendfile>() system call contains multiple logical "
"messages that the eBPF program is supposed to read and for which it should "
"apply a verdict."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1761
msgid ""
"An eBPF program only cares to read the first I<bytes> of a I<msg>\\&. If the "
"message has a large payload, then setting up and calling the eBPF program "
"repeatedly for all bytes, even though the verdict is already known, would "
"create unnecessary overhead."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1774
msgid ""
"When called from within an eBPF program, the helper sets a counter internal "
"to the BPF infrastructure, that is used to apply the last verdict to the "
"next I<bytes>\\&. If I<bytes> is smaller than the current data being "
"processed from a B<sendmsg>() or B<sendfile>() system call, the first "
"I<bytes> will be sent and the eBPF program will be re-run with the pointer "
"for start of data pointing to byte number I<bytes> B<+ 1>\\&. If I<bytes> is "
"larger than the current data being processed, then the eBPF verdict will be "
"applied to multiple B<sendmsg>() or B<sendfile>() calls until I<bytes> are "
"consumed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1778
msgid ""
"Note that if a socket closes with the internal counter holding a non-zero "
"value, this is not a problem because data is not being buffered for I<bytes> "
"and is sent as it is received."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1782
#, no-wrap
msgid "B<long bpf_msg_cork_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr "B<long bpf_msg_cork_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1790
msgid ""
"For socket policies, prevent the execution of the verdict eBPF program for "
"message I<msg> until I<bytes> (byte number) have been accumulated."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1800
msgid ""
"This can be used when one needs a specific number of bytes before a verdict "
"can be assigned, even if the data spans multiple B<sendmsg>() or "
"B<sendfile>() calls. The extreme case would be a user calling B<sendmsg>() "
"repeatedly with 1-byte long message segments. Obviously, this is bad for "
"performance, but it is still valid. If the eBPF program needs I<bytes> bytes "
"to validate a header, this helper can be used to prevent the eBPF program to "
"be called again until I<bytes> have been accumulated."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1804
#, no-wrap
msgid "B<long bpf_msg_pull_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 >I<end>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_msg_pull_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 >I<end>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1812
msgid ""
"For socket policies, pull in non-linear data from user space for I<msg> and "
"set pointers I<msg>B<-E<gt>data> and I<msg>B<-E<gt>data_end> to I<start> and "
"I<end> bytes offsets into I<msg>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1825
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it can only "
"parse data that the (B<data>, B<data_end>)  pointers have already consumed. "
"For B<sendmsg>() hooks this is likely the first scatterlist element. But for "
"calls relying on the B<sendpage> handler (e.g. B<sendfile>()) this will be "
"the range (B<0>, B<0>) because the data is shared with user space and by "
"default the objective is to avoid allowing user space to modify data while "
"(or after) eBPF verdict is being decided. This helper can be used to pull in "
"data and to set the start and end pointer to given values. Data will be "
"copied if necessary (i.e. if data was not linear and if start and end "
"pointers do not point to the same chunk)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1838
#, no-wrap
msgid "B<long bpf_bind(struct bpf_sock_addr *>I<ctx>B<, struct sockaddr *>I<addr>B<, int >I<addr_len>B<)>"
msgstr "B<long bpf_bind(struct bpf_sock_addr *>I<ctx>B<, struct sockaddr *>I<addr>B<, int >I<addr_len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1848
msgid ""
"Bind the socket associated to I<ctx> to the address pointed by I<addr>, of "
"length I<addr_len>\\&. This allows for making outgoing connection from the "
"desired IP address, which can be useful for example when all processes "
"inside a cgroup should use one single IP address on a host that has multiple "
"IP configured."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1856
msgid ""
"This helper works for IPv4 and IPv6, TCP and UDP sockets. The domain "
"(I<addr>B<-E<gt>sa_family>) must be B<AF_INET> (or B<AF_INET6>). It\\(aqs "
"advised to pass zero port (B<sin_port> or B<sin6_port>) which triggers "
"IP_BIND_ADDRESS_NO_PORT-like behavior and lets the kernel efficiently pick "
"up an unused port as long as 4-tuple is unique. Passing non-zero port might "
"lead to degraded performance."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1860
#, no-wrap
msgid "B<long bpf_xdp_adjust_tail(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr "B<long bpf_xdp_adjust_tail(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1868
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data_end> by I<delta> bytes. It is possible "
"to both shrink and grow the packet tail.  Shrink done via I<delta> being a "
"negative integer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1878
#, no-wrap
msgid "B<long bpf_skb_get_xfrm_state(struct sk_buff *>I<skb>B<, u32 >I<index>B<, struct bpf_xfrm_state *>I<xfrm_state>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_skb_get_xfrm_state(struct sk_buff *>I<skb>B<, u32 >I<index>B<, struct bpf_xfrm_state *>I<xfrm_state>B<, u32 >I<size>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1885
msgid ""
"Retrieve the XFRM state (IP transform framework, see also B<ip-xfrm(8)>) at "
"I<index> in XFRM \"security path\" for I<skb>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1888
msgid ""
"The retrieved value is stored in the B<struct bpf_xfrm_state> pointed by "
"I<xfrm_state> and of length I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1894
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_XFRM> "
"configuration option."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1898
#, no-wrap
msgid "B<long bpf_get_stack(void *>I<ctx>B<, void *>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_get_stack(void *>I<ctx>B<, void *>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1908
msgid ""
"Return a user or a kernel stack in bpf program provided buffer.  To achieve "
"this, the helper needs I<ctx>, which is a pointer to the context on which "
"the tracing program is executed.  To store the stacktrace, the bpf program "
"provides I<buf> with a nonnegative I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1913 build/C/man7/bpf-helpers.7:3565
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set the following flags:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1917 build/C/man7/bpf-helpers.7:3569
#, no-wrap
msgid "B<BPF_F_USER_BUILD_ID>"
msgstr "B<BPF_F_USER_BUILD_ID>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1921 build/C/man7/bpf-helpers.7:3573
msgid ""
"Collect buildid+offset instead of ips for user stack, only valid if "
"B<BPF_F_USER_STACK> is also specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1929
msgid ""
"B<bpf_get_stack>() can collect up to B<PERF_MAX_STACK_DEPTH> both kernel and "
"user frames, subject to sufficient large buffer size. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually "
"increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1941 build/C/man7/bpf-helpers.7:3593
msgid ""
"A non-negative value equal to or less than I<size> on success, or a negative "
"error in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1942
#, no-wrap
msgid "B<long bpf_skb_load_bytes_relative(const void *>I<skb>B<, u32 >I<offset>B<, void *>I<to>B<, u32 >I<len>B<, u32 >I<start_header>B<)>"
msgstr "B<long bpf_skb_load_bytes_relative(const void *>I<skb>B<, u32 >I<offset>B<, void *>I<to>B<, u32 >I<len>B<, u32 >I<start_header>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1953
msgid ""
"This helper is similar to B<bpf_skb_load_bytes>() in that it provides an "
"easy way to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&. The difference to "
"B<bpf_skb_load_bytes>() is that a fifth argument I<start_header> exists in "
"order to select a base offset to start from. I<start_header> can be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1954
#, no-wrap
msgid "B<BPF_HDR_START_MAC>"
msgstr "B<BPF_HDR_START_MAC>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1957
msgid "Base offset to load data from is I<skb>\\(aqs mac header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1957
#, no-wrap
msgid "B<BPF_HDR_START_NET>"
msgstr "B<BPF_HDR_START_NET>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1960
msgid "Base offset to load data from is I<skb>\\(aqs network header."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1967
msgid ""
"In general, \"direct packet access\" is the preferred method to access "
"packet data, however, this helper is in particular useful in socket filters "
"where I<skb>B<-E<gt>data> does not always point to the start of the mac "
"header and where \"direct packet access\" is not available."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1971
#, no-wrap
msgid "B<long bpf_fib_lookup(void *>I<ctx>B<, struct bpf_fib_lookup *>I<params>B<, int >I<plen>B<, u32 >I<flags>B<)>"
msgstr "B<long bpf_fib_lookup(void *>I<ctx>B<, struct bpf_fib_lookup *>I<params>B<, int >I<plen>B<, u32 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1985
msgid ""
"Do FIB lookup in kernel tables using parameters in I<params>\\&.  If lookup "
"is successful and result shows packet is to be forwarded, the neighbor "
"tables are searched for the nexthop.  If successful (ie., FIB lookup shows "
"forwarding and nexthop is resolved), the nexthop address is returned in "
"ipv4_dst or ipv6_dst based on family, smac is set to mac address of egress "
"device, dmac is set to nexthop mac address, rt_metric is set to metric from "
"route (IPv4/IPv6 only), and ifindex is set to the device index of the "
"nexthop from the FIB lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1989
#, fuzzy
#| msgid ""
#| "The I<flags> argument is formed by ORing one or more of the following "
#| "values:"
msgid ""
"I<plen> argument is the size of the passed in struct.  I<flags> argument can "
"be a combination of one or more of the following values:"
msgstr ""
"I<flags> 引数には、以下の値を 1つ以上、ビット単位の論理和 を取ったものを指"
"定する:"

#. type: TP
#: build/C/man7/bpf-helpers.7:1990
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_DIRECT>"
msgstr "B<BPF_FIB_LOOKUP_DIRECT>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1994
msgid "Do a direct table lookup vs full lookup using FIB rules."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1994
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_OUTPUT>"
msgstr "B<BPF_FIB_LOOKUP_OUTPUT>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1998
msgid "Perform lookup from an egress perspective (default is ingress)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2002
msgid ""
"I<ctx> is either B<struct xdp_md> for XDP programs or B<struct sk_buff> tc "
"cls_act programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2007
msgid "E<lt> 0 if any input argument is invalid"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2009
msgid "0 on success (packet is forwarded, nexthop neighbor exists)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2012
msgid ""
"E<gt> 0 one of B<BPF_FIB_LKUP_RET_> codes explaining why the packet is not "
"forwarded or needs assist from full stack"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2014
#, no-wrap
msgid "B<long bpf_sock_hash_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sock_hash_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2022
msgid ""
"Add an entry to, or update a sockhash I<map> referencing sockets.  The "
"I<skops> is used as a new value for the entry associated to I<key>\\&. "
"I<flags> is one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2041
#, no-wrap
msgid "B<long bpf_msg_redirect_hash(struct sk_msg_buff *>I<msg>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_msg_redirect_hash(struct sk_msg_buff *>I<msg>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2055
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message I<msg> is allowed to pass (i.e. if the verdict eBPF program "
"returns B<SK_PASS>), redirect it to the socket referenced by I<map> (of type "
"B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2059
#, no-wrap
msgid "B<long bpf_sk_redirect_hash(struct sk_buff *>I<skb>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sk_redirect_hash(struct sk_buff *>I<skb>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2073
msgid ""
"This helper is used in programs implementing policies at the skb socket "
"level. If the sk_buff I<skb> is allowed to pass (i.e.  if the verdict eBPF "
"program returns B<SK_PASS>), redirect it to the socket referenced by I<map> "
"(of type B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and "
"egress interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress otherwise). This is the only flag supported for now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2077
#, no-wrap
msgid "B<long bpf_lwt_push_encap(struct sk_buff *>I<skb>B<, u32 >I<type>B<, void *>I<hdr>B<, u32 >I<len>B<)>"
msgstr "B<long bpf_lwt_push_encap(struct sk_buff *>I<skb>B<, u32 >I<type>B<, void *>I<hdr>B<, u32 >I<len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2086
msgid ""
"Encapsulate the packet associated to I<skb> within a Layer 3 protocol "
"header. This header is provided in the buffer at address I<hdr>, with I<len> "
"its size in bytes. I<type> indicates the protocol of the header and can be "
"one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2087
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6>"
msgstr "B<BPF_LWT_ENCAP_SEG6>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2092
msgid ""
"IPv6 encapsulation with Segment Routing Header (B<struct ipv6_sr_hdr>). "
"I<hdr> only contains the SRH, the IPv6 header is computed by the kernel."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2092
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6_INLINE>"
msgstr "B<BPF_LWT_ENCAP_SEG6_INLINE>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2097
msgid ""
"Only works if I<skb> contains an IPv6 packet. Insert a Segment Routing "
"Header (B<struct ipv6_sr_hdr>) inside the IPv6 header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2097
#, no-wrap
msgid "B<BPF_LWT_ENCAP_IP>"
msgstr "B<BPF_LWT_ENCAP_IP>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2106
msgid ""
"IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6, "
"followed by zero or more additional headers, up to B<LWT_BPF_MAX_HEADROOM> "
"total bytes in all prepended headers. Please note that if "
"B<skb_is_gso>(I<skb>) is true, no more than two headers can be prepended, "
"and the inner header, if present, should be either GRE or UDP/GUE."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2112
msgid ""
"B<BPF_LWT_ENCAP_SEG6>* types can be called by BPF programs of type "
"B<BPF_PROG_TYPE_LWT_IN>; B<BPF_LWT_ENCAP_IP> type can be called by bpf "
"programs of types B<BPF_PROG_TYPE_LWT_IN> and B<BPF_PROG_TYPE_LWT_XMIT>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2122
#, no-wrap
msgid "B<long bpf_lwt_seg6_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, const void *>I<from>B<, u32 >I<len>B<)>"
msgstr "B<long bpf_lwt_seg6_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, const void *>I<from>B<, u32 >I<len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2131
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. Only the flags, tag and TLVs inside the outermost "
"IPv6 Segment Routing Header can be modified through this helper."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2141
#, no-wrap
msgid "B<long bpf_lwt_seg6_adjust_srh(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, s32 >I<delta>B<)>"
msgstr "B<long bpf_lwt_seg6_adjust_srh(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, s32 >I<delta>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2151
msgid ""
"Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing "
"Header contained in the packet associated to I<skb>, at position I<offset> "
"by I<delta> bytes. Only offsets after the segments are accepted. I<delta> "
"can be as well positive (growing) as negative (shrinking)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2161
#, no-wrap
msgid "B<long bpf_lwt_seg6_action(struct sk_buff *>I<skb>B<, u32 >I<action>B<, void *>I<param>B<, u32 >I<param_len>B<)>"
msgstr "B<long bpf_lwt_seg6_action(struct sk_buff *>I<skb>B<, u32 >I<action>B<, void *>I<param>B<, u32 >I<param_len>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2170
msgid ""
"Apply an IPv6 Segment Routing action of type I<action> to the packet "
"associated to I<skb>\\&. Each action takes a parameter contained at address "
"I<param>, and of length I<param_len> bytes.  I<action> can be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2171
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_X>"
msgstr "B<SEG6_LOCAL_ACTION_END_X>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2175
msgid ""
"End.X action: Endpoint with Layer-3 cross-connect.  Type of I<param>: "
"B<struct in6_addr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2175
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_T>"
msgstr "B<SEG6_LOCAL_ACTION_END_T>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2179
msgid ""
"End.T action: Endpoint with specific IPv6 table lookup.  Type of I<param>: "
"B<int>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2179
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6>"
msgstr "B<SEG6_LOCAL_ACTION_END_B6>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2183
msgid ""
"End.B6 action: Endpoint bound to an SRv6 policy.  Type of I<param>: B<struct "
"ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2183
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6_ENCAP>"
msgstr "B<SEG6_LOCAL_ACTION_END_B6_ENCAP>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2188
msgid ""
"End.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy.  Type "
"of I<param>: B<struct ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2199
#, no-wrap
msgid "B<long bpf_rc_repeat(void *>I<ctx>B<)>"
msgstr "B<long bpf_rc_repeat(void *>I<ctx>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2208
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded repeat key message. This delays the generation of a key "
"up event for previously generated key down event."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2211
msgid ""
"Some IR protocols like NEC have a special IR message for repeating last "
"button, for when a button is held down."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2214 build/C/man7/bpf-helpers.7:2241
#: build/C/man7/bpf-helpers.7:2519
msgid "The I<ctx> should point to the lirc sample as passed into the program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2218 build/C/man7/bpf-helpers.7:2248
#: build/C/man7/bpf-helpers.7:2523
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_BPF_LIRC_MODE2> configuration option set to \"B<y>\"."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2222
#, no-wrap
msgid "B<long bpf_rc_keydown(void *>I<ctx>B<, u32 >I<protocol>B<, u64 >I<scancode>B<, u32 >I<toggle>B<)>"
msgstr "B<long bpf_rc_keydown(void *>I<ctx>B<, u32 >I<protocol>B<, u64 >I<scancode>B<, u32 >I<toggle>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2235
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded key press with I<scancode>, I<toggle> value in the "
"given I<protocol>\\&. The scancode will be translated to a keycode using the "
"rc keymap, and reported as an input key down event. After a period a key up "
"event is generated. This period can be extended by calling either "
"B<bpf_rc_keydown>() again with the same values, or calling "
"B<bpf_rc_repeat>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2238
msgid ""
"Some protocols include a toggle bit, in case the button was released and "
"pressed again between consecutive scancodes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2244
msgid ""
"The I<protocol> is the decoded protocol number (see B<enum rc_proto> for "
"some predefined values)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2252
#, no-wrap
msgid "B<u64 bpf_skb_cgroup_id(struct sk_buff *>I<skb>B<)>"
msgstr "B<u64 bpf_skb_cgroup_id(struct sk_buff *>I<skb>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2264
msgid ""
"Return the cgroup v2 id of the socket associated with the I<skb>\\&.  This "
"is roughly similar to the B<bpf_get_cgroup_classid>()  helper for cgroup v1 "
"by providing a tag resp. identifier that can be matched on or used for map "
"lookups e.g. to implement policy. The cgroup v2 id of a given path in the "
"hierarchy is exposed in user space through the f_handle API in order to get "
"to the same 64-bit id."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2268
msgid ""
"This helper can be used on TC egress path, but not on ingress, and is "
"available only if the kernel was compiled with the "
"B<CONFIG_SOCK_CGROUP_DATA> configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2271 build/C/man7/bpf-helpers.7:2336
#: build/C/man7/bpf-helpers.7:3189 build/C/man7/bpf-helpers.7:3358
#: build/C/man7/bpf-helpers.7:3380
#, fuzzy
#| msgid ""
#| "is returned to indicate that expedited or out-of-band data were received."
msgid "The id is returned or 0 in case the id could not be retrieved."
msgstr "速達データや帯域外データを受信したことを示す。"

#. type: TP
#: build/C/man7/bpf-helpers.7:2272
#, no-wrap
msgid "B<u64 bpf_get_current_cgroup_id(void)>"
msgstr "B<u64 bpf_get_current_cgroup_id(void)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2279
msgid ""
"A 64-bit integer containing the current cgroup id based on the cgroup within "
"which the current task is running."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2280
#, no-wrap
msgid "B<void *bpf_get_local_storage(void *>I<map>B<, u64 >I<flags>B<)>"
msgstr "B<void *bpf_get_local_storage(void *>I<map>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2290
msgid ""
"Get the pointer to the local storage area.  The type and the size of the "
"local storage is defined by the I<map> argument.  The I<flags> meaning is "
"specific for each map type, and has to be 0 for cgroup local storage."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2294
msgid ""
"Depending on the BPF program type, a local storage area can be shared "
"between multiple instances of the BPF program, running simultaneously."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2298
msgid ""
"A user should care about the synchronization by himself.  For example, by "
"using the B<BPF_STX_XADD> instruction to alter the shared data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2301
msgid "A pointer to the local storage area."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2302
#, no-wrap
msgid "B<long bpf_sk_select_reuseport(struct sk_reuseport_md *>I<reuse>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sk_select_reuseport(struct sk_reuseport_md *>I<reuse>B<, struct bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2311
msgid ""
"Select a B<SO_REUSEPORT> socket from a B<BPF_MAP_TYPE_REUSEPORT_ARRAY> I<map>"
"\\&.  It checks the selected socket is matching the incoming request in the "
"socket buffer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2315
#, no-wrap
msgid "B<u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *>I<skb>B<, int >I<ancestor_level>B<)>"
msgstr "B<u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *>I<skb>B<, int >I<ancestor_level>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2326
msgid ""
"Return id of cgroup v2 that is ancestor of cgroup associated with the I<skb> "
"at the I<ancestor_level>\\&.  The root cgroup is at I<ancestor_level> zero "
"and each step down the hierarchy increments the level. If I<ancestor_level> "
"== level of cgroup associated with I<skb>, then return value will be same as "
"that of B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2330
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with I<skb>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2333
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2337
#, no-wrap
msgid "B<struct bpf_sock *bpf_sk_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple *>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr "B<struct bpf_sock *bpf_sk_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple *>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2345 build/C/man7/bpf-helpers.7:2665
msgid ""
"Look for TCP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>, "
"released via B<bpf_sk_release>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2349 build/C/man7/bpf-helpers.7:2393
msgid ""
"The I<ctx> should point to the context of the program, such as the skb or "
"socket (depending on the hook in use). This is used to determine the base "
"network namespace for the lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2351 build/C/man7/bpf-helpers.7:2395
msgid "I<tuple_size> must be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2352 build/C/man7/bpf-helpers.7:2396
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv4)>"
msgstr "B<sizeof(>I<tuple>B<-E<gt>ipv4)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2355 build/C/man7/bpf-helpers.7:2399
msgid "Look for an IPv4 socket."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2355 build/C/man7/bpf-helpers.7:2399
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv6)>"
msgstr "B<sizeof(>I<tuple>B<-E<gt>ipv6)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2358 build/C/man7/bpf-helpers.7:2402
msgid "Look for an IPv6 socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2368 build/C/man7/bpf-helpers.7:2412
msgid ""
"If the I<netns> is a negative signed 32-bit integer, then the socket lookup "
"table in the netns associated with the I<ctx> will be used. For the TC "
"hooks, this is the netns of the device in the skb. For socket hooks, this is "
"the netns of the socket.  If I<netns> is any other signed 32-bit value "
"greater than or equal to zero then it specifies the ID of the netns relative "
"to the netns associated with the I<ctx>\\&. I<netns> values beyond the range "
"of 32-bit integers are reserved for future use."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2374 build/C/man7/bpf-helpers.7:2418
#: build/C/man7/bpf-helpers.7:2673
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_NET> "
"configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2380 build/C/man7/bpf-helpers.7:2424
#: build/C/man7/bpf-helpers.7:2679
msgid ""
"Pointer to B<struct bpf_sock>, or B<NULL> in case of failure.  For sockets "
"with reuseport option, the B<struct bpf_sock> result is from I<reuse>B<-"
"E<gt>socks>[] using the hash of the tuple."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2381
#, no-wrap
msgid "B<struct bpf_sock *bpf_sk_lookup_udp(void *>I<ctx>B<, struct bpf_sock_tuple *>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr "B<struct bpf_sock *bpf_sk_lookup_udp(void *>I<ctx>B<, struct bpf_sock_tuple *>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2389
msgid ""
"Look for UDP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>, "
"released via B<bpf_sk_release>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2425
#, no-wrap
msgid "B<long bpf_sk_release(struct bpf_sock *>I<sock>B<)>"
msgstr "B<long bpf_sk_release(struct bpf_sock *>I<sock>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2433
msgid ""
"Release the reference held by I<sock>\\&. I<sock> must be a non-B<NULL> "
"pointer that was returned from B<bpf_sk_lookup_xxx>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2437
#, no-wrap
msgid "B<long bpf_map_push_elem(struct bpf_map *>I<map>B<, const void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2443
msgid "Push an element I<value> in I<map>\\&. I<flags> is one of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2448
msgid ""
"If the queue/stack is full, the oldest element is removed to make room for "
"this."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2453
#, no-wrap
msgid "B<long bpf_map_pop_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2459
msgid "Pop an element from I<map>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2463
#, no-wrap
msgid "B<long bpf_map_peek_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2469
msgid "Get an element from I<map> without removing it."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2473
#, no-wrap
msgid "B<long bpf_msg_push_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2480
msgid ""
"For socket policies, insert I<len> bytes into I<msg> at offset I<start>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2485
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it may want "
"to insert metadata or options into the I<msg>\\&.  This can later be read "
"and used by any of the lower layer BPF hooks."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2489
msgid ""
"This helper may fail if under memory pressure (a malloc fails) in these "
"cases BPF programs will get an appropriate error and BPF programs will need "
"to handle them."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2493
#, no-wrap
msgid "B<long bpf_msg_pop_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2505
msgid ""
"Will remove I<len> bytes from a I<msg> starting at byte I<start>\\&.  This "
"may result in B<ENOMEM> errors under certain situations if an allocation and "
"copy are required due to a full ring buffer.  However, the helper will try "
"to avoid doing the allocation if possible. Other errors can occur if input "
"parameters are invalid either due to I<start> byte not being valid part of "
"I<msg> payload and/or I<pop> value being to large."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2509
#, no-wrap
msgid "B<long bpf_rc_pointer_rel(void *>I<ctx>B<, s32 >I<rel_x>B<, s32 >I<rel_y>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2516
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded pointer movement."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2527
#, no-wrap
msgid "B<long bpf_spin_lock(struct bpf_spin_lock *>I<lock>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2537
msgid ""
"Acquire a spinlock represented by the pointer I<lock>, which is stored as "
"part of a value of a map. Taking the lock allows to safely update the rest "
"of the fields in that value. The spinlock can (and must) later be released "
"with a call to B<bpf_spin_unlock>(I<lock>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2540
msgid ""
"Spinlocks in BPF programs come with a number of restrictions and constraints:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2545
msgid ""
"B<bpf_spin_lock> objects are only allowed inside maps of types "
"B<BPF_MAP_TYPE_HASH> and B<BPF_MAP_TYPE_ARRAY> (this list could be extended "
"in the future)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2547
msgid "BTF description of the map is mandatory."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2550
msgid ""
"The BPF program can take ONE lock at a time, since taking two or more could "
"cause dead locks."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2552
msgid "Only one B<struct bpf_spin_lock> is allowed per map element."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2555
msgid ""
"When the lock is taken, calls (either BPF to BPF or helpers)  are not "
"allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2558
msgid ""
"The B<BPF_LD_ABS> and B<BPF_LD_IND> instructions are not allowed inside a "
"spinlock-ed region."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2561
msgid ""
"The BPF program MUST call B<bpf_spin_unlock>() to release the lock, on all "
"execution paths, before it returns."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2566
msgid ""
"The BPF program can access B<struct bpf_spin_lock> only via the "
"B<bpf_spin_lock>() and B<bpf_spin_unlock>()  helpers. Loading or storing "
"data into the B<struct bpf_spin_lock> I<lock>B<;> field of a map is not "
"allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2571
msgid ""
"To use the B<bpf_spin_lock>() helper, the BTF description of the map value "
"must be a struct and have B<struct bpf_spin_lock> I<anyname>B<;> field at "
"the top level.  Nested lock inside another struct is not allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2574
msgid ""
"The B<struct bpf_spin_lock> I<lock> field in a map value must be aligned on "
"a multiple of 4 bytes in that value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2577
msgid ""
"Syscall with command B<BPF_MAP_LOOKUP_ELEM> does not copy the "
"B<bpf_spin_lock> field to user space."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2580
msgid ""
"Syscall with command B<BPF_MAP_UPDATE_ELEM>, or update from a BPF program, "
"do not update the B<bpf_spin_lock> field."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2583
msgid ""
"B<bpf_spin_lock> cannot be on the stack or inside a networking packet (it "
"can only be inside of a map values)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2585
msgid "B<bpf_spin_lock> is available to root only."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2589
msgid ""
"Tracing programs and socket filter programs cannot use B<bpf_spin_lock>() "
"due to insufficient preemption checks (but this may change in the future)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2591
msgid "B<bpf_spin_lock> is not allowed in inner maps of map-in-map."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2596
#, no-wrap
msgid "B<long bpf_spin_unlock(struct bpf_spin_lock *>I<lock>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2603
msgid ""
"Release the I<lock> previously locked by a call to B<bpf_spin_lock>(I<lock>)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2607
#, no-wrap
msgid "B<struct bpf_sock *bpf_sk_fullsock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2614
msgid ""
"This helper gets a B<struct bpf_sock> pointer such that all the fields in "
"this B<bpf_sock> can be accessed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2618 build/C/man7/bpf-helpers.7:2656
msgid "A B<struct bpf_sock> pointer on success, or B<NULL> in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2619
#, no-wrap
msgid "B<struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2626
msgid ""
"This helper gets a B<struct bpf_tcp_sock> pointer from a B<struct bpf_sock> "
"pointer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2630
msgid ""
"A B<struct bpf_tcp_sock> pointer on success, or B<NULL> in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2631
#, no-wrap
msgid "B<long bpf_skb_ecn_set_ce(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2640
msgid ""
"Set ECN (Explicit Congestion Notification) field of IP header to B<CE> "
"(Congestion Encountered) if current value is B<ECT> (ECN Capable Transport). "
"Otherwise, do nothing. Works with IPv6 and IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2644
msgid ""
"1 if the B<CE> flag is set (either by the current helper call or because it "
"was already present), 0 if it is not set."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2645
#, no-wrap
msgid "B<struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2652
msgid ""
"Return a B<struct bpf_sock> pointer in B<TCP_LISTEN> state.  "
"B<bpf_sk_release>() is unnecessary and not allowed."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2657
#, no-wrap
msgid "B<struct bpf_sock *bpf_skc_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple *>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2670
msgid ""
"This function is identical to B<bpf_sk_lookup_tcp>(), except that it also "
"returns timewait or request sockets. Use B<bpf_sk_fullsock>() or "
"B<bpf_tcp_sock>() to access the full structure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2680
#, no-wrap
msgid "B<long bpf_tcp_check_syncookie(struct bpf_sock *>I<sk>B<, void *>I<iph>B<, u32 >I<iph_len>B<, struct tcphdr *>I<th>B<, u32 >I<th_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2687
msgid ""
"Check whether I<iph> and I<th> contain a valid SYN cookie ACK for the "
"listening socket in I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2691 build/C/man7/bpf-helpers.7:2913
msgid ""
"I<iph> points to the start of the IPv4 or IPv6 header, while I<iph_len> "
"contains B<sizeof>(B<struct iphdr>) or B<sizeof>(B<struct ip6hdr>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2694
msgid ""
"I<th> points to the start of the TCP header, while I<th_len> contains "
"B<sizeof>(B<struct tcphdr>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2698
msgid ""
"0 if I<iph> and I<th> are a valid SYN cookie ACK, or a negative error "
"otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2699
#, no-wrap
msgid "B<long bpf_sysctl_get_name(struct bpf_sysctl *>I<ctx>B<, char *>I<buf>B<, size_t >I<buf_len>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sysctl_get_name(struct bpf_sysctl *>I<ctx>B<, char *>I<buf>B<, size_t >I<buf_len>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2706
msgid ""
"Get name of sysctl in /proc/sys/ and copy it into provided by program buffer "
"I<buf> of size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2708 build/C/man7/bpf-helpers.7:2732
#: build/C/man7/bpf-helpers.7:2754
msgid "The buffer is always NUL terminated, unless it\\(aqs zero-sized."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2712
msgid ""
"If I<flags> is zero, full name (e.g. \"net/ipv4/tcp_mem\") is copied. Use "
"B<BPF_F_SYSCTL_BASE_NAME> flag to copy base name only (e.g. \"tcp_mem\")."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2715 build/C/man7/bpf-helpers.7:2735
#: build/C/man7/bpf-helpers.7:2757
msgid "Number of character copied (not including the trailing NUL)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2718 build/C/man7/bpf-helpers.7:2738
#: build/C/man7/bpf-helpers.7:2760
msgid ""
"B<-E2BIG> if the buffer wasn\\(aqt big enough (I<buf> will contain truncated "
"name in this case)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2719
#, no-wrap
msgid "B<long bpf_sysctl_get_current_value(struct bpf_sysctl *>I<ctx>B<, char *>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2727
msgid ""
"Get current value of sysctl as it is presented in /proc/sys (incl. newline, "
"etc), and copy it as a string into provided by program buffer I<buf> of size "
"I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2730
msgid ""
"The whole value is copied, no matter what file position user space issued e."
"g. sys_read at."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2741
msgid ""
"B<-EINVAL> if current value was unavailable, e.g. because sysctl is "
"uninitialized and read returns -EIO for it."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2742
#, no-wrap
msgid "B<long bpf_sysctl_get_new_value(struct bpf_sysctl *>I<ctx>B<, char *>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2750
msgid ""
"Get new value being written by user space to sysctl (before the actual write "
"happens) and copy it as a string into provided by program buffer I<buf> of "
"size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2752
msgid "User space may write new value at file position E<gt> 0."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2762 build/C/man7/bpf-helpers.7:2783
msgid "B<-EINVAL> if sysctl is being read."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2763
#, no-wrap
msgid "B<long bpf_sysctl_set_new_value(struct bpf_sysctl *>I<ctx>B<, const char *>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2770
msgid ""
"Override new value being written by user space to sysctl with value provided "
"by program in buffer I<buf> of size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2773
msgid ""
"I<buf> should contain a string in same form as provided by user space on "
"sysctl write."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2776
msgid ""
"User space may write new value at file position E<gt> 0. To override the "
"whole sysctl value file position should be set to zero."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2779 build/C/man7/bpf-helpers.7:2880
msgid "0 on success."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2781
msgid "B<-E2BIG> if the I<buf_len> is too big."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2784
#, no-wrap
msgid "B<long bpf_strtol(const char *>I<buf>B<, size_t >I<buf_len>B<, u64 >I<flags>B<, long *>I<res>B<)>"
msgstr "B<long bpf_strtol(const char *>I<buf>B<, size_t >I<buf_len>B<, u64 >I<flags>B<, long *>I<res>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2792
msgid ""
"Convert the initial part of the string from buffer I<buf> of size I<buf_len> "
"to a long integer according to the given base and save the result in I<res>"
"\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2796
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3)) followed by a single optional \\(aqB<->\\(aq sign."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2799 build/C/man7/bpf-helpers.7:2826
msgid ""
"Five least significant bits of I<flags> encode base, other bits are "
"currently unused."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2802
msgid ""
"Base must be either 8, 10, 16 or 0 to detect it automatically similar to "
"user space B<strtol>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2806 build/C/man7/bpf-helpers.7:2833
msgid ""
"Number of characters consumed on success. Must be positive but no more than "
"I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2809 build/C/man7/bpf-helpers.7:2836
msgid ""
"B<-EINVAL> if no valid digits were found or unsupported base was provided."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2811 build/C/man7/bpf-helpers.7:2838
msgid "B<-ERANGE> if resulting value was out of range."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2812
#, no-wrap
msgid "B<long bpf_strtoul(const char *>I<buf>B<, size_t >I<buf_len>B<, u64 >I<flags>B<, unsigned long *>I<res>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2820
msgid ""
"Convert the initial part of the string from buffer I<buf> of size I<buf_len> "
"to an unsigned long integer according to the given base and save the result "
"in I<res>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2823
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3))."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2829
msgid ""
"Base must be either 8, 10, 16 or 0 to detect it automatically similar to "
"user space B<strtoul>(3)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2839
#, no-wrap
msgid "B<void *bpf_sk_storage_get(struct bpf_map *>I<map>B<, struct bpf_sock *>I<sk>B<, void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2845
msgid "Get a bpf-local-storage from a I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2852
msgid ""
"Logically, it could be thought of getting the value from a I<map> with I<sk> "
"as the B<key>\\&.  From this perspective, the usage is not much different "
"from B<bpf_map_lookup_elem>(I<map>, B<&>I<sk>) except this helper enforces "
"the key must be a full socket and the map must be a "
"B<BPF_MAP_TYPE_SK_STORAGE> also."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2857
msgid ""
"Underneath, the value is stored locally at I<sk> instead of the I<map>\\&.  "
"The I<map> is used as the bpf-local-storage \"type\". The bpf-local-storage "
"\"type\" (i.e. the I<map>) is searched against all bpf-local-storages "
"residing at I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2864
msgid ""
"An optional I<flags> (B<BPF_SK_STORAGE_GET_F_CREATE>) can be used such that "
"a new bpf-local-storage will be created if one does not exist.  I<value> can "
"be used together with B<BPF_SK_STORAGE_GET_F_CREATE> to specify the initial "
"value of a bpf-local-storage.  If I<value> is B<NULL>, the new bpf-local-"
"storage will be zero initialized."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2867
msgid "A bpf-local-storage pointer is returned on success."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2870
msgid ""
"B<NULL> if not found or there was an error in adding a new bpf-local-storage."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2871
#, no-wrap
msgid "B<long bpf_sk_storage_delete(struct bpf_map *>I<map>B<, struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2877
msgid "Delete a bpf-local-storage from a I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2882
msgid "B<-ENOENT> if the bpf-local-storage cannot be found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2883
#, no-wrap
msgid "B<long bpf_send_signal(u32 >I<sig>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2890
msgid ""
"Send signal I<sig> to the process of the current task.  The signal may be "
"delivered to any of this process\\(aqs threads."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2893 build/C/man7/bpf-helpers.7:3065
msgid "0 on success or successfully queued."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2895 build/C/man7/bpf-helpers.7:3067
msgid "B<-EBUSY> if work queue under nmi is full."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2897 build/C/man7/bpf-helpers.7:3069
msgid "B<-EINVAL> if I<sig> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2899 build/C/man7/bpf-helpers.7:3071
msgid "B<-EPERM> if no permission to send the I<sig>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2901 build/C/man7/bpf-helpers.7:3073
msgid "B<-EAGAIN> if bpf program can try again."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2902
#, no-wrap
msgid "B<s64 bpf_tcp_gen_syncookie(struct bpf_sock *>I<sk>B<, void *>I<iph>B<, u32 >I<iph_len>B<, struct tcphdr *>I<th>B<, u32 >I<th_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2909
msgid ""
"Try to issue a SYN cookie for the packet with corresponding IP/TCP headers, "
"I<iph> and I<th>, on the listening socket in I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2916
msgid ""
"I<th> points to the start of the TCP header, while I<th_len> contains the "
"length of the TCP header."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2921
msgid ""
"On success, lower 32 bits hold the generated SYN cookie in followed by 16 "
"bits which hold the MSS value for that cookie, and the top 16 bits are "
"unused."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2923
msgid "On failure, the returned value is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2925
msgid "B<-EINVAL> SYN cookie cannot be issued due to error"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2927
msgid "B<-ENOENT> SYN cookie should not be issued (no SYN flood)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2929
msgid "B<-EOPNOTSUPP> kernel configuration does not enable SYN cookies"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2931
msgid "B<-EPROTONOSUPPORT> IP packet version is not 4 or 6"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2932
#, no-wrap
msgid "B<long bpf_skb_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 >I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2953
msgid "I<ctx> is a pointer to in-kernel struct sk_buff."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2956
msgid ""
"This helper is similar to B<bpf_perf_event_output>() but restricted to "
"raw_tracepoint bpf programs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2960
#, no-wrap
msgid "B<long bpf_probe_read_user(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2967
msgid ""
"Safely attempt to read I<size> bytes from user space address I<unsafe_ptr> "
"and store the data in I<dst>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2971
#, no-wrap
msgid "B<long bpf_probe_read_kernel(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2978
msgid ""
"Safely attempt to read I<size> bytes from kernel space address I<unsafe_ptr> "
"and store the data in I<dst>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2982
#, no-wrap
msgid "B<long bpf_probe_read_user_str(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2993
msgid ""
"Copy a NUL terminated string from an unsafe user address I<unsafe_ptr> to "
"I<dst>\\&. The I<size> should include the terminating NUL byte. In case the "
"string length is smaller than I<size>, the target is not padded with further "
"NUL bytes. If the string length is larger than I<size>, just I<size>-1 bytes "
"are copied and the last byte is set to NUL."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2998
msgid ""
"On success, the length of the copied string is returned. This makes this "
"helper useful in tracing programs for reading strings, and more importantly "
"to get its length at runtime. See the following snippet:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3008
#, no-wrap
msgid ""
"SEC(\"kprobe/sys_open\")\n"
"void bpf_sys_open(struct pt_regs *ctx)\n"
"{\n"
"        char buf[PATHLEN]; // PATHLEN is defined to 256\n"
"        int res = bpf_probe_read_user_str(buf, sizeof(buf),\n"
"                                          ctx-E<gt>di);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3014
#, no-wrap
msgid ""
"        // Consume buf, for example push it to\n"
"        // userspace via bpf_perf_event_output(); we\n"
"        // can use res (the string length) as event\n"
"        // size, after checking its boundaries.\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3022
msgid ""
"In comparison, using B<bpf_probe_read_user>() helper here instead to read "
"the string would require to estimate the length at compile time, and would "
"often result in copying more memory than necessary."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3027
msgid ""
"Another useful use case is when parsing individual process arguments or "
"individual environment variables navigating I<current>B<-E<gt>mm-"
"E<gt>arg_start> and I<current>B<-E<gt>mm-E<gt>env_start>: using this helper "
"and the return value, one can quickly iterate at the right offset of the "
"memory area."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3033
#, no-wrap
msgid "B<long bpf_probe_read_kernel_str(void *>I<dst>B<, u32 >I<size>B<, const void *>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3040
msgid ""
"Copy a NUL terminated string from an unsafe kernel address I<unsafe_ptr> to "
"I<dst>\\&. Same semantics as with B<bpf_probe_read_user_str>() apply."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3045
#, no-wrap
msgid "B<long bpf_tcp_send_ack(void *>I<tp>B<, u32 >I<rcv_nxt>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3052
msgid ""
"Send out a tcp-ack. I<tp> is the in-kernel struct B<tcp_sock>\\&.  "
"I<rcv_nxt> is the ack_seq to be sent out."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3056
#, no-wrap
msgid "B<long bpf_send_signal_thread(u32 >I<sig>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3062
msgid "Send signal I<sig> to the thread corresponding to the current task."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3074
#, no-wrap
msgid "B<u64 bpf_jiffies64(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3080
msgid "Obtain the 64bit jiffies"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3083
msgid "The 64 bit jiffies"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3084
#, no-wrap
msgid "B<long bpf_read_branch_records(struct bpf_perf_event_data *>I<ctx>B<, void *>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3093
msgid ""
"For an eBPF program attached to a perf event, retrieve the branch records "
"(B<struct perf_branch_entry>) associated to I<ctx> and store it in the "
"buffer pointed by I<buf> up to size I<size> bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3097
msgid ""
"On success, number of bytes written to I<buf>\\&. On error, a negative value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3101
msgid ""
"The I<flags> can be set to B<BPF_F_GET_BRANCH_RECORDS_SIZE> to instead "
"return the number of bytes required to store all the branch entries. If this "
"flag is set, I<buf> may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3104
msgid ""
"B<-EINVAL> if arguments invalid or B<size> not a multiple of "
"B<sizeof>(B<struct perf_branch_entry>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3106
msgid "B<-ENOENT> if architecture does not support branch records."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3107
#, no-wrap
msgid "B<long bpf_get_ns_current_pid_tgid(u64 >I<dev>B<, u64 >I<ino>B<, struct bpf_pidns_info *>I<nsdata>B<, u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3114
msgid ""
"Returns 0 on success, values for I<pid> and I<tgid> as seen from the current "
"I<namespace> will be returned in I<nsdata>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3117
msgid "0 on success, or one of the following in case of failure:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3120
msgid ""
"B<-EINVAL> if dev and inum supplied don\\(aqt match dev_t and inode number "
"with nsfs of current task, or if dev conversion to dev_t lost high bits."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3122
msgid "B<-ENOENT> if pidns does not exists for the current task."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3123
#, no-wrap
msgid "B<long bpf_xdp_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 >I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3144
msgid "I<ctx> is a pointer to in-kernel struct xdp_buff."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3147
msgid ""
"This helper is similar to B<bpf_perf_eventoutput>() but restricted to "
"raw_tracepoint bpf programs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3151
#, no-wrap
msgid "B<u64 bpf_get_netns_cookie(void *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3164
msgid ""
"Retrieve the cookie (generated by the kernel) of the network namespace the "
"input I<ctx> is associated with. The network namespace cookie remains stable "
"for its lifetime and provides a global identifier that can be assumed "
"unique. If I<ctx> is NULL, then the helper returns the cookie for the "
"initial network namespace. The cookie itself is very similar to that of "
"B<bpf_get_socket_cookie>() helper, but for network namespaces instead of "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3167
msgid "A 8-byte long opaque number."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3168
#, no-wrap
msgid "B<u64 bpf_get_current_ancestor_cgroup_id(int >I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3179
msgid ""
"Return id of cgroup v2 that is ancestor of the cgroup associated with the "
"current task at the I<ancestor_level>\\&. The root cgroup is at "
"I<ancestor_level> zero and each step down the hierarchy increments the "
"level. If I<ancestor_level> == level of cgroup associated with the current "
"task, then return value will be the same as that of "
"B<bpf_get_current_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3183
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3186
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_get_current_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3190
#, no-wrap
msgid "B<long bpf_sk_assign(struct sk_buff *>I<skb>B<, struct bpf_sock *>I<sk>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_sk_assign(struct sk_buff *>I<skb>B<, struct bpf_sock *>I<sk>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3198
msgid ""
"Helper is overloaded depending on BPF program type. This description applies "
"to B<BPF_PROG_TYPE_SCHED_CLS> and B<BPF_PROG_TYPE_SCHED_ACT> programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3205
msgid ""
"Assign the I<sk> to the I<skb>\\&. When combined with appropriate routing "
"configuration to receive the packet towards the socket, will cause I<skb> to "
"be delivered to the specified socket.  Subsequent redirection of I<skb> via "
"B<bpf_redirect>(), B<bpf_clone_redirect>() or other methods outside of BPF "
"may interfere with successful delivery to the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3207
msgid "This operation is only valid from TC ingress path."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3209
#, fuzzy
#| msgid "The flags argument"
msgid "The I<flags> argument must be zero."
msgstr "フラグ引数"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3212 build/C/man7/bpf-helpers.7:3317
#: build/C/man7/bpf-helpers.7:3338
msgid "0 on success, or a negative error in case of failure:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3214
msgid "B<-EINVAL> if specified I<flags> are not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3216
msgid "B<-ENOENT> if the socket is unavailable for assignment."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3218
msgid "B<-ENETUNREACH> if the socket is unreachable (wrong netns)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3221
msgid ""
"B<-EOPNOTSUPP> if the operation is not supported, for example a call from "
"outside of TC ingress."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3224
msgid "B<-ESOCKTNOSUPPORT> if the socket type is not supported (reuseport)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3225
#, no-wrap
msgid "B<long bpf_sk_assign(struct bpf_sk_lookup *>I<ctx>B<, struct bpf_sock *>I<sk>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3232
msgid ""
"Helper is overloaded depending on BPF program type. This description applies "
"to B<BPF_PROG_TYPE_SK_LOOKUP> programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3234
msgid "Select the I<sk> as a result of a socket lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3237
msgid ""
"For the operation to succeed passed socket must be compatible with the "
"packet description provided by the I<ctx> object."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3242
msgid ""
"L4 protocol (B<IPPROTO_TCP> or B<IPPROTO_UDP>) must be an exact match. While "
"IP family (B<AF_INET> or B<AF_INET6>) must be compatible, that is IPv6 "
"sockets that are not v6-only can be selected for IPv4 packets."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3246
msgid ""
"Only TCP listeners and UDP unconnected sockets can be selected. I<sk> can "
"also be NULL to reset any previous selection."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3248
#, fuzzy
#| msgid ""
#| "The I<flags> argument is formed by ORing one or more of the following "
#| "values:"
msgid "I<flags> argument can combination of following values:"
msgstr ""
"I<flags> 引数には、以下の値を 1つ以上、ビット単位の論理和 を取ったものを指"
"定する:"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3253
msgid ""
"B<BPF_SK_LOOKUP_F_REPLACE> to override the previous socket selection, "
"potentially done by a BPF program that ran before us."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3257
msgid ""
"B<BPF_SK_LOOKUP_F_NO_REUSEPORT> to skip load-balancing within reuseport "
"group for the socket being selected."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3260
msgid "On success I<ctx-E<gt>sk> will point to the selected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3263
msgid "0 on success, or a negative errno in case of failure."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3267
msgid ""
"B<-EAFNOSUPPORT> if socket family (I<sk-E<gt>family>) is not compatible with "
"packet family (I<ctx-E<gt>family>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3271
msgid ""
"B<-EEXIST> if socket has been already selected, potentially by another "
"program, and B<BPF_SK_LOOKUP_F_REPLACE> flag was not specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3273
msgid "B<-EINVAL> if unsupported flags were specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3277
msgid ""
"B<-EPROTOTYPE> if socket L4 protocol (I<sk-E<gt>protocol>) doesn\\(aqt match "
"packet protocol (I<ctx-E<gt>protocol>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3280
msgid ""
"B<-ESOCKTNOSUPPORT> if socket is not in allowed state (TCP listening or UDP "
"unconnected)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3282
#, no-wrap
msgid "B<u64 bpf_ktime_get_boot_ns(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3290
msgid ""
"Return the time elapsed since system boot, in nanoseconds.  Does include the "
"time the system was suspended.  See: B<clock_gettime>(B<CLOCK_BOOTTIME>)"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3294
#, no-wrap
msgid "B<long bpf_seq_printf(struct seq_file *>I<m>B<, const char *>I<fmt>B<, u32 >I<fmt_size>B<, const void *>I<data>B<, u32 >I<data_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3307
msgid ""
"B<bpf_seq_printf>() uses seq_file B<seq_printf>() to print out the format "
"string.  The I<m> represents the seq_file. The I<fmt> and I<fmt_size> are "
"for the format string itself. The I<data> and I<data_len> are format string "
"arguments. The I<data> are a B<u64> array and corresponding format string "
"values are stored in the array. For strings and pointers where pointees are "
"accessed, only the pointer values are stored in the I<data> array.  The "
"I<data_len> is the size of I<data> in bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3314
msgid ""
"Formats B<%s>, B<%p{i,I}{4,6}> requires to read kernel memory.  Reading "
"kernel memory may fail due to either invalid address or valid address but "
"requiring a major memory fault. If reading kernel memory fails, the string "
"for B<%s> will be an empty string, and the ip address for B<%p{i,I}{4,6}> "
"will be 0. Not returning error to bpf program is consistent with what "
"B<bpf_trace_printk>() does for now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3320
msgid ""
"B<-EBUSY> if per-CPU memory copy buffer is busy, can try again by returning "
"1 from bpf program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3322
msgid ""
"B<-EINVAL> if arguments are invalid, or if I<fmt> is invalid/unsupported."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3324
msgid "B<-E2BIG> if I<fmt> contains too many format specifiers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3326 build/C/man7/bpf-helpers.7:3340
msgid ""
"B<-EOVERFLOW> if an overflow happened: The same object will be tried again."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3327
#, no-wrap
msgid "B<long bpf_seq_write(struct seq_file *>I<m>B<, const void *>I<data>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3335
msgid ""
"B<bpf_seq_write>() uses seq_file B<seq_write>() to write the data.  The I<m> "
"represents the seq_file. The I<data> and I<len> represent the data to write "
"in bytes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3341
#, no-wrap
msgid "B<u64 bpf_sk_cgroup_id(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3347
msgid "Return the cgroup v2 id of the socket I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3352
msgid ""
"I<sk> must be a non-B<NULL> pointer to a full socket, e.g. one returned from "
"B<bpf_sk_lookup_xxx>(), B<bpf_sk_fullsock>(), etc. The format of returned id "
"is same as in B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3355
msgid ""
"This helper is available only if the kernel was compiled with the "
"B<CONFIG_SOCK_CGROUP_DATA> configuration option."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3359
#, no-wrap
msgid "B<u64 bpf_sk_ancestor_cgroup_id(struct bpf_sock *>I<sk>B<, int >I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3370
msgid ""
"Return id of cgroup v2 that is ancestor of cgroup associated with the I<sk> "
"at the I<ancestor_level>\\&.  The root cgroup is at I<ancestor_level> zero "
"and each step down the hierarchy increments the level. If I<ancestor_level> "
"== level of cgroup associated with I<sk>, then return value will be same as "
"that of B<bpf_sk_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3374
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3377
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_sk_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3381
#, no-wrap
msgid "B<long bpf_ringbuf_output(void *>I<ringbuf>B<, void *>I<data>B<, u64 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3391
msgid ""
"Copy I<size> bytes from I<data> into a ring buffer I<ringbuf>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3395
#, no-wrap
msgid "B<void *bpf_ringbuf_reserve(void *>I<ringbuf>B<, u64 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3401
msgid "Reserve I<size> bytes of payload in a ring buffer I<ringbuf>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3405
msgid "Valid pointer with I<size> bytes of memory available; NULL, otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3406
#, no-wrap
msgid "B<void bpf_ringbuf_submit(void *>I<data>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3416
msgid ""
"Submit reserved ring buffer sample, pointed to by I<data>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3419 build/C/man7/bpf-helpers.7:3433
msgid "Nothing. Always succeeds."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3420
#, no-wrap
msgid "B<void bpf_ringbuf_discard(void *>I<data>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3430
msgid ""
"Discard reserved ring buffer sample, pointed to by I<data>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3434
#, no-wrap
msgid "B<u64 bpf_ringbuf_query(void *>I<ringbuf>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3441
msgid ""
"Query various characteristics of provided ring buffer. What exactly is "
"queries is determined by I<flags>:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3444
msgid "B<BPF_RB_AVAIL_DATA>: Amount of data not yet consumed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3446
msgid "B<BPF_RB_RING_SIZE>: The size of ring buffer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3448
msgid "B<BPF_RB_CONS_POS>: Consumer position (can wrap around)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3450
msgid "B<BPF_RB_PROD_POS>: Producer(s) position (can wrap around)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3456
msgid ""
"Data returned is just a momentary snapshot of actual values and could be "
"inaccurate, so this facility should be used to power heuristics and for "
"reporting, not to make 100% correct calculation."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3459
msgid "Requested value, or 0, if I<flags> are not recognized."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3460
#, no-wrap
msgid "B<long bpf_csum_level(struct sk_buff *>I<skb>B<, u64 >I<level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3478
msgid ""
"Change the skbs checksum level by one layer up or down, or reset it entirely "
"to none in order to have the stack perform checksum validation. The level is "
"applicable to the following protocols: TCP, UDP, GRE, SCTP, FCOE. For "
"example, a decap of | ETH | IP | UDP | GUE | IP | TCP | into | ETH | IP | "
"TCP | through B<bpf_skb_adjust_room>() helper with passing in "
"B<BPF_F_ADJ_ROOM_NO_CSUM_RESET> flag would require one call to "
"B<bpf_csum_level>() with B<BPF_CSUM_LEVEL_DEC> since the UDP header is "
"removed. Similarly, an encap of the latter into the former could be "
"accompanied by a helper call to B<bpf_csum_level>() with "
"B<BPF_CSUM_LEVEL_INC> if the skb is still intended to be processed in higher "
"layers of the stack instead of just egressing at tc."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3480
msgid "There are three supported level settings at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3484
msgid ""
"B<BPF_CSUM_LEVEL_INC>: Increases skb-E<gt>csum_level for skbs with "
"CHECKSUM_UNNECESSARY."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3487
msgid ""
"B<BPF_CSUM_LEVEL_DEC>: Decreases skb-E<gt>csum_level for skbs with "
"CHECKSUM_UNNECESSARY."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3490
msgid ""
"B<BPF_CSUM_LEVEL_RESET>: Resets skb-E<gt>csum_level to 0 and sets "
"CHECKSUM_NONE to force checksum validation by the stack."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3493
msgid ""
"B<BPF_CSUM_LEVEL_QUERY>: No-op, returns the current skb-E<gt>csum_level."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3500
msgid ""
"0 on success, or a negative error in case of failure. In the case of "
"B<BPF_CSUM_LEVEL_QUERY>, the current skb-E<gt>csum_level is returned or the "
"error code -EACCES in case the skb is not subject to CHECKSUM_UNNECESSARY."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3501
#, no-wrap
msgid "B<struct tcp6_sock *bpf_skc_to_tcp6_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3507
msgid "Dynamically cast a I<sk> pointer to a I<tcp6_sock> pointer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3510 build/C/man7/bpf-helpers.7:3520
#: build/C/man7/bpf-helpers.7:3530 build/C/man7/bpf-helpers.7:3540
#: build/C/man7/bpf-helpers.7:3550
msgid "I<sk> if casting is valid, or NULL otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3511
#, no-wrap
msgid "B<struct tcp_sock *bpf_skc_to_tcp_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3517
msgid "Dynamically cast a I<sk> pointer to a I<tcp_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3521
#, no-wrap
msgid "B<struct tcp_timewait_sock *bpf_skc_to_tcp_timewait_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3527
msgid "Dynamically cast a I<sk> pointer to a I<tcp_timewait_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3531
#, no-wrap
msgid "B<struct tcp_request_sock *bpf_skc_to_tcp_request_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3537
msgid "Dynamically cast a I<sk> pointer to a I<tcp_request_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3541
#, no-wrap
msgid "B<struct udp6_sock *bpf_skc_to_udp6_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3547
msgid "Dynamically cast a I<sk> pointer to a I<udp6_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3551
#, no-wrap
msgid "B<long bpf_get_task_stack(struct task_struct *>I<task>B<, void *>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr "B<long bpf_get_task_stack(struct task_struct *>I<task>B<, void *>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3560
msgid ""
"Return a user or a kernel stack in bpf program provided buffer.  To achieve "
"this, the helper needs I<task>, which is a valid pointer to struct "
"task_struct. To store the stacktrace, the bpf program provides I<buf> with a "
"nonnegative I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3581
msgid ""
"B<bpf_get_task_stack>() can collect up to B<PERF_MAX_STACK_DEPTH> both "
"kernel and user frames, subject to sufficient large buffer size. Note that "
"this limit can be controlled with the B<sysctl> program, and that it should "
"be manually increased in order to profile long user stacks (such as stacks "
"for Java programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3599
msgid ""
"Example usage for most of the eBPF helpers listed in this manual page are "
"available within the Linux kernel sources, at the following locations:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3602
msgid "I<samples/bpf/>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3604
msgid "I<tools/testing/selftests/bpf/>"
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:3605
#, no-wrap
msgid "LICENSE"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3612
msgid ""
"eBPF programs can have an associated license, passed along with the bytecode "
"instructions to the kernel when the programs are loaded. The format for that "
"string is identical to the one in use for kernel modules (Dual licenses, "
"such as \"Dual BSD/GPL\", may be used). Some helper functions are only "
"accessible to programs that are compatible with the GNU Privacy License "
"(GPL)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3617
msgid ""
"In order to use such helpers, the eBPF program must be loaded with the "
"correct license string passed (via B<attr>) to the B<bpf>() system call, and "
"this generally translates into the C source code of the program containing a "
"line similar to the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3622
#, no-wrap
msgid "char ____license[] __attribute__((section(\"license\"), used)) = \"GPL\";\n"
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:3625
#, no-wrap
msgid "IMPLEMENTATION"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3635
msgid ""
"This manual page is an effort to document the existing eBPF helper "
"functions.  But as of this writing, the BPF sub-system is under heavy "
"development. New eBPF program or map types are added, along with new helper "
"functions. Some helpers are occasionally made available for additional "
"program types. So in spite of the efforts of the community, this page might "
"not be up-to-date. If you want to check by yourself what helper functions "
"exist in your kernel, or what types of programs they can support, here are "
"some files among the kernel tree that you may be interested in:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3640
msgid ""
"I<include/uapi/linux/bpf.h> is the main BPF header. It contains the full "
"list of all helper functions, as well as many other BPF definitions "
"including most of the flags, structs or constants used by the helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3643
msgid ""
"I<net/core/filter.c> contains the definition of most network-related helper "
"functions, and the list of program types from which they can be used."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3646
msgid ""
"I<kernel/trace/bpf_trace.c> is the equivalent for most tracing program-"
"related helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3649
msgid ""
"I<kernel/bpf/verifier.c> contains the functions used to check that valid "
"types of eBPF maps are used with a given helper function."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3652
msgid ""
"I<kernel/bpf/> directory contains other files in which additional helpers "
"are defined (for cgroups, sockmaps, etc.)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3658
msgid ""
"The bpftool utility can be used to probe the availability of helper "
"functions on the system (as well as supported program and map types, and a "
"number of other parameters). To do so, run B<bpftool feature probe> (see "
"B<bpftool-feature>(8) for details). Add the B<unprivileged> keyword to list "
"features available to unprivileged users."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3667
msgid ""
"Compatibility between helper functions and program types can generally be "
"found in the files where helper functions are defined. Look for the B<struct "
"bpf_func_proto> objects and for functions returning them: these functions "
"contain a list of helpers that a given program type can call. Note that the "
"B<default:> label of the B<switch ... case> used to filter helpers can call "
"other functions, themselves allowing access to additional helpers. The "
"requirement for GPL license is also in those B<struct bpf_func_proto>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3670
msgid ""
"Compatibility between helper functions and map types can be found in the "
"B<check_map_func_compatibility>() function in file I<kernel/bpf/verifier.c>"
"\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3674
msgid ""
"Helper functions that invalidate the checks on B<data> and B<data_end> "
"pointers for network processing are listed in function "
"B<bpf_helper_changes_pkt_data>() in file I<net/core/filter.c>\\&."
msgstr ""

#.  Generated by docutils manpage writer.
#. type: Plain text
#: build/C/man7/bpf-helpers.7:3685
msgid ""
"B<bpf>(2), B<bpftool>(8), B<cgroups>(7), B<ip>(8), B<perf_event_open>(2), "
"B<sendmsg>(2), B<socket>(7), B<tc-bpf>(8)"
msgstr "B<bpf>(2), B<bpftool>(8), B<cgroups>(7), B<ip>(8), B<perf_event_open>(2), B<sendmsg>(2), B<socket>(7), B<tc-bpf>(8)"

#. type: TH
#: build/C/man7/address_families.7:26
#, no-wrap
msgid "ADDRESS_FAMILIES"
msgstr ""

#. type: TH
#: build/C/man7/address_families.7:26
#, no-wrap
msgid "2018-10-16"
msgstr "2018-10-16"

#. type: Plain text
#: build/C/man7/address_families.7:29
msgid "address_families - socket address families (domains)"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:45
msgid ""
"The I<domain> argument of the B<socket>(2)  specifies a communication "
"domain; this selects the protocol family which will be used for "
"communication.  These families are defined in I<E<lt>sys/socket.hE<gt>>.  "
"The formats currently understood by the Linux kernel include:"
msgstr "B<socket>(2) の I<domain> 引数は通信を行なうドメインを指定する; これはどの プロトコルファミリー (protocol family) を通信に使用するかを指定する。 これらのファミリーは I<E<lt>sys/socket.hE<gt>> に定義されている。 現在カーネルが理解できるフォーマットは以下の通り。"

#. type: TP
#: build/C/man7/address_families.7:45
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>"
msgstr "B<AF_UNIX>, B<AF_LOCAL>"

#. type: Plain text
#: build/C/man7/address_families.7:50
msgid "Local communication For further information, see B<unix>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:55
msgid "IPv4 Internet protocols.  For further information, see B<ip>(7)."
msgstr ""

#.  Part of ax25-tools
#. type: Plain text
#: build/C/man7/address_families.7:61
msgid "Amateur radio AX.25 protocol.  For further information, see B<ax25>(4)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:64
msgid "IPX - Novell protocols."
msgstr "IPX - Novell プロトコル"

#. type: Plain text
#: build/C/man7/address_families.7:69
msgid "AppleTalk For further information, see B<ddp>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:69
#, no-wrap
msgid "B<AF_NETROM>"
msgstr "B<AF_NETROM>"

#.  Part of ax25-tools package
#. type: Plain text
#: build/C/man7/address_families.7:84
msgid ""
"AX.25 packet layer protocol.  For further information, see B<netrom>(4), E<."
"UR https://www.tldp.org/HOWTO/AX25-HOWTO/x61.html> I<The Packet Radio "
"Protocols and Linux> E<.UE> and the I<AX.25>, I<NET/ROM>, and I<ROSE network "
"programming> chapters of the E<.UR https://www.tldp.org/HOWTO/AX25-HOWTO/"
"x2107.html> I<Linux Amateur Radio AX.25 HOWTO> E<.UE .>"
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:84
#, no-wrap
msgid "B<AF_BRIDGE>"
msgstr "B<AF_BRIDGE>"

#. type: Plain text
#: build/C/man7/address_families.7:90
msgid ""
"Can't be used for creating sockets; mostly used for bridge links in "
"B<rtnetlink>(7)  protocol commands."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:90
#, no-wrap
msgid "B<AF_ATMPVC>"
msgstr "B<AF_ATMPVC>"

#. type: Plain text
#: build/C/man7/address_families.7:97
msgid ""
"Access to raw ATM Permanent Virtual Circuits (PVCs).  For further "
"information, see the E<.UR https://www.tldp.org/HOWTO/text/ATM-Linux-HOWTO> "
"I<ATM on Linux HOWTO> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:102
msgid ""
"ITU-T X.25 / ISO-8208 protocol.  For further information, see B<x25>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:107
msgid "IPv6 Internet protocols.  For further information, see B<ipv6>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:107
#, no-wrap
msgid "B<AF_ROSE>"
msgstr "B<AF_ROSE>"

#. type: Plain text
#: build/C/man7/address_families.7:113
msgid ""
"RATS (Radio Amateur Telecommunications Society)  Open Systems environment "
"(ROSE) AX.25 packet layer protocol.  For further information, see the "
"resources listed for B<AF_NETROM>."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:119
msgid ""
"DECet protocol sockets.  See I<Documentation/networking/decnet.txt> in the "
"Linux kernel source tree for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:119
#, no-wrap
msgid "B<AF_NETBEUI>"
msgstr "B<AF_NETBEUI>"

#. type: Plain text
#: build/C/man7/address_families.7:122
msgid "Reserved for \"802.2LLC project\"; never used."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:122
#, no-wrap
msgid "B<AF_SECURITY>"
msgstr "B<AF_SECURITY>"

#. type: Plain text
#: build/C/man7/address_families.7:126
msgid ""
"This was a short-lived (between Linux 2.1.30 and 2.1.99pre2) protocol family "
"for firewall upcalls."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:139
msgid ""
"Key management protocol, originally developed for usage with IPsec (since "
"Linux 2.1.38).  This has no relation to B<keyctl>(2)  and the in-kernel key "
"storage facility.  See E<.UR https://tools.ietf.org/html/rfc2367> RFC 2367 "
"I<PF_KEY Key Management API, Version 2> E<.UE> for details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:144
msgid ""
"Kernel user interface device For further information, see B<netlink>(7)."
msgstr ""

#.  .TP
#.  .B AF_ASH
#.  Asynchronous Serial Host protocol (?)
#.  Notes from Eugene Syromyatnikov:
#.  I haven't found any concrete information about this one;
#.  it never was implemented in Linux, at least, judging by historical
#.  repos.  There is also this file (and its variations):
#.  https://github.com/ecki/net-tools/blob/master/lib/ash.c
#.  ( https://github.com/ecki/net-tools/commits/master/lib/ash.c )
#.  it mentions "NET-2 distribution" (BSD Net/2?), but, again, I failed
#.  to find any mentions of "ash" protocol there.
#.  (for the reference:
#.  ftp://pdp11.org.ru/pub/unix-archive/Distributions/UCB/Net2/net2.tar.gz )
#.  Another source that mentions it is
#.  https://www.silabs.com/documents/public/user-guides/ug101-uart-gateway-protocol-reference.pdf
#.  https://www.silabs.com/documents/public/user-guides/ug115-ashv3-protocol-reference.pdf
#.  but I doubt that it's related, as former files use 64-byte addresses and
#.  "Hamming-encode of hops", and that's barely combines with a protocol
#.  that is mainly used over serial connection.
#. type: Plain text
#: build/C/man7/address_families.7:168
msgid "Low-level packet interface.  For further information, see B<packet>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:168
#, no-wrap
msgid "B<AF_ECONET>"
msgstr "B<AF_ECONET>"

#.  commit: 349f29d841dbae854bd7367be7c250401f974f47
#. type: Plain text
#: build/C/man7/address_families.7:177
msgid ""
"Acorn Econet protocol (removed in Linux 3.5).  See the E<.UR http://www.8bs."
"com/othrdnld/manuals/econet.shtml> Econet documentation E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:177
#, no-wrap
msgid "B<AF_ATMSVC>"
msgstr "B<AF_ATMSVC>"

#. type: Plain text
#: build/C/man7/address_families.7:185
msgid ""
"Access to ATM Switched Virtual Circuits (SVCs)  See the E<.UR https://www."
"tldp.org/HOWTO/text/ATM-Linux-HOWTO> I<ATM on Linux HOWTO> E<.UE> for "
"details."
msgstr ""

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: Plain text
#: build/C/man7/address_families.7:201
msgid ""
"Reliable Datagram Sockets (RDS) protocol (since Linux 2.6.30).  RDS over "
"RDMA has no relation to B<AF_SMC> or B<AF_XDP>.  For further information see "
"B<rds>(7), B<rds-rdma>(7), and I<Documentation/networking/rds.txt> in the "
"Linux kernel source tree."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:201
#, no-wrap
msgid "B<AF_IRDA>"
msgstr "B<AF_IRDA>"

#.  commits: 1ca163afb6fd569b, d64c2a76123f0300
#.  irda-utils: https://sourceforge.net/p/irda/code/HEAD/tree/tags/IRDAUTILS_0_9_18/irda-utils/man/irda.7.gz?format=raw
#. type: Plain text
#: build/C/man7/address_families.7:209
msgid ""
"Socket interface over IrDA (moved to staging in Linux 4.14, removed in Linux "
"4.17).  For further information see B<irda>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:216
msgid ""
"Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE).  "
"See I<Documentation/networking/l2tp.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:216
#, no-wrap
msgid "B<AF_WANPIPE>"
msgstr "B<AF_WANPIPE>"

#.  commits: ce0ecd594d78710422599918a608e96dd1ee6024
#. type: Plain text
#: build/C/man7/address_families.7:222
msgid ""
"Legacy protocol for wide area network (WAN) connectivity that was used by "
"Sangoma WAN cards (called \"WANPIPE\"); removed in Linux 2.6.21."
msgstr ""

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: Plain text
#: build/C/man7/address_families.7:245
msgid ""
"Logical link control (IEEE 802.2 LLC) protocol, upper part of data link "
"layer of ISO/OSI networking protocol stack (since Linux 2.4); has no "
"relation to B<AF_PACKET>.  See chapter I<13.5.3. Logical Link Control> in "
"I<Understanding Linux Kernel Internals> (O'Reilly Media, 2006)  and I<IEEE "
"Standards for Local Area Networks: Logical Link Control> (The Institute of "
"Electronics and Electronics Engineers, Inc., New York, New York, 1985)  for "
"details.  See also E<.UR https://wiki.linuxfoundation.org/networking/llc> "
"some historical notes E<.UE> regarding its development."
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: Plain text
#: build/C/man7/address_families.7:249
msgid "InfiniBand native addressing (since Linux 3.11)."
msgstr ""

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: Plain text
#: build/C/man7/address_families.7:256
msgid ""
"Multiprotocol Label Switching (since Linux 4.1); mostly used for configuring "
"MPLS routing via B<netlink>(7), as it doesn't expose ability to create "
"sockets to user space."
msgstr ""

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: Plain text
#: build/C/man7/address_families.7:263
msgid ""
"Controller Area Network automotive bus protocol (since Linux 2.6.25).  See "
"I<Documentation/networking/can.rst> in the Linux kernel source tree for "
"details."
msgstr ""

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: Plain text
#: build/C/man7/address_families.7:276
msgid ""
"TIPC, \"cluster domain sockets\" protocol (since Linux 2.6.16).  See E<.UR "
"http://tipc.io/programming.html> I<TIPC Programmer's Guide> E<.UE> and the "
"E<.UR http://tipc.io/protocol.html> protocol description E<.UE> for details."
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: Plain text
#: build/C/man7/address_families.7:290
msgid ""
"Bluetooth low-level socket protocol (since Linux 3.11).  See E<.UR https://"
"git.kernel.org\\:/pub/scm\\:/bluetooth/bluez.git\\:/tree/doc/mgmt-api.txt> "
"I<Bluetooth Management API overview> E<.UE> and E<.UR https://people.csail."
"mit.edu/albert/bluez-intro/> I<An Introduction to Bluetooth Programming> by "
"Albert Huang E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:290
#, no-wrap
msgid "B<AF_IUCV>"
msgstr "B<AF_IUCV>"

#.  commit: eac3731bd04c7131478722a3c148b78774553116
#. type: Plain text
#: build/C/man7/address_families.7:304
msgid ""
"IUCV (inter-user communication vehicle) z/VM protocol for hypervisor-guest "
"interaction (since Linux 2.6.21); has no relation to B<AF_VSOCK> and/or "
"B<AF_SMC> See E<.UR https://www.ibm.com\\:/support\\:/knowledgecenter\\:/en/"
"SSB27U_6.4.0\\:/com.ibm.zvm.v640.hcpb4\\:/iucv.htm> I<IUCV protocol "
"overview> E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:304
#, no-wrap
msgid "B<AF_RXRPC>"
msgstr "B<AF_RXRPC>"

#.  commit: 17926a79320afa9b95df6b977b40cca6d8713cea
#.  http://people.redhat.com/~dhowells/rxrpc/
#.  https://www.infradead.org/~dhowells/kafs/af_rxrpc_client.html
#.  http://workshop.openafs.org/afsbpw09/talks/thu_2/kafs.pdf
#.  http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf
#.  http://web.mit.edu/kolya/afs/rx/rx-spec
#. type: Plain text
#: build/C/man7/address_families.7:317
msgid ""
"Rx, Andrew File System remote procedure call protocol (since Linux 2.6.22).  "
"See I<Documentation/networking/rxrpc.txt> in the Linux kernel source tree "
"for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:317
#, no-wrap
msgid "B<AF_ISDN>"
msgstr "B<AF_ISDN>"

#.  commit: 1b2b03f8e514e4f68e293846ba511a948b80243c
#. type: Plain text
#: build/C/man7/address_families.7:326
msgid ""
"New \"modular ISDN\" driver interface protocol (since Linux 2.6.27).  See "
"the E<.UR http://www.misdn.eu/wiki/Main_Page/> mISDN wiki E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:326
#, no-wrap
msgid "B<AF_PHONET>"
msgstr "B<AF_PHONET>"

#.  commit: 4b07b3f69a8471cdc142c51461a331226fef248a
#. type: Plain text
#: build/C/man7/address_families.7:333
msgid ""
"Nokia cellular modem IPC/RPC interface (since Linux 2.6.31).  See "
"I<Documentation/networking/phonet.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:333
#, no-wrap
msgid "B<AF_IEEE802154>"
msgstr "B<AF_IEEE802154>"

#.  commit: 9ec7671603573ede31207eb5b0b3e1aa211b2854
#. type: Plain text
#: build/C/man7/address_families.7:341
msgid ""
"IEEE 802.15.4 WPAN (wireless personal area network) raw packet protocol "
"(since Linux 2.6.31).  See I<Documentation/networking/ieee802154.txt> in the "
"Linux kernel source tree for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:341
#, no-wrap
msgid "B<AF_CAIF>"
msgstr "B<AF_CAIF>"

#.  commit: 529d6dad5bc69de14cdd24831e2a14264e93daa4
#.  https://lwn.net/Articles/371017/
#.  http://read.pudn.com/downloads157/doc/comm/698729/Misc/caif/Com%20CPU%20to%20Appl%20CPU%20Interface%20DESCRIPTION_LZN901%202002_revR1C.pdf
#.  http://read.pudn.com/downloads157/doc/comm/698729/Misc/caif/Com%20CPU%20to%20Appl%20CPU%20Interface%20PROTOCOL%20SPECIFICATION_LZN901%201708_revR1A.pdf
#. type: Plain text
#: build/C/man7/address_families.7:352
msgid ""
"Ericsson's Communication CPU to Application CPU interface (CAIF) protocol "
"(since Linux 2.6.36).  See I<Documentation/networking/caif/Linux-CAIF.txt> "
"in the Linux kernel source tree for details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:358
msgid ""
"Interface to kernel crypto API (since Linux 2.6.38).  See I<Documentation/"
"crypto/userspace-if.rst> in the Linux kernel source tree for details."
msgstr ""

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: Plain text
#: build/C/man7/address_families.7:368
msgid ""
"VMWare VSockets protocol for hypervisor-guest interaction (since Linux 3.9); "
"has no relation to B<AF_IUCV> and B<AF_SMC>.  For further information, see "
"B<vsock>(7)."
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: Plain text
#: build/C/man7/address_families.7:375
msgid ""
"KCM (kernel connection multiplexer) interface (since Linux 4.6).  See "
"I<Documentation/networking/kcm.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:375
#, no-wrap
msgid "B<AF_QIPCRTR>"
msgstr "B<AF_QIPCRTR>"

#.  commit: bdabad3e363d825ddf9679dd431cca0b2c30f881
#. type: Plain text
#: build/C/man7/address_families.7:379
msgid "Qualcomm IPC router interface protocol (since Linux 4.7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:379
#, no-wrap
msgid "B<AF_SMC>"
msgstr "B<AF_SMC>"

#.  commit: f3a3e248f3f7cd9a4bed334022704d7e7fc781bf
#. type: Plain text
#: build/C/man7/address_families.7:400
msgid ""
"SMC-R (shared memory communications over RDMA) protocol (since Linux 4.11), "
"and SMC-D (shared memory communications, direct memory access) protocol for "
"intra-node z/VM quest interaction (since Linux 4.19); has no relation to "
"B<AF_RDS>, B<AF_IUCV> or B<AF_VSOCK>.  See E<.UR https://tools.ietf.org/html/"
"rfc7609> RFC 7609 I<IBM's Shared Memory Communications over RDMA (SMC-R) "
"Protocol> E<.UE> for details regarding SMC-R.  See E<.UR https://www-01.ibm."
"com\\:/software/network\\:/commserver\\:/SMC-D/index.html> I<SMC-D Reference "
"Information> E<.UE> for details regarding SMC-D."
msgstr ""

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: Plain text
#: build/C/man7/address_families.7:407
msgid ""
"XDP (express data path) interface (since Linux 4.18).  See I<Documentation/"
"networking/af_xdp.rst> in the Linux kernel source tree for details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:410
msgid "B<socket>(2), B<socket>(7)"
msgstr "B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man7/sock_diag.7:24
#, no-wrap
msgid "SOCK_DIAG"
msgstr "SOCK_DIAG"

#. type: Plain text
#: build/C/man7/sock_diag.7:27
msgid "sock_diag - obtaining information about sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/sock_diag.hE<gt>>\n"
"B<#include E<lt>linux/unix_diag.hE<gt>> /* for UNIX domain sockets */\n"
"B<#include E<lt>linux/inet_diag.hE<gt>> /* for IPv4 and IPv6 sockets */\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/sock_diag.hE<gt>>\n"
"B<#include E<lt>linux/unix_diag.hE<gt>> /* for UNIX domain sockets */\n"
"B<#include E<lt>linux/inet_diag.hE<gt>> /* for IPv4 and IPv6 sockets */\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:35
#, no-wrap
msgid "B<diag_socket = socket(AF_NETLINK, >I<socket_type>B<, NETLINK_SOCK_DIAG);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:41
msgid ""
"The sock_diag netlink subsystem provides a mechanism for obtaining "
"information about sockets of various address families from the kernel.  This "
"subsystem can be used to obtain information about individual sockets or "
"request a list of sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:45
msgid ""
"In the request, the caller can specify additional information it would like "
"to obtain about the socket, for example, memory information or information "
"specific to the address family."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:50
msgid ""
"When requesting a list of sockets, the caller can specify filters that would "
"be applied by the kernel to select a subset of sockets to report.  For now, "
"there is only the ability to filter sockets by state (connected, listening, "
"and so on.)"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:62
msgid ""
"Note that sock_diag reports only those sockets that have a name; that is, "
"either sockets bound explicitly with B<bind>(2)  or sockets that were "
"automatically bound to an address (e.g., by B<connect>(2)).  This is the "
"same set of sockets that is available via I</proc/net/unix>, I</proc/net/"
"tcp>, I</proc/net/udp>, and so on."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:62
#, no-wrap
msgid "Request"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:73
msgid ""
"The request starts with a I<struct nlmsghdr> header described in "
"B<netlink>(7)  with I<nlmsg_type> field set to B<SOCK_DIAG_BY_FAMILY>.  It "
"is followed by a header specific to the address family that starts with a "
"common part shared by all address families:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:80
#, no-wrap
msgid ""
"struct sock_diag_req {\n"
"    __u8 sdiag_family;\n"
"    __u8 sdiag_protocol;\n"
"};\n"
msgstr ""
"struct sock_diag_req {\n"
"    __u8 sdiag_family;\n"
"    __u8 sdiag_protocol;\n"
"};\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:84 build/C/man7/sock_diag.7:146
#: build/C/man7/sock_diag.7:206 build/C/man7/sock_diag.7:249
#: build/C/man7/sock_diag.7:310 build/C/man7/sock_diag.7:425
#: build/C/man7/sock_diag.7:519
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:84 build/C/man7/sock_diag.7:146
#: build/C/man7/sock_diag.7:375
#, no-wrap
msgid "I<sdiag_family>"
msgstr "I<sdiag_family>"

#. type: Plain text
#: build/C/man7/sock_diag.7:90
msgid ""
"An address family.  It should be set to the appropriate B<AF_*> constant."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:90 build/C/man7/sock_diag.7:152
#: build/C/man7/sock_diag.7:382
#, no-wrap
msgid "I<sdiag_protocol>"
msgstr "I<sdiag_protocol>"

#. type: Plain text
#: build/C/man7/sock_diag.7:101
msgid ""
"Depends on I<sdiag_family>.  It should be set to the appropriate "
"B<IPPROTO_*> constant for B<AF_INET> and B<AF_INET6>, and to 0 otherwise."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:111
msgid ""
"If the I<nlmsg_flags> field of the I<struct nlmsghdr> header has the "
"B<NLM_F_DUMP> flag set, it means that a list of sockets is being requested; "
"otherwise it is a query about an individual socket."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:111
#, no-wrap
msgid "Response"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:120
msgid ""
"The response starts with a I<struct nlmsghdr> header and is followed by an "
"array of objects specific to the address family.  The array is to be "
"accessed with the standard B<NLMSG_*> macros from the B<netlink>(3)  API."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:128
msgid ""
"Each object is the NLA (netlink attributes) list that is to be accessed with "
"the B<RTA_*> macros from B<rtnetlink>(3)  API."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:128
#, no-wrap
msgid "UNIX domain sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:130
msgid ""
"For UNIX domain sockets the request is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:142
#, no-wrap
msgid ""
"struct unix_diag_req {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u16   pad;\n"
"    __u32   udiag_states;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_show;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""
"struct unix_diag_req {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u16   pad;\n"
"    __u32   udiag_states;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_show;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:150
msgid "The address family; it should be set to B<AF_UNIX>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:153 build/C/man7/sock_diag.7:327
#: build/C/man7/sock_diag.7:454
#, no-wrap
msgid "I<pad>"
msgstr "I<pad>"

#. type: Plain text
#: build/C/man7/sock_diag.7:157
msgid "These fields should be set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:157
#, no-wrap
msgid "I<udiag_states>"
msgstr "I<udiag_states>"

#. type: Plain text
#: build/C/man7/sock_diag.7:163
msgid ""
"This is a bit mask that defines a filter of sockets states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket.  Supported values are:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:167
msgid "1 E<lt>E<lt> B<TCP_ESTABLISHED>"
msgstr "1 E<lt>E<lt> B<TCP_ESTABLISHED>"

#. type: Plain text
#: build/C/man7/sock_diag.7:170
msgid "1 E<lt>E<lt> B<TCP_LISTEN>"
msgstr "1 E<lt>E<lt> B<TCP_LISTEN>"

#. type: TP
#: build/C/man7/sock_diag.7:171 build/C/man7/sock_diag.7:330
#, no-wrap
msgid "I<udiag_ino>"
msgstr "I<udiag_ino>"

#. type: Plain text
#: build/C/man7/sock_diag.7:175
msgid ""
"This is an inode number when querying for an individual socket.  Ignored "
"when querying for a list of sockets."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:175
#, no-wrap
msgid "I<udiag_show>"
msgstr "I<udiag_show>"

#. type: Plain text
#: build/C/man7/sock_diag.7:180
msgid ""
"This is a set of flags defining what kind of information to report.  Each "
"requested kind of information is reported back as a netlink attribute as "
"described below:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:181
#, no-wrap
msgid "B<UDIAG_SHOW_NAME>"
msgstr "B<UDIAG_SHOW_NAME>"

#. type: Plain text
#: build/C/man7/sock_diag.7:189
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_NAME>.  The "
"payload associated with this attribute is the pathname to which the socket "
"was bound (a sequence of bytes up to B<UNIX_PATH_MAX> length)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:189
#, no-wrap
msgid "B<UDIAG_SHOW_VFS>"
msgstr "B<UDIAG_SHOW_VFS>"

#. type: Plain text
#: build/C/man7/sock_diag.7:195
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_VFS>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:202
#, no-wrap
msgid ""
"struct unix_diag_vfs {\n"
"    __u32 udiag_vfs_dev;\n"
"    __u32 udiag_vfs_ino;\n"
"};\n"
msgstr ""
"struct unix_diag_vfs {\n"
"    __u32 udiag_vfs_dev;\n"
"    __u32 udiag_vfs_ino;\n"
"};\n"

#. type: TP
#: build/C/man7/sock_diag.7:207
#, no-wrap
msgid "I<udiag_vfs_dev>"
msgstr "I<udiag_vfs_dev>"

#. type: Plain text
#: build/C/man7/sock_diag.7:210
msgid "The device number of the corresponding on-disk socket inode."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:210
#, no-wrap
msgid "I<udiag_vfs_ino>"
msgstr "I<udiag_vfs_ino>"

#. type: Plain text
#: build/C/man7/sock_diag.7:213
msgid "The inode number of the corresponding on-disk socket inode."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:214
#, no-wrap
msgid "B<UDIAG_SHOW_PEER>"
msgstr "B<UDIAG_SHOW_PEER>"

#. type: Plain text
#: build/C/man7/sock_diag.7:221
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_PEER>.  The "
"payload associated with this attribute is a __u32 value which is the peer's "
"inode number.  This attribute is reported for connected sockets only."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:221
#, no-wrap
msgid "B<UDIAG_SHOW_ICONS>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:232
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_ICONS>.  The "
"payload associated with this attribute is an array of __u32 values which are "
"inode numbers of sockets that has passed the B<connect>(2)  call, but hasn't "
"been processed with B<accept>(2)  yet.  This attribute is reported for "
"listening sockets only."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:232
#, no-wrap
msgid "B<UDIAG_SHOW_RQLEN>"
msgstr "B<UDIAG_SHOW_RQLEN>"

#. type: Plain text
#: build/C/man7/sock_diag.7:238
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_RQLEN>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:245
#, no-wrap
msgid ""
"struct unix_diag_rqlen {\n"
"    __u32 udiag_rqueue;\n"
"    __u32 udiag_wqueue;\n"
"};\n"
msgstr ""
"struct unix_diag_rqlen {\n"
"    __u32 udiag_rqueue;\n"
"    __u32 udiag_wqueue;\n"
"};\n"

#. type: TP
#: build/C/man7/sock_diag.7:250
#, no-wrap
msgid "I<udiag_rqueue>"
msgstr "I<udiag_rqueue>"

#. type: Plain text
#: build/C/man7/sock_diag.7:257
msgid ""
"For listening sockets: the number of pending connections.  The length of the "
"array associated with the B<UNIX_DIAG_ICONS> response attribute is equal to "
"this value."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:260
msgid "For established sockets: the amount of data in incoming queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:260
#, no-wrap
msgid "I<udiag_wqueue>"
msgstr "I<udiag_wqueue>"

#. type: Plain text
#: build/C/man7/sock_diag.7:265
msgid ""
"For listening sockets: the backlog length which equals to the value passed "
"as the second argument to B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:268
msgid "For established sockets: the amount of memory available for sending."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:269
#, no-wrap
msgid "B<UDIAG_SHOW_MEMINFO>"
msgstr "B<UDIAG_SHOW_MEMINFO>"

#. type: Plain text
#: build/C/man7/sock_diag.7:275
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_MEMINFO>.  "
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:277
msgid ""
"The following attributes are reported back without any specific request:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:277
#, no-wrap
msgid "B<UNIX_DIAG_SHUTDOWN>"
msgstr "B<UNIX_DIAG_SHUTDOWN>"

#. type: Plain text
#: build/C/man7/sock_diag.7:283
msgid ""
"The payload associated with this attribute is __u8 value which represents "
"bits of B<shutdown>(2)  state."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:284 build/C/man7/sock_diag.7:333
#, no-wrap
msgid "I<udiag_cookie>"
msgstr "I<udiag_cookie>"

#. type: Plain text
#: build/C/man7/sock_diag.7:291
msgid ""
"This is an array of opaque identifiers that could be used along with "
"I<udiag_ino> to specify an individual socket.  It is ignored when querying "
"for a list of sockets, as well as when all its elements are set to -1."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:293
msgid ""
"The response to a query for UNIX domain sockets is represented as an array of"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:304
#, no-wrap
msgid ""
"struct unix_diag_msg {\n"
"    __u8    udiag_family;\n"
"    __u8    udiag_type;\n"
"    __u8    udiag_state;\n"
"    __u8    pad;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""
"struct unix_diag_msg {\n"
"    __u8    udiag_family;\n"
"    __u8    udiag_type;\n"
"    __u8    udiag_state;\n"
"    __u8    pad;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:308 build/C/man7/sock_diag.7:517
msgid "followed by netlink attributes."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:310
#, no-wrap
msgid "I<udiag_family>"
msgstr "I<udiag_family>"

#. type: Plain text
#: build/C/man7/sock_diag.7:314
msgid "This field has the same meaning as in I<struct unix_diag_req>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:314
#, no-wrap
msgid "I<udiag_type>"
msgstr "I<udiag_type>"

#. type: Plain text
#: build/C/man7/sock_diag.7:321
msgid ""
"This is set to one of B<SOCK_PACKET>, B<SOCK_STREAM>, or B<SOCK_SEQPACKET>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:321
#, no-wrap
msgid "I<udiag_state>"
msgstr "I<udiag_state>"

#. type: Plain text
#: build/C/man7/sock_diag.7:327
msgid "This is set to one of B<TCP_LISTEN> or B<TCP_ESTABLISHED>."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:330
msgid "This field is set to 0."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:333 build/C/man7/sock_diag.7:588
msgid "This is the socket inode number."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:338
msgid ""
"This is an array of opaque identifiers that could be used in subsequent "
"queries."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:338
#, no-wrap
msgid "IPv4 and IPv6 sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:341
msgid ""
"For IPv4 and IPv6 sockets, the request is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:352
#, no-wrap
msgid ""
"struct inet_diag_req_v2 {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u8    idiag_ext;\n"
"    __u8    pad;\n"
"    __u32   idiag_states;\n"
"    struct inet_diag_sockid id;\n"
"};\n"
msgstr ""
"struct inet_diag_req_v2 {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u8    idiag_ext;\n"
"    __u8    pad;\n"
"    __u32   idiag_states;\n"
"    struct inet_diag_sockid id;\n"
"};\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:358
msgid "where I<struct inet_diag_sockid> is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:369
#, no-wrap
msgid ""
"struct inet_diag_sockid {\n"
"    __be16  idiag_sport;\n"
"    __be16  idiag_dport;\n"
"    __be32  idiag_src[4];\n"
"    __be32  idiag_dst[4];\n"
"    __u32   idiag_if;\n"
"    __u32   idiag_cookie[2];\n"
"};\n"
msgstr ""
"struct inet_diag_sockid {\n"
"    __be16  idiag_sport;\n"
"    __be16  idiag_dport;\n"
"    __be32  idiag_src[4];\n"
"    __be32  idiag_dst[4];\n"
"    __u32   idiag_if;\n"
"    __u32   idiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:375
msgid "The fields of I<struct inet_diag_req_v2> are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:382
msgid ""
"This should be set to either B<AF_INET> or B<AF_INET6> for IPv4 or IPv6 "
"sockets respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:389
msgid ""
"This should be set to one of B<IPPROTO_TCP>, B<IPPROTO_UDP>, or "
"B<IPPROTO_UDPLITE>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:389
#, no-wrap
msgid "I<idiag_ext>"
msgstr "I<idiag_ext>"

#. type: Plain text
#: build/C/man7/sock_diag.7:394
msgid ""
"This is a set of flags defining what kind of extended information to "
"report.  Each requested kind of information is reported back as a netlink "
"attribute as described below:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:395
#, no-wrap
msgid "B<INET_DIAG_TOS>"
msgstr "B<INET_DIAG_TOS>"

#. type: Plain text
#: build/C/man7/sock_diag.7:399
msgid ""
"The payload associated with this attribute is a __u8 value which is the TOS "
"of the socket."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:399
#, no-wrap
msgid "B<INET_DIAG_TCLASS>"
msgstr "B<INET_DIAG_TCLASS>"

#. type: Plain text
#: build/C/man7/sock_diag.7:408
msgid ""
"The payload associated with this attribute is a __u8 value which is the "
"TClass of the socket.  IPv6 sockets only.  For LISTEN and CLOSE sockets, "
"this is followed by B<INET_DIAG_SKV6ONLY> attribute with associated __u8 "
"payload value meaning whether the socket is IPv6-only or not."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:408
#, no-wrap
msgid "B<INET_DIAG_MEMINFO>"
msgstr "B<INET_DIAG_MEMINFO>"

#. type: Plain text
#: build/C/man7/sock_diag.7:412
msgid ""
"The payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:421
#, no-wrap
msgid ""
"struct inet_diag_meminfo {\n"
"    __u32 idiag_rmem;\n"
"    __u32 idiag_wmem;\n"
"    __u32 idiag_fmem;\n"
"    __u32 idiag_tmem;\n"
"};\n"
msgstr ""
"struct inet_diag_meminfo {\n"
"    __u32 idiag_rmem;\n"
"    __u32 idiag_wmem;\n"
"    __u32 idiag_fmem;\n"
"    __u32 idiag_tmem;\n"
"};\n"

#. type: TP
#: build/C/man7/sock_diag.7:426
#, no-wrap
msgid "I<idiag_rmem>"
msgstr "I<idiag_rmem>"

#. type: Plain text
#: build/C/man7/sock_diag.7:429
msgid "The amount of data in the receive queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:429
#, no-wrap
msgid "I<idiag_wmem>"
msgstr "I<idiag_wmem>"

#. type: Plain text
#: build/C/man7/sock_diag.7:432
msgid "The amount of data that is queued by TCP but not yet sent."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:432
#, no-wrap
msgid "I<idiag_fmem>"
msgstr "I<idiag_fmem>"

#. type: Plain text
#: build/C/man7/sock_diag.7:435 build/C/man7/sock_diag.7:611
msgid "The amount of memory scheduled for future use (TCP only)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:435
#, no-wrap
msgid "I<idiag_tmem>"
msgstr "I<idiag_tmem>"

#. type: Plain text
#: build/C/man7/sock_diag.7:438 build/C/man7/sock_diag.7:604
msgid "The amount of data in send queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:439
#, no-wrap
msgid "B<INET_DIAG_SKMEMINFO>"
msgstr "B<INET_DIAG_SKMEMINFO>"

#. type: Plain text
#: build/C/man7/sock_diag.7:443
msgid ""
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:443
#, no-wrap
msgid "B<INET_DIAG_INFO>"
msgstr "B<INET_DIAG_INFO>"

#. type: Plain text
#: build/C/man7/sock_diag.7:448
msgid ""
"The payload associated with this attribute is specific to the address "
"family.  For TCP sockets, it is an object of type I<struct tcp_info>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:448
#, no-wrap
msgid "B<INET_DIAG_CONG>"
msgstr "B<INET_DIAG_CONG>"

#. type: Plain text
#: build/C/man7/sock_diag.7:453
msgid ""
"The payload associated with this attribute is a string that describes the "
"congestion control algorithm used.  For TCP sockets only."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:457
msgid "This should be set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:457
#, no-wrap
msgid "I<idiag_states>"
msgstr "I<idiag_states>"

#. type: Plain text
#: build/C/man7/sock_diag.7:462
msgid ""
"This is a bit mask that defines a filter of socket states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:462
#, no-wrap
msgid "I<id>"
msgstr "I<id>"

#. type: Plain text
#: build/C/man7/sock_diag.7:469
msgid ""
"This is a socket ID object that is used in dump requests, in queries about "
"individual sockets, and is reported back in each response.  Unlike UNIX "
"domain sockets, IPv4 and IPv6 sockets are identified using addresses and "
"ports.  All values are in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:473
msgid "The fields of I<struct inet_diag_sockid> are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:473
#, no-wrap
msgid "I<idiag_sport>"
msgstr "I<idiag_sport>"

#. type: Plain text
#: build/C/man7/sock_diag.7:476
msgid "The source port."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:476
#, no-wrap
msgid "I<idiag_dport>"
msgstr "I<idiag_dport>"

#. type: Plain text
#: build/C/man7/sock_diag.7:479
msgid "The destination port."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:479
#, no-wrap
msgid "I<idiag_src>"
msgstr "I<idiag_src>"

#. type: Plain text
#: build/C/man7/sock_diag.7:482
msgid "The source address."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:482
#, no-wrap
msgid "I<idiag_dst>"
msgstr "I<idiag_dst>"

#. type: Plain text
#: build/C/man7/sock_diag.7:485
msgid "The destination address."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:485
#, no-wrap
msgid "I<idiag_if>"
msgstr "I<idiag_if>"

#. type: Plain text
#: build/C/man7/sock_diag.7:488
msgid "The interface number the socket is bound to."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:488
#, no-wrap
msgid "I<idiag_cookie>"
msgstr "I<idiag_cookie>"

#. type: Plain text
#: build/C/man7/sock_diag.7:494
msgid ""
"This is an array of opaque identifiers that could be used along with other "
"fields of this structure to specify an individual socket.  It is ignored "
"when querying for a list of sockets, as well as when all its elements are "
"set to -1."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:496
msgid ""
"The response to a query for IPv4 or IPv6 sockets is represented as an array "
"of"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:504
#, no-wrap
msgid ""
"struct inet_diag_msg {\n"
"    __u8    idiag_family;\n"
"    __u8    idiag_state;\n"
"    __u8    idiag_timer;\n"
"    __u8    idiag_retrans;\n"
msgstr ""
"struct inet_diag_msg {\n"
"    __u8    idiag_family;\n"
"    __u8    idiag_state;\n"
"    __u8    idiag_timer;\n"
"    __u8    idiag_retrans;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:506
#, no-wrap
msgid "    struct inet_diag_sockid id;\n"
msgstr "    struct inet_diag_sockid id;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:513
#, no-wrap
msgid ""
"    __u32   idiag_expires;\n"
"    __u32   idiag_rqueue;\n"
"    __u32   idiag_wqueue;\n"
"    __u32   idiag_uid;\n"
"    __u32   idiag_inode;\n"
"};\n"
msgstr ""
"    __u32   idiag_expires;\n"
"    __u32   idiag_rqueue;\n"
"    __u32   idiag_wqueue;\n"
"    __u32   idiag_uid;\n"
"    __u32   idiag_inode;\n"
"};\n"

#. type: TP
#: build/C/man7/sock_diag.7:519
#, no-wrap
msgid "I<idiag_family>"
msgstr "I<idiag_family>"

#. type: Plain text
#: build/C/man7/sock_diag.7:523
msgid "This is the same field as in I<struct inet_diag_req_v2>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:523
#, no-wrap
msgid "I<idiag_state>"
msgstr "I<idiag_state>"

#. type: Plain text
#: build/C/man7/sock_diag.7:527
msgid "This denotes socket state as in I<struct inet_diag_req_v2>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:527
#, no-wrap
msgid "I<idiag_timer>"
msgstr "I<idiag_timer>"

#. type: Plain text
#: build/C/man7/sock_diag.7:532
msgid ""
"For TCP sockets, this field describes the type of timer that is currently "
"active for the socket.  It is set to one of the following constants:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:535
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man7/sock_diag.7:538
msgid "no timer is active"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:538
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: build/C/man7/sock_diag.7:541
msgid "a retransmit timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:541
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: build/C/man7/sock_diag.7:544
msgid "a keep-alive timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:544
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man7/sock_diag.7:547
msgid "a TIME_WAIT timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:547
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: build/C/man7/sock_diag.7:550
msgid "a zero window probe timer"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:554
msgid "For non-TCP sockets, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:554
#, no-wrap
msgid "I<idiag_retrans>"
msgstr "I<idiag_retrans>"

#. type: Plain text
#: build/C/man7/sock_diag.7:562
msgid ""
"For I<idiag_timer> values 1, 2, and 4, this field contains the number of "
"retransmits.  For other I<idiag_timer> values, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:562
#, no-wrap
msgid "I<idiag_expires>"
msgstr "I<idiag_expires>"

#. type: Plain text
#: build/C/man7/sock_diag.7:567
msgid ""
"For TCP sockets that have an active timer, this field describes its "
"expiration time in milliseconds.  For other sockets, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:567
#, no-wrap
msgid "I<idiag_rqueue>"
msgstr "I<idiag_rqueue>"

#. type: Plain text
#: build/C/man7/sock_diag.7:571
msgid "For listening sockets: the number of pending connections."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:574
msgid "For other sockets: the amount of data in the incoming queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:574
#, no-wrap
msgid "I<idiag_wqueue>"
msgstr "I<idiag_wqueue>"

#. type: Plain text
#: build/C/man7/sock_diag.7:578
msgid "For listening sockets: the backlog length."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:581
msgid "For other sockets: the amount of memory available for sending."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:581
#, no-wrap
msgid "I<idiag_uid>"
msgstr "I<idiag_uid>"

#. type: Plain text
#: build/C/man7/sock_diag.7:584
msgid "This is the socket owner UID."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:584
#, no-wrap
msgid "I<idiag_inode>"
msgstr "I<idiag_inode>"

#. type: SS
#: build/C/man7/sock_diag.7:588
#, no-wrap
msgid "Socket memory information"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:594
msgid ""
"The payload associated with B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> "
"netlink attributes is an array of the following __u32 values:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:594
#, no-wrap
msgid "B<SK_MEMINFO_RMEM_ALLOC>"
msgstr "B<SK_MEMINFO_RMEM_ALLOC>"

#. type: Plain text
#: build/C/man7/sock_diag.7:597
msgid "The amount of data in receive queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:597
#, no-wrap
msgid "B<SK_MEMINFO_RCVBUF>"
msgstr "B<SK_MEMINFO_RCVBUF>"

#. type: Plain text
#: build/C/man7/sock_diag.7:601
msgid "The receive socket buffer as set by B<SO_RCVBUF>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:601
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_ALLOC>"
msgstr "B<SK_MEMINFO_WMEM_ALLOC>"

#. type: TP
#: build/C/man7/sock_diag.7:604
#, no-wrap
msgid "B<SK_MEMINFO_SNDBUF>"
msgstr "B<SK_MEMINFO_SNDBUF>"

#. type: Plain text
#: build/C/man7/sock_diag.7:608
msgid "The send socket buffer as set by B<SO_SNDBUF>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:608
#, no-wrap
msgid "B<SK_MEMINFO_FWD_ALLOC>"
msgstr "B<SK_MEMINFO_FWD_ALLOC>"

#. type: TP
#: build/C/man7/sock_diag.7:611
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_QUEUED>"
msgstr "B<SK_MEMINFO_WMEM_QUEUED>"

#. type: Plain text
#: build/C/man7/sock_diag.7:614
msgid "The amount of data queued by TCP, but not yet sent."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:614
#, no-wrap
msgid "B<SK_MEMINFO_OPTMEM>"
msgstr "B<SK_MEMINFO_OPTMEM>"

#. type: Plain text
#: build/C/man7/sock_diag.7:618
msgid ""
"The amount of memory allocated for the socket's service needs (e.g., socket "
"filter)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:618
#, no-wrap
msgid "B<SK_MEMINFO_BACKLOG>"
msgstr "B<SK_MEMINFO_BACKLOG>"

#. type: Plain text
#: build/C/man7/sock_diag.7:621
#, fuzzy
#| msgid "Maximum number of packets in the global input queue."
msgid "The amount of packets in the backlog (not yet processed)."
msgstr "グローバルな入力キューにおける最大のパケット数。"

#. type: Plain text
#: build/C/man7/sock_diag.7:633
msgid ""
"B<NETLINK_INET_DIAG> was introduced in Linux 2.6.14 and supported B<AF_INET> "
"and B<AF_INET6> sockets only.  In Linux 3.3, it was renamed to "
"B<NETLINK_SOCK_DIAG> and extended to support B<AF_UNIX> sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:638
msgid ""
"B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> were introduced in Linux 3.6."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:640
msgid "The NETLINK_SOCK_DIAG API is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:643
msgid ""
"The following example program prints inode number, peer's inode number, and "
"name of all UNIX domain sockets in the current namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:655
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>linux/netlink.hE<gt>\n"
"#include E<lt>linux/rtnetlink.hE<gt>\n"
"#include E<lt>linux/sock_diag.hE<gt>\n"
"#include E<lt>linux/unix_diag.hE<gt>\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>linux/netlink.hE<gt>\n"
"#include E<lt>linux/rtnetlink.hE<gt>\n"
"#include E<lt>linux/sock_diag.hE<gt>\n"
"#include E<lt>linux/unix_diag.hE<gt>\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:688
#, no-wrap
msgid ""
"static int\n"
"send_query(int fd)\n"
"{\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct\n"
"    {\n"
"        struct nlmsghdr nlh;\n"
"        struct unix_diag_req udr;\n"
"    } req = {\n"
"        .nlh = {\n"
"            .nlmsg_len = sizeof(req),\n"
"            .nlmsg_type = SOCK_DIAG_BY_FAMILY,\n"
"            .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP\n"
"        },\n"
"        .udr = {\n"
"            .sdiag_family = AF_UNIX,\n"
"            .udiag_states = -1,\n"
"            .udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER\n"
"        }\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = &req,\n"
"        .iov_len = sizeof(req)\n"
"    };\n"
"    struct msghdr msg = {\n"
"        .msg_name = &nladdr,\n"
"        .msg_namelen = sizeof(nladdr),\n"
"        .msg_iov = &iov,\n"
"        .msg_iovlen = 1\n"
"    };\n"
msgstr ""
"static int\n"
"send_query(int fd)\n"
"{\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct\n"
"    {\n"
"        struct nlmsghdr nlh;\n"
"        struct unix_diag_req udr;\n"
"    } req = {\n"
"        .nlh = {\n"
"            .nlmsg_len = sizeof(req),\n"
"            .nlmsg_type = SOCK_DIAG_BY_FAMILY,\n"
"            .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP\n"
"        },\n"
"        .udr = {\n"
"            .sdiag_family = AF_UNIX,\n"
"            .udiag_states = -1,\n"
"            .udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER\n"
"        }\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = &req,\n"
"        .iov_len = sizeof(req)\n"
"    };\n"
"    struct msghdr msg = {\n"
"        .msg_name = &nladdr,\n"
"        .msg_namelen = sizeof(nladdr),\n"
"        .msg_iov = &iov,\n"
"        .msg_iovlen = 1\n"
"    };\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:693
#, no-wrap
msgid ""
"    for (;;) {\n"
"        if (sendmsg(fd, &msg, 0) E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""
"    for (;;) {\n"
"        if (sendmsg(fd, &msg, 0) E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:697
#, no-wrap
msgid ""
"            perror(\"sendmsg\");\n"
"            return -1;\n"
"        }\n"
msgstr ""
"            perror(\"sendmsg\");\n"
"            return -1;\n"
"        }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:701
#, no-wrap
msgid ""
"        return 0;\n"
"    }\n"
"}\n"
msgstr ""
"        return 0;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:713
#, no-wrap
msgid ""
"static int\n"
"print_diag(const struct unix_diag_msg *diag, unsigned int len)\n"
"{\n"
"    if (len E<lt> NLMSG_LENGTH(sizeof(*diag))) {\n"
"        fputs(\"short response\\en\", stderr);\n"
"        return -1;\n"
"    }\n"
"    if (diag-E<gt>udiag_family != AF_UNIX) {\n"
"        fprintf(stderr, \"unexpected family %u\\en\", diag-E<gt>udiag_family);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"static int\n"
"print_diag(const struct unix_diag_msg *diag, unsigned int len)\n"
"{\n"
"    if (len E<lt> NLMSG_LENGTH(sizeof(*diag))) {\n"
"        fputs(\"short response\\en\", stderr);\n"
"        return -1;\n"
"    }\n"
"    if (diag-E<gt>udiag_family != AF_UNIX) {\n"
"        fprintf(stderr, \"unexpected family %u\\en\", diag-E<gt>udiag_family);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:718
#, no-wrap
msgid ""
"    unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));\n"
"    unsigned int peer = 0;\n"
"    size_t path_len = 0;\n"
"    char path[sizeof(((struct sockaddr_un *) 0)-E<gt>sun_path) + 1];\n"
msgstr ""
"    unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));\n"
"    unsigned int peer = 0;\n"
"    size_t path_len = 0;\n"
"    char path[sizeof(((struct sockaddr_un *) 0)-E<gt>sun_path) + 1];\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:731
#, no-wrap
msgid ""
"    for (struct rtattr *attr = (struct rtattr *) (diag + 1);\n"
"             RTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n"
"        switch (attr-E<gt>rta_type) {\n"
"        case UNIX_DIAG_NAME:\n"
"            if (!path_len) {\n"
"                path_len = RTA_PAYLOAD(attr);\n"
"                if (path_len E<gt> sizeof(path) - 1)\n"
"                    path_len = sizeof(path) - 1;\n"
"                memcpy(path, RTA_DATA(attr), path_len);\n"
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"            }\n"
"            break;\n"
msgstr ""
"    for (struct rtattr *attr = (struct rtattr *) (diag + 1);\n"
"             RTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n"
"        switch (attr-E<gt>rta_type) {\n"
"        case UNIX_DIAG_NAME:\n"
"            if (!path_len) {\n"
"                path_len = RTA_PAYLOAD(attr);\n"
"                if (path_len E<gt> sizeof(path) - 1)\n"
"                    path_len = sizeof(path) - 1;\n"
"                memcpy(path, RTA_DATA(attr), path_len);\n"
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"            }\n"
"            break;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:738
#, no-wrap
msgid ""
"        case UNIX_DIAG_PEER:\n"
"            if (RTA_PAYLOAD(attr) E<gt>= sizeof(peer))\n"
"                peer = *(unsigned int *) RTA_DATA(attr);\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"        case UNIX_DIAG_PEER:\n"
"            if (RTA_PAYLOAD(attr) E<gt>= sizeof(peer))\n"
"                peer = *(unsigned int *) RTA_DATA(attr);\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:740
#, no-wrap
msgid "    printf(\"inode=%u\", diag-E<gt>udiag_ino);\n"
msgstr "    printf(\"inode=%u\", diag-E<gt>udiag_ino);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:743
#, no-wrap
msgid ""
"    if (peer)\n"
"        printf(\", peer=%u\", peer);\n"
msgstr ""
"    if (peer)\n"
"        printf(\", peer=%u\", peer);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:747
#, no-wrap
msgid ""
"    if (path_len)\n"
"        printf(\", name=%s%s\", *path ? \"\" : \"@\",\n"
"                *path ? path : path + 1);\n"
msgstr ""
"    if (path_len)\n"
"        printf(\", name=%s%s\", *path ? \"\" : \"@\",\n"
"                *path ? path : path + 1);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:751
#, no-wrap
msgid ""
"    putchar(\\(aq\\en\\(aq);\n"
"    return 0;\n"
"}\n"
msgstr ""
"    putchar(\\(aq\\en\\(aq);\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:764
#, no-wrap
msgid ""
"static int\n"
"receive_responses(int fd)\n"
"{\n"
"    long buf[8192 / sizeof(long)];\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = buf,\n"
"        .iov_len = sizeof(buf)\n"
"    };\n"
"    int flags = 0;\n"
msgstr ""
"static int\n"
"receive_responses(int fd)\n"
"{\n"
"    long buf[8192 / sizeof(long)];\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = buf,\n"
"        .iov_len = sizeof(buf)\n"
"    };\n"
"    int flags = 0;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:772
#, no-wrap
msgid ""
"    for (;;) {\n"
"        struct msghdr msg = {\n"
"            .msg_name = &nladdr,\n"
"            .msg_namelen = sizeof(nladdr),\n"
"            .msg_iov = &iov,\n"
"            .msg_iovlen = 1\n"
"        };\n"
msgstr ""
"    for (;;) {\n"
"        struct msghdr msg = {\n"
"            .msg_name = &nladdr,\n"
"            .msg_namelen = sizeof(nladdr),\n"
"            .msg_iov = &iov,\n"
"            .msg_iovlen = 1\n"
"        };\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:774
#, no-wrap
msgid "        ssize_t ret = recvmsg(fd, &msg, flags);\n"
msgstr "        ssize_t ret = recvmsg(fd, &msg, flags);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:778
#, no-wrap
msgid ""
"        if (ret E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""
"        if (ret E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:784
#, no-wrap
msgid ""
"            perror(\"recvmsg\");\n"
"            return -1;\n"
"        }\n"
"        if (ret == 0)\n"
"            return 0;\n"
msgstr ""
"            perror(\"recvmsg\");\n"
"            return -1;\n"
"        }\n"
"        if (ret == 0)\n"
"            return 0;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:786
#, no-wrap
msgid "        const struct nlmsghdr *h = (struct nlmsghdr *) buf;\n"
msgstr "        const struct nlmsghdr *h = (struct nlmsghdr *) buf;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:791
#, no-wrap
msgid ""
"        if (!NLMSG_OK(h, ret)) {\n"
"            fputs(\"!NLMSG_OK\\en\", stderr);\n"
"            return -1;\n"
"        }\n"
msgstr ""
"        if (!NLMSG_OK(h, ret)) {\n"
"            fputs(\"!NLMSG_OK\\en\", stderr);\n"
"            return -1;\n"
"        }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:795
#, no-wrap
msgid ""
"        for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {\n"
"            if (h-E<gt>nlmsg_type == NLMSG_DONE)\n"
"                return 0;\n"
msgstr ""
"        for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {\n"
"            if (h-E<gt>nlmsg_type == NLMSG_DONE)\n"
"                return 0;\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:798
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type == NLMSG_ERROR) {\n"
"                const struct nlmsgerr *err = NLMSG_DATA(h);\n"
msgstr ""
"            if (h-E<gt>nlmsg_type == NLMSG_ERROR) {\n"
"                const struct nlmsgerr *err = NLMSG_DATA(h);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:805
#, no-wrap
msgid ""
"                if (h-E<gt>nlmsg_len E<lt> NLMSG_LENGTH(sizeof(*err))) {\n"
"                    fputs(\"NLMSG_ERROR\\en\", stderr);\n"
"                } else {\n"
"                    errno = -err-E<gt>error;\n"
"                    perror(\"NLMSG_ERROR\");\n"
"                }\n"
msgstr ""
"                if (h-E<gt>nlmsg_len E<lt> NLMSG_LENGTH(sizeof(*err))) {\n"
"                    fputs(\"NLMSG_ERROR\\en\", stderr);\n"
"                } else {\n"
"                    errno = -err-E<gt>error;\n"
"                    perror(\"NLMSG_ERROR\");\n"
"                }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:808
#, no-wrap
msgid ""
"                return -1;\n"
"            }\n"
msgstr ""
"                return -1;\n"
"            }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:814
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n"
"                fprintf(stderr, \"unexpected nlmsg_type %u\\en\",\n"
"                        (unsigned) h-E<gt>nlmsg_type);\n"
"                return -1;\n"
"            }\n"
msgstr ""
"            if (h-E<gt>nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n"
"                fprintf(stderr, \"unexpected nlmsg_type %u\\en\",\n"
"                        (unsigned) h-E<gt>nlmsg_type);\n"
"                return -1;\n"
"            }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:820
#, no-wrap
msgid ""
"            if (print_diag(NLMSG_DATA(h), h-E<gt>nlmsg_len))\n"
"                return -1;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            if (print_diag(NLMSG_DATA(h), h-E<gt>nlmsg_len))\n"
"                return -1;\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:825
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:830
#, no-wrap
msgid ""
"    if (fd E<lt> 0) {\n"
"        perror(\"socket\");\n"
"        return 1;\n"
"    }\n"
msgstr ""
"    if (fd E<lt> 0) {\n"
"        perror(\"socket\");\n"
"        return 1;\n"
"    }\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:832
#, no-wrap
msgid "    int ret = send_query(fd) || receive_responses(fd);\n"
msgstr "    int ret = send_query(fd) || receive_responses(fd);\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:836
#, no-wrap
msgid ""
"    close(fd);\n"
"    return ret;\n"
"}\n"
msgstr ""
"    close(fd);\n"
"    return ret;\n"
"}\n"

#. type: Plain text
#: build/C/man7/sock_diag.7:842
msgid "B<netlink>(3), B<rtnetlink>(3), B<netlink>(7), B<tcp>(7)"
msgstr "B<netlink>(3), B<rtnetlink>(3), B<netlink>(7), B<tcp>(7)"

#. type: TH
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "VSOCK"
msgstr "VSOCK"

#. type: TH
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "2020-02-09"
msgstr "2020-02-09"

#. type: Plain text
#: build/C/man7/vsock.7:28
msgid "vsock - Linux VSOCK address family"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:32
msgid "B<#include E<lt>linux/vm_sockets.hE<gt>>"
msgstr "B<#include E<lt>linux/vm_sockets.hE<gt>>"

#. type: Plain text
#: build/C/man7/vsock.7:34
msgid "I<stream_socket>B< = socket(AF_VSOCK, SOCK_STREAM, 0);>"
msgstr "I<stream_socket>B< = socket(AF_VSOCK, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/vsock.7:36
msgid "I<datagram_socket>B< = socket(AF_VSOCK, SOCK_DGRAM, 0);>"
msgstr "I<datagram_socket>B< = socket(AF_VSOCK, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/vsock.7:42
msgid ""
"The VSOCK address family facilitates communication between virtual machines "
"and the host they are running on.  This address family is used by guest "
"agents and hypervisor services that need a communications channel that is "
"independent of virtual machine network configuration."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:54
msgid ""
"Valid socket types are B<SOCK_STREAM> and B<SOCK_DGRAM>.  B<SOCK_STREAM> "
"provides connection-oriented byte streams with guaranteed, in-order "
"delivery.  B<SOCK_DGRAM> provides a connectionless datagram packet service "
"with best-effort delivery and best-effort ordering.  Availability of these "
"socket types is dependent on the underlying hypervisor."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:56
#, fuzzy
#| msgid "A socket is created with B<socket>(2)."
msgid "A new socket is created with"
msgstr "B<socket>(2)  でソケットを作成する。"

#. type: Plain text
#: build/C/man7/vsock.7:60
#, no-wrap
msgid "socket(AF_VSOCK, socket_type, 0);\n"
msgstr "socket(AF_VSOCK, socket_type, 0);\n"

#. type: Plain text
#: build/C/man7/vsock.7:67
msgid ""
"When a process wants to establish a connection, it calls B<connect>(2)  with "
"a given destination socket address.  The socket is automatically bound to a "
"free port if unbound."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:73
msgid ""
"A process can listen for incoming connections by first binding to a socket "
"address using B<bind>(2)  and then calling B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:83
msgid ""
"Data is transmitted using the B<send>(2)  or B<write>(2)  families of system "
"calls and data is received using the B<recv>(2)  or B<read>(2)  families of "
"system calls."
msgstr ""

#. type: SS
#: build/C/man7/vsock.7:83
#, no-wrap
msgid "Address format"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:90
msgid ""
"A socket address is defined as a combination of a 32-bit Context Identifier "
"(CID) and a 32-bit port number.  The CID identifies the source or "
"destination, which is either a virtual machine or the host.  The port number "
"differentiates between multiple services running on a single machine."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:104
#, no-wrap
msgid ""
"struct sockaddr_vm {\n"
"    sa_family_t    svm_family;     /* Address family: AF_VSOCK */\n"
"    unsigned short svm_reserved1;\n"
"    unsigned int   svm_port;       /* Port # in host byte order */\n"
"    unsigned int   svm_cid;        /* Address in host byte order */\n"
"    unsigned char  svm_zero[sizeof(struct sockaddr) -\n"
"                            sizeof(sa_family_t) -\n"
"                            sizeof(unsigned short) -\n"
"                            sizeof(unsigned int) -\n"
"                            sizeof(unsigned int)];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:123
msgid ""
"I<svm_family> is always set to B<AF_VSOCK>.  I<svm_reserved1> is always set "
"to 0.  I<svm_port> contains the port number in host byte order.  The port "
"numbers below 1024 are called I<privileged ports>.  Only a process with the "
"B<CAP_NET_BIND_SERVICE> capability may B<bind>(2)  to these port numbers.  "
"I<svm_zero> must be zero-filled."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:135
msgid ""
"There are several special addresses: B<VMADDR_CID_ANY> (-1U)  means any "
"address for binding; B<VMADDR_CID_HYPERVISOR> (0) is reserved for services "
"built into the hypervisor; B<VMADDR_CID_LOCAL> (1) is the well-known address "
"for local communication (loopback); B<VMADDR_CID_HOST> (2)  is the well-"
"known address of the host."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:140
msgid ""
"The special constant B<VMADDR_PORT_ANY> (-1U)  means any port number for "
"binding."
msgstr ""

#. type: SS
#: build/C/man7/vsock.7:140
#, no-wrap
msgid "Live migration"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:146
msgid ""
"Sockets are affected by live migration of virtual machines.  Connected "
"B<SOCK_STREAM> sockets become disconnected when the virtual machine migrates "
"to a new host.  Applications must reconnect when this happens."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:150
msgid ""
"The local CID may change across live migration if the old CID is not "
"available on the new host.  Bound sockets are automatically updated to the "
"new CID."
msgstr ""

#. type: TP
#: build/C/man7/vsock.7:151
#, no-wrap
msgid "B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:156
msgid ""
"Get the CID of the local machine.  The argument is a pointer to an "
"I<unsigned int>."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:160
#, no-wrap
msgid "ioctl(socket, IOCTL_VM_SOCKETS_GET_LOCAL_CID, &cid);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:167
msgid ""
"Consider using B<VMADDR_CID_ANY> when binding instead of getting the local "
"CID with B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:172
msgid ""
"B<VMADDR_CID_LOCAL> (1) directs packets to the same host that generated "
"them.  This is useful for testing applications on a single host and for "
"debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:177
msgid ""
"The local CID obtained with B<IOCTL_VM_SOCKETS_GET_LOCAL_CID> can be used "
"for the same purpose, but it is preferable to use B<VMADDR_CID_LOCAL .>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:183
#, fuzzy
#| msgid ""
#| "The caller did not have superuser privilege (to be precise: the "
#| "B<CAP_NET_BIND_SERVICE> capability is required)."
msgid ""
"Unable to bind to a privileged port without the B<CAP_NET_BIND_SERVICE> "
"capability."
msgstr ""
"呼び出し元がスーパーユーザーの特権を持っていなかった (より正確に言うと、 "
"B<CAP_NET_BIND_SERVICE> ケーパビリティが必要である)。"

#. type: Plain text
#: build/C/man7/vsock.7:186
#, fuzzy
#| msgid "The given address is already in use."
msgid "Unable to bind to a port that is already in use."
msgstr "指定されたアドレスが既に使用中である。"

#. type: Plain text
#: build/C/man7/vsock.7:189
msgid ""
"Unable to find a free port for binding or unable to bind to a nonlocal CID."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:196
msgid ""
"Invalid parameters.  This includes: attempting to bind a socket that is "
"already bound, providing an invalid struct I<sockaddr_vm>, and other input "
"validation errors."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:202
msgid "Invalid socket option in B<setsockopt>(2)  or B<getsockopt>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:205
msgid "Unable to perform operation on an unconnected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:218
msgid ""
"Operation not supported.  This includes: the B<MSG_OOB> flag that is not "
"implemented for the B<send>(2)  family of syscalls and B<MSG_PEEK> for the "
"B<recv>(2)  family of syscalls."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:222
msgid "Invalid socket protocol number.  The protocol should always be 0."
msgstr ""

#. type: TP
#: build/C/man7/vsock.7:222
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: build/C/man7/vsock.7:231
msgid ""
"Unsupported socket type in B<socket>(2).  Only B<SOCK_STREAM> and "
"B<SOCK_DGRAM> are valid."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:235
msgid ""
"Support for VMware (VMCI) has been available since Linux 3.9.  KVM (virtio) "
"is supported since Linux 4.8.  Hyper-V is supported since Linux 4.14."
msgstr ""

#.  commit ef343b35d46667668a099655fca4a5b2e43a5dfe
#. type: Plain text
#: build/C/man7/vsock.7:241
msgid ""
"VMADDR_CID_LOCAL is supported since Linux 5.6.  Local communication in the "
"guest and on the host is available since Linux 5.6.  Previous versions "
"supported only local communication within a guest (not on the host), and "
"with only some transports (VMCI and virtio)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:249
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<recv>(2), B<send>(2), "
"B<socket>(2), B<capabilities>(7)"
msgstr "B<bind>(2), B<connect>(2), B<listen>(2), B<recv>(2), B<send>(2), B<socket>(2), B<capabilities>(7)"

#~ msgid "The descriptor is invalid."
#~ msgstr "ディスクリプターが不正。"

#~ msgid "The descriptor references a file, not a socket."
#~ msgstr "ディスクリプターはソケットではなくファイルを参照している。"

#~ msgid ""
#~ "The third argument of B<accept>()  was originally declared as an I<int *> "
#~ "(and is that under libc4 and libc5 and on many other systems like 4.x "
#~ "BSD, SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a "
#~ "I<size_t *>, and that is what it is for SunOS 5.  Later POSIX drafts have "
#~ "I<socklen_t *>, and so do the Single UNIX Specification and glibc2.  "
#~ "Quoting Linus Torvalds:"
#~ msgstr ""
#~ "B<accept>()  の第 3 引数は、もともと I<int *> と宣言されていた (libc4 "
#~ "や libc5, 4.x BSD, SunOS 4, SGI など多くのシステムではそうなっている)。 "
#~ "POSIX.1g draft 標準は、 これを I<size_t *> に変更しようとし、SunOS 5 では"
#~ "そう宣言されている。 後に POSIX drafts には I<socklen_t *> が含まれるよう"
#~ "になり、 Single UNIX Specification や glibc2 ではこのように宣言されるよう"
#~ "になった。 Linus Torvald の発言を引用する:"

#~ msgid ""
#~ "\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
#~ "Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
#~ "make it a size_t, and I (and hopefully others, but obviously not too "
#~ "many) complained to them very loudly indeed.  Making it a size_t is "
#~ "completely broken, exactly because size_t very seldom is the same size as "
#~ "\"int\" on 64-bit architectures, for example.  And it I<has> to be the "
#~ "same size as \"int\" because that's what the BSD socket interface is.  "
#~ "Anyway, the POSIX people eventually got a clue, and created \"socklen_t"
#~ "\".  They shouldn't have touched it in the first place, but once they did "
#~ "they felt it had to have a named type for some unfathomable reason "
#~ "(probably somebody didn't like losing face over having done the original "
#~ "stupid thing, so they silently just renamed their blunder).\""
#~ msgstr ""
#~ "「まともなライブラリを作りたければ、 \"socklen_t\" のサイズは int と同じに"
#~ "しなきゃならない。 さもないと BSD ソケット層を破壊することになっちゃう。 "
#~ "POSIX は最初こいつを size_t にしたんで、 ぼくは彼らに文句をがなりたてた "
#~ "(多分そういう人は他にもいたと思う。多くはなかったようだけど)。 こいつを "
#~ "size_t にするのは完全にいかれてる。 例えば 64 ビットアーキテクチャーで"
#~ "は、 size_t が \"int\" と同じサイズだなんてことはほとんどないからね。 この"
#~ "サイズは \"int\" と 同じでなきゃ『ダメ』なんだ。 BSD ソケットインター"
#~ "フェースっていうのはそういうものなんだから。 まあともかく POSIX の人たち"
#~ "も、 \"socklen_t\" を作るという解決策をなんとかひねり出した。 そもそも最初"
#~ "から放っておけば良かったんだが、 いじっちゃった以上、 名前付きの型を持たせ"
#~ "なきゃならない、と思ったみたいだね。 なんでかはわかんないけど (きっと最初"
#~ "にやっちまった馬鹿な間違いで顔をつぶしたくなかったから、 こっそり名前を付"
#~ "け替えて自分たちの大失敗をごまかそうとしたんだろう)。」"

#~ msgid "I<sockfd> is not a valid descriptor."
#~ msgstr "I<sockfd> が不正なディスクリプターである。"

#~ msgid "I<sockfd> is a descriptor for a file, not a socket."
#~ msgstr ""
#~ "I<sockfd> がファイルに対するディスクリプターで、ソケットに対するものではな"
#~ "い。"

#~ msgid "The file does not exist."
#~ msgstr "ファイルが存在しない。"

#~ msgid "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  first appeared in 4.2BSD)."
#~ msgstr ""
#~ "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  は 4.2BSD で最初に現われた)。"

#~ msgid ""
#~ "The third argument of B<bind>()  is in reality an I<int> (and this is "
#~ "what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
#~ "the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
#~ msgstr ""
#~ "B<bind>()  の三番目の引数は (4.x BSD や libc4, libc5 と同様に) 実際には "
#~ "I<int> である。glibc でも使われている現在の I<socklen_t> に関して、POSIX "
#~ "には少し混乱がある。 詳しくは B<accept>(2)  を参照のこと。"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid ""
#~ "Since glibc 2.17, the B<bindresvport>()  function uses a lock to protect "
#~ "the static variable, so it is thread-safe."
#~ msgstr ""
#~ "glibc 2.17 以降では、 B<bindresvport>() 関数は静的変数を保護するロックを"
#~ "使っており、スレッドセーフである。"

#~ msgid "2014-09-06"
#~ msgstr "2014-09-06"

#~ msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
#~ msgstr "B<#include E<lt>sys/types.hE<gt>>          /* 「注意」参照 */\n"

#~ msgid "Insufficient entries in the routing cache."
#~ msgstr "ルーティングキャッシュにエントリーが十分にない。"

#~ msgid "The file descriptor is not a valid index in the descriptor table."
#~ msgstr ""
#~ "ファイルディスクリプターがディスクリプターテーブルの 有効なインデックスで"
#~ "はない。"

#~ msgid ""
#~ "SVr4, 4.4BSD, (the B<connect>()  function first appeared in 4.2BSD), "
#~ "POSIX.1-2001."
#~ msgstr ""
#~ "SVr4, 4.4BSD, (B<connect>()  関数は 4.2BSD で最初に登場した), "
#~ "POSIX.1-2001."

#~ msgid ""
#~ "The third argument of B<connect>()  is in reality an I<int> (and this is "
#~ "what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
#~ "the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
#~ msgstr ""
#~ "B<connect>()  の三番目の引数は 4.x BSD や libc4, libc5 と同様に実際には "
#~ "I<int> である。 POSIX では紆余曲折を経て現在の I<socklen_t> になってお"
#~ "り、 glibc でも I<socklen_t> を使っている。 B<accept>(2)  も参照のこと。"

#~ msgid "2014-02-26"
#~ msgstr "2014-02-26"

#~ msgid "2008-12-03"
#~ msgstr "2008-12-03"

#~ msgid "The argument I<sockfd> is a file, not a socket."
#~ msgstr "引数 I<sockfd> がソケットではなくファイルである。"

#~ msgid ""
#~ "SVr4, 4.4BSD (the B<getsockname>()  function call appeared in 4.2BSD), "
#~ "POSIX.1-2001."
#~ msgstr ""
#~ "SVr4, 4.4BSD (B<getsockname>()  関数は 4.2BSD で追加された), POSIX.1-2001."

#~ msgid ""
#~ "The third argument of B<getsockname>()  is in reality an I<int\\ *> (and "
#~ "this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
#~ "resulted in the present I<socklen_t>, also used by glibc.  See also "
#~ "B<accept>(2)."
#~ msgstr ""
#~ "B<getsockname>()  の三番目の引数は (4.x BSD や libc4, libc5 と同様に) 実"
#~ "際には I<int\\ *> である。 glibc でも使われている現在の I<socklen_t> に関"
#~ "して、 POSIX には少し混乱がある。 詳しくは B<accept>(2)  を参照のこと。"

#~ msgid "2014-04-28"
#~ msgstr "2014-04-28"

#~ msgid ""
#~ "The I<optlen> argument of B<getsockopt>()  and B<setsockopt>()  is in "
#~ "reality an I<int [*]> (and this is what 4.x BSD and libc4 and libc5 "
#~ "have).  Some POSIX confusion resulted in the present I<socklen_t>, also "
#~ "used by glibc.  See also B<accept>(2)."
#~ msgstr ""
#~ "B<getsockopt>()  と B<setsockopt>()  の I<optlen> 引数は実際は I<int "
#~ "[*]> である (そして 4.x BSD と libc4 と libc5 はそうなっている)。 POSIX で"
#~ "は紆余曲折を経て現在の I<socklen_t> になっており、 glibc でも "
#~ "I<socklen_t> を使っている。 B<accept>(2)  も参照のこと。"

#~ msgid "RFC\\ 3493, POSIX.1-2001."
#~ msgstr "RFC\\ 3493, POSIX.1-2001."

#~ msgid "2014-05-10"
#~ msgstr "2014-05-10"

#~ msgid "The argument I<sockfd> is not a socket."
#~ msgstr "引数 I<sockfd> はソケットではない。"

#~ msgid ""
#~ "4.4BSD, POSIX.1-2001.  The B<listen>()  function call first appeared in "
#~ "4.2BSD."
#~ msgstr ""
#~ "4.4BSD, POSIX.1-2001.  B<listen>()  関数は 4.2BSDで初めて実装された。"

#~ msgid "B<#include E<lt>sys/types.hE<gt>>\n"
#~ msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#~ msgid ""
#~ "Enables nonblocking operation; if the operation would block, the call "
#~ "fails with the error B<EAGAIN> or B<EWOULDBLOCK> (this can also be "
#~ "enabled using the B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
#~ msgstr ""
#~ "非停止 (nonblocking) 操作を有効にする。 操作が停止するような場合にエラー "
#~ "B<EAGAIN> か B<EWOULDBLOCK> で呼び出しが失敗する (B<fcntl>(2)  の "
#~ "B<F_SETFL> で B<O_NONBLOCK> フラグを指定することによっても有効にできる)。"

#~ msgid ""
#~ "4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
#~ msgstr "4.4BSD (これらの関数は 4.2BSD で現われた), POSIX.1-2001。"

#~ msgid "2014-06-13"
#~ msgstr "2014-06-13"

#~ msgid "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
#~ msgstr "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"

#~ msgid "2015-01-22"
#~ msgstr "2015-01-22"

#~ msgid "/* According to POSIX.1-2001 */\n"
#~ msgstr "/* POSIX.1-2001 に従う場合 */\n"

#~ msgid "/* According to earlier standards */\n"
#~ msgstr "/* 以前の規格に従う場合 */\n"

#~ msgid "B<#include E<lt>sys/time.hE<gt>>\n"
#~ msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#~ msgid "B<#include E<lt>unistd.hE<gt>>\n"
#~ msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#~ msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
#~ msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#~ msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
#~ msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#~ msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
#~ msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#~ msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
#~ msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#~ msgid "(i)"
#~ msgstr "(i)"

#~ msgid "(ii)"
#~ msgstr "(ii)"

#~ msgid "(iii)"
#~ msgstr "(iii)"

#~ msgid ""
#~ "Three independent sets of file descriptors are watched.  Those listed in "
#~ "I<readfds> will be watched to see if characters become available for "
#~ "reading (more precisely, to see if a read will not block; in particular, "
#~ "a file descriptor is also ready on end-of-file), those in I<writefds> "
#~ "will be watched to see if space is available for write (though a large "
#~ "write may still block), and those in I<exceptfds> will be watched for "
#~ "exceptions.  On exit, the sets are modified in place to indicate which "
#~ "file descriptors actually changed status.  Each of the three file "
#~ "descriptor sets may be specified as NULL if no file descriptors are to be "
#~ "watched for the corresponding class of events."
#~ msgstr ""
#~ "3 つの独立したファイルディスクリプター集合の監視を行う。 I<readfds> に入れ"
#~ "られたディスクリプターについては、読み込みが可能かどうかを 監視する (より"
#~ "正確にいうと、停止 (block) なしで読むことができるかを 調べる。ファイルの終"
#~ "端 (end-of-file) の場合も、 ファイルディスクリプターは読み込み可能として扱"
#~ "われる)。 I<writefds> に入れられたディスクリプターについては、書き込み用に"
#~ "利用可能な領域があるかを監視する (ただし、大きな書き込みの場合には停止する"
#~ "可能性はある)。 I<exceptfds> にあるものについては、例外の監視を行なう。シ"
#~ "ステムコール終了時に、 どのファイルディスクリプターの状態が実際に変化した"
#~ "か示すために、 集合の内容が変更される。 ある種別のイベントを監視したいファ"
#~ "イルディスクリプターが一つもない場合には、 対応するファイルディスクリプ"
#~ "ター集合に NULL を指定することができる。"

#~ msgid ""
#~ "Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
#~ "set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given "
#~ "file descriptor from a set.  B<FD_ISSET>()  tests to see if a file "
#~ "descriptor is part of the set; this is useful after B<select>()  returns."
#~ msgstr ""
#~ "集合を操作するために 4 つのマクロが提供されている。 B<FD_ZERO>()  は集合を"
#~ "消去する。 B<FD_SET>()  と B<FD_CLR>()  はそれぞれ指定したファイルディスク"
#~ "リプターの集合への追加、削除を行う。 B<FD_ISSET>()  は集合にファイルディス"
#~ "クリプターがあるかどうか調べる; このマクロは B<select>()  が終了した後に使"
#~ "うと便利である。"

#~ msgid ""
#~ "I<nfds> is the highest-numbered file descriptor in any of the three sets, "
#~ "plus 1."
#~ msgstr ""
#~ "I<nfds> は 3 つの集合に含まれるファイルディスクリプターの最大値に 1 を足し"
#~ "たものである。"

#~ msgid ""
#~ "The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and "
#~ "look like"
#~ msgstr ""
#~ "これらの関数で使用される時間関連の構造体は、 I<E<lt>sys/time.hE<gt>> で"

#~ msgid ""
#~ "struct timeval {\n"
#~ "    long    tv_sec;         /* seconds */\n"
#~ "    long    tv_usec;        /* microseconds */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct timeval {\n"
#~ "    long    tv_sec;         /* 秒 */\n"
#~ "    long    tv_usec;        /* マイクロ秒 */\n"
#~ "};\n"

#~ msgid "and"
#~ msgstr "や"

#~ msgid "(However, see below on the POSIX.1-2001 versions.)"
#~ msgstr ""
#~ "のように定義されている。 (POSIX.1-2001 での定義については下記の「注意」を"
#~ "参照)"

#~ msgid ""
#~ "Concerning the types involved, the classical situation is that the two "
#~ "fields of a I<timeval> structure are typed as I<long> (as shown above), "
#~ "and the structure is defined in I<E<lt>sys/time.hE<gt>>.  The "
#~ "POSIX.1-2001 situation is"
#~ msgstr ""
#~ "型宣言に関しては、昔ながらの状況では I<timeval> 構造体の 2 つのフィールド"
#~ "は (上記のように) 両方とも I<long> 型であり、構造体は I<E<lt>sys/time."
#~ "hE<gt>> で定義されている。 POSIX.1-2001 の下では、以下のようになっている。"

#~ msgid ""
#~ "where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
#~ "types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types."
#~ "hE<gt>>."
#~ msgstr ""
#~ "この構造体は I<E<lt>sys/select.hE<gt>> で定義されており、データ型 "
#~ "I<time_t> と I<suseconds_t> は I<E<lt>sys/types.hE<gt>> で定義されている。"

#~ msgid ""
#~ "Concerning prototypes, the classical situation is that one should include "
#~ "I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that "
#~ "one should include I<E<lt>sys/select.hE<gt>> for B<select>()  and "
#~ "B<pselect>()."
#~ msgstr ""
#~ "プロトタイプに関しては、昔ながらの状況で B<select>()  を使いたい場合は、 "
#~ "I<E<lt>time.hE<gt>> をインクルードすればよい。 POSIX.1-2001 の環境で "
#~ "B<select>()  と B<pselect>()  を使いたい場合は、 I<E<lt>sys/select."
#~ "hE<gt>> をインクルードすればよい。"

#~ msgid ""
#~ "Under glibc 2.0, I<E<lt>sys/select.hE<gt>> gives the wrong prototype for "
#~ "B<pselect>().  Under glibc 2.1 to 2.2.1, it gives B<pselect>()  when "
#~ "B<_GNU_SOURCE> is defined.  Since glibc 2.2.2, the requirements are as "
#~ "shown in the SYNOPSIS."
#~ msgstr ""
#~ "glibc 2.0 では I<E<lt>sys/select.hE<gt>> が提供する B<pselect>()  のプロト"
#~ "タイプが間違っている。 glibc 2.1 から 2.2.1 では B<_GNU_SOURCE> が定義され"
#~ "ている場合に、 B<pselect>()  が提供される。 glibc 2.2.2 以降では、 "
#~ "B<pselect>()  を使用するには、「書式」に記載された要件を満たす必要がある。"

#~ msgid ""
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>sys/time.hE<gt>\n"
#~ "#include E<lt>sys/types.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"
#~ msgstr ""
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>sys/time.hE<gt>\n"
#~ "#include E<lt>sys/types.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"

#~ msgid "2013-12-30"
#~ msgstr "2013-12-30"

#~ msgid ""
#~ "B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
#~ "B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
#~ msgstr ""
#~ "B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
#~ "B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"

#~ msgid ""
#~ "B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
#~ "B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
#~ "B<            const sigset_t *>I<sigmask>B<);>\n"
#~ msgstr ""
#~ "B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
#~ "B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
#~ "B<            const sigset_t *>I<sigmask>B<);>\n"

#~ msgid ""
#~ "Its principal arguments are three \"sets\" of file descriptors: "
#~ "I<readfds>, I<writefds>, and I<exceptfds>.  Each set is declared as type "
#~ "I<fd_set>, and its contents can be manipulated with the macros "
#~ "B<FD_CLR>(), B<FD_ISSET>(), B<FD_SET>(), and B<FD_ZERO>().  A newly "
#~ "declared set should first be cleared using B<FD_ZERO>().  B<select>()  "
#~ "modifies the contents of the sets according to the rules described below; "
#~ "after calling B<select>()  you can test if a file descriptor is still "
#~ "present in a set with the B<FD_ISSET>()  macro.  B<FD_ISSET>()  returns "
#~ "nonzero if a specified file descriptor is present in a set and zero if it "
#~ "is not.  B<FD_CLR>()  removes a file descriptor from a set."
#~ msgstr ""
#~ "この関数の主要な引数は、3種類のファイルディスクリプターの「集合」 "
#~ "I<readfds>, I<writefds>, I<exceptfds> である。 各々の集合は B<fd_set> とし"
#~ "て宣言され、その内容は B<FD_CLR>(), B<FD_ISSET>(), B<FD_SET>(), "
#~ "B<FD_ZERO>()  といったマクロによって操作できる。 新しく宣言された集合は、"
#~ "まず最初に B<FD_ZERO>()  を使ってクリアすべきである。 B<select>()  はこれ"
#~ "らの集合の内容を、以降に述べる規則に従って修正する。 B<select>()  を呼んだ"
#~ "後、ファイルディスクリプターがまだ集合に存在しているかどうかは、 "
#~ "B<FD_ISSET>()  マクロによって調べることができる。 B<FD_ISSET>()  は指定さ"
#~ "れたディスクリプターが集合に存在していれば 0 以外の値を返し、 存在しなけれ"
#~ "ば 0 を返す。 B<FD_CLR>()  は集合からのファイルディスクリプターの削除を行"
#~ "う。"

#~ msgid ""
#~ "This set is watched for \"exceptional conditions\".  In practice, only "
#~ "one such exceptional condition is common: the availability of I<out-of-"
#~ "band> (OOB) data for reading from a TCP socket.  See B<recv>(2), "
#~ "B<send>(2), and B<tcp>(7)  for more details about OOB data.  (One other "
#~ "less common case where B<select>(2)  indicates an exceptional condition "
#~ "occurs with pseudoterminals in packet mode; see B<tty_ioctl>(4).)  After "
#~ "B<select>()  has returned, I<exceptfds> will be cleared of all file "
#~ "descriptors except for those for which an exceptional condition has "
#~ "occurred."
#~ msgstr ""
#~ "この集合に含まれるいずれかのファイルディスクリプターで、 「例外状態 "
#~ "(exceptional condition)」が発生したかどうかを監視する。 実際の動作では、普"
#~ "通に起こり得る例外状態は一つだけであり、 それは TCP ソケットで I<帯域外 "
#~ "(out-of-band; OOB)> データが 読み込み可能な場合である。 OOB データの詳細に"
#~ "ついては、 B<recv>(2), B<send>(2), B<tcp>(7)  を参照のこと。 (これ以外で"
#~ "は、まれなことだが、 パケットモードの擬似端末 (pseudoterminals) で "
#~ "B<select>()  が例外状態を示すことがある。)  B<select>()  が返る時に、"
#~ "I<exceptfds> のうち、 例外状態が発生したディスクリプター以外は集合から削除"
#~ "される。"

#~ msgid ""
#~ "This is an integer one more than the maximum of any file descriptor in "
#~ "any of the sets.  In other words, while adding file descriptors to each "
#~ "of the sets, you must calculate the maximum integer value of all of them, "
#~ "then increment this value by one, and then pass this as I<nfds>."
#~ msgstr ""
#~ "全ての集合に含まれるファイルディスクリプターのうち、 値が最大のものに 1 を"
#~ "足した整数である。 すなわち、ファイルディスクリプターを各集合に加える作業"
#~ "の途中で、 全てのファイルディスクリプターを見て最大値を求め、 それに 1 を"
#~ "加えて I<nfds> として渡さないといけない、ということだ。"

#~ msgid ""
#~ "This is the longest time B<select>()  may wait before returning, even if "
#~ "nothing interesting happened.  If this value is passed as NULL, then "
#~ "B<select>()  blocks indefinitely waiting for a file descriptor to become "
#~ "ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  "
#~ "to return immediately, with information about the readiness of file "
#~ "descriptors at the time of the call.  The structure I<struct timeval> is "
#~ "defined as:"
#~ msgstr ""
#~ "(何も起こらなかった場合に)  B<select>()  が戻る前に待つ最大時間である。 こ"
#~ "の値に NULL を渡すと、 B<select>()  はファイルディスクリプターのいずれか"
#~ "が ready (準備ができた) 状態に なるまで待ち続けてずっと停止する。 "
#~ "I<utimeout> は 0 秒にすることもでき、 この場合 B<select>()  は直ちに返り、"
#~ "呼び出し時点のファイルディスクリプターの状態に 関する情報が返される。 構造"
#~ "体 I<struct timeval> は次のように定義されている:"

#~ msgid ""
#~ "struct timeval {\n"
#~ "    time_t tv_sec;    /* seconds */\n"
#~ "    long tv_usec;     /* microseconds */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct timeval {\n"
#~ "    time_t tv_sec;    /* seconds */\n"
#~ "    long tv_usec;     /* microseconds */\n"
#~ "};\n"

#~ msgid "I<ntimeout>"
#~ msgstr "I<ntimeout>"

#~ msgid ""
#~ "This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
#~ "I<struct timespec> has nanosecond precision as follows:"
#~ msgstr ""
#~ "B<pselect>()  のこの引数は I<utimeout> と同じ意味を持つが、 I<struct "
#~ "timespec> は次に示すようにナノ秒の精度を持つ。"

#~ msgid ""
#~ "struct timespec {\n"
#~ "    long tv_sec;    /* seconds */\n"
#~ "    long tv_nsec;   /* nanoseconds */\n"
#~ "};\n"
#~ msgstr ""
#~ "struct timespec {\n"
#~ "    long tv_sec;    /* seconds */\n"
#~ "    long tv_nsec;   /* nanoseconds */\n"
#~ "};\n"

#~ msgid "I<sigmask>"
#~ msgstr "I<sigmask>"

#~ msgid ""
#~ "This argument holds a set of signals that the kernel should unblock (i."
#~ "e., remove from the signal mask of the calling thread), while the caller "
#~ "is blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
#~ "B<sigprocmask>(2)).  It may be NULL, in which case the call does not "
#~ "modify the signal mask on entry and exit to the function.  In this case, "
#~ "B<pselect>()  will then behave just like B<select>()."
#~ msgstr ""
#~ "この引数は、呼び出し側が B<pselect>()  内部で停止している間に、カーネル"
#~ "が通知を許可すべきシグナル集合 (すなわち、呼び出したスレッドのシグナルマス"
#~ "クから削除すべきシグナル集合)  を保持する (B<sigaddset>(3)  と "
#~ "B<sigprocmask>(2)  を参照)。 この引数は NULL にすることもでき、その場合"
#~ "はこの関数へ 入るとき・出るときにシグナルマスクを変更しない。 この場合、 "
#~ "B<pselect>()  は B<select>()  と全く同じ動作となる。"

#~ msgid "Usleep emulation"
#~ msgstr "usleep エミュレーション"

#~ msgid ""
#~ "On systems that do not have a B<usleep>(3)  function, you can call "
#~ "B<select>()  with a finite timeout and no file descriptors as follows:"
#~ msgstr ""
#~ "B<usleep>(3)  関数を持たないシステムでは、 有限のタイムアウトを指定し、"
#~ "ファイルディスクリプターを全くセットせずに B<select>()  を呼び出すことで、"
#~ "これを代用できる。 以下のようにする。"

#~ msgid ""
#~ "    struct timeval tv;\n"
#~ "    tv.tv_sec = 0;\n"
#~ "    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
#~ "    select(0, NULL, NULL, NULL, &tv);\n"
#~ msgstr ""
#~ "    struct timeval tv;\n"
#~ "    tv.tv_sec = 0;\n"
#~ "    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
#~ "    select(0, NULL, NULL, NULL, &tv);\n"

#~ msgid "This is guaranteed to work only on UNIX systems, however."
#~ msgstr "但し、これが動くと保証されているのは UNIX システムに限られる。"

#~ msgid ""
#~ "On success, B<select>()  returns the total number of file descriptors "
#~ "still present in the file descriptor sets."
#~ msgstr ""
#~ "成功すると、 B<select>()  はファイルディスクリプター集合に残っている ファ"
#~ "イルディスクリプターの総数を返す。"

#~ msgid ""
#~ "If B<select>()  timed out, then the return value will be zero.  The file "
#~ "descriptors set should be all empty (but may not be on some systems)."
#~ msgstr ""
#~ "B<select>()  がタイムアウトすると、返り値は 0 になる。 その時、ファイル"
#~ "ディスクリプター集合はすべて空である (しかしそうならないシステムもある)。"

#~ msgid ""
#~ "A return value of -1 indicates an error, with I<errno> being set "
#~ "appropriately.  In the case of an error, the contents of the returned "
#~ "sets and the I<struct timeout> contents are undefined and should not be "
#~ "used.  B<pselect>()  however never modifies I<ntimeout>."
#~ msgstr ""
#~ "返り値が -1 の場合はエラーを意味し、 I<errno> が適切にセットされる。エラー"
#~ "が起こった場合、 返された集合の内容や構造体 I<struct timeout> の内容は 未"
#~ "定義となっており、使用すべきではない。 しかし B<pselect>()  は決して "
#~ "I<ntimeout> を変更しない。"

#~ msgid ""
#~ "    s = socket(AF_INET, SOCK_STREAM, 0);\n"
#~ "    if (s == -1) {\n"
#~ "        perror(\"socket\");\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    yes = 1;\n"
#~ "    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
#~ "            &yes, sizeof(yes)) == -1) {\n"
#~ "        perror(\"setsockopt\");\n"
#~ "        close(s);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    memset(&a, 0, sizeof(a));\n"
#~ "    a.sin_port = htons(listen_port);\n"
#~ "    a.sin_family = AF_INET;\n"
#~ "    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
#~ "        perror(\"bind\");\n"
#~ "        close(s);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    printf(\"accepting connections on port %d\\en\", listen_port);\n"
#~ "    listen(s, 10);\n"
#~ "    return s;\n"
#~ "}\n"
#~ msgstr ""
#~ "    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
#~ "        perror(\"socket\");\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    yes = 1;\n"
#~ "    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
#~ "            &yes, sizeof(yes)) == -1) {\n"
#~ "        perror(\"setsockopt\");\n"
#~ "        close(s);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    memset(&a, 0, sizeof(a));\n"
#~ "    a.sin_port = htons(listen_port);\n"
#~ "    a.sin_family = AF_INET;\n"
#~ "    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
#~ "        perror(\"bind\");\n"
#~ "        close(s);\n"
#~ "        return -1;\n"
#~ "    }\n"
#~ "    printf(\"accepting connections on port %d\\en\", listen_port);\n"
#~ "    listen(s, 10);\n"
#~ "    return s;\n"
#~ "}\n"

#~ msgid ""
#~ "        FD_ZERO(&rd);\n"
#~ "        FD_ZERO(&wr);\n"
#~ "        FD_ZERO(&er);\n"
#~ "        FD_SET(h, &rd);\n"
#~ "        nfds = max(nfds, h);\n"
#~ "        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
#~ "            FD_SET(fd1, &rd);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
#~ "            FD_SET(fd2, &rd);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"
#~ "        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
#~ "            FD_SET(fd1, &wr);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
#~ "            FD_SET(fd2, &wr);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"
#~ "        if (fd1 E<gt> 0) {\n"
#~ "            FD_SET(fd1, &er);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0) {\n"
#~ "            FD_SET(fd2, &er);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"
#~ msgstr ""
#~ "        FD_ZERO(&rd);\n"
#~ "        FD_ZERO(&wr);\n"
#~ "        FD_ZERO(&er);\n"
#~ "        FD_SET(h, &rd);\n"
#~ "        nfds = max(nfds, h);\n"
#~ "        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
#~ "            FD_SET(fd1, &rd);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
#~ "            FD_SET(fd2, &rd);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"
#~ "        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
#~ "            FD_SET(fd1, &wr);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
#~ "            FD_SET(fd2, &wr);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"
#~ "        if (fd1 E<gt> 0) {\n"
#~ "            FD_SET(fd1, &er);\n"
#~ "            nfds = max(nfds, fd1);\n"
#~ "        }\n"
#~ "        if (fd2 E<gt> 0) {\n"
#~ "            FD_SET(fd2, &er);\n"
#~ "            nfds = max(nfds, fd2);\n"
#~ "        }\n"

#~ msgid ""
#~ "B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
#~ "B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
#~ "B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
#~ "B<sigismember>(3), B<epoll>(7)"
#~ msgstr ""
#~ "B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
#~ "B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
#~ "B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
#~ "B<sigismember>(3), B<epoll>(7)"

#~ msgid ""
#~ "Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
#~ "B<EWOULDBLOCK> is returned (this can also be enabled using the "
#~ "B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
#~ msgstr ""
#~ "非停止 (nonblocking) 操作を有効にする。操作が停止されるような場合には "
#~ "B<EAGAIN> か B<EWOULDBLOCK> を返すようにする (B<fcntl>(2)  の B<F_SETFL> "
#~ "で B<O_NONBLOCK> フラグを指定することによっても有効にできる)。"

#~ msgid ""
#~ "Requests not to send B<SIGPIPE> on errors on stream oriented sockets when "
#~ "the other end breaks the connection.  The B<EPIPE> error is still "
#~ "returned."
#~ msgstr ""
#~ "ストリーム指向のソケットで相手側が接続を切断した時に、エラーとして "
#~ "B<SIGPIPE> を送信しないように要求する。この場合でも B<EPIPE> は返される。"

#~ msgid "An invalid descriptor was specified."
#~ msgstr "無効なディスクリプターが指定された。"

#~ msgid "2014-07-08"
#~ msgstr "2014-07-08"

#~ msgid "2014-02-28"
#~ msgstr "2014-02-28"

#~ msgid "The B<sockatmark>()  function is thread-safe."
#~ msgstr "B<sockatmark>() 関数はスレッドセーフである。"

#~ msgid ""
#~ "B<socket>()  creates an endpoint for communication and returns a "
#~ "descriptor."
#~ msgstr ""
#~ "B<socket>() は通信のための端点 (endpoint) を作成し、 ディスクリプターを返"
#~ "す。"

#~ msgid "Access to raw ATM PVCs"
#~ msgstr "生の ATM PVC にアクセスする"

#~ msgid "Process file table overflow."
#~ msgstr "プロセスのファイルテーブルが溢れている。"

#~ msgid "4.4BSD, POSIX.1-2001."
#~ msgstr "4.4BSD, POSIX.1-2001."

#~ msgid ""
#~ "The B<AF_ALG> protocol type was added in Linux 2.6.38.  More information "
#~ "on this interface is provided in the kernel source file, I<Documentation/"
#~ "crypto/crypto-API-userspace.txt>."
#~ msgstr ""
#~ "B<AF_ALG> プロトコル種別は Linux 2.6.38 で追加された。 このインターフェー"
#~ "スの詳しい情報は、 カーネルのソースファイル I<Documentation/crypto/crypto-"
#~ "API-userspace.txt> に書かれている。"

#~ msgid ""
#~ "Return the credentials of the foreign process connected to this socket.  "
#~ "This is possible only for connected B<AF_UNIX> stream sockets and "
#~ "B<AF_UNIX> stream and datagram socket pairs created using "
#~ "B<socketpair>(2); see B<unix>(7).  The returned credentials are those "
#~ "that were in effect at the time of the call to B<connect>(2)  or "
#~ "B<socketpair>(2).  The argument is a I<ucred> structure; define the "
#~ "B<_GNU_SOURCE> feature test macro to obtain the definition of that "
#~ "structure from I<E<lt>sys/socket.hE<gt>>.  This socket option is read-"
#~ "only."
#~ msgstr ""
#~ "このソケットに接続してきた外部プロセスの信任状 (credential) を返す。このソ"
#~ "ケットオプションが利用できるのは、接続された B<AF_UNIX> ストリームソケット"
#~ "間、および B<socketpair>(2) を使って作成された B<AF_UNIX> のストリームソ"
#~ "ケットとデータグラムソケットのペアだけである。 B<unix>(7)  を参照のこと。 "
#~ "B<connect>(2) や B<socketpair>(2) が呼ばれた時に有効であった信任状が返され"
#~ "る。 引数は I<ucred> 構造体である。この構造体の定義を I<E<lt>sys/socket."
#~ "hE<gt>> を得るには、 機能検査マクロ B<_GNU_SOURCE> を定義すること。 このソ"
#~ "ケットオプションは読み込み専用である。"

#~ msgid ""
#~ "Set the process or process group to send B<SIGIO> or B<SIGURG> signals to "
#~ "when an asynchronous I/O operation has finished or urgent data is "
#~ "available.  The argument is a pointer to a I<pid_t>.  If the argument is "
#~ "positive, send the signals to that process.  If the argument is negative, "
#~ "send the signals to the process group with the ID of the absolute value "
#~ "of the argument.  The process may only choose itself or its own process "
#~ "group to receive signals unless it has the B<CAP_KILL> capability or an "
#~ "effective UID of 0."
#~ msgstr ""
#~ "非同期 I/O 操作の終了時や緊急データの受信時に B<SIGIO> や B<SIGURG> シグナ"
#~ "ル群を送るプロセスやプロセスグループを設定する。 引数は I<pid_t> へのポ"
#~ "インターである。 引数が正だと、そのプロセスにシグナルが送られる。負だ"
#~ "と、 引数の絶対値を ID に持つプロセスグループにシグナルが送られる。 シグ"
#~ "ナル受信先には、自分自身のプロセス / 自分の所属するプロセスグループ しか指"
#~ "定できない。但し、 B<CAP_KILL> ケーパビリティを持っている場合、及び実効"
#~ "ユーザー ID が 0 のプロセスの場合は この限りではない。"

#~ msgid ""
#~ "The B<CONFIG_FILTER> socket options B<SO_ATTACH_FILTER> and "
#~ "B<SO_DETACH_FILTER> are not documented.  The suggested interface to use "
#~ "them is via the libpcap library."
#~ msgstr ""
#~ "B<CONFIG_FILTER> ソケットオプションである B<SO_ATTACH_FILTER> と "
#~ "B<SO_DETACH_FILTER> について記載されていない。これらは libpcap ライブラリ"
#~ "を通して 用いる方が良い。"

#~ msgid "2008-10-11"
#~ msgstr "2008-10-11"

#~ msgid "Too many descriptors are in use by this process."
#~ msgstr "このプロセスが使用しているディスクリプターの数が多すぎる。"
