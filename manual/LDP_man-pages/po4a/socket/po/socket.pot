# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/accept.2:41
#, no-wrap
msgid "ACCEPT"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/connect.2:67 build/C/man2/getsockopt.2:44 build/C/man2/select_tut.2:32
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:69 build/C/man2/bpf.2:26 build/C/man2/connect.2:67 build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44 build/C/man2/listen.2:45 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:40 build/C/man2/select_tut.2:32 build/C/man2/send.2:40 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25 build/C/man2/socket.2:42 build/C/man7/socket.7:54 build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42 build/C/man7/address_families.7:26 build/C/man7/sock_diag.7:24 build/C/man7/vsock.7:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:69 build/C/man3/bindresvport.3:30 build/C/man2/bpf.2:26 build/C/man2/connect.2:67 build/C/man3/getifaddrs.3:36 build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44 build/C/man3/if_nameindex.3:26 build/C/man3/if_nametoindex.3:25 build/C/man2/listen.2:45 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:40 build/C/man2/select_tut.2:32 build/C/man2/send.2:40 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25 build/C/man2/socket.2:42 build/C/man7/socket.7:54 build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42 build/C/man7/address_families.7:26 build/C/man7/sock_diag.7:24 build/C/man7/vsock.7:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:42 build/C/man2/bind.2:70 build/C/man3/bindresvport.3:31 build/C/man2/bpf.2:27 build/C/man2/connect.2:68 build/C/man3/getifaddrs.3:37 build/C/man2/getsockname.2:41 build/C/man2/getsockopt.2:45 build/C/man3/if_nameindex.3:27 build/C/man3/if_nametoindex.3:26 build/C/man2/listen.2:46 build/C/man2/recv.2:42 build/C/man2/recvmmsg.2:32 build/C/man2/select.2:41 build/C/man2/select_tut.2:33 build/C/man2/send.2:41 build/C/man2/sendmmsg.2:29 build/C/man3/sockatmark.3:26 build/C/man2/socket.2:43 build/C/man7/socket.7:55 build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:43 build/C/man7/bpf-helpers.7:4 build/C/man7/address_families.7:27 build/C/man7/sock_diag.7:25 build/C/man7/vsock.7:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:44
msgid "accept, accept4 - accept a connection on a socket"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:44 build/C/man2/bind.2:72 build/C/man3/bindresvport.3:33 build/C/man2/bpf.2:29 build/C/man2/connect.2:70 build/C/man3/getifaddrs.3:39 build/C/man2/getsockname.2:43 build/C/man2/getsockopt.2:47 build/C/man3/if_nameindex.3:29 build/C/man3/if_nametoindex.3:29 build/C/man2/listen.2:48 build/C/man2/recv.2:44 build/C/man2/recvmmsg.2:34 build/C/man2/select.2:44 build/C/man2/select_tut.2:35 build/C/man2/send.2:43 build/C/man2/sendmmsg.2:31 build/C/man3/sockatmark.3:28 build/C/man2/socket.2:45 build/C/man7/socket.7:57 build/C/man2/socketcall.2:28 build/C/man2/socketpair.2:45 build/C/man7/address_families.7:29 build/C/man7/sock_diag.7:27 build/C/man7/vsock.7:28
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:48 build/C/man2/bind.2:76 build/C/man2/connect.2:74 build/C/man2/getsockopt.2:51 build/C/man2/listen.2:52
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:50
#, no-wrap
msgid ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:53
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:56
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:57 build/C/man2/bind.2:80 build/C/man3/bindresvport.3:40 build/C/man2/bpf.2:35 build/C/man2/connect.2:78 build/C/man3/getifaddrs.3:48 build/C/man2/getsockname.2:50 build/C/man2/getsockopt.2:57 build/C/man3/if_nameindex.3:36 build/C/man3/if_nametoindex.3:37 build/C/man2/listen.2:55 build/C/man2/recv.2:58 build/C/man2/recvmmsg.2:43 build/C/man2/select.2:68 build/C/man2/select_tut.2:38 build/C/man2/send.2:58 build/C/man2/sendmmsg.2:40 build/C/man3/sockatmark.3:42 build/C/man2/socket.2:51 build/C/man7/socket.7:61 build/C/man2/socketcall.2:32 build/C/man2/socketpair.2:52 build/C/man7/bpf-helpers.7:91 build/C/man7/address_families.7:35 build/C/man7/sock_diag.7:36 build/C/man7/vsock.7:36
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:72
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:81
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:99
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:107
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:112 build/C/man2/getsockname.2:67
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:125
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:140
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2), B<poll>(2), or B<epoll>(7).  A readable event will be "
"delivered when a new connection is attempted and you may then call "
"B<accept>()  to get a socket for that connection.  Alternatively, you can "
"set the socket to deliver B<SIGIO> when activity occurs on a socket; see "
"B<socket>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:150
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:150 build/C/man2/socket.2:264
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:160 build/C/man2/socket.2:274
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:160 build/C/man2/socket.2:274
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:170 build/C/man2/socket.2:284
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:170 build/C/man2/bind.2:153 build/C/man3/bindresvport.3:69 build/C/man2/bpf.2:974 build/C/man2/connect.2:136 build/C/man3/getifaddrs.3:142 build/C/man2/getsockname.2:67 build/C/man2/getsockopt.2:130 build/C/man3/if_nameindex.3:71 build/C/man3/if_nametoindex.3:54 build/C/man2/listen.2:81 build/C/man2/recv.2:434 build/C/man2/recvmmsg.2:147 build/C/man2/select.2:388 build/C/man2/select_tut.2:318 build/C/man2/send.2:318 build/C/man2/sendmmsg.2:119 build/C/man3/sockatmark.3:51 build/C/man2/socket.2:416 build/C/man2/socketpair.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:179
msgid ""
"On success, these system calls return a file descriptor for the accepted "
"socket (a nonnegative integer).  On error, -1 is returned, I<errno> is set "
"appropriately, and I<addrlen> is left unchanged."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:179
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:206
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of "
"TCP/IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:206 build/C/man2/bind.2:158 build/C/man3/bindresvport.3:74 build/C/man2/bpf.2:989 build/C/man2/connect.2:141 build/C/man3/getifaddrs.3:149 build/C/man2/getsockname.2:72 build/C/man2/getsockopt.2:139 build/C/man3/if_nameindex.3:78 build/C/man3/if_nametoindex.3:69 build/C/man2/listen.2:86 build/C/man2/recv.2:450 build/C/man2/recvmmsg.2:155 build/C/man2/select.2:408 build/C/man2/send.2:323 build/C/man2/sendmmsg.2:133 build/C/man3/sockatmark.3:58 build/C/man2/socket.2:421 build/C/man2/socketpair.2:84 build/C/man7/vsock.7:177
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:207 build/C/man2/recv.2:455 build/C/man2/send.2:339
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/accept.2:216
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 and POSIX.1-2008 allow either error to be returned "
"for this case, and do not require these constants to have the same value, so "
"a portable application should check for both possibilities."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:216 build/C/man2/bind.2:176 build/C/man2/bpf.2:1012 build/C/man2/connect.2:194 build/C/man2/getsockname.2:73 build/C/man2/getsockopt.2:140 build/C/man2/listen.2:103 build/C/man2/recv.2:464 build/C/man2/select.2:409 build/C/man2/send.2:363 build/C/man3/sockatmark.3:59
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:220
msgid "I<sockfd> is not an open file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:220
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:223
msgid "A connection has been aborted."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:223 build/C/man2/bind.2:209 build/C/man2/bpf.2:1016 build/C/man2/connect.2:203 build/C/man2/getsockname.2:78 build/C/man2/getsockopt.2:145 build/C/man2/recv.2:473 build/C/man2/send.2:373 build/C/man2/socketpair.2:88
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:228
msgid "The I<addr> argument is not in a writable part of the user address space."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:228 build/C/man2/connect.2:233 build/C/man2/recv.2:477 build/C/man2/select.2:415 build/C/man2/send.2:376
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:233
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:233 build/C/man2/accept.2:238 build/C/man2/bind.2:180 build/C/man2/bind.2:185 build/C/man2/bpf.2:1027 build/C/man2/bpf.2:1032 build/C/man2/bpf.2:1039 build/C/man2/bpf.2:1048 build/C/man2/getsockname.2:84 build/C/man2/getsockopt.2:155 build/C/man2/recv.2:482 build/C/man2/recvmmsg.2:159 build/C/man2/select.2:419 build/C/man2/select.2:426 build/C/man2/send.2:380 build/C/man3/sockatmark.3:63 build/C/man2/socket.2:429 build/C/man2/socket.2:432 build/C/man7/vsock.7:189
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:238
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:243
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:243 build/C/man2/socket.2:437 build/C/man2/socketpair.2:93
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:246 build/C/man2/socket.2:440 build/C/man2/socketpair.2:96
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:246 build/C/man2/socket.2:440 build/C/man2/socketpair.2:96
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:249 build/C/man2/socket.2:443 build/C/man2/socketpair.2:99
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:249
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:254
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:254 build/C/man2/bind.2:191 build/C/man2/connect.2:245 build/C/man2/getsockname.2:92 build/C/man2/getsockopt.2:169 build/C/man2/listen.2:108 build/C/man2/recv.2:497 build/C/man2/send.2:409
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:259 build/C/man2/bind.2:196 build/C/man2/connect.2:250 build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:174 build/C/man2/listen.2:113 build/C/man2/recv.2:502 build/C/man2/send.2:414
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:259 build/C/man2/listen.2:113 build/C/man2/send.2:414 build/C/man2/socketpair.2:99 build/C/man7/vsock.7:205
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:263
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:263
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:266
msgid "Protocol error."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:270
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:270 build/C/man2/bpf.2:1068
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:273
msgid "Firewall rules forbid connection."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:285
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:285 build/C/man2/bpf.2:1074 build/C/man3/getifaddrs.3:162 build/C/man3/if_nameindex.3:97 build/C/man2/recvmmsg.2:165 build/C/man2/select.2:434 build/C/man2/sendmmsg.2:146 build/C/man3/sockatmark.3:70 build/C/man7/socket.7:1207 build/C/man7/sock_diag.7:621 build/C/man7/vsock.7:231
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:290
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:290 build/C/man2/bind.2:233 build/C/man3/bindresvport.3:117 build/C/man2/bpf.2:1078 build/C/man2/connect.2:262 build/C/man3/getifaddrs.3:184 build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:174 build/C/man3/if_nameindex.3:119 build/C/man3/if_nametoindex.3:106 build/C/man2/listen.2:118 build/C/man2/recv.2:502 build/C/man2/recvmmsg.2:170 build/C/man2/select.2:440 build/C/man2/send.2:428 build/C/man2/sendmmsg.2:151 build/C/man3/sockatmark.3:85 build/C/man2/socket.2:454 build/C/man2/socketcall.2:150 build/C/man2/socketpair.2:105 build/C/man7/sock_diag.7:638
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: build/C/man2/accept.2:302
msgid ""
"B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<accept>()  first "
"appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:305
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr ""

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: build/C/man2/accept.2:320
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:320 build/C/man2/bind.2:245 build/C/man3/bindresvport.3:120 build/C/man2/bpf.2:1082 build/C/man2/connect.2:278 build/C/man3/getifaddrs.3:204 build/C/man2/getsockname.2:103 build/C/man2/getsockopt.2:181 build/C/man2/listen.2:122 build/C/man2/recv.2:512 build/C/man2/select.2:455 build/C/man2/select_tut.2:321 build/C/man2/send.2:442 build/C/man2/sendmmsg.2:154 build/C/man3/sockatmark.3:87 build/C/man2/socket.2:468 build/C/man7/socket.7:1221 build/C/man2/socketcall.2:153 build/C/man2/socketpair.2:112
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:326
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:348
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2), B<poll>(2), or B<epoll>(7)  return a readability event "
"because the connection might have been removed by an asynchronous network "
"error or another thread before B<accept>()  is called.  If this happens, "
"then the call will block waiting for the next connection to arrive.  To "
"ensure that B<accept>()  never blocks, the passed socket I<sockfd> needs to "
"have the B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:359
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECnet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently, only DECnet has these "
"semantics on Linux."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:359
#, no-wrap
msgid "The socklen_t type"
msgstr ""

#.  such as Linux libc4 and libc5, SunOS 4, SGI
#.  SunOS 5 has 'size_t *'
#. type: Plain text
#: build/C/man2/accept.2:370
msgid ""
"In the original BSD sockets implementation (and on other older systems)  the "
"third argument of B<accept>()  was declared as an I<int\\ *>.  A POSIX.1g "
"draft standard wanted to change it into a I<size_t\\ *>C; later POSIX "
"standards and glibc 2.x have I<socklen_t\\ * >."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:370 build/C/man2/bind.2:259 build/C/man2/bpf.2:1204 build/C/man2/connect.2:295 build/C/man3/getifaddrs.3:221 build/C/man3/if_nameindex.3:123 build/C/man2/listen.2:178 build/C/man2/recv.2:557 build/C/man2/recvmmsg.2:192 build/C/man2/select.2:709 build/C/man2/select_tut.2:347 build/C/man2/send.2:471 build/C/man2/sendmmsg.2:177 build/C/man3/sockatmark.3:111 build/C/man2/socket.2:487 build/C/man7/bpf-helpers.7:3595 build/C/man7/sock_diag.7:640
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:373 build/C/man2/listen.2:181
msgid "See B<bind>(2)."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:373 build/C/man2/bind.2:324 build/C/man3/bindresvport.3:126 build/C/man2/bpf.2:1273 build/C/man2/connect.2:300 build/C/man3/getifaddrs.3:324 build/C/man2/getsockname.2:108 build/C/man2/getsockopt.2:195 build/C/man3/if_nameindex.3:162 build/C/man3/if_nametoindex.3:110 build/C/man2/listen.2:181 build/C/man2/recv.2:562 build/C/man2/recvmmsg.2:286 build/C/man2/select.2:746 build/C/man2/select_tut.2:639 build/C/man2/send.2:476 build/C/man2/sendmmsg.2:245 build/C/man3/sockatmark.3:146 build/C/man2/socket.2:492 build/C/man7/socket.7:1241 build/C/man2/socketcall.2:174 build/C/man2/socketpair.2:138 build/C/man7/bpf-helpers.7:3674 build/C/man7/address_families.7:407 build/C/man7/sock_diag.7:837 build/C/man7/vsock.7:241
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:380
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:380 build/C/man2/bind.2:337 build/C/man3/bindresvport.3:129 build/C/man2/bpf.2:1282 build/C/man2/connect.2:308 build/C/man3/getifaddrs.3:330 build/C/man2/getsockname.2:115 build/C/man2/getsockopt.2:206 build/C/man3/if_nameindex.3:169 build/C/man3/if_nametoindex.3:114 build/C/man2/listen.2:187 build/C/man2/recv.2:578 build/C/man2/recvmmsg.2:293 build/C/man2/select.2:761 build/C/man2/select_tut.2:652 build/C/man2/send.2:493 build/C/man2/sendmmsg.2:250 build/C/man3/sockatmark.3:151 build/C/man2/socket.2:523 build/C/man7/socket.7:1259 build/C/man2/socketcall.2:192 build/C/man2/socketpair.2:145 build/C/man7/bpf-helpers.7:3686 build/C/man7/address_families.7:410 build/C/man7/sock_diag.7:842 build/C/man7/vsock.7:249
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:388 build/C/man2/bind.2:345 build/C/man3/bindresvport.3:137 build/C/man2/bpf.2:1290 build/C/man2/connect.2:316 build/C/man3/getifaddrs.3:338 build/C/man2/getsockname.2:123 build/C/man2/getsockopt.2:214 build/C/man3/if_nameindex.3:177 build/C/man3/if_nametoindex.3:122 build/C/man2/listen.2:195 build/C/man2/recv.2:586 build/C/man2/recvmmsg.2:301 build/C/man2/select.2:769 build/C/man2/select_tut.2:660 build/C/man2/send.2:501 build/C/man2/sendmmsg.2:258 build/C/man3/sockatmark.3:159 build/C/man2/socket.2:531 build/C/man7/socket.7:1267 build/C/man2/socketcall.2:200 build/C/man2/socketpair.2:153 build/C/man7/bpf-helpers.7:3694 build/C/man7/address_families.7:418 build/C/man7/sock_diag.7:850 build/C/man7/vsock.7:257
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/bind.2:69
#, no-wrap
msgid "BIND"
msgstr ""

#. type: TH
#: build/C/man2/bind.2:69 build/C/man2/bpf.2:26 build/C/man3/getifaddrs.3:36 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:40 build/C/man2/send.2:40 build/C/man7/sock_diag.7:24
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:72
msgid "bind - bind a name to a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:79
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:93
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:100
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:131
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET>, see "
"B<ip>(7); for B<AF_INET6>, see B<ipv6>(7); for B<AF_UNIX>, see B<unix>(7); "
"for B<AF_APPLETALK>, see B<ddp>(7); for B<AF_PACKET>, see B<packet>(7); for "
"B<AF_X25>, see B<x25>(7); and for B<AF_NETLINK>, see B<netlink>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:138
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:145
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:153
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLES below."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:158 build/C/man2/getsockname.2:72 build/C/man2/listen.2:86
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:159 build/C/man2/bind.2:200 build/C/man3/bindresvport.3:79 build/C/man2/bpf.2:995 build/C/man2/connect.2:144 build/C/man2/send.2:328 build/C/man2/socket.2:422 build/C/man7/vsock.7:178
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: build/C/man2/bind.2:163
msgid "The address is protected, and the user is not the superuser."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:163 build/C/man2/bind.2:166 build/C/man3/bindresvport.3:85 build/C/man2/connect.2:164 build/C/man2/listen.2:87 build/C/man2/listen.2:90 build/C/man7/vsock.7:183
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:166
msgid "The given address is already in use."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:176
msgid ""
"(Internet domain sockets)  The port number was specified as zero in the "
"socket address structure, but, upon attempting to bind to an ephemeral port, "
"it was determined that all port numbers in the ephemeral port range are "
"currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:180 build/C/man3/sockatmark.3:63
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: build/C/man2/bind.2:185
msgid "The socket is already bound to an address."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:191
msgid ""
"I<addrlen> is wrong, or I<addr> is not a valid address for this socket's "
"domain."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:200
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:205
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/bind.2:205 build/C/man2/connect.2:167 build/C/man7/vsock.7:186
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:209
msgid ""
"A nonexistent interface was requested or the requested address was not "
"local."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:213
msgid "I<addr> points outside the user's accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:213
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:217
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:217
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:221
msgid "I<addr> is too long."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:221 build/C/man2/bpf.2:1056
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:224
msgid "A component in the directory prefix of the socket pathname does not exist."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:224 build/C/man2/bpf.2:1065 build/C/man2/recv.2:486 build/C/man2/select.2:431 build/C/man2/send.2:403
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:227
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:227
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:230
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:230
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:233
msgid "The socket inode would reside on a read-only filesystem."
msgstr ""

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: build/C/man2/bind.2:245
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<bind>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:251 build/C/man2/connect.2:284 build/C/man2/getsockopt.2:187 build/C/man2/listen.2:148 build/C/man2/socket.2:474 build/C/man2/socketpair.2:138
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this "
"header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:256 build/C/man2/connect.2:289 build/C/man2/getsockname.2:108 build/C/man2/getsockopt.2:192
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#. type: SH
#: build/C/man2/bind.2:256 build/C/man2/getsockopt.2:192 build/C/man2/recvmmsg.2:173 build/C/man2/select.2:635 build/C/man2/send.2:466 build/C/man2/sendmmsg.2:169 build/C/man3/sockatmark.3:107
#, no-wrap
msgid "BUGS"
msgstr ""

#.  FIXME Document transparent proxy options
#. type: Plain text
#: build/C/man2/bind.2:259
msgid "The transparent proxy options are not described."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:264
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: build/C/man2/bind.2:271
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:278
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:281
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:284
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:291
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:295
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:301
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(my_addr));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:305
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(my_addr)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:308
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:311
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:317
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(peer_addr);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:319
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:323
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:337
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:30
#, no-wrap
msgid "BINDRESVPORT"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:30 build/C/man2/getsockname.2:40 build/C/man3/if_nametoindex.3:25 build/C/man2/socketcall.2:25
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:33
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:39
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr ""

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: build/C/man3/bindresvport.3:48
msgid ""
"B<bindresvport>()  is used to bind the socket referred to by the file "
"descriptor I<sockfd> to a privileged anonymous IP port, that is, a port "
"number arbitrarily selected from the range 512 to 1023."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:58
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin> "
"is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:69
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken "
"to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:74
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:79
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:85
msgid ""
"The calling process was not privileged (on Linux: the calling process did "
"not have the B<CAP_NET_BIND_SERVICE> capability in the user namespace "
"governing its network namespace)."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:88
msgid "All privileged ports are in use."
msgstr ""

#. type: TP
#: build/C/man3/bindresvport.3:88
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:95
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""

#. type: SH
#: build/C/man3/bindresvport.3:95 build/C/man3/getifaddrs.3:170 build/C/man3/if_nameindex.3:104 build/C/man3/if_nametoindex.3:93 build/C/man3/sockatmark.3:73
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:98 build/C/man3/getifaddrs.3:173 build/C/man3/if_nameindex.3:107 build/C/man3/if_nametoindex.3:96 build/C/man3/sockatmark.3:76
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177 build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100 build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177 build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100 build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:102 build/C/man3/getifaddrs.3:177 build/C/man3/if_nameindex.3:111 build/C/man3/if_nametoindex.3:100 build/C/man3/sockatmark.3:80
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:105
#, no-wrap
msgid "B<bindresvport>()"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:105 build/C/man3/getifaddrs.3:181 build/C/man3/if_nameindex.3:116 build/C/man3/if_nametoindex.3:104 build/C/man3/sockatmark.3:83
#, no-wrap
msgid "Thread safety"
msgstr ""

#.  commit f6da27e53695ad1cc0e2a9490358decbbfdff5e5
#. type: tbl table
#: build/C/man3/bindresvport.3:108
#, no-wrap
msgid "glibc E<gt>= 2.17: MT-Safe\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:108 build/C/man3/if_nameindex.3:114 build/C/man2/socket.2:147 build/C/man7/socket.7:188
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man3/bindresvport.3:110
#, no-wrap
msgid "glibc E<lt> 2.17: MT-Unsafe"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:117
msgid ""
"The B<bindresvport>()  function uses a static variable that was not "
"protected by a lock before glibc 2.17, rendering the function MT-Unsafe."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:120
msgid "Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:126
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:129
msgid "B<bind>(2), B<getsockname>(2)"
msgstr ""

#. type: TH
#: build/C/man2/bpf.2:26
#, no-wrap
msgid "BPF"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:29
msgid "bpf - perform a command on an extended BPF map or program"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:32
#, no-wrap
msgid "B<#include E<lt>linux/bpf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:34
#, no-wrap
msgid ""
"B<int bpf(int >I<cmd>B<, union bpf_attr *>I<attr>B<, unsigned int "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:45
msgid ""
"The B<bpf>()  system call performs a range of operations related to extended "
"Berkeley Packet Filters.  Extended BPF (or eBPF) is similar to the original "
"(\"classic\") BPF (cBPF) used to filter network packets.  For both cBPF and "
"eBPF programs, the kernel statically analyzes the programs before loading "
"them, in order to ensure that they cannot harm the running system."
msgstr ""

#.  See 'enum bpf_func_id' in include/uapi/linux/bpf.h
#. type: Plain text
#: build/C/man2/bpf.2:54
msgid ""
"eBPF extends cBPF in multiple ways, including the ability to call a fixed "
"set of in-kernel helper functions (via the B<BPF_CALL> opcode extension "
"provided by eBPF)  and access shared data structures such as eBPF maps."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:54
#, no-wrap
msgid "Extended BPF Design/Architecture"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:59
msgid ""
"eBPF maps are a generic data structure for storage of different data types.  "
"Data types are generally treated as binary blobs, so a user just specifies "
"the size of the key and the size of the value at map-creation time.  In "
"other words, a key/value for a given map can have an arbitrary structure."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:65
msgid ""
"A user process can create multiple maps (with key/value-pairs being opaque "
"bytes of data) and access them via file descriptors.  Different eBPF "
"programs can access the same maps in parallel.  It's up to the user process "
"and eBPF program to decide what they store inside maps."
msgstr ""

#.  Defined by the kernel constant MAX_TAIL_CALL_CNT in include/linux/bpf.h
#. type: Plain text
#: build/C/man2/bpf.2:83
msgid ""
"There's one special map type, called a program array.  This type of map "
"stores file descriptors referring to other eBPF programs.  When a lookup in "
"the map is performed, the program flow is redirected in-place to the "
"beginning of another eBPF program and does not return back to the calling "
"program.  The level of nesting has a fixed limit of 32, so that infinite "
"loops cannot be crafted.  At run time, the program file descriptors stored "
"in the map can be modified, so program functionality can be altered based on "
"specific requirements.  All programs referred to in a program-array map must "
"have been previously loaded into the kernel via B<bpf>().  If a map lookup "
"fails, the current program continues its execution.  See "
"B<BPF_MAP_TYPE_PROG_ARRAY> below for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:97
msgid ""
"Generally, eBPF programs are loaded by the user process and automatically "
"unloaded when the process exits.  In some cases, for example, B<tc-bpf>(8), "
"the program will continue to stay alive inside the kernel even after the "
"process that loaded the program exits.  In that case, the tc subsystem holds "
"a reference to the eBPF program after the file descriptor has been closed by "
"the user-space program.  Thus, whether a specific program continues to live "
"inside the kernel depends on how it is further attached to a given kernel "
"subsystem after it was loaded via B<bpf>()."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:105
msgid ""
"Each eBPF program is a set of instructions that is safe to run until its "
"completion.  An in-kernel verifier statically determines that the eBPF "
"program terminates and is safe to execute.  During verification, the kernel "
"increments reference counts for each of the maps that the eBPF program uses, "
"so that the attached maps can't be removed until the program is unloaded."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:116
msgid ""
"eBPF programs can be attached to different events.  These events can be the "
"arrival of network packets, tracing events, classification events by network "
"queueing disciplines (for eBPF programs attached to a B<tc>(8)  classifier), "
"and other types that may be added in the future.  A new event triggers "
"execution of the eBPF program, which may store information about the event "
"in eBPF maps.  Beyond storing data, eBPF programs may call a fixed set of "
"in-kernel helper functions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:119
msgid ""
"The same eBPF program can be attached to multiple events and different eBPF "
"programs can access the same map:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:131
#, no-wrap
msgid ""
"tracing     tracing    tracing    packet      packet     packet\n"
"event A     event B    event C    on eth0     on eth1    on eth2\n"
" |             |         |          |           |          \\(ha\n"
" |             |         |          |           v          |\n"
" --E<gt> tracing E<lt>--     tracing      socket    tc ingress   tc egress\n"
"      prog_1          prog_2      prog_3    classifier    action\n"
"      |  |              |           |         prog_4      prog_5\n"
"   |---  -----|  |------|          map_3        |           |\n"
" map_1       map_2                              --| map_4 |--\n"
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:134 build/C/man2/select.2:155
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:150
msgid ""
"The operation to be performed by the B<bpf>()  system call is determined by "
"the I<cmd> argument.  Each operation takes an accompanying argument, "
"provided via I<attr>, which is a pointer to a union of type I<bpf_attr> (see "
"below).  The I<size> argument is the size of the union pointed to by "
"I<attr>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:154
msgid "The value provided in I<cmd> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:154 build/C/man2/bpf.2:248 build/C/man2/bpf.2:976
#, no-wrap
msgid "B<BPF_MAP_CREATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:160
msgid ""
"Create a map and return a file descriptor that refers to the map.  The "
"close-on-exec file descriptor flag (see B<fcntl>(2))  is automatically "
"enabled for the new file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:160 build/C/man2/bpf.2:395
#, no-wrap
msgid "B<BPF_MAP_LOOKUP_ELEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:163
msgid "Look up an element by key in a specified map and return its value."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:163 build/C/man2/bpf.2:431
#, no-wrap
msgid "B<BPF_MAP_UPDATE_ELEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:166
msgid "Create or update an element (key/value pair) in a specified map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:166 build/C/man2/bpf.2:503
#, no-wrap
msgid "B<BPF_MAP_DELETE_ELEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:169
msgid "Look up and delete an element by key in a specified map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:169 build/C/man2/bpf.2:533
#, no-wrap
msgid "B<BPF_MAP_GET_NEXT_KEY>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:173
msgid ""
"Look up an element by key in a specified map and return the key of the next "
"element."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:173 build/C/man2/bpf.2:979
#, no-wrap
msgid "B<BPF_PROG_LOAD>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:180
msgid ""
"Verify and load an eBPF program, returning a new file descriptor associated "
"with the program.  The close-on-exec file descriptor flag (see B<fcntl>(2))  "
"is automatically enabled for the new file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:186
msgid ""
"The I<bpf_attr> union consists of various anonymous structures that are used "
"by different B<bpf>()  commands:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:197
#, no-wrap
msgid ""
"union bpf_attr {\n"
"    struct {    /* Used by BPF_MAP_CREATE */\n"
"        __u32         map_type;\n"
"        __u32         key_size;    /* size of key in bytes */\n"
"        __u32         value_size;  /* size of value in bytes */\n"
"        __u32         max_entries; /* maximum number of entries\n"
"                                      in a map */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:208
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY\n"
"                   commands */\n"
"        __u32         map_fd;\n"
"        __aligned_u64 key;\n"
"        union {\n"
"            __aligned_u64 value;\n"
"            __aligned_u64 next_key;\n"
"        };\n"
"        __u64         flags;\n"
"    };\n"
msgstr ""

#.                  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: build/C/man2/bpf.2:224
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_PROG_LOAD */\n"
"        __u32         prog_type;\n"
"        __u32         insn_cnt;\n"
"        __aligned_u64 insns;      /* \\(aqconst struct bpf_insn *\\(aq */\n"
"        __aligned_u64 license;    /* \\(aqconst char *\\(aq */\n"
"        __u32         log_level;  /* verbosity level of verifier */\n"
"        __u32         log_size;   /* size of user buffer */\n"
"        __aligned_u64 log_buf;    /* user supplied \\(aqchar *\\(aq\n"
"                                     buffer */\n"
"        __u32         kern_version;\n"
"                                  /* checked when prog_type=kprobe\n"
"                                     (since Linux 4.1) */\n"
"    };\n"
"} __attribute__((aligned(8)));\n"
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:227
#, no-wrap
msgid "eBPF maps"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:231
msgid ""
"Maps are a generic data structure for storage of different types of data.  "
"They allow sharing of data between eBPF kernel programs, and also between "
"kernel and user-space applications."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:233
msgid "Each map type has the following attributes:"
msgstr ""

#. type: IP
#: build/C/man2/bpf.2:233 build/C/man2/bpf.2:235 build/C/man2/bpf.2:237 build/C/man2/bpf.2:239 build/C/man2/bpf.2:600 build/C/man2/bpf.2:604 build/C/man2/bpf.2:606 build/C/man2/bpf.2:613 build/C/man2/bpf.2:625 build/C/man2/bpf.2:638 build/C/man2/bpf.2:640 build/C/man2/bpf.2:642 build/C/man2/bpf.2:647 build/C/man2/bpf.2:666 build/C/man2/bpf.2:670 build/C/man2/bpf.2:672 build/C/man2/bpf.2:797 build/C/man2/bpf.2:802 build/C/man2/bpf.2:806 build/C/man2/bpf.2:813 build/C/man2/bpf.2:821 build/C/man2/bpf.2:830 build/C/man2/bpf.2:1097 build/C/man2/bpf.2:1100 build/C/man2/bpf.2:1102 build/C/man2/bpf.2:1104 build/C/man2/bpf.2:1170 build/C/man2/bpf.2:1174 build/C/man2/bpf.2:1177 build/C/man2/bpf.2:1180 build/C/man2/bpf.2:1183 build/C/man2/bpf.2:1186 build/C/man2/bpf.2:1190 build/C/man2/bpf.2:1193 build/C/man2/bpf.2:1196 build/C/man2/bpf.2:1200
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:235
msgid "type"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:237
msgid "maximum number of elements"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:239
msgid "key size in bytes"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:241
msgid "value size in bytes"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:248
msgid ""
"The following wrapper functions demonstrate how various B<bpf>()  commands "
"can be used to access the maps.  The functions use the I<cmd> argument to "
"invoke different operations."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:254
msgid ""
"The B<BPF_MAP_CREATE> command creates a new map, returning a new file "
"descriptor that refers to the map."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:269
#, no-wrap
msgid ""
"int\n"
"bpf_create_map(enum bpf_map_type map_type,\n"
"               unsigned int key_size,\n"
"               unsigned int value_size,\n"
"               unsigned int max_entries)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_type    = map_type,\n"
"        .key_size    = key_size,\n"
"        .value_size  = value_size,\n"
"        .max_entries = max_entries\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:272
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:290
msgid ""
"The new map has the type specified by I<map_type>, and attributes as "
"specified in I<key_size>, I<value_size>, and I<max_entries>.  On success, "
"this operation returns a file descriptor.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, or B<ENOMEM>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:307
msgid ""
"The I<key_size> and I<value_size> attributes will be used by the verifier "
"during program loading to check that the program is calling "
"B<bpf_map_*_elem>()  helper functions with a correctly initialized I<key> "
"and to check that the program doesn't access the map element I<value> beyond "
"the specified I<value_size>.  For example, when a map is created with a "
"I<key_size> of 8 and the eBPF program calls"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:311
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, fp - 4)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:316
msgid "the program will be rejected, since the in-kernel helper function"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:320
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, void *key)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:331
msgid ""
"expects to read 8 bytes from the location pointed to by I<key>, but the "
"I<fp\\ -\\ 4> (where I<fp> is the top of the stack)  starting address will "
"cause out-of-bounds stack access."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:335
msgid ""
"Similarly, when a map is created with a I<value_size> of 1 and the eBPF "
"program contains"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:340
#, no-wrap
msgid ""
"value = bpf_map_lookup_elem(...);\n"
"*(u32 *) value = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:348
msgid ""
"the program will be rejected, since it accesses the I<value> pointer beyond "
"the specified 1 byte I<value_size> limit."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:351
msgid "Currently, the following values are supported for I<map_type>:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:381
#, no-wrap
msgid ""
"enum bpf_map_type {\n"
"    BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */\n"
"    BPF_MAP_TYPE_HASH,\n"
"    BPF_MAP_TYPE_ARRAY,\n"
"    BPF_MAP_TYPE_PROG_ARRAY,\n"
"    BPF_MAP_TYPE_PERF_EVENT_ARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_PERCPU_ARRAY,\n"
"    BPF_MAP_TYPE_STACK_TRACE,\n"
"    BPF_MAP_TYPE_CGROUP_ARRAY,\n"
"    BPF_MAP_TYPE_LRU_HASH,\n"
"    BPF_MAP_TYPE_LRU_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_LPM_TRIE,\n"
"    BPF_MAP_TYPE_ARRAY_OF_MAPS,\n"
"    BPF_MAP_TYPE_HASH_OF_MAPS,\n"
"    BPF_MAP_TYPE_DEVMAP,\n"
"    BPF_MAP_TYPE_SOCKMAP,\n"
"    BPF_MAP_TYPE_CPUMAP,\n"
"    BPF_MAP_TYPE_XSKMAP,\n"
"    BPF_MAP_TYPE_SOCKHASH,\n"
"    BPF_MAP_TYPE_CGROUP_STORAGE,\n"
"    BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,\n"
"    BPF_MAP_TYPE_QUEUE,\n"
"    BPF_MAP_TYPE_STACK,\n"
"    /* See /usr/include/linux/bpf.h for the full list. */\n"
"};\n"
msgstr ""

#.  FIXME We need an explanation of why one might choose each of
#.  these map implementations
#. type: Plain text
#: build/C/man2/bpf.2:395
msgid ""
"I<map_type> selects one of the available map implementations in the kernel.  "
"For all map types, eBPF programs access maps with the same "
"B<bpf_map_lookup_elem>()  and B<bpf_map_update_elem>()  helper functions.  "
"Further details of the various map types are given below."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:403
msgid ""
"The B<BPF_MAP_LOOKUP_ELEM> command looks up an element with a given I<key> "
"in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:414
#, no-wrap
msgid ""
"int\n"
"bpf_lookup_elem(int fd, const void *key, void *value)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:417
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:426
msgid ""
"If an element is found, the operation returns zero and stores the element's "
"value into I<value>, which must point to a buffer of I<value_size> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:431
msgid ""
"If no element is found, the operation returns -1 and sets I<errno> to "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:440
msgid ""
"The B<BPF_MAP_UPDATE_ELEM> command creates or updates an element with a "
"given I<key/value> in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:453
#, no-wrap
msgid ""
"int\n"
"bpf_update_elem(int fd, const void *key, const void *value,\n"
"                uint64_t flags)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"        .flags  = flags,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:456
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:462
msgid "The I<flags> argument should be specified as one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:463 build/C/man7/bpf-helpers.7:144 build/C/man7/bpf-helpers.7:1480 build/C/man7/bpf-helpers.7:2029
#, no-wrap
msgid "B<BPF_ANY>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:466
msgid "Create a new element or update an existing element."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:466 build/C/man7/bpf-helpers.7:138 build/C/man7/bpf-helpers.7:1474 build/C/man7/bpf-helpers.7:2023
#, no-wrap
msgid "B<BPF_NOEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:469
msgid "Create a new element only if it did not exist."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:469 build/C/man7/bpf-helpers.7:141 build/C/man7/bpf-helpers.7:1477 build/C/man7/bpf-helpers.7:2026 build/C/man7/bpf-helpers.7:2444
#, no-wrap
msgid "B<BPF_EXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:472
msgid "Update an existing element."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:503
msgid ""
"On success, the operation returns zero.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, B<ENOMEM>, or B<E2BIG>.  B<E2BIG> "
"indicates that the number of elements in the map reached the I<max_entries> "
"limit specified at map creation time.  B<EEXIST> will be returned if "
"I<flags> specifies B<BPF_NOEXIST> and the element with I<key> already exists "
"in the map.  B<ENOENT> will be returned if I<flags> specifies B<BPF_EXIST> "
"and the element with I<key> doesn't exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:512
msgid ""
"The B<BPF_MAP_DELETE_ELEM> command deletes the element whose key is I<key> "
"from the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:522
#, no-wrap
msgid ""
"int\n"
"bpf_delete_elem(int fd, const void *key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:525
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:533
msgid ""
"On success, zero is returned.  If the element is not found, -1 is returned "
"and I<errno> is set to B<ENOENT>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:544
msgid ""
"The B<BPF_MAP_GET_NEXT_KEY> command looks up an element by I<key> in the map "
"referred to by the file descriptor I<fd> and sets the I<next_key> pointer to "
"the key of the next element."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:555
#, no-wrap
msgid ""
"int\n"
"bpf_get_next_key(int fd, const void *key, void *next_key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd   = fd,\n"
"        .key      = ptr_to_u64(key),\n"
"        .next_key = ptr_to_u64(next_key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:558
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:586
msgid ""
"If I<key> is found, the operation returns zero and sets the I<next_key> "
"pointer to the key of the next element.  If I<key> is not found, the "
"operation returns zero and sets the I<next_key> pointer to the key of the "
"first element.  If I<key> is the last element, -1 is returned and I<errno> "
"is set to B<ENOENT>.  Other possible I<errno> values are B<ENOMEM>, "
"B<EFAULT>, B<EPERM>, and B<EINVAL>.  This method can be used to iterate over "
"all elements in the map."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:586
#, no-wrap
msgid "B<close(map_fd)>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:593
msgid ""
"Delete the map referred to by the file descriptor I<map_fd>.  When the "
"user-space program that created a map exits, all maps will be deleted "
"automatically (but see NOTES)."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:593
#, no-wrap
msgid "eBPF map types"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:595
msgid "The following map types are supported:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:595
#, no-wrap
msgid "B<BPF_MAP_TYPE_HASH>"
msgstr ""

#.  commit 0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475
#. type: Plain text
#: build/C/man2/bpf.2:599
msgid "Hash-table maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:604
msgid ""
"Maps are created and destroyed by user-space programs.  Both user-space and "
"eBPF programs can perform lookup, update, and delete operations."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:606
msgid "The kernel takes care of allocating and freeing key/value pairs."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:613
msgid ""
"The B<map_update_elem>()  helper will fail to insert new element when the "
"I<max_entries> limit is reached.  (This ensures that eBPF programs cannot "
"exhaust memory.)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:616
msgid "B<map_update_elem>()  replaces existing elements atomically."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:620
msgid "Hash-table maps are optimized for speed of lookup."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:620
#, no-wrap
msgid "B<BPF_MAP_TYPE_ARRAY>"
msgstr ""

#.  commit 28fbcfa08d8ed7c5a50d41a0433aad222835e8e3
#. type: Plain text
#: build/C/man2/bpf.2:624
msgid "Array maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:638
msgid ""
"Optimized for fastest possible lookup.  In the future the verifier/JIT "
"compiler may recognize lookup() operations that employ a constant key and "
"optimize it into constant pointer.  It is possible to optimize a "
"non-constant key into direct pointer arithmetic as well, since pointers and "
"I<value_size> are constant for the life of the eBPF program.  In other "
"words, B<array_map_lookup_elem>()  may be 'inlined' by the verifier/JIT "
"compiler while preserving concurrent access to this map from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:640
msgid "All array elements pre-allocated and zero initialized at init time"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:642
msgid "The key is an array index, and must be exactly four bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:647
msgid ""
"B<map_delete_elem>()  fails with the error B<EINVAL>, since elements cannot "
"be deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:662
msgid ""
"B<map_update_elem>()  replaces elements in a B<nonatomic> fashion; for "
"atomic updates, a hash-table map should be used instead.  There is however "
"one special case that can also be used with arrays: the atomic built-in "
"B<__sync_fetch_and_add()> can be used on 32 and 64 bit atomic counters.  For "
"example, it can be applied on the whole value itself if it represents a "
"single counter, or in case of a structure containing multiple counters, it "
"could be used on individual counters.  This is quite often useful for "
"aggregation and accounting of events."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:665
msgid "Among the uses for array maps are the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:670
msgid ""
"As \"global\" eBPF variables: an array of 1 element whose key is (index) 0 "
"and where the value is a collection of 'global' variables which eBPF "
"programs can use to keep state between events."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:672
msgid "Aggregation of tracing events into a fixed set of buckets."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:675
msgid ""
"Accounting of networking events, for example, number of packets and packet "
"sizes."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:676
#, no-wrap
msgid "B<BPF_MAP_TYPE_PROG_ARRAY> (since Linux 4.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:688
msgid ""
"A program array map is a special kind of array map whose map values contain "
"only file descriptors referring to other eBPF programs.  Thus, both the "
"I<key_size> and I<value_size> must be exactly four bytes.  This map is used "
"in conjunction with the B<bpf_tail_call>()  helper."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:691
msgid ""
"This means that an eBPF program with a program array map attached to it can "
"call from kernel side into"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:696
#, no-wrap
msgid ""
"void bpf_tail_call(void *context, void *prog_map,\n"
"                   unsigned int index);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:705
msgid ""
"and therefore replace its own program flow with the one from the program at "
"the given program array slot, if present.  This can be regarded as kind of a "
"jump table to a different eBPF program.  The invoked program will then reuse "
"the same stack.  When a jump into the new program has been performed, it "
"won't return to the old program anymore."
msgstr ""

#.  MAX_TAIL_CALL_CNT
#. type: Plain text
#: build/C/man2/bpf.2:714
msgid ""
"If no eBPF program is found at the given index of the program array (because "
"the map slot doesn't contain a valid program file descriptor, the specified "
"lookup index/key is out of bounds, or the limit of 32 nested calls has been "
"exceed), execution continues with the current eBPF program.  This can be "
"used as a fall-through for default cases."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:726
msgid ""
"A program array map is useful, for example, in tracing or networking, to "
"handle individual system calls or protocols in their own subprograms and use "
"their identifiers as an individual map index.  This approach may result in "
"performance benefits, and also makes it possible to overcome the maximum "
"instruction limit of a single eBPF program.  In dynamic environments, a "
"user-space daemon might atomically replace individual subprograms at "
"run-time with newer versions to alter overall program behavior, for "
"instance, if global policies change."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:726
#, no-wrap
msgid "eBPF programs"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:732
msgid ""
"The B<BPF_PROG_LOAD> command is used to load an eBPF program into the "
"kernel.  The return value for this command is a new file descriptor "
"associated with this eBPF program."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:736
#, no-wrap
msgid "char bpf_log_buf[LOG_BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:751
#, no-wrap
msgid ""
"int\n"
"bpf_prog_load(enum bpf_prog_type type,\n"
"              const struct bpf_insn *insns, int insn_cnt,\n"
"              const char *license)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .prog_type = type,\n"
"        .insns     = ptr_to_u64(insns),\n"
"        .insn_cnt  = insn_cnt,\n"
"        .license   = ptr_to_u64(license),\n"
"        .log_buf   = ptr_to_u64(bpf_log_buf),\n"
"        .log_size  = LOG_BUF_SIZE,\n"
"        .log_level = 1,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:754
#, no-wrap
msgid ""
"    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:759
msgid "I<prog_type> is one of the available program types:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:789
#, no-wrap
msgid ""
"enum bpf_prog_type {\n"
"    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid\n"
"                                    program type */\n"
"    BPF_PROG_TYPE_SOCKET_FILTER,\n"
"    BPF_PROG_TYPE_KPROBE,\n"
"    BPF_PROG_TYPE_SCHED_CLS,\n"
"    BPF_PROG_TYPE_SCHED_ACT,\n"
"    BPF_PROG_TYPE_TRACEPOINT,\n"
"    BPF_PROG_TYPE_XDP,\n"
"    BPF_PROG_TYPE_PERF_EVENT,\n"
"    BPF_PROG_TYPE_CGROUP_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK,\n"
"    BPF_PROG_TYPE_LWT_IN,\n"
"    BPF_PROG_TYPE_LWT_OUT,\n"
"    BPF_PROG_TYPE_LWT_XMIT,\n"
"    BPF_PROG_TYPE_SOCK_OPS,\n"
"    BPF_PROG_TYPE_SK_SKB,\n"
"    BPF_PROG_TYPE_CGROUP_DEVICE,\n"
"    BPF_PROG_TYPE_SK_MSG,\n"
"    BPF_PROG_TYPE_RAW_TRACEPOINT,\n"
"    BPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n"
"    BPF_PROG_TYPE_LWT_SEG6LOCAL,\n"
"    BPF_PROG_TYPE_LIRC_MODE2,\n"
"    BPF_PROG_TYPE_SK_REUSEPORT,\n"
"    BPF_PROG_TYPE_FLOW_DISSECTOR,\n"
"    /* See /usr/include/linux/bpf.h for the full list. */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:793
msgid "For further details of eBPF program types, see below."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:797
msgid "The remaining fields of I<bpf_attr> are set as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:802
msgid "I<insns> is an array of I<struct bpf_insn> instructions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:806
msgid ""
"I<insn_cnt> is the number of instructions in the program referred to by "
"I<insns>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:813
msgid ""
"I<license> is a license string, which must be GPL compatible to call helper "
"functions marked I<gpl_only>.  (The licensing rules are the same as for "
"kernel modules, so that also dual licenses, such as \"Dual BSD/GPL\", may be "
"used.)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:821
msgid ""
"I<log_buf> is a pointer to a caller-allocated buffer in which the in-kernel "
"verifier can store the verification log.  This log is a multi-line string "
"that can be checked by the program author in order to understand how the "
"verifier came to the conclusion that the eBPF program is unsafe.  The format "
"of the output can change at any time as the verifier evolves."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:830
msgid ""
"I<log_size> size of the buffer pointed to by I<log_buf>.  If the size of the "
"buffer is not large enough to store all verifier messages, -1 is returned "
"and I<errno> is set to B<ENOSPC>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:839
msgid ""
"I<log_level> verbosity level of the verifier.  A value of zero means that "
"the verifier will not provide a log; in this case, I<log_buf> must be a NULL "
"pointer, and I<log_size> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:845
msgid ""
"Applying B<close>(2)  to the file descriptor returned by B<BPF_PROG_LOAD> "
"will unload the eBPF program (but see NOTES)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:857
msgid ""
"Maps are accessible from eBPF programs and are used to exchange data between "
"eBPF programs and between eBPF programs and user-space programs.  For "
"example, eBPF programs can process various events (like kprobe, packets) and "
"store their data into a map, and user-space programs can then fetch data "
"from the map.  Conversely, user-space programs can use a map as a "
"configuration mechanism, populating the map with values checked by the eBPF "
"program, which then modifies its behavior on the fly according to those "
"values."
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:857
#, no-wrap
msgid "eBPF program types"
msgstr ""

#
#.  FIXME
#.  Somewhere in this page we need a general introduction to the
#.  bpf_context. For example, how does a BPF program access the
#.  context?
#. type: Plain text
#: build/C/man2/bpf.2:871
msgid ""
"The eBPF program type (I<prog_type>)  determines the subset of kernel helper "
"functions that the program may call.  The program type also determines the "
"program input (context)\\(emthe format of I<struct bpf_context> (which is "
"the data blob passed into the eBPF program as the first argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:878
msgid ""
"For example, a tracing program does not have the exact same subset of helper "
"functions as a socket filter program (though they may have some helpers in "
"common).  Similarly, the input (context) for a tracing program is a set of "
"register values, while for a socket filter it is a network packet."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:881
msgid ""
"The set of functions available to eBPF programs of a given type may increase "
"in the future."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:883
msgid "The following program types are supported:"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:883
#, no-wrap
msgid "B<BPF_PROG_TYPE_SOCKET_FILTER> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:888
msgid "Currently, the set of functions for B<BPF_PROG_TYPE_SOCKET_FILTER> is:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:897
#, no-wrap
msgid ""
"bpf_map_lookup_elem(map_fd, void *key)\n"
"                    /* look up key in a map_fd */\n"
"bpf_map_update_elem(map_fd, void *key, void *value)\n"
"                    /* update key/value */\n"
"bpf_map_delete_elem(map_fd, void *key)\n"
"                    /* delete key in a map_fd */\n"
msgstr ""

#.  FIXME: We need some text here to explain how the program
#.  accesses __sk_buff.
#.  See 'struct __sk_buff' and commit 9bac3d6d548e5
#
#.  Alexei commented:
#.  Actually now in case of SOCKET_FILTER, SCHED_CLS, SCHED_ACT
#.  the program can now access skb fields.
#. type: Plain text
#: build/C/man2/bpf.2:912
msgid "The I<bpf_context> argument is a pointer to a I<struct __sk_buff>."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:912
#, no-wrap
msgid "B<BPF_PROG_TYPE_KPROBE> (since Linux 4.1)"
msgstr ""

#.  commit 94caee8c312d96522bcdae88791aaa9ebcd5f22c
#.  commit a8cb5f556b567974d75ea29c15181c445c541b1f
#.  FIXME Document this program type
#. 	  Describe allowed helper functions for this program type
#. 	  Describe bpf_context for this program type
#. type: Plain text
#: build/C/man2/bpf.2:921 build/C/man2/bpf.2:929 build/C/man2/bpf.2:937
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:921
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_CLS> (since Linux 4.1)"
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:929
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_ACT> (since Linux 4.1)"
msgstr ""

#. type: SS
#: build/C/man2/bpf.2:937
#, no-wrap
msgid "Events"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:940
msgid ""
"Once a program is loaded, it can be attached to an event.  Various kernel "
"subsystems have different ways to do so."
msgstr ""

#.  commit 89aa075832b0da4402acebd698d0411dcc82d03e
#. type: Plain text
#: build/C/man2/bpf.2:949
msgid ""
"Since Linux 3.19, the following call will attach the program I<prog_fd> to "
"the socket I<sockfd>, which was created by an earlier call to B<socket>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:954
#, no-wrap
msgid ""
"setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,\n"
"           &prog_fd, sizeof(prog_fd));\n"
msgstr ""

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: build/C/man2/bpf.2:966
msgid ""
"Since Linux 4.1, the following call may be used to attach the eBPF program "
"referred to by the file descriptor I<prog_fd> to a perf event file "
"descriptor, I<event_fd>, that was created by a previous call to "
"B<perf_event_open>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:970
#, no-wrap
msgid "ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:976
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:979
msgid "The new file descriptor associated with the eBPF map."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:982
msgid "The new file descriptor associated with the eBPF program."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:982
#, no-wrap
msgid "All other commands"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:985
msgid "Zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:989
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/bpf.2:990
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:995
msgid ""
"The eBPF program is too large or a map reached the I<max_entries> limit "
"(maximum number of elements)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1012
msgid ""
"For B<BPF_PROG_LOAD>, even though all program instructions are valid, the "
"program has been rejected because it was deemed unsafe.  This may be because "
"it may have accessed a disallowed memory region or an uninitialized "
"stack/register or because the function constraints don't match the actual "
"types or because there was a misaligned memory access.  In this case, it is "
"recommended to call B<bpf>()  again with I<log_level = 1> and examine "
"I<log_buf> for the specific reason provided by the verifier."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1016
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1027
msgid ""
"One of the pointers (I<key> or I<value> or I<log_buf> or I<insns>)  is "
"outside the accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1032
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1039
msgid "For B<BPF_MAP_CREATE>, either I<map_type> or attributes are invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1048
msgid ""
"For B<BPF_MAP_*_ELEM> commands, some of the fields of I<union bpf_attr> that "
"are not used by this command are not set to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1056
msgid ""
"For B<BPF_PROG_LOAD>, indicates an attempt to load an invalid program.  eBPF "
"programs can be deemed invalid due to unrecognized instructions, the use of "
"reserved fields, jumps out of range, infinite loops or calls of unknown "
"functions."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1065
msgid ""
"For B<BPF_MAP_LOOKUP_ELEM> or B<BPF_MAP_DELETE_ELEM>, indicates that the "
"element with the given I<key> was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1068
msgid "Cannot allocate sufficient memory."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1074
msgid ""
"The call was made without sufficient privilege (without the B<CAP_SYS_ADMIN> "
"capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1078
msgid "The B<bpf>()  system call first appeared in Linux 3.18."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1082
msgid "The B<bpf>()  system call is Linux-specific."
msgstr ""

#.  commit 1be7f75d1668d6296b80bf35dcf6762393530afc
#.  [Linux 5.6] mtk: The list of available functions is, I think, governed
#.  by the check in net/core/filter.c::bpf_base_func_proto().
#. type: Plain text
#: build/C/man2/bpf.2:1097
msgid ""
"Prior to Linux 4.4, all B<bpf>()  commands require the caller to have the "
"B<CAP_SYS_ADMIN> capability.  From Linux 4.4 onwards, an unprivileged user "
"may create limited programs of type B<BPF_PROG_TYPE_SOCKET_FILTER> and "
"associated maps.  However they may not store kernel pointers within the maps "
"and are presently limited to the following helper functions:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1099
msgid "get_random"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1102
msgid "get_smp_processor_id"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1104
msgid "tail_call"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1106
msgid "ktime_get_ns"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1110
msgid ""
"Unprivileged access may be blocked by writing the value 1 to the file "
"I</proc/sys/kernel/unprivileged_bpf_disabled>."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1123
msgid ""
"eBPF objects (maps and programs) can be shared between processes.  For "
"example, after B<fork>(2), the child inherits file descriptors referring to "
"the same eBPF objects.  In addition, file descriptors referring to eBPF "
"objects can be transferred over UNIX domain sockets.  File descriptors "
"referring to eBPF objects can be duplicated in the usual way, using "
"B<dup>(2)  and similar calls.  An eBPF object is deallocated only after all "
"file descriptors referring to the object have been closed."
msgstr ""

#.  There are also examples for the tc classifier, in the iproute2
#.  project, in examples/bpf
#. type: Plain text
#: build/C/man2/bpf.2:1135
msgid ""
"eBPF programs can be written in a restricted C that is compiled (using the "
"B<clang> compiler) into eBPF bytecode.  Various features are omitted from "
"this restricted C, such as loops, global variables, variadic functions, "
"floating-point numbers, and passing structures as function arguments.  Some "
"examples can be found in the I<samples/bpf/*_kern.c> files in the kernel "
"source tree."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1143
msgid ""
"The kernel contains a just-in-time (JIT) compiler that translates eBPF "
"bytecode into native machine code for better performance.  In kernels before "
"Linux 4.15, the JIT compiler is disabled by default, but its operation can "
"be controlled by writing one of the following integer strings to the file "
"I</proc/sys/net/core/bpf_jit_enable>:"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1143 build/C/man7/bpf-helpers.7:1325 build/C/man7/bpf-helpers.7:1661 build/C/man7/bpf-helpers.7:1781 build/C/man7/bpf-helpers.7:1803 build/C/man7/bpf-helpers.7:2221 build/C/man7/bpf-helpers.7:2251 build/C/man7/bpf-helpers.7:2526 build/C/man7/bpf-helpers.7:2595 build/C/man7/bpf-helpers.7:2606
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1145
msgid "Disable JIT compilation (default)."
msgstr ""

#. type: IP
#: build/C/man2/bpf.2:1145
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1147
msgid "Normal compilation."
msgstr ""

#. type: IP
#: build/C/man2/bpf.2:1147
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1153
msgid ""
"Debugging mode.  The generated opcodes are dumped in hexadecimal into the "
"kernel log.  These opcodes can then be disassembled using the program "
"I<tools/net/bpf_jit_disasm.c> provided in the kernel source tree."
msgstr ""

#.  commit 290af86629b25ffd1ed6232c4e9107da031705cb
#. type: Plain text
#: build/C/man2/bpf.2:1164
msgid ""
"Since Linux 4.15, the kernel may configured with the "
"B<CONFIG_BPF_JIT_ALWAYS_ON> option.  In this case, the JIT compiler is "
"always enabled, and the I<bpf_jit_enable> is initialized to 1 and is "
"immutable.  (This kernel configuration option was provided as a mitigation "
"for one of the Spectre attacks against the BPF interpreter.)"
msgstr ""

#.  Last reviewed in Linux 4.18-rc by grepping for BPF_ALU64 in arch/
#.  and by checking the documentation for bpf_jit_enable in
#.  Documentation/sysctl/net.txt
#. type: Plain text
#: build/C/man2/bpf.2:1170
msgid ""
"The JIT compiler for eBPF is currently available for the following "
"architectures:"
msgstr ""

#.  commit 0a14842f5a3c0e88a1e59fac5c3025db39721f74
#. type: Plain text
#: build/C/man2/bpf.2:1173
msgid "x86-64 (since Linux 3.18; cBPF since Linux 3.0);"
msgstr ""

#.  commit ddecdfcea0ae891f782ae853771c867ab51024c2
#. type: Plain text
#: build/C/man2/bpf.2:1177
msgid "ARM32 (since Linux 3.18; cBPF since Linux 3.4);"
msgstr ""

#.  commit 2809a2087cc44b55e4377d7b9be3f7f5d2569091
#. type: Plain text
#: build/C/man2/bpf.2:1180
msgid "SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);"
msgstr ""

#.  commit e54bcde3d69d40023ae77727213d14f920eb264a
#. type: Plain text
#: build/C/man2/bpf.2:1183
msgid "ARM-64 (since Linux 3.18);"
msgstr ""

#.  commit c10302efe569bfd646b4c22df29577a4595b4580
#. type: Plain text
#: build/C/man2/bpf.2:1186
msgid "s390 (since Linux 4.1; cBPF since Linux 3.7);"
msgstr ""

#.  commit 0ca87f05ba8bdc6791c14878464efc901ad71e99
#.  commit 156d0e290e969caba25f1851c52417c14d141b24
#. type: Plain text
#: build/C/man2/bpf.2:1190
msgid "PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);"
msgstr ""

#.  commit 7a12b5031c6b947cc13918237ae652b536243b76
#. type: Plain text
#: build/C/man2/bpf.2:1193
msgid "SPARC 64 (since Linux 4.12);"
msgstr ""

#.  commit 03f5781be2c7b7e728d724ac70ba10799cc710d7
#. type: Plain text
#: build/C/man2/bpf.2:1196
msgid "x86-32 (since Linux 4.18);"
msgstr ""

#.  commit c6610de353da5ca6eee5b8960e838a87a90ead0c
#.  commit f381bf6d82f032b7410185b35d000ea370ac706b
#. type: Plain text
#: build/C/man2/bpf.2:1200
msgid "MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);"
msgstr ""

#.  commit 2353ecc6f91fd15b893fa01bf85a1c7a823ee4f2
#. type: Plain text
#: build/C/man2/bpf.2:1203
msgid "riscv (since Linux 5.1)."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1219
#, no-wrap
msgid ""
"/* bpf+sockets example:\n"
" * 1. create array map of 256 elements\n"
" * 2. load program that counts number of packets received\n"
" *    r0 = skb-E<gt>data[ETH_HLEN + offsetof(struct iphdr, protocol)]\n"
" *    map[r0]++\n"
" * 3. attach prog_fd to raw socket via setsockopt()\n"
" * 4. print number of received TCP/UDP packets every second\n"
" */\n"
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int sock, map_fd, prog_fd, key;\n"
"    long long value = 0, tcp_cnt, udp_cnt;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1227
#, no-wrap
msgid ""
"    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),\n"
"                            sizeof(value), 256);\n"
"    if (map_fd E<lt> 0) {\n"
"        printf(\"failed to create map \\(aq%s\\(aq\\en\", "
"strerror(errno));\n"
"        /* likely not run as root */\n"
"        return 1;\n"
"    }\n"
msgstr ""

#.                                 == atomic64_add
#. type: Plain text
#: build/C/man2/bpf.2:1248
#, no-wrap
msgid ""
"    struct bpf_insn prog[] = {\n"
"        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */\n"
"        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),\n"
"                                /* r0 = ip-E<gt>proto */\n"
"        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n"
"                                /* *(u32 *)(fp - 4) = r0 */\n"
"        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */\n"
"        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */\n"
"        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */\n"
"        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),\n"
"                                /* r0 = map_lookup(r1, r2) */\n"
"        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n"
"                                /* if (r0 == 0) goto pc+2 */\n"
"        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */\n"
"        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),\n"
"                                /* lock *(u64 *) r0 += r1 */\n"
"        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */\n"
"        BPF_EXIT_INSN(),                            /* return r0 */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1251
#, no-wrap
msgid ""
"    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,\n"
"                            sizeof(prog) / sizeof(prog[0]), \"GPL\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1253
#, no-wrap
msgid "    sock = open_raw_sock(\"lo\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1256
#, no-wrap
msgid ""
"    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,\n"
"                      sizeof(prog_fd)) == 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1265
#, no-wrap
msgid ""
"    for (;;) {\n"
"        key = IPPROTO_TCP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);\n"
"        key = IPPROTO_UDP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);\n"
"        printf(\"TCP %lld UDP %lld packets\\en\", tcp_cnt, udp_cnt);\n"
"        sleep(1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1268
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1273
msgid ""
"Some complete working code can be found in the I<samples/bpf> directory in "
"the kernel source tree."
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1279
msgid "B<seccomp>(2), B<bpf-helpers>(7), B<socket>(7), B<tc>(8), B<tc-bpf>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/bpf.2:1282
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>."
msgstr ""

#. type: TH
#: build/C/man2/connect.2:67
#, no-wrap
msgid "CONNECT"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:70
msgid "connect - initiate a connection on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:77
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:96
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:112
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM>, then I<addr> is the "
"address to which datagrams are sent by default, and the only address from "
"which datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:117
msgid ""
"Some protocol sockets (e.g., UNIX domain stream sockets)  may successfully "
"B<connect>()  only once."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:123
msgid ""
"Some protocol sockets (e.g., datagram sockets in the UNIX and Internet "
"domains)  may use B<connect>()  multiple times to change their association."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:136
msgid ""
"Some protocol sockets (e.g., TCP sockets as well as datagram sockets in the "
"UNIX and Internet domains)  may dissolve the association by connecting to an "
"address with the I<sa_family> member of I<sockaddr> set to B<AF_UNSPEC>; "
"thereafter, the socket can be connected to another address.  (B<AF_UNSPEC> "
"is supported on Linux since kernel 2.2.)"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:141
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:144
msgid ""
"The following are general socket errors only.  There may be other "
"domain-specific error codes."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:152
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/connect.2:152
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:157
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:164
msgid ""
"B<EACCES> can also be returned if an SELinux policy denied a connection (for "
"example, if there is a policy saying that an HTTP proxy can only connect to "
"ports associated with HTTP servers, and the proxy tries to connect to a "
"different port).  dd"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:167
msgid "Local address is already in use."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:180 build/C/man2/listen.2:103
msgid ""
"(Internet domain sockets)  The socket referred to by I<sockfd> had not "
"previously been bound to an address and, upon attempting to bind it to an "
"ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> in B<ip>(7)."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:180 build/C/man2/socket.2:426 build/C/man2/socketpair.2:85
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:185
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:185 build/C/man2/send.2:347
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:190
msgid ""
"For nonblocking UNIX domain sockets, the socket is nonblocking, and the "
"connection cannot be completed immediately.  For other socket families, "
"there are insufficient entries in the routing cache."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:190 build/C/man2/send.2:360
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:194
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:198 build/C/man2/send.2:367
msgid "I<sockfd> is not a valid open file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:198 build/C/man2/recv.2:469
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:203
msgid ""
"A B<connect>()  on a stream socket found no one listening on the remote "
"address."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:206
msgid "The socket structure address is outside the user's address space."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:206
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:233
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  (UNIX domain sockets failed with B<EAGAIN> instead.)  It is "
"possible to B<select>(2)  or B<poll>(2)  for completion by selecting the "
"socket for writing.  After B<select>(2)  indicates writability, use "
"B<getsockopt>(2)  to read the B<SO_ERROR> option at level B<SOL_SOCKET> to "
"determine whether B<connect>()  completed successfully (B<SO_ERROR> is zero) "
"or unsuccessfully (B<SO_ERROR> is one of the usual error codes listed here, "
"explaining the reason for the failure)."
msgstr ""

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: build/C/man2/connect.2:239
msgid ""
"The system call was interrupted by a signal that was caught; see "
"B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:239 build/C/man2/send.2:383
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:242
msgid "The socket is already connected."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:242
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:245
msgid "Network is unreachable."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:250
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:255
msgid ""
"The socket type does not support the requested communications protocol.  "
"This error can occur, for example, on an attempt to connect a UNIX domain "
"datagram socket to a stream socket."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:255
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:262
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: build/C/man2/connect.2:278
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (connectB<()> first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:295
msgid ""
"If B<connect>()  fails, consider the state of the socket as unspecified.  "
"Portable applications should close the socket and create a new one for "
"reconnecting."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:300
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:308
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7), B<selinux>(8)"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:36 build/C/man3/if_nameindex.3:26 build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing "
"the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: build/C/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a null pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a null pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be "
"freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr ""

#. type: tbl table
#: build/C/man3/getifaddrs.3:181
#, no-wrap
msgid ""
"B<getifaddrs>(),\n"
"B<freeifaddrs>()"
msgstr ""

#. type: tbl table
#: build/C/man3/getifaddrs.3:181 build/C/man3/if_nameindex.3:116 build/C/man3/if_nametoindex.3:104 build/C/man3/sockatmark.3:83
#, no-wrap
msgid "MT-Safe"
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: build/C/man3/getifaddrs.3:204
msgid ""
"Not in POSIX.1.  This function first appeared in BSDi and is present on the "
"BSD systems, but with slightly different semantics documented\\(emreturning "
"one entry per interface, not per address.  This means I<ifa_addr> and other "
"fields can actually be NULL if the interface has no address, and no "
"link-level address is returned if the interface has an IP address assigned.  "
"Also, the way of choosing either I<ifa_broadaddr> or I<ifa_dstaddr> differs "
"on various systems."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:221
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in "
"I<E<lt>linux/netdevice.hE<gt>>), which contains various interface attributes "
"and statistics."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:228
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(), "
"and B<getnameinfo>(3).  Here is what we see when running this program on one "
"system:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:249
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"
msgstr ""

#. type: SS
#: build/C/man3/getifaddrs.3:251 build/C/man3/if_nameindex.3:136 build/C/man2/recvmmsg.2:224
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:263
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:269
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:274
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:277
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:282
#, no-wrap
msgid ""
"    for (struct ifaddrs *ifa = ifaddr; ifa != NULL;\n"
"             ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:284
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:287
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:294
#, no-wrap
msgid ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:296
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:307
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:309
#, no-wrap
msgid "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:312
#, no-wrap
msgid ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:319
#, no-wrap
msgid ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:323
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:330
msgid "B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:46
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:78 build/C/man2/getsockopt.2:145 build/C/man2/listen.2:108
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:84
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:88
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: build/C/man2/getsockname.2:88 build/C/man3/if_nameindex.3:83 build/C/man2/send.2:395
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:92
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: build/C/man2/getsockname.2:103
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:115
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:56
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:66
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:85
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:107
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:117
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:126
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:130
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:135
msgid ""
"On success, zero is returned for the standard options.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:139
msgid ""
"Netfilter allows the programmer to define custom socket options with "
"associated handlers; for such options, the return value on success is the "
"value returned by the handler."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:155
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:166
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""

#. type: TP
#: build/C/man2/getsockopt.2:166 build/C/man7/vsock.7:196
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:169
msgid "The option is unknown at the level indicated."
msgstr ""

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: build/C/man2/getsockopt.2:181
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these system calls first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:195
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:206
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/if_nameindex.3:26
#, no-wrap
msgid "IF_NAMEINDEX"
msgstr ""

#. type: TH
#: build/C/man3/if_nameindex.3:26 build/C/man2/listen.2:45 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25 build/C/man2/socket.2:42 build/C/man2/socketpair.2:42
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:29
msgid "if_nameindex, if_freenameindex - get network interface names and indexes"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:32 build/C/man3/if_nametoindex.3:32
#, no-wrap
msgid "B<#include E<lt>net/if.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:35
#, no-wrap
msgid ""
"B<struct if_nameindex *if_nameindex(>I<void>B<);>\n"
"B<void if_freenameindex(struct if_nameindex *>I<ptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:46
msgid ""
"The B<if_nameindex>()  function returns an array of I<if_nameindex> "
"structures, each containing information about one of the network interfaces "
"on the local system.  The I<if_nameindex> structure contains at least the "
"following entries:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:51
#, no-wrap
msgid ""
"unsigned int if_index; /* Index of interface (1, 2, ...) */\n"
"char        *if_name;  /* Null-terminated name (\"eth0\", etc.) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:65
msgid ""
"The I<if_index> field contains the interface index.  The I<if_name> field "
"points to the null-terminated interface name.  The end of the array is "
"indicated by entry with I<if_index> set to zero and I<if_name> set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:71
msgid ""
"The data structure returned by B<if_nameindex>()  is dynamically allocated "
"and should be freed using B<if_freenameindex>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:78
msgid ""
"On success, B<if_nameindex>()  returns pointer to the array; on error, NULL "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:83
msgid "B<if_nameindex>()  may fail and set I<errno> if:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:86
msgid "Insufficient resources available."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:97
msgid ""
"B<if_nameindex>()  may also fail for any of the errors specified for "
"B<socket>(2), B<bind>(2), B<ioctl>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), or B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:104
msgid ""
"The B<if_nameindex>()  function first appeared in glibc 2.1, but before "
"glibc 2.3.4, the implementation supported only interfaces with IPv4 "
"addresses.  Support of interfaces that don't have IPv4 addresses is "
"available only on kernels that support netlink."
msgstr ""

#. type: tbl table
#: build/C/man3/if_nameindex.3:114
#, no-wrap
msgid "B<if_nameindex>(),\n"
msgstr ""

#. type: tbl table
#: build/C/man3/if_nameindex.3:116
#, no-wrap
msgid "B<if_freenameindex>()"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:121 build/C/man3/if_nametoindex.3:108
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 3493."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:123 build/C/man3/if_nametoindex.3:110
msgid "This function first appeared in BSDi."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:127
msgid ""
"The program below demonstrates the use of the functions described on this "
"page.  An example of the output this program might produce is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:134
#, no-wrap
msgid ""
"$ B<./a.out>I<\n"
"1: lo\n"
"2: wlan0\n"
"3: em1>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:142
#, no-wrap
msgid ""
"#include E<lt>net/if.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:147
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct if_nameindex *if_ni, *i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:153
#, no-wrap
msgid ""
"    if_ni = if_nameindex();\n"
"    if (if_ni == NULL) {\n"
"        perror(\"if_nameindex\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:156
#, no-wrap
msgid ""
"    for (i = if_ni; ! (i-E<gt>if_index == 0 && i-E<gt>if_name == NULL); "
"i++)\n"
"        printf(\"%u: %s\\en\", i-E<gt>if_index, i-E<gt>if_name);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:158
#, no-wrap
msgid "    if_freenameindex(if_ni);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:161 build/C/man2/select.2:745
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:169
msgid ""
"B<getsockopt>(2), B<setsockopt>(2), B<getifaddrs>(3), B<if_indextoname>(3), "
"B<if_nametoindex>(3), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "IF_NAMETOINDEX"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:29
msgid ""
"if_nametoindex, if_indextoname - mappings between network interface names "
"and indexes"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:34
#, no-wrap
msgid "B<unsigned int if_nametoindex(const char *>I<ifname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:36
#, no-wrap
msgid "B<char *if_indextoname(unsigned int ifindex, char *>I<ifname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:43
msgid ""
"The B<if_nametoindex>()  function returns the index of the network interface "
"corresponding to the name I<ifname>."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:54
msgid ""
"The B<if_indextoname>()  function returns the name of the network interface "
"corresponding to the interface index I<ifindex>.  The name is placed in the "
"buffer pointed to by I<ifname>.  The buffer must allow for the storage of at "
"least B<IF_NAMESIZE> bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:61
msgid ""
"On success, B<if_nametoindex>()  returns the index number of the network "
"interface; on error, 0 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:69
msgid ""
"On success, B<if_indextoname>()  returns I<ifname>; on error, NULL is "
"returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:74
msgid "B<if_nametoindex>()  may fail and set I<errno> if:"
msgstr ""

#. type: TP
#: build/C/man3/if_nametoindex.3:74
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:77
msgid "No interface found with given name."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:82
msgid "B<if_indextoname>()  may fail and set I<errno> if:"
msgstr ""

#. type: TP
#: build/C/man3/if_nametoindex.3:82
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:85
msgid "No interface found for the index."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:93
msgid ""
"B<if_nametoindex>()  and B<if_indextoname>()  may also fail for any of the "
"errors specified for B<socket>(2)  or B<ioctl>(2)."
msgstr ""

#. type: tbl table
#: build/C/man3/if_nametoindex.3:104
#, no-wrap
msgid ""
"B<if_nametoindex>(),\n"
"B<if_indextoname>()"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:114
msgid "B<getifaddrs>(3), B<if_nameindex>(3), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man2/listen.2:45
#, no-wrap
msgid "LISTEN"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:48
msgid "listen - listen for connections on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:54
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:62
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:69
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:81
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:90
msgid "Another socket is already listening on the same port."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:118
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:122
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<listen>()  first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:124
msgid "To accept connections, the following steps are performed:"
msgstr ""

#. type: TP
#: build/C/man2/listen.2:125 build/C/man2/select_tut.2:192
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:128
msgid "A socket is created with B<socket>(2)."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:128 build/C/man2/select_tut.2:201
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:134
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:134 build/C/man2/select_tut.2:205
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:138
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:138 build/C/man2/select_tut.2:212
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:141
msgid "Connections are accepted with B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:164
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: build/C/man2/listen.2:178
msgid ""
"If the I<backlog> argument is greater than the value in "
"I</proc/sys/net/core/somaxconn>, then it is silently truncated to that "
"value.  Since Linux 5.4, the default in this file is 4096; in earlier "
"kernels, the default value is 128.  In kernels before 2.4.25, this limit was "
"a hard coded value, B<SOMAXCONN>, with the value 128."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:187
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:50 build/C/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:52
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:55
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:57
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:69
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:84
msgid ""
"The only difference between B<recv>()  and B<read>(2)  is the presence of "
"I<flags>.  With a zero I<flags> argument, B<recv>()  is generally equivalent "
"to B<read>(2)  (but see NOTES).  Also, the following call"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:86
#, no-wrap
msgid "    recv(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:88 build/C/man2/send.2:88
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:90
#, no-wrap
msgid "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:96
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:106
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:113
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""

#. type: SS
#: build/C/man2/recv.2:113 build/C/man2/send.2:160
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:117
msgid ""
"The I<flags> argument is formed by ORing one or more of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:117
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:128
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:128 build/C/man2/send.2:188
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:147
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK>.  This provides similar behavior "
"to setting the B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> "
"operation), but differs in that B<MSG_DONTWAIT> is a per-call option, "
"whereas B<O_NONBLOCK> is a setting on the open file description (see "
"B<open>(2)), which will affect all threads in the calling process and as "
"well as other processes that hold file descriptors referring to the same "
"open file description."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:147
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:166
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:170
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:177
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:189
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:191
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:215
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:229
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> flag is set in the I<msghdr>.  After an error has been "
"passed, the pending socket error is regenerated based on the next queued "
"error and will be passed on the next socket operation."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:229 build/C/man2/recv.2:427 build/C/man2/send.2:249
#, no-wrap
msgid "B<MSG_OOB>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:236
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:236
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:243
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:243
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr ""

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: build/C/man2/recv.2:253
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:256
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:256
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:265
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned.  This flag has no effect "
"for datagram sockets."
msgstr ""

#. type: SS
#: build/C/man2/recv.2:265
#, no-wrap
msgid "recvfrom()"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:271
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: build/C/man2/recv.2:299
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if "
"the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:306
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""

#. type: SS
#: build/C/man2/recv.2:306
#, no-wrap
msgid "recv()"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:314
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:317
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: SS
#: build/C/man2/recv.2:317
#, no-wrap
msgid "recvmsg()"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:325
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:332
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:342
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags on received message */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:358
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_namelen> will contain the length of the "
"returned address.  If the application does not need to know the source "
"address, I<msg_name> can be specified as NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:365
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:380
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:382
msgid "The messages are of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:393
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:398
msgid "Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:406
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets.  For "
"further information on the use of ancillary data in various socket domains, "
"see B<unix>(7)  and B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:414
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:414
#, no-wrap
msgid "B<MSG_EOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:419
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:419
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:423
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:423
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:427
msgid ""
"indicates that some control data was discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:430
msgid "is returned to indicate that expedited or out-of-band data was received."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:430
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:434
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:440
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  In the event of an error, I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:443
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:447
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:450
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive "
"from a stream socket was 0."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:455
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/recv.2:464
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1 allows either error to be returned for this case, and "
"does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:469
msgid "The argument I<sockfd> is an invalid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:473
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:477
msgid "The receive buffer pointer(s) point outside the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:482
msgid ""
"The receive was interrupted by delivery of a signal before any data was "
"available; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:486 build/C/man2/send.2:383
msgid "Invalid argument passed."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:490
msgid "Could not allocate memory for B<recvmsg>()."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:490 build/C/man2/send.2:406 build/C/man7/vsock.7:202
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:497
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:505
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:512
msgid ""
"POSIX.1 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:525
msgid ""
"If a zero-length datagram is pending, B<read>(2)  and B<recv>()  with a "
"I<flags> argument of zero provide different behavior.  In this circumstance, "
"B<read>(2)  has no effect (the datagram remains pending), while B<recv>()  "
"consumes the pending datagram."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:531
msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#.  glibc bug for msg_controllen raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type these fields varies
#.  across architectures, but socklen_t is always 32 bits,
#.  as (at least with GCC) is int.
#. type: Plain text
#: build/C/man2/recv.2:552
msgid ""
"According to POSIX.1, the I<msg_controllen> field of the I<msghdr> structure "
"should be typed as I<socklen_t>, and the I<msg_iovlen> field should be typed "
"as I<int>, but glibc currently types both as I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:557
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:562
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:578
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:38 build/C/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:42
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:54
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:58
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:66 build/C/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:72 build/C/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:79
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:94
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:101
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: build/C/man2/recvmmsg.2:101
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:106
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:121
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:132
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:147
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:155
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:159
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:163
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:165
msgid "See also BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: build/C/man2/recvmmsg.2:184
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:192
msgid ""
"If an error occurs after at least one message has been received, the call "
"succeeds, and returns the number of messages received.  The error code is "
"expected to be returned on a subsequent call to B<recvmmsg>().  In the "
"current implementation, however, the error code can be overwritten in the "
"meantime by an unrelated network event on a socket, for example an incoming "
"ICMP packet."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:199
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers "
"are filled or if the timeout specified has expired."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:202
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:207
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234;>\n"
"B<sleep 0.25; done>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:212
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:222
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:233
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:246
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:252 build/C/man2/sendmmsg.2:210
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:260
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:268
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (int i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:271
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:277
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:285
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (int i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:293
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/select.2:40
#, no-wrap
msgid "SELECT"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:44
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:47
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:50
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:55
#, no-wrap
msgid ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:59
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:64 build/C/man3/sockatmark.3:36
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:68
msgid "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:79
msgid ""
"B<select>()  allows a program to monitor multiple file descriptors, waiting "
"until one or more of the file descriptors become \"ready\" for some class of "
"I/O operation (e.g., input possible).  A file descriptor is considered ready "
"if it is possible to perform a corresponding I/O operation (e.g., "
"B<read>(2), or a sufficiently small B<write>(2))  without blocking."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:89
msgid ""
"B<select>()  can monitor only file descriptors numbers that are less than "
"B<FD_SETSIZE>; B<poll>(2)  and B<epoll>(7)  do not have this limitation.  "
"See BUGS."
msgstr ""

#. type: SS
#: build/C/man2/select.2:89
#, no-wrap
msgid "File descriptor sets"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:100
msgid ""
"The principal arguments of B<select>()  are three \"sets\" of file "
"descriptors (declared with the type I<fd_set>), which allow the caller to "
"wait for three classes of events on the specified set of file descriptors.  "
"Each of the I<fd_set> arguments may be specified as NULL if no file "
"descriptors are to be watched for the corresponding class of events."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:113
msgid ""
"B<Note well>: Upon return, each of the file descriptor sets is modified in "
"place to indicate which file descriptors are currently \"ready\".  Thus, if "
"using B<select>()  within a loop, the sets I<must be reinitialized> before "
"each call.  The implementation of the I<fd_set> arguments as value-result "
"arguments is a design error that is avoided in B<poll>(2)  and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:116
msgid ""
"The contents of a file descriptor set can be manipulated using the following "
"macros:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:116
#, no-wrap
msgid "B<FD_ZERO>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:121
msgid ""
"This macro clears (removes all file descriptors from)  I<set>.  It should be "
"employed as the first step in initializing a file descriptor set."
msgstr ""

#. type: TP
#: build/C/man2/select.2:121
#, no-wrap
msgid "B<FD_SET>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:129
msgid ""
"This macro adds the file descriptor I<fd> to I<set>.  Adding a file "
"descriptor that is already present in the set is a no-op, and does not "
"produce an error."
msgstr ""

#. type: TP
#: build/C/man2/select.2:129
#, no-wrap
msgid "B<FD_CLR>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:137
msgid ""
"This macro removes the file descriptor I<fd> from I<set>.  Removing a file "
"descriptor that is not present in the set is a no-op, and does not produce "
"an error."
msgstr ""

#. type: TP
#: build/C/man2/select.2:137
#, no-wrap
msgid "B<FD_ISSET>()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:155
msgid ""
"B<select>()  modifies the contents of the sets according to the rules "
"described below.  After calling B<select>(), the B<FD_ISSET>()  macro can be "
"used to test if a file descriptor is still present in a set.  B<FD_ISSET>()  "
"returns nonzero if the file descriptor I<fd> is present in I<set>, and zero "
"if it is not."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:159
msgid "The arguments of B<select>()  are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:159
#, no-wrap
msgid "I<readfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:165
msgid ""
"The file descriptors in this set are watched to see if they are ready for "
"reading.  A file descriptor is ready for reading if a read operation will "
"not block; in particular, a file descriptor is also ready on end-of-file."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:170
msgid ""
"After B<select>()  has returned, I<readfds> will be cleared of all file "
"descriptors except for those that are ready for reading."
msgstr ""

#. type: TP
#: build/C/man2/select.2:170
#, no-wrap
msgid "I<writefds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:177
msgid ""
"The file descriptors in this set are watched to see if they are ready for "
"writing.  A file descriptor is ready for writing if a write operation will "
"not block.  However, even if a file descriptor indicates as writable, a "
"large write may still block."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:182
msgid ""
"After B<select>()  has returned, I<writefds> will be cleared of all file "
"descriptors except for those that are ready for writing."
msgstr ""

#. type: TP
#: build/C/man2/select.2:182
#, no-wrap
msgid "I<exceptfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:189
msgid ""
"The file descriptors in this set are watched for \"exceptional "
"conditions\".  For examples of some exceptional conditions, see the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:195
msgid ""
"After B<select>()  has returned, I<exceptfds> will be cleared of all file "
"descriptors except for those for which an exceptional condition has "
"occurred."
msgstr ""

#. type: TP
#: build/C/man2/select.2:195
#, no-wrap
msgid "I<nfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:201
msgid ""
"This argument should be set to the highest-numbered file descriptor in any "
"of the three sets, plus 1.  The indicated file descriptors in each set are "
"checked, up to this limit (but see BUGS)."
msgstr ""

#. type: TP
#: build/C/man2/select.2:201
#, no-wrap
msgid "I<timeout>"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:211
msgid ""
"The I<timeout> argument is a I<timeval> structure (shown below) that "
"specifies the interval that B<select>()  should block waiting for a file "
"descriptor to become ready.  The call will block until either:"
msgstr ""

#. type: IP
#: build/C/man2/select.2:212 build/C/man2/select.2:214 build/C/man2/select.2:216 build/C/man2/select.2:250 build/C/man2/select.2:259 build/C/man2/select.2:266 build/C/man7/bpf-helpers.7:225 build/C/man7/bpf-helpers.7:227 build/C/man7/bpf-helpers.7:229 build/C/man7/bpf-helpers.7:232 build/C/man7/bpf-helpers.7:239 build/C/man7/bpf-helpers.7:241 build/C/man7/bpf-helpers.7:244 build/C/man7/bpf-helpers.7:783 build/C/man7/bpf-helpers.7:785 build/C/man7/bpf-helpers.7:787 build/C/man7/bpf-helpers.7:883 build/C/man7/bpf-helpers.7:886 build/C/man7/bpf-helpers.7:889 build/C/man7/bpf-helpers.7:1016 build/C/man7/bpf-helpers.7:1018 build/C/man7/bpf-helpers.7:1020 build/C/man7/bpf-helpers.7:1086 build/C/man7/bpf-helpers.7:1088 build/C/man7/bpf-helpers.7:1090 build/C/man7/bpf-helpers.7:1339 build/C/man7/bpf-helpers.7:1341 build/C/man7/bpf-helpers.7:1349 build/C/man7/bpf-helpers.7:1354 build/C/man7/bpf-helpers.7:1360 build/C/man7/bpf-helpers.7:1362 build/C/man7/bpf-helpers.7:1381 build/C/man7/bpf-helpers.7:1388 build/C/man7/bpf-helpers.7:1391 build/C/man7/bpf-helpers.7:1398 build/C/man7/bpf-helpers.7:1401 build/C/man7/bpf-helpers.7:1406 build/C/man7/bpf-helpers.7:1410 build/C/man7/bpf-helpers.7:1611 build/C/man7/bpf-helpers.7:1613 build/C/man7/bpf-helpers.7:1621 build/C/man7/bpf-helpers.7:1624 build/C/man7/bpf-helpers.7:1626 build/C/man7/bpf-helpers.7:1683 build/C/man7/bpf-helpers.7:1685 build/C/man7/bpf-helpers.7:1687 build/C/man7/bpf-helpers.7:1689 build/C/man7/bpf-helpers.7:1705 build/C/man7/bpf-helpers.7:1707 build/C/man7/bpf-helpers.7:1709 build/C/man7/bpf-helpers.7:1711 build/C/man7/bpf-helpers.7:1713 build/C/man7/bpf-helpers.7:1751 build/C/man7/bpf-helpers.7:1755 build/C/man7/bpf-helpers.7:2005 build/C/man7/bpf-helpers.7:2007 build/C/man7/bpf-helpers.7:2009 build/C/man7/bpf-helpers.7:2541 build/C/man7/bpf-helpers.7:2545 build/C/man7/bpf-helpers.7:2547 build/C/man7/bpf-helpers.7:2550 build/C/man7/bpf-helpers.7:2552 build/C/man7/bpf-helpers.7:2555 build/C/man7/bpf-helpers.7:2558 build/C/man7/bpf-helpers.7:2561 build/C/man7/bpf-helpers.7:2566 build/C/man7/bpf-helpers.7:2571 build/C/man7/bpf-helpers.7:2574 build/C/man7/bpf-helpers.7:2577 build/C/man7/bpf-helpers.7:2580 build/C/man7/bpf-helpers.7:2583 build/C/man7/bpf-helpers.7:2585 build/C/man7/bpf-helpers.7:2589 build/C/man7/bpf-helpers.7:3249 build/C/man7/bpf-helpers.7:3253 build/C/man7/bpf-helpers.7:3264 build/C/man7/bpf-helpers.7:3267 build/C/man7/bpf-helpers.7:3271 build/C/man7/bpf-helpers.7:3273 build/C/man7/bpf-helpers.7:3277 build/C/man7/bpf-helpers.7:3442 build/C/man7/bpf-helpers.7:3444 build/C/man7/bpf-helpers.7:3446 build/C/man7/bpf-helpers.7:3448 build/C/man7/bpf-helpers.7:3481 build/C/man7/bpf-helpers.7:3484 build/C/man7/bpf-helpers.7:3487 build/C/man7/bpf-helpers.7:3490 build/C/man7/bpf-helpers.7:3600 build/C/man7/bpf-helpers.7:3602 build/C/man7/bpf-helpers.7:3636 build/C/man7/bpf-helpers.7:3640 build/C/man7/bpf-helpers.7:3643 build/C/man7/bpf-helpers.7:3646 build/C/man7/bpf-helpers.7:3649 build/C/man7/bpf-helpers.7:3652
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:214
msgid "a file descriptor becomes ready;"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:216
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:218
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:225
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:232
msgid ""
"If both fields of the I<timeval> structure are zero, then B<select>()  "
"returns immediately.  (This is useful for polling.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:239
msgid ""
"If I<timeout> is specified as NULL, B<select>()  blocks indefinitely waiting "
"for a file descriptor to become ready."
msgstr ""

#. type: SS
#: build/C/man2/select.2:239
#, no-wrap
msgid "pselect()"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:244
msgid ""
"The B<pselect>()  system call allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:250
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:259
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:266
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:274
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:290
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask.  (If I<sigmask> is NULL, the signal mask "
"is not modified during the B<pselect>()  call.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:296
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:301
#, no-wrap
msgid ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:307
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:311
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:315
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:337
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""

#. type: SS
#: build/C/man2/select.2:337
#, no-wrap
msgid "The timeout"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:343
msgid ""
"The I<timeout> argument for B<select>()  is a structure of the following "
"type:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:350
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:356
msgid "The corresponding argument for B<pselect>()  has the following type:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:363
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    long        tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: build/C/man2/select.2:388
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1 permits either "
"behavior.)  This causes problems both when Linux code which reads I<timeout> "
"is ported to other operating systems, and when code is ported to Linux that "
"reuses a I<struct timeval> for multiple B<select>()s in a loop without "
"reinitializing it.  Consider I<timeout> to be undefined after B<select>()  "
"returns."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:400
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, "
"I<exceptfds>).  The return value may be zero if the timeout expired before "
"any file descriptors became ready."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:408
msgid ""
"On error, -1 is returned, and I<errno> is set to indicate the error; the "
"file descriptor sets are unmodified, and I<timeout> becomes undefined."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:415
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)  "
"However, see BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:419
msgid "A signal was caught; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:426
msgid ""
"I<nfds> is negative or exceeds the B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:431
msgid "The value contained within I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:434
msgid "Unable to allocate memory for internal tables."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:440
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:451
msgid ""
"B<select>()  conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (B<select>()  "
"first appeared in 4.2BSD).  Generally portable to/from non-BSD systems "
"supporting clones of the BSD socket layer (including System\\ V variants).  "
"However, note that the System\\ V variant typically sets the timeout "
"variable before returning, but the BSD variant does not."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:455
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:472
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:480
msgid ""
"The operation of B<select>()  and B<pselect>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: build/C/man2/select.2:498
msgid ""
"On some other UNIX systems, B<select>()  can fail with the error B<EAGAIN> "
"if the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX specifies this error for B<poll>(2), but not "
"for B<select>().  Portable programs may wish to check for B<EAGAIN> and "
"loop, just as with B<EINTR>."
msgstr ""

#. type: SS
#: build/C/man2/select.2:498
#, no-wrap
msgid "The self-pipe trick"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:512
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""

#. type: SS
#: build/C/man2/select.2:512
#, no-wrap
msgid "Emulating usleep(3)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:523
msgid ""
"Before the advent of B<usleep>(3), some code employed a call to B<select>()  "
"with all three sets empty, I<nfds> zero, and a non-NULL I<timeout> as a "
"fairly portable way to sleep with subsecond precision."
msgstr ""

#. type: SS
#: build/C/man2/select.2:523
#, no-wrap
msgid "Correspondence between select() and poll() notifications"
msgstr ""

#.  fs/select.c
#. type: Plain text
#: build/C/man2/select.2:533
msgid ""
"Within the Linux kernel source, we find the following definitions which show "
"the correspondence between the readable, writable, and exceptional condition "
"notifications of B<select>()  and the event notifications provided by "
"B<poll>(2)  and B<epoll>(7):"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:544
#, no-wrap
msgid ""
"#define POLLIN_SET  (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN |\n"
"                     EPOLLHUP | EPOLLERR)\n"
"                   /* Ready for reading */\n"
"#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT |\n"
"                     EPOLLERR)\n"
"                   /* Ready for writing */\n"
"#define POLLEX_SET  (EPOLLPRI)\n"
"                   /* Exceptional condition */\n"
msgstr ""

#. type: SS
#: build/C/man2/select.2:547
#, no-wrap
msgid "Multithreaded applications"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:564
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"process reopens file descriptor between the time B<select>()  returned and "
"the I/O operation is performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""

#. type: SS
#: build/C/man2/select.2:564
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:572
msgid ""
"The Linux kernel allows file descriptor sets of arbitrary size, determining "
"the length of the sets to be checked from the value of I<nfds>.  However, in "
"the glibc implementation, the I<fd_set> type is fixed in size.  See also "
"BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:580
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:595
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:601
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:609
#, no-wrap
msgid ""
"struct {\n"
"    const kernel_sigset_t *ss;   /* Pointer to signal set */\n"
"    size_t ss_len;               /* Size (in bytes) of object\n"
"                                    pointed to by \\(aqss\\(aq */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:621
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call.  See B<sigprocmask>(2)  for a "
"discussion of the difference between the kernel and libc notion of the "
"signal set."
msgstr ""

#. type: SS
#: build/C/man2/select.2:621
#, no-wrap
msgid "Historical glibc details"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:627
msgid ""
"Glibc 2.0 provided an incorrect version of B<pselect>()  that did not take a "
"I<sigmask> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:635
msgid ""
"In glibc versions 2.1 to 2.2.1, one must define B<_GNU_SOURCE> in order to "
"obtain the declaration of B<pselect>()  from I<E<lt>sys/select.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:653
msgid ""
"POSIX allows an implementation to define an upper limit, advertised via the "
"constant B<FD_SETSIZE>, on the range of file descriptors that can be "
"specified in a file descriptor set.  The Linux kernel imposes no fixed "
"limit, but the glibc implementation makes I<fd_set> a fixed-size type, with "
"B<FD_SETSIZE> defined as 1024, and the B<FD_*>()  macros operating according "
"to that limit.  To monitor file descriptors greater than 1023, use "
"B<poll>(2)  or B<epoll>(7)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:665
msgid ""
"According to POSIX, B<select>()  should check all specified file descriptors "
"in the three file descriptor sets, up to the limit I<nfds-1>.  However, the "
"current implementation ignores any file descriptor in these sets that is "
"greater than the maximum file descriptor number that the process currently "
"has open.  According to POSIX, any such file descriptor that is specified in "
"one of the sets should result in the error B<EBADF>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:678
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: build/C/man2/select.2:694
msgid ""
"On Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has the wrong "
"checksum and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:709
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:714
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:721
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:723
#, no-wrap
msgid "    /* Watch stdin (fd 0) to see when it has input. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:726
#, no-wrap
msgid ""
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:728
#, no-wrap
msgid "    /* Wait up to five seconds. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:731
#, no-wrap
msgid ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:734
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don\\(aqt rely on the value of tv now! */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:742
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:758
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:761
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""

#. type: TH
#: build/C/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:35
msgid "select, pselect - synchronous I/O multiplexing"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:38
msgid "See B<select>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:47
msgid ""
"The B<select>()  and B<pselect>()  system calls are used to efficiently "
"monitor multiple file descriptors, to see if any of them is, or becomes, "
"\"ready\"; that is, to see whether I/O becomes possible, or an \"exceptional "
"condition\" has occurred on any of the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:57
msgid ""
"This page provides background and tutorial information on the use of these "
"system calls.  For details of the arguments and semantics of B<select>()  "
"and B<pselect>(), see B<select>(2)."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:57
#, no-wrap
msgid "Combining signal and data events"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:74
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:102
msgid ""
"Now, somewhere in the main loop will be a conditional to check the global "
"flag.  So we must ask: what if a signal arrives after the conditional, but "
"before the B<select>()  call? The answer is that B<select>()  would block "
"indefinitely, even though an event is actually pending.  This race condition "
"is solved by the B<pselect>()  call.  This call can be used to set the "
"signal mask to a set of signals that are to be received only within the "
"B<pselect>()  call.  For instance, let us say that the event in question was "
"the exit of a child process.  Before the start of the main loop, we would "
"block B<SIGCHLD> using B<sigprocmask>(2).  Our B<pselect>()  call would "
"enable B<SIGCHLD> by using an empty signal mask.  Our program would look "
"like:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:105
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:111
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:119
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:126
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:134
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:136
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:140
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:146
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:149
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:153
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:157
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:158
#, no-wrap
msgid "Practical"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:179
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my file "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:179
#, no-wrap
msgid "Select law"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:192
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:201
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:205
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:212
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:218
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:218
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:233
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:233
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:241
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:241
#, no-wrap
msgid "7."
msgstr ""

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: build/C/man2/select_tut.2:267
msgid ""
"Calls to B<read>(2), B<recv>(2), B<write>(2), B<send>(2), and B<select>()  "
"can fail with the error B<EINTR>, and calls to B<read>(2), B<recv>(2)  "
"B<write>(2), and B<send>(2)  can fail with I<errno> set to B<EAGAIN> "
"(B<EWOULDBLOCK>).  These results must be properly managed (not done properly "
"above).  If your program is not going to receive any signals, then it is "
"unlikely you will get B<EINTR>.  If your program does not set nonblocking "
"I/O, you will not get B<EAGAIN>."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:267
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:276
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:276
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:292
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that file "
"descriptor to B<select>()  again.  In the example below, I close the file "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:292
#, no-wrap
msgid "10."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:299
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:299
#, no-wrap
msgid "11."
msgstr ""

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: build/C/man2/select_tut.2:318
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:321
msgid "See B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:330
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:339
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:347
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:352
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:364
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:366
#, no-wrap
msgid "static int forward_port;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:369
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:376
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:382
#, no-wrap
msgid ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:390
#, no-wrap
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:399
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:404
#, no-wrap
msgid ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:410
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:416
#, no-wrap
msgid ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:420
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:426
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:435
#, no-wrap
msgid ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:443
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:451
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:453
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:462
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:468
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> "
"E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:470
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:472
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:476
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:481
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:487
#, no-wrap
msgid ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:494
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:499
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:508
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:510
#, no-wrap
msgid "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:513
#, no-wrap
msgid ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:518
#, no-wrap
msgid ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:523
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:541
#, no-wrap
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:544
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file\n"
"                   descriptors. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:548
#, no-wrap
msgid ""
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:550
#, no-wrap
msgid "        /* NB: read OOB data before normal reads */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:553
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:562
#, no-wrap
msgid ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:601
#, no-wrap
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) "
"{\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) "
"{\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:603
#, no-wrap
msgid "        /* Check if write data has caught read data */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:608
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:611
#, no-wrap
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:619
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:633
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:639
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: build/C/man2/select_tut.2:652
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:50
#, no-wrap
msgid ""
"B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t "
">I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:57
#, no-wrap
msgid ""
"B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""

#.  FIXME . ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: build/C/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""

#. type: TP
#: build/C/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:209
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned.  This provides similar behavior to setting the "
"B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> operation), but differs "
"in that B<MSG_DONTWAIT> is a per-call option, whereas B<O_NONBLOCK> is a "
"setting on the open file description (see B<open>(2)), which will affect all "
"threads in the calling process and as well as other processes that hold file "
"descriptors referring to the same open file description."
msgstr ""

#. type: TP
#: build/C/man2/send.2:209
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:213
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/send.2:213
#, no-wrap
msgid "B<MSG_MORE> (since Linux 2.4.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:222
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:231
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:231
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:249
msgid ""
"Don't generate a B<SIGPIPE> signal if the peer on a stream-oriented socket "
"has closed the connection.  The B<EPIPE> error is still returned.  This "
"provides similar behavior to using B<sigaction>(2)  to ignore B<SIGPIPE>, "
"but, whereas B<MSG_NOSIGNAL> is a per-call feature, ignoring B<SIGPIPE> sets "
"a process attribute that affects all threads in the process."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:258
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""

#. type: SS
#: build/C/man2/send.2:258
#, no-wrap
msgid "sendmsg()"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:264
msgid ""
"The definition of the I<msghdr> structure employed by B<sendmsg>()  is as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:276
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags (unused) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:288
msgid ""
"The I<msg_name> field is used on an unconnected socket to specify the target "
"address for a datagram.  It points to a buffer containing the address; the "
"I<msg_namelen> field should be set to the size of the address.  For a "
"connected socket, these fields should be specified as NULL and 0, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:295
msgid ""
"The I<msg_iov> and I<msg_iovlen> fields specify scatter-gather locations, as "
"for B<writev>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:311
msgid ""
"You may send control information (ancillary data) using the I<msg_control> "
"and I<msg_controllen> members.  The maximum control buffer length the kernel "
"can process is limited per socket by the value in "
"I</proc/sys/net/core/optmem_max>; see B<socket>(7).  For further information "
"on the use of ancillary data in various socket domains, see B<unix>(7)  and "
"B<ip>(7)."
msgstr ""

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#. type: Plain text
#: build/C/man2/send.2:318
msgid "The I<msg_flags> field is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:323
msgid ""
"On success, these calls return the number of bytes sent.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:328
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:336
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:339
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/send.2:347
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:360
msgid ""
"(Internet domain datagram sockets)  The socket referred to by I<sockfd> had "
"not previously been bound to an address and, upon attempting to bind it to "
"an ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> in B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:363
msgid "Another Fast Open is in progress."
msgstr ""

#. type: TP
#: build/C/man2/send.2:367
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:370
msgid "Connection reset by peer."
msgstr ""

#. type: TP
#: build/C/man2/send.2:370
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:373
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:376
msgid "An invalid user space address was specified for an argument."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:380
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:389
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:389
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: build/C/man2/send.2:395
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:403
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:406
msgid "No memory available."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:409
msgid "The socket is not connected, and no target has been given."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:419
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""

#. type: TP
#: build/C/man2/send.2:419
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:428
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case, the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:431
msgid "4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:442
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""

#.  glibc bug for msg_controllen raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type these fields varies
#.  across architectures, but socklen_t is always 32 bits,
#.  as (at least with GCC) is int.
#. type: Plain text
#: build/C/man2/send.2:461
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, and the I<msg_iovlen> field "
"should be typed as I<int>, but glibc currently types both as I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:466
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:471
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:476
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:493
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"
msgstr ""

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: build/C/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#
#.      This matches the behavior of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: build/C/man2/sendmmsg.2:146
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent.  See also BUGS."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:151
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:154
msgid "B<sendmmsg>()  is Linux-specific."
msgstr ""

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: build/C/man2/sendmmsg.2:169
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:177
msgid ""
"If an error occurs after at least one message has been sent, the call "
"succeeds, and returns the number of messages sent.  The error code is lost.  "
"The caller can retry the transmission, starting at the first failed message, "
"but there is no guarantee that, if an error is returned, it will be the same "
"as the one that was lost on the previous call."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:186
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:204
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:218
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:224
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:228
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:241
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:244
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:250
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sockatmark.3:25
#, no-wrap
msgid "SOCKATMARK"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:28
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:30 build/C/man2/socket.2:49 build/C/man7/socket.7:59 build/C/man2/socketpair.2:49 build/C/man7/address_families.7:33 build/C/man7/vsock.7:30
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:32
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:41
msgid "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:51
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:58
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the "
"out-of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: build/C/man3/sockatmark.3:70
msgid "I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:73
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr ""

#. type: tbl table
#: build/C/man3/sockatmark.3:83
#, no-wrap
msgid "B<sockatmark>()"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:87
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:94
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:96
msgid "Out-of-band data is supported only on some stream socket protocols."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:101
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:107
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:111
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:116
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:121
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:128
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:131
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:138
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:145
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:151
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr ""

#. type: TH
#: build/C/man2/socket.2:42 build/C/man7/socket.7:54
#, no-wrap
msgid "SOCKET"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:45
msgid "socket - create an endpoint for communication"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:47 build/C/man2/socketpair.2:47 build/C/man7/address_families.7:31
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:51 build/C/man7/address_families.7:35
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:57
msgid ""
"B<socket>()  creates an endpoint for communication and returns a file "
"descriptor that refers to that endpoint.  The file descriptor returned by a "
"successful call will be the lowest-numbered file descriptor not currently "
"open for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:65
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The formats currently understood by "
"the Linux kernel include:"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Name"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Purpose"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:68 build/C/man2/socketcall.2:48
#, no-wrap
msgid "Man page"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:71
#, no-wrap
msgid "B<AF_UNIX>"
msgstr ""

#. type: SS
#: build/C/man2/socket.2:73 build/C/man7/vsock.7:167
#, no-wrap
msgid "Local communication"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:75
#, no-wrap
msgid "B<unix>(7)"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:78
#, no-wrap
msgid "B<AF_LOCAL>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:81
#, no-wrap
msgid ""
"Synonym for\n"
"B<AF_UNIX>"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:85 build/C/man7/address_families.7:50
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:85
#, no-wrap
msgid "IPv4 Internet protocols"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:87
#, no-wrap
msgid "B<ip>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:90 build/C/man7/address_families.7:55
#, no-wrap
msgid "B<AF_AX25>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:92
#, no-wrap
msgid "Amateur radio AX.25 protocol"
msgstr ""

#.  Part of ax25-tools
#. type: tbl table
#: build/C/man2/socket.2:95
#, no-wrap
msgid "B<ax25>(4)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:98 build/C/man7/address_families.7:61
#, no-wrap
msgid "B<AF_IPX>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:98
#, no-wrap
msgid "IPX - Novell protocols"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:101 build/C/man7/address_families.7:64
#, no-wrap
msgid "B<AF_APPLETALK>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:101
#, no-wrap
msgid "AppleTalk"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:103
#, no-wrap
msgid "B<ddp>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:106 build/C/man7/address_families.7:97
#, no-wrap
msgid "B<AF_X25>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:106
#, no-wrap
msgid "ITU-T X.25 / ISO-8208 protocol"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:108
#, no-wrap
msgid "B<x25>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:111 build/C/man7/address_families.7:102
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:111
#, no-wrap
msgid "IPv6 Internet protocols"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:113
#, no-wrap
msgid "B<ipv6>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:116 build/C/man7/address_families.7:113
#, no-wrap
msgid "B<AF_DECnet>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:118
#, no-wrap
msgid "DECet protocol sockets"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:121 build/C/man7/address_families.7:126
#, no-wrap
msgid "B<AF_KEY>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:123
#, no-wrap
msgid "Key management protocol, originally developed for usage with IPsec"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:126 build/C/man7/address_families.7:139
#, no-wrap
msgid "B<AF_NETLINK>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:128
#, no-wrap
msgid "Kernel user interface device"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:130
#, no-wrap
msgid "B<netlink>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:133 build/C/man7/address_families.7:144
#, no-wrap
msgid "B<AF_PACKET>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:135
#, no-wrap
msgid "Low-level packet interface"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:137
#, no-wrap
msgid "B<packet>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:140 build/C/man7/address_families.7:185
#, no-wrap
msgid "B<AF_RDS>"
msgstr ""

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#. type: tbl table
#: build/C/man2/socket.2:143
#, no-wrap
msgid "Reliable Datagram Sockets (RDS) protocol"
msgstr ""

#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: tbl table
#: build/C/man2/socket.2:147
#, no-wrap
msgid "B<rds>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:149
#, no-wrap
msgid "B<rds-rdma>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:152 build/C/man7/address_families.7:209
#, no-wrap
msgid "B<AF_PPPOX>"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:155
#, no-wrap
msgid ""
"Generic PPP transport layer, for setting up L2 tunnels\n"
"(L2TP and PPPoE)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:158 build/C/man7/address_families.7:222
#, no-wrap
msgid "B<AF_LLC>"
msgstr ""

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: tbl table
#: build/C/man2/socket.2:161
#, no-wrap
msgid "Logical link control (IEEE 802.2 LLC) protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:164 build/C/man7/address_families.7:245
#, no-wrap
msgid "B<AF_IB>"
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: build/C/man2/socket.2:167
#, no-wrap
msgid "InfiniBand native addressing"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:170 build/C/man7/address_families.7:249
#, no-wrap
msgid "B<AF_MPLS>"
msgstr ""

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: tbl table
#: build/C/man2/socket.2:173
#, no-wrap
msgid "Multiprotocol Label Switching"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:176 build/C/man7/address_families.7:256
#, no-wrap
msgid "B<AF_CAN>"
msgstr ""

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: tbl table
#: build/C/man2/socket.2:179
#, no-wrap
msgid "Controller Area Network automotive bus protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:182 build/C/man7/address_families.7:263
#, no-wrap
msgid "B<AF_TIPC>"
msgstr ""

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: tbl table
#: build/C/man2/socket.2:185
#, no-wrap
msgid "TIPC, \"cluster domain sockets\" protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:188 build/C/man7/address_families.7:276
#, no-wrap
msgid "B<AF_BLUETOOTH>"
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: build/C/man2/socket.2:191
#, no-wrap
msgid "Bluetooth low-level socket protocol"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:194 build/C/man7/address_families.7:352
#, no-wrap
msgid "B<AF_ALG>"
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: build/C/man2/socket.2:197
#, no-wrap
msgid "Interface to kernel crypto API"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:200 build/C/man7/address_families.7:358
#, no-wrap
msgid "B<AF_VSOCK>"
msgstr ""

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: tbl table
#: build/C/man2/socket.2:204
#, no-wrap
msgid ""
"VSOCK (originally \"VMWare VSockets\") protocol\n"
"for hypervisor-guest communication"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:206
#, no-wrap
msgid "B<vsock>(7)"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:209 build/C/man7/address_families.7:368
#, no-wrap
msgid "B<AF_KCM>"
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: build/C/man2/socket.2:212
#, no-wrap
msgid "KCM (kernel connection multiplexer) interface"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:215 build/C/man7/address_families.7:400
#, no-wrap
msgid "B<AF_XDP>"
msgstr ""

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: tbl table
#: build/C/man2/socket.2:218
#, no-wrap
msgid "XDP (express data path) interface"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:224
msgid ""
"Further details of the above address families, as well as information on "
"several other address families, can be found in B<address_families>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:230
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:230
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:234
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:234
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:238
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:238
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:243
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:243
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:246
msgid "Provides raw network protocol access."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:246
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:249
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:249
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:254
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:256
msgid "Some socket types may not be implemented by all protocol families."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:264
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:300
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:330
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams.  They do not "
"preserve record boundaries.  A stream socket must be in a I<connected> state "
"before any data may be sent or received on it.  A connection to another "
"socket is created with a B<connect>(2)  call.  Once connected, data may be "
"transferred using B<read>(2)  and B<write>(2)  calls or some variant of the "
"B<send>(2)  and B<recv>(2)  calls.  When a session has been completed a "
"B<close>(2)  may be performed.  Out-of-band data may also be transmitted as "
"described in B<send>(2)  and received as described in B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:356
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:366
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:373
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:396
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:406
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using an ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:416
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:421
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:426
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:429
msgid "The implementation does not support the specified address family."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:432
msgid "Unknown protocol, or protocol family not available."
msgstr ""

#.  Since Linux 2.6.27
#. type: Plain text
#: build/C/man2/socket.2:437
msgid "Invalid flags in I<type>."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:443
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:448
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:448 build/C/man2/socketpair.2:102 build/C/man7/vsock.7:218
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:452
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:454
msgid "Other errors may be generated by the underlying protocol modules."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:456
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:462
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:468
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:487
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:492
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:517
msgid ""
"B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), "
"B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), "
"B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), "
"B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), "
"B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:523
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""

#. type: TH
#: build/C/man7/socket.7:54
#, no-wrap
msgid "2020-08-13"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:57
msgid "socket - Linux socket interface"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:61
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:80
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> such as B<AF_INET>, B<AF_IPX>, "
"and B<AF_PACKET>, and I<socket types> such as B<SOCK_STREAM> or "
"B<SOCK_DGRAM>.  See B<socket>(2)  for more information on families and "
"types."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:80
#, no-wrap
msgid "Socket-layer functions"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:84
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:100
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets "
"(implemented only for a few local families like B<AF_UNIX>)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:122
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:133
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:138
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:144
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:161
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:165
#, no-wrap
msgid "I/O events"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Event"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Poll flag"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "Occurrence"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:167 build/C/man7/socket.7:170 build/C/man7/socket.7:174 build/C/man7/socket.7:177
#, no-wrap
msgid "Read"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:167 build/C/man7/socket.7:170
#, no-wrap
msgid "POLLIN"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:169
#, no-wrap
msgid "New data arrived."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:173
#, no-wrap
msgid ""
"A connection setup has been completed\n"
"(for connection-oriented sockets)"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:174 build/C/man7/socket.7:177 build/C/man7/socket.7:196
#, no-wrap
msgid "POLLHUP"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:176
#, no-wrap
msgid "A disconnection request has been initiated by the other end."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:182
#, no-wrap
msgid ""
"A connection is broken (only for connection-oriented protocols).\n"
"When the socket is written\n"
"B<SIGPIPE>\n"
"is also sent."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:183
#, no-wrap
msgid "Write"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:183 build/C/man7/socket.7:190
#, no-wrap
msgid "POLLOUT"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:185
#, no-wrap
msgid "Socket has enough send buffer space for writing new data."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:186 build/C/man7/socket.7:195 build/C/man7/socket.7:196
#, no-wrap
msgid "Read/Write"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:188
#, no-wrap
msgid "POLLIN |\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:194
#, no-wrap
msgid ""
"An outgoing\n"
"B<connect>(2)\n"
"finished."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:195
#, no-wrap
msgid "POLLERR"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:195
#, no-wrap
msgid "An asynchronous error occurred."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:196
#, no-wrap
msgid "The other end has shut down one direction."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:197
#, no-wrap
msgid "Exception"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:197
#, no-wrap
msgid "POLLPRI"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:201
#, no-wrap
msgid ""
"Urgent data arrived.\n"
"B<SIGURG>\n"
"is sent then."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:229
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:229
#, no-wrap
msgid "Socket address structures"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:245
msgid ""
"Each socket domain has its own format for socket addresses, with a "
"domain-specific address structure.  Each of these structures begins with an "
"integer \"family\" field (typed as I<sa_family_t>)  that indicates the type "
"of the address structure.  This allows the various system calls (e.g., "
"B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2)), which are generic to all socket domains, to determine "
"the domain of a particular socket address."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:255
msgid ""
"To allow any type of socket address to be passed to interfaces in the "
"sockets API, the type I<struct sockaddr> is defined.  The purpose of this "
"type is purely to allow casting of domain-specific socket address types to a "
"\"generic\" type, so as to avoid compiler warnings about type mismatches in "
"calls to the sockets API."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:265
msgid ""
"In addition, the sockets API provides the data type I<struct "
"sockaddr_storage>.  This type is suitable to accommodate all supported "
"domain-specific socket address structures; it is large enough and is aligned "
"properly.  (In particular, it is large enough to hold IPv6 socket "
"addresses.)  The structure includes the following field, which can be used "
"to identify the type of socket address actually stored in the structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:269
#, no-wrap
msgid "    sa_family_t ss_family;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:277
msgid ""
"The I<sockaddr_storage> structure is useful in programs that must handle "
"socket addresses in a generic way (e.g., programs that must deal with both "
"IPv4 and IPv6 socket addresses)."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:277
#, no-wrap
msgid "Socket options"
msgstr ""

#.  FIXME .
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: build/C/man7/socket.7:295
msgid ""
"The socket options listed below can be set by using B<setsockopt>(2)  and "
"read with B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for "
"all sockets.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:295
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:303
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:303
#, no-wrap
msgid "B<SO_ATTACH_FILTER> (since Linux 2.2), B<SO_ATTACH_BPF> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:316
msgid ""
"Attach a classic BPF (B<SO_ATTACH_FILTER>)  or an extended BPF "
"(B<SO_ATTACH_BPF>)  program to the socket for use as a filter of incoming "
"packets.  A packet will be dropped if the filter program returns zero.  If "
"the filter program returns a nonzero value which is less than the packet's "
"data length, the packet will be truncated to the length returned.  If the "
"value returned by the filter is greater than or equal to the packet's data "
"length, the packet is allowed to proceed unmodified."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:323
msgid ""
"The argument for B<SO_ATTACH_FILTER> is a I<sock_fprog> structure, defined "
"in I<E<lt>linux/filter.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:330
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;\n"
"    struct sock_filter *filter;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:339
msgid ""
"The argument for B<SO_ATTACH_BPF> is a file descriptor returned by the "
"B<bpf>(2)  system call and must refer to a program of type "
"B<BPF_PROG_TYPE_SOCKET_FILTER>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:345
msgid ""
"These options may be set multiple times for a given socket, each time "
"replacing the previous filter program.  The classic and extended versions "
"may be called on the same socket, but the previous filter will always be "
"replaced such that a socket never has more than one filter defined."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:348
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:348
#, no-wrap
msgid "B<SO_ATTACH_REUSEPORT_CBPF>, B<SO_ATTACH_REUSEPORT_EBPF>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:360
msgid ""
"For use with the B<SO_REUSEPORT> option, these options allow the user to set "
"a classic BPF (B<SO_ATTACH_REUSEPORT_CBPF>)  or an extended BPF "
"(B<SO_ATTACH_REUSEPORT_EBPF>)  program which defines how packets are "
"assigned to the sockets in the reuseport group (that is, all sockets which "
"have B<SO_REUSEPORT> set and are using the same local address to receive "
"packets)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:368
msgid ""
"The BPF program must return an index between 0 and N-1 representing the "
"socket which should receive the packet (where N is the number of sockets in "
"the group).  If the BPF program returns an invalid index, socket selection "
"will fall back to the plain B<SO_REUSEPORT> mechanism."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:380
msgid ""
"Sockets are numbered in the order in which they are added to the group (that "
"is, the order of B<bind>(2)  calls for UDP sockets or the order of "
"B<listen>(2)  calls for TCP sockets).  New sockets added to a reuseport "
"group will inherit the BPF program.  When a socket is removed from a "
"reuseport group (via B<close>(2)), the last socket in the group will be "
"moved into the closed socket's position."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:383
msgid ""
"These options may be set repeatedly at any time on any socket in the group "
"to replace the current BPF program used by all sockets in the group."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:391
msgid ""
"B<SO_ATTACH_REUSEPORT_CBPF> takes the same argument type as "
"B<SO_ATTACH_FILTER> and B<SO_ATTACH_REUSEPORT_EBPF> takes the same argument "
"type as B<SO_ATTACH_BPF>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:394
msgid ""
"UDP support for this feature is available since Linux 4.5; TCP support is "
"available since Linux 4.6."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:394
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:413
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this works only for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:427
msgid ""
"Before Linux 3.8, this socket option could be set, but could not retrieved "
"with B<getsockopt>(2).  Since Linux 3.8, it is readable.  The I<optlen> "
"argument should contain the buffer size available to receive the device name "
"and is recommended to be B<IFNAMSIZ> bytes.  The real device name length is "
"reported back in the I<optlen> argument."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:427
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:433
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on "
"stream-oriented sockets."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:433
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:445
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled, ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:445
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:451
msgid ""
"Enable socket debugging.  Allowed only for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:451
#, no-wrap
msgid "B<SO_DETACH_FILTER> (since Linux 2.2), B<SO_DETACH_BPF> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:460
msgid ""
"These two options, which are synonyms, may be used to remove the classic or "
"extended BPF program attached to a socket with either B<SO_ATTACH_FILTER> or "
"B<SO_ATTACH_BPF>.  The option value is ignored."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:460
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:468
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:468
#, no-wrap
msgid "B<SO_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:473
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:473
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:482
msgid ""
"Don't send via a gateway, send only to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:482
#, no-wrap
msgid "B<SO_INCOMING_CPU> (gettable since Linux 3.19, settable since Linux 4.4)"
msgstr ""

#.  getsockopt 2c8c56e15df3d4c2af3d656e44feb18789f75837
#.  setsockopt 70da268b569d32a9fddeea85dc18043de9d89f89
#. type: Plain text
#: build/C/man7/socket.7:488
msgid "Sets or gets the CPU affinity of a socket.  Expects an integer flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:494
#, no-wrap
msgid ""
"int cpu = 1;\n"
"setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu,\n"
"           sizeof(cpu));\n"
msgstr ""

#
#.  From an email conversation with Eric Dumazet:
#.  >> Note that setting the option is not supported if SO_REUSEPORT is used.
#.  >
#.  > Please define "not supported". Does this yield an API diagnostic?
#.  > If so, what is it?
#.  >
#.  >> Socket will be selected from an array, either by a hash or BPF program
#.  >> that has no access to this information.
#.  >
#.  > Sorry -- I'm lost here. How does this comment relate to the proposed
#.  > man page text above?
#
#.  Simply that :
#
#.  If an application uses both SO_INCOMING_CPU and SO_REUSEPORT, then
#.  SO_REUSEPORT logic, selecting the socket to receive the packet, ignores
#.  SO_INCOMING_CPU setting.
#. type: Plain text
#: build/C/man7/socket.7:522
msgid ""
"Because all of the packets for a single stream (i.e., all packets for the "
"same 4-tuple)  arrive on the single RX queue that is associated with a "
"particular CPU, the typical use case is to employ one listening process per "
"RX queue, with the incoming flow being handled by a listener on the same CPU "
"that is handling the RX queue.  This provides optimal NUMA behavior and "
"keeps CPU caches hot."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:522
#, no-wrap
msgid "B<SO_INCOMING_NAPI_ID> (gettable since Linux 4.12)"
msgstr ""

#.  getsockopt 6d4339028b350efbf87c61e6d9e113e5373545c9
#. type: Plain text
#: build/C/man7/socket.7:528
msgid ""
"Returns a system-level unique ID called NAPI ID that is associated with a RX "
"queue on which the last packet associated with that socket is received."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:538
msgid ""
"This can be used by an application to split the incoming flows among worker "
"threads based on the RX queue on which the packets associated with the flows "
"are received.  It allows each worker thread to be associated with a NIC HW "
"receive queue and service all the connection requests received on that RX "
"queue.  This mapping between a app thread and a HW NIC queue streamlines the "
"flow of data from the NIC to the application."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:538
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:542
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:542
#, no-wrap
msgid "B<SO_LINGER>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:550
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:557
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:571
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:571
#, no-wrap
msgid "B<SO_LOCK_FILTER>"
msgstr ""

#.  commit d59577b6ffd313d0ab3be39cb1ab47e29bdc9182
#. type: Plain text
#: build/C/man7/socket.7:582
msgid ""
"When set, this option will prevent changing the filters associated with the "
"socket.  These filters include any set using the socket options "
"B<SO_ATTACH_FILTER>, B<SO_ATTACH_BPF>, B<SO_ATTACH_REUSEPORT_CBPF>, and "
"B<SO_ATTACH_REUSEPORT_EBPF>."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:591
msgid ""
"The typical use case is for a privileged process to set up a raw socket (an "
"operation that requires the B<CAP_NET_RAW> capability), apply a restrictive "
"filter, set the B<SO_LOCK_FILTER> option, and then either drop its "
"privileges or pass the socket file descriptor to an unprivileged process via "
"a UNIX domain socket."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:599
msgid ""
"Once the B<SO_LOCK_FILTER> option has been enabled, attempts to change or "
"remove the filter attached to a socket, or to disable the B<SO_LOCK_FILTER> "
"option will fail with the error B<EPERM>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:599
#, no-wrap
msgid "B<SO_MARK> (since Linux 2.6.25)"
msgstr ""

#.  commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
#.  and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
#. type: Plain text
#: build/C/man7/socket.7:610
msgid ""
"Set the mark for each packet sent through this socket (similar to the "
"netfilter MARK target but socket-based).  Changing the mark can be used for "
"mark-based routing without netfilter or for packet filtering.  Setting this "
"option requires the B<CAP_NET_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:610
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr ""

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#.      The kernel has support for the SO_NO_CHECK socket
#.      option (boolean: 0 == default, calculate checksum on xmit,
#.      1 == do not calculate checksum on xmit).
#.  Additional note from Andi Kleen on SO_NO_CHECK (2010-08-30)
#.      On Linux UDP checksums are essentially free and there's no reason
#.      to turn them off and it would disable another safety line.
#.      That is why I didn't document the option.
#. type: Plain text
#: build/C/man7/socket.7:626
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise, out-of-band data is passed only when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:626
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:633
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:633
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:640
msgid ""
"Enable or disable the receiving of the B<SCM_SECURITY> control message.  For "
"more information see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:640
#, no-wrap
msgid "B<SO_PEEK_OFF> (since Linux 3.4)"
msgstr ""

#.  commit ef64a54f6e558155b4f149bb10666b9e914b6c54
#. type: Plain text
#: build/C/man7/socket.7:650
msgid ""
"This option, which is currently supported only for B<unix>(7)  sockets, sets "
"the value of the \"peek offset\" for the B<recv>(2)  system call when used "
"with B<MSG_PEEK> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:658
msgid ""
"When this option is set to a negative value (it is set to -1 for all new "
"sockets), traditional behavior is provided: B<recv>(2)  with the B<MSG_PEEK> "
"flag will peek data from the front of the queue."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:665
msgid ""
"When the option is set to a value greater than or equal to zero, then the "
"next peek at data queued in the socket will occur at the byte offset "
"specified by the option value.  At the same time, the \"peek offset\" will "
"be incremented by the number of bytes that were peeked from the queue, so "
"that a subsequent peek will return the next data in the queue."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:677
msgid ""
"If data is removed from the front of the queue via a call to B<recv>(2)  (or "
"similar) without the B<MSG_PEEK> flag, the \"peek offset\" will be decreased "
"by the number of bytes removed.  In other words, receiving data without the "
"B<MSG_PEEK> flag will cause the \"peek offset\" to be adjusted to maintain "
"the correct relative position in the queued data, so that a subsequent peek "
"will retrieve the data that would have been retrieved had the data not been "
"removed."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:682
msgid ""
"For datagram sockets, if the \"peek offset\" points to the middle of a "
"packet, the data returned will be marked with the B<MSG_TRUNC> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:686
msgid ""
"The following example serves to illustrate the use of B<SO_PEEK_OFF>.  "
"Suppose a stream socket has the following queued input data:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:688
#, no-wrap
msgid "    aabbccddeeff\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:692
msgid ""
"The following sequence of B<recv>(2)  calls would have the effect noted in "
"the comments:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:697
#, no-wrap
msgid ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:702
#, no-wrap
msgid ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:704
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:709
msgid ""
"Return the credentials of the peer process connected to this socket.  For "
"further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:709
#, no-wrap
msgid "B<SO_PEERSEC> (since Linux 2.6.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:716
msgid ""
"Return the security context of the peer socket connected to this socket.  "
"For further details, see B<unix>(7)  and B<ip>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:716
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr ""

#.  For
#.  .BR ip (7),
#.  this also sets the IP type-of-service (TOS) field for outgoing packets.
#. type: Plain text
#: build/C/man7/socket.7:729
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  Setting a priority outside the range 0 to 6 requires "
"the B<CAP_NET_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:729
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:737
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:737
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  The following thread on LMKL is quite informative:
#.  getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behavior
#.  17 July 2012
#.  http://thread.gmane.org/gmane.linux.kernel/1328935
#. type: Plain text
#: build/C/man7/socket.7:756
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:756
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:765
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:765
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:781
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4."
msgstr ""

#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#.  commit c7004482e8dcb7c3c72666395cfa98a216a4fb70
#. type: Plain text
#: build/C/man7/socket.7:805
msgid ""
"Before Linux 2.6.28 B<select>(2), B<poll>(2), and B<epoll>(7)  did not "
"respect the B<SO_RCVLOWAT> setting on Linux, and indicated a socket as "
"readable when even a single byte of data was available.  A subsequent read "
"from the socket would then block until B<SO_RCVLOWAT> bytes are available.  "
"Since Linux 2.6.28, B<select>(2), B<poll>(2), and B<epoll>(7)  indicate a "
"socket as readable only if at least B<SO_RCVLOWAT> bytes are available."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:805
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr ""

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: build/C/man7/socket.7:840
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached, then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK>, or B<EINPROGRESS> (for "
"B<connect>(2))  just as if the socket was specified to be nonblocking.  If "
"the timeout is set to zero (the default), then the operation will never "
"timeout.  Timeouts only have effect for system calls that perform socket I/O "
"(e.g., B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have "
"no effect for B<select>(2), B<poll>(2), B<epoll_wait>(2), and so on."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:840
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr ""

#. 	commit c617f398edd4db2b8567a28e899a88f8f574798d
#. 	https://lwn.net/Articles/542629/
#. type: Plain text
#: build/C/man7/socket.7:857
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:857
#, no-wrap
msgid "B<SO_REUSEPORT> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:872
msgid ""
"Permits multiple B<AF_INET> or B<AF_INET6> sockets to be bound to an "
"identical socket address.  This option must be set on each socket (including "
"the first socket)  prior to calling B<bind>(2)  on the socket.  To prevent "
"port hijacking, all of the processes binding to the same address must have "
"the same effective UID.  This option can be employed with both TCP and UDP "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:884
msgid ""
"For TCP sockets, this option allows B<accept>(2)  load distribution in a "
"multi-threaded server to be improved by using a distinct listener socket for "
"each thread.  This provides improved load distribution as compared to "
"traditional techniques such using a single B<accept>(2)ing thread that "
"distributes connections, or having multiple threads that compete to "
"B<accept>(2)  from the same socket."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:890
msgid ""
"For UDP sockets, the use of this option can provide better distribution of "
"incoming datagrams to multiple processes (or threads) as compared to the "
"traditional technique of having multiple processes compete to receive "
"datagrams on the same socket."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:890
#, no-wrap
msgid "B<SO_RXQ_OVFL> (since Linux 2.6.33)"
msgstr ""

#.  commit 3b885787ea4112eaa80945999ea0901bf742707f
#. type: Plain text
#: build/C/man7/socket.7:896
msgid ""
"Indicates that an unsigned 32-bit value ancillary message (cmsg)  should be "
"attached to received skbs indicating the number of packets dropped by the "
"socket since its creation."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:896
#, no-wrap
msgid "B<SO_SELECT_ERR_QUEUE> (since Linux 3.10)"
msgstr ""

#. 	commit 7d4c04fc170087119727119074e72445f2bb192b
#. 	Author: Keller, Jacob E <jacob.e.keller@intel.com>
#.  It does not affect wake up.
#. type: Plain text
#: build/C/man7/socket.7:913
msgid ""
"When this option is set on a socket, an error condition on a socket causes "
"notification not only via the I<exceptfds> set of B<select>(2).  Similarly, "
"B<poll>(2)  also returns a B<POLLPRI> whenever an B<POLLERR> event is "
"returned."
msgstr ""

#.  commit 6e5d58fdc9bedd0255a8
#.  ("skbuff: Fix not waking applications when errors are enqueued")
#. type: Plain text
#: build/C/man7/socket.7:932
msgid ""
"Background: this option was added when waking up on an error condition "
"occurred only via the I<readfds> and I<writefds> sets of B<select>(2).  The "
"option was added to allow monitoring for error conditions via the "
"I<exceptfds> argument without simultaneously having to receive notifications "
"(via I<readfds>)  for regular data that can be read from the socket.  After "
"changes in Linux 4.16, the use of this flag to achieve the desired "
"notifications is no longer necessary.  This option is nevertheless retained "
"for backwards compatibility."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:932
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
#. type: Plain text
#: build/C/man7/socket.7:948
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:948
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:957
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:957
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:977
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and a "
"I<cmsg_type> of B<SCM_TIMESTAMP>.  The I<cmsg_data> field is a I<struct "
"timeval> indicating the reception time of the last packet passed to the user "
"in this call.  See B<cmsg>(3)  for details on control messages."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:977
#, no-wrap
msgid "B<SO_TIMESTAMPNS> (since Linux 2.6.22)"
msgstr ""

#.  commit 92f37fd2ee805aa77925c1e64fd56088b46094fc
#. type: Plain text
#: build/C/man7/socket.7:1000
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMPNS> control message.  "
"The timestamp control message is sent with level B<SOL_SOCKET> and a "
"I<cmsg_type> of B<SCM_TIMESTAMPNS>.  The I<cmsg_data> field is a I<struct "
"timespec> indicating the reception time of the last packet passed to the "
"user in this call.  The clock used for the timestamp is B<CLOCK_REALTIME>.  "
"See B<cmsg>(3)  for details on control messages."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1006
msgid ""
"A socket cannot mix B<SO_TIMESTAMP> and B<SO_TIMESTAMPNS>: the two modes are "
"mutually exclusive."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1006
#, no-wrap
msgid "B<SO_TYPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1011
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1011
#, no-wrap
msgid "B<SO_BUSY_POLL> (since Linux 3.11)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1020
msgid ""
"Sets the approximate time in microseconds to busy poll on a blocking receive "
"when there is no data.  Increasing this value requires B<CAP_NET_ADMIN>.  "
"The default for this option is controlled by the "
"I</proc/sys/net/core/busy_read> file."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1030
msgid ""
"The value in the I</proc/sys/net/core/busy_poll> file determines how long "
"B<select>(2)  and B<poll>(2)  will busy poll when they operate on sockets "
"with B<SO_BUSY_POLL> set and no events to report are found."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1034
msgid ""
"In both cases, busy polling will only be done when the socket last received "
"data from a network device that supports this option."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1038
msgid ""
"While busy polling may improve latency of some applications, care must be "
"taken when using it since this will increase both CPU utilization and power "
"usage."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:1038
#, no-wrap
msgid "Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1049
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1074
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of "
"its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""

#.  .SS Ancillary messages
#. type: Plain text
#: build/C/man7/socket.7:1082
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:1082
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1086
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1086
#, no-wrap
msgid "I<rmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1089
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1089
#, no-wrap
msgid "I<rmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1095
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1095
#, no-wrap
msgid "I<wmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1098
msgid "contains the default setting in bytes of the socket send buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1098
#, no-wrap
msgid "I<wmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1104
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1104
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1108
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1108
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1111
msgid "Maximum number of packets in the global input queue."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1111
#, no-wrap
msgid "I<optmem_max>"
msgstr ""

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: build/C/man7/socket.7:1116
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:1116 build/C/man7/vsock.7:150
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1119
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1123
#, no-wrap
msgid ""
"I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, "
">I<&value_result>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1125
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1153
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should be used only if the socket options B<SO_TIMESTAMP> and "
"B<SO_TIMESTAMPNS> are not set on the socket.  Otherwise, it returns the "
"timestamp of the last packet that was received while B<SO_TIMESTAMP> and "
"B<SO_TIMESTAMPNS> were not set, or it fails if no such packet has been "
"received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set to B<ENOENT>)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1153
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1166
msgid ""
"Set the process or process group that is to receive B<SIGIO> or B<SIGURG> "
"signals when I/O becomes possible or urgent data is available.  The argument "
"is a pointer to a I<pid_t>.  For further details, see the description of "
"B<F_SETOWN> in B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1166
#, no-wrap
msgid "B<FIOASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1176
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1184
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1184
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1193
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1197
msgid "Valid B<fcntl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1197
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1202
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:1202
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1207
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1221
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces were introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1226
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/socket.7:1241
msgid ""
"Linux will allow port reuse only with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:1259
msgid ""
"B<wireshark>(1), B<bpf>(2), B<connect>(2), B<getsockopt>(2), "
"B<setsockopt>(2), B<socket>(2), B<pcap>(3), B<address_families>(7), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<ipv6>(7), B<packet>(7), "
"B<tcp>(7), B<udp>(7), B<unix>(7), B<tcpdump>(8)"
msgstr ""

#. type: TH
#: build/C/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:30
msgid "B<#include E<lt>linux/net.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:32
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:40
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:44
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:48
#, no-wrap
msgid "I<call>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:51
#, no-wrap
msgid "B<SYS_SOCKET>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:53
#, no-wrap
msgid "B<socket>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:56
#, no-wrap
msgid "B<SYS_BIND>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:58
#, no-wrap
msgid "B<bind>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:61
#, no-wrap
msgid "B<SYS_CONNECT>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:63
#, no-wrap
msgid "B<connect>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:66
#, no-wrap
msgid "B<SYS_LISTEN>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:68
#, no-wrap
msgid "B<listen>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:71
#, no-wrap
msgid "B<SYS_ACCEPT>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:73
#, no-wrap
msgid "B<accept>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:76
#, no-wrap
msgid "B<SYS_GETSOCKNAME>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:78
#, no-wrap
msgid "B<getsockname>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:81
#, no-wrap
msgid "B<SYS_GETPEERNAME>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:83
#, no-wrap
msgid "B<getpeername>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:86
#, no-wrap
msgid "B<SYS_SOCKETPAIR>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:88
#, no-wrap
msgid "B<socketpair>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:91
#, no-wrap
msgid "B<SYS_SEND>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:93
#, no-wrap
msgid "B<send>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:96
#, no-wrap
msgid "B<SYS_RECV>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:98
#, no-wrap
msgid "B<recv>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:101
#, no-wrap
msgid "B<SYS_SENDTO>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:103
#, no-wrap
msgid "B<sendto>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:106
#, no-wrap
msgid "B<SYS_RECVFROM>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:108
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:111
#, no-wrap
msgid "B<SYS_SHUTDOWN>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:113
#, no-wrap
msgid "B<shutdown>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:116
#, no-wrap
msgid "B<SYS_SETSOCKOPT>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:118
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:121
#, no-wrap
msgid "B<SYS_GETSOCKOPT>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:123
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:126
#, no-wrap
msgid "B<SYS_SENDMSG>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:128
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:131
#, no-wrap
msgid "B<SYS_RECVMSG>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:133
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:136
#, no-wrap
msgid "B<SYS_ACCEPT4>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:138
#, no-wrap
msgid "B<accept4>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:141
#, no-wrap
msgid "B<SYS_RECVMMSG>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:143
#, no-wrap
msgid "B<recvmmsg>(2)"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:146
#, no-wrap
msgid "B<SYS_SENDMMSG>"
msgstr ""

#. type: tbl table
#: build/C/man2/socketcall.2:148
#, no-wrap
msgid "B<sendmmsg>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:153
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:161
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr ""

#.  commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb
#. type: Plain text
#: build/C/man2/socketcall.2:174
msgid ""
"On x86-32, B<socketcall>()  was historically the only entry point for the "
"sockets API.  However, starting in Linux 4.3, direct system calls are "
"provided on x86-32 for the sockets API.  This facilitates the creation of "
"B<seccomp>(2)  filters that filter sockets system calls (for new user-space "
"binaries that are compiled to use the new entry points)  and also provides a "
"(very) small performance improvement."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:192
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""

#. type: TH
#: build/C/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:69
msgid ""
"The file descriptors used in referencing the new sockets are returned in "
"I<sv[0]> and I<sv[1]>.  The two sockets are indistinguishable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:76
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<sv> is left unchanged"
msgstr ""

#.  http://austingroupbugs.net/view.php?id=483
#. type: Plain text
#: build/C/man2/socketpair.2:84
msgid ""
"On Linux (and other systems), B<socketpair>()  does not modify I<sv> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2008 TC2."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:88
msgid "The specified address family is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:93
msgid ""
"The address I<sv> does not specify a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:102
msgid "The specified protocol does not support creation of socket pairs."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:105
msgid "The specified protocol is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:112
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD.  B<socketpair>()  first appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System\\ V variants)."
msgstr ""

#.  commit: 70b03759e9ecfae400605fa34f3d7154cccbbba3
#. type: Plain text
#: build/C/man2/socketpair.2:121
msgid ""
"On Linux, the only supported domains for this call are B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>)  and B<AF_TIPC> (since Linux 4.12)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:132
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags in the I<type> argument, as described in B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:145
msgid "B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man7/bpf-helpers.7:3
#, no-wrap
msgid "BPF-HELPERS"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:6
msgid "BPF-HELPERS - list of eBPF helper functions"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:17
msgid ""
"\\e$1 \\en[an-margin] level \\en[rst2man-indent-level] level margin: "
"\\en[rst2man-indent\\en[rst2man-indent-level]] - \\en[rst2man-indent0] "
"\\en[rst2man-indent1] \\en[rst2man-indent2]"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:100
msgid ""
"The extended Berkeley Packet Filter (eBPF) subsystem consists in programs "
"written in a pseudo-assembly language, then attached to one of the several "
"kernel hooks and run in reaction of specific events. This framework differs "
"from the older, \"classic\" BPF (or \"cBPF\") in several aspects, one of "
"them being the ability to call special functions (or \"helpers\") from "
"within a program.  These functions are restricted to a white-list of helpers "
"defined in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:107
msgid ""
"These helpers are used by eBPF programs to interact with the system, or with "
"the context in which they work. For instance, they can be used to print "
"debugging messages, to get the time since the system was booted, to interact "
"with eBPF maps, or to manipulate network packets. Since there are several "
"eBPF program types, and that they do not run in the same context, each "
"program type can only call a subset of those helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:109
msgid "Due to eBPF conventions, a helper can not have more than five arguments."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:113
msgid ""
"Internally, eBPF programs call directly into the compiled helper functions "
"without requiring any foreign-function interface. As a result, calling "
"helpers introduces no overhead, thus offering excellent performance."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:117
msgid ""
"This document is an attempt to list and document the helpers available to "
"eBPF developers. They are sorted by chronological order (the oldest helpers "
"in the kernel at the top)."
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:117
#, no-wrap
msgid "HELPERS"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:119
#, no-wrap
msgid ""
"B<void *bpf_map_lookup_elem(struct bpf_map *>I<map>B<, const void "
"*>I<key>B<)>"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:122 build/C/man7/bpf-helpers.7:133 build/C/man7/bpf-helpers.7:159 build/C/man7/bpf-helpers.7:169 build/C/man7/bpf-helpers.7:183 build/C/man7/bpf-helpers.7:195 build/C/man7/bpf-helpers.7:274 build/C/man7/bpf-helpers.7:290 build/C/man7/bpf-helpers.7:303 build/C/man7/bpf-helpers.7:323 build/C/man7/bpf-helpers.7:352 build/C/man7/bpf-helpers.7:388 build/C/man7/bpf-helpers.7:423 build/C/man7/bpf-helpers.7:469 build/C/man7/bpf-helpers.7:484 build/C/man7/bpf-helpers.7:514 build/C/man7/bpf-helpers.7:534 build/C/man7/bpf-helpers.7:550 build/C/man7/bpf-helpers.7:608 build/C/man7/bpf-helpers.7:658 build/C/man7/bpf-helpers.7:690 build/C/man7/bpf-helpers.7:716 build/C/man7/bpf-helpers.7:744 build/C/man7/bpf-helpers.7:797 build/C/man7/bpf-helpers.7:818 build/C/man7/bpf-helpers.7:872 build/C/man7/bpf-helpers.7:907 build/C/man7/bpf-helpers.7:929 build/C/man7/bpf-helpers.7:943 build/C/man7/bpf-helpers.7:973 build/C/man7/bpf-helpers.7:1008 build/C/man7/bpf-helpers.7:1027 build/C/man7/bpf-helpers.7:1054 build/C/man7/bpf-helpers.7:1077 build/C/man7/bpf-helpers.7:1097 build/C/man7/bpf-helpers.7:1125 build/C/man7/bpf-helpers.7:1165 build/C/man7/bpf-helpers.7:1181 build/C/man7/bpf-helpers.7:1192 build/C/man7/bpf-helpers.7:1207 build/C/man7/bpf-helpers.7:1232 build/C/man7/bpf-helpers.7:1251 build/C/man7/bpf-helpers.7:1268 build/C/man7/bpf-helpers.7:1285 build/C/man7/bpf-helpers.7:1296 build/C/man7/bpf-helpers.7:1318 build/C/man7/bpf-helpers.7:1329 build/C/man7/bpf-helpers.7:1372 build/C/man7/bpf-helpers.7:1428 build/C/man7/bpf-helpers.7:1453 build/C/man7/bpf-helpers.7:1468 build/C/man7/bpf-helpers.7:1495 build/C/man7/bpf-helpers.7:1528 build/C/man7/bpf-helpers.7:1585 build/C/man7/bpf-helpers.7:1600 build/C/man7/bpf-helpers.7:1636 build/C/man7/bpf-helpers.7:1665 build/C/man7/bpf-helpers.7:1726 build/C/man7/bpf-helpers.7:1744 build/C/man7/bpf-helpers.7:1785 build/C/man7/bpf-helpers.7:1807 build/C/man7/bpf-helpers.7:1841 build/C/man7/bpf-helpers.7:1863 build/C/man7/bpf-helpers.7:1881 build/C/man7/bpf-helpers.7:1901 build/C/man7/bpf-helpers.7:1945 build/C/man7/bpf-helpers.7:1974 build/C/man7/bpf-helpers.7:2017 build/C/man7/bpf-helpers.7:2044 build/C/man7/bpf-helpers.7:2062 build/C/man7/bpf-helpers.7:2080 build/C/man7/bpf-helpers.7:2125 build/C/man7/bpf-helpers.7:2144 build/C/man7/bpf-helpers.7:2164 build/C/man7/bpf-helpers.7:2202 build/C/man7/bpf-helpers.7:2225 build/C/man7/bpf-helpers.7:2255 build/C/man7/bpf-helpers.7:2283 build/C/man7/bpf-helpers.7:2305 build/C/man7/bpf-helpers.7:2318 build/C/man7/bpf-helpers.7:2340 build/C/man7/bpf-helpers.7:2384 build/C/man7/bpf-helpers.7:2428 build/C/man7/bpf-helpers.7:2440 build/C/man7/bpf-helpers.7:2456 build/C/man7/bpf-helpers.7:2466 build/C/man7/bpf-helpers.7:2476 build/C/man7/bpf-helpers.7:2496 build/C/man7/bpf-helpers.7:2512 build/C/man7/bpf-helpers.7:2530 build/C/man7/bpf-helpers.7:2599 build/C/man7/bpf-helpers.7:2610 build/C/man7/bpf-helpers.7:2622 build/C/man7/bpf-helpers.7:2634 build/C/man7/bpf-helpers.7:2648 build/C/man7/bpf-helpers.7:2660 build/C/man7/bpf-helpers.7:2683 build/C/man7/bpf-helpers.7:2702 build/C/man7/bpf-helpers.7:2722 build/C/man7/bpf-helpers.7:2745 build/C/man7/bpf-helpers.7:2766 build/C/man7/bpf-helpers.7:2787 build/C/man7/bpf-helpers.7:2815 build/C/man7/bpf-helpers.7:2842 build/C/man7/bpf-helpers.7:2874 build/C/man7/bpf-helpers.7:2886 build/C/man7/bpf-helpers.7:2905 build/C/man7/bpf-helpers.7:2935 build/C/man7/bpf-helpers.7:2963 build/C/man7/bpf-helpers.7:2974 build/C/man7/bpf-helpers.7:2985 build/C/man7/bpf-helpers.7:3036 build/C/man7/bpf-helpers.7:3048 build/C/man7/bpf-helpers.7:3059 build/C/man7/bpf-helpers.7:3077 build/C/man7/bpf-helpers.7:3087 build/C/man7/bpf-helpers.7:3110 build/C/man7/bpf-helpers.7:3126 build/C/man7/bpf-helpers.7:3154 build/C/man7/bpf-helpers.7:3171 build/C/man7/bpf-helpers.7:3193 build/C/man7/bpf-helpers.7:3228 build/C/man7/bpf-helpers.7:3285 build/C/man7/bpf-helpers.7:3297 build/C/man7/bpf-helpers.7:3330 build/C/man7/bpf-helpers.7:3344 build/C/man7/bpf-helpers.7:3362 build/C/man7/bpf-helpers.7:3384 build/C/man7/bpf-helpers.7:3398 build/C/man7/bpf-helpers.7:3409 build/C/man7/bpf-helpers.7:3423 build/C/man7/bpf-helpers.7:3437 build/C/man7/bpf-helpers.7:3463 build/C/man7/bpf-helpers.7:3504 build/C/man7/bpf-helpers.7:3514 build/C/man7/bpf-helpers.7:3524 build/C/man7/bpf-helpers.7:3534 build/C/man7/bpf-helpers.7:3544 build/C/man7/bpf-helpers.7:3554
#, no-wrap
msgid "B<Description>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:125
msgid "Perform a lookup in I<map> for an entry associated to I<key>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:125 build/C/man7/bpf-helpers.7:152 build/C/man7/bpf-helpers.7:162 build/C/man7/bpf-helpers.7:176 build/C/man7/bpf-helpers.7:188 build/C/man7/bpf-helpers.7:266 build/C/man7/bpf-helpers.7:283 build/C/man7/bpf-helpers.7:296 build/C/man7/bpf-helpers.7:316 build/C/man7/bpf-helpers.7:345 build/C/man7/bpf-helpers.7:381 build/C/man7/bpf-helpers.7:416 build/C/man7/bpf-helpers.7:444 build/C/man7/bpf-helpers.7:451 build/C/man7/bpf-helpers.7:461 build/C/man7/bpf-helpers.7:477 build/C/man7/bpf-helpers.7:507 build/C/man7/bpf-helpers.7:527 build/C/man7/bpf-helpers.7:543 build/C/man7/bpf-helpers.7:601 build/C/man7/bpf-helpers.7:651 build/C/man7/bpf-helpers.7:682 build/C/man7/bpf-helpers.7:706 build/C/man7/bpf-helpers.7:736 build/C/man7/bpf-helpers.7:790 build/C/man7/bpf-helpers.7:811 build/C/man7/bpf-helpers.7:864 build/C/man7/bpf-helpers.7:899 build/C/man7/bpf-helpers.7:922 build/C/man7/bpf-helpers.7:936 build/C/man7/bpf-helpers.7:966 build/C/man7/bpf-helpers.7:1001 build/C/man7/bpf-helpers.7:1012 build/C/man7/bpf-helpers.7:1040 build/C/man7/bpf-helpers.7:1047 build/C/man7/bpf-helpers.7:1070 build/C/man7/bpf-helpers.7:1082 build/C/man7/bpf-helpers.7:1118 build/C/man7/bpf-helpers.7:1158 build/C/man7/bpf-helpers.7:1173 build/C/man7/bpf-helpers.7:1200 build/C/man7/bpf-helpers.7:1225 build/C/man7/bpf-helpers.7:1244 build/C/man7/bpf-helpers.7:1259 build/C/man7/bpf-helpers.7:1277 build/C/man7/bpf-helpers.7:1289 build/C/man7/bpf-helpers.7:1300 build/C/man7/bpf-helpers.7:1307 build/C/man7/bpf-helpers.7:1322 build/C/man7/bpf-helpers.7:1365 build/C/man7/bpf-helpers.7:1421 build/C/man7/bpf-helpers.7:1445 build/C/man7/bpf-helpers.7:1461 build/C/man7/bpf-helpers.7:1488 build/C/man7/bpf-helpers.7:1521 build/C/man7/bpf-helpers.7:1578 build/C/man7/bpf-helpers.7:1593 build/C/man7/bpf-helpers.7:1629 build/C/man7/bpf-helpers.7:1658 build/C/man7/bpf-helpers.7:1716 build/C/man7/bpf-helpers.7:1737 build/C/man7/bpf-helpers.7:1778 build/C/man7/bpf-helpers.7:1800 build/C/man7/bpf-helpers.7:1834 build/C/man7/bpf-helpers.7:1856 build/C/man7/bpf-helpers.7:1874 build/C/man7/bpf-helpers.7:1894 build/C/man7/bpf-helpers.7:1937 build/C/man7/bpf-helpers.7:1967 build/C/man7/bpf-helpers.7:2002 build/C/man7/bpf-helpers.7:2037 build/C/man7/bpf-helpers.7:2055 build/C/man7/bpf-helpers.7:2073 build/C/man7/bpf-helpers.7:2118 build/C/man7/bpf-helpers.7:2137 build/C/man7/bpf-helpers.7:2157 build/C/man7/bpf-helpers.7:2195 build/C/man7/bpf-helpers.7:2218 build/C/man7/bpf-helpers.7:2248 build/C/man7/bpf-helpers.7:2268 build/C/man7/bpf-helpers.7:2275 build/C/man7/bpf-helpers.7:2298 build/C/man7/bpf-helpers.7:2311 build/C/man7/bpf-helpers.7:2333 build/C/man7/bpf-helpers.7:2374 build/C/man7/bpf-helpers.7:2418 build/C/man7/bpf-helpers.7:2433 build/C/man7/bpf-helpers.7:2449 build/C/man7/bpf-helpers.7:2459 build/C/man7/bpf-helpers.7:2469 build/C/man7/bpf-helpers.7:2489 build/C/man7/bpf-helpers.7:2505 build/C/man7/bpf-helpers.7:2523 build/C/man7/bpf-helpers.7:2592 build/C/man7/bpf-helpers.7:2603 build/C/man7/bpf-helpers.7:2614 build/C/man7/bpf-helpers.7:2626 build/C/man7/bpf-helpers.7:2640 build/C/man7/bpf-helpers.7:2652 build/C/man7/bpf-helpers.7:2673 build/C/man7/bpf-helpers.7:2694 build/C/man7/bpf-helpers.7:2712 build/C/man7/bpf-helpers.7:2732 build/C/man7/bpf-helpers.7:2754 build/C/man7/bpf-helpers.7:2776 build/C/man7/bpf-helpers.7:2802 build/C/man7/bpf-helpers.7:2829 build/C/man7/bpf-helpers.7:2864 build/C/man7/bpf-helpers.7:2877 build/C/man7/bpf-helpers.7:2890 build/C/man7/bpf-helpers.7:2916 build/C/man7/bpf-helpers.7:2956 build/C/man7/bpf-helpers.7:2967 build/C/man7/bpf-helpers.7:2978 build/C/man7/bpf-helpers.7:3027 build/C/man7/bpf-helpers.7:3040 build/C/man7/bpf-helpers.7:3052 build/C/man7/bpf-helpers.7:3062 build/C/man7/bpf-helpers.7:3080 build/C/man7/bpf-helpers.7:3093 build/C/man7/bpf-helpers.7:3114 build/C/man7/bpf-helpers.7:3147 build/C/man7/bpf-helpers.7:3164 build/C/man7/bpf-helpers.7:3186 build/C/man7/bpf-helpers.7:3209 build/C/man7/bpf-helpers.7:3260 build/C/man7/bpf-helpers.7:3290 build/C/man7/bpf-helpers.7:3314 build/C/man7/bpf-helpers.7:3335 build/C/man7/bpf-helpers.7:3355 build/C/man7/bpf-helpers.7:3377 build/C/man7/bpf-helpers.7:3391 build/C/man7/bpf-helpers.7:3401 build/C/man7/bpf-helpers.7:3416 build/C/man7/bpf-helpers.7:3430 build/C/man7/bpf-helpers.7:3456 build/C/man7/bpf-helpers.7:3494 build/C/man7/bpf-helpers.7:3507 build/C/man7/bpf-helpers.7:3517 build/C/man7/bpf-helpers.7:3527 build/C/man7/bpf-helpers.7:3537 build/C/man7/bpf-helpers.7:3547 build/C/man7/bpf-helpers.7:3589
#, no-wrap
msgid "B<Return>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:129
msgid "Map value associated to I<key>, or B<NULL> if no entry was found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:130
#, no-wrap
msgid ""
"B<long bpf_map_update_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<, "
"const void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:137
msgid ""
"Add or update the value of the entry associated to I<key> in I<map> with "
"I<value>\\&. I<flags> is one of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:141 build/C/man7/bpf-helpers.7:1477 build/C/man7/bpf-helpers.7:2026
msgid "The entry for I<key> must not exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:144 build/C/man7/bpf-helpers.7:1480 build/C/man7/bpf-helpers.7:2029
msgid "The entry for I<key> must already exist in the map."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:147 build/C/man7/bpf-helpers.7:1483 build/C/man7/bpf-helpers.7:2032
msgid "No condition on the existence of the entry for I<key>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:152
msgid ""
"Flag value B<BPF_NOEXIST> cannot be used for maps of types "
"B<BPF_MAP_TYPE_ARRAY> or B<BPF_MAP_TYPE_PERCPU_ARRAY> (all elements always "
"exist), the helper would return an error."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:155 build/C/man7/bpf-helpers.7:165 build/C/man7/bpf-helpers.7:179 build/C/man7/bpf-helpers.7:319 build/C/man7/bpf-helpers.7:348 build/C/man7/bpf-helpers.7:384 build/C/man7/bpf-helpers.7:419 build/C/man7/bpf-helpers.7:447 build/C/man7/bpf-helpers.7:480 build/C/man7/bpf-helpers.7:530 build/C/man7/bpf-helpers.7:546 build/C/man7/bpf-helpers.7:604 build/C/man7/bpf-helpers.7:654 build/C/man7/bpf-helpers.7:793 build/C/man7/bpf-helpers.7:814 build/C/man7/bpf-helpers.7:939 build/C/man7/bpf-helpers.7:969 build/C/man7/bpf-helpers.7:1004 build/C/man7/bpf-helpers.7:1073 build/C/man7/bpf-helpers.7:1121 build/C/man7/bpf-helpers.7:1161 build/C/man7/bpf-helpers.7:1228 build/C/man7/bpf-helpers.7:1247 build/C/man7/bpf-helpers.7:1368 build/C/man7/bpf-helpers.7:1424 build/C/man7/bpf-helpers.7:1491 build/C/man7/bpf-helpers.7:1524 build/C/man7/bpf-helpers.7:1581 build/C/man7/bpf-helpers.7:1596 build/C/man7/bpf-helpers.7:1632 build/C/man7/bpf-helpers.7:1837 build/C/man7/bpf-helpers.7:1859 build/C/man7/bpf-helpers.7:1877 build/C/man7/bpf-helpers.7:1897 build/C/man7/bpf-helpers.7:1970 build/C/man7/bpf-helpers.7:2040 build/C/man7/bpf-helpers.7:2121 build/C/man7/bpf-helpers.7:2140 build/C/man7/bpf-helpers.7:2160 build/C/man7/bpf-helpers.7:2198 build/C/man7/bpf-helpers.7:2314 build/C/man7/bpf-helpers.7:2436 build/C/man7/bpf-helpers.7:2452 build/C/man7/bpf-helpers.7:2462 build/C/man7/bpf-helpers.7:2472 build/C/man7/bpf-helpers.7:2492 build/C/man7/bpf-helpers.7:2508 build/C/man7/bpf-helpers.7:2959 build/C/man7/bpf-helpers.7:2970 build/C/man7/bpf-helpers.7:2981 build/C/man7/bpf-helpers.7:3055 build/C/man7/bpf-helpers.7:3150 build/C/man7/bpf-helpers.7:3394
msgid "0 on success, or a negative error in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:156
#, no-wrap
msgid ""
"B<long bpf_map_delete_elem(struct bpf_map *>I<map>B<, const void "
"*>I<key>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:162
msgid "Delete entry with I<key> from I<map>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:166
#, no-wrap
msgid ""
"B<long bpf_probe_read(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:173
msgid ""
"For tracing programs, safely attempt to read I<size> bytes from kernel space "
"address I<unsafe_ptr> and store the data in I<dst>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:176
msgid ""
"Generally, use B<bpf_probe_read_user>() or B<bpf_probe_read_kernel>() "
"instead."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:180
#, no-wrap
msgid "B<u64 bpf_ktime_get_ns(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:188
msgid ""
"Return the time elapsed since system boot, in nanoseconds.  Does not include "
"time the system was suspended.  See: B<clock_gettime>(B<CLOCK_MONOTONIC>)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:191 build/C/man7/bpf-helpers.7:3293
msgid "Current I<ktime>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:192
#, no-wrap
msgid "B<long bpf_trace_printk(const char *>I<fmt>B<, u32 >I<fmt_size>B<, ...)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:203
msgid ""
"This helper is a \"printk()-like\" facility for debugging. It prints a "
"message defined by format I<fmt> (of size I<fmt_size>)  to file "
"I</sys/kernel/debug/tracing/trace> from DebugFS, if available. It can take "
"up to three additional B<u64> arguments (as an eBPF helpers, the total "
"number of arguments is limited to five)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:212
msgid ""
"Each time the helper is called, it appends a line to the trace.  Lines are "
"discarded while I</sys/kernel/debug/tracing/trace> is open, use "
"I</sys/kernel/debug/tracing/trace_pipe> to avoid this.  The format of the "
"trace is customizable, and the exact output one will get depends on the "
"options set in I</sys/kernel/debug/tracing/trace_options> (see also the "
"I<README> file under the same directory). However, it usually defaults to "
"something like:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:217
#, no-wrap
msgid "telnet-470   [001] .N.. 419421.045894: 0x00000001: E<lt>formatted msgE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:222
msgid "In the above:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:227
msgid "B<telnet> is the name of the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:229
msgid "B<470> is the PID of the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:232
msgid "B<001> is the CPU number on which the task is running."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:239
msgid ""
"In B<\\&.N..>, each character refers to a set of options (whether irqs are "
"enabled, scheduling options, whether hard/softirqs are running, level of "
"preempt_disabled respectively). B<N> means that B<TIF_NEED_RESCHED> and "
"B<PREEMPT_NEED_RESCHED> are set."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:241
msgid "B<419421.045894> is a timestamp."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:244
msgid ""
"B<0x00000001> is a fake value used by BPF for the instruction pointer "
"register."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:247
msgid "B<E<lt>formatted msgE<gt>> is the message formatted with I<fmt>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:258
msgid ""
"The conversion specifiers supported by I<fmt> are similar, but more limited "
"than for printk(). They are B<%d>, B<%i>, B<%u>, B<%x>, B<%ld>, B<%li>, "
"B<%lu>, B<%lx>, B<%lld>, B<%lli>, B<%llu>, B<%llx>, B<%p>, B<%s>\\&. No "
"modifier (size of field, padding with zeroes, etc.) is available, and the "
"helper will return B<-EINVAL> (but print nothing) if it encounters an "
"unknown specifier."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:266
msgid ""
"Also, note that B<bpf_trace_printk>() is slow, and should only be used for "
"debugging purposes. For this reason, a notice block (spanning several lines) "
"is printed to kernel logs and states that the helper should not be used "
"\"for production use\" the first time this helper is used (or more "
"precisely, when B<trace_printk>() buffers are allocated). For passing values "
"to user space, perf events should be preferred."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:270
msgid ""
"The number of bytes written to the buffer, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:271
#, no-wrap
msgid "B<u32 bpf_get_prandom_u32(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:277
msgid "Get a pseudo-random number."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:283
msgid ""
"From a security point of view, this helper uses its own pseudo-random "
"internal state, and cannot be used to infer the seed of other random "
"functions in the kernel. However, it is essential to note that the generator "
"used by the helper is not cryptographically secure."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:286
msgid "A random 32-bit unsigned value."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:287
#, no-wrap
msgid "B<u32 bpf_get_smp_processor_id(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:296
msgid ""
"Get the SMP (symmetric multiprocessing) processor id. Note that all programs "
"run with preemption disabled, which means that the SMP processor id is "
"stable during all the execution of the program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:299
msgid "The SMP id of the processor running the program."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:300
#, no-wrap
msgid ""
"B<long bpf_skb_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"const void *>I<from>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:310
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. I<flags> are a combination of "
"B<BPF_F_RECOMPUTE_CSUM> (automatically recompute the checksum for the packet "
"after storing the bytes) and B<BPF_F_INVALIDATE_HASH> (set "
"I<skb>B<-E<gt>hash>, I<skb>B<-E<gt>swhash> and I<skb>B<-E<gt>l4hash> to 0)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:316 build/C/man7/bpf-helpers.7:345 build/C/man7/bpf-helpers.7:381 build/C/man7/bpf-helpers.7:444 build/C/man7/bpf-helpers.7:527 build/C/man7/bpf-helpers.7:543 build/C/man7/bpf-helpers.7:966 build/C/man7/bpf-helpers.7:1118 build/C/man7/bpf-helpers.7:1158 build/C/man7/bpf-helpers.7:1225 build/C/man7/bpf-helpers.7:1244 build/C/man7/bpf-helpers.7:1421 build/C/man7/bpf-helpers.7:1521 build/C/man7/bpf-helpers.7:1831 build/C/man7/bpf-helpers.7:1874 build/C/man7/bpf-helpers.7:2118 build/C/man7/bpf-helpers.7:2137 build/C/man7/bpf-helpers.7:2157 build/C/man7/bpf-helpers.7:2195
msgid ""
"A call to this helper is susceptible to change the underlying packet "
"buffer. Therefore, at load time, all checks on pointers previously done by "
"the verifier are invalidated and must be performed again, if the helper is "
"used in combination with direct packet access."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:320
#, no-wrap
msgid ""
"B<long bpf_l3_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 "
">I<from>B<, u64 >I<to>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:334
msgid ""
"Recompute the layer 3 (e.g. IP) checksum for the packet associated to "
"I<skb>\\&. Computation is incremental, so the helper must know the former "
"value of the header field that was modified (I<from>), the new value of this "
"field (I<to>), and the number of bytes (2 or 4) for this field, stored in "
"I<size>\\&.  Alternatively, it is possible to store the difference between "
"the previous and the new values of the header field in I<to>, by setting "
"I<from> and I<size> to 0. For both methods, I<offset> indicates the location "
"of the IP checksum within the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:339 build/C/man7/bpf-helpers.7:375
msgid ""
"This helper works in combination with B<bpf_csum_diff>(), which does not "
"update the checksum in-place, but offers more flexibility and can handle "
"sizes larger than 2 or 4 for the checksum to update."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:349
#, no-wrap
msgid ""
"B<long bpf_l4_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 "
">I<from>B<, u64 >I<to>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:370
msgid ""
"Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet "
"associated to I<skb>\\&. Computation is incremental, so the helper must know "
"the former value of the header field that was modified (I<from>), the new "
"value of this field (I<to>), and the number of bytes (2 or 4) for this "
"field, stored on the lowest four bits of I<flags>\\&. Alternatively, it is "
"possible to store the difference between the previous and the new values of "
"the header field in I<to>, by setting I<from> and the four lowest bits of "
"I<flags> to 0. For both methods, I<offset> indicates the location of the IP "
"checksum within the packet. In addition to the size of the field, I<flags> "
"can be added (bitwise OR) actual flags. With B<BPF_F_MARK_MANGLED_0>, a null "
"checksum is left untouched (unless B<BPF_F_MARK_ENFORCE> is added as well), "
"and for updates resulting in a null checksum the value is set to "
"B<CSUM_MANGLED_0> instead. Flag B<BPF_F_PSEUDO_HDR> indicates the checksum "
"is to be computed against a pseudo-header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:385
#, no-wrap
msgid ""
"B<long bpf_tail_call(void *>I<ctx>B<, struct bpf_map *>I<prog_array_map>B<, "
"u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:399
msgid ""
"This special helper is used to trigger a \"tail call\", or in other words, "
"to jump into another eBPF program. The same stack frame is used (but values "
"on stack and in registers for the caller are not accessible to the "
"callee). This mechanism allows for program chaining, either for raising the "
"maximum number of available eBPF instructions, or to execute given programs "
"in conditional blocks. For security reasons, there is an upper limit to the "
"number of successive tail calls that can be performed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:404
msgid ""
"Upon call of this helper, the program attempts to jump into a program "
"referenced at index I<index> in I<prog_array_map>, a special map of type "
"B<BPF_MAP_TYPE_PROG_ARRAY>, and passes I<ctx>, a pointer to the context."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:416
msgid ""
"If the call succeeds, the kernel immediately runs the first instruction of "
"the new program. This is not a function call, and it never returns to the "
"previous program. If the call fails, then the helper has no effect, and the "
"caller continues to run its subsequent instructions. A call can fail if the "
"destination program for the jump does not exist (i.e. I<index> is superior "
"to the number of entries in I<prog_array_map>), or if the maximum number of "
"tail calls has been reached for this chain of programs. This limit is "
"defined in the kernel by the macro B<MAX_TAIL_CALL_CNT> (not accessible to "
"user space), which is currently set to 32."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:420
#, no-wrap
msgid ""
"B<long bpf_clone_redirect(struct sk_buff *>I<skb>B<, u32 >I<ifindex>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:431
msgid ""
"Clone and redirect the packet associated to I<skb> to another net device of "
"index I<ifindex>\\&. Both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise).  This is the only flag supported for now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:438
msgid ""
"In comparison with B<bpf_redirect>() helper, B<bpf_clone_redirect>() has the "
"associated cost of duplicating the packet buffer, but this can be executed "
"out of the eBPF program. Conversely, B<bpf_redirect>() is more efficient, "
"but it is handled through an action code where the redirection happens only "
"after the eBPF program has returned."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:448
#, no-wrap
msgid "B<u64 bpf_get_current_pid_tgid(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:457
msgid ""
"A 64-bit integer containing the current tgid and pid, and created as such: "
"I<current_task>B<-E<gt>tgid E<lt>E<lt> 32 |> I<current_task>B<-E<gt>pid>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:458
#, no-wrap
msgid "B<u64 bpf_get_current_uid_gid(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:465
msgid ""
"A 64-bit integer containing the current GID and UID, and created as such: "
"I<current_gid> B<E<lt>E<lt> 32 |> I<current_uid>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:466
#, no-wrap
msgid "B<long bpf_get_current_comm(void *>I<buf>B<, u32 >I<size_of_buf>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:477
msgid ""
"Copy the B<comm> attribute of the current task into I<buf> of "
"I<size_of_buf>\\&. The B<comm> attribute contains the name of the executable "
"(excluding the path) for the current task. The I<size_of_buf> must be "
"strictly positive. On success, the helper makes sure that the I<buf> is "
"NUL-terminated. On failure, it is filled with zeroes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:481
#, no-wrap
msgid "B<u32 bpf_get_cgroup_classid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:488
msgid ""
"Retrieve the classid for the current task, i.e. for the net_cls cgroup to "
"which I<skb> belongs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:490
msgid "This helper can be used on TC egress path, but not on ingress."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:496
msgid ""
"The net_cls cgroup provides an interface to tag network packets based on a "
"user-provided identifier for all traffic coming from the tasks belonging to "
"the related cgroup. See also the related kernel documentation, available "
"from the Linux sources in file "
"I<Documentation/admin-guide/cgroup-v1/net_cls.rst>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:503
msgid ""
"The Linux kernel has two versions for cgroups: there are cgroups v1 and "
"cgroups v2. Both are available to users, who can use a mixture of them, but "
"note that the net_cls cgroup is for cgroup v1 only. This makes it "
"incompatible with BPF programs run on cgroups, which is a cgroup-v2-only "
"feature (a socket can only hold data for one version of cgroups at a time)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:507
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_CGROUP_NET_CLASSID> configuration option set to \"B<y>\" or to "
"\"B<m>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:510
msgid "The classid, or 0 for the default unconfigured classid."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:511
#, no-wrap
msgid ""
"B<long bpf_skb_vlan_push(struct sk_buff *>I<skb>B<, __be16 >I<vlan_proto>B<, "
"u16 >I<vlan_tci>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:521
msgid ""
"Push a I<vlan_tci> (VLAN tag control information) of protocol I<vlan_proto> "
"to the packet associated to I<skb>, then update the checksum. Note that if "
"I<vlan_proto> is different from B<ETH_P_8021Q> and B<ETH_P_8021AD>, it is "
"considered to be B<ETH_P_8021Q>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:531
#, no-wrap
msgid "B<long bpf_skb_vlan_pop(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:537
msgid "Pop a VLAN header from the packet associated to I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:547
#, no-wrap
msgid ""
"B<long bpf_skb_get_tunnel_key(struct sk_buff *>I<skb>B<, struct "
"bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:558
msgid ""
"Get tunnel metadata. This helper takes a pointer I<key> to an empty B<struct "
"bpf_tunnel_key> of B<size>, that will be filled with tunnel metadata for the "
"packet associated to I<skb>\\&.  The I<flags> can be set to "
"B<BPF_F_TUNINFO_IPV6>, which indicates that the tunnel is based on IPv6 "
"protocol instead of IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:569
msgid ""
"The B<struct bpf_tunnel_key> is an object that generalizes the principal "
"parameters used by various tunneling protocols into a single struct. This "
"way, it can be used to easily make a decision based on the contents of the "
"encapsulation header, \"summarized\" in this struct. In particular, it holds "
"the IP address of the remote end (IPv4 or IPv6, depending on the case)  in "
"I<key>B<-E<gt>remote_ipv4> or I<key>B<-E<gt>remote_ipv6>\\&. Also, this "
"struct exposes the I<key>B<-E<gt>tunnel_id>, which is generally mapped to a "
"VNI (Virtual Network Identifier), making it programmable together with the "
"B<bpf_skb_set_tunnel_key>() helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:574
msgid ""
"Let\\(aqs imagine that the following code is part of a program attached to "
"the TC ingress interface, on one end of a GRE tunnel, and is supposed to "
"filter out all messages coming from remote ends with IPv4 address other than "
"10.0.0.1:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:580
#, no-wrap
msgid ""
"int ret;\n"
"struct bpf_tunnel_key key = {};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:584
#, no-wrap
msgid ""
"ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n"
"if (ret E<lt> 0)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:587
#, no-wrap
msgid ""
"if (key.remote_ipv4 != 0x0a000001)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:589
#, no-wrap
msgid "return TC_ACT_OK;               // accept packet\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:598
msgid ""
"This interface can also be used with all encapsulation devices that can "
"operate in \"collect metadata\" mode: instead of having one network device "
"per specific configuration, the \"collect metadata\" mode only requires a "
"single device where the configuration can be extracted from this helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:601
msgid ""
"This can be used together with various tunnels such as VXLan, Geneve, GRE or "
"IP in IP (IPIP)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:605
#, no-wrap
msgid ""
"B<long bpf_skb_set_tunnel_key(struct sk_buff *>I<skb>B<, struct "
"bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:613
msgid ""
"Populate tunnel metadata for packet associated to I<skb.> The tunnel "
"metadata is set to the contents of I<key>, of I<size>\\&. The I<flags> can "
"be set to a combination of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:614
#, no-wrap
msgid "B<BPF_F_TUNINFO_IPV6>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:618
msgid "Indicate that the tunnel is based on IPv6 protocol instead of IPv4."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:618
#, no-wrap
msgid "B<BPF_F_ZERO_CSUM_TX>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:623
msgid ""
"For IPv4 packets, add a flag to tunnel metadata indicating that checksum "
"computation should be skipped and checksum set to zeroes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:623
#, no-wrap
msgid "B<BPF_F_DONT_FRAGMENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:627
msgid ""
"Add a flag to tunnel metadata indicating that the packet should not be "
"fragmented."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:627
#, no-wrap
msgid "B<BPF_F_SEQ_NUMBER>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:634
msgid ""
"Add a flag to tunnel metadata indicating that a sequence number should be "
"added to tunnel header before sending the packet. This flag was added for "
"GRE encapsulation, but might be used with other protocols as well in the "
"future."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:637
msgid "Here is a typical usage on the transmit path:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:645
#, no-wrap
msgid ""
"struct bpf_tunnel_key key;\n"
"     populate key ...\n"
"bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n"
"bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:651
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_key>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:655
#, no-wrap
msgid "B<u64 bpf_perf_event_read(struct bpf_map *>I<map>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:670
msgid ""
"Read the value of a perf event counter. This helper relies on a I<map> of "
"type B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event "
"counter is selected when I<map> is updated with perf event file "
"descriptors. The I<map> is an array whose size is the number of available "
"CPUs, and each cell contains a value relative to one CPU. The value to "
"retrieve is indicated by I<flags>, that contains the index of the CPU to "
"look up, masked with B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be "
"set to B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU "
"should be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:673
msgid "Note that before Linux 4.13, only hardware perf event can be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:682
msgid ""
"Also, be aware that the newer helper B<bpf_perf_event_read_value>() is "
"recommended over B<bpf_perf_event_read>() in general. The latter has some "
"ABI quirks where error and counter value are used as a return code (which is "
"wrong to do since ranges may overlap). This issue is fixed with "
"B<bpf_perf_event_read_value>(), which at the same time provides more "
"features over the B<bpf_perf_event_read>() interface. Please refer to the "
"description of B<bpf_perf_event_read_value>() for details."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:686
msgid ""
"The value of the perf event counter read from the map, or a negative error "
"code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:687
#, no-wrap
msgid "B<long bpf_redirect(u32 >I<ifindex>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:695
msgid ""
"Redirect the packet to another net device of index I<ifindex>\\&.  This "
"helper is somewhat similar to B<bpf_clone_redirect>(), except that the "
"packet is not cloned, which provides increased performance."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:702
msgid ""
"Except for XDP, both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise). Currently, XDP only supports redirection to the egress "
"interface, and accepts no flag at all."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:706
msgid ""
"The same effect can also be attained with the more generic "
"B<bpf_redirect_map>(), which uses a BPF map to store the redirect target "
"instead of providing it directly to the helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:712
msgid ""
"For XDP, the helper returns B<XDP_REDIRECT> on success or B<XDP_ABORTED> on "
"error. For other program types, the values are B<TC_ACT_REDIRECT> on success "
"or B<TC_ACT_SHOT> on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:713
#, no-wrap
msgid "B<u32 bpf_get_route_realm(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:724
msgid ""
"Retrieve the realm or the route, that is to say the B<tclassid> field of the "
"destination for the I<skb>\\&. The identifier retrieved is a user-provided "
"tag, similar to the one used with the net_cls cgroup (see description for "
"B<bpf_get_cgroup_classid>() helper), but here this tag is held by a route (a "
"destination entry), not by a task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:733
msgid ""
"Retrieving this identifier works with the clsact TC egress hook (see also "
"B<tc-bpf(8)>), or alternatively on conventional classful egress qdiscs, but "
"not on TC ingress path. In case of clsact TC egress hook, this has the "
"advantage that, internally, the destination entry has not been dropped yet "
"in the transmit path. Therefore, the destination entry does not need to be "
"artificially held via B<netif_keep_dst>() for a classful qdisc until the "
"I<skb> is freed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:736
msgid ""
"This helper is available only if the kernel was compiled with "
"B<CONFIG_IP_ROUTE_CLASSID> configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:740
msgid ""
"The realm of the route for the packet associated to I<skb>, or 0 if none was "
"found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:741
#, no-wrap
msgid ""
"B<long bpf_perf_event_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 "
">I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:751 build/C/man7/bpf-helpers.7:2942 build/C/man7/bpf-helpers.7:3133
msgid ""
"Write raw I<data> blob into a special BPF perf event held by I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. This perf event must have the following "
"attributes: B<PERF_SAMPLE_RAW> as B<sample_type>, B<PERF_TYPE_SOFTWARE> as "
"B<type>, and B<PERF_COUNT_SW_BPF_OUTPUT> as B<config>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:757 build/C/man7/bpf-helpers.7:2948 build/C/man7/bpf-helpers.7:3139
msgid ""
"The I<flags> are used to indicate the index in I<map> for which the value "
"must be put, masked with B<BPF_F_INDEX_MASK>\\&.  Alternatively, I<flags> "
"can be set to B<BPF_F_CURRENT_CPU> to indicate that the index of the current "
"CPU core should be used."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:760 build/C/man7/bpf-helpers.7:2951 build/C/man7/bpf-helpers.7:3142
msgid ""
"The value to write, of I<size>, is passed through eBPF stack and pointed by "
"I<data>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:763
msgid "The context of the program I<ctx> needs also be passed to the helper."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:772
msgid ""
"On user space, a program willing to read the values needs to call "
"B<perf_event_open>() on the perf event (either for one or for all CPUs) and "
"to store the file descriptor into the I<map>\\&. This must be done before "
"the eBPF program can send data into it. An example is available in file "
"I<samples/bpf/trace_output_user.c> in the Linux kernel source tree (the eBPF "
"program counterpart is in I<samples/bpf/trace_output_kern.c>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:777
msgid ""
"B<bpf_perf_event_output>() achieves better performance than "
"B<bpf_trace_printk>() for sharing data with user space, and is much better "
"suitable for streaming data from eBPF programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:782
msgid ""
"Note that this helper is not restricted to tracing use cases and can be used "
"with programs attached to TC or XDP as well, where it allows for passing "
"data to user space listeners. Data can be:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:785
msgid "Only custom structs,"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:787
msgid "Only the packet payload, or"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:789
msgid "A combination of both."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:794
#, no-wrap
msgid ""
"B<long bpf_skb_load_bytes(const void *>I<skb>B<, u32 >I<offset>B<, void "
"*>I<to>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:803
msgid ""
"This helper was provided as an easy way to load data from a packet. It can "
"be used to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:811
msgid ""
"Since Linux 4.7, usage of this helper has mostly been replaced by \"direct "
"packet access\", enabling packet data to be manipulated with "
"I<skb>B<-E<gt>data> and I<skb>B<-E<gt>data_end> pointing respectively to the "
"first byte of packet data and to the byte after the last byte of packet "
"data. However, it remains useful if one wishes to read large quantities of "
"data at once from a packet into the eBPF stack."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:815
#, no-wrap
msgid ""
"B<long bpf_get_stackid(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:824
msgid ""
"Walk a user or a kernel stack and return its id. To achieve this, the helper "
"needs I<ctx>, which is a pointer to the context on which the tracing program "
"is executed, and a pointer to a I<map> of type "
"B<BPF_MAP_TYPE_STACK_TRACE>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:829
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set a combination of the following flags:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:830 build/C/man7/bpf-helpers.7:1914 build/C/man7/bpf-helpers.7:3566
#, no-wrap
msgid "B<BPF_F_USER_STACK>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:833 build/C/man7/bpf-helpers.7:1917 build/C/man7/bpf-helpers.7:3569
msgid "Collect a user space stack instead of a kernel stack."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:833
#, no-wrap
msgid "B<BPF_F_FAST_STACK_CMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:836
msgid "Compare stacks by hash only."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:836
#, no-wrap
msgid "B<BPF_F_REUSE_STACKID>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:840
msgid "If two different stacks hash into the same I<stackid>, discard the old one."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:847
msgid ""
"The stack id retrieved is a 32 bit long integer handle which can be further "
"combined with other data (including other stack ids) and used as a key into "
"maps. This can be useful for generating a variety of graphs (such as flame "
"graphs or off-cpu graphs)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:856
msgid ""
"For walking a stack, this helper is an improvement over B<bpf_probe_read>(), "
"which can be used with unrolled loops but is not efficient and consumes a "
"lot of eBPF instructions.  Instead, B<bpf_get_stackid>() can collect up to "
"B<PERF_MAX_STACK_DEPTH> both kernel and user frames. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually "
"increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:861 build/C/man7/bpf-helpers.7:1934 build/C/man7/bpf-helpers.7:3586
#, no-wrap
msgid "# sysctl kernel.perf_event_max_stack=E<lt>new valueE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:868
msgid ""
"The positive or null stack id on success, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:869
#, no-wrap
msgid ""
"B<s64 bpf_csum_diff(__be32 *>I<from>B<, u32 >I<from_size>B<, __be32 "
"*>I<to>B<, u32 >I<to_size>B<, __wsum >I<seed>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:880
msgid ""
"Compute a checksum difference, from the raw buffer pointed by I<from>, of "
"length I<from_size> (that must be a multiple of 4), towards the raw buffer "
"pointed by I<to>, of size I<to_size> (same remark). An optional I<seed> can "
"be added to the value (this can be cascaded, the seed may come from a "
"previous call to the helper)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:882
msgid "This is flexible enough to be used in several ways:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:886
msgid ""
"With I<from_size> == 0, I<to_size> E<gt> 0 and I<seed> set to checksum, it "
"can be used when pushing new data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:889
msgid ""
"With I<from_size> E<gt> 0, I<to_size> == 0 and I<seed> set to checksum, it "
"can be used when removing data from a packet."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:893
msgid ""
"With I<from_size> E<gt> 0, I<to_size> E<gt> 0 and I<seed> set to 0, it can "
"be used to compute a diff. Note that I<from_size> and I<to_size> do not need "
"to be equal."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:899
msgid ""
"This helper can be used in combination with B<bpf_l3_csum_replace>() and "
"B<bpf_l4_csum_replace>(), to which one can feed in the difference computed "
"with B<bpf_csum_diff>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:903
msgid "The checksum result, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:904
#, no-wrap
msgid ""
"B<long bpf_skb_get_tunnel_opt(struct sk_buff *>I<skb>B<, void *>I<opt>B<, "
"u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:912
msgid ""
"Retrieve tunnel options metadata for the packet associated to I<skb>, and "
"store the raw tunnel option data to the buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:922
msgid ""
"This helper can be used with encapsulation devices that can operate in "
"\"collect metadata\" mode (please refer to the related note in the "
"description of B<bpf_skb_get_tunnel_key>() for more details). A particular "
"example where this can be used is in combination with the Geneve "
"encapsulation protocol, where it allows for pushing (with "
"B<bpf_skb_get_tunnel_opt>() helper)  and retrieving arbitrary TLVs "
"(Type-Length-Value headers) from the eBPF program. This allows for full "
"customization of these headers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:925
msgid "The size of the option data retrieved."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:926
#, no-wrap
msgid ""
"B<long bpf_skb_set_tunnel_opt(struct sk_buff *>I<skb>B<, void *>I<opt>B<, "
"u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:933
msgid ""
"Set tunnel options metadata for the packet associated to I<skb> to the "
"option data contained in the raw buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:936
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_opt>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:940
#, no-wrap
msgid ""
"B<long bpf_skb_change_proto(struct sk_buff *>I<skb>B<, __be16 >I<proto>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:953
msgid ""
"Change the protocol of the I<skb> to I<proto>\\&. Currently supported are "
"transition from IPv4 to IPv6, and from IPv6 to IPv4. The helper takes care "
"of the groundwork for the transition, including resizing the socket "
"buffer. The eBPF program is expected to fill the new headers, if any, via "
"B<skb_store_bytes>() and to recompute the checksums with "
"B<bpf_l3_csum_replace>() and B<bpf_l4_csum_replace>(). The main case for "
"this helper is to perform NAT64 operations out of an eBPF program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:957
msgid ""
"Internally, the GSO type is marked as dodgy so that headers are checked and "
"segments are recalculated by the GSO/GRO engine.  The size for GSO target is "
"adapted as well."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:960 build/C/man7/bpf-helpers.7:1219 build/C/man7/bpf-helpers.7:1834 build/C/man7/bpf-helpers.7:1891 build/C/man7/bpf-helpers.7:2371 build/C/man7/bpf-helpers.7:2415
msgid ""
"All values for I<flags> are reserved for future usage, and must be left at "
"zero."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:970
#, no-wrap
msgid "B<long bpf_skb_change_type(struct sk_buff *>I<skb>B<, u32 >I<type>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:979
msgid ""
"Change the packet type for the packet associated to I<skb>\\&. This comes "
"down to setting I<skb>B<-E<gt>pkt_type> to I<type>, except the eBPF program "
"does not have a write access to I<skb>B<-E<gt>pkt_type> beside this "
"helper. Using a helper here allows for graceful handling of errors."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:984
msgid ""
"The major use case is to change incoming I<skb*s to **PACKET_HOST*> in a "
"programmatic way instead of having to recirculate via B<redirect>(..., "
"B<BPF_F_INGRESS>), for example."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:987
msgid "Note that I<type> only allows certain values. At this time, they are:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:988
#, no-wrap
msgid "B<PACKET_HOST>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:991
msgid "Packet is for us."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:991
#, no-wrap
msgid "B<PACKET_BROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:994
msgid "Send packet to all."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:994
#, no-wrap
msgid "B<PACKET_MULTICAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:997
msgid "Send packet to group."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:997
#, no-wrap
msgid "B<PACKET_OTHERHOST>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1000
msgid "Send packet to someone else."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1005
#, no-wrap
msgid ""
"B<long bpf_skb_under_cgroup(struct sk_buff *>I<skb>B<, struct bpf_map "
"*>I<map>B<, u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1012
msgid ""
"Check whether I<skb> is a descendant of the cgroup2 held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1015 build/C/man7/bpf-helpers.7:1085
msgid "The return value depends on the result of the test, and can be:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1018
msgid "0, if the I<skb> failed the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1020
msgid "1, if the I<skb> succeeded the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1022 build/C/man7/bpf-helpers.7:1092
msgid "A negative error code, if an error occurred."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1024
#, no-wrap
msgid "B<u32 bpf_get_hash_recalc(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1033
msgid ""
"Retrieve the hash of the packet, I<skb>B<-E<gt>hash>\\&. If it is not set, "
"in particular if the hash was cleared due to mangling, recompute this "
"hash. Later accesses to the hash can be done directly with "
"I<skb>B<-E<gt>hash>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1040
msgid ""
"Calling B<bpf_set_hash_invalid>(), changing a packet prototype with "
"B<bpf_skb_change_proto>(), or calling B<bpf_skb_store_bytes>() with the "
"B<BPF_F_INVALIDATE_HASH> are actions susceptible to clear the hash and to "
"trigger a new computation for the next call to B<bpf_get_hash_recalc>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1043
msgid "The 32-bit hash."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1044
#, no-wrap
msgid "B<u64 bpf_get_current_task(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1050
msgid "A pointer to the current task struct."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1051
#, no-wrap
msgid ""
"B<long bpf_probe_write_user(void *>I<dst>B<, const void *>I<src>B<, u32 "
">I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1059
msgid ""
"Attempt in a safe way to write I<len> bytes from the buffer I<src> to I<dst> "
"in memory. It only works for threads that are in user context, and I<dst> "
"must be a valid user space address."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1064
msgid ""
"This helper should not be used to implement any kind of security mechanism "
"because of TOC-TOU attacks, but rather to debug, divert, and manipulate "
"execution of semi-cooperative processes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1070
msgid ""
"Keep in mind that this feature is meant for experiments, and it has a risk "
"of crashing the system and running programs.  Therefore, when an eBPF "
"program using this helper is attached, a warning including PID and process "
"name is printed to kernel logs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1074
#, no-wrap
msgid ""
"B<long bpf_current_task_under_cgroup(struct bpf_map *>I<map>B<, u32 "
">I<index>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1082
msgid ""
"Check whether the probe is being run is the context of a given subset of the "
"cgroup2 hierarchy. The cgroup2 to test is held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1088
msgid "0, if the I<skb> task belongs to the cgroup2."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1090
msgid "1, if the I<skb> task does not belong to the cgroup2."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1094
#, no-wrap
msgid ""
"B<long bpf_skb_change_tail(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1102
msgid ""
"Resize (trim or grow) the packet associated to I<skb> to the new "
"I<len>\\&. The I<flags> are reserved for future usage, and must be left at "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1112
msgid ""
"The basic idea is that the helper performs the needed work to change the "
"size of the packet, then the eBPF program rewrites the rest via helpers like "
"B<bpf_skb_store_bytes>(), B<bpf_l3_csum_replace>(), B<bpf_l3_csum_replace>()  "
"and others. This helper is a slow path utility intended for replies with "
"control messages. And because it is targeted for slow path, the helper "
"itself can afford to be slow: it implicitly linearizes, unclones and drops "
"offloads from the I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1122
#, no-wrap
msgid "B<long bpf_skb_pull_data(struct sk_buff *>I<skb>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1131
msgid ""
"Pull in non-linear data in case the I<skb> is non-linear and not all of "
"I<len> are part of the linear section. Make I<len> bytes from I<skb> "
"readable and writable. If a zero value is passed for I<len>, then the whole "
"length of the I<skb> is pulled."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1134
msgid ""
"This helper is only needed for reading and writing with direct packet "
"access."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1145
msgid ""
"For direct packet access, testing that offsets to access are within packet "
"boundaries (test on I<skb>B<-E<gt>data_end>) is susceptible to fail if "
"offsets are invalid, or if the requested data is in non-linear parts of the "
"I<skb>\\&. On failure the program can just bail out, or in the case of a "
"non-linear buffer, use a helper to make the data available. The "
"B<bpf_skb_load_bytes>() helper is a first solution to access the "
"data. Another one consists in using B<bpf_skb_pull_data> to pull in once the "
"non-linear parts, then retesting and eventually access the data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1152
msgid ""
"At the same time, this also makes sure the I<skb> is uncloned, which is a "
"necessary condition for direct write. As this needs to be an invariant for "
"the write part only, the verifier detects writes and adds a prologue that is "
"calling B<bpf_skb_pull_data()> to effectively unclone the I<skb> from the "
"very beginning in case it is indeed cloned."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1162
#, no-wrap
msgid "B<s64 bpf_csum_update(struct sk_buff *>I<skb>B<, __wsum >I<csum>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1173
msgid ""
"Add the checksum I<csum> into I<skb>B<-E<gt>csum> in case the driver has "
"supplied a checksum for the entire packet into that field. Return an error "
"otherwise. This helper is intended to be used in combination with "
"B<bpf_csum_diff>(), in particular when the checksum needs to be updated "
"after data has been written into the packet through direct packet access."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1177
msgid "The checksum on success, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1178
#, no-wrap
msgid "B<void bpf_set_hash_invalid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1188
msgid ""
"Invalidate the current I<skb>B<-E<gt>hash>\\&. It can be used after mangling "
"on headers through direct packet access, in order to indicate that the hash "
"is outdated and to trigger a recalculation the next time the kernel tries to "
"access this hash or when the B<bpf_get_hash_recalc>() helper is called."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1189
#, no-wrap
msgid "B<long bpf_get_numa_node_id(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1200
msgid ""
"Return the id of the current NUMA node. The primary use case for this helper "
"is the selection of sockets for the local NUMA node, when the program is "
"attached to sockets using the B<SO_ATTACH_REUSEPORT_EBPF> option (see also "
"B<socket(7)>), but the helper is also available to other eBPF program types, "
"similarly to B<bpf_get_smp_processor_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1203
msgid "The id of current NUMA node."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1204
#, no-wrap
msgid ""
"B<long bpf_skb_change_head(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1213
msgid ""
"Grows headroom of packet associated to I<skb> and adjusts the offset of the "
"MAC header accordingly, adding I<len> bytes of space. It automatically "
"extends and reallocates memory as required."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1216
msgid ""
"This helper can be used on a layer 3 I<skb> to push a MAC header for "
"redirection into a layer 2 device."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1229
#, no-wrap
msgid "B<long bpf_xdp_adjust_head(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1238
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data> by I<delta> bytes. Note that it is "
"possible to use a negative value for I<delta>\\&. This helper can be used to "
"prepare the packet for pushing or popping headers."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1248
#, no-wrap
msgid ""
"B<long bpf_probe_read_str(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1256
msgid ""
"Copy a NUL terminated string from an unsafe kernel address I<unsafe_ptr> to "
"I<dst>\\&. See B<bpf_probe_read_kernel_str>() for more details."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1259
msgid ""
"Generally, use B<bpf_probe_read_user_str>() or "
"B<bpf_probe_read_kernel_str>() instead."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1264 build/C/man7/bpf-helpers.7:3032 build/C/man7/bpf-helpers.7:3044
msgid ""
"On success, the strictly positive length of the string, including the "
"trailing NUL character. On error, a negative value."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1265
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1277
msgid ""
"If the B<struct sk_buff> pointed by I<skb> has a known socket, retrieve the "
"cookie (generated by the kernel) of this socket.  If no cookie has been set "
"yet, generate a new cookie. Once generated, the socket cookie remains stable "
"for the life of the socket. This helper can be useful for monitoring per "
"socket networking traffic statistics as it provides a global socket "
"identifier that can be assumed unique."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1281
msgid ""
"A 8-byte long non-decreasing number on success, or 0 if the socket field is "
"missing inside I<skb>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1282
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_addr *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1289
msgid ""
"Equivalent to bpf_get_socket_cookie() helper that accepts I<skb>, but gets "
"socket from B<struct bpf_sock_addr> context."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1292 build/C/man7/bpf-helpers.7:1303
msgid "A 8-byte long non-decreasing number."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1293
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_ops *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1300
msgid ""
"Equivalent to B<bpf_get_socket_cookie>() helper that accepts I<skb>, but "
"gets socket from B<struct bpf_sock_ops> context."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1304
#, no-wrap
msgid "B<u32 bpf_get_socket_uid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1314
msgid ""
"The owner UID of the socket associated to I<skb>\\&. If the socket is "
"B<NULL>, or if it is not a full socket (i.e. if it is a time-wait or a "
"request socket instead), B<overflowuid> value is returned (note that "
"B<overflowuid> might also be the actual UID value for the socket)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1315
#, no-wrap
msgid "B<long bpf_set_hash(struct sk_buff *>I<skb>B<, u32 >I<hash>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1322
msgid ""
"Set the full hash for I<skb> (set the field I<skb>B<-E<gt>hash>)  to value "
"I<hash>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1326
#, no-wrap
msgid ""
"B<long bpf_setsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int "
">I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1336
msgid ""
"Emulate a call to B<setsockopt()> on the socket associated to I<bpf_socket>, "
"which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<setsockopt(2)> "
"for more information.  The option value of length I<optlen> is pointed by "
"I<optval>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1338 build/C/man7/bpf-helpers.7:1610
msgid "I<bpf_socket> should be one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1341 build/C/man7/bpf-helpers.7:1613
msgid "B<struct bpf_sock_ops> for B<BPF_PROG_TYPE_SOCK_OPS>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1344 build/C/man7/bpf-helpers.7:1616
msgid ""
"B<struct bpf_sock_addr> for B<BPF_CGROUP_INET4_CONNECT> and "
"B<BPF_CGROUP_INET6_CONNECT>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1348
msgid ""
"This helper actually implements a subset of B<setsockopt()>\\&.  It supports "
"the following I<level>s:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1354
msgid ""
"B<SOL_SOCKET>, which supports the following I<optname>s: B<SO_RCVBUF>, "
"B<SO_SNDBUF>, B<SO_MAX_PACING_RATE>, B<SO_PRIORITY>, B<SO_RCVLOWAT>, "
"B<SO_MARK>, B<SO_BINDTODEVICE>, B<SO_KEEPALIVE>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1360
msgid ""
"B<IPPROTO_TCP>, which supports the following I<optname>s: B<TCP_CONGESTION>, "
"B<TCP_BPF_IW>, B<TCP_BPF_SNDCWND_CLAMP>, B<TCP_SAVE_SYN>, B<TCP_KEEPIDLE>, "
"B<TCP_KEEPINTVL>, B<TCP_KEEPCNT>, B<TCP_SYNCNT>, B<TCP_USER_TIMEOUT>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1362 build/C/man7/bpf-helpers.7:1626
msgid "B<IPPROTO_IP>, which supports I<optname> B<IP_TOS>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1364 build/C/man7/bpf-helpers.7:1628
msgid "B<IPPROTO_IPV6>, which supports I<optname> B<IPV6_TCLASS>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1369
#, no-wrap
msgid ""
"B<long bpf_skb_adjust_room(struct sk_buff *>I<skb>B<, s32 >I<len_diff>B<, "
"u32 >I<mode>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1376
msgid ""
"Grow or shrink the room for data in the packet associated to I<skb> by "
"I<len_diff>, and according to the selected I<mode>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1380
msgid ""
"By default, the helper will reset any offloaded checksum indicator of the "
"skb to CHECKSUM_NONE. This can be avoided by the following flag:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1384
msgid ""
"B<BPF_F_ADJ_ROOM_NO_CSUM_RESET>: Do not reset offloaded checksum data of the "
"skb to CHECKSUM_NONE."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1387
msgid "There are two supported modes at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1391
msgid ""
"B<BPF_ADJ_ROOM_MAC>: Adjust room at the mac layer (room space is added or "
"removed below the layer 2 header)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1394
msgid ""
"B<BPF_ADJ_ROOM_NET>: Adjust room at the network layer (room space is added "
"or removed below the layer 3 header)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1397
msgid "The following flags are supported at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1401
msgid ""
"B<BPF_F_ADJ_ROOM_FIXED_GSO>: Do not adjust gso_size.  Adjusting mss in this "
"way is not allowed for datagrams."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1406
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L3_IPV4>, B<BPF_F_ADJ_ROOM_ENCAP_L3_IPV6>: Any new "
"space is reserved to hold a tunnel header.  Configure skb offsets and other "
"fields accordingly."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1410
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L4_GRE>, B<BPF_F_ADJ_ROOM_ENCAP_L4_UDP>: Use with "
"ENCAP_L3 flags to further specify the tunnel type."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1414
msgid ""
"B<BPF_F_ADJ_ROOM_ENCAP_L2>(I<len>): Use with ENCAP_L3/L4 flags to further "
"specify the tunnel type; I<len> is the length of the inner MAC header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1425
#, no-wrap
msgid ""
"B<long bpf_redirect_map(struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1436
msgid ""
"Redirect the packet to the endpoint referenced by I<map> at index "
"I<key>\\&. Depending on its type, this I<map> can contain references to net "
"devices (for forwarding packets through other ports), or to CPUs (for "
"redirecting XDP frames to another CPU; but this is only implemented for "
"native XDP (with driver support) as of this writing)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1442
msgid ""
"The lower two bits of I<flags> are used as the return code if the map lookup "
"fails. This is so that the return value can be one of the XDP program return "
"codes up to B<XDP_TX>, as chosen by the caller. Any higher bits in the "
"I<flags> argument must be unset."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1445
msgid ""
"See also B<bpf_redirect>(), which only supports redirecting to an ifindex, "
"but doesn\\(aqt require a map to do so."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1449
msgid ""
"B<XDP_REDIRECT> on success, or the value of the two lower bits of the "
"I<flags> argument on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1450
#, no-wrap
msgid ""
"B<long bpf_sk_redirect_map(struct sk_buff *>I<skb>B<, struct bpf_map "
"*>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1461
msgid ""
"Redirect the packet to the socket referenced by I<map> (of type "
"B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1464 build/C/man7/bpf-helpers.7:1740 build/C/man7/bpf-helpers.7:2058 build/C/man7/bpf-helpers.7:2076
msgid "B<SK_PASS> on success, or B<SK_DROP> on error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1465
#, no-wrap
msgid ""
"B<long bpf_sock_map_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1473
msgid ""
"Add an entry to, or update a I<map> referencing sockets. The I<skops> is "
"used as a new value for the entry associated to I<key>\\&. I<flags> is one "
"of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1488 build/C/man7/bpf-helpers.7:2037
msgid ""
"If the I<map> has eBPF programs (parser and verdict), those will be "
"inherited by the socket being added. If the socket is already attached to "
"eBPF programs, this results in an error."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1492
#, no-wrap
msgid "B<long bpf_xdp_adjust_meta(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1502
msgid ""
"Adjust the address pointed by I<xdp_md>B<-E<gt>data_meta> by I<delta> (which "
"can be positive or negative). Note that this operation modifies the address "
"stored in I<xdp_md>B<-E<gt>data>, so the latter must be loaded only after "
"the helper has been called."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1515
msgid ""
"The use of I<xdp_md>B<-E<gt>data_meta> is optional and programs are not "
"required to use it. The rationale is that when the packet is processed with "
"XDP (e.g. as DoS filter), it is possible to push further meta data along "
"with it before passing to the stack, and to give the guarantee that an "
"ingress eBPF program attached as a TC classifier on the same device can pick "
"this up for further post-processing. Since TC works with socket buffers, it "
"remains possible to set from XDP the B<mark> or B<priority> pointers, or "
"other pointers for the socket buffer.  Having this scratch space generic and "
"programmable allows for more flexibility as the user is free to store "
"whatever meta data they need."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1525
#, no-wrap
msgid ""
"B<long bpf_perf_event_read_value(struct bpf_map *>I<map>B<, u64 >I<flags>B<, "
"struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1541
msgid ""
"Read the value of a perf event counter, and store it into I<buf> of size "
"I<buf_size>\\&. This helper relies on a I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event counter is "
"selected when I<map> is updated with perf event file descriptors. The I<map> "
"is an array whose size is the number of available CPUs, and each cell "
"contains a value relative to one CPU. The value to retrieve is indicated by "
"I<flags>, that contains the index of the CPU to look up, masked with "
"B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be set to "
"B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU should "
"be retrieved."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1550
msgid ""
"This helper behaves in a way close to B<bpf_perf_event_read>() helper, save "
"that instead of just returning the value observed, it fills the I<buf> "
"structure. This allows for additional data to be retrieved: in particular, "
"the enabled and running times (in I<buf>B<-E<gt>enabled> and "
"I<buf>B<-E<gt>running>, respectively) are copied. In general, "
"B<bpf_perf_event_read_value>() is recommended over B<bpf_perf_event_read>(), "
"which has some ABI issues and provides fewer functionalities."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1562
msgid ""
"These values are interesting, because hardware PMU (Performance Monitoring "
"Unit) counters are limited resources. When there are more PMU based perf "
"events opened than available counters, kernel will multiplex these events so "
"each event gets certain percentage (but not all) of the PMU time. In case "
"that multiplexing happens, the number of samples or counter value will not "
"reflect the case compared to when no multiplexing occurs. This makes "
"comparison between different runs difficult.  Typically, the counter value "
"should be normalized before comparing to other experiments. The usual "
"normalization is done as follows."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1567
#, no-wrap
msgid "normalized_counter = counter * t_enabled / t_running\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1578
msgid ""
"Where t_enabled is the time enabled for event and t_running is the time "
"running for event since last normalization. The enabled and running times "
"are accumulated since the perf event open. To achieve scaling factor between "
"two invocations of an eBPF program, users can use CPU id as the key (which "
"is typical for perf array usage model) to remember the previous value and do "
"the calculation inside the eBPF program."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1582
#, no-wrap
msgid ""
"B<long bpf_perf_prog_read_value(struct bpf_perf_event_data *>I<ctx>B<, "
"struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1593
msgid ""
"For en eBPF program attached to a perf event, retrieve the value of the "
"event counter associated to I<ctx> and store it in the structure pointed by "
"I<buf> and of size I<buf_size>\\&. Enabled and running times are also stored "
"in the structure (see description of helper B<bpf_perf_event_read_value>() "
"for more details)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1597
#, no-wrap
msgid ""
"B<long bpf_getsockopt(void *>I<bpf_socket>B<, int >I<level>B<, int "
">I<optname>B<, void *>I<optval>B<, int >I<optlen>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1608
msgid ""
"Emulate a call to B<getsockopt()> on the socket associated to I<bpf_socket>, "
"which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<getsockopt(2)> "
"for more information.  The retrieved value is stored in the structure "
"pointed by I<opval> and of length I<optlen>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1620
msgid ""
"This helper actually implements a subset of B<getsockopt()>\\&.  It supports "
"the following I<level>s:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1624
msgid "B<IPPROTO_TCP>, which supports I<optname> B<TCP_CONGESTION>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1633
#, no-wrap
msgid "B<long bpf_override_return(struct pt_regs *>I<regs>B<, u64 >I<rc>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1642
msgid ""
"Used for error injection, this helper uses kprobes to override the return "
"value of the probed function, and to set it to I<rc>\\&.  The first argument "
"is the context I<regs> on which the kprobe works."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1648
msgid ""
"This helper works by setting the PC (program counter)  to an override "
"function which is run in place of the original probed function. This means "
"the probed function is not run at all. The replacement function just returns "
"with the required value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1654
msgid ""
"This helper has security implications, and thus is subject to "
"restrictions. It is only available if the kernel was compiled with the "
"B<CONFIG_BPF_KPROBE_OVERRIDE> configuration option, and in this case it only "
"works on functions tagged with B<ALLOW_ERROR_INJECTION> in the kernel code."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1658
msgid ""
"Also, the helper is only available for the architectures having the "
"CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing, x86 architecture "
"is the only one to support this feature."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1662
#, no-wrap
msgid ""
"B<long bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *>I<bpf_sock>B<, int "
">I<argval>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1670
msgid ""
"Attempt to set the value of the B<bpf_sock_ops_cb_flags> field for the full "
"TCP socket associated to I<bpf_sock_ops> to I<argval>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1680
msgid ""
"The primary use of this field is to determine if there should be calls to "
"eBPF programs of type B<BPF_PROG_TYPE_SOCK_OPS> at various points in the TCP "
"code. A program of the same type can change its value, per connection and as "
"necessary, when the connection is established. This field is directly "
"accessible for reading, but this helper must be used for updates in order to "
"return an error if an eBPF program tries to set a callback that is not "
"supported in the current kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1682
msgid "I<argval> is a flag array which can combine these flags:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1685
msgid "B<BPF_SOCK_OPS_RTO_CB_FLAG> (retransmission time out)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1687
msgid "B<BPF_SOCK_OPS_RETRANS_CB_FLAG> (retransmission)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1689
msgid "B<BPF_SOCK_OPS_STATE_CB_FLAG> (TCP state change)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1691
msgid "B<BPF_SOCK_OPS_RTT_CB_FLAG> (every RTT)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1696
msgid ""
"Therefore, this function can be used to clear a callback flag by setting the "
"appropriate bit to zero. e.g. to disable the RTO callback:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1697
#, no-wrap
msgid "B<bpf_sock_ops_cb_flags_set(bpf_sock,>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1700
msgid "B<bpf_sock-E<gt>bpf_sock_ops_cb_flags & ~BPF_SOCK_OPS_RTO_CB_FLAG)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1704
msgid "Here are some examples of where one could call such eBPF program:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1707
msgid "When RTO fires."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1709
msgid "When a packet is retransmitted."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1711
msgid "When the connection terminates."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1713
msgid "When a packet is sent."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1715
msgid "When a packet is received."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1722
msgid ""
"Code B<-EINVAL> if the socket is not a full TCP socket; otherwise, a "
"positive number containing the bits that could not be set is returned (which "
"comes down to 0 if all bits were set as required)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1723
#, no-wrap
msgid ""
"B<long bpf_msg_redirect_map(struct sk_msg_buff *>I<msg>B<, struct bpf_map "
"*>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1737
msgid ""
"This helper is used in programs implementing policies at the socket "
"level. If the message I<msg> is allowed to pass (i.e. if the verdict eBPF "
"program returns B<SK_PASS>), redirect it to the socket referenced by I<map> "
"(of type B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and "
"egress interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1741
#, no-wrap
msgid "B<long bpf_msg_apply_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1748
msgid ""
"For socket policies, apply the verdict of the eBPF program to the next "
"I<bytes> (number of bytes) of message I<msg>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1750
msgid "For example, this helper can be used in the following cases:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1755
msgid ""
"A single B<sendmsg>() or B<sendfile>() system call contains multiple logical "
"messages that the eBPF program is supposed to read and for which it should "
"apply a verdict."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1761
msgid ""
"An eBPF program only cares to read the first I<bytes> of a I<msg>\\&. If the "
"message has a large payload, then setting up and calling the eBPF program "
"repeatedly for all bytes, even though the verdict is already known, would "
"create unnecessary overhead."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1774
msgid ""
"When called from within an eBPF program, the helper sets a counter internal "
"to the BPF infrastructure, that is used to apply the last verdict to the "
"next I<bytes>\\&. If I<bytes> is smaller than the current data being "
"processed from a B<sendmsg>() or B<sendfile>() system call, the first "
"I<bytes> will be sent and the eBPF program will be re-run with the pointer "
"for start of data pointing to byte number I<bytes> B<+ 1>\\&. If I<bytes> is "
"larger than the current data being processed, then the eBPF verdict will be "
"applied to multiple B<sendmsg>() or B<sendfile>() calls until I<bytes> are "
"consumed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1778
msgid ""
"Note that if a socket closes with the internal counter holding a non-zero "
"value, this is not a problem because data is not being buffered for I<bytes> "
"and is sent as it is received."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1782
#, no-wrap
msgid "B<long bpf_msg_cork_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1790
msgid ""
"For socket policies, prevent the execution of the verdict eBPF program for "
"message I<msg> until I<bytes> (byte number) have been accumulated."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1800
msgid ""
"This can be used when one needs a specific number of bytes before a verdict "
"can be assigned, even if the data spans multiple B<sendmsg>() or "
"B<sendfile>() calls. The extreme case would be a user calling B<sendmsg>() "
"repeatedly with 1-byte long message segments. Obviously, this is bad for "
"performance, but it is still valid. If the eBPF program needs I<bytes> bytes "
"to validate a header, this helper can be used to prevent the eBPF program to "
"be called again until I<bytes> have been accumulated."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1804
#, no-wrap
msgid ""
"B<long bpf_msg_pull_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 "
">I<end>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1812
msgid ""
"For socket policies, pull in non-linear data from user space for I<msg> and "
"set pointers I<msg>B<-E<gt>data> and I<msg>B<-E<gt>data_end> to I<start> and "
"I<end> bytes offsets into I<msg>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1825
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it can only "
"parse data that the (B<data>, B<data_end>)  pointers have already "
"consumed. For B<sendmsg>() hooks this is likely the first scatterlist "
"element. But for calls relying on the B<sendpage> handler "
"(e.g. B<sendfile>()) this will be the range (B<0>, B<0>) because the data is "
"shared with user space and by default the objective is to avoid allowing "
"user space to modify data while (or after) eBPF verdict is being "
"decided. This helper can be used to pull in data and to set the start and "
"end pointer to given values. Data will be copied if necessary (i.e. if data "
"was not linear and if start and end pointers do not point to the same "
"chunk)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1838
#, no-wrap
msgid ""
"B<long bpf_bind(struct bpf_sock_addr *>I<ctx>B<, struct sockaddr "
"*>I<addr>B<, int >I<addr_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1848
msgid ""
"Bind the socket associated to I<ctx> to the address pointed by I<addr>, of "
"length I<addr_len>\\&. This allows for making outgoing connection from the "
"desired IP address, which can be useful for example when all processes "
"inside a cgroup should use one single IP address on a host that has multiple "
"IP configured."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1856
msgid ""
"This helper works for IPv4 and IPv6, TCP and UDP sockets. The domain "
"(I<addr>B<-E<gt>sa_family>) must be B<AF_INET> (or B<AF_INET6>). It\\(aqs "
"advised to pass zero port (B<sin_port> or B<sin6_port>) which triggers "
"IP_BIND_ADDRESS_NO_PORT-like behavior and lets the kernel efficiently pick "
"up an unused port as long as 4-tuple is unique. Passing non-zero port might "
"lead to degraded performance."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1860
#, no-wrap
msgid "B<long bpf_xdp_adjust_tail(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1868
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data_end> by I<delta> bytes. It is possible "
"to both shrink and grow the packet tail.  Shrink done via I<delta> being a "
"negative integer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1878
#, no-wrap
msgid ""
"B<long bpf_skb_get_xfrm_state(struct sk_buff *>I<skb>B<, u32 >I<index>B<, "
"struct bpf_xfrm_state *>I<xfrm_state>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1885
msgid ""
"Retrieve the XFRM state (IP transform framework, see also B<ip-xfrm(8)>) at "
"I<index> in XFRM \"security path\" for I<skb>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1888
msgid ""
"The retrieved value is stored in the B<struct bpf_xfrm_state> pointed by "
"I<xfrm_state> and of length I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1894
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_XFRM> "
"configuration option."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1898
#, no-wrap
msgid ""
"B<long bpf_get_stack(void *>I<ctx>B<, void *>I<buf>B<, u32 >I<size>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1908
msgid ""
"Return a user or a kernel stack in bpf program provided buffer.  To achieve "
"this, the helper needs I<ctx>, which is a pointer to the context on which "
"the tracing program is executed.  To store the stacktrace, the bpf program "
"provides I<buf> with a nonnegative I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1913 build/C/man7/bpf-helpers.7:3565
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set the following flags:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1917 build/C/man7/bpf-helpers.7:3569
#, no-wrap
msgid "B<BPF_F_USER_BUILD_ID>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1921 build/C/man7/bpf-helpers.7:3573
msgid ""
"Collect buildid+offset instead of ips for user stack, only valid if "
"B<BPF_F_USER_STACK> is also specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1929
msgid ""
"B<bpf_get_stack>() can collect up to B<PERF_MAX_STACK_DEPTH> both kernel and "
"user frames, subject to sufficient large buffer size. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually "
"increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1941 build/C/man7/bpf-helpers.7:3593
msgid ""
"A non-negative value equal to or less than I<size> on success, or a negative "
"error in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1942
#, no-wrap
msgid ""
"B<long bpf_skb_load_bytes_relative(const void *>I<skb>B<, u32 >I<offset>B<, "
"void *>I<to>B<, u32 >I<len>B<, u32 >I<start_header>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1953
msgid ""
"This helper is similar to B<bpf_skb_load_bytes>() in that it provides an "
"easy way to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&. The difference to "
"B<bpf_skb_load_bytes>() is that a fifth argument I<start_header> exists in "
"order to select a base offset to start from. I<start_header> can be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1954
#, no-wrap
msgid "B<BPF_HDR_START_MAC>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1957
msgid "Base offset to load data from is I<skb>\\(aqs mac header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1957
#, no-wrap
msgid "B<BPF_HDR_START_NET>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1960
msgid "Base offset to load data from is I<skb>\\(aqs network header."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1967
msgid ""
"In general, \"direct packet access\" is the preferred method to access "
"packet data, however, this helper is in particular useful in socket filters "
"where I<skb>B<-E<gt>data> does not always point to the start of the mac "
"header and where \"direct packet access\" is not available."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1971
#, no-wrap
msgid ""
"B<long bpf_fib_lookup(void *>I<ctx>B<, struct bpf_fib_lookup *>I<params>B<, "
"int >I<plen>B<, u32 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1985
msgid ""
"Do FIB lookup in kernel tables using parameters in I<params>\\&.  If lookup "
"is successful and result shows packet is to be forwarded, the neighbor "
"tables are searched for the nexthop.  If successful (ie., FIB lookup shows "
"forwarding and nexthop is resolved), the nexthop address is returned in "
"ipv4_dst or ipv6_dst based on family, smac is set to mac address of egress "
"device, dmac is set to nexthop mac address, rt_metric is set to metric from "
"route (IPv4/IPv6 only), and ifindex is set to the device index of the "
"nexthop from the FIB lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1989
msgid ""
"I<plen> argument is the size of the passed in struct.  I<flags> argument can "
"be a combination of one or more of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1990
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_DIRECT>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1994
msgid "Do a direct table lookup vs full lookup using FIB rules."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:1994
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:1998
msgid "Perform lookup from an egress perspective (default is ingress)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2002
msgid ""
"I<ctx> is either B<struct xdp_md> for XDP programs or B<struct sk_buff> tc "
"cls_act programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2007
msgid "E<lt> 0 if any input argument is invalid"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2009
msgid "0 on success (packet is forwarded, nexthop neighbor exists)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2012
msgid ""
"E<gt> 0 one of B<BPF_FIB_LKUP_RET_> codes explaining why the packet is not "
"forwarded or needs assist from full stack"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2014
#, no-wrap
msgid ""
"B<long bpf_sock_hash_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2022
msgid ""
"Add an entry to, or update a sockhash I<map> referencing sockets.  The "
"I<skops> is used as a new value for the entry associated to "
"I<key>\\&. I<flags> is one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2041
#, no-wrap
msgid ""
"B<long bpf_msg_redirect_hash(struct sk_msg_buff *>I<msg>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2055
msgid ""
"This helper is used in programs implementing policies at the socket "
"level. If the message I<msg> is allowed to pass (i.e. if the verdict eBPF "
"program returns B<SK_PASS>), redirect it to the socket referenced by I<map> "
"(of type B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and "
"egress interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for "
"now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2059
#, no-wrap
msgid ""
"B<long bpf_sk_redirect_hash(struct sk_buff *>I<skb>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2073
msgid ""
"This helper is used in programs implementing policies at the skb socket "
"level. If the sk_buff I<skb> is allowed to pass (i.e.  if the verdict eBPF "
"program returns B<SK_PASS>), redirect it to the socket referenced by I<map> "
"(of type B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and "
"egress interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress otherwise). This is the only flag supported for now."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2077
#, no-wrap
msgid ""
"B<long bpf_lwt_push_encap(struct sk_buff *>I<skb>B<, u32 >I<type>B<, void "
"*>I<hdr>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2086
msgid ""
"Encapsulate the packet associated to I<skb> within a Layer 3 protocol "
"header. This header is provided in the buffer at address I<hdr>, with I<len> "
"its size in bytes. I<type> indicates the protocol of the header and can be "
"one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2087
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2092
msgid ""
"IPv6 encapsulation with Segment Routing Header (B<struct "
"ipv6_sr_hdr>). I<hdr> only contains the SRH, the IPv6 header is computed by "
"the kernel."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2092
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6_INLINE>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2097
msgid ""
"Only works if I<skb> contains an IPv6 packet. Insert a Segment Routing "
"Header (B<struct ipv6_sr_hdr>) inside the IPv6 header."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2097
#, no-wrap
msgid "B<BPF_LWT_ENCAP_IP>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2106
msgid ""
"IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or IPv6, "
"followed by zero or more additional headers, up to B<LWT_BPF_MAX_HEADROOM> "
"total bytes in all prepended headers. Please note that if "
"B<skb_is_gso>(I<skb>) is true, no more than two headers can be prepended, "
"and the inner header, if present, should be either GRE or UDP/GUE."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2112
msgid ""
"B<BPF_LWT_ENCAP_SEG6>* types can be called by BPF programs of type "
"B<BPF_PROG_TYPE_LWT_IN>; B<BPF_LWT_ENCAP_IP> type can be called by bpf "
"programs of types B<BPF_PROG_TYPE_LWT_IN> and B<BPF_PROG_TYPE_LWT_XMIT>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2122
#, no-wrap
msgid ""
"B<long bpf_lwt_seg6_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"const void *>I<from>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2131
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. Only the flags, tag and TLVs inside the outermost "
"IPv6 Segment Routing Header can be modified through this helper."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2141
#, no-wrap
msgid ""
"B<long bpf_lwt_seg6_adjust_srh(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"s32 >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2151
msgid ""
"Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing "
"Header contained in the packet associated to I<skb>, at position I<offset> "
"by I<delta> bytes. Only offsets after the segments are accepted. I<delta> "
"can be as well positive (growing) as negative (shrinking)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2161
#, no-wrap
msgid ""
"B<long bpf_lwt_seg6_action(struct sk_buff *>I<skb>B<, u32 >I<action>B<, void "
"*>I<param>B<, u32 >I<param_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2170
msgid ""
"Apply an IPv6 Segment Routing action of type I<action> to the packet "
"associated to I<skb>\\&. Each action takes a parameter contained at address "
"I<param>, and of length I<param_len> bytes.  I<action> can be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2171
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_X>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2175
msgid ""
"End.X action: Endpoint with Layer-3 cross-connect.  Type of I<param>: "
"B<struct in6_addr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2175
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_T>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2179
msgid ""
"End.T action: Endpoint with specific IPv6 table lookup.  Type of I<param>: "
"B<int>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2179
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2183
msgid ""
"End.B6 action: Endpoint bound to an SRv6 policy.  Type of I<param>: B<struct "
"ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2183
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6_ENCAP>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2188
msgid ""
"End.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy.  Type "
"of I<param>: B<struct ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2199
#, no-wrap
msgid "B<long bpf_rc_repeat(void *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2208
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded repeat key message. This delays the generation of a key "
"up event for previously generated key down event."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2211
msgid ""
"Some IR protocols like NEC have a special IR message for repeating last "
"button, for when a button is held down."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2214 build/C/man7/bpf-helpers.7:2241 build/C/man7/bpf-helpers.7:2519
msgid "The I<ctx> should point to the lirc sample as passed into the program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2218 build/C/man7/bpf-helpers.7:2248 build/C/man7/bpf-helpers.7:2523
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_BPF_LIRC_MODE2> configuration option set to \"B<y>\"."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2222
#, no-wrap
msgid ""
"B<long bpf_rc_keydown(void *>I<ctx>B<, u32 >I<protocol>B<, u64 "
">I<scancode>B<, u32 >I<toggle>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2235
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded key press with I<scancode>, I<toggle> value in the "
"given I<protocol>\\&. The scancode will be translated to a keycode using the "
"rc keymap, and reported as an input key down event. After a period a key up "
"event is generated. This period can be extended by calling either "
"B<bpf_rc_keydown>() again with the same values, or calling "
"B<bpf_rc_repeat>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2238
msgid ""
"Some protocols include a toggle bit, in case the button was released and "
"pressed again between consecutive scancodes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2244
msgid ""
"The I<protocol> is the decoded protocol number (see B<enum rc_proto> for "
"some predefined values)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2252
#, no-wrap
msgid "B<u64 bpf_skb_cgroup_id(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2264
msgid ""
"Return the cgroup v2 id of the socket associated with the I<skb>\\&.  This "
"is roughly similar to the B<bpf_get_cgroup_classid>()  helper for cgroup v1 "
"by providing a tag resp. identifier that can be matched on or used for map "
"lookups e.g. to implement policy. The cgroup v2 id of a given path in the "
"hierarchy is exposed in user space through the f_handle API in order to get "
"to the same 64-bit id."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2268
msgid ""
"This helper can be used on TC egress path, but not on ingress, and is "
"available only if the kernel was compiled with the "
"B<CONFIG_SOCK_CGROUP_DATA> configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2271 build/C/man7/bpf-helpers.7:2336 build/C/man7/bpf-helpers.7:3189 build/C/man7/bpf-helpers.7:3358 build/C/man7/bpf-helpers.7:3380
msgid "The id is returned or 0 in case the id could not be retrieved."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2272
#, no-wrap
msgid "B<u64 bpf_get_current_cgroup_id(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2279
msgid ""
"A 64-bit integer containing the current cgroup id based on the cgroup within "
"which the current task is running."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2280
#, no-wrap
msgid "B<void *bpf_get_local_storage(void *>I<map>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2290
msgid ""
"Get the pointer to the local storage area.  The type and the size of the "
"local storage is defined by the I<map> argument.  The I<flags> meaning is "
"specific for each map type, and has to be 0 for cgroup local storage."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2294
msgid ""
"Depending on the BPF program type, a local storage area can be shared "
"between multiple instances of the BPF program, running simultaneously."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2298
msgid ""
"A user should care about the synchronization by himself.  For example, by "
"using the B<BPF_STX_XADD> instruction to alter the shared data."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2301
msgid "A pointer to the local storage area."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2302
#, no-wrap
msgid ""
"B<long bpf_sk_select_reuseport(struct sk_reuseport_md *>I<reuse>B<, struct "
"bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2311
msgid ""
"Select a B<SO_REUSEPORT> socket from a B<BPF_MAP_TYPE_REUSEPORT_ARRAY> "
"I<map>\\&.  It checks the selected socket is matching the incoming request "
"in the socket buffer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2315
#, no-wrap
msgid ""
"B<u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *>I<skb>B<, int "
">I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2326
msgid ""
"Return id of cgroup v2 that is ancestor of cgroup associated with the I<skb> "
"at the I<ancestor_level>\\&.  The root cgroup is at I<ancestor_level> zero "
"and each step down the hierarchy increments the level. If I<ancestor_level> "
"== level of cgroup associated with I<skb>, then return value will be same as "
"that of B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2330
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with I<skb>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2333
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2337
#, no-wrap
msgid ""
"B<struct bpf_sock *bpf_sk_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple "
"*>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2345 build/C/man7/bpf-helpers.7:2665
msgid ""
"Look for TCP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>, "
"released via B<bpf_sk_release>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2349 build/C/man7/bpf-helpers.7:2393
msgid ""
"The I<ctx> should point to the context of the program, such as the skb or "
"socket (depending on the hook in use). This is used to determine the base "
"network namespace for the lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2351 build/C/man7/bpf-helpers.7:2395
msgid "I<tuple_size> must be one of:"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2352 build/C/man7/bpf-helpers.7:2396
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv4)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2355 build/C/man7/bpf-helpers.7:2399
msgid "Look for an IPv4 socket."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2355 build/C/man7/bpf-helpers.7:2399
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv6)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2358 build/C/man7/bpf-helpers.7:2402
msgid "Look for an IPv6 socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2368 build/C/man7/bpf-helpers.7:2412
msgid ""
"If the I<netns> is a negative signed 32-bit integer, then the socket lookup "
"table in the netns associated with the I<ctx> will be used. For the TC "
"hooks, this is the netns of the device in the skb. For socket hooks, this is "
"the netns of the socket.  If I<netns> is any other signed 32-bit value "
"greater than or equal to zero then it specifies the ID of the netns relative "
"to the netns associated with the I<ctx>\\&. I<netns> values beyond the range "
"of 32-bit integers are reserved for future use."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2374 build/C/man7/bpf-helpers.7:2418 build/C/man7/bpf-helpers.7:2673
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_NET> "
"configuration option."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2380 build/C/man7/bpf-helpers.7:2424 build/C/man7/bpf-helpers.7:2679
msgid ""
"Pointer to B<struct bpf_sock>, or B<NULL> in case of failure.  For sockets "
"with reuseport option, the B<struct bpf_sock> result is from "
"I<reuse>B<-E<gt>socks>[] using the hash of the tuple."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2381
#, no-wrap
msgid ""
"B<struct bpf_sock *bpf_sk_lookup_udp(void *>I<ctx>B<, struct bpf_sock_tuple "
"*>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2389
msgid ""
"Look for UDP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>, "
"released via B<bpf_sk_release>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2425
#, no-wrap
msgid "B<long bpf_sk_release(struct bpf_sock *>I<sock>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2433
msgid ""
"Release the reference held by I<sock>\\&. I<sock> must be a non-B<NULL> "
"pointer that was returned from B<bpf_sk_lookup_xxx>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2437
#, no-wrap
msgid ""
"B<long bpf_map_push_elem(struct bpf_map *>I<map>B<, const void *>I<value>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2443
msgid "Push an element I<value> in I<map>\\&. I<flags> is one of:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2448
msgid ""
"If the queue/stack is full, the oldest element is removed to make room for "
"this."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2453
#, no-wrap
msgid "B<long bpf_map_pop_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2459
msgid "Pop an element from I<map>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2463
#, no-wrap
msgid "B<long bpf_map_peek_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2469
msgid "Get an element from I<map> without removing it."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2473
#, no-wrap
msgid ""
"B<long bpf_msg_push_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 "
">I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2480
msgid "For socket policies, insert I<len> bytes into I<msg> at offset I<start>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2485
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it may want "
"to insert metadata or options into the I<msg>\\&.  This can later be read "
"and used by any of the lower layer BPF hooks."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2489
msgid ""
"This helper may fail if under memory pressure (a malloc fails) in these "
"cases BPF programs will get an appropriate error and BPF programs will need "
"to handle them."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2493
#, no-wrap
msgid ""
"B<long bpf_msg_pop_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 "
">I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2505
msgid ""
"Will remove I<len> bytes from a I<msg> starting at byte I<start>\\&.  This "
"may result in B<ENOMEM> errors under certain situations if an allocation and "
"copy are required due to a full ring buffer.  However, the helper will try "
"to avoid doing the allocation if possible. Other errors can occur if input "
"parameters are invalid either due to I<start> byte not being valid part of "
"I<msg> payload and/or I<pop> value being to large."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2509
#, no-wrap
msgid ""
"B<long bpf_rc_pointer_rel(void *>I<ctx>B<, s32 >I<rel_x>B<, s32 "
">I<rel_y>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2516
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded pointer movement."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2527
#, no-wrap
msgid "B<long bpf_spin_lock(struct bpf_spin_lock *>I<lock>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2537
msgid ""
"Acquire a spinlock represented by the pointer I<lock>, which is stored as "
"part of a value of a map. Taking the lock allows to safely update the rest "
"of the fields in that value. The spinlock can (and must) later be released "
"with a call to B<bpf_spin_unlock>(I<lock>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2540
msgid ""
"Spinlocks in BPF programs come with a number of restrictions and "
"constraints:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2545
msgid ""
"B<bpf_spin_lock> objects are only allowed inside maps of types "
"B<BPF_MAP_TYPE_HASH> and B<BPF_MAP_TYPE_ARRAY> (this list could be extended "
"in the future)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2547
msgid "BTF description of the map is mandatory."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2550
msgid ""
"The BPF program can take ONE lock at a time, since taking two or more could "
"cause dead locks."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2552
msgid "Only one B<struct bpf_spin_lock> is allowed per map element."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2555
msgid ""
"When the lock is taken, calls (either BPF to BPF or helpers)  are not "
"allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2558
msgid ""
"The B<BPF_LD_ABS> and B<BPF_LD_IND> instructions are not allowed inside a "
"spinlock-ed region."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2561
msgid ""
"The BPF program MUST call B<bpf_spin_unlock>() to release the lock, on all "
"execution paths, before it returns."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2566
msgid ""
"The BPF program can access B<struct bpf_spin_lock> only via the "
"B<bpf_spin_lock>() and B<bpf_spin_unlock>()  helpers. Loading or storing "
"data into the B<struct bpf_spin_lock> I<lock>B<;> field of a map is not "
"allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2571
msgid ""
"To use the B<bpf_spin_lock>() helper, the BTF description of the map value "
"must be a struct and have B<struct bpf_spin_lock> I<anyname>B<;> field at "
"the top level.  Nested lock inside another struct is not allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2574
msgid ""
"The B<struct bpf_spin_lock> I<lock> field in a map value must be aligned on "
"a multiple of 4 bytes in that value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2577
msgid ""
"Syscall with command B<BPF_MAP_LOOKUP_ELEM> does not copy the "
"B<bpf_spin_lock> field to user space."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2580
msgid ""
"Syscall with command B<BPF_MAP_UPDATE_ELEM>, or update from a BPF program, "
"do not update the B<bpf_spin_lock> field."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2583
msgid ""
"B<bpf_spin_lock> cannot be on the stack or inside a networking packet (it "
"can only be inside of a map values)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2585
msgid "B<bpf_spin_lock> is available to root only."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2589
msgid ""
"Tracing programs and socket filter programs cannot use B<bpf_spin_lock>() "
"due to insufficient preemption checks (but this may change in the future)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2591
msgid "B<bpf_spin_lock> is not allowed in inner maps of map-in-map."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2596
#, no-wrap
msgid "B<long bpf_spin_unlock(struct bpf_spin_lock *>I<lock>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2603
msgid ""
"Release the I<lock> previously locked by a call to "
"B<bpf_spin_lock>(I<lock>)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2607
#, no-wrap
msgid "B<struct bpf_sock *bpf_sk_fullsock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2614
msgid ""
"This helper gets a B<struct bpf_sock> pointer such that all the fields in "
"this B<bpf_sock> can be accessed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2618 build/C/man7/bpf-helpers.7:2656
msgid "A B<struct bpf_sock> pointer on success, or B<NULL> in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2619
#, no-wrap
msgid "B<struct bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2626
msgid ""
"This helper gets a B<struct bpf_tcp_sock> pointer from a B<struct bpf_sock> "
"pointer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2630
msgid "A B<struct bpf_tcp_sock> pointer on success, or B<NULL> in case of failure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2631
#, no-wrap
msgid "B<long bpf_skb_ecn_set_ce(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2640
msgid ""
"Set ECN (Explicit Congestion Notification) field of IP header to B<CE> "
"(Congestion Encountered) if current value is B<ECT> (ECN Capable "
"Transport). Otherwise, do nothing. Works with IPv6 and IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2644
msgid ""
"1 if the B<CE> flag is set (either by the current helper call or because it "
"was already present), 0 if it is not set."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2645
#, no-wrap
msgid "B<struct bpf_sock *bpf_get_listener_sock(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2652
msgid ""
"Return a B<struct bpf_sock> pointer in B<TCP_LISTEN> state.  "
"B<bpf_sk_release>() is unnecessary and not allowed."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2657
#, no-wrap
msgid ""
"B<struct bpf_sock *bpf_skc_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple "
"*>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2670
msgid ""
"This function is identical to B<bpf_sk_lookup_tcp>(), except that it also "
"returns timewait or request sockets. Use B<bpf_sk_fullsock>() or "
"B<bpf_tcp_sock>() to access the full structure."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2680
#, no-wrap
msgid ""
"B<long bpf_tcp_check_syncookie(struct bpf_sock *>I<sk>B<, void *>I<iph>B<, "
"u32 >I<iph_len>B<, struct tcphdr *>I<th>B<, u32 >I<th_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2687
msgid ""
"Check whether I<iph> and I<th> contain a valid SYN cookie ACK for the "
"listening socket in I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2691 build/C/man7/bpf-helpers.7:2913
msgid ""
"I<iph> points to the start of the IPv4 or IPv6 header, while I<iph_len> "
"contains B<sizeof>(B<struct iphdr>) or B<sizeof>(B<struct ip6hdr>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2694
msgid ""
"I<th> points to the start of the TCP header, while I<th_len> contains "
"B<sizeof>(B<struct tcphdr>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2698
msgid ""
"0 if I<iph> and I<th> are a valid SYN cookie ACK, or a negative error "
"otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2699
#, no-wrap
msgid ""
"B<long bpf_sysctl_get_name(struct bpf_sysctl *>I<ctx>B<, char *>I<buf>B<, "
"size_t >I<buf_len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2706
msgid ""
"Get name of sysctl in /proc/sys/ and copy it into provided by program buffer "
"I<buf> of size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2708 build/C/man7/bpf-helpers.7:2732 build/C/man7/bpf-helpers.7:2754
msgid "The buffer is always NUL terminated, unless it\\(aqs zero-sized."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2712
msgid ""
"If I<flags> is zero, full name (e.g. \"net/ipv4/tcp_mem\") is copied. Use "
"B<BPF_F_SYSCTL_BASE_NAME> flag to copy base name only (e.g. \"tcp_mem\")."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2715 build/C/man7/bpf-helpers.7:2735 build/C/man7/bpf-helpers.7:2757
msgid "Number of character copied (not including the trailing NUL)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2718 build/C/man7/bpf-helpers.7:2738 build/C/man7/bpf-helpers.7:2760
msgid ""
"B<-E2BIG> if the buffer wasn\\(aqt big enough (I<buf> will contain truncated "
"name in this case)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2719
#, no-wrap
msgid ""
"B<long bpf_sysctl_get_current_value(struct bpf_sysctl *>I<ctx>B<, char "
"*>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2727
msgid ""
"Get current value of sysctl as it is presented in /proc/sys (incl. newline, "
"etc), and copy it as a string into provided by program buffer I<buf> of size "
"I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2730
msgid ""
"The whole value is copied, no matter what file position user space issued "
"e.g. sys_read at."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2741
msgid ""
"B<-EINVAL> if current value was unavailable, e.g. because sysctl is "
"uninitialized and read returns -EIO for it."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2742
#, no-wrap
msgid ""
"B<long bpf_sysctl_get_new_value(struct bpf_sysctl *>I<ctx>B<, char "
"*>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2750
msgid ""
"Get new value being written by user space to sysctl (before the actual write "
"happens) and copy it as a string into provided by program buffer I<buf> of "
"size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2752
msgid "User space may write new value at file position E<gt> 0."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2762 build/C/man7/bpf-helpers.7:2783
msgid "B<-EINVAL> if sysctl is being read."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2763
#, no-wrap
msgid ""
"B<long bpf_sysctl_set_new_value(struct bpf_sysctl *>I<ctx>B<, const char "
"*>I<buf>B<, size_t >I<buf_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2770
msgid ""
"Override new value being written by user space to sysctl with value provided "
"by program in buffer I<buf> of size I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2773
msgid ""
"I<buf> should contain a string in same form as provided by user space on "
"sysctl write."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2776
msgid ""
"User space may write new value at file position E<gt> 0. To override the "
"whole sysctl value file position should be set to zero."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2779 build/C/man7/bpf-helpers.7:2880
msgid "0 on success."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2781
msgid "B<-E2BIG> if the I<buf_len> is too big."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2784
#, no-wrap
msgid ""
"B<long bpf_strtol(const char *>I<buf>B<, size_t >I<buf_len>B<, u64 "
">I<flags>B<, long *>I<res>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2792
msgid ""
"Convert the initial part of the string from buffer I<buf> of size I<buf_len> "
"to a long integer according to the given base and save the result in "
"I<res>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2796
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3)) followed by a single optional \\(aqB<->\\(aq sign."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2799 build/C/man7/bpf-helpers.7:2826
msgid ""
"Five least significant bits of I<flags> encode base, other bits are "
"currently unused."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2802
msgid ""
"Base must be either 8, 10, 16 or 0 to detect it automatically similar to "
"user space B<strtol>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2806 build/C/man7/bpf-helpers.7:2833
msgid ""
"Number of characters consumed on success. Must be positive but no more than "
"I<buf_len>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2809 build/C/man7/bpf-helpers.7:2836
msgid "B<-EINVAL> if no valid digits were found or unsupported base was provided."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2811 build/C/man7/bpf-helpers.7:2838
msgid "B<-ERANGE> if resulting value was out of range."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2812
#, no-wrap
msgid ""
"B<long bpf_strtoul(const char *>I<buf>B<, size_t >I<buf_len>B<, u64 "
">I<flags>B<, unsigned long *>I<res>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2820
msgid ""
"Convert the initial part of the string from buffer I<buf> of size I<buf_len> "
"to an unsigned long integer according to the given base and save the result "
"in I<res>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2823
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3))."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2829
msgid ""
"Base must be either 8, 10, 16 or 0 to detect it automatically similar to "
"user space B<strtoul>(3)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2839
#, no-wrap
msgid ""
"B<void *bpf_sk_storage_get(struct bpf_map *>I<map>B<, struct bpf_sock "
"*>I<sk>B<, void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2845
msgid "Get a bpf-local-storage from a I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2852
msgid ""
"Logically, it could be thought of getting the value from a I<map> with I<sk> "
"as the B<key>\\&.  From this perspective, the usage is not much different "
"from B<bpf_map_lookup_elem>(I<map>, B<&>I<sk>) except this helper enforces "
"the key must be a full socket and the map must be a "
"B<BPF_MAP_TYPE_SK_STORAGE> also."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2857
msgid ""
"Underneath, the value is stored locally at I<sk> instead of the I<map>\\&.  "
"The I<map> is used as the bpf-local-storage \"type\". The bpf-local-storage "
"\"type\" (i.e. the I<map>) is searched against all bpf-local-storages "
"residing at I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2864
msgid ""
"An optional I<flags> (B<BPF_SK_STORAGE_GET_F_CREATE>) can be used such that "
"a new bpf-local-storage will be created if one does not exist.  I<value> can "
"be used together with B<BPF_SK_STORAGE_GET_F_CREATE> to specify the initial "
"value of a bpf-local-storage.  If I<value> is B<NULL>, the new "
"bpf-local-storage will be zero initialized."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2867
msgid "A bpf-local-storage pointer is returned on success."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2870
msgid ""
"B<NULL> if not found or there was an error in adding a new "
"bpf-local-storage."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2871
#, no-wrap
msgid ""
"B<long bpf_sk_storage_delete(struct bpf_map *>I<map>B<, struct bpf_sock "
"*>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2877
msgid "Delete a bpf-local-storage from a I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2882
msgid "B<-ENOENT> if the bpf-local-storage cannot be found."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2883
#, no-wrap
msgid "B<long bpf_send_signal(u32 >I<sig>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2890
msgid ""
"Send signal I<sig> to the process of the current task.  The signal may be "
"delivered to any of this process\\(aqs threads."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2893 build/C/man7/bpf-helpers.7:3065
msgid "0 on success or successfully queued."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2895 build/C/man7/bpf-helpers.7:3067
msgid "B<-EBUSY> if work queue under nmi is full."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2897 build/C/man7/bpf-helpers.7:3069
msgid "B<-EINVAL> if I<sig> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2899 build/C/man7/bpf-helpers.7:3071
msgid "B<-EPERM> if no permission to send the I<sig>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2901 build/C/man7/bpf-helpers.7:3073
msgid "B<-EAGAIN> if bpf program can try again."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2902
#, no-wrap
msgid ""
"B<s64 bpf_tcp_gen_syncookie(struct bpf_sock *>I<sk>B<, void *>I<iph>B<, u32 "
">I<iph_len>B<, struct tcphdr *>I<th>B<, u32 >I<th_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2909
msgid ""
"Try to issue a SYN cookie for the packet with corresponding IP/TCP headers, "
"I<iph> and I<th>, on the listening socket in I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2916
msgid ""
"I<th> points to the start of the TCP header, while I<th_len> contains the "
"length of the TCP header."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2921
msgid ""
"On success, lower 32 bits hold the generated SYN cookie in followed by 16 "
"bits which hold the MSS value for that cookie, and the top 16 bits are "
"unused."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2923
msgid "On failure, the returned value is one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2925
msgid "B<-EINVAL> SYN cookie cannot be issued due to error"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2927
msgid "B<-ENOENT> SYN cookie should not be issued (no SYN flood)"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2929
msgid "B<-EOPNOTSUPP> kernel configuration does not enable SYN cookies"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2931
msgid "B<-EPROTONOSUPPORT> IP packet version is not 4 or 6"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2932
#, no-wrap
msgid ""
"B<long bpf_skb_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 "
">I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2953
msgid "I<ctx> is a pointer to in-kernel struct sk_buff."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2956
msgid ""
"This helper is similar to B<bpf_perf_event_output>() but restricted to "
"raw_tracepoint bpf programs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2960
#, no-wrap
msgid ""
"B<long bpf_probe_read_user(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2967
msgid ""
"Safely attempt to read I<size> bytes from user space address I<unsafe_ptr> "
"and store the data in I<dst>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2971
#, no-wrap
msgid ""
"B<long bpf_probe_read_kernel(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2978
msgid ""
"Safely attempt to read I<size> bytes from kernel space address I<unsafe_ptr> "
"and store the data in I<dst>\\&."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:2982
#, no-wrap
msgid ""
"B<long bpf_probe_read_user_str(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2993
msgid ""
"Copy a NUL terminated string from an unsafe user address I<unsafe_ptr> to "
"I<dst>\\&. The I<size> should include the terminating NUL byte. In case the "
"string length is smaller than I<size>, the target is not padded with further "
"NUL bytes. If the string length is larger than I<size>, just I<size>-1 bytes "
"are copied and the last byte is set to NUL."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:2998
msgid ""
"On success, the length of the copied string is returned. This makes this "
"helper useful in tracing programs for reading strings, and more importantly "
"to get its length at runtime. See the following snippet:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3008
#, no-wrap
msgid ""
"SEC(\"kprobe/sys_open\")\n"
"void bpf_sys_open(struct pt_regs *ctx)\n"
"{\n"
"        char buf[PATHLEN]; // PATHLEN is defined to 256\n"
"        int res = bpf_probe_read_user_str(buf, sizeof(buf),\n"
"                                          ctx-E<gt>di);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3014
#, no-wrap
msgid ""
"        // Consume buf, for example push it to\n"
"        // userspace via bpf_perf_event_output(); we\n"
"        // can use res (the string length) as event\n"
"        // size, after checking its boundaries.\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3022
msgid ""
"In comparison, using B<bpf_probe_read_user>() helper here instead to read "
"the string would require to estimate the length at compile time, and would "
"often result in copying more memory than necessary."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3027
msgid ""
"Another useful use case is when parsing individual process arguments or "
"individual environment variables navigating "
"I<current>B<-E<gt>mm-E<gt>arg_start> and "
"I<current>B<-E<gt>mm-E<gt>env_start>: using this helper and the return "
"value, one can quickly iterate at the right offset of the memory area."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3033
#, no-wrap
msgid ""
"B<long bpf_probe_read_kernel_str(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3040
msgid ""
"Copy a NUL terminated string from an unsafe kernel address I<unsafe_ptr> to "
"I<dst>\\&. Same semantics as with B<bpf_probe_read_user_str>() apply."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3045
#, no-wrap
msgid "B<long bpf_tcp_send_ack(void *>I<tp>B<, u32 >I<rcv_nxt>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3052
msgid ""
"Send out a tcp-ack. I<tp> is the in-kernel struct B<tcp_sock>\\&.  "
"I<rcv_nxt> is the ack_seq to be sent out."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3056
#, no-wrap
msgid "B<long bpf_send_signal_thread(u32 >I<sig>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3062
msgid "Send signal I<sig> to the thread corresponding to the current task."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3074
#, no-wrap
msgid "B<u64 bpf_jiffies64(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3080
msgid "Obtain the 64bit jiffies"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3083
msgid "The 64 bit jiffies"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3084
#, no-wrap
msgid ""
"B<long bpf_read_branch_records(struct bpf_perf_event_data *>I<ctx>B<, void "
"*>I<buf>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3093
msgid ""
"For an eBPF program attached to a perf event, retrieve the branch records "
"(B<struct perf_branch_entry>) associated to I<ctx> and store it in the "
"buffer pointed by I<buf> up to size I<size> bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3097
msgid ""
"On success, number of bytes written to I<buf>\\&. On error, a negative "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3101
msgid ""
"The I<flags> can be set to B<BPF_F_GET_BRANCH_RECORDS_SIZE> to instead "
"return the number of bytes required to store all the branch entries. If this "
"flag is set, I<buf> may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3104
msgid ""
"B<-EINVAL> if arguments invalid or B<size> not a multiple of "
"B<sizeof>(B<struct perf_branch_entry>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3106
msgid "B<-ENOENT> if architecture does not support branch records."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3107
#, no-wrap
msgid ""
"B<long bpf_get_ns_current_pid_tgid(u64 >I<dev>B<, u64 >I<ino>B<, struct "
"bpf_pidns_info *>I<nsdata>B<, u32 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3114
msgid ""
"Returns 0 on success, values for I<pid> and I<tgid> as seen from the current "
"I<namespace> will be returned in I<nsdata>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3117
msgid "0 on success, or one of the following in case of failure:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3120
msgid ""
"B<-EINVAL> if dev and inum supplied don\\(aqt match dev_t and inode number "
"with nsfs of current task, or if dev conversion to dev_t lost high bits."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3122
msgid "B<-ENOENT> if pidns does not exists for the current task."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3123
#, no-wrap
msgid ""
"B<long bpf_xdp_output(void *>I<ctx>B<, struct bpf_map *>I<map>B<, u64 "
">I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3144
msgid "I<ctx> is a pointer to in-kernel struct xdp_buff."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3147
msgid ""
"This helper is similar to B<bpf_perf_eventoutput>() but restricted to "
"raw_tracepoint bpf programs."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3151
#, no-wrap
msgid "B<u64 bpf_get_netns_cookie(void *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3164
msgid ""
"Retrieve the cookie (generated by the kernel) of the network namespace the "
"input I<ctx> is associated with. The network namespace cookie remains stable "
"for its lifetime and provides a global identifier that can be assumed "
"unique. If I<ctx> is NULL, then the helper returns the cookie for the "
"initial network namespace. The cookie itself is very similar to that of "
"B<bpf_get_socket_cookie>() helper, but for network namespaces instead of "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3167
msgid "A 8-byte long opaque number."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3168
#, no-wrap
msgid "B<u64 bpf_get_current_ancestor_cgroup_id(int >I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3179
msgid ""
"Return id of cgroup v2 that is ancestor of the cgroup associated with the "
"current task at the I<ancestor_level>\\&. The root cgroup is at "
"I<ancestor_level> zero and each step down the hierarchy increments the "
"level. If I<ancestor_level> == level of cgroup associated with the current "
"task, then return value will be the same as that of "
"B<bpf_get_current_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3183
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with the current task."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3186
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_get_current_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3190
#, no-wrap
msgid ""
"B<long bpf_sk_assign(struct sk_buff *>I<skb>B<, struct bpf_sock *>I<sk>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3198
msgid ""
"Helper is overloaded depending on BPF program type. This description applies "
"to B<BPF_PROG_TYPE_SCHED_CLS> and B<BPF_PROG_TYPE_SCHED_ACT> programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3205
msgid ""
"Assign the I<sk> to the I<skb>\\&. When combined with appropriate routing "
"configuration to receive the packet towards the socket, will cause I<skb> to "
"be delivered to the specified socket.  Subsequent redirection of I<skb> via "
"B<bpf_redirect>(), B<bpf_clone_redirect>() or other methods outside of BPF "
"may interfere with successful delivery to the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3207
msgid "This operation is only valid from TC ingress path."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3209
msgid "The I<flags> argument must be zero."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3212 build/C/man7/bpf-helpers.7:3317 build/C/man7/bpf-helpers.7:3338
msgid "0 on success, or a negative error in case of failure:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3214
msgid "B<-EINVAL> if specified I<flags> are not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3216
msgid "B<-ENOENT> if the socket is unavailable for assignment."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3218
msgid "B<-ENETUNREACH> if the socket is unreachable (wrong netns)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3221
msgid ""
"B<-EOPNOTSUPP> if the operation is not supported, for example a call from "
"outside of TC ingress."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3224
msgid "B<-ESOCKTNOSUPPORT> if the socket type is not supported (reuseport)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3225
#, no-wrap
msgid ""
"B<long bpf_sk_assign(struct bpf_sk_lookup *>I<ctx>B<, struct bpf_sock "
"*>I<sk>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3232
msgid ""
"Helper is overloaded depending on BPF program type. This description applies "
"to B<BPF_PROG_TYPE_SK_LOOKUP> programs."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3234
msgid "Select the I<sk> as a result of a socket lookup."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3237
msgid ""
"For the operation to succeed passed socket must be compatible with the "
"packet description provided by the I<ctx> object."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3242
msgid ""
"L4 protocol (B<IPPROTO_TCP> or B<IPPROTO_UDP>) must be an exact match. While "
"IP family (B<AF_INET> or B<AF_INET6>) must be compatible, that is IPv6 "
"sockets that are not v6-only can be selected for IPv4 packets."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3246
msgid ""
"Only TCP listeners and UDP unconnected sockets can be selected. I<sk> can "
"also be NULL to reset any previous selection."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3248
msgid "I<flags> argument can combination of following values:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3253
msgid ""
"B<BPF_SK_LOOKUP_F_REPLACE> to override the previous socket selection, "
"potentially done by a BPF program that ran before us."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3257
msgid ""
"B<BPF_SK_LOOKUP_F_NO_REUSEPORT> to skip load-balancing within reuseport "
"group for the socket being selected."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3260
msgid "On success I<ctx-E<gt>sk> will point to the selected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3263
msgid "0 on success, or a negative errno in case of failure."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3267
msgid ""
"B<-EAFNOSUPPORT> if socket family (I<sk-E<gt>family>) is not compatible with "
"packet family (I<ctx-E<gt>family>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3271
msgid ""
"B<-EEXIST> if socket has been already selected, potentially by another "
"program, and B<BPF_SK_LOOKUP_F_REPLACE> flag was not specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3273
msgid "B<-EINVAL> if unsupported flags were specified."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3277
msgid ""
"B<-EPROTOTYPE> if socket L4 protocol (I<sk-E<gt>protocol>) doesn\\(aqt match "
"packet protocol (I<ctx-E<gt>protocol>)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3280
msgid ""
"B<-ESOCKTNOSUPPORT> if socket is not in allowed state (TCP listening or UDP "
"unconnected)."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3282
#, no-wrap
msgid "B<u64 bpf_ktime_get_boot_ns(void)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3290
msgid ""
"Return the time elapsed since system boot, in nanoseconds.  Does include the "
"time the system was suspended.  See: B<clock_gettime>(B<CLOCK_BOOTTIME>)"
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3294
#, no-wrap
msgid ""
"B<long bpf_seq_printf(struct seq_file *>I<m>B<, const char *>I<fmt>B<, u32 "
">I<fmt_size>B<, const void *>I<data>B<, u32 >I<data_len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3307
msgid ""
"B<bpf_seq_printf>() uses seq_file B<seq_printf>() to print out the format "
"string.  The I<m> represents the seq_file. The I<fmt> and I<fmt_size> are "
"for the format string itself. The I<data> and I<data_len> are format string "
"arguments. The I<data> are a B<u64> array and corresponding format string "
"values are stored in the array. For strings and pointers where pointees are "
"accessed, only the pointer values are stored in the I<data> array.  The "
"I<data_len> is the size of I<data> in bytes."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3314
msgid ""
"Formats B<%s>, B<%p{i,I}{4,6}> requires to read kernel memory.  Reading "
"kernel memory may fail due to either invalid address or valid address but "
"requiring a major memory fault. If reading kernel memory fails, the string "
"for B<%s> will be an empty string, and the ip address for B<%p{i,I}{4,6}> "
"will be 0. Not returning error to bpf program is consistent with what "
"B<bpf_trace_printk>() does for now."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3320
msgid ""
"B<-EBUSY> if per-CPU memory copy buffer is busy, can try again by returning "
"1 from bpf program."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3322
msgid "B<-EINVAL> if arguments are invalid, or if I<fmt> is invalid/unsupported."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3324
msgid "B<-E2BIG> if I<fmt> contains too many format specifiers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3326 build/C/man7/bpf-helpers.7:3340
msgid "B<-EOVERFLOW> if an overflow happened: The same object will be tried again."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3327
#, no-wrap
msgid ""
"B<long bpf_seq_write(struct seq_file *>I<m>B<, const void *>I<data>B<, u32 "
">I<len>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3335
msgid ""
"B<bpf_seq_write>() uses seq_file B<seq_write>() to write the data.  The I<m> "
"represents the seq_file. The I<data> and I<len> represent the data to write "
"in bytes."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3341
#, no-wrap
msgid "B<u64 bpf_sk_cgroup_id(struct bpf_sock *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3347
msgid "Return the cgroup v2 id of the socket I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3352
msgid ""
"I<sk> must be a non-B<NULL> pointer to a full socket, e.g. one returned from "
"B<bpf_sk_lookup_xxx>(), B<bpf_sk_fullsock>(), etc. The format of returned id "
"is same as in B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3355
msgid ""
"This helper is available only if the kernel was compiled with the "
"B<CONFIG_SOCK_CGROUP_DATA> configuration option."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3359
#, no-wrap
msgid ""
"B<u64 bpf_sk_ancestor_cgroup_id(struct bpf_sock *>I<sk>B<, int "
">I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3370
msgid ""
"Return id of cgroup v2 that is ancestor of cgroup associated with the I<sk> "
"at the I<ancestor_level>\\&.  The root cgroup is at I<ancestor_level> zero "
"and each step down the hierarchy increments the level. If I<ancestor_level> "
"== level of cgroup associated with I<sk>, then return value will be same as "
"that of B<bpf_sk_cgroup_id>()."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3374
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with I<sk>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3377
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_sk_cgroup_id>()."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3381
#, no-wrap
msgid ""
"B<long bpf_ringbuf_output(void *>I<ringbuf>B<, void *>I<data>B<, u64 "
">I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3391
msgid ""
"Copy I<size> bytes from I<data> into a ring buffer I<ringbuf>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3395
#, no-wrap
msgid ""
"B<void *bpf_ringbuf_reserve(void *>I<ringbuf>B<, u64 >I<size>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3401
msgid "Reserve I<size> bytes of payload in a ring buffer I<ringbuf>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3405
msgid "Valid pointer with I<size> bytes of memory available; NULL, otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3406
#, no-wrap
msgid "B<void bpf_ringbuf_submit(void *>I<data>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3416
msgid ""
"Submit reserved ring buffer sample, pointed to by I<data>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3419 build/C/man7/bpf-helpers.7:3433
msgid "Nothing. Always succeeds."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3420
#, no-wrap
msgid "B<void bpf_ringbuf_discard(void *>I<data>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3430
msgid ""
"Discard reserved ring buffer sample, pointed to by I<data>\\&.  If "
"B<BPF_RB_NO_WAKEUP> is specified in I<flags>, no notification of new data "
"availability is sent.  If B<BPF_RB_FORCE_WAKEUP> is specified in I<flags>, "
"notification of new data availability is sent unconditionally."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3434
#, no-wrap
msgid "B<u64 bpf_ringbuf_query(void *>I<ringbuf>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3441
msgid ""
"Query various characteristics of provided ring buffer. What exactly is "
"queries is determined by I<flags>:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3444
msgid "B<BPF_RB_AVAIL_DATA>: Amount of data not yet consumed."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3446
msgid "B<BPF_RB_RING_SIZE>: The size of ring buffer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3448
msgid "B<BPF_RB_CONS_POS>: Consumer position (can wrap around)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3450
msgid "B<BPF_RB_PROD_POS>: Producer(s) position (can wrap around)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3456
msgid ""
"Data returned is just a momentary snapshot of actual values and could be "
"inaccurate, so this facility should be used to power heuristics and for "
"reporting, not to make 100% correct calculation."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3459
msgid "Requested value, or 0, if I<flags> are not recognized."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3460
#, no-wrap
msgid "B<long bpf_csum_level(struct sk_buff *>I<skb>B<, u64 >I<level>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3478
msgid ""
"Change the skbs checksum level by one layer up or down, or reset it entirely "
"to none in order to have the stack perform checksum validation. The level is "
"applicable to the following protocols: TCP, UDP, GRE, SCTP, FCOE. For "
"example, a decap of | ETH | IP | UDP | GUE | IP | TCP | into | ETH | IP | "
"TCP | through B<bpf_skb_adjust_room>() helper with passing in "
"B<BPF_F_ADJ_ROOM_NO_CSUM_RESET> flag would require one call to "
"B<bpf_csum_level>() with B<BPF_CSUM_LEVEL_DEC> since the UDP header is "
"removed. Similarly, an encap of the latter into the former could be "
"accompanied by a helper call to B<bpf_csum_level>() with "
"B<BPF_CSUM_LEVEL_INC> if the skb is still intended to be processed in higher "
"layers of the stack instead of just egressing at tc."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3480
msgid "There are three supported level settings at this time:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3484
msgid ""
"B<BPF_CSUM_LEVEL_INC>: Increases skb-E<gt>csum_level for skbs with "
"CHECKSUM_UNNECESSARY."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3487
msgid ""
"B<BPF_CSUM_LEVEL_DEC>: Decreases skb-E<gt>csum_level for skbs with "
"CHECKSUM_UNNECESSARY."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3490
msgid ""
"B<BPF_CSUM_LEVEL_RESET>: Resets skb-E<gt>csum_level to 0 and sets "
"CHECKSUM_NONE to force checksum validation by the stack."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3493
msgid "B<BPF_CSUM_LEVEL_QUERY>: No-op, returns the current skb-E<gt>csum_level."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3500
msgid ""
"0 on success, or a negative error in case of failure. In the case of "
"B<BPF_CSUM_LEVEL_QUERY>, the current skb-E<gt>csum_level is returned or the "
"error code -EACCES in case the skb is not subject to CHECKSUM_UNNECESSARY."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3501
#, no-wrap
msgid "B<struct tcp6_sock *bpf_skc_to_tcp6_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3507
msgid "Dynamically cast a I<sk> pointer to a I<tcp6_sock> pointer."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3510 build/C/man7/bpf-helpers.7:3520 build/C/man7/bpf-helpers.7:3530 build/C/man7/bpf-helpers.7:3540 build/C/man7/bpf-helpers.7:3550
msgid "I<sk> if casting is valid, or NULL otherwise."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3511
#, no-wrap
msgid "B<struct tcp_sock *bpf_skc_to_tcp_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3517
msgid "Dynamically cast a I<sk> pointer to a I<tcp_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3521
#, no-wrap
msgid "B<struct tcp_timewait_sock *bpf_skc_to_tcp_timewait_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3527
msgid "Dynamically cast a I<sk> pointer to a I<tcp_timewait_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3531
#, no-wrap
msgid "B<struct tcp_request_sock *bpf_skc_to_tcp_request_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3537
msgid "Dynamically cast a I<sk> pointer to a I<tcp_request_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3541
#, no-wrap
msgid "B<struct udp6_sock *bpf_skc_to_udp6_sock(void *>I<sk>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3547
msgid "Dynamically cast a I<sk> pointer to a I<udp6_sock> pointer."
msgstr ""

#. type: TP
#: build/C/man7/bpf-helpers.7:3551
#, no-wrap
msgid ""
"B<long bpf_get_task_stack(struct task_struct *>I<task>B<, void *>I<buf>B<, "
"u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3560
msgid ""
"Return a user or a kernel stack in bpf program provided buffer.  To achieve "
"this, the helper needs I<task>, which is a valid pointer to struct "
"task_struct. To store the stacktrace, the bpf program provides I<buf> with a "
"nonnegative I<size>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3581
msgid ""
"B<bpf_get_task_stack>() can collect up to B<PERF_MAX_STACK_DEPTH> both "
"kernel and user frames, subject to sufficient large buffer size. Note that "
"this limit can be controlled with the B<sysctl> program, and that it should "
"be manually increased in order to profile long user stacks (such as stacks "
"for Java programs). To do so, use:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3599
msgid ""
"Example usage for most of the eBPF helpers listed in this manual page are "
"available within the Linux kernel sources, at the following locations:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3602
msgid "I<samples/bpf/>"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3604
msgid "I<tools/testing/selftests/bpf/>"
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:3605
#, no-wrap
msgid "LICENSE"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3612
msgid ""
"eBPF programs can have an associated license, passed along with the bytecode "
"instructions to the kernel when the programs are loaded. The format for that "
"string is identical to the one in use for kernel modules (Dual licenses, "
"such as \"Dual BSD/GPL\", may be used). Some helper functions are only "
"accessible to programs that are compatible with the GNU Privacy License "
"(GPL)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3617
msgid ""
"In order to use such helpers, the eBPF program must be loaded with the "
"correct license string passed (via B<attr>) to the B<bpf>() system call, and "
"this generally translates into the C source code of the program containing a "
"line similar to the following:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3622
#, no-wrap
msgid "char ____license[] __attribute__((section(\"license\"), used)) = \"GPL\";\n"
msgstr ""

#. type: SH
#: build/C/man7/bpf-helpers.7:3625
#, no-wrap
msgid "IMPLEMENTATION"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3635
msgid ""
"This manual page is an effort to document the existing eBPF helper "
"functions.  But as of this writing, the BPF sub-system is under heavy "
"development. New eBPF program or map types are added, along with new helper "
"functions. Some helpers are occasionally made available for additional "
"program types. So in spite of the efforts of the community, this page might "
"not be up-to-date. If you want to check by yourself what helper functions "
"exist in your kernel, or what types of programs they can support, here are "
"some files among the kernel tree that you may be interested in:"
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3640
msgid ""
"I<include/uapi/linux/bpf.h> is the main BPF header. It contains the full "
"list of all helper functions, as well as many other BPF definitions "
"including most of the flags, structs or constants used by the helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3643
msgid ""
"I<net/core/filter.c> contains the definition of most network-related helper "
"functions, and the list of program types from which they can be used."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3646
msgid ""
"I<kernel/trace/bpf_trace.c> is the equivalent for most tracing "
"program-related helpers."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3649
msgid ""
"I<kernel/bpf/verifier.c> contains the functions used to check that valid "
"types of eBPF maps are used with a given helper function."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3652
msgid ""
"I<kernel/bpf/> directory contains other files in which additional helpers "
"are defined (for cgroups, sockmaps, etc.)."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3658
msgid ""
"The bpftool utility can be used to probe the availability of helper "
"functions on the system (as well as supported program and map types, and a "
"number of other parameters). To do so, run B<bpftool feature probe> (see "
"B<bpftool-feature>(8) for details). Add the B<unprivileged> keyword to list "
"features available to unprivileged users."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3667
msgid ""
"Compatibility between helper functions and program types can generally be "
"found in the files where helper functions are defined. Look for the B<struct "
"bpf_func_proto> objects and for functions returning them: these functions "
"contain a list of helpers that a given program type can call. Note that the "
"B<default:> label of the B<switch ... case> used to filter helpers can call "
"other functions, themselves allowing access to additional helpers. The "
"requirement for GPL license is also in those B<struct bpf_func_proto>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3670
msgid ""
"Compatibility between helper functions and map types can be found in the "
"B<check_map_func_compatibility>() function in file "
"I<kernel/bpf/verifier.c>\\&."
msgstr ""

#. type: Plain text
#: build/C/man7/bpf-helpers.7:3674
msgid ""
"Helper functions that invalidate the checks on B<data> and B<data_end> "
"pointers for network processing are listed in function "
"B<bpf_helper_changes_pkt_data>() in file I<net/core/filter.c>\\&."
msgstr ""

#.  Generated by docutils manpage writer.
#. type: Plain text
#: build/C/man7/bpf-helpers.7:3685
msgid ""
"B<bpf>(2), B<bpftool>(8), B<cgroups>(7), B<ip>(8), B<perf_event_open>(2), "
"B<sendmsg>(2), B<socket>(7), B<tc-bpf>(8)"
msgstr ""

#. type: TH
#: build/C/man7/address_families.7:26
#, no-wrap
msgid "ADDRESS_FAMILIES"
msgstr ""

#. type: TH
#: build/C/man7/address_families.7:26
#, no-wrap
msgid "2018-10-16"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:29
msgid "address_families - socket address families (domains)"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:45
msgid ""
"The I<domain> argument of the B<socket>(2)  specifies a communication "
"domain; this selects the protocol family which will be used for "
"communication.  These families are defined in I<E<lt>sys/socket.hE<gt>>.  "
"The formats currently understood by the Linux kernel include:"
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:45
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:50
msgid "Local communication For further information, see B<unix>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:55
msgid "IPv4 Internet protocols.  For further information, see B<ip>(7)."
msgstr ""

#.  Part of ax25-tools
#. type: Plain text
#: build/C/man7/address_families.7:61
msgid "Amateur radio AX.25 protocol.  For further information, see B<ax25>(4)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:64
msgid "IPX - Novell protocols."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:69
msgid "AppleTalk For further information, see B<ddp>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:69
#, no-wrap
msgid "B<AF_NETROM>"
msgstr ""

#.  Part of ax25-tools package
#. type: Plain text
#: build/C/man7/address_families.7:84
msgid ""
"AX.25 packet layer protocol.  For further information, see B<netrom>(4), "
"E<.UR https://www.tldp.org/HOWTO/AX25-HOWTO/x61.html> I<The Packet Radio "
"Protocols and Linux> E<.UE> and the I<AX.25>, I<NET/ROM>, and I<ROSE network "
"programming> chapters of the E<.UR "
"https://www.tldp.org/HOWTO/AX25-HOWTO/x2107.html> I<Linux Amateur Radio "
"AX.25 HOWTO> E<.UE .>"
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:84
#, no-wrap
msgid "B<AF_BRIDGE>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:90
msgid ""
"Can't be used for creating sockets; mostly used for bridge links in "
"B<rtnetlink>(7)  protocol commands."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:90
#, no-wrap
msgid "B<AF_ATMPVC>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:97
msgid ""
"Access to raw ATM Permanent Virtual Circuits (PVCs).  For further "
"information, see the E<.UR https://www.tldp.org/HOWTO/text/ATM-Linux-HOWTO> "
"I<ATM on Linux HOWTO> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:102
msgid "ITU-T X.25 / ISO-8208 protocol.  For further information, see B<x25>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:107
msgid "IPv6 Internet protocols.  For further information, see B<ipv6>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:107
#, no-wrap
msgid "B<AF_ROSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:113
msgid ""
"RATS (Radio Amateur Telecommunications Society)  Open Systems environment "
"(ROSE) AX.25 packet layer protocol.  For further information, see the "
"resources listed for B<AF_NETROM>."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:119
msgid ""
"DECet protocol sockets.  See I<Documentation/networking/decnet.txt> in the "
"Linux kernel source tree for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:119
#, no-wrap
msgid "B<AF_NETBEUI>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:122
msgid "Reserved for \"802.2LLC project\"; never used."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:122
#, no-wrap
msgid "B<AF_SECURITY>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:126
msgid ""
"This was a short-lived (between Linux 2.1.30 and 2.1.99pre2) protocol family "
"for firewall upcalls."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:139
msgid ""
"Key management protocol, originally developed for usage with IPsec (since "
"Linux 2.1.38).  This has no relation to B<keyctl>(2)  and the in-kernel key "
"storage facility.  See E<.UR https://tools.ietf.org/html/rfc2367> RFC 2367 "
"I<PF_KEY Key Management API, Version 2> E<.UE> for details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:144
msgid "Kernel user interface device For further information, see B<netlink>(7)."
msgstr ""

#.  .TP
#.  .B AF_ASH
#.  Asynchronous Serial Host protocol (?)
#.  Notes from Eugene Syromyatnikov:
#.  I haven't found any concrete information about this one;
#.  it never was implemented in Linux, at least, judging by historical
#.  repos.  There is also this file (and its variations):
#.  https://github.com/ecki/net-tools/blob/master/lib/ash.c
#.  ( https://github.com/ecki/net-tools/commits/master/lib/ash.c )
#.  it mentions "NET-2 distribution" (BSD Net/2?), but, again, I failed
#.  to find any mentions of "ash" protocol there.
#.  (for the reference:
#.  ftp://pdp11.org.ru/pub/unix-archive/Distributions/UCB/Net2/net2.tar.gz )
#.  Another source that mentions it is
#.  https://www.silabs.com/documents/public/user-guides/ug101-uart-gateway-protocol-reference.pdf
#.  https://www.silabs.com/documents/public/user-guides/ug115-ashv3-protocol-reference.pdf
#.  but I doubt that it's related, as former files use 64-byte addresses and
#.  "Hamming-encode of hops", and that's barely combines with a protocol
#.  that is mainly used over serial connection.
#. type: Plain text
#: build/C/man7/address_families.7:168
msgid "Low-level packet interface.  For further information, see B<packet>(7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:168
#, no-wrap
msgid "B<AF_ECONET>"
msgstr ""

#.  commit: 349f29d841dbae854bd7367be7c250401f974f47
#. type: Plain text
#: build/C/man7/address_families.7:177
msgid ""
"Acorn Econet protocol (removed in Linux 3.5).  See the E<.UR "
"http://www.8bs.com/othrdnld/manuals/econet.shtml> Econet documentation "
"E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:177
#, no-wrap
msgid "B<AF_ATMSVC>"
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:185
msgid ""
"Access to ATM Switched Virtual Circuits (SVCs)  See the E<.UR "
"https://www.tldp.org/HOWTO/text/ATM-Linux-HOWTO> I<ATM on Linux HOWTO> "
"E<.UE> for details."
msgstr ""

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: Plain text
#: build/C/man7/address_families.7:201
msgid ""
"Reliable Datagram Sockets (RDS) protocol (since Linux 2.6.30).  RDS over "
"RDMA has no relation to B<AF_SMC> or B<AF_XDP>.  For further information see "
"B<rds>(7), B<rds-rdma>(7), and I<Documentation/networking/rds.txt> in the "
"Linux kernel source tree."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:201
#, no-wrap
msgid "B<AF_IRDA>"
msgstr ""

#.  commits: 1ca163afb6fd569b, d64c2a76123f0300
#.  irda-utils: https://sourceforge.net/p/irda/code/HEAD/tree/tags/IRDAUTILS_0_9_18/irda-utils/man/irda.7.gz?format=raw
#. type: Plain text
#: build/C/man7/address_families.7:209
msgid ""
"Socket interface over IrDA (moved to staging in Linux 4.14, removed in Linux "
"4.17).  For further information see B<irda>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:216
msgid ""
"Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE).  "
"See I<Documentation/networking/l2tp.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:216
#, no-wrap
msgid "B<AF_WANPIPE>"
msgstr ""

#.  commits: ce0ecd594d78710422599918a608e96dd1ee6024
#. type: Plain text
#: build/C/man7/address_families.7:222
msgid ""
"Legacy protocol for wide area network (WAN) connectivity that was used by "
"Sangoma WAN cards (called \"WANPIPE\"); removed in Linux 2.6.21."
msgstr ""

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: Plain text
#: build/C/man7/address_families.7:245
msgid ""
"Logical link control (IEEE 802.2 LLC) protocol, upper part of data link "
"layer of ISO/OSI networking protocol stack (since Linux 2.4); has no "
"relation to B<AF_PACKET>.  See chapter I<13.5.3. Logical Link Control> in "
"I<Understanding Linux Kernel Internals> (O'Reilly Media, 2006)  and I<IEEE "
"Standards for Local Area Networks: Logical Link Control> (The Institute of "
"Electronics and Electronics Engineers, Inc., New York, New York, 1985)  for "
"details.  See also E<.UR https://wiki.linuxfoundation.org/networking/llc> "
"some historical notes E<.UE> regarding its development."
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: Plain text
#: build/C/man7/address_families.7:249
msgid "InfiniBand native addressing (since Linux 3.11)."
msgstr ""

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: Plain text
#: build/C/man7/address_families.7:256
msgid ""
"Multiprotocol Label Switching (since Linux 4.1); mostly used for configuring "
"MPLS routing via B<netlink>(7), as it doesn't expose ability to create "
"sockets to user space."
msgstr ""

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: Plain text
#: build/C/man7/address_families.7:263
msgid ""
"Controller Area Network automotive bus protocol (since Linux 2.6.25).  See "
"I<Documentation/networking/can.rst> in the Linux kernel source tree for "
"details."
msgstr ""

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: Plain text
#: build/C/man7/address_families.7:276
msgid ""
"TIPC, \"cluster domain sockets\" protocol (since Linux 2.6.16).  See E<.UR "
"http://tipc.io/programming.html> I<TIPC Programmer's Guide> E<.UE> and the "
"E<.UR http://tipc.io/protocol.html> protocol description E<.UE> for details."
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: Plain text
#: build/C/man7/address_families.7:290
msgid ""
"Bluetooth low-level socket protocol (since Linux 3.11).  See E<.UR "
"https://git.kernel.org\\:/pub/scm\\:/bluetooth/bluez.git\\:/tree/doc/mgmt-api.txt> "
"I<Bluetooth Management API overview> E<.UE> and E<.UR "
"https://people.csail.mit.edu/albert/bluez-intro/> I<An Introduction to "
"Bluetooth Programming> by Albert Huang E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:290
#, no-wrap
msgid "B<AF_IUCV>"
msgstr ""

#.  commit: eac3731bd04c7131478722a3c148b78774553116
#. type: Plain text
#: build/C/man7/address_families.7:304
msgid ""
"IUCV (inter-user communication vehicle) z/VM protocol for hypervisor-guest "
"interaction (since Linux 2.6.21); has no relation to B<AF_VSOCK> and/or "
"B<AF_SMC> See E<.UR "
"https://www.ibm.com\\:/support\\:/knowledgecenter\\:/en/SSB27U_6.4.0\\:/com.ibm.zvm.v640.hcpb4\\:/iucv.htm> "
"I<IUCV protocol overview> E<.UE> for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:304
#, no-wrap
msgid "B<AF_RXRPC>"
msgstr ""

#.  commit: 17926a79320afa9b95df6b977b40cca6d8713cea
#.  http://people.redhat.com/~dhowells/rxrpc/
#.  https://www.infradead.org/~dhowells/kafs/af_rxrpc_client.html
#.  http://workshop.openafs.org/afsbpw09/talks/thu_2/kafs.pdf
#.  http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf
#.  http://web.mit.edu/kolya/afs/rx/rx-spec
#. type: Plain text
#: build/C/man7/address_families.7:317
msgid ""
"Rx, Andrew File System remote procedure call protocol (since Linux 2.6.22).  "
"See I<Documentation/networking/rxrpc.txt> in the Linux kernel source tree "
"for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:317
#, no-wrap
msgid "B<AF_ISDN>"
msgstr ""

#.  commit: 1b2b03f8e514e4f68e293846ba511a948b80243c
#. type: Plain text
#: build/C/man7/address_families.7:326
msgid ""
"New \"modular ISDN\" driver interface protocol (since Linux 2.6.27).  See "
"the E<.UR http://www.misdn.eu/wiki/Main_Page/> mISDN wiki E<.UE> for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:326
#, no-wrap
msgid "B<AF_PHONET>"
msgstr ""

#.  commit: 4b07b3f69a8471cdc142c51461a331226fef248a
#. type: Plain text
#: build/C/man7/address_families.7:333
msgid ""
"Nokia cellular modem IPC/RPC interface (since Linux 2.6.31).  See "
"I<Documentation/networking/phonet.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:333
#, no-wrap
msgid "B<AF_IEEE802154>"
msgstr ""

#.  commit: 9ec7671603573ede31207eb5b0b3e1aa211b2854
#. type: Plain text
#: build/C/man7/address_families.7:341
msgid ""
"IEEE 802.15.4 WPAN (wireless personal area network) raw packet protocol "
"(since Linux 2.6.31).  See I<Documentation/networking/ieee802154.txt> in the "
"Linux kernel source tree for details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:341
#, no-wrap
msgid "B<AF_CAIF>"
msgstr ""

#.  commit: 529d6dad5bc69de14cdd24831e2a14264e93daa4
#.  https://lwn.net/Articles/371017/
#.  http://read.pudn.com/downloads157/doc/comm/698729/Misc/caif/Com%20CPU%20to%20Appl%20CPU%20Interface%20DESCRIPTION_LZN901%202002_revR1C.pdf
#.  http://read.pudn.com/downloads157/doc/comm/698729/Misc/caif/Com%20CPU%20to%20Appl%20CPU%20Interface%20PROTOCOL%20SPECIFICATION_LZN901%201708_revR1A.pdf
#. type: Plain text
#: build/C/man7/address_families.7:352
msgid ""
"Ericsson's Communication CPU to Application CPU interface (CAIF) protocol "
"(since Linux 2.6.36).  See I<Documentation/networking/caif/Linux-CAIF.txt> "
"in the Linux kernel source tree for details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:358
msgid ""
"Interface to kernel crypto API (since Linux 2.6.38).  See "
"I<Documentation/crypto/userspace-if.rst> in the Linux kernel source tree for "
"details."
msgstr ""

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: Plain text
#: build/C/man7/address_families.7:368
msgid ""
"VMWare VSockets protocol for hypervisor-guest interaction (since Linux 3.9); "
"has no relation to B<AF_IUCV> and B<AF_SMC>.  For further information, see "
"B<vsock>(7)."
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: Plain text
#: build/C/man7/address_families.7:375
msgid ""
"KCM (kernel connection multiplexer) interface (since Linux 4.6).  See "
"I<Documentation/networking/kcm.txt> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:375
#, no-wrap
msgid "B<AF_QIPCRTR>"
msgstr ""

#.  commit: bdabad3e363d825ddf9679dd431cca0b2c30f881
#. type: Plain text
#: build/C/man7/address_families.7:379
msgid "Qualcomm IPC router interface protocol (since Linux 4.7)."
msgstr ""

#. type: TP
#: build/C/man7/address_families.7:379
#, no-wrap
msgid "B<AF_SMC>"
msgstr ""

#.  commit: f3a3e248f3f7cd9a4bed334022704d7e7fc781bf
#. type: Plain text
#: build/C/man7/address_families.7:400
msgid ""
"SMC-R (shared memory communications over RDMA) protocol (since Linux 4.11), "
"and SMC-D (shared memory communications, direct memory access) protocol for "
"intra-node z/VM quest interaction (since Linux 4.19); has no relation to "
"B<AF_RDS>, B<AF_IUCV> or B<AF_VSOCK>.  See E<.UR "
"https://tools.ietf.org/html/rfc7609> RFC 7609 I<IBM's Shared Memory "
"Communications over RDMA (SMC-R) Protocol> E<.UE> for details regarding "
"SMC-R.  See E<.UR "
"https://www-01.ibm.com\\:/software/network\\:/commserver\\:/SMC-D/index.html> "
"I<SMC-D Reference Information> E<.UE> for details regarding SMC-D."
msgstr ""

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: Plain text
#: build/C/man7/address_families.7:407
msgid ""
"XDP (express data path) interface (since Linux 4.18).  See "
"I<Documentation/networking/af_xdp.rst> in the Linux kernel source tree for "
"details."
msgstr ""

#. type: Plain text
#: build/C/man7/address_families.7:410
msgid "B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man7/sock_diag.7:24
#, no-wrap
msgid "SOCK_DIAG"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:27
msgid "sock_diag - obtaining information about sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/sock_diag.hE<gt>>\n"
"B<#include E<lt>linux/unix_diag.hE<gt>> /* for UNIX domain sockets */\n"
"B<#include E<lt>linux/inet_diag.hE<gt>> /* for IPv4 and IPv6 sockets */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:35
#, no-wrap
msgid "B<diag_socket = socket(AF_NETLINK, >I<socket_type>B<, NETLINK_SOCK_DIAG);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:41
msgid ""
"The sock_diag netlink subsystem provides a mechanism for obtaining "
"information about sockets of various address families from the kernel.  This "
"subsystem can be used to obtain information about individual sockets or "
"request a list of sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:45
msgid ""
"In the request, the caller can specify additional information it would like "
"to obtain about the socket, for example, memory information or information "
"specific to the address family."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:50
msgid ""
"When requesting a list of sockets, the caller can specify filters that would "
"be applied by the kernel to select a subset of sockets to report.  For now, "
"there is only the ability to filter sockets by state (connected, listening, "
"and so on.)"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:62
msgid ""
"Note that sock_diag reports only those sockets that have a name; that is, "
"either sockets bound explicitly with B<bind>(2)  or sockets that were "
"automatically bound to an address (e.g., by B<connect>(2)).  This is the "
"same set of sockets that is available via I</proc/net/unix>, "
"I</proc/net/tcp>, I</proc/net/udp>, and so on."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:62
#, no-wrap
msgid "Request"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:73
msgid ""
"The request starts with a I<struct nlmsghdr> header described in "
"B<netlink>(7)  with I<nlmsg_type> field set to B<SOCK_DIAG_BY_FAMILY>.  It "
"is followed by a header specific to the address family that starts with a "
"common part shared by all address families:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:80
#, no-wrap
msgid ""
"struct sock_diag_req {\n"
"    __u8 sdiag_family;\n"
"    __u8 sdiag_protocol;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:84 build/C/man7/sock_diag.7:146 build/C/man7/sock_diag.7:206 build/C/man7/sock_diag.7:249 build/C/man7/sock_diag.7:310 build/C/man7/sock_diag.7:425 build/C/man7/sock_diag.7:519
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:84 build/C/man7/sock_diag.7:146 build/C/man7/sock_diag.7:375
#, no-wrap
msgid "I<sdiag_family>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:90
msgid "An address family.  It should be set to the appropriate B<AF_*> constant."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:90 build/C/man7/sock_diag.7:152 build/C/man7/sock_diag.7:382
#, no-wrap
msgid "I<sdiag_protocol>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:101
msgid ""
"Depends on I<sdiag_family>.  It should be set to the appropriate "
"B<IPPROTO_*> constant for B<AF_INET> and B<AF_INET6>, and to 0 otherwise."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:111
msgid ""
"If the I<nlmsg_flags> field of the I<struct nlmsghdr> header has the "
"B<NLM_F_DUMP> flag set, it means that a list of sockets is being requested; "
"otherwise it is a query about an individual socket."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:111
#, no-wrap
msgid "Response"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:120
msgid ""
"The response starts with a I<struct nlmsghdr> header and is followed by an "
"array of objects specific to the address family.  The array is to be "
"accessed with the standard B<NLMSG_*> macros from the B<netlink>(3)  API."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:128
msgid ""
"Each object is the NLA (netlink attributes) list that is to be accessed with "
"the B<RTA_*> macros from B<rtnetlink>(3)  API."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:128
#, no-wrap
msgid "UNIX domain sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:130
msgid ""
"For UNIX domain sockets the request is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:142
#, no-wrap
msgid ""
"struct unix_diag_req {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u16   pad;\n"
"    __u32   udiag_states;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_show;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:150
msgid "The address family; it should be set to B<AF_UNIX>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:153 build/C/man7/sock_diag.7:327 build/C/man7/sock_diag.7:454
#, no-wrap
msgid "I<pad>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:157
msgid "These fields should be set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:157
#, no-wrap
msgid "I<udiag_states>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:163
msgid ""
"This is a bit mask that defines a filter of sockets states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket.  Supported values are:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:167
msgid "1 E<lt>E<lt> B<TCP_ESTABLISHED>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:170
msgid "1 E<lt>E<lt> B<TCP_LISTEN>"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:171 build/C/man7/sock_diag.7:330
#, no-wrap
msgid "I<udiag_ino>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:175
msgid ""
"This is an inode number when querying for an individual socket.  Ignored "
"when querying for a list of sockets."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:175
#, no-wrap
msgid "I<udiag_show>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:180
msgid ""
"This is a set of flags defining what kind of information to report.  Each "
"requested kind of information is reported back as a netlink attribute as "
"described below:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:181
#, no-wrap
msgid "B<UDIAG_SHOW_NAME>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:189
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_NAME>.  The "
"payload associated with this attribute is the pathname to which the socket "
"was bound (a sequence of bytes up to B<UNIX_PATH_MAX> length)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:189
#, no-wrap
msgid "B<UDIAG_SHOW_VFS>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:195
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_VFS>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:202
#, no-wrap
msgid ""
"struct unix_diag_vfs {\n"
"    __u32 udiag_vfs_dev;\n"
"    __u32 udiag_vfs_ino;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:207
#, no-wrap
msgid "I<udiag_vfs_dev>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:210
msgid "The device number of the corresponding on-disk socket inode."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:210
#, no-wrap
msgid "I<udiag_vfs_ino>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:213
msgid "The inode number of the corresponding on-disk socket inode."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:214
#, no-wrap
msgid "B<UDIAG_SHOW_PEER>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:221
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_PEER>.  The "
"payload associated with this attribute is a __u32 value which is the peer's "
"inode number.  This attribute is reported for connected sockets only."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:221
#, no-wrap
msgid "B<UDIAG_SHOW_ICONS>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:232
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_ICONS>.  The "
"payload associated with this attribute is an array of __u32 values which are "
"inode numbers of sockets that has passed the B<connect>(2)  call, but hasn't "
"been processed with B<accept>(2)  yet.  This attribute is reported for "
"listening sockets only."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:232
#, no-wrap
msgid "B<UDIAG_SHOW_RQLEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:238
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_RQLEN>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:245
#, no-wrap
msgid ""
"struct unix_diag_rqlen {\n"
"    __u32 udiag_rqueue;\n"
"    __u32 udiag_wqueue;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:250
#, no-wrap
msgid "I<udiag_rqueue>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:257
msgid ""
"For listening sockets: the number of pending connections.  The length of the "
"array associated with the B<UNIX_DIAG_ICONS> response attribute is equal to "
"this value."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:260
msgid "For established sockets: the amount of data in incoming queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:260
#, no-wrap
msgid "I<udiag_wqueue>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:265
msgid ""
"For listening sockets: the backlog length which equals to the value passed "
"as the second argument to B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:268
msgid "For established sockets: the amount of memory available for sending."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:269
#, no-wrap
msgid "B<UDIAG_SHOW_MEMINFO>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:275
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_MEMINFO>.  "
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:277
msgid "The following attributes are reported back without any specific request:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:277
#, no-wrap
msgid "B<UNIX_DIAG_SHUTDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:283
msgid ""
"The payload associated with this attribute is __u8 value which represents "
"bits of B<shutdown>(2)  state."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:284 build/C/man7/sock_diag.7:333
#, no-wrap
msgid "I<udiag_cookie>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:291
msgid ""
"This is an array of opaque identifiers that could be used along with "
"I<udiag_ino> to specify an individual socket.  It is ignored when querying "
"for a list of sockets, as well as when all its elements are set to -1."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:293
msgid ""
"The response to a query for UNIX domain sockets is represented as an array "
"of"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:304
#, no-wrap
msgid ""
"struct unix_diag_msg {\n"
"    __u8    udiag_family;\n"
"    __u8    udiag_type;\n"
"    __u8    udiag_state;\n"
"    __u8    pad;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:308 build/C/man7/sock_diag.7:517
msgid "followed by netlink attributes."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:310
#, no-wrap
msgid "I<udiag_family>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:314
msgid "This field has the same meaning as in I<struct unix_diag_req>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:314
#, no-wrap
msgid "I<udiag_type>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:321
msgid "This is set to one of B<SOCK_PACKET>, B<SOCK_STREAM>, or B<SOCK_SEQPACKET>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:321
#, no-wrap
msgid "I<udiag_state>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:327
msgid "This is set to one of B<TCP_LISTEN> or B<TCP_ESTABLISHED>."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:330
msgid "This field is set to 0."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:333 build/C/man7/sock_diag.7:588
msgid "This is the socket inode number."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:338
msgid ""
"This is an array of opaque identifiers that could be used in subsequent "
"queries."
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:338
#, no-wrap
msgid "IPv4 and IPv6 sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:341
msgid ""
"For IPv4 and IPv6 sockets, the request is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:352
#, no-wrap
msgid ""
"struct inet_diag_req_v2 {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u8    idiag_ext;\n"
"    __u8    pad;\n"
"    __u32   idiag_states;\n"
"    struct inet_diag_sockid id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:358
msgid "where I<struct inet_diag_sockid> is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:369
#, no-wrap
msgid ""
"struct inet_diag_sockid {\n"
"    __be16  idiag_sport;\n"
"    __be16  idiag_dport;\n"
"    __be32  idiag_src[4];\n"
"    __be32  idiag_dst[4];\n"
"    __u32   idiag_if;\n"
"    __u32   idiag_cookie[2];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:375
msgid "The fields of I<struct inet_diag_req_v2> are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:382
msgid ""
"This should be set to either B<AF_INET> or B<AF_INET6> for IPv4 or IPv6 "
"sockets respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:389
msgid ""
"This should be set to one of B<IPPROTO_TCP>, B<IPPROTO_UDP>, or "
"B<IPPROTO_UDPLITE>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:389
#, no-wrap
msgid "I<idiag_ext>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:394
msgid ""
"This is a set of flags defining what kind of extended information to "
"report.  Each requested kind of information is reported back as a netlink "
"attribute as described below:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:395
#, no-wrap
msgid "B<INET_DIAG_TOS>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:399
msgid ""
"The payload associated with this attribute is a __u8 value which is the TOS "
"of the socket."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:399
#, no-wrap
msgid "B<INET_DIAG_TCLASS>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:408
msgid ""
"The payload associated with this attribute is a __u8 value which is the "
"TClass of the socket.  IPv6 sockets only.  For LISTEN and CLOSE sockets, "
"this is followed by B<INET_DIAG_SKV6ONLY> attribute with associated __u8 "
"payload value meaning whether the socket is IPv6-only or not."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:408
#, no-wrap
msgid "B<INET_DIAG_MEMINFO>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:412
msgid ""
"The payload associated with this attribute is represented in the following "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:421
#, no-wrap
msgid ""
"struct inet_diag_meminfo {\n"
"    __u32 idiag_rmem;\n"
"    __u32 idiag_wmem;\n"
"    __u32 idiag_fmem;\n"
"    __u32 idiag_tmem;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:426
#, no-wrap
msgid "I<idiag_rmem>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:429
msgid "The amount of data in the receive queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:429
#, no-wrap
msgid "I<idiag_wmem>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:432
msgid "The amount of data that is queued by TCP but not yet sent."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:432
#, no-wrap
msgid "I<idiag_fmem>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:435 build/C/man7/sock_diag.7:611
msgid "The amount of memory scheduled for future use (TCP only)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:435
#, no-wrap
msgid "I<idiag_tmem>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:438 build/C/man7/sock_diag.7:604
msgid "The amount of data in send queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:439
#, no-wrap
msgid "B<INET_DIAG_SKMEMINFO>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:443
msgid ""
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:443
#, no-wrap
msgid "B<INET_DIAG_INFO>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:448
msgid ""
"The payload associated with this attribute is specific to the address "
"family.  For TCP sockets, it is an object of type I<struct tcp_info>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:448
#, no-wrap
msgid "B<INET_DIAG_CONG>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:453
msgid ""
"The payload associated with this attribute is a string that describes the "
"congestion control algorithm used.  For TCP sockets only."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:457
msgid "This should be set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:457
#, no-wrap
msgid "I<idiag_states>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:462
msgid ""
"This is a bit mask that defines a filter of socket states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:462
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:469
msgid ""
"This is a socket ID object that is used in dump requests, in queries about "
"individual sockets, and is reported back in each response.  Unlike UNIX "
"domain sockets, IPv4 and IPv6 sockets are identified using addresses and "
"ports.  All values are in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:473
msgid "The fields of I<struct inet_diag_sockid> are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:473
#, no-wrap
msgid "I<idiag_sport>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:476
msgid "The source port."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:476
#, no-wrap
msgid "I<idiag_dport>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:479
msgid "The destination port."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:479
#, no-wrap
msgid "I<idiag_src>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:482
msgid "The source address."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:482
#, no-wrap
msgid "I<idiag_dst>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:485
msgid "The destination address."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:485
#, no-wrap
msgid "I<idiag_if>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:488
msgid "The interface number the socket is bound to."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:488
#, no-wrap
msgid "I<idiag_cookie>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:494
msgid ""
"This is an array of opaque identifiers that could be used along with other "
"fields of this structure to specify an individual socket.  It is ignored "
"when querying for a list of sockets, as well as when all its elements are "
"set to -1."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:496
msgid ""
"The response to a query for IPv4 or IPv6 sockets is represented as an array "
"of"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:504
#, no-wrap
msgid ""
"struct inet_diag_msg {\n"
"    __u8    idiag_family;\n"
"    __u8    idiag_state;\n"
"    __u8    idiag_timer;\n"
"    __u8    idiag_retrans;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:506
#, no-wrap
msgid "    struct inet_diag_sockid id;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:513
#, no-wrap
msgid ""
"    __u32   idiag_expires;\n"
"    __u32   idiag_rqueue;\n"
"    __u32   idiag_wqueue;\n"
"    __u32   idiag_uid;\n"
"    __u32   idiag_inode;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:519
#, no-wrap
msgid "I<idiag_family>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:523
msgid "This is the same field as in I<struct inet_diag_req_v2>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:523
#, no-wrap
msgid "I<idiag_state>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:527
msgid "This denotes socket state as in I<struct inet_diag_req_v2>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:527
#, no-wrap
msgid "I<idiag_timer>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:532
msgid ""
"For TCP sockets, this field describes the type of timer that is currently "
"active for the socket.  It is set to one of the following constants:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:535
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:538
msgid "no timer is active"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:538
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:541
msgid "a retransmit timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:541
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:544
msgid "a keep-alive timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:544
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:547
msgid "a TIME_WAIT timer"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:547
#, no-wrap
msgid "B<4>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:550
msgid "a zero window probe timer"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:554
msgid "For non-TCP sockets, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:554
#, no-wrap
msgid "I<idiag_retrans>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:562
msgid ""
"For I<idiag_timer> values 1, 2, and 4, this field contains the number of "
"retransmits.  For other I<idiag_timer> values, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:562
#, no-wrap
msgid "I<idiag_expires>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:567
msgid ""
"For TCP sockets that have an active timer, this field describes its "
"expiration time in milliseconds.  For other sockets, this field is set to 0."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:567
#, no-wrap
msgid "I<idiag_rqueue>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:571
msgid "For listening sockets: the number of pending connections."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:574
msgid "For other sockets: the amount of data in the incoming queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:574
#, no-wrap
msgid "I<idiag_wqueue>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:578
msgid "For listening sockets: the backlog length."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:581
msgid "For other sockets: the amount of memory available for sending."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:581
#, no-wrap
msgid "I<idiag_uid>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:584
msgid "This is the socket owner UID."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:584
#, no-wrap
msgid "I<idiag_inode>"
msgstr ""

#. type: SS
#: build/C/man7/sock_diag.7:588
#, no-wrap
msgid "Socket memory information"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:594
msgid ""
"The payload associated with B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> "
"netlink attributes is an array of the following __u32 values:"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:594
#, no-wrap
msgid "B<SK_MEMINFO_RMEM_ALLOC>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:597
msgid "The amount of data in receive queue."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:597
#, no-wrap
msgid "B<SK_MEMINFO_RCVBUF>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:601
msgid "The receive socket buffer as set by B<SO_RCVBUF>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:601
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_ALLOC>"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:604
#, no-wrap
msgid "B<SK_MEMINFO_SNDBUF>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:608
msgid "The send socket buffer as set by B<SO_SNDBUF>."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:608
#, no-wrap
msgid "B<SK_MEMINFO_FWD_ALLOC>"
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:611
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_QUEUED>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:614
msgid "The amount of data queued by TCP, but not yet sent."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:614
#, no-wrap
msgid "B<SK_MEMINFO_OPTMEM>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:618
msgid ""
"The amount of memory allocated for the socket's service needs (e.g., socket "
"filter)."
msgstr ""

#. type: TP
#: build/C/man7/sock_diag.7:618
#, no-wrap
msgid "B<SK_MEMINFO_BACKLOG>"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:621
msgid "The amount of packets in the backlog (not yet processed)."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:633
msgid ""
"B<NETLINK_INET_DIAG> was introduced in Linux 2.6.14 and supported B<AF_INET> "
"and B<AF_INET6> sockets only.  In Linux 3.3, it was renamed to "
"B<NETLINK_SOCK_DIAG> and extended to support B<AF_UNIX> sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:638
msgid ""
"B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> were introduced in Linux "
"3.6."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:640
msgid "The NETLINK_SOCK_DIAG API is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:643
msgid ""
"The following example program prints inode number, peer's inode number, and "
"name of all UNIX domain sockets in the current namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:655
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>linux/netlink.hE<gt>\n"
"#include E<lt>linux/rtnetlink.hE<gt>\n"
"#include E<lt>linux/sock_diag.hE<gt>\n"
"#include E<lt>linux/unix_diag.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:688
#, no-wrap
msgid ""
"static int\n"
"send_query(int fd)\n"
"{\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct\n"
"    {\n"
"        struct nlmsghdr nlh;\n"
"        struct unix_diag_req udr;\n"
"    } req = {\n"
"        .nlh = {\n"
"            .nlmsg_len = sizeof(req),\n"
"            .nlmsg_type = SOCK_DIAG_BY_FAMILY,\n"
"            .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP\n"
"        },\n"
"        .udr = {\n"
"            .sdiag_family = AF_UNIX,\n"
"            .udiag_states = -1,\n"
"            .udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER\n"
"        }\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = &req,\n"
"        .iov_len = sizeof(req)\n"
"    };\n"
"    struct msghdr msg = {\n"
"        .msg_name = &nladdr,\n"
"        .msg_namelen = sizeof(nladdr),\n"
"        .msg_iov = &iov,\n"
"        .msg_iovlen = 1\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:693
#, no-wrap
msgid ""
"    for (;;) {\n"
"        if (sendmsg(fd, &msg, 0) E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:697
#, no-wrap
msgid ""
"            perror(\"sendmsg\");\n"
"            return -1;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:701
#, no-wrap
msgid ""
"        return 0;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:713
#, no-wrap
msgid ""
"static int\n"
"print_diag(const struct unix_diag_msg *diag, unsigned int len)\n"
"{\n"
"    if (len E<lt> NLMSG_LENGTH(sizeof(*diag))) {\n"
"        fputs(\"short response\\en\", stderr);\n"
"        return -1;\n"
"    }\n"
"    if (diag-E<gt>udiag_family != AF_UNIX) {\n"
"        fprintf(stderr, \"unexpected family %u\\en\", "
"diag-E<gt>udiag_family);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:718
#, no-wrap
msgid ""
"    unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));\n"
"    unsigned int peer = 0;\n"
"    size_t path_len = 0;\n"
"    char path[sizeof(((struct sockaddr_un *) 0)-E<gt>sun_path) + 1];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:731
#, no-wrap
msgid ""
"    for (struct rtattr *attr = (struct rtattr *) (diag + 1);\n"
"             RTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n"
"        switch (attr-E<gt>rta_type) {\n"
"        case UNIX_DIAG_NAME:\n"
"            if (!path_len) {\n"
"                path_len = RTA_PAYLOAD(attr);\n"
"                if (path_len E<gt> sizeof(path) - 1)\n"
"                    path_len = sizeof(path) - 1;\n"
"                memcpy(path, RTA_DATA(attr), path_len);\n"
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"            }\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:738
#, no-wrap
msgid ""
"        case UNIX_DIAG_PEER:\n"
"            if (RTA_PAYLOAD(attr) E<gt>= sizeof(peer))\n"
"                peer = *(unsigned int *) RTA_DATA(attr);\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:740
#, no-wrap
msgid "    printf(\"inode=%u\", diag-E<gt>udiag_ino);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:743
#, no-wrap
msgid ""
"    if (peer)\n"
"        printf(\", peer=%u\", peer);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:747
#, no-wrap
msgid ""
"    if (path_len)\n"
"        printf(\", name=%s%s\", *path ? \"\" : \"@\",\n"
"                *path ? path : path + 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:751
#, no-wrap
msgid ""
"    putchar(\\(aq\\en\\(aq);\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:764
#, no-wrap
msgid ""
"static int\n"
"receive_responses(int fd)\n"
"{\n"
"    long buf[8192 / sizeof(long)];\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = buf,\n"
"        .iov_len = sizeof(buf)\n"
"    };\n"
"    int flags = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:772
#, no-wrap
msgid ""
"    for (;;) {\n"
"        struct msghdr msg = {\n"
"            .msg_name = &nladdr,\n"
"            .msg_namelen = sizeof(nladdr),\n"
"            .msg_iov = &iov,\n"
"            .msg_iovlen = 1\n"
"        };\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:774
#, no-wrap
msgid "        ssize_t ret = recvmsg(fd, &msg, flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:778
#, no-wrap
msgid ""
"        if (ret E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:784
#, no-wrap
msgid ""
"            perror(\"recvmsg\");\n"
"            return -1;\n"
"        }\n"
"        if (ret == 0)\n"
"            return 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:786
#, no-wrap
msgid "        const struct nlmsghdr *h = (struct nlmsghdr *) buf;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:791
#, no-wrap
msgid ""
"        if (!NLMSG_OK(h, ret)) {\n"
"            fputs(\"!NLMSG_OK\\en\", stderr);\n"
"            return -1;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:795
#, no-wrap
msgid ""
"        for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {\n"
"            if (h-E<gt>nlmsg_type == NLMSG_DONE)\n"
"                return 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:798
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type == NLMSG_ERROR) {\n"
"                const struct nlmsgerr *err = NLMSG_DATA(h);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:805
#, no-wrap
msgid ""
"                if (h-E<gt>nlmsg_len E<lt> NLMSG_LENGTH(sizeof(*err))) {\n"
"                    fputs(\"NLMSG_ERROR\\en\", stderr);\n"
"                } else {\n"
"                    errno = -err-E<gt>error;\n"
"                    perror(\"NLMSG_ERROR\");\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:808
#, no-wrap
msgid ""
"                return -1;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:814
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n"
"                fprintf(stderr, \"unexpected nlmsg_type %u\\en\",\n"
"                        (unsigned) h-E<gt>nlmsg_type);\n"
"                return -1;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:820
#, no-wrap
msgid ""
"            if (print_diag(NLMSG_DATA(h), h-E<gt>nlmsg_len))\n"
"                return -1;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:825
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:830
#, no-wrap
msgid ""
"    if (fd E<lt> 0) {\n"
"        perror(\"socket\");\n"
"        return 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:832
#, no-wrap
msgid "    int ret = send_query(fd) || receive_responses(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:836
#, no-wrap
msgid ""
"    close(fd);\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/sock_diag.7:842
msgid "B<netlink>(3), B<rtnetlink>(3), B<netlink>(7), B<tcp>(7)"
msgstr ""

#. type: TH
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "VSOCK"
msgstr ""

#. type: TH
#: build/C/man7/vsock.7:25
#, no-wrap
msgid "2020-02-09"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:28
msgid "vsock - Linux VSOCK address family"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:32
msgid "B<#include E<lt>linux/vm_sockets.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:34
msgid "I<stream_socket>B< = socket(AF_VSOCK, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:36
msgid "I<datagram_socket>B< = socket(AF_VSOCK, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:42
msgid ""
"The VSOCK address family facilitates communication between virtual machines "
"and the host they are running on.  This address family is used by guest "
"agents and hypervisor services that need a communications channel that is "
"independent of virtual machine network configuration."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:54
msgid ""
"Valid socket types are B<SOCK_STREAM> and B<SOCK_DGRAM>.  B<SOCK_STREAM> "
"provides connection-oriented byte streams with guaranteed, in-order "
"delivery.  B<SOCK_DGRAM> provides a connectionless datagram packet service "
"with best-effort delivery and best-effort ordering.  Availability of these "
"socket types is dependent on the underlying hypervisor."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:56
msgid "A new socket is created with"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:60
#, no-wrap
msgid "socket(AF_VSOCK, socket_type, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:67
msgid ""
"When a process wants to establish a connection, it calls B<connect>(2)  with "
"a given destination socket address.  The socket is automatically bound to a "
"free port if unbound."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:73
msgid ""
"A process can listen for incoming connections by first binding to a socket "
"address using B<bind>(2)  and then calling B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:83
msgid ""
"Data is transmitted using the B<send>(2)  or B<write>(2)  families of system "
"calls and data is received using the B<recv>(2)  or B<read>(2)  families of "
"system calls."
msgstr ""

#. type: SS
#: build/C/man7/vsock.7:83
#, no-wrap
msgid "Address format"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:90
msgid ""
"A socket address is defined as a combination of a 32-bit Context Identifier "
"(CID) and a 32-bit port number.  The CID identifies the source or "
"destination, which is either a virtual machine or the host.  The port number "
"differentiates between multiple services running on a single machine."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:104
#, no-wrap
msgid ""
"struct sockaddr_vm {\n"
"    sa_family_t    svm_family;     /* Address family: AF_VSOCK */\n"
"    unsigned short svm_reserved1;\n"
"    unsigned int   svm_port;       /* Port # in host byte order */\n"
"    unsigned int   svm_cid;        /* Address in host byte order */\n"
"    unsigned char  svm_zero[sizeof(struct sockaddr) -\n"
"                            sizeof(sa_family_t) -\n"
"                            sizeof(unsigned short) -\n"
"                            sizeof(unsigned int) -\n"
"                            sizeof(unsigned int)];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:123
msgid ""
"I<svm_family> is always set to B<AF_VSOCK>.  I<svm_reserved1> is always set "
"to 0.  I<svm_port> contains the port number in host byte order.  The port "
"numbers below 1024 are called I<privileged ports>.  Only a process with the "
"B<CAP_NET_BIND_SERVICE> capability may B<bind>(2)  to these port numbers.  "
"I<svm_zero> must be zero-filled."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:135
msgid ""
"There are several special addresses: B<VMADDR_CID_ANY> (-1U)  means any "
"address for binding; B<VMADDR_CID_HYPERVISOR> (0) is reserved for services "
"built into the hypervisor; B<VMADDR_CID_LOCAL> (1) is the well-known address "
"for local communication (loopback); B<VMADDR_CID_HOST> (2)  is the "
"well-known address of the host."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:140
msgid ""
"The special constant B<VMADDR_PORT_ANY> (-1U)  means any port number for "
"binding."
msgstr ""

#. type: SS
#: build/C/man7/vsock.7:140
#, no-wrap
msgid "Live migration"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:146
msgid ""
"Sockets are affected by live migration of virtual machines.  Connected "
"B<SOCK_STREAM> sockets become disconnected when the virtual machine migrates "
"to a new host.  Applications must reconnect when this happens."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:150
msgid ""
"The local CID may change across live migration if the old CID is not "
"available on the new host.  Bound sockets are automatically updated to the "
"new CID."
msgstr ""

#. type: TP
#: build/C/man7/vsock.7:151
#, no-wrap
msgid "B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:156
msgid ""
"Get the CID of the local machine.  The argument is a pointer to an "
"I<unsigned int>."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:160
#, no-wrap
msgid "ioctl(socket, IOCTL_VM_SOCKETS_GET_LOCAL_CID, &cid);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:167
msgid ""
"Consider using B<VMADDR_CID_ANY> when binding instead of getting the local "
"CID with B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:172
msgid ""
"B<VMADDR_CID_LOCAL> (1) directs packets to the same host that generated "
"them.  This is useful for testing applications on a single host and for "
"debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:177
msgid ""
"The local CID obtained with B<IOCTL_VM_SOCKETS_GET_LOCAL_CID> can be used "
"for the same purpose, but it is preferable to use B<VMADDR_CID_LOCAL .>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:183
msgid ""
"Unable to bind to a privileged port without the B<CAP_NET_BIND_SERVICE> "
"capability."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:186
msgid "Unable to bind to a port that is already in use."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:189
msgid "Unable to find a free port for binding or unable to bind to a nonlocal CID."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:196
msgid ""
"Invalid parameters.  This includes: attempting to bind a socket that is "
"already bound, providing an invalid struct I<sockaddr_vm>, and other input "
"validation errors."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:202
msgid "Invalid socket option in B<setsockopt>(2)  or B<getsockopt>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:205
msgid "Unable to perform operation on an unconnected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:218
msgid ""
"Operation not supported.  This includes: the B<MSG_OOB> flag that is not "
"implemented for the B<send>(2)  family of syscalls and B<MSG_PEEK> for the "
"B<recv>(2)  family of syscalls."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:222
msgid "Invalid socket protocol number.  The protocol should always be 0."
msgstr ""

#. type: TP
#: build/C/man7/vsock.7:222
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:231
msgid ""
"Unsupported socket type in B<socket>(2).  Only B<SOCK_STREAM> and "
"B<SOCK_DGRAM> are valid."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:235
msgid ""
"Support for VMware (VMCI) has been available since Linux 3.9.  KVM (virtio) "
"is supported since Linux 4.8.  Hyper-V is supported since Linux 4.14."
msgstr ""

#.  commit ef343b35d46667668a099655fca4a5b2e43a5dfe
#. type: Plain text
#: build/C/man7/vsock.7:241
msgid ""
"VMADDR_CID_LOCAL is supported since Linux 5.6.  Local communication in the "
"guest and on the host is available since Linux 5.6.  Previous versions "
"supported only local communication within a guest (not on the host), and "
"with only some transports (VMCI and virtio)."
msgstr ""

#. type: Plain text
#: build/C/man7/vsock.7:249
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<recv>(2), B<send>(2), "
"B<socket>(2), B<capabilities>(7)"
msgstr ""
