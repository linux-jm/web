# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-19 09:44+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsearch.3:31
#, no-wrap
msgid "BSEARCH"
msgstr "BSEARCH"

#. type: TH
#: build/C/man3/bsearch.3:31 build/C/man3/hsearch.3:35 build/C/man3/qsort.3:37
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: TH
#: build/C/man3/bsearch.3:31 build/C/man3/hsearch.3:35
#: build/C/man3/lsearch.3:26 build/C/man3/qsort.3:37 build/C/man3/tsearch.3:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bsearch.3:32 build/C/man3/hsearch.3:36
#: build/C/man3/lsearch.3:27 build/C/man3/qsort.3:38 build/C/man3/tsearch.3:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bsearch.3:34
msgid "bsearch - binary search of a sorted array"
msgstr "bsearch - ソートされた配列を二分木検索 (binary search) する"

#. type: SH
#: build/C/man3/bsearch.3:34 build/C/man3/hsearch.3:39
#: build/C/man3/lsearch.3:29 build/C/man3/qsort.3:40 build/C/man3/tsearch.3:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bsearch.3:37 build/C/man3/qsort.3:43
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bsearch.3:41
#, no-wrap
msgid ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: SH
#: build/C/man3/bsearch.3:42 build/C/man3/hsearch.3:59
#: build/C/man3/lsearch.3:39 build/C/man3/qsort.3:61 build/C/man3/tsearch.3:57
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bsearch.3:56
msgid ""
"The B<bsearch>()  function searches an array of I<nmemb> objects, the "
"initial member of which is pointed to by I<base>, for a member that matches "
"the object pointed to by I<key>.  The size of each member of the array is "
"specified by I<size>."
msgstr ""
"B<bsearch>()  関数は I<nmemb> 個のオブジェクトからなる配列を検索 する。配列の"
"最初のメンバーへのポインターは I<base> によって与える。 ポインター I<key> で"
"参照されるオブジェクトと一致するメンバーが返される。 配列中の各々のメンバーの"
"サイズは I<size> によって指定する。"

#. type: Plain text
#: build/C/man3/bsearch.3:70
msgid ""
"The contents of the array should be in ascending sorted order according to "
"the comparison function referenced by I<compar>.  The I<compar> routine is "
"expected to have two arguments which point to the I<key> object and to an "
"array member, in that order, and should return an integer less than, equal "
"to, or greater than zero if the I<key> object is found, respectively, to be "
"less than, to match, or be greater than the array member."
msgstr ""
"配列の内容は比較関数 I<compar> に基づき、昇順にソートされていなけれ ばならな"
"い。 I<compar> ルーチンは二つの引数を取る関数で、一つ 目に I<key> へのポイ"
"ンター、次に配列のメンバーへのポインターを取る。 この順に指定したとき、 "
"I<key> が配列メンバーより小さいときには 負の整数を、大きいときには正の整数"
"を、一致したときには 0 を、それぞれ I<compar> は返さなければならない。"

#. type: SH
#: build/C/man3/bsearch.3:70 build/C/man3/hsearch.3:173
#: build/C/man3/lsearch.3:72 build/C/man3/qsort.3:91 build/C/man3/tsearch.3:189
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bsearch.3:77
msgid ""
"The B<bsearch>()  function returns a pointer to a matching member of the "
"array, or NULL if no match is found.  If there are multiple elements that "
"match the key, the element returned is unspecified."
msgstr ""
"B<bsearch>()  関数は、配列のメンバーのうち、一致したものへのポインターを 返"
"す。見つからなかったときは NULL を返す。 I<key> と一致したメンバーが 複数ある"
"とき、そのうちのどのメンバーが返されるかはわからない。"

#. type: SH
#: build/C/man3/bsearch.3:77 build/C/man3/hsearch.3:230
#: build/C/man3/lsearch.3:80 build/C/man3/qsort.3:100
#: build/C/man3/tsearch.3:218
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/bsearch.3:80 build/C/man3/hsearch.3:233
#: build/C/man3/lsearch.3:83 build/C/man3/qsort.3:103
#: build/C/man3/tsearch.3:221
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明については、 B<attributes>(7) を参照。"

#. type: tbl table
#: build/C/man3/bsearch.3:84 build/C/man3/hsearch.3:237
#: build/C/man3/lsearch.3:87 build/C/man3/qsort.3:107
#: build/C/man3/tsearch.3:225
#, no-wrap
msgid "Interface"
msgstr "インターフェース"

#. type: tbl table
#: build/C/man3/bsearch.3:84 build/C/man3/hsearch.3:237
#: build/C/man3/lsearch.3:87 build/C/man3/qsort.3:107
#: build/C/man3/tsearch.3:225
#, no-wrap
msgid "Attribute"
msgstr "属性"

#. type: tbl table
#: build/C/man3/bsearch.3:84 build/C/man3/hsearch.3:237
#: build/C/man3/lsearch.3:87 build/C/man3/qsort.3:107
#: build/C/man3/tsearch.3:225
#, no-wrap
msgid "Value"
msgstr "値"

#. type: tbl table
#: build/C/man3/bsearch.3:87
#, no-wrap
msgid "B<bsearch>()"
msgstr "B<bsearch>()"

#. type: tbl table
#: build/C/man3/bsearch.3:87 build/C/man3/hsearch.3:243
#: build/C/man3/hsearch.3:249 build/C/man3/lsearch.3:91
#: build/C/man3/qsort.3:111 build/C/man3/tsearch.3:231
#: build/C/man3/tsearch.3:234 build/C/man3/tsearch.3:237
#: build/C/man3/tsearch.3:240
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/bsearch.3:87 build/C/man3/lsearch.3:91 build/C/man3/qsort.3:111
#: build/C/man3/tsearch.3:240
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#: build/C/man3/bsearch.3:90 build/C/man3/hsearch.3:251
#: build/C/man3/lsearch.3:94 build/C/man3/qsort.3:114
#: build/C/man3/tsearch.3:242
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bsearch.3:92
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: SH
#: build/C/man3/bsearch.3:92 build/C/man3/hsearch.3:299
#: build/C/man3/qsort.3:121 build/C/man3/tsearch.3:266
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/bsearch.3:97
msgid ""
"The example below first sorts an array of structures using B<qsort>(3), then "
"retrieves desired elements using B<bsearch>()."
msgstr ""
"以下の例は、 B<qsort>(3)  を使って構造体の配列の並び換えを行った後、 所望の要"
"素を B<bsearch>()  を使って取得するものである。"

#. type: Plain text
#: build/C/man3/bsearch.3:102 build/C/man3/qsort.3:132
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/bsearch.3:111
#, no-wrap
msgid ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"
msgstr ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"

#. type: Plain text
#: build/C/man3/bsearch.3:113
#, no-wrap
msgid "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"
msgstr "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"

#. type: Plain text
#: build/C/man3/bsearch.3:121
#, no-wrap
msgid ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    const struct mi *mi1 = m1;\n"
"    const struct mi *mi2 = m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"
msgstr ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    const struct mi *mi1 = m1;\n"
"    const struct mi *mi2 = m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"

#. type: Plain text
#: build/C/man3/bsearch.3:129
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    qsort(months, nr_of_months, sizeof(months[0]), compmi);\n"
"    for (int i = 1; i E<lt> argc; i++) {\n"
"        struct mi key;\n"
"        struct mi *res;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    qsort(months, nr_of_months, sizeof(months[0]), compmi);\n"
"    for (int i = 1; i E<lt> argc; i++) {\n"
"        struct mi key;\n"
"        struct mi *res;\n"

#. type: Plain text
#: build/C/man3/bsearch.3:140
#, no-wrap
msgid ""
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(months[0]), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(months[0]), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/bsearch.3:142 build/C/man3/hsearch.3:348
#: build/C/man3/lsearch.3:99 build/C/man3/qsort.3:158
#: build/C/man3/tsearch.3:343
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bsearch.3:147
msgid "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"
msgstr "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"

#. type: SH
#: build/C/man3/bsearch.3:147 build/C/man3/hsearch.3:353
#: build/C/man3/lsearch.3:103 build/C/man3/qsort.3:163
#: build/C/man3/tsearch.3:348
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bsearch.3:155 build/C/man3/hsearch.3:361
#: build/C/man3/lsearch.3:111 build/C/man3/qsort.3:171
#: build/C/man3/tsearch.3:356
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/hsearch.3:35
#, no-wrap
msgid "HSEARCH"
msgstr "HSEARCH"

#. type: TH
#: build/C/man3/hsearch.3:35 build/C/man3/lsearch.3:26
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/hsearch.3:39
msgid ""
"hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r, hsearch_r - hash table "
"management"
msgstr ""
"hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r, hsearch_r - ハッシュテーブ"
"ルの管理"

#. type: Plain text
#: build/C/man3/hsearch.3:42 build/C/man3/lsearch.3:32
#: build/C/man3/tsearch.3:31
#, no-wrap
msgid "B<#include E<lt>search.hE<gt>>\n"
msgstr "B<#include E<lt>search.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:44
#, no-wrap
msgid "B<int hcreate(size_t >I<nel>B<);>\n"
msgstr "B<int hcreate(size_t >I<nel>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:46
#, no-wrap
msgid "B<ENTRY *hsearch(ENTRY >I<item>B<, ACTION >I<action>B<);>\n"
msgstr "B<ENTRY *hsearch(ENTRY >I<item>B<, ACTION >I<action>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:48
#, no-wrap
msgid "B<void hdestroy(void);>\n"
msgstr "B<void hdestroy(void);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:51 build/C/man3/tsearch.3:49
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>search.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>search.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:53
#, no-wrap
msgid "B<int hcreate_r(size_t >I<nel>B<, struct hsearch_data *>I<htab>B<);>\n"
msgstr "B<int hcreate_r(size_t >I<nel>B<, struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:56
#, no-wrap
msgid ""
"B<int hsearch_r(ENTRY >I<item>B<, ACTION >I<action>B<, ENTRY **>I<retval>B<,>\n"
"B<              struct hsearch_data *>I<htab>B<);>\n"
msgstr ""
"B<int hsearch_r(ENTRY >I<item>B<, ACTION >I<action>B<, ENTRY **>I<retval>B<,>\n"
"B<              struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:58
#, no-wrap
msgid "B<void hdestroy_r(struct hsearch_data *>I<htab>B<);>\n"
msgstr "B<void hdestroy_r(struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:68
msgid ""
"The three functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  allow the "
"caller to create and manage a hash search table containing entries "
"consisting of a key (a string) and associated data.  Using these functions, "
"only one hash table can be used at a time."
msgstr ""
"B<hcreate>(), B<hsearch>(), B<hdestroy>()  の 3 つの関数を利用すると、キー "
"(文字列) と対応するデータから構成される エントリーを格納できるハッシュ検索"
"テーブルを作成、管理することができる。 これらの関数を使って、一度に使用できる"
"のは一つのハッシュテーブルだけである。"

#. type: Plain text
#: build/C/man3/hsearch.3:82
msgid ""
"The three functions B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>()  are "
"reentrant versions that allow a program to use more than one hash search "
"table at the same time.  The last argument, I<htab>, points to a structure "
"that describes the table on which the function is to operate.  The "
"programmer should treat this structure as opaque (i.e., do not attempt to "
"directly access or modify the fields in this structure)."
msgstr ""
"B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>()  の 3 つの関数はリエントラン"
"ト版で、これらを利用すると、 一つのプログラムで同時に複数のハッシュテーブルを"
"使うことができる。 最後の引数 I<htab> は関数の操作対象となるテーブルを示す"
"構造体へのポインターである。 プログラマはこの構造体をブラックボックスとして扱"
"うべきである (つまり、この構造体のフィールドに直接アクセスしたり変更したり し"
"ないこと)。"

#.  e.g., in glibc it is raised to the next higher prime number
#. type: Plain text
#: build/C/man3/hsearch.3:91
msgid ""
"First a hash table must be created using B<hcreate>().  The argument I<nel> "
"specifies the maximum number of entries in the table.  (This maximum cannot "
"be changed later, so choose it wisely.)  The implementation may adjust this "
"value upward to improve the performance of the resulting hash table."
msgstr ""
"最初に、 B<hcreate>()  関数によってハッシュテーブルを作成しなければならな"
"い。 引数 I<nel> でテーブルの最大エントリー数を指定する (この最大値は後で変"
"更することはできないので、よく考えて選択すること)。 作成されるハッシュテーブ"
"ルの性能を向上させるために、 関数内部の実装によりこの値は増やされる場合もあ"
"る。"

#. type: Plain text
#: build/C/man3/hsearch.3:102
msgid ""
"The B<hcreate_r>()  function performs the same task as B<hcreate>(), but for "
"the table described by the structure I<*htab>.  The structure pointed to by "
"I<htab> must be zeroed before the first call to B<hcreate_r>()."
msgstr ""
"B<hcreate_r>()  関数は B<hcreate>()  と同じ動作をするが、構造体 I<*htab> で示"
"されるテーブルを対象として動作する。 I<htab> が指し示す構造体は、 "
"B<hcreate_r>()  を初めて呼び出す前に 0 で埋めておかなければならない。"

#. type: Plain text
#: build/C/man3/hsearch.3:117
msgid ""
"The function B<hdestroy>()  frees the memory occupied by the hash table that "
"was created by B<hcreate>().  After calling B<hdestroy>(), a new hash table "
"can be created using B<hcreate>().  The B<hdestroy_r>()  function performs "
"the analogous task for a hash table described by I<*htab>, which was "
"previously created using B<hcreate_r>()."
msgstr ""
"B<hdestroy>()  関数は、 B<hcreate>()  で作成されたハッシュテーブルが占有して"
"いたメモリーを解放する。 ハッシュテーブルによって占有されていたメモリーを解放"
"し、 新しいテーブルを作成できるようにする。 B<hdestroy>()  を呼び出すと、その"
"後は B<hcreate>()  を使って新しいハッシュテーブルを作成することができる。 "
"B<hdestroy_r>()  関数は、同様の処理を、それ以前に B<hcreate_r>()  を使って作"
"成した I<*htab> で示されるハッシュテーブルに対して実行する。"

#. type: Plain text
#: build/C/man3/hsearch.3:124
msgid ""
"The B<hsearch>()  function searches the hash table for an item with the same "
"key as I<item> (where \"the same\" is determined using B<strcmp>(3)), and if "
"successful returns a pointer to it."
msgstr ""
"B<hsearch>()  関数は、I<item> と同じキーを持つ項目をハッシュテーブルから 検索"
"し、項目が見つかった場合にはその項目へのポインターを返す (「同じ」かどうかは "
"B<strcmp>(3)  を使って判定する)。"

#. type: Plain text
#: build/C/man3/hsearch.3:127
msgid ""
"The argument I<item> is of type I<ENTRY>, which is defined in I<E<lt>search."
"hE<gt>> as follows:"
msgstr ""
"引数 I<item> は B<ENTRY> 型であり、I<E<lt>search.hE<gt>> の中で 以下のよう"
"に定義されている。"

#. type: Plain text
#: build/C/man3/hsearch.3:134
#, no-wrap
msgid ""
"typedef struct entry {\n"
"    char *key;\n"
"    void *data;\n"
"} ENTRY;\n"
msgstr ""
"typedef struct entry {\n"
"    char *key;\n"
"    void *data;\n"
"} ENTRY;\n"

#. type: Plain text
#: build/C/man3/hsearch.3:140
msgid ""
"The field I<key> points to a null-terminated string which is the search "
"key.  The field I<data> points to data that is associated with that key."
msgstr ""
"フィールド I<key> は検索キーとなるヌル終端された文字列を指す。 フィールド "
"I<data> は、このキーに対応するデータを指す。"

#. type: Plain text
#: build/C/man3/hsearch.3:159
msgid ""
"The argument I<action> determines what B<hsearch>()  does after an "
"unsuccessful search.  This argument must either have the value B<ENTER>, "
"meaning insert a copy of I<item> (and return a pointer to the new hash table "
"entry as the function result), or the value B<FIND>, meaning that NULL "
"should be returned.  (If I<action> is B<FIND>, then I<data> is ignored.)"
msgstr ""
"検索が失敗した後の動作は、引数 I<action> により決まる。 この引数には "
"B<ENTER> か B<FIND> のいずれかの値を指定しなければならない。 B<ENTER> は "
"I<item> のコピーを挿入することを (関数の結果として新しいハッシュテーブルエン"
"トリーへのポインターを返す)、 B<FIND> は NULL を返すことを意味する "
"(I<action> が B<FIND> の場合、 I<data> は無視される)。"

#. type: Plain text
#: build/C/man3/hsearch.3:173
msgid ""
"The B<hsearch_r>()  function is like B<hsearch>()  but operates on the hash "
"table described by I<*htab>.  The B<hsearch_r>()  function differs from "
"B<hsearch>()  in that a pointer to the found item is returned in I<*retval>, "
"rather than as the function result."
msgstr ""
"B<hsearch_r>()  関数は B<hsearch>()  と同様だが、 I<*htab> で示されるハッシュ"
"テーブルに対して処理を行う。 B<hsearch_r>()  関数が B<hsearch>()  と異なるの"
"は、見つかった項目へのポインターを、 関数の結果としてではなく、 I<*retval> に"
"格納して返す点である。"

#. type: Plain text
#: build/C/man3/hsearch.3:181
msgid ""
"B<hcreate>()  and B<hcreate_r>()  return nonzero on success.  They return 0 "
"on error, with I<errno> set to indicate the cause of the error."
msgstr ""
"B<hcreate>()  と B<hcreate_r>()  は、成功した場合 0 以外の値を返す。 エラーの"
"場合 0 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/hsearch.3:195
msgid ""
"On success, B<hsearch>()  returns a pointer to an entry in the hash table.  "
"B<hsearch>()  returns NULL on error, that is, if I<action> is B<ENTER> and "
"the hash table is full, or I<action> is B<FIND> and I<item> cannot be found "
"in the hash table.  B<hsearch_r>()  returns nonzero on success, and 0 on "
"error.  In the event of an error, these two functions set I<errno> to "
"indicate the cause of the error."
msgstr ""
"成功すると、 B<hsearch>()  は、ハッシュテーブル内のエントリーへのポインターを"
"返す。 エラーの場合、 B<hsearch>()  は NULL を返す。 エラーとなるのは、 "
"I<action> が B<ENTER> でハッシュテーブルがいっぱいの場合か、 I<action> が "
"B<FIND> で I<item> がハッシュテーブル内に 見つからない場合である。 "
"B<hsearch_r>()  は、成功すると 0 以外を返し、エラーの場合 0 を返す。 エラーの"
"場合、 これら二つの関数は I<errno> にエラーの原因を示す値を設定する。"

#. type: SH
#: build/C/man3/hsearch.3:195
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/hsearch.3:200
msgid ""
"B<hcreate_r>()  and B<hdestroy_r>()  can fail for the following reasons:"
msgstr ""
"B<hcreate_r>()  と B<hdestroy_r>()  は以下の理由で失敗する可能性がある。"

#. type: TP
#: build/C/man3/hsearch.3:200
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/hsearch.3:204
msgid "I<htab> is NULL."
msgstr "I<htab> が NULL である。"

#. type: Plain text
#: build/C/man3/hsearch.3:209
msgid "B<hsearch>()  and B<hsearch_r>()  can fail for the following reasons:"
msgstr "B<hsearch>()  と B<hsearch_r>()  は以下の理由で失敗する可能性がある。"

#. type: TP
#: build/C/man3/hsearch.3:209
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/hsearch.3:217
msgid ""
"I<action> was B<ENTER>, I<key> was not found in the table, and there was no "
"room in the table to add a new entry."
msgstr ""
"I<action> が B<ENTER> で、 I<key> がテーブル内に見つからず、 テーブルに新しい"
"エントリーを追加する余地がなかった。"

#. type: TP
#: build/C/man3/hsearch.3:217
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man3/hsearch.3:225
msgid "I<action> was B<FIND>, and I<key> was not found in the table."
msgstr "I<action> が B<FIND> で、 I<key> がテーブル内に見つからなかった。"

#.  PROX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man3/hsearch.3:230
msgid "POSIX.1 specifies only the B<ENOMEM> error."
msgstr "POSIX.1 が規定しているのは、エラー B<ENOMEM> だけである。"

#. type: tbl table
#: build/C/man3/hsearch.3:241
#, no-wrap
msgid ""
"B<hcreate>(),\n"
"B<hsearch>(),\n"
msgstr ""
"B<hcreate>(),\n"
"B<hsearch>(),\n"

#. type: tbl table
#: build/C/man3/hsearch.3:241 build/C/man3/hsearch.3:247
#: build/C/man3/tsearch.3:229
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/hsearch.3:243
#, no-wrap
msgid "B<hdestroy>()"
msgstr "B<hdestroy>()"

#. type: tbl table
#: build/C/man3/hsearch.3:243
#, no-wrap
msgid "MT-Unsafe race:hsearch"
msgstr "MT-Unsafe race:hsearch"

#. type: tbl table
#: build/C/man3/hsearch.3:247
#, no-wrap
msgid ""
"B<hcreate_r>(),\n"
"B<hsearch_r>(),\n"
msgstr ""
"B<hcreate_r>(),\n"
"B<hsearch_r>(),\n"

#. type: tbl table
#: build/C/man3/hsearch.3:249
#, no-wrap
msgid "B<hdestroy_r>()"
msgstr "B<hdestroy_r>()"

#. type: tbl table
#: build/C/man3/hsearch.3:249
#, no-wrap
msgid "MT-Safe race:htab"
msgstr "MT-Safe race:htab"

#. type: Plain text
#: build/C/man3/hsearch.3:258
msgid ""
"The functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  are from SVr4, "
"and are described in POSIX.1-2001 and POSIX.1-2008."
msgstr "関数 B<hcreate>(), B<hsearch>(), B<hdestroy>()  は SVr4 から導入されたもので、POSIX.1-2001 と POSIX.1-2008 に記述されている。"

#. type: Plain text
#: build/C/man3/hsearch.3:265
msgid ""
"The functions B<hcreate_r>(), B<hsearch_r>(), and B<hdestroy_r>()  are GNU "
"extensions."
msgstr "関数 B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>() は GNU による拡張である。"

#. type: SH
#: build/C/man3/hsearch.3:265 build/C/man3/qsort.3:117
#: build/C/man3/tsearch.3:249
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/hsearch.3:272
msgid ""
"Hash table implementations are usually more efficient when the table "
"contains enough free space to minimize collisions.  Typically, this means "
"that I<nel> should be at least 25% larger than the maximum number of "
"elements that the caller expects to store in the table."
msgstr ""
"通常、ハッシュテーブルの実装は、衝突を最小限にするために テーブルに十分な空き"
"領域がある場合に効率がよくなる。 このため、普通は、 I<nel> を、呼び出し側が"
"テーブルに格納しようと思っている エントリーの最大数より少なくとも 25% は大き"
"な値にすべきである。"

#. type: Plain text
#: build/C/man3/hsearch.3:290
msgid ""
"The B<hdestroy>()  and B<hdestroy_r>()  functions do not free the buffers "
"pointed to by the I<key> and I<data> elements of the hash table entries.  "
"(It can't do this because it doesn't know whether these buffers were "
"allocated dynamically.)  If these buffers need to be freed (perhaps because "
"the program is repeatedly creating and destroying hash tables, rather than "
"creating a single table whose lifetime matches that of the program), then "
"the program must maintain bookkeeping data structures that allow it to free "
"them."
msgstr ""
"B<hdestroy>()  と B<hdestroy_r>()  は、ハッシュテーブルのエントリーの要素であ"
"る I<key> と I<data> が指すバッファーを解放しない (これができないのは、これら"
"のバッファーが動的に割り当てられたのかを 知ることができないからである)。 これ"
"らのバッファーを解放する必要がある場合、 プログラムでは、これらのバッファーを"
"解放できるように管理用のデータ構造を 設けて、これを管理しなければならない (解"
"放が必要となる理由は、たいていは、プログラム自身と生存期間が同じ ハッシュテー"
"ブルを一つだけ作成するのではなく、そのプログラムでは複数の ハッシュテーブルを"
"繰り返して作成したり破棄したりするからであろう)。"

#. type: SH
#: build/C/man3/hsearch.3:290 build/C/man3/lsearch.3:97
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/hsearch.3:297
msgid ""
"SVr4 and POSIX.1-2001 specify that I<action> is significant only for "
"unsuccessful searches, so that an B<ENTER> should not do anything for a "
"successful search.  In libc and glibc (before version 2.3), the "
"implementation violates the specification, updating the I<data> for the "
"given I<key> in this case."
msgstr ""
"SVr4 と POSIX.1-2001 の規定では、 I<action> は検索が失敗したときにだけ意味を"
"持つとなっている。 よって、検索が成功した場合、I<action> の値が B<ENTER> で"
"も 何もすべきではない。 (バージョン 2.3 より前の) libc と glibc の実装はこの"
"規格に違反しており、 この状況で、指定された I<key> に対応する I<data> が更新"
"される。"

#. type: Plain text
#: build/C/man3/hsearch.3:299
msgid "Individual hash table entries can be added, but not deleted."
msgstr "ハッシュテーブルエントリーの追加はできるが、削除ができない。"

#. type: Plain text
#: build/C/man3/hsearch.3:302
msgid ""
"The following program inserts 24 items into a hash table, then prints some "
"of them."
msgstr ""
"次のプログラムは、ハッシュテーブルに 24 個の項目を挿入し、 それからそのうちの"
"いくつかを表示する。"

#. type: Plain text
#: build/C/man3/hsearch.3:307
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:314
#, no-wrap
msgid ""
"static char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
"     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
"     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
"     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
"     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
"};\n"
msgstr ""
"static char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
"     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
"     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
"     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
"     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
"};\n"

#. type: Plain text
#: build/C/man3/hsearch.3:320
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    ENTRY e;\n"
"    ENTRY *ep;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    ENTRY e;\n"
"    ENTRY *ep;\n"

#. type: Plain text
#: build/C/man3/hsearch.3:322
#, no-wrap
msgid "    hcreate(30);\n"
msgstr "    hcreate(30);\n"

#. type: Plain text
#: build/C/man3/hsearch.3:335
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> 24; i++) {\n"
"        e.key = data[i];\n"
"        /* data is just an integer, instead of a\n"
"           pointer to something */\n"
"        e.data = (void *) i;\n"
"        ep = hsearch(e, ENTER);\n"
"        /* there should be no failures */\n"
"        if (ep == NULL) {\n"
"            fprintf(stderr, \"entry failed\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    for (int i = 0; i E<lt> 24; i++) {\n"
"        e.key = data[i];\n"
"        /* データは、ポインターではなく、単なる整数値である。 */\n"
"        e.data = (void *) i;\n"
"        ep = hsearch(e, ENTER);\n"
"        /* エラーは起こらないはずである。 */\n"
"        if (ep == NULL) {\n"
"            fprintf(stderr, \"entry failed\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/hsearch.3:347
#, no-wrap
msgid ""
"    for (int i = 22; i E<lt> 26; i++) {\n"
"        /* print two entries from the table, and\n"
"           show that two are not in the table */\n"
"        e.key = data[i];\n"
"        ep = hsearch(e, FIND);\n"
"        printf(\"%9.9s -E<gt> %9.9s:%d\\en\", e.key,\n"
"               ep ? ep-E<gt>key : \"NULL\", ep ? (int)(ep-E<gt>data) : 0);\n"
"    }\n"
"    hdestroy();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    for (int i = 22; i E<lt> 26; i++) {\n"
"        /* テーブルにある 2 つのエントリーを表示し、\n"
"           あとの 2 つがテーブルにないことを示す。 */\n"
"        e.key = data[i];\n"
"        ep = hsearch(e, FIND);\n"
"        printf(\"%9.9s -E<gt> %9.9s:%d\\en\", e.key,\n"
"               ep ? ep-E<gt>key : \"NULL\", ep ? (int)(ep-E<gt>data) : 0);\n"
"    }\n"
"    hdestroy();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/hsearch.3:353
msgid "B<bsearch>(3), B<lsearch>(3), B<malloc>(3), B<tsearch>(3)"
msgstr "B<bsearch>(3), B<lsearch>(3), B<malloc>(3), B<tsearch>(3)"

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "LSEARCH"
msgstr "LSEARCH"

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: build/C/man3/lsearch.3:29
msgid "lfind, lsearch - linear search of an array"
msgstr "lfind, lsearch - 配列を線形検索する"

#. type: Plain text
#: build/C/man3/lsearch.3:35
#, no-wrap
msgid ""
"B<void *lfind(const void *>I<key>B<, const void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *lfind(const void *>I<key>B<, const void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/lsearch.3:38
#, no-wrap
msgid ""
"B<void *lsearch(const void *>I<key>B<, void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *lsearch(const void *>I<key>B<, void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/lsearch.3:61
msgid ""
"B<lfind>()  and B<lsearch>()  perform a linear search for I<key> in the "
"array I<base> which has I<*nmemb> elements of I<size> bytes each.  The "
"comparison function referenced by I<compar> is expected to have two "
"arguments which point to the I<key> object and to an array member, in that "
"order, and which returns zero if the I<key> object matches the array member, "
"and nonzero otherwise."
msgstr ""
"B<lfind>()  と B<lsearch>()  は、 I<size> バイトの要素 I<*nmemb> 個からなる配"
"列 I<base> から、 I<key> を線形検索する。比較を行うのは I<compar> が参照して"
"いる関数で、 これは 2つの引数を持ち、1つめの引数が I<key> を、2つめの引"
"数は配列メンバーを指す。また I<compar> は、 I<key> が配列のメンバーとマッチし"
"たなら 0、そうでなければ 0 以外を返すことが期待されている。"

#. type: Plain text
#: build/C/man3/lsearch.3:72
msgid ""
"If B<lsearch>()  does not find a matching element, then the I<key> object is "
"inserted at the end of the table, and I<*nmemb> is incremented.  In "
"particular, one should know that a matching element exists, or that more "
"room is available."
msgstr ""
"B<lsearch>()  は、マッチする要素を見つけられなかったとき、 配列の最後に "
"I<key> をつけ加える。そして I<*nmemb> を 1 ふやす。 したがって、この関数を使"
"用する際には、マッチする要素が存在するか、 もしくは配列に要素を追加するための"
"領域があるか、を把握しておく必要がある。"

#. type: Plain text
#: build/C/man3/lsearch.3:80
msgid ""
"B<lfind>()  returns a pointer to a matching member of the array, or NULL if "
"no match is found.  B<lsearch>()  returns a pointer to a matching member of "
"the array, or to the newly added member if no match is found."
msgstr ""
"B<lfind>()  の返り値は、配列のマッチしたメンバーへのポインターである。 もし"
"マッチするメンバーが見つからないと NULL を返す。 B<lsearch>()  の返り値も、配"
"列のマッチしたメンバーへのポインターである。 マッチするメンバーが見つからな"
"かったときは、 新たにつけ加えたメンバーへのポインターを返す。"

#. type: tbl table
#: build/C/man3/lsearch.3:91
#, no-wrap
msgid ""
"B<lfind>(),\n"
"B<lsearch>()"
msgstr ""
"B<lfind>(),\n"
"B<lsearch>()"

#. type: Plain text
#: build/C/man3/lsearch.3:97
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  Present in libc since libc-4.6.27."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD. libc には libc-4.6.27 以降で実装されている。"

#. type: Plain text
#: build/C/man3/lsearch.3:99
msgid "The naming is unfortunate."
msgstr "関数の名前の選び方がよくない。"

#. type: Plain text
#: build/C/man3/lsearch.3:103
msgid "B<bsearch>(3), B<hsearch>(3), B<tsearch>(3)"
msgstr "B<bsearch>(3), B<hsearch>(3), B<tsearch>(3)"

#. type: TH
#: build/C/man3/qsort.3:37
#, no-wrap
msgid "QSORT"
msgstr "QSORT"

#. type: Plain text
#: build/C/man3/qsort.3:40
msgid "qsort, qsort_r - sort an array"
msgstr "qsort, qsort_r - 配列を並べ変える"

#. type: Plain text
#: build/C/man3/qsort.3:46
#, no-wrap
msgid ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/qsort.3:50
#, no-wrap
msgid ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"
msgstr ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"

#. type: Plain text
#: build/C/man3/qsort.3:55
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/qsort.3:60
msgid "B<qsort_r>(): _GNU_SOURCE"
msgstr "B<qsort_r>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/qsort.3:68
msgid ""
"The B<qsort>()  function sorts an array with I<nmemb> elements of size "
"I<size>.  The I<base> argument points to the start of the array."
msgstr ""
"B<qsort>()  関数は、 I<nmemb> 個の大きさ I<size> の要素をもつ配列を並べ変え"
"る。 I<base> 引数は配列の先頭へのポインターである。"

#. type: Plain text
#: build/C/man3/qsort.3:72
msgid ""
"The contents of the array are sorted in ascending order according to a "
"comparison function pointed to by I<compar>, which is called with two "
"arguments that point to the objects being compared."
msgstr ""
"I<compar> をポインターとする比較関数によって、 配列の中身は昇順 (値の大きいも"
"のほど後に並ぶ順番) に並べられる。 比較関数の引数は比較されるふたつのオブ"
"ジェクトのポインターである。"

#. type: Plain text
#: build/C/man3/qsort.3:78
msgid ""
"The comparison function must return an integer less than, equal to, or "
"greater than zero if the first argument is considered to be respectively "
"less than, equal to, or greater than the second.  If two members compare as "
"equal, their order in the sorted array is undefined."
msgstr ""
"比較関数は、第一引数が第二引数に対して、 1) 小さい、2) 等しい、3) 大きい"
"のそれぞれに応じて、 1) ゼロより小さい整数、2) ゼロ、3) ゼロより大きい整数の "
"いずれかを返さなければならない。 二つの要素の比較結果が等しいとき、 並べ変え"
"た後の配列では、これら二つの順序は規定されていない。"

#. type: Plain text
#: build/C/man3/qsort.3:91
msgid ""
"The B<qsort_r>()  function is identical to B<qsort>()  except that the "
"comparison function I<compar> takes a third argument.  A pointer is passed "
"to the comparison function via I<arg>.  In this way, the comparison function "
"does not need to use global variables to pass through arbitrary arguments, "
"and is therefore reentrant and safe to use in threads."
msgstr ""
"B<qsort_r>() 関数は B<qsort>() と同じだが、比較関数 I<compar> が第 3 引数"
"を\n"
"取る点が異なる。ポインターが I<arg> 経由で比較関数に渡される。\n"
"これにより、比較関数は任意の引数を渡すためにグローバル変数を使う必要がなく"
"なり、\n"
"そのため、リエントラント (再入可能) で安全にスレッドで使用できるようになる。"

#. type: Plain text
#: build/C/man3/qsort.3:97
msgid "The B<qsort>()  and B<qsort_r>()  functions return no value."
msgstr "関数 B<qsort>() と B<qsort_r>() は値を返さない。"

#. type: SH
#: build/C/man3/qsort.3:97 build/C/man3/tsearch.3:215
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/qsort.3:100
msgid "B<qsort_r>()  was added to glibc in version 2.8."
msgstr "B<qsort_r>() は glibc バージョン 2.8 で追加された。"

#. type: tbl table
#: build/C/man3/qsort.3:111
#, no-wrap
msgid ""
"B<qsort>(),\n"
"B<qsort_r>()"
msgstr ""
"B<qsort>(),\n"
"B<qsort_r>()"

#. type: Plain text
#: build/C/man3/qsort.3:117
msgid "B<qsort>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "B<qsort>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man3/qsort.3:121
msgid ""
"To compare C strings, the comparison function can call B<strcmp>(3), as "
"shown in the example below."
msgstr "C の文字列を比較する場合、以下の例にあるように比較関数で B<strcmp>(3) を呼び出すこともできる。"

#. type: Plain text
#: build/C/man3/qsort.3:124
msgid "For one example of use, see the example under B<bsearch>(3)."
msgstr "使用例については、 B<bsearch>(3)  にある例を参照すること。"

#. type: Plain text
#: build/C/man3/qsort.3:127
msgid ""
"Another example is the following program, which sorts the strings given in "
"its command-line arguments:"
msgstr ""
"以下のプログラムに別の使用例を示す。このプログラムは、 コマンドライン引数で"
"指定された文字列の並び換えを行う。"

#. type: Plain text
#: build/C/man3/qsort.3:139
#, no-wrap
msgid ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* The actual arguments to this function are \"pointers to\n"
"       pointers to char\", but strcmp(3) arguments are \"pointers\n"
"       to char\", hence the following cast plus dereference */\n"
msgstr ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* この関数の実際の引数は \"char 型へのポインターのポインター\" だが、\n"
"       strcmp(3) の引数は \"char 型へのポインター\" である。\n"
"       そこで、以下のようにキャストをしてからポインターの逆参照を行う。*/\n"

#. type: Plain text
#: build/C/man3/qsort.3:142
#, no-wrap
msgid ""
"    return strcmp(*(const char **) p1, *(const char **) p2);\n"
"}\n"
msgstr ""
"    return strcmp(*(const char **) p1, *(const char **) p2);\n"
"}\n"

#. type: Plain text
#: build/C/man3/qsort.3:150
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/qsort.3:152
#, no-wrap
msgid "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"
msgstr "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"

#. type: Plain text
#: build/C/man3/qsort.3:157
#, no-wrap
msgid ""
"    for (int j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    for (int j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/qsort.3:163
msgid "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"
msgstr "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"

#. type: TH
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "TSEARCH"
msgstr "TSEARCH"

#. type: Plain text
#: build/C/man3/tsearch.3:28
msgid "tsearch, tfind, tdelete, twalk, tdestroy - manage a binary search tree"
msgstr "tsearch, tfind, tdelete, twalk, tdestroy - 二分探索木 (binary search tree) の操作"

#. type: Plain text
#: build/C/man3/tsearch.3:33
#, no-wrap
msgid "B<typedef enum { preorder, postorder, endorder, leaf } VISIT;>\n"
msgstr "B<typedef enum { preorder, postorder, endorder, leaf } VISIT;>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:36
#, no-wrap
msgid ""
"B<void *tsearch(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tsearch(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:39
#, no-wrap
msgid ""
"B<void *tfind(const void *>I<key>B<, void *const *>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tfind(const void *>I<key>B<, void *const *>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:42
#, no-wrap
msgid ""
"B<void *tdelete(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tdelete(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:46
#, no-wrap
msgid ""
"B<void twalk(const void *>I<root>B<,>\n"
"B<                void (*>I<action>B<)(const void *>I<nodep>B<, VISIT >I<which>B<,>\n"
"B<                               int >I<depth>B<));>\n"
msgstr ""
"B<void twalk(const void *>I<root>B<,>\n"
"B<                void (*>I<action>B<)(const void *>I<nodep>B<, VISIT >I<which>B<,>\n"
"B<                               int >I<depth>B<));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:54
#, no-wrap
msgid ""
"B<void twalk_r(const void *>I<root>B<,>\n"
"B<                void (*>I<action>B<)(const void *>I<nodep>B<, VISIT >I<which>B<,>\n"
"B<                               void *>I<closure>B<),>\n"
"B<                void *>I<closure>B<);>\n"
msgstr ""
"B<void twalk_r(const void *>I<root>B<,>\n"
"B<                void (*>I<action>B<)(const void *>I<nodep>B<, VISIT >I<which>B<,>\n"
"B<                               void *>I<closure>B<),>\n"
"B<                void *>I<closure>B<);>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:56
#, no-wrap
msgid "B<void tdestroy(void *>I<root>B<, void (*>I<free_node>B<)(void *>I<nodep>B<));>\n"
msgstr "B<void tdestroy(void *>I<root>B<, void (*>I<free_node>B<)(void *>I<nodep>B<));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:75
msgid ""
"B<tsearch>(), B<tfind>(), B<twalk>(), and B<tdelete>()  manage a binary "
"search tree.  They are generalized from Knuth (6.2.2) Algorithm T.  The "
"first field in each node of the tree is a pointer to the corresponding data "
"item.  (The calling program must store the actual data.)  I<compar> points "
"to a comparison routine, which takes pointers to two items.  It should "
"return an integer which is negative, zero, or positive, depending on whether "
"the first item is less than, equal to, or greater than the second."
msgstr "B<tsearch>(), B<tfind>(), B<twalk>(), B<tdelete>()  は 二分探索木を操作する関数である。 これらの関数は Knuth (6.2.2) Algorithm T に基づいている。 木構造における各ノードの最初のフィールドは、対応するデータ アイテムへのポインターである。 (参照先のデータは、呼び出しプログラムで用意する。)  I<compar> は比較ルーチンへのポインターである。 比較ルーチンは、アイテムへのポインター 2 つを引数に持つ。 比較ルーチンの返り値は、1 つ目のアイテムが 2 つ目のアイテムよりも 「小さい、等しい、大きい」によって、 「負、0、正」の整数値でなければならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:97
#, fuzzy
#| msgid ""
#| "B<tsearch>()  searches the tree for an item.  I<key> points to the item "
#| "to be searched for.  I<rootp> points to a variable which points to the "
#| "root of the tree.  If the tree is empty, then the variable that I<rootp> "
#| "points to should be set to NULL.  If the item is found in the tree, then "
#| "B<tsearch>()  returns a pointer to it.  If it is not found, then "
#| "B<tsearch>()  adds it, and returns a pointer to the newly added item."
msgid ""
"B<tsearch>()  searches the tree for an item.  I<key> points to the item to "
"be searched for.  I<rootp> points to a variable which points to the root of "
"the tree.  If the tree is empty, then the variable that I<rootp> points to "
"should be set to NULL.  If the item is found in the tree, then B<tsearch>()  "
"returns a pointer to the corresponding tree node.  (In other words, "
"B<tsearch>()  returns a pointer to a pointer to the data item.)  If the item "
"is not found, then B<tsearch>()  adds it, and returns a pointer to the "
"corresponding tree node."
msgstr ""
"B<tsearch>()  は、木構造からアイテムを検索する関数である。 I<key> は、検索す"
"るアイテムへのポインターである。 I<rootp> は木構造の根へのポインターへのポイ"
"ンターである。 木構造がノードを含まない場合、I<rootp> の参照している変数は "
"NULL に設定されていなければならない。 木構造にアイテムが見つかった場合、 "
"B<tsearch>()  はそのアイテムへのポインターを返す。 見つからなかった場合は、ア"
"イテムを木構造に追加し、 追加したアイテムへのポインターを返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:105
msgid ""
"B<tfind>()  is like B<tsearch>(), except that if the item is not found, then "
"B<tfind>()  returns NULL."
msgstr ""
"B<tfind>()  は、 B<tsearch>()  に似ているが、 アイテムが見つからなかった場合 "
"NULL を返す点が異なる。"

#. type: Plain text
#: build/C/man3/tsearch.3:110
msgid ""
"B<tdelete>()  deletes an item from the tree.  Its arguments are the same as "
"for B<tsearch>()."
msgstr ""
"B<tdelete>()  は木構造からアイテムを削除する。 引数は B<tsearch>()  と同じ"
"である。"

#. type: Plain text
#: build/C/man3/tsearch.3:145
msgid ""
"B<twalk>()  performs depth-first, left-to-right traversal of a binary tree.  "
"I<root> points to the starting node for the traversal.  If that node is not "
"the root, then only part of the tree will be visited.  B<twalk>()  calls the "
"user function I<action> each time a node is visited (that is, three times "
"for an internal node, and once for a leaf).  I<action>, in turn, takes three "
"arguments.  The first argument is a pointer to the node being visited.  The "
"structure of the node is unspecified, but it is possible to cast the pointer "
"to a pointer-to-pointer-to-element in order to access the element stored "
"within the node.  The application must not modify the structure pointed to "
"by this argument.  The second argument is an integer which takes one of the "
"values B<preorder>, B<postorder>, or B<endorder> depending on whether this "
"is the first, second, or third visit to the internal node, or the value "
"B<leaf> if this is the single visit to a leaf node.  (These symbols are "
"defined in I<E<lt>search.hE<gt>>.)  The third argument is the depth of the "
"node; the root node has depth zero."
msgstr ""
"B<twalk>()  は、二分木を深さ優先 (depth-first) で、 左から右にたどっていく関"
"数である。 I<root> は起点となるノードへのポインターである。 I<root> に根以外"
"のノードを指定すると、部分木が対象となる。 B<twalk>()  は、ノードを訪れる度に"
"ユーザー関数 I<action> を呼び出す (内部ノードに対しては 3 回、葉に対しては 1 "
"回呼び出しが行われる)。 I<action> には以下の順に 3 つの引数が与えられる。 "
"最初の引数は訪れたノードへのポインターである。 ノードの構造体は規定されてい"
"ないが、 ポインターを要素へのポインターのポインターにキャストし、 ノードに格"
"納された要素にアクセスすることができる。 アプリケーションは、この引数が指す"
"構造体を変更してはならない。 2 番目の引数には、内部ノードの場合は訪問回数に"
"応じて B<preorder>, B<postorder>, B<endorder> のいずれかの整数が、 葉を最初に"
"訪れた場合は B<leaf> の値が渡される (これらのシンボルは I<E<lt>search."
"hE<gt>> で定義されている)。  3 番目の引数はノードの深さで、根の場合は深さ "
"0 である。"

#. type: Plain text
#: build/C/man3/tsearch.3:161
msgid ""
"(More commonly, B<preorder>, B<postorder>, and B<endorder> are known as "
"B<preorder>, B<inorder>, and B<postorder>: before visiting the children, "
"after the first and before the second, and after visiting the children.  "
"Thus, the choice of name B<post\\%order> is rather confusing.)"
msgstr ""
"(より一般的には、B<preorder>, B<postorder>, B<endorder> は B<preorder>, "
"B<inorder>, B<postorder> として知られている: それぞれ、子要素を辿る前・最初の"
"子要素を辿った後かつ 2 番目の子要素を辿る前・ 子要素を辿った後ということを表"
"している。 よって B<post\\%order> という名前を選ぶのは少し紛らわしい。)"

#. type: Plain text
#: build/C/man3/tsearch.3:174
msgid ""
"B<twalk_r>()  is similar to B<twalk>(), but instead of the I<depth> "
"argument, the I<closure> argument pointer is passed to each invocation of "
"the action callback, unchanged.  This pointer can be used to pass "
"information to and from the callback function in a thread-safe fashion, "
"without resorting to global variables."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:189
msgid ""
"B<tdestroy>()  removes the whole tree pointed to by I<root>, freeing all "
"resources allocated by the B<tsearch>()  function.  For the data in each "
"tree node the function I<free_node> is called.  The pointer to the data is "
"passed as the argument to the function.  If no such work is necessary, "
"I<free_node> must point to a function doing nothing."
msgstr ""
"B<tdestroy>()  は I<root> が指す木構造全体を削除し、 B<tsearch>()  関数で確保"
"されたリソースを全て解放する。 木構造の各ノードについて、関数 I<free_node> が"
"呼び出される。 データへのポインターがこの関数の引数として渡される。 そのよ"
"うな動作が必要でなければ、 I<free_node> は何もしない関数へのポインターでなけ"
"ればならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:199
#, fuzzy
#| msgid ""
#| "B<tsearch>()  returns a pointer to a matching item in the tree, or to the "
#| "newly added item, or NULL if there was insufficient memory to add the "
#| "item.  B<tfind>()  returns a pointer to the item, or NULL if no match is "
#| "found.  If there are multiple elements that match the key, the element "
#| "returned is unspecified."
msgid ""
"B<tsearch>()  returns a pointer to a matching node in the tree, or to the "
"newly added node, or NULL if there was insufficient memory to add the item.  "
"B<tfind>()  returns a pointer to the node, or NULL if no match is found.  If "
"there are multiple items that match the key, the item whose node is returned "
"is unspecified."
msgstr ""
"B<tsearch>()  は、木構造に見つかったアイテムか、 新しく追加したアイテムへのポ"
"インターを返す。 メモリーの不足のためアイテムを追加できなかった場合は NULL を"
"返す。 B<tfind>()  は、アイテムへのポインターを返す。 一致するアイテムが見つ"
"からない場合は NULL を返す。 検索条件に一致する要素が複数ある場合、返される値"
"は不定である。"

#. type: Plain text
#: build/C/man3/tsearch.3:206
#, fuzzy
#| msgid ""
#| "B<tdelete>()  returns a pointer to the parent of the item deleted, or "
#| "NULL if the item was not found."
msgid ""
"B<tdelete>()  returns a pointer to the parent of the node deleted, or NULL "
"if the item was not found.  If the deleted node was the root node, "
"B<tdelete>()  returns a dangling pointer that must not be accessed."
msgstr ""
"B<tdelete>()  は削除したアイテムの親へのポインターを返す。 アイテムが見つから"
"なかった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:215
msgid ""
"B<tsearch>(), B<tfind>(), and B<tdelete>()  also return NULL if I<rootp> was "
"NULL on entry."
msgstr ""
"I<rootp> が NULL の場合、 B<tsearch>(), B<tfind>(), B<tdelete>()  は NULL を"
"返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:218
msgid "B<twalk_r>()  is available in glibc since version 2.30."
msgstr "B<twalk_r>() は glibc バージョン 2.30 以降で利用可能である。"

#. type: tbl table
#: build/C/man3/tsearch.3:229
#, no-wrap
msgid ""
"B<tsearch>(),\n"
"B<tfind>(),\n"
msgstr ""
"B<tsearch>(),\n"
"B<tfind>(),\n"

#. type: tbl table
#: build/C/man3/tsearch.3:231
#, no-wrap
msgid "B<tdelete>()"
msgstr "B<tdelete>()"

#. type: tbl table
#: build/C/man3/tsearch.3:231
#, no-wrap
msgid "MT-Safe race:rootp"
msgstr "MT-Safe race:rootp"

#. type: tbl table
#: build/C/man3/tsearch.3:234
#, no-wrap
msgid "B<twalk>()"
msgstr "B<twalk>()"

#. type: tbl table
#: build/C/man3/tsearch.3:234 build/C/man3/tsearch.3:237
#, no-wrap
msgid "MT-Safe race:root"
msgstr "MT-Safe race:root"

#. type: tbl table
#: build/C/man3/tsearch.3:237
#, no-wrap
msgid "B<twalk_r>()"
msgstr "B<twalk_r>()"

#. type: tbl table
#: build/C/man3/tsearch.3:240
#, no-wrap
msgid "B<tdestroy>()"
msgstr "B<tdestroy>()"

#. type: Plain text
#: build/C/man3/tsearch.3:249
#, fuzzy
#| msgid "SVr4, POSIX.1-2001.  The function B<tdestroy>()  is a GNU extension."
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  The functions B<tdestroy>()  and "
"B<twalk_r>()  are GNU extensions."
msgstr "SVr4, POSIX.1-2001.  関数 B<tdestroy>()  は GNU の拡張である。"

#. type: Plain text
#: build/C/man3/tsearch.3:253
msgid ""
"B<twalk>()  takes a pointer to the root, while the other functions take a "
"pointer to a variable which points to the root."
msgstr ""
"B<twalk>()  は根へのポインターを引数にとるが、 ほかの関数は根へのポインター"
"へのポインターである。"

#. type: Plain text
#: build/C/man3/tsearch.3:258
msgid ""
"B<tdelete>()  frees the memory required for the node in the tree.  The user "
"is responsible for freeing the memory for the corresponding data."
msgstr ""
"B<tdelete>()  は、削除したノードの使用していたメモリーを解放するが、 ノードに"
"対応するデータのメモリーは、ユーザーが解放しなければならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:266
msgid ""
"The example program depends on the fact that B<twalk>()  makes no further "
"reference to a node after calling the user function with argument \"endorder"
"\" or \"leaf\".  This works with the GNU library implementation, but is not "
"in the System V documentation."
msgstr ""
"下のプログラム例は、ユーザー関数が \"endorder\" か \"leaf\" を引数にして 呼"
"び出されて以降は、 B<twalk>()  がそのノードを参照しないことを前提としてい"
"る。 これは GNU ライブラリの実装では機能するが、System V のマニュアルには存在"
"しない。"

#. type: Plain text
#: build/C/man3/tsearch.3:270
msgid ""
"The following program inserts twelve random numbers into a binary tree, "
"where duplicate numbers are collapsed, then prints the numbers in order."
msgstr ""
"以下のプログラムは 12 個の乱数を二分木に挿入した後、 挿入した数を順番に出力す"
"る (挿入の際、重複した乱数は 1 つにまとめられる)。"

#. type: Plain text
#: build/C/man3/tsearch.3:278
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Expose declaration of tdestroy() */\n"
"#include E<lt>search.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* Expose declaration of tdestroy() */\n"
"#include E<lt>search.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:280
#, no-wrap
msgid "static void *root = NULL;\n"
msgstr "static void *root = NULL;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:291
#, no-wrap
msgid ""
"static void *\n"
"xmalloc(size_t n)\n"
"{\n"
"    void *p;\n"
"    p = malloc(n);\n"
"    if (p)\n"
"        return p;\n"
"    fprintf(stderr, \"insufficient memory\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void *\n"
"xmalloc(size_t n)\n"
"{\n"
"    void *p;\n"
"    p = malloc(n);\n"
"    if (p)\n"
"        return p;\n"
"    fprintf(stderr, \"insufficient memory\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:301
#, no-wrap
msgid ""
"static int\n"
"compare(const void *pa, const void *pb)\n"
"{\n"
"    if (*(int *) pa E<lt> *(int *) pb)\n"
"        return -1;\n"
"    if (*(int *) pa E<gt> *(int *) pb)\n"
"        return 1;\n"
"    return 0;\n"
"}\n"
msgstr ""
"static int\n"
"compare(const void *pa, const void *pb)\n"
"{\n"
"    if (*(int *) pa E<lt> *(int *) pb)\n"
"        return -1;\n"
"    if (*(int *) pa E<gt> *(int *) pb)\n"
"        return 1;\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:306
#, no-wrap
msgid ""
"static void\n"
"action(const void *nodep, VISIT which, int depth)\n"
"{\n"
"    int *datap;\n"
msgstr ""
"static void\n"
"action(const void *nodep, VISIT which, int depth)\n"
"{\n"
"    int *datap;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:322
#, no-wrap
msgid ""
"    switch (which) {\n"
"    case preorder:\n"
"        break;\n"
"    case postorder:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    case endorder:\n"
"        break;\n"
"    case leaf:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""
"    switch (which) {\n"
"    case preorder:\n"
"        break;\n"
"    case postorder:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    case endorder:\n"
"        break;\n"
"    case leaf:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:327
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int **val;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int **val;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:342
#, no-wrap
msgid ""
"    srand(time(NULL));\n"
"    for (int i = 0; i E<lt> 12; i++) {\n"
"        int *ptr = xmalloc(sizeof(*ptr));\n"
"        *ptr = rand() & 0xff;\n"
"        val = tsearch(ptr, &root, compare);\n"
"        if (val == NULL)\n"
"            exit(EXIT_FAILURE);\n"
"        else if (*val != ptr)\n"
"            free(ptr);\n"
"    }\n"
"    twalk(root, action);\n"
"    tdestroy(root, free);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    srand(time(NULL));\n"
"    for (int i = 0; i E<lt> 12; i++) {\n"
"        int *ptr = xmalloc(sizeof(*ptr));\n"
"        *ptr = rand() & 0xff;\n"
"        val = tsearch(ptr, &root, compare);\n"
"        if (val == NULL)\n"
"            exit(EXIT_FAILURE);\n"
"        else if (*val != ptr)\n"
"            free(ptr);\n"
"    }\n"
"    twalk(root, action);\n"
"    tdestroy(root, free);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:348
msgid "B<bsearch>(3), B<hsearch>(3), B<lsearch>(3), B<qsort>(3)"
msgstr "B<bsearch>(3), B<hsearch>(3), B<lsearch>(3)  B<qsort>(3)"

#~ msgid "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."
#~ msgstr "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."

#~ msgid ""
#~ "int\n"
#~ "main(int argc, char **argv)\n"
#~ "{\n"
#~ "    int i;\n"
#~ msgstr ""
#~ "int\n"
#~ "main(int argc, char **argv)\n"
#~ "{\n"
#~ "    int i;\n"

#~ msgid "2014-01-05"
#~ msgstr "2014-01-05"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid ""
#~ "The B<hcreate>(), B<hsearch>(), and B<hdestroy>()  functions use a global "
#~ "space for storing the table, so they are not thread-safe."
#~ msgstr ""
#~ "関数 B<hcreate>(), B<hsearch>(), B<hdestroy>() はテーブルを格納するのにグ"
#~ "ローバル空間を使用する。そのため、これらの関数はスレッドセーフではない。"

#~ msgid "INSQUE"
#~ msgstr "INSQUE"

#~ msgid "2014-08-19"
#~ msgstr "2014-08-19"

#~ msgid "insque, remque - insert/remove an item from a queue"
#~ msgstr "insque, remque - キューにアイテムを挿入/削除する"

#~ msgid "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"
#~ msgstr "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"

#~ msgid "B<void remque(void *>I<elem>B<);>\n"
#~ msgstr "B<void remque(void *>I<elem>B<);>\n"

#~ msgid "B<insque>(), B<remque>():"
#~ msgstr "B<insque>(), B<remque>():"

#~ msgid ""
#~ "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"
#~ msgstr ""
#~ "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
#~ "_XOPEN_SOURCE_EXTENDED"

#~ msgid ""
#~ "The B<insque>()  and B<remque>()  functions manipulate doubly-linked "
#~ "lists.  Each element in the list is a structure of which the first two "
#~ "elements are a forward and a backward pointer.  The linked list may be "
#~ "linear (i.e., NULL forward pointer at the end of the list and NULL "
#~ "backward pointer at the start of the list)  or circular."
#~ msgstr ""
#~ "関数 B<insque>() と B<remque>() は双方向連結リスト (doubly-linked list) "
#~ "を\n"
#~ "操作する。リスト中のそれぞれの要素は、最初の二つの要素がそれぞれ次と前へ"
#~ "の\n"
#~ "ポインターであるような構造体である。\n"
#~ "リンクリストは、線形 (linear) か環状 (circular) のどちらかになる\n"
#~ "(線形の場合には、リストの末尾では次へのポインターが NULL になり、\n"
#~ "リストの先頭では前へのポインターが NULL になる)。"

#~ msgid ""
#~ "The B<insque>()  function inserts the element pointed to by I<elem> "
#~ "immediately after the element pointed to by I<prev>."
#~ msgstr ""
#~ "B<insque>() 関数は I<elem> で示される要素を I<prev> で示される\n"
#~ "要素の直後に挿入する。"

#~ msgid ""
#~ "If the list is linear, then the call I<insque(elem, NULL)> can be used to "
#~ "insert the initial list element, and the call sets the forward and "
#~ "backward pointers of I<elem> to NULL."
#~ msgstr ""
#~ "リストが線形の場合、I<insque(elem, NULL)> を呼び出すと、\n"
#~ "リストの最初の要素を挿入することができる。\n"
#~ "この呼び出しを行うと I<elem> の次へのポインターと前へのポインターに\n"
#~ "共に NULL が設定される。"

#~ msgid ""
#~ "If the list is circular, the caller should ensure that the forward and "
#~ "backward pointers of the first element are initialized to point to that "
#~ "element, and the I<prev> argument of the B<insque>()  call should also "
#~ "point to the element."
#~ msgstr ""
#~ "リストが環状の場合、呼び出す側が、最初の要素の次へのポインターと前へのポイ"
#~ "ンター\n"
#~ "が自分自身を指し、また  B<insque>() の呼び出しで I<prev> 引数が最初の要"
#~ "素\n"
#~ "を指すように保証しなければならない。"

#~ msgid ""
#~ "The B<remque>()  function removes the element pointed to by I<elem> from "
#~ "the doubly-linked list."
#~ msgstr ""
#~ "B<remque>() 関数は I<elem> で示される要素を双方向連結リストから取り除く。"

#~ msgid "POSIX.1-2001."
#~ msgstr "POSIX.1-2001."

#~ msgid ""
#~ "Traditionally (e.g., SunOS, Linux libc4 and libc5), the arguments of "
#~ "these functions were of type I<struct qelem *>, defined as:"
#~ msgstr ""
#~ "伝統的に (SunOS, Linux libc 4,5 では) これらの関数の引数は I<struct "
#~ "qelem *>型であり、これは以下のように定義されている。"

#~ msgid ""
#~ "struct qelem {\n"
#~ "    struct qelem *q_forw;\n"
#~ "    struct qelem *q_back;\n"
#~ "    char          q_data[1];\n"
#~ "};\n"
#~ msgstr ""
#~ "struct qelem {\n"
#~ "    struct qelem *q_forw;\n"
#~ "    struct qelem *q_back;\n"
#~ "    char          q_data[1];\n"
#~ "};\n"

#~ msgid ""
#~ "This is still what you will get if B<_GNU_SOURCE> is defined before "
#~ "including I<E<lt>search.hE<gt>>."
#~ msgstr ""
#~ "この定義は I<E<lt>search.hE<gt>> をインクルードする前に B<_GNU_SOURCE> を"
#~ "定義することで得られる。"

#~ msgid ""
#~ "The location of the prototypes for these functions differs among several "
#~ "versions of UNIX.  The above is the POSIX version.  Some systems place "
#~ "them in I<E<lt>string.hE<gt>>."
#~ msgstr ""
#~ "これらの関数のプロトタイプの置かれる場所は、UNIX の種類により異なる。\n"
#~ "上記は POSIX 版である。 I<E<lt>string.hE<gt>> にあるシステムもある。"

#~ msgid ""
#~ "In glibc 2.4 and earlier, it was not possible to specify I<prev> as "
#~ "NULL.  Consequently, to build a linear list, the caller had to build a "
#~ "list using an initial call that contained the first two elements of the "
#~ "list, with the forward and backward pointers in each element suitably "
#~ "initialized."
#~ msgstr ""
#~ "glibc 2.4 以前では I<prev> に NULL を指定することができなかった。\n"
#~ "その結果、線形のリストを作成するためには、\n"
#~ "呼び出し側は、最初の呼び出しで、リストの最初の 2 つの要素を持ち、\n"
#~ "各要素の次へのポインターと前へのポインターを適切に初期化したリストを\n"
#~ "作成しなければならなかった。"

#~ msgid ""
#~ "The program below demonstrates the use of B<insque>().  Here is an "
#~ "example run of the program:"
#~ msgstr ""
#~ "次のプログラムは B<insque>() の使用法を示したものである。\n"
#~ "下記はプログラムの実行例である。"

#~ msgid ""
#~ "$ B<./a.out -c a b c>\n"
#~ "Traversing completed list:\n"
#~ "    a\n"
#~ "    b\n"
#~ "    c\n"
#~ "That was a circular list\n"
#~ msgstr ""
#~ "$ B<./a.out -c a b c>\n"
#~ "Traversing completed list:\n"
#~ "    a\n"
#~ "    b\n"
#~ "    c\n"
#~ "That was a circular list\n"

#~ msgid "Program source"
#~ msgstr "プログラムのソース"

#~ msgid ""
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"
#~ "#include E<lt>search.hE<gt>\n"
#~ msgstr ""
#~ "#include E<lt>stdio.hE<gt>\n"
#~ "#include E<lt>stdlib.hE<gt>\n"
#~ "#include E<lt>unistd.hE<gt>\n"
#~ "#include E<lt>search.hE<gt>\n"

#~ msgid ""
#~ "struct element {\n"
#~ "    struct element *forward;\n"
#~ "    struct element *backward;\n"
#~ "    char *name;\n"
#~ "};\n"
#~ msgstr ""
#~ "struct element {\n"
#~ "    struct element *forward;\n"
#~ "    struct element *backward;\n"
#~ "    char *name;\n"
#~ "};\n"

#~ msgid ""
#~ "static struct element *\n"
#~ "new_element(void)\n"
#~ "{\n"
#~ "    struct element *e;\n"
#~ msgstr ""
#~ "static struct element *\n"
#~ "new_element(void)\n"
#~ "{\n"
#~ "    struct element *e;\n"

#~ msgid ""
#~ "    e = malloc(sizeof(struct element));\n"
#~ "    if (e == NULL) {\n"
#~ "        fprintf(stderr, \"malloc() failed\\en\");\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"
#~ msgstr ""
#~ "    e = malloc(sizeof(struct element));\n"
#~ "    if (e == NULL) {\n"
#~ "        fprintf(stderr, \"malloc() failed\\en\");\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"

#~ msgid ""
#~ "    return e;\n"
#~ "}\n"
#~ msgstr ""
#~ "    return e;\n"
#~ "}\n"

#~ msgid ""
#~ "int\n"
#~ "main(int argc, char *argv[])\n"
#~ "{\n"
#~ "    struct element *first, *elem, *prev;\n"
#~ "    int circular, opt, errfnd;\n"
#~ msgstr ""
#~ "int\n"
#~ "main(int argc, char *argv[])\n"
#~ "{\n"
#~ "    struct element *first, *elem, *prev;\n"
#~ "    int circular, opt, errfnd;\n"

#~ msgid ""
#~ "    /* The \"-c\" command-line option can be used to specify that the\n"
#~ "       list is circular */\n"
#~ msgstr ""
#~ "    /* The \"-c\" command-line option can be used to specify that the\n"
#~ "       list is circular */\n"

#~ msgid ""
#~ "    errfnd = 0;\n"
#~ "    circular = 0;\n"
#~ "    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
#~ "        switch (opt) {\n"
#~ "        case 'c':\n"
#~ "            circular = 1;\n"
#~ "            break;\n"
#~ "        default:\n"
#~ "            errfnd = 1;\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"
#~ msgstr ""
#~ "    errfnd = 0;\n"
#~ "    circular = 0;\n"
#~ "    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
#~ "        switch (opt) {\n"
#~ "        case 'c':\n"
#~ "            circular = 1;\n"
#~ "            break;\n"
#~ "        default:\n"
#~ "            errfnd = 1;\n"
#~ "            break;\n"
#~ "        }\n"
#~ "    }\n"

#~ msgid ""
#~ "    if (errfnd || optind E<gt>= argc) {\n"
#~ "        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"
#~ msgstr ""
#~ "    if (errfnd || optind E<gt>= argc) {\n"
#~ "        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
#~ "        exit(EXIT_FAILURE);\n"
#~ "    }\n"

#~ msgid "    /* Create first element and place it in the linked list */\n"
#~ msgstr "    /* Create first element and place it in the linked list */\n"

#~ msgid ""
#~ "    elem = new_element();\n"
#~ "    first = elem;\n"
#~ msgstr ""
#~ "    elem = new_element();\n"
#~ "    first = elem;\n"

#~ msgid "    elem-E<gt>name = argv[optind];\n"
#~ msgstr "    elem-E<gt>name = argv[optind];\n"

#~ msgid ""
#~ "    if (circular) {\n"
#~ "        elem-E<gt>forward = elem;\n"
#~ "        elem-E<gt>backward = elem;\n"
#~ "        insque(elem, elem);\n"
#~ "    } else {\n"
#~ "        insque(elem, NULL);\n"
#~ "    }\n"
#~ msgstr ""
#~ "    if (circular) {\n"
#~ "        elem-E<gt>forward = elem;\n"
#~ "        elem-E<gt>backward = elem;\n"
#~ "        insque(elem, elem);\n"
#~ "    } else {\n"
#~ "        insque(elem, NULL);\n"
#~ "    }\n"

#~ msgid "    /* Add remaining command-line arguments as list elements */\n"
#~ msgstr "    /* Add remaining command-line arguments as list elements */\n"

#~ msgid ""
#~ "    while (++optind E<lt> argc) {\n"
#~ "        prev = elem;\n"
#~ msgstr ""
#~ "    while (++optind E<lt> argc) {\n"
#~ "        prev = elem;\n"

#~ msgid ""
#~ "        elem = new_element();\n"
#~ "        elem-E<gt>name = argv[optind];\n"
#~ "        insque(elem, prev);\n"
#~ "    }\n"
#~ msgstr ""
#~ "        elem = new_element();\n"
#~ "        elem-E<gt>name = argv[optind];\n"
#~ "        insque(elem, prev);\n"
#~ "    }\n"

#~ msgid "    /* Traverse the list from the start, printing element names */\n"
#~ msgstr "    /* Traverse the list from the start, printing element names */\n"

#~ msgid ""
#~ "    printf(\"Traversing completed list:\\en\");\n"
#~ "    elem = first;\n"
#~ "    do {\n"
#~ "        printf(\"    %s\\en\", elem-E<gt>name);\n"
#~ "        elem = elem-E<gt>forward;\n"
#~ "    } while (elem != NULL && elem != first);\n"
#~ msgstr ""
#~ "    printf(\"Traversing completed list:\\en\");\n"
#~ "    elem = first;\n"
#~ "    do {\n"
#~ "        printf(\"    %s\\en\", elem-E<gt>name);\n"
#~ "        elem = elem-E<gt>forward;\n"
#~ "    } while (elem != NULL && elem != first);\n"

#~ msgid ""
#~ "    if (elem == first)\n"
#~ "        printf(\"That was a circular list\\en\");\n"
#~ msgstr ""
#~ "    if (elem == first)\n"
#~ "        printf(\"That was a circular list\\en\");\n"

#~ msgid ""
#~ "    exit(EXIT_SUCCESS);\n"
#~ "}\n"
#~ msgstr ""
#~ "    exit(EXIT_SUCCESS);\n"
#~ "}\n"

#~ msgid "1999-09-27"
#~ msgstr "1999-09-27"

#~ msgid "2012-03-08"
#~ msgstr "2012-03-08"

#~ msgid "The B<qsort>()  function conforms to SVr4, 4.3BSD, C89, C99."
#~ msgstr "B<qsort>() 関数は SVr4, 4.3BSD, C89, C99 に準拠している。"

#~ msgid ""
#~ "int\n"
#~ "main(int argc, char *argv[])\n"
#~ "{\n"
#~ "    int j;\n"
#~ msgstr ""
#~ "int\n"
#~ "main(int argc, char *argv[])\n"
#~ "{\n"
#~ "    int j;\n"

#~ msgid "2014-05-28"
#~ msgstr "2014-05-28"
