# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: 2021-07-14 00:21+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr "EPOLL"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25
#: build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:30
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25
#: build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/epoll.7:22 build/C/man2/epoll_create.2:26
#: build/C/man2/epoll_ctl.2:22 build/C/man2/epoll_wait.2:24
#: build/C/man2/poll.2:31
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr "epoll - I/O イベント通知機能"

#. type: SH
#: build/C/man7/epoll.7:24 build/C/man2/epoll_create.2:28
#: build/C/man2/epoll_ctl.2:24 build/C/man2/epoll_wait.2:26
#: build/C/man2/poll.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man7/epoll.7:26 build/C/man2/epoll_ctl.2:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>"

#. type: SH
#: build/C/man7/epoll.7:26 build/C/man2/epoll_create.2:35
#: build/C/man2/epoll_ctl.2:29 build/C/man2/epoll_wait.2:36
#: build/C/man2/poll.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/epoll.7:36
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API "
"can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors."
msgstr "B<epoll> API は B<poll>(2) と同様の処理を行う、つまり、複数のファイルディスクリプタを監視し、その中のいずれかが入出力可能な状態であるかを確認する。 B<epoll> API は、エッジトリガーインターフェースとレベルトリガーインターフェースのいずれとしても使用することができ、監視するファイルディスクリプターの数が多い場合にも使用できる。"

#. type: Plain text
#: build/C/man7/epoll.7:44
msgid ""
"The central concept of the B<epoll> API is the B<epoll> I<instance>, an in-"
"kernel data structure which, from a user-space perspective, can be "
"considered as a container for two lists:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:44 build/C/man7/epoll.7:51 build/C/man7/epoll.7:65
#: build/C/man7/epoll.7:74 build/C/man7/epoll.7:80 build/C/man2/epoll_wait.2:68
#: build/C/man2/epoll_wait.2:70 build/C/man2/epoll_wait.2:72
#: build/C/man2/poll.2:137 build/C/man2/poll.2:139 build/C/man2/poll.2:141
#: build/C/man2/poll.2:171 build/C/man2/poll.2:174 build/C/man2/poll.2:178
#: build/C/man2/poll.2:489 build/C/man2/poll.2:493 build/C/man2/poll.2:496
#: build/C/man2/poll.2:545 build/C/man2/poll.2:554 build/C/man2/poll.2:562
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man7/epoll.7:51
msgid ""
"The I<interest> list (sometimes also called the B<epoll> set): the set of "
"file descriptors that the process has registered an interest in monitoring."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:60
msgid ""
"The I<ready> list: the set of file descriptors that are \"ready\" for I/O.  "
"The ready list is a subset of (or, more precisely, a set of references to)  "
"the file descriptors in the interest list.  The ready list is dynamically "
"populated by the kernel as a result of I/O activity on those file "
"descriptors."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:65
msgid ""
"The following system calls are provided to create and manage an B<epoll> "
"instance:"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:74
msgid ""
"B<epoll_create>(2)  creates a new B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent "
"B<epoll_create1>(2)  extends the functionality of B<epoll_create>(2).)"
msgstr ""
"B<epoll_create>(2) は新規の B<epoll> インスタンスを作成し、そのインスタンスを参照する\n"
"ファイルディスクリプターを返す。(もっと新しい B<epoll_create1>(2) では、\n"
"B<epoll_create>(2) の機能が拡張されている)。"

#. type: Plain text
#: build/C/man7/epoll.7:80
#, fuzzy
#| msgid ""
#| "Interest in particular file descriptors is then registered via "
#| "B<epoll_ctl>(2).  The set of file descriptors currently registered on an "
#| "B<epoll> instance is sometimes called an I<epoll> set."
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2), which adds items to the interest list of the B<epoll> "
"instance."
msgstr ""
"特定のファイルディスクリプターに対する監視内容を B<epoll_ctl>(2)  で登録す"
"る。 B<epoll> インスタンスに現在登録されているファイルディスクリプターの集合"
"は I<epoll> 集合と呼ばれることもある。"

#. type: Plain text
#: build/C/man7/epoll.7:89
#, fuzzy
#| msgid ""
#| "B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
#| "events are currently available."
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available.  (This system call can be thought of as "
"fetching items from the ready list of the B<epoll> instance.)"
msgstr ""
"B<epoll_wait>(2) は I/O イベントを待つ。\n"
"現在利用可能な状態のイベントがなければ、呼び出したスレッドを停止する。"

#. type: SS
#: build/C/man7/epoll.7:89
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr "レベルトリガーとエッジトリガー"

#. type: Plain text
#: build/C/man7/epoll.7:98
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""
"B<epoll> イベント配送 (distribution) インターフェースは、 エッジトリガー "
"(ET) としてもレベルトリガー (LT) としても動作させることができる。 二つの配送"
"機構の違いは、次のように説明できる。 このようなシナリオが起こったとしよう:"

#. type: IP
#: build/C/man7/epoll.7:98 build/C/man7/epoll.7:378
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/epoll.7:104
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""
"パイプの読み込み側を表すファイルディスクリプター (I<rfd>)  が B<epoll> インス"
"タンスに登録される。"

#. type: IP
#: build/C/man7/epoll.7:104 build/C/man7/epoll.7:412
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/epoll.7:106
msgid "A pipe writer writes 2\\ kB of data on the write side of the pipe."
msgstr "パイプへ書き込むプログラムが 2\\ kB のデータをパイプの書き込み側へ書き込む。"

#. type: IP
#: build/C/man7/epoll.7:106 build/C/man7/epoll.7:422
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/epoll.7:112
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""
"B<epoll_wait>(2)  を呼び出すと、読み込み可能 (ready) なファイルディスクリプ"
"ターとして I<rfd> が返る。"

#. type: IP
#: build/C/man7/epoll.7:112 build/C/man7/epoll.7:432
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/epoll.7:115
msgid "The pipe reader reads 1\\ kB of data from I<rfd>."
msgstr "パイプから読み出すプログラムが、1\\ kB のデータを I<rfd> から読み出す。"

#. type: IP
#: build/C/man7/epoll.7:115 build/C/man7/epoll.7:446
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man7/epoll.7:119
msgid "A call to B<epoll_wait>(2)  is done."
msgstr "B<epoll_wait>(2)  の呼び出しが行われる。"

#. type: Plain text
#: build/C/man7/epoll.7:154
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that edge-"
"triggered mode delivers events only when changes occur on the monitored file "
"descriptor.  So, in step B<5> the caller might end up waiting for some data "
"that is already present inside the input buffer.  In the above example, an "
"event on I<rfd> will be generated because of the write done in B<2> and the "
"event is consumed in B<3>.  Since the read operation done in B<4> does not "
"consume the whole buffer data, the call to B<epoll_wait>(2)  done in step "
"B<5> might block indefinitely."
msgstr ""
"I<rfd> ファイルディスクリプターが B<EPOLLET> フラグ (エッジトリガー) を使っ"
"て B<epoll> に追加されていると、 利用可能なデータがファイル入力バッファーにま"
"だ存在するにもかかわらず ステップ B<5> の B<epoll_wait>(2)  の呼び出しでハン"
"グする可能性がある。 その一方で、リモートの接続先 (peer) は既に送られたデータ"
"に 基づいて応答を期待しているかもしれない。 このようなことが起こる理由は、"
"エッジトリガーイベント配送では、 モニタしているファイルでイベントが起ったとき"
"にのみイベントが 配送されるためである。 したがって、ステップ B<5> では、呼び"
"出し側は結果的に 入力バッファー内にすで存在するデータを待つことになるかもしれ"
"ない。 上記の例では、 B<2> で行われた書き込みによって I<rfd> に関するイベント"
"が生成され、 B<3> でイベントが消費 (consume) される。 B<4> で行われる読み込み"
"操作では、全部のバッファーデータを消費しないので、 ステップ B<5> で行われる "
"B<epoll_wait>(2)  の呼び出しが 無期限に停止 (block) するかもしれない。"

#. type: Plain text
#: build/C/man7/epoll.7:164
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""
"B<EPOLLET> フラグを採用するアプリケーションでは、 インターフェースはブロック"
"しない (nonblocking) ファイルディスクリプターを 使うべきである。 これは、ブ"
"ロックされる読み込みや書き込みによって、 複数のファイルディスクリプターを扱う"
"タスクが 停止してしまうのを避けるためである。 B<epoll> をエッジトリガー "
"(B<EPOLLET>)  インターフェースとして使うために提案される方法は以下の通りであ"
"る。"

#. type: IP
#: build/C/man7/epoll.7:164
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man7/epoll.7:166
msgid "with nonblocking file descriptors; and"
msgstr "ブロックしないファイルディスクリプターと共に使う。"

#. type: IP
#: build/C/man7/epoll.7:166
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man7/epoll.7:173
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""
"B<read>(2)  または B<write>(2)  が B<EAGAIN> を返した後でのみ、イベントを待"
"つ。"

#. type: Plain text
#: build/C/man7/epoll.7:183
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""
"一方、レベルトリガーインターフェースとして使う場合\n"
" (こちらがデフォルトである、\n"
"B<EPOLLET> が指定されなかった場合)、\n"
"B<epoll> は単に高速な B<poll>(2) であり、使い方が同じなので、\n"
"B<poll>(2) が使われているところではどこでも使用することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:200
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガーを使った場合でも、複数のデータを受信すると複数の B<epoll> イベ"
"ントが生成されるので、 呼び出し側には B<EPOLLONESHOT> フラグを指定するオプ"
"ションがある。 このフラグは B<epoll> に対して、 B<epoll_wait>(2)  によるイベ"
"ントを受信した後で、関連するファイルディスクリプターを無効にさせる。 "
"B<EPOLLONESHOT> フラグが指定された場合、 B<epoll_ctl>(2)  に "
"B<EPOLL_CTL_MOD> を指定してファイルディスクリプターを再度使用できるようにする"
"のは、 呼び出し側の責任である。"

#. type: Plain text
#: build/C/man7/epoll.7:217
msgid ""
"If multiple threads (or processes, if child processes have inherited the "
"B<epoll> file descriptor across B<fork>(2))  are blocked in "
"B<epoll_wait>(2)  waiting on the same epoll file descriptor and a file "
"descriptor in the interest list that is marked for edge-triggered "
"(B<EPOLLET>)  notification becomes ready, just one of the threads (or "
"processes) is awoken from B<epoll_wait>(2).  This provides a useful "
"optimization for avoiding \"thundering herd\" wake-ups in some scenarios."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:217
#, no-wrap
msgid "Interaction with autosleep"
msgstr "autosleep との関係"

#. type: Plain text
#: build/C/man7/epoll.7:229
msgid ""
"If the system is in B<autosleep> mode via I</sys/power/autosleep> and an "
"event happens which wakes the device from sleep, the device driver will keep "
"the device awake only until that event is queued.  To keep the device awake "
"until the event has been processed, it is necessary to use the "
"B<epoll_ctl>(2)  B<EPOLLWAKEUP> flag."
msgstr "システムが I</sys/power/autosleep> 経由で B<autosleep> モードになっていて、 デバイスをスリープ状態から起こすイベントが発生した場合、 デバイスドライバーはデバイスを起こしておくのはそのイベントがキューに入るまでだけである。 イベントが処理されるまでデバイスを起こしたままにしておくには、 B<epoll_ctl>(2) B<EPOLLWAKEUP> フラグを使う必要がある。"

#. type: Plain text
#: build/C/man7/epoll.7:248
msgid ""
"When the B<EPOLLWAKEUP> flag is set in the B<events> field for a I<struct "
"epoll_event>, the system will be kept awake from the moment the event is "
"queued, through the B<epoll_wait>(2)  call which returns the event until the "
"subsequent B<epoll_wait>(2)  call.  If the event should keep the system "
"awake beyond that time, then a separate I<wake_lock> should be taken before "
"the second B<epoll_wait>(2)  call."
msgstr ""
"B<EPOLLWAKEUP> フラグが I<struct epoll_event> の B<events> フィールドでセット"
"された場合、 イベントがキューに入った瞬間から、B<epoll_wait>(2) がそのイベン"
"トを返し次の B<epoll_wait>(2) の呼び出しが行われるまでの間、システムは起きた"
"ままの状態になる。 イベントが上記の時間の範囲を超えてシステムを起きたままの状"
"態にしておく必要がある場合は、 2 番目の B<epoll_wait>(2) の呼び出しの前に別"
"の I<wake_lock> を取る必要がある。"

#. type: SS
#: build/C/man7/epoll.7:248
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: build/C/man7/epoll.7:256
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""
"epoll が消費するカーネルメモリーの量を制限するために、 以下のインターフェース"
"を使用することができる。"

#. type: TP
#: build/C/man7/epoll.7:256
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll/max_user_watches> (Linux 2.6.28 以降)"

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: build/C/man7/epoll.7:270
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""
"このファイルは、あるユーザーがシステム上の全ての epoll インスタンスに 登録で"
"きるファイルディスクリプターの総数の上限を規定する。 この上限は実ユーザー ID "
"単位である。 登録されたファイルディスクリプター 1 つが消費するメモリー量は、 "
"32 ビットカーネルでおよそ 90 バイト、 64 ビットカーネルでおよそ 160 バイトで"
"ある。 現在のところ、 I<max_user_watches> のデフォルト値は、利用可能なメモ"
"リー下限の 1/25 (4%) であり、 登録で消費されるメモリー量 (バイト単位) で割っ"
"た値となる。"

#. type: SS
#: build/C/man7/epoll.7:270
#, no-wrap
msgid "Example for suggested usage"
msgstr "おすすめな使用例"

#. type: Plain text
#: build/C/man7/epoll.7:299
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An event-"
"driven state machine application should, after having received B<EAGAIN>, "
"record its current state so that at the next call to I<do_use_fd()> it will "
"continue to B<read>(2)  or B<write>(2)  from where it stopped before."
msgstr ""
"レベルトリガーインターフェースとして使用するときの B<epoll> の使い方は "
"B<poll>(2)  と同じである。 しかしエッジトリガーとして使う場合は、 アプリケー"
"ションのイベントループでストール (stall) しないように、 使い方をより明確にし"
"ておく必要がある。 この例では、リスナはブロックしないソケットであり、 "
"B<listen>(2)  が呼ばれている。 関数 I<do_use_fd()> は、 B<read>(2)  または "
"B<write>(2)  によって B<EAGAIN> が返されるまでは、新しい準備済みのファイル"
"ディスクリプターを使う。 イベント駆動ステートマシンアプリケーションは、 "
"B<EAGAIN> を受信した後、カレントの状態を記録しておくべきである。 これにより、"
"次の I<do_use_fd()> 呼び出しのときに、以前に停止したところから B<read>(2)  ま"
"たは B<write>(2)  を継続することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:305
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"

#. type: Plain text
#: build/C/man7/epoll.7:308
#, no-wrap
msgid ""
"/* Code to set up listening socket, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) omitted */\n"
msgstr ""
"/* Code to set up listening socket, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) omitted */\n"

#. type: Plain text
#: build/C/man7/epoll.7:314
#, no-wrap
msgid ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:321
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:328
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/epoll.7:350
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:369
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガーインターフェースとして使う場合、性能上の理由により、 一度 "
"(B<EPOLLIN>|B<EPOLLOUT>)  を指定してから (B<EPOLL_CTL_ADD> で) ファイルディス"
"クリプターを B<epoll> インターフェースに追加することができる。 これにより、 "
"B<epoll_ctl>(2)  に B<EPOLL_CTL_MOD> を指定して呼び出すことで B<EPOLLIN> と "
"B<EPOLLOUT> の連続的な切り替えが避けられる。"

#. type: SS
#: build/C/man7/epoll.7:369
#, no-wrap
msgid "Questions and answers"
msgstr "質問と解答"

#. type: IP
#: build/C/man7/epoll.7:370
#, no-wrap
msgid "0."
msgstr "0."

#. type: Plain text
#: build/C/man7/epoll.7:373
#, fuzzy
#| msgid ""
#| "What is the key used to distinguish the file descriptors registered in an "
#| "B<epoll> set?"
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"interest list?"
msgstr ""
"B<epoll> 集合内の登録されたファイルディスクリプターを区別するには、 何をキー"
"として使えばよいか？"

#. type: Plain text
#: build/C/man7/epoll.7:378
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""
"キーはファイルディスクリプター番号とオープンファイル記述 (open file "
"description) の組である (オープンファイル記述は \"open file handle\" とも 呼"
"ばれ、オープンされたファイルのカーネルの内部表現である)。"

#. type: Plain text
#: build/C/man7/epoll.7:382
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""
"1 つの B<epoll> インスタンスに同じファイルディスクリプターを 2 回登録するとど"
"うなるか？"

#.  But a file descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, file descriptors duplicated by fork have
#.  similar semantics to file descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  file descriptor means that even if the parent closes its file descriptor,
#.  then epoll_wait() in the parent will continue to receive notifications for
#.  that file descriptor because of the duplicated file descriptor in the child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: build/C/man7/epoll.7:412
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  file descriptor to the "
"same B<epoll> instance.  This can be a useful technique for filtering "
"events, if the duplicate file descriptors are registered with different "
"I<events> masks."
msgstr "たぶん B<EEXIST> を受け取るだろう。 しかしながら、同じ B<epoll> インスタンスに対して複製されたファイルディスクリプターを追加することは可能である (B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD> など)。 複製したファイルディスクリプターを異なる I<events> マスクで登録すれば、イベントをフィルタリングするのに この機能は有用な手法である。"

#. type: Plain text
#: build/C/man7/epoll.7:419
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""
"2 つの B<epoll> インスタンスが同じファイルディスクリプターを待ち受けることは"
"可能か？ もし可能であれば、イベントは両方の B<epoll> ファイルディスクリプター"
"に報告されるか？"

#. type: Plain text
#: build/C/man7/epoll.7:422
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""
"イベントは両方に報告される。 しかしながら、これを正しく扱うには注意深くプログ"
"ラミングする必要が あるかもしれない。"

#. type: Plain text
#: build/C/man7/epoll.7:426
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr "B<epoll> ファイルディスクリプター自身は poll/epoll/select が可能か？"

#. type: Plain text
#: build/C/man7/epoll.7:432
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting, then it will "
"indicate as being readable."
msgstr ""
"可能である。 B<epoll> ファイルディスクリプターに処理待ちのイベントがある場合"
"は、 読み出し可能だと通知されることだろう。"

#. type: Plain text
#: build/C/man7/epoll.7:436
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""
"B<epoll> ファイルディスクリプターを自身のファイルディスクリプター集合に 入れ"
"ようとするとどうなるか？"

#. type: Plain text
#: build/C/man7/epoll.7:446
msgid ""
"The B<epoll_ctl>(2)  call fails (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr "B<epoll_ctl>(2)  の呼び出しは (B<EINVAL> で) 失敗する。 ただし B<epoll> ファイルディスクリプターを他の B<epoll> ファイルディスクリプター集合の内部に追加することは可能である。"

#. type: Plain text
#: build/C/man7/epoll.7:450
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""
"B<epoll> ファイルディスクリプターを UNIX ドメインソケットで他のプロセスに送る"
"ことは可能か？"

#. type: Plain text
#: build/C/man7/epoll.7:453
#, fuzzy
#| msgid ""
#| "Yes, but it does not make sense to do this, since the receiving process "
#| "would not have copies of the file descriptors in the B<epoll> set."
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the interest list."
msgstr ""
"可能だが、これをすることに意味はない。 なぜなら、受信側のプロセスが B<epoll> "
"集合内のファイルディスクリプターのコピーを持っていないからである。"

#. type: IP
#: build/C/man7/epoll.7:453
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: build/C/man7/epoll.7:457
#, fuzzy
#| msgid ""
#| "Will closing a file descriptor cause it to be removed from all B<epoll> "
#| "sets automatically?"
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> "
"interest lists?"
msgstr ""
"ファイルディスクリプターをクローズすると、そのファイルディスクリプターは全て"
"の B<epoll> 集合から自動的に削除されるか？"

#. type: Plain text
#: build/C/man7/epoll.7:472
#, fuzzy
#| msgid ""
#| "Yes, but be aware of the following point.  A file descriptor is a "
#| "reference to an open file description (see B<open>(2)).  Whenever a "
#| "descriptor is duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  "
#| "B<F_DUPFD>, or B<fork>(2), a new file descriptor referring to the same "
#| "open file description is created.  An open file description continues to "
#| "exist until all file descriptors referring to it have been closed.  A "
#| "file descriptor is removed from an B<epoll> set only after all the file "
#| "descriptors referring to the underlying open file description have been "
#| "closed (or before if the descriptor is explicitly removed using "
#| "B<epoll_ctl>(2)  B<EPOLL_CTL_DEL>).  This means that even after a file "
#| "descriptor that is part of an B<epoll> set has been closed, events may be "
#| "reported for that file descriptor if other file descriptors referring to "
#| "the same underlying file description remain open."
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a file descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed."
msgstr ""
"削除されるが、以下の点に注意が必要である。 ファイルディスクリプターはオープン"
"ファイル記述 (B<open>(2)  参照) への参照である。 ディスクリプターの複製を "
"B<dup>(2), B<dup2>(2), B<fcntl>(2)  の B<F_DUPFD> や B<fork>(2)  経由で行う度"
"に、同じオープンファイル記述を参照する新規のファイル ディスクリプターが生成さ"
"れる。 オープンファイル記述自体は、自身を参照する全てのファイルディスクリプ"
"ター がクローズされるまで存在し続ける。 ファイルディスクリプターが B<epoll> "
"集合から削除されるのは、対応するオープンファイル記述を参照している 全てのファ"
"イルディスクリプターがクローズされた後である (B<epoll_ctl>(2)  "
"B<EPOLL_CTL_DEL> を使ってそのディスクリプターを明示的に削除した場合にも削除さ"
"れる)。 このことは、 B<epoll> 集合に属しているあるファイルディスクリプターを"
"クローズした後であっても、 同じファイル記述を参照する他のファイルディスクリプ"
"ターがオープンされている間は、 クローズしたファイルディスクリプター宛にイベン"
"トが報告される可能性があると いうことを意味する。"

#. type: Plain text
#: build/C/man7/epoll.7:492
msgid ""
"A file descriptor is removed from an interest list only after all the file "
"descriptors referring to the underlying open file description have been "
"closed.  This means that even after a file descriptor that is part of an "
"interest list has been closed, events may be reported for that file "
"descriptor if other file descriptors referring to the same underlying file "
"description remain open.  To prevent this happening, the file descriptor "
"must be explicitly removed from the interest list (using B<epoll_ctl>(2)  "
"B<EPOLL_CTL_DEL>)  before it is duplicated.  Alternatively, the application "
"must ensure that all file descriptors are closed (which may be difficult if "
"file descriptors were duplicated behind the scenes by library functions that "
"used B<dup>(2)  or B<fork>(2))."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:492
#, no-wrap
msgid "7."
msgstr "7."

#. type: Plain text
#: build/C/man7/epoll.7:496
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""
"2 つ以上のイベントが B<epoll_wait>(2)  コールの間に発生した場合、それらはまと"
"めて報告されるか、 それとも別々に報告されるか？"

#. type: Plain text
#: build/C/man7/epoll.7:498
msgid "They will be combined."
msgstr "まとめて報告されるだろう。"

#. type: IP
#: build/C/man7/epoll.7:498
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: build/C/man7/epoll.7:501
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""
"ファイルディスクリプターに対する操作は、 既に集められているがまだ報告されてい"
"ないイベントに影響するか？"

#. type: Plain text
#: build/C/man7/epoll.7:506
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""
"既存のファイルディスクリプターに対して 2 つの操作を行うことができる。 この場"
"合、削除には意味がない。 変更すると、使用可能な I/O が再び読み込まれる。"

#. type: IP
#: build/C/man7/epoll.7:506
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: build/C/man7/epoll.7:513
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior)?"
msgstr ""
"B<EPOLLET> フラグ (エッジトリガー動作) を使っている場合、 B<EAGAIN> を受け取"
"るまで、 継続してファイルディスクリプターを読み書きする必要があるか？"

#. type: Plain text
#: build/C/man7/epoll.7:522
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""
"B<epoll_wait>(2)  からイベントを受け取ることは、 そのファイルディスクリプター"
"が要求された I/O 操作に対して準備済みである、 ということをユーザーに示すもの"
"である。 次の (ブロックしない) read/write で B<EAGAIN> を受け取るまではファイ"
"ルディスクリプターは準備済みであると 考えなければならない。 そのファイルディ"
"スクリプターをいつどのように使うかは、 全くユーザーに任されてる。"

#. type: Plain text
#: build/C/man7/epoll.7:528
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""
"パケット指向やトークン指向のファイル (例えば、データグラムソケット、 "
"canonical モードの端末) では、 読み込み用 / 書き込み用の I/O 空間の末尾を検知"
"する唯一の方法は B<EAGAIN> になるまで read/write を行うことである。"

#. type: Plain text
#: build/C/man7/epoll.7:544
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""
"ストリーム指向のファイル (例えば、パイプ、FIFO、ストリームソケット) では、 読"
"み込み用 / 書き込み用の I/O 空間が使い尽くされた状態は、 対象となるファイル"
"ディスクリプターから読み込んだデータ量または 書き込んだデータ量をチェックする"
"ことでも検知できる。 例えば、ある特定の量のデータを読み込むために "
"B<read>(2)  を呼んだときに、 B<read>(2)  が返したバイト数がそれより少なかった"
"場合、 そのファイルディスクリプターの読み込み用 I/O 空間が 使い尽くされたこと"
"が分かる。 B<write>(2)  を使って書き込みをするときも、同じことが言える (監視"
"しているファイルディスクリプターが常にストリーム指向のファイルを 参照している"
"ことを保証できない場合には、後者の手法の使用を避けること)。"

#. type: SS
#: build/C/man7/epoll.7:544
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr "ありがちな落とし穴と回避方法"

#. type: TP
#: build/C/man7/epoll.7:545
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr "B<o 飢餓 (starvation) (エッジトリガー)>"

#. type: Plain text
#: build/C/man7/epoll.7:553
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""
"大きな I/O 空間がある場合、 その I/O 空間のデータを全て処理 (drain) しようと"
"すると、 他のファイルが処理されず、飢餓を発生させることがある (この問題は "
"B<epoll> に固有のものではない)。"

#. type: Plain text
#: build/C/man7/epoll.7:561
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""
"この問題の解決法は、準備済み状態のリストを管理して、 関連する data 構造体の中"
"でファイルディスクリプターが 利用可能であるとマークすることである。 それに"
"よって、利用可能なすべてのファイルの中で どのファイルを処理する必要があるかを"
"憶えることができ、 しかも順番に処理 (round robin) することができる。 既に利用"
"可能であるファイルディスクリプターに対して それ以後に受け取るイベントを無視す"
"ることもできる。"

#. type: TP
#: build/C/man7/epoll.7:561
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr "B<o イベントキャッシュを使っている場合>"

#. type: Plain text
#: build/C/man7/epoll.7:577
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""
"イベントキャッシュを使っている場合、 または B<epoll_wait>(2)  から返された全"
"てのファイルディスクリプターを格納している場合、 クローズされたことを動的に"
"マークする (つまり前のイベントの処理によってマークされる) 方法を提供すべきで"
"ある。 B<epoll_wait>(2)  から 100 個のイベントを受け取り、 イベント #47 では"
"ある条件でイベント #13 が閉じられると仮定する。 イベント #13 の構造体を削除し"
"ファイルディスクリプターを B<close>(2)  すると、イベントキャッシュはそのファ"
"イルディスクリプターを待つイベントが 存在するといって、混乱が起きる。"

#. type: Plain text
#: build/C/man7/epoll.7:588
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""
"この問題を解決する 1 つの方法は、イベント 47 の処理をしている間に、 ファイル"
"ディスクリプター 13 を削除して B<close>(2)  するために "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  を呼び出し、関連付けられた data 構造体を削除"
"済みとマークして、 クリーンアップリストにリンクすることである。 バッチ処理の"
"中でファイルディスクリプター 13 についての 他のイベントを見つけた場合、 その"
"ファイルディスクリプターが以前に削除されたものであると分かるので、 混乱は起き"
"ない。"

#. type: SH
#: build/C/man7/epoll.7:588 build/C/man2/epoll_create.2:112
#: build/C/man2/epoll_ctl.2:421 build/C/man2/epoll_wait.2:210
#: build/C/man2/poll.2:385
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man7/epoll.7:594
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#. type: SH
#: build/C/man7/epoll.7:594 build/C/man2/epoll_create.2:122
#: build/C/man2/epoll_ctl.2:427 build/C/man2/epoll_wait.2:220
#: build/C/man2/poll.2:401
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/epoll.7:603
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has I</dev/poll>."
msgstr ""
"B<epoll> API は Linux 固有である。 他のシステムでも同様の機構が提供されている"
"場合がある。 例えば、FreeBSD の I<kqueue> や Solaris の I</dev/poll> などであ"
"る。"

#. type: SH
#: build/C/man7/epoll.7:603 build/C/man2/epoll_create.2:125
#: build/C/man2/epoll_ctl.2:430 build/C/man2/epoll_wait.2:223
#: build/C/man2/poll.2:410
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man7/epoll.7:612
msgid ""
"The set of file descriptors that is being monitored via an epoll file "
"descriptor can be viewed via the entry for the epoll file descriptor in the "
"process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:618
msgid ""
"The B<kcmp>(2)  B<KCMP_EPOLL_TFD> operation can be used to test whether a "
"file descriptor is present in an epoll instance."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:618 build/C/man2/epoll_create.2:148
#: build/C/man2/epoll_ctl.2:476 build/C/man2/epoll_wait.2:280
#: build/C/man2/poll.2:659
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/epoll.7:625
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), "
"B<poll>(2), B<select>(2)"
msgstr "B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<poll>(2), B<select>(2)"

#. type: SH
#: build/C/man7/epoll.7:625 build/C/man2/epoll_create.2:153
#: build/C/man2/epoll_ctl.2:481 build/C/man2/epoll_wait.2:284
#: build/C/man2/poll.2:665
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/epoll.7:633 build/C/man2/epoll_create.2:161
#: build/C/man2/epoll_ctl.2:489 build/C/man2/epoll_wait.2:292
#: build/C/man2/poll.2:673
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/epoll_create.2:25
#, no-wrap
msgid "EPOLL_CREATE"
msgstr "EPOLL_CREATE"

#. type: TH
#: build/C/man2/epoll_create.2:25 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:30
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man2/epoll_create.2:28
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""
"epoll_create, epoll_create1 - epoll ファイルディスクリプターをオープンする"

#. type: Plain text
#: build/C/man2/epoll_create.2:31 build/C/man2/epoll_wait.2:29
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:34
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:43
msgid ""
"B<epoll_create>()  creates a new B<epoll>(7)  instance.  Since Linux 2.6.8, "
"the I<size> argument is ignored, but must be greater than zero; see NOTES."
msgstr ""
"B<epoll_create>() は新規の B<epoll>(7) インスタンスを作成する。\n"
"Linux 2.6.8 以降では、I<size> 引数は無視されるが、 0 より大きな値で\n"
"なければならない。「注意」を参照。"

#. type: Plain text
#: build/C/man2/epoll_create.2:56
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""
"B<epoll_create>()  は、新しい epoll インスタンスを参照するファイルディスクリ"
"プターを返す。 このファイルディスクリプターは、その後の B<epoll> インター"
"フェースの呼び出しに使われる。 もう必要でなくなった場合は、 "
"B<epoll_create>()  で返されたファイルディスクリプターは B<close>(2)  を使って"
"クローズされるべきである。 ある epoll インスタンスを参照する全てのファイル"
"ディスクリプターがクローズされると、 カーネルはそのインスタンスを破壊して、対"
"応するリソースを解放し、 再使用できるようにする。"

#. type: SS
#: build/C/man2/epoll_create.2:56
#, no-wrap
msgid "epoll_create1()"
msgstr "epoll_create1()"

#. type: Plain text
#: build/C/man2/epoll_create.2:68
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different behavior:"
msgstr ""
"B<epoll_create1>()  は、 I<flags> が 0 の場合、現在では使われていない "
"I<size> 引数がなくなっている点を除けば B<epoll_create>()  と同じである。 "
"I<flags> に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさ"
"せることができる。"

#. type: TP
#: build/C/man2/epoll_create.2:68
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr "B<EPOLL_CLOEXEC>"

#. type: Plain text
#: build/C/man2/epoll_create.2:78
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプターに対して close-on-exec (B<FD_CLOEXEC>)  フラグ"
"をセットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: SH
#: build/C/man2/epoll_create.2:78 build/C/man2/epoll_ctl.2:309
#: build/C/man2/epoll_wait.2:173 build/C/man2/poll.2:344
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/epoll_create.2:85
msgid ""
"On success, these system calls return a file descriptor (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr "成功すると、これらのシステムコールはファイルディスクリプター (非負の整数) を返す。 エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/epoll_create.2:85 build/C/man2/epoll_ctl.2:318
#: build/C/man2/epoll_wait.2:185 build/C/man2/poll.2:358
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/epoll_create.2:86 build/C/man2/epoll_create.2:90
#: build/C/man2/epoll_ctl.2:333 build/C/man2/epoll_ctl.2:346
#: build/C/man2/epoll_ctl.2:352 build/C/man2/epoll_ctl.2:361
#: build/C/man2/epoll_ctl.2:371 build/C/man2/epoll_wait.2:202
#: build/C/man2/poll.2:369 build/C/man2/poll.2:376
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/epoll_create.2:90
msgid "I<size> is not positive."
msgstr "I<size> が正でない。"

#. type: Plain text
#: build/C/man2/epoll_create.2:95
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr "(B<epoll_create1>())  I<flags> に無効な値が指定された。"

#. type: TP
#: build/C/man2/epoll_create.2:95 build/C/man2/epoll_create.2:103
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:103
msgid ""
"The per-user limit on the number of epoll instances imposed by I</proc/sys/"
"fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  for further "
"details."
msgstr ""
"I</proc/sys/fs/epoll/max_user_instances> によって指定されている、epoll インス"
"タンスのユーザー単位の制限に達した。 更なる詳細については B<epoll>(7)  を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/epoll_create.2:106
#, fuzzy
#| msgid "The system limit on the total number of open files has been reached."
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "オープンされたファイルの総数がシステム制限に達した。"

#. type: TP
#: build/C/man2/epoll_create.2:106
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:109
#, fuzzy
#| msgid "The system limit on the total number of open files has been reached."
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム制限に達した。"

#. type: TP
#: build/C/man2/epoll_create.2:109 build/C/man2/epoll_ctl.2:397
#: build/C/man2/poll.2:382
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/epoll_create.2:112
msgid "There was insufficient memory to create the kernel object."
msgstr "カーネルオブジェクトを作成するのに十分なメモリーがなかった。"

#. type: Plain text
#: build/C/man2/epoll_create.2:116
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll_create>() はカーネル 2.6 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_create.2:122
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""
"B<epoll_create1>() はカーネル 2.6.27 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.9 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_create.2:125
msgid "B<epoll_create>()  is Linux-specific."
msgstr "B<epoll_create>() は Linux 独自である。"

#. type: Plain text
#: build/C/man2/epoll_create.2:148
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""
"初期の B<epoll_create>() の実装では、I<size> 引数は、呼び出し元が "
"B<epoll>\n"
"インスタンスに追加しようとするファイルディスクリプター数をカーネルに教えるの"
"に\n"
"使われていた。カーネルはこの情報をイベントの情報を格納する内部データ構造に"
"最\n"
"初に割り当てる大きさを決める際のヒントとして使用していた (I<size> で渡され"
"た\n"
"ヒントよりも使用量が大きくなった場合には、必要に応じてカーネルは追加で領域"
"を\n"
"割り当てる)。\n"
"\n"
"現在では、このヒントはもはや必要なくなっている (カーネルはヒントなしで必要"
"な\n"
"データ構造のサイズを動的に変更する) が、今も I<size> には 0 より大きい値を\n"
"指定しなければならない。これは、B<epoll> を使うアプリケーションが古いカーネ"
"ル\n"
"で実行される際の後方互換性を保証するためである。"

#. type: Plain text
#: build/C/man2/epoll_create.2:153
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_ctl.2:21
#, no-wrap
msgid "EPOLL_CTL"
msgstr "EPOLL_CTL"

#. type: TH
#: build/C/man2/epoll_ctl.2:21
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:24
msgid "epoll_ctl - control interface for an epoll file descriptor"
msgstr "epoll_ctl - epoll ファイルディスクリプターのインターフェースを操作する"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:29
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:40
#, fuzzy
#| msgid ""
#| "This system call performs control operations on the B<epoll>(7)  instance "
#| "referred to by the file descriptor I<epfd>.  It requests that the "
#| "operation I<op> be performed for the target file descriptor, I<fd>."
msgid ""
"This system call is used to add, modify, or remove entries in the interest "
"list of the B<epoll>(7)  instance referred to by the file descriptor "
"I<epfd>.  It requests that the operation I<op> be performed for the target "
"file descriptor, I<fd>."
msgstr ""
"このシステムコールは、ファイルディスクリプター I<epfd> が参照する "
"B<epoll>(7)\n"
"インスタンスに対する操作を行う。 対象のファイルディスクリプター I<fd> に対し"
"て、\n"
"操作 I<op> の実行が要求される。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:44
msgid "Valid values for the I<op> argument are:"
msgstr "I<op> 引数に指定できる有効な値は以下の通りである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:44
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr "B<EPOLL_CTL_ADD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:56
msgid ""
"Add an entry to the interest list of the epoll file descriptor, I<epfd>.  "
"The entry includes the file descriptor, I<fd>, a reference to the "
"corresponding open file description (see B<epoll>(7)  and B<open>(2)), and "
"the settings specified in I<event>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:56
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr "B<EPOLL_CTL_MOD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:62
msgid ""
"Change the settings associated with I<fd> in the interest list to the new "
"settings specified in I<event>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:62
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr "B<EPOLL_CTL_DEL>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:70
#, fuzzy
#| msgid ""
#| "Remove (deregister) the target file descriptor I<fd> from the B<epoll> "
#| "instance referred to by I<epfd>.  The I<event> is ignored and can be NULL "
#| "(but see BUGS below)."
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the interest "
"list.  The I<event> argument is ignored and can be NULL (but see BUGS below)."
msgstr ""
"対象のファイルディスクリプター I<fd> を I<epfd> が参照する B<epoll> インスタ"
"ンスから削除する。 I<event> 引数は無視されるので、NULL にすることもできる "
"(但し、下記の「バグ」を参照)。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:78
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as:"
msgstr ""
"I<event> 引数は、ファイルディスクリプター I<fd> にリンクされたオブジェクト"
"を表す。 I<struct epoll_event> は以下のように定義される。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:87
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:92
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;      /* epoll イベント */\n"
"    epoll_data_t data;        /* ユーザーデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:102
msgid ""
"The I<data> member of the I<epoll_event> structure specifies data that the "
"kernel should save and then return (via B<epoll_wait>(2))  when this file "
"descriptor becomes ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:109
#, fuzzy
#| msgid ""
#| "The I<events> member is a bit set composed using the following available "
#| "event types:"
msgid ""
"The I<events> member of the I<epoll_event> structure is a bit mask composed "
"by ORing together zero or more of the following available event types:"
msgstr ""
"I<events> メンバは、以下のような使用可能なイベントタイプを使って構成された "
"ビットセットである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:109
#, no-wrap
msgid "B<EPOLLIN>"
msgstr "B<EPOLLIN>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:114
msgid "The associated file is available for B<read>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<read>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:114
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr "B<EPOLLOUT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:119
msgid "The associated file is available for B<write>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<write>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:119
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr "B<EPOLLRDHUP\">(LinuxB<2.6.17>以降)\""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:125
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using edge-triggered monitoring.)"
msgstr ""
"ストリームソケットの他端が、コネクションの close 、 またはコネクションの書き"
"込み側の shutdown を行った。 (このフラグを使うと、エッジトリガーの監視を行う"
"場合に、 通信のもう一端が閉じられたことを検知するコードを 非常に簡潔に書くこ"
"とができる。)"

#. type: TP
#: build/C/man2/epoll_ctl.2:125
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr "B<EPOLLPRI>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:132
msgid ""
"There is an exceptional condition on the file descriptor.  See the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:132
#, no-wrap
msgid "B<EPOLLERR>"
msgstr "B<EPOLLERR>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:137
#, fuzzy
#| msgid ""
#| "Error condition happened on the associated file descriptor.  "
#| "B<epoll_wait>(2)  will always wait for this event; it is not necessary to "
#| "set it in I<events>."
msgid ""
"Error condition happened on the associated file descriptor.  This event is "
"also reported for the write end of a pipe when the read end has been closed."
msgstr ""
"関連付けられたファイルディスクリプターにエラー条件が起こった。 "
"B<epoll_wait>(2)  は常にこのイベントを待つので、 I<events> に設定する必要はな"
"い。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:143
#, fuzzy
#| msgid ""
#| "Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  "
#| "will always wait for this event; it is not necessary to set it in "
#| "I<events>."
msgid ""
"B<epoll_wait>(2)  will always report for this event; it is not necessary to "
"set it in I<events> when calling B<epoll_ctl>()."
msgstr ""
"関連付けられたファイルディスクリプターにハングアップが起こった。 "
"B<epoll_wait>(2)  は常にこのイベントを待つので、 I<events> に設定する必要はな"
"い。"

#. type: TP
#: build/C/man2/epoll_ctl.2:143
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr "B<EPOLLHUP>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:146
#, fuzzy
#| msgid "There was no space to allocate file descriptor tables."
msgid "Hang up happened on the associated file descriptor."
msgstr "ファイルディスクリプターテーブルを確保するためのメモリーがない。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:152
#, fuzzy
#| msgid ""
#| "Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  "
#| "will always wait for this event; it is not necessary to set it in "
#| "I<events>."
msgid ""
"B<epoll_wait>(2)  will always wait for this event; it is not necessary to "
"set it in I<events> when calling B<epoll_ctl>()."
msgstr ""
"関連付けられたファイルディスクリプターにハングアップが起こった。 "
"B<epoll_wait>(2)  は常にこのイベントを待つので、 I<events> に設定する必要はな"
"い。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:157
msgid ""
"Note that when reading from a channel such as a pipe or a stream socket, "
"this event merely indicates that the peer closed its end of the channel.  "
"Subsequent reads from the channel will return 0 (end of file)  only after "
"all outstanding data in the channel has been consumed."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:157
#, no-wrap
msgid "B<EPOLLET>"
msgstr "B<EPOLLET>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:167
#, fuzzy
#| msgid ""
#| "Sets the Edge Triggered behavior for the associated file descriptor.  The "
#| "default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for "
#| "more detailed information about Edge and Level Triggered event "
#| "distribution architectures."
msgid ""
"Requests edge-triggered notification for the associated file descriptor.  "
"The default behavior for B<epoll> is level-triggered.  See B<epoll>(7)  for "
"more detailed information about edge-triggered and level-triggered "
"notification."
msgstr ""
"関連付けられたファイルディスクリプターに エッジトリガー動作 (Edge Triggered "
"behavior) を設定する。 B<epoll> のデフォルトの動作は、レベルトリガー (Level "
"Triggered) である。 エッジトリガーとレベルトリガーによるイベント分配機構 "
"(event distribution architectures) についての詳細な情報は、 B<epoll>(7)  を参"
"照すること。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:174 build/C/man2/epoll_ctl.2:195
#: build/C/man2/epoll_ctl.2:230
msgid ""
"This flag is an input flag for the I<event.events> field when calling "
"B<epoll_ctl>(); it is never returned by B<epoll_wait>(2)."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:174
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr "B<EPOLLONESHOT> (Linux 2.6.2 以降)"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:188
#, fuzzy
#| msgid ""
#| "Sets the one-shot behavior for the associated file descriptor.  This "
#| "means that after an event is pulled out with B<epoll_wait>(2)  the "
#| "associated file descriptor is internally disabled and no other events "
#| "will be reported by the B<epoll> interface.  The user must call "
#| "B<epoll_ctl>()  with B<EPOLL_CTL_MOD> to rearm the file descriptor with a "
#| "new event mask."
msgid ""
"Requests one-shot notification for the associated file descriptor.  This "
"means that after an event notified for the file descriptor by "
"B<epoll_wait>(2), the file descriptor is disabled in the interest list and "
"no other events will be reported by the B<epoll> interface.  The user must "
"call B<epoll_ctl>()  with B<EPOLL_CTL_MOD> to rearm the file descriptor with "
"a new event mask."
msgstr ""
"関連付けられたファイルディスクリプターに 一撃動作 (One-Shot behavior) を設定"
"する。 これはイベントが B<epoll_wait>(2)  によって引き出された後、 関連付けら"
"れたファイルディスクリプターが内部的に破棄され、 B<epoll> インターフェースに"
"よってイベントが報告されなくなることを意味する。 新しいイベントマスクでファイ"
"ルディスクリプターを再度有効にするためには、 B<epoll_ctl>()  に "
"B<EPOLL_CTL_MOD> を指定して呼び出さなければならない。 I<op> 引数に指定でき"
"る有効な値は、以下の通り:"

#. type: TP
#: build/C/man2/epoll_ctl.2:195
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr "B<EPOLLWAKEUP> (Linux 3.5 以降)"

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: build/C/man2/epoll_ctl.2:223
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being "
"processed.  The event is considered as being \"processed\" from the time "
"when it is returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""
"B<EPOLLONESHOT> と B<EPOLLET> がクリアされており、 プロセスが "
"B<CAP_BLOCK_SUSPEND> ケーパビリティを持っている場合、 イベントが処理待ちか処"
"理中かにかかわらず、必ずシステムが \"suspend\" や \"hibernate\" に入らないよ"
"うにすること。 B<epoll_wait>(2) の呼び出しが返った時点から、 同じ "
"B<epoll>(7) ファイルディスクリプターに対して B<epoll_wait>(2) が次に呼び出さ"
"れるか、 そのファイルディスクリプターが閉じられるか、 イベントファイルディス"
"クリプターが B<EPOLL_CTL_DEL> で削除されるか、 B<EPOLL_CTL_MOD> でイベント"
"ファイルディスクリプターの B<EPOLLWAKEUP> がクリアされるか、 のいずれかになる"
"まで、イベントは「処理中」であるとみなされる。 「バグ」の節も参照のこと。"

#. type: TP
#: build/C/man2/epoll_ctl.2:230
#, no-wrap
msgid "B<EPOLLEXCLUSIVE> (since Linux 4.5)"
msgstr "B<EPOLLEXCLUSIVE> (Linux 4.5 以降)"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:245
msgid ""
"Sets an exclusive wakeup mode for the epoll file descriptor that is being "
"attached to the target file descriptor, I<fd>.  When a wakeup event occurs "
"and multiple epoll file descriptors are attached to the same target file "
"using B<EPOLLEXCLUSIVE>, one or more of the epoll file descriptors will "
"receive an event with B<epoll_wait>(2).  The default in this scenario (when "
"B<EPOLLEXCLUSIVE> is not set) is for all epoll file descriptors to receive "
"an event.  B<EPOLLEXCLUSIVE> is thus useful for avoiding thundering herd "
"problems in certain scenarios."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:254
msgid ""
"If the same file descriptor is in multiple epoll instances, some with the "
"B<EPOLLEXCLUSIVE> flag, and others without, then events will be provided to "
"all epoll instances that did not specify B<EPOLLEXCLUSIVE>, and at least one "
"of the epoll instances that did specify B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:273
msgid ""
"The following values may be specified in conjunction with B<EPOLLEXCLUSIVE>: "
"B<EPOLLIN>, B<EPOLLOUT>, B<EPOLLWAKEUP>, and B<EPOLLET>.  B<EPOLLHUP> and "
"B<EPOLLERR> can also be specified, but this is not required: as usual, these "
"events are always reported if they occur, regardless of whether they are "
"specified in I<events>.  Attempts to specify other values in I<events> yield "
"the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:300
msgid ""
"B<EPOLLEXCLUSIVE> may be used only in an B<EPOLL_CTL_ADD> operation; "
"attempts to employ it with B<EPOLL_CTL_MOD> yield an error.  If "
"B<EPOLLEXCLUSIVE> has been set using B<epoll_ctl>(), then a subsequent "
"B<EPOLL_CTL_MOD> on the same I<epfd>,\\ I<fd> pair yields an error.  A call "
"to B<epoll_ctl>()  that specifies B<EPOLLEXCLUSIVE> in I<events> and "
"specifies the target file descriptor I<fd> as an epoll instance will "
"likewise fail.  The error in all of these cases is B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:309
msgid ""
"The B<EPOLLEXCLUSIVE> flag is an input flag for the I<event.events> field "
"when calling B<epoll_ctl>(); it is never returned by B<epoll_wait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:318
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_ctl>()  は 0 を返す。 エラーが起こった場合、 "
"B<epoll_ctl>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: TP
#: build/C/man2/epoll_ctl.2:319 build/C/man2/epoll_wait.2:186
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:325
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr "I<epfd> か I<fd> が有効なファイルディスクリプターでない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:325
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:333
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_ADD> であり、かつ与えられたファイルディスクリプター "
"I<fd> がこの epoll インスタンスに既に登録されている。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:346
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプターでない。 または I<fd> が I<epfd> "
"と同一である。 または要求された操作 I<op> がこのインターフェースでサポートさ"
"れていない。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:352
msgid ""
"An invalid event type was specified along with B<EPOLLEXCLUSIVE> in "
"I<events>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:361
msgid "I<op> was B<EPOLL_CTL_MOD> and I<events> included B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:371
msgid ""
"I<op> was B<EPOLL_CTL_MOD> and the B<EPOLLEXCLUSIVE> flag has previously "
"been applied to this I<epfd>,\\ I<fd> pair."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:379
msgid ""
"B<EPOLLEXCLUSIVE> was specified in I<event> and I<fd> refers to an epoll "
"instance."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:379
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:387
msgid ""
"I<fd> refers to an epoll instance and this B<EPOLL_CTL_ADD> operation would "
"result in a circular loop of epoll instances monitoring one another or a "
"nesting depth of epoll instances greater than 5."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:387
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:397
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_MOD> または B<EPOLL_CTL_DEL> で、かつ I<fd> がこの "
"epoll インスタンスに登録されていない。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:402
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr "要求された I<op> 制御操作を扱うのに十分なメモリーがない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:402
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:412
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""
"epoll インスタンスに新しいファイルディスクリプターを登録 (B<EPOLL_CTL_ADD>)  "
"しようとした際に、 I</proc/sys/fs/epoll/max_user_watches> で決まる上限に達し"
"た。 詳細は B<epoll>(7)  を参照。"

#. type: TP
#: build/C/man2/epoll_ctl.2:412
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:421
msgid ""
"The target file I<fd> does not support B<epoll>.  This error can occur if "
"I<fd> refers to, for example, a regular file or a directory."
msgstr ""
"対象ファイル I<fd> が B<epoll> に対応していない。 このエラーは I<fd> が例えば"
"通常ファイルやディレクトリを参照している場合にも起こり得る。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_ctl.2:427
msgid ""
"B<epoll_ctl>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll_ctl>() はカーネル 2.6 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:430
msgid "B<epoll_ctl>()  is Linux-specific."
msgstr "B<epoll_ctl>() は Linux 独自である。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:435
msgid ""
"The B<epoll> interface supports all file descriptors that support B<poll>(2)."
msgstr ""
"B<epoll> インターフェースは、 B<poll>(2)  に対応している全てのファイルディス"
"クリプターに対応している。"

#. type: SH
#: build/C/man2/epoll_ctl.2:435 build/C/man2/epoll_wait.2:255
#: build/C/man2/poll.2:476
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:449
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""
"Linux 2.6.9 より前では、 B<EPOLL_CTL_DEL> 操作の際、引数 I<event> に (たと"
"え無視される場合であっても) NULL でないポインターを渡す必要があった。 カーネ"
"ル 2.6.9 以降では、 B<EPOLL_CTL_DEL> を使う際に I<event> に NULL を指定できる"
"ようになっている。 2.6.9 より前のカーネルへの移植性が必要なアプリケーションで"
"は、 I<event> に NULL でないポインターを指定すべきである。"

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: build/C/man2/epoll_ctl.2:476
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the "
"B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently "
"ignored>.  This unfortunate behavior is necessary because no validity checks "
"were performed on the I<flags> argument in the original implementation, and "
"the addition of the B<EPOLLWAKEUP> with a check that caused the call to fail "
"if the caller did not have the B<CAP_BLOCK_SUSPEND> capability caused a "
"breakage in at least one existing user-space application that happened to "
"randomly (and uselessly) specify this bit.  A robust application should "
"therefore double check that it has the B<CAP_BLOCK_SUSPEND> capability if "
"attempting to use the B<EPOLLWAKEUP> flag."
msgstr ""
"I<flags> に B<EPOLLWAKEUP> が指定されたが、呼び出し元が B<CAP_BLOCK_SUSPEND> "
"ケーパビリティを持っていない場合、 B<EPOLLWAKEUP> フラグは I<黙って無視される"
">。 元の実装では I<flags> 引数に対する正当性チェックが実行されていないた"
"め、 この残念な動作は必要である。 また、 呼び出し元が B<CAP_BLOCK_SUSPEND> "
"ケーパビリティを持っていなかった場合に呼び出しを失敗させるようにチェックを "
"B<EPOLLWAKEUP> に追加すると、 少なくともひとつは動かなくなる既存のユーザー空"
"間アプリケーションがあった。 そのアプリケーションはたまたま (しかも意味もな"
"く) このビットを指定していた。 したがって、信頼性が求められるアプリケーション"
"では、 B<EPOLLWAKEUP> フラグを使おうする場合には B<CAP_BLOCK_SUSPEND> ケーパ"
"ビリティを持っているかも確認するようにすべきである。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:481
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_wait.2:23
#, no-wrap
msgid "EPOLL_WAIT"
msgstr "EPOLL_WAIT"

#. type: Plain text
#: build/C/man2/epoll_wait.2:26
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""
"epoll_wait, epoll_pwait - epoll ファイルディスクリプターの I/O イベントを待つ"

#. type: Plain text
#: build/C/man2/epoll_wait.2:35
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:55
#, fuzzy
#| msgid ""
#| "The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
#| "instance referred to by the file descriptor I<epfd>.  The memory area "
#| "pointed to by I<events> will contain the events that will be available "
#| "for the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
#| "I<maxevents> argument must be greater than zero."
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The buffer pointed to "
"by I<events> is used to return information from the ready list about file "
"descriptors in the interest list that have some events available.  Up to "
"I<maxevents> are returned by B<epoll_wait>().  The I<maxevents> argument "
"must be greater than zero."
msgstr ""
"B<epoll_wait>() システムコールは、ファイルディスクリプター I<epfd> で参照され"
"る\n"
"B<epoll>(7) インスタンスに対するイベントを待つ。 I<events> が指すメモリー領域"
"には、\n"
"呼び出し側が利用可能なイベントが格納される。最大 I<maxevents> 個のイベント"
"が\n"
"B<epoll_wait>() によって返される。\n"
"I<maxevents> 引数は 0 より大きくなければならない。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:64
#, fuzzy
#| msgid ""
#| "The I<timeout> argument specifies the number of milliseconds that "
#| "B<epoll_wait>()  will block.  The call will block until either:"
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  Time is measured against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""
"I<timeout> 引数は B<epoll_wait>() が停止する時間をミリ秒で指定する。 "
"B<epoll_wait>() の呼び出しは以下のいずれかになるまで停止する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:68
#, fuzzy
#| msgid "A call to B<epoll_wait>(2)  is done."
msgid "A call to B<epoll_wait>()  will block until either:"
msgstr "B<epoll_wait>(2)  の呼び出しが行われる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:70
msgid "a file descriptor delivers an event;"
msgstr "ファイルディスクリプターがイベントを配送した"

#. type: Plain text
#: build/C/man2/epoll_wait.2:72 build/C/man2/poll.2:141
msgid "the call is interrupted by a signal handler; or"
msgstr "呼び出しがシグナルハンドラーにより割り込まれた"

#. type: Plain text
#: build/C/man2/epoll_wait.2:74 build/C/man2/poll.2:143
msgid "the timeout expires."
msgstr "タイムアウトが満了する"

#. type: Plain text
#: build/C/man2/epoll_wait.2:89
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""
"I<timeout> 時間はシステムクロックの粒度に切り上げられ、カーネルのスケジューリ"
"ング遅延により少しだけ長くなる可能性がある点に注意すること。 I<timeout> を "
"-1 に指定すると、 B<epoll_wait>() は無限に停止する。 I<timeout> を 0 に指定す"
"ると、 B<epoll_wait>() は利用可能なイベントがなくても、すぐに返る。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:93
msgid "The I<struct epoll_event> is defined as:"
msgstr "I<struct epoll_event> は以下のように定義される。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:102
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:107
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;    /* epoll イベント */\n"
"    epoll_data_t data;      /* ユーザーデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:119
#, fuzzy
#| msgid ""
#| "The I<data> of each returned structure will contain the same data the "
#| "user set with an B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  "
#| "while the I<events> member will contain the returned event bit field."
msgid ""
"The I<data> field of each returned I<epoll_event> structure contains the "
"same data as was specified in the most recent call to B<epoll_ctl>(2)  "
"(B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  for the corresponding open file "
"descriptor."
msgstr ""
"返される構造体の I<data> メンバには、ユーザーが B<epoll_ctl>(2)  "
"(B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  で指定したデータが格納される。 一方、 "
"I<events> メンバには返された利用可能なイベントのビットフィールドが格納され"
"る。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:128
msgid ""
"The I<events> field is a bit mask that indicates the events that have "
"occurred for the corresponding open file description.  See B<epoll_ctl>(2)  "
"for a list of the bits that may appear in this mask."
msgstr ""

#. type: SS
#: build/C/man2/epoll_wait.2:128
#, no-wrap
msgid "epoll_pwait()"
msgstr "epoll_pwait()"

#. type: Plain text
#: build/C/man2/epoll_wait.2:142
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""
"B<epoll_wait>()  と B<epoll_pwait>()  の関係は、 B<select>(2)  と "
"B<pselect>(2)  の関係と同様である。 B<pselect>(2)  同様、 B<epoll_pwait>()  "
"を使うと、アプリケーションは、ファイルディスクリプターが準備できた状態になる"
"か、 シグナルが捕捉されるまで、安全に待つことができる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:146
msgid "The following B<epoll_pwait>()  call:"
msgstr "以下の B<epoll_pwait>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/epoll_wait.2:150
#, no-wrap
msgid "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:156
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "次の呼び出しを I<atomic> に実行するのと等価である。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:160
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr "sigset_t origmask;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:164
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:173
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""
"I<sigmask> 引数には NULL を指定してもよい。 その場合には、 "
"B<epoll_pwait>()  は B<epoll_wait>()  と等価となる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:185
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_wait>()  は要求された I/O に対して準備ができているファ"
"イルディスクリプターの数を返す。 また要求された I<timeout> ミリ秒の間にファイ"
"ルディスクリプターが準備できない場合は、0 を返す。 エラーが起こった場合、 "
"B<epoll_wait>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:190
msgid "I<epfd> is not a valid file descriptor."
msgstr "I<epfd> が有効なファイルディスクリプターでない。"

#. type: TP
#: build/C/man2/epoll_wait.2:190 build/C/man2/poll.2:359
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:195
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr "I<events> で指されるメモリー領域に書き込み権限でアクセスできない。"

#. type: TP
#: build/C/man2/epoll_wait.2:195 build/C/man2/poll.2:365
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:202
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""
"(1) 要求されたどのイベントも発生せず、かつ (2) I<timeout> の期限が切れる前"
"に、システムコールがシグナルハンドラーによって割り込まれた。 B<signal>(7) 参"
"照。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:210
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプターでない。 または I<maxevents> が "
"0 以下である。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_wait.2:216
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll_wait>() はカーネル 2.6 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:220
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""
"B<epoll_pwait>() はカーネル 2.6.19 で Linux に追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.6 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:223
msgid "B<epoll_wait>()  is Linux-specific."
msgstr "B<epoll_wait>() は Linux 独自である。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:233
msgid ""
"While one thread is blocked in a call to B<epoll_wait>(), it is possible for "
"another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr "あるスレッドが B<epoll_wait>() を呼び出して停止されている間に、別のスレッドが wait 中の B<epoll> インストールにファイルディスクリプターを追加することがある。新しいファイルディスクリプターでイベントが発生すると、 B<epoll_wait>() の呼び出しによる停止が解除されることになる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:245
msgid ""
"If more than I<maxevents> file descriptors are ready when B<epoll_wait>()  "
"is called, then successive B<epoll_wait>()  calls will round robin through "
"the set of ready file descriptors.  This behavior helps avoid starvation "
"scenarios, where a process fails to notice that additional file descriptors "
"are ready because it focuses on a set of file descriptors that are already "
"known to be ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:255
msgid ""
"Note that it is possible to call B<epoll_wait>()  on an B<epoll> instance "
"whose interest list is currently empty (or whose interest list becomes empty "
"because file descriptors are closed or removed from the interest in another "
"thread).  The call will block until some file descriptor is later added to "
"the interest list (in another thread) and that file descriptor becomes ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:267
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where I<sizeof(long)> is 4 and the kernel I<HZ> value "
"is 1000, this means that timeouts greater than 35.79 minutes are treated as "
"infinity."
msgstr ""
"バージョン 2.6.37 より前のカーネルでは、おおよそ I<LONG_MAX / HZ> ミリ秒より"
"大きい I<timeout> 値は -1 (つまり無限大) として扱われる。したがって、例えば、"
"I<sizeof(long)> が 4 で、カーネルの I<HZ> の値が 1000 のシステムでは、 35.79 "
"分よりも大きなタイムアウトは無限大として扱われるということである。"

#. type: SS
#: build/C/man2/epoll_wait.2:267 build/C/man2/poll.2:445
#, no-wrap
msgid "C library/kernel differences"
msgstr "C ライブラリとカーネルの違い"

#. type: Plain text
#: build/C/man2/epoll_wait.2:280
msgid ""
"The raw B<epoll_pwait>()  system call has a sixth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the I<sigmask> argument.  "
"The glibc B<epoll_pwait>()  wrapper function specifies this argument as a "
"fixed value (equal to I<sizeof(sigset_t)>)."
msgstr ""
"素の B<epoll_pwait>() システムコールは 6 番目の引数 I<size_t sigsetsize> を"
"取る。 この引数は I<sigmask> 引数のバイト単位のサイズを指定する。 glibc "
"の B<epoll_pwait>() ラッパー関数は、この引数に固定値 (I<sizeof(sigset_t)> "
"と同じ) を指定する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:284
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/poll.2:30
#, no-wrap
msgid "POLL"
msgstr "POLL"

#. type: Plain text
#: build/C/man2/poll.2:33
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr "poll, ppoll - ファイルディスクリプターにおけるイベントを待つ"

#. type: Plain text
#: build/C/man2/poll.2:36
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:38
#, no-wrap
msgid "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"
msgstr "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:45
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<,>\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<,>\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:56
#, fuzzy
#| msgid ""
#| "B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
#| "set of file descriptors to become ready to perform I/O."
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O.  The Linux-specific "
"B<epoll>(7)  API performs a similar task, but offers features beyond those "
"found in B<poll>()."
msgstr ""
"B<poll>()  は B<select>(2)  と同様の仕事を行う、つまり、ファイルディスクリプ"
"ター集合のいずれか一つが I/O を実行可能な状態になるのを待つ。"

#. type: Plain text
#: build/C/man2/poll.2:60
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""
"監視するファイルディスクリプター集合は、 I<fds> 引数で指定する。 I<fds> "
"は、以下の型の構造体の配列である。"

#. type: Plain text
#: build/C/man2/poll.2:68
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:75
msgid ""
"The caller should specify the number of items in the I<fds> array in I<nfds>."
msgstr "I<nfds> には、 I<fds> 配列の要素数を指定する。"

#. type: Plain text
#: build/C/man2/poll.2:91
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> "
"field.  Note, however, that this technique can't be used to ignore file "
"descriptor 0.)"
msgstr ""
"I<fd> フィールドには、オープンされたファイルのファイルディスクリプターが入"
"る。 このフィールドが負の場合、対応する I<events> フィールドは無視され、 "
"I<revents> には 0 が返される。(この機能により、一つの B<poll>() の呼び出しで"
"簡単にあるファイルディスクリプターを無視することができる。 単に I<fd> フィー"
"ルドの符号を反転するだけでよい。 ただし、この方法はファイルディスクリプター "
"0 を無視するのには使用できない点に注意すること。)"

#. type: Plain text
#: build/C/man2/poll.2:106
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""
"構造体の I<events> 要素は入力パラメーターで、 ファイルディスクリプター I<fd> "
"に関して、 アプリケーションが興味を持っているイベントのビットマスクを指定す"
"る。 このフィールドには 0 を指定することもでき、 その場合 I<revents> で返され"
"るイベントは B<POLLHUP>, B<POLLERR>, B<POLLNVAL> だけである (下記参照)。"

#. type: Plain text
#: build/C/man2/poll.2:125
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""
"I<revents> 要素は出力パラメーターで、実際に起こったイベントがカーネルにより設"
"定される。 I<revents> で返されるビット列には、 I<events> で指定したもののどれ"
"か、もしくは B<POLLERR>, B<POLLHUP>, B<POLLNVAL> のうちの一つが含まれる "
"(B<POLLERR>, B<POLLHUP>, B<POLLNVAL> の 3つのビットは I<events> に指定しても"
"意味がなく、対応した状態が真の場合に I<revents> に設定される)。"

#. type: Plain text
#: build/C/man2/poll.2:130
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""
"どのファイルディスクリプターにも要求したイベントが発生しておらず、 エラーも起"
"こらない場合、 B<poll>()  はイベントのうちいずれか一つが発生するまで停止 "
"(block) する。"

#. type: Plain text
#: build/C/man2/poll.2:137
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""
"I<timeout> 引数は、 ファイルディスクリプターが利用可能になるまで B<poll>() "
"が停止する時間をミリ秒で指定する。 B<poll>() の呼び出しは以下のいずれかになる"
"まで停止する。"

#. type: Plain text
#: build/C/man2/poll.2:139
msgid "a file descriptor becomes ready;"
msgstr "ファイルディスクリプターが利用可能になる"

#. type: Plain text
#: build/C/man2/poll.2:157
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes "
"B<poll>()  to return immediately, even if no file descriptors are ready."
msgstr ""
"I<timeout> 時間はシステムクロックの粒度に切り上げられ、 カーネルのスケジュー"
"リング遅延により少しだけ長くなる可能性がある点に注意すること。 I<timeout> に"
"負の値を指定した場合、タイムアウト時間が無限大を意味する。 I<timeout> を 0 に"
"指定した場合、I/O 可能なファイルディスクリプターがない場合であっても、 "
"B<poll>() はすぐに返る。"

#. type: Plain text
#: build/C/man2/poll.2:163
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""
"I<events> に指定したり、 I<revents> で返されるビットは I<E<lt>poll.hE<gt>> で"
"定義されている:"

#. type: TP
#: build/C/man2/poll.2:163
#, no-wrap
msgid "B<POLLIN>"
msgstr "B<POLLIN>"

#. type: Plain text
#: build/C/man2/poll.2:166
msgid "There is data to read."
msgstr "読み出し可能なデータがある。"

#. type: TP
#: build/C/man2/poll.2:166
#, no-wrap
msgid "B<POLLPRI>"
msgstr "B<POLLPRI>"

#. type: Plain text
#: build/C/man2/poll.2:170
msgid ""
"There is some exceptional condition on the file descriptor.  Possibilities "
"include:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:174
msgid "There is out-of-band data on a TCP socket (see B<tcp>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:178
msgid ""
"A pseudoterminal master in packet mode has seen a state change on the slave "
"(see B<ioctl_tty>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:183
msgid "A I<cgroup.events> file has been modified (see B<cgroups>(7))."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:184
#, no-wrap
msgid "B<POLLOUT>"
msgstr "B<POLLOUT>"

#. type: Plain text
#: build/C/man2/poll.2:190
msgid ""
"Writing is now possible, though a write larger than the available space in a "
"socket or pipe will still block (unless B<O_NONBLOCK> is set)."
msgstr ""
"書き込みが可能になった。ただし、ソケットやパイプで利用可能な空間よりも大きな"
"データを書き込んだ場合には (B<O_NONBLOCK> がセットされている場合以外は) やは"
"り停止することになる。"

#. type: TP
#: build/C/man2/poll.2:190
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr "B<POLLRDHUP> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man2/poll.2:201
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""
"ストリームソケットの他端が、コネクションを close したか、 コネクションの書き"
"込み側を shutdown した。 この定義を有効にするには、 (「どの」ヘッダーファイル"
"をインクルードするよりも前に)  B<_GNU_SOURCE> 機能検査マクロを定義しなければ"
"ならない。"

#. type: TP
#: build/C/man2/poll.2:201
#, no-wrap
msgid "B<POLLERR>"
msgstr "B<POLLERR>"

#. type: Plain text
#: build/C/man2/poll.2:209
msgid ""
"Error condition (only returned in I<revents>; ignored in I<events>).  This "
"bit is also set for a file descriptor referring to the write end of a pipe "
"when the read end has been closed."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:209
#, no-wrap
msgid "B<POLLHUP>"
msgstr "B<POLLHUP>"

#. type: Plain text
#: build/C/man2/poll.2:219
msgid ""
"Hang up (only returned in I<revents>; ignored in I<events>).  Note that when "
"reading from a channel such as a pipe or a stream socket, this event merely "
"indicates that the peer closed its end of the channel.  Subsequent reads "
"from the channel will return 0 (end of file)  only after all outstanding "
"data in the channel has been consumed."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:219
#, no-wrap
msgid "B<POLLNVAL>"
msgstr "B<POLLNVAL>"

#. type: Plain text
#: build/C/man2/poll.2:227
#, fuzzy
#| msgid "Invalid request: I<fd> not open (output only)."
msgid ""
"Invalid request: I<fd> not open (only returned in I<revents>; ignored in "
"I<events>)."
msgstr "不正な要求: I<fd> がオープンされていない (出力の場合のみ)。"

#. type: Plain text
#: build/C/man2/poll.2:232
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""
"B<_XOPEN_SOURCE> を定義してコンパイルした場合には、以下の定義も行われる。 た"
"だし、上記のリストにあるビット以上の情報が得られる訳ではない。"

#. type: TP
#: build/C/man2/poll.2:232
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr "B<POLLRDNORM>"

#. type: Plain text
#: build/C/man2/poll.2:236
msgid "Equivalent to B<POLLIN>."
msgstr "B<POLLIN> と同じ。"

#. type: TP
#: build/C/man2/poll.2:236
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr "B<POLLRDBAND>"

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: build/C/man2/poll.2:240
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""
"優先帯域データ (priority band data) が読み出し可能である (普通は Linux では使"
"用されない)。"

#. type: TP
#: build/C/man2/poll.2:240
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr "B<POLLWRNORM>"

#. type: Plain text
#: build/C/man2/poll.2:244
msgid "Equivalent to B<POLLOUT>."
msgstr "B<POLLOUT> と同じ。"

#. type: TP
#: build/C/man2/poll.2:244
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr "B<POLLWRBAND>"

#. type: Plain text
#: build/C/man2/poll.2:247
msgid "Priority data may be written."
msgstr "優先帯域データ (priority data) が書き込み可能である。"

#. type: Plain text
#: build/C/man2/poll.2:250
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr "Linux では B<POLLMSG> も定義されているが、使用されていない。"

#. type: SS
#: build/C/man2/poll.2:250
#, no-wrap
msgid "ppoll()"
msgstr "ppoll()"

#. type: Plain text
#: build/C/man2/poll.2:264
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""
"B<poll>()  と B<ppoll>()  の関係は B<select>(2)  と B<pselect>(2)  の関係と同"
"じようなものである: B<pselect>(2)  と同様に、 B<ppoll>()  を使うと、アプリ"
"ケーションはファイルディスクリプターの状態変化 もしくはシグナルの捕捉を安全に"
"待つことができる。"

#. type: Plain text
#: build/C/man2/poll.2:270
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""
"I<timeout> 引数の精度の違いを除くと、以下の B<ppoll>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/poll.2:274
#, no-wrap
msgid "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"
msgstr "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"

#. type: Plain text
#: build/C/man2/poll.2:280
msgid "is nearly equivalent to I<atomically> executing the following calls:"
msgstr "次の呼び出しを I<atomic> に実行するのとほぼ等価である。"

#. type: Plain text
#: build/C/man2/poll.2:285
#, no-wrap
msgid ""
"sigset_t origmask;\n"
"int timeout;\n"
msgstr ""
"sigset_t origmask;\n"
"int timeout;\n"

#. type: Plain text
#: build/C/man2/poll.2:291
#, no-wrap
msgid ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/poll.2:304
msgid ""
"The above code segment is described as I<nearly> equivalent because whereas "
"a negative I<timeout> value for B<poll>()  is interpreted as an infinite "
"timeout, a negative value expressed in I<*tmo_p> results in an error from "
"B<ppoll>()."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:310
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""
"なぜ B<ppoll>()  が必要なのかについての説明は B<pselect>(2)  の説明を参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/poll.2:322
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""
"I<sigmask> 引数に NULL が指定された場合、シグナルマスクの操作は行われない "
"(したがって、 B<ppoll>()  の B<poll>()  との違いは I<timeout> 引数の精度だ"
"けとなる)。"

#. type: Plain text
#: build/C/man2/poll.2:329
msgid ""
"The I<tmo_p> argument specifies an upper limit on the amount of time that "
"B<ppoll>()  will block.  This argument is a pointer to a structure of the "
"following form:"
msgstr "I<tmo_p> 引数は B<ppoll>()  が停止する時間の上限を指定するものである。 この引数には以下の型の構造体へのポインターを指定する。"

#. type: Plain text
#: build/C/man2/poll.2:336
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:344
msgid ""
"If I<tmo_p> is specified as NULL, then B<ppoll>()  can block indefinitely."
msgstr "I<tmo_p> に NULL が指定された場合、 B<ppoll> は無限に停止することがあり得る。"

#. type: Plain text
#: build/C/man2/poll.2:354
msgid ""
"On success, B<poll>()  returns a nonnegative value which is the number of "
"elements in the I<pollfds> whose I<revents> fields have been set to a "
"nonzero value (indicating an event or an error).  A return value of zero "
"indicates that the system call timed out before any file descriptors became "
"read."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:358
#, fuzzy
#| msgid ""
#| "On success, these system calls return a nonnegative file descriptor.  On "
#| "error, -1 is returned, and I<errno> is set to indicate the error."
msgid ""
"On error, -1 is returned, and I<errno> is set to indicate the cause of the "
"error."
msgstr ""
"成功すると、これらのシステムコールは 非負のファイルディスクリプターを返す。 "
"エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/poll.2:365
#, fuzzy
#| msgid ""
#| "The array given as argument was not contained in the calling program's "
#| "address space."
msgid ""
"I<fds> points outside the process's accessible address space.  The array "
"given as argument was not contained in the calling program's address space."
msgstr ""
"引数として指定した配列が、呼び出したプロセスのアドレス空間に 含まれていな"
"い。"

#. type: Plain text
#: build/C/man2/poll.2:369
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""
"要求されたイベントのどれかが起こる前にシグナルが発生した。 B<signal>(7)  参"
"照。"

#. type: Plain text
#: build/C/man2/poll.2:376
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr "I<nfds> の値が B<RLIMIT_NOFILE> を超えた。"

#. type: Plain text
#: build/C/man2/poll.2:382
msgid ""
"(B<ppoll>())  The timeout value expressed in I<*ip> is invalid (negative)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:385
msgid "Unable to allocate memory for kernel data structures."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:394
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc B<poll>()  wrapper function provides "
"emulation using B<select>(2)."
msgstr "B<poll>() システムコールは Linux 2.1.23 で導入された。このシステムコールが存在しない古いカーネルでは、 glibc は B<select>(2) を使用して B<poll>() ラッパー関数のエミュレーションを行う。"

#. type: Plain text
#: build/C/man2/poll.2:401
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""
"B<ppoll>()  システムコールは カーネル 2.6.16 で Linux に追加された。 "
"B<ppoll>()  ライブラリコールは glibc 2.4 に追加された。"

#.  FIXME .
#.  ppoll() is proposed for inclusion in POSIX:
#.  https://www.austingroupbugs.net/view.php?id=1263
#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: build/C/man2/poll.2:410
msgid ""
"B<poll>()  conforms to POSIX.1-2001 and POSIX.1-2008.  B<ppoll>()  is Linux-"
"specific."
msgstr "B<poll>() は POSIX.1-2001 と POSIX.1-2008 に準拠している。 B<ppoll>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/poll.2:418
msgid ""
"The operation of B<poll>()  and B<ppoll>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: build/C/man2/poll.2:432
msgid ""
"On some other UNIX systems, B<poll>()  can fail with the error B<EAGAIN> if "
"the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX permits this behavior.  Portable programs "
"may wish to check for B<EAGAIN> and loop, just as with B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:440
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""
"いくつかの実装では、値 -1 を持った非標準の定数 B<INFTIM> が定義されており、 "
"B<poll>()  の I<timeout> の指定に使用できる。 この定数は glibc では定義されて"
"いない。"

#. type: Plain text
#: build/C/man2/poll.2:445
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""
"B<poll>() で監視中のファイルディスクリプターが別のスレッドによってクローズさ"
"れた場合に何が起こるかの議論については、 B<select>(2) を参照してほしい。"

#. type: Plain text
#: build/C/man2/poll.2:459
msgid ""
"The Linux B<ppoll>()  system call modifies its I<tmo_p> argument.  However, "
"the glibc wrapper function hides this behavior by using a local variable for "
"the timeout argument that is passed to the system call.  Thus, the glibc "
"B<ppoll>()  function does not modify its I<tmo_p> argument."
msgstr "Linux の B<ppoll>()  システムコールは I<tmo_p> 引数を変更する。 しかし、glibc のラッパー関数は、システムコールに渡す timeout 引数 としてローカル変数を使うことでこの動作を隠蔽している。 このため、glibc の B<ppoll>()  関数では I<tmo_p> 引数は変更されない。"

#. type: Plain text
#: build/C/man2/poll.2:476
#, fuzzy
#| msgid ""
#| "The raw B<ppoll>()  system call has a fifth argument, I<size_t "
#| "sigsetsize>, which specifies the size in bytes of the I<sigmask> "
#| "argument.  The glibc B<ppoll>()  wrapper function specifies this argument "
#| "as a fixed value (equal to I<sizeof(sigset_t)>)."
msgid ""
"The raw B<ppoll>()  system call has a fifth argument, I<size_t sigsetsize>, "
"which specifies the size in bytes of the I<sigmask> argument.  The glibc "
"B<ppoll>()  wrapper function specifies this argument as a fixed value (equal "
"to I<sizeof(kernel_sigset_t)>).  See B<sigprocmask>(2)  for a discussion on "
"the differences between the kernel and the libc notion of the sigset."
msgstr ""
"素の B<ppoll>() システムコールは 5 番目の引数 I<size_t sigsetsize> をと"
"る。 この引数は I<sigmask> 引数のバイト単位のサイズを指定する。 glibc の "
"B<ppoll>() ラッパー関数は、この引数に固定値 (I<sizeof(sigset_t)> と同じ) を"
"指定する。"

#. type: Plain text
#: build/C/man2/poll.2:480
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""
"B<select>(2)  の「バグ」の節に書かれている、誤った準備完了通知 (spurious "
"readiness notifications) についての議論を参照のこと。"

#. type: SH
#: build/C/man2/poll.2:480
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man2/poll.2:489
msgid ""
"The program below opens each of the files named in its command-line "
"arguments and monitors the resulting file descriptors for readiness to read "
"(B<POLLIN>).  The program loops, repeatedly using B<poll>()  to monitor the "
"file descriptors, printing the number of ready file descriptors on return.  "
"For each ready file descriptor, the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:493
msgid "displays the returned I<revents> field in a human-readable form;"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:496
msgid ""
"if the file descriptor is readable, reads some data from it, and displays "
"that data on standard output; and"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:501
msgid ""
"if the file descriptors was not readable, but some other event occurred "
"(presumably B<POLLHUP>), closes the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:503
msgid "Suppose we run the program in one terminal, asking it to open a FIFO:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:508
#, no-wrap
msgid ""
"$ B<mkfifo myfifo>\n"
"$ B<./poll_input myfifo>\n"
msgstr ""
"$ B<mkfifo myfifo>\n"
"$ B<./poll_input myfifo>\n"

#. type: Plain text
#: build/C/man2/poll.2:513
msgid ""
"In a second terminal window, we then open the FIFO for writing, write some "
"data to it, and close the FIFO:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:517
#, no-wrap
msgid "$ B<echo aaaaabbbbbccccc E<gt> myfifo>\n"
msgstr "$ B<echo aaaaabbbbbccccc E<gt> myfifo>\n"

#. type: Plain text
#: build/C/man2/poll.2:521
msgid "In the terminal where we are running the program, we would then see:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:533
#, no-wrap
msgid ""
"Opened \"myfifo\" on fd 3\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 10 bytes: aaaaabbbbb\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 6 bytes: ccccc\n"
msgstr ""
"Opened \"myfifo\" on fd 3\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 10 bytes: aaaaabbbbb\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 6 bytes: ccccc\n"

#. type: Plain text
#: build/C/man2/poll.2:539
#, no-wrap
msgid ""
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLHUP\n"
"    closing fd 3\n"
"All file descriptors closed; bye\n"
msgstr ""
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLHUP\n"
"    closing fd 3\n"
"All file descriptors closed; bye\n"

#. type: Plain text
#: build/C/man2/poll.2:545
msgid "In the above output, we see that B<poll>()  returned three times:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:554
msgid ""
"On the first return, the bits returned in the I<revents> field were "
"B<POLLIN>, indicating that the file descriptor is readable, and B<POLLHUP>, "
"indicating that the other end of the FIFO has been closed.  The program then "
"consumed some of the available input."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:562
msgid ""
"The second return from B<poll>()  also indicated B<POLLIN> and B<POLLHUP>; "
"the program then consumed the last of the available input."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:570
msgid ""
"On the final return, B<poll>()  indicated only B<POLLHUP> on the FIFO, at "
"which point the file descriptor was closed and the program terminated."
msgstr ""

#. type: SS
#: build/C/man2/poll.2:570
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/poll.2:574
#, no-wrap
msgid "/* poll_input.c\n"
msgstr "/* poll_input.c\n"

#. type: Plain text
#: build/C/man2/poll.2:583
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/poll.2:586
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/poll.2:592
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int nfds, num_open_fds;\n"
"    struct pollfd *pfds;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int nfds, num_open_fds;\n"
"    struct pollfd *pfds;\n"

#. type: Plain text
#: build/C/man2/poll.2:597
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"       fprintf(stderr, \"Usage: %s file...\\en\", argv[0]);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"       fprintf(stderr, \"Usage: %s file...\\en\", argv[0]);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/poll.2:602
#, no-wrap
msgid ""
"    num_open_fds = nfds = argc - 1;\n"
"    pfds = calloc(nfds, sizeof(struct pollfd));\n"
"    if (pfds == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""
"    num_open_fds = nfds = argc - 1;\n"
"    pfds = calloc(nfds, sizeof(struct pollfd));\n"
"    if (pfds == NULL)\n"
"        errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man2/poll.2:604
#, no-wrap
msgid "    /* Open each file on command line, and add it \\(aqpfds\\(aq array */\n"
msgstr "    /* Open each file on command line, and add it \\(aqpfds\\(aq array */\n"

#. type: Plain text
#: build/C/man2/poll.2:609
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> nfds; j++) {\n"
"        pfds[j].fd = open(argv[j + 1], O_RDONLY);\n"
"        if (pfds[j].fd == -1)\n"
"            errExit(\"open\");\n"
msgstr ""
"    for (int j = 0; j E<lt> nfds; j++) {\n"
"        pfds[j].fd = open(argv[j + 1], O_RDONLY);\n"
"        if (pfds[j].fd == -1)\n"
"            errExit(\"open\");\n"

#. type: Plain text
#: build/C/man2/poll.2:611
#, no-wrap
msgid "        printf(\"Opened \\e\"%s\\e\" on fd %d\\en\", argv[j + 1], pfds[j].fd);\n"
msgstr "        printf(\"Opened \\e\"%s\\e\" on fd %d\\en\", argv[j + 1], pfds[j].fd);\n"

#. type: Plain text
#: build/C/man2/poll.2:614
#, no-wrap
msgid ""
"        pfds[j].events = POLLIN;\n"
"    }\n"
msgstr ""
"        pfds[j].events = POLLIN;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/poll.2:617
#, no-wrap
msgid ""
"    /* Keep calling poll() as long as at least one file descriptor is\n"
"       open */\n"
msgstr ""
"    /* Keep calling poll() as long as at least one file descriptor is\n"
"       open */\n"

#. type: Plain text
#: build/C/man2/poll.2:620
#, no-wrap
msgid ""
"    while (num_open_fds E<gt> 0) {\n"
"        int ready;\n"
msgstr ""
"    while (num_open_fds E<gt> 0) {\n"
"        int ready;\n"

#. type: Plain text
#: build/C/man2/poll.2:625
#, no-wrap
msgid ""
"        printf(\"About to poll()\\en\");\n"
"        ready = poll(pfds, nfds, -1);\n"
"        if (ready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""
"        printf(\"About to poll()\\en\");\n"
"        ready = poll(pfds, nfds, -1);\n"
"        if (ready == -1)\n"
"            errExit(\"poll\");\n"

#. type: Plain text
#: build/C/man2/poll.2:627
#, no-wrap
msgid "        printf(\"Ready: %d\\en\", ready);\n"
msgstr "        printf(\"Ready: %d\\en\", ready);\n"

#. type: Plain text
#: build/C/man2/poll.2:629
#, no-wrap
msgid "        /* Deal with array returned by poll() */\n"
msgstr "        /* Deal with array returned by poll() */\n"

#. type: Plain text
#: build/C/man2/poll.2:632
#, no-wrap
msgid ""
"        for (int j = 0; j E<lt> nfds; j++) {\n"
"            char buf[10];\n"
msgstr ""
"        for (int j = 0; j E<lt> nfds; j++) {\n"
"            char buf[10];\n"

#. type: Plain text
#: build/C/man2/poll.2:638
#, no-wrap
msgid ""
"            if (pfds[j].revents != 0) {\n"
"                printf(\"  fd=%d; events: %s%s%s\\en\", pfds[j].fd,\n"
"                        (pfds[j].revents & POLLIN)  ? \"POLLIN \"  : \"\",\n"
"                        (pfds[j].revents & POLLHUP) ? \"POLLHUP \" : \"\",\n"
"                        (pfds[j].revents & POLLERR) ? \"POLLERR \" : \"\");\n"
msgstr ""
"            if (pfds[j].revents != 0) {\n"
"                printf(\"  fd=%d; events: %s%s%s\\en\", pfds[j].fd,\n"
"                        (pfds[j].revents & POLLIN)  ? \"POLLIN \"  : \"\",\n"
"                        (pfds[j].revents & POLLHUP) ? \"POLLHUP \" : \"\",\n"
"                        (pfds[j].revents & POLLERR) ? \"POLLERR \" : \"\");\n"

#. type: Plain text
#: build/C/man2/poll.2:654
#, no-wrap
msgid ""
"                if (pfds[j].revents & POLLIN) {\n"
"                    ssize_t s = read(pfds[j].fd, buf, sizeof(buf));\n"
"                    if (s == -1)\n"
"                        errExit(\"read\");\n"
"                    printf(\"    read %zd bytes: %.*s\\en\",\n"
"                            s, (int) s, buf);\n"
"                } else {                /* POLLERR | POLLHUP */\n"
"                    printf(\"    closing fd %d\\en\", pfds[j].fd);\n"
"                    if (close(pfds[j].fd) == -1)\n"
"                        errExit(\"close\");\n"
"                    num_open_fds--;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                if (pfds[j].revents & POLLIN) {\n"
"                    ssize_t s = read(pfds[j].fd, buf, sizeof(buf));\n"
"                    if (s == -1)\n"
"                        errExit(\"read\");\n"
"                    printf(\"    read %zd bytes: %.*s\\en\",\n"
"                            s, (int) s, buf);\n"
"                } else {                /* POLLERR | POLLHUP */\n"
"                    printf(\"    closing fd %d\\en\", pfds[j].fd);\n"
"                    if (close(pfds[j].fd) == -1)\n"
"                        errExit(\"close\");\n"
"                    num_open_fds--;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man2/poll.2:658
#, no-wrap
msgid ""
"    printf(\"All file descriptors closed; bye\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"All file descriptors closed; bye\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/poll.2:665
msgid ""
"B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), "
"B<time>(7)"
msgstr "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), B<time>(7)"

#~ msgid ""
#~ "Register the target file descriptor I<fd> on the B<epoll> instance "
#~ "referred to by the file descriptor I<epfd> and associate the event "
#~ "I<event> with the internal file linked to I<fd>."
#~ msgstr ""
#~ "対象のファイルディスクリプター I<fd> をファイルディスクリプター I<epfd> が"
#~ "参照する B<epoll> インスタンスに登録し、イベント I<event> を I<fd> に結び"
#~ "付けられた内部ファイルに関連付ける。"

#~ msgid ""
#~ "Change the event I<event> associated with the target file descriptor "
#~ "I<fd>."
#~ msgstr ""
#~ "イベント I<event> を対象のファイルディスクリプター I<fd> に関連付けるよう"
#~ "に変更する。"

#~ msgid "There is urgent data available for B<read>(2)  operations."
#~ msgstr "B<read>(2)  操作が可能な緊急 (urgent) データがある。"

#~ msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
#~ msgstr "B<epoll_ctl>()  はカーネル 2.6 で追加された。"

#~ msgid ""
#~ "B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
#~ "starting with version 2.3.2."
#~ msgstr ""
#~ "B<epoll_ctl>()  は Linux 独自である。\n"
#~ "ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#~ msgid ""
#~ "For a discussion of what may happen if a file descriptor in an B<epoll> "
#~ "instance being monitored by B<epoll_wait>()  is closed in another thread, "
#~ "see B<select>(2)."
#~ msgstr ""
#~ "B<epoll_wait>() で監視中の B<epoll> インスタンス内のファイルディスクリプ"
#~ "ターが別のスレッドによってクローズされた場合に何が起こるかの議論について"
#~ "は、 B<select>(2) を参照してほしい。"

#~ msgid ""
#~ "There is urgent data to read (e.g., out-of-band data on TCP socket; "
#~ "pseudoterminal master in packet mode has seen state change in slave)."
#~ msgstr ""
#~ "読み出し可能な緊急データ (urgent data) がある (例えば、TCP ソケットの帯域"
#~ "外 (out-of-band data) データを受信した場合や、 パケットモードの擬似端末の"
#~ "マスタがスレーブ側の変化を見つけたとき)。"

#~ msgid "Error condition (output only)."
#~ msgstr "エラー状態 (出力の場合のみ)。"

#~ msgid "Hang up (output only)."
#~ msgstr "ハングアップした (出力の場合のみ)。"

#~ msgid ""
#~ "On success, a positive number is returned; this is the number of "
#~ "structures which have nonzero I<revents> fields (in other words, those "
#~ "descriptors with events or errors reported).  A value of 0 indicates that "
#~ "the call timed out and no file descriptors were ready.  On error, -1 is "
#~ "returned, and I<errno> is set appropriately."
#~ msgstr ""
#~ "成功した場合は正の数を返す。この数は 0 以外の I<revents> 要素を持つ構造体"
#~ "の数である (別の言い方をすると、これらのディスクリプター にはイベントかエ"
#~ "ラー報告がある)。 値 0 は、タイムアウトとなり、どのファイルディスクリプ"
#~ "ターでもイベントが 発生しなかったことを示す。エラーの場合は -1 が返され、 "
#~ "I<errno> が適切に設定される。"
