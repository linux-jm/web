# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25 build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23 build/C/man2/poll.2:30
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25 build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23 build/C/man2/poll.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:22 build/C/man2/epoll_create.2:26 build/C/man2/epoll_ctl.2:22 build/C/man2/epoll_wait.2:24 build/C/man2/poll.2:31
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:24 build/C/man2/epoll_create.2:28 build/C/man2/epoll_ctl.2:24 build/C/man2/epoll_wait.2:26 build/C/man2/poll.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:26 build/C/man2/epoll_ctl.2:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:26 build/C/man2/epoll_create.2:35 build/C/man2/epoll_ctl.2:29 build/C/man2/epoll_wait.2:36 build/C/man2/poll.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:36
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API "
"can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:44
msgid ""
"The central concept of the B<epoll> API is the B<epoll> I<instance>, an "
"in-kernel data structure which, from a user-space perspective, can be "
"considered as a container for two lists:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:44 build/C/man7/epoll.7:51 build/C/man7/epoll.7:65 build/C/man7/epoll.7:74 build/C/man7/epoll.7:80 build/C/man2/epoll_wait.2:68 build/C/man2/epoll_wait.2:70 build/C/man2/epoll_wait.2:72 build/C/man2/poll.2:137 build/C/man2/poll.2:139 build/C/man2/poll.2:141 build/C/man2/poll.2:171 build/C/man2/poll.2:174 build/C/man2/poll.2:178 build/C/man2/poll.2:489 build/C/man2/poll.2:493 build/C/man2/poll.2:496 build/C/man2/poll.2:545 build/C/man2/poll.2:554 build/C/man2/poll.2:562
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:51
msgid ""
"The I<interest> list (sometimes also called the B<epoll> set): the set of "
"file descriptors that the process has registered an interest in monitoring."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:60
msgid ""
"The I<ready> list: the set of file descriptors that are \"ready\" for I/O.  "
"The ready list is a subset of (or, more precisely, a set of references to)  "
"the file descriptors in the interest list.  The ready list is dynamically "
"populated by the kernel as a result of I/O activity on those file "
"descriptors."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:65
msgid ""
"The following system calls are provided to create and manage an B<epoll> "
"instance:"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:74
msgid ""
"B<epoll_create>(2)  creates a new B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent B<epoll_create1>(2)  "
"extends the functionality of B<epoll_create>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:80
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2), which adds items to the interest list of the B<epoll> "
"instance."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:89
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available.  (This system call can be thought of as "
"fetching items from the ready list of the B<epoll> instance.)"
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:89
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:98
msgid ""
"The B<epoll> event distribution interface is able to behave both as "
"edge-triggered (ET) and as level-triggered (LT).  The difference between the "
"two mechanisms can be described as follows.  Suppose that this scenario "
"happens:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:98 build/C/man7/epoll.7:378
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:104
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:104 build/C/man7/epoll.7:412
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:106
msgid "A pipe writer writes 2\\ kB of data on the write side of the pipe."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:106 build/C/man7/epoll.7:422
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:112
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:112 build/C/man7/epoll.7:432
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:115
msgid "The pipe reader reads 1\\ kB of data from I<rfd>."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:115 build/C/man7/epoll.7:446
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:119
msgid "A call to B<epoll_wait>(2)  is done."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:154
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that "
"edge-triggered mode delivers events only when changes occur on the monitored "
"file descriptor.  So, in step B<5> the caller might end up waiting for some "
"data that is already present inside the input buffer.  In the above example, "
"an event on I<rfd> will be generated because of the write done in B<2> and "
"the event is consumed in B<3>.  Since the read operation done in B<4> does "
"not consume the whole buffer data, the call to B<epoll_wait>(2)  done in "
"step B<5> might block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:164
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:164
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:166
msgid "with nonblocking file descriptors; and"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:166
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:173
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:183
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:200
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:217
msgid ""
"If multiple threads (or processes, if child processes have inherited the "
"B<epoll> file descriptor across B<fork>(2))  are blocked in B<epoll_wait>(2)  "
"waiting on the same epoll file descriptor and a file descriptor in the "
"interest list that is marked for edge-triggered (B<EPOLLET>)  notification "
"becomes ready, just one of the threads (or processes) is awoken from "
"B<epoll_wait>(2).  This provides a useful optimization for avoiding "
"\"thundering herd\" wake-ups in some scenarios."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:217
#, no-wrap
msgid "Interaction with autosleep"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:229
msgid ""
"If the system is in B<autosleep> mode via I</sys/power/autosleep> and an "
"event happens which wakes the device from sleep, the device driver will keep "
"the device awake only until that event is queued.  To keep the device awake "
"until the event has been processed, it is necessary to use the "
"B<epoll_ctl>(2)  B<EPOLLWAKEUP> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:248
msgid ""
"When the B<EPOLLWAKEUP> flag is set in the B<events> field for a I<struct "
"epoll_event>, the system will be kept awake from the moment the event is "
"queued, through the B<epoll_wait>(2)  call which returns the event until the "
"subsequent B<epoll_wait>(2)  call.  If the event should keep the system "
"awake beyond that time, then a separate I<wake_lock> should be taken before "
"the second B<epoll_wait>(2)  call."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:248
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: build/C/man7/epoll.7:256
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:256
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr ""

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: build/C/man7/epoll.7:270
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:270
#, no-wrap
msgid "Example for suggested usage"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:299
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An "
"event-driven state machine application should, after having received "
"B<EAGAIN>, record its current state so that at the next call to "
"I<do_use_fd()> it will continue to B<read>(2)  or B<write>(2)  from where it "
"stopped before."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:305
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:308
#, no-wrap
msgid ""
"/* Code to set up listening socket, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) omitted */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:314
#, no-wrap
msgid ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:321
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:328
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:350
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:369
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:369
#, no-wrap
msgid "Questions and answers"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:370
#, no-wrap
msgid "0."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:373
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"interest list?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:378
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:382
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""

#.  But a file descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, file descriptors duplicated by fork have
#.  similar semantics to file descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  file descriptor means that even if the parent closes its file descriptor,
#.  then epoll_wait() in the parent will continue to receive notifications for
#.  that file descriptor because of the duplicated file descriptor in the child.
#
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#
#.  mtk, Feb 2008
#. type: Plain text
#: build/C/man7/epoll.7:412
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  file descriptor to the "
"same B<epoll> instance.  This can be a useful technique for filtering "
"events, if the duplicate file descriptors are registered with different "
"I<events> masks."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:419
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:422
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:426
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:432
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting, then it will "
"indicate as being readable."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:436
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:446
msgid ""
"The B<epoll_ctl>(2)  call fails (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:450
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:453
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the interest list."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:453
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:457
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> "
"interest lists?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:472
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a file descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:492
msgid ""
"A file descriptor is removed from an interest list only after all the file "
"descriptors referring to the underlying open file description have been "
"closed.  This means that even after a file descriptor that is part of an "
"interest list has been closed, events may be reported for that file "
"descriptor if other file descriptors referring to the same underlying file "
"description remain open.  To prevent this happening, the file descriptor "
"must be explicitly removed from the interest list (using B<epoll_ctl>(2)  "
"B<EPOLL_CTL_DEL>)  before it is duplicated.  Alternatively, the application "
"must ensure that all file descriptors are closed (which may be difficult if "
"file descriptors were duplicated behind the scenes by library functions that "
"used B<dup>(2)  or B<fork>(2))."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:492
#, no-wrap
msgid "7."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:496
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:498
msgid "They will be combined."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:498
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:501
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:506
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:506
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:513
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior)?"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:522
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:528
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:544
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a "
"stream-oriented file.)"
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:544
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:545
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:553
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:561
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:561
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:577
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:588
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:588 build/C/man2/epoll_create.2:112 build/C/man2/epoll_ctl.2:421 build/C/man2/epoll_wait.2:210 build/C/man2/poll.2:385
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man7/epoll.7:594
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:594 build/C/man2/epoll_create.2:122 build/C/man2/epoll_ctl.2:427 build/C/man2/epoll_wait.2:220 build/C/man2/poll.2:401
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:603
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has "
"I</dev/poll>."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:603 build/C/man2/epoll_create.2:125 build/C/man2/epoll_ctl.2:430 build/C/man2/epoll_wait.2:223 build/C/man2/poll.2:410
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:612
msgid ""
"The set of file descriptors that is being monitored via an epoll file "
"descriptor can be viewed via the entry for the epoll file descriptor in the "
"process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:618
msgid ""
"The B<kcmp>(2)  B<KCMP_EPOLL_TFD> operation can be used to test whether a "
"file descriptor is present in an epoll instance."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:618 build/C/man2/epoll_create.2:148 build/C/man2/epoll_ctl.2:476 build/C/man2/epoll_wait.2:280 build/C/man2/poll.2:659
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:625
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), "
"B<poll>(2), B<select>(2)"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:625 build/C/man2/epoll_create.2:153 build/C/man2/epoll_ctl.2:481 build/C/man2/epoll_wait.2:284 build/C/man2/poll.2:665
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:633 build/C/man2/epoll_create.2:161 build/C/man2/epoll_ctl.2:489 build/C/man2/epoll_wait.2:292 build/C/man2/poll.2:673
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/epoll_create.2:25
#, no-wrap
msgid "EPOLL_CREATE"
msgstr ""

#. type: TH
#: build/C/man2/epoll_create.2:25 build/C/man2/epoll_wait.2:23 build/C/man2/poll.2:30
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:28
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:31 build/C/man2/epoll_wait.2:29
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:34
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:43
msgid ""
"B<epoll_create>()  creates a new B<epoll>(7)  instance.  Since Linux 2.6.8, "
"the I<size> argument is ignored, but must be greater than zero; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:56
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""

#. type: SS
#: build/C/man2/epoll_create.2:56
#, no-wrap
msgid "epoll_create1()"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:68
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:68
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:78
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#: build/C/man2/epoll_create.2:78 build/C/man2/epoll_ctl.2:309 build/C/man2/epoll_wait.2:173 build/C/man2/poll.2:344
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:85
msgid ""
"On success, these system calls return a file descriptor (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: SH
#: build/C/man2/epoll_create.2:85 build/C/man2/epoll_ctl.2:318 build/C/man2/epoll_wait.2:185 build/C/man2/poll.2:358
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:86 build/C/man2/epoll_create.2:90 build/C/man2/epoll_ctl.2:333 build/C/man2/epoll_ctl.2:346 build/C/man2/epoll_ctl.2:352 build/C/man2/epoll_ctl.2:361 build/C/man2/epoll_ctl.2:371 build/C/man2/epoll_wait.2:202 build/C/man2/poll.2:369 build/C/man2/poll.2:376
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:90
msgid "I<size> is not positive."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:95
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:95 build/C/man2/epoll_create.2:103
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:103
msgid ""
"The per-user limit on the number of epoll instances imposed by "
"I</proc/sys/fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  "
"for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:106
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:106
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:109
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:109 build/C/man2/epoll_ctl.2:397 build/C/man2/poll.2:382
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:112
msgid "There was insufficient memory to create the kernel object."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:116
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_create.2:122
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:125
msgid "B<epoll_create>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:148
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:153
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/epoll_ctl.2:21
#, no-wrap
msgid "EPOLL_CTL"
msgstr ""

#. type: TH
#: build/C/man2/epoll_ctl.2:21
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:24
msgid "epoll_ctl - control interface for an epoll file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:29
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:40
msgid ""
"This system call is used to add, modify, or remove entries in the interest "
"list of the B<epoll>(7)  instance referred to by the file descriptor "
"I<epfd>.  It requests that the operation I<op> be performed for the target "
"file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:44
msgid "Valid values for the I<op> argument are:"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:44
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:56
msgid ""
"Add an entry to the interest list of the epoll file descriptor, I<epfd>.  "
"The entry includes the file descriptor, I<fd>, a reference to the "
"corresponding open file description (see B<epoll>(7)  and B<open>(2)), and "
"the settings specified in I<event>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:56
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:62
msgid ""
"Change the settings associated with I<fd> in the interest list to the new "
"settings specified in I<event>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:62
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:70
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the interest "
"list.  The I<event> argument is ignored and can be NULL (but see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:78
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:87
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:92
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:102
msgid ""
"The I<data> member of the I<epoll_event> structure specifies data that the "
"kernel should save and then return (via B<epoll_wait>(2))  when this file "
"descriptor becomes ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:109
msgid ""
"The I<events> member of the I<epoll_event> structure is a bit mask composed "
"by ORing together zero or more of the following available event types:"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:109
#, no-wrap
msgid "B<EPOLLIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:114
msgid "The associated file is available for B<read>(2)  operations."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:114
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:119
msgid "The associated file is available for B<write>(2)  operations."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:119
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:125
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using edge-triggered monitoring.)"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:125
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:132
msgid ""
"There is an exceptional condition on the file descriptor.  See the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:132
#, no-wrap
msgid "B<EPOLLERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:137
msgid ""
"Error condition happened on the associated file descriptor.  This event is "
"also reported for the write end of a pipe when the read end has been closed."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:143
msgid ""
"B<epoll_wait>(2)  will always report for this event; it is not necessary to "
"set it in I<events> when calling B<epoll_ctl>()."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:143
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:146
msgid "Hang up happened on the associated file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:152
msgid ""
"B<epoll_wait>(2)  will always wait for this event; it is not necessary to "
"set it in I<events> when calling B<epoll_ctl>()."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:157
msgid ""
"Note that when reading from a channel such as a pipe or a stream socket, "
"this event merely indicates that the peer closed its end of the channel.  "
"Subsequent reads from the channel will return 0 (end of file)  only after "
"all outstanding data in the channel has been consumed."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:157
#, no-wrap
msgid "B<EPOLLET>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:167
msgid ""
"Requests edge-triggered notification for the associated file descriptor.  "
"The default behavior for B<epoll> is level-triggered.  See B<epoll>(7)  for "
"more detailed information about edge-triggered and level-triggered "
"notification."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:174 build/C/man2/epoll_ctl.2:195 build/C/man2/epoll_ctl.2:230
msgid ""
"This flag is an input flag for the I<event.events> field when calling "
"B<epoll_ctl>(); it is never returned by B<epoll_wait>(2)."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:174
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:188
msgid ""
"Requests one-shot notification for the associated file descriptor.  This "
"means that after an event notified for the file descriptor by "
"B<epoll_wait>(2), the file descriptor is disabled in the interest list and "
"no other events will be reported by the B<epoll> interface.  The user must "
"call B<epoll_ctl>()  with B<EPOLL_CTL_MOD> to rearm the file descriptor with "
"a new event mask."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:195
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr ""

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: build/C/man2/epoll_ctl.2:223
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being "
"processed.  The event is considered as being \"processed\" from the time "
"when it is returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:230
#, no-wrap
msgid "B<EPOLLEXCLUSIVE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:245
msgid ""
"Sets an exclusive wakeup mode for the epoll file descriptor that is being "
"attached to the target file descriptor, I<fd>.  When a wakeup event occurs "
"and multiple epoll file descriptors are attached to the same target file "
"using B<EPOLLEXCLUSIVE>, one or more of the epoll file descriptors will "
"receive an event with B<epoll_wait>(2).  The default in this scenario (when "
"B<EPOLLEXCLUSIVE> is not set) is for all epoll file descriptors to receive "
"an event.  B<EPOLLEXCLUSIVE> is thus useful for avoiding thundering herd "
"problems in certain scenarios."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:254
msgid ""
"If the same file descriptor is in multiple epoll instances, some with the "
"B<EPOLLEXCLUSIVE> flag, and others without, then events will be provided to "
"all epoll instances that did not specify B<EPOLLEXCLUSIVE>, and at least one "
"of the epoll instances that did specify B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:273
msgid ""
"The following values may be specified in conjunction with B<EPOLLEXCLUSIVE>: "
"B<EPOLLIN>, B<EPOLLOUT>, B<EPOLLWAKEUP>, and B<EPOLLET>.  B<EPOLLHUP> and "
"B<EPOLLERR> can also be specified, but this is not required: as usual, these "
"events are always reported if they occur, regardless of whether they are "
"specified in I<events>.  Attempts to specify other values in I<events> yield "
"the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:300
msgid ""
"B<EPOLLEXCLUSIVE> may be used only in an B<EPOLL_CTL_ADD> operation; "
"attempts to employ it with B<EPOLL_CTL_MOD> yield an error.  If "
"B<EPOLLEXCLUSIVE> has been set using B<epoll_ctl>(), then a subsequent "
"B<EPOLL_CTL_MOD> on the same I<epfd>,\\ I<fd> pair yields an error.  A call "
"to B<epoll_ctl>()  that specifies B<EPOLLEXCLUSIVE> in I<events> and "
"specifies the target file descriptor I<fd> as an epoll instance will "
"likewise fail.  The error in all of these cases is B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:309
msgid ""
"The B<EPOLLEXCLUSIVE> flag is an input flag for the I<event.events> field "
"when calling B<epoll_ctl>(); it is never returned by B<epoll_wait>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:318
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:319 build/C/man2/epoll_wait.2:186
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:325
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:325
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:333
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:346
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:352
msgid ""
"An invalid event type was specified along with B<EPOLLEXCLUSIVE> in "
"I<events>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:361
msgid "I<op> was B<EPOLL_CTL_MOD> and I<events> included B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:371
msgid ""
"I<op> was B<EPOLL_CTL_MOD> and the B<EPOLLEXCLUSIVE> flag has previously "
"been applied to this I<epfd>,\\ I<fd> pair."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:379
msgid ""
"B<EPOLLEXCLUSIVE> was specified in I<event> and I<fd> refers to an epoll "
"instance."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:379
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:387
msgid ""
"I<fd> refers to an epoll instance and this B<EPOLL_CTL_ADD> operation would "
"result in a circular loop of epoll instances monitoring one another or a "
"nesting depth of epoll instances greater than 5."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:387
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:397
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:402
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:402
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:412
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:412
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:421
msgid ""
"The target file I<fd> does not support B<epoll>.  This error can occur if "
"I<fd> refers to, for example, a regular file or a directory."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_ctl.2:427
msgid ""
"B<epoll_ctl>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:430
msgid "B<epoll_ctl>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:435
msgid ""
"The B<epoll> interface supports all file descriptors that support "
"B<poll>(2)."
msgstr ""

#. type: SH
#: build/C/man2/epoll_ctl.2:435 build/C/man2/epoll_wait.2:255 build/C/man2/poll.2:476
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:449
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: build/C/man2/epoll_ctl.2:476
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the "
"B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently "
"ignored>.  This unfortunate behavior is necessary because no validity checks "
"were performed on the I<flags> argument in the original implementation, and "
"the addition of the B<EPOLLWAKEUP> with a check that caused the call to fail "
"if the caller did not have the B<CAP_BLOCK_SUSPEND> capability caused a "
"breakage in at least one existing user-space application that happened to "
"randomly (and uselessly) specify this bit.  A robust application should "
"therefore double check that it has the B<CAP_BLOCK_SUSPEND> capability if "
"attempting to use the B<EPOLLWAKEUP> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:481
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/epoll_wait.2:23
#, no-wrap
msgid "EPOLL_WAIT"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:26
msgid "epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:35
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:55
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The buffer pointed to "
"by I<events> is used to return information from the ready list about file "
"descriptors in the interest list that have some events available.  Up to "
"I<maxevents> are returned by B<epoll_wait>().  The I<maxevents> argument "
"must be greater than zero."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:64
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  Time is measured against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:68
msgid "A call to B<epoll_wait>()  will block until either:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:70
msgid "a file descriptor delivers an event;"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:72 build/C/man2/poll.2:141
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:74 build/C/man2/poll.2:143
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:89
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:93
msgid "The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:102
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:107
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:119
msgid ""
"The I<data> field of each returned I<epoll_event> structure contains the "
"same data as was specified in the most recent call to B<epoll_ctl>(2)  "
"(B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  for the corresponding open file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:128
msgid ""
"The I<events> field is a bit mask that indicates the events that have "
"occurred for the corresponding open file description.  See B<epoll_ctl>(2)  "
"for a list of the bits that may appear in this mask."
msgstr ""

#. type: SS
#: build/C/man2/epoll_wait.2:128
#, no-wrap
msgid "epoll_pwait()"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:142
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:146
msgid "The following B<epoll_pwait>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:150
#, no-wrap
msgid "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:156
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:160
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:164
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:173
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:185
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:190
msgid "I<epfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/epoll_wait.2:190 build/C/man2/poll.2:359
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:195
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr ""

#. type: TP
#: build/C/man2/epoll_wait.2:195 build/C/man2/poll.2:365
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:202
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:210
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_wait.2:216
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:220
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:223
msgid "B<epoll_wait>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:233
msgid ""
"While one thread is blocked in a call to B<epoll_wait>(), it is possible for "
"another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:245
msgid ""
"If more than I<maxevents> file descriptors are ready when B<epoll_wait>()  "
"is called, then successive B<epoll_wait>()  calls will round robin through "
"the set of ready file descriptors.  This behavior helps avoid starvation "
"scenarios, where a process fails to notice that additional file descriptors "
"are ready because it focuses on a set of file descriptors that are already "
"known to be ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:255
msgid ""
"Note that it is possible to call B<epoll_wait>()  on an B<epoll> instance "
"whose interest list is currently empty (or whose interest list becomes empty "
"because file descriptors are closed or removed from the interest in another "
"thread).  The call will block until some file descriptor is later added to "
"the interest list (in another thread) and that file descriptor becomes "
"ready."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:267
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where I<sizeof(long)> is 4 and the kernel I<HZ> value "
"is 1000, this means that timeouts greater than 35.79 minutes are treated as "
"infinity."
msgstr ""

#. type: SS
#: build/C/man2/epoll_wait.2:267 build/C/man2/poll.2:445
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:280
msgid ""
"The raw B<epoll_pwait>()  system call has a sixth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the I<sigmask> argument.  "
"The glibc B<epoll_pwait>()  wrapper function specifies this argument as a "
"fixed value (equal to I<sizeof(sigset_t)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:284
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/poll.2:30
#, no-wrap
msgid "POLL"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:33
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:36
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:38
#, no-wrap
msgid ""
"B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int "
">I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:45
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<,>\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t "
"*>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:56
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O.  The Linux-specific "
"B<epoll>(7)  API performs a similar task, but offers features beyond those "
"found in B<poll>()."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:60
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:68
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:75
msgid ""
"The caller should specify the number of items in the I<fds> array in "
"I<nfds>."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:91
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> "
"field.  Note, however, that this technique can't be used to ignore file "
"descriptor 0.)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:106
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:125
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:130
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:137
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:139
msgid "a file descriptor becomes ready;"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:157
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes B<poll>()  "
"to return immediately, even if no file descriptors are ready."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:163
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""

#. type: TP
#: build/C/man2/poll.2:163
#, no-wrap
msgid "B<POLLIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:166
msgid "There is data to read."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:166
#, no-wrap
msgid "B<POLLPRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:170
msgid ""
"There is some exceptional condition on the file descriptor.  Possibilities "
"include:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:174
msgid "There is out-of-band data on a TCP socket (see B<tcp>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:178
msgid ""
"A pseudoterminal master in packet mode has seen a state change on the slave "
"(see B<ioctl_tty>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:183
msgid "A I<cgroup.events> file has been modified (see B<cgroups>(7))."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:184
#, no-wrap
msgid "B<POLLOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:190
msgid ""
"Writing is now possible, though a write larger than the available space in a "
"socket or pipe will still block (unless B<O_NONBLOCK> is set)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:190
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:201
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:201
#, no-wrap
msgid "B<POLLERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:209
msgid ""
"Error condition (only returned in I<revents>; ignored in I<events>).  This "
"bit is also set for a file descriptor referring to the write end of a pipe "
"when the read end has been closed."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:209
#, no-wrap
msgid "B<POLLHUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:219
msgid ""
"Hang up (only returned in I<revents>; ignored in I<events>).  Note that when "
"reading from a channel such as a pipe or a stream socket, this event merely "
"indicates that the peer closed its end of the channel.  Subsequent reads "
"from the channel will return 0 (end of file)  only after all outstanding "
"data in the channel has been consumed."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:219
#, no-wrap
msgid "B<POLLNVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:227
msgid ""
"Invalid request: I<fd> not open (only returned in I<revents>; ignored in "
"I<events>)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:232
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""

#. type: TP
#: build/C/man2/poll.2:232
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:236
msgid "Equivalent to B<POLLIN>."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:236
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr ""

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: build/C/man2/poll.2:240
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:240
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:244
msgid "Equivalent to B<POLLOUT>."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:244
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:247
msgid "Priority data may be written."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:250
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr ""

#. type: SS
#: build/C/man2/poll.2:250
#, no-wrap
msgid "ppoll()"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:264
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:270
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:274
#, no-wrap
msgid "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:280
msgid "is nearly equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:285
#, no-wrap
msgid ""
"sigset_t origmask;\n"
"int timeout;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:291
#, no-wrap
msgid ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:304
msgid ""
"The above code segment is described as I<nearly> equivalent because whereas "
"a negative I<timeout> value for B<poll>()  is interpreted as an infinite "
"timeout, a negative value expressed in I<*tmo_p> results in an error from "
"B<ppoll>()."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:310
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:322
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:329
msgid ""
"The I<tmo_p> argument specifies an upper limit on the amount of time that "
"B<ppoll>()  will block.  This argument is a pointer to a structure of the "
"following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:336
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:344
msgid "If I<tmo_p> is specified as NULL, then B<ppoll>()  can block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:354
msgid ""
"On success, B<poll>()  returns a nonnegative value which is the number of "
"elements in the I<pollfds> whose I<revents> fields have been set to a "
"nonzero value (indicating an event or an error).  A return value of zero "
"indicates that the system call timed out before any file descriptors became "
"read."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:358
msgid ""
"On error, -1 is returned, and I<errno> is set to indicate the cause of the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:365
msgid ""
"I<fds> points outside the process's accessible address space.  The array "
"given as argument was not contained in the calling program's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:369
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:376
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:382
msgid "(B<ppoll>())  The timeout value expressed in I<*ip> is invalid (negative)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:385
msgid "Unable to allocate memory for kernel data structures."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:394
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc B<poll>()  wrapper function provides "
"emulation using B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:401
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""

#.  FIXME .
#.  ppoll() is proposed for inclusion in POSIX:
#.  https://www.austingroupbugs.net/view.php?id=1263
#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: build/C/man2/poll.2:410
msgid ""
"B<poll>()  conforms to POSIX.1-2001 and POSIX.1-2008.  B<ppoll>()  is "
"Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:418
msgid ""
"The operation of B<poll>()  and B<ppoll>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: build/C/man2/poll.2:432
msgid ""
"On some other UNIX systems, B<poll>()  can fail with the error B<EAGAIN> if "
"the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX permits this behavior.  Portable programs "
"may wish to check for B<EAGAIN> and loop, just as with B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:440
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:445
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:459
msgid ""
"The Linux B<ppoll>()  system call modifies its I<tmo_p> argument.  However, "
"the glibc wrapper function hides this behavior by using a local variable for "
"the timeout argument that is passed to the system call.  Thus, the glibc "
"B<ppoll>()  function does not modify its I<tmo_p> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:476
msgid ""
"The raw B<ppoll>()  system call has a fifth argument, I<size_t sigsetsize>, "
"which specifies the size in bytes of the I<sigmask> argument.  The glibc "
"B<ppoll>()  wrapper function specifies this argument as a fixed value (equal "
"to I<sizeof(kernel_sigset_t)>).  See B<sigprocmask>(2)  for a discussion on "
"the differences between the kernel and the libc notion of the sigset."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:480
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""

#. type: SH
#: build/C/man2/poll.2:480
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:489
msgid ""
"The program below opens each of the files named in its command-line "
"arguments and monitors the resulting file descriptors for readiness to read "
"(B<POLLIN>).  The program loops, repeatedly using B<poll>()  to monitor the "
"file descriptors, printing the number of ready file descriptors on return.  "
"For each ready file descriptor, the program:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:493
msgid "displays the returned I<revents> field in a human-readable form;"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:496
msgid ""
"if the file descriptor is readable, reads some data from it, and displays "
"that data on standard output; and"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:501
msgid ""
"if the file descriptors was not readable, but some other event occurred "
"(presumably B<POLLHUP>), closes the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:503
msgid "Suppose we run the program in one terminal, asking it to open a FIFO:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:508
#, no-wrap
msgid ""
"$ B<mkfifo myfifo>\n"
"$ B<./poll_input myfifo>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:513
msgid ""
"In a second terminal window, we then open the FIFO for writing, write some "
"data to it, and close the FIFO:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:517
#, no-wrap
msgid "$ B<echo aaaaabbbbbccccc E<gt> myfifo>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:521
msgid "In the terminal where we are running the program, we would then see:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:533
#, no-wrap
msgid ""
"Opened \"myfifo\" on fd 3\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 10 bytes: aaaaabbbbb\n"
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLIN POLLHUP\n"
"    read 6 bytes: ccccc\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:539
#, no-wrap
msgid ""
"About to poll()\n"
"Ready: 1\n"
"  fd=3; events: POLLHUP\n"
"    closing fd 3\n"
"All file descriptors closed; bye\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:545
msgid "In the above output, we see that B<poll>()  returned three times:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:554
msgid ""
"On the first return, the bits returned in the I<revents> field were "
"B<POLLIN>, indicating that the file descriptor is readable, and B<POLLHUP>, "
"indicating that the other end of the FIFO has been closed.  The program then "
"consumed some of the available input."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:562
msgid ""
"The second return from B<poll>()  also indicated B<POLLIN> and B<POLLHUP>; "
"the program then consumed the last of the available input."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:570
msgid ""
"On the final return, B<poll>()  indicated only B<POLLHUP> on the FIFO, at "
"which point the file descriptor was closed and the program terminated."
msgstr ""

#. type: SS
#: build/C/man2/poll.2:570
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:574
#, no-wrap
msgid "/* poll_input.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:583
#, no-wrap
msgid ""
"   Licensed under GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:586
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:592
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int nfds, num_open_fds;\n"
"    struct pollfd *pfds;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:597
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"       fprintf(stderr, \"Usage: %s file...\\en\", argv[0]);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:602
#, no-wrap
msgid ""
"    num_open_fds = nfds = argc - 1;\n"
"    pfds = calloc(nfds, sizeof(struct pollfd));\n"
"    if (pfds == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:604
#, no-wrap
msgid "    /* Open each file on command line, and add it \\(aqpfds\\(aq array */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:609
#, no-wrap
msgid ""
"    for (int j = 0; j E<lt> nfds; j++) {\n"
"        pfds[j].fd = open(argv[j + 1], O_RDONLY);\n"
"        if (pfds[j].fd == -1)\n"
"            errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:611
#, no-wrap
msgid ""
"        printf(\"Opened \\e\"%s\\e\" on fd %d\\en\", argv[j + 1], "
"pfds[j].fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:614
#, no-wrap
msgid ""
"        pfds[j].events = POLLIN;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:617
#, no-wrap
msgid ""
"    /* Keep calling poll() as long as at least one file descriptor is\n"
"       open */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:620
#, no-wrap
msgid ""
"    while (num_open_fds E<gt> 0) {\n"
"        int ready;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:625
#, no-wrap
msgid ""
"        printf(\"About to poll()\\en\");\n"
"        ready = poll(pfds, nfds, -1);\n"
"        if (ready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:627
#, no-wrap
msgid "        printf(\"Ready: %d\\en\", ready);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:629
#, no-wrap
msgid "        /* Deal with array returned by poll() */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:632
#, no-wrap
msgid ""
"        for (int j = 0; j E<lt> nfds; j++) {\n"
"            char buf[10];\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:638
#, no-wrap
msgid ""
"            if (pfds[j].revents != 0) {\n"
"                printf(\"  fd=%d; events: %s%s%s\\en\", pfds[j].fd,\n"
"                        (pfds[j].revents & POLLIN)  ? \"POLLIN \"  : \"\",\n"
"                        (pfds[j].revents & POLLHUP) ? \"POLLHUP \" : \"\",\n"
"                        (pfds[j].revents & POLLERR) ? \"POLLERR \" : "
"\"\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:654
#, no-wrap
msgid ""
"                if (pfds[j].revents & POLLIN) {\n"
"                    ssize_t s = read(pfds[j].fd, buf, sizeof(buf));\n"
"                    if (s == -1)\n"
"                        errExit(\"read\");\n"
"                    printf(\"    read %zd bytes: %.*s\\en\",\n"
"                            s, (int) s, buf);\n"
"                } else {                /* POLLERR | POLLHUP */\n"
"                    printf(\"    closing fd %d\\en\", pfds[j].fd);\n"
"                    if (close(pfds[j].fd) == -1)\n"
"                        errExit(\"close\");\n"
"                    num_open_fds--;\n"
"                }\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:658
#, no-wrap
msgid ""
"    printf(\"All file descriptors closed; bye\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:665
msgid ""
"B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), "
"B<time>(7)"
msgstr ""
