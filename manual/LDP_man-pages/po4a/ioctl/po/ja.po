# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-14 00:24+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/ioctl.2:41
#, no-wrap
msgid "IOCTL"
msgstr "IOCTL"

#. type: TH
#: build/C/man2/ioctl.2:41
#, no-wrap
msgid "2020-04-11"
msgstr ""

#. type: TH
#: build/C/man2/ioctl.2:41 build/C/man2/ioctl_console.2:40
#: build/C/man2/ioctl_fat.2:24 build/C/man2/ioctl_ficlonerange.2:23
#: build/C/man2/ioctl_fideduperange.2:23 build/C/man2/ioctl_fslabel.2:23
#: build/C/man2/ioctl_getfsmap.2:23 build/C/man2/ioctl_iflags.2:26
#: build/C/man2/ioctl_ns.2:26 build/C/man2/ioctl_tty.2:8
#: build/C/man2/ioctl_userfaultfd.2:28
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/ioctl.2:41 build/C/man2/ioctl_console.2:40
#: build/C/man2/ioctl_fat.2:24 build/C/man2/ioctl_ficlonerange.2:23
#: build/C/man2/ioctl_fideduperange.2:23 build/C/man2/ioctl_fslabel.2:23
#: build/C/man2/ioctl_getfsmap.2:23 build/C/man2/ioctl_iflags.2:26
#: build/C/man2/ioctl_ns.2:26 build/C/man2/ioctl_tty.2:8
#: build/C/man2/ioctl_userfaultfd.2:28
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/ioctl.2:42 build/C/man2/ioctl_console.2:41
#: build/C/man2/ioctl_fat.2:25 build/C/man2/ioctl_ficlonerange.2:24
#: build/C/man2/ioctl_fideduperange.2:24 build/C/man2/ioctl_fslabel.2:24
#: build/C/man2/ioctl_getfsmap.2:24 build/C/man2/ioctl_iflags.2:27
#: build/C/man2/ioctl_ns.2:27 build/C/man2/ioctl_tty.2:9
#: build/C/man2/ioctl_userfaultfd.2:29
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/ioctl.2:44
msgid "ioctl - control device"
msgstr "ioctl - デバイスを制御する"

#. type: SH
#: build/C/man2/ioctl.2:44 build/C/man2/ioctl_fat.2:27
#: build/C/man2/ioctl_ficlonerange.2:26 build/C/man2/ioctl_fideduperange.2:26
#: build/C/man2/ioctl_fslabel.2:26 build/C/man2/ioctl_getfsmap.2:26
#: build/C/man2/ioctl_tty.2:11 build/C/man2/ioctl_userfaultfd.2:32
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/ioctl.2:46 build/C/man2/ioctl_ficlonerange.2:28
#: build/C/man2/ioctl_fideduperange.2:28 build/C/man2/ioctl_fslabel.2:28
#: build/C/man2/ioctl_getfsmap.2:28
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#.  POSIX says 'request' is int, but glibc has the above
#.  See https://bugzilla.kernel.org/show_bug.cgi?id=42705
#. type: Plain text
#: build/C/man2/ioctl.2:50
msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: SH
#: build/C/man2/ioctl.2:50 build/C/man2/ioctl_console.2:43
#: build/C/man2/ioctl_fat.2:40 build/C/man2/ioctl_ficlonerange.2:34
#: build/C/man2/ioctl_fideduperange.2:32 build/C/man2/ioctl_fslabel.2:34
#: build/C/man2/ioctl_getfsmap.2:34 build/C/man2/ioctl_iflags.2:29
#: build/C/man2/ioctl_ns.2:29 build/C/man2/ioctl_tty.2:15
#: build/C/man2/ioctl_userfaultfd.2:38
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/ioctl.2:61
#, fuzzy
#| msgid ""
#| "The B<ioctl>()  function manipulates the underlying device parameters of "
#| "special files.  In particular, many operating characteristics of "
#| "character special files (e.g., terminals) may be controlled with "
#| "B<ioctl>()  requests.  The argument I<fd> must be an open file descriptor."
msgid ""
"The B<ioctl>()  system call manipulates the underlying device parameters of "
"special files.  In particular, many operating characteristics of character "
"special files (e.g., terminals) may be controlled with B<ioctl>()  "
"requests.  The argument I<fd> must be an open file descriptor."
msgstr ""
"B<ioctl>()  関数はスペシャルファイルを構成するデバイスのパラメーターを 操作す"
"る。特に、キャラクター型のスペシャルファイル (例えば端末 (terminal))  の多く"
"の動作特性を B<ioctl>()  リクエストによって制御することができる。引数 "
"I<fd> はオープンされたファイルディスクリプターでなければならない。"

#. type: Plain text
#: build/C/man2/ioctl.2:69
msgid ""
"The second argument is a device-dependent request code.  The third argument "
"is an untyped pointer to memory.  It's traditionally B<char *>I<argp> (from "
"the days before B<void *> was valid C), and will be so named for this "
"discussion."
msgstr ""
"2 番目の引数は、デバイス依存のリクエストコードである。 3 番目の引数は、メ"
"モリーへの型を指定しないポインターである。 この引数は伝統的に (C で B<void "
"*> という書き方が有効になる前から)  B<char *>I<argp> と表記されている。した"
"がって、この文章でもそう名付けることとする。"

#. type: Plain text
#: build/C/man2/ioctl.2:86
#, fuzzy
#| msgid ""
#| "An B<ioctl>()  I<request> has encoded in it whether the argument is an "
#| "I<in> parameter or I<out> parameter, and the size of the argument I<argp> "
#| "in bytes.  Macros and defines used in specifying an B<ioctl>()  "
#| "I<request> are located in the file I<E<lt>sys/ioctl.hE<gt>>."
msgid ""
"An B<ioctl>()  I<request> has encoded in it whether the argument is an I<in> "
"parameter or I<out> parameter, and the size of the argument I<argp> in "
"bytes.  Macros and defines used in specifying an B<ioctl>()  I<request> are "
"located in the file I<E<lt>sys/ioctl.hE<gt>>.  See NOTES."
msgstr ""
"B<ioctl>()  の I<request> には、 その引数が I<入力> パラメーターと I<出力> "
"パラメーターのどちらであるかの区別や、 I<argp> 引数のバイト単位のサイズ、と"
"いった情報がエンコードされている。 B<ioctl>()  の I<request> を指定するための"
"マクロ (macro) と定義は I<E<lt>sys/ioctl.hE<gt>> ファイルにある。"

#. type: SH
#: build/C/man2/ioctl.2:86 build/C/man2/ioctl_console.2:803
#: build/C/man2/ioctl_fat.2:189 build/C/man2/ioctl_ficlonerange.2:84
#: build/C/man2/ioctl_fideduperange.2:144 build/C/man2/ioctl_fslabel.2:45
#: build/C/man2/ioctl_getfsmap.2:321 build/C/man2/ioctl_tty.2:533
#: build/C/man2/ioctl_userfaultfd.2:652
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/ioctl.2:95
msgid ""
"Usually, on success zero is returned.  A few B<ioctl>()  requests use the "
"return value as an output parameter and return a nonnegative value on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"たいていの場合、成功するとゼロが返される。 ただし、 B<ioctl>()  リクエストの"
"中にはパラメーターの出力に返り値を使用しているものが若干あり、 その場合は、成"
"功したときに非負の値が返される。 エラーの場合は -1 が返され、 I<errno> が適切"
"に設定される。"

#. type: SH
#: build/C/man2/ioctl.2:95 build/C/man2/ioctl_console.2:808
#: build/C/man2/ioctl_fat.2:200 build/C/man2/ioctl_ficlonerange.2:88
#: build/C/man2/ioctl_fideduperange.2:148 build/C/man2/ioctl_fslabel.2:49
#: build/C/man2/ioctl_getfsmap.2:325 build/C/man2/ioctl_ns.2:177
#: build/C/man2/ioctl_tty.2:540 build/C/man2/ioctl_userfaultfd.2:654
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/ioctl.2:96 build/C/man2/ioctl_console.2:811
#: build/C/man2/ioctl_ficlonerange.2:90 build/C/man2/ioctl_fideduperange.2:150
#: build/C/man2/ioctl_getfsmap.2:329
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/ioctl.2:100
#, fuzzy
#| msgid "I<fd> is not a valid descriptor."
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が無効なディスクリプターである。"

#. type: TP
#: build/C/man2/ioctl.2:100 build/C/man2/ioctl_fslabel.2:51
#: build/C/man2/ioctl_getfsmap.2:336 build/C/man2/ioctl_userfaultfd.2:240
#: build/C/man2/ioctl_userfaultfd.2:344 build/C/man2/ioctl_userfaultfd.2:658
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/ioctl.2:104
msgid "I<argp> references an inaccessible memory area."
msgstr "I<argp> がアクセス不可能なメモリーを参照している。"

#. type: TP
#: build/C/man2/ioctl.2:104 build/C/man2/ioctl_console.2:814
#: build/C/man2/ioctl_ficlonerange.2:99 build/C/man2/ioctl_fideduperange.2:159
#: build/C/man2/ioctl_fslabel.2:55 build/C/man2/ioctl_getfsmap.2:339
#: build/C/man2/ioctl_ns.2:111 build/C/man2/ioctl_ns.2:173
#: build/C/man2/ioctl_tty.2:541 build/C/man2/ioctl_userfaultfd.2:245
#: build/C/man2/ioctl_userfaultfd.2:250 build/C/man2/ioctl_userfaultfd.2:349
#: build/C/man2/ioctl_userfaultfd.2:356 build/C/man2/ioctl_userfaultfd.2:359
#: build/C/man2/ioctl_userfaultfd.2:367 build/C/man2/ioctl_userfaultfd.2:391
#: build/C/man2/ioctl_userfaultfd.2:402 build/C/man2/ioctl_userfaultfd.2:405
#: build/C/man2/ioctl_userfaultfd.2:479 build/C/man2/ioctl_userfaultfd.2:494
#: build/C/man2/ioctl_userfaultfd.2:583 build/C/man2/ioctl_userfaultfd.2:592
#: build/C/man2/ioctl_userfaultfd.2:641 build/C/man2/ioctl_userfaultfd.2:662
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/ioctl.2:110
msgid "I<request> or I<argp> is not valid."
msgstr "I<request> または I<argp> が不正である。"

#. type: TP
#: build/C/man2/ioctl.2:110 build/C/man2/ioctl.2:114
#: build/C/man2/ioctl_console.2:819 build/C/man2/ioctl_fat.2:219
#: build/C/man2/ioctl_fslabel.2:58 build/C/man2/ioctl_ns.2:104
#: build/C/man2/ioctl_ns.2:181 build/C/man2/ioctl_tty.2:547
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl.2:114
msgid "I<fd> is not associated with a character special device."
msgstr "I<fd> がキャラクター型のスペシャルデバイスを参照していない。"

#. type: Plain text
#: build/C/man2/ioctl.2:120
#, fuzzy
#| msgid ""
#| "The specified request does not apply to the kind of object that the "
#| "descriptor I<fd> references."
msgid ""
"The specified request does not apply to the kind of object that the file "
"descriptor I<fd> references."
msgstr ""
"指定されたリクエストはディスクリプター I<fd> が参照する種類のオブジェクトには"
"適用することができない。"

#. type: SH
#: build/C/man2/ioctl.2:120 build/C/man2/ioctl_fat.2:244
#: build/C/man2/ioctl_ficlonerange.2:135 build/C/man2/ioctl_fideduperange.2:200
#: build/C/man2/ioctl_fslabel.2:73 build/C/man2/ioctl_getfsmap.2:358
#: build/C/man2/ioctl_iflags.2:193 build/C/man2/ioctl_ns.2:187
#: build/C/man2/ioctl_userfaultfd.2:669
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/ioctl.2:127
#, fuzzy
#| msgid ""
#| "No single standard.  Arguments, returns, and semantics of B<ioctl>()  "
#| "vary according to the device driver in question (the call is used as a "
#| "catch-all for operations that don't cleanly fit the UNIX stream I/O "
#| "model).  See B<ioctl_list>(2)  for a list of many of the known "
#| "B<ioctl>()  calls.  The B<ioctl>()  function call appeared in Version 7 "
#| "AT&T UNIX."
msgid ""
"No single standard.  Arguments, returns, and semantics of B<ioctl>()  vary "
"according to the device driver in question (the call is used as a catch-all "
"for operations that don't cleanly fit the UNIX stream I/O model)."
msgstr ""
"どれか一つの標準に対応しているわけではない。 B<ioctl>()  の引数、返り値、解"
"釈は、処理対象のデバイスドライバごとに 異なる (この関数は UNIX の ストリーム "
"I/O モデル に きちんと適合していない操作のための便利屋として使用される)。 よ"
"く知られている B<ioctl>()  のリストについては B<ioctl_list>(2)  を参照するこ"
"と。 B<ioctl>()  関数コールは Version 7 AT&T UNIX で登場した。"

#. type: Plain text
#: build/C/man2/ioctl.2:131
msgid "The B<ioctl>()  system call appeared in Version 7 AT&T UNIX."
msgstr ""

#. type: SH
#: build/C/man2/ioctl.2:131 build/C/man2/ioctl_console.2:826
#: build/C/man2/ioctl_ficlonerange.2:137 build/C/man2/ioctl_fideduperange.2:202
#: build/C/man2/ioctl_fslabel.2:75 build/C/man2/ioctl_iflags.2:195
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/ioctl.2:140
msgid ""
"In order to use this call, one needs an open file descriptor.  Often the "
"B<open>(2)  call has unwanted side effects, that can be avoided under Linux "
"by giving it the B<O_NONBLOCK> flag."
msgstr ""
"このシステムコールを使うには、オープンされたファイルディスクリプターが 必要で"
"ある。 B<open>(2)  コールはしばしば望んでいない副作用を伴うことがあるが、"
"Linux では B<open>(2)  に B<O_NONBLOCK> フラグをつけることでこの副作用を避け"
"ることができる。"

#. type: SS
#: build/C/man2/ioctl.2:140
#, no-wrap
msgid "ioctl structure"
msgstr ""

#.  added two sections - aeb
#. type: Plain text
#: build/C/man2/ioctl.2:145
msgid ""
"Ioctl command values are 32-bit constants.  In principle these constants are "
"completely arbitrary, but people have tried to build some structure into "
"them."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl.2:164
msgid ""
"The old Linux situation was that of mostly 16-bit constants, where the last "
"byte is a serial number, and the preceding byte(s) give a type indicating "
"the driver.  Sometimes the major number was used: 0x03 for the B<HDIO_*> "
"ioctls, 0x06 for the B<LP*> ioctls.  And sometimes one or more ASCII letters "
"were used.  For example, B<TCGETS> has value 0x00005401, with 0x54 = \\(aqT"
"\\(aq indicating the terminal driver, and B<CYGETTIMEOUT> has value "
"0x00435906, with 0x43 0x59 = \\(aqC\\(aq \\(aqY\\(aq indicating the cyclades "
"driver."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl.2:172
msgid ""
"Later (0.98p5) some more information was built into the number.  One has 2 "
"direction bits (00: none, 01: write, 10: read, 11: read/write)  followed by "
"14 size bits (giving the size of the argument), followed by an 8-bit type "
"(collecting the ioctls in groups for a common purpose or a common driver), "
"and an 8-bit serial number."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl.2:183
msgid ""
"The macros describing this structure live in I<E<lt>asm/ioctl.hE<gt>> and "
"are B<_IO(type,nr)> and B<{_IOR,_IOW,_IOWR}(type,nr,size)>.  They use "
"I<sizeof(size)> so that size is a misnomer here: this third argument is a "
"data type."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl.2:188
msgid ""
"Note that the size bits are very unreliable: in lots of cases they are "
"wrong, either because of buggy macros using I<sizeof(sizeof(struct))>, or "
"because of legacy values."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl.2:192
msgid ""
"Thus, it seems that the new structure only gave disadvantages: it does not "
"help in checking, but it causes varying values for the various architectures."
msgstr ""

#. type: SH
#: build/C/man2/ioctl.2:192 build/C/man2/ioctl_console.2:848
#: build/C/man2/ioctl_fat.2:501 build/C/man2/ioctl_ficlonerange.2:142
#: build/C/man2/ioctl_fideduperange.2:210 build/C/man2/ioctl_fslabel.2:85
#: build/C/man2/ioctl_getfsmap.2:367 build/C/man2/ioctl_iflags.2:214
#: build/C/man2/ioctl_ns.2:361 build/C/man2/ioctl_tty.2:576
#: build/C/man2/ioctl_userfaultfd.2:685
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#.  .BR mt (4),
#. type: Plain text
#: build/C/man2/ioctl.2:209
msgid ""
"B<execve>(2), B<fcntl>(2), B<ioctl_console>(2), B<ioctl_fat>(2), "
"B<ioctl_ficlonerange>(2), B<ioctl_fideduperange>(2), B<ioctl_fslabel>(2), "
"B<ioctl_getfsmap>(2), B<ioctl_iflags>(2), B<ioctl_ns>(2), B<ioctl_tty>(2), "
"B<ioctl_userfaultfd>(2), B<open>(2), B<sd>(4), B<tty>(4)"
msgstr ""

#. type: SH
#: build/C/man2/ioctl.2:209 build/C/man2/ioctl_console.2:874
#: build/C/man2/ioctl_fat.2:503 build/C/man2/ioctl_ficlonerange.2:144
#: build/C/man2/ioctl_fideduperange.2:212 build/C/man2/ioctl_fslabel.2:88
#: build/C/man2/ioctl_getfsmap.2:369 build/C/man2/ioctl_iflags.2:223
#: build/C/man2/ioctl_ns.2:366 build/C/man2/ioctl_tty.2:596
#: build/C/man2/ioctl_userfaultfd.2:692
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/ioctl.2:217 build/C/man2/ioctl_console.2:882
#: build/C/man2/ioctl_fat.2:511 build/C/man2/ioctl_ficlonerange.2:152
#: build/C/man2/ioctl_fideduperange.2:220 build/C/man2/ioctl_fslabel.2:96
#: build/C/man2/ioctl_getfsmap.2:377 build/C/man2/ioctl_iflags.2:231
#: build/C/man2/ioctl_ns.2:374 build/C/man2/ioctl_tty.2:604
#: build/C/man2/ioctl_userfaultfd.2:700
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/ioctl_console.2:40
#, no-wrap
msgid "IOCTL_CONSOLE"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_console.2:40 build/C/man2/ioctl_ficlonerange.2:23
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:43
msgid "ioctl_console - ioctls for console terminal and virtual consoles"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:49
msgid ""
"The following Linux-specific B<ioctl>(2)  requests are supported for console "
"terminals and virtual consoles.  Each requires a third argument, assumed "
"here to be I<argp>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:49
#, no-wrap
msgid "B<KDGETLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:59
msgid ""
"Get state of LEDs.  I<argp> points to a I<char>.  The lower three bits of "
"I<*argp> are set to the state of the LEDs, as follows:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:61
#, no-wrap
msgid "LED_CAP "
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:61 build/C/man2/ioctl_console.2:398
#, no-wrap
msgid "0x04"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:61
#, no-wrap
msgid "caps lock led"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:62
#, no-wrap
msgid "LED_NUM "
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:62
#, no-wrap
msgid "0x02"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:62
#, no-wrap
msgid "num lock led"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:63
#, no-wrap
msgid "LED_SCR "
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:63 build/C/man2/ioctl_console.2:131
#, no-wrap
msgid "0x01"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:63
#, no-wrap
msgid "scroll lock led"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:65
#, no-wrap
msgid "B<KDSETLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:74
msgid ""
"Set the LEDs.  The LEDs are set to correspond to the lower three bits of the "
"unsigned long integer in I<argp>.  However, if a higher order bit is set, "
"the LEDs revert to normal: displaying the state of the keyboard functions of "
"caps lock, num lock, and scroll lock."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:81
msgid ""
"Before Linux 1.1.54, the LEDs just reflected the state of the corresponding "
"keyboard flags, and KDGETLED/KDSETLED would also change the keyboard flags.  "
"Since Linux 1.1.54 the LEDs can be made to display arbitrary information, "
"but by default they display the keyboard flags.  The following two ioctls "
"are used to access the keyboard flags."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:81
#, no-wrap
msgid "B<KDGKBLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:90
msgid ""
"Get keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> "
"points to a char which is set to the flag state.  The low order three bits "
"(mask 0x7) get the current flag state, and the low order bits of the next "
"nibble (mask 0x70) get the default flag state.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:90
#, no-wrap
msgid "B<KDSKBLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:99
msgid ""
"Set keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> is "
"an unsigned long integer that has the desired flag state.  The low order "
"three bits (mask 0x7) have the flag state, and the low order bits of the "
"next nibble (mask 0x70) have the default flag state.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:99
#, no-wrap
msgid "B<KDGKBTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:103
msgid "Get keyboard type.  This returns the value KB_101, defined as 0x02."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:103
#, no-wrap
msgid "B<KDADDIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:108
msgid "Add I/O port as valid.  Equivalent to I<ioperm(arg,1,1)>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:108
#, no-wrap
msgid "B<KDDELIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:113
msgid "Delete I/O port as valid.  Equivalent to I<ioperm(arg,1,0)>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:113
#, no-wrap
msgid "B<KDENABIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:118
msgid ""
"Enable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, 1)>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:118
#, no-wrap
msgid "B<KDDISABIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:123
msgid ""
"Disable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, "
"0)>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:123
#, no-wrap
msgid "B<KDSETMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:128
msgid ""
"Set text/graphics mode.  I<argp> is an unsigned integer containing one of:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:130
#, no-wrap
msgid "KD_TEXT"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:130
#, no-wrap
msgid "0x00"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:131
#, no-wrap
msgid "KD_GRAPHICS"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:133
#, no-wrap
msgid "B<KDGETMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:142
msgid ""
"Get text/graphics mode.  I<argp> points to an I<int> which is set to one of "
"the values shown above for B<KDSETMODE>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:142
#, no-wrap
msgid "B<KDMKTONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:156
msgid ""
"Generate tone of specified length.  The lower 16 bits of the unsigned long "
"integer in I<argp> specify the period in clock cycles, and the upper 16 bits "
"give the duration in msec.  If the duration is zero, the sound is turned "
"off.  Control returns immediately.  For example, I<argp> = (125E<lt>E<lt>16) "
"+ 0x637 would specify the beep normally associated with a ctrl-G.  (Thus "
"since Linux 0.99pl1; broken in Linux 2.1.49-50.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:156
#, no-wrap
msgid "B<KIOCSOUND>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:168
msgid ""
"Start or stop sound generation.  The lower 16 bits of I<argp> specify the "
"period in clock cycles (that is, I<argp> = 1193180/frequency).  I<argp> = 0 "
"turns sound off.  In either case, control returns immediately."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:168
#, no-wrap
msgid "B<GIO_CMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:175
msgid ""
"Get the current default color map from kernel.  I<argp> points to a 48-byte "
"array.  (Since Linux 1.3.3.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:175
#, no-wrap
msgid "B<PIO_CMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:188
msgid ""
"Change the default text-mode color map.  I<argp> points to a 48-byte array "
"which contains, in order, the Red, Green, and Blue values for the 16 "
"available screen colors: 0 is off, and 255 is full intensity.  The default "
"colors are, in order: black, dark red, dark green, brown, dark blue, dark "
"purple, dark cyan, light grey, dark grey, bright red, bright green, yellow, "
"bright blue, bright purple, bright cyan and white.  (Since Linux 1.3.3.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:188
#, no-wrap
msgid "B<GIO_FONT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:198
msgid ""
"Gets 256-character screen font in expanded form.  I<argp> points to an 8192-"
"byte array.  Fails with error code B<EINVAL> if the currently loaded font is "
"a 512-character font, or if the console is not in text mode."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:198
#, no-wrap
msgid "B<GIO_FONTX>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:226
msgid ""
"Gets screen font and associated information.  I<argp> points to a I<struct "
"consolefontdesc> (see B<PIO_FONTX>).  On call, the I<charcount> field should "
"be set to the maximum number of characters that would fit in the buffer "
"pointed to by I<chardata>.  On return, the I<charcount> and I<charheight> "
"are filled with the respective data for the currently loaded font, and the "
"I<chardata> array contains the font data if the initial value of "
"I<charcount> indicated enough space was available; otherwise the buffer is "
"untouched and I<errno> is set to B<ENOMEM>.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:226
#, no-wrap
msgid "B<PIO_FONT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:241
msgid ""
"Sets 256-character screen font.  Load font into the EGA/VGA character "
"generator.  I<argp> points to an 8192-byte map, with 32 bytes per "
"character.  Only the first I<N> of them are used for an 8xI<N> font (0 E<lt> "
"I<N> E<lt>= 32).  This call also invalidates the Unicode mapping."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:241
#, no-wrap
msgid "B<PIO_FONTX>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:246
msgid ""
"Sets screen font and associated rendering information.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:257
#, no-wrap
msgid ""
"struct consolefontdesc {\n"
"    unsigned short charcount;  /* characters in font\n"
"                                  (256 or 512) */\n"
"    unsigned short charheight; /* scan lines per\n"
"                                  character (1-32) */\n"
"    char          *chardata;   /* font data in\n"
"                                  expanded form */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:265
msgid ""
"If necessary, the screen will be appropriately resized, and B<SIGWINCH> sent "
"to the appropriate processes.  This call also invalidates the Unicode "
"mapping.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:265
#, no-wrap
msgid "B<PIO_FONTRESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:273
msgid ""
"Resets the screen font, size and Unicode mapping to the bootup defaults.  "
"I<argp> is unused, but should be set to NULL to ensure compatibility with "
"future versions of Linux.  (Since Linux 1.3.28.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:273
#, no-wrap
msgid "B<GIO_SCRNMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:282
msgid ""
"Get screen mapping from kernel.  I<argp> points to an area of size E_TABSZ, "
"which is loaded with the font positions used to display each character.  "
"This call is likely to return useless information if the currently loaded "
"font is more than 256 characters."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:282
#, no-wrap
msgid "B<GIO_UNISCRNMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:294
msgid ""
"Get full Unicode screen mapping from kernel.  I<argp> points to an area of "
"size I<E_TABSZ*sizeof(unsigned short)>, which is loaded with the Unicodes "
"each character represent.  A special set of Unicodes, starting at U+F000, "
"are used to represent \"direct to font\" mappings.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:294
#, no-wrap
msgid "B<PIO_SCRNMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:301
msgid ""
"Loads the \"user definable\" (fourth) table in the kernel which maps bytes "
"into console screen symbols.  I<argp> points to an area of size E_TABSZ."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:301
#, no-wrap
msgid "B<PIO_UNISCRNMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:309
msgid ""
"Loads the \"user definable\" (fourth) table in the kernel which maps bytes "
"into Unicodes, which are then translated into screen symbols according to "
"the currently loaded Unicode-to-font map.  Special Unicodes starting at U"
"+F000 can be used to map directly to the font symbols.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:309
#, no-wrap
msgid "B<GIO_UNIMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:314
msgid "Get Unicode-to-font mapping from kernel.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:321
#, no-wrap
msgid ""
"struct unimapdesc {\n"
"    unsigned short  entry_ct;\n"
"    struct unipair *entries;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:327
msgid "where I<entries> points to an array of"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:334
#, no-wrap
msgid ""
"struct unipair {\n"
"    unsigned short unicode;\n"
"    unsigned short fontpos;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:338 build/C/man2/ioctl_console.2:362
msgid "(Since Linux 1.1.92.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:338
#, no-wrap
msgid "B<PIO_UNIMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:345
msgid ""
"Put unicode-to-font mapping in kernel.  I<argp> points to a I<struct "
"unimapdesc>.  (Since Linux 1.1.92)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:345
#, no-wrap
msgid "B<PIO_UNIMAPCLR>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:350
msgid "Clear table, possibly advise hash algorithm.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:358
#, no-wrap
msgid ""
"struct unimapinit {\n"
"    unsigned short advised_hashsize;  /* 0 if no opinion */\n"
"    unsigned short advised_hashstep;  /* 0 if no opinion */\n"
"    unsigned short advised_hashlevel; /* 0 if no opinion */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:362
#, no-wrap
msgid "B<KDGKBMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:370
msgid ""
"Gets current keyboard mode.  I<argp> points to a I<long> which is set to one "
"of these:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:372
#, no-wrap
msgid "K_RAW"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:372
#, no-wrap
msgid "0x00  /* Raw (scancode) mode */"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:373
#, no-wrap
msgid "K_XLATE"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:373
#, no-wrap
msgid "0x01  /* Translate keycodes using keymap */"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:374
#, no-wrap
msgid "K_MEDIUMRAW"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:374
#, no-wrap
msgid "0x02  /* Medium raw (scancode) mode */"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:375
#, no-wrap
msgid "K_UNICODE"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:375
#, no-wrap
msgid "0x03  /* Unicode mode */"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:376
#, no-wrap
msgid "K_OFF"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:376
#, no-wrap
msgid "0x04  /* Disabled mode; since Linux 2.6.39 */"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:379
#, no-wrap
msgid "B<KDSKBMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:387
msgid ""
"Sets current keyboard mode.  I<argp> is a I<long> equal to one of the values "
"shown for B<KDGKBMODE>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:387
#, no-wrap
msgid "B<KDGKBMETA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:395
msgid ""
"Gets meta key handling mode.  I<argp> points to a I<long> which is set to "
"one of these:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:397
#, no-wrap
msgid "K_METABIT"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:397
#, no-wrap
msgid "0x03"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:397
#, no-wrap
msgid "set high order bit"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:398
#, no-wrap
msgid "K_ESCPREFIX"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:398
#, no-wrap
msgid "escape prefix"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:400
#, no-wrap
msgid "B<KDSKBMETA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:408
msgid ""
"Sets meta key handling mode.  I<argp> is a I<long> equal to one of the "
"values shown above for B<KDGKBMETA>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:408
#, no-wrap
msgid "B<KDGKBENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:413
msgid ""
"Gets one entry in key translation table (keycode to action code).  I<argp> "
"points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:421
#, no-wrap
msgid ""
"struct kbentry {\n"
"    unsigned char  kb_table;\n"
"    unsigned char  kb_index;\n"
"    unsigned short kb_value;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:440
msgid ""
"with the first two members filled in: I<kb_table> selects the key table (0 "
"E<lt>= I<kb_table> E<lt> MAX_NR_KEYMAPS), and I<kb_index> is the keycode (0 "
"E<lt>= I<kb_index> E<lt> NR_KEYS).  I<kb_value> is set to the corresponding "
"action code, or K_HOLE if there is no such key, or K_NOSUCHMAP if "
"I<kb_table> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:440
#, no-wrap
msgid "B<KDSKBENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:446
msgid ""
"Sets one entry in translation table.  I<argp> points to a I<struct kbentry>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:446
#, no-wrap
msgid "B<KDGKBSENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:451
msgid "Gets one function key string.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:458
#, no-wrap
msgid ""
"struct kbsentry {\n"
"    unsigned char kb_func;\n"
"    unsigned char kb_string[512];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:466
msgid ""
"I<kb_string> is set to the (null-terminated) string corresponding to the "
"I<kb_func>th function key action code."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:466
#, no-wrap
msgid "B<KDSKBSENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:472
msgid ""
"Sets one function key string entry.  I<argp> points to a I<struct kbsentry>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:472
#, no-wrap
msgid "B<KDGKBDIACR>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:477
msgid "Read kernel accent table.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:484
#, no-wrap
msgid ""
"struct kbdiacrs {\n"
"    unsigned int   kb_cnt;\n"
"    struct kbdiacr kbdiacr[256];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:491
msgid ""
"where I<kb_cnt> is the number of entries in the array, each of which is a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:499
#, no-wrap
msgid ""
"struct kbdiacr {\n"
"    unsigned char diacr;\n"
"    unsigned char base;\n"
"    unsigned char result;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:501
#, no-wrap
msgid "B<KDGETKEYCODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:506
msgid ""
"Read kernel keycode table entry (scan code to keycode).  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:513
#, no-wrap
msgid ""
"struct kbkeycode {\n"
"    unsigned int scancode;\n"
"    unsigned int keycode;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:527
msgid ""
"I<keycode> is set to correspond to the given I<scancode>.  (89 E<lt>= "
"I<scancode> E<lt>= 255 only.  For 1 E<lt>= I<scancode> E<lt>= 88, "
"I<keycode>==I<scancode>.)  (Since Linux 1.1.63.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:527
#, no-wrap
msgid "B<KDSETKEYCODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:534
msgid ""
"Write kernel keycode table entry.  I<argp> points to a I<struct kbkeycode>.  "
"(Since Linux 1.1.63.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:534
#, no-wrap
msgid "B<KDSIGACCEPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:546
msgid ""
"The calling process indicates its willingness to accept the signal I<argp> "
"when it is generated by pressing an appropriate key combination.  (1 E<lt>= "
"I<argp> E<lt>= NSIG).  (See I<spawn_console>()  in I<linux/drivers/char/"
"keyboard.c>.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:546
#, no-wrap
msgid "B<VT_OPENQRY>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:556
msgid ""
"Returns the first available (non-opened) console.  I<argp> points to an "
"I<int> which is set to the number of the vt (1 E<lt>= I<*argp> E<lt>= "
"MAX_NR_CONSOLES)."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:556
#, no-wrap
msgid "B<VT_GETMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:561
msgid "Get mode of active vt.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:571
#, no-wrap
msgid ""
"struct vt_mode {\n"
"    char  mode;    /* vt mode */\n"
"    char  waitv;   /* if set, hang on writes if not active */\n"
"    short relsig;  /* signal to raise on release req */\n"
"    short acqsig;  /* signal to raise on acquisition */\n"
"    short frsig;   /* unused (set to 0) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:577
msgid ""
"which is set to the mode of the active vt.  I<mode> is set to one of these "
"values:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:579
#, no-wrap
msgid "VT_AUTO"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:579
#, no-wrap
msgid "auto vt switching"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:580
#, no-wrap
msgid "VT_PROCESS"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:580
#, no-wrap
msgid "process controls switching"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:581
#, no-wrap
msgid "VT_ACKACQ"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_console.2:581
#, no-wrap
msgid "acknowledge switch"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:583
#, no-wrap
msgid "B<VT_SETMODE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:589
msgid "Set mode of active vt.  I<argp> points to a I<struct vt_mode>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:589
#, no-wrap
msgid "B<VT_GETSTATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:594
msgid "Get global vt state info.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:602
#, no-wrap
msgid ""
"struct vt_stat {\n"
"    unsigned short v_active;  /* active vt */\n"
"    unsigned short v_signal;  /* signal to send */\n"
"    unsigned short v_state;   /* vt bit mask */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:609
msgid ""
"For each vt in use, the corresponding bit in the I<v_state> member is set.  "
"(Kernels 1.0 through 1.1.92.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:609
#, no-wrap
msgid "B<VT_RELDISP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:612
msgid "Release a display."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:612
#, no-wrap
msgid "B<VT_ACTIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:619
msgid "Switch to vt I<argp> (1 E<lt>= I<argp> E<lt>= MAX_NR_CONSOLES)."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:619
#, no-wrap
msgid "B<VT_WAITACTIVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:624
msgid "Wait until vt I<argp> has been activated."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:624
#, no-wrap
msgid "B<VT_DISALLOCATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:629
msgid ""
"Deallocate the memory associated with vt I<argp>.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:629
#, no-wrap
msgid "B<VT_RESIZE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:634
msgid "Set the kernel's idea of screensize.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:642
#, no-wrap
msgid ""
"struct vt_sizes {\n"
"    unsigned short v_rows;       /* # rows */\n"
"    unsigned short v_cols;       /* # columns */\n"
"    unsigned short v_scrollsize; /* no longer used */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:649
msgid ""
"Note that this does not change the videomode.  See B<resizecons>(8).  (Since "
"Linux 1.1.54.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:649
#, no-wrap
msgid "B<VT_RESIZEX>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:654
msgid ""
"Set the kernel's idea of various screen parameters.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:669
#, no-wrap
msgid ""
"struct vt_consize {\n"
"    unsigned short v_rows;  /* number of rows */\n"
"    unsigned short v_cols;  /* number of columns */\n"
"    unsigned short v_vlin;  /* number of pixel rows\n"
"                               on screen */\n"
"    unsigned short v_clin;  /* number of pixel rows\n"
"                               per character */\n"
"    unsigned short v_vcol;  /* number of pixel columns\n"
"                               on screen */\n"
"    unsigned short v_ccol;  /* number of pixel columns\n"
"                               per character */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:678
msgid ""
"Any parameter may be set to zero, indicating \"no change\", but if multiple "
"parameters are set, they must be self-consistent.  Note that this does not "
"change the videomode.  See B<resizecons>(8).  (Since Linux 1.3.3.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:685
msgid ""
"The action of the following ioctls depends on the first byte in the struct "
"pointed to by I<argp>, referred to here as the I<subcode>.  These are legal "
"only for the superuser or the owner of the current terminal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:685
#, no-wrap
msgid "B<TIOCLINUX, subcode=0>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:693
msgid ""
"Dump the screen.  Disappeared in Linux 1.1.92.  (With kernel 1.1.92 or "
"later, read from I</dev/vcsN> or I</dev/vcsaN> instead.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:693
#, no-wrap
msgid "B<TIOCLINUX, subcode=1>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:697
msgid "Get task information.  Disappeared in Linux 1.1.92."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:697
#, no-wrap
msgid "B<TIOCLINUX, subcode=2>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:702
msgid "Set selection.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:710
#, no-wrap
msgid ""
"struct {\n"
"    char  subcode;\n"
"    short xs, ys, xe, ye;\n"
"    short sel_mode;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:730
msgid ""
"I<xs> and I<ys> are the starting column and row.  I<xe> and I<ye> are the "
"ending column and row.  (Upper left corner is row=column=1.)  I<sel_mode> is "
"0 for character-by-character selection, 1 for word-by-word selection, or 2 "
"for line-by-line selection.  The indicated screen characters are highlighted "
"and saved in the static array sel_buffer in I<devices/char/console.c>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:730
#, no-wrap
msgid "B<TIOCLINUX, subcode=3>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:736
msgid ""
"Paste selection.  The characters in the selection buffer are written to "
"I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:736
#, no-wrap
msgid "B<TIOCLINUX, subcode=4>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:739
msgid "Unblank the screen."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:739
#, no-wrap
msgid "B<TIOCLINUX, subcode=5>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:744
msgid ""
"Sets contents of a 256-bit look up table defining characters in a \"word\", "
"for word-by-word selection.  (Since Linux 1.1.32.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:744
#, no-wrap
msgid "B<TIOCLINUX, subcode=6>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:751
msgid ""
"I<argp> points to a char which is set to the value of the kernel variable "
"I<shift_state>.  (Since Linux 1.1.32.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:751
#, no-wrap
msgid "B<TIOCLINUX, subcode=7>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:758
msgid ""
"I<argp> points to a char which is set to the value of the kernel variable "
"I<report_mouse>.  (Since Linux 1.1.33.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:758
#, no-wrap
msgid "B<TIOCLINUX, subcode=8>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:766
msgid ""
"Dump screen width and height, cursor position, and all the character-"
"attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With kernel 1.1.92 "
"or later, read from I</dev/vcsa*> instead.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:766
#, no-wrap
msgid "B<TIOCLINUX, subcode=9>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:774
msgid ""
"Restore screen width and height, cursor position, and all the character-"
"attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With kernel 1.1.92 "
"or later, write to I</dev/vcsa*> instead.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_console.2:774
#, no-wrap
msgid "B<TIOCLINUX, subcode=10>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:782
msgid ""
"Handles the Power Saving feature of the new generation of monitors.  VESA "
"screen blanking mode is set to I<argp[1]>, which governs what screen "
"blanking does:"
msgstr ""

#. type: IP
#: build/C/man2/ioctl_console.2:783
#, no-wrap
msgid "0:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:785
msgid "Screen blanking is disabled."
msgstr ""

#. type: IP
#: build/C/man2/ioctl_console.2:785
#, no-wrap
msgid "1:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:792
msgid ""
"The current video adapter register settings are saved, then the controller "
"is programmed to turn off the vertical synchronization pulses.  This puts "
"the monitor into \"standby\" mode.  If your monitor has an Off_Mode timer, "
"then it will eventually power down by itself."
msgstr ""

#. type: IP
#: build/C/man2/ioctl_console.2:792
#, no-wrap
msgid "2:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:802
msgid ""
"The current settings are saved, then both the vertical and horizontal "
"synchronization pulses are turned off.  This puts the monitor into \"off\" "
"mode.  If your monitor has no Off_Mode timer, or if you want your monitor to "
"power down immediately when the blank_timer times out, then you choose this "
"option.  (I<Caution:> Powering down frequently will damage the monitor.)  "
"(Since Linux 1.1.76.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:808
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:811
msgid "I<errno> may take on these values:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:814
msgid "The file descriptor is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:819
#, fuzzy
#| msgid "I<request> or I<argp> is not valid."
msgid "The file descriptor or I<argp> is invalid."
msgstr "I<request> または I<argp> が不正である。"

#. type: Plain text
#: build/C/man2/ioctl_console.2:823
#, fuzzy
#| msgid "I<fd> is not associated with a character special device."
msgid ""
"The file descriptor is not associated with a character special device, or "
"the specified request does not apply to it."
msgstr "I<fd> がキャラクター型のスペシャルデバイスを参照していない。"

#. type: TP
#: build/C/man2/ioctl_console.2:823 build/C/man2/ioctl_ficlonerange.2:116
#: build/C/man2/ioctl_fideduperange.2:183 build/C/man2/ioctl_fslabel.2:61
#: build/C/man2/ioctl_ns.2:97 build/C/man2/ioctl_tty.2:551
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:826 build/C/man2/ioctl_tty.2:554
msgid "Insufficient permission."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:837
msgid ""
"B<Warning>: Do not regard this man page as documentation of the Linux "
"console ioctls.  This is provided for the curious only, as an alternative to "
"reading the source.  Ioctl's are undocumented Linux internals, liable to be "
"changed without warning.  (And indeed, this page more or less describes the "
"situation as of kernel version 1.1.94; there are many minor and not-so-minor "
"differences with earlier versions.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:842
msgid ""
"Very often, ioctls are introduced for communication between the kernel and "
"one particular well-known program (fdisk, hdparm, setserial, tunelp, "
"loadkeys, selection, setfont, etc.), and their behavior will be changed when "
"required by this particular program."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:846
msgid ""
"Programs using these ioctls will not be portable to other versions of UNIX, "
"will not work on older versions of Linux, and will not work on future "
"versions of Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:848
msgid "Use POSIX functions."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:871
msgid ""
"B<dumpkeys>(1), B<kbd_mode>(1), B<loadkeys>(1), B<mknod>(1), B<setleds>(1), "
"B<setmetamode>(1), B<execve>(2), B<fcntl>(2), B<ioctl_tty>(2), B<ioperm>(2), "
"B<termios>(3), B<console_codes>(4), B<mt>(4), B<sd>(4), B<tty>(4), "
"B<ttyS>(4), B<vcs>(4), B<vcsa>(4), B<charsets>(7), B<mapscrn>(8), "
"B<resizecons>(8), B<setfont>(8)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_console.2:874
msgid "I</usr/include/linux/kd.h>, I</usr/include/linux/vt.h>"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_fat.2:24
#, fuzzy, no-wrap
#| msgid "IOCTL"
msgid "IOCTL_FAT"
msgstr "IOCTL"

#. type: TH
#: build/C/man2/ioctl_fat.2:24 build/C/man2/ioctl_ns.2:26
#, no-wrap
msgid "2020-11-01"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:27
msgid "ioctl_fat - manipulating the FAT filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:31
#, fuzzy, no-wrap
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid ""
"B<#include E<lt>linux/msdos_fs.hE<gt>>\n"
"B<#include E<lt>sys/ioctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man2/ioctl_fat.2:39
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_GET_ATTRIBUTES, uint32_t *>I<attr>B<);>\n"
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_SET_ATTRIBUTES, uint32_t *>I<attr>B<);>\n"
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_GET_VOLUME_ID, uint32_t *>I<id>B<);>\n"
"B<int ioctl(int >I<fd>B<, VFAT_IOCTL_READDIR_BOTH,>\n"
"B<          struct __fat_dirent[2] >I<entry>B<);>\n"
"B<int ioctl(int >I<fd>B<, VFAT_IOCTL_READDIR_SHORT,>\n"
"B<          struct __fat_dirent[2] >I<entry>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:45
msgid ""
"The B<ioctl>(2)  system call can be used to read and write metadata of FAT "
"filesystems that are not accessible using other system calls."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:45
#, no-wrap
msgid "Reading and setting file attributes"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:51
msgid ""
"Files and directories in the FAT filesystem possess an attribute bit mask "
"that can be read with B<FAT_IOCTL_GET_ATTRIBUTES> and written with "
"B<FAT_IOCTL_SET_ATTRIBUTES>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:60
msgid ""
"The I<fd> argument contains a file descriptor for a file or directory.  It "
"is sufficient to create the file descriptor by calling B<open>(2)  with the "
"B<O_RDONLY> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:65
msgid ""
"The I<attr> argument contains a pointer to a bit mask.  The bits of the bit "
"mask are:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:65
#, no-wrap
msgid "B<ATTR_RO>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:68
msgid "This bit specifies that the file or directory is read-only."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:68
#, no-wrap
msgid "B<ATTR_HIDDEN>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:71
msgid "This bit specifies that the file or directory is hidden."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:71
#, no-wrap
msgid "B<ATTR_SYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:74
msgid "This bit specifies that the file is a system file."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:74
#, no-wrap
msgid "B<ATTR_VOLUME>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:78
msgid ""
"This bit specifies that the file is a volume label.  This attribute is read-"
"only."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:78
#, no-wrap
msgid "B<ATTR_DIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:82
msgid ""
"This bit specifies that this is a directory.  This attribute is read-only."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:82
#, no-wrap
msgid "B<ATTR_ARCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:87
msgid ""
"This bit indicates that this file or directory should be archived.  It is "
"set when a file is created or modified.  It is reset by an archiving system."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:91
msgid ""
"The zero value B<ATTR_NONE> can be used to indicate that no attribute bit is "
"set."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:91 build/C/man2/ioctl_fat.2:350
#, no-wrap
msgid "Reading the volume ID"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:95
msgid ""
"FAT filesystems are identified by a volume ID.  The volume ID can be read "
"with B<FAT_IOCTL_GET_VOLUME_ID>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:105
msgid ""
"The I<fd> argument can be a file descriptor for any file or directory of the "
"filesystem.  It is sufficient to create the file descriptor by calling "
"B<open>(2)  with the B<O_RDONLY> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:111
msgid ""
"The I<id> argument is a pointer to the field that will be filled with the "
"volume ID.  Typically the volume ID is displayed to the user as a group of "
"two 16-bit fields:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:115
#, no-wrap
msgid "printf(\"Volume ID %04x-%04x\\en\", id E<gt>E<gt> 16, id & 0xFFFF);\n"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:117
#, no-wrap
msgid "Reading short filenames of a directory"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:123
msgid ""
"A file or directory on a FAT filesystem always has a short filename "
"consisting of up to 8 capital letters, optionally followed by a period and "
"up to 3 capital letters for the file extension.  If the actual filename does "
"not fit into this scheme, it is stored as a long filename of up to 255 "
"UTF-16 characters."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:128
msgid ""
"The short filenames in a directory can be read with "
"B<VFAT_IOCTL_READDIR_SHORT>.  B<VFAT_IOCTL_READDIR_BOTH> reads both the "
"short and the long filenames."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:141
msgid ""
"The I<fd> argument must be a file descriptor for a directory.  It is "
"sufficient to create the file descriptor by calling B<open>(2)  with the "
"B<O_RDONLY> flag.  The file descriptor can be used only once to iterate over "
"the directory entries by calling B<ioctl>(2)  repeatedly."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:145
msgid ""
"The I<entry> argument is a two-element array of the following structures:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:154
#, no-wrap
msgid ""
"struct __fat_dirent {\n"
"    long            d_ino;\n"
"    __kernel_off_t  d_off;\n"
"    uint32_t short  d_reclen;\n"
"    char            d_name[256];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:159
msgid ""
"The first entry in the array is for the short filename.  The second entry is "
"for the long filename."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:173
msgid ""
"The I<d_ino> and I<d_off> fields are filled only for long filenames.  The "
"I<d_ino> field holds the inode number of the directory.  The I<d_off> field "
"holds the offset of the file entry in the directory.  As these values are "
"not available for short filenames, the user code should simply ignore them."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:189
msgid ""
"The field I<d_reclen> contains the length of the filename in the field "
"I<d_name>.  To keep backward compatibility, a length of 0 for the short "
"filename signals that the end of the directory has been reached.  However, "
"the preferred method for detecting the end of the directory is to test the "
"B<ioctl>(2)  return value.  If no long filename exists, field I<d_reclen> is "
"set to 0 and I<d_name> is a character string of length 0 for the long "
"filename."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:193 build/C/man2/ioctl_ficlonerange.2:88
#: build/C/man2/ioctl_fideduperange.2:148 build/C/man2/ioctl_getfsmap.2:325
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:200
msgid ""
"For B<VFAT_IOCTL_READDIR_BOTH> and B<VFAT_IOCTL_READDIR_SHORT> a return "
"value of 1 signals that a new directory entry has been read and a return "
"value of 0 signals that the end of the directory has been reached."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:201
#, fuzzy, no-wrap
#| msgid "B<ENOTTY>"
msgid "B<ENOENT>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl_fat.2:210
msgid ""
"This error is returned by B<VFAT_IOCTL_READDIR_BOTH> and "
"B<VFAT_IOCTL_READDIR_SHORT> if the file descriptor I<fd> refers to a "
"removed, but still open directory."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fat.2:210
#, fuzzy, no-wrap
#| msgid "B<ENOTTY>"
msgid "B<ENOTDIR>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl_fat.2:219
msgid ""
"This error is returned by B<VFAT_IOCTL_READDIR_BOTH> and "
"B<VFAT_IOCTL_READDIR_SHORT> if the file descriptor I<fd> does not refer to a "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:224
msgid ""
"The file descriptor I<fd> does not refer to an object in a FAT filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:227
msgid "For further error values, see B<ioctl>(2)."
msgstr ""

#. type: SH
#: build/C/man2/ioctl_fat.2:227 build/C/man2/ioctl_ficlonerange.2:128
#: build/C/man2/ioctl_fideduperange.2:195 build/C/man2/ioctl_fslabel.2:64
#: build/C/man2/ioctl_getfsmap.2:354
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:232
msgid ""
"B<VFAT_IOCTL_READDIR_BOTH> and B<VFAT_IOCTL_READDIR_SHORT> first appeared in "
"Linux 2.0."
msgstr ""

#.  just before we got Git history
#. type: Plain text
#: build/C/man2/ioctl_fat.2:239
msgid ""
"B<FAT_IOCTL_GET_ATTRIBUTES> and B<FAT_IOCTL_SET_ATTRIBUTES> first appeared "
"in Linux 2.6.12."
msgstr ""

#.  commit 6e5b93ee55d401f1619092fb675b57c28c9ed7ec
#. type: Plain text
#: build/C/man2/ioctl_fat.2:244
msgid ""
"B<FAT_IOCTL_GET_VOLUME_ID> was introduced in version 3.11 of the Linux "
"kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:246 build/C/man2/ioctl_ficlonerange.2:137
#: build/C/man2/ioctl_fideduperange.2:202 build/C/man2/ioctl_fslabel.2:75
msgid "This API is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man2/ioctl_fat.2:246 build/C/man2/ioctl_getfsmap.2:361
#: build/C/man2/ioctl_ns.2:189 build/C/man2/ioctl_tty.2:554
#: build/C/man2/ioctl_userfaultfd.2:682
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:247
#, no-wrap
msgid "Toggling the archive flag"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:254
msgid ""
"The following program demonstrates the usage of B<ioctl>(2)  to manipulate "
"file attributes.  The program reads and displays the archive attribute of a "
"file.  After inverting the value of the attribute, the program reads and "
"displays the attribute again."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:257
msgid ""
"The following was recorded when applying the program for the file I</mnt/"
"user/foo>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:264
#, no-wrap
msgid ""
"# ./toggle_fat_archive_flag /mnt/user/foo\n"
"Archive flag is set\n"
"Toggling archive flag\n"
"Archive flag is not set\n"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:266
#, no-wrap
msgid "Program source (toggle_fat_archive_flag.c)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:276 build/C/man2/ioctl_fat.2:375
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/msdos_fs.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:286
#, no-wrap
msgid ""
"/*\n"
" * Read file attributes of a file on a FAT filesystem.\n"
" * Output the state of the archive flag.\n"
" */\n"
"static uint32_t\n"
"readattr(int fd)\n"
"{\n"
"    uint32_t attr;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:292
#, no-wrap
msgid ""
"    ret = ioctl(fd, FAT_IOCTL_GET_ATTRIBUTES, &attr);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:297
#, no-wrap
msgid ""
"    if (attr & ATTR_ARCH)\n"
"        printf(\"Archive flag is set\\en\");\n"
"    else\n"
"        printf(\"Archive flag is not set\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:300
#, no-wrap
msgid ""
"    return attr;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:307
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint32_t attr;\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:312 build/C/man2/ioctl_fat.2:387
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        printf(\"Usage: %s FILENAME\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:318 build/C/man2/ioctl_fat.2:393
#: build/C/man2/ioctl_ns.2:299
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:323
#, no-wrap
msgid ""
"    /*\n"
"     * Read and display the FAT file attributes.\n"
"     */\n"
"    attr = readattr(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:329
#, no-wrap
msgid ""
"    /*\n"
"     * Invert archive attribute.\n"
"     */\n"
"    printf(\"Toggling archive flag\\en\");\n"
"    attr \\(ha= ATTR_ARCH;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:338
#, no-wrap
msgid ""
"    /*\n"
"     * Write the changed FAT file attributes.\n"
"     */\n"
"    ret = ioctl(fd, FAT_IOCTL_SET_ATTRIBUTES, &attr);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:343
#, no-wrap
msgid ""
"    /*\n"
"     * Read and display the FAT file attributes.\n"
"     */\n"
"    readattr(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:345 build/C/man2/ioctl_fat.2:409
#, no-wrap
msgid "    close(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:348 build/C/man2/ioctl_fat.2:412
#: build/C/man2/ioctl_fat.2:499 build/C/man2/ioctl_ns.2:360
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:354
msgid ""
"The following program demonstrates the use of B<ioctl>(2)  to display the "
"volume ID of a FAT filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:358
msgid ""
"The following output was recorded when applying the program for directory I</"
"mnt/user>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:363
#, no-wrap
msgid ""
"$ ./display_fat_volume_id /mnt/user\n"
"Volume ID 6443-6241\n"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:365
#, no-wrap
msgid "Program source (display_fat_volume_id.c)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:382
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint32_t id;\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:402
#, no-wrap
msgid ""
"    /*\n"
"     * Read volume ID.\n"
"     */\n"
"    ret = ioctl(fd, FAT_IOCTL_GET_VOLUME_ID, &id);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:407
#, no-wrap
msgid ""
"    /*\n"
"     * Format the output as two groups of 16 bits each.\n"
"     */\n"
"    printf(\"Volume ID %04x-%04x\\en\", id E<gt>E<gt> 16, id & 0xFFFF);\n"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:414
#, no-wrap
msgid "Listing a directory"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:418
msgid ""
"The following program demonstrates the use of B<ioctl>(2)  to list a "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:421
msgid ""
"The following was recorded when applying the program to the directory I</mnt/"
"user>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:430
#, no-wrap
msgid ""
"$ B<./fat_dir /mnt/user>\n"
"\\[char46] -E<gt> \\(aq\\(aq\n"
"\\[char46]. -E<gt> \\(aq\\(aq\n"
"ALONGF\\(ti1.TXT -E<gt> \\(aqa long filename.txt\\(aq\n"
"UPPER.TXT -E<gt> \\(aq\\(aq\n"
"LOWER.TXT -E<gt> \\(aqlower.txt\\(aq\n"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_fat.2:433 build/C/man2/ioctl_ns.2:250
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:442
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/msdos_fs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:449
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct __fat_dirent entry[2];\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:454
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        printf(\"Usage: %s DIRECTORY\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:463
#, no-wrap
msgid ""
"    /*\n"
"     * Open file descriptor for the directory.\n"
"     */\n"
"    fd = open(argv[1], O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:465
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:470
#, no-wrap
msgid ""
"        /*\n"
"         * Read next directory entry.\n"
"         */\n"
"        ret = ioctl( fd, VFAT_IOCTL_READDIR_BOTH, entry);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:480
#, no-wrap
msgid ""
"        /*\n"
"         * If an error occurs, the return value is -1.\n"
"         * If the end of the directory list has been reached,\n"
"         * the return value is 0.\n"
"         * For backward compatibility the end of the directory\n"
"         * list is also signaled by d_reclen == 0.\n"
"         */\n"
"        if (ret E<lt> 1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:486
#, no-wrap
msgid ""
"        /*\n"
"         * Write both the short name and the long name.\n"
"         */\n"
"        printf(\"%s -E<gt> \\(aq%s\\(aq\\en\", entry[0].d_name, entry[1].d_name);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:491
#, no-wrap
msgid ""
"    if (ret == -1) {\n"
"        perror(\"VFAT_IOCTL_READDIR_BOTH\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:496
#, no-wrap
msgid ""
"    /*\n"
"     * Close the file descriptor.\n"
"     */\n"
"    close(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fat.2:503 build/C/man2/ioctl_ficlonerange.2:144
#: build/C/man2/ioctl_fideduperange.2:212 build/C/man2/ioctl_getfsmap.2:369
msgid "B<ioctl>(2)"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_ficlonerange.2:23
#, no-wrap
msgid "IOCTL_FICLONERANGE"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:26
msgid ""
"ioctl_ficlonerange, ioctl_ficlone - share some the data of one file with "
"another file"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:30 build/C/man2/ioctl_fideduperange.2:30
#: build/C/man2/ioctl_fslabel.2:30 build/C/man2/ioctl_getfsmap.2:30
#, fuzzy
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid "B<#include E<lt>linux/fs.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:32
#, fuzzy
#| msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgid ""
"B<int ioctl(int >I<dest_fd>B<, FICLONERANGE, struct file_clone_range "
"*>I<arg>B<);>"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:34
#, fuzzy
#| msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgid "B<int ioctl(int >I<dest_fd>B<, FICLONE, int >I<src_fd>B<);>"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:49
msgid ""
"If a filesystem supports files sharing physical storage between multiple "
"files (\"reflink\"), this B<ioctl>(2)  operation can be used to make some of "
"the data in the I<src_fd> file appear in the I<dest_fd> file by sharing the "
"underlying storage, which is faster than making a separate physical copy of "
"the data.  Both files must reside within the same filesystem.  If a file "
"write should occur to a shared region, the filesystem must ensure that the "
"changes remain private to the file being written.  This behavior is commonly "
"referred to as \"copy on write\"."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:66
msgid ""
"This ioctl reflinks up to I<src_length> bytes from file descriptor I<src_fd> "
"at offset I<src_offset> into the file I<dest_fd> at offset I<dest_offset>, "
"provided that both are files.  If I<src_length> is zero, the ioctl reflinks "
"to the end of the source file.  This information is conveyed in a structure "
"of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:75
#, no-wrap
msgid ""
"struct file_clone_range {\n"
"    __s64 src_fd;\n"
"    __u64 src_offset;\n"
"    __u64 src_length;\n"
"    __u64 dest_offset;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:80
msgid ""
"Clones are atomic with regards to concurrent writes, so no locks need to be "
"taken to obtain a consistent cloned copy."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:84
msgid "The B<FICLONE> ioctl clones entire files."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:90 build/C/man2/ioctl_fideduperange.2:150
msgid "Error codes can be one of, but are not limited to, the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:99
msgid ""
"I<src_fd> is not open for reading; I<dest_fd> is not open for writing or is "
"open for append-only writes; or the filesystem which I<src_fd> resides on "
"does not support reflink."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:108
msgid ""
"The filesystem does not support reflinking the ranges of the given files.  "
"This error can also appear if either file descriptor represents a device, "
"FIFO, or socket.  Disk filesystems generally require the offset and length "
"arguments to be aligned to the fundamental block size.  XFS and Btrfs do not "
"support overlapping reflink ranges in the same file."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ficlonerange.2:108 build/C/man2/ioctl_fideduperange.2:168
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:112 build/C/man2/ioctl_fideduperange.2:172
msgid ""
"One of the files is a directory and the filesystem does not support shared "
"regions in directories."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ficlonerange.2:112 build/C/man2/ioctl_fideduperange.2:179
#: build/C/man2/ioctl_getfsmap.2:348
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:116
msgid ""
"This can appear if the filesystem does not support reflinking either file "
"descriptor, or if either file descriptor refers to special inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:120 build/C/man2/ioctl_fideduperange.2:187
msgid "I<dest_fd> is immutable."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ficlonerange.2:120 build/C/man2/ioctl_fideduperange.2:187
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:124 build/C/man2/ioctl_fideduperange.2:191
msgid "One of the files is a swap file.  Swap files cannot share storage."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ficlonerange.2:124 build/C/man2/ioctl_fideduperange.2:191
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:128 build/C/man2/ioctl_fideduperange.2:195
msgid "I<dest_fd> and I<src_fd> are not on the same mounted filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:135
msgid ""
"These ioctl operations first appeared in Linux 4.5.  They were previously "
"known as B<BTRFS_IOC_CLONE> and B<BTRFS_IOC_CLONE_RANGE>, and were private "
"to Btrfs."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ficlonerange.2:142 build/C/man2/ioctl_fideduperange.2:207
msgid ""
"Because a copy-on-write operation requires the allocation of new storage, "
"the B<fallocate>(2)  operation may unshare shared blocks to guarantee that "
"subsequent writes will not fail because of lack of disk space."
msgstr ""

#. type: TH
#: build/C/man2/ioctl_fideduperange.2:23
#, no-wrap
msgid "IOCTL_FIDEDUPERANGE"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_fideduperange.2:23
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:26
msgid "ioctl_fideduperange - share some the data of one file with another file"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:32
msgid ""
"B<int ioctl(int >I<src_fd>B<, FIDEDUPERANGE, struct file_dedupe_range "
"*>I<arg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:49
msgid ""
"If a filesystem supports files sharing physical storage between multiple "
"files, this B<ioctl>(2)  operation can be used to make some of the data in "
"the B<src_fd> file appear in the B<dest_fd> file by sharing the underlying "
"storage if the file data is identical (\"deduplication\").  Both files must "
"reside within the same filesystem.  This reduces storage consumption by "
"allowing the filesystem to store one shared copy of the data.  If a file "
"write should occur to a shared region, the filesystem must ensure that the "
"changes remain private to the file being written.  This behavior is commonly "
"referred to as \"copy on write\"."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:57
msgid ""
"This ioctl performs the \"compare and share if identical\" operation on up "
"to I<src_length> bytes from file descriptor I<src_fd> at offset "
"I<src_offset>.  This information is conveyed in a structure of the following "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:68
#, no-wrap
msgid ""
"struct file_dedupe_range {\n"
"    __u64 src_offset;\n"
"    __u64 src_length;\n"
"    __u16 dest_count;\n"
"    __u16 reserved1;\n"
"    __u32 reserved2;\n"
"    struct file_dedupe_range_info info[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:73
msgid ""
"Deduplication is atomic with regards to concurrent writes, so no locks need "
"to be taken to obtain a consistent deduplicated copy."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:77
msgid "The fields I<reserved1> and I<reserved2> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:83
msgid ""
"Destinations for the deduplication operation are conveyed in the array at "
"the end of the structure.  The number of destinations is given in "
"I<dest_count>, and the destination information is conveyed in the following "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:93
#, no-wrap
msgid ""
"struct file_dedupe_range_info {\n"
"    __s64 dest_fd;\n"
"    __u64 dest_offset;\n"
"    __u64 bytes_deduped;\n"
"    __s32 status;\n"
"    __u32 reserved;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:126
msgid ""
"Each deduplication operation targets I<src_length> bytes in file descriptor "
"I<dest_fd> at offset I<dest_offset>.  The field I<reserved> must be zero.  "
"During the call, I<src_fd> must be open for reading and I<dest_fd> must be "
"open for writing.  The combined size of the struct I<file_dedupe_range> and "
"the struct I<file_dedupe_range_info> array must not exceed the system page "
"size.  The maximum size of I<src_length> is filesystem dependent and is "
"typically 16\\ MiB.  This limit will be enforced silently by the "
"filesystem.  By convention, the storage used by I<src_fd> is mapped into "
"I<dest_fd> and the previous contents in I<dest_fd> are freed."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:144
msgid ""
"Upon successful completion of this ioctl, the number of bytes successfully "
"deduplicated is returned in I<bytes_deduped> and a status code for the "
"deduplication operation is returned in I<status>.  If even a single byte in "
"the range does not match, the deduplication request will be ignored and "
"I<status> set to B<FILE_DEDUPE_RANGE_DIFFERS>.  The I<status> code is set to "
"B<FILE_DEDUPE_RANGE_SAME> for success, a negative error code in case of "
"error, or B<FILE_DEDUPE_RANGE_DIFFERS> if the data did not match."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:159
msgid ""
"I<src_fd> is not open for reading; I<dest_fd> is not open for writing or is "
"open for append-only writes; or the filesystem which I<src_fd> resides on "
"does not support deduplication."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:168
msgid ""
"The filesystem does not support deduplicating the ranges of the given "
"files.  This error can also appear if either file descriptor represents a "
"device, FIFO, or socket.  Disk filesystems generally require the offset and "
"length arguments to be aligned to the fundamental block size.  Neither Btrfs "
"nor XFS support overlapping deduplication ranges in the same file."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_fideduperange.2:172 build/C/man2/ioctl_getfsmap.2:345
#, fuzzy, no-wrap
#| msgid "B<ENOTTY>"
msgid "B<ENOMEM>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:179
msgid ""
"The kernel was unable to allocate sufficient memory to perform the operation "
"or I<dest_count> is so large that the input argument description spans more "
"than a single page of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:183
msgid ""
"This can appear if the filesystem does not support deduplicating either file "
"descriptor, or if either file descriptor refers to special inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:200
msgid ""
"This ioctl operation first appeared in Linux 4.5.  It was previously known "
"as B<BTRFS_IOC_FILE_EXTENT_SAME> and was private to Btrfs."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fideduperange.2:210
msgid ""
"Some filesystems may limit the amount of data that can be deduplicated in a "
"single call."
msgstr ""

#. type: TH
#: build/C/man2/ioctl_fslabel.2:23
#, no-wrap
msgid "IOCTL_FSLABEL"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_fslabel.2:23
#, no-wrap
msgid "2020-04-20"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:26
msgid "ioctl_fslabel - get or set a filesystem label"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:32
msgid ""
"B<int ioctl(int >I<fd>B<, FS_IOC_GETFSLABEL, char >I<label>B<[FSLABEL_MAX]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:34
msgid ""
"B<int ioctl(int >I<fd>B<, FS_IOC_SETFSLABEL, char >I<label>B<[FSLABEL_MAX]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:45
msgid ""
"If a filesystem supports online label manipulation, these B<ioctl>(2)  "
"operations can be used to get or set the filesystem label for the filesystem "
"on which B<fd> resides.  The B<FS_IOC_SETFSLABEL> operation requires "
"privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:49
msgid ""
"On success zero is returned.  On error, -1 is returned, and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:51
msgid "Error can include (but are not limited to) the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:55
#, fuzzy
#| msgid "I<argp> references an inaccessible memory area."
msgid "I<label> references an inaccessible memory area."
msgstr "I<argp> がアクセス不可能なメモリーを参照している。"

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:58
msgid ""
"The specified label exceeds the maximum label length for the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:61
msgid ""
"This can appear if the filesystem does not support online label manipulation."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:64
msgid ""
"The calling process does not have sufficient permissions to set the label."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:73
msgid ""
"These B<ioctl>(2)  operations first appeared in Linux 4.18.  They were "
"previously known as B<BTRFS_IOC_GET_FSLABEL> and B<BTRFS_IOC_SET_FSLABEL> "
"and were private to Btrfs."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:85
msgid ""
"The maximum string length for this interface is B<FSLABEL_MAX>, including "
"the terminating null byte (\\(aq\\e0\\(aq).  Filesystems have differing "
"maximum label lengths, which may or may not include the terminating null.  "
"The string provided to B<FS_IOC_SETFSLABEL> must always be null-terminated, "
"and the string returned by B<FS_IOC_GETFSLABEL> will always be null-"
"terminated."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_fslabel.2:88
msgid "B<ioctl>(2), B<blkid>(8)"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_getfsmap.2:23
#, no-wrap
msgid "IOCTL_GETFSMAP"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_getfsmap.2:23 build/C/man2/ioctl_tty.2:8
#: build/C/man2/ioctl_userfaultfd.2:28
#, no-wrap
msgid "2020-06-09"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:26
msgid "ioctl_getfsmap - retrieve the physical layout of the filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:32
#, fuzzy
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid "B<#include E<lt>linux/fsmap.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:34
#, fuzzy
#| msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgid ""
"B<int ioctl(int >I<fd>B<, FS_IOC_GETFSMAP, struct fsmap_head * >I<arg>B<);>"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:40
msgid ""
"This B<ioctl>(2)  operation retrieves physical extent mappings for a "
"filesystem.  This information can be used to discover which files are mapped "
"to a physical block, examine free space, or find known bad blocks, among "
"other things."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:43
msgid ""
"The sole argument to this operation should be a pointer to a single I<struct "
"fsmap_head>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:55
#, no-wrap
msgid ""
"struct fsmap {\n"
"    __u32 fmr_device;      /* Device ID */\n"
"    __u32 fmr_flags;       /* Mapping flags */\n"
"    __u64 fmr_physical;    /* Device offset of segment */\n"
"    __u64 fmr_owner;       /* Owner ID */\n"
"    __u64 fmr_offset;      /* File offset of segment */\n"
"    __u64 fmr_length;      /* Length of segment */\n"
"    __u64 fmr_reserved[3]; /* Must be zero */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:62
#, no-wrap
msgid ""
"struct fsmap_head {\n"
"    __u32 fmh_iflags;       /* Control flags */\n"
"    __u32 fmh_oflags;       /* Output flags */\n"
"    __u32 fmh_count;        /* # of entries in array incl. input */\n"
"    __u32 fmh_entries;      /* # of entries filled in (output) */\n"
"    __u64 fmh_reserved[6];  /* Must be zero */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:67
#, no-wrap
msgid ""
"    struct fsmap fmh_keys[2];  /* Low and high keys for\n"
"                                  the mapping search */\n"
"    struct fsmap fmh_recs[];   /* Returned records */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:79
msgid ""
"The two I<fmh_keys> array elements specify the lowest and highest reverse-"
"mapping key for which the application would like physical mapping "
"information.  A reverse mapping key consists of the tuple (device, block, "
"owner, offset).  The owner and offset fields are part of the key because "
"some filesystems support sharing physical blocks between multiple files and "
"therefore may return multiple mappings for a given physical block."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:84
msgid ""
"Filesystem mappings are copied into the I<fmh_recs> array, which immediately "
"follows the header data."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_getfsmap.2:84
#, no-wrap
msgid "Fields of struct fsmap_head"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:89
msgid ""
"The I<fmh_iflags> field is a bit mask passed to the kernel to alter the "
"output.  No flags are currently defined, so the caller must set this value "
"to zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:100
msgid ""
"The I<fmh_oflags> field is a bit mask of flags set by the kernel concerning "
"the returned mappings.  If B<FMH_OF_DEV_T> is set, then the I<fmr_device> "
"field represents a I<dev_t> structure containing the major and minor numbers "
"of the block device."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:110
msgid ""
"The I<fmh_count> field contains the number of elements in the array being "
"passed to the kernel.  If this value is 0, I<fmh_entries> will be set to the "
"number of records that would have been returned had the array been large "
"enough; no mapping information will be returned."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:116
msgid ""
"The I<fmh_entries> field contains the number of elements in the I<fmh_recs> "
"array that contain useful information."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:121
msgid "The I<fmh_reserved> fields must be set to zero."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_getfsmap.2:121
#, no-wrap
msgid "Keys"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:144
msgid ""
"The two key records in I<fsmap_head.fmh_keys> specify the lowest and highest "
"extent records in the keyspace that the caller wants returned.  A filesystem "
"that can share blocks between files likely requires the tuple (I<device>, "
"I<physical>, I<owner>, I<offset>, I<flags>)  to uniquely index any "
"filesystem mapping record.  Classic non-sharing filesystems might be able to "
"identify any record with only (I<device>, I<physical>, I<flags>).  For "
"example, if the low key is set to (8:0, 36864, 0, 0, 0), the filesystem will "
"only return records for extents starting at or above 36\\ KiB on disk.  If "
"the high key is set to (8:0, 1048576, 0, 0, 0), only records below 1\\ MiB "
"will be returned.  The format of I<fmr_device> in the keys must match the "
"format of the same field in the output records, as defined below.  By "
"convention, the field I<fsmap_head.fmh_keys[0]> must contain the low key and "
"I<fsmap_head.fmh_keys[1]> must contain the high key for the request."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:160
msgid ""
"For convenience, if I<fmr_length> is set in the low key, it will be added to "
"I<fmr_block> or I<fmr_offset> as appropriate.  The caller can take advantage "
"of this subtlety to set up subsequent calls by copying I<fsmap_head."
"fmh_recs[fsmap_head.fmh_entries - 1]> into the low key.  The function "
"I<fsmap_advance> (defined in I<linux/fsmap.h>)  provides this functionality."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_getfsmap.2:160
#, no-wrap
msgid "Fields of struct fsmap"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:173
msgid ""
"The I<fmr_device> field uniquely identifies the underlying storage device.  "
"If the B<FMH_OF_DEV_T> flag is set in the header's I<fmh_oflags> field, this "
"field contains a I<dev_t> from which major and minor numbers can be "
"extracted.  If the flag is not set, this field contains a value that must be "
"unique for each unique storage device."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:177
msgid ""
"The I<fmr_physical> field contains the disk address of the extent in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:187
msgid ""
"The I<fmr_owner> field contains the owner of the extent.  This is an inode "
"number unless B<FMR_OF_SPECIAL_OWNER> is set in the I<fmr_flags> field, in "
"which case the value is determined by the filesystem.  See the section below "
"about owner values for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:195
msgid ""
"The I<fmr_offset> field contains the logical address in the mapping record "
"in bytes.  This field has no meaning if the B<FMR_OF_SPECIAL_OWNER> or "
"B<FMR_OF_EXTENT_MAP> flags are set in I<fmr_flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:199
msgid "The I<fmr_length> field contains the length of the extent in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:204
msgid ""
"The I<fmr_flags> field is a bit mask of extent state flags.  The bits are:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:205
#, no-wrap
msgid "B<FMR_OF_PREALLOC>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:208
msgid "The extent is allocated but not yet written."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:208
#, no-wrap
msgid "B<FMR_OF_ATTR_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:211
msgid "This extent contains extended attribute data."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:211
#, no-wrap
msgid "B<FMR_OF_EXTENT_MAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:214
msgid "This extent contains extent map information for the owner."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:214
#, no-wrap
msgid "B<FMR_OF_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:217
msgid "Parts of this extent may be shared."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:217
#, no-wrap
msgid "B<FMR_OF_SPECIAL_OWNER>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:222
msgid ""
"The I<fmr_owner> field contains a special value instead of an inode number."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:222
#, no-wrap
msgid "B<FMR_OF_LAST>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:225
msgid "This is the last record in the data set."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:231
msgid "The I<fmr_reserved> field will be set to zero."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_getfsmap.2:231
#, no-wrap
msgid "Owner values"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:245
msgid ""
"Generally, the value of the I<fmr_owner> field for non-metadata extents "
"should be an inode number.  However, filesystems are under no obligation to "
"report inode numbers; they may instead report B<FMR_OWN_UNKNOWN> if the "
"inode number cannot easily be retrieved, if the caller lacks sufficient "
"privilege, if the filesystem does not support stable inode numbers, or for "
"any other reason.  If a filesystem wishes to condition the reporting of "
"inode numbers based on process capabilities, it is strongly urged that the "
"B<CAP_SYS_ADMIN> capability be used for this purpose."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:245
#, no-wrap
msgid "The following special owner values are generic to all filesystems:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:248
#, no-wrap
msgid "B<FMR_OWN_FREE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:251 build/C/man2/ioctl_getfsmap.2:264
#: build/C/man2/ioctl_getfsmap.2:301
msgid "Free space."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:251
#, no-wrap
msgid "B<FMR_OWN_UNKNOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:254 build/C/man2/ioctl_getfsmap.2:267
#: build/C/man2/ioctl_getfsmap.2:304
msgid ""
"This extent is in use but its owner is not known or not easily retrieved."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:254
#, no-wrap
msgid "B<FMR_OWN_METADATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:257
msgid "This extent is filesystem metadata."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:260
msgid "XFS can return the following special owner values:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:261
#, no-wrap
msgid "B<XFS_FMR_OWN_FREE>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:264
#, no-wrap
msgid "B<XFS_FMR_OWN_UNKNOWN>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:267
#, no-wrap
msgid "B<XFS_FMR_OWN_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:271
msgid ""
"Static filesystem metadata which exists at a fixed address.  These are the "
"AG superblock, the AGF, the AGFL, and the AGI headers."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:271
#, no-wrap
msgid "B<XFS_FMR_OWN_LOG>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:274 build/C/man2/ioctl_getfsmap.2:311
msgid "The filesystem journal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:274
#, no-wrap
msgid "B<XFS_FMR_OWN_AG>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:278
msgid ""
"Allocation group metadata, such as the free space btrees and the reverse "
"mapping btrees."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:278
#, no-wrap
msgid "B<XFS_FMR_OWN_INOBT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:281
msgid "The inode and free inode btrees."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:281
#, no-wrap
msgid "B<XFS_FMR_OWN_INODES>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:284 build/C/man2/ioctl_getfsmap.2:314
msgid "Inode records."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:284
#, no-wrap
msgid "B<XFS_FMR_OWN_REFC>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:287
msgid "Reference count information."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:287
#, no-wrap
msgid "B<XFS_FMR_OWN_COW>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:290
msgid "This extent is being used to stage a copy-on-write."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:290
#, no-wrap
msgid "B<XFS_FMR_OWN_DEFECTIVE:>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:294
msgid ""
"This extent has been marked defective either by the filesystem or the "
"underlying device."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:297
msgid "ext4 can return the following special owner values:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:298
#, no-wrap
msgid "B<EXT4_FMR_OWN_FREE>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:301
#, no-wrap
msgid "B<EXT4_FMR_OWN_UNKNOWN>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:304
#, no-wrap
msgid "B<EXT4_FMR_OWN_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:308
msgid ""
"Static filesystem metadata which exists at a fixed address.  This is the "
"superblock and the group descriptors."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:308
#, no-wrap
msgid "B<EXT4_FMR_OWN_LOG>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:311
#, no-wrap
msgid "B<EXT4_FMR_OWN_INODES>"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:314
#, no-wrap
msgid "B<EXT4_FMR_OWN_BLKBM>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:317
msgid "Block bit map."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:317
#, no-wrap
msgid "B<EXT4_FMR_OWN_INOBM>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:320
msgid "Inode bit map."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:329
msgid ""
"The error placed in I<errno> can be one of, but is not limited to, the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:333
msgid "I<fd> is not open for reading."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:333
#, fuzzy, no-wrap
#| msgid "B<EBADF>"
msgid "B<EBADMSG>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:336
msgid "The filesystem has detected a checksum error in the metadata."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:339
msgid "The pointer passed in was not mapped to a valid memory address."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:345
msgid ""
"The array is not long enough, the keys do not point to a valid part of the "
"filesystem, the low key points to a higher point in the filesystem's "
"physical storage address space than the high key, or a nonzero value was "
"passed in one of the fields that must be zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:348
msgid "Insufficient memory to process the request."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:351
msgid "The filesystem does not support this command."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_getfsmap.2:351
#, no-wrap
msgid "B<EUCLEAN>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:354
msgid "The filesystem metadata is corrupt and needs repair."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:358
msgid "The B<FS_IOC_GETFSMAP> operation first appeared in Linux 4.12."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:361
msgid "This API is Linux-specific.  Not all filesystems support it."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_getfsmap.2:367
msgid "See I<io/fsmap.c> in the I<xfsprogs> distribution for a sample program."
msgstr ""

#. type: TH
#: build/C/man2/ioctl_iflags.2:26
#, no-wrap
msgid "IOCTL_IFLAGS"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_iflags.2:26
#, no-wrap
msgid "2019-11-19"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:29
msgid "ioctl_iflags - ioctl() operations for inode flags"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:36
msgid ""
"Various Linux filesystems support the notion of I<inode flags>"
"\\(emattributes that modify the semantics of files and directories.  These "
"flags can be retrieved and modified using two B<ioctl>(2)  operations:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:41
#, no-wrap
msgid ""
"int attr;\n"
"fd = open(\"pathname\", ...);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:47
#, no-wrap
msgid ""
"ioctl(fd, FS_IOC_GETFLAGS, &attr);  /* Place current flags\n"
"                                       in \\(aqattr\\(aq */\n"
"attr |= FS_NOATIME_FL;              /* Tweak returned bit mask */\n"
"ioctl(fd, FS_IOC_SETFLAGS, &attr);  /* Update flags for inode\n"
"                                       referred to by \\(aqfd\\(aq */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:56
msgid ""
"The B<lsattr>(1)  and B<chattr>(1)  shell commands provide interfaces to "
"these two operations, allowing a user to view and modify the inode flags "
"associated with a file."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:62
msgid ""
"The following flags are supported (shown along with the corresponding letter "
"used to indicate the flag by B<lsattr>(1)  and B<chattr>(1)):"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:62
#, no-wrap
msgid "B<FS_APPEND_FL> \\(aqa\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:71
msgid ""
"The file can be opened only with the B<O_APPEND> flag.  (This restriction "
"applies even to the superuser.)  Only a privileged process "
"(B<CAP_LINUX_IMMUTABLE>)  can set or clear this attribute."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:71
#, no-wrap
msgid "B<FS_COMPR_FL> \\(aqc\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:79
msgid ""
"Store the file in a compressed format on disk.  This flag is I<not> "
"supported by most of the mainstream filesystem implementations; one "
"exception is B<btrfs>(5)."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:79
#, no-wrap
msgid "B<FS_DIRSYNC_FL> \\(aqD\\(aq (since Linux 2.6.0)"
msgstr ""

#.  .TP
#.  .BR FS_EXTENT_FL " \(aqe\(aq"
#.  FIXME Some support on ext4? (EXT4_EXTENTS_FL)
#. type: Plain text
#: build/C/man2/ioctl_iflags.2:90
msgid ""
"Write directory changes synchronously to disk.  This flag provides semantics "
"equivalent to the B<mount>(2)  B<MS_DIRSYNC> option, but on a per-directory "
"basis.  This flag can be applied only to directories."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:90
#, no-wrap
msgid "B<FS_IMMUTABLE_FL> \\(aqi\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:99
msgid ""
"The file is immutable: no changes are permitted to the file contents or "
"metadata (permissions, timestamps, ownership, link count and so on).  (This "
"restriction applies even to the superuser.)  Only a privileged process "
"(B<CAP_LINUX_IMMUTABLE>)  can set or clear this attribute."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:99
#, no-wrap
msgid "B<FS_JOURNAL_DATA_FL> \\(aqj\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:114
msgid ""
"Enable journaling of file data on B<ext3>(5)  and B<ext4>(5)  filesystems.  "
"On a filesystem that is journaling in I<ordered> or I<writeback> mode, a "
"privileged (B<CAP_SYS_RESOURCE>)  process can set this flag to enable "
"journaling of data updates on a per-file basis."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:114
#, no-wrap
msgid "B<FS_NOATIME_FL> \\(aqA\\(aq"
msgstr ""

#.  .TP
#.  .BR FS_NOCOMP_FL " \(aq\(aq"
#.  FIXME Support for FS_NOCOMP_FL on Btrfs?
#. type: Plain text
#: build/C/man2/ioctl_iflags.2:126
msgid ""
"Don't update the file last access time when the file is accessed.  This can "
"provide I/O performance benefits for applications that do not care about the "
"accuracy of this timestamp.  This flag provides functionality similar to the "
"B<mount>(2)  B<MS_NOATIME> flag, but on a per-file basis."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:126
#, no-wrap
msgid "B<FS_NOCOW_FL> \\(aqC\\(aq (since Linux 2.6.39)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:135
msgid ""
"The file will not be subject to copy-on-write updates.  This flag has an "
"effect only on filesystems that support copy-on-write semantics, such as "
"Btrfs.  See B<chattr>(1)  and B<btrfs>(5)."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:135
#, no-wrap
msgid "B<FS_NODUMP_FL> \\(aqd\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:139
msgid "Don't include this file in backups made using B<dump>(8)."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:139
#, no-wrap
msgid "B<FS_NOTAIL_FL> \\(aqt\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:145
msgid ""
"This flag is supported only on Reiserfs.  It disables the Reiserfs tail-"
"packing feature, which tries to pack small files (and the final fragment of "
"larger files)  into the same disk block as the file metadata."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:145
#, no-wrap
msgid "B<FS_PROJINHERIT_FL> \\(aqP\\(aq (since Linux 4.5)"
msgstr ""

#.  commit 040cb3786d9b25293b8b0b05b90da0f871e1eb9b
#.  Flag name was added in Linux 4.4
#.  FIXME Not currently supported because not in FS_FL_USER_MODIFIABLE?
#. type: Plain text
#: build/C/man2/ioctl_iflags.2:153
msgid ""
"Inherit the quota project ID.  Files and subdirectories will inherit the "
"project ID of the directory.  This flag can be applied only to directories."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:153
#, no-wrap
msgid "B<FS_SECRM_FL> \\(aqs\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:159
msgid ""
"Mark the file for secure deletion.  This feature is not implemented by any "
"filesystem, since the task of securely erasing a file from a recording "
"medium is surprisingly difficult."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:159
#, no-wrap
msgid "B<FS_SYNC_FL> \\(aqS\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:169
msgid ""
"Make file updates synchronous.  For files, this makes all writes synchronous "
"(as though all opens of the file were with the B<O_SYNC> flag).  For "
"directories, this has the same effect as the B<FS_DIRSYNC_FL> flag."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:169
#, no-wrap
msgid "B<FS_TOPDIR_FL> \\(aqT\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:178
msgid ""
"Mark a directory for special treatment under the Orlov block-allocation "
"strategy.  See B<chattr>(1)  for details.  This flag can be applied only to "
"directories and has an effect only for ext2, ext3, and ext4."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_iflags.2:178
#, no-wrap
msgid "B<FS_UNRM_FL> \\(aqu\\(aq"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:183
msgid ""
"Allow the file to be undeleted if it is deleted.  This feature is not "
"implemented by any filesystem, since it is possible to implement file-"
"recovery mechanisms outside the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:193
msgid ""
"In most cases, when any of the above flags is set on a directory, the flag "
"is inherited by files and subdirectories created inside that directory.  "
"Exceptions include B<FS_TOPDIR_FL>, which is not inheritable, and "
"B<FS_DIRSYNC_FL>, which is inherited only by subdirectories."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:195
msgid "Inode flags are a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:203
msgid ""
"In order to change the inode flags of a file using the B<FS_IOC_SETFLAGS> "
"operation, the effective user ID of the caller must match the owner of the "
"file, or the caller must have the B<CAP_FOWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:214
msgid ""
"The type of the argument given to the B<FS_IOC_GETFLAGS> and "
"B<FS_IOC_SETFLAGS> operations is I<int\\ *>, notwithstanding the implication "
"in the kernel source file I<include/uapi/linux/fs.h> that the argument is "
"I<long\\ *>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_iflags.2:223
msgid ""
"B<chattr>(1), B<lsattr>(1), B<mount>(2), B<btrfs>(5), B<ext4>(5), B<xfs>(5), "
"B<xattr>(7), B<mount>(8)"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_ns.2:26
#, fuzzy, no-wrap
#| msgid "IOCTL"
msgid "IOCTL_NS"
msgstr "IOCTL"

#. type: Plain text
#: build/C/man2/ioctl_ns.2:29
msgid "ioctl_ns - ioctl() operations for Linux namespaces"
msgstr ""

#.  ============================================================
#. type: SS
#: build/C/man2/ioctl_ns.2:32
#, no-wrap
msgid "Discovering namespace relationships"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:40
msgid ""
"The following B<ioctl>(2)  operations are provided to allow discovery of "
"namespace relationships (see B<user_namespaces>(7)  and "
"B<pid_namespaces>(7)).  The form of the calls is:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:44
#, no-wrap
msgid "new_fd = ioctl(fd, request);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:53
msgid ""
"In each case, I<fd> refers to a I</proc/[pid]/ns/*> file.  Both operations "
"return a new file descriptor on success."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ns.2:53
#, no-wrap
msgid "B<NS_GET_USERNS> (since Linux 4.9)"
msgstr ""

#.  commit bcac25a58bfc6bd79191ac5d7afb49bea96da8c9
#.  commit 6786741dbf99e44fb0c0ed85a37582b8a26f1c3b
#. type: Plain text
#: build/C/man2/ioctl_ns.2:60
msgid ""
"Returns a file descriptor that refers to the owning user namespace for the "
"namespace referred to by I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_ns.2:60
#, no-wrap
msgid "B<NS_GET_PARENT> (since Linux 4.9)"
msgstr ""

#.  commit a7306ed8d94af729ecef8b6e37506a1c6fc14788
#. type: Plain text
#: build/C/man2/ioctl_ns.2:72
msgid ""
"Returns a file descriptor that refers to the parent namespace of the "
"namespace referred to by I<fd>.  This operation is valid only for "
"hierarchical namespaces (i.e., PID and user namespaces).  For user "
"namespaces, B<NS_GET_PARENT> is synonymous with B<NS_GET_USERNS>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:80
msgid ""
"The new file descriptor returned by these operations is opened with the "
"B<O_RDONLY> and B<O_CLOEXEC> (close-on-exec; see B<fcntl>(2))  flags."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:93
msgid ""
"By applying B<fstat>(2)  to the returned file descriptor, one obtains a "
"I<stat> structure whose I<st_dev> (resident device) and I<st_ino> (inode "
"number) fields together identify the owning/parent namespace.  This inode "
"number can be matched with the inode number of another I</proc/[pid]/ns/{pid,"
"user}> file to determine whether that is the owning/parent namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:97
msgid ""
"Either of these B<ioctl>(2)  operations can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:104
msgid ""
"The requested namespace is outside of the caller's namespace scope.  This "
"error can occur if, for example, the owning user namespace is an ancestor of "
"the caller's current user namespace.  It can also occur on attempts to "
"obtain the parent of the initial user or PID namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:107
msgid "The operation is not supported by this kernel version."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:111
msgid ""
"Additionally, the B<NS_GET_PARENT> operation can fail with the following "
"error:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:115
msgid "I<fd> refers to a nonhierarchical namespace."
msgstr ""

#.  ============================================================
#. type: Plain text
#: build/C/man2/ioctl_ns.2:119
msgid "See the EXAMPLES section for an example of the use of these operations."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_ns.2:119
#, no-wrap
msgid "Discovering the namespace type"
msgstr ""

#.  commit e5ff5ce6e20ee22511398bb31fb912466cf82a36
#. type: Plain text
#: build/C/man2/ioctl_ns.2:126
msgid ""
"The B<NS_GET_NSTYPE> operation (available since Linux 4.11) can be used to "
"discover the type of namespace referred to by the file descriptor I<fd>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:130
#, no-wrap
msgid "nstype = ioctl(fd, NS_GET_NSTYPE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:137
msgid "I<fd> refers to a I</proc/[pid]/ns/*> file."
msgstr ""

#.  ============================================================
#. type: Plain text
#: build/C/man2/ioctl_ns.2:147
msgid ""
"The return value is one of the B<CLONE_NEW*> values that can be specified to "
"B<clone>(2)  or B<unshare>(2)  in order to create a namespace."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_ns.2:147
#, no-wrap
msgid "Discovering the owner of a user namespace"
msgstr ""

#.  commit 015bb305b8ebe8d601a238ab70ebdc394c7a19ba
#. type: Plain text
#: build/C/man2/ioctl_ns.2:155
msgid ""
"The B<NS_GET_OWNER_UID> operation (available since Linux 4.11) can be used "
"to discover the owner user ID of a user namespace (i.e., the effective user "
"ID of the process that created the user namespace).  The form of the call is:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:160
#, no-wrap
msgid ""
"uid_t uid;\n"
"ioctl(fd, NS_GET_OWNER_UID, &uid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:167
msgid "I<fd> refers to a I</proc/[pid]/ns/user> file."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:171
msgid ""
"The owner user ID is returned in the I<uid_t> pointed to by the third "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:173
msgid "This operation can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:177
msgid "I<fd> does not refer to a user namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:181
msgid ""
"Any of the above B<ioctl>()  operations can return the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:187
msgid "I<fd> does not refer to a I</proc/[pid]/ns/*> file."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:189
msgid ""
"Namespaces and the operations described on this page are a Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:196
msgid ""
"The example shown below uses the B<ioctl>(2)  operations described above to "
"perform simple discovery of namespace relationships.  The following shell "
"sessions show various examples of the use of this program."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:199
msgid ""
"Trying to get the parent of the initial user namespace fails, since it has "
"no parent:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:204
#, no-wrap
msgid ""
"$ B<./ns_show /proc/self/ns/user p>\n"
"The parent namespace is outside your namespace scope\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:211
msgid ""
"Create a process running B<sleep>(1)  that resides in new user and UTS "
"namespaces, and show that the new UTS namespace is associated with the new "
"user namespace:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:220
#, no-wrap
msgid ""
"$ B<unshare -Uu sleep 1000 &>\n"
"[1] 23235\n"
"$ B<./ns_show /proc/23235/ns/uts u>\n"
"Device/Inode of owning user namespace is: [0,3] / 4026532448\n"
"$ B<readlink /proc/23235/ns/user>\n"
"user:[4026532448]\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:225
msgid ""
"Then show that the parent of the new user namespace in the preceding example "
"is the initial user namespace:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:232
#, no-wrap
msgid ""
"$ B<readlink /proc/self/ns/user>\n"
"user:[4026531837]\n"
"$ B<./ns_show /proc/23235/ns/user p>\n"
"Device/Inode of parent namespace is: [0,3] / 4026531837\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:240
msgid ""
"Start a shell in a new user namespace, and show that from within this shell, "
"the parent user namespace can't be discovered.  Similarly, the UTS namespace "
"(which is associated with the initial user namespace)  can't be discovered."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:248
#, no-wrap
msgid ""
"$ B<PS1=\"sh2$ \" unshare -U bash>\n"
"sh2$ B<./ns_show /proc/self/ns/user p>\n"
"The parent namespace is outside your namespace scope\n"
"sh2$ B<./ns_show /proc/self/ns/uts u>\n"
"The owning user namespace is outside your namespace scope\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:254
#, no-wrap
msgid "/* ns_show.c\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:267
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:273
#, no-wrap
msgid ""
"#ifndef NS_GET_USERNS\n"
"#define NSIO    0xb7\n"
"#define NS_GET_USERNS   _IO(NSIO, 0x1)\n"
"#define NS_GET_PARENT   _IO(NSIO, 0x2)\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:279
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, userns_fd, parent_fd;\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:290
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s /proc/[pid]/ns/[file] [p|u]\\en\",\n"
"                argv[0]);\n"
"        fprintf(stderr, \"\\enDisplay the result of one or both \"\n"
"                \"of NS_GET_USERNS (u) or NS_GET_PARENT (p)\\en\"\n"
"                \"for the specified /proc/[pid]/ns/[file]. If neither \"\n"
"                \"\\(aqp\\(aq nor \\(aqu\\(aq is specified,\\en\"\n"
"                \"NS_GET_USERNS is the default.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:293
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the \\(aqns\\(aq file specified\n"
"       in argv[1] */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:302
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the owning user namespace and\n"
"       then obtain and display the inode number of that namespace */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:305
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strchr(argv[2], \\(aqu\\(aq)) {\n"
"        userns_fd = ioctl(fd, NS_GET_USERNS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:314
#, no-wrap
msgid ""
"        if (userns_fd == -1) {\n"
"            if (errno == EPERM)\n"
"                printf(\"The owning user namespace is outside \"\n"
"                        \"your namespace scope\\en\");\n"
"            else\n"
"               perror(\"ioctl-NS_GET_USERNS\");\n"
"            exit(EXIT_FAILURE);\n"
"         }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:324
#, no-wrap
msgid ""
"        if (fstat(userns_fd, &sb) == -1) {\n"
"            perror(\"fstat-userns\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"Device/Inode of owning user namespace is: \"\n"
"                \"[%jx,%jx] / %ju\\en\",\n"
"                (uintmax_t) major(sb.st_dev),\n"
"                (uintmax_t) minor(sb.st_dev),\n"
"                (uintmax_t) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:327
#, no-wrap
msgid ""
"        close(userns_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:330
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the parent namespace and\n"
"       then obtain and display the inode number of that namespace */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:333
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq)) {\n"
"        parent_fd = ioctl(fd, NS_GET_PARENT);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:345
#, no-wrap
msgid ""
"        if (parent_fd == -1) {\n"
"            if (errno == EINVAL)\n"
"                printf(\"Can\\(aq get parent namespace of a \"\n"
"                        \"nonhierarchical namespace\\en\");\n"
"            else if (errno == EPERM)\n"
"                printf(\"The parent namespace is outside \"\n"
"                        \"your namespace scope\\en\");\n"
"            else\n"
"                perror(\"ioctl-NS_GET_PARENT\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:354
#, no-wrap
msgid ""
"        if (fstat(parent_fd, &sb) == -1) {\n"
"            perror(\"fstat-parentns\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"Device/Inode of parent namespace is: [%jx,%jx] / %ju\\en\",\n"
"                (uintmax_t) major(sb.st_dev),\n"
"                (uintmax_t) minor(sb.st_dev),\n"
"                (uintmax_t) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:357
#, no-wrap
msgid ""
"        close(parent_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_ns.2:366
msgid "B<fstat>(2), B<ioctl>(2), B<proc>(5), B<namespaces>(7)"
msgstr ""

#. type: TH
#: build/C/man2/ioctl_tty.2:8
#, fuzzy, no-wrap
#| msgid "IOCTL"
msgid "IOCTL_TTY"
msgstr "IOCTL"

#. type: Plain text
#: build/C/man2/ioctl_tty.2:11
msgid "ioctl_tty - ioctls for terminals and serial lines"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:13
#, fuzzy
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid "B<#include E<lt>termios.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man2/ioctl_tty.2:15
#, fuzzy
#| msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgid "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl_tty.2:23
msgid ""
"The B<ioctl>(2)  call for terminals and serial ports accepts many possible "
"command arguments.  Most require a third argument, of varying type, here "
"called I<argp> or I<arg>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:30
msgid ""
"Use of I<ioctl> makes for nonportable programs.  Use the POSIX interface "
"described in B<termios>(3)  whenever possible."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:30
#, no-wrap
msgid "Get and set terminal attributes"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:31
#, no-wrap
msgid "B<TCGETS\tstruct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:35
msgid "Equivalent to I<tcgetattr(fd, argp)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:37
msgid "Get the current serial port settings."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:37
#, no-wrap
msgid "B<TCSETS\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:41
msgid "Equivalent to I<tcsetattr(fd, TCSANOW, argp)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:43
msgid "Set the current serial port settings."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:43
#, no-wrap
msgid "B<TCSETSW\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:47
msgid "Equivalent to I<tcsetattr(fd, TCSADRAIN, argp)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:50
msgid ""
"Allow the output buffer to drain, and set the current serial port settings."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:50
#, no-wrap
msgid "B<TCSETSF\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:54
msgid "Equivalent to I<tcsetattr(fd, TCSAFLUSH, argp)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:57
msgid ""
"Allow the output buffer to drain, discard pending input, and set the current "
"serial port settings."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:67
msgid ""
"The following four ioctls are just like B<TCGETS>, B<TCSETS>, B<TCSETSW>, "
"B<TCSETSF>, except that they take a I<struct termio\\ *> instead of a "
"I<struct termios\\ *>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:69
msgid "B<TCGETA\tstruct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:71
msgid "B<TCSETA\tconst struct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:73
msgid "B<TCSETAW\tconst struct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:75
msgid "B<TCSETAF\tconst struct termio *>I<argp>"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:75
#, no-wrap
msgid "Locking the termios structure"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:83
msgid ""
"The I<termios> structure of a terminal can be locked.  The lock is itself a "
"I<termios> structure, with nonzero bits or fields indicating a locked value."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:83
#, no-wrap
msgid "B<TIOCGLCKTRMIOS\tstruct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:88
msgid "Gets the locking status of the I<termios> structure of the terminal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:88
#, no-wrap
msgid "B<TIOCSLCKTRMIOS\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:96
msgid ""
"Sets the locking status of the I<termios> structure of the terminal.  Only a "
"process with the B<CAP_SYS_ADMIN> capability can do this."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:96
#, no-wrap
msgid "Get and set window size"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:101
msgid ""
"Window sizes are kept in the kernel, but not used by the kernel (except in "
"the case of virtual consoles, where the kernel will update the window size "
"when the size of the virtual console changes, for example, by loading a new "
"font)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:104
msgid ""
"The following constants and structure are defined in I<E<lt>sys/ioctl."
"hE<gt>>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:104
#, no-wrap
msgid "B<TIOCGWINSZ\tstruct winsize *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:107
msgid "Get window size."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:107
#, no-wrap
msgid "B<TIOCSWINSZ\tconst struct winsize *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:110
msgid "Set window size."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:112
msgid "The struct used by these ioctls is defined as"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:121
#, no-wrap
msgid ""
"struct winsize {\n"
"    unsigned short ws_row;\n"
"    unsigned short ws_col;\n"
"    unsigned short ws_xpixel;   /* unused */\n"
"    unsigned short ws_ypixel;   /* unused */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:128
msgid ""
"When the window size changes, a B<SIGWINCH> signal is sent to the foreground "
"process group."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:128
#, no-wrap
msgid "Sending a break"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:129
#, no-wrap
msgid "B<TCSBRK\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:133
msgid "Equivalent to I<tcsendbreak(fd, arg)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:144
msgid ""
"If the terminal is using asynchronous serial data transmission, and I<arg> "
"is zero, then send a break (a stream of zero bits) for between 0.25 and 0.5 "
"seconds.  If the terminal is not using asynchronous serial data "
"transmission, then either a break is sent, or the function returns without "
"doing anything.  When I<arg> is nonzero, nobody knows what will happen."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:162
msgid ""
"(SVr4, UnixWare, Solaris, Linux treat I<tcsendbreak(fd,arg)> with nonzero "
"I<arg> like I<tcdrain(fd)>.  SunOS treats I<arg> as a multiplier, and sends "
"a stream of bits I<arg> times as long as done for zero I<arg>.  DG/UX and "
"AIX treat I<arg> (when nonzero) as a time interval measured in "
"milliseconds.  HP-UX ignores I<arg>.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:162
#, no-wrap
msgid "B<TCSBRKP\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:170
msgid ""
"So-called \"POSIX version\" of B<TCSBRK>.  It treats nonzero I<arg> as a "
"time interval measured in deciseconds, and does nothing when the driver does "
"not support breaks."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:170
#, no-wrap
msgid "B<TIOCSBRK\tvoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:173
msgid "Turn break on, that is, start sending zero bits."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:173
#, no-wrap
msgid "B<TIOCCBRK\tvoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:176
msgid "Turn break off, that is, stop sending zero bits."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:176
#, no-wrap
msgid "Software flow control"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:177
#, no-wrap
msgid "B<TCXONC\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:181
msgid "Equivalent to I<tcflow(fd, arg)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:189
msgid ""
"See B<tcflow>(3)  for the argument values B<TCOOFF>, B<TCOON>, B<TCIOFF>, "
"B<TCION>."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:189
#, no-wrap
msgid "Buffer count and flushing"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:190
#, no-wrap
msgid "B<FIONREAD\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:193
msgid "Get the number of bytes in the input buffer."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:193
#, no-wrap
msgid "B<TIOCINQ\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:197
msgid "Same as B<FIONREAD>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:197
#, no-wrap
msgid "B<TIOCOUTQ\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:200
msgid "Get the number of bytes in the output buffer."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:200
#, no-wrap
msgid "B<TCFLSH\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:204
msgid "Equivalent to I<tcflush(fd, arg)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:211
msgid ""
"See B<tcflush>(3)  for the argument values B<TCIFLUSH>, B<TCOFLUSH>, "
"B<TCIOFLUSH>."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:211
#, no-wrap
msgid "Faking input"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:212
#, no-wrap
msgid "B<TIOCSTI\tconst char *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:215
msgid "Insert the given byte in the input queue."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:215
#, no-wrap
msgid "Redirecting console output"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:216
#, no-wrap
msgid "B<TIOCCONS\tvoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:238
msgid ""
"Redirect output that would have gone to I</dev/console> or I</dev/tty0> to "
"the given terminal.  If that was a pseudoterminal master, send it to the "
"slave.  In Linux before version 2.6.10, anybody can do this as long as the "
"output was not redirected yet; since version 2.6.10, only a process with the "
"B<CAP_SYS_ADMIN> capability may do this.  If output was redirected already, "
"then B<EBUSY> is returned, but redirection can be stopped by using this "
"ioctl with I<fd> pointing at I</dev/console> or I</dev/tty0>."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:238
#, no-wrap
msgid "Controlling terminal"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:239
#, no-wrap
msgid "B<TIOCSCTTY\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:247
msgid ""
"Make the given terminal the controlling terminal of the calling process.  "
"The calling process must be a session leader and not have a controlling "
"terminal already.  For this case, I<arg> should be specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:257
msgid ""
"If this terminal is already the controlling terminal of a different session "
"group, then the ioctl fails with B<EPERM>, unless the caller has the "
"B<CAP_SYS_ADMIN> capability and I<arg> equals 1, in which case the terminal "
"is stolen, and all processes that had it as controlling terminal lose it."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:257
#, fuzzy, no-wrap
#| msgid "B<ENOTTY>"
msgid "B<TIOCNOTTY\tvoid>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl_tty.2:268
msgid ""
"If the given terminal was the controlling terminal of the calling process, "
"give up this controlling terminal.  If the process was session leader, then "
"send B<SIGHUP> and B<SIGCONT> to the foreground process group and all "
"processes in the current session lose their controlling terminal."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:268
#, no-wrap
msgid "Process group and session ID"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:269
#, no-wrap
msgid "B<TIOCGPGRP\tpid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:273
msgid "When successful, equivalent to I<*argp = tcgetpgrp(fd)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:275
msgid ""
"Get the process group ID of the foreground process group on this terminal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:275
#, no-wrap
msgid "B<TIOCSPGRP\tconst pid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:279
msgid "Equivalent to I<tcsetpgrp(fd, *argp)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:281
msgid "Set the foreground process group ID of this terminal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:281
#, no-wrap
msgid "B<TIOCGSID\tpid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:289
msgid ""
"Get the session ID of the given terminal.  This fails with the error "
"B<ENOTTY> if the terminal is not a master pseudoterminal and not our "
"controlling terminal.  Strange."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:289
#, no-wrap
msgid "Exclusive mode"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:290
#, no-wrap
msgid "B<TIOCEXCL\tvoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:301
msgid ""
"Put the terminal into exclusive mode.  No further B<open>(2)  operations on "
"the terminal are permitted.  (They fail with B<EBUSY>, except for a process "
"with the B<CAP_SYS_ADMIN> capability.)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:301
#, no-wrap
msgid "B<TIOCGEXCL\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:309
msgid ""
"(since Linux 3.8)  If the terminal is currently in exclusive mode, place a "
"nonzero value in the location pointed to by I<argp>; otherwise, place zero "
"in I<*argp>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:309
#, no-wrap
msgid "B<TIOCNXCL\tvoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:312
msgid "Disable exclusive mode."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:312
#, no-wrap
msgid "Line discipline"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:313
#, no-wrap
msgid "B<TIOCGETD\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:316
msgid "Get the line discipline of the terminal."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:316
#, no-wrap
msgid "B<TIOCSETD\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:319
msgid "Set the line discipline of the terminal."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:319
#, no-wrap
msgid "Pseudoterminal ioctls"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:320
#, no-wrap
msgid "B<TIOCPKT\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:337
msgid ""
"Enable (when *I<argp> is nonzero) or disable packet mode.  Can be applied to "
"the master side of a pseudoterminal only (and will return B<ENOTTY> "
"otherwise).  In packet mode, each subsequent B<read>(2)  will return a "
"packet that either contains a single nonzero control byte, or has a single "
"byte containing zero (\\(aq\\e0\\(aq) followed by data written on the slave "
"side of the pseudoterminal.  If the first byte is not B<TIOCPKT_DATA> (0), "
"it is an OR of one or more of the following bits:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:340
#, no-wrap
msgid "TIOCPKT_FLUSHREAD"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:340
#, no-wrap
msgid "The read queue for the terminal is flushed."
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:341
#, no-wrap
msgid "TIOCPKT_FLUSHWRITE"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:341
#, no-wrap
msgid "The write queue for the terminal is flushed."
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:342
#, no-wrap
msgid "TIOCPKT_STOP"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:342
#, no-wrap
msgid "Output to the terminal is stopped."
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:343
#, no-wrap
msgid "TIOCPKT_START"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:343
#, no-wrap
msgid "Output to the terminal is restarted."
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:344
#, no-wrap
msgid "TIOCPKT_DOSTOP"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:344
#, no-wrap
msgid "The start and stop characters are B<\\(haS>/B<\\(haQ>."
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:345
#, no-wrap
msgid "TIOCPKT_NOSTOP"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:345
#, no-wrap
msgid "The start and stop characters are not B<\\(haS>/B<\\(haQ>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:357
msgid ""
"While packet mode is in use, the presence of control status information to "
"be read from the master side may be detected by a B<select>(2)  for "
"exceptional conditions or a B<poll>(2)  for the B<POLLPRI> event."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:364
msgid ""
"This mode is used by B<rlogin>(1)  and B<rlogind>(8)  to implement a remote-"
"echoed, locally B<\\(haS>/B<\\(haQ> flow-controlled remote login."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:364
#, no-wrap
msgid "B<TIOCGPKT\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:369
msgid ""
"(since Linux 3.8)  Return the current packet mode setting in the integer "
"pointed to by I<argp>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:369
#, no-wrap
msgid "B<TIOCSPTLCK\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:378
msgid ""
"Set (if I<*argp> is nonzero) or remove (if I<*argp> is zero) the lock on the "
"pseudoterminal slave device.  (See also B<unlockpt>(3).)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:378
#, no-wrap
msgid "B<TIOCGPTLCK\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:384
msgid ""
"(since Linux 3.8)  Place the current lock state of the pseudoterminal slave "
"device in the location pointed to by I<argp>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:384
#, no-wrap
msgid "B<TIOCGPTPEER\tint >I<flags>"
msgstr ""

#.  commit 54ebbfb1603415d9953c150535850d30609ef077
#. type: Plain text
#: build/C/man2/ioctl_tty.2:399
msgid ""
"(since Linux 4.13)  Given a file descriptor in I<fd> that refers to a "
"pseudoterminal master, open (with the given B<open>(2)-style I<flags>)  and "
"return a new file descriptor that refers to the peer pseudoterminal slave "
"device.  This operation can be performed regardless of whether the pathname "
"of the slave device is accessible through the calling process's mount "
"namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:410
msgid ""
"Security-conscious programs interacting with namespaces may wish to use this "
"operation rather than B<open>(2)  with the pathname returned by "
"B<ptsname>(3), and similar library functions that have insecure APIs.  (For "
"example, confusion can occur in some cases using B<ptsname>(3)  with a "
"pathname where a devpts filesystem has been mounted in a different mount "
"namespace.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:417
msgid ""
"The BSD ioctls B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL>, B<TIOCREMOTE> have "
"not been implemented under Linux."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:417
#, no-wrap
msgid "Modem control"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:418
#, no-wrap
msgid "B<TIOCMGET\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:421
msgid "Get the status of modem bits."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:421
#, no-wrap
msgid "B<TIOCMSET\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:424
msgid "Set the status of modem bits."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:424
#, no-wrap
msgid "B<TIOCMBIC\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:427
msgid "Clear the indicated modem bits."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:427
#, no-wrap
msgid "B<TIOCMBIS\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:430
msgid "Set the indicated modem bits."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:432
msgid "The following bits are used by the above ioctls:"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:435
#, no-wrap
msgid "TIOCM_LE"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:435
#, no-wrap
msgid "DSR (data set ready/line enable)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:436
#, no-wrap
msgid "TIOCM_DTR"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:436
#, no-wrap
msgid "DTR (data terminal ready)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:437
#, no-wrap
msgid "TIOCM_RTS"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:437
#, no-wrap
msgid "RTS (request to send)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:438
#, no-wrap
msgid "TIOCM_ST"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:438
#, no-wrap
msgid "Secondary TXD (transmit)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:439
#, no-wrap
msgid "TIOCM_SR"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:439
#, no-wrap
msgid "Secondary RXD (receive)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:440
#, no-wrap
msgid "TIOCM_CTS"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:440
#, no-wrap
msgid "CTS (clear to send)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:441
#, no-wrap
msgid "TIOCM_CAR"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:441
#, no-wrap
msgid "DCD (data carrier detect)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:442
#, no-wrap
msgid "TIOCM_CD"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:442
#, no-wrap
msgid "see TIOCM_CAR"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:443
#, no-wrap
msgid "TIOCM_RNG"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:443
#, no-wrap
msgid "RNG (ring)"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:444
#, no-wrap
msgid "TIOCM_RI"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:444
#, no-wrap
msgid "see TIOCM_RNG"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:445
#, no-wrap
msgid "TIOCM_DSR"
msgstr ""

#. type: tbl table
#: build/C/man2/ioctl_tty.2:445
#, no-wrap
msgid "DSR (data set ready)"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:447
#, no-wrap
msgid "B<TIOCMIWAIT\tint >I<arg>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:461
msgid ""
"Wait for any of the 4 modem bits (DCD, RI, DSR, CTS) to change.  The bits of "
"interest are specified as a bit mask in I<arg>, by ORing together any of the "
"bit values, B<TIOCM_RNG>, B<TIOCM_DSR>, B<TIOCM_CD>, and B<TIOCM_CTS>.  The "
"caller should use B<TIOCGICOUNT> to see which bit has changed."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:461
#, no-wrap
msgid "B<TIOCGICOUNT\tstruct serial_icounter_struct *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:468
msgid ""
"Get counts of input serial line interrupts (DCD, RI, DSR, CTS).  The counts "
"are written to the I<serial_icounter_struct> structure pointed to by I<argp>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:471
msgid ""
"Note: both 1-E<gt>0 and 0-E<gt>1 transitions are counted, except for RI, "
"where only 0-E<gt>1 transitions are counted."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:471
#, no-wrap
msgid "Marking a line as local"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:472
#, no-wrap
msgid "B<TIOCGSOFTCAR\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:478
msgid ""
"(\"Get software carrier flag\")  Get the status of the CLOCAL flag in the "
"c_cflag field of the I<termios> structure."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:478
#, no-wrap
msgid "B<TIOCSSOFTCAR\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:486
msgid ""
"(\"Set software carrier flag\")  Set the CLOCAL flag in the I<termios> "
"structure when *I<argp> is nonzero, and clear it otherwise."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:501
msgid ""
"If the B<CLOCAL> flag for a line is off, the hardware carrier detect (DCD)  "
"signal is significant, and an B<open>(2)  of the corresponding terminal will "
"block until DCD is asserted, unless the B<O_NONBLOCK> flag is given.  If "
"B<CLOCAL> is set, the line behaves as if DCD is always asserted.  The "
"software carrier flag is usually turned on for local devices, and is off for "
"lines with modems."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:501
#, no-wrap
msgid "Linux-specific"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:506
msgid "For the B<TIOCLINUX> ioctl, see B<ioctl_console>(2)."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_tty.2:506
#, no-wrap
msgid "Kernel debugging"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:508
#, fuzzy
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid "B<#include E<lt>linux/tty.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: TP
#: build/C/man2/ioctl_tty.2:508
#, no-wrap
msgid "B<TIOCTTYGSTRUCT\tstruct tty_struct *>I<argp>"
msgstr ""

#
#
#
#.      commit b3506a09d15dc5aee6d4bb88d759b157016e1864
#.      Author: Andries E. Brouwer <andries.brouwer@cwi.nl>
#.      Date:   Tue Apr 1 04:42:46 2003 -0800
#.      [PATCH] kill TIOCTTYGSTRUCT
#.      Only used for (dubious) debugging purposes, and exposes
#.      internal kernel state.
#.  .SS Serial info
#.  .BR "#include <linux/serial.h>"
#.  .PP
#.  .TP
#.  .BI "TIOCGSERIAL	struct serial_struct *" argp
#.  Get serial info.
#.  .TP
#.  .BI "TIOCSSERIAL	const struct serial_struct *" argp
#.  Set serial info.
#. type: Plain text
#: build/C/man2/ioctl_tty.2:533
msgid ""
"Get the I<tty_struct> corresponding to I<fd>.  This command was removed in "
"Linux 2.5.67."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:540
msgid ""
"The B<ioctl>(2)  system call returns 0 on success.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:544
msgid "Invalid command parameter."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_tty.2:544
#, fuzzy, no-wrap
#| msgid "B<ENOTTY>"
msgid "B<ENOIOCTLCMD>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man2/ioctl_tty.2:547
msgid "Unknown command."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:551
msgid "Inappropriate I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:556
msgid "Check the condition of DTR on the serial port."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:561
#, no-wrap
msgid ""
"#include E<lt>termios.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:566
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd, serial;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_tty.2:575
#, no-wrap
msgid ""
"    fd = open(\"/dev/ttyS0\", O_RDONLY);\n"
"    ioctl(fd, TIOCMGET, &serial);\n"
"    if (serial & TIOCM_DTR)\n"
"        puts(\"TIOCM_DTR is set\");\n"
"    else\n"
"        puts(\"TIOCM_DTR is not set\");\n"
"    close(fd);\n"
"}\n"
msgstr ""

#.  FIONBIO			const int *
#.  FIONCLEX			void
#.  FIOCLEX			void
#.  FIOASYNC			const int *
#.  from serial.c:
#.  TIOCSERCONFIG		void
#.  TIOCSERGWILD		int *
#.  TIOCSERSWILD		const int *
#.  TIOCSERGSTRUCT		struct async_struct *
#.  TIOCSERGETLSR		int *
#.  TIOCSERGETMULTI		struct serial_multiport_struct *
#.  TIOCSERSETMULTI		const struct serial_multiport_struct *
#.  TIOCGSERIAL, TIOCSSERIAL (see above)
#. type: Plain text
#: build/C/man2/ioctl_tty.2:596
#, fuzzy
#| msgid ""
#| "B<execve>(2), B<fcntl>(2), B<ioctl_list>(2), B<open>(2), B<sd>(4), "
#| "B<tty>(4)"
msgid ""
"B<ldattach>(1), B<ioctl>(2), B<ioctl_console>(2), B<termios>(3), B<pty>(7)"
msgstr ""
"B<execve>(2), B<fcntl>(2), B<ioctl_list>(2), B<open>(2), B<sd>(4), B<tty>(4)"

#. type: TH
#: build/C/man2/ioctl_userfaultfd.2:28
#, no-wrap
msgid "IOCTL_USERFAULTFD"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:32
msgid ""
"ioctl_userfaultfd - create a file descriptor for handling page faults in "
"user space"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:35
#, fuzzy, no-wrap
#| msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgid "B<#include E<lt>sys/ioctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:37
#, fuzzy, no-wrap
#| msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgid "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>\n"
msgstr "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:44
msgid ""
"Various B<ioctl>(2)  operations can be performed on a userfaultfd object "
"(created by a call to B<userfaultfd>(2))  using calls of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:48
#, no-wrap
msgid "ioctl(fd, cmd, argp);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:58
msgid ""
"In the above, I<fd> is a file descriptor referring to a userfaultfd object, "
"I<cmd> is one of the commands listed below, and I<argp> is a pointer to a "
"data structure that is specific to I<cmd>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:78
msgid ""
"The various B<ioctl>(2)  operations are described below.  The B<UFFDIO_API>, "
"B<UFFDIO_REGISTER>, and B<UFFDIO_UNREGISTER> operations are used to "
"I<configure> userfaultfd behavior.  These operations allow the caller to "
"choose what features will be enabled and what kinds of events will be "
"delivered to the application.  The remaining operations are I<range> "
"operations.  These operations enable the calling application to resolve page-"
"fault events."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:78
#, no-wrap
msgid "UFFDIO_API"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:81
msgid ""
"(Since Linux 4.3.)  Enable operation of the userfaultfd and perform API "
"handshake."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:87
msgid ""
"The I<argp> argument is a pointer to a I<uffdio_api> structure, defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:95
#, no-wrap
msgid ""
"struct uffdio_api {\n"
"    __u64 api;        /* Requested API version (input) */\n"
"    __u64 features;   /* Requested features (input/output) */\n"
"    __u64 ioctls;     /* Available ioctl() operations (output) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:101
msgid "The I<api> field denotes the API version requested by the application."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:110
msgid ""
"The kernel verifies that it can support the requested API version, and sets "
"the I<features> and I<ioctls> fields to bit masks representing all the "
"available features and the generic B<ioctl>(2)  operations available."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:119
msgid ""
"For Linux kernel versions before 4.11, the I<features> field must be "
"initialized to zero before the call to B<UFFDIO_API>, and zero (i.e., no "
"feature bits) is placed in the I<features> field by the kernel upon return "
"from B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:127
msgid ""
"Starting from Linux 4.11, the I<features> field can be used to ask whether "
"particular features are supported and explicitly enable userfaultfd features "
"that are disabled by default.  The kernel always reports all the available "
"features in the I<features> field."
msgstr ""

#.  FIXME add more details about feature negotiation and enablement
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:138
msgid ""
"To enable userfaultfd features the application should set a bit "
"corresponding to each feature it wants to enable in the I<features> field.  "
"If the kernel supports all the requested features it will enable them.  "
"Otherwise it will zero out the returned I<uffdio_api> structure and return "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:140
msgid "The following feature bits may be set:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:140
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_FORK> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:149
msgid ""
"When this feature is enabled, the userfaultfd objects associated with a "
"parent process are duplicated into the child process during B<fork>(2)  and "
"a B<UFFD_EVENT_FORK> event is delivered to the userfaultfd monitor"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:149
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_REMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:156
msgid ""
"If this feature is enabled, when the faulting process invokes B<mremap>(2), "
"the userfaultfd monitor will receive an event of type B<UFFD_EVENT_REMAP>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:156
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_REMOVE> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:168
msgid ""
"If this feature is enabled, when the faulting process calls B<madvise>(2)  "
"with the B<MADV_DONTNEED> or B<MADV_REMOVE> advice value to free a virtual "
"memory area the userfaultfd monitor will receive an event of type "
"B<UFFD_EVENT_REMOVE>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:168
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_UNMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:179
msgid ""
"If this feature is enabled, when the faulting process unmaps virtual memory "
"either explicitly with B<munmap>(2), or implicitly during either B<mmap>(2)  "
"or B<mremap>(2).  the userfaultfd monitor will receive an event of type "
"B<UFFD_EVENT_UNMAP>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:179
#, no-wrap
msgid "B<UFFD_FEATURE_MISSING_HUGETLBFS> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:184
msgid ""
"If this feature bit is set, the kernel supports registering userfaultfd "
"ranges on hugetlbfs virtual memory areas"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:184
#, no-wrap
msgid "B<UFFD_FEATURE_MISSING_SHMEM> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:199
msgid ""
"If this feature bit is set, the kernel supports registering userfaultfd "
"ranges on shared memory areas.  This includes all kernel shared memory APIs: "
"System V shared memory, B<tmpfs>(5), shared mappings of I</dev/zero>, "
"B<mmap>(2)  with the B<MAP_SHARED> flag set, B<memfd_create>(2), and so on."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:199
#, no-wrap
msgid "B<UFFD_FEATURE_SIGBUS> (since Linux 4.14)"
msgstr ""

#.  commit 2d6d6f5a09a96cc1fec7ed992b825e05f64cb50e
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:211
msgid ""
"If this feature bit is set, no page-fault events (B<UFFD_EVENT_PAGEFAULT>)  "
"will be delivered.  Instead, a B<SIGBUS> signal will be sent to the faulting "
"process.  Applications using this feature will not require the use of a "
"userfaultfd monitor for processing memory accesses to the regions registered "
"with userfaultfd."
msgstr ""

#.  FIXME This user-space API seems not fully polished. Why are there
#.  not constants defined for each of the bit-mask values listed below?
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:217
msgid "The returned I<ioctls> field can contain the following bits:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:217
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_API>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:222
msgid "The B<UFFDIO_API> operation is supported."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:222
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_REGISTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:227
msgid "The B<UFFDIO_REGISTER> operation is supported."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:227
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_UNREGISTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:232
msgid "The B<UFFDIO_UNREGISTER> operation is supported."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:240 build/C/man2/ioctl_userfaultfd.2:340
#: build/C/man2/ioctl_userfaultfd.2:391 build/C/man2/ioctl_userfaultfd.2:641
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error.  Possible errors "
"include:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:245 build/C/man2/ioctl_userfaultfd.2:349
msgid ""
"I<argp> refers to an address that is outside the calling process's "
"accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:250
msgid ""
"The userfaultfd has already been enabled by a previous B<UFFDIO_API> "
"operation."
msgstr ""

#
#.  FIXME In the above error case, the returned 'uffdio_api' structure is
#.  zeroed out. Why is this done? This should be explained in the manual page.
#.  Mike Rapoport:
#.      In my understanding the uffdio_api
#.      structure is zeroed to allow the caller
#.      to distinguish the reasons for -EINVAL.
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:266
msgid ""
"The API version requested in the I<api> field is not supported by this "
"kernel, or the I<features> field passed to the kernel includes feature bits "
"that are not supported by the current kernel version."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:266
#, no-wrap
msgid "UFFDIO_REGISTER"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:270
msgid ""
"(Since Linux 4.3.)  Register a memory address range with the userfaultfd "
"object.  The pages in the range must be \"compatible\"."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:274
msgid ""
"Up to Linux kernel 4.11, only private anonymous ranges are compatible for "
"registering with B<UFFDIO_REGISTER>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:278
msgid ""
"Since Linux 4.11, hugetlbfs and shared memory ranges are also compatible "
"with B<UFFDIO_REGISTER>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:284
msgid ""
"The I<argp> argument is a pointer to a I<uffdio_register> structure, defined "
"as:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:291
#, no-wrap
msgid ""
"struct uffdio_range {\n"
"    __u64 start;    /* Start of range */\n"
"    __u64 len;      /* Length of range (bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:297
#, no-wrap
msgid ""
"struct uffdio_register {\n"
"    struct uffdio_range range;\n"
"    __u64 mode;     /* Desired mode of operation (input) */\n"
"    __u64 ioctls;   /* Available ioctl() operations (output) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:307
msgid ""
"The I<range> field defines a memory range starting at I<start> and "
"continuing for I<len> bytes that should be handled by the userfaultfd."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:313
msgid ""
"The I<mode> field defines the mode of operation desired for this memory "
"region.  The following values may be bitwise ORed to set the userfaultfd "
"mode for the specified range:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:313
#, no-wrap
msgid "B<UFFDIO_REGISTER_MODE_MISSING>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:316
msgid "Track page faults on missing pages."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:316
#, no-wrap
msgid "B<UFFDIO_REGISTER_MODE_WP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:319
msgid "Track page faults on write-protected pages."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:322
msgid "Currently, the only supported mode is B<UFFDIO_REGISTER_MODE_MISSING>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:330
msgid ""
"If the operation is successful, the kernel modifies the I<ioctls> bit-mask "
"field to indicate which B<ioctl>(2)  operations are available for the "
"specified range.  This returned bit mask is as for B<UFFDIO_API>."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:340
#, fuzzy, no-wrap
#| msgid "B<EBADF>"
msgid "B<EBUSY>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:344
msgid ""
"A mapping in the specified range is registered with another userfaultfd "
"object."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:356
msgid ""
"An invalid or unsupported bit was specified in the I<mode> field; or the "
"I<mode> field was zero."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:359
msgid "There is no mapping in the specified address range."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:367
msgid ""
"I<range.start> or I<range.len> is not a multiple of the system page size; "
"or, I<range.len> is zero; or these fields are otherwise invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:373 build/C/man2/ioctl_userfaultfd.2:405
msgid "There as an incompatible mapping in the specified address range."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:373
#, no-wrap
msgid "UFFDIO_UNREGISTER"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:378
msgid ""
"(Since Linux 4.3.)  Unregister a memory address range from userfaultfd.  The "
"pages in the range must be \"compatible\" (see the description of "
"B<UFFDIO_REGISTER>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:383
msgid ""
"The address range to unregister is specified in the I<uffdio_range> "
"structure pointed to by I<argp>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:402
msgid ""
"Either the I<start> or the I<len> field of the I<ufdio_range> structure was "
"not a multiple of the system page size; or the I<len> field was zero; or "
"these fields were otherwise invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:409
msgid "There was no mapping in the specified address range."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:409
#, no-wrap
msgid "UFFDIO_COPY"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:420
msgid ""
"(Since Linux 4.3.)  Atomically copy a continuous memory chunk into the "
"userfault registered range and optionally wake up the blocked thread.  The "
"source and destination addresses and the number of bytes to copy are "
"specified by the I<src>, I<dst>, and I<len> fields of the I<uffdio_copy> "
"structure pointed to by I<argp>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:430
#, no-wrap
msgid ""
"struct uffdio_copy {\n"
"    __u64 dst;    /* Destination of copy */\n"
"    __u64 src;    /* Source of copy */\n"
"    __u64 len;    /* Number of bytes to copy */\n"
"    __u64 mode;   /* Flags controlling behavior of copy */\n"
"    __s64 copy;   /* Number of bytes copied, or negated error */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:438
msgid ""
"The following value may be bitwise ORed in I<mode> to change the behavior of "
"the B<UFFDIO_COPY> operation:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:438
#, no-wrap
msgid "B<UFFDIO_COPY_MODE_DONTWAKE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:441
msgid "Do not wake up the thread that waits for page-fault resolution"
msgstr ""

#.  FIXME Above: Why is the 'copy' field used to return error values?
#.  This should be explained in the manual page.
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:462
msgid ""
"The I<copy> field is used by the kernel to return the number of bytes that "
"was actually copied, or an error (a negated I<errno>-style value).  If the "
"value returned in I<copy> doesn't match the value that was specified in "
"I<len>, the operation fails with the error B<EAGAIN>.  The I<copy> field is "
"output-only; it is not read by the B<UFFDIO_COPY> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:471
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  In this case, the entire "
"area was copied.  On error, -1 is returned and I<errno> is set to indicate "
"the cause of the error.  Possible errors include:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:471 build/C/man2/ioctl_userfaultfd.2:575
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:479
msgid ""
"The number of bytes copied (i.e., the value returned in the I<copy> field)  "
"does not equal the value that was specified in the I<len> field."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:494
msgid ""
"Either I<dst> or I<len> was not a multiple of the system page size, or the "
"range specified by I<src> and I<len> or I<dst> and I<len> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:499 build/C/man2/ioctl_userfaultfd.2:597
msgid "An invalid bit was specified in the I<mode> field."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:499
#, no-wrap
msgid "B<ENOENT> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:505
msgid ""
"The faulting process has changed its virtual memory layout simultaneously "
"with an outstanding B<UFFDIO_COPY> operation."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:505
#, no-wrap
msgid "B<ENOSPC> (from Linux 4.11 until Linux 4.13)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:510 build/C/man2/ioctl_userfaultfd.2:516
msgid ""
"The faulting process has exited at the time of a B<UFFDIO_COPY> operation."
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:510 build/C/man2/ioctl_userfaultfd.2:597
#, no-wrap
msgid "B<ESRCH> (since Linux 4.13)"
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:516
#, no-wrap
msgid "UFFDIO_ZEROPAGE"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:519
msgid ""
"(Since Linux 4.3.)  Zero out a memory range registered with userfaultfd."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:526
msgid ""
"The requested range is specified by the I<range> field of the "
"I<uffdio_zeropage> structure pointed to by I<argp>:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:534
#, no-wrap
msgid ""
"struct uffdio_zeropage {\n"
"    struct uffdio_range range;\n"
"    __u64 mode;     /* Flags controlling behavior of copy */\n"
"    __s64 zeropage; /* Number of bytes zeroed, or negated error */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:542
msgid ""
"The following value may be bitwise ORed in I<mode> to change the behavior of "
"the B<UFFDIO_ZEROPAGE> operation:"
msgstr ""

#. type: TP
#: build/C/man2/ioctl_userfaultfd.2:542
#, no-wrap
msgid "B<UFFDIO_ZEROPAGE_MODE_DONTWAKE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:545
msgid "Do not wake up the thread that waits for page-fault resolution."
msgstr ""

#.  FIXME Why is the 'zeropage' field used to return error values?
#.  This should be explained in the manual page.
#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:566
msgid ""
"The I<zeropage> field is used by the kernel to return the number of bytes "
"that was actually zeroed, or an error in the same manner as B<UFFDIO_COPY>.  "
"If the value returned in the I<zeropage> field doesn't match the value that "
"was specified in I<range.len>, the operation fails with the error "
"B<EAGAIN>.  The I<zeropage> field is output-only; it is not read by the "
"B<UFFDIO_ZEROPAGE> operation."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:575
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  In this case, the entire "
"area was zeroed.  On error, -1 is returned and I<errno> is set to indicate "
"the cause of the error.  Possible errors include:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:583
msgid ""
"The number of bytes zeroed (i.e., the value returned in the I<zeropage> "
"field)  does not equal the value that was specified in the I<range.len> "
"field."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:592
msgid ""
"Either I<range.start> or I<range.len> was not a multiple of the system page "
"size; or I<range.len> was zero; or the range specified was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:603
msgid ""
"The faulting process has exited at the time of a B<UFFDIO_ZEROPAGE> "
"operation."
msgstr ""

#. type: SS
#: build/C/man2/ioctl_userfaultfd.2:603
#, no-wrap
msgid "UFFDIO_WAKE"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:607
msgid ""
"(Since Linux 4.3.)  Wake up the thread waiting for page-fault resolution on "
"a specified memory address range."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:627
msgid ""
"The B<UFFDIO_WAKE> operation is used in conjunction with B<UFFDIO_COPY> and "
"B<UFFDIO_ZEROPAGE> operations that have the B<UFFDIO_COPY_MODE_DONTWAKE> or "
"B<UFFDIO_ZEROPAGE_MODE_DONTWAKE> bit set in the I<mode> field.  The "
"userfault monitor can perform several B<UFFDIO_COPY> and B<UFFDIO_ZEROPAGE> "
"operations in a batch and then explicitly wake up the faulting thread using "
"B<UFFDIO_WAKE>."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:633
msgid ""
"The I<argp> argument is a pointer to a I<uffdio_range> structure (shown "
"above) that specifies the address range."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:652
msgid ""
"The I<start> or the I<len> field of the I<ufdio_range> structure was not a "
"multiple of the system page size; or I<len> was zero; or the specified range "
"was otherwise invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:654
msgid "See descriptions of the individual operations, above."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:658
msgid ""
"See descriptions of the individual operations, above.  In addition, the "
"following general errors can occur for all of the operations described above:"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:662
#, fuzzy
#| msgid "I<argp> references an inaccessible memory area."
msgid "I<argp> does not point to a valid memory address."
msgstr "I<argp> がアクセス不可能なメモリーを参照している。"

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:669
msgid ""
"(For all operations except B<UFFDIO_API>.)  The userfaultfd object has not "
"yet been enabled (via the B<UFFDIO_API> operation)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:673
msgid "These B<ioctl>(2)  operations are Linux-specific."
msgstr ""

#. type: SH
#: build/C/man2/ioctl_userfaultfd.2:673
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:682
msgid ""
"In order to detect available userfault features and enable some subset of "
"those features the userfaultfd file descriptor must be closed after the "
"first B<UFFDIO_API> operation that queries features availability and "
"reopened before the second B<UFFDIO_API> operation that actually enables the "
"desired features."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:685
msgid "See B<userfaultfd>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:689
msgid "B<ioctl>(2), B<mmap>(2), B<userfaultfd>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/ioctl_userfaultfd.2:692
msgid ""
"I<Documentation/admin-guide/mm/userfaultfd.rst> in the Linux kernel source "
"tree"
msgstr ""

#~ msgid "2014-12-31"
#~ msgstr "2014-12-31"
