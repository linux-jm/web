# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2021-03-12 14:01+0900\n"
"PO-Revision-Date: 2021-07-19 09:01+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/arp.7:12
#, no-wrap
msgid "ARP"
msgstr "ARP"

#. type: TH
#: build/C/man7/arp.7:12 build/C/man7/netdevice.7:17 build/C/man7/raw.7:12
#: build/C/man5/resolv.conf.5:23
#, no-wrap
msgid "2020-08-13"
msgstr "2020-08-13"

#. type: TH
#: build/C/man7/arp.7:12 build/C/man3/bswap.3:25 build/C/man3/cmsg.3:11
#: build/C/man7/ddp.7:12 build/C/man5/gai.conf.5:19 build/C/man1/getent.1:25
#: build/C/man3/getipnodebyname.3:26 build/C/man2/getpeername.2:42
#: build/C/man5/host.conf.5:26 build/C/man7/hostname.7:39
#: build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12
#: build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26
#: build/C/man3/inet_pton.3:27 build/C/man7/ip.7:42 build/C/man7/ipv6.7:86
#: build/C/man7/netdevice.7:17 build/C/man5/nss.5:19
#: build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:12
#: build/C/man5/protocols.5:29 build/C/man7/raw.7:12 build/C/man3/rcmd.3:43
#: build/C/man3/rexec.3:41 build/C/man5/services.5:34
#: build/C/man2/shutdown.2:40 build/C/man7/tcp.7:96 build/C/man7/udp.7:12
#: build/C/man7/udplite.7:27 build/C/man7/unix.7:20 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/arp.7:12 build/C/man3/bswap.3:25 build/C/man3/byteorder.3:32
#: build/C/man3/cmsg.3:11 build/C/man7/ddp.7:12 build/C/man3/endian.3:28
#: build/C/man3/ether_aton.3:31 build/C/man5/gai.conf.5:19
#: build/C/man3/getaddrinfo.3:44 build/C/man3/getaddrinfo_a.3:30
#: build/C/man3/gethostbyname.3:38 build/C/man3/getipnodebyname.3:26
#: build/C/man3/getnameinfo.3:10 build/C/man3/getnetent.3:30
#: build/C/man3/getnetent_r.3:26 build/C/man2/getpeername.2:42
#: build/C/man3/getprotoent.3:30 build/C/man3/getprotoent_r.3:26
#: build/C/man3/getservent.3:34 build/C/man3/getservent_r.3:26
#: build/C/man7/hostname.7:39 build/C/man5/hosts.5:27
#: build/C/man5/hosts.equiv.5:6 build/C/man7/icmp.7:12 build/C/man3/inet.3:42
#: build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26
#: build/C/man3/inet_pton.3:27 build/C/man7/ip.7:42 build/C/man7/ipv6.7:86
#: build/C/man7/netdevice.7:17 build/C/man8/nscd.8:23
#: build/C/man5/nscd.conf.5:20 build/C/man5/nss.5:19
#: build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:12
#: build/C/man5/protocols.5:29 build/C/man7/raw.7:12 build/C/man3/rcmd.3:43
#: build/C/man5/resolv.conf.5:23 build/C/man3/resolver.3:33
#: build/C/man3/rexec.3:41 build/C/man5/services.5:34
#: build/C/man3/setnetgrent.3:10 build/C/man2/shutdown.2:40
#: build/C/man7/tcp.7:96 build/C/man7/udp.7:12 build/C/man7/udplite.7:27
#: build/C/man7/unix.7:20 build/C/man7/x25.7:12
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/arp.7:13 build/C/man3/bswap.3:26 build/C/man3/byteorder.3:33
#: build/C/man3/cmsg.3:12 build/C/man7/ddp.7:13 build/C/man3/endian.3:29
#: build/C/man3/ether_aton.3:32 build/C/man5/gai.conf.5:20
#: build/C/man3/getaddrinfo.3:45 build/C/man3/getaddrinfo_a.3:31
#: build/C/man1/getent.1:26 build/C/man3/gethostbyname.3:39
#: build/C/man3/getipnodebyname.3:27 build/C/man3/getnameinfo.3:11
#: build/C/man3/getnetent.3:31 build/C/man3/getnetent_r.3:27
#: build/C/man2/getpeername.2:43 build/C/man3/getprotoent.3:31
#: build/C/man3/getprotoent_r.3:27 build/C/man3/getservent.3:35
#: build/C/man3/getservent_r.3:27 build/C/man5/host.conf.5:27
#: build/C/man7/hostname.7:40 build/C/man5/hosts.5:28
#: build/C/man5/hosts.equiv.5:7 build/C/man7/icmp.7:13 build/C/man3/inet.3:43
#: build/C/man3/inet_net_pton.3:26 build/C/man3/inet_ntop.3:27
#: build/C/man3/inet_pton.3:28 build/C/man7/ip.7:43 build/C/man7/ipv6.7:87
#: build/C/man7/netdevice.7:18 build/C/man5/networks.5:27
#: build/C/man8/nscd.8:24 build/C/man5/nscd.conf.5:21 build/C/man5/nss.5:20
#: build/C/man5/nsswitch.conf.5:26 build/C/man7/packet.7:13
#: build/C/man5/protocols.5:30 build/C/man7/raw.7:13 build/C/man3/rcmd.3:44
#: build/C/man5/resolv.conf.5:25 build/C/man3/resolver.3:34
#: build/C/man3/rexec.3:42 build/C/man5/services.5:35
#: build/C/man3/setnetgrent.3:11 build/C/man2/shutdown.2:41
#: build/C/man7/tcp.7:97 build/C/man7/udp.7:13 build/C/man7/udplite.7:28
#: build/C/man7/unix.7:21 build/C/man7/x25.7:13
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/arp.7:15
msgid "arp - Linux ARP kernel module."
msgstr "arp - Linux ARP カーネルモジュール"

#. type: SH
#: build/C/man7/arp.7:15 build/C/man3/bswap.3:36 build/C/man3/byteorder.3:48
#: build/C/man3/cmsg.3:25 build/C/man7/ddp.7:23 build/C/man3/endian.3:76
#: build/C/man3/ether_aton.3:57 build/C/man5/gai.conf.5:22
#: build/C/man3/getaddrinfo.3:75 build/C/man3/getaddrinfo_a.3:51
#: build/C/man1/getent.1:30 build/C/man3/gethostbyname.3:141
#: build/C/man3/getipnodebyname.3:44 build/C/man3/getnameinfo.3:33
#: build/C/man3/getnetent.3:48 build/C/man3/getnetent_r.3:63
#: build/C/man2/getpeername.2:50 build/C/man3/getprotoent.3:48
#: build/C/man3/getprotoent_r.3:60 build/C/man3/getservent.3:52
#: build/C/man3/getservent_r.3:60 build/C/man5/host.conf.5:29
#: build/C/man7/hostname.7:42 build/C/man5/hosts.5:32
#: build/C/man5/hosts.equiv.5:11 build/C/man7/icmp.7:15 build/C/man3/inet.3:80
#: build/C/man3/inet_net_pton.3:60 build/C/man3/inet_ntop.3:36
#: build/C/man3/inet_pton.3:36 build/C/man7/ip.7:59 build/C/man7/ipv6.7:99
#: build/C/man7/netdevice.7:24 build/C/man5/networks.5:29
#: build/C/man8/nscd.8:26 build/C/man5/nscd.conf.5:23 build/C/man5/nss.5:22
#: build/C/man5/nsswitch.conf.5:28 build/C/man7/packet.7:23
#: build/C/man5/protocols.5:32 build/C/man7/raw.7:21 build/C/man3/rcmd.3:95
#: build/C/man5/resolv.conf.5:29 build/C/man3/resolver.3:110
#: build/C/man3/rexec.3:64 build/C/man5/services.5:37
#: build/C/man3/setnetgrent.3:47 build/C/man2/shutdown.2:47
#: build/C/man7/tcp.7:107 build/C/man7/udp.7:23 build/C/man7/udplite.7:38
#: build/C/man7/unix.7:31 build/C/man7/x25.7:21
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/arp.7:23
msgid ""
"This kernel protocol module implements the Address Resolution Protocol "
"defined in RFC\\ 826.  It is used to convert between Layer2 hardware "
"addresses and IPv4 protocol addresses on directly connected networks.  The "
"user normally doesn't interact directly with this module except to configure "
"it; instead it provides a service for other protocols in the kernel."
msgstr ""
"このカーネルプロトコルモジュールは、 RFC\\ 826 で定義されている Address "
"Resolution Protocol を 実装したものである。 ARP は、ダイレクトに接続された"
"ネットワーク上で、 第 2 層のハードウェアアドレスをIPv4 プロトコルアドレスに "
"変換するために用いられる。ユーザーは設定の場合を除いて 通常直接このモジュール"
"に関ることはない。 これはカーネル内部の他のプロトコルにサービスを提供するもの"
"である。"

#. type: Plain text
#: build/C/man7/arp.7:36
msgid ""
"A user process can receive ARP packets by using B<packet>(7)  sockets.  "
"There is also a mechanism for managing the ARP cache in user-space by using "
"B<netlink>(7)  sockets.  The ARP table can also be controlled via "
"B<ioctl>(2)  on any B<AF_INET> socket."
msgstr ""
"ユーザープロセスは、 B<packet>(7)  ソケットを用いれば ARP パケットを受信する"
"ことができる。 ARP キャッシュをユーザー空間で管理することもできる。 これには "
"B<netlink>(7)  を用いる。 ARP テーブルも制御可能で、これには任意の "
"B<AF_INET> ソケットに B<ioctl>(2)  を用いる。"

#. type: Plain text
#: build/C/man7/arp.7:48
msgid ""
"The ARP module maintains a cache of mappings between hardware addresses and "
"protocol addresses.  The cache has a limited size so old and less frequently "
"used entries are garbage-collected.  Entries which are marked as permanent "
"are never deleted by the garbage-collector.  The cache can be directly "
"manipulated by the use of ioctls and its behavior can be tuned by the I</"
"proc> interfaces described below."
msgstr ""
"ARP モジュールはハードウェアアドレスからプロトコルアドレスへの マッピングの"
"キャッシュを管理する。キャッシュの大きさには制限が あるので、古いエントリーや"
"利用されないエントリーはガベージコレクト される。 permanent (保存) マークがつ"
"けられたエントリーは、 決してガベージコレクタによって消去されない。 ioctl を"
"用いればキャッシュを直接操作することもできる。 また後述の I</proc> インター"
"フェースによりキャッシュの振る舞いを調整できる。"

#. type: Plain text
#: build/C/man7/arp.7:71
msgid ""
"When there is no positive feedback for an existing mapping after some time "
"(see the I</proc> interfaces below), a neighbor cache entry is considered "
"stale.  Positive feedback can be gotten from a higher layer; for example "
"from a successful TCP ACK.  Other protocols can signal forward progress "
"using the B<MSG_CONFIRM> flag to B<sendmsg>(2).  When there is no forward "
"progress, ARP tries to reprobe.  It first tries to ask a local arp daemon "
"B<app_solicit> times for an updated MAC address.  If that fails and an old "
"MAC address is known, a unicast probe is sent B<ucast_solicit> times.  If "
"that fails too, it will broadcast a new ARP request to the network.  "
"Requests are sent only when there is data queued for sending."
msgstr ""
"存在しているマッピングに対して、 正のフィードバックが一定時間ない (後述の I</"
"proc> インターフェースを見よ) と、 近傍キャッシュエントリー (neighbor cache "
"entry) は 古くなった (stale) とみなされる。 正のフィードバックは高位のレイ"
"ヤーからも取得できる (例えば TCP ACK が成功した場合など)。 他のプロトコル"
"は、 B<sendmsg>(2)  に B<MSG_CONFIRM> フラグを用いることによって、 フォワード"
"プログレス (forward progress) をシグナルできる。 フォワードプログレスがなけれ"
"ば、 ARP は再びプローブを試みる。 まずローカルな arp デーモンに問合わせを行"
"い、 更新された MAC アドレスを取得しようとする。 このリクエストに "
"B<app_solicit> 回失敗すると、古い MAC アドレスがわかっている場合は、 unicast "
"のプローブが B<ucaset_solicit> 回送られる。これにも失敗すると、新しい ARP リ"
"クエスト をネットワークにブロードキャストする。 リクエストは、データが送信"
"キューにある場合のみ送られる。"

#. type: Plain text
#: build/C/man7/arp.7:76
msgid ""
"Linux will automatically add a nonpermanent proxy arp entry when it receives "
"a request for an address it forwards to and proxy arp is enabled on the "
"receiving interface.  When there is a reject route for the target, no proxy "
"arp entry is added."
msgstr ""
"Linux は、あるアドレスへのリクエストを受信・フォワードし、 受信したインター"
"フェースで代理 arp が有効になっている場合には、 自動的にそのアドレスを "
"nonpermanent な代理 arp エントリーに追加する。 そのターゲットに reject route "
"があった場合には、 代理 arp エントリーは一切追加されない。"

#. type: SS
#: build/C/man7/arp.7:76 build/C/man7/ddp.7:144 build/C/man7/ip.7:1222
#: build/C/man7/netdevice.7:63 build/C/man7/packet.7:495
#: build/C/man7/tcp.7:1241 build/C/man7/udp.7:207 build/C/man7/unix.7:636
#, no-wrap
msgid "Ioctls"
msgstr "ioctl"

#. type: Plain text
#: build/C/man7/arp.7:83
msgid ""
"Three ioctls are available on all B<AF_INET> sockets.  They take a pointer "
"to a I<struct arpreq> as their argument."
msgstr ""
"すべての B<AF_INET> ソケットでは、 3 つの ioctl が使用できる。 これらは "
"I<struct arpreq> へのポインターを引数に取る。"

#. type: Plain text
#: build/C/man7/arp.7:93
#, no-wrap
msgid ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"
msgstr ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"

#. type: Plain text
#: build/C/man7/arp.7:102
msgid ""
"B<SIOCSARP>, B<SIOCDARP> and B<SIOCGARP> respectively set, delete and get an "
"ARP mapping.  Setting and deleting ARP maps are privileged operations and "
"may be performed only by a process with the B<CAP_NET_ADMIN> capability or "
"an effective UID of 0."
msgstr ""
"B<SIOCSARP>, B<SIOCDARP>, B<SIOCGARP> は、それぞれ ARP マッピングを設定・削"
"除・取得する。 ARP マップの設定と削除は特権が必要な操作であり、 "
"B<CAP_NET_ADMIN> 権限を持つプロセスか、実行ユーザー ID が 0 のプロセス でなけ"
"れば実行できない。"

#. type: Plain text
#: build/C/man7/arp.7:112
msgid ""
"I<arp_pa> must be an B<AF_INET> address and I<arp_ha> must have the same "
"type as the device which is specified in I<arp_dev>.  I<arp_dev> is a zero-"
"terminated string which names a device."
msgstr ""
"I<arp_pa> は B<AF_INET> アドレスでなければならず、 I<arp_ha> は I<arp_dev> で"
"設定されたデバイスと同じタイプでなければならない。 I<arp_dev> はデバイスの名"
"前を示す、ゼロで終端された文字列である。"

#. type: tbl table
#: build/C/man7/arp.7:117
#, no-wrap
msgid "I<arp_flags>"
msgstr "I<arp_flags>"

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "flag"
msgstr "フラグ"

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "meaning"
msgstr "意味"

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "ATF_COM"
msgstr "ATF_COM"

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "Lookup complete"
msgstr "参照完了"

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "ATF_PERM"
msgstr "ATF_PERM"

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "Permanent entry"
msgstr "エントリーを peramanent にする"

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "ATF_PUBL"
msgstr "ATF_PUBL"

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "Publish entry"
msgstr "エントリーを publish する"

#. type: tbl table
#: build/C/man7/arp.7:122
#, no-wrap
msgid "ATF_USETRAILERS"
msgstr "ATF_USETRAILERS"

#. type: tbl table
#: build/C/man7/arp.7:122
#, no-wrap
msgid "Trailers requested"
msgstr "trailer が必要"

#. type: tbl table
#: build/C/man7/arp.7:123
#, no-wrap
msgid "ATF_NETMASK"
msgstr "ATF_NETMASK"

#. type: tbl table
#: build/C/man7/arp.7:123
#, no-wrap
msgid "Use a netmask"
msgstr "netmask を用いる"

#. type: tbl table
#: build/C/man7/arp.7:124
#, no-wrap
msgid "ATF_DONTPUB"
msgstr "ATF_DONTPUB"

#. type: tbl table
#: build/C/man7/arp.7:124
#, no-wrap
msgid "Don't answer"
msgstr "回答しない"

#. type: Plain text
#: build/C/man7/arp.7:137
msgid ""
"If the B<ATF_NETMASK> flag is set, then I<arp_netmask> should be valid.  "
"Linux 2.2 does not support proxy network ARP entries, so this should be set "
"to 0xffffffff, or 0 to remove an existing proxy arp entry.  "
"B<ATF_USETRAILERS> is obsolete and should not be used."
msgstr ""
"B<ATF_NETMASK> フラグがセットされているときには、 I<arp_netmask> が有効でなけ"
"ればならない。 Linux 2.2 は代理ネットワーク ARP エントリーをサポートしていな"
"いので、 これは 0xffffffff にセットしておくか、あるいは 現存の代理 arp エント"
"リーを削除したい場合には 0 にしておく必要がある。 B<ATF_USETRAILERS> は "
"obsolete なので、用いるべきでない。"

#. type: SS
#: build/C/man7/arp.7:137 build/C/man7/ddp.7:122 build/C/man7/icmp.7:41
#: build/C/man7/ip.7:1073 build/C/man7/tcp.7:247 build/C/man7/udp.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man7/arp.7:150
msgid ""
"ARP supports a range of I</proc> interfaces to configure parameters on a "
"global or per-interface basis.  The interfaces can be accessed by reading or "
"writing the I</proc/sys/net/ipv4/neigh/*/*> files.  Each interface in the "
"system has its own directory in I</proc/sys/net/ipv4/neigh/>.  The setting "
"in the \"default\" directory is used for all newly created devices.  Unless "
"otherwise specified, time-related interfaces are specified in seconds."
msgstr ""
"ARP では、グローバルなパラメーターやインターフェースごとのパラメーターを I</"
"proc> インターフェースを通して設定することができる。 これらのインターフェース"
"には、 I<proc/sys/net/ipv4/neigh/*/*> ファイルの読み書きによりアクセスでき"
"る。 システムにあるそれぞれのインターフェースには、 それぞれ対応するディレク"
"トリが I</proc/sys/net/ipv4/neigh/> 以下にある。 \"default\" ディレクトリに対"
"して設定をすると、 それ以降生成されるデバイス全てに対してその設定が用いられ"
"る。 特に指定がなければ、時間に関る sysctl の単位は秒である。"

#. type: TP
#: build/C/man7/arp.7:150
#, no-wrap
msgid "I<anycast_delay> (since Linux 2.2)"
msgstr "I<anycast_delay> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:157
msgid ""
"The maximum number of jiffies to delay before replying to a IPv6 neighbor "
"solicitation message.  Anycast support is not yet implemented.  Defaults to "
"1 second."
msgstr ""
"IPv6 の近傍要請メッセージ (neighbor soliciation message)  に応答するまでの最"
"大遅延時間 (jiffy 単位)。 anycast のサポートはまだ実装されていない。 デフォル"
"トは 1 秒。"

#. type: TP
#: build/C/man7/arp.7:157
#, no-wrap
msgid "I<app_solicit> (since Linux 2.2)"
msgstr "I<app_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:164
msgid ""
"The maximum number of probes to send to the user space ARP daemon via "
"netlink before dropping back to multicast probes (see I<mcast_solicit>).  "
"Defaults to 0."
msgstr ""
"ユーザー空間の ARP デーモンに netlink を用いて探索させる最大回数。 これを越え"
"るとマルチキャストによる探索に移行する (I<mcast_solicit> を見よ)。"

#. type: TP
#: build/C/man7/arp.7:164
#, no-wrap
msgid "I<base_reachable_time> (since Linux 2.2)"
msgstr "I<base_reachable_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:175
msgid ""
"Once a neighbor has been found, the entry is considered to be valid for at "
"least a random value between I<base_reachable_time>/2 and "
"3*I<base_reachable_time>/2.  An entry's validity will be extended if it "
"receives positive feedback from higher level protocols.  Defaults to 30 "
"seconds.  This file is now obsolete in favor of I<base_reachable_time_ms>."
msgstr ""
"近傍のホストがみつかると、そのエントリーは I<base_reachable_time>/2 から "
"3*I<base_reachable_time>/2 の間のランダムな値の時間、有効であるとみなされ"
"る。 エントリーの有効性は、高位のプロトコルからポジティブなフィードバックを "
"受け取ると延長される。デフォルトは 30 秒。 このファイルは現在は非推奨であり、"
"代わりに I<base_reachable_time_ms> を使うこと。"

#. type: TP
#: build/C/man7/arp.7:175
#, no-wrap
msgid "I<base_reachable_time_ms> (since Linux 2.6.12)"
msgstr "I<base_reachable_time_ms> (Linux 2.6.12 以降)"

#. type: Plain text
#: build/C/man7/arp.7:181
msgid ""
"As for I<base_reachable_time>, but measures time in milliseconds.  Defaults "
"to 30000 milliseconds."
msgstr ""
"I<base_reachable_time> と同じだが、時間をミリ秒単位で測る。 デフォルトは "
"30000 ミリ秒である。"

#. type: TP
#: build/C/man7/arp.7:181
#, no-wrap
msgid "I<delay_first_probe_time> (since Linux 2.2)"
msgstr "I<delay_first_probe_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:187
msgid ""
"Delay before first probe after it has been decided that a neighbor is "
"stale.  Defaults to 5 seconds."
msgstr ""
"近傍ホストのエントリーが古くなったと判断された後に 最初に探索を行うまでの遅延"
"時間。デフォルトは 5 秒。"

#. type: TP
#: build/C/man7/arp.7:187
#, no-wrap
msgid "I<gc_interval> (since Linux 2.2)"
msgstr "I<gc_interval> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:193
msgid ""
"How frequently the garbage collector for neighbor entries should attempt to "
"run.  Defaults to 30 seconds."
msgstr ""
"ガベージコレクタを近傍ホストエントリーに対して実行させる頻度。 デフォルトは "
"30 秒。"

#. type: TP
#: build/C/man7/arp.7:193
#, no-wrap
msgid "I<gc_stale_time> (since Linux 2.2)"
msgstr "I<gc_stale_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:200
msgid ""
"Determines how often to check for stale neighbor entries.  When a neighbor "
"entry is considered stale, it is resolved again before sending data to it.  "
"Defaults to 60 seconds."
msgstr ""
"古くなった近傍ホストエントリーに対してチェックを行う頻度。 近傍ホストエント"
"リーが古くなったとみなされると、そのエントリーに データを送る前には再度解決が"
"行われる。 デフォルトは 60 秒。"

#. type: TP
#: build/C/man7/arp.7:200
#, no-wrap
msgid "I<gc_thresh1> (since Linux 2.2)"
msgstr "I<gc_thresh1> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:207
msgid ""
"The minimum number of entries to keep in the ARP cache.  The garbage "
"collector will not run if there are fewer than this number of entries in the "
"cache.  Defaults to 128."
msgstr ""
"ARP キャッシュに保存するエントリー数の最小値。 この数より少ないエントリーしか"
"キャッシュになければ、 ガベージコレクタは実行されない。 デフォルトは 128。"

#. type: TP
#: build/C/man7/arp.7:207
#, no-wrap
msgid "I<gc_thresh2> (since Linux 2.2)"
msgstr "I<gc_thresh2> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:214
msgid ""
"The soft maximum number of entries to keep in the ARP cache.  The garbage "
"collector will allow the number of entries to exceed this for 5 seconds "
"before collection will be performed.  Defaults to 512."
msgstr ""
"ARP キャッシュに保存されるエントリー数のソフトな最大値。 キャッシュのエント"
"リーがこの数を 5 秒間越えつづけると、 ガベージコレクタが実行される。 デフォル"
"トは 512。"

#. type: TP
#: build/C/man7/arp.7:214
#, no-wrap
msgid "I<gc_thresh3> (since Linux 2.2)"
msgstr "I<gc_thresh3> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:221
msgid ""
"The hard maximum number of entries to keep in the ARP cache.  The garbage "
"collector will always run if there are more than this number of entries in "
"the cache.  Defaults to 1024."
msgstr ""
"ARP キャッシュに保存されるエントリー数のハードな最大値。 キャッシュのエント"
"リーがこの数を越えると、 ガベージコレクタはただちに実行される。 デフォルトは "
"1024。"

#. type: TP
#: build/C/man7/arp.7:221
#, no-wrap
msgid "I<locktime> (since Linux 2.2)"
msgstr "I<locktime> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:228
msgid ""
"The minimum number of jiffies to keep an ARP entry in the cache.  This "
"prevents ARP cache thrashing if there is more than one potential mapping "
"(generally due to network misconfiguration).  Defaults to 1 second."
msgstr ""
"ARP エントリーをキャッシュに保存する時間の最小値 (jiffy 単位)。 可能性のある"
"マッピングが一つ以上ある (たいていはネットワーク設定のミス)  場合に、 ARP "
"キャッシュのスラッシングが起きることを防ぐ。 デフォルトは 1 秒。"

#. type: TP
#: build/C/man7/arp.7:228
#, no-wrap
msgid "I<mcast_solicit> (since Linux 2.2)"
msgstr "I<mcast_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:234
msgid ""
"The maximum number of attempts to resolve an address by multicast/broadcast "
"before marking the entry as unreachable.  Defaults to 3."
msgstr ""
"エントリーを unreachable マークする前に、 アドレスをマルチキャスト/ブロード"
"キャストで解決しようとする 試行回数の最大値。 デフォルトは 3。"

#. type: TP
#: build/C/man7/arp.7:234
#, no-wrap
msgid "I<proxy_delay> (since Linux 2.2)"
msgstr "I<proxy_delay> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:242
msgid ""
"When an ARP request for a known proxy-ARP address is received, delay up to "
"I<proxy_delay> jiffies before replying.  This is used to prevent network "
"flooding in some cases.  Defaults to 0.8 seconds."
msgstr ""
"既知の代理 ARP アドレスに対して ARP リクエストを受信した場合に、 応答前に最"
"大 I<proxy_delay> jiffy まで遅延する。これは場合によって生じる ネットワークフ"
"ラッディング (network flooding) を避けるために用いる。 デフォルトは 0.8 秒。"

#. type: TP
#: build/C/man7/arp.7:242
#, no-wrap
msgid "I<proxy_qlen> (since Linux 2.2)"
msgstr "I<proxy_qlen> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:247
msgid ""
"The maximum number of packets which may be queued to proxy-ARP addresses.  "
"Defaults to 64."
msgstr ""
"代理 ARP アドレスに対してキューイングできる最大のパケット数。 デフォルトは "
"64。"

#. type: TP
#: build/C/man7/arp.7:247
#, no-wrap
msgid "I<retrans_time> (since Linux 2.2)"
msgstr "I<retrans_time> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:254
msgid ""
"The number of jiffies to delay before retransmitting a request.  Defaults to "
"1 second.  This file is now obsolete in favor of I<retrans_time_ms>."
msgstr ""
"リクエストを再度送るまでの遅延時間 (jiffy 単位)。 デフォルトは 1 秒。 この"
"ファイルは現在は非推奨であり、代わりに I<retrans_time_ms> を使うこと。"

#. type: TP
#: build/C/man7/arp.7:254
#, no-wrap
msgid "I<retrans_time_ms> (since Linux 2.6.12)"
msgstr "I<retrans_time_ms> (Linux 2.6.12 以降)"

#. type: Plain text
#: build/C/man7/arp.7:258
msgid ""
"The number of milliseconds to delay before retransmitting a request.  "
"Defaults to 1000 milliseconds."
msgstr ""
"リクエストを再度送るまでの遅延時間 (ミリ秒単位)。 デフォルトは 1000 ミリ秒。"

#. type: TP
#: build/C/man7/arp.7:258
#, no-wrap
msgid "I<ucast_solicit> (since Linux 2.2)"
msgstr "I<ucast_solicit> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:265
msgid ""
"The maximum number of attempts to send unicast probes before asking the ARP "
"daemon (see I<app_solicit>).  Defaults to 3."
msgstr ""
"ARP デーモンへの問い合わせを行う前に行う unicast 探索の最大試行数 "
"(I<app_solicit> を見よ)。デフォルトは 3。"

#. type: TP
#: build/C/man7/arp.7:265
#, no-wrap
msgid "I<unres_qlen> (since Linux 2.2)"
msgstr "I<unres_qlen> (Linux 2.2 以降)"

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:271
msgid ""
"The maximum number of packets which may be queued for each unresolved "
"address by other network layers.  Defaults to 3."
msgstr ""
"解決されていないアドレスに対して、 他のネットワーク層からキューイングできる最"
"大パケット数。 デフォルトは 3。"

#. type: SH
#: build/C/man7/arp.7:271 build/C/man7/ddp.7:218 build/C/man3/endian.3:97
#: build/C/man5/gai.conf.5:74 build/C/man3/getnameinfo.3:204
#: build/C/man7/icmp.7:166 build/C/man7/ipv6.7:362 build/C/man7/packet.7:548
#: build/C/man7/raw.7:180 build/C/man3/rcmd.3:264 build/C/man3/rexec.3:146
#: build/C/man7/tcp.7:1358 build/C/man7/udp.7:256 build/C/man7/udplite.7:133
#: build/C/man7/unix.7:804 build/C/man7/x25.7:100
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/arp.7:278
msgid ""
"The I<struct arpreq> changed in Linux 2.0 to include the I<arp_dev> member "
"and the ioctl numbers changed at the same time.  Support for the old ioctls "
"was dropped in Linux 2.2."
msgstr ""
"Linux 2.0 で、 I<struct arpreq> に I<arp_dev> メンバーが含まれるように変更が"
"あった。また同時に ioctl 番号も変更された。古い ioctl は Linux 2.2 で用いるこ"
"とができなくなった。"

#. type: Plain text
#: build/C/man7/arp.7:284
msgid ""
"Support for proxy arp entries for networks (netmask not equal 0xffffffff)  "
"was dropped in Linux 2.2.  It is replaced by automatic proxy arp setup by "
"the kernel for all reachable hosts on other interfaces (when forwarding and "
"proxy arp is enabled for the interface)."
msgstr ""
"ネットワークに対する代理 arp エントリー (netmask が 0xffffffff でない)  は、 "
"Linux 2.2 で用いることができなくなった。 これはカーネルによって設定される、別"
"のインターフェースにおける 到達可能なすべてのホストに対する自動代理 arp に"
"よって置き換えられた (そのインターフェースでフォワーディングと代理 arp が有効"
"になっている場合)。"

#. type: Plain text
#: build/C/man7/arp.7:288
msgid "The I<neigh/*> interfaces did not exist before Linux 2.2."
msgstr "I<neigh/*> の各インターフェースは Linux 2.2 以前には存在しない。"

#. type: SH
#: build/C/man7/arp.7:288 build/C/man7/ddp.7:241 build/C/man3/ether_aton.3:151
#: build/C/man3/gethostbyname.3:531 build/C/man3/inet_ntop.3:125
#: build/C/man3/inet_pton.3:164 build/C/man7/ip.7:1392 build/C/man7/ipv6.7:406
#: build/C/man7/netdevice.7:357 build/C/man7/packet.7:619
#: build/C/man7/raw.7:257 build/C/man3/rcmd.3:305 build/C/man3/rexec.3:172
#: build/C/man2/shutdown.2:105 build/C/man7/tcp.7:1365
#: build/C/man7/udplite.7:135 build/C/man7/unix.7:830 build/C/man7/x25.7:102
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man7/arp.7:292
msgid ""
"Some timer settings are specified in jiffies, which is architecture- and "
"kernel version-dependent; see B<time>(7)."
msgstr ""
"いくつかのタイマー設定は jiffy で指定されるが、 jiffy はアーキテクチャーや"
"カーネルのバージョンに依存する。 B<time>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/arp.7:298
msgid ""
"There is no way to signal positive feedback from user space.  This means "
"connection-oriented protocols implemented in user space will generate "
"excessive ARP traffic, because ndisc will regularly reprobe the MAC "
"address.  The same problem applies for some kernel protocols (e.g., NFS over "
"UDP)."
msgstr ""
"ユーザー空間からポジティブなフィードバックを送る方法が存在しない。 つまり接続"
"指向 (connection-oriented) のプロトコルをユーザー空間で 実装すると、余計な "
"ARP トラフィックの原因となる。 なぜなら ndisc は定期的に MAC アドレスを再探索"
"するからである。 同様の問題はいくつかのカーネルプロトコル (NFS over UDP な"
"ど) にも存在する。"

#. type: Plain text
#: build/C/man7/arp.7:301
msgid ""
"This man page mashes together functionality that is IPv4-specific with "
"functionality that is shared between IPv4 and IPv6."
msgstr ""
"この man ページでは IPv4 特有の機能と IPv4 とIPv6 で共通の機能を一緒に説明し"
"ている。"

#. type: SH
#: build/C/man7/arp.7:301 build/C/man3/bswap.3:81 build/C/man3/byteorder.3:98
#: build/C/man3/cmsg.3:248 build/C/man7/ddp.7:246 build/C/man3/endian.3:174
#: build/C/man3/ether_aton.3:157 build/C/man5/gai.conf.5:100
#: build/C/man3/getaddrinfo.3:844 build/C/man3/getaddrinfo_a.3:617
#: build/C/man1/getent.1:398 build/C/man3/gethostbyname.3:536
#: build/C/man3/getipnodebyname.3:266 build/C/man3/getnameinfo.3:299
#: build/C/man3/getnetent.3:205 build/C/man3/getnetent_r.3:162
#: build/C/man2/getpeername.2:137 build/C/man3/getprotoent.3:193
#: build/C/man3/getprotoent_r.3:254 build/C/man3/getservent.3:210
#: build/C/man3/getservent_r.3:257 build/C/man5/host.conf.5:212
#: build/C/man7/hostname.7:108 build/C/man5/hosts.5:127
#: build/C/man5/hosts.equiv.5:170 build/C/man7/icmp.7:196
#: build/C/man3/inet.3:331 build/C/man3/inet_net_pton.3:389
#: build/C/man3/inet_ntop.3:131 build/C/man3/inet_pton.3:229
#: build/C/man7/ip.7:1419 build/C/man7/ipv6.7:417 build/C/man7/netdevice.7:371
#: build/C/man5/networks.5:74 build/C/man8/nscd.8:93
#: build/C/man5/nscd.conf.5:239 build/C/man5/nss.5:113
#: build/C/man5/nsswitch.conf.5:432 build/C/man7/packet.7:635
#: build/C/man5/protocols.5:81 build/C/man7/raw.7:274 build/C/man3/rcmd.3:312
#: build/C/man5/resolv.conf.5:372 build/C/man3/resolver.3:512
#: build/C/man3/rexec.3:181 build/C/man5/services.5:208
#: build/C/man3/setnetgrent.3:154 build/C/man2/shutdown.2:116
#: build/C/man7/tcp.7:1377 build/C/man7/udp.7:261 build/C/man7/udplite.7:147
#: build/C/man7/unix.7:1187 build/C/man7/x25.7:118
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/arp.7:305
msgid "B<capabilities>(7), B<ip>(7), B<arpd>(8)"
msgstr "B<capabilities>(7), B<ip>(7), B<arpd>(8)"

#. type: Plain text
#: build/C/man7/arp.7:310
msgid ""
"RFC\\ 826 for a description of ARP.  RFC\\ 2461 for a description of IPv6 "
"neighbor discovery and the base algorithms used.  Linux 2.2+ IPv4 ARP uses "
"the IPv6 algorithms when applicable."
msgstr ""
"RFC \\ 826: ARP の説明。 RFC\\ 2461: IPv6 neighbor discovery の説明と利用され"
"ている基礎アルゴリズム。 Linux 2.2 以降では IPv4 ARP は可能な場合は IPv6 アル"
"ゴリズムを使っている。"

#. type: SH
#: build/C/man7/arp.7:310 build/C/man3/bswap.3:84 build/C/man3/byteorder.3:103
#: build/C/man3/cmsg.3:253 build/C/man7/ddp.7:251 build/C/man3/endian.3:177
#: build/C/man3/ether_aton.3:159 build/C/man5/gai.conf.5:103
#: build/C/man3/getaddrinfo.3:854 build/C/man3/getaddrinfo_a.3:624
#: build/C/man1/getent.1:400 build/C/man3/gethostbyname.3:550
#: build/C/man3/getipnodebyname.3:271 build/C/man3/getnameinfo.3:332
#: build/C/man3/getnetent.3:212 build/C/man3/getnetent_r.3:165
#: build/C/man2/getpeername.2:144 build/C/man3/getprotoent.3:198
#: build/C/man3/getprotoent_r.3:257 build/C/man3/getservent.3:215
#: build/C/man3/getservent_r.3:260 build/C/man5/host.conf.5:219
#: build/C/man7/hostname.7:126 build/C/man5/hosts.5:140
#: build/C/man5/hosts.equiv.5:174 build/C/man7/icmp.7:201
#: build/C/man3/inet.3:342 build/C/man3/inet_net_pton.3:392
#: build/C/man3/inet_ntop.3:135 build/C/man3/inet_pton.3:233
#: build/C/man7/ip.7:1440 build/C/man7/ipv6.7:424 build/C/man7/netdevice.7:376
#: build/C/man5/networks.5:80 build/C/man8/nscd.8:99
#: build/C/man5/nscd.conf.5:244 build/C/man5/nss.5:115
#: build/C/man5/nsswitch.conf.5:435 build/C/man7/packet.7:658
#: build/C/man5/protocols.5:86 build/C/man7/raw.7:287 build/C/man3/rcmd.3:319
#: build/C/man5/resolv.conf.5:382 build/C/man3/resolver.3:521
#: build/C/man3/rexec.3:184 build/C/man5/services.5:220
#: build/C/man3/setnetgrent.3:158 build/C/man2/shutdown.2:121
#: build/C/man7/tcp.7:1406 build/C/man7/udp.7:275 build/C/man7/udplite.7:157
#: build/C/man7/unix.7:1197 build/C/man7/x25.7:127
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/arp.7:318 build/C/man3/bswap.3:92 build/C/man3/byteorder.3:111
#: build/C/man3/cmsg.3:261 build/C/man7/ddp.7:259 build/C/man3/endian.3:185
#: build/C/man3/ether_aton.3:167 build/C/man5/gai.conf.5:111
#: build/C/man3/getaddrinfo.3:862 build/C/man3/getaddrinfo_a.3:632
#: build/C/man1/getent.1:408 build/C/man3/gethostbyname.3:558
#: build/C/man3/getipnodebyname.3:279 build/C/man3/getnameinfo.3:340
#: build/C/man3/getnetent.3:220 build/C/man3/getnetent_r.3:173
#: build/C/man2/getpeername.2:152 build/C/man3/getprotoent.3:206
#: build/C/man3/getprotoent_r.3:265 build/C/man3/getservent.3:223
#: build/C/man3/getservent_r.3:268 build/C/man5/host.conf.5:227
#: build/C/man7/hostname.7:134 build/C/man5/hosts.5:148
#: build/C/man5/hosts.equiv.5:182 build/C/man7/icmp.7:209
#: build/C/man3/inet.3:350 build/C/man3/inet_net_pton.3:400
#: build/C/man3/inet_ntop.3:143 build/C/man3/inet_pton.3:241
#: build/C/man7/ip.7:1448 build/C/man7/ipv6.7:432 build/C/man7/netdevice.7:384
#: build/C/man5/networks.5:88 build/C/man8/nscd.8:107
#: build/C/man5/nscd.conf.5:252 build/C/man5/nss.5:123
#: build/C/man5/nsswitch.conf.5:443 build/C/man7/packet.7:666
#: build/C/man5/protocols.5:94 build/C/man7/raw.7:295 build/C/man3/rcmd.3:327
#: build/C/man5/resolv.conf.5:390 build/C/man3/resolver.3:529
#: build/C/man3/rexec.3:192 build/C/man5/services.5:228
#: build/C/man3/setnetgrent.3:166 build/C/man2/shutdown.2:129
#: build/C/man7/tcp.7:1414 build/C/man7/udp.7:283 build/C/man7/udplite.7:165
#: build/C/man7/unix.7:1205 build/C/man7/x25.7:135
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr "この man ページは Linux I<man-pages> プロジェクトのリリース 5.10 の一部である。プロジェクトの説明とバグ報告に関する情報は \\%https://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/bswap.3:25
#, no-wrap
msgid "BSWAP"
msgstr "BSWAP"

#. type: TH
#: build/C/man3/bswap.3:25 build/C/man3/cmsg.3:11 build/C/man3/endian.3:28
#: build/C/man3/getaddrinfo.3:44 build/C/man3/getaddrinfo_a.3:30
#: build/C/man3/getprotoent_r.3:26 build/C/man3/getservent_r.3:26
#: build/C/man7/ip.7:42 build/C/man7/unix.7:20
#, no-wrap
msgid "2020-11-01"
msgstr "2020-11-01"

#. type: Plain text
#: build/C/man3/bswap.3:28
msgid "bswap_16, bswap_32, bswap_64 - reverse order of bytes"
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:28 build/C/man3/byteorder.3:36 build/C/man3/cmsg.3:14
#: build/C/man7/ddp.7:15 build/C/man3/endian.3:33 build/C/man3/ether_aton.3:35
#: build/C/man3/getaddrinfo.3:48 build/C/man3/getaddrinfo_a.3:34
#: build/C/man1/getent.1:28 build/C/man3/gethostbyname.3:46
#: build/C/man3/getipnodebyname.3:30 build/C/man3/getnameinfo.3:13
#: build/C/man3/getnetent.3:34 build/C/man3/getnetent_r.3:30
#: build/C/man2/getpeername.2:45 build/C/man3/getprotoent.3:34
#: build/C/man3/getprotoent_r.3:30 build/C/man3/getservent.3:38
#: build/C/man3/getservent_r.3:30 build/C/man5/hosts.5:30
#: build/C/man3/inet.3:46 build/C/man3/inet_net_pton.3:28
#: build/C/man3/inet_ntop.3:29 build/C/man3/inet_pton.3:30 build/C/man7/ip.7:45
#: build/C/man7/ipv6.7:89 build/C/man7/netdevice.7:20 build/C/man7/packet.7:15
#: build/C/man7/raw.7:15 build/C/man3/rcmd.3:48 build/C/man5/resolv.conf.5:27
#: build/C/man3/resolver.3:38 build/C/man3/rexec.3:44
#: build/C/man3/setnetgrent.3:14 build/C/man2/shutdown.2:43
#: build/C/man7/tcp.7:99 build/C/man7/udp.7:15 build/C/man7/udplite.7:30
#: build/C/man7/unix.7:23 build/C/man7/x25.7:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bswap.3:31
#, no-wrap
msgid "B<#include E<lt>byteswap.hE<gt>>\n"
msgstr "B<#include E<lt>byteswap.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bswap.3:35
#, no-wrap
msgid ""
"B<bswap_16(>I<x>B<);>\n"
"B<bswap_32(>I<x>B<);>\n"
"B<bswap_64(>I<x>B<);>\n"
msgstr ""
"B<bswap_16(>I<x>B<);>\n"
"B<bswap_32(>I<x>B<);>\n"
"B<bswap_64(>I<x>B<);>\n"

#. type: Plain text
#: build/C/man3/bswap.3:39
msgid ""
"These macros return a value in which the order of the bytes in their 2-, 4-, "
"or 8-byte arguments is reversed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:39 build/C/man3/getaddrinfo.3:484
#: build/C/man3/getaddrinfo_a.3:243 build/C/man3/gethostbyname.3:296
#: build/C/man3/getipnodebyname.3:186 build/C/man3/getnameinfo.3:139
#: build/C/man3/getnetent.3:130 build/C/man3/getnetent_r.3:119
#: build/C/man2/getpeername.2:68 build/C/man3/getprotoent.3:123
#: build/C/man3/getprotoent_r.3:109 build/C/man3/getservent.3:142
#: build/C/man3/getservent_r.3:108 build/C/man3/inet_net_pton.3:129
#: build/C/man3/inet_ntop.3:83 build/C/man3/inet_pton.3:118
#: build/C/man3/rcmd.3:241 build/C/man3/resolver.3:435
#: build/C/man3/setnetgrent.3:89 build/C/man2/shutdown.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bswap.3:41
msgid ""
"These macros return the value of their argument with the bytes reversed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:41 build/C/man7/ddp.7:149
#: build/C/man3/gethostbyname.3:308 build/C/man3/getnetent_r.3:130
#: build/C/man2/getpeername.2:73 build/C/man3/getprotoent_r.3:120
#: build/C/man3/getservent_r.3:119 build/C/man3/inet_net_pton.3:144
#: build/C/man3/inet_ntop.3:91 build/C/man7/ip.7:1231 build/C/man7/ipv6.7:351
#: build/C/man7/packet.7:512 build/C/man7/raw.7:149 build/C/man2/shutdown.2:74
#: build/C/man7/tcp.7:1340 build/C/man7/udp.7:246 build/C/man7/udplite.7:121
#: build/C/man7/unix.7:683
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/bswap.3:43
msgid "These macros always succeed."
msgstr ""

#. type: SH
#: build/C/man3/bswap.3:43 build/C/man3/byteorder.3:91 build/C/man3/cmsg.3:159
#: build/C/man3/endian.3:99 build/C/man3/ether_aton.3:149
#: build/C/man3/getaddrinfo.3:610 build/C/man3/getaddrinfo_a.3:322
#: build/C/man3/gethostbyname.3:410 build/C/man3/getipnodebyname.3:258
#: build/C/man3/getnameinfo.3:220 build/C/man3/getnetent.3:196
#: build/C/man3/getnetent_r.3:158 build/C/man2/getpeername.2:101
#: build/C/man3/getprotoent.3:191 build/C/man3/getprotoent_r.3:149
#: build/C/man3/getservent.3:208 build/C/man3/getservent_r.3:147
#: build/C/man3/inet.3:245 build/C/man3/inet_net_pton.3:158
#: build/C/man3/inet_ntop.3:113 build/C/man3/inet_pton.3:143
#: build/C/man3/rcmd.3:297 build/C/man3/resolver.3:510 build/C/man3/rexec.3:163
#: build/C/man3/setnetgrent.3:139 build/C/man2/shutdown.2:92
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bswap.3:45
msgid "These macros are GNU extensions."
msgstr "これらのマクロは GNU 拡張である。"

#. type: SH
#: build/C/man3/bswap.3:45 build/C/man3/cmsg.3:189 build/C/man3/endian.3:130
#: build/C/man5/gai.conf.5:79 build/C/man3/getaddrinfo.3:639
#: build/C/man3/getaddrinfo_a.3:331 build/C/man3/getnameinfo.3:260
#: build/C/man3/getprotoent_r.3:153 build/C/man3/getservent_r.3:151
#: build/C/man5/hosts.5:110 build/C/man5/hosts.equiv.5:84
#: build/C/man3/inet.3:288 build/C/man3/inet_net_pton.3:246
#: build/C/man3/inet_ntop.3:128 build/C/man3/inet_pton.3:170
#: build/C/man5/nss.5:100 build/C/man7/unix.7:917
#, no-wrap
msgid "EXAMPLES"
msgstr "例"

#. type: Plain text
#: build/C/man3/bswap.3:49
msgid ""
"The program below swaps the bytes of the 8-byte integer supplied as its "
"command-line argument.  The following shell session demonstrates the use of "
"the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/bswap.3:54
#, no-wrap
msgid ""
"$ B<./a.out 0x0123456789abcdef>\n"
"0x123456789abcdef ==E<gt> 0xefcdab8967452301\n"
msgstr ""
"$ B<./a.out 0x0123456789abcdef>\n"
"0x123456789abcdef ==E<gt> 0xefcdab8967452301\n"

#. type: SS
#: build/C/man3/bswap.3:56 build/C/man3/endian.3:146
#: build/C/man3/getprotoent_r.3:180 build/C/man3/getservent_r.3:177
#: build/C/man3/inet.3:304 build/C/man3/inet_net_pton.3:330
#: build/C/man3/inet_pton.3:187 build/C/man7/unix.7:948
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/bswap.3:64
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>\n"
"#include E<lt>byteswap.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>\n"
"#include E<lt>byteswap.hE<gt>\n"

#. type: Plain text
#: build/C/man3/bswap.3:69
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint64_t x;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint64_t x;\n"

#. type: Plain text
#: build/C/man3/bswap.3:74
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/bswap.3:77
#, no-wrap
msgid ""
"    x = strtoull(argv[1], NULL, 0);\n"
"    printf(\"%#\" PRIx64 \" ==E<gt> %#\" PRIx64 \"\\en\", x, bswap_64(x));\n"
msgstr ""
"    x = strtoull(argv[1], NULL, 0);\n"
"    printf(\"%#\" PRIx64 \" ==E<gt> %#\" PRIx64 \"\\en\", x, bswap_64(x));\n"

#. type: Plain text
#: build/C/man3/bswap.3:80 build/C/man3/endian.3:173
#: build/C/man3/getaddrinfo.3:843 build/C/man3/getprotoent_r.3:253
#: build/C/man3/getservent_r.3:256 build/C/man3/inet_net_pton.3:388
#: build/C/man3/inet_pton.3:228 build/C/man7/unix.7:1092
#: build/C/man7/unix.7:1181
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/bswap.3:84
msgid "B<byteorder>(3), B<endian>(3)"
msgstr "B<byteorder>(3), B<endian>(3)"

#. type: TH
#: build/C/man3/byteorder.3:32
#, no-wrap
msgid "BYTEORDER"
msgstr "BYTEORDER"

#. type: TH
#: build/C/man3/byteorder.3:32 build/C/man7/ddp.7:12
#: build/C/man3/ether_aton.3:31 build/C/man3/getipnodebyname.3:26
#: build/C/man3/getnetent_r.3:26 build/C/man2/getpeername.2:42
#: build/C/man3/rexec.3:41 build/C/man3/setnetgrent.3:10
#: build/C/man7/udplite.7:27 build/C/man7/x25.7:12
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: build/C/man3/byteorder.3:32 build/C/man3/endian.3:28
#: build/C/man3/ether_aton.3:31 build/C/man3/getaddrinfo.3:44
#: build/C/man3/getaddrinfo_a.3:30 build/C/man3/getnameinfo.3:10
#: build/C/man3/getnetent.3:30 build/C/man3/getnetent_r.3:26
#: build/C/man3/getprotoent.3:30 build/C/man3/getprotoent_r.3:26
#: build/C/man3/getservent.3:34 build/C/man3/getservent_r.3:26
#: build/C/man3/inet.3:42 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20
#: build/C/man3/resolver.3:33 build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/byteorder.3:36
msgid ""
"htonl, htons, ntohl, ntohs - convert values between host and network byte "
"order"
msgstr ""
"htonl, htons, ntohl, ntohs - ホストバイトオーダーとネットワークバイトオーダー"
"の間で値を変換する"

#. type: Plain text
#: build/C/man3/byteorder.3:39 build/C/man3/inet_net_pton.3:31
#: build/C/man3/inet_ntop.3:32 build/C/man3/inet_pton.3:33
#, no-wrap
msgid "B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr "B<#include E<lt>arpa/inet.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:41
#, no-wrap
msgid "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"
msgstr "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:43
#, no-wrap
msgid "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"
msgstr "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:45
#, no-wrap
msgid "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"
msgstr "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:47
#, no-wrap
msgid "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"
msgstr "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"

#. type: Plain text
#: build/C/man3/byteorder.3:54
msgid ""
"The B<htonl>()  function converts the unsigned integer I<hostlong> from host "
"byte order to network byte order."
msgstr ""
"B<htonl>()  関数は unsigned integer I<hostlong> を ホストバイトオーダーから"
"ネットワークバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:60
msgid ""
"The B<htons>()  function converts the unsigned short integer I<hostshort> "
"from host byte order to network byte order."
msgstr ""
"B<htons>()  関数は unsigned short integer I<hostshort> を ホストバイトオー"
"ダーからネットワークバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:66
msgid ""
"The B<ntohl>()  function converts the unsigned integer I<netlong> from "
"network byte order to host byte order."
msgstr ""
"B<ntohl>()  関数は unsigned integer I<netlong> を ネットワークバイトオーダー"
"からホストバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:72
msgid ""
"The B<ntohs>()  function converts the unsigned short integer I<netshort> "
"from network byte order to host byte order."
msgstr ""
"B<ntohs>()  関数は unsigned short integer I<netshort> を ネットワークバイト"
"オーダーからホストバイトオーダーに変換する。"

#. type: Plain text
#: build/C/man3/byteorder.3:76
msgid ""
"On the i386 the host byte order is Least Significant Byte first, whereas the "
"network byte order, as used on the Internet, is Most Significant Byte first."
msgstr ""
"i80x86 のホストバイトオーダーでは最下位バイトが若いアドレスに配置されるが、 "
"インターネットで用いられるネットワークバイトオーダーでは最上位バイト が先に配"
"置される。"

#. type: SH
#: build/C/man3/byteorder.3:76 build/C/man3/ether_aton.3:127
#: build/C/man3/getaddrinfo.3:593 build/C/man3/getaddrinfo_a.3:306
#: build/C/man3/gethostbyname.3:339 build/C/man3/getnameinfo.3:207
#: build/C/man3/getnetent.3:145 build/C/man3/getnetent_r.3:142
#: build/C/man3/getprotoent.3:140 build/C/man3/getprotoent_r.3:132
#: build/C/man3/getservent.3:157 build/C/man3/getservent_r.3:131
#: build/C/man3/inet.3:223 build/C/man3/inet_ntop.3:100
#: build/C/man3/inet_pton.3:131 build/C/man3/rcmd.3:272
#: build/C/man3/resolver.3:485 build/C/man3/rexec.3:150
#: build/C/man3/setnetgrent.3:95
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: Plain text
#: build/C/man3/byteorder.3:79 build/C/man3/ether_aton.3:130
#: build/C/man3/getaddrinfo.3:596 build/C/man3/getaddrinfo_a.3:309
#: build/C/man3/gethostbyname.3:342 build/C/man3/getnameinfo.3:210
#: build/C/man3/getnetent.3:148 build/C/man3/getnetent_r.3:145
#: build/C/man3/getprotoent.3:143 build/C/man3/getprotoent_r.3:135
#: build/C/man3/getservent.3:160 build/C/man3/getservent_r.3:134
#: build/C/man3/inet.3:226 build/C/man3/inet_ntop.3:103
#: build/C/man3/inet_pton.3:134 build/C/man3/rcmd.3:275
#: build/C/man3/resolver.3:488 build/C/man3/rexec.3:153
#: build/C/man3/setnetgrent.3:98
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "この節で使用されている用語の説明は B<attributes>(7) を参照のこと。"

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135
#: build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313
#: build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214
#: build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150
#: build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139
#: build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139
#: build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107
#: build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279
#: build/C/man3/resolver.3:492 build/C/man3/rexec.3:157
#: build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Interface"
msgstr "Interface"

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135
#: build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313
#: build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214
#: build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150
#: build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139
#: build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139
#: build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107
#: build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279
#: build/C/man3/resolver.3:492 build/C/man3/rexec.3:157
#: build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Attribute"
msgstr "Attribute"

#. type: tbl table
#: build/C/man3/byteorder.3:83 build/C/man3/ether_aton.3:135
#: build/C/man3/getaddrinfo.3:600 build/C/man3/getaddrinfo_a.3:313
#: build/C/man3/gethostbyname.3:346 build/C/man3/getnameinfo.3:214
#: build/C/man3/getnetent.3:152 build/C/man3/getnetent_r.3:150
#: build/C/man3/getprotoent.3:147 build/C/man3/getprotoent_r.3:139
#: build/C/man3/getservent.3:164 build/C/man3/getservent_r.3:139
#: build/C/man3/inet.3:230 build/C/man3/inet_ntop.3:107
#: build/C/man3/inet_pton.3:138 build/C/man3/rcmd.3:279
#: build/C/man3/resolver.3:492 build/C/man3/rexec.3:157
#: build/C/man3/setnetgrent.3:102
#, no-wrap
msgid "Value"
msgstr "Value"

#. type: tbl table
#: build/C/man3/byteorder.3:89
#, no-wrap
msgid ""
"B<htonl>(),\n"
"B<htons>(),\n"
"B<ntohl>(),\n"
"B<ntohs>()"
msgstr ""
"B<htonl>(),\n"
"B<htons>(),\n"
"B<ntohl>(),\n"
"B<ntohs>()"

#. type: tbl table
#: build/C/man3/byteorder.3:89 build/C/man3/ether_aton.3:139
#: build/C/man3/ether_aton.3:146 build/C/man3/getaddrinfo.3:603
#: build/C/man3/getaddrinfo.3:607 build/C/man3/getaddrinfo_a.3:319
#: build/C/man3/gethostbyname.3:349 build/C/man3/gethostbyname.3:356
#: build/C/man3/gethostbyname.3:367 build/C/man3/gethostbyname.3:376
#: build/C/man3/gethostbyname.3:379 build/C/man3/gethostbyname.3:386
#: build/C/man3/gethostbyname.3:395 build/C/man3/getnameinfo.3:217
#: build/C/man3/getnetent.3:155 build/C/man3/getnetent.3:162
#: build/C/man3/getnetent.3:169 build/C/man3/getnetent.3:178
#: build/C/man3/getnetent_r.3:155 build/C/man3/getprotoent.3:150
#: build/C/man3/getprotoent.3:157 build/C/man3/getprotoent.3:164
#: build/C/man3/getprotoent.3:173 build/C/man3/getprotoent_r.3:146
#: build/C/man3/getservent.3:167 build/C/man3/getservent.3:174
#: build/C/man3/getservent.3:181 build/C/man3/getservent.3:190
#: build/C/man3/getservent_r.3:144 build/C/man3/inet.3:237
#: build/C/man3/inet.3:243 build/C/man3/inet_ntop.3:110
#: build/C/man3/inet_pton.3:141 build/C/man3/rcmd.3:283 build/C/man3/rcmd.3:287
#: build/C/man3/rcmd.3:294 build/C/man3/resolver.3:501
#: build/C/man3/resolver.3:507 build/C/man3/rexec.3:161
#: build/C/man3/setnetgrent.3:109 build/C/man3/setnetgrent.3:116
#: build/C/man3/setnetgrent.3:119
#, no-wrap
msgid "Thread safety"
msgstr "Thread safety"

#. type: tbl table
#: build/C/man3/byteorder.3:89 build/C/man3/ether_aton.3:146
#: build/C/man3/getaddrinfo.3:607 build/C/man3/getaddrinfo_a.3:319
#: build/C/man3/gethostbyname.3:376 build/C/man3/inet.3:243
#: build/C/man3/rcmd.3:287 build/C/man3/resolver.3:507
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: build/C/man3/byteorder.3:93 build/C/man3/inet_pton.3:145
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/byteorder.3:98
msgid ""
"Some systems require the inclusion of I<E<lt>netinet/in.hE<gt>> instead of "
"I<E<lt>arpa/inet.hE<gt>>."
msgstr ""
"いくつかのシステムでは、 I<E<lt>arpa/inet.hE<gt>> の代わりに I<E<lt>netinet/"
"in.hE<gt>> をインクルードする必要がある。"

#. type: Plain text
#: build/C/man3/byteorder.3:103
msgid "B<bswap>(3), B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"
msgstr "B<bswap>(3), B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"

#. type: TH
#: build/C/man3/cmsg.3:11
#, no-wrap
msgid "CMSG"
msgstr "CMSG"

#. type: Plain text
#: build/C/man3/cmsg.3:14
msgid ""
"CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - access ancillary data"
msgstr ""
"CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - 補助データにアクセスす"
"る。"

#. type: Plain text
#: build/C/man3/cmsg.3:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>\n"
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<,>\n"
"B<                            struct cmsghdr *>cmsgB<);>\n"
"B<size_t CMSG_ALIGN(size_t >I<length>B<);>\n"
"B<size_t CMSG_SPACE(size_t >I<length>B<);>\n"
"B<size_t CMSG_LEN(size_t >I<length>B<);>\n"
"B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>\n"
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<,>\n"
"B<                            struct cmsghdr *>cmsgB<);>\n"
"B<size_t CMSG_ALIGN(size_t >I<length>B<);>\n"
"B<size_t CMSG_SPACE(size_t >I<length>B<);>\n"
"B<size_t CMSG_LEN(size_t >I<length>B<);>\n"
"B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>\n"

#. type: Plain text
#: build/C/man3/cmsg.3:39
msgid ""
"These macros are used to create and access control messages (also called "
"ancillary data) that are not a part of the socket payload.  This control "
"information may include the interface the packet was received on, various "
"rarely used header fields, an extended error description, a set of file "
"descriptors, or UNIX credentials.  For instance, control messages can be "
"used to send additional header fields such as IP options.  Ancillary data is "
"sent by calling B<sendmsg>(2)  and received by calling B<recvmsg>(2).  See "
"their manual pages for more information."
msgstr ""
"これらのマクロは制御メッセージ (補助データ (ancillary data) とも呼ばれる) を"
"作り、 それにアクセスするために使われる。 制御メッセージはソケットにのるデー"
"タではない。 この制御情報は、到着したパケットへのインターフェイス、様々なあま"
"り 使われないヘッダーフィールド、エラー記述の拡張、ファイルデスクリ プタの集"
"合や、UNIXにおける信頼情報 (credential) を含んでいる。 制御メッセージは、例え"
"ば IP オプションのような追加ヘッダーフィールドを 送るのに使う事ができる。 補"
"助データは、 B<sendmsg>(2)  を呼び出して送り、 B<recvmsg>(2)  を呼び出して受"
"け取る。 詳細はそれらのマニュアルページを参照。"

#. type: Plain text
#: build/C/man3/cmsg.3:48
msgid ""
"Ancillary data is a sequence of I<cmsghdr> structures with appended data.  "
"See the specific protocol man pages for the available control message "
"types.  The maximum ancillary buffer size allowed per socket can be set "
"using I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr "補助データは I<cmsghdr> 構造体のシーケンスに追加データが付加されたものである。使用可能な制御メッセージのタイプについては、 それぞれのプロトコルのマニュアルページを参照のこと。接続毎の最大補助用バッファーサイズは I</proc/sys/net/core/optmem_max> を使って設定できる。 B<socket>(7) を参照。"

#. type: Plain text
#: build/C/man3/cmsg.3:52
msgid "The I<cmsghdr> structure is defined as follows:"
msgstr "I<cmsghdr> 構造体は以下のように定義されている。"

#. type: Plain text
#: build/C/man3/cmsg.3:63
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"   unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"   unsigned char cmsg_data[]; */\n"
"};\n"

#. type: Plain text
#: build/C/man3/cmsg.3:70
msgid ""
"The sequence of I<cmsghdr> structures should never be accessed directly.  "
"Instead, use only the following macros:"
msgstr ""

#. type: IP
#: build/C/man3/cmsg.3:70 build/C/man3/cmsg.3:80 build/C/man3/cmsg.3:95
#: build/C/man3/cmsg.3:100 build/C/man3/cmsg.3:105 build/C/man3/cmsg.3:115
#: build/C/man3/getaddrinfo.3:346 build/C/man3/getaddrinfo.3:369
#: build/C/man3/getaddrinfo_a.3:192 build/C/man3/getaddrinfo_a.3:196
#: build/C/man3/getaddrinfo_a.3:198 build/C/man3/inet_net_pton.3:206
#: build/C/man3/inet_net_pton.3:212 build/C/man3/inet_net_pton.3:219
#: build/C/man3/inet_net_pton.3:226 build/C/man3/inet_net_pton.3:233
#: build/C/man7/ip.7:1148 build/C/man7/ip.7:1151 build/C/man7/ip.7:1154
#: build/C/man7/ip.7:1157 build/C/man5/nsswitch.conf.5:134
#: build/C/man5/nsswitch.conf.5:138 build/C/man7/packet.7:131
#: build/C/man7/packet.7:138 build/C/man7/packet.7:148
#: build/C/man7/packet.7:165 build/C/man7/packet.7:292
#: build/C/man7/packet.7:300 build/C/man7/packet.7:304
#: build/C/man7/packet.7:307 build/C/man7/packet.7:311
#: build/C/man7/packet.7:314 build/C/man7/unix.7:99 build/C/man7/unix.7:124
#: build/C/man7/unix.7:140 build/C/man7/unix.7:165 build/C/man7/unix.7:169
#: build/C/man7/unix.7:173
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/cmsg.3:80
#, fuzzy
#| msgid ""
#| "B<CMSG_FIRSTHDR>()  returns a pointer to the first I<cmsghdr> in the "
#| "ancillary data buffer associated with the passed I<msghdr>."
msgid ""
"B<CMSG_FIRSTHDR>()  returns a pointer to the first I<cmsghdr> in the "
"ancillary data buffer associated with the passed I<msghdr>.  It returns NULL "
"if there isn't enough space for a I<cmsghdr> in the buffer."
msgstr ""
"B<CMSG_FIRSTHDR>()  は、渡した I<msghdr> に関連した補助データバッファー中の、"
"最初の I<cmsghdr> へのポインターを返す。"

#. type: Plain text
#: build/C/man3/cmsg.3:87
msgid ""
"B<CMSG_NXTHDR>()  returns the next valid I<cmsghdr> after the passed "
"I<cmsghdr>.  It returns NULL when there isn't enough space left in the "
"buffer."
msgstr ""
"B<CMSG_NXTHDR>()  は、渡した I<cmsghdr> の次にくる (有効な)  I<cmsghdr> を返"
"す。 バッファーに十分な空きが無い場合、NULL を返す。"

#. type: Plain text
#: build/C/man3/cmsg.3:95
msgid ""
"When initializing a buffer that will contain a series of I<cmsghdr> "
"structures (e.g., to be sent with B<sendmsg>(2)), that buffer should first "
"be zero-initialized to ensure the correct operation of B<CMSG_NXTHDR>()."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:100
msgid ""
"B<CMSG_ALIGN>(), given a length, returns it including the required "
"alignment.  This is a constant expression."
msgstr ""
"B<CMSG_ALIGN>()  に長さを与えると、必要なアラインメントを加味した長さを返して"
"くる。 これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:105
msgid ""
"B<CMSG_SPACE>()  returns the number of bytes an ancillary element with "
"payload of the passed data length occupies.  This is a constant expression."
msgstr ""
"B<CMSG_SPACE>()  は、与えたデータ長が占めるのに必要な補助要素 (ancillary "
"element) の バイト数を返す。これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:115
msgid ""
"B<CMSG_DATA>()  returns a pointer to the data portion of a I<cmsghdr>.  The "
"pointer returned cannot be assumed to be suitably aligned for accessing "
"arbitrary payload data types.  Applications should not cast it to a pointer "
"type matching the payload, but should instead use B<memcpy>(3)  to copy data "
"to or from a suitably declared object."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:126
msgid ""
"B<CMSG_LEN>()  returns the value to store in the I<cmsg_len> member of the "
"I<cmsghdr> structure, taking into account any necessary alignment.  It takes "
"the data length as an argument.  This is a constant expression."
msgstr ""
"B<CMSG_LEN>()  は、 I<cmsghdr> 構造体の I<cmsg_len> メンバにデータを格納する"
"際に必要な値を返す。アラインメントも考慮に入れ られる。 引数としてデータ長を"
"とる。これは定数式である。"

#. type: Plain text
#: build/C/man3/cmsg.3:159
msgid ""
"To create ancillary data, first initialize the I<msg_controllen> member of "
"the I<msghdr> with the length of the control message buffer.  Use "
"B<CMSG_FIRSTHDR>()  on the I<msghdr> to get the first control message and "
"B<CMSG_NXTHDR>()  to get all subsequent ones.  In each control message, "
"initialize I<cmsg_len> (with B<CMSG_LEN>()), the other I<cmsghdr> header "
"fields, and the data portion using B<CMSG_DATA>().  Finally, the "
"I<msg_controllen> field of the I<msghdr> should be set to the sum of the "
"B<CMSG_SPACE>()  of the length of all control messages in the buffer.  For "
"more information on the I<msghdr>, see B<recvmsg>(2)."
msgstr ""
"補助データを作るためには最初に I<msghdr> のメンバー I<msg_controllen> を、制"
"御メッセージバッファーの長さで初期化する。 B<CMSG_FIRSTHDR>()  を I<msghdr> "
"に用いると最初の制御メッセージが得られ、 B<CMSG_NXTHDR>()  を使うと次の制御"
"メッセージが得られる。 それぞれの制御メッセージでは、 I<cmsg_len> を初期化す"
"る (B<CMSG_LEN>()  を使う)。 その他の I<cmsghdr> ヘッダーフィールド、そして"
"データ部分に対しても B<CMSG_DATA>()  を使って初期化をする。 最後に I<msghdr> "
"の I<msg_controllen> フィールドに、バッファー中の制御メッセージの長さの "
"B<CMSG_SPACE>()  の合計がセットされる。 I<msghdr> についての詳細は "
"B<recvmsg>(2)  を参照。"

#.  https://www.austingroupbugs.net/view.php?id=978#c3242
#. type: Plain text
#: build/C/man3/cmsg.3:172
#, fuzzy
#| msgid ""
#| "This ancillary data model conforms to the POSIX.1g draft, 4.4BSD-Lite, "
#| "the IPv6 advanced API described in RFC\\ 2292 and SUSv2.  "
#| "B<CMSG_ALIGN>()  is a Linux extension."
msgid ""
"This ancillary data model conforms to the POSIX.1g draft, 4.4BSD-Lite, the "
"IPv6 advanced API described in RFC\\ 2292 and SUSv2.  B<CMSG_FIRSTHDR>(), "
"B<CMSG_NXTHDR>(), and B<CMSG_DATA>()  are specified in POSIX.1-2008.  "
"B<CMSG_SPACE>()  and B<CMSG_LEN>()  will be included in the next POSIX "
"release (Issue 8)."
msgstr ""
"この補助データモデルは、POSIX.1g draft, 4.4BSD-Lite, RFC\\ 2292 に 記述されて"
"いる IPv6 advanced API, そして SUSv2 に準拠している。 B<CMSG_ALIGN>()  は "
"Linux の拡張である。"

#. type: Plain text
#: build/C/man3/cmsg.3:175
msgid "B<CMSG_ALIGN>()  is a Linux extension."
msgstr ""

#. type: SH
#: build/C/man3/cmsg.3:175 build/C/man7/ddp.7:223 build/C/man3/endian.3:114
#: build/C/man3/getaddrinfo.3:615 build/C/man3/getaddrinfo_a.3:325
#: build/C/man3/gethostbyname.3:434 build/C/man3/getipnodebyname.3:261
#: build/C/man3/getnameinfo.3:222 build/C/man3/getnetent.3:198
#: build/C/man2/getpeername.2:105 build/C/man5/host.conf.5:126
#: build/C/man5/hosts.5:91 build/C/man5/hosts.equiv.5:71
#: build/C/man7/icmp.7:174 build/C/man3/inet.3:252
#: build/C/man3/inet_net_pton.3:164 build/C/man3/inet_pton.3:145
#: build/C/man7/ip.7:1322 build/C/man7/ipv6.7:386 build/C/man7/netdevice.7:340
#: build/C/man8/nscd.8:64 build/C/man5/nscd.conf.5:232
#: build/C/man5/nsswitch.conf.5:413 build/C/man7/packet.7:554
#: build/C/man7/raw.7:192 build/C/man3/setnetgrent.3:150
#: build/C/man2/shutdown.2:96 build/C/man7/unix.7:810
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/cmsg.3:180
msgid ""
"For portability, ancillary data should be accessed using only the macros "
"described here.  B<CMSG_ALIGN>()  is a Linux extension and should not be "
"used in portable programs."
msgstr ""
"移植性のために、補助データへのアクセスには、 ここで述べられているマクロだけを"
"使うべきである。 B<CMSG_ALIGN>()  は Linux での拡張であり、移植性を考えたプロ"
"グラムでは使うべきではない。"

#. type: Plain text
#: build/C/man3/cmsg.3:189
#, fuzzy
#| msgid ""
#| "In Linux, B<CMSG_LEN>(), B<CMSG_DATA>(), and B<CMSG_ALIGN>()  are "
#| "constant expressions (assuming their argument is constant); this could be "
#| "used to declare the size of global variables.  This may not be portable, "
#| "however."
msgid ""
"In Linux, B<CMSG_LEN>(), B<CMSG_DATA>(), and B<CMSG_ALIGN>()  are constant "
"expressions (assuming their argument is constant), meaning that these values "
"can be used to declare the size of global variables.  This may not be "
"portable, however."
msgstr ""
"Linux では B<CMSG_LEN>(), B<CMSG_DATA>(), B<CMSG_ALIGN>()  は定数式である (そ"
"れらの引数が定数とみなされる)。 このことは、大域変数のサイズを宣言するのに使"
"える。 しかし移植性はなくなるだろう。"

#. type: Plain text
#: build/C/man3/cmsg.3:193
msgid ""
"This code looks for the B<IP_TTL> option in a received ancillary buffer:"
msgstr ""
"次のコードは、受け取った補助バッファーから B<IP_TTL> オプションを探すものであ"
"る。"

#. type: Plain text
#: build/C/man3/cmsg.3:199
#, no-wrap
msgid ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int received_ttl;\n"
msgstr ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int received_ttl;\n"

#. type: Plain text
#: build/C/man3/cmsg.3:201
#, no-wrap
msgid "/* Receive auxiliary data in msgh */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:210
#, no-wrap
msgid ""
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh, cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        memcpy(&receive_ttl, CMSG_DATA(cmsg), sizeof(received_ttl));\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh, cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        memcpy(&receive_ttl, CMSG_DATA(cmsg), sizeof(received_ttl));\n"
"        break;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/cmsg.3:214
#, no-wrap
msgid ""
"if (cmsg == NULL) {\n"
"    /* Error: IP_TTL not enabled or small buffer or I/O error */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:220
msgid ""
"The code below passes an array of file descriptors over a UNIX domain socket "
"using B<SCM_RIGHTS>:"
msgstr ""
"以下のコードは、 B<SCM_RIGHTS> を使い、ファイルディスクリプターの配列を UNIX "
"ドメインソケットを通して送るものである。"

#. type: Plain text
#: build/C/man3/cmsg.3:236
#, no-wrap
msgid ""
"struct msghdr msg = { 0 };\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD];  /* Contains the file descriptors to pass */\n"
"char iobuf[1];\n"
"struct iovec io = {\n"
"    .iov_base = iobuf,\n"
"    .iov_len = sizeof(iobuf)\n"
"};\n"
"union {         /* Ancillary data buffer, wrapped in a union\n"
"                   in order to ensure it is suitably aligned */\n"
"    char buf[CMSG_SPACE(sizeof(myfds))];\n"
"    struct cmsghdr align;\n"
"} u;\n"
msgstr ""
"struct msghdr msg = { 0 };\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD];  /* Contains the file descriptors to pass */\n"
"char iobuf[1];\n"
"struct iovec io = {\n"
"    .iov_base = iobuf,\n"
"    .iov_len = sizeof(iobuf)\n"
"};\n"
"union {         /* Ancillary data buffer, wrapped in a union\n"
"                   in order to ensure it is suitably aligned */\n"
"    char buf[CMSG_SPACE(sizeof(myfds))];\n"
"    struct cmsghdr align;\n"
"} u;\n"

#. type: Plain text
#: build/C/man3/cmsg.3:246
#, no-wrap
msgid ""
"msg.msg_iov = &io;\n"
"msg.msg_iovlen = 1;\n"
"msg.msg_control = u.buf;\n"
"msg.msg_controllen = sizeof(u.buf);\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(myfds));\n"
"memcpy(CMSG_DATA(cmsg), myfds, sizeof(myfds));\n"
msgstr ""
"msg.msg_iov = &io;\n"
"msg.msg_iovlen = 1;\n"
"msg.msg_control = u.buf;\n"
"msg.msg_controllen = sizeof(u.buf);\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(myfds));\n"
"memcpy(CMSG_DATA(cmsg), myfds, sizeof(myfds));\n"

#. type: Plain text
#: build/C/man3/cmsg.3:251
msgid "B<recvmsg>(2), B<sendmsg>(2)"
msgstr "B<recvmsg>(2), B<sendmsg>(2)"

#. type: Plain text
#: build/C/man3/cmsg.3:253
msgid "RFC\\ 2292"
msgstr "RFC\\ 2292"

#. type: TH
#: build/C/man7/ddp.7:12
#, no-wrap
msgid "DDP"
msgstr "DDP"

#. type: Plain text
#: build/C/man7/ddp.7:15
msgid "ddp - Linux AppleTalk protocol implementation"
msgstr "ddp - Linux での AppleTalk プロトコルの実装"

#. type: Plain text
#: build/C/man7/ddp.7:17 build/C/man2/getpeername.2:47 build/C/man7/ip.7:47
#: build/C/man7/ipv6.7:91 build/C/man7/raw.7:17 build/C/man2/shutdown.2:45
#: build/C/man7/tcp.7:101 build/C/man7/udp.7:17 build/C/man7/udplite.7:32
#: build/C/man7/unix.7:25 build/C/man7/x25.7:17
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: build/C/man7/ddp.7:19
msgid "B<#include E<lt>netatalk/at.hE<gt>>"
msgstr "B<#include E<lt>netatalk/at.hE<gt>>"

#. type: Plain text
#: build/C/man7/ddp.7:21
msgid "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"
msgstr "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/ddp.7:23
msgid "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ddp.7:34
msgid ""
"Linux implements the AppleTalk protocols described in I<Inside AppleTalk>.  "
"Only the DDP layer and AARP are present in the kernel.  They are designed to "
"be used via the B<netatalk> protocol libraries.  This page documents the "
"interface for those who wish or need to use the DDP layer directly."
msgstr ""
"Linux は I<Inside AppleTalk> に記述されている AppleTalk プロトコルを実装して"
"いる。 カーネルにあるのは DDP 層と AARP だけである。これらは B<netatalk> プロ"
"トコルライブラリを通して利用されるように設計されている。 このページは DDP 層"
"を直接利用したいユーザーのために、 インターフェースを記述したものである。"

#. type: Plain text
#: build/C/man7/ddp.7:39
msgid ""
"The communication between AppleTalk and the user program works using a BSD-"
"compatible socket interface.  For more information on sockets, see "
"B<socket>(7)."
msgstr ""
"AppleTalk とユーザープログラムとの通信には、 BSD 互換のソケットインターフェー"
"スを利用する。 ソケットに関するより詳しい情報は B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/ddp.7:60
msgid ""
"An AppleTalk socket is created by calling the B<socket>(2)  function with a "
"B<AF_APPLETALK> socket family argument.  Valid socket types are "
"B<SOCK_DGRAM> to open a B<ddp> socket or B<SOCK_RAW> to open a B<raw> "
"socket.  I<protocol> is the AppleTalk protocol to be received or sent.  For "
"B<SOCK_RAW> you must specify B<ATPROTO_DDP>."
msgstr ""
"AppleTalk ソケットは、 ソケットファミリーの引数に B<AF_APPLETALK> を指定して "
"B<socket>(2)  関数を呼び出すことによって生成される。指定できるソケットタイプ"
"は、 B<ddp> ソケットをオープンする場合には B<SOCK_DGRAM>、 B<raw> ソケットを"
"オープンする場合には B<SOCK_RAW> である。 I<protocol> は送受信される "
"AppleTalk プロトコルである。 ソケットタイプに B<SOCK_RAW> を指定した場合は、"
"プロトコルに B<ATPROTO_DDP> を指定しなければならない。"

#. type: Plain text
#: build/C/man7/ddp.7:65
msgid ""
"Raw sockets may be opened only by a process with effective user ID 0 or when "
"the process has the B<CAP_NET_RAW> capability."
msgstr ""
"raw ソケットは実効ユーザー ID が 0 のプロセスか、 B<CAT_NEW_RAW> 権限を持った"
"プロセスでないとオープンできない。"

#. type: SS
#: build/C/man7/ddp.7:65 build/C/man7/ip.7:145 build/C/man7/ipv6.7:142
#: build/C/man7/raw.7:96 build/C/man7/udp.7:98 build/C/man7/udplite.7:58
#: build/C/man7/unix.7:58
#, no-wrap
msgid "Address format"
msgstr "アドレスのフォーマット"

#. type: Plain text
#: build/C/man7/ddp.7:68
msgid ""
"An AppleTalk socket address is defined as a combination of a network number, "
"a node number, and a port number."
msgstr ""
"AppleTalk ソケットアドレスはネットワーク番号、 ノード番号、 ポート番号の組み"
"合わせで定義される。"

#. type: Plain text
#: build/C/man7/ddp.7:75
#, no-wrap
msgid ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"
msgstr ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"

#. type: Plain text
#: build/C/man7/ddp.7:81
#, no-wrap
msgid ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"
msgstr ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"

#.  FIXME . this doesn't make sense [johnl]
#. type: Plain text
#: build/C/man7/ddp.7:120
msgid ""
"I<sat_family> is always set to B<AF_APPLETALK>.  I<sat_port> contains the "
"port.  The port numbers below 129 are known as I<reserved ports>.  Only "
"processes with the effective user ID 0 or the B<CAP_NET_BIND_SERVICE> "
"capability may B<bind>(2)  to these sockets.  I<sat_addr> is the host "
"address.  The I<net> member of I<struct at_addr> contains the host network "
"in network byte order.  The value of B<AT_ANYNET> is a wildcard and also "
"implies \\(lqthis network.\\(rq The I<node> member of I<struct at_addr> "
"contains the host node number.  The value of B<AT_ANYNODE> is a wildcard and "
"also implies \\(lqthis node.\\(rq The value of B<ATADDR_BCAST> is a link "
"local broadcast address."
msgstr ""
"I<sat_family> は常に B<AF_APPLETALK> に設定する。 I<sat_port> はポートを与え"
"る。ポート番号が 129 以下のポートは 「予約ポート (reserved port)」 と呼ばれ"
"る。実効ユーザー ID が 0 のプロセスか、 B<CAP_NET_BIND_SERVICE> 権限を持つプ"
"ロセスだけが、このようなソケットを B<bind>(2)  できる。 I<sat_addr> はホスト"
"アドレスである。 I<struct at_addr> のメンバー I<s_net> にはホストのネットワー"
"クをネットワークバイトオーダーで与える。値 B<AT_ANYNET> はワイルドカードで、"
"「このネットワーク」も暗黙のうちに含まれる。 I<struct at_addr> のメンバー "
"I<s_node> にはホストのノード番号を与える。値 B<AT_ANYNODE> はワイルドカード"
"で、「このノード」も暗黙のうちに含まれる。値 B<ATADDR_BCAST> はローカルなブ"
"ロードキャストアドレスである。"

#. type: SS
#: build/C/man7/ddp.7:120 build/C/man7/ip.7:250 build/C/man7/ipv6.7:192
#: build/C/man7/packet.7:184 build/C/man7/raw.7:114 build/C/man7/tcp.7:998
#: build/C/man7/udp.7:178 build/C/man7/udplite.7:67 build/C/man7/unix.7:268
#: build/C/man7/x25.7:72
#, no-wrap
msgid "Socket options"
msgstr "ソケットオプション"

#. type: Plain text
#: build/C/man7/ddp.7:122
msgid "No protocol-specific socket options are supported."
msgstr "プロトコル固有のソケットオプションはない。"

#. type: Plain text
#: build/C/man7/ddp.7:128
msgid ""
"IP supports a set of I</proc> interfaces to configure some global AppleTalk "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/atalk/>."
msgstr ""
"Appletalk のグローバルパラメーターのいくつかは、 I</proc> インターフェースを"
"通して設定することができる。 これらのパラメーターには、 I</proc/sys/net/"
"atalk/> ディレクトリ内のファイルの読み書きでアクセスできる。"

#. type: TP
#: build/C/man7/ddp.7:128
#, no-wrap
msgid "I<aarp-expiry-time>"
msgstr "I<aarp-expiry-time>"

#. type: Plain text
#: build/C/man7/ddp.7:131
msgid "The time interval (in seconds) before an AARP cache entry expires."
msgstr "AARP キャッシュエントリーを破棄するまでのタイムインターバル (秒単位)。"

#. type: TP
#: build/C/man7/ddp.7:131
#, no-wrap
msgid "I<aarp-resolve-time>"
msgstr "I<aarp-resolve-time>"

#. type: Plain text
#: build/C/man7/ddp.7:134
msgid "The time interval (in seconds) before an AARP cache entry is resolved."
msgstr ""
"AARP キャッシュエントリーが解決されるまでのタイムインターバル (秒単位)。"

#. type: TP
#: build/C/man7/ddp.7:134
#, no-wrap
msgid "I<aarp-retransmit-limit>"
msgstr "I<aarp-retransmit-limit>"

#. type: Plain text
#: build/C/man7/ddp.7:138
msgid ""
"The number of retransmissions of an AARP query before the node is declared "
"dead."
msgstr ""
"AARP クエリーの最大再送信回数。この回数を越えると、 そのノードは dead である"
"とみなされる。"

#. type: TP
#: build/C/man7/ddp.7:138
#, no-wrap
msgid "I<aarp-tick-time>"
msgstr "I<aarp-tick-time>"

#. type: Plain text
#: build/C/man7/ddp.7:141
msgid "The timer rate (in seconds) for the timer driving AARP."
msgstr "タイマー動作する AARP のタイマーレート (秒単位)"

#. type: Plain text
#: build/C/man7/ddp.7:144
msgid ""
"The default values match the specification and should never need to be "
"changed."
msgstr ""
"デフォルトの値で仕様にマッチしているので、 変更する必要は全くないはずである。"

#.  FIXME . Add a section about multicasting
#. type: Plain text
#: build/C/man7/ddp.7:149
msgid "All ioctls described in B<socket>(7)  apply to DDP."
msgstr "B<socket>(7)  に記述されているすべての ioctl が DDP にも適用される。"

#. type: TP
#: build/C/man7/ddp.7:150 build/C/man7/ip.7:1235 build/C/man7/raw.7:150
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man7/ddp.7:157
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include sending to a broadcast address without having the broadcast "
"flag set, and trying to bind to a reserved port without effective user ID 0 "
"or B<CAP_NET_BIND_SERVICE>."
msgstr ""
"ユーザーが行おうとした操作に必要な権限を持っていない。 broadcast フラグをセッ"
"トせずにブロードキャストアドレスへ送信を行おうとした、 実効ユーザー ID が 0 "
"でなく、 B<CAP_NET_BIND_SERVICE> 権限のないプロセスで特権ポートをバインドしよ"
"うとした、などが考えられる。"

#. type: TP
#: build/C/man7/ddp.7:157 build/C/man7/ip.7:1251 build/C/man7/unix.7:684
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: build/C/man7/ddp.7:160 build/C/man7/ip.7:1254
msgid "Tried to bind to an address already in use."
msgstr "既に使用されているアドレスにバインドしようとした。"

#. type: TP
#: build/C/man7/ddp.7:160 build/C/man7/ip.7:1254 build/C/man7/packet.7:513
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: build/C/man7/ddp.7:164 build/C/man7/ip.7:1258
msgid ""
"A nonexistent interface was requested or the requested source address was "
"not local."
msgstr ""
"存在しないインターフェースが要求された。または 要求されたソースアドレスがロー"
"カルでない。"

#. type: TP
#: build/C/man7/ddp.7:164 build/C/man7/ip.7:1258
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1261
msgid "Operation on a nonblocking socket would block."
msgstr "非ブロッキングソケットに対してブロックする操作を行った。"

#. type: TP
#: build/C/man7/ddp.7:167 build/C/man7/ip.7:1261
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1264
msgid "A connection operation on a nonblocking socket is already in progress."
msgstr "非ブロッキングソケットに対する接続操作が既に実行中である。"

#. type: TP
#: build/C/man7/ddp.7:170 build/C/man7/ip.7:1264
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: build/C/man7/ddp.7:174 build/C/man7/ip.7:1268
msgid "A connection was closed during an B<accept>(2)."
msgstr "B<accept>(2)  の途中で接続がクローズされた。"

#. type: TP
#: build/C/man7/ddp.7:174 build/C/man7/ip.7:1268
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr "B<EHOSTUNREACH>"

#. type: Plain text
#: build/C/man7/ddp.7:177
msgid "No routing table entry matches the destination address."
msgstr "行き先アドレスにマッチするエントリーがルーティングテーブルにない。"

#. type: TP
#: build/C/man7/ddp.7:177 build/C/man2/getpeername.2:85 build/C/man7/ip.7:1273
#: build/C/man7/packet.7:519 build/C/man7/raw.7:157 build/C/man2/shutdown.2:79
#: build/C/man7/unix.7:709
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man7/ddp.7:180
msgid "Invalid argument passed."
msgstr "渡した引数が不正。"

#. type: TP
#: build/C/man7/ddp.7:180 build/C/man7/ip.7:1279 build/C/man7/unix.7:718
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: build/C/man7/ddp.7:184 build/C/man7/ip.7:1283
msgid "B<connect>(2)  was called on an already connected socket."
msgstr "接続済みのソケットに対して B<connect>(2)  が呼ばれた。"

#. type: TP
#: build/C/man7/ddp.7:184 build/C/man3/inet_net_pton.3:150
#: build/C/man7/ip.7:1283 build/C/man7/packet.7:522 build/C/man7/raw.7:160
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: build/C/man7/ddp.7:187
msgid "Datagram is bigger than the DDP MTU."
msgstr "データグラムが DDP MTU より大きい。"

#. type: TP
#: build/C/man7/ddp.7:187 build/C/man7/ipv6.7:352 build/C/man7/packet.7:531
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man7/ddp.7:190
msgid "Network device not available or not capable of sending IP."
msgstr "ネットワークデバイスがない。あるいは IP を送ることができない。"

#. type: TP
#: build/C/man7/ddp.7:190 build/C/man3/getnetent_r.3:131
#: build/C/man3/getprotoent_r.3:121 build/C/man3/getservent_r.3:120
#: build/C/man3/inet_net_pton.3:153 build/C/man7/ip.7:1291
#: build/C/man7/packet.7:534 build/C/man7/unix.7:723
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man7/ddp.7:194 build/C/man7/ip.7:1295
msgid "B<SIOCGSTAMP> was called on a socket where no packet arrived."
msgstr "パケットが到着していないソケットに対して B<SIOCGSTAMP> が呼ばれた。"

#. type: TP
#: build/C/man7/ddp.7:194
#, no-wrap
msgid "B<ENOMEM> and B<ENOBUFS>"
msgstr "B<ENOMEM> と B<ENOBUFS>"

#. type: Plain text
#: build/C/man7/ddp.7:197
msgid "Not enough memory available."
msgstr "メモリーが足りない。"

#. type: TP
#: build/C/man7/ddp.7:197 build/C/man7/ip.7:1295
#, no-wrap
msgid "B<ENOPKG>"
msgstr "B<ENOPKG>"

#. type: Plain text
#: build/C/man7/ddp.7:200 build/C/man7/ip.7:1298
msgid "A kernel subsystem was not configured."
msgstr "カーネルサブシステムが設定されていない。"

#. type: TP
#: build/C/man7/ddp.7:200 build/C/man7/ip.7:1298
#, no-wrap
msgid "B<ENOPROTOOPT> and B<EOPNOTSUPP>"
msgstr "B<ENOPROTOOPT> と B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man7/ddp.7:203 build/C/man7/ip.7:1301
msgid "Invalid socket option passed."
msgstr "無効なソケットオプションが渡された。"

#. type: TP
#: build/C/man7/ddp.7:203 build/C/man2/getpeername.2:93 build/C/man7/ip.7:1301
#: build/C/man7/packet.7:537 build/C/man2/shutdown.2:84 build/C/man7/unix.7:731
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: build/C/man7/ddp.7:207 build/C/man7/ip.7:1305
msgid ""
"The operation is defined only on a connected socket, but the socket wasn't "
"connected."
msgstr ""
"接続されていないソケットに対して、 接続状態でしか定義されていない操作を行おう"
"とした。"

#. type: TP
#: build/C/man7/ddp.7:207 build/C/man7/ip.7:1305 build/C/man7/packet.7:543
#: build/C/man7/raw.7:171 build/C/man7/unix.7:738
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man7/ddp.7:212
msgid ""
"User doesn't have permission to set high priority, make a configuration "
"change, or send signals to the requested process or group."
msgstr ""
"高い優先度に設定したり、設定を変更したり、 指定したプロセスやグループにシグナ"
"ルを送るのに必要な権限を ユーザーが持っていない。"

#. type: TP
#: build/C/man7/ddp.7:212 build/C/man7/ip.7:1309 build/C/man7/tcp.7:1347
#: build/C/man7/unix.7:742
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man7/ddp.7:215 build/C/man7/ip.7:1312
msgid "The connection was unexpectedly closed or shut down by the other end."
msgstr ""
"接続が接続相手によって、予期しないやり方でクローズまたはシャットダウンされ"
"た。"

#. type: TP
#: build/C/man7/ddp.7:215 build/C/man7/ip.7:1312 build/C/man7/unix.7:764
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: build/C/man7/ddp.7:218
msgid "The socket was unconfigured, or an unknown socket type was requested."
msgstr "ソケットが設定されていない。または未知のソケットタイプが要求された。"

#. type: Plain text
#: build/C/man7/ddp.7:223
msgid ""
"AppleTalk is supported by Linux 2.0 or higher.  The I</proc> interfaces "
"exist since Linux 2.2."
msgstr ""
"AppleTalk は Linux 2.0 以降でサポートされている。 I</proc> インターフェース"
"は Linux 2.2 以降に存在する。"

#. type: Plain text
#: build/C/man7/ddp.7:229
msgid ""
"Be very careful with the B<SO_BROADCAST> option; it is not privileged in "
"Linux.  It is easy to overload the network with careless sending to "
"broadcast addresses."
msgstr ""
"B<SO_BROADCAST> オプションを用いる時には慎重の上にも慎重になってほしい。 "
"Linux ではこれに特権を必要としない。 不注意にブロードキャストアドレスに送信を"
"行うと、 ネットワークの状態が簡単に変更されてしまう。"

#. type: SS
#: build/C/man7/ddp.7:229 build/C/man7/ip.7:1379 build/C/man7/packet.7:585
#, no-wrap
msgid "Compatibility"
msgstr "移植性"

#. type: Plain text
#: build/C/man7/ddp.7:236
msgid ""
"The basic AppleTalk socket interface is compatible with B<netatalk> on BSD-"
"derived systems.  Many BSD systems fail to check B<SO_BROADCAST> when "
"sending broadcast frames; this can lead to compatibility problems."
msgstr ""
"基本的な Appletalk ソケットインターフェースは BSD 由来のシステムにおける "
"B<netatalk> と互換性がある。多くの BSD システムでは、 ブロードキャストフレー"
"ムを送信しようとしたときの B<SO_BROADCAST> のチェックに失敗する。これは互換性"
"の問題となるかもしれない。"

#. type: Plain text
#: build/C/man7/ddp.7:241
msgid ""
"The raw socket mode is unique to Linux and exists to support the alternative "
"CAP package and AppleTalk monitoring tools more easily."
msgstr ""
"raw ソケットモードは Linux 独特のもので、もう一方の実装である CAP パッケージ"
"や、 Appletalk モニタツールをより簡単に実装できるようになる。"

#. type: Plain text
#: build/C/man7/ddp.7:243 build/C/man7/ip.7:1394
msgid "There are too many inconsistent error values."
msgstr "エラーの値がまったく首尾一貫していない。"

#. type: Plain text
#: build/C/man7/ddp.7:246
msgid ""
"The ioctls used to configure routing tables, devices, AARP tables, and other "
"devices are not yet described."
msgstr ""
"ルーティングテーブル、 デバイス、 AARP テーブル、 その他のデバイスを設定する"
"ために用いられる ioctl がまだ記述されていない。"

#. type: Plain text
#: build/C/man7/ddp.7:251
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"
msgstr "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"

#. type: TH
#: build/C/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr "ENDIAN"

#. type: Plain text
#: build/C/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and big-/"
"little-endian byte order"
msgstr ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh,\n"
"le32toh, htobe64, htole64, be64toh, le64toh - ホストバイトオーダーと\n"
"ビッグ/リトルエンディアンバイトオーダーの間で値の変換を行う"

#. type: Plain text
#: build/C/man3/endian.3:36
#, no-wrap
msgid "B<#include E<lt>endian.hE<gt>>\n"
msgstr "B<#include E<lt>endian.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/endian.3:41
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:46
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:51
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"

#. type: Plain text
#: build/C/man3/endian.3:56 build/C/man3/getaddrinfo.3:66
#: build/C/man3/gethostbyname.3:91 build/C/man3/getnameinfo.3:26
#: build/C/man3/getnetent_r.3:52 build/C/man3/getprotoent_r.3:49
#: build/C/man3/getservent_r.3:49 build/C/man3/inet.3:70
#: build/C/man3/inet_net_pton.3:44 build/C/man3/rcmd.3:81
#: build/C/man3/setnetgrent.3:34
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/endian.3:70
msgid ""
"B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), "
"B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), "
"B<be64toh>(), B<le64toh>():"
msgstr "B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), B<be64toh>(), B<le64toh>():"

#. type: Plain text
#: build/C/man3/endian.3:75 build/C/man3/rexec.3:63
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:80
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""
"これらの関数は、整数値のバイトエンコーディングを、\n"
"使用中の CPU (\"ホスト\") のバイトオーダーから\n"
"リトルエンディアンやビッグエンディアンバイトオーダーへの変換や\n"
"その逆の変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:85
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""
"各関数の名前に付いている数字 I<nn> は、その関数が扱う整数のサイズ\n"
"(16, 32, 64 ビットのどれか) を示している。"

#. type: Plain text
#: build/C/man3/endian.3:88
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""
"名前が \"htobeI<nn>\" という形の関数は、ホストバイトオーダーから\n"
"ビッグエンディアンバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:91
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""
"名前が \"htoleI<nn>\" という形の関数は、ホストバイトオーダーから\n"
"リトルエンディアンバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:94
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""
"名前が \"beI<nn>toh\" という形の関数は、ビッグエンディアンバイトオーダー\n"
"からホストバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:97
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from little-"
"endian order to host byte order."
msgstr ""
"名前が \"leI<nn>toh\" という形の関数は、リトルエンディアンバイトオーダー\n"
"からホストバイトオーダーへの変換を行う。"

#. type: Plain text
#: build/C/man3/endian.3:99
msgid "These functions were added to glibc in version 2.9."
msgstr "これらの関数は glibc バージョン 2.9 で追加された。"

#. type: Plain text
#: build/C/man3/endian.3:114
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs, "
"where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby "
"the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""
"これらの関数は非標準である。\n"
"BSD には同様の関数が存在するが、 BSD では\n"
"必要なヘッダーファイルは I<E<lt>endian.hE<gt>> ではなく\n"
"I<E<lt>sys/endian.hE<gt>> である。\n"
"不幸なことに、 NetBSD, FreeBSD, glibc では、\n"
"これらの関数の元々の OpenBSD での、 I<nn> は常に関数名の末尾に置く\n"
"という名前付けルールが踏襲されていない\n"
"(そのため、例を挙げると、 OpenBSD の \"betoh32\" と等価な関数は\n"
"NetBSD, FreeBSD, glibc では \"be32toh\" となる)。"

#. type: Plain text
#: build/C/man3/endian.3:122
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()."
msgstr ""
"これらの関数は、前からある B<byteorder>(3) 系の関数と同じである。\n"
"例えば、 B<be32toh>() は B<ntohl>() と等価である。"

#. type: Plain text
#: build/C/man3/endian.3:130
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the "
"64-bit and little-endian variants described in this page."
msgstr ""
"B<byteorder>(3) 系の関数のメリットは、これらが\n"
"全ての UNIX システムで利用可能な標準関数である点である。\n"
"一方で、これらの関数は TCP/IP 処理で使用されることを想定して\n"
"設計されたため、このページで説明している 64 ビット版や\n"
"リトルエンディアン版などが存在しない。"

#. type: Plain text
#: build/C/man3/endian.3:137
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte "
"order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""
"以下のプログラムは、整数をホストバイトオーダーからリトルエンディアンと\n"
"ビットエンディアンの両方のバイトオーダーに変換し、その結果を表示する。\n"
"ホストバイトオーダーはリトルエンディアンかビットエンディアンのいずれか\n"
"なので、変換に意味があるのはどちらか一方だけである。\n"
"このプログラムを x86-32 などのリトルエンディアンのシステムで実行した\n"
"場合の実行結果は下記のようになる。"

#. type: Plain text
#: build/C/man3/endian.3:144
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"

#. type: Plain text
#: build/C/man3/endian.3:153
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/endian.3:161
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"

#. type: Plain text
#: build/C/man3/endian.3:166
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"

#. type: Plain text
#: build/C/man3/endian.3:170
#, no-wrap
msgid ""
"    printf(\"x.u32 = %#x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = %#x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = %#x\\en\", htobe32(x.u32));\n"
msgstr ""
"    printf(\"x.u32 = %#x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = %#x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = %#x\\en\", htobe32(x.u32));\n"

#. type: Plain text
#: build/C/man3/endian.3:177
msgid "B<bswap>(3), B<byteorder>(3)"
msgstr "B<bswap>(3), B<byteorder>(3)"

#. type: TH
#: build/C/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr "ETHER_ATON"

#. type: Plain text
#: build/C/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet アドレスの操作用関数"

#. type: Plain text
#: build/C/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr "B<#include E<lt>netinet/ether.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:44
#, no-wrap
msgid "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:46
#, no-wrap
msgid "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:51
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr "/* GNU 拡張 */\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:53
#, no-wrap
msgid "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"
msgstr "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: build/C/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""
"関数 B<ether_aton>()  は、標準的な 16進数とコロンの形式で書かれた 48ビットの "
"Ethernet ホストアドレス I<asc> を、ネットワークでのバイト順 (byte order)  の"
"バイナリデータに変換し、静的に割り当てられたバッファーに格納されたデータ への"
"ポインターを返す。このバッファーは、これ以降の関数呼び出しで上書きされる。 ア"
"ドレスが不正な場合、 B<ether_aton>()  は NULL を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""
"関数 B<ether_ntoa>()  は、ネットワークのバイト順で表された Ethernet ホストア"
"ドレス I<addr> を、標準的な 16進数とコロンの形式の文字列に変換する。 但し、先"
"頭の 0 は省略される。変換後の文字列は静的に割り当てられたバッファー に格納さ"
"れて返される。このバッファーは、これ以降の関数呼び出しで上書きされる。"

#. type: Plain text
#: build/C/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""
"関数 B<ether_ntohost>()  は、Ethernet アドレスに対応するホスト名を I</etc/"
"ethers> を検索して割り当てる。対応するホスト名が見つからなかった場合は、 非 "
"0 を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be found."
msgstr ""
"関数 B<ether_hostton>()  は、ホスト名に対応する Ethernet アドレスを I</etc/"
"ethers> を検索して割り当てる。対応するホスト名が見つからなかった場合は、 非 "
"0 を返す。"

#. type: Plain text
#: build/C/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""
"関数 B<ether_line>()  は、 I</etc/ethers> 形式になった行を解析し、 アドレスと"
"ホスト名の組を返す (I</etc/ethers> 形式は、Ethernet アドレス、ホスト名が空白"
"文字 (whitespace)  で区切られた書式で、\\(aq#\\(aq 以降はコメントとみなされ"
"る)。 解析できなかった場合は、非 0 を返す。 I<hostname> で指定されたバッ"
"ファーは十分な長さが必要である。つまり、 I<line> と同じ長さでなければならな"
"い。"

#. type: Plain text
#: build/C/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant thread-"
"safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, and do "
"not use static buffers."
msgstr ""
"関数 B<ether_ntoa_r>()  と B<ether_aton_r>()  は、 それぞれ B<ether_ntoa>()  "
"と B<ether_aton>()  の リエントラントでスレッドセーフなバージョンであり、 静"
"的なバッファーを使用しない。"

#. type: Plain text
#: build/C/man3/ether_aton.3:119
msgid ""
"The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr ""
"I<ether_addr> 構造体は I<E<lt>net/ethernet.hE<gt>> で次のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"

#. type: tbl table
#: build/C/man3/ether_aton.3:139
#, no-wrap
msgid ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"
msgstr ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"

#. type: tbl table
#: build/C/man3/ether_aton.3:139 build/C/man3/rcmd.3:283
#: build/C/man3/rexec.3:161
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: tbl table
#: build/C/man3/ether_aton.3:146
#, no-wrap
msgid ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"
msgstr ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"

#. type: Plain text
#: build/C/man3/ether_aton.3:151
msgid "4.3BSD, SunOS."
msgstr "4.3BSD, SunOS."

#.  The fix was presumably commit c0a0f9a32c8baa6ab93d00eb42d92c02e9e146d7
#.  which was in glibc 2.3
#. type: Plain text
#: build/C/man3/ether_aton.3:157
msgid ""
"In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is broken."
msgstr "glibc 2.2.5 以前では、 B<ether_line>()  の実装はおかしい。"

#. type: Plain text
#: build/C/man3/ether_aton.3:159
msgid "B<ethers>(5)"
msgstr "B<ethers>(5)"

#. type: TH
#: build/C/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr "GAI.CONF"

#. type: TH
#: build/C/man5/gai.conf.5:19 build/C/man3/getnameinfo.3:10
#: build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:6
#: build/C/man3/inet_net_pton.3:25 build/C/man3/inet_ntop.3:26
#: build/C/man3/inet_pton.3:27 build/C/man5/nss.5:19
#, no-wrap
msgid "2020-06-09"
msgstr "2020-06-09"

#. type: Plain text
#: build/C/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr "gai.conf - getaddrinfo(3) 設定ファイル"

#. type: Plain text
#: build/C/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to RFC"
"\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr ""
"B<getaddrinfo>(3) の呼び出しでは、複数の答えが返る場合がある。 RFC\\ 3484 に"
"よれば、 これらの答えは、 最も成功の可能性が高い答えがリストの先頭になるよう"
"な順番に並び替えなければならない。 RFC には、 並び替えのアルゴリズムが書かれ"
"ている。 しかしながら、 静的なルールが常に適切という訳ではない。 この理由か"
"ら、 RFC では、 並び替え方法をシステム管理者が動的に変更できるようにすること"
"も要求している。 glibc の実装では、 I</etc/gai.conf> ファイルでこれが実現でき"
"るようになっている。"

#. type: Plain text
#: build/C/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr ""
"設定ファイルの各行は、キーワードとそのパラメーターで構成される。 ホワイトス"
"ペースはどこにあっても全て無視される。 \\(aq#\\(aq で始まる行はコメントで、 "
"無視される。"

#. type: Plain text
#: build/C/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr "現在のところ、認識されるキーワードは以下の通りである。"

#. type: TP
#: build/C/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr "B<label> I<netmask> I<precedence>"

#. type: Plain text
#: build/C/man5/gai.conf.5:51
#, fuzzy
#| msgid ""
#| "The value is added to the label table used in the RFC\\ 3484 sorting.  If "
#| "any B<label> definition is present in the configuration file is present, "
#| "the default table is not used.  All the label definitions of the default "
#| "table which are to be maintained have to be duplicated.  Following the "
#| "keyword, the line has to contain a network mask and a label value."
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file, the default "
"table is not used.  All the label definitions of the default table which are "
"to be maintained have to be duplicated.  Following the keyword, the line has "
"to contain a network mask and a precedence value."
msgstr ""
"指定した値は RFC\\ 3484 の並び替えで使用されるラベルテーブルに追加される。 設"
"定ファイルに B<label> 定義が一つでもあれば、デフォルトテーブルは使用されな"
"い。 デフォルトテーブルのすべてのラベル定義はきちんと管理されていれば、 重複"
"が発生するはずだからである。 ラベル行では、 キーワードの後に、 ネットワークマ"
"スクとラベル値が含まれていなければならない。"

#. type: TP
#: build/C/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr "B<precedence> I<netmask> I<precedence>"

#. type: Plain text
#: build/C/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table "
"to not be used."
msgstr ""
"このキーワードは B<label> に似ているが、 指定された値を RFC\\ 3484 で規定され"
"た優先度テーブルに追加する点が異なる。 繰り返しになるが、 設定ファイルに "
"B<precedence> が一つでもあれば、デフォルトテーブルは使用されない。"

#. type: TP
#: build/C/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr "B<reload> E<lt>B<yes>|B<no>E<gt>"

#. type: Plain text
#: build/C/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\", the file is reread.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr ""
"このキーワードは、 設定ファイルが前回の読み出し以降に変更されているかをプロセ"
"スが確認するかを制御する。 値が \"B<yes>\" であれば、 ファイルが再読み込みさ"
"れる。 再読み込みはマルチスレッドアプリケーションで問題を起こす可能性があ"
"り、 一般にはよい考えとは言えない。 デフォルトは \"B<no>\" である。"

#. type: TP
#: build/C/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr "B<scopev4> I<mask> I<value>"

#. type: Plain text
#: build/C/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr ""
"IPv4 アドレス用の RFC\\ 3484 スコープテーブルに別のルールを追加する。 デフォ"
"ルトでは、 RFC\\ 3438 のセクション 3.2 で説明されているスコープ ID が使用され"
"る。 これらのデフォルト値の変更が必要になることはまずないだろう。"

#. type: SH
#: build/C/man5/gai.conf.5:72 build/C/man3/getaddrinfo.3:591
#: build/C/man3/gethostbyname.3:329 build/C/man3/getnameinfo.3:198
#: build/C/man3/getnetent.3:141 build/C/man3/getprotoent.3:134
#: build/C/man3/getservent.3:153 build/C/man5/host.conf.5:116
#: build/C/man5/hosts.5:89 build/C/man5/hosts.equiv.5:69
#: build/C/man5/networks.5:70 build/C/man5/nss.5:98
#: build/C/man5/nsswitch.conf.5:332 build/C/man5/protocols.5:77
#: build/C/man5/resolv.conf.5:369 build/C/man3/resolver.3:478
#: build/C/man5/services.5:183 build/C/man3/setnetgrent.3:91
#: build/C/man7/udplite.7:126
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man5/gai.conf.5:74 build/C/man3/getaddrinfo.3:593
msgid "I</etc/gai.conf>"
msgstr "I</etc/gai.conf>"

#.  Added in 2006
#. type: Plain text
#: build/C/man5/gai.conf.5:79
msgid "The I<gai.conf> file is supported by glibc since version 2.5."
msgstr "I<gai.conf> ファイルは glibc バージョン 2.5 以降でサポートされている。"

#. type: Plain text
#: build/C/man5/gai.conf.5:82
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr ""
"RFC\\ 3484 で規定されているデフォルトテーブルは、 以下の設定ファイルを指定す"
"るのと同じである。"

#. type: Plain text
#: build/C/man5/gai.conf.5:95
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"

#. type: Plain text
#: build/C/man5/gai.conf.5:103
msgid "B<getaddrinfo>(3), RFC\\ 3484"
msgstr "B<getaddrinfo>(3), RFC\\ 3484"

#. type: TH
#: build/C/man3/getaddrinfo.3:44
#, no-wrap
msgid "GETADDRINFO"
msgstr "GETADDRINFO"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:48
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr ""
"getaddrinfo, freeaddrinfo, gai_strerror - ネットワークのアドレスとサービスを"
"変換する"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:53 build/C/man3/getipnodebyname.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:57
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:59
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:61
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr "B<const char *gai_strerror(int >I<errcode>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:74
#, no-wrap
msgid ""
"B<getaddrinfo>(),\n"
"B<freeaddrinfo>(),\n"
"B<gai_strerror>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service, "
"B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which "
"contains an Internet address that can be specified in a call to B<bind>(2)  "
"or B<connect>(2).  The B<getaddrinfo>()  function combines the functionality "
"provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  functions into "
"a single interface, but unlike the latter functions, B<getaddrinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""
"B<getaddrinfo>()  は、(インターネットのホストとサービスを識別する)  I<node> "
"と I<service> を渡すと、一つ以上の I<addrinfo> 構造体を返す。それぞれの "
"I<addrinfo> 構造体には、 B<bind>(2)  や B<connect>(2)  を呼び出す際に指定でき"
"るインターネットアドレスが格納されている。 B<getaddrinfo>()  関数は、 "
"B<gethostbyname>(3) と B<getservbyname>(3) の機能をまとめて一つのインター"
"フェースにしたものであるが、 これらの関数と違い、 B<getaddrinfo>() はリエント"
"ラントであり、 B<getaddrinfo>() を使うことでプログラムは IPv4 と IPv6 の違い"
"に関する依存関係を なくすことができる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr ""
"B<getaddrinfo>()  が用いる I<addrinfo> 構造体は以下のフィールドを含む。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr ""
"I<hints> 引数は I<addrinfo> 構造体を指し示し、この構造体を用いて I<res> が"
"指すリストに入れて返すソケットアドレス構造体を選択するための基準を指定する。 "
"I<hints> が NULL でない場合、 I<hints> は I<addrinfo> 構造体を指し示し、その"
"構造体のフィールド I<ai_family>, I<ai_socktype>, I<ai_protocol> で "
"B<getaddrinfo>()  が返すソケットアドレス集合に対する基準を指定する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr "I<ai_family>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses.  "
"Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value "
"B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket addresses "
"for any address family (either IPv4 or IPv6, for example) that can be used "
"with I<node> and I<service>."
msgstr ""
"このフィールドは返されるアドレスの希望のアドレスファミリーを指定する。 この"
"フィールドに指定できる有効な値としては B<AF_INET> と B<AF_INET6> がある。 ま"
"た、値 B<AF_UNSPEC> を指定すると、 B<getaddrinfo>()  は I<node> と "
"I<service> で使用できるいずれかのアドレスファミリー (例えば IPv4 か IPv6) の "
"ソケットアドレスを返すことを求められる。"

#. type: TP
#: build/C/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr "I<ai_socktype>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr ""
"このフィールドは推奨のソケット型 (例えば B<SOCK_STREAM> や B<SOCK_DGRAM>)  を"
"指定する。 このフィールドに 0 を指定すると、任意のソケット型のソケットアドレ"
"スを B<getaddrinfo>()  が返してよいことを意味する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr "I<ai_protocol>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol "
"can be returned by B<getaddrinfo>()."
msgstr ""
"このフィールドは返されるソケットアドレスのプロトコルを指定する。 このフィール"
"ドに 0 を指定すると、任意のプロトコルののソケットアドレスを "
"B<getaddrinfo>()  が返してよいことを意味する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr "I<ai_flags>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr ""
"このフィールドは、追加のオプション (下記) を指定する。 複数のフラグを指定する"
"際には、それらのビット単位の OR をとって指定する。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:180
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a null pointer, as appropriate."
msgstr ""
"I<hints> が指し示す構造体の他のすべてのフィールドには 0 かヌルポインターを適"
"切に入れなければならない。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:215
msgid ""
"Specifying I<hints> as NULL is equivalent to setting I<ai_socktype> and "
"I<ai_protocol> to 0; I<ai_family> to B<AF_UNSPEC>; and I<ai_flags> to "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>.  (POSIX specifies different defaults "
"for I<ai_flags>; see NOTES.)  I<node> specifies either a numerical network "
"address (for IPv4, numbers-and-dots notation as supported by "
"B<inet_aton>(3); for IPv6, hexadecimal string format as supported by "
"B<inet_pton>(3)), or a network hostname, whose network addresses are looked "
"up and resolved.  If I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag, "
"then I<node> must be a numerical network address.  The B<AI_NUMERICHOST> "
"flag suppresses any potentially lengthy network host address lookups."
msgstr ""
"I<hints> に NULL を指定するのは、 I<ai_socktype> と I<ai_protocol> に 0 を、 "
"I<ai_family> に B<AF_UNSPEC> を、 I<ai_flags> に B<(AI_V4MAPPED\\ |\\ "
"AI_ADDRCONFIG)> を設定するのと等価である (POSIX では I<ai_flags> には別のデ"
"フォルト値が規定されている; 「備考」を参照)。 I<node> には、数値形式のネット"
"ワークアドレス (IPv4 の場合は B<inet_aton>(3)  でサポートされているドット区切"
"りの数字による表記、 IPv6 の場合は B<inet_pton>(3)  でサポートされている 16 "
"進数の文字列形式) もしくは ネットワークホスト名を指定する。 ネットワークホス"
"ト名を指定した場合には、そのネットワークアドレスが検索され、 名前解決が行なわ"
"れる。 I<hints.ai_flags> に B<AI_NUMERICHOST> フラグが含まれている場合は、 "
"I<node> は数値形式のネットワークアドレスでなければならない。 "
"B<AI_NUMERICHOST> フラグを使うと、時間の掛かる可能性のあるネットワークホスト"
"アドレスの検索は すべて抑制される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:240
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the host's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""
"I<hints.ai_flags> に B<AI_PASSIVE> フラグが指定され、かつ I<node> が NULL の"
"場合、 返されるソケットアドレスは コネクションを B<accept>(2)  するためのソ"
"ケットを B<bind>(2)  するのに適したものとなる。 返されるソケットアドレスには"
"「ワイルドカードアドレス」 (IPv4 アドレスの場合は B<INADDR_ANY>、 IPv6 アドレ"
"スの場合は B<IN6ADDR_ANY_INIT>)  が入る。 ワイルドカードアドレスは、任意のホ"
"ストのネットワークアドレスで接続を 受け付けようとするアプリケーション (通常は"
"サーバー) で用いられる。 I<node> が NULL でない場合、 B<AI_PASSIVE> フラグは"
"無視される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:260
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned "
"socket addresses will be suitable for use with B<connect>(2), B<sendto>(2), "
"or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set "
"to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""
"I<hints.ai_flags> に B<AI_PASSIVE> フラグがセットされていない場合、 返される"
"ソケットアドレスは B<connect>(2), B<sendto>(2), B<sendmsg>(2)  での使用に適し"
"たものとなる。 I<node> が NULL の場合、ネットワークアドレスにはループバックイ"
"ンターフェイスの アドレス (IPv4 アドレスの場合は B<INADDR_LOOPBACK> IPv6 アド"
"レスの場合は B<IN6ADDR_LOOPBACK_INIT>)B<が設定される。> これは同じホスト上で"
"動作している接続相手と通信するような アプリケーションで用いられる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:283
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal "
"number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left "
"uninitialized.  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and "
"I<service> is not NULL, then I<service> must point to a string containing a "
"numeric port number.  This flag is used to inhibit the invocation of a name "
"resolution service in cases where it is known not to be required."
msgstr ""
"I<service> により、返される各アドレス構造体のポート番号が決まる。 この引数"
"がサービス名 (B<services>(5)  参照) の場合、対応するポート番号に翻訳される。 "
"この引数には 10 進数も指定することができ、 この場合にはバイナリへの変換だけ"
"が行われる。 I<service> が NULL の場合、返されるソケットアドレスのポート番号"
"は 初期化されないままとなる。 I<hints.ai_flags> に B<AI_NUMERICSERV> が指定さ"
"れ、かつ I<service> が NULL でない場合、 I<service> は数値のポート番号を含む"
"文字列を指し示さなければならない。 このフラグは、名前解決サービスが不要である"
"ことが分かっている場合に、 サービスの起動を抑制するために用いられる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:289
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr ""
"I<node> と I<service> のどちらかは NULL にしてよいが、両方同時に NULL にして"
"はならない。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:305
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns "
"a pointer to the start of the list in I<res>.  The items in the linked list "
"are linked by the I<ai_next> field."
msgstr ""
"B<getaddrinfo>()  関数は、 I<addrinfo> 構造体のメモリー確保を行い、 "
"I<addrinfo> 構造体のリンクリストを初期化し、 I<res> にリストの先頭へのポイン"
"ターを入れて返す。 このとき、各構造体のネットワークアドレスは I<node> と "
"I<service> に一致し、 I<hints> で課されたすべての制限を満たすものとなる。 リ"
"ンクリストの要素は I<ai_next> フィールドにより連結される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:327
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible "
"over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the same "
"service is available from multiple socket types (one B<SOCK_STREAM> address "
"and another B<SOCK_DGRAM> address, for example).  Normally, the application "
"should try using the addresses in the order in which they are returned.  The "
"sorting function used within B<getaddrinfo>()  is defined in RFC\\ 3484; the "
"order can be tweaked for a particular system by editing I</etc/gai.conf> "
"(available since glibc 2.5)."
msgstr ""
"リンクリストの I<addrinfo> 構造体は複数個になることもあり、その理由はいくつか"
"ある。 ネットワークホストがマルチホームである、 複数のプロトコルでアクセスで"
"きる (例えば B<AF_INET> と B<AF_INET6> の両方) 、 複数のソケット種別で同じ"
"サービスが利用できる (例えば、ひとつが B<SOCK_STREM> アドレスで、もうひとつ"
"が B<SOCK_DGRAM> アドレスである)、がある。 通常は、アプリケーションは返された"
"順序でアドレスを試すべきである。 B<getaddrinfo>()  の中で使用される並べ替え関"
"数は RFC\\ 3484 で定義されている。 特殊なシステムでは、 I</etc/gai.conf> を編"
"集することで、この順序を微調整することができる (I</etc/gai.conf> は glibc "
"2.5 以降で利用できる)。"

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: build/C/man3/getaddrinfo.3:342
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""
"I<hints.ai_flags> に B<AI_CANONNAME> フラグが含まれている場合、返されるリスト"
"の最初の I<addrinfo> 構造体の I<ai_canonname> フィールドはホストの公式な名前"
"を指すように設定される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:346
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""
"返される各々の I<addrinfo> 構造体の残りのフィールドは以下のように初期化され"
"る。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:369
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""
"I<ai_family>, I<ai_socktype>, I<ai_protocol> フィールドはソケット生成パラメー"
"ターを返す (これらのフィールドの意味は B<socket>(2)  の同じ名前の引数と同じ"
"である)。 例えば、 I<ai_family> は B<AF_INET> や B<AF_INET6> を返し、 "
"I<ai_socktype> は B<SOCK_DGRAM> や B<SOCK_STREAM> を返し、 I<ai_protocol> は"
"そのソケットのプロトコルを返す。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:376
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> field."
msgstr ""
"I<ai_addr> フィールドにはソケットアドレスへのポインターが書き込まれ、 "
"I<ai_addrlen> フィールドにはソケットアドレスの長さがバイト単位で書き込まれ"
"る。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:395
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses "
"are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address.  "
"This flag is useful on, for example, IPv4-only systems, to ensure that "
"B<getaddrinfo>()  does not return IPv6 socket addresses that would always "
"fail in B<connect>(2)  or B<bind>(2)."
msgstr ""
"I<hints.ai_flags> が B<AI_ADDRCONFIG> を含む場合、 I<res> が指すリストには、"
"ローカルシステムに最低一つの IPv4 アドレスが設定されている場合のみ IPv4 アド"
"レスが返され、 ローカルシステムに最低一つの IPv6 アドレスが設定されている場合"
"にのみ IPv6 アドレスが返される。 なお、この場合には、ループバックアドレスは有"
"効に設定されたアドレスとはみなされない。 このフラグは、例えば、IPv4 だけのシ"
"ステムで、 B<getaddrinfo>() が必ず IPv6 ソケットアドレスを返さないことを保証"
"するのに役立つ。 IPv4 だけのシステムでは、IPv6 アドレスは B<connect>(2) や "
"B<bind>(2) で必ず失敗することになる。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:420
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and I<hints."
"ai_family> was specified as B<AF_INET6>, and no matching IPv6 addresses "
"could be found, then return IPv4-mapped IPv6 addresses in the list pointed "
"to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified in I<hints."
"ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses in the list "
"pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is not also "
"specified."
msgstr ""
"I<hints.ai_flags> に B<AI_V4MAPPED> が指定されていて、 I<hints.ai_family> に "
"B<AF_INET6> が指定され、 マッチする IPv6 アドレスが見つからなかった場合、 "
"I<res> が指すリストには IPv4-mapped IPv6 アドレスが返される。 I<hints."
"ai_flags> に B<AI_V4MAPPED> と B<AI_ALL> の両方が指定されている場合、 I<res> "
"が指すリストには IPv6 アドレスと IPv4-mapped IPv6 アドレスの 両方が返され"
"る。 B<AI_V4MAPPED> が指定されていない場合、 B<AI_ALL> は無視される。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:426
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""
"B<freeaddrinfo>()  関数は、 リンクリスト I<res> に対して動的に割り当てられた"
"メモリーを解放する。"

#. type: SS
#: build/C/man3/getaddrinfo.3:426
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr "国際化ドメイン名のための getaddrinfo() の拡張"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:434
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr ""
"glibc 2.3.4 から、 B<getaddrinfo>()  は入出力するホスト名を透過的に国際化ドメ"
"イン名 (IDN) 形式 (RFC 3490 の I<Internationalizing Domain Names in "
"Applications (IDNA)> を参照のこと) と変換することを選択的に認めるように拡張さ"
"れている。 4 つの新しいフラグが定義されている:"

#. type: TP
#: build/C/man3/getaddrinfo.3:434
#, no-wrap
msgid "B<AI_IDN>"
msgstr "B<AI_IDN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:440
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr ""
"このフラグが指定されると、 I<node> で与えられたノード名は必要があれば IDN 形"
"式に変換される。 ソース符号化形式は現在のロケールのものである。"

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:452
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain non-"
"ASCII characters are encoded using ASCII Compatible Encoding (ACE)  before "
"being passed to the name resolution functions."
msgstr ""
"入力名に非 ASCII 文字が含まれている場合、 IDN 符号化形式が使われる。 非 "
"ASCII 文字が含まれている(ピリオドで区切られる)部分ノード名は、 名前解決機能に"
"渡される前に ASCII 互換符号化形式 (ACE) を使って 符号化される。"

#. type: TP
#: build/C/man3/getaddrinfo.3:452
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr "B<AI_CANONIDN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:464
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution function."
msgstr ""
"B<AI_CANONNAME> が指定されている場合、 B<getaddrinfo>()  は名前の検索に成功し"
"た後、 返された I<addrinfo> 構造体に対応するノードの正規名を返す。 返り値は名"
"前解決機能から返された値の正確なコピーである。"

#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:477
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's "
"encoding."
msgstr ""
"B<AI_CANONIDN> 名前が ACE で符号化されている場合、一つまたは複数の名前の構成"
"要素の先頭に I<xn--> を含んでいる。 これらの構成要素を読み込み可能な形に変換"
"するために、 B<AI_CANONNAME> と共に B<AI_CANONIDN> フラグを渡すことも出来"
"る。 返される文字列は現在のロケールの符号化形式で符号化されている。"

#. type: TP
#: build/C/man3/getaddrinfo.3:477
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:484 build/C/man3/getnameinfo.3:139
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the "
"IDNA handling."
msgstr ""
"これらのフラグをセットすると、IDNA 処理で使用されるフラグ "
"IDNA_ALLOW_UNASSIGNED (未割り当ての Unicode のコードポイントを許容) と "
"IDNA_USE_STD3_ASCII_RULES (出力が STD3 準拠のホスト名かをチェックする)  がそ"
"れぞれ有効になる。"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.     #ifdef __USE_GNU
#.     #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.     #define EAI_CANCELED    -101  /* Request canceled.  */
#.     #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.     #define EAI_ALLDONE     -103  /* All requests done.  */
#.     #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.     #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.     #endif
#. type: Plain text
#: build/C/man3/getaddrinfo.3:498
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr ""
"B<getaddrinfo>()  は成功すると 0 を返し、失敗すると以下の非 0 のエラーコード"
"のいずれかを返す。"

#. type: TP
#: build/C/man3/getaddrinfo.3:498
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr "B<EAI_ADDRFAMILY>"

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:503
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr ""
"指定されたネットワークホストには、 要求されたアドレスファミリーのネットワーク"
"アドレスがない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:503 build/C/man3/getaddrinfo_a.3:248
#: build/C/man3/getaddrinfo_a.3:265 build/C/man3/getnameinfo.3:156
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr "B<EAI_AGAIN>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:507
msgid ""
"The name server returned a temporary failure indication.  Try again later."
msgstr ""
"ネームサーバーから一時的な失敗 (temporary failure)  を意味する返事が返され"
"た。後でもう一度試してみよ。"

#. type: TP
#: build/C/man3/getaddrinfo.3:507 build/C/man3/getnameinfo.3:160
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr "B<EAI_BADFLAGS>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:517
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr ""
"I<hints.ai_flags> のフラグに不正なフラグが含まれている。または、 I<hints."
"ai_flags> に B<AI_CANONNAME> が含まれていて、かつ I<name> が NULL であった。"

#. type: TP
#: build/C/man3/getaddrinfo.3:517 build/C/man3/getnameinfo.3:165
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr "B<EAI_FAIL>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:520
msgid "The name server returned a permanent failure indication."
msgstr ""
"ネームサーバーから恒久的な失敗 (permanent failure)  を意味する返事が返され"
"た。"

#. type: TP
#: build/C/man3/getaddrinfo.3:520 build/C/man3/getnameinfo.3:168
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr "B<EAI_FAMILY>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:523
msgid "The requested address family is not supported."
msgstr "要求されたアドレスファミリーがサポートされていない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:523 build/C/man3/getaddrinfo_a.3:253
#: build/C/man3/getnameinfo.3:172
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr "B<EAI_MEMORY>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:526 build/C/man3/getaddrinfo_a.3:256
#: build/C/man3/getnameinfo.3:175 build/C/man7/unix.7:731
msgid "Out of memory."
msgstr "メモリーが足りない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:526
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr "B<EAI_NODATA>"

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:531
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr ""
"指定されたネットワークホストは存在するが、 ネットワークアドレスがひとつも定義"
"されていない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:531 build/C/man3/getnameinfo.3:175
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr "B<EAI_NONAME>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:548
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service> "
"was not a numeric port-number string."
msgstr ""
"I<node> と I<service> のどちらかが不明、または I<node> と I<service> の両方"
"が NULL だった場合、または B<AI_NUMERICSERV> が I<hints.ai_flags> に指定され"
"ていて、 I<hints.ai_flags> と I<service> が数値のポート番号の文字列でない。"

#. type: TP
#: build/C/man3/getaddrinfo.3:548
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr "B<EAI_SERVICE>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:569
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could "
"occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or I<hints."
"ai_socktype> was B<SOCK_DGRAM>; or the error could occur if I<service> was "
"not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket type that does "
"not support the concept of services)."
msgstr ""
"要求されたサービスは、要求されたソケットタイプでは利用できない。 他のソケット"
"タイプでなら利用可能かもしれない。 このエラーが発生する例としては、 "
"I<service> が \"shell\" (ストリームソケットでのみ利用できるサービス) で、 "
"I<hints.ai_protocol> に B<IPPROTO_UDP> が指定されたり、 I<hints.ai_socktype> "
"に B<SOCK_DGRAM> が指定されたりした場合がある。 また、 I<service> が NULL 以"
"外で、 I<hints.ai_socktype> に B<SOCK_RAW> (サービスの考え方をサポートしてい"
"ないソケット種別)  が指定された場合にも、このエラーが発生する。"

#. type: TP
#: build/C/man3/getaddrinfo.3:569
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr "B<EAI_SOCKTYPE>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:581
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr ""
"要求されたソケットタイプがサポートされていない。 このエラーが発生する例として"
"は、 I<hints.ai_socktype> と I<hints.ai_protocol> が矛盾している場合 (例えば "
"I<hints.ai_socktype> が B<SOCK_DGRAM> で I<hints.ai_protocol> が "
"B<IPPROTO_TCP>)  がある。"

#. type: TP
#: build/C/man3/getaddrinfo.3:581 build/C/man3/getaddrinfo_a.3:256
#: build/C/man3/getnameinfo.3:188
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr "B<EAI_SYSTEM>"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:586
msgid "Other system error, check I<errno> for details."
msgstr "その他のシステムエラー。詳しくは I<errno> を調べること。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:591
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""
"B<gai_strerror>()  関数を用いると、これらのエラーコードを人間に可読な文字列に"
"変換できるので、 エラー報告に適するだろう。"

#. type: tbl table
#: build/C/man3/getaddrinfo.3:603
#, no-wrap
msgid "B<getaddrinfo>()"
msgstr "B<getaddrinfo>()"

#. type: tbl table
#: build/C/man3/getaddrinfo.3:603 build/C/man3/gethostbyname.3:395
#: build/C/man3/getnameinfo.3:217
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: tbl table
#: build/C/man3/getaddrinfo.3:607
#, no-wrap
msgid ""
"B<freeaddrinfo>(),\n"
"B<gai_strerror>()"
msgstr ""
"B<freeaddrinfo>(),\n"
"B<gai_strerror>()"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:615
msgid ""
"POSIX.1-2001, POSIX.1-2008.  The B<getaddrinfo>()  function is documented in "
"RFC\\ 2553."
msgstr "POSIX.1-2001, POSIX.1-2008.  B<getaddrinfo>()  関数は RFC 2553 に記載されている。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:620
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr ""
"B<getaddrinfo>()  は、IPv6 scope-ID を指定するために I<address>B<%>I<scope-"
"id> 記法をサポートしている。"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:628
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, B<AI_V4MAPPED> は glibc 2.3.3 以降で利用可能であ"
"る。 B<AI_NUMERICSERV> は glibc 2.3.4 以降で利用可能である。"

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: build/C/man3/getaddrinfo.3:639
msgid ""
"According to POSIX.1, specifying I<hints> as NULL should cause I<ai_flags> "
"to be assumed as 0.  The GNU C library instead assumes a value of "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr "POSIX.1 によると、 I<hints> に NULL が指定された場合、 I<ai_flags> を 0 とみなすべきとされている。 GNU C ライブラリでは、この場合に、代わりに I<ai_flags> を B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> とみなすようになっている。 この値の方が標準規格の改善になると考えられているからである。"

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: build/C/man3/getaddrinfo.3:653
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr ""
"以下のプログラムは、 B<getaddrinfo>(), B<gai_strerror>(), B<freeaddrinfo>(), "
"B<getnameinfo>(3)  の使い方を示したものである。 プログラムは UDP データグラム"
"の echo サーバとクライアントである。"

#. type: SS
#: build/C/man3/getaddrinfo.3:653
#, no-wrap
msgid "Server program"
msgstr "サーバのプログラム"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:663
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>  \n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:665 build/C/man3/getaddrinfo.3:760
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr "#define BUF_SIZE 500\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:676
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:681
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:690
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:696
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:701
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:707
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype, \n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:710
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:713 build/C/man3/getaddrinfo.3:806
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr ""
"        close(sfd);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:715 build/C/man3/getaddrinfo.3:808
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr "    freeaddrinfo(result);           /* No longer needed */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:720
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:722
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr "    /* Read datagrams and echo them back to sender */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:729
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(peer_addr);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(peer_addr);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:731
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:740
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"        if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"        if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:747
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"

#. type: SS
#: build/C/man3/getaddrinfo.3:748
#, no-wrap
msgid "Client program"
msgstr "クライアントのプログラム"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:758
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:770
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:775
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:777
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr "    /* Obtain address(es) matching host/port */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:783
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr ""
"    memset(&hints, 0, sizeof(hints));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:789
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:794
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:800
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:803
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:813
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:816
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr ""
"    /* Send remaining command-line arguments as separate \n"
"       datagrams, and read responses from server */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:820
#, no-wrap
msgid ""
"    for (int j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr ""
"    for (int j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:826
#, no-wrap
msgid ""
"        if (len E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr ""
"        if (len E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:831
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:837
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo.3:840
#, no-wrap
msgid ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"
msgstr ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:854
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"

#. type: TH
#: build/C/man3/getaddrinfo_a.3:30
#, no-wrap
msgid "GETADDRINFO_A"
msgstr "GETADDRINFO_A"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:34
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - 非同期のネットワークアド"
"レスとサービスの変換"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:41
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:44
#, no-wrap
msgid ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:46
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_error(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:48
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:50
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr "I<-lanl> でリンクする。\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:58
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr ""
"B<getaddrinfo_a>() 関数は B<getaddrinfo>(3) と同じ処理を実行するが、 複数の名"
"前検索を非同期で実行でき、 検索処理の完了の通知ができる点が異なる。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:62
msgid "The I<mode> argument has one of the following values:"
msgstr "I<mode> 引数は以下の値のいずれかを指定する。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:62
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr "B<GAI_WAIT>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:66
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have "
"completed."
msgstr "検索を同期で実行する。 呼び出しは検索が完了するまで停止 (block) する。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:66
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr "B<GAI_NOWAIT>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:74
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""
"検索を非同期で実行する。 呼び出しは直ちに返り、 要求はバックグラウンドで処理"
"される。 以下の I<sevp> 引数の議論を参照。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:89
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up "
"operations are started in parallel.  NULL elements in I<list> are ignored.  "
"Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""
"配列 I<list> は処理すべき検索要求を指定する。 I<nitems> 引数は I<list> の要"
"素数を指定する。 要求された検索命令は並列に開始される。 I<list> の NULL 要素"
"は無視される。 各要求は以下のように定義された I<gaicb> 構造体で規定される。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:98
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:129
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and "
"I<ar_service> to the I<service> argument, identifying an Internet host and a "
"service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr ""
"この構造体の要素は B<getaddrinfo>(3) の引数に対応している。 したがって、 "
"I<ar_name> はインターネットホストを示す I<node> 引数に、 I<ar_service> は"
"サービスを示す I<service> 引数に対応する。 I<ar_request> 要素は、 返された"
"ソケットアドレス構造体を選択する基準を示す I<hints> 引数に対応する。 最後"
"の I<ar_request> は I<res> 引数に対応する。 この要素を初期化する必要はな"
"く、この要素は要求が解決されると自動的にセットされる。 最後の 2 つの要素が参"
"照している I<addrinfo> 構造体については B<getaddrinfo>(3) に説明がある。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:145
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have "
"the following values:"
msgstr ""
"I<mode> に B<GAI_NOWAIT> が指定された場合、 解決した要求に関する通知を "
"I<sevp> 引数が指す I<sigevent> 構造体を使って受け取ることができる。 この構"
"造体の定義と一般的な説明については B<sigevent>(7) を参照。 I<sevp-"
"E<gt>sigev_notify> フィールドには以下の値を指定できる。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:145
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:148
msgid "Don't provide any notification."
msgstr "通知は行わない。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:148
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:164
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""
"検索が完了した際に、 プロセスに対してシグナル I<sigev_signo> を生成する。 一"
"般的な説明は B<sigevent>(7) を参照。 I<siginfo_t> 構造体の I<si_code> フィー"
"ルドには B<SI_ASYNCNL> がセットされる。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:164
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:172
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""
"検索が完了した際に、 I<sigev_notify_function> を新しいスレッドの開始関数であ"
"るかのように起動する。 詳細は B<sigevent>(7) を参照。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:181
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point I<sevp-"
"E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""
"B<SIGEV_SIGNAL> と B<SIGEV_THREAD> では、 I<sevp-E<gt>sigev_value.sival_ptr> "
"が I<list> を指すようにしておくと役立つことがある。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:192
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""
"B<gai_suspend>() 関数は呼び出し元のスレッドの実行を中断し、 配列 I<list> 内の"
"一つ以上の要求が完了するのを待つ。 I<nitems> 引数は配列 I<list> の大きさを"
"指定する。 呼び出しは以下のいずれかの状況になるまで停止する。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:196
msgid "One or more of the operations in I<list> completes."
msgstr "I<list> 内の一つ以上の操作が完了した。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:198
msgid "The call is interrupted by a signal that is caught."
msgstr "呼び出しが補足されたシグナルに割り込まれた。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:211
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""
"I<timeout> で指定された期間が経過した。 この引数は、秒とナノ秒でタイムアウ"
"トを指定する (I<timespec> 構造体の詳細は B<nanosleep>(2) を参照)。 "
"I<timeout> が NULL の場合、 (上記のイベントのいずれかが発生するまで) 呼び出し"
"は無限に停止する。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:216
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""
"どの要求が完了したかは明示的な通知は行われない。 どの要求が完了したかを知るた"
"めには、 要求のリストに対して B<gai_error>() を繰り返し呼び出す必要がある。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:226
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""
"B<gai_error>() 関数は要求 I<req> のステータスを返す。 要求がまだ完了していな"
"い場合は B<EAI_INPROGRESS> が、 要求が正常に処理された場合は 0 が、 要求を解"
"決できなかった場合はエラーコードが返される。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:243
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr "B<gai_cancel>() 関数は要求 I<req> をキャンセルする。 要求が正常にキャンセルされた場合、 要求のエラーステータスに B<EAI_CANCELED> が設定され、 通常の非同期通知が実行される。 要求が現在処理中でキャンセルできない場合もある。 この場合 B<gai_cancel>() が呼ばれなかったかのように処理が行われる。 I<req> が NULL の場合、 そのプロセスが行ったすべての処理中の要求をキャンセルしようとする。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:248
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""
"B<getaddrinfo_a>() 関数はすべての要求が正常にキューに追加されると 0 を返す。 "
"または、以下のいずれかの 0 でないエラーコードを返す。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:253
msgid ""
"The resources necessary to enqueue the look-up requests were not available.  "
"The application may check the error status of each request to determine "
"which ones failed."
msgstr ""
"検索要求をキューに入れるために必要なリソースがなかった。 アプリケーションは書"
"く要求のエラーステータスを確認し、 どの要求が失敗したかを判定することができ"
"る。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:260
msgid "I<mode> is invalid."
msgstr "I<mode> が無効である。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:265
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""
"B<gai_suspend>() 関数はリストの要求の少なくともひとつが完了すると 0 を返す。 "
"それ以外の場合、 以下の 0 でないエラーコードのいずれかを返す。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:268
msgid ""
"The given timeout expired before any of the requests could be completed."
msgstr "いずれかの要求が完了する前に指定されたタイムアウト時間が満了した。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:268 build/C/man3/getaddrinfo_a.3:298
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr "B<EAI_ALLDONE>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:271
msgid "There were no actual requests given to the function."
msgstr "指定された関数には実際には要求がなかった。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:271
#, no-wrap
msgid "B<EAI_INTR>"
msgstr "B<EAI_INTR>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:276
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""
"シグナルが関数に割り込んだ。 この割り込みは検索要求が完了したことを示すシグナ"
"ル通知により起こる場合もある。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:288
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELED> if the request has been canceled "
"explicitly before it could be finished."
msgstr "B<gai_error>() 関数は、 完了していない検索要求に対して B<EAI_INPROGRESS> を返し、 成功で完了した検索に対して 0 を返す。 B<getaddrinfo>(3) が返すエラーコードのいずれかを返す場合もある。 要求の完了前に明示的に要求がキャンセルされた場合はエラーコード B<EAI_CANCELED> を返す。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:292
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr "B<gai_cancel>() 関数はこれらの値のいずれかを返すことがある。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:292
#, no-wrap
msgid "B<EAI_CANCELED>"
msgstr "B<EAI_CANCELED>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:295
msgid "The request has been canceled successfully."
msgstr "要求は正常にキャンセルされた。"

#. type: TP
#: build/C/man3/getaddrinfo_a.3:295
#, no-wrap
msgid "B<EAI_NOTCANCELED>"
msgstr "B<EAI_NOTCANCELED>"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:298
msgid "The request has not been canceled."
msgstr "要求はキャンセルされていない。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:301
msgid "The request has already completed."
msgstr "要求はすでに完了している。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:306 build/C/man3/getnameinfo.3:198
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""
"B<gai_strerror>(3) 関数を使うと、 これらのエラーコードを、 エラーレポートに適"
"した人間が読みやすい文字列に翻訳してくれる。"

#. type: tbl table
#: build/C/man3/getaddrinfo_a.3:319
#, no-wrap
msgid ""
"B<getaddrinfo_a>(),\n"
"B<gai_suspend>(),\n"
"B<gai_error>(),\n"
"B<gai_cancel>()"
msgstr ""
"B<getaddrinfo_a>(),\n"
"B<gai_suspend>(),\n"
"B<gai_error>(),\n"
"B<gai_cancel>()"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:325
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr ""
"これらの関数は GNU 拡張である。 バージョン 2.2.3 で初めて glibc に登場した。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:331
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)  "
"interface."
msgstr ""
"B<getaddrinfo_a>() インターフェースは B<lio_listio>(3) インターフェースの後に"
"モデル化された。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:335
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""
"ここでは二つの例を示す。 一つは複数の要求を同期処理で並行して解決する例で、 "
"もう一つは非同期機能を使った複雑な例である。"

#. type: SS
#: build/C/man3/getaddrinfo_a.3:335
#, no-wrap
msgid "Synchronous example"
msgstr "同期型の例"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:340
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""
"以下のプログラムは単に複数のホスト名の解決を並行で行う。 B<getaddrinfo>(3) を"
"使って順番にホスト名の解決を行うのに比べて速度が向上する。 このプログラムは以"
"下のように使う。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:347
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:351
msgid "Here is the program source code"
msgstr "プログラムのソースコードは以下のとおりである。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:358 build/C/man3/getaddrinfo_a.3:447
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:366
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:381
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:388
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""
"    for (int i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:404
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:411
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: build/C/man3/getaddrinfo_a.3:412
#, no-wrap
msgid "Asynchronous example"
msgstr "非同期型の例"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:417
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""
"この例は B<getaddrinfo_a>() の簡単な対話式のフロントエンドである。 通知機能は"
"使っていない。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:419
msgid "An example session might look like this:"
msgstr "セッションの実行例は以下のようになる。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:436
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:440
msgid "The program source is as follows:"
msgstr "プログラムのソースは以下のとおりである。"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:450
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:455
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:459
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:462
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:465
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr ""
"    return buf;\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:473
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:477
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, sizeof(reqs[0]) * nreqs);\n"
msgstr ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, sizeof(reqs[0]) * nreqs);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:481
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:483
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr "    /* Queue nreqs_base..nreqs requests. */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:492
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:504 build/C/man3/getaddrinfo_a.3:541
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:509 build/C/man3/getaddrinfo_a.3:546
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:512
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:518
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:522
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:526
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:531
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:538
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:552
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:560
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:564
#, no-wrap
msgid ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr ""
"    for (int i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:567
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:582
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:588
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:591
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:616
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:624
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"

#. type: TH
#: build/C/man1/getent.1:25
#, no-wrap
msgid "GETENT"
msgstr "GETENT"

#. type: TH
#: build/C/man1/getent.1:25 build/C/man3/gethostbyname.3:38
#: build/C/man3/getnetent.3:30 build/C/man3/getprotoent.3:30
#: build/C/man3/getservent.3:34 build/C/man3/inet.3:42 build/C/man7/ipv6.7:86
#: build/C/man5/nscd.conf.5:20 build/C/man7/packet.7:12 build/C/man3/rcmd.3:43
#: build/C/man3/resolver.3:33 build/C/man7/tcp.7:96
#, no-wrap
msgid "2020-12-21"
msgstr "2020-12-21"

#. type: TH
#: build/C/man1/getent.1:25
#, no-wrap
msgid "User Commands"
msgstr "User Commands"

#. type: Plain text
#: build/C/man1/getent.1:28
msgid "getent - get entries from Name Service Switch libraries"
msgstr "getent - 名前サービス切り替えライブラリからエントリーを取得する"

#. type: Plain text
#: build/C/man1/getent.1:30
msgid "B<getent\\ [>I<option>B<]...\\ >I<database>B<\\ >I<key>B<...>"
msgstr "B<getent\\ [>I<option>B<]...\\ >I<database>B<\\ >I<key>B<...>"

#. type: Plain text
#: build/C/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If "
"one or more I<key> arguments are provided, then only the entries that match "
"the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr ""
"B<getent> コマンドは、 名前サービス切り替えライブラリでサポートされているデー"
"タベースのエントリーを表示する。 名前サービス切り替えライブラリの設定は I</"
"etc/nsswitch.conf> で行う。 一つ以上の I<key> 引数が指定されると、 指定され"
"たキーにマッチするエントリーだけが表示される。 I<key> が指定されなかった場"
"合、 すべてのエントリーが表示される (データベースで列挙 (enumeration) がサ"
"ポートされていない場合を除く)。"

#. type: Plain text
#: build/C/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr ""
"I<database> には GNU C ライブラリでサポートされているデータベースのいずれかを"
"指定できる。 以下にそのリストを示す。"

#. type: TP
#: build/C/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr "B<ahosts>"

#. type: Plain text
#: build/C/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr ""
"I<key> が指定されなかった場合、 B<sethostent>(3), B<gethostent>(3), "
"B<endhostent>(3) を使用して hosts データベースを列挙する。 これは B<hosts> を"
"使うのと全く同じである。 I<key> 引数が一つ以上指定された場合は、 それぞれ"
"の I<key> についてアドレスファミリー B<AF_UNSPEC> で B<getaddrinfo>(3) を呼び"
"出し、 返された各々のソケットアドレス構造体を列挙する。"

#. type: TP
#: build/C/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr "B<ahostsv4>"

#. type: Plain text
#: build/C/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr ""
"B<ahosts> を同じだが、 アドレスファミリーとして B<AF_INET> を使用する。"

#. type: TP
#: build/C/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr "B<ahostsv6>"

#. type: Plain text
#: build/C/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr ""
"B<ahosts> を同じだが、 アドレスファミリーとして B<AF_INET6> を使用する。 この"
"場合の B<getaddrinfo>(3) の呼び出しでは B<AI_V4MAPPED> も指定される。"

#. type: TP
#: build/C/man1/getent.1:88 build/C/man5/nsswitch.conf.5:44
#: build/C/man5/nsswitch.conf.5:371
#, no-wrap
msgid "B<aliases>"
msgstr "B<aliases>"

#. type: Plain text
#: build/C/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setaliasent>(3), B<getaliasent>(3), "
"B<endaliasent>(3) を使用して aliases データベースを列挙する。 I<key> 引数が"
"一つ以上指定された場合は、 それぞれの I<key> についてB<getaliasbyname>(3) を"
"呼び出し、 結果を表示する。"

#. type: TP
#: build/C/man1/getent.1:105 build/C/man5/nsswitch.conf.5:49
#: build/C/man5/nsswitch.conf.5:375
#, no-wrap
msgid "B<ethers>"
msgstr "B<ethers>"

#. type: Plain text
#: build/C/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr ""
"I<key> 引数が一つ以上指定された場合、 結果が得られるまで、 それぞれの "
"I<key> について B<ether_aton>(3) と B<ether_hostton>(3) を順に呼び出し、 結果"
"を表示する。 B<ethers> では列挙はサポートされていない。 したがって、 I<key> "
"は指定しなければならない。"

#. type: TP
#: build/C/man1/getent.1:121 build/C/man5/nsswitch.conf.5:52
#: build/C/man5/nsswitch.conf.5:378
#, no-wrap
msgid "B<group>"
msgstr "B<group>"

#. type: Plain text
#: build/C/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each "
"nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setgrent>(3), B<getgrent>(3), "
"B<endgrent>(3) を使用して group データベースを列挙する。 I<key> 引数が一つ"
"以上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getgrgid>(3) を、 数値以外であれば B<getgrnam>(3) を呼び出し、 結果を表示す"
"る。"

#. type: TP
#: build/C/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr "B<gshadow>"

#. type: Plain text
#: build/C/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setsgent>(3), B<getsgent>(3), "
"B<endsgent>(3) を使用して gshadow データベースを列挙する。 I<key> 引数が一"
"つ以上指定された場合は、 それぞれの I<key> について B<getsgnam>(3) を呼び出"
"し、 結果を表示する。"

#. type: TP
#: build/C/man1/getent.1:159 build/C/man5/nsswitch.conf.5:57
#: build/C/man5/nsswitch.conf.5:381
#, no-wrap
msgid "B<hosts>"
msgstr "B<hosts>"

#. type: Plain text
#: build/C/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the "
"result."
msgstr ""
"I<key> が指定されなかった場合、 B<sethostent>(3), B<gethostent>(3), "
"B<endhostent>(3) を使用して hosts データベースを列挙する。 I<key> 引数が一"
"つ以上指定された場合は、 それぞれの I<key> について B<gethostbyaddr>(3) か "
"B<gethostbyname2>(3) を呼び出し、 結果を表示する。 B<gethostbyaddr>(3) か "
"B<gethostbyname2>(3) のどちらを呼び出すかは、B<inet_pton>(3) の呼び出しで、 "
"I<key> が IPv6 や IPv4 アドレスか、 そうでないか、 判定され、その結果によって"
"決まる。"

#. type: TP
#: build/C/man1/getent.1:182 build/C/man5/nsswitch.conf.5:62
#: build/C/man5/nsswitch.conf.5:384
#, no-wrap
msgid "B<initgroups>"
msgstr "B<initgroups>"

#. type: Plain text
#: build/C/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr ""
"I<key> 引数が一つ以上指定された場合、 結果が得られるまで、 それぞれの "
"I<key> について B<getgrouplist>(3) を呼び出し、 結果を表示する。 "
"B<initgroups> では列挙はサポートされていない。 したがって、 I<key> は指定しな"
"ければならない。"

#. type: TP
#: build/C/man1/getent.1:196 build/C/man5/nsswitch.conf.5:67
#: build/C/man5/nsswitch.conf.5:387
#, no-wrap
msgid "B<netgroup>"
msgstr "B<netgroup>"

#. type: Plain text
#: build/C/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username>, and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on "
"B<netgroup>, so either one or three I<keys> must be provided."
msgstr ""
"1 個の I<key> を指定すると、 その I<key> を B<setnetgrent>(3) に渡し、 "
"B<getnetgrent>(3) を使って結果の 3 つ組の文字列 (I<hostname>, I<username>, "
"I<domainname>) を表示する。 代わりに、 3 個の I<key> を指定することもでき"
"る。 3 個の I<key> は I<hostname>, I<username>, I<domainname> と解釈され、 "
"B<innetgr>(3) を使って対応する netgroup があるか照合される。 B<netgroup> では"
"列挙はサポートされていない。 したがって、 1 個か 3 個のいずれかの I<key> を指"
"定しなければならない。"

#. type: TP
#: build/C/man1/getent.1:222 build/C/man5/nsswitch.conf.5:71
#: build/C/man5/nsswitch.conf.5:390
#, no-wrap
msgid "B<networks>"
msgstr "B<networks>"

#. type: Plain text
#: build/C/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setnetent>(3), B<getnetent>(3), "
"B<endnetent>(3) を使用して networks データベースを列挙する。 I<key> 引数が"
"一つ以上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getnetbyaddr>(3) を、 数値以外であれば B<getnetbyname>(3) を呼び出し、 結果"
"を表示する。"

#. type: TP
#: build/C/man1/getent.1:243 build/C/man5/nsswitch.conf.5:76
#: build/C/man5/nsswitch.conf.5:393
#, no-wrap
msgid "B<passwd>"
msgstr "B<passwd>"

#. type: Plain text
#: build/C/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each "
"nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setpwent>(3), B<getpwent>(3), "
"B<endpwent>(3) を使用して passwd データベースを列挙する。 I<key> 引数が一つ"
"以上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getpwgid>(3) を、 数値以外であれば B<getpwnam>(3) を呼び出し、 結果を表示す"
"る。"

#. type: TP
#: build/C/man1/getent.1:264 build/C/man5/nsswitch.conf.5:81
#: build/C/man5/nsswitch.conf.5:396
#, no-wrap
msgid "B<protocols>"
msgstr "B<protocols>"

#. type: Plain text
#: build/C/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setprotoent>(3), B<getprotoent>(3), "
"B<endprotoent>(3) を使用して protocols データベースを列挙する。 I<key> 引数"
"が一つ以上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getprotobynumber>(3) を、 数値以外であれば B<getprotobyname>(3) を呼び出"
"し、 結果を表示する。"

#. type: TP
#: build/C/man1/getent.1:285 build/C/man5/nsswitch.conf.5:89
#: build/C/man5/nsswitch.conf.5:402
#, no-wrap
msgid "B<rpc>"
msgstr "B<rpc>"

#. type: Plain text
#: build/C/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setrpcent>(3), B<getrpcent>(3), "
"B<endrpcent>(3) を使用して rpc データベースを列挙する。 I<key> 引数が一つ以"
"上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getrpcbynumber>(3) を、 数値以外であれば B<getrpcbyname>(3) を呼び出し、 結"
"果を表示する。"

#. type: TP
#: build/C/man1/getent.1:306 build/C/man5/nsswitch.conf.5:94
#: build/C/man5/nsswitch.conf.5:405
#, no-wrap
msgid "B<services>"
msgstr "B<services>"

#. type: Plain text
#: build/C/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setservent>(3), B<getservent>(3), "
"B<endservent>(3) を使用して services データベースを列挙する。 I<key> 引数が"
"一つ以上指定された場合は、 それぞれの I<key> について、 数値であれば "
"B<getservbynumber>(3) を、 数値以外であれば B<getservbyname>(3) を呼び出し、 "
"結果を表示する。"

#. type: TP
#: build/C/man1/getent.1:327 build/C/man5/nsswitch.conf.5:99
#: build/C/man5/nsswitch.conf.5:408
#, no-wrap
msgid "B<shadow>"
msgstr "B<shadow>"

#. type: Plain text
#: build/C/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr ""
"I<key> が指定されなかった場合、 B<setspent>(3), B<getspent>(3), "
"B<endspent>(3) を使用して shadow データベースを列挙する。 I<key> 引数が一つ"
"以上指定された場合は、 それぞれの I<key> について B<getspnam>(3) を呼び出"
"し、 結果を表示する。"

#. type: SH
#: build/C/man1/getent.1:345 build/C/man8/nscd.8:60
#, no-wrap
msgid "OPTIONS"
msgstr "オプション"

#. type: TP
#: build/C/man1/getent.1:346
#, no-wrap
msgid "B<-s\\ >I<service>, B<--service\\ >I<service>"
msgstr "B<-s\\ >I<service>, B<--service\\ >I<service>"

#.  commit 9d0881aa76b399e6a025c5cf44bebe2ae0efa8af (glibc)
#. type: Plain text
#: build/C/man1/getent.1:351
msgid ""
"Override all databases with the specified service.  (Since glibc 2.2.5.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:351
#, no-wrap
msgid "B<-s\\ >I<database>B<:>I<service>, B<--service\\ >I<database>B<:>I<service>"
msgstr "B<-s\\ >I<database>B<:>I<service>, B<--service\\ >I<database>B<:>I<service>"

#.  commit b4f6f4be85d32b9c03361c38376e36f08100e3e8 (glibc)
#. type: Plain text
#: build/C/man1/getent.1:359
msgid ""
"Override only specified databases with the specified service.  The option "
"may be used multiple times, but only the last service for each database will "
"be used.  (Since glibc 2.4.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:359
#, no-wrap
msgid "B<-i>, B<--no-idn>"
msgstr ""

#.  commit a160f8d808cf8020b13bd0ef4a9eaf3c11f964ad (glibc)
#. type: Plain text
#: build/C/man1/getent.1:365
msgid ""
"Disables IDN encoding in lookups for B<ahosts>/B<getaddrinfo>(3)  (Since "
"glibc-2.13.)"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:365
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr "B<-?>, B<--help>"

#. type: Plain text
#: build/C/man1/getent.1:368
msgid "Print a usage summary and exit."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:368
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: build/C/man1/getent.1:371
msgid "Print a short usage summary and exit."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:371
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr "B<-V>, B<--version>"

#. type: Plain text
#: build/C/man1/getent.1:375
msgid ""
"Print the version number, license, and disclaimer of warranty for B<getent>."
msgstr ""

#. type: SH
#: build/C/man1/getent.1:375
#, no-wrap
msgid "EXIT STATUS"
msgstr "終了ステータス"

#. type: Plain text
#: build/C/man1/getent.1:378
msgid "One of the following exit values can be returned by B<getent>:"
msgstr "B<getent> は以下のいずれかの終了ステータスを返す。"

#. type: TP
#: build/C/man1/getent.1:379
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man1/getent.1:382
msgid "Command completed successfully."
msgstr "コマンドが正常に完了した。"

#. type: TP
#: build/C/man1/getent.1:382
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: build/C/man1/getent.1:387
msgid "Missing arguments, or I<database> unknown."
msgstr "引数が不足しているか、 知らない I<database> が指定された。"

#. type: TP
#: build/C/man1/getent.1:387
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: build/C/man1/getent.1:393
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr "指定された I<key> が I<database> で見つからなかった。"

#. type: TP
#: build/C/man1/getent.1:393
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man1/getent.1:397
msgid "Enumeration not supported on this I<database>."
msgstr "この I<database> では列挙はサポートされていない。"

#. type: Plain text
#: build/C/man1/getent.1:400
msgid "B<nsswitch.conf>(5)"
msgstr "B<nsswitch.conf>(5)"

#. type: TH
#: build/C/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr "GETHOSTBYNAME"

#. type: Plain text
#: build/C/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - ネットワーク上のホストのエントリーを取得する"

#. type: Plain text
#: build/C/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>       /* AF_INET を使う場合 */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr "B<void sethostent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr "B<void endhostent(void);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr "B<void herror(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr "B<const char *hstrerror(int >I<err>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:67
#, no-wrap
msgid ""
"/* System V/POSIX extension */\n"
"B<struct hostent *gethostent(void);>\n"
msgstr ""
"/* System V/POSIX 拡張 */\n"
"B<struct hostent *gethostent(void);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:70
#, no-wrap
msgid ""
"/* GNU extensions */\n"
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr ""
"/* GNU 拡張 */\n"
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:74
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:78
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:82
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:86
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:100
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"

#. type: TP
#: build/C/man3/gethostbyname.3:101 build/C/man3/gethostbyname.3:114
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "glibc 2.19 以降:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:104 build/C/man3/gethostbyname.3:117
#: build/C/man3/inet_net_pton.3:54
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: build/C/man3/gethostbyname.3:104
#, no-wrap
msgid "Glibc versions up to and including 2.19:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:107 build/C/man3/gethostbyname.3:120
#: build/C/man3/inet_net_pton.3:57
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/gethostbyname.3:113
msgid "B<herror>(), B<hstrerror>():"
msgstr "B<herror>(), B<hstrerror>():"

#. type: TP
#: build/C/man3/gethostbyname.3:117
#, no-wrap
msgid "Glibc 2.8 to 2.19:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:120
#, no-wrap
msgid "Before glibc 2.8:"
msgstr "glibc 2.8 より前:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:123 build/C/man3/gethostbyname.3:138
msgid "none"
msgstr "なし"

#. type: Plain text
#: build/C/man3/gethostbyname.3:128
msgid "B<h_errno>:"
msgstr "B<h_errno>:"

#. type: TP
#: build/C/man3/gethostbyname.3:129
#, no-wrap
msgid "Since glibc 2.19"
msgstr "glibc 2.19 以降:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:132
msgid "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"

#. type: TP
#: build/C/man3/gethostbyname.3:132
#, no-wrap
msgid "Glibc 2.12 to 2.19:"
msgstr "glibc 2.12 から 2.19 まで:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:135
msgid "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"

#. type: TP
#: build/C/man3/gethostbyname.3:135
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.12 より前:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:155
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and "
"B<hstrerror>()  functions are obsolete.  Applications should use "
"B<getaddrinfo>(3), B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr ""
"関数 B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), B<hstrerror> は過"
"去のものである。 アプリケーションは、代わりに B<getaddrinfo>(3), "
"B<getnameinfo>(3), B<gai_strerror>(3) を使用すること。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:194
#, fuzzy
#| msgid ""
#| "The B<gethostbyname>()  function returns a structure of type I<hostent> "
#| "for the given host I<name>.  Here I<name> is either a hostname, or an "
#| "IPv4 address in standard dot notation (as for B<inet_addr>(3)), or an "
#| "IPv6 address in colon (and possibly dot) notation.  (See RFC\\ 1884 for "
#| "the description of IPv6 addresses.)  If I<name> is an IPv4 or IPv6 "
#| "address, no lookup is performed and B<gethostbyname>()  simply copies "
#| "I<name> into the I<h_name> field and its I<struct in_addr> equivalent "
#| "into the I<h_addr_list[0]> field of the returned I<hostent> structure.  "
#| "If I<name> doesn't end in a dot and the environment variable "
#| "B<HOSTALIASES> is set, the alias file pointed to by B<HOSTALIASES> will "
#| "first be searched for I<name> (see B<hostname>(7)  for the file format).  "
#| "The current domain and its parents are searched unless I<name> ends in a "
#| "dot."
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)).  If I<name> is an "
"IPv4 address, no lookup is performed and B<gethostbyname>()  simply copies "
"I<name> into the I<h_name> field and its I<struct in_addr> equivalent into "
"the I<h_addr_list[0]> field of the returned I<hostent> structure.  If "
"I<name> doesn't end in a dot and the environment variable B<HOSTALIASES> is "
"set, the alias file pointed to by B<HOSTALIASES> will first be searched for "
"I<name> (see B<hostname>(7)  for the file format).  The current domain and "
"its parents are searched unless I<name> ends in a dot."
msgstr ""
"B<gethostbyname>()  関数は与えられたホスト名 I<name> に対応する構造体 "
"I<hostent> を返す。 I<name> にはホスト名、ドット区切りの IPv4 アドレス "
"(B<inet_addr>(3)  参照)、コロン区切りの IPv6 アドレス (おそらくドット区切りで"
"も大丈夫)  のいずれかを指定する (IPv6 アドレスの記述方法については RFC\\ "
"1884 を参考にしてほしい)。 I<name> が IPv4 か IPv6 のアドレスだった場合、 名"
"前解決 (lookup) は行われない。その場合には、 B<gethostbyname>()  は I<name> "
"をそのまま I<hostent> 構造体の I<h_name> フィールドにコピーし、 さらに "
"I<name> を I<struct in_addr> 形式で表したデータを I<hostent> 構造体の "
"I<h_addr_list[0]> フィールドに入れて、その I<hostent> 構造体を返す。 I<name> "
"がドットで終了していて、かつ環境変数 B<HOSTALIASES> が設定されている場合、ま"
"ず B<HOSTALIASES> で指定されているエイリアスファイルから I<name> のエントリー"
"が検索される (ファイルのフォーマットについては B<hostname>(7)  を参照のこ"
"と)。 I<name> がドットで終了していなければ、現在のドメインとその親ドメインが"
"検索される。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:210
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""
"B<gethostbyaddr>()  関数は与えられたホストアドレス I<addr> (長さ I<len>、 タ"
"イプ I<type>) に対応する構造体 I<hostent> を返す。 用いることのできるタイプ"
"は B<AF_INET> と B<AF_INET6> である。 ホストアドレス引数はアドレスタイプに"
"依存した 構造体へのポインターである。 例えば、アドレスタイプ B<AF_INET> に対"
"しては (B<inet_addr>(3)  の呼び出しで得られる)  I<struct in_addr *> である。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:217
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the "
"connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""
"B<sethostent>()  関数は、ネームサーバへの接続形態を指定する。 I<stayopen> が"
"真 (1) ならば、ネームサーバへの問い合わせには、 接続された TCP ソケットを用"
"い、連続した問い合わせの間に接続を維持する。 偽ならばネームサーバへの問い合わ"
"せに UDP データグラムを用いる。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:222
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""
"B<endhostent>()  関数はネームサーバへの問い合わせに用いた TCP 接続の利用を終"
"了する。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:227
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""
"(廃止予定の)  B<herror>()  関数は現在の I<h_errno> に対応するエラーメッセージ"
"を標準エラー I<stderr> に出力する。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:232
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""
"(廃止予定の)  B<hstrerror>()  関数はエラー番号 (通常は I<h_errno>) を引数に"
"取り、 対応するエラーメッセージ文字列を返す。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:246
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  rely on the Name Service Switch (B<nsswitch.conf>(5))  "
"configured sources or a local name server (B<named>(8)).  The default action "
"is to query the Name Service Switch (B<nsswitch.conf>(5))  configured "
"sources, failing that, a local name server (B<named>(8))."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:246 build/C/man5/host.conf.5:135
#, fuzzy, no-wrap
#| msgid "Historical notes"
msgid "Historical"
msgstr "歴史的な経緯"

#. type: Plain text
#: build/C/man3/gethostbyname.3:250 build/C/man5/host.conf.5:139
msgid ""
"The B<nsswitch.conf>(5)  file is the modern way of controlling the order of "
"host lookups."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:256
msgid ""
"In glibc 2.4 and earlier, the I<order> keyword was used to control the order "
"of host lookups as defined in I</etc/host.conf> (B<host.conf>(5))."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:258
msgid "The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "I<hostent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man3/gethostbyname.3:269
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* 過去との互換性のため */\n"

#. type: Plain text
#: build/C/man3/gethostbyname.3:273
msgid "The members of the I<hostent> structure are:"
msgstr "I<hostent> 構造体のメンバは以下の通り。"

#. type: TP
#: build/C/man3/gethostbyname.3:273 build/C/man3/getipnodebyname.3:210
#, no-wrap
msgid "I<h_name>"
msgstr "I<h_name>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:276
msgid "The official name of the host."
msgstr "ホストの正式名 (official name)。"

#. type: TP
#: build/C/man3/gethostbyname.3:276 build/C/man3/getipnodebyname.3:213
#, no-wrap
msgid "I<h_aliases>"
msgstr "I<h_aliases>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:279
msgid ""
"An array of alternative names for the host, terminated by a null pointer."
msgstr "ホストの別名の配列。配列はヌルポインターで終端される。"

#. type: TP
#: build/C/man3/gethostbyname.3:279 build/C/man3/getipnodebyname.3:217
#, no-wrap
msgid "I<h_addrtype>"
msgstr "I<h_addrtype>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:286
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr "アドレスのタイプ。現在はすべて B<AF_INET> または B<AF_INET6> である。"

#. type: TP
#: build/C/man3/gethostbyname.3:286 build/C/man3/getipnodebyname.3:239
#, no-wrap
msgid "I<h_length>"
msgstr "I<h_length>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:289
msgid "The length of the address in bytes."
msgstr "バイト単位で表したアドレスの長さ。"

#. type: TP
#: build/C/man3/gethostbyname.3:289 build/C/man3/getipnodebyname.3:253
#, no-wrap
msgid "I<h_addr_list>"
msgstr "I<h_addr_list>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:293
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a null pointer."
msgstr ""
"ホストのネットワークアドレスへのポインターの配列。 配列はヌルポインターで終端"
"される。 ネットワークアドレスはネットワークバイトオーダ形式である。"

#. type: TP
#: build/C/man3/gethostbyname.3:293
#, no-wrap
msgid "I<h_addr>"
msgstr "I<h_addr>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:296
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""
"I<h_addr_list> の最初のアドレス。過去との互換性を保つためのものである。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:308
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a null pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""
"B<gethostbyname>()  および B<gethostbyaddr>()  関数は I<hostent> 構造体を返"
"す。エラーが起こったらヌルポインターを返す。エラーの際には I<h_errno> 変数が"
"エラーの番号を保持する。 返り値が NULL でない場合、静的データをポインターで指"
"していることもある。 以下の「注意」を参照すること。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:310
msgid "The variable I<h_errno> can have the following values:"
msgstr "I<h_errno> 変数は以下の値を取りうる。"

#. type: TP
#: build/C/man3/gethostbyname.3:310 build/C/man3/getipnodebyname.3:190
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr "B<HOST_NOT_FOUND>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:313
msgid "The specified host is unknown."
msgstr "指定したホストが見つからない。"

#. type: TP
#: build/C/man3/gethostbyname.3:313
#, no-wrap
msgid "B<NO_DATA>"
msgstr "B<NO_DATA>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:322
msgid ""
"The requested name is valid but does not have an IP address.  Another type "
"of request to the name server for this domain may return an answer.  The "
"constant B<NO_ADDRESS> is a synonym for B<NO_DATA>."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:322 build/C/man3/getipnodebyname.3:199
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr "B<NO_RECOVERY>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:325
msgid "A nonrecoverable name server error occurred."
msgstr "ネームサーバの復旧不能なエラーが起こった。"

#. type: TP
#: build/C/man3/gethostbyname.3:325 build/C/man3/getipnodebyname.3:202
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr "B<TRY_AGAIN>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:329
msgid ""
"A temporary error occurred on an authoritative name server.  Try again later."
msgstr ""
"authoritative なネームサーバで一時的なエラーが起こった。 時間をおいてもう一度"
"試すこと。"

#. type: TP
#: build/C/man3/gethostbyname.3:330 build/C/man5/host.conf.5:117
#: build/C/man3/resolver.3:482
#, no-wrap
msgid "I</etc/host.conf>"
msgstr "I</etc/host.conf>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:333 build/C/man3/resolver.3:482
#: build/C/man3/resolver.3:485
msgid "resolver configuration file"
msgstr "名前解決の設定ファイル"

#. type: Plain text
#: build/C/man3/gethostbyname.3:333 build/C/man3/getnameinfo.3:200
#: build/C/man5/host.conf.5:123 build/C/man5/hosts.5:91
#: build/C/man5/nsswitch.conf.5:384
#, no-wrap
msgid "I</etc/hosts>"
msgstr "I</etc/hosts>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:336
msgid "host database file"
msgstr "ホストのデータベースファイル"

#. type: Plain text
#: build/C/man3/gethostbyname.3:336 build/C/man3/getnameinfo.3:202
#: build/C/man5/nsswitch.conf.5:340 build/C/man3/setnetgrent.3:95
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#. type: Plain text
#: build/C/man3/gethostbyname.3:339
msgid "name service switch configuration"
msgstr "ネームサービス切替設定"

#. type: tbl table
#: build/C/man3/gethostbyname.3:349
#, no-wrap
msgid "B<gethostbyname>()"
msgstr "B<gethostbyname>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:351
#, no-wrap
msgid "MT-Unsafe race:hostbyname env\n"
msgstr "MT-Unsafe race:hostbyname env\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:351 build/C/man3/gethostbyname.3:358
#: build/C/man3/gethostbyname.3:363 build/C/man3/gethostbyname.3:365
#: build/C/man3/gethostbyname.3:369 build/C/man3/gethostbyname.3:374
#: build/C/man3/gethostbyname.3:381 build/C/man3/gethostbyname.3:388
#: build/C/man3/getnetent.3:157 build/C/man3/getnetent.3:164
#: build/C/man3/getnetent.3:171 build/C/man3/getnetent.3:176
#: build/C/man3/getnetent.3:180 build/C/man3/getprotoent.3:152
#: build/C/man3/getprotoent.3:159 build/C/man3/getprotoent.3:166
#: build/C/man3/getprotoent.3:171 build/C/man3/getprotoent.3:175
#: build/C/man3/getprotoent_r.3:142 build/C/man3/getprotoent_r.3:144
#: build/C/man3/getservent.3:169 build/C/man3/getservent.3:176
#: build/C/man3/getservent.3:183 build/C/man3/getservent.3:188
#: build/C/man3/getservent.3:192 build/C/man3/inet.3:234
#: build/C/man3/inet.3:241 build/C/man3/rcmd.3:291 build/C/man3/resolver.3:497
#: build/C/man3/resolver.3:505 build/C/man3/setnetgrent.3:105
#: build/C/man3/setnetgrent.3:107 build/C/man3/setnetgrent.3:111
#: build/C/man3/setnetgrent.3:121
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:353 build/C/man3/gethostbyname.3:360
#: build/C/man3/gethostbyname.3:371 build/C/man3/getnetent.3:173
#: build/C/man3/getnetent.3:182 build/C/man3/getprotoent.3:161
#: build/C/man3/getprotoent.3:168 build/C/man3/getprotoent.3:177
#: build/C/man3/getservent.3:178 build/C/man3/getservent.3:185
#: build/C/man3/getservent.3:194 build/C/man3/setnetgrent.3:113
#, no-wrap
msgid "locale"
msgstr "locale"

#. type: tbl table
#: build/C/man3/gethostbyname.3:356
#, no-wrap
msgid "B<gethostbyaddr>()"
msgstr "B<gethostbyaddr>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:358
#, no-wrap
msgid "MT-Unsafe race:hostbyaddr env\n"
msgstr "MT-Unsafe race:hostbyaddr env\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:363
#, no-wrap
msgid "B<sethostent>(),\n"
msgstr "B<sethostent>(),\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:365
#, no-wrap
msgid "B<endhostent>(),\n"
msgstr "B<endhostent>(),\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:367
#, no-wrap
msgid "B<gethostent_r>()"
msgstr "B<gethostent_r>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:369
#, no-wrap
msgid "MT-Unsafe race:hostent env\n"
msgstr "MT-Unsafe race:hostent env\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:374
#, no-wrap
msgid "B<herror>(),\n"
msgstr "B<herror>(),\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:376
#, no-wrap
msgid "B<hstrerror>()"
msgstr "B<hstrerror>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:379
#, no-wrap
msgid "B<gethostent>()"
msgstr "B<gethostent>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:381
#, no-wrap
msgid "MT-Unsafe race:hostent\n"
msgstr "MT-Unsafe race:hostent\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:383
#, no-wrap
msgid "race:hostentbuf env locale"
msgstr "race:hostentbuf env locale"

#. type: tbl table
#: build/C/man3/gethostbyname.3:386
#, no-wrap
msgid "B<gethostbyname2>()"
msgstr "B<gethostbyname2>()"

#. type: tbl table
#: build/C/man3/gethostbyname.3:388
#, no-wrap
msgid "MT-Unsafe race:hostbyname2\n"
msgstr "MT-Unsafe race:hostbyname2\n"

#. type: tbl table
#: build/C/man3/gethostbyname.3:390 build/C/man3/getnetent.3:166
#, no-wrap
msgid "env locale"
msgstr "env locale"

#. type: tbl table
#: build/C/man3/gethostbyname.3:395
#, no-wrap
msgid ""
"B<gethostbyaddr_r>(),\n"
"B<gethostbyname_r>(),\n"
"B<gethostbyname2_r>()"
msgstr ""
"B<gethostbyaddr_r>(),\n"
"B<gethostbyname_r>(),\n"
"B<gethostbyname2_r>()"

#. type: Plain text
#: build/C/man3/gethostbyname.3:410
msgid ""
"In the above table, I<hostent> in I<race:hostent> signifies that if any of "
"the functions B<sethostent>(), B<gethostent>(), B<gethostent_r>(), or "
"B<endhostent>()  are used in parallel in different threads of a program, "
"then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:434
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use "
"of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""
"POSIX.1-2001 では、 B<gethostbyname>(), B<gethostbyaddr>(), B<sethostent>(), "
"B<endhostent>(), B<gethostent>(), I<h_errno> が規定されており、 "
"B<gethostbyaddr>()  と B<gethostbyname>()  は廃止予定であるとされている。 "
"POSIX.1-2008 では B<gethostbyname>(), B<gethostbyaddr>(), I<h_errno> の仕様が"
"削除されている。 代わりに、 B<getaddrinfo>(3)  と B<getnameinfo>(3)  の使用が"
"推奨されている。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:444
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""
"B<gethostbyname>()  および B<gethostbyaddr>()  関数は静的データへのポインター"
"を返す。 このポインターは、その後の呼び出しで上書きされるかもしれない。 "
"I<hostent> 構造体はポインターを含んでいるので、構造体のコピーだけでは不十分で"
"ある; より深いコピーが必要である。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:468
msgid ""
"In the original BSD implementation the I<len> argument of "
"B<gethostbyname>()  was an I<int>.  The SUSv2 standard is buggy and declares "
"the I<len> argument of B<gethostbyaddr>()  to be of type I<size_t>.  (That "
"is wrong, because it has to be I<int>, and I<size_t> is not.  POSIX.1-2001 "
"makes it I<socklen_t>, which is OK.)  See also B<accept>(2)."
msgstr ""
"オリジナルの BSD の実装では、 B<gethostbyname>()  の I<len> 引数は I<int> "
"であった。 SUSv2 標準はバグが多く、 B<gethostbyaddr>()  の I<len> パラメー"
"ターを I<size_t> 型として宣言している。 (これは誤りで、 I<size_t> 型ではなく "
"I<int> 型でなければならない。 POSIX.1-2001 ではこれを I<socklen_t> としている"
"が、これは OK。)  B<accept>(2)  も参照。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:474
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr ""
"B<gethostbyaddr>()  の BSD のプロトタイプは、最初の引数として I<const char"
"\\ *> を使う。"

#. type: SS
#: build/C/man3/gethostbyname.3:474
#, no-wrap
msgid "System V/POSIX extension"
msgstr "System V/POSIX 拡張"

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: build/C/man3/gethostbyname.3:491
msgid ""
"POSIX requires the B<gethostent>()  call, which should return the next entry "
"in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems, a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""
"POSIX では、 B<gethostent>()  が必須とされている。 この関数はホストデータベー"
"スの次のエントリーを返す。 DNS/BIND を使う場合はあまり意味を持たないが、 ホス"
"トデータベースが 1 行ずつ読み込まれるファイルである場合は意味がある。 多くの"
"システムでは、この名前のルーチンはファイル I</etc/hosts> を読み込む。 DNS サ"
"ポートなしでライブラリがビルドされた場合にのみ利用可能である。 glibc 版は "
"ipv6 エントリーを無視する。 この関数はリエントラント (reentrant) ではなく、 "
"glibc にはリエントラント版の B<gethostent_r>()  が追加された。"

#. type: SS
#: build/C/man3/gethostbyname.3:491
#, no-wrap
msgid "GNU extensions"
msgstr "GNU 拡張"

#. type: Plain text
#: build/C/man3/gethostbyname.3:497
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""
"glibc2 には B<gethostbyname2>()  もあり、 B<gethostbyname>()  と同じように動"
"作するが、 こちらはアドレスが属するアドレスファミリーを指定することができる。"

#. type: Plain text
#: build/C/man3/gethostbyname.3:531
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""
"glibc2 にはリエントラントな B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  と B<gethostbyname2_r>()  もある。 呼び出し側は、成功時"
"に結果が格納される I<hostent> 構造体 I<ret> と、大きさ I<buflen> の一時的な作"
"業バッファー I<buf> を提供する。 コール終了後、成功した場合 I<result> は結果"
"を指している。 エラーの場合、またはエントリーが見つからなかった場合、 "
"I<result> は NULL になる。 これらの関数は、成功した場合 0 を返し、失敗の場合"
"は 0 以外のエラー番号を返す。 これらの関数のリエントラントでないバージョンが"
"返すエラーに加えて、 これらの関数は、 I<buf> が小さすぎた場合に B<ERANGE> を"
"返す。この場合はもっと大きなバッファーを用意して 関数呼び出しを再度行うべきで"
"ある。 大域変数 I<h_errno> は変更されないが、エラー番号を格納する変数のアドレ"
"スが I<h_errnop> に渡される。"

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: build/C/man3/gethostbyname.3:536
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""
"B<gethostbyname>()  は、16進数表現のドット区切りの IPv4 アドレス文字列の要素"
"を認識しない。"

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#.  .BR resolv+ (8)
#. type: Plain text
#: build/C/man3/gethostbyname.3:550
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"

#. type: TH
#: build/C/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr "GETIPNODEBYNAME"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""
"getipnodebyname, getipnodebyaddr, freehostent - ネットワークホストの名前とア"
"ドレスの取得"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr "B<void freehostent(struct hostent *>I<ip>B<);>\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""
"これらの関数は非推奨である (glibc では利用できない)。 代わりに "
"B<getaddrinfo>(3)  と B<getnameinfo>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""
"B<getipnodebyname>()  と B<getipnodebyaddr>()  は、ネットワークホストの名前と"
"アドレスを返す。 これらの関数は、以下の構造体へのポインターを返す。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""
"これらの関数は、 IPv4 ネットワークアドレスファミリーにしかアクセスできない "
"B<gethostbyname>(3)  や B<gethostbyaddr>(3)  を置き換えるものである。 "
"B<getipnodebyname>()  関数と B<getipnodebyaddr>()  関数は複数のネットワークア"
"ドレスファミリーにアクセス可能になっている。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""
"これらの関数は、 B<gethostby> の関数群と異なり、動的に割り当てられたメモリー"
"へのポインターを返す。 呼び出し元がこれらの I<hostent> 構造体を必要としなく"
"なった後は、 B<freehostent>()  関数を用いれば動的な割り当てメモリーを解放でき"
"る。"

#. type: SS
#: build/C/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr "getipnodebyname() の引数"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""
"B<getipnodebyname>()  関数は I<name> 引数で指定されたホストのネットワークア"
"ドレスを引く。 I<af> 引数には以下の値のいずれかを指定する。"

#. type: TP
#: build/C/man3/getipnodebyname.3:104 build/C/man3/getipnodebyname.3:166
#: build/C/man3/inet_ntop.3:57 build/C/man3/inet_pton.3:55
#, no-wrap
msgid "B<AF_INET>"
msgstr "B<AF_INET>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""
"I<name> 引数は、ドットで 4 つに区切られた IPv4 アドレスか、 IPv4 ネットワー"
"クホストの名前へのポインターである。"

#. type: TP
#: build/C/man3/getipnodebyname.3:110 build/C/man3/getipnodebyname.3:176
#: build/C/man3/inet_ntop.3:70 build/C/man3/inet_pton.3:69
#, no-wrap
msgid "B<AF_INET6>"
msgstr "B<AF_INET6>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""
"I<name> 引数は、16 進の IPv6 アドレスか、 IPv6 ネットワークホストの名前への"
"ポインターである。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to "
"0 if no options are desired."
msgstr ""
"I<flags> パラメーターには追加のオプションを指定する。 複数のフラグを指定する"
"には、それらのビット単位の OR をとって指定すればよい。 オプションをひとつも指"
"定したくないときには、 I<flags> に 0 を設定する必要がある。"

#. type: TP
#: build/C/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr "B<AI_V4MAPPED>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""
"このフラグは B<AF_INET6> と共に用いられ、IPv6 アドレスの代わりに IPv4 アドレ"
"スを問い合わせる。 問い合わせる IPv4 アドレスは IPv6 アドレスにマップされる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr "B<AI_ALL>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""
"このフラグは B<AI_V4MAPPED> と共に用いられ、IPv4 アドレスと IPv6 アドレスの両"
"方を問い合わせる。 見つかった IPv4 アドレスは、すべて IPv6 アドレスにマップさ"
"れる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr "B<AI_ADDRCONFIG>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address "
"assigned to a network interface, and that queries for IPv4 addresses should "
"not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""
"このフラグは B<AF_INET6> と共に用いられ、 IPv6 が割り当てられたネットワークイ"
"ンターフェースが システムにひとつもなければ IPv6 アドレスの問い合わせを行わ"
"ず、 IPv4 が割り当てられたネットワークインターフェースが システムにひとつもな"
"ければ IPv4 アドレスの問い合わせを行わないように要求する。 このフラグは単独で"
"も、あるいは B<AI_V4MAPPED> フラグと共にでも用いることができる。"

#. type: TP
#: build/C/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr "B<AI_DEFAULT>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr "このフラグは B<(AI_ADDRCONFIG>|B<AI_V4MAPPED)> と等価である。"

#. type: SS
#: build/C/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr "getipnodebyaddr() の引数"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""
"B<getipnodebyaddr>()  関数は、ネットワークアドレスが I<addr> 引数で指定され"
"たホストの名前を引く。 I<af> 引数には以下の値のいずれかを指定する。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to "
"I<sizeof(struct in_addr)>."
msgstr ""
"I<addr> 引数は I<struct in_addr> へのポインターであり、 I<len> 引数は "
"I<sizeof(struct in_addr)> に設定しなければならない。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""
"I<addr> 引数は I<struct in6_addr> へのポインターであり、 I<len> 引数は "
"I<sizeof(struct in6_addr)> に設定しなければならない。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:190
msgid ""
"NULL is returned if an error occurred, and I<error_num> will contain an "
"error code from the following list:"
msgstr ""
"エラーが起こると NULL が返され、 I<error_num> に以下にリストされたエラーコー"
"ドのいずれかが設定される。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr "ホスト名またはネットワークアドレスが見つからなかった。"

#. type: TP
#: build/C/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr "B<NO_ADDRESS>"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer "
"was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""
"ドメインネームサーバーは そのネットワークアドレスまたはネットワーク名を認識し"
"たが、 返事が返ってこなかった。原因としては、 例えば IPv4 アドレスしか持たな"
"いネットワークホストに対して IPv6 の情報の問い合わせが行われた (およびその"
"逆) などが考えられる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr ""
"ドメインネームサーバーから恒久的な失敗 (permanent failure)  を意味する返事が"
"返された。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""
"ネームサーバーから一時的な失敗 (temporary failure)  を意味する返事が返され"
"た。次にはもうちょっと運が必要かも。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains "
"the following fields:"
msgstr ""
"問い合わせに成功すると、 I<hostent> 構造体へのポインターが返される。 この構造"
"体は以下のフィールドからなる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr "これはこのネットワークホストのオフィシャルな名前である。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a null pointer."
msgstr ""
"これは、そのホストのオフィシャルでない別名へのポインターの配列である。 配列は"
"ヌルポインターで終端する。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""
"これは B<getipnodebyname>()  または B<getipnodebyaddr>()  に与えられた I<af> "
"引数のコピーである。 I<af> 引数が B<AF_INET> なら I<h_addrtype> は常に "
"B<AF_INET> になり、 I<af> 引数が B<AF_INET6> なら I<h_addrtype> も常に "
"B<AF_INET6> になる。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""
"このフィールドは、 I<h_addrtype> が B<AF_INET> なら I<sizeof(struct "
"in_addr)> に、 I<h_addrtype> が B<AF_INET6> なら I<sizeof(struct in6_addr)> "
"に設定される。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a null pointer."
msgstr ""
"これはひとつ以上のポインターの配列で、 それぞれのポインターは、 そのネット"
"ワークホストに対応するネットワークアドレス構造体を指す。 この配列はヌルポイン"
"ターで終端する。"

#.  Not in POSIX.1-2001.
#. type: Plain text
#: build/C/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr "RFC\\ 2553."

#. type: Plain text
#: build/C/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""
"これらの関数は glibc 2.1.91-95 に存在したが、再び削除された。 いくつかの "
"UNIX 風システムはこれらの関数に対応しているが、 これらの関数は全て推奨されな"
"い。"

#. type: Plain text
#: build/C/man3/getipnodebyname.3:271
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"

#. type: TH
#: build/C/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr "GETNAMEINFO"

#. type: Plain text
#: build/C/man3/getnameinfo.3:13
msgid ""
"getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""
"getnameinfo - アドレスから名前への変換をプロトコルに依存しないかたちで行う"

#. type: Plain text
#: build/C/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t >I<addrlen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t >I<addrlen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:32
#, no-wrap
msgid ""
"B<getnameinfo>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""
"B<getnameinfo>():\n"
"    glibc 2.22 以降: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    glibc 2.21 以前: _POSIX_C_SOURCE\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:48
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a protocol-"
"independent manner.  It combines the functionality of B<gethostbyaddr>(3)  "
"and B<getservbyport>(3), but unlike those functions, B<getnameinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""
"B<getnameinfo>()  関数は、 B<getaddrinfo>(3)  の逆の動作を行う。つまり、プロ"
"トコルに依存しないかたちで ソケットアドレスから対応するホスト名とサービスへの"
"変換を行う。 この関数は B<gethostbyaddr>(3)  と B<getservbyport>(3)  の機能を"
"一つにしたものだが、 これらの関数と違い、 B<getnameinfo>(3)  はリエントラント"
"であり、IPv4 と IPv6 の差分に依存しないかたちで プログラムを書くことができ"
"る。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:71
msgid ""
"The I<addr> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<addrlen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr "I<addr> 引数は、 IP アドレスとポート番号の情報を保持している 汎用的なソケットアドレス構造体 (I<sockaddr_in> 型または I<sockaddr_in6> 型) へのポインターである。 I<addrlen> は I<addr> のサイズである。 I<host> と I<serv> 引数は、(それぞれサイズが I<hostlen> と I<servlen> の) 呼び出し側で確保されたバッファーへのポインターであり、 ホスト名とサービス名を含むヌル終端された文字列が それぞれのバッファーに格納される。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:84
msgid ""
"The caller can specify that no hostname (or no service name)  is required by "
"providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""
"ホスト名が不要であることをこの関数に伝えるには、 I<host> に NULL を指定する"
"か、 I<hostlen> に 0 を指定する。同様に、サービス名が不要な場合は、 I<serv> "
"に NULL を指定するか、 I<servlen> に 0 を指定する。 しかし、ホスト名とサービ"
"ス名の両方を不要だと指定することはできない (いずれか一方は要求すること)。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:90
msgid ""
"The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""
"I<flags> 引数で B<getnameinfo>()  の動作を変えることができる。指定できる値"
"は以下の通り:"

#. type: TP
#: build/C/man3/getnameinfo.3:90
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr "B<NI_NAMEREQD>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:93
msgid "If set, then an error is returned if the hostname cannot be determined."
msgstr "指定すると、ホスト名が決定できなかった場合にエラーを返す。"

#. type: TP
#: build/C/man3/getnameinfo.3:93
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr "B<NI_DGRAM>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:99
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512\\(en514)  that have "
"different services for UDP and TCP."
msgstr "指定すると、ストリームベース (TCP) でなくデータグラムベース (UDP)  のサービスを対象にする。数は少ないが、 UDP と TCP で違うサービスを提供しているポート (512\\(en514) に対して必要となる。"

#. type: TP
#: build/C/man3/getnameinfo.3:99
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr "B<NI_NOFQDN>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:103
msgid ""
"If set, return only the hostname part of the fully qualified domain name for "
"local hosts."
msgstr ""
"指定すると、ローカルなホストには fully qualified domain name (FQDN) の ホスト"
"名の部分のみを返す。"

#. type: TP
#: build/C/man3/getnameinfo.3:103
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr "B<NI_NUMERICHOST>"

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2001 TC1 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: build/C/man3/getnameinfo.3:113
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""
"指定すると、数値形式のホスト名が返される。 (指定しなくても、ノードの名前が決"
"定できない場合は数値形式が返ることがある)。"

#. type: TP
#: build/C/man3/getnameinfo.3:113
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr "B<NI_NUMERICSERV>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:118
msgid ""
"If set, then the numeric form of the service address is returned.  (When not "
"set, this will still happen in case the service's name cannot be determined.)"
msgstr ""
"指定すると、数値形式のサービス名 (例えばポート番号) が返される (指定しなくて"
"も、サービス名が決定できない場合は数値形式が返ることがある)。"

#. type: SS
#: build/C/man3/getnameinfo.3:118
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr "国際化ドメイン名のための getnameinfo() の拡張"

#. type: Plain text
#: build/C/man3/getnameinfo.3:126
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags "
"are defined:"
msgstr ""
"glibc 2.3.4 から、 B<getnameinfo>()  に拡張が行われ、ホスト名と 国際化ドメイ"
"ン名 (Internationalized Domain Name; IDN) 形式との間で 透過的な変換ができるよ"
"うになっている (IDN 形式については RFC 3490 の I<Internationalizing Domain "
"Names in Applications (IDNA)> を参照)。3つのフラグが新たに定義されている:"

#. type: TP
#: build/C/man3/getnameinfo.3:126
#, no-wrap
msgid "B<NI_IDN>"
msgstr "B<NI_IDN>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:132
msgid ""
"If this flag is used, then the name found in the lookup process is converted "
"from IDN format to the locale's encoding if necessary.  ASCII-only names are "
"not affected by the conversion, which makes this flag usable in existing "
"programs and environments."
msgstr ""
"このフラグを指定すると、必要であれば、検索処理で見つかった名前は IDN 形式から"
"ロケールに応じた符号化形式に変換される。 ASCII 文字だけの名前はこの変換では影"
"響を受けない。このため、 既存のプログラムや環境でこのフラグを使うことができ"
"る。"

#. type: TP
#: build/C/man3/getnameinfo.3:132
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.      #ifdef __USE_GNU
#.      #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.      #define EAI_CANCELED    -101  /* Request canceled.  */
#.      #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.      #define EAI_ALLDONE     -103  /* All requests done.  */
#.      #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.      #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.      #endif
#. type: Plain text
#: build/C/man3/getnameinfo.3:156
msgid ""
"On success, 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified "
"buffer lengths.  On error, one of the following nonzero error codes is "
"returned:"
msgstr ""
"成功すると 0 が返り、(要求されていれば) ノードとサービスの名前がヌル終端され"
"た文字列の形式でそれぞれの指定バッファーに返される (バッファーの長さにあうよ"
"うに縮められるかもしれない)。 エラーの場合は、以下の 0 以外のエラーコードが返"
"される:"

#. type: Plain text
#: build/C/man3/getnameinfo.3:160
msgid "The name could not be resolved at this time.  Try again later."
msgstr "指定された名前が現時点では解決できなかった。 後で再試行してみること。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:165
msgid "The I<flags> argument has an invalid value."
msgstr "I<flags> 引数に不正な値が与えられた。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:168
msgid "A nonrecoverable error occurred."
msgstr "回復できないエラーが発生した。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:172
msgid ""
"The address family was not recognized, or the address length was invalid for "
"the specified family."
msgstr ""
"指定したアドレスファミリーが認識できなかった。 あるいはアドレスの長さが指定さ"
"れたファミリーに合うものでなかった。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:181
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set "
"and the host's name cannot be located, or neither hostname nor service name "
"were requested."
msgstr ""
"与えられたパラメーターでは名前が解決できない。 B<NI_NAMEREQD> が設定されてい"
"たがホスト名が決定できなかったか、 ホスト名もサービス名も要求されなかった。"

#. type: TP
#: build/C/man3/getnameinfo.3:181
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr "B<EAI_OVERFLOW>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:188
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr "I<host> または I<serv> が指しているバッファーが小さすぎた。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:193
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr "システムエラーが起った。 エラーコードは I<errno> に設定される。"

#. type: TP
#: build/C/man3/getnameinfo.3:204 build/C/man5/host.conf.5:120
#: build/C/man3/resolver.3:479
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr "I</etc/resolv.conf>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:207
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr "B<getnameinfo>()  は、glibc バージョン 2.1 以降で提供されている。"

#. type: tbl table
#: build/C/man3/getnameinfo.3:217
#, no-wrap
msgid "B<getnameinfo>()"
msgstr "B<getnameinfo>()"

#. type: Plain text
#: build/C/man3/getnameinfo.3:222
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."
msgstr "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."

#. type: Plain text
#: build/C/man3/getnameinfo.3:227
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""
"適切なバッファーサイズを選択できるように、 I<E<lt>netdb.hE<gt>> に以下の定数"
"が定義されている。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:232
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:245
#, fuzzy
#| msgid ""
#| "Since glibc 2.8, these definitions are exposed only if one of the feature "
#| "test macros B<_BSD_SOURCE>, B<_SVID_SOURCE>, or B<_GNU_SOURCE> is defined."
msgid ""
"Since glibc 2.8, these definitions are exposed only if suitable feature test "
"macros are defined, namely: B<_GNU_SOURCE>, B<_DEFAULT_SOURCE> (since glibc "
"2.19), or (in glibc versions up to and including 2.19)  B<_BSD_SOURCE> or "
"B<_SVID_SOURCE>."
msgstr ""
"glibc 2.8 以降では、機能検査マクロ B<_BSD_SOURCE>, B<_SVID_SOURCE>, "
"B<_GNU_SOURCE> のいずれかが定義された場合にのみ、これらの定義が公開される。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:253
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the "
"services listed in the current Assigned Numbers RFC."
msgstr ""
"前者は、最近のバージョンの BIND のヘッダーファイル I<E<lt>arpa/nameser."
"hE<gt>> 中の定数 B<MAXDNAME> と同じ値である。 後者は、割り当て済の数値につい"
"て記した現在の RFC に 列挙されてサービスから推量した値である。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:260
msgid ""
"Before glibc version 2.2, the I<hostlen> and I<servlen> arguments were typed "
"as I<size_t>."
msgstr ""
"glibc バージョン 2.2 より前では、 引数 I<hostlen>, I<servlen> の型は "
"I<size_t> であった。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:265
msgid ""
"The following code tries to get the numeric hostname and service name, for a "
"given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""
"以下のコードは、指定されたソケットアドレスに対する ホストとサービスの数値表式"
"を取得しようと試みる。 特定のアドレスファミリーに対する参照情報は 一切ハード"
"コードされていないことに着目してほしい。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:271
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:275
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:280
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""
"以下ではソケットアドレスに 逆向きのアドレスマッピングが存在するかをチェックし"
"ている。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:286
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:292
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"

#. type: Plain text
#: build/C/man3/getnameinfo.3:299
msgid ""
"An example program using B<getnameinfo>()  can be found in B<getaddrinfo>(3)."
msgstr ""
"B<getnameinfo>()  を使ったプログラム例が B<getaddrinfo>(3)  に記載されてい"
"る。"

#. type: Plain text
#: build/C/man3/getnameinfo.3:314
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"

#. type: Plain text
#: build/C/man3/getnameinfo.3:318
msgid ""
"R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket "
"Interface Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr "R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket Interface Extensions for IPv6>, RFC\\ 2553, March 1999."

#. type: Plain text
#: build/C/man3/getnameinfo.3:324
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org\\:/"
"internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"
msgstr ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org\\:/"
"internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"

#. type: Plain text
#: build/C/man3/getnameinfo.3:329
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"

#. type: Plain text
#: build/C/man3/getnameinfo.3:332
msgid ""
"E<.UR http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/"
"usenix2000\\:/freenix\\:/metzprotocol.html> E<.UE .>"
msgstr ""
"E<.UR http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/"
"usenix2000\\:/freenix\\:/metzprotocol.html> E<.UE .>"

#. type: TH
#: build/C/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr "GETNETENT"

#. type: Plain text
#: build/C/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - ネットワークエ"
"ントリーを取得する"

#. type: Plain text
#: build/C/man3/getnetent.3:37 build/C/man3/getnetent_r.3:33
#: build/C/man3/getprotoent.3:37 build/C/man3/getprotoent_r.3:33
#: build/C/man3/getservent.3:41 build/C/man3/getservent_r.3:33
#: build/C/man3/rexec.3:47 build/C/man3/setnetgrent.3:17
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr "B<struct netent *getnetent(void);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr "B<void setnetent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr "B<void endnetent(void);>\n"

#. type: Plain text
#: build/C/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database "
"and returns a I<netent> structure containing the broken-out fields from the "
"entry.  A connection is opened to the database if necessary."
msgstr ""
"B<getnetent>()  関数はネットワークデータベースから次のエントリーを読み込み、 "
"そのエントリーを I<netent> 構造体の要素別のフィールドに格納し、 その構造体を"
"返す。 必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr ""
"B<getnetbyname>()  関数は、ネットワーク名 I<name> にマッチするエントリーを "
"データベースから探し、そのエントリーを収めた I<netent> 構造体を返す。"

#. type: Plain text
#: build/C/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr ""
"B<getnetbyaddr>()  関数は、I<type> 型のネットワーク番号 I<net> にマッチするエ"
"ントリーを データベースから探し、そのエントリーを収めた I<netent> 構造体を返"
"す。 I<net> 引数はホストバイトオーダでなければならない。"

#. type: Plain text
#: build/C/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr ""
"B<setnetent>()  関数はデータベースへの接続をオープンし、 次の読み込みエント"
"リーを先頭のエントリーに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getnet*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr "B<endnetent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "I<netent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr "I<netent> 構造体のメンバは以下の通り。"

#. type: TP
#: build/C/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr "I<n_name>"

#. type: Plain text
#: build/C/man3/getnetent.3:120
msgid "The official name of the network."
msgstr "ネットワークの正式名 (official name)。"

#. type: TP
#: build/C/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr "I<n_aliases>"

#. type: Plain text
#: build/C/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr "ネットワークの別名からなるリスト。 リストはヌルで終端される。"

#. type: TP
#: build/C/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr "I<n_addrtype>"

#. type: Plain text
#: build/C/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr "ネットワーク番号の形式。現在は B<AF_INET> のみ。"

#. type: TP
#: build/C/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr "I<n_net>"

#. type: Plain text
#: build/C/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr "ホストバイトオーダ形式のネットワーク番号。"

#. type: Plain text
#: build/C/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>(), and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a null "
"pointer if an error occurs or the end of the file is reached."
msgstr ""
"B<getnetent>(), B<getnetbyname>(), B<getnetbyaddr>()  関数は、静的に割り当て"
"られた I<netent> 構造体へのポインターを返す。 エラーが起こったり、ファイルの"
"末尾に達した場合はヌルポインターを返す。"

#. type: Plain text
#: build/C/man3/getnetent.3:142 build/C/man5/networks.5:71
#: build/C/man5/nsswitch.conf.5:393
#, no-wrap
msgid "I</etc/networks>"
msgstr "I</etc/networks>"

#. type: Plain text
#: build/C/man3/getnetent.3:145
msgid "networks database file"
msgstr "ネットワークデータベースファイル"

#. type: tbl table
#: build/C/man3/getnetent.3:155
#, no-wrap
msgid "B<getnetent>()"
msgstr "B<getnetent>()"

#. type: tbl table
#: build/C/man3/getnetent.3:157
#, no-wrap
msgid "MT-Unsafe race:netent\n"
msgstr "MT-Unsafe race:netent\n"

#. type: tbl table
#: build/C/man3/getnetent.3:159
#, no-wrap
msgid "race:netentbuf env locale"
msgstr "race:netentbuf env locale"

#. type: tbl table
#: build/C/man3/getnetent.3:162
#, no-wrap
msgid "B<getnetbyname>()"
msgstr "B<getnetbyname>()"

#. type: tbl table
#: build/C/man3/getnetent.3:164
#, no-wrap
msgid "MT-Unsafe race:netbyname\n"
msgstr "MT-Unsafe race:netbyname\n"

#. type: tbl table
#: build/C/man3/getnetent.3:169
#, no-wrap
msgid "B<getnetbyaddr>()"
msgstr "B<getnetbyaddr>()"

#. type: tbl table
#: build/C/man3/getnetent.3:171
#, no-wrap
msgid "MT-Unsafe race:netbyaddr\n"
msgstr "MT-Unsafe race:netbyaddr\n"

#. type: tbl table
#: build/C/man3/getnetent.3:176
#, no-wrap
msgid "B<setnetent>(),\n"
msgstr "B<setnetent>(),\n"

#. type: tbl table
#: build/C/man3/getnetent.3:178
#, no-wrap
msgid "B<endnetent>()"
msgstr "B<endnetent>()"

#. type: tbl table
#: build/C/man3/getnetent.3:180
#, no-wrap
msgid "MT-Unsafe race:netent env\n"
msgstr "MT-Unsafe race:netent env\n"

#. type: Plain text
#: build/C/man3/getnetent.3:196
msgid ""
"In the above table, I<netent> in I<race:netent> signifies that if any of the "
"functions B<setnetent>(), B<getnetent>(), or B<endnetent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:198 build/C/man3/getprotoent.3:193
#: build/C/man3/getservent.3:210
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: build/C/man3/getnetent.3:205
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr ""
"バージョン 2.2 より前の glibc では、 B<getnetbyaddr>()  の引数 I<net> は "
"I<long> 型だった。"

#.  .BR networks (5)
#. type: Plain text
#: build/C/man3/getnetent.3:210
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"

#. type: Plain text
#: build/C/man3/getnetent.3:212
msgid "RFC\\ 1101"
msgstr "RFC\\ 1101"

#. type: TH
#: build/C/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr "GETNETENT_R"

#. type: Plain text
#: build/C/man3/getnetent_r.3:30
msgid ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - ネットワークエントリーを\n"
"取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: build/C/man3/getnetent_r.3:62
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:80
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""
"関数 B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>() は、\n"
"それぞれ B<getnetent>(3), B<getnetbyname>(3), B<getnetbynumber>(3) の\n"
"リエントラント版である。\n"
"I<netent> 構造体の返し方と、関数呼び出し時の引数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:86
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure "
"as the function result, these functions copy the structure into the location "
"pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<netent> 構造体\n"
"へのポインターを返すのではなく、 I<netent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getnetent_r.3:103
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<netent> 構造体が指す文字列フィールドを格納\n"
"するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファーで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファーで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:111
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでネットワークレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: build/C/man3/getnetent_r.3:119
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""
"I<h_errnop> が指すバッファーは、リエントラントでない関数では\n"
"グローバル変数 I<h_errno> に格納されていた値を返すのに使用される。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:122 build/C/man3/getprotoent_r.3:112
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""
"成功すると、これらの関数は 0 を返す。エラーの場合、「エラー」の節の\n"
"リストにある正のエラー番号のいずれかを返す。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:130
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()) やこれ以上レコードがない場合 (B<getnetent_r>())、\n"
"I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:135
msgid "(B<getnetent_r>())  No more records in database."
msgstr "(B<getnetent_r>())  データベースにこれ以上レコードがない。"

#. type: TP
#: build/C/man3/getnetent_r.3:135 build/C/man3/getprotoent_r.3:125
#: build/C/man3/getservent_r.3:124
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/getnetent_r.3:142 build/C/man3/getprotoent_r.3:132
#: build/C/man3/getservent_r.3:131
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""
"I<buf> が小さすぎる。もっと大きなバッファーにして \n"
"(または I<buflen> を増やして) 再度呼び出すこと。"

#. type: tbl table
#: build/C/man3/getnetent_r.3:155
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()"
msgstr ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()"

#. type: tbl table
#: build/C/man3/getnetent_r.3:155 build/C/man3/getprotoent_r.3:146
#: build/C/man3/getservent_r.3:144 build/C/man3/inet.3:237
#: build/C/man3/inet_ntop.3:110 build/C/man3/inet_pton.3:141
#: build/C/man3/rcmd.3:294 build/C/man3/resolver.3:501
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: build/C/man3/getnetent_r.3:162 build/C/man3/getprotoent_r.3:153
#: build/C/man3/getservent_r.3:151
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""
"これらの関数は GNU による拡張である。\n"
"他のシステムにも同様の名前の関数が存在する場合があるが、\n"
"通常は関数の引数が異なる。"

#. type: Plain text
#: build/C/man3/getnetent_r.3:165
msgid "B<getnetent>(3), B<networks>(5)"
msgstr "B<getnetent>(3), B<networks>(5)"

#. type: TH
#: build/C/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr "GETPEERNAME"

#. type: Plain text
#: build/C/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr "getpeername - 接続している相手ソケットの名前を取得する"

#. type: Plain text
#: build/C/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"

#. type: Plain text
#: build/C/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by "
"I<addr>.  On return it contains the actual size of the name returned (in "
"bytes).  The name is truncated if the buffer provided is too small."
msgstr ""
"B<getpeername>()  は、ソケット(socket)  I<sockfd> に接続している相手のアドレ"
"スを、 I<addr> が指すバッファーに格納して返す。 I<addrlen> 引数は、 "
"I<addr> が指している領域のサイズに初期化しておかなければならない。 関数が返る"
"時には、 I<addrlen> には実際に返された名前のサイズが (バイト単位で) 格納され"
"る。 提供されたバッファーが小さすぎた場合には、名前は切り詰められる。"

#. type: Plain text
#: build/C/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""
"渡されたバッファーが小さ過ぎた場合は、返されるアドレスの末尾が切り詰められ"
"る。 この場合には、 I<addrlen> には、呼び出し時に指定された値よりも大きな値が"
"格納される。"

#. type: Plain text
#: build/C/man2/getpeername.2:73 build/C/man2/shutdown.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: TP
#: build/C/man2/getpeername.2:74 build/C/man2/shutdown.2:75
#: build/C/man7/unix.7:688
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr "引数 I<sockfd> が有効なファイルディスクリプターでない。"

#. type: TP
#: build/C/man2/getpeername.2:79 build/C/man7/packet.7:516
#: build/C/man7/raw.7:154 build/C/man7/unix.7:706
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""
"I<addr> 引数の指しているメモリーが有効なプロセスのアドレス空間の 一部でな"
"い。"

#. type: Plain text
#: build/C/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "I<addrlen> が不正である (例えば、負で場合など)。"

#. type: TP
#: build/C/man2/getpeername.2:89 build/C/man7/packet.7:528
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: build/C/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the operation."
msgstr "この操作を行なうのに十分な資源がシステムに存在しない。"

#. type: Plain text
#: build/C/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr "ソケットが接続していない。"

#. type: TP
#: build/C/man2/getpeername.2:96 build/C/man2/shutdown.2:87
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: build/C/man2/getpeername.2:101 build/C/man2/shutdown.2:92
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr "ファイルディスクリプター I<sockfd> がソケットを参照していない。"

#. type: Plain text
#: build/C/man2/getpeername.2:105
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  関数コールは 4.2BSD で初めて登場した)。"

#. type: Plain text
#: build/C/man2/getpeername.2:110
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:137
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the "
"other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on "
"a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr ""
"ストリームソケットでは、 いったん B<connect>(2) が実行されると、 どのソケット"
"も B<getpeername>() を使って相手ソケットのアドレスを取得できる。 一方、データ"
"グラムソケットはコネクションレスである (接続がない)。 データグラムソケットに"
"対する B<connect>(2) の呼び出しは、 B<write>(2) や B<recv>(2) で送信される出"
"力データグラムの相手アドレスを設定するだけである。\n"
"B<connect>(2) の呼び出し元は、 B<getpeername>() を使って、それ以前にそのソ"
"ケットに設定された相手アドレスを取得することができる。 しかし、相手ソケットは"
"この情報を知らないので、 相手ソケットで B<getpeername>() を呼び出しても、 役"
"に立つ情報は得られない (相手側でも B<connect>(2) が呼び出されている場合を除"
"く)。 なお、データグラムの受信側では B<recvfrom>(2) を使って送信元アドレスを "
"取得できることも覚えておいてほしい。"

#. type: Plain text
#: build/C/man2/getpeername.2:144
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"

#. type: TH
#: build/C/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr "GETPROTOENT"

#. type: Plain text
#: build/C/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - プ"
"ロトコルのエントリーを取得する"

#. type: Plain text
#: build/C/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr "B<struct protoent *getprotoent(void);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr "B<void setprotoent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr "B<void endprotoent(void);>\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""
"B<getprotoent>()  関数は、プロトコルのデータベース (B<protocols>(5)  参照) か"
"ら次のエントリーを読み込み、 そのエントリーを I<protoent> 構造体の要素別の"
"フィールドに格納し、 その構造体を返す。 必要であれば、データベースへの接続が"
"オープンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""
"B<getprotobyname>()  関数は、プロトコル名 I<name> にマッチするエントリーを "
"データベースから探し、そのエントリーを収めた I<protoent> 構造体を返す。 必要"
"であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""
"B<getprotobynumber>()  関数は、プロトコル番号 I<number> にマッチするエント"
"リーを データベースから探し、そのエントリーを収めた I<protoent> 構造体を返"
"す。 必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""
"B<setprotoent>()  関数はデータベースへの接続をオープンし、 次の読み込みエント"
"リーを先頭のエントリーに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getproto*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr "B<endprotoent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getprotoent.3:100
msgid ""
"The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""
"I<protoent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr "I<protoent> 構造体のメンバーは以下の通り。"

#. type: TP
#: build/C/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr "I<p_name>"

#. type: Plain text
#: build/C/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr "プロトコルの正式名 (official name)。"

#. type: TP
#: build/C/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr "I<p_aliases>"

#. type: Plain text
#: build/C/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr "プロトコルの別名のリスト。 リストはヌルで終端される。"

#. type: TP
#: build/C/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr "I<p_proto>"

#. type: Plain text
#: build/C/man3/getprotoent.3:123
msgid "The protocol number."
msgstr "プロトコルの番号"

#. type: Plain text
#: build/C/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>(), and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a null pointer if an error occurs or the end of the file is reached."
msgstr ""
"B<getprotoent>(), B<getprotobyname>(), B<getprotobynumber>()  関数は、静的に"
"割り当てられた I<protoent> 構造体へのポインターを返す。 エラーが起こったり、"
"ファイルの最後に達した場合は NULL を返す。"

#. type: TP
#: build/C/man3/getprotoent.3:136 build/C/man5/nsswitch.conf.5:399
#: build/C/man5/protocols.5:78
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: build/C/man3/getprotoent.3:139
msgid "protocol database file"
msgstr "プロトコルのデータベースファイル"

#. type: tbl table
#: build/C/man3/getprotoent.3:150
#, no-wrap
msgid "B<getprotoent>()"
msgstr "B<getprotoent>()"

#. type: tbl table
#: build/C/man3/getprotoent.3:152 build/C/man3/getprotoent.3:175
#, no-wrap
msgid "MT-Unsafe race:protoent\n"
msgstr "MT-Unsafe race:protoent\n"

#. type: tbl table
#: build/C/man3/getprotoent.3:154
#, no-wrap
msgid "race:protoentbuf locale"
msgstr "race:protoentbuf locale"

#. type: tbl table
#: build/C/man3/getprotoent.3:157
#, no-wrap
msgid "B<getprotobyname>()"
msgstr "B<getprotobyname>()"

#. type: tbl table
#: build/C/man3/getprotoent.3:159
#, no-wrap
msgid "MT-Unsafe race:protobyname\n"
msgstr "MT-Unsafe race:protobyname\n"

#. type: tbl table
#: build/C/man3/getprotoent.3:164
#, no-wrap
msgid "B<getprotobynumber>()"
msgstr "B<getprotobynumber>()"

#. type: tbl table
#: build/C/man3/getprotoent.3:166
#, no-wrap
msgid "MT-Unsafe race:protobynumber\n"
msgstr "MT-Unsafe race:protobynumber\n"

#. type: tbl table
#: build/C/man3/getprotoent.3:171
#, no-wrap
msgid "B<setprotoent>(),\n"
msgstr "B<setprotoent>(),\n"

#. type: tbl table
#: build/C/man3/getprotoent.3:173
#, no-wrap
msgid "B<endprotoent>()"
msgstr "B<endprotoent>()"

#. type: Plain text
#: build/C/man3/getprotoent.3:191
msgid ""
"In the above table, I<protoent> in I<race:protoent> signifies that if any of "
"the functions B<setprotoent>(), B<getprotoent>(), or B<endprotoent>()  are "
"used in parallel in different threads of a program, then data races could "
"occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:198
msgid "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr ""
"B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"

#. type: TH
#: build/C/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr "GETPROTOENT_R"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - プロトコル\n"
"エントリーを取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:59
#, no-wrap
msgid ""
"B<getprotoent_r>(),\n"
"B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:77
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3), "
"B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences "
"from the nonreentrant functions."
msgstr ""
"関数 B<getprotoent_r>(), B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>() は、それぞれ B<getprotoent>(3),\n"
"B<getprotobyname>(3), B<getprotobynumber>(3) のリエントラント版である。\n"
"I<protoent> 構造体の返し方と、関数呼び出し時の引数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<protoent> 構造体\n"
"へのポインターを返すのではなく、 I<protoent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: build/C/man3/getprotoent_r.3:101
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<protoent> 構造体が指す文字列フィールドを\n"
"格納するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファーで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファーで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:109
msgid ""
"If the function call successfully obtains a protocol record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでプロトコルレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:120
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()), "
"or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getprotobyname_r>(),\n"
"B<getprotobyaddr_r>()) やこれ以上レコードがない場合\n"
"(B<getprotoent_r>())、I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:125
msgid "(B<getprotoent_r>())  No more records in database."
msgstr "(B<getprotoent_r>())  データベースにこれ以上レコードがない。"

#. type: tbl table
#: build/C/man3/getprotoent_r.3:142
#, no-wrap
msgid "B<getprotoent_r>(),\n"
msgstr "B<getprotoent_r>(),\n"

#. type: tbl table
#: build/C/man3/getprotoent_r.3:144
#, no-wrap
msgid "B<getprotobyname_r>(),\n"
msgstr "B<getprotobyname_r>(),\n"

#. type: tbl table
#: build/C/man3/getprotoent_r.3:146
#, no-wrap
msgid "B<getprotobynumber_r>()"
msgstr "B<getprotobynumber_r>()"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:167
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""
"以下のプログラムは、 B<getprotobyname_r>() を使って、最初のコマンド\n"
"ライン引数で指定された名前のプロトコルのレコードを取得する。\n"
"二番目のコマンドライン引数 (整数値) が指定された場合は、\n"
"その値が I<buflen> の初期値として使用される。\n"
"B<getprotobyname_r>() がエラー B<ERANGE> で失敗すると、プログラムは\n"
"より大きなバッファーサイズで再度 B<getprotobyname_r> を呼び出す。\n"
"下記のシェルのセッションは、実行例を示している。"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:178
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:190 build/C/man3/getservent_r.3:187
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:192 build/C/man3/getservent_r.3:189
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr "#define MAX_BUF 10000\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:200
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:205
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:209
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:214 build/C/man3/getservent_r.3:216
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:223
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:226 build/C/man3/getservent_r.3:228
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:228 build/C/man3/getservent_r.3:230
#, no-wrap
msgid "            buflen++;\n"
msgstr "            buflen++;\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:235 build/C/man3/getservent_r.3:237
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:239
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:244 build/C/man3/getservent_r.3:246
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:250
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (char **p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (char **p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/getprotoent_r.3:257
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr "B<getprotoent>(3), B<protocols>(5)"

#. type: TH
#: build/C/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr "GETSERVENT"

#. type: Plain text
#: build/C/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""
"getservent, getservbyname, getservbyport, setservent, endservent - サービスの"
"エントリーを取得する"

#. type: Plain text
#: build/C/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr "B<struct servent *getservent(void);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:45
#, no-wrap
msgid "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:47
#, no-wrap
msgid "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr "B<void setservent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr "B<void endservent(void);>\n"

#. type: Plain text
#: build/C/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing "
"the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""
"B<getservent>()  関数はサービスのデータベース (B<services>(5)  参照) から次の"
"エントリーを読み込み、 そのエントリーを I<servent> 構造体の要素別のフィールド"
"に格納し、 その構造体を返す。 必要であれば、データベースへの接続がオープンさ"
"れる。"

#. type: Plain text
#: build/C/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""
"B<getservbyname>()  関数は、 プロトコル I<proto> を用いるサービスの名前 "
"I<name> にマッチするエントリーをデータベースから探し、 そのエントリーを収め"
"た I<servent> 構造体を返す。 I<proto> が NULL の場合は、任意のプロトコルに"
"マッチする。 必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte "
"order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be "
"matched.  A connection is opened to the database if necessary."
msgstr ""
"B<getservbyport>()  関数は、 プロトコル I<proto> を用いるサービスのポート番"
"号 I<port> にマッチするエントリーをデータベースから探し、 そのエントリーの内"
"容を収めた I<servent> 構造体を返す (ポート番号 I<port> はネットワークバイト"
"オーダで指定する)。 I<proto> が NULL の場合は任意のプロトコルにマッチする。 "
"必要であれば、データベースへの接続がオープンされる。"

#. type: Plain text
#: build/C/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""
"B<setservent>()  関数はデータベースへの接続をオープンし、 次の読み込みエント"
"リーを先頭のエントリーに設定する。 I<stayopen> が 0 でない場合、 一つ一つの "
"B<getserv*>()  関数の呼び出し間でデータベースへの接続をクローズしない。"

#. type: Plain text
#: build/C/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr "B<endservent>()  関数はデータベースへの接続をクローズする。"

#. type: Plain text
#: build/C/man3/getservent.3:115
msgid "The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""
"I<servent> 構造体は I<E<lt>netdb.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"

#. type: Plain text
#: build/C/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr "I<servent> 構造体のメンバーは以下の通り。"

#. type: TP
#: build/C/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr "I<s_name>"

#. type: Plain text
#: build/C/man3/getservent.3:133
msgid "The official name of the service."
msgstr "サービスの正式名 (official name)。"

#. type: TP
#: build/C/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr "I<s_aliases>"

#. type: Plain text
#: build/C/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr "サービスの別名のリスト。 リストはヌルで終端される。"

#. type: TP
#: build/C/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr "I<s_port>"

#. type: Plain text
#: build/C/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr "サービスのポート番号。ネットワークバイトオーダで指定される。"

#. type: TP
#: build/C/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr "I<s_proto>"

#. type: Plain text
#: build/C/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr "このサービスと共に用いるプロトコルの名前。"

#. type: Plain text
#: build/C/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>(), and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or NULL if "
"an error occurs or the end of the file is reached."
msgstr ""
"B<getservent>(), B<getservbyname>(), B<getservbyport>()  関数は、 静的に割り"
"当てられた I<servent> 構造体へのポインターを返す。 エラーが起こったり、ファイ"
"ルの末尾に達した場合は NULL を返す。"

#. type: TP
#: build/C/man3/getservent.3:154 build/C/man5/nsswitch.conf.5:408
#: build/C/man5/services.5:184
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: build/C/man3/getservent.3:157
msgid "services database file"
msgstr "サービスのデータベースファイル"

#. type: tbl table
#: build/C/man3/getservent.3:167
#, no-wrap
msgid "B<getservent>()"
msgstr "B<getservent>()"

#. type: tbl table
#: build/C/man3/getservent.3:169 build/C/man3/getservent.3:192
#, no-wrap
msgid "MT-Unsafe race:servent\n"
msgstr "MT-Unsafe race:servent\n"

#. type: tbl table
#: build/C/man3/getservent.3:171
#, no-wrap
msgid "race:serventbuf locale"
msgstr "race:serventbuf locale"

#. type: tbl table
#: build/C/man3/getservent.3:174
#, no-wrap
msgid "B<getservbyname>()"
msgstr "B<getservbyname>()"

#. type: tbl table
#: build/C/man3/getservent.3:176
#, no-wrap
msgid "MT-Unsafe race:servbyname\n"
msgstr "MT-Unsafe race:servbyname\n"

#. type: tbl table
#: build/C/man3/getservent.3:181
#, no-wrap
msgid "B<getservbyport>()"
msgstr "B<getservbyport>()"

#. type: tbl table
#: build/C/man3/getservent.3:183
#, no-wrap
msgid "MT-Unsafe race:servbyport\n"
msgstr "MT-Unsafe race:servbyport\n"

#. type: tbl table
#: build/C/man3/getservent.3:188
#, no-wrap
msgid "B<setservent>(),\n"
msgstr "B<setservent>(),\n"

#. type: tbl table
#: build/C/man3/getservent.3:190
#, no-wrap
msgid "B<endservent>()"
msgstr "B<endservent>()"

#. type: Plain text
#: build/C/man3/getservent.3:208
msgid ""
"In the above table, I<servent> in I<race:servent> signifies that if any of "
"the functions B<setservent>(), B<getservent>(), or B<endservent>()  are used "
"in parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:215
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"

#. type: TH
#: build/C/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr "GETSERVENT_R"

#. type: Plain text
#: build/C/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""
"getservent_r, getservbyname_r, getservbyport_r - サービスエントリーを\n"
"取得する (リエントラント版)"

#. type: Plain text
#: build/C/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:59
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:77
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""
"関数 B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>() は、\n"
"それぞれ B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3) の\n"
"リエントラント版である。\n"
"I<servent> 構造体の返し方と、関数呼び出し時の引数と返り値が異なる。\n"
"このマニュアルページでは、リエントラントでない関数との違いだけを\n"
"説明する。"

#. type: Plain text
#: build/C/man3/getservent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""
"これらの関数は、関数の結果として静的に割り当てられた I<servent> 構造体\n"
"へのポインターを返すのではなく、 I<servent> 構造体を I<result_buf> が\n"
"指す場所にコピーする。"

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getservent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""
"配列 I<buf> は、返される I<servent> 構造体が指す文字列フィールドを\n"
"格納するのに使用される (リエントラントでない関数の場合は、\n"
"これらの文字列は静的な領域に格納される)。\n"
"この配列の大きさは I<buflen> で指定される。\n"
"I<buf> が小さすぎる場合、関数呼び出しはエラー B<ERANGE> で失敗し、\n"
"呼び出し側ではもっと大きなバッファーで再度呼び出す必要がある (ほとんどの\n"
"アプリケーションでは、長さ 1024 バイトのバッファーで十分なはずである)。"

#. type: Plain text
#: build/C/man3/getservent_r.3:108
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""
"関数呼び出しでサービスレコードの取得に成功すると、\n"
"I<*result> は I<result_buf> を指すように設定される。\n"
"それ以外の場合は I<*result> に NULL が設定される。"

#. type: Plain text
#: build/C/man3/getservent_r.3:111
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""
"成功すると、これらの関数は 0 を返す。エラーの場合、「エラー」の節の\n"
"リストにある正のエラー番号のいずれかを返す。"

#. type: Plain text
#: build/C/man3/getservent_r.3:119
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""
"エラーの場合、レコードが見つからなかった場合 (B<getservbyname_r>(),\n"
"B<getservbyaddr_r>()) やこれ以上レコードがない場合 (B<getservent_r>())、\n"
"I<result> には NULL が設定される。"

#. type: Plain text
#: build/C/man3/getservent_r.3:124
msgid "(B<getservent_r>())  No more records in database."
msgstr "(B<getservent_r>())  データベースにこれ以上レコードがない。"

#. type: tbl table
#: build/C/man3/getservent_r.3:144
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>()"
msgstr ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>()"

#. type: Plain text
#: build/C/man3/getservent_r.3:165
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial "
"value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""
"以下のプログラムは、 B<getservbyport_r>() を使って、コマンド\n"
"ライン引数で指定されたポート番号とプロトコル名を持つ\n"
"サービスレコードを取得する。\n"
"三番目のコマンドライン引数 (整数値) が指定された場合は、\n"
"その値が I<buflen> の初期値として使用される。\n"
"B<getservbyport_r>() がエラー B<ERANGE> で失敗すると、プログラムは\n"
"より大きなバッファーサイズで再度 B<getservbyport_r> を呼び出す。\n"
"下記のシェルのセッションは実行例を示している。"

#. type: Plain text
#: build/C/man3/getservent_r.3:175
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:198
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:203
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:207
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:211
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:225
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:241
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:253
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (char **p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (char **p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/getservent_r.3:260
msgid "B<getservent>(3), B<services>(5)"
msgstr "B<getservent>(3), B<services>(5)"

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "HOST.CONF"
msgstr "HOST.CONF"

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: build/C/man5/host.conf.5:26 build/C/man5/networks.5:26
#, no-wrap
msgid "Linux System Administration"
msgstr "Linux System Administration"

#. type: Plain text
#: build/C/man5/host.conf.5:29
msgid "host.conf - resolver configuration file"
msgstr "host.conf - レゾルバ設定ファイル"

#. type: Plain text
#: build/C/man5/host.conf.5:36
msgid ""
"The file I</etc/host.conf> contains configuration information specific to "
"the resolver library.  It should contain one configuration keyword per line, "
"followed by appropriate configuration information.  The following keywords "
"are recognized:"
msgstr "ファイル I</etc/host.conf> には、レゾルバライブラリの詳細な設定情報が含まれている。 このファイルには、1 行毎に 1 つの設定キーワードと それに続く適切な設定情報がなければならない。以下のキーワードが認識される。"

#. type: TP
#: build/C/man5/host.conf.5:36
#, no-wrap
msgid "I<trim>"
msgstr "I<trim>"

#. type: Plain text
#: build/C/man5/host.conf.5:56
msgid ""
"This keyword may be listed more than once.  Each time it should be followed "
"by a list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot.  When set, the "
"resolver library will automatically trim the given domain name from the end "
"of any hostname resolved via DNS.  This is intended for use with local hosts "
"and domains.  (Related note: I<trim> will not affect hostnames gathered via "
"NIS or the B<hosts>(5)  file.  Care should be taken to ensure that the first "
"hostname for each entry in the hosts file is fully qualified or unqualified, "
"as appropriate for the local installation.)"
msgstr "このキーワードは、2 回以上リストすることができる。 毎回、このキーワードの後には、 ドットではじまる 1 つ以上のドメイン名のリストを続けなければならない。 ドメイン名はコロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,\\(aq)  で区切る。 このキーワードが設定されると、レゾルバライブラリは DNS でレゾルブされた すべてのホスト名の後ろから与えられたドメイン名を自動的に取り去る。 このキーワードはローカルなホストとドメインで使用することを意図している。 (関連した注意 : NIS または B<hosts>(5) ファイルで集められたホスト名に I<trim> は影響しない。 hosts ファイルの各エントリーの最初のホスト名を、 完全なドメイン名付きのものにするかしないかは、 ホストごとのインストールポリシーにあわせて 適切に選択する必要がある。注意すること。)"

#. type: TP
#: build/C/man5/host.conf.5:56
#, no-wrap
msgid "I<multi>"
msgstr "I<multi>"

#. type: Plain text
#: build/C/man5/host.conf.5:71
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will return all valid addresses for a host that appears in the I</etc/hosts> "
"file, instead of only the first.  This is I<off> by default, as it may cause "
"a substantial performance loss at sites with large hosts files."
msgstr "有効な値は I<on> と I<off> である。 I<on> に設定された場合、最初のエントリーのみを例外として、 レゾルバライブラリは I</etc/hosts> ファイルに現れるホストに対して全ての有効なアドレスを返そうとする。 大きな hosts ファイルを持つサイトでは、 この設定は非常な性能の低下を招くので、 デフォルトでは I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:71
#, no-wrap
msgid "I<reorder>"
msgstr "I<reorder>"

#. type: Plain text
#: build/C/man5/host.conf.5:85
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will attempt to reorder host addresses so that local addresses (i.e., on the "
"same subnet) are listed first when a B<gethostbyname>(3)  is performed.  "
"Reordering is done for all lookup methods.  The default value is I<off>."
msgstr "有効な値は I<on> と I<off> である。 I<on> に設定されると、 B<gethostbyname (3)> が実行されるとき、レゾルバライブラリは、ローカルな (つまり、同じサブネットにある) アドレスが最初にリストされるように ホストアドレスを並べ変える。 すべてのルックアップ方式に対して並べ変えが行われる。 デフォルトの値は、 I<off> である。"

#. type: SH
#: build/C/man5/host.conf.5:85
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man5/host.conf.5:89
msgid ""
"The following environment variables can be used to allow users to override "
"the behavior which is configured in I</etc/host.conf>:"
msgstr "以下の環境変数を使って、ユーザーは I</etc/host.conf> で設定されている動作を上書きできる。"

#. type: TP
#: build/C/man5/host.conf.5:89
#, no-wrap
msgid "B<RESOLV_HOST_CONF>"
msgstr "B<RESOLV_HOST_CONF>"

#. type: Plain text
#: build/C/man5/host.conf.5:93
msgid ""
"If set, this variable points to a file that should be read instead of I</etc/"
"host.conf>."
msgstr ""
"この変数を設定すると、 I</etc/host.conf> の代りに読み込むファイルを設定でき"
"る。"

#. type: TP
#: build/C/man5/host.conf.5:93
#, no-wrap
msgid "B<RESOLV_MULTI>"
msgstr "B<RESOLV_MULTI>"

#. type: Plain text
#: build/C/man5/host.conf.5:98
msgid "Overrides the I<multi> command."
msgstr "I<multi> コマンドを上書きする。"

#. type: TP
#: build/C/man5/host.conf.5:98
#, no-wrap
msgid "B<RESOLV_REORDER>"
msgstr "B<RESOLV_REORDER>"

#. type: Plain text
#: build/C/man5/host.conf.5:103
msgid "Overrides the I<reorder> command."
msgstr "I<reorder> コマンドを上書きする。"

#. type: TP
#: build/C/man5/host.conf.5:103
#, no-wrap
msgid "B<RESOLV_ADD_TRIM_DOMAINS>"
msgstr "B<RESOLV_ADD_TRIM_DOMAINS>"

#. type: Plain text
#: build/C/man5/host.conf.5:108
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will be added to "
"the list of domains that should be trimmed."
msgstr ""
"コロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,\\(aq) で区切っ"
"た ドット (\\(aq.\\(aq) で始まるドメイン名のリスト。 ホスト名から取り去るドメ"
"イン名のリストに追加する。"

#. type: TP
#: build/C/man5/host.conf.5:108
#, no-wrap
msgid "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"
msgstr "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"

#. type: Plain text
#: build/C/man5/host.conf.5:116
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons (\\(aq;"
"\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will replace the "
"list of domains that should be trimmed.  Overrides the I<trim> command."
msgstr ""
"コロン (\\(aq:\\(aq)、セミコロン (\\(aq;\\(aq)、コンマ (\\(aq,\\(aq) で区切っ"
"た ドット (\\(aq.\\(aq) で始まるドメイン名のリスト。 ホスト名から取り去るドメ"
"イン名のリストを上書きする。 I<trim> コマンドを上書きする。"

#. type: Plain text
#: build/C/man5/host.conf.5:120 build/C/man5/host.conf.5:123
msgid "Resolver configuration file"
msgstr "リゾルバ設定ファイル"

#. type: Plain text
#: build/C/man5/host.conf.5:126
msgid "Local hosts database"
msgstr "ローカルの hosts データベース"

#. type: Plain text
#: build/C/man5/host.conf.5:135
msgid ""
"The following differences exist compared to the original implementation.  A "
"new command I<spoof> and a new environment variable B<RESOLV_SPOOF_CHECK> "
"can take arguments like I<off>, I<nowarn>, and I<warn>.  Line comments can "
"appear anywhere and not only at the beginning of a line."
msgstr ""
"元々の実装に比べて以下のような違いがある。 新しいコマンド I<spoof> と新しい環"
"境変数 B<RESOLV_SPOOF_CHECK> は、引数 I<off>, I<nowarn>, I<warn> をとる。 "
"コメントは行頭だけではなく、どこに書いてもよい。"

#. type: Plain text
#: build/C/man5/host.conf.5:141
#, fuzzy
#| msgid ""
#| "In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is "
#| "broken."
msgid "In glibc 2.4 and earlier, the following keyword is recognized:"
msgstr "glibc 2.2.5 以前では、 B<ether_line>()  の実装はおかしい。"

#. type: TP
#: build/C/man5/host.conf.5:141
#, no-wrap
msgid "I<order>"
msgstr "I<order>"

#. type: Plain text
#: build/C/man5/host.conf.5:147
msgid ""
"This keyword specifies how host lookups are to be performed.  It should be "
"followed by one or more lookup methods, separated by commas.  Valid methods "
"are I<bind>, I<hosts>, and I<nis>."
msgstr ""
"このキーワードは、ホストのルックアップ方式を指定する。 このキーワードの後に"
"は、コンマで分けた 1 つ以上のルックアップ方式が続かなくてはならない。 使用可"
"能な方式は I<bind>, I<hosts>, I<nis> である。"

#. type: TP
#: build/C/man5/host.conf.5:147
#, no-wrap
msgid "B<RESOLV_SERV_ORDER>"
msgstr "B<RESOLV_SERV_ORDER>"

#. type: Plain text
#: build/C/man5/host.conf.5:152
msgid "Overrides the I<order> command."
msgstr "I<order> コマンドを上書きする。"

#.  commit 7d68cdaa4f748e87ee921f587ee2d483db624b3d
#. type: Plain text
#: build/C/man5/host.conf.5:156
msgid ""
"Since glibc 2.0.7, and up through glibc 2.24, the following keywords and "
"environment variable have been recognized but never implemented:"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:156
#, no-wrap
msgid "I<nospoof>"
msgstr "I<nospoof>"

#. type: Plain text
#: build/C/man5/host.conf.5:171
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolver library "
"will attempt to prevent hostname spoofing to enhance the security of "
"B<rlogin> and B<rsh>.  It works as follows: after performing a host address "
"lookup, the resolver library will perform a hostname lookup for that "
"address.  If the two hostnames do not match, the query fails.  The default "
"value is I<off>."
msgstr "有効な値は I<on> と I<off> である。 I<on> に設定された場合、レゾルバライブラリは B<rlogin> と B<rsh> のセキュリティを向上させるためホスト名の偽装を防止しようとする。 これは、「ホストアドレスのルックアップを行った後、 レゾルバライブラリはそのアドレスに対してホスト名のルックアップを行い、 もし 2 つのホスト名が一致しなかった場合は、クエリーは失敗する。」 というように動作する。 デフォルトの値は I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:171
#, no-wrap
msgid "I<spoofalert>"
msgstr "I<spoofalert>"

#. type: Plain text
#: build/C/man5/host.conf.5:184
msgid ""
"Valid values are I<on> and I<off>.  If this option is set to I<on> and the "
"I<nospoof> option is also set, the resolver library will log a warning of "
"the error via the syslog facility.  The default value is I<off>."
msgstr "有効な値は I<on> と I<off> である。 このオプションが I<on> に設定されていて、 I<nospoof> オプションも (on に) 設定されている場合、 レゾルバライブラリは syslog 機能を通じてエラーに関する警告のログをとる。 デフォルトの値は I<off> である。"

#. type: TP
#: build/C/man5/host.conf.5:184
#, no-wrap
msgid "I<spoof>"
msgstr "I<spoof>"

#. type: Plain text
#: build/C/man5/host.conf.5:203
msgid ""
"Valid values are I<off>, I<nowarn>, and I<warn>.  If this option is set to "
"I<off>, spoofed addresses are permitted and no warnings will be emitted via "
"the syslog facility.  If this option is set to I<warn>, the resolver library "
"will attempt to prevent hostname spoofing to enhance the security and log a "
"warning of the error via the syslog facility.  If this option is set to "
"I<nowarn>, the resolver library will attempt to prevent hostname spoofing to "
"enhance the security but not emit warnings via the syslog facility.  Setting "
"this option to anything else is equal to setting it to I<nowarn>."
msgstr "有効な値は I<off>, I<nowarn>, I<warn> である。 このオプションを I<off> に設定すると、偽装されたアドレスを許可して、 syslog 機能を通じた警告を発しない。 このオプションを I<warn> に設定すると、レゾルバライブラリはセキュリティを高めるためにホスト名の偽装を防止し、 syslog 機能を通じてエラーに関する警告のログをとる。 このオプションを I<nowarn> に設定すると、レゾルバライブラリはセキュリティを高めるためにホスト名の偽装を防止するが、 syslog 機能を通じた警告は発しない。 このオプションを何も設定しない場合は、 I<nowarn> を設定したのと同じになる。"

#. type: TP
#: build/C/man5/host.conf.5:203
#, no-wrap
msgid "B<RESOLV_SPOOF_CHECK>"
msgstr "B<RESOLV_SPOOF_CHECK>"

#. type: Plain text
#: build/C/man5/host.conf.5:212
msgid ""
"Overrides the I<nospoof>, I<spoofalert>, and I<spoof> commands in the same "
"way as the I<spoof> command is parsed.  Valid values are I<off>, I<nowarn>, "
"and I<warn>."
msgstr ""
"I<spoof> コマンドを解析するのと同じ方式で、 I<nospoof>, I<spoofalert>, "
"I<spoof> コマンドを上書きできる。 有効な値は I<off>, I<nowarn>, I<warn> であ"
"る。"

#. type: Plain text
#: build/C/man5/host.conf.5:219
msgid ""
"B<gethostbyname>(3), B<hosts>(5), B<nsswitch.conf>(5), B<resolv.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr "B<gethostbyname>(3), B<hosts>(5), B<nsswitch.conf>(5), B<resolv.conf>(5), B<hostname>(7), B<named>(8)"

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "HOSTNAME"
msgstr "HOSTNAME"

#. type: TH
#: build/C/man7/hostname.7:39
#, no-wrap
msgid "2019-05-09"
msgstr "2019-05-09"

#. type: Plain text
#: build/C/man7/hostname.7:42
msgid "hostname - hostname resolution description"
msgstr "hostname - ホスト名の名前解決の説明"

#. type: Plain text
#: build/C/man7/hostname.7:46
msgid ""
"Hostnames are domains, where a domain is a hierarchical, dot-separated list "
"of subdomains; for example, the machine \"monet\", in the \"example\" "
"subdomain of the \"com\" domain would be represented as \"monet.example.com"
"\"."
msgstr "ホスト名は、階層構造でドット区切りのサブドメインである。例えば、 \"com\" ドメインの \"example\" サブドメインのマシン \"monet\" は、 \"monet.example.com\" と表現される。"

#. type: Plain text
#: build/C/man7/hostname.7:61
msgid ""
"Each element of the hostname must be from 1 to 63 characters long and the "
"entire hostname, including the dots, can be at most 253 characters long.  "
"Valid characters for hostnames are B<ASCII>(7)  letters from I<a> to I<z>, "
"the digits from I<0> to I<9>, and the hyphen (-).  A hostname may not start "
"with a hyphen."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:68
msgid ""
"Hostnames are often used with network client and server programs, which must "
"generally translate the name to an address for use.  (This task is generally "
"performed by either B<getaddrinfo>(3)  or the obsolete B<gethostbyname>(3).)"
msgstr ""
"ホスト名は、ネットワーククライアントやサーバのプログラムでは一般的に使用され、使用する際には名前からアドレスに変換しなければならない (一般的にはアドレスへの変換処理は B<getaddrinfo>(3) か (廃止予定の)\n"
"B<gethostbyname>(3) で行われる)。"

#. type: Plain text
#: build/C/man7/hostname.7:78
msgid ""
"Hostnames are resolved by the NSS framework in glibc according to the "
"B<hosts> configuration in B<nsswitch.conf>.  The DNS-based name resolver (in "
"the B<dns> NSS service module) resolves them in the following fashion."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:91
msgid ""
"If the name consists of a single component, that is, contains no dot, and if "
"the environment variable B<HOSTALIASES> is set to the name of a file, that "
"file is searched for any string matching the input hostname.  The file "
"should consist of lines made up of two white-space separated strings, the "
"first of which is the hostname alias, and the second of which is the "
"complete hostname to be substituted for that alias.  If a case-insensitive "
"match is found between the hostname to be resolved and the first field of a "
"line in the file, the substituted name is looked up with no further "
"processing."
msgstr ""
"ホスト名がドットを含まない単一要素で構成されていて、環境変数\n"
"B<HOSTALIASES> にファイル名が設定されている場合、入力されたホスト名に\n"
"マッチする文字列を検索するのに指定されたファイルが使用される。\n"
"そのファイルの各行は、ホワイトスペースで区切られた文字列 2 つで\n"
"構成され、各行の最初の文字列がホスト名のエイリアス (別名) で、\n"
"二番目の文字列がそのエイリアスに対応する完全なホスト名である。\n"
"解決するホスト名と一致するホスト名のエイリアス (ファイルの各行の最初の\n"
"フィールド) が見つかれば、完全なホスト名に置き換えられ、\n"
"それ以上の変換処理は行わずに、そのホスト名で検索処理が行われる\n"
"(ホスト名とエイリアスの照合では大文字、小文字の違いは無視される)。"

#. type: Plain text
#: build/C/man7/hostname.7:95
msgid ""
"If the input name ends with a trailing dot, the trailing dot is removed, and "
"the remaining name is looked up with no further processing."
msgstr ""
"入力されたホスト名の末尾がドットの場合、\n"
"末尾のドットは削除され、それ以上の処理は行われず、\n"
"(末尾のドットを削除した) 残りの名前で検索が行われる。"

#. type: Plain text
#: build/C/man7/hostname.7:108
#, fuzzy
#| msgid ""
#| "If the input name does not end with a trailing dot, it is looked up by "
#| "searching through a list of domains until a match is found.  The default "
#| "search list includes first the local domain, then its parent domains with "
#| "at least 2 name components (longest first).  For example, in the domain "
#| "CS.Berkeley.EDU, the name lithium.CChem will be checked first as lithium."
#| "CChem.CS.Berkeley.EDU and then as lithium.CChem.Berkeley.EDU.  Lithium."
#| "CChem.EDU will not be tried, as there is only one component remaining "
#| "from the local domain.  The search path can be changed from the default "
#| "by a system-wide configuration file (see B<resolver>(5))."
msgid ""
"If the input name does not end with a trailing dot, it is looked up by "
"searching through a list of domains until a match is found.  The default "
"search list includes first the local domain, then its parent domains with at "
"least 2 name components (longest first).  For example, in the domain cs."
"example.com, the name lithium.cchem will be checked first as lithium.cchem."
"cs.example and then as lithium.cchem.example.com.  lithium.cchem.com will "
"not be tried, as there is only one component remaining from the local "
"domain.  The search path can be changed from the default by a system-wide "
"configuration file (see B<resolver>(5))."
msgstr ""
"入力された名前の末尾がドットでない場合、\n"
"マッチするものが見つかるまでドメインのリストの検索が行われる。\n"
"デフォルトのドメインの検索リストは、先頭ローカルのドメインで、\n"
"親ドメインが (長いものから順に) 続く (親ドメインはドット区切りで\n"
"少なくとも 2 要素あるものだけが使用される)。\n"
"例えば、 CS.Berkeley.EDU ドメインで、\n"
"lithium.CChem というホスト名の場合には、\n"
"最初に lithium.CChem.CS.Berkeley.EDU が確認され、\n"
"次に lithium.CChem.Berkeley.EDU が確認される。\n"
"Lithium.CChem.EDU はチェックされない。\n"
"なぜなら、ローカルドメイン CS.Berkeley.EDU で残っているドメインは\n"
"EDU で、これは一つしか要素がないからである。\n"
"検索リストはシステム全体で共通の設定ファイルでデフォルト値から\n"
"変更できる (B<resolver>(5) 参照)。"

#. type: Plain text
#: build/C/man7/hostname.7:115
msgid ""
"B<getaddrinfo>(3), B<gethostbyname>(3), B<nsswitch.conf>(5), B<resolver>(5), "
"B<mailaddr>(7), B<named>(8)"
msgstr "B<getaddrinfo>(3), B<gethostbyname>(3), B<nsswitch.conf>(5), B<resolver>(5), B<mailaddr>(7), B<named>(8)"

#. type: Plain text
#: build/C/man7/hostname.7:119
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1123.txt> IETF RFC\\ 1123 E<.UE>"
msgstr "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1123.txt> IETF RFC\\ 1123 E<.UE>"

#.  .SH HISTORY
#.  Hostname appeared in
#.  4.2BSD.
#. type: Plain text
#: build/C/man7/hostname.7:126
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1178.txt> IETF RFC\\ 1178 E<.UE>"
msgstr "E<.UR http://www.ietf.org\\:/rfc\\:/rfc1178.txt> IETF RFC\\ 1178 E<.UE>"

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "HOSTS"
msgstr "HOSTS"

#. type: Plain text
#: build/C/man5/hosts.5:30
msgid "hosts - static table lookup for hostnames"
msgstr "hosts - ホスト名の静的なルックアップテーブル"

#. type: Plain text
#: build/C/man5/hosts.5:32
msgid "B</etc/hosts>"
msgstr "B</etc/hosts>"

#. type: Plain text
#: build/C/man5/hosts.5:40
msgid ""
"This manual page describes the format of the I</etc/hosts> file.  This file "
"is a simple text file that associates IP addresses with hostnames, one line "
"per IP address.  For each host a single line should be present with the "
"following information:"
msgstr ""
"このマニュアルページは、 I</etc/hosts> ファイルのフォーマットについて記述して"
"いる。 このファイルは簡単なテキストファイルで、1 行に 1 つの IP アドレスがあ"
"り、 IP アドレスとホスト名を関連づけている。 各ホストについて、次のような情報"
"が 1 行で与えられる。"

#. type: Plain text
#: build/C/man5/hosts.5:43
msgid "IP_address canonical_hostname [aliases...]"
msgstr "IPアドレス 正式なホスト名 [エイリアス...]"

#. type: Plain text
#: build/C/man5/hosts.5:59
#, fuzzy
#| msgid ""
#| "Fields of the entry are separated by any number of blanks and/or tab "
#| "characters.  Text from a \"#\" character until the end of the line is a "
#| "comment, and is ignored.  Host names may contain only alphanumeric "
#| "characters, minus signs (\"-\"), and periods (\".\").  They must begin "
#| "with an alphabetic character and end with an alphanumeric character.  "
#| "Optional aliases provide for name changes, alternate spellings, shorter "
#| "hostnames, or generic hostnames (for example, I<localhost>)."
msgid ""
"The IP address can conform to either IPv4 or IPv6.  Fields of the entry are "
"separated by any number of blanks and/or tab characters.  Text from a \"#\" "
"character until the end of the line is a comment, and is ignored.  Host "
"names may contain only alphanumeric characters, minus signs (\"-\"), and "
"periods (\".\").  They must begin with an alphabetic character and end with "
"an alphanumeric character.  Optional aliases provide for name changes, "
"alternate spellings, shorter hostnames, or generic hostnames (for example, "
"I<localhost>).  If required, a host may have two separate entries in this "
"file; one for each version of the Internet Protocol (IPv4 and IPv6)."
msgstr ""
"エントリーのフィールドは、空白またはタブ (複数でも可) で区切られる。 \"#\" 文"
"字から行末までのテキストはコメントとして無視される。 ホスト名は英数字、 マイ"
"ナス記号 (\"-\")、 ピリオド (\".\") を含むことができる。 ホスト名は英文字 "
"(alphabetic character) で始まって、 英数字 (alphanumeric characte) で終わらな"
"ければならない。 エイリアスはオプションであり、名前の変更、別のスペル、 短い"
"ホスト名、一般的に使われるホスト名 (例えば I<localhost>)  などのために用意さ"
"れている。"

#. type: Plain text
#: build/C/man5/hosts.5:67
msgid ""
"The Berkeley Internet Name Domain (BIND) Server implements the Internet name "
"server for UNIX systems.  It augments or replaces the I</etc/hosts> file or "
"hostname lookup, and frees a host from relying on I</etc/hosts> being up to "
"date and complete."
msgstr ""
"Berkeley Internet Name Domain (BIND) サーバは、 UNIX システムのためのインター"
"ネットネームサーバを実装している。 これは、 I</etc/hosts> ファイルやホスト名"
"ルックアップを拡張したり置き換えたりするものである。 これにより各ホストは I</"
"etc/hosts> を最新かつ完全に保たなくてもよくなる。"

#. type: Plain text
#: build/C/man5/hosts.5:70
msgid ""
"In modern systems, even though the host table has been superseded by DNS, it "
"is still widely used for:"
msgstr ""
"ホストテーブルは、DNS にとって代わられたにもかかわらず、 現在のシステムにおい"
"て次のような用途で広く使われている。"

#. type: TP
#: build/C/man5/hosts.5:70
#, no-wrap
msgid "B<bootstrapping>"
msgstr "B<ブート時>"

#. type: Plain text
#: build/C/man5/hosts.5:76
msgid ""
"Most systems have a small host table containing the name and address "
"information for important hosts on the local network.  This is useful when "
"DNS is not running, for example during system bootup."
msgstr ""
"大部分のシステムは、ローカルネットワークにおいて重要なホストの 名前とアドレス"
"が含まれた小さなホストテーブルを持っている。 これは、システムのブート時など"
"の DNS が稼働していないときに役立つ。"

#. type: TP
#: build/C/man5/hosts.5:76
#, no-wrap
msgid "B<NIS>"
msgstr "B<NIS>"

#. type: Plain text
#: build/C/man5/hosts.5:82
msgid ""
"Sites that use NIS use the host table as input to the NIS host database.  "
"Even though NIS can be used with DNS, most NIS sites still use the host "
"table with an entry for all local hosts as a backup."
msgstr ""
"NIS を使用しているサイトは、ホストテーブルを NIS ホストデータベースの入力とし"
"て用いる。 NIS を DNS と共に使用できるにもかかわらず、 大部分の NIS サイトは"
"未だに、 全てのローカルホストのエントリーをもつホストテーブルを バックアップ"
"として使用している。"

#. type: TP
#: build/C/man5/hosts.5:82
#, no-wrap
msgid "B<isolated nodes>"
msgstr "B<隔絶されたノード>"

#. type: Plain text
#: build/C/man5/hosts.5:89
msgid ""
"Very small sites that are isolated from the network use the host table "
"instead of DNS.  If the local information rarely changes, and the network is "
"not connected to the Internet, DNS offers little advantage."
msgstr ""
"ネットワークから隔絶された非常に小さなサイトは、 DNS の代わりにホストテーブル"
"を使用している。 ローカル情報が稀にしか変更されず、 ネットワークがインター"
"ネットと接続されていない場合、 DNS にそれほどの利点はない。"

#. type: Plain text
#: build/C/man5/hosts.5:94
msgid ""
"Modifications to this file normally take effect immediately, except in cases "
"where the file is cached by applications."
msgstr ""
"このファイルへの変更は通常すぐに反映される。但し、アプリケーション によりファ"
"イルの内容がキャッシュされている場合はこの限りではない。"

#. type: SS
#: build/C/man5/hosts.5:94
#, no-wrap
msgid "Historical notes"
msgstr "歴史的な経緯"

#. type: Plain text
#: build/C/man5/hosts.5:97
msgid ""
"RFC\\ 952 gave the original format for the host table, though it has since "
"changed."
msgstr ""
"ホストテーブルのフォーマットはその後変更されているが、 元々のフォーマットは "
"RFC\\ 952 には記載されている。"

#. type: Plain text
#: build/C/man5/hosts.5:110
msgid ""
"Before the advent of DNS, the host table was the only way of resolving "
"hostnames on the fledgling Internet.  Indeed, this file could be created "
"from the official host data base maintained at the Network Information "
"Control Center (NIC), though local changes were often required to bring it "
"up to date regarding unofficial aliases and/or unknown hosts.  The NIC no "
"longer maintains the hosts.txt files, though looking around at the time of "
"writing (circa 2000), there are historical hosts.txt files on the WWW.  I "
"just found three, from 92, 94, and 95."
msgstr ""
"DNS の登場以前、ホストテーブルは、駆け出したばかりのインターネットにおける ホ"
"スト名解決の唯一の方法であった。 実際、このファイルは Network Information "
"Control Center (NIC) によって 管理される公式ホストデータベースから作成するこ"
"とができた。 しかし、非公式なエイリアスや不明なホストを扱えるように、 最新に"
"保つためのローカルな変更が頻繁に必要とされた。 NIC は既に hosts.txt を管理し"
"ていないが、 これを書いている (2000 年頃の) 時点で調べてみると、 WWW 上に歴史"
"的な hosts.txt が存在する。 92, 94, 95 年のものが見つかった。"

#. type: Plain text
#: build/C/man5/hosts.5:114
#, no-wrap
msgid ""
"# The following lines are desirable for IPv4 capable hosts\n"
"127.0.0.1       localhost\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:121
#, no-wrap
msgid ""
"# 127.0.1.1 is often used for the FQDN of the machine\n"
"127.0.1.1       thishost.mydomain.org  thishost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"
msgstr ""
"# 127.0.1.1 is often used for the FQDN of the machine\n"
"127.0.1.1       thishost.mydomain.org  thishost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"

#. type: Plain text
#: build/C/man5/hosts.5:126
#, no-wrap
msgid ""
"# The following lines are desirable for IPv6 capable hosts\n"
"::1             localhost ip6-localhost ip6-loopback\n"
"ff02::1         ip6-allnodes\n"
"ff02::2         ip6-allrouters\n"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:135
msgid ""
"B<hostname>(1), B<resolver>(3), B<host.conf>(5), B<resolv.conf>(5), "
"B<resolver>(5), B<hostname>(7), B<named>(8)"
msgstr "B<hostname>(1), B<resolver>(3), B<host.conf>(5), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), B<named>(8)"

#.  .SH AUTHOR
#.  This manual page was written by Manoj Srivastava <srivasta@debian.org>,
#.  for the Debian GNU/Linux system.
#. type: Plain text
#: build/C/man5/hosts.5:140
msgid "Internet RFC\\ 952"
msgstr "Internet RFC\\ 952"

#. type: TH
#: build/C/man5/hosts.equiv.5:6
#, no-wrap
msgid "HOSTS.EQUIV"
msgstr "HOSTS.EQUIV"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:11
msgid ""
"hosts.equiv - list of hosts and users that are granted \"trusted\" B<r> "
"command access to your system"
msgstr "hosts.equiv - 「信頼された」B<r> コマンドによるシステムへの アクセスを許可するホストおよびユーザーのリスト"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:22
msgid ""
"The file I</etc/hosts.equiv> allows or denies hosts and users to use the "
"B<r>-commands (e.g., B<rlogin>, B<rsh>, or B<rcp>)  without supplying a "
"password."
msgstr "B</etc/hosts.equiv> ファイルは B<r>-コマンド (B<rlogin>, B<rsh>, B<rcp> など) によるパスワードなしでの利用を 許可/拒否するホスト/ユーザーを設定する。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:24
msgid "The file uses the following format:"
msgstr "このファイルでは以下の書式を用いる。"

#. type: TP
#: build/C/man5/hosts.equiv.5:24
#, no-wrap
msgid "I<+|[-]hostname|+@netgroup|-@netgroup> I<[+|[-]username|+@netgroup|-@netgroup]>"
msgstr "I<+|[-]hostname|+@netgroup|-@netgroup> I<[+|[-]username|+@netgroup|-@netgroup]>"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:43
#, fuzzy
#| msgid ""
#| "The I<hostname> is the name of a host which is logically equivalent to "
#| "the local host.  Users logged into that host are allowed to access like-"
#| "named user accounts on the local host without supplying a password.  The "
#| "I<hostname> may be (optionally) preceded by a plus (+) sign.  If the plus "
#| "sign is used alone, it allows any host to access your system.  You can "
#| "explicitly deny access to a host by preceding the I<hostname> by a minus "
#| "(-) sign.  Users from that host must always supply a password.  For "
#| "security reasons you should always use the FQDN of the hostname and not "
#| "the short hostname."
msgid ""
"The I<hostname> is the name of a host which is logically equivalent to the "
"local host.  Users logged into that host are allowed to access like-named "
"user accounts on the local host without supplying a password.  The "
"I<hostname> may be (optionally) preceded by a plus (+) sign.  If the plus "
"sign is used alone, it allows any host to access your system.  You can "
"explicitly deny access to a host by preceding the I<hostname> by a minus (-) "
"sign.  Users from that host must always supply additional credentials, "
"including possibly a password. For security reasons you should always use "
"the FQDN of the hostname and not the short hostname."
msgstr ""
"I<hostname> は、ローカルホストと論理的に等価なホストの名前である。 そのホスト"
"にログインしているユーザーは、パスワードなしで ローカルホストの同じ名前のユー"
"ザーアカウントにアカウントできる。 I<hostname> の前にはプラス記号 (+) を置い"
"てもよい。プラス記号が単独で置かれた場合は、 このシステムへのアクセスをあらゆ"
"るホストに対して許可したことになる。 アクセスを明示的に拒否するには、 "
"I<hostname> の前にマイナス記号 (-) を付ける。そのホストからのユーザーは 常に"
"パスワードを要求される。セキュリティ上、ホスト名は 短い名前ではなく常に FQDN "
"を使って指定すべきである。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:61
msgid ""
"The I<username> entry grants a specific user access to all user accounts "
"(except root) without supplying a password.  That means the user is NOT "
"restricted to like-named accounts.  The I<username> may be (optionally) "
"preceded by a plus (+) sign.  You can also explicitly deny access to a "
"specific user by preceding the I<username> with a minus (-) sign.  This says "
"that the user is not trusted no matter what other entries for that host "
"exist."
msgstr ""
"I<username> エントリーは、特定のユーザーに対して、 (root 以外の) あらゆるユー"
"ザーアカウント へのアクセスをパスワードなしで許可する。すなわち、そのユーザー"
"は同じ名前の アカウント以外にもアクセスできる。 I<username> の前にはプラス記"
"号 (+) を置いてもよい。 特定のユーザーからのアクセスを明示的に拒否するには、 "
"I<username> の前にマイナス記号 (-) を付ける。こうすると、 ホストのエントリー"
"がなんと言おうとも、そのユーザーは信頼されないことになる。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:63
msgid "Netgroups can be specified by preceding the netgroup by an @ sign."
msgstr "netgroup を指定することもでき、その場合は @ 記号を前につける。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:69
msgid ""
"Be extremely careful when using the plus (+) sign.  A simple typographical "
"error could result in a standalone plus sign.  A standalone plus sign is a "
"wildcard character that means \"any host\"!"
msgstr ""
"プラス記号 (+) を利用する際にはくれぐれも注意すること。 単純なミスタイプで、"
"単独のプラス記号を置いてしまうことがある。 単独のプラス記号は「すべてのホス"
"ト」を表すワイルドカードになってしまう!"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:71
msgid "I</etc/hosts.equiv>"
msgstr "I</etc/hosts.equiv>"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:76
msgid ""
"Some systems will honor the contents of this file only when it has owner "
"root and no write permission for anybody else.  Some exceptionally paranoid "
"systems even require that there be no other hard links to the file."
msgstr ""
"システムによっては、このファイルの内容が効力を持つのは、 このファイルの所有者"
"が root で、 かつそれ以外に書き込み権限がない場合に限定されていることもあ"
"る。 また、非常に制限がきついシステムでは、このファイルに対する他の ハードリ"
"ンクがないことが要求される場合もある。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:84
msgid ""
"Modern systems use the Pluggable Authentication Modules library (PAM).  With "
"PAM a standalone plus sign is considered a wildcard character which means "
"\"any host\" only when the word I<promiscuous> is added to the auth "
"component line in your PAM file for the particular service (e.g., B<rlogin>)."
msgstr ""
"最近のシステムでは Pluggable Authentication Modules library (PAM) が 使われて"
"いる。PAM では、単独のプラス記号が「すべてのホスト」を表す ワイルドカードとし"
"て扱われるのは、特定のサービス (例えば B<rlogin>)  用の PAM ファイルで auth "
"行にキーワード I<promiscuous> が追加されている場合のみである。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:90
msgid "Below are some example I</etc/host.equiv> or I<\\(ti/.rhosts> files."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:92
msgid "Allow any user to log in from any host:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:94
#, no-wrap
msgid "    +\n"
msgstr "    +\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:98
msgid "Allow any user from I<host> with a matching local account to log in:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:100
#, no-wrap
msgid "    host\n"
msgstr "    host\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:105
msgid ""
"Note: the use of I<+host> is never a valid syntax, including attempting to "
"specify that any user from the host is allowed."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:109
msgid "Allow any user from I<host> to log in:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:111
#, no-wrap
msgid "    host +\n"
msgstr "    host +\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:114
msgid ""
"Note: this is distinct from the previous example since it does not require a "
"matching local account."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:120
msgid "Allow I<user> from I<host> to log in as any non-root user:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:122
#, no-wrap
msgid "    host user\n"
msgstr "    host user\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:127
msgid ""
"Allow all users with matching local accounts from I<host> to log in except "
"for I<baduser>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:130
#, no-wrap
msgid ""
"    host -baduser\n"
"    host\n"
msgstr ""
"    host -baduser\n"
"    host\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:133
msgid "Deny all users from I<host>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:135
#, no-wrap
msgid "    -host\n"
msgstr "    -host\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:141
msgid ""
"Note: the use of I<-host\\ -user> is never a valid syntax, including "
"attempting to specify that a particular user from the host is not trusted."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:144
msgid ""
"Allow all users with matching local accounts on all hosts in a I<netgroup>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:146
#, no-wrap
msgid "    +@netgroup\n"
msgstr "    +@netgroup\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:149
#, fuzzy
#| msgid "Include all users in the given I<netgroup>."
msgid "Disallow all users on all hosts in a I<netgroup>:"
msgstr "指定された I<netgroup> の全ユーザーを含める。"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:151
#, no-wrap
msgid "    -@netgroup\n"
msgstr "    -@netgroup\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:157
msgid ""
"Allow all users in a I<netgroup> to log in from I<host> as any non-root user:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:159
#, no-wrap
msgid "    host +@netgroup\n"
msgstr "    host +@netgroup\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:164
msgid ""
"Allow all users with matching local accounts on all hosts in a I<netgroup> "
"except I<baduser>:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:167
#, no-wrap
msgid ""
"    +@netgroup -baduser\n"
"    +@netgroup\n"
msgstr ""
"    +@netgroup -baduser\n"
"    +@netgroup\n"

#. type: Plain text
#: build/C/man5/hosts.equiv.5:170
msgid ""
"Note: the deny statements must always precede the allow statements because "
"the file is processed sequentially until the first matching rule is found."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:174
msgid "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"
msgstr "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"

#. type: TH
#: build/C/man7/icmp.7:12
#, no-wrap
msgid "ICMP"
msgstr "ICMP"

#. type: TH
#: build/C/man7/icmp.7:12
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: build/C/man7/icmp.7:15
msgid "icmp - Linux IPv4 ICMP kernel module."
msgstr "icmp - Linux IPv4 ICMP カーネルモジュール"

#. type: Plain text
#: build/C/man7/icmp.7:23
msgid ""
"This kernel protocol module implements the Internet Control Message Protocol "
"defined in RFC\\ 792.  It is used to signal error conditions and for "
"diagnosis.  The user doesn't interact directly with this module; instead it "
"communicates with the other protocols in the kernel and these pass the ICMP "
"errors to the application layers.  The kernel ICMP module also answers ICMP "
"requests."
msgstr ""
"このカーネルモジュールは RFC\\ 792 で定義されている Internet Control Message "
"Protocol を実装したものである。 このプロトコルはエラー状況を知らせたり診断を"
"行うために用いられる。 ユーザーはこのモジュールとは直接には通信できない。 こ"
"のモジュールはカーネルの他のプロトコルと通信し、 それらのプロトコルが ICMP エ"
"ラーをアプリケーションレイヤに渡す。 カーネルの ICMP モジュールは ICMP リクエ"
"ストに対する応答も行う。"

#. type: Plain text
#: build/C/man7/icmp.7:35
msgid ""
"A user protocol may receive ICMP packets for all local sockets by opening a "
"raw socket with the protocol B<IPPROTO_ICMP>.  See B<raw>(7)  for more "
"information.  The types of ICMP packets passed to the socket can be filtered "
"using the B<ICMP_FILTER> socket option.  ICMP packets are always processed "
"by the kernel too, even when passed to a user socket."
msgstr ""
"raw ソケットをプロトコル B<IPPROTO_ICMP> でオープンすれば、 ユーザープロトコ"
"ルはローカルなソケット全てに対する ICMP パケットを受信することができる。 詳細"
"は B<raw>(7)  を参照のこと。 ソケットに渡される ICMP パケットのタイプは "
"B<ICMP_FILTER> オプションによってフィルターできる。 ICMP パケットは (たとえ"
"ユーザーソケットに渡される場合でも)、 常にカーネルによって (も) 処理される。"

#. type: Plain text
#: build/C/man7/icmp.7:41
msgid ""
"Linux limits the rate of ICMP error packets to each destination.  "
"B<ICMP_REDIRECT> and B<ICMP_DEST_UNREACH> are also limited by the "
"destination route of the incoming packets."
msgstr ""
"Linux では ICMP エラーパケットのレートをそれぞれの送り先に対して 制限してい"
"る。 B<ICMP_REDIRECT> と B<ICMP_DEST_UNREACH> も到着したパケットの行き先経路 "
"(destination route) を制限する。"

#.  FIXME . better description needed
#. type: Plain text
#: build/C/man7/icmp.7:54
msgid ""
"ICMP supports a set of I</proc> interfaces to configure some global IP "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/ipv4/>.  Most of these parameters are rate "
"limitations for specific ICMP types.  Linux 2.2 uses a token bucket filter "
"to limit ICMPs.  The value is the timeout in jiffies until the token bucket "
"filter is cleared after a burst.  A jiffy is a system dependent unit, "
"usually 10ms on i386 and about 1ms on alpha and ia64."
msgstr ""
"ICMP では、いくつかのグローバルパラメーターを設定するための I</proc> ファイル"
"群が用意されている。 これらのパラメーターには、 I</proc/sys/net/ipv4/> ディレ"
"クトリ内のファイルの読み書きでアクセスできる。 これらのパラメーターのほとんど"
"は特定の ICMP タイプに対するレート制限 (rate limitation) である。 Linux 2.2 "
"は ICMP の制限にトークンバケットフィルタ (token bucket filter) を用いる。 そ"
"れぞれの値は、バーストの後にトークンバケットフィルタがクリア されるまでのタイ"
"ムアウトを秒単位で表したものである。最小単位(jiffy)は システム依存の単位で "
"i386 システムは通常 10ms、alpha や ia64 では 1ms である。"

#. type: TP
#: build/C/man7/icmp.7:54
#, no-wrap
msgid "I<icmp_destunreach_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_destunreach_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:63
msgid ""
"Maximum rate to send ICMP Destination Unreachable packets.  This limits the "
"rate at which packets are sent to any individual route or destination.  The "
"limit does not affect sending of B<ICMP_FRAG_NEEDED> packets needed for path "
"MTU discovery."
msgstr ""
"ICMP 不達パケット (Destination Unreachable packet) を送る最大レート。 これは"
"特定のルートまたは行き先にパケットを送信するレートを制限する。 この制限は、 "
"path MTU discovery に必要な B<ICMP_FRAG_NEEDED> パケットの送信には影響しな"
"い。"

#. type: TP
#: build/C/man7/icmp.7:63
#, no-wrap
msgid "I<icmp_echo_ignore_all> (since Linux 2.2)"
msgstr "I<icmp_echo_ignore_all> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:69
msgid "If this value is nonzero, Linux will ignore all B<ICMP_ECHO> requests."
msgstr ""
"この値が非ゼロの場合は、 Linux はすべての B<ICMP_ECHO> 要求を無視する。"

#. type: TP
#: build/C/man7/icmp.7:69
#, no-wrap
msgid "I<icmp_echo_ignore_broadcasts> (since Linux 2.2)"
msgstr "I<icmp_echo_ignore_broadcasts> (Linux 2.2 以降)"

#.  Precisely: from 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:75
msgid ""
"If this value is nonzero, Linux will ignore all B<ICMP_ECHO> packets sent to "
"broadcast addresses."
msgstr ""
"この値が非ゼロの場合は、 Linux はブロードキャストアドレスに送られたすべての "
"B<ICMP_ECHO> 要求を無視する。"

#. type: TP
#: build/C/man7/icmp.7:75
#, no-wrap
msgid "I<icmp_echoreply_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_echoreply_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:83
msgid ""
"Maximum rate for sending B<ICMP_ECHOREPLY> packets in response to "
"B<ICMP_ECHOREQUEST> packets."
msgstr ""
"B<ICMP_ECHOREQUEST> パケットに応答する B<ICMP_ECHOREPLY> パケットの最大送信"
"レート。"

#. type: TP
#: build/C/man7/icmp.7:83
#, no-wrap
msgid "I<icmp_errors_use_inbound_ifaddr> (Boolean; default: disabled; since Linux 2.6.12)"
msgstr "I<icmp_errors_use_inbound_ifaddr> (ブール値; デフォルト: 無効; Linux 2.6.12 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:88
msgid ""
"If disabled, ICMP error messages are sent with the primary address of the "
"exiting interface."
msgstr ""
"これを無効にすると、ICMP エラーメッセージは、 出力インターフェースのプライマ"
"リアドレスで送信される。"

#. type: Plain text
#: build/C/man7/icmp.7:94
msgid ""
"If enabled, the message will be sent with the primary address of the "
"interface that received the packet that caused the ICMP error.  This is the "
"behavior that many network administrators will expect from a router.  And it "
"can make debugging complicated network layouts much easier."
msgstr ""
"これを有効にすると、エラーメッセージは ICMP エラーの原因となったパケットを 受"
"信したインターフェースのプライマリアドレスで送信される。 この動作は、多くの"
"ネットワーク管理者がルーターに対して期待しているものであり、 これにより複雑な"
"ネットワークレイアウトのデバッグがより容易になる。"

#. type: Plain text
#: build/C/man7/icmp.7:98
msgid ""
"Note that if no primary address exists for the interface selected, then the "
"primary address of the first non-loopback interface that has one will be "
"used regardless of this setting."
msgstr ""
"選択されたインターフェースでプライマリアドレスが存在しない場合は、 この設定に"
"関わらず、最初のループバック以外のインターフェースで、 プライマリアドレスを持"
"つインターフェースのプライマリアドレスが使用される点に 注意すること。"

#. type: TP
#: build/C/man7/icmp.7:98
#, no-wrap
msgid "I<icmp_ignore_bogus_error_responses> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<icmp_ignore_bogus_error_responses> (ブール値; デフォルト: 無効; Linux 2.2 以降)"

#.  precisely: since 2.1.32
#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:106
msgid ""
"Some routers violate RFC1122 by sending bogus responses to broadcast "
"frames.  Such violations are normally logged via a kernel warning.  If this "
"parameter is enabled, the kernel will not give such warnings, which will "
"avoid log file clutter."
msgstr ""
"ルーターの中には、RFC1122 に違反し、ブロードキャストフレームに対して 偽の応答"
"を送信するものがある。 このような違反は通常カーネルの警告としてログに記録され"
"る。 このパラメーターを有効にすると、カーネルはこのような警告を出さなくな"
"り、 ログファイルに雑音のような情報が記録されるのを避けることができる。"

#. type: TP
#: build/C/man7/icmp.7:106
#, no-wrap
msgid "I<icmp_paramprob_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_paramprob_rate> (Linux 2.2 から 2.4.9 まで)"

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:113
msgid ""
"Maximum rate for sending B<ICMP_PARAMETERPROB> packets.  These packets are "
"sent when a packet arrives with an invalid IP header."
msgstr ""
"B<ICMP_PARAMETERPROB> パケットの最大送信レート。 これらのパケットは不正な IP "
"ヘッダーを持つパケットが到着した場合に 送信される。"

#. type: TP
#: build/C/man7/icmp.7:113
#, no-wrap
msgid "I<icmp_ratelimit> (integer; default: 1000; since Linux 2.4.10)"
msgstr "I<icmp_ratelimit> (integer; default: 1000; Linux 2.4.10 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:121
msgid ""
"Limit the maximum rates for sending ICMP packets whose type matches "
"I<icmp_ratemask> (see below) to specific targets.  0 to disable any "
"limiting, otherwise the minimum space between responses in milliseconds."
msgstr ""
"種別が I<icmp_ratemask> (下記参照) にマッチした ICMP パケットの、 特定の送信"
"先への送信レートの最大値を制限する。 0 はレート制限を無効にすることを、 0 以"
"外の値は応答間の最小間隔 (ミリ秒単位) を示す。"

#. type: TP
#: build/C/man7/icmp.7:121
#, no-wrap
msgid "I<icmp_ratemask> (integer; default: see below; since Linux 2.4.10)"
msgstr "I<icmp_ratemask> (integer; default: 下記参照; Linux 2.4.10 以降)"

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:125
msgid "Mask made of ICMP types for which rates are being limited."
msgstr "レート制限を行う ICMP タイプを決めるマスク。"

#. type: Plain text
#: build/C/man7/icmp.7:127
msgid "Significant bits: IHGFEDCBA9876543210"
msgstr "有効ビット: IHGFEDCBA9876543210"

#. type: Plain text
#: build/C/man7/icmp.7:129
msgid "Default mask: 0000001100000011000 (0x1818)"
msgstr "デフォルトマスク: 0000001100000011000 (0x1818)"

#. type: Plain text
#: build/C/man7/icmp.7:132
msgid ""
"Bit definitions (see the Linux kernel source file I<include/linux/icmp.h>):"
msgstr ""
"ビット定義 (Linux カーネルソースファイル I<include/linux/icmp.h> を参照):"

#. type: tbl table
#: build/C/man7/icmp.7:135
#, no-wrap
msgid "0 Echo Reply"
msgstr "0 Echo Reply"

#. type: tbl table
#: build/C/man7/icmp.7:136
#, no-wrap
msgid "3 Destination Unreachable *"
msgstr "3 Destination Unreachable *"

#. type: tbl table
#: build/C/man7/icmp.7:137
#, no-wrap
msgid "4 Source Quench *"
msgstr "4 Source Quench *"

#. type: tbl table
#: build/C/man7/icmp.7:138
#, no-wrap
msgid "5 Redirect"
msgstr "5 Redirect"

#. type: tbl table
#: build/C/man7/icmp.7:139
#, no-wrap
msgid "8 Echo Request"
msgstr "8 Echo Request"

#. type: tbl table
#: build/C/man7/icmp.7:140
#, no-wrap
msgid "B Time Exceeded *"
msgstr "B Time Exceeded *"

#. type: tbl table
#: build/C/man7/icmp.7:141
#, no-wrap
msgid "C Parameter Problem *"
msgstr "C Parameter Problem *"

#. type: tbl table
#: build/C/man7/icmp.7:142
#, no-wrap
msgid "D Timestamp Request"
msgstr "D Timestamp Request"

#. type: tbl table
#: build/C/man7/icmp.7:143
#, no-wrap
msgid "E Timestamp Reply"
msgstr "E Timestamp Reply"

#. type: tbl table
#: build/C/man7/icmp.7:144
#, no-wrap
msgid "F Info Request"
msgstr "F Info Request"

#. type: tbl table
#: build/C/man7/icmp.7:145
#, no-wrap
msgid "G Info Reply"
msgstr "G Info Reply"

#. type: tbl table
#: build/C/man7/icmp.7:146
#, no-wrap
msgid "H Address Mask Request"
msgstr "H Address Mask Request"

#. type: tbl table
#: build/C/man7/icmp.7:147
#, no-wrap
msgid "I Address Mask Reply"
msgstr "I Address Mask Reply"

#. type: Plain text
#: build/C/man7/icmp.7:153
msgid ""
"The bits marked with an asterisk are rate limited by default (see the "
"default mask above)."
msgstr ""
"アスタリスク印 (*) が付いたビットは、 デフォルトでレート制限が有効になってい"
"る (上記のマスクのデフォルトも参照)。"

#. type: TP
#: build/C/man7/icmp.7:153
#, no-wrap
msgid "I<icmp_timeexceed_rate> (Linux 2.2 to 2.4.9)"
msgstr "I<icmp_timeexceed_rate> (Linux 2.2 から 2.4.9 まで)"

#. type: Plain text
#: build/C/man7/icmp.7:160
msgid ""
"Maximum rate for sending B<ICMP_TIME_EXCEEDED> packets.  These packets are "
"sent to prevent loops when a packet has crossed too many hops."
msgstr ""
"B<ICMP_TIME_EXCEEDED> パケットの最大送信レート。 これらのパケットはパケットが"
"あまりに多くの hop を通過した場合に、 ループを防ぐために送られる。"

#. type: TP
#: build/C/man7/icmp.7:160
#, fuzzy, no-wrap
#| msgid "I<icmp_ratemask> (integer; default: see below; since Linux 2.4.10)"
msgid "I<ping_group_range> (two integers; default: see below; since Linux 2.6.39)"
msgstr "I<icmp_ratemask> (integer; default: 下記参照; Linux 2.4.10 以降)"

#. type: Plain text
#: build/C/man7/icmp.7:166
msgid ""
"Range of the group IDs (minimum and maximum group IDs, inclusive)  that are "
"allowed to create ICMP Echo sockets.  The default is \"1 0\", which means no "
"group is allowed to create ICMP Echo sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:170
msgid "Support for the B<ICMP_ADDRESS> request was removed in 2.2."
msgstr "B<ICMP_ADDRESS> 要求に対するサポートは 2.2 で削除された。"

#. type: Plain text
#: build/C/man7/icmp.7:174
msgid "Support for B<ICMP_SOURCE_QUENCH> was removed in Linux 2.2."
msgstr "B<ICMP_SOURCE_QUENCH> は Linux 2.2 で削除された。"

#.  not really true ATM
#.  .PP
#.  Linux ICMP should be compliant to RFC 1122.
#. type: Plain text
#: build/C/man7/icmp.7:182
msgid ""
"As many other implementations don't support B<IPPROTO_ICMP> raw sockets, "
"this feature should not be relied on in portable programs."
msgstr ""
"他の多くの実装では、 B<IPPROTO_ICMP> raw ソケットがサポートされていない。 こ"
"の機能は移植性が必要なプログラムでは用いるべきでない。"

#. type: Plain text
#: build/C/man7/icmp.7:187
msgid ""
"B<ICMP_REDIRECT> packets are not sent when Linux is not acting as a router.  "
"They are also accepted only from the old gateway defined in the routing "
"table and the redirect routes are expired after some time."
msgstr ""
"Linux がルーターとして動作していないときには、 B<ICMP_REDIRECT> パケットは送"
"信されない。 またこれらが受け取られるのも、発信元がルーティングテーブルに定義"
"されている 古いゲートウェイで、リダイレクトルート (redirect route) が 適当な"
"時間の後に期限切れになっている場合に限られる。"

#. type: Plain text
#: build/C/man7/icmp.7:191
msgid ""
"The 64-bit timestamp returned by B<ICMP_TIMESTAMP> is in milliseconds since "
"the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""
"B<ICMP_TIMESTAMP> から返される 64 ビットのタイムスタンプは、 紀元 (Epoch) で"
"ある 1970-01-01 00:00:00 +0000 (UTC)  からの経過時間をミリ秒単位で表したもの"
"である。"

#. type: Plain text
#: build/C/man7/icmp.7:196
msgid ""
"Linux ICMP internally uses a raw socket to send ICMPs.  This raw socket may "
"appear in B<netstat>(8)  output with a zero inode."
msgstr ""
"Linux ICMP は ICMP を送るために内部で raw ソケットを用いる。 raw ソケットは "
"B<netstat>(8)  の出力に 0 inode として出力される。"

#. type: Plain text
#: build/C/man7/icmp.7:199
msgid "B<ip>(7), B<rdisc>(8)"
msgstr "B<ip>(7), B<rdisc>(8)"

#. type: Plain text
#: build/C/man7/icmp.7:201
msgid "RFC\\ 792 for a description of the ICMP protocol."
msgstr "B<RFC\\ 792>: ICMP プロトコルの説明"

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "INET"
msgstr "INET"

#. type: Plain text
#: build/C/man3/inet.3:46
msgid ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - Internet address manipulation routines"
msgstr ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - インターネットアドレス操作ルーチン"

#. type: Plain text
#: build/C/man3/inet.3:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/inet.3:53
#, no-wrap
msgid "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"
msgstr "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:55
#, no-wrap
msgid "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"
msgstr "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:57
#, no-wrap
msgid "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"
msgstr "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:59
#, no-wrap
msgid "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"
msgstr "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:61
#, no-wrap
msgid "B<struct in_addr inet_makeaddr(in_addr_t >I<net>B<, in_addr_t >I<host>B<);>\n"
msgstr "B<struct in_addr inet_makeaddr(in_addr_t >I<net>B<, in_addr_t >I<host>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:63
#, no-wrap
msgid "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"
msgstr "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:65
#, no-wrap
msgid "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"
msgstr "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"

#. type: Plain text
#: build/C/man3/inet.3:74
msgid "B<inet_aton>(), B<inet_ntoa>():"
msgstr "B<inet_aton>(), B<inet_ntoa>():"

#. type: Plain text
#: build/C/man3/inet.3:79
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:90
msgid ""
"B<inet_aton>()  converts the Internet host address I<cp> from the IPv4 "
"numbers-and-dots notation into binary form (in network byte order)  and "
"stores it in the structure that I<inp> points to.  B<inet_aton>()  returns "
"nonzero if the address is valid, zero if not.  The address supplied in I<cp> "
"can have one of the following forms:"
msgstr ""
"B<inet_aton>()  は、インターネットホストのアドレス I<cp> を、 IPv4 の数値と"
"ドットによる表記から (ネットワークバイトオーダの) バイナリ値へ 変換し、変換結"
"果を I<inp> が指している構造体に格納する。 アドレスが有効な場合 0 以外を返"
"し、そうでない場合は 0 を返す。 I<cp> で渡すアドレスとして、以下の形式を用い"
"ることができる。"

#. type: TP
#: build/C/man3/inet.3:90
#, no-wrap
msgid "I<a.b.c.d>"
msgstr "I<a.b.c.d>"

#. type: Plain text
#: build/C/man3/inet.3:94
msgid ""
"Each of the four numeric parts specifies a byte of the address; the bytes "
"are assigned in left-to-right order to produce the binary address."
msgstr ""
"4 つの数字のそれぞれはアドレスの各バイトを示す。 これらのバイトは左から右の順"
"序でバイナリアドレスに割り当てられる。"

#. type: TP
#: build/C/man3/inet.3:94
#, no-wrap
msgid "I<a.b.c>"
msgstr "I<a.b.c>"

#. type: Plain text
#: build/C/man3/inet.3:107
msgid ""
"Parts I<a> and I<b> specify the first two bytes of the binary address.  Part "
"I<c> is interpreted as a 16-bit value that defines the rightmost two bytes "
"of the binary address.  This notation is suitable for specifying (outmoded) "
"Class B network addresses."
msgstr ""
"I<a> と I<b> はバイナリアドレスの最初の 2 バイトを示す。 I<c> は 16 ビット値"
"と解釈され、バイナリアドレスの右側の 2 バイトを表す。 この表記は、(過去のもの"
"となった) クラス B ネットワークアドレスを 指定するのに適している。"

#. type: TP
#: build/C/man3/inet.3:107
#, no-wrap
msgid "I<a.b>"
msgstr "I<a.b>"

#. type: Plain text
#: build/C/man3/inet.3:118
msgid ""
"Part I<a> specifies the first byte of the binary address.  Part I<b> is "
"interpreted as a 24-bit value that defines the rightmost three bytes of the "
"binary address.  This notation is suitable for specifying (outmoded) Class A "
"network addresses."
msgstr ""
"I<a> はバイナリアドレスの最初のバイトを示す。 I<b> は 24 ビット値と解釈され、"
"バイナリアドレスの右側の 3 バイトを表す。 この表記は、(過去のものとなった) ク"
"ラス A ネットワークアドレスを 指定するのに適している。"

#. type: TP
#: build/C/man3/inet.3:118
#, no-wrap
msgid "I<a>"
msgstr "I<a>"

#. type: Plain text
#: build/C/man3/inet.3:124
msgid ""
"The value I<a> is interpreted as a 32-bit value that is stored directly into "
"the binary address without any byte rearrangement."
msgstr ""
"値 I<a> は 32 ビット値と解釈され、バイトの再配置は行われず、 そのままバイナリ"
"アドレスとして格納される。"

#. type: Plain text
#: build/C/man3/inet.3:137
msgid ""
"In all of the above forms, components of the dotted address can be specified "
"in decimal, octal (with a leading I<0>), or hexadecimal, with a leading "
"I<0X>).  Addresses in any of these forms are collectively termed I<IPV4 "
"numbers-and-dots notation>.  The form that uses exactly four decimal numbers "
"is referred to as I<IPv4 dotted-decimal notation> (or sometimes: I<IPv4 "
"dotted-quad notation>)."
msgstr ""
"上記の全ての形式で、ドット区切りのアドレスの各要素は、10 進数、 8 進数 (先頭"
"に I<0> を付ける)、 16 進数 (先頭に I<0X> を付ける) で指定できる。 これらの形"
"式のアドレスをまとめて I<IPv4 の数値とドットによる表記 (IPv4 numbers-and-"
"dots notation)> と呼ぶ。 また、10 進数 4 つだけを使った形式を I<IPv4 のドット"
"区切りの 10 進数表記 (IPv4 dotted-decimal notation)> と呼ぶ (I<IPv4 のドット"
"区切り 4 分割表記 (IPv4 dotted-decimal notation)> と呼ぶこともある)。"

#. type: Plain text
#: build/C/man3/inet.3:145
msgid ""
"B<inet_aton>()  returns 1 if the supplied string was successfully "
"interpreted, or 0 if the string is invalid (B<errno> is I<not> set on error)."
msgstr ""
"B<inet_aton>() は渡された文字列が正常に解釈できた場合 1 を返し、 文字列が不正"
"な場合 0 を返す (エラーの場合に B<errno> はセットI<されない>)。"

#. type: Plain text
#: build/C/man3/inet.3:162
msgid ""
"The B<inet_addr>()  function converts the Internet host address I<cp> from "
"IPv4 numbers-and-dots notation into binary data in network byte order.  If "
"the input is invalid, B<INADDR_NONE> (usually -1) is returned.  Use of this "
"function is problematic because -1 is a valid address (255.255.255.255).  "
"Avoid its use in favor of B<inet_aton>(), B<inet_pton>(3), or "
"B<getaddrinfo>(3), which provide a cleaner way to indicate error return."
msgstr ""
"B<inet_addr>()  関数は、インターネットホストのアドレス I<cp> を、 IPv4 の数値"
"とドットによる表記からネットワークバイトオーダでの バイナリ値へ変換して返"
"す。 入力が不正な場合、 B<INADDR_NONE> (普通は -1) を返す。 -1 は有効なアドレ"
"ス (255.255.255.255) なので、この関数を使うと 問題になるかもしれない。 この関"
"数を使うのは避け、代わりに B<inet_aton>(), B<inet_pton>(3), "
"B<getaddrinfo>(3)  を使うのがよい。 これらの関数の方が、エラーの通知がよりき"
"れいな方法で行われる。"

#. type: Plain text
#: build/C/man3/inet.3:172
msgid ""
"The B<inet_network>()  function converts I<cp>, a string in IPv4 numbers-and-"
"dots notation, into a number in host byte order suitable for use as an "
"Internet network address.  On success, the converted address is returned.  "
"If the input is invalid, -1 is returned."
msgstr ""
"B<inet_network>()  関数は、 IPv4 の数値とドットによる表記の文字列 I<cp> を、 "
"インターネットアドレスとしての使用に適した ホストバイトオーダの数値に変換す"
"る。 成功すると、変換されたアドレスを返す。 入力が不正な場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/inet.3:180
msgid ""
"The B<inet_ntoa>()  function converts the Internet host address I<in>, given "
"in network byte order, to a string in IPv4 dotted-decimal notation.  The "
"string is returned in a statically allocated buffer, which subsequent calls "
"will overwrite."
msgstr ""
"B<inet_ntoa>()  関数は、ネットワークバイトオーダで渡されたインターネットホス"
"トアドレス I<in> を、 IPv4 のドット区切りの 10 進数表記の文字列に変換する。 "
"文字列は静的に割当てられたバッファーに格納されて返されるので、 この後でこの関"
"数を再度呼び出すと文字列は上書きされる。"

#. type: Plain text
#: build/C/man3/inet.3:186
msgid ""
"The B<inet_lnaof>()  function returns the local network address part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""
"B<inet_lnaof>()  関数は、インターネットアドレス I<in> のローカルネットワーク"
"部分を返す。 この返り値はホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:192
msgid ""
"The B<inet_netof>()  function returns the network number part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""
"B<inet_netof>()  関数は、インターネットアドレス I<in> のネットワーク部分を返"
"す。 この返り値はホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:203
msgid ""
"The B<inet_makeaddr>()  function is the converse of B<inet_netof>()  and "
"B<inet_lnaof>().  It returns an Internet host address in network byte order, "
"created by combining the network number I<net> with the local address "
"I<host>, both in host byte order."
msgstr ""
"B<inet_makeaddr>()  関数は B<inet_netof>()  と B<inet_lnaof>()  の逆の機能を"
"持つ。 ネットワーク番号 I<net> と、ローカルアドレス I<host> を 組み合わせて生"
"成した、インターネットホストアドレスを ネットワークバイトオーダで返す。 "
"I<host>, I<net> はともにホストバイトオーダである。"

#. type: Plain text
#: build/C/man3/inet.3:213
msgid ""
"The structure I<in_addr> as used in B<inet_ntoa>(), B<inet_makeaddr>(), "
"B<inet_lnaof>(), and B<inet_netof>()  is defined in I<E<lt>netinet/in."
"hE<gt>> as:"
msgstr ""
"B<inet_ntoa>(), B<inet_makeaddr>(), B<inet_lnaof>(), B<inet_netof>()  で使用"
"する構造体 I<in_addr> は I<E<lt>netinet/in.hE<gt>> で次のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man3/inet.3:217
#, no-wrap
msgid "typedef uint32_t in_addr_t;\n"
msgstr "typedef uint32_t in_addr_t;\n"

#. type: Plain text
#: build/C/man3/inet.3:221
#, no-wrap
msgid ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"
msgstr ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"

#. type: tbl table
#: build/C/man3/inet.3:234
#, no-wrap
msgid ""
"B<inet_aton>(),\n"
"B<inet_addr>(),\n"
msgstr ""
"B<inet_aton>(),\n"
"B<inet_addr>(),\n"

#. type: tbl table
#: build/C/man3/inet.3:237
#, no-wrap
msgid ""
"B<inet_network>(),\n"
"B<inet_ntoa>()"
msgstr ""
"B<inet_network>(),\n"
"B<inet_ntoa>()"

#. type: tbl table
#: build/C/man3/inet.3:241
#, no-wrap
msgid ""
"B<inet_makeaddr>(),\n"
"B<inet_lnaof>(),\n"
msgstr ""
"B<inet_makeaddr>(),\n"
"B<inet_lnaof>(),\n"

#. type: tbl table
#: build/C/man3/inet.3:243
#, no-wrap
msgid "B<inet_netof>()"
msgstr "B<inet_netof>()"

#. type: Plain text
#: build/C/man3/inet.3:249
msgid "B<inet_addr>(), B<inet_ntoa>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "B<inet_addr>(), B<inet_ntoa>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: build/C/man3/inet.3:252
#, fuzzy
#| msgid ""
#| "4.3BSD.  B<inet_addr>()  and B<inet_ntoa>()  are specified in "
#| "POSIX.1-2001.  B<inet_aton>()  is not specified in POSIX.1-2001, but is "
#| "available on most systems."
msgid ""
"B<inet_aton>()  is not specified in POSIX.1, but is available on most "
"systems."
msgstr ""
"4.3BSD.  B<inet_addr>(), B<inet_ntoa>()  は POSIX.1-2001 で規定されている。 "
"B<inet_aton>()  は POSIX.1-2001 で規定されていないが、ほとんどのシステムで利"
"用可能である。"

#. type: Plain text
#: build/C/man3/inet.3:256
msgid ""
"On x86 architectures, the host byte order is Least Significant Byte first "
"(little endian), whereas the network byte order, as used on the Internet, is "
"Most Significant Byte first (big endian)."
msgstr "x86 アーキテクチャーではホストバイトオーダは Least Significant Byte (LSB) first (リトルエンディアン) だが、 インターネットで使われるネットワークバイトオーダは Most Significant Byte (MSB) first (ビッグエンディアン)  である点に注意すること。"

#. type: Plain text
#: build/C/man3/inet.3:265
msgid ""
"B<inet_lnaof>(), B<inet_netof>(), and B<inet_makeaddr>()  are legacy "
"functions that assume they are dealing with I<classful network addresses>.  "
"Classful networking divides IPv4 network addresses into host and network "
"components at byte boundaries, as follows:"
msgstr ""
"B<inet_lnaof>(), B<inet_netof>(), B<inet_makeaddr>()  は過去の名残であり、渡"
"されたアドレスが I<クラスフルネットワークアドレス (classful network "
"addresses)> であると仮定して処理を行う。 クラスフルネットワークアドレスでは、"
"以下にあるように、 IPv4 ネットワークアドレスをバイト境界でネットワーク部とホ"
"スト部に分割する。"

#. type: TP
#: build/C/man3/inet.3:265
#, no-wrap
msgid "Class A"
msgstr "Class A"

#. type: Plain text
#: build/C/man3/inet.3:271
msgid ""
"This address type is indicated by the value 0 in the most significant bit of "
"the (network byte ordered) address.  The network address is contained in the "
"most significant byte, and the host address occupies the remaining three "
"bytes."
msgstr ""
"(ネットワークバイトオーダの) アドレスの最上位ビットが 0 の場合、 このアドレス"
"種別となる。このアドレス種別では、 最上位バイトがネットワークアドレスを表"
"し、 残りの 3 バイトがホストアドレスを表す。"

#. type: TP
#: build/C/man3/inet.3:271
#, no-wrap
msgid "Class B"
msgstr "Class B"

#. type: Plain text
#: build/C/man3/inet.3:277
msgid ""
"This address type is indicated by the binary value 10 in the most "
"significant two bits of the address.  The network address is contained in "
"the two most significant bytes, and the host address occupies the remaining "
"two bytes."
msgstr ""
"(ネットワークバイトオーダの) アドレスの上位側 2 ビットがバイナリ値で 10 の場"
"合、このアドレス種別となる。このアドレス種別では、 上位 2 バイトがネットワー"
"クアドレスを表し、 残りの 2 バイトがホストアドレスを表す。"

#. type: TP
#: build/C/man3/inet.3:277
#, no-wrap
msgid "Class C"
msgstr "Class C"

#. type: Plain text
#: build/C/man3/inet.3:283
msgid ""
"This address type is indicated by the binary value 110 in the most "
"significant three bits of the address.  The network address is contained in "
"the three most significant bytes, and the host address occupies the "
"remaining byte."
msgstr ""
"(ネットワークバイトオーダの) アドレスの上位側 3 ビットがバイナリ値で 110 の場"
"合、このアドレス種別となる。このアドレス種別では、 上位 3 バイトがネットワー"
"クアドレスを表し、 残りの 1 バイトがホストアドレスを表す。"

#. type: Plain text
#: build/C/man3/inet.3:288
msgid ""
"Classful network addresses are now obsolete, having been superseded by "
"Classless Inter-Domain Routing (CIDR), which divides addresses into network "
"and host components at arbitrary bit (rather than byte) boundaries."
msgstr ""
"クラスフルネットワークアドレスは現在では廃止され、 クラスレスドメイン間ルーチ"
"ン (CIDR) に取って代わられた。 CIDR では、アドレスを任意のビット境界 (バイト"
"境界ではない) で ネットワーク部とホスト部に分割する。"

#. type: Plain text
#: build/C/man3/inet.3:295
msgid ""
"An example of the use of B<inet_aton>()  and B<inet_ntoa>()  is shown "
"below.  Here are some example runs:"
msgstr ""
"以下は B<inet_aton>()  と B<inet_ntoa>()  の使用例である。このように実行す"
"る。"

#. type: Plain text
#: build/C/man3/inet.3:302
#, no-wrap
msgid ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"
msgstr ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"

#. type: Plain text
#: build/C/man3/inet.3:311
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/inet.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"

#. type: Plain text
#: build/C/man3/inet.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet.3:326
#, no-wrap
msgid ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        fprintf(stderr, \"Invalid address\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        fprintf(stderr, \"Invalid address\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet.3:330
#, no-wrap
msgid ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/inet.3:342
msgid ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_net_pton>(3), B<inet_ntop>(3), B<inet_pton>(3), "
"B<hosts>(5), B<networks>(5)"
msgstr ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_net_pton>(3), B<inet_ntop>(3), B<inet_pton>(3), "
"B<hosts>(5), B<networks>(5)"

#. type: TH
#: build/C/man3/inet_net_pton.3:25
#, no-wrap
msgid "INET_NET_PTON"
msgstr "INET_NET_PTON"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:28
msgid "inet_net_pton, inet_net_ntop - Internet network number conversion"
msgstr "inet_net_pton, inet_net_ntop - インターネットのネットワーク番号の変換"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:34
#, no-wrap
msgid ""
"B<int inet_net_pton(int >I<af>B<, const char *>I<pres>B<,>\n"
"B<                  void *>I<netp>B<, size_t >I<nsize>B<);>\n"
msgstr ""
"B<int inet_net_pton(int >I<af>B<, const char *>I<pres>B<,>\n"
"B<                  void *>I<netp>B<, size_t >I<nsize>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:37
#, no-wrap
msgid ""
"B<char *inet_net_ntop(int >I<af>B<, const void *>I<netp>B<, int >I<bits>B<,>\n"
"B<                    char *>I<pres>B<, size_t >I<psize>B<);>\n"
msgstr ""
"B<char *inet_net_ntop(int >I<af>B<, const void *>I<netp>B<, int >I<bits>B<,>\n"
"B<                    char *>I<pres>B<, size_t >I<psize>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:40 build/C/man3/resolver.3:110
msgid "Link with I<-lresolv>."
msgstr "I<-lresolv> でリンクする。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:48
msgid "B<inet_net_pton>(), B<inet_net_ntop>():"
msgstr "B<inet_net_pton>(), B<inet_net_ntop>():"

#. type: TP
#: build/C/man3/inet_net_pton.3:51
#, no-wrap
msgid "Since glibc 2.20:"
msgstr "glibc 2.20 以降:"

#. type: TP
#: build/C/man3/inet_net_pton.3:54
#, no-wrap
msgid "Before glibc 2.20:"
msgstr "glibc 2.20 より前:"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:63
msgid ""
"These functions convert network numbers between presentation (i.e., "
"printable) format and network (i.e., binary) format."
msgstr ""
"これらの関数は (印字可能な) 表記形式とネットワーク形式 (バイナリー形式) 間の"
"変換を行う。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:69
msgid ""
"For both functions, I<af> specifies the address family for the conversion; "
"the only supported value is B<AF_INET>."
msgstr ""
"どちらの関数でも I<af> は変換を行うアドレスファミリーを指定する。 サポートさ"
"れている値は B<AF_INET> だけである。"

#. type: SS
#: build/C/man3/inet_net_pton.3:69
#, no-wrap
msgid "inet_net_pton()"
msgstr "inet_net_pton()"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:88
msgid ""
"The B<inet_net_pton>()  function converts I<pres>, a null-terminated string "
"containing an Internet network number in presentation format to network "
"format.  The result of the conversion, which is in network byte order, is "
"placed in the buffer pointed to by I<net>.  (The I<netp> argument typically "
"points to an I<in_addr> structure.)  The I<nsize> argument specifies the "
"number of bytes available in I<netp>."
msgstr ""
"B<inet_net_pton>() 関数は、 表記形式でインターネットネットワーク番号を格納し"
"た NULL 終端された文字列である I<pres> をネットワーク形式に変換する。 ネット"
"ワークバイトオーダーの変換結果は I<netp> が指すバッファーに格納される "
"(I<netp> 引数は通常 I<in_addr> 構造体を指している)。 I<nsize> 引数は "
"I<netp> で利用可能なバイト数を示す。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:96
msgid ""
"On success, B<inet_net_pton>()  returns the number of bits in the network "
"number field of the result placed in I<netp>.  For a discussion of the input "
"presentation format and the return value, see NOTES."
msgstr ""
"成功すると B<inet_net_pton>() は I<netp> に格納した結果のネットワーク番号"
"フィールドのビット数を返す。 入力の表記形式と返り値に関する議論は「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:106
msgid ""
"I<Note>: the buffer pointed to by I<netp> should be zeroed out before "
"calling B<inet_net_pton>(), since the call writes only as many bytes as are "
"required for the network number (or as are explicitly specified by I<pres>), "
"which may be less than the number of bytes in a complete network address."
msgstr ""
"I<注意>: I<netp> が指すバッファーは B<inet_net_pton>() の呼び出し前に 0 で埋"
"めるべきである。 呼び出しではネットワーク番号で必要なバイトだけが書き込ま"
"れ、 そのバイト数は完全なネットワークアドレスのバイト数よりも少ないこともあ"
"る。"

#. type: SS
#: build/C/man3/inet_net_pton.3:106
#, no-wrap
msgid "inet_net_ntop()"
msgstr "inet_net_ntop()"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:118
msgid ""
"The B<inet_net_ntop>()  function converts the network number in the buffer "
"pointed to by I<netp> to presentation format; I<*netp> is interpreted as a "
"value in network byte order.  The I<bits> argument specifies the number of "
"bits in the network number in I<*netp>."
msgstr ""
"B<inet_net_ntop>() 関数は I<netp> が指すバッファーのネットワーク番号を表記形"
"式に変換する。 I<*netp> はネットワークバイトオーダーでの値として解釈される。 "
"I<bits> 引数は I<*netp> のネットワーク番号のビット数を指定する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:129
msgid ""
"The null-terminated presentation-format string is placed in the buffer "
"pointed to by I<pres>.  The I<psize> argument specifies the number of bytes "
"available in I<pres>.  The presentation string is in CIDR format: a dotted-"
"decimal number representing the network address, followed by a slash, and "
"the size of the network number in bits."
msgstr ""
"NULL 終端された表記形式の文字列は I<pres> が指すバッファーに格納される。 "
"I<psize> 引数は I<pres> で利用可能なバイト数を指定する。 表記形式は CIDR 形"
"式、 つまり、 ネットワークアドレスを表すドット区切りの 10 進数に、 スラッシュ"
"とネットワーク番号のビットサイズが続く形式である。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:136
msgid ""
"On success, B<inet_net_pton>()  returns the number of bits in the network "
"number.  On error, it returns -1, and I<errno> is set to indicate the cause "
"of the error."
msgstr ""
"成功すると B<inet_net_pton>() はネットワーク番号のビット数を返す。 エラーの場"
"合、 -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:144
msgid ""
"On success, B<inet_net_ntop>()  returns I<pres>.  On error, it returns NULL, "
"and I<errno> is set to indicate the cause of the error."
msgstr ""
"成功すると B<inet_net_ntop>() は I<pres> を返す。 エラーの場合、 NULL を返"
"し、 I<errno> にエラーを示す値がセットされる。"

#. type: TP
#: build/C/man3/inet_net_pton.3:145 build/C/man3/inet_ntop.3:92
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:150
msgid "I<af> specified a value other than B<AF_INET>."
msgstr "I<af> に B<AF_INET> 以外の値が指定された。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:153
msgid "The size of the output buffer was insufficient."
msgstr "出力バッファーのサイズが十分でなかった。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:158
msgid "(B<inet_net_pton>())  I<pres> was not in correct presentation format."
msgstr "(B<inet_net_pton>() の場合) I<pres> が正しい表記形式ではなかった。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:164
msgid ""
"The B<inet_net_pton>()  and B<inet_net_ntop>()  functions are nonstandard, "
"but widely available."
msgstr ""
"関数 B<inet_net_pton>() と B<inet_net_ntop>() は非標準だが、多くのシステムで"
"利用可能である。"

#. type: SS
#: build/C/man3/inet_net_pton.3:165
#, no-wrap
msgid "Input presentation format for inet_net_pton()"
msgstr "inet_net_pton() の入力の表記形式"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:169
msgid ""
"The network number may be specified either as a hexadecimal value or in "
"dotted-decimal notation."
msgstr ""
"ネットワーク番号は、 16 進数値、またはドット区切りの 10 進数表記で指定でき"
"る。"

#.  If the hexadecimal string is short, the remaining nibbles are zeroed.
#. type: Plain text
#: build/C/man3/inet_net_pton.3:174
msgid ""
"Hexadecimal values are indicated by an initial \"0x\" or \"0X\".  The "
"hexadecimal digits populate the nibbles (half octets) of the network number "
"from left to right in network byte order."
msgstr ""
"先頭に \"0x\" か \"0X\" がある場合 16 進数値となる。 16 進数はネットワークバ"
"イトオーダーの左から右へ半オクテット (4 ビット) ずつ順番に埋められる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:178
msgid ""
"In dotted-decimal notation, up to four octets are specified, as decimal "
"numbers separated by dots.  Thus, any of the following forms are accepted:"
msgstr ""
"ドット区切りの 10 進数表記では、 最大 4 つのオクテットをドット区切りの 10 進"
"数で指定する。 したがって、 以下の形式を指定できる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:183
#, no-wrap
msgid ""
"    a.b.c.d\n"
"    a.b.c\n"
"    a.b\n"
"    a\n"
msgstr ""
"    a.b.c.d\n"
"    a.b.c\n"
"    a.b\n"
"    a\n"

#.  Reading other man pages, some other implementations treat
#.  	'c' in a.b.c as a 16-bit number that populates right-most two bytes
#.      'b' in a.b as a 24-bit number that populates right-most three bytes
#. type: Plain text
#: build/C/man3/inet_net_pton.3:191
msgid ""
"Each part is a number in the range 0 to 255 that populates one byte of the "
"resulting network number, going from left to right, in network-byte (big "
"endian) order.  Where a part is omitted, the resulting byte in the network "
"number is zero."
msgstr ""
"各部分は 0 から 255 の範囲の数字で、ネットワーク番号の各バイトに左から右に"
"ネットワークバイトオーダー (ビッグエンディアン) で順番に埋められる。 省略され"
"た部分があれば、 対応するネットワーク番号のバイトは 0 となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:196
msgid ""
"For either hexadecimal or dotted-decimal format, the network number can "
"optionally be followed by a slash and a number in the range 0 to 32, which "
"specifies the size of the network number in bits."
msgstr ""
"16 進数とドット区切りの 10 進数形式のどちらの場合も、 ネットワーク番号の後ろ"
"にスラッシュと 0 から 32 の範囲の数字をオプションで付けることができる。 この"
"数字はネットワーク番号のビット単位のサイズを示すものである。"

#. type: SS
#: build/C/man3/inet_net_pton.3:196
#, no-wrap
msgid "Return value of inet_net_pton()"
msgstr "inet_net_pton() の返り値"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:206
msgid ""
"The return value of B<inet_net_pton>()  is the number of bits in the network "
"number field.  If the input presentation string terminates with a slash and "
"an explicit size value, then that size becomes the return value of "
"B<inet_net_pton>().  Otherwise, the return value, I<bits>, is inferred as "
"follows:"
msgstr ""
"B<inet_net_pton>() の返り値はネットワーク番号フィールドのビット数である。 入"
"力の表記形式の文字列がスラッシュとサイズの明示的な値で終わっている場合、 指定"
"されたサイズが B<inet_net_pton>() の返り値となる。 そうでない場合は、 返り値 "
"I<bits> が以下のようにして推測される。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:212
msgid ""
"If the most significant byte of the network number is greater than or equal "
"to 240, then I<bits> is 32."
msgstr ""
"ネットワーク番号の最上位バイトが 240 以上の場合、 I<bits> は 32 となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:219
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 224, then I<bits> is 4."
msgstr ""
"それ以外で、 ネットワーク番号の最上位バイトが 224 以上の場合、 I<bits> は 4 "
"となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:226
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 192, then I<bits> is 24."
msgstr ""
"それ以外で、 ネットワーク番号の最上位バイトが 192 以上の場合、 I<bits> は 24 "
"となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:233
msgid ""
"Otherwise, if the most significant byte of the network number is greater "
"than or equal to 128, then I<bits> is 16."
msgstr ""
"それ以外で、 ネットワーク番号の最上位バイトが 128 以上の場合、 I<bits> は 16 "
"となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:237
msgid "Otherwise, I<bits> is 8."
msgstr "それ以外の場合、 I<bits> は 8 となる。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:246
msgid ""
"If the resulting I<bits> value from the above steps is greater than or equal "
"to 8, but the number of octets specified in the network number exceed "
"I<bits/8>, then I<bits> is set to 8 times the number of octets actually "
"specified."
msgstr ""
"上記の手順から得られる I<bits> の値が 8 以上だが、 ネットワーク番号で指定され"
"たオクテット数が I<bits/8> より大きい場合、 I<bits> には実際に指定されたオク"
"テット数を 8 倍した値が設定される。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:260
msgid ""
"The program below demonstrates the use of B<inet_net_pton>()  and "
"B<inet_net_ntop>().  It uses B<inet_net_pton>()  to convert the presentation "
"format network address provided in its first command-line argument to binary "
"form, displays the return value from B<inet_net_pton>().  It then uses "
"B<inet_net_ntop>()  to convert the binary form back to presentation format, "
"and displays the resulting string."
msgstr ""
"以下のプログラムは B<inet_net_pton>() と B<inet_net_ntop>() の使用例を示すも"
"のである。 B<inet_net_pton>() を使って、 コマンドラインの最初の引数で渡され"
"た表記形式のネットワークアドレスをバイナリー形式に変換し、 "
"I<inet_net_pton>() の返り値を出力する。 それから B<inet_net_ntop>() を使って"
"バイナリー形式を表記形式に再度戻して、結果の文字列を出力する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:274
msgid ""
"In order to demonstrate that B<inet_net_pton>()  may not write to all bytes "
"of its I<netp> argument, the program allows an optional second command-line "
"argument, a number used to initialize the buffer before B<inet_net_pton>()  "
"is called.  As its final line of output, the program displays all of the "
"bytes of the buffer returned by B<inet_net_pton>()  allowing the user to see "
"which bytes have not been touched by B<inet_net_pton>()."
msgstr ""
"B<inet_net_pton>() が I<netp> 引数のすべてのバイトに書き込むわけではないこ"
"とを示すため、 プログラムにはオプションで 2 番目のコマンドライン引数を指定"
"することができ、 その引数の数字を使って B<inet_net_pton>() を呼び出す前に"
"バッファーを初期化する。 出力の最終行として、 ユーザーがどのバイトが "
"B<inet_net_pton>() によって変更されなかったかを確認できるように、 プログラム"
"は B<inet_net_pton>() が返したバッファーの全バイトを表示する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:278
msgid ""
"An example run, showing that B<inet_net_pton>()  infers the number of bits "
"in the network number:"
msgstr ""
"この実行例では、 B<inet_net_pton>() が推測したネットワーク番号のビット数を表"
"示する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:285
#, no-wrap
msgid ""
"$ B<./a.out 193.168>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a80000\n"
msgstr ""
"$ B<./a.out 193.168>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a80000\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:291
msgid ""
"Demonstrate that B<inet_net_pton>()  does not zero out unused bytes in its "
"result buffer:"
msgstr ""
"B<inet_net_pton>() が結果のバッファーの未使用バイトを 0 埋めしないことを確認"
"する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:298
#, no-wrap
msgid ""
"$ B<./a.out 193.168 0xffffffff>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a800ff\n"
msgstr ""
"$ B<./a.out 193.168 0xffffffff>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.0/24\n"
"Raw address:              c1a800ff\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:306
msgid ""
"Demonstrate that B<inet_net_pton>()  will widen the inferred size of the "
"network number, if the supplied number of bytes in the presentation string "
"exceeds the inferred value:"
msgstr ""
"表記形式の文字列で渡されたバイト数が推測した値より大きい場合、 "
"B<inet_net_pton>() が推測するネットワーク番号のサイズを広げることを確認する。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:313
#, no-wrap
msgid ""
"$ B<./a.out 193.168.1.128>\n"
"inet_net_pton() returned: 32\n"
"inet_net_ntop() yielded:  193.168.1.128/32\n"
"Raw address:              c1a80180\n"
msgstr ""
"$ B<./a.out 193.168.1.128>\n"
"inet_net_pton() returned: 32\n"
"inet_net_ntop() yielded:  193.168.1.128/32\n"
"Raw address:              c1a80180\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:321
msgid ""
"Explicitly specifying the size of the network number overrides any inference "
"about its size (but any extra bytes that are explicitly specified will still "
"be used by B<inet_net_pton>(): to populate the result buffer):"
msgstr ""
"ネットワーク番号のサイズが明示的に指定すると、推測されるネットワーク番号のサ"
"イズが上書きされる (ただし、 明示的に指定された残りのバイトは "
"B<inet_net_pton>() で使用され、結果のバッファーに書き込まれる)。"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:328
#, no-wrap
msgid ""
"$ B<./a.out 193.168.1.128/24>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.1/24\n"
"Raw address:              c1a80180\n"
msgstr ""
"$ B<./a.out 193.168.1.128/24>\n"
"inet_net_pton() returned: 24\n"
"inet_net_ntop() yielded:  193.168.1/24\n"
"Raw address:              c1a80180\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:333
#, no-wrap
msgid "/* Link with \"-lresolv\" */\n"
msgstr "/* \"-lresolv\" でリンクする */\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:337
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:340
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:347
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf[100];\n"
"    struct in_addr addr;\n"
"    int bits;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf[100];\n"
"    struct in_addr addr;\n"
"    int bits;\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:354
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr,\n"
"                \"Usage: %s presentation-form [addr-init-value]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr,\n"
"                \"Usage: %s presentation-form [addr-init-value]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:360
#, no-wrap
msgid ""
"    /* If argv[2] is supplied (a numeric value), use it to initialize\n"
"       the output buffer given to inet_net_pton(), so that we can see\n"
"       that inet_net_pton() initializes only those bytes needed for\n"
"       the network number. If argv[2] is not supplied, then initialize\n"
"       the buffer to zero (as is recommended practice). */\n"
msgstr ""
"    /* argv[2] (数値) が指定されると、その数字を使って inet_net_pton()\n"
"       に渡す出力バッファーを初期化する。これにより inet_net_pton() が\n"
"       ネットワーク番号に必要なバイトだけを書き込むことを確認できるよう\n"
"       にする。 argv[2] が指定されなかった場合、バッファーは 0 で初期化\n"
"       する (これが推奨される方法である)。 */\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:362
#, no-wrap
msgid "    addr.s_addr = (argc E<gt> 2) ? strtod(argv[2], NULL) : 0;\n"
msgstr "    addr.s_addr = (argc E<gt> 2) ? strtod(argv[2], NULL) : 0;\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:364
#, no-wrap
msgid "    /* Convert presentation network number in argv[1] to binary */\n"
msgstr "    /* argv[1] の表記形式のネットワーク番号をバイナリー形式に変換する */\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:368
#, no-wrap
msgid ""
"    bits = inet_net_pton(AF_INET, argv[1], &addr, sizeof(addr));\n"
"    if (bits == -1)\n"
"        errExit(\"inet_net_ntop\");\n"
msgstr ""
"    bits = inet_net_pton(AF_INET, argv[1], &addr, sizeof(addr));\n"
"    if (bits == -1)\n"
"        errExit(\"inet_net_ntop\");\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:370
#, no-wrap
msgid "    printf(\"inet_net_pton() returned: %d\\en\", bits);\n"
msgstr "    printf(\"inet_net_pton() returned: %d\\en\", bits);\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:373
#, no-wrap
msgid ""
"    /* Convert binary format back to presentation, using \\(aqbits\\(aq\n"
"       returned by inet_net_pton() */\n"
msgstr ""
"    /* inet_net_pton() が返した \\(aqbits\\(aq を使って、\n"
"       バイナリー形式を表記形式に変換する */\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:376
#, no-wrap
msgid ""
"    if (inet_net_ntop(AF_INET, &addr, bits, buf, sizeof(buf)) == NULL)\n"
"        errExit(\"inet_net_ntop\");\n"
msgstr ""
"    if (inet_net_ntop(AF_INET, &addr, bits, buf, sizeof(buf)) == NULL)\n"
"        errExit(\"inet_net_ntop\");\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:378
#, no-wrap
msgid "    printf(\"inet_net_ntop() yielded:  %s\\en\", buf);\n"
msgstr "    printf(\"inet_net_ntop() yielded:  %s\\en\", buf);\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:383
#, no-wrap
msgid ""
"    /* Display \\(aqaddr\\(aq in raw form (in network byte order), so we can\n"
"       see bytes not displayed by inet_net_ntop(); some of those bytes\n"
"       may not have been touched by inet_net_ntop(), and so will still\n"
"       have any initial value that was specified in argv[2]. */\n"
msgstr ""
"    /* \\(aqaddr\\(aq を名前の形で (ネットワークバイトオーダーで) 表示する。\n"
"       これにより inet_net_ntop() が表示しないバイトを確認できる。\n"
"       これらのバイトの一部は inet_net_ntop() では変更されない場合があり、\n"
"       その場合 argv[2] で指定された初期値のままになる。 */\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:385
#, no-wrap
msgid "    printf(\"Raw address:              %x\\en\", htonl(addr.s_addr));\n"
msgstr "    printf(\"Raw address:              %x\\en\", htonl(addr.s_addr));\n"

#. type: Plain text
#: build/C/man3/inet_net_pton.3:392
msgid "B<inet>(3), B<networks>(5)"
msgstr "B<inet>(3), B<networks>(5)"

#. type: TH
#: build/C/man3/inet_ntop.3:26
#, no-wrap
msgid "INET_NTOP"
msgstr "INET_NTOP"

#. type: Plain text
#: build/C/man3/inet_ntop.3:29
msgid "inet_ntop - convert IPv4 and IPv6 addresses from binary to text form"
msgstr "inet_ntop - IPv4/IPv6 アドレスをバイナリ形式からテキスト形式に変換する"

#. type: Plain text
#: build/C/man3/inet_ntop.3:35
#, no-wrap
msgid ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"
msgstr ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_ntop.3:48
msgid ""
"This function converts the network address structure I<src> in the I<af> "
"address family into a character string.  The resulting string is copied to "
"the buffer pointed to by I<dst>, which must be a non-null pointer.  The "
"caller specifies the number of bytes available in this buffer in the "
"argument I<size>."
msgstr ""
"この関数は、 I<af> アドレスファミリーのネットワークアドレス構造体 I<src> を文"
"字列に変換する。 変換結果の文字列は、 I<dst> が指すバッファーにコピーされ"
"る。 I<dst> は NULL でないポインターでなければならない。 呼び出し時に、この"
"バッファーで利用できるバイト数を 引数 I<size> に指定する。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:57
msgid ""
"B<inet_ntop>()  extends the B<inet_ntoa>(3)  function to support multiple "
"address families, B<inet_ntoa>(3)  is now considered to be deprecated in "
"favor of B<inet_ntop>().  The following address families are currently "
"supported:"
msgstr ""
"B<inet_ntop>()  は B<inet_ntoa>(3)  関数を拡張して複数のアドレスファミリーを"
"扱えるようにしたものである。 今後は B<inet_ntoa>(3)  は使わず、 "
"B<inet_ntop>()  を使うようにすると良いだろう。 現在サポートされているアドレス"
"ファミリーは以下の通り:"

#. type: Plain text
#: build/C/man3/inet_ntop.3:70
msgid ""
"I<src> points to a I<struct in_addr> (in network byte order)  which is "
"converted to an IPv4 network address in the dotted-decimal format, \"I<ddd."
"ddd.ddd.ddd>\".  The buffer I<dst> must be at least B<INET_ADDRSTRLEN> bytes "
"long."
msgstr ""
"この場合 I<src> は (ネットワークバイトオーダーの)  I<struct in_addr> へのポイ"
"ンターとみなされ、この構造体の内容が ドット区切りの 10 進数形式 \"I<ddd.ddd."
"ddd.ddd>\" の IPv4 ネットワークアドレスに変換される。 バッファー I<dst> は少"
"なくとも B<INET_ADDRSTRLEN> バイトの長さを持たなければならない。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:83
msgid ""
"I<src> points to a I<struct in6_addr> (in network byte order)  which is "
"converted to a representation of this address in the most appropriate IPv6 "
"network address format for this address.  The buffer I<dst> must be at least "
"B<INET6_ADDRSTRLEN> bytes long."
msgstr ""
"この場合 I<src> は (ネットワークバイトオーダーの)  I<struct in6_addr> へのポ"
"インターとみなされ、この構造体の内容が、 (このアドレスに対してもっとも適切"
"な)  IPv6 ネットワークアドレスの表示形式に変換される。 バッファー I<dst> は少"
"なくとも B<INET6_ADDRSTRLEN> バイトの長さを持たなければならない。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:91
msgid ""
"On success, B<inet_ntop>()  returns a non-null pointer to I<dst>.  NULL is "
"returned if there was an error, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<inet_ntop>()  は I<dst> への (NULL でない) ポインターを返す。 "
"エラーがあった場合は NULL を返し、 I<errno> をエラーを示す値に適切に設定す"
"る。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:96
msgid "I<af> was not a valid address family."
msgstr "I<af> がサポートされているアドレスファミリーでなかった。"

#. type: TP
#: build/C/man3/inet_ntop.3:96
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man3/inet_ntop.3:100
msgid "The converted address string would exceed the size given by I<size>."
msgstr ""
"変換されたアドレス文字列の長さが I<size> で指定されたサイズを超過してしまう。"

#. type: tbl table
#: build/C/man3/inet_ntop.3:110
#, no-wrap
msgid "B<inet_ntop>()"
msgstr "B<inet_ntop>()"

#.  2.1.3: size_t, 2.1.91: socklen_t
#. type: Plain text
#: build/C/man3/inet_ntop.3:125
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that RFC\\ 2553 defines a prototype where "
"the last argument I<size> is of type I<size_t>.  Many systems follow RFC\\ "
"2553.  Glibc 2.0 and 2.1 have I<size_t>, but 2.2 and later have I<socklen_t>."
msgstr "POSIX.1-2001. POSIX.1-2008, RFC\\ 2553 では最後の引数 I<size> のプロトタイプを I<size_t> 型と定義している。多くのシステムでは RFC\\ 2553 にしたがっている。 glibc 2.0 と 2.1 では I<size_t> だが、 glibc 2.2 以降では I<socklen_t> となっている。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:128
msgid "B<AF_INET6> converts IPv4-mapped IPv6 addresses into an IPv6 format."
msgstr ""
"B<AF_INET6> は IPv4 がマップされた IPv6 アドレスを IPv6 形式に変換してしま"
"う。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:131
msgid "See B<inet_pton>(3)."
msgstr "B<inet_pton>(3)  を参照。"

#. type: Plain text
#: build/C/man3/inet_ntop.3:135
msgid "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"
msgstr "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"

#. type: TH
#: build/C/man3/inet_pton.3:27
#, no-wrap
msgid "INET_PTON"
msgstr "INET_PTON"

#. type: Plain text
#: build/C/man3/inet_pton.3:30
msgid "inet_pton - convert IPv4 and IPv6 addresses from text to binary form"
msgstr "inet_pton - IPv4/IPv6 アドレスをテキスト形式からバイナリ形式に変換する"

#. type: Plain text
#: build/C/man3/inet_pton.3:35
#, no-wrap
msgid "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"
msgstr "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:53
#, fuzzy
#| msgid ""
#| "This function converts the character string I<src> into a network address "
#| "structure in the I<af> address family, then copies the network address "
#| "structure to I<dst>.  The I<af> argument must be either B<AF_INET> or "
#| "B<AF_INET6>."
msgid ""
"This function converts the character string I<src> into a network address "
"structure in the I<af> address family, then copies the network address "
"structure to I<dst>.  The I<af> argument must be either B<AF_INET> or "
"B<AF_INET6>.  I<dst> is written in network byte order."
msgstr ""
"この関数は文字列 I<src> を、アドレスファミリー I<af> のネットワークアドレス構"
"造体に変換し、 I<dst> にコピーする。 I<af> 引数は B<AF_INET> か "
"B<AF_INET6> のどちらかでなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:55
msgid "The following address families are currently supported:"
msgstr "現在サポートされているアドレスファミリーは以下の通りである。"

#. type: Plain text
#: build/C/man3/inet_pton.3:69
msgid ""
"I<src> points to a character string containing an IPv4 network address in "
"dotted-decimal format, \"I<ddd.ddd.ddd.ddd>\", where I<ddd> is a decimal "
"number of up to three digits in the range 0 to 255.  The address is "
"converted to a I<struct in_addr> and copied to I<dst>, which must be "
"I<sizeof(struct in_addr)> (4) bytes (32 bits) long."
msgstr ""
"I<src> はドット区切りの 10 進数形式 \"I<ddd.ddd.ddd.ddd>\" の IPv4 ネットワー"
"クアドレス文字列へのポインターである。 I<ddd> は 0 から 255 までの範囲の最大 "
"3 桁の 10 進数である。 このアドレスは I<struct in_addr> に変換されて I<dst> "
"にコピーされる。 I<dst> の長さは I<sizeof(struct in_addr)> (4) バイト (32ビッ"
"ト) でなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:81
msgid ""
"I<src> points to a character string containing an IPv6 network address.  The "
"address is converted to a I<struct in6_addr> and copied to I<dst>, which "
"must be I<sizeof(struct in6_addr)> (16) bytes (128 bits) long.  The allowed "
"formats for IPv6 addresses follow these rules:"
msgstr ""
"I<src> は IPv6 ネットワークアドレスが格納された文字列へのポインターである。 "
"このアドレスは I<struct in6_addr> に変換されて I<dst> にコピーされる。 "
"I<dst> の長さは I<sizeof(struct in6_addr)> (16) バイト (128 ビット) でなけれ"
"ばならない。 以下の 3 つのルールにしたがった形式が IPv6 アドレスとして入力で"
"きる。"

#. type: IP
#: build/C/man3/inet_pton.3:82 build/C/man7/unix.7:595
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man3/inet_pton.3:89
msgid ""
"The preferred format is I<x:x:x:x:x:x:x:x>.  This form consists of eight "
"hexadecimal numbers, each of which expresses a 16-bit value (i.e., each I<x> "
"can be up to 4 hex digits)."
msgstr ""
"推奨形式は I<x:x:x:x:x:x:x:x> である。この形式は 8 個の 16 進数から構成さ"
"れ、 各々の 16 進数は 16 ビット値を表す (I<x> は最大 4 桁の 16 進数である)。"

#. type: IP
#: build/C/man3/inet_pton.3:89 build/C/man7/unix.7:598
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man3/inet_pton.3:102
msgid ""
"A series of contiguous zero values in the preferred format can be "
"abbreviated to I<::>.  Only one instance of I<::> can occur in an address.  "
"For example, the loopback address I<0:0:0:0:0:0:0:1> can be abbreviated as "
"I<::1>.  The wildcard address, consisting of all zeros, can be written as "
"I<::>."
msgstr ""
"推奨形式の中の連続する 0 の列は I<::> に短縮できる。アドレス中で使用できる "
"I<::> は 1 個だけである。 例えば、ループバックアドレス I<0:0:0:0:0:0:0:1> は "
"I<::1> と短縮できる。 全ビットが 0 で構成されるワイルドカードアドレスは I<::"
"> と記載できる。"

#. type: IP
#: build/C/man3/inet_pton.3:102 build/C/man7/unix.7:601
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man3/inet_pton.3:115
msgid ""
"An alternate format is useful for expressing IPv4-mapped IPv6 addresses.  "
"This form is written as I<x:x:x:x:x:x:d.d.d.d>, where the six leading I<x>s "
"are hexadecimal values that define the six most-significant 16-bit pieces of "
"the address (i.e., 96 bits), and the I<d>s express a value in dotted-decimal "
"notation that defines the least significant 32 bits of the address.  An "
"example of such an address is I<::FFFF:204.152.189.116>."
msgstr ""
"IPv4 をマッピングした IPv6 アドレスを表記するには別の形式が便利である。 この"
"別の形式は I<x:x:x:x:x:x:d.d.d.d> と書くことができる。 最初の 6 個の I<x> は"
"アドレスを 16 ビット単位に区切ったときの上位側 6 個分 (つまり 96 ビット分)  "
"を定義する 16 進数であり、 I<d> の部分はアドレスの下位 32 ビットをドット区切"
"りの 10 進数表記で表したものである。 I<::FFFF:204.152.189.116> はこの形式の例"
"である。"

#. type: Plain text
#: build/C/man3/inet_pton.3:118
msgid ""
"See RFC 2373 for further details on the representation of IPv6 addresses."
msgstr "IPv6 アドレスの表現方法の詳細については RFC 2373 を参照のこと。"

#. type: Plain text
#: build/C/man3/inet_pton.3:131
msgid ""
"B<inet_pton>()  returns 1 on success (network address was successfully "
"converted).  0 is returned if I<src> does not contain a character string "
"representing a valid network address in the specified address family.  If "
"I<af> does not contain a valid address family, -1 is returned and I<errno> "
"is set to B<EAFNOSUPPORT>."
msgstr ""
"成功する (ネットワークアドレスが正常に変換される) と、 B<inet_pton>()  は 1 "
"を返す。 I<src> が指定されたアドレスファミリーに対する 正しいネットワークアド"
"レス表記でない場合には、 0 を返す。 I<af> がサポートされているアドレスファミ"
"リーでない場合には、 -1 を返し、 I<errno> に B<EAFNOSUPPORT> を設定する。"

#. type: tbl table
#: build/C/man3/inet_pton.3:141
#, no-wrap
msgid "B<inet_pton>()"
msgstr "B<inet_pton>()"

#. type: Plain text
#: build/C/man3/inet_pton.3:164
msgid ""
"Unlike B<inet_aton>(3)  and B<inet_addr>(3), B<inet_pton>()  supports IPv6 "
"addresses.  On the other hand, B<inet_pton>()  accepts only IPv4 addresses "
"in dotted-decimal notation, whereas B<inet_aton>(3)  and B<inet_addr>(3)  "
"allow the more general numbers-and-dots notation (hexadecimal and octal "
"number formats, and formats that don't require all four bytes to be "
"explicitly written).  For an interface that handles both IPv6 addresses, and "
"IPv4 addresses in numbers-and-dots notation, see B<getaddrinfo>(3)."
msgstr ""
"B<inet_aton>(3)  や B<inet_addr>(3)  と異なり、 B<inet_pton>()  は IPv6 アド"
"レスに対応している。 一方で、 B<inet_pton>()  が受け付ける IPv4 アドレスは"
"ドット区切りの 10 進数表記だけである。 これに対し、 B<inet_aton>(3)  や "
"B<inet_addr>(3)  ではもっと一般的なドット区切りの数字表記 (16 進数や 8 進数の"
"形式や、 4 バイト全てを明示的に書かなくてもよい形式) が使用できる。 ドット区"
"切りの数字表記で IPv6 アドレスと IPv4 アドレスの両方を扱える インターフェイス"
"については、 B<getaddrinfo>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/inet_pton.3:170
msgid ""
"B<AF_INET6> does not recognize IPv4 addresses.  An explicit IPv4-mapped IPv6 "
"address must be supplied in I<src> instead."
msgstr ""
"B<AF_INET6> は IPv4 アドレスを認識しない。 代わりに IPv4 アドレスをマッピング"
"した IPv6 アドレスを I<src> に与えなければならない。"

#. type: Plain text
#: build/C/man3/inet_pton.3:176
msgid ""
"The program below demonstrates the use of B<inet_pton>()  and "
"B<inet_ntop>(3).  Here are some example runs:"
msgstr ""
"以下のプログラムは B<inet_pton>()  と B<inet_ntop>(3)  の使用例を示すものであ"
"る。 実行すると以下のようになる。"

#. type: Plain text
#: build/C/man3/inet_pton.3:185
#, no-wrap
msgid ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"
msgstr ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:194
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:201
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:206
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:209
#, no-wrap
msgid ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"
msgstr ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:218
#, no-wrap
msgid ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:223
#, no-wrap
msgid ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:225
#, no-wrap
msgid "    printf(\"%s\\en\", str);\n"
msgstr "    printf(\"%s\\en\", str);\n"

#. type: Plain text
#: build/C/man3/inet_pton.3:233
msgid "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"
msgstr "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"

#. type: TH
#: build/C/man7/ip.7:42
#, no-wrap
msgid "IP"
msgstr "IP"

#. type: Plain text
#: build/C/man7/ip.7:45
msgid "ip - Linux IPv4 protocol implementation"
msgstr "ip - Linux IPv4 プロトコルの実装"

#. type: Plain text
#: build/C/man7/ip.7:51 build/C/man7/ipv6.7:93 build/C/man7/raw.7:19
#: build/C/man7/tcp.7:103 build/C/man7/udp.7:19
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr "B<#include E<lt>netinet/in.hE<gt>>"

#. type: Plain text
#: build/C/man7/ip.7:53
msgid "B<#include E<lt>netinet/ip.hE<gt> >/* superset of previous */"
msgstr "B<#include E<lt>netinet/ip.hE<gt> >/* 上記のスーパーセット */"

#. type: Plain text
#: build/C/man7/ip.7:55
msgid "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/ip.7:57
msgid "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/ip.7:59
msgid "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ip.7:65
msgid ""
"Linux implements the Internet Protocol, version 4, described in RFC\\ 791 "
"and RFC\\ 1122.  B<ip> contains a level 2 multicasting implementation "
"conforming to RFC\\ 1112.  It also contains an IP router including a packet "
"filter."
msgstr ""
"Linux は RFC\\ 791 と RFC\\ 1122 で記述されている Internet Protocol, version "
"4 を実装している。 B<ip> には RFC\\ 1112 に準拠した level 2 マルチキャストの"
"実装が含まれている。 またパケットフィルタ機能を含む IP ルーターも実装されてい"
"る。"

#. type: Plain text
#: build/C/man7/ip.7:69
msgid ""
"The programming interface is BSD-sockets compatible.  For more information "
"on sockets, see B<socket>(7)."
msgstr ""
"プログラミングインターフェースは BSD ソケットと互換である。 ソケットに関する"
"より詳細な情報は B<socket>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/ip.7:72
msgid "An IP socket is created using B<socket>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:74
#, no-wrap
msgid "    socket(AF_INET, socket_type, protocol);\n"
msgstr "    socket(AF_INET, socket_type, protocol);\n"

#. type: Plain text
#: build/C/man7/ip.7:84
msgid ""
"Valid socket types include B<SOCK_STREAM> to open a stream socket, "
"B<SOCK_DGRAM> to open a datagram socket, and B<SOCK_RAW> to open a "
"B<raw>(7)  socket to access the IP protocol directly."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:90
msgid ""
"I<protocol> is the IP protocol in the IP header to be received or sent.  "
"Valid values for I<protocol> include:"
msgstr ""

#. type: IP
#: build/C/man7/ip.7:90 build/C/man7/ip.7:96 build/C/man7/ip.7:102
#: build/C/man7/ip.7:107
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:96
msgid "0 and B<IPPROTO_TCP> for B<tcp>(7)  stream sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:102
msgid "0 and B<IPPROTO_UDP> for B<udp>(7)  datagram sockets;"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:107
msgid "B<IPPROTO_SCTP> for B<sctp>(7)  stream sockets; and"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:112
msgid "B<IPPROTO_UDPLITE> for B<udplite>(7)  datagram sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:117
msgid ""
"For B<SOCK_RAW> you may specify a valid IANA IP protocol defined in RFC\\ "
"1700 assigned numbers."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:139
msgid ""
"When a process wants to receive new incoming packets or connections, it "
"should bind a socket to a local interface address using B<bind>(2).  In this "
"case, only one IP socket may be bound to any given local (address, port) "
"pair.  When B<INADDR_ANY> is specified in the bind call, the socket will be "
"bound to I<all> local interfaces.  When B<listen>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port with "
"the local address set to B<INADDR_ANY>.  When B<connect>(2)  is called on an "
"unbound socket, the socket is automatically bound to a random free port or "
"to a usable shared port with the local address set to B<INADDR_ANY>."
msgstr ""
"あるプロセスで、やってくるパケットを受信したり 接続要求を受けたりしたい場合に"
"は、 そのプロセスはローカルなインターフェースアドレスに、 B<bind>(2) を用いて"
"ソケットをバインドしなければならない。 この場合、 ローカルの「アドレスとポー"
"ト」のペアに対してバインドできる IP ソケットは一つだけである。 B<bind>(2) の"
"呼び出しで B<INADDR_ANY> が指定されていた場合は、 ソケットは I<すべて> のロー"
"カルインターフェースにバインドされる。 B<listen>(2) がバインドされていないソ"
"ケットに対してコールされると、 そのソケットは、 ローカルポートはランダムに選"
"択された空いているポートで、 ローカルアドレスは B<INADDR_ANY> で自動的にバイ"
"ンドされる。 B<connect>(2) がバインドされていないソケットに対してコールされる"
"と、 そのソケットは、 ローカルポートはランダムに選択された空いているポートか"
"未使用の共有ポートで、 ローカルアドレスは B<INADDR_ANY> で自動的にバインドさ"
"れる。"

#. type: Plain text
#: build/C/man7/ip.7:145
msgid ""
"A TCP local socket address that has been bound is unavailable for some time "
"after closing, unless the B<SO_REUSEADDR> flag has been set.  Care should be "
"taken when using this flag as it makes TCP less reliable."
msgstr ""
"B<SO_REUSEADDR> フラグがセットされていない場合には、 バインドされていた TCP "
"ローカルソケットアドレスは クローズされた後しばらくの間使えなくなる。 "
"B<SO_REUSEADDR> フラグを使うと TCP の信頼性を低下させるので、 使うときには注"
"意が必要である。"

#. type: Plain text
#: build/C/man7/ip.7:156
msgid ""
"An IP socket address is defined as a combination of an IP interface address "
"and a 16-bit port number.  The basic IP protocol does not supply port "
"numbers, they are implemented by higher level protocols like B<udp>(7)  and "
"B<tcp>(7).  On raw sockets I<sin_port> is set to the IP protocol."
msgstr ""
"IP ソケットアドレスは、 IP インターフェースアドレスと 16ビットのポート番号の"
"組み合わせで定義される。 IP プロトコルそのものはポート番号を扱わない。 ポート"
"番号は、 B<udp>(7)  や B<tcp>(7)  といった、上位のプロトコルで実装される。 "
"raw ソケットでは、 I<sin_port> が IP プロトコルにセットされる。"

#. type: Plain text
#: build/C/man7/ip.7:164
#, no-wrap
msgid ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"
msgstr ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:169
#, no-wrap
msgid ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"
msgstr ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:195
#, fuzzy
#| msgid ""
#| "I<sin_family> is always set to B<AF_INET>.  This is required; in Linux "
#| "2.2 most networking functions return B<EINVAL> when this setting is "
#| "missing.  I<sin_port> contains the port in network byte order.  The port "
#| "numbers below 1024 are called I<privileged ports> (or sometimes: "
#| "I<reserved ports>).  Only privileged processes (i.e., those having the "
#| "B<CAP_NET_BIND_SERVICE> capability) may B<bind>(2)  to these sockets.  "
#| "Note that the raw IPv4 protocol as such has no concept of a port, they "
#| "are implemented only by higher protocols like B<tcp>(7)  and B<udp>(7)."
msgid ""
"I<sin_family> is always set to B<AF_INET>.  This is required; in Linux 2.2 "
"most networking functions return B<EINVAL> when this setting is missing.  "
"I<sin_port> contains the port in network byte order.  The port numbers below "
"1024 are called I<privileged ports> (or sometimes: I<reserved ports>).  Only "
"a privileged process (on Linux: a process that has the "
"B<CAP_NET_BIND_SERVICE> capability in the user namespace governing its "
"network namespace) may B<bind>(2)  to these sockets.  Note that the raw IPv4 "
"protocol as such has no concept of a port, they are implemented only by "
"higher protocols like B<tcp>(7)  and B<udp>(7)."
msgstr ""
"I<sin_familiy> には常に B<AF_INET> をセットする。これは必須である。 Linux "
"2.2 では、このセットを忘れると ほとんどのネットワーク関数は B<EINVAL> を返す"
"ようになっている。 I<sin_port> にはポート番号をネットワークバイトオーダーで指"
"定する。 1024 未満のポート番号は I<特権ポート (privileged ports)> と呼ばれる "
"(I<予約ポート (reserved ports)> とも時々呼ばれる)。 特権プロセス "
"(B<CAP_NET_BIND_SERVICE> ケーパビリティを持つプロセス) 以外のプロセスは、これ"
"らのポートには B<bind>(2)  できない。 IPv4 プロトコルそのものにはポートに関す"
"る概念がない。ポートが実装されるのは、 B<tcp>(7)  や B<udp>(7) といった、上位"
"のプロトコルにおいてのみである。"

#. type: Plain text
#: build/C/man7/ip.7:217
#, fuzzy
#| msgid ""
#| "I<sin_addr> is the IP host address.  The I<s_addr> member of I<struct "
#| "in_addr> contains the host interface address in network byte order.  "
#| "I<in_addr> should be assigned one of the B<INADDR_*> values (e.g., "
#| "B<INADDR_ANY>)  or set using the B<inet_aton>(3), B<inet_addr>(3), "
#| "B<inet_makeaddr>(3)  library functions or directly with the name resolver "
#| "(see B<gethostbyname>(3))."
msgid ""
"I<sin_addr> is the IP host address.  The I<s_addr> member of I<struct "
"in_addr> contains the host interface address in network byte order.  "
"I<in_addr> should be assigned one of the B<INADDR_*> values (e.g., "
"B<INADDR_LOOPBACK>)  using B<htonl>(3)  or set using the B<inet_aton>(3), "
"B<inet_addr>(3), B<inet_makeaddr>(3)  library functions or directly with the "
"name resolver (see B<gethostbyname>(3))."
msgstr ""
"I<sin_addr> は IP ホストアドレスである。 I<struct in_addr> の I<s_addr> \n"
"メンバには、ホストのインターフェースアドレスを ネットワークバイトオーダーで\n"
"指定する。 I<in_addr> は、B<INADDR_*> の一つ (例えば B<INADDR_ANY>) を代入す"
"る、\n"
"ライブラリ関数 B<inet_aton>(3), B<inet_addr>(3), B<inet_makeaddr>(3) を用い"
"る、\n"
"あるいは名前解決機構 (name resolver) を直接用いる、のどれかで設定すべきであ"
"る。\n"
"(B<gethostbyname>(3) を見よ)。"

#.  Leave a loophole for XTP @)
#. type: Plain text
#: build/C/man7/ip.7:229
msgid ""
"IPv4 addresses are divided into unicast, broadcast, and multicast "
"addresses.  Unicast addresses specify a single interface of a host, "
"broadcast addresses specify all hosts on a network, and multicast addresses "
"address all hosts in a multicast group.  Datagrams to broadcast addresses "
"can be sent or received only when the B<SO_BROADCAST> socket flag is set.  "
"In the current implementation, connection-oriented sockets are allowed to "
"use only unicast addresses."
msgstr ""
"IPv4 アドレスには、ユニキャストアドレス、 ブロードキャストアドレス、マルチ"
"キャストアドレスがある。 ユニキャストアドレスは、あるホストの一つのアドレスを"
"指定する。 ブロードキャストアドレスは、あるネットワーク上の全てのホストを指定"
"する。 マルチキャストアドレスは、マルチキャストグループに所属する 全てのホス"
"トを指定する。ブロードキャストアドレスへのデータグラムは、 B<SO_BROADCAST> ソ"
"ケットフラグがセットされていないと送信・受信できない。 現在の実装では、接続指"
"向のソケットにはユニキャストアドレスしか使えない。"

#. type: Plain text
#: build/C/man7/ip.7:237
msgid ""
"Note that the address and the port are always stored in network byte order.  "
"In particular, this means that you need to call B<htons>(3)  on the number "
"that is assigned to a port.  All address/port manipulation functions in the "
"standard library work in network byte order."
msgstr ""
"アドレスとポートは常にネットワークバイトオーダーで格納されることに注意せよ。 "
"具体的には、ポートを指定する数値には B<htons>(3)  を呼び出す必要がある。 標準"
"ライブラリにあるアドレス/ポート操作関数は すべてネットワークバイトオーダーで"
"動作する。"

#. type: Plain text
#: build/C/man7/ip.7:250
msgid ""
"There are several special addresses: B<INADDR_LOOPBACK> (127.0.0.1)  always "
"refers to the local host via the loopback device; B<INADDR_ANY> (0.0.0.0)  "
"means any address for binding; B<INADDR_BROADCAST> (255.255.255.255)  means "
"any host and has the same effect on bind as B<INADDR_ANY> for historical "
"reasons."
msgstr ""
"特別なアドレスがいくつか存在する: B<INADDR_LOOPBACK>(127.0.0.1)  は loopback "
"デバイスを通して常にローカルなホストを参照する。 B<INADDR_ANY>(0.0.0.0)  は任"
"意のアドレスを意味し、バインド用である。 "
"B<INADDR_BROADCAST>(255.255.255.255)  は任意のホストを意味し、歴史的理由か"
"ら、バインドの際には B<INADDR_ANY> と同じ効果になる。"

#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:259
msgid ""
"IP supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IP is B<IPPROTO_IP>.  A boolean integer flag is zero when it is false, "
"otherwise true."
msgstr ""
"IP にはプロトコル固有のソケットオプションがいくつか存在し、 "
"B<setsockopt>(2)  で設定が、 B<getsockopt>(2)  で取得ができる。 IP のソケット"
"オプションレベルは B<IPPROTO_IP> である。 ブール整数値のフラグでは、 0 は偽、"
"それ以外は真を意味する。"

#. type: Plain text
#: build/C/man7/ip.7:266
#, fuzzy
#| msgid ""
#| "Raw socket options can be set with B<setsockopt>(2)  and read with "
#| "B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgid ""
"When an invalid socket option is specified, B<getsockopt>(2)  and "
"B<setsockopt>(2)  fail with the error B<ENOPROTOOPT>."
msgstr ""
"raw ソケットのオプションは、 B<IPPROTO_RAW> ファミリーフラグを与えて "
"B<setsockopt>(2)  を呼べば設定でき、 B<getsockopt>(2)  を呼べば取得できる。"

#. type: TP
#: build/C/man7/ip.7:266
#, no-wrap
msgid "B<IP_ADD_MEMBERSHIP> (since Linux 1.2)"
msgstr "B<IP_ADD_MEMBERSHIP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:272
msgid "Join a multicast group.  Argument is an I<ip_mreqn> structure."
msgstr "マルチキャストグループに参加する。 引数は I<ip_mreqn> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:282
#, no-wrap
msgid ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"
msgstr ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"

#.  (i.e., within the 224.0.0.0-239.255.255.255 range)
#. type: Plain text
#: build/C/man7/ip.7:303
msgid ""
"I<imr_multiaddr> contains the address of the multicast group the application "
"wants to join or leave.  It must be a valid multicast address (or "
"B<setsockopt>(2)  fails with the error B<EINVAL>).  I<imr_address> is the "
"address of the local interface with which the system should join the "
"multicast group; if it is equal to B<INADDR_ANY>, an appropriate interface "
"is chosen by the system.  I<imr_ifindex> is the interface index of the "
"interface that should join/leave the I<imr_multiaddr> group, or 0 to "
"indicate any interface."
msgstr ""
"I<imr_multiaddr> には、アプリケーションが参加または脱退したい マルチキャスト"
"グループのアドレスが入る。 指定するアドレスは有効なマルチキャストアドレスでな"
"ければならない (さもなければ B<setsockopt>(2)  がエラー B<EINVAL> で失敗す"
"る)。 I<imr_address> はシステムがマルチキャストグループに参加する際に用いる "
"ローカルなインターフェースのアドレスである。 これが B<INADDR_ANY> であった場"
"合には、適切なインターフェースがシステムによって選択される。 I<imr_ifindex> "
"は I<imr_multiaddr> グループに参加/脱退するインターフェースの interface "
"index である。 どのインターフェースでもよい場合は 0 にする。"

#. type: Plain text
#: build/C/man7/ip.7:318
#, fuzzy
#| msgid ""
#| "The I<ip_mreqn> structure is available only since Linux 2.2.  For "
#| "compatibility, the old I<ip_mreq> structure (present since Linux 1.2) is "
#| "still supported; it differs from I<ip_mreqn> only by not including the "
#| "I<imr_ifindex> field.  Only valid as a B<setsockopt>(2)."
msgid ""
"The I<ip_mreqn> structure is available only since Linux 2.2.  For "
"compatibility, the old I<ip_mreq> structure (present since Linux 1.2) is "
"still supported; it differs from I<ip_mreqn> only by not including the "
"I<imr_ifindex> field.  (The kernel determines which structure is being "
"passed based on the size passed in I<optlen>.)"
msgstr ""
"I<ip_mreqn> 構造体は Linux 2.2 以降でのみ利用可能である。互換性のため、 古い "
"I<ip_mreq> 構造体 (Linux 1.2 以降で存在する) もまだサポートされている。 "
"I<ip_mreqn> との違いは、 I<imr_ifindex> フィールドを含まないことだけである。 "
"B<setsockopt>(2) でのみ使える。"

#. type: Plain text
#: build/C/man7/ip.7:323
msgid "B<IP_ADD_MEMBERSHIP> is valid only for B<setsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:323
#, no-wrap
msgid "B<IP_ADD_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_ADD_SOURCE_MEMBERSHIP> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:330
msgid ""
"Join a multicast group and allow receiving data only from a specified "
"source.  Argument is an I<ip_mreq_source> structure."
msgstr ""
"マルチキャストグループに参加、指定された送信元からのデータの受信のみを許可す"
"る。 引数は I<ip_mreq_source> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:341
#, no-wrap
msgid ""
"struct ip_mreq_source {\n"
"    struct in_addr imr_multiaddr;  /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imr_interface;  /* IP address of local\n"
"                                      interface */\n"
"    struct in_addr imr_sourceaddr; /* IP address of\n"
"                                      multicast source */\n"
"};\n"
msgstr ""
"struct ip_mreq_source {\n"
"    struct in_addr imr_multiaddr;  /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imr_interface;  /* IP address of local\n"
"                                      interface */\n"
"    struct in_addr imr_sourceaddr; /* IP address of\n"
"                                      multicast source */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:362
msgid ""
"The I<ip_mreq_source> structure is similar to I<ip_mreqn> described under "
"B<IP_ADD_MEMBERSHIP>.  The I<imr_multiaddr> field contains the address of "
"the multicast group the application wants to join or leave.  The "
"I<imr_interface> field is the address of the local interface with which the "
"system should join the multicast group.  Finally, the I<imr_sourceaddr> "
"field contains the address of the source the application wants to receive "
"data from."
msgstr "I<ip_mreq_source> 構造体は B<IP_ADD_MEMBERSHIP> の項で説明した I<ip_mreqn> に似ている。 I<imr_multiaddr> フィールドには、アプリケーションが参加または脱退したいマルチキャストグループのアドレスが入る。 I<imr_interface> フィールドは、 マルチキャストグループに参加する際に システムが使用すべきローカルインターフェースのアドレスである。 I<imr_sourceaddr> フィールドには、アプリケーションがデータを受信したい送信元のアドレスが入る。"

#. type: Plain text
#: build/C/man7/ip.7:365
msgid ""
"This option can be used multiple times to allow receiving data from more "
"than one source."
msgstr ""
"このオプションを複数回使うことで、 複数の送信元からのデータ受信を許可すること"
"ができる。"

#. type: TP
#: build/C/man7/ip.7:365
#, no-wrap
msgid "B<IP_BIND_ADDRESS_NO_PORT> (since Linux 4.2)"
msgstr "B<IP_BIND_ADDRESS_NO_PORT> (Linux 4.2 以降)"

#.  commit 90c337da1524863838658078ec34241f45d8394d
#. type: Plain text
#: build/C/man7/ip.7:375
msgid ""
"Inform the kernel to not reserve an ephemeral port when using B<bind>(2)  "
"with a port number of 0.  The port will later be automatically chosen at "
"B<connect>(2)  time, in a way that allows sharing a source port as long as "
"the 4-tuple is unique."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:375
#, no-wrap
msgid "B<IP_BLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_BLOCK_SOURCE> (since Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:383
msgid ""
"Stop receiving multicast data from a specific source in a given group.  This "
"is valid only after the application has subscribed to the multicast group "
"using either B<IP_ADD_MEMBERSHIP> or B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""
"指定したグループで、指定した送信元からのマルチキャストデータの受信を停止す"
"る。 このオプションは、アプリケーションが  B<IP_ADD_MEMBERSHIP> か "
"B<IP_ADD_SOURCE_MEMBERSHIP> のいずれかを使ってマルチキャストグループに参加し"
"た後でのみ有効である。"

#. type: Plain text
#: build/C/man7/ip.7:388 build/C/man7/ip.7:410 build/C/man7/ip.7:1016
msgid ""
"Argument is an I<ip_mreq_source> structure as described under "
"B<IP_ADD_SOURCE_MEMBERSHIP>."
msgstr ""
"引数は I<ip_mreq_source> 構造体である。 B<IP_ADD_SOURCE_MEMBERSHIP> の項に"
"説明がある。"

#. type: TP
#: build/C/man7/ip.7:388
#, no-wrap
msgid "B<IP_DROP_MEMBERSHIP> (since Linux 1.2)"
msgstr "B<IP_DROP_MEMBERSHIP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:397
msgid ""
"Leave a multicast group.  Argument is an I<ip_mreqn> or I<ip_mreq> structure "
"similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""
"マルチキャストグループから抜ける。引数は B<IP_ADD_MEMBERSHIP> と同様に "
"I<ip_mreqn> または I<ip_mreq> 構造体である。"

#. type: TP
#: build/C/man7/ip.7:397
#, no-wrap
msgid "B<IP_DROP_SOURCE_MEMBERSHIP> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_DROP_SOURCE_MEMBERSHIP> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:405
msgid ""
"Leave a source-specific group\\(emthat is, stop receiving data from a given "
"multicast group that come from a given source.  If the application has "
"subscribed to multiple sources within the same group, data from the "
"remaining sources will still be delivered.  To stop receiving data from all "
"sources at once, use B<IP_DROP_MEMBERSHIP>."
msgstr "送信元を指定してグループから抜ける。 つまり、 指定したマルチキャストグループの指定された送信元からのデータ受信を停止する。 アプリケーションは同じマルチキャストグループで複数の送信元を購読 (subscribe) している場合には、 残りの送信元からのデータの受信は引き続き配信される。 すべての送信元からのデータ受信を一度で停止するには B<IP_DROP_MEMBERSHIP> を使うこと。"

#. type: TP
#: build/C/man7/ip.7:410
#, no-wrap
msgid "B<IP_FREEBIND> (since Linux 2.4)"
msgstr "B<IP_FREEBIND> (Linux 2.4 以降)"

#.  Precisely: 2.4.0-test10
#. type: Plain text
#: build/C/man7/ip.7:423
msgid ""
"If enabled, this boolean option allows binding to an IP address that is "
"nonlocal or does not (yet) exist.  This permits listening on a socket, "
"without requiring the underlying network interface or the specified dynamic "
"IP address to be up at the time that the application is trying to bind to "
"it.  This option is the per-socket equivalent of the I<ip_nonlocal_bind> I</"
"proc> interface described below."
msgstr ""
"このブール値のオプションを有効にすると、ローカルではない IP アドレスや存在\n"
"しない IP アドレスをバインドできるようになる。これを使うと、対応するネット\n"
"ワークインターフェイスがなかったり、アプリケーションがソケットをバインドしよ"
"うと\n"
"する時点で特定の動的 IP アドレスが有効になっていなかったりしても、ソケット"
"を\n"
"接続待ち状態 (listening) にできるようになる。\n"
"このオプションは、下記に説明がある I<ip_nonlocal_bind> I</proc> インターフェ"
"イス\n"
"のソケット単位の設定である。"

#. type: TP
#: build/C/man7/ip.7:423
#, no-wrap
msgid "B<IP_HDRINCL> (since Linux 2.0)"
msgstr "B<IP_HDRINCL> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man7/ip.7:438
#, fuzzy
#| msgid ""
#| "If enabled, the user supplies an IP header in front of the user data.  "
#| "Only valid for B<SOCK_RAW> sockets.  See B<raw>(7)  for more "
#| "information.  When this flag is enabled the values set by B<IP_OPTIONS>, "
#| "B<IP_TTL> and B<IP_TOS> are ignored."
msgid ""
"If enabled, the user supplies an IP header in front of the user data.  Valid "
"only for B<SOCK_RAW> sockets; see B<raw>(7)  for more information.  When "
"this flag is enabled, the values set by B<IP_OPTIONS>, B<IP_TTL>, and "
"B<IP_TOS> are ignored."
msgstr ""
"有効になっていると、ユーザーは IP ヘッダーをユーザーデータの前に与える。 "
"B<SOCK_RAW> ソケットでのみ有効である。詳細は B<raw>(7)  を見よ。このフラグが"
"有効になっていると、 B<IP_OPTIONS>, B<IP_TTL>, B<IP_TOS> は無視される。"

#. type: TP
#: build/C/man7/ip.7:438
#, no-wrap
msgid "B<IP_MSFILTER> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_MSFILTER> (since Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:444
msgid ""
"This option provides access to the advanced full-state filtering API.  "
"Argument is an I<ip_msfilter> structure."
msgstr ""
"このオプションを使うと、 高度なフィルタリング API へアクセスできる。 この "
"API ではすべての状態にアクセスできる。 引数は I<ip_msfilter> 構造体である。"

#. type: Plain text
#: build/C/man7/ip.7:453
#, no-wrap
msgid ""
"struct ip_msfilter {\n"
"    struct in_addr imsf_multiaddr; /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imsf_interface; /* IP address of local\n"
"                                      interface */\n"
"    uint32_t       imsf_fmode;     /* Filter-mode */\n"
msgstr ""
"struct ip_msfilter {\n"
"    struct in_addr imsf_multiaddr; /* IP multicast group\n"
"                                      address */\n"
"    struct in_addr imsf_interface; /* IP address of local\n"
"                                      interface */\n"
"    uint32_t       imsf_fmode;     /* Filter-mode */\n"

#. type: Plain text
#: build/C/man7/ip.7:459
#, no-wrap
msgid ""
"    uint32_t       imsf_numsrc;    /* Number of sources in\n"
"                                      the following array */\n"
"    struct in_addr imsf_slist[1];  /* Array of source\n"
"                                      addresses */\n"
"};\n"
msgstr ""
"    uint32_t       imsf_numsrc;    /* Number of sources in\n"
"                                      the following array */\n"
"    struct in_addr imsf_slist[1];  /* Array of source\n"
"                                      addresses */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:474
msgid ""
"There are two macros, B<MCAST_INCLUDE> and B<MCAST_EXCLUDE>, which can be "
"used to specify the filtering mode.  Additionally, the "
"B<IP_MSFILTER_SIZE>(n)  macro exists to determine how much memory is needed "
"to store I<ip_msfilter> structure with I<n> sources in the source list."
msgstr ""
"B<MCAST_INCLUDE> と B<MCAST_EXCLUDE> の 2 つのマクロがあり、 フィルタリング"
"モードを指定するのに使用できる。 また、 B<IP_MSFILTER_SIZE>(n) マクロがあ"
"り、 送信元リストに I<n> 個の送信元が入った I<ip_msfilter> 構造体を格納するの"
"に必要なメモリー量を判定することができる。"

#. type: Plain text
#: build/C/man7/ip.7:477
msgid ""
"For the full description of multicast source filtering refer to RFC 3376."
msgstr "マルチキャスト送信元フィルタリングの全容は RFC\\ 3376 を参照のこと。"

#. type: TP
#: build/C/man7/ip.7:477
#, no-wrap
msgid "B<IP_MTU> (since Linux 2.2)"
msgstr "B<IP_MTU> (Linux 2.2 以降)"

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:482
#, fuzzy
#| msgid ""
#| "B<getsockopt>(): Retrieve the current known path MTU of the current "
#| "socket.  Only valid when the socket has been connected.  Returns an "
#| "integer."
msgid ""
"Retrieve the current known path MTU of the current socket.  Returns an "
"integer."
msgstr ""
"B<getsockopt>(): ソケットの、既知の path MTU を取得する。ソケットが接続してい"
"る場合のみ有効である。整数を返す。"

#. type: Plain text
#: build/C/man7/ip.7:487
msgid ""
"B<IP_MTU> is valid only for B<getsockopt>(2)  and can be employed only when "
"the socket has been connected."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:487
#, no-wrap
msgid "B<IP_MTU_DISCOVER> (since Linux 2.2)"
msgstr "B<IP_MTU_DISCOVER> (Linux 2.2 以降)"

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:508
msgid ""
"Set or receive the Path MTU Discovery setting for a socket.  When enabled, "
"Linux will perform Path MTU Discovery as defined in RFC\\ 1191 on "
"B<SOCK_STREAM> sockets.  For non-B<SOCK_STREAM> sockets, B<IP_PMTUDISC_DO> "
"forces the don't-fragment flag to be set on all outgoing packets.  It is the "
"user's responsibility to packetize the data in MTU-sized chunks and to do "
"the retransmits if necessary.  The kernel will reject (with B<EMSGSIZE>)  "
"datagrams that are bigger than the known path MTU.  B<IP_PMTUDISC_WANT> will "
"fragment a datagram if needed according to the path MTU, or will set the "
"don't-fragment flag otherwise."
msgstr ""
"ソケットの Path MTU Discovery の設定をセット・取得する。\n"
"有効になっていると、Linux は B<SOCK_STREAM> ソケットに対して\n"
"RFC\\ 1191 で定義されている Path MTU Discovery を行う。\n"
"B<SOCK_STREAM> でないソケットについては、 B<IP_PMTUDISC_DO> をセットする"
"と、\n"
"全ての送信パケットでフラグメント不許可フラグ (don't-fragment flag) が必ず\n"
"セットされるようになる。 B<SOCK_STREAM> でないソケットでは、\n"
"パケットを MTU のサイズの塊に分割したり、必要に応じて再送したりするのは、\n"
"ユーザーが責任を持って行う必要がある。\n"
"既知の Path MTU よりも大きなデータグラムの送信が要求されると、\n"
"カーネルは (B<EMSGSIZE> で) 送信を拒否する。\n"
"B<IP_PMTUDISC_WANT> の場合は、 Path MTU に基づいて必要であればデータグラム\n"
"の分割が行われ、それ以外の場合はフラグメント不許可フラグがセットされる。"

#. type: Plain text
#: build/C/man7/ip.7:516
msgid ""
"The system-wide default can be toggled between B<IP_PMTUDISC_WANT> and "
"B<IP_PMTUDISC_DONT> by writing (respectively, zero and nonzero values) to "
"the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file."
msgstr ""
"システム全体のデフォルトは B<IP_PMTUDISC_WANT> と B<IP_PMTUDISC_DONT> の\n"
"どちらかに設定することができる。設定の変更は、\n"
"I</proc/sys/net/ipv4/ip_no_pmtu_disc> ファイルに、0 (B<IP_PMTUDISC_WANT>) "
"か\n"
"0 以外 (B<IP_PMTUDISC_DONT>) を書き込むことで行う。"

#. type: tbl table
#: build/C/man7/ip.7:520
#, no-wrap
msgid "Path MTU discovery value"
msgstr "Path MTU discovery 値"

#. type: tbl table
#: build/C/man7/ip.7:520
#, no-wrap
msgid "Meaning"
msgstr "意味"

#. type: tbl table
#: build/C/man7/ip.7:521
#, no-wrap
msgid "IP_PMTUDISC_WANT"
msgstr "IP_PMTUDISC_WANT"

#. type: tbl table
#: build/C/man7/ip.7:521
#, no-wrap
msgid "Use per-route settings."
msgstr "ルートごとの設定を用いる。"

#. type: tbl table
#: build/C/man7/ip.7:522
#, no-wrap
msgid "IP_PMTUDISC_DONT"
msgstr "IP_PMTUDISC_DONT"

#. type: tbl table
#: build/C/man7/ip.7:522
#, no-wrap
msgid "Never do Path MTU Discovery."
msgstr "Path MTU Discovery を行わない。"

#. type: tbl table
#: build/C/man7/ip.7:523
#, no-wrap
msgid "IP_PMTUDISC_DO"
msgstr "IP_PMTUDISC_DO"

#. type: tbl table
#: build/C/man7/ip.7:523
#, no-wrap
msgid "Always do Path MTU Discovery."
msgstr "常に Path MTU Discovery を行う。"

#. type: tbl table
#: build/C/man7/ip.7:524
#, no-wrap
msgid "IP_PMTUDISC_PROBE"
msgstr "IP_PMTUDISC_PROBE"

#. type: tbl table
#: build/C/man7/ip.7:524
#, no-wrap
msgid "Set DF but ignore Path MTU."
msgstr "DFビットをセットするが、Path MTU を無視する。"

#. type: Plain text
#: build/C/man7/ip.7:542
msgid ""
"When PMTU discovery is enabled, the kernel automatically keeps track of the "
"path MTU per destination host.  When it is connected to a specific peer with "
"B<connect>(2), the currently known path MTU can be retrieved conveniently "
"using the B<IP_MTU> socket option (e.g., after an B<EMSGSIZE> error "
"occurred).  The path MTU may change over time.  For connectionless sockets "
"with many destinations, the new MTU for a given destination can also be "
"accessed using the error queue (see B<IP_RECVERR>).  A new error will be "
"queued for every incoming MTU update."
msgstr ""
"path MTU discovery が有効になっていると、カーネルは宛先ホストごとに 自動的"
"に\n"
"path MTU を処理する。特定の相手に B<connect>(2) で接続した場合には、\n"
"B<IP_MTU> ソケットオプションを用いれば、既知の path MTU の取得に便利である\n"
"(たとえば B<EMSGSIZE> エラーが起きた後など)。 path MTU は時間とともに変化す"
"る\n"
"かもしれない。 宛先がたくさんあるコネクションレスなソケットでは、 与えられ"
"た\n"
"宛先に対する新しい MTU にも、 エラーキューを用いてアクセスすることができる\n"
"(B<IP_RECVERR> を見よ)。 MTU 更新が到着するごとに、新たなエラーがキューイン"
"グ\n"
"される。"

#. type: Plain text
#: build/C/man7/ip.7:547
msgid ""
"While MTU discovery is in progress, initial packets from datagram sockets "
"may be dropped.  Applications using UDP should be aware of this and not take "
"it into account for their packet retransmit strategy."
msgstr ""
"MTU discovery の進行中には、データグラムソケットからの初期パケットは 到着しな"
"いかもしれない。 UDP を用いるアプリケーションでは、 このことを気にかけてお"
"き、 パケットの再送アルゴリズムにこの分を除外させるべきである。"

#. type: Plain text
#: build/C/man7/ip.7:551
#, fuzzy
#| msgid ""
#| "To bootstrap the path MTU discovery process on unconnected sockets, it is "
#| "possible to start with a big datagram size (up to 64K-headers bytes long) "
#| "and let it shrink by updates of the path MTU."
msgid ""
"To bootstrap the path MTU discovery process on unconnected sockets, it is "
"possible to start with a big datagram size (headers up to 64 kilobytes long) "
"and let it shrink by updates of the path MTU."
msgstr ""
"接続していないソケットに対して path MTU discovery プロセスを立ち上げるには、 "
"大きなデータグラムサイズ (最大 64K ヘッダーバイト長) からはじめて、 path MTU "
"が更新されるまでサイズを縮めていくことも可能である。"

#. type: Plain text
#: build/C/man7/ip.7:560
msgid ""
"To get an initial estimate of the path MTU, connect a datagram socket to the "
"destination address using B<connect>(2)  and retrieve the MTU by calling "
"B<getsockopt>(2)  with the B<IP_MTU> option."
msgstr ""
"path MTU の値をまず見積もってみるには、宛先アドレスに B<connect>(2)  を使って"
"データグラムソケットを接続し、 B<getsockopt>(2)  を B<IP_MTU> オプションとと"
"もに呼び、 MTU を取得することである。"

#. type: Plain text
#: build/C/man7/ip.7:572
msgid ""
"It is possible to implement RFC 4821 MTU probing with B<SOCK_DGRAM> or "
"B<SOCK_RAW> sockets by setting a value of B<IP_PMTUDISC_PROBE> (available "
"since Linux 2.6.22).  This is also particularly useful for diagnostic tools "
"such as B<tracepath>(8)  that wish to deliberately send probe packets larger "
"than the observed Path MTU."
msgstr ""
"B<IP_PMTUDISC_PROBE> (Linux 2.6.22 以降で利用可能) を設定することで、 "
"B<SOCK_DGRAM> や B<SOCK_RAW> のソケットで RFC 4821 の MTU 探索を実装すること"
"が可能である。 また、この機能は、 B<tracepath>(8)  のような診断ツールで特に有"
"用である。これらのツールでは、 観測された Path MTU よりも大きな探索パケットを"
"意図的に 送信しようとする。"

#. type: TP
#: build/C/man7/ip.7:572
#, no-wrap
msgid "B<IP_MULTICAST_ALL> (since Linux 2.6.31)"
msgstr "B<IP_MULTICAST_ALL> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man7/ip.7:586
msgid ""
"This option can be used to modify the delivery policy of multicast messages "
"to sockets bound to the wildcard B<INADDR_ANY> address.  The argument is a "
"boolean integer (defaults to 1).  If set to 1, the socket will receive "
"messages from all the groups that have been joined globally on the whole "
"system.  Otherwise, it will deliver messages only from the groups that have "
"been explicitly joined (for example via the B<IP_ADD_MEMBERSHIP> option) on "
"this particular socket."
msgstr ""
"このオプションを使って、 マルチキャストメッセージの、 ワイルドカードの "
"B<INADDR_ANY> アドレスにバインドされているソケットへの 配送ポリシーを変更する"
"ことができる。 引数はブート値の整数で、 デフォルト値は 1 である。 このオプ"
"ションを 1 に設定されている場合、そのソケットでは、このシステムで参加している"
"すべてのグループからのメッセージが受信される。 それ以外の場合は、そのソケット"
"では、 そのソケットに対して (B<IP_ADD_MEMBERSHIP> などを使って) 明示的に参加"
"が指定されたグループからのメッセージだけが受信される。"

#. type: TP
#: build/C/man7/ip.7:586
#, no-wrap
msgid "B<IP_MULTICAST_IF> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_IF> (Linux 1.2 以降)"

#.  net: IP_MULTICAST_IF setsockopt now recognizes struct mreq
#.  Commit: 3a084ddb4bf299a6e898a9a07c89f3917f0713f7
#. type: Plain text
#: build/C/man7/ip.7:611
msgid ""
"Set the local device for a multicast socket.  The argument for "
"B<setsockopt>(2)  is an I<ip_mreqn> or (since Linux 3.5)  I<ip_mreq> "
"structure similar to B<IP_ADD_MEMBERSHIP>, or an I<in_addr> structure.  (The "
"kernel determines which structure is being passed based on the size passed "
"in I<optlen>.)  For B<getsockopt>(2), the argument is an I<in_addr> "
"structure."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:611
#, no-wrap
msgid "B<IP_MULTICAST_LOOP> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_LOOP> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:615
msgid ""
"Set or read a boolean integer argument that determines whether sent "
"multicast packets should be looped back to the local sockets."
msgstr ""
"マルチキャストパケットをローカルなソケットにループバックするかどうかを 定める"
"ブール値の整数引数を設定・取得する。"

#. type: TP
#: build/C/man7/ip.7:615
#, no-wrap
msgid "B<IP_MULTICAST_TTL> (since Linux 1.2)"
msgstr "B<IP_MULTICAST_TTL> (Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:623
msgid ""
"Set or read the time-to-live value of outgoing multicast packets for this "
"socket.  It is very important for multicast packets to set the smallest TTL "
"possible.  The default is 1 which means that multicast packets don't leave "
"the local network unless the user program explicitly requests it.  Argument "
"is an integer."
msgstr ""
"このソケットから発信されるマルチキャストパケットの time-to-live 値を設定・取"
"得する。 マルチキャストパケットに対しては、できるだけ小さな TTL に設定するこ"
"とがとても重要である。デフォルトは 1 で、 ユーザープログラムが明示的に要求し"
"ない限り マルチキャストパケットはローカルなネットワークから出ないことにな"
"る。 引数に整数を取る。"

#. type: TP
#: build/C/man7/ip.7:623
#, no-wrap
msgid "B<IP_NODEFRAG> (since Linux 2.6.36)"
msgstr "B<IP_NODEFRAG> (Linux 2.6.36 以降)"

#. type: Plain text
#: build/C/man7/ip.7:628
#, fuzzy
#| msgid ""
#| "If enabled (argument is nonzero), the reassembly of outgoing packets is "
#| "disabled in the netfilter layer.  This option is valid only for "
#| "B<SOCK_RAW> sockets.  The argument is an integer."
msgid ""
"If enabled (argument is nonzero), the reassembly of outgoing packets is "
"disabled in the netfilter layer.  The argument is an integer."
msgstr ""
"有効 (引数が 0 以外の場合) になっていると、netfilter 層での出力パケットの\n"
"再構築 (reassembly) が行われなくなる。このオプションは B<SOCK_RAW> ソケット\n"
"においてのみ有効である。引数は整数である。"

#. type: Plain text
#: build/C/man7/ip.7:632
msgid "This option is valid only for B<SOCK_RAW> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:632
#, no-wrap
msgid "B<IP_OPTIONS> (since Linux 2.0)"
msgstr "B<IP_OPTIONS> (Linux 2.0 以降)"

#.  Precisely: 1.3.30
#. type: Plain text
#: build/C/man7/ip.7:661
msgid ""
"Set or get the IP options to be sent with every packet from this socket.  "
"The arguments are a pointer to a memory buffer containing the options and "
"the option length.  The B<setsockopt>(2)  call sets the IP options "
"associated with a socket.  The maximum option size for IPv4 is 40 bytes.  "
"See RFC\\ 791 for the allowed options.  When the initial connection request "
"packet for a B<SOCK_STREAM> socket contains IP options, the IP options will "
"be set automatically to the options from the initial packet with routing "
"headers reversed.  Incoming packets are not allowed to change options after "
"the connection is established.  The processing of all incoming source "
"routing options is disabled by default and can be enabled by using the "
"I<accept_source_route> I</proc> interface.  Other options like timestamps "
"are still handled.  For datagram sockets, IP options can be set only by the "
"local user.  Calling B<getsockopt>(2)  with B<IP_OPTIONS> puts the current "
"IP options used for sending into the supplied buffer."
msgstr ""
"このソケットから送られるパケット全てに付随する IP オプションを 設定・取得す"
"る。オプションを保存しているメモリーバッファーへのポインターと オプションの長"
"さとを引数に取る。 B<setsockopt>(2)  を呼び出すと、ソケットに関連づけられ"
"る IP オプションを設定できる。 IPv4 におけるオプションのサイズの最大値は 40 "
"バイトである。 用いることのできるオプションについては RFC\\ 791 を見よ。 "
"B<SOCK_STREAM> ソケットに対する初期接続要求パケットに IP オプションが含まれて"
"いると、 ルーティングヘッダーを付けて戻されてくる初期パケットの IP オプション"
"に同じオプションがセットされる。接続が確立された後、 やってきたパケットのオプ"
"ションを変更することはできない。 デフォルトでは。外部から受信したパケットの全"
"ての source routing オプション の処理は無効となっており、 I</proc> インター"
"フェースの I<accept_source_route> を使うとこれを有効にできる。これを無効にし"
"ていても timestamps など の他のオプションの処理は行われる。データグラムソケッ"
"トでは、 IP オプションはローカルユーザーしか設定できない。 B<getsockopt>(2)  "
"を B<IP_OPTIONS> をつけて呼ぶと、現在送信に用いられている IP オプションを 引"
"数に与えたバッファーに取得できる。"

#. type: TP
#: build/C/man7/ip.7:661
#, no-wrap
msgid "B<IP_PASSSEC> (since Linux 2.6.17)"
msgstr "B<IP_PASSSEC> (Linux 2.6.17 以降)"

#.  commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
#. type: Plain text
#: build/C/man7/ip.7:674
msgid ""
"If labeled IPSEC or NetLabel is configured on the sending and receiving "
"hosts, this option enables receiving of the security context of the peer "
"socket in an ancillary message of type B<SCM_SECURITY> retrieved using "
"B<recvmsg>(2).  This option is supported only for UDP sockets; for TCP or "
"SCTP sockets, see the description of the B<SO_PEERSEC> option below."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:680 build/C/man7/unix.7:302 build/C/man7/unix.7:314
msgid ""
"The value given as an argument to B<setsockopt>(2)  and returned as the "
"result of B<getsockopt>(2)  is an integer boolean flag."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:687
msgid ""
"The security context returned in the B<SCM_SECURITY> ancillary message is of "
"the same format as the one described under the B<SO_PEERSEC> option below."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:700
msgid ""
"Note: the reuse of the B<SCM_SECURITY> message type for the B<IP_PASSSEC> "
"socket option was likely a mistake, since other IP control messages use "
"their own numbering scheme in the IP namespace and often use the socket "
"option value as the message type.  There is no conflict currently since the "
"IP option with the same value as B<SCM_SECURITY> is B<IP_HDRINCL> and this "
"is never used for a control message type."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:700
#, no-wrap
msgid "B<IP_PKTINFO> (since Linux 2.2)"
msgstr "B<IP_PKTINFO> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:717
msgid ""
"Pass an B<IP_PKTINFO> ancillary message that contains a I<pktinfo> structure "
"that supplies some information about the incoming packet.  This works only "
"for datagram oriented sockets.  The argument is a flag that tells the socket "
"whether the B<IP_PKTINFO> message should be passed or not.  The message "
"itself can be sent/retrieved only as a control message with a packet using "
"B<recvmsg>(2)  or B<sendmsg>(2)."
msgstr ""
"B<IP_PKTINFO> 補助メッセージを渡す。これには到着パケットに関する情報を提供す"
"る I<pktinfo> 構造体が含まれている。 データグラム指向のソケットでしか動作しな"
"い。 引数は B<IP_PKTINFO> メッセージを通過させるかどうかをソケットに知らせ"
"るフラグである。 メッセージ自身は B<recvmsg>(2)  または B<sendmsg>(2)  を用い"
"たパケットの制御メッセージとしてのみ送受信できる。"

#. type: Plain text
#: build/C/man7/ip.7:726
#, no-wrap
msgid ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"
msgstr ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"

#.  This field is grossly misnamed
#. type: Plain text
#: build/C/man7/ip.7:750
msgid ""
"I<ipi_ifindex> is the unique index of the interface the packet was received "
"on.  I<ipi_spec_dst> is the local address of the packet and I<ipi_addr> is "
"the destination address in the packet header.  If B<IP_PKTINFO> is passed to "
"B<sendmsg>(2)  and I<ipi_spec_dst> is not zero, then it is used as the local "
"source address for the routing table lookup and for setting up IP source "
"route options.  When I<ipi_ifindex> is not zero, the primary local address "
"of the interface specified by the index overwrites I<ipi_spec_dst> for the "
"routing table lookup."
msgstr ""
"I<ipi_ifindex> はパケットが受信されたインターフェースの、他と重ならないイン"
"デックスである。 I<ipi_spec_dst> はパケットのローカルアドレスである。 "
"I<ipi_addr> はパケットヘッダーにある宛先アドレスである。 B<IP_PKTINFO> が "
"B<sendmsg>(2)  に渡されて、かつ I<ipi_spec_dst> が 0 以外の場合、 "
"I<ipi_spec_dst> はルーティングテーブルを検索する際にローカルな送信元アドレス"
"として使用され、 IP source route オプションを設定するのにも使用される。 "
"I<ipi_ifindex> が 0 以外の場合、このインデックスによって指定されるインター"
"フェースの プライマリローカルアドレスで I<ipi_spec_dst> を上書きし、ルーティ"
"ングテーブルを検索する。"

#. type: TP
#: build/C/man7/ip.7:750
#, no-wrap
msgid "B<IP_RECVERR> (since Linux 2.2)"
msgstr "B<IP_RECVERR> (Linux 2.2 以降)"

#.  Precisely: 2.1.15
#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:772
msgid ""
"Enable extended reliable error message passing.  When enabled on a datagram "
"socket, all generated errors will be queued in a per-socket error queue.  "
"When the user receives an error from a socket operation, the errors can be "
"received by calling B<recvmsg>(2)  with the B<MSG_ERRQUEUE> flag set.  The "
"I<sock_extended_err> structure describing the error will be passed in an "
"ancillary message with the type B<IP_RECVERR> and the level B<IPPROTO_IP>.  "
"This is useful for reliable error handling on unconnected sockets.  The "
"received data portion of the error queue contains the error packet."
msgstr ""
"エラーメッセージの受け渡しに、信頼性の高い拡張された方法を有効にする。 データ"
"グラムソケットに対して有効になっていると、 発生したエラーは全てソケットごとの"
"エラーキューに保存される。 ユーザーはソケット操作からエラーを受け取ったと"
"き、 B<recvmsg>(2)  を B<MSG_ERRQUEUE> フラグとともに呼べばそのエラーを取得で"
"きる。 そのエラーを記述する I<sock_extended_err> 構造体が、タイプ "
"B<IP_RECVERR>・ レベル B<IPPROTO_IP> の補助メッセージとして渡される。 これは"
"接続志向でないソケットで信頼性の高いエラー処理を行いたい場合に 有用である。エ"
"ラーキューの受信データフラグメントには エラーパケットが含まれる。"

#. type: Plain text
#: build/C/man7/ip.7:778
msgid ""
"The B<IP_RECVERR> control message contains a I<sock_extended_err> structure:"
msgstr ""
"B<IP_RECVERR> 制御メッセージには I<sock_extended_err> 構造体が含まれる:"

#. type: Plain text
#: build/C/man7/ip.7:785
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: build/C/man7/ip.7:796
#, no-wrap
msgid ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ip.7:798
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: build/C/man7/ip.7:821
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SO_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined."
msgstr ""
"I<ee_errno> にはキューに入っているエラーの I<errno> 番号が入る。 "
"I<ee_origin> にはエラーが発生した場所を示すコードが入る。 その他のフィールド"
"はプロトコル依存である。 B<SO_EE_OFFENDER> マクロは与えられた補助メッセージへ"
"のポインターから エラーの発生したネットワークオブジェクトのアドレスへのポイン"
"ターを返す。 アドレスが不明な場合、 I<sockaddr> 構造体の I<sa_family> フィー"
"ルドは B<AF_UNSPEC> となり、その他のフィールド値は不定である。"

#.  FIXME . Is it a good idea to document that? It is a dubious feature.
#.  On
#.  .B SOCK_STREAM
#.  sockets,
#.  .B IP_RECVERR
#.  has slightly different semantics. Instead of
#.  saving the errors for the next timeout, it passes all incoming
#.  errors immediately to the user.
#.  This might be useful for very short-lived TCP connections which
#.  need fast error handling. Use this option with care:
#.  it makes TCP unreliable
#.  by not allowing it to recover properly from routing
#.  shifts and other normal
#.  conditions and breaks the protocol specification.
#. type: Plain text
#: build/C/man7/ip.7:880
msgid ""
"IP uses the I<sock_extended_err> structure as follows: I<ee_origin> is set "
"to B<SO_EE_ORIGIN_ICMP> for errors received as an ICMP packet, or "
"B<SO_EE_ORIGIN_LOCAL> for locally generated errors.  Unknown values should "
"be ignored.  I<ee_type> and I<ee_code> are set from the type and code fields "
"of the ICMP header.  I<ee_info> contains the discovered MTU for B<EMSGSIZE> "
"errors.  The message also contains the I<sockaddr_in of the node> caused the "
"error, which can be accessed with the B<SO_EE_OFFENDER> macro.  The "
"I<sin_family> field of the B<SO_EE_OFFENDER> address is B<AF_UNSPEC> when "
"the source was unknown.  When the error originated from the network, all IP "
"options (B<IP_OPTIONS>, B<IP_TTL>, etc.) enabled on the socket and contained "
"in the error packet are passed as control messages.  The payload of the "
"packet causing the error is returned as normal payload.  Note that TCP has "
"no error queue; B<MSG_ERRQUEUE> is not permitted on B<SOCK_STREAM> sockets.  "
"B<IP_RECVERR> is valid for TCP, but all errors are returned by socket "
"function return or B<SO_ERROR> only."
msgstr ""
"IP は以下のような I<sock_extended_err> 構造体を用いる: I<ee_origin> は、エ"
"ラー\n"
"が ICMP パケットとして受信された場合には B<SO_EE_ORIGIN_ICMP> にセットさ"
"れ、\n"
"ローカルで起こった場合には B<SO_EE_ORIGIN_LOCAL> にセットされる。 不明な値"
"は\n"
"無視される。 I<ee_type> と I<ee_code> は ICMP ヘッダーの type フィールドと\n"
"code フィールドの値にセットされる。 I<ee_info> には B<EMSGSIZE> エラーに対"
"す\n"
"る discover された MTU が入る。 メッセージにはエラーを引き起こしたノードの\n"
"I<sockaddr_in> 構造体も含まれる。 これには B<SO_EE_OFFENDER> マクロを使って"
"ア\n"
"クセスできる。 ソースが不明の場合、 B<SO_EE_OFFENDER> アドレスの\n"
"I<sin_family> フィールドは B<AF_UNSPEC> となる。 エラーがネットワークで起き"
"た\n"
"場合には、 ソケットで有効になっていたすべての IP オプション (B<IP_OPTIONS>,\n"
"B<IP_TTL> など) とエラーパケットに含まれていたすべての IP オプションとが、 "
"制\n"
"御メッセージとして渡される。 エラーを起こしたパケットのペイロード (payload)\n"
"は 普通のペイロードとして返される。 TCP にはエラーキューがないことに注意し"
"て\n"
"ほしい。 B<MSG_ERRQUEUE> は B<SOCK_STREAM> ソケットに対しては使えない。 TCP\n"
"では B<IP_RECVERR> だけが有効だが、ソケット関数から返されるエラーは\n"
"B<SO_ERROR> だけになる。"

#. type: Plain text
#: build/C/man7/ip.7:885
msgid ""
"For raw sockets, B<IP_RECVERR> enables passing of all received ICMP errors "
"to the application, otherwise errors are reported only on connected sockets"
msgstr ""
"raw ソケットに対して B<IP_RECVERR> を指定すると、受信したすべての ICMP エラー"
"をアプリケーションに 渡すようになる。指定しないと、 接続済みのソケットに対す"
"るエラーだけを報告する。"

#. type: Plain text
#: build/C/man7/ip.7:889
msgid ""
"It sets or retrieves an integer boolean flag.  B<IP_RECVERR> defaults to off."
msgstr ""
"このオプションはブール値のフラグを設定・取得する。 B<IP_RECVERR> はデフォルト"
"ではオフになっている。"

#. type: TP
#: build/C/man7/ip.7:889
#, no-wrap
msgid "B<IP_RECVOPTS> (since Linux 2.2)"
msgstr "B<IP_RECVOPTS> (Linux 2.2 以降)"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:900
msgid ""
"Pass all incoming IP options to the user in a B<IP_OPTIONS> control "
"message.  The routing header and other options are already filled in for the "
"local host.  Not supported for B<SOCK_STREAM> sockets."
msgstr ""
"到着した全ての IP オプションを B<IP_OPTION> コントロールメッセージに入れて"
"ユーザーに渡す。 ルーティングヘッダーとその他のオプションとは、 ローカルホス"
"トに対してはあらかじめ記入されている。 B<SOCK_STREAM> ソケットではサポートさ"
"れていない。"

#. type: TP
#: build/C/man7/ip.7:900
#, no-wrap
msgid "B<IP_RECVORIGDSTADDR> (since Linux 2.6.29)"
msgstr "B<IP_RECVORIGDSTADDR> (Linux 2.6.29 以降)"

#.  commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
#. type: Plain text
#: build/C/man7/ip.7:911
msgid ""
"This boolean option enables the B<IP_ORIGDSTADDR> ancillary message in "
"B<recvmsg>(2), in which the kernel returns the original destination address "
"of the datagram being received.  The ancillary message contains a I<struct "
"sockaddr_in>."
msgstr ""
"このブール値のオプションがセットされると、\n"
"B<recvmsg>(2) で B<IP_ORIGDSTADDR> 補助メッセージが有効になる。\n"
"カーネルはデータグラムを受信した元の宛先アドレスをこの補助メッセージで返"
"す。\n"
"この補助メッセージには I<struct sockaddr_in> が格納される。"

#. type: TP
#: build/C/man7/ip.7:911
#, no-wrap
msgid "B<IP_RECVTOS> (since Linux 2.2)"
msgstr "B<IP_RECVTOS> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:920
msgid ""
"If enabled, the B<IP_TOS> ancillary message is passed with incoming "
"packets.  It contains a byte which specifies the Type of Service/Precedence "
"field of the packet header.  Expects a boolean integer flag."
msgstr ""
"有効になっていると、 B<IP_TOS> 補助メッセージが到着パケットとともに渡され"
"る。 これにはパケットヘッダーの Service/Precedence フィールドのタイプを指定す"
"るバイトデータが含まれている。 ブール整数値のフラグをとる。"

#. type: TP
#: build/C/man7/ip.7:920
#, no-wrap
msgid "B<IP_RECVTTL> (since Linux 2.2)"
msgstr "B<IP_RECVTTL> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:930
#, fuzzy
#| msgid ""
#| "When this flag is set, pass a B<IP_TTL> control message with the time to "
#| "live field of the received packet as a byte.  Not supported for "
#| "B<SOCK_STREAM> sockets."
msgid ""
"When this flag is set, pass a B<IP_TTL> control message with the time-to-"
"live field of the received packet as a 32 bit integer.  Not supported for "
"B<SOCK_STREAM> sockets."
msgstr ""
"このフラグがセットされていると、 B<IP_TTL> コントロールメッセージが受信パケッ"
"トの time-to-live フィールドのバイトデータとともに渡される。 B<SOCK_STREAM> "
"ソケットではサポートされていない。"

#. type: TP
#: build/C/man7/ip.7:930
#, no-wrap
msgid "B<IP_RETOPTS> (since Linux 2.2)"
msgstr "B<IP_RETOPTS>"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:937
msgid ""
"Identical to B<IP_RECVOPTS>, but returns raw unprocessed options with "
"timestamp and route record options not filled in for this hop."
msgstr ""
"B<IP_RETOPTS> (Linux 2.2 以降)  B<IP_RECVOPTS> と等価だが、未処理の生のオプ"
"ションを、 この hop では記入されない timestamp レコードと route レコードとと"
"もに返す。"

#. type: TP
#: build/C/man7/ip.7:937
#, no-wrap
msgid "B<IP_ROUTER_ALERT> (since Linux 2.2)"
msgstr "B<IP_ROUTER_ALERT> (Linux 2.2 以降)"

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:949
#, fuzzy
#| msgid ""
#| "Pass all to-be forwarded packets with the IP Router Alert option set to "
#| "this socket.  Only valid for raw sockets.  This is useful, for instance, "
#| "for user-space RSVP daemons.  The tapped packets are not forwarded by the "
#| "kernel; it is the user's responsibility to send them out again.  Socket "
#| "binding is ignored, such packets are only filtered by protocol.  Expects "
#| "an integer flag."
msgid ""
"Pass all to-be forwarded packets with the IP Router Alert option set to this "
"socket.  Valid only for raw sockets.  This is useful, for instance, for user-"
"space RSVP daemons.  The tapped packets are not forwarded by the kernel; it "
"is the user's responsibility to send them out again.  Socket binding is "
"ignored, such packets are filtered only by protocol.  Expects an integer "
"flag."
msgstr ""
"フォワードすべきパケットを IP Router Alert オプションをつけて このソケットに"
"渡す。 raw ソケットに対してのみ有効である。これはたとえばユーザー空間の RSVP "
"デーモンに対して便利である。タップされたパケットは カーネルによってはフォワー"
"ドされないので、これらを再送するのは ユーザーの責任となる。ソケットのバインド"
"は無視され、 このようなパケットはプロトコルによってのみフィルタリングされ"
"る。 整数値のフラグを取る。"

#. type: TP
#: build/C/man7/ip.7:949
#, no-wrap
msgid "B<IP_TOS> (since Linux 1.0)"
msgstr "B<IP_TOS> (Linux 1.0 以降)"

#.  FIXME elaborate on this
#.  The priority can also be set in a protocol-independent way by the
#.  .RB ( SOL_SOCKET ", " SO_PRIORITY )
#.  socket option (see
#.  .BR socket (7)).
#. type: Plain text
#: build/C/man7/ip.7:978
msgid ""
"Set or receive the Type-Of-Service (TOS) field that is sent with every IP "
"packet originating from this socket.  It is used to prioritize packets on "
"the network.  TOS is a byte.  There are some standard TOS flags defined: "
"B<IPTOS_LOWDELAY> to minimize delays for interactive traffic, "
"B<IPTOS_THROUGHPUT> to optimize throughput, B<IPTOS_RELIABILITY> to optimize "
"for reliability, B<IPTOS_MINCOST> should be used for \"filler data\" where "
"slow transmission doesn't matter.  At most one of these TOS values can be "
"specified.  Other bits are invalid and shall be cleared.  Linux sends "
"B<IPTOS_LOWDELAY> datagrams first by default, but the exact behavior depends "
"on the configured queueing discipline.  Some high-priority levels may "
"require superuser privileges (the B<CAP_NET_ADMIN> capability)."
msgstr "このソケットから送信されるすべての IP パケットに適用される Type-Of-Service (TOS) フィールドを設定・取得する。 これはネットワーク上でのパケットの優先度を決めるために用いられる。 TOS はバイトデータである。標準の TOS フラグがいくつか定義されている。 B<IPTOS_LOWDELAY> はインタラクティブなトラフィックの遅延を最小にする。 B<IPTOS_THROUGHPUT> はスループットを最大にする。 B<IPTOS_RELIABILITY> は信頼性を最高にする。 B<IPTOS_MINCOST> は転送速度が遅くてもかまわないとき、「データを詰め込む」のに用いられる。 これらのうち、 1 つまでだけを設定できる。 他のビットは無効で、クリアされる。 Linux はデフォルトでは B<IPTOS_LOWDELAY> データグラムを最初に送信する。 しかし、正確な振る舞いはキュー処理の設定に依存する。 高い優先度にするにはスーパーユーザー権限 (B<CAP_NET_ADMIN> ケーパビリティ) が必要となるかもしれない。"

#. type: TP
#: build/C/man7/ip.7:978
#, no-wrap
msgid "B<IP_TRANSPARENT> (since Linux 2.6.24)"
msgstr "B<IP_TRANSPARENT> (Linux 2.6.24 以降)"

#.  commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
#.      This patch introduces the IP_TRANSPARENT socket option: enabling that
#.      will make the IPv4 routing omit the non-local source address check on
#.      output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:998
msgid ""
"Setting this boolean option enables transparent proxying on this socket.  "
"This socket option allows the calling application to bind to a nonlocal IP "
"address and operate both as a client and a server with the foreign address "
"as the local endpoint.  NOTE: this requires that routing be set up in a way "
"that packets going to the foreign address are routed through the TProxy box "
"(i.e., the system hosting the application that employs the B<IP_TRANSPARENT> "
"socket option).  Enabling this socket option requires superuser privileges "
"(the B<CAP_NET_ADMIN> capability)."
msgstr ""
"このブール値のオプションを有効にすると、 このソケットで透過プロキシ "
"(transparent proxy) ができるようになる。 このソケットオプションを使うと、呼び"
"出したアプリケーションは、 ローカルではない IP アドレスをバインドして、ローカ"
"ルの端点として自分以外のアドレス (foreign address) を持つクライアントやサーバ"
"の両方として動作できるようになる。 B<注意>: この機能が動作するためには、自分"
"以外のアドレス宛のパケットが透過プロキシが動作するマシン (すなわちソケットオ"
"プション B<IP_TRANSPARENT> を利用するアプリケーションが動作しているシステム) "
"経由で転送されるように、 ルーティングが設定される必要がある。 このソケットオ"
"プションを有効にするには、スーパーユーザー特権 (B<CAP_NET_ADMIN> ケーパビリ"
"ティ) が必要である。"

#. type: Plain text
#: build/C/man7/ip.7:1001
msgid ""
"TProxy redirection with the iptables TPROXY target also requires that this "
"option be set on the redirected socket."
msgstr ""
"iptables の TPROXY ターゲットで透過プロキシリダイレクション \n"
"(TProxy redirection) を行うには、リダイレクトされるソケットに対して\n"
"このオプションを設定する必要がある。"

#. type: TP
#: build/C/man7/ip.7:1001
#, no-wrap
msgid "B<IP_TTL> (since Linux 1.0)"
msgstr "B<IP_TTL> (Linux 1.0 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1005
msgid ""
"Set or retrieve the current time-to-live field that is used in every packet "
"sent from this socket."
msgstr ""
"time-to-live フィールドの値を設定または取得する。 この値はこのソケットから送"
"信されるすべてのパケットに用いられる。"

#. type: TP
#: build/C/man7/ip.7:1005
#, no-wrap
msgid "B<IP_UNBLOCK_SOURCE> (since Linux 2.4.22 / 2.5.68)"
msgstr "B<IP_UNBLOCK_SOURCE> (Linux 2.4.22 以降 / 2.5.68 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1011
msgid ""
"Unblock previously blocked multicast source.  Returns B<EADDRNOTAVAIL> when "
"given source is not being blocked."
msgstr ""
"それ以前はブロックされていたマルチキャストの送信元のブロックを解除する。 指定"
"した送信元がブロックされていない場合は B<EADDRNOTAVAIL> を返す。"

#. type: TP
#: build/C/man7/ip.7:1016
#, no-wrap
msgid "B<SO_PEERSEC> (since Linux 2.6.17)"
msgstr "B<SO_PEERSEC> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1025
msgid ""
"If labeled IPSEC or NetLabel is configured on both the sending and receiving "
"hosts, this read-only socket option returns the security context of the peer "
"socket connected to this socket.  By default, this will be the same as the "
"security context of the process that created the peer socket unless "
"overridden by the policy or by a process with the required permissions."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1045 build/C/man7/unix.7:379
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a buffer of the specified "
"length in bytes into which the security context string will be copied.  If "
"the buffer length is less than the length of the security context string, "
"then B<getsockopt>(2)  returns -1, sets I<errno> to B<ERANGE>, and returns "
"the required length via I<optlen>.  The caller should allocate at least "
"B<NAME_MAX> bytes for the buffer initially, although this is not guaranteed "
"to be sufficient.  Resizing the buffer to the returned length and retrying "
"may be necessary."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1054 build/C/man7/unix.7:388
msgid ""
"The security context string may include a terminating null character in the "
"returned length, but is not guaranteed to do so: a security context \"foo\" "
"might be represented as either {'f','o','o'} of length 3 or "
"{'f','o','o','\\e0'} of length 4, which are considered to be "
"interchangeable.  The string is printable, does not contain non-terminating "
"null characters, and is in an unspecified encoding (in particular, it is not "
"guaranteed to be ASCII or UTF-8)."
msgstr ""

#.  commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
#.  commit d452930fd3b9031e59abfeddb2fa383f1403d61a
#. type: Plain text
#: build/C/man7/ip.7:1062
msgid ""
"The use of this option for sockets in the B<AF_INET> address family is "
"supported since Linux 2.6.17 for TCP sockets, and since Linux 4.17 for SCTP "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1073
msgid ""
"For SELinux, NetLabel conveys only the MLS portion of the security context "
"of the peer across the wire, defaulting the rest of the security context to "
"the values defined in the policy for the netmsg initial security identifier "
"(SID).  However, NetLabel can be configured to pass full security contexts "
"over loopback.  Labeled IPSEC always passes full security contexts as part "
"of establishing the security association (SA) and looks them up based on the "
"association for each packet."
msgstr ""

#.  FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
#.   ip_queue_maxlen
#.   ip_conntrack_max
#. type: Plain text
#: build/C/man7/ip.7:1089
msgid ""
"The IP protocol supports a set of I</proc> interfaces to configure some "
"global parameters.  The parameters can be accessed by reading or writing "
"files in the directory I</proc/sys/net/ipv4/>.  Interfaces described as "
"I<Boolean> take an integer value, with a nonzero value (\"true\") meaning "
"that the corresponding option is enabled, and a zero value (\"false\")  "
"meaning that the option is disabled."
msgstr ""
"IP プロトコルでは、いくつかのグローバルパラメーターを設定するための I</proc> "
"ファイル群が用意されている。 これらのパラメーターには、 I</proc/sys/net/ipv4/"
"> ディレクトリ内のファイルの読み書きでアクセスできる。 I<Boolean> と書かれた"
"インターフェースは整数値をとり、 0 以外の値 (\"true\") は対応するオプションが"
"有効、 0 値 (\"false\") は無効、であることを意味する。"

#. type: TP
#: build/C/man7/ip.7:1089
#, no-wrap
msgid "I<ip_always_defrag> (Boolean; since Linux 2.2.13)"
msgstr "I<ip_always_defrag> (Boolean; Linux 2.2.13 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1095
msgid ""
"[New with kernel 2.2.13; in earlier kernel versions this feature was "
"controlled at compile time by the B<CONFIG_IP_ALWAYS_DEFRAG> option; this "
"option is not present in 2.4.x and later]"
msgstr ""
"[2.2.13 で新規登場。以前のバージョンのカーネルでは、この機能は コンパイル時"
"に B<CONFIG_IP_ALWAYS_DEFRAG> オプションによって制御されていた; このファイル"
"は 2.4.x 以降では存在しない]"

#. type: Plain text
#: build/C/man7/ip.7:1102
msgid ""
"When this boolean flag is enabled (not equal 0), incoming fragments (parts "
"of IP packets that arose when some host between origin and destination "
"decided that the packets were too large and cut them into pieces) will be "
"reassembled (defragmented) before being processed, even if they are about to "
"be forwarded."
msgstr ""
"このブール値のフラグが有効になっている (0 以外になっている) と、 到着したフラ"
"グメント (IP パケットの一部で、 発信元と発信先の間のどこかのホストで、そのパ"
"ケットが 大きすぎると判断され、分割された場合に生じる)  は、たとえフォワード"
"される場合であっても 処理前に再構築 (デフラグメント) される。"

#. type: Plain text
#: build/C/man7/ip.7:1109
msgid ""
"Enable only if running either a firewall that is the sole link to your "
"network or a transparent proxy; never ever use it for a normal router or "
"host.  Otherwise, fragmented communication can be disturbed if the fragments "
"travel over different links.  Defragmentation also has a large memory and "
"CPU time cost."
msgstr ""
"ファイアウォールがローカル側のネットワークに唯一のリンクを持っている 場合や、"
"透過プロクシの場合に限って有効にすべきである。 通常のルーターやホストでは決し"
"て使用することのないように。 さもないとフラグメントが別のリンクを経由して伝わ"
"る場合に、 通信のフラグメント化ができなくなってしまう。 またフラグメント再構"
"築処理はメモリーと CPU 時間のコストが非常に大きい。"

#. type: Plain text
#: build/C/man7/ip.7:1113
msgid ""
"This is automagically turned on when masquerading or transparent proxying "
"are configured."
msgstr ""
"これはマスカレードや透過プロクシが設定されると、 不思議な仕組みによって自動的"
"に有効になる。"

#. type: TP
#: build/C/man7/ip.7:1113
#, no-wrap
msgid "I<ip_autoconfig> (since Linux 2.2 to 2.6.17)"
msgstr "I<ip_autoconfig> (Linux 2.2 以降 2.6.17 まで)"

#.  Precisely: since 2.1.68
#.  FIXME document ip_autoconfig
#. type: Plain text
#: build/C/man7/ip.7:1119
msgid "Not documented."
msgstr "まだ記述していない。"

#. type: TP
#: build/C/man7/ip.7:1119
#, no-wrap
msgid "I<ip_default_ttl> (integer; default: 64; since Linux 2.2)"
msgstr "I<ip_default_ttl> (integer; default: 64; Linux 2.2 以降)"

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:1127
msgid ""
"Set the default time-to-live value of outgoing packets.  This can be changed "
"per socket with the B<IP_TTL> option."
msgstr ""
"送出されるパケットの time-to-live 値のデフォルトをセットする。 これは "
"B<IP_TTL> オプションを用いれば、パケットごとに変えることもできる。"

#. type: TP
#: build/C/man7/ip.7:1127
#, no-wrap
msgid "I<ip_dynaddr> (Boolean; default: disabled; since Linux 2.0.31)"
msgstr "I<ip_dynaddr> (ブール値; デフォルト: 無効; Linux 2.0.31 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1134
msgid ""
"Enable dynamic socket address and masquerading entry rewriting on interface "
"address change.  This is useful for dialup interface with changing IP "
"addresses.  0 means no rewriting, 1 turns it on and 2 enables verbose mode."
msgstr ""
"動的ソケットアドレスと、インターフェースアドレスが変更された際の マスカレード"
"エントリーの再書き込みを有効にする。 ダイアルアップインターフェースで、 IP ア"
"ドレスが変更される場合に便利である。"

#. type: TP
#: build/C/man7/ip.7:1134
#, no-wrap
msgid "I<ip_forward> (Boolean; default: disabled; since Linux 1.2)"
msgstr "I<ip_forward> (ブール値; デフォルト: 無効; Linux 1.2 以降)"

#. type: Plain text
#: build/C/man7/ip.7:1139
msgid ""
"Enable IP forwarding with a boolean flag.  IP forwarding can be also set on "
"a per-interface basis."
msgstr ""
"IP forwarding を有効にするかどうかのブール値フラグ。 IP forwarding するかどう"
"かはインターフェースごとにも設定できる。"

#. type: TP
#: build/C/man7/ip.7:1139
#, no-wrap
msgid "I<ip_local_port_range> (since Linux 2.2)"
msgstr "I<ip_local_port_range> (Linux 2.2 以降)"

#.  Precisely: since 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:1147
msgid ""
"This file contains two integers that define the default local port range "
"allocated to sockets that are not explicitly bound to a port number\\(emthat "
"is, the range used for I<ephemeral ports>.  An ephemeral port is allocated "
"to a socket in the following circumstances:"
msgstr ""
"このファイルには、 ポート番号に明示的にバインドされないソケットに割り当てられ"
"るデフォルトのローカルポートの範囲 \\(em つまり「一時ポート (I<ephemeral "
"ports>)」に使用される範囲 \\(em を定める 2 つの整数が入っている。 一時ポート"
"は以下の場合にソケットに割り当てられる。"

#. type: Plain text
#: build/C/man7/ip.7:1151
msgid ""
"the port number in a socket address is specified as 0 when calling "
"B<bind>(2);"
msgstr ""
"B<bind>(2) の呼び出し時にソケットアドレスのポート番号に 0 が指定されている。"

#. type: Plain text
#: build/C/man7/ip.7:1154
msgid ""
"B<listen>(2)  is called on a stream socket that was not previously bound;"
msgstr ""
"バインドされていないストリームソケットに対して B<listen>(2) が呼び出された。"

#. type: Plain text
#: build/C/man7/ip.7:1157
msgid "B<connect>(2)  was called on a socket that was not previously bound;"
msgstr "バインドされていないソケットに対して B<connect>(2)  が呼ばれた。"

#. type: Plain text
#: build/C/man7/ip.7:1160
msgid ""
"B<sendto>(2)  is called on a datagram socket that was not previously bound."
msgstr ""
"バインドされていないデータグラムソケットに対して B<sendto>(2)  が呼ばれた。"

#. type: Plain text
#: build/C/man7/ip.7:1167
msgid ""
"Allocation of ephemeral ports starts with the first number in "
"I<ip_local_port_range> and ends with the second number.  If the range of "
"ephemeral ports is exhausted, then the relevant system call returns an error "
"(but see BUGS)."
msgstr ""
"一時ポートに割り当てられるポート番号の範囲は、 I<ip_local_port_range> の最初"
"の数字から始まり、 2 番目の数字で終わる。 一時ポートの範囲を使い切った場合、 "
"関連するシステムコールはエラーを返す (バグの節を参照)。"

#. type: Plain text
#: build/C/man7/ip.7:1178
msgid ""
"Note that the port range in I<ip_local_port_range> should not conflict with "
"the ports used by masquerading (although the case is handled).  Also, "
"arbitrary choices may cause problems with some firewall packet filters that "
"make assumptions about the local ports in use.  The first number should be "
"at least greater than 1024, or better, greater than 4096, to avoid clashes "
"with well known ports and to minimize firewall problems."
msgstr ""
"I<ip_local_port_range> で指定するポート番号の範囲は、 マスカレードで用いられ"
"ているポートと重なってはならない (その場合も取り扱われるが)。 ファイアウォー"
"ルのパケットフィルターが「利用中のローカルポート」 について何らかの仮定をして"
"いる場合には、 番号を勝手に決めてしまうと問題が起きるかもしれない。 1 番目の"
"番号は少なくとも 1024 より大きくすべきである。 良く使われるポートとの衝突を避"
"けたり、ファイアウォールの問題を 回避したければ、 4096 よりも大きくするほうが"
"良いだろう。"

#. type: TP
#: build/C/man7/ip.7:1178
#, no-wrap
msgid "I<ip_no_pmtu_disc> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<ip_no_pmtu_disc> (ブール値; デフォルト: 無効; Linux 2.2 以降)"

#.  Precisely: 2.1.15
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1190
msgid ""
"If enabled, don't do Path MTU Discovery for TCP sockets by default.  Path "
"MTU discovery may fail if misconfigured firewalls (that drop all ICMP "
"packets) or misconfigured interfaces (e.g., a point-to-point link where the "
"both ends don't agree on the MTU) are on the path.  It is better to fix the "
"broken routers on the path than to turn off Path MTU Discovery globally, "
"because not doing it incurs a high cost to the network."
msgstr ""
"有効になっていると、デフォルトで TCP ソケットに対する Path MTU Discoverty を"
"行わない。 Path MTU Discovery は、 正しく設定されていない (ICMP パケットを全"
"てドロップする) ファイアウォールや、 (point-to-point リンクで双方の MTU が一"
"致していない場合など)  正しく設定されていないインターフェースが経路上に存在す"
"ると失敗してしまう。 Path MTU Discovery をグローバルに無効にするよりは、 壊れ"
"ているルーターを直すほうが良い。 Path MTU Discovery を無効にするとネットワー"
"クのコストが 大きくなってしまうからである。"

#. type: TP
#: build/C/man7/ip.7:1190
#, no-wrap
msgid "I<ip_nonlocal_bind> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<ip_nonlocal_bind> (ブール値; デフォルト: 無効; Linux 2.4 以降)"

#.  Precisely: patch-2.4.0-test10
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1199
msgid ""
"If set, allows processes to B<bind>(2)  to nonlocal IP addresses, which can "
"be quite useful, but may break some applications."
msgstr ""
"セットされていれば、プロセスが自分以外の IP アドレスを B<bind>(2)  できるよう"
"になる。これはかなり便利だが、うまく動かないアプリケーションもある。"

#. type: TP
#: build/C/man7/ip.7:1199
#, no-wrap
msgid "I<ip6frag_time> (integer; default: 30)"
msgstr "I<ip6frag_time> (integer; default: 30)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:1204
msgid "Time in seconds to keep an IPv6 fragment in memory."
msgstr "IPv6 フラグメントをメモリーに保持しておく時間 (秒単位)。"

#. type: TP
#: build/C/man7/ip.7:1204
#, no-wrap
msgid "I<ip6frag_secret_interval> (integer; default: 600)"
msgstr "I<ip6frag_secret_interval> (integer; default: 600)"

#. type: Plain text
#: build/C/man7/ip.7:1208
msgid ""
"Regeneration interval (in seconds) of the hash secret (or lifetime for the "
"hash secret) for IPv6 fragments."
msgstr ""
"IPv6 フラグメントの hash secret の生成間隔 (hash secret の寿命)  (秒単位)。"

#. type: TP
#: build/C/man7/ip.7:1208
#, no-wrap
msgid "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"
msgstr "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"

#. type: Plain text
#: build/C/man7/ip.7:1215
msgid ""
"If the amount of queued IP fragments reaches I<ipfrag_high_thresh>, the "
"queue is pruned down to I<ipfrag_low_thresh>.  Contains an integer with the "
"number of bytes."
msgstr ""
"キューイングされている IP フラグメントの量が I<ipfrag_high_thresh> に達する"
"と、キューの内容は I<ipfrag_low_thresh> にまで切り捨てられる。それぞれの大き"
"さを バイト単位で表す整数値が入っている。"

#. type: TP
#: build/C/man7/ip.7:1215
#, no-wrap
msgid "I<neigh/*>"
msgstr "I<neigh/*>"

#.  FIXME Document the conf/*/* interfaces
#.  FIXME Document the route/* interfaces
#. type: Plain text
#: build/C/man7/ip.7:1222
msgid "See B<arp>(7)."
msgstr "B<arp>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/ip.7:1227
msgid "All ioctls described in B<socket>(7)  apply to B<ip>."
msgstr "B<socket>(7)  に記述されている ioctl は、すべて B<ip> にも適用される。"

#.  FIXME Add a discussion of multicasting
#. type: Plain text
#: build/C/man7/ip.7:1231
msgid ""
"Ioctls to configure generic device parameters are described in "
"B<netdevice>(7)."
msgstr ""
"ジェネリックデバイスのパラメーターを設定する ioctl については "
"B<netdevice>(7)  に記述されている。"

#. type: Plain text
#: build/C/man7/ip.7:1251
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include: sending a packet to a broadcast address without having the "
"B<SO_BROADCAST> flag set; sending a packet via a I<prohibit> route; "
"modifying firewall settings without superuser privileges (the "
"B<CAP_NET_ADMIN> capability); binding to a privileged port without superuser "
"privileges (the B<CAP_NET_BIND_SERVICE> capability)."
msgstr ""
"必要な権限のないユーザーが操作を実行しようとした。 以下のような場合が考えられ"
"る: B<SO_BROADCAST> フラグを設定していない状態でブロードキャストアドレスに パ"
"ケットを送ろうとした。 I<prohibit> なルートを通してパケットを送ろうとした。 "
"スーパーユーザー権限 (B<CAP_NET_ADMIN> ケーパビリティ) なしでファイアウォール"
"の設定を変更しようとした。 スーパーユーザー権限 (B<CAP_NET_BIND_SERVICE> ケー"
"パビリティ) なしで特権ポートにバインドしようとした。"

#. type: Plain text
#: build/C/man7/ip.7:1273
msgid ""
"No valid routing table entry matches the destination address.  This error "
"can be caused by an ICMP message from a remote router or for the local "
"routing table."
msgstr ""
"宛先アドレスにマッチする有効なエントリーがルーティングテーブルに 存在しない。"
"このエラーはリモートルーターからの、 あるいはローカルルーティングテーブルへ"
"の ICMP メッセージによって引き起こされることがある。"

#. type: Plain text
#: build/C/man7/ip.7:1279
msgid ""
"Invalid argument passed.  For send operations this can be caused by sending "
"to a I<blackhole> route."
msgstr ""
"不正な引数が渡された。送信操作において、 I<blackhole> ルートに送信しようと"
"するとこのエラーが起こることがある。"

#. type: Plain text
#: build/C/man7/ip.7:1286
msgid "Datagram is bigger than an MTU on the path and it cannot be fragmented."
msgstr "データグラムが path MTU よりも大きく、フラグメント化もできない。"

#. type: TP
#: build/C/man7/ip.7:1286
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr "B<ENOBUFS>, B<ENOMEM>"

#. type: Plain text
#: build/C/man7/ip.7:1291
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory, but this is "
"not 100% consistent."
msgstr ""
"空きメモリーが足りない。 このエラーは、メモリーアロケーションがソケットバッ"
"ファーの 大きさによって制限されていることを意味しているのが通常であるが、 "
"100% そうだというわけではない。"

#. type: Plain text
#: build/C/man7/ip.7:1309
msgid ""
"User doesn't have permission to set high priority, change configuration, or "
"send signals to the requested process or group."
msgstr ""
"高い優先度を設定したり、設定を変更したり、要求されたプロセスや プロセスグルー"
"プにシグナルを送ったりするのに必要な権限を、 ユーザーが持っていない。"

#. type: Plain text
#: build/C/man7/ip.7:1315
msgid "The socket is not configured or an unknown socket type was requested."
msgstr "ソケットが未設定であるか、知らないソケットタイプが要求された。"

#. type: Plain text
#: build/C/man7/ip.7:1322
msgid ""
"Other errors may be generated by the overlaying protocols; see B<tcp>(7), "
"B<raw>(7), B<udp>(7), and B<socket>(7)."
msgstr ""
"他のエラーが上層のプロトコルによって生じるかもしれない。 B<tcp>(7), "
"B<raw>(7), B<udp>(7), B<socket>(7)  などを参照のこと。"

#.  IP_XFRM_POLICY is Linux-specific
#.  IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
#. type: Plain text
#: build/C/man7/ip.7:1337
msgid ""
"B<IP_FREEBIND>, B<IP_MSFILTER>, B<IP_MTU>, B<IP_MTU_DISCOVER>, "
"B<IP_RECVORIGDSTADDR>, B<IP_PASSSEC>, B<IP_PKTINFO>, B<IP_RECVERR>, "
"B<IP_ROUTER_ALERT>, and B<IP_TRANSPARENT> are Linux-specific."
msgstr "B<IP_FREEBIND>, B<IP_MSFILTER>, B<IP_MTU>, B<IP_MTU_DISCOVER>, B<IP_RECVORIGDSTADDR>, B<IP_PASSSEC>, B<IP_PKTINFO>, B<IP_RECVERR>, B<IP_ROUTER_ALERT>, B<IP_TRANSPARENT> は Linux 固有である。"

#. type: Plain text
#: build/C/man7/ip.7:1346
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless broadcasts.  For "
"new application protocols it is better to use a multicast group instead of "
"broadcasting.  Broadcasting is discouraged."
msgstr ""
"B<SO_BROADCAST> オプションの利用には、くれぐれも注意すること。\n"
"これは Linux では特権操作ではない。\n"
"不注意なブロードキャストを行うと、ネットワークは簡単に過負荷状態になる。\n"
"新しいアプリケーションプロトコルには、ブロードキャストではなく\n"
"マルチキャストグループを用いるほうがよい。 ブロードキャストは推奨されない。"

#. type: Plain text
#: build/C/man7/ip.7:1356
msgid ""
"Some other BSD sockets implementations provide B<IP_RCVDSTADDR> and "
"B<IP_RECVIF> socket options to get the destination address and the interface "
"of received datagrams.  Linux has the more general B<IP_PKTINFO> for the "
"same task."
msgstr ""
"他の BSD のソケット実装では、 B<IP_RCVDSTADDR> と B<IP_RECVIF> といったソケッ"
"トオプションがサポートされており、 宛先アドレスや受信データグラムのインター"
"フェースが取得できるように なっていることもある。 Linux で同じことをやらせる"
"には、より一般的な B<IP_PKTINFO> が使える。"

#. type: Plain text
#: build/C/man7/ip.7:1365
msgid ""
"Some BSD sockets implementations also provide an B<IP_RECVTTL> option, but "
"an ancillary message with type B<IP_RECVTTL> is passed with the incoming "
"packet.  This is different from the B<IP_TTL> option used in Linux."
msgstr ""
"いくつかの BSD のソケット実装では B<IP_RECVTTL> オプションも提供されている"
"が、タイプ B<IP_RECVTTL> の補助メッセージは受信パケットとともに渡される。 こ"
"れは Linux で使われている B<IP_TTL> オプションとは異なる動作である。"

#. type: Plain text
#: build/C/man7/ip.7:1371
msgid ""
"Using the B<SOL_IP> socket options level isn't portable; BSD-based stacks "
"use the B<IPPROTO_IP> level."
msgstr ""
"B<SOL_IP> ソケットオプションレベルは移植性がない。 BSD ベースのプロトコルス"
"タックでは B<IPPROTO_IP> レベルが使用されている。"

#. type: Plain text
#: build/C/man7/ip.7:1379
#, no-wrap
msgid ""
"B<INADDR_ANY>\n"
"(0.0.0.0) and\n"
"B<INADDR_BROADCAST>\n"
"(255.255.255.255) are byte-order-neutral.\n"
" This means\n"
"B<htonl>(3)\n"
"has no effect on them.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1392
msgid ""
"For compatibility with Linux 2.0, the obsolete B<socket(AF_INET, "
"SOCK_PACKET, >I<protocol>B<)> syntax is still supported to open a "
"B<packet>(7)  socket.  This is deprecated and should be replaced by "
"B<socket(AF_PACKET, SOCK_RAW, >I<protocol>B<)> instead.  The main difference "
"is the new I<sockaddr_ll> address structure for generic link layer "
"information instead of the old B<sockaddr_pkt>."
msgstr ""
"Linux 2.0 との互換性のために、 obsolete な B<socket(AF_INET, SOCK_PACKET, "
">I<protocol>B<)> という書式でも B<packet>(7)  をオープンできるようになってい"
"るが、これはお勧めできない。今後は B<socket(AF_PACKET, SOCK_RAW, "
">I<protocol>B<)> を代わりに用いるべきである。主な違いは、ジェネリックなリンク"
"層用の I<sockaddr_ll> アドレス構造体が、古い B<sockaddr_pkt> に変わって用いら"
"れるようになったことである。"

#. type: Plain text
#: build/C/man7/ip.7:1402
msgid ""
"The error used to diagnose exhaustion of the ephemeral port range differs "
"across the various system calls (B<connect>(2), B<bind>(2), B<listen>(2), "
"B<sendto>(2))  that can assign ephemeral ports."
msgstr ""
"一時ポートの範囲の枯渇を示すのに使われるエラーは、 一時ポートの割り当てを行え"
"るシステムコール (B<connect>(2), B<bind>(2), B<listen>(2), B<sendto>(2)) によ"
"り異なる。"

#.  .PP
#.  Some versions of glibc forget to declare
#.  .IR in_pktinfo .
#.  Workaround currently is to copy it into your program from this man page.
#. type: Plain text
#: build/C/man7/ip.7:1409
msgid ""
"The ioctls to configure IP-specific interface options and ARP tables are not "
"described."
msgstr ""
"IP 固有のインターフェースオプションを指定するための ioctl と ARP テーブルのこ"
"とが記述されていない。"

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/ip.7:1419
msgid ""
"Receiving the original destination address with B<MSG_ERRQUEUE> in "
"I<msg_name> by B<recvmsg>(2)  does not work in some 2.2 kernels."
msgstr ""
"B<recvmsg>(2)  で I<msg_name> に B<MSG_ERRQUEUE> を指定して、受信パケットに"
"入っていた宛先アドレスを取得する方法は 2.2 カーネルの一部でうまく動かない。"

#. type: Plain text
#: build/C/man7/ip.7:1433
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<capabilities>(7), "
"B<icmp>(7), B<ipv6>(7), B<netdevice>(7), B<netlink>(7), B<raw>(7), "
"B<socket>(7), B<tcp>(7), B<udp>(7), B<ip>(8)"
msgstr "B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<capabilities>(7), B<icmp>(7), B<ipv6>(7), B<netdevice>(7), B<netlink>(7), B<raw>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<ip>(8)"

#. type: Plain text
#: build/C/man7/ip.7:1436 build/C/man7/tcp.7:1392 build/C/man7/udp.7:269
msgid "The kernel source file I<Documentation/networking/ip-sysctl.txt>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1440
msgid ""
"RFC\\ 791 for the original IP specification.  RFC\\ 1122 for the IPv4 host "
"requirements.  RFC\\ 1812 for the IPv4 router requirements."
msgstr ""
"RFC\\ 791: 元々の IP 仕様。 RFC\\ 1122: IPv4 ホストの要件。 RFC\\ 1812: IPv4 "
"ルーターの要件。"

#. type: TH
#: build/C/man7/ipv6.7:86
#, no-wrap
msgid "IPV6"
msgstr "IPV6"

#. type: Plain text
#: build/C/man7/ipv6.7:89
msgid "ipv6 - Linux IPv6 protocol implementation"
msgstr "ipv6 - Linux IPv6 プロトコルの実装"

#. type: Plain text
#: build/C/man7/ipv6.7:95
msgid "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"
msgstr "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/ipv6.7:97
msgid "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ipv6.7:99
msgid "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"
msgstr "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/ipv6.7:106
msgid ""
"Linux 2.2 optionally implements the Internet Protocol, version 6.  This man "
"page contains a description of the IPv6 basic API as implemented by the "
"Linux kernel and glibc 2.1.  The interface is based on the BSD sockets "
"interface; see B<socket>(7)."
msgstr ""
"Linux 2.2 では、Internet Protocol, version 6 を オプションとして実装してい"
"る。 この man ページでは、Linux カーネルと glibc 2.1 での実装に基づいて、 "
"IPv6 の基本的な API を解説する。 インターフェースは BSD ソケットインター"
"フェースをもとにしている。 B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man7/ipv6.7:111
msgid ""
"The IPv6 API aims to be mostly compatible with the IPv4 API (see B<ip>(7)).  "
"Only differences are described in this man page."
msgstr ""
"IPv6 API は、 IPv4 API (B<ip>(7)  参照) とほぼ互換になることを目指している。 "
"この man ページでは相違点のみを解説する。"

#. type: Plain text
#: build/C/man7/ipv6.7:123
msgid ""
"To bind an B<AF_INET6> socket to any process, the local address should be "
"copied from the I<in6addr_any> variable which has I<in6_addr> type.  In "
"static initializations, B<IN6ADDR_ANY_INIT> may also be used, which expands "
"to a constant expression.  Both of them are in network byte order."
msgstr ""
"B<AF_INET6> ソケットを何らかのプロセスにバインドするには、 ローカルアドレス"
"を I<in6_addr> 型の変数 I<in6addr_any> からコピーしてくる必要がある。 static "
"な初期値 B<IN6ADDR_ANY_INIT> も用いることができ、これは定数式に展開される。 "
"これらの両者はネットワークバイトオーダーである。"

#. type: Plain text
#: build/C/man7/ipv6.7:130
msgid ""
"The IPv6 loopback address (::1) is available in the global "
"I<in6addr_loopback> variable.  For initializations, B<IN6ADDR_LOOPBACK_INIT> "
"should be used."
msgstr ""
"IPv6 のループバックアドレス (::1) は global 変数 I<in6addr_loopback> から取得"
"できる。初期化には B<IN6ADDR_LOOPBACK_INIT> を用いるべきである。"

#. type: Plain text
#: build/C/man7/ipv6.7:137
msgid ""
"IPv4 connections can be handled with the v6 API by using the v4-mapped-on-v6 "
"address type; thus a program needs to support only this API type to support "
"both protocols.  This is handled transparently by the address handling "
"functions in the C library."
msgstr ""
"v4-mapped-on-v6 アドレス型を用いることで、 IPv4 接続も v6 API で扱うことがで"
"きる。 こうすれば、プログラムは v6 の API をサポートするだけで、 両方のプロト"
"コルをサポートできる。 v4-mapped-on-v6 アドレス型は C ライブラリ内部のアドレ"
"スを 扱う関数によって透過的に処理される。"

#. type: Plain text
#: build/C/man7/ipv6.7:142
msgid ""
"IPv4 and IPv6 share the local port space.  When you get an IPv4 connection "
"or packet to an IPv6 socket, its source address will be mapped to v6 and it "
"will be mapped to v6."
msgstr ""
"IPv4 と IPv6 はローカルポート空間を共有する。 IPv4 の接続 (またはパケット) "
"を IPv6 ソケットが取得すると、 発信元アドレスが v6 にマップされ、その接続 (パ"
"ケット) も v6 にマップされる。"

#. type: Plain text
#: build/C/man7/ipv6.7:152
#, no-wrap
msgid ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"
msgstr ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ipv6.7:156
#, no-wrap
msgid ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"
msgstr ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/ipv6.7:178
msgid ""
"I<sin6_family> is always set to B<AF_INET6>; I<sin6_port> is the protocol "
"port (see I<sin_port> in B<ip>(7)); I<sin6_flowinfo> is the IPv6 flow "
"identifier; I<sin6_addr> is the 128-bit IPv6 address.  I<sin6_scope_id> is "
"an ID depending on the scope of the address.  It is new in Linux 2.4.  Linux "
"supports it only for link-local addresses, in that case I<sin6_scope_id> "
"contains the interface index (see B<netdevice>(7))"
msgstr ""
"I<sin6_family> は常に B<AF_INET6> に設定される。\n"
"I<sin6_port> はプロトコルポートである (B<ip>(7) の I<sin_port> を参照)。\n"
"I<sin6_flowinfo> は IPv6 のフロー指定子 (flow identifier) である。\n"
"I<sin6_addr> は 128 ビットの IPv6 アドレスである。 I<sin6_scope_id> は\n"
"アドレスのスコープに依存した ID である (これは Linux 2.4 で導入された)。\n"
"Linux の場合は、これはリンクローカルアドレスでのみサポートされている。\n"
"この場合 I<sin6_scope_id> にはインターフェースのインデックスが含まれる\n"
"ことになる (B<netdevice>(7) を参照)。"

#. type: Plain text
#: build/C/man7/ipv6.7:184
msgid ""
"IPv6 supports several address types: unicast to address a single host, "
"multicast to address a group of hosts, anycast to address the nearest member "
"of a group of hosts (not implemented in Linux), IPv4-on-IPv6 to address an "
"IPv4 host, and other reserved address types."
msgstr ""
"IPv6 は何種類かのアドレスタイプをサポートしている。 単一のホストをアドレスす"
"るための unicast、 ホストのグループをアドレスするための multicast、 ホストの"
"グループ中で最も近くにいるものをアドレスするための anycast (これは Linux では"
"実装されていない)、 IPv4 ホストをアドレスするための IPv4-on-IPv6。 他にも予約"
"済みのアドレスタイプがある。"

#. type: Plain text
#: build/C/man7/ipv6.7:190
msgid ""
"The address notation for IPv6 is a group of 8 4-digit hexadecimal numbers, "
"separated with a \\(aq:\\(aq.  \\&\"::\" stands for a string of 0 bits.  "
"Special addresses are ::1 for loopback and ::FFFF:E<lt>IPv4 addressE<gt> for "
"IPv4-mapped-on-IPv6."
msgstr ""
"IPv6 でのアドレス表記は 4 桁の 16 進数 8 個からなり、 \\(aq:\\(aq は区切り文"
"字はで、\"::\" は 0 ビットの文字列を表す。 特殊なアドレスとして、ループバック"
"を表す ::1、 IPv4-mapped-on-IPv6 を表す ::FFFF::E<lt>IPv4 アドレスE<gt> があ"
"る。"

#. type: Plain text
#: build/C/man7/ipv6.7:192
msgid "The port space of IPv6 is shared with IPv4."
msgstr "IPv6 のポート空間は IPv4 と共有されている。"

#. type: Plain text
#: build/C/man7/ipv6.7:200
msgid ""
"IPv6 supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IPv6 is B<IPPROTO_IPV6>.  A boolean integer flag is zero when it is "
"false, otherwise true."
msgstr ""
"IPv6 はプロトコル固有のソケットオプションをいくつかサポートしている。 これら"
"は B<setsockopt>(2)  で設定でき、 B<getsockopt>(2)  で取得できる。 IPv6 のソ"
"ケットオプションレベルは B<IPPROTO_IPV6> である。 ブール整数のフラグは、0 が"
"偽であり、それ以外は真である。"

#. type: TP
#: build/C/man7/ipv6.7:200
#, no-wrap
msgid "B<IPV6_ADDRFORM>"
msgstr "B<IPV6_ADDRFORM>"

#. type: Plain text
#: build/C/man7/ipv6.7:214
msgid ""
"Turn an B<AF_INET6> socket into a socket of a different address family.  "
"Only B<AF_INET> is currently supported for that.  It is allowed only for "
"IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address.  The "
"argument is a pointer to an integer containing B<AF_INET>.  This is useful "
"to pass v4-mapped sockets as file descriptors to programs that don't know "
"how to deal with the IPv6 API."
msgstr ""
"B<AF_INET6> ソケットを別のアドレスファミリーのソケットに変える。 現在は "
"B<AF_INET> のみが変更先のアドレスファミリーとしてサポートされている。 これが"
"許可されるのは、IPv6 が接続され、 v4-mapped-on-v6 アドレスにバインドされた場"
"合に限られる。 引数は B<AF_INET> が入っている整数へのポインターである。 v4-"
"mapped ソケットを、IPv6 API を扱えないプログラムに対して ファイルディスクリプ"
"ターとして渡す場合に便利。"

#. type: TP
#: build/C/man7/ipv6.7:214
#, no-wrap
msgid "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"
msgstr "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"

#. type: Plain text
#: build/C/man7/ipv6.7:219
msgid ""
"Control membership in multicast groups.  Argument is a pointer to a I<struct "
"ipv6_mreq>."
msgstr ""
"multicast グループのメンバーを制御する。 引数は I<struct ipv6_mreq> 構造体"
"へのポインター。"

#. type: TP
#: build/C/man7/ipv6.7:219
#, no-wrap
msgid "B<IPV6_MTU>"
msgstr "B<IPV6_MTU>"

#. type: Plain text
#: build/C/man7/ipv6.7:225
msgid ""
"B<getsockopt>(): Retrieve the current known path MTU of the current socket.  "
"Valid only when the socket has been connected.  Returns an integer."
msgstr ""
"B<getsockopt>(): ソケットの、既知の path MTU を取得する。ソケットが接続してい"
"る場合のみ有効である。整数を返す。"

#. type: Plain text
#: build/C/man7/ipv6.7:231
msgid ""
"B<setsockopt>(): Set the MTU to be used for the socket.  The MTU is limited "
"by the device MTU or the path MTU when path MTU discovery is enabled.  "
"Argument is a pointer to integer."
msgstr ""
"B<setsockopt>(): そのソケットに対して用いる MTU の値を設定する。 MTU の大きさ"
"は、 そのデバイスの MTU または (Path MTU Discovery が可能なら) その経路の "
"MTU の大きさ以下でなければならない。 引数は整数へのポインター。"

#. type: TP
#: build/C/man7/ipv6.7:231
#, no-wrap
msgid "B<IPV6_MTU_DISCOVER>"
msgstr "B<IPV6_MTU_DISCOVER>"

#. type: Plain text
#: build/C/man7/ipv6.7:239
msgid ""
"Control path-MTU discovery on the socket.  See B<IP_MTU_DISCOVER> in "
"B<ip>(7)  for details."
msgstr ""
"そのソケットでの Path MTU Discovery を制御する。 詳細は B<ip>(7)  の "
"B<IP_MTU_DISCOVER> を参照。"

#. type: TP
#: build/C/man7/ipv6.7:239
#, no-wrap
msgid "B<IPV6_MULTICAST_HOPS>"
msgstr "B<IPV6_MULTICAST_HOPS>"

#. type: Plain text
#: build/C/man7/ipv6.7:246
msgid ""
"Set the multicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""
"そのソケットでの multicast の hop 数の上限値を設定する。 引数は整数へのポイ"
"ンターである。 -1 を指定すると経路のデフォルトを用いることを意味する。 それ以"
"外の場合は 0 から 255 の範囲を指定する。"

#. type: TP
#: build/C/man7/ipv6.7:246
#, no-wrap
msgid "B<IPV6_MULTICAST_IF>"
msgstr "B<IPV6_MULTICAST_IF>"

#. type: Plain text
#: build/C/man7/ipv6.7:257
msgid ""
"Set the device for outgoing multicast packets on the socket.  This is "
"allowed only for B<SOCK_DGRAM> and B<SOCK_RAW> socket.  The argument is a "
"pointer to an interface index (see B<netdevice>(7))  in an integer."
msgstr ""
"そのソケットでの、送信 multicast パケットに用いるデバイスを設定する。 これは "
"B<SOCK_DGRAM> および B<SOCK_RAW> 各ソケットでのみ許される。 引数はインター"
"フェースのインデックスの整数値 (B<netdevice>(7)  を参照) へのポインターであ"
"る。"

#. type: TP
#: build/C/man7/ipv6.7:257
#, no-wrap
msgid "B<IPV6_MULTICAST_LOOP>"
msgstr "B<IPV6_MULTICAST_LOOP>"

#. type: Plain text
#: build/C/man7/ipv6.7:261
msgid ""
"Control whether the socket sees multicast packets that it has send itself.  "
"Argument is a pointer to boolean."
msgstr ""
"ソケットが、自分自身の送信した multicast パケットを監視するかどうかを制御す"
"る。 引数はブール値へのポインター。"

#. type: TP
#: build/C/man7/ipv6.7:261
#, no-wrap
msgid "B<IPV6_RECVPKTINFO> (since Linux 2.6.14)"
msgstr "B<IPV6_RECVPKTINFO> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/ipv6.7:275
msgid ""
"Set delivery of the B<IPV6_PKTINFO> control message on incoming datagrams.  "
"Such control messages contain a I<struct in6_pktinfo>, as per RFC 3542.  "
"Allowed only for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value in an integer."
msgstr ""
"データグラムの到着時における B<IPV6_PKTINFO> 制御メッセージを配送するかどうか"
"を設定する。 制御メッセージは RFC 3542 に基づき I<struct in6_pktinfo> に格納"
"される。 B<SOCK_DGRAM> ソケットまたは B<SOCK_RAW> ソケットに対してのみ許可さ"
"れる。 引数はブール値の入った整数。"

#. type: Plain text
#: build/C/man7/ipv6.7:278
#, no-wrap
msgid "B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, IPV6_HOPLIMIT>\n"
msgstr "B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, IPV6_HOPLIMIT>\n"

#. type: Plain text
#: build/C/man7/ipv6.7:303
msgid ""
"Set delivery of control messages for incoming datagrams containing extension "
"headers from the received packet.  B<IPV6_RTHDR> delivers the routing "
"header, B<IPV6_AUTHHDR> delivers the authentication header, B<IPV6_DSTOPTS> "
"delivers the destination options, B<IPV6_HOPOPTS> delivers the hop options, "
"B<IPV6_FLOWINFO> delivers an integer containing the flow ID, "
"B<IPV6_HOPLIMIT> delivers an integer containing the hop count of the "
"packet.  The control messages have the same type as the socket option.  All "
"these header options can also be set for outgoing packets by putting the "
"appropriate control message into the control buffer of B<sendmsg>(2).  "
"Allowed only for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value."
msgstr ""
"受信パケットのデータグラムに拡張ヘッダーが含まれている場合の、 制御メッセージ"
"の配送を設定する。 B<IPV6_RTHDR>: routing ヘッダーを配送するかどうか。 "
"B<IPV6_AUTHHDR>: authentication ヘッダーを配送するかどうか。 "
"B<IPV6_DSTOPTS>: destination オプションを配送するかどうか。 B<IPV6_HOPOPTS>: "
"hop オプションを配送するかどうか。 B<IPV6_FLOWINFO>: flow ID を含む整数を配送"
"するかどうか。 B<IPV6_HOPLIMIT>: パケットの hop カウントを含む整数を配送する"
"かどうか。 制御メッセージはソケットオプションのものと同じタイプを持つ。 これ"
"らのすべてのヘッダーオプションは、 適切な制御メッセージを B<sendmsg>(2)  の制"
"御バッファーに書きこめば、 送信パケットにでも設定できる。 B<SOCK_DGRAM> ソ"
"ケットまたは B<SOCK_RAW> ソケットでのみ許される。引数はブール値へのポイン"
"ター。"

#. type: TP
#: build/C/man7/ipv6.7:303
#, no-wrap
msgid "B<IPV6_RECVERR>"
msgstr "B<IPV6_RECVERR>"

#. type: Plain text
#: build/C/man7/ipv6.7:312
msgid ""
"Control receiving of asynchronous error options.  See B<IP_RECVERR> in "
"B<ip>(7)  for details.  Argument is a pointer to boolean."
msgstr ""
"非同期エラー (asynchronous error) オプションの受信を制御する。 詳細は "
"B<ip>(7)  の B<IP_RECVERR> を参照。 引数はブール値へのポインター。"

#. type: TP
#: build/C/man7/ipv6.7:312
#, no-wrap
msgid "B<IPV6_ROUTER_ALERT>"
msgstr "B<IPV6_ROUTER_ALERT>"

#. type: Plain text
#: build/C/man7/ipv6.7:327
msgid ""
"Pass forwarded packets containing a router alert hop-by-hop option to this "
"socket.  Allowed only for B<SOCK_RAW> sockets.  The tapped packets are not "
"forwarded by the kernel, it is the user's responsibility to send them out "
"again.  Argument is a pointer to an integer.  A positive integer indicates a "
"router alert option value to intercept.  Packets carrying a router alert "
"option with a value field containing this integer will be delivered to the "
"socket.  A negative integer disables delivery of packets with router alert "
"options to this socket."
msgstr ""
"このソケットで、router alert hop-by-hop オプションの付いた転送パケットを 通す"
"かどうかを制御する。 B<SOCK_RAW> ソケットでのみ許可される。 tap されたパケッ"
"トはカーネルによっては転送されない。そうしたパケットを 再度送信するのはユー"
"ザーの責任である。 引数は整数 (integer) へのポインター。 正の整数は傍受を行"
"う router alert オプション値を示す。 オプション値がこの整数である router "
"alert オプションの付いたパケットは ソケットに配送される。負の整数を指定する"
"と、このソケットへの router alert オプションの付いたパケットの配送が行われな"
"い。"

#. type: TP
#: build/C/man7/ipv6.7:327
#, no-wrap
msgid "B<IPV6_UNICAST_HOPS>"
msgstr "B<IPV6_UNICAST_HOPS>"

#. type: Plain text
#: build/C/man7/ipv6.7:333
msgid ""
"Set the unicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""
"そのソケットでの unicast の hop 数の上限値を設定する。 引数は整数へのポイン"
"ターである。 -1 を指定すると経路のデフォルトを用いることを意味する。 それ以外"
"の場合は 0 から 255 の範囲を指定する。"

#. type: TP
#: build/C/man7/ipv6.7:333
#, no-wrap
msgid "B<IPV6_V6ONLY> (since Linux 2.4.21 and 2.6)"
msgstr "B<IPV6_V6ONLY> (Linux 2.4.21 以降および 2.6 以降)"

#.  See RFC 3493
#. type: Plain text
#: build/C/man7/ipv6.7:340
msgid ""
"If this flag is set to true (nonzero), then the socket is restricted to "
"sending and receiving IPv6 packets only.  In this case, an IPv4 and an IPv6 "
"application can bind to a single port at the same time."
msgstr ""
"このフラグを真 (0 以外) に設定すると、そのソケットは IPv6 パケットだけを 送受"
"信するように制限される。 この場合、IPv4 アプリケーションと IPv6 アプリケー"
"ションが同時に 一つのポートをバインドできる。"

#. type: Plain text
#: build/C/man7/ipv6.7:344
msgid ""
"If this flag is set to false (zero), then the socket can be used to send and "
"receive packets to and from an IPv6 address or an IPv4-mapped IPv6 address."
msgstr ""
"このフラグを偽 (0) に設定すると、そのソケットはパケットの送受信に IPv6 アドレ"
"スと IPv4-mapped IPv6 アドレスの両方を使用できる。"

#. type: Plain text
#: build/C/man7/ipv6.7:346
msgid "The argument is a pointer to a boolean value in an integer."
msgstr "引数はブール値の入った整数へのポインターである。"

#.  FLOWLABEL_MGR, FLOWINFO_SEND
#. type: Plain text
#: build/C/man7/ipv6.7:351
msgid ""
"The default value for this flag is defined by the contents of the file I</"
"proc/sys/net/ipv6/bindv6only>.  The default value for that file is 0 (false)."
msgstr ""
"このフラグのデフォルト値はファイル I</proc/sys/net/ipv6/bindv6only> の内容に"
"より定義される。 このファイルのデフォルト値は 0 (偽) である。"

#. type: Plain text
#: build/C/man7/ipv6.7:362
msgid ""
"The user tried to B<bind>(2)  to a link-local IPv6 address, but the "
"I<sin6_scope_id> in the supplied I<sockaddr_in6> structure is not a valid "
"interface index."
msgstr ""
"ユーザーがリンクローカルの IPv6 アドレスを B<bind>(2) しようとしたが、\n"
"指定された I<sockaddr_in6> 構造体の I<sin6_scope_id> が\n"
"有効なインターフェースのインデックスでなかった。"

#. type: Plain text
#: build/C/man7/ipv6.7:378
msgid ""
"Linux 2.4 will break binary compatibility for the I<sockaddr_in6> for 64-bit "
"hosts by changing the alignment of I<in6_addr> and adding an additional "
"I<sin6_scope_id> field.  The kernel interfaces stay compatible, but a "
"program including I<sockaddr_in6> or I<in6_addr> into other structures may "
"not be.  This is not a problem for 32-bit hosts like i386."
msgstr ""
"Linux 2.4 では 64 ビットのホストに対して I<sockaddr_in6> のバイナリ互換性が保"
"たれていない。 I<in6_addr> のアラインメントが変更され、また I<sin6_scope_id> "
"フィールドが新たに追加されたからである。 カーネルインターフェースの互換性は保"
"たれているが、 I<sockaddr_in6> や I<in6_addr> を他の構造体に含んでいるような"
"プログラムでは 保たれないかもしれない。 これは i386 のような 32 ビットのホス"
"トでは問題にならない。"

#. type: Plain text
#: build/C/man7/ipv6.7:386
msgid ""
"The I<sin6_flowinfo> field is new in Linux 2.4.  It is transparently passed/"
"read by the kernel when the passed address length contains it.  Some "
"programs that pass a longer address buffer and then check the outgoing "
"address length may break."
msgstr ""
"I<sin6_flowinfo> フィールドは Linux 2.4 で登場した。 これが渡されたアドレス長"
"に含まれていると、 カーネルに透過的に渡され、読まれる。 より長いアドレスバッ"
"ファーを渡し、 そして送信アドレスの長さをチェックするようなプログラムは うま"
"く動かないかもしれない。"

#. type: Plain text
#: build/C/man7/ipv6.7:396
msgid ""
"The I<sockaddr_in6> structure is bigger than the generic I<sockaddr>.  "
"Programs that assume that all address types can be stored safely in a "
"I<struct sockaddr> need to be changed to use I<struct sockaddr_storage> for "
"that instead."
msgstr ""
"I<sockaddr_in6> 構造体はジェネリックな I<sockaddr> よりも大きい。 すべてのア"
"ドレスタイプが I<struct sockaddr> の中に安全に納められると仮定しているプログ"
"ラムは、代わりに I<struct sockaddr_storage> を用いるように変更する必要があ"
"る。"

#. type: Plain text
#: build/C/man7/ipv6.7:406
msgid ""
"B<SOL_IP>, B<SOL_IPV6>, B<SOL_ICMPV6>, and other B<SOL_*> socket options are "
"nonportable variants of B<IPPROTO_*>.  See also B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:411
msgid ""
"The IPv6 extended API as in RFC\\ 2292 is currently only partly implemented; "
"although the 2.2 kernel has near complete support for receiving options, the "
"macros for generating IPv6 options are missing in glibc 2.1."
msgstr ""
"IPv6 拡張 API は、現在まだ RFC\\ 2292 を完全には実装していない。 2.2 カーネル"
"は受信オプションをほぼ完全にサポートサポートしているが、 glibc2.1 には IPv6 "
"オプションを生成するマクロが存在していない。"

#. type: Plain text
#: build/C/man7/ipv6.7:413
msgid "IPSec support for EH and AH headers is missing."
msgstr "EH および AH ヘッダー での IPSec のサポートは存在しない。"

#. type: Plain text
#: build/C/man7/ipv6.7:415
msgid "Flow label management is not complete and not documented here."
msgstr "フローラベル管理はまだ完全でなく、ここにも記述されていない。"

#. type: Plain text
#: build/C/man7/ipv6.7:417
msgid "This man page is not complete."
msgstr "この man ページはまだ完成していない。"

#. type: Plain text
#: build/C/man7/ipv6.7:420
msgid "B<cmsg>(3), B<ip>(7)"
msgstr "B<cmsg>(3), B<ip>(7)"

#. type: Plain text
#: build/C/man7/ipv6.7:424
msgid ""
"RFC\\ 2553: IPv6 BASIC API; Linux tries to be compliant to this.  RFC\\ "
"2460: IPv6 specification."
msgstr ""
"RFC\\ 2553: IPv6 BASIC API; Linux はこの RFC に準拠するようにしている。 RFC"
"\\ 2460: IPv6 specification."

#. type: TH
#: build/C/man7/netdevice.7:17
#, no-wrap
msgid "NETDEVICE"
msgstr "NETDEVICE"

#. type: Plain text
#: build/C/man7/netdevice.7:20
msgid "netdevice - low-level access to Linux network devices"
msgstr "netdevice - Linux ネットワークデバイスへの低レベルアクセス"

#. type: Plain text
#: build/C/man7/netdevice.7:22
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#. type: Plain text
#: build/C/man7/netdevice.7:24
msgid "B<#include E<lt>net/if.hE<gt>>"
msgstr "B<#include E<lt>net/if.hE<gt>>"

#. type: Plain text
#: build/C/man7/netdevice.7:27
msgid ""
"This man page describes the sockets interface which is used to configure "
"network devices."
msgstr ""
"この man ページでは、ネットワークデバイスを設定するために 用いるソケットイン"
"ターフェースについて解説する。"

#. type: Plain text
#: build/C/man7/netdevice.7:34
msgid ""
"Linux supports some standard ioctls to configure network devices.  They can "
"be used on any socket's file descriptor regardless of the family or type.  "
"Most of them pass an I<ifreq> structure:"
msgstr ""
"Linux はネットワークデバイスを設定するための標準的な ioctl を いくつか備えて"
"いる。これらはどんなソケットのファイルディスクリプターにも 用いることができ"
"る。ファミリーやタイプは何でもよい。 これらの ioctl のほとんどは I<ifreq> 構"
"造体を渡す。"

#. type: Plain text
#: build/C/man7/netdevice.7:55
#, no-wrap
msgid ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"
msgstr ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:63
msgid ""
"Normally, the user specifies which device to affect by setting I<ifr_name> "
"to the name of the interface.  All other members of the structure may share "
"memory."
msgstr ""
"通常、ユーザーによる設定対象デバイスの指定は、 I<ifr_name> にインターフェース"
"の名前をセットすることによって行う。 他の構造体の全てのメンバは、メモリーを共"
"有する。"

#. type: Plain text
#: build/C/man7/netdevice.7:71
msgid ""
"If an ioctl is marked as privileged, then using it requires an effective "
"user ID of 0 or the B<CAP_NET_ADMIN> capability.  If this is not the case, "
"B<EPERM> will be returned."
msgstr ""
"「特権が必要」と記述されている ioctl を実行するには、 実効ユーザー ID が 0 "
"か、 B<CAP_NET_ADMIN> 権限が必要である。これが満たされていない場合は "
"B<EPERM> が返される。"

#. type: TP
#: build/C/man7/netdevice.7:71
#, no-wrap
msgid "B<SIOCGIFNAME>"
msgstr "B<SIOCGIFNAME>"

#. type: Plain text
#: build/C/man7/netdevice.7:79
msgid ""
"Given the I<ifr_ifindex>, return the name of the interface in I<ifr_name>.  "
"This is the only ioctl which returns its result in I<ifr_name>."
msgstr ""
"I<ifr_ifindex> を受け取り、インターフェースの名前を I<ifr_name> に入れて返"
"す。これは結果を I<ifr_name> として返す唯一の ioctl である。"

#. type: TP
#: build/C/man7/netdevice.7:79
#, no-wrap
msgid "B<SIOCGIFINDEX>"
msgstr "B<SIOCGIFINDEX>"

#. type: Plain text
#: build/C/man7/netdevice.7:83
msgid "Retrieve the interface index of the interface into I<ifr_ifindex>."
msgstr ""
"インターフェースの interface index を取得し、 I<ifr_ifindex> に入れて返す。"

#. type: TP
#: build/C/man7/netdevice.7:83
#, no-wrap
msgid "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"
msgstr "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"

#.  Do not right adjust text blocks in tables
#. type: Plain text
#: build/C/man7/netdevice.7:89
msgid ""
"Get or set the active flag word of the device.  I<ifr_flags> contains a bit "
"mask of the following values:"
msgstr ""
"デバイスの active フラグワードを取得または設定する。 I<ifr_flags> には以下の"
"値のビットマスクが入る。"

#. type: tbl table
#: build/C/man7/netdevice.7:94
#, no-wrap
msgid "Device flags"
msgstr "デバイスフラグ"

#. type: tbl table
#: build/C/man7/netdevice.7:95
#, no-wrap
msgid "IFF_UP"
msgstr "IFF_UP"

#. type: tbl table
#: build/C/man7/netdevice.7:95
#, no-wrap
msgid "Interface is running."
msgstr "インターフェースは動作中。"

#. type: tbl table
#: build/C/man7/netdevice.7:96
#, no-wrap
msgid "IFF_BROADCAST"
msgstr "IFF_BROADCAST"

#. type: tbl table
#: build/C/man7/netdevice.7:96
#, no-wrap
msgid "Valid broadcast address set."
msgstr "有効なブロードキャストアドレスがセットされている。"

#. type: tbl table
#: build/C/man7/netdevice.7:97
#, no-wrap
msgid "IFF_DEBUG"
msgstr "IFF_DEBUG"

#. type: tbl table
#: build/C/man7/netdevice.7:97
#, no-wrap
msgid "Internal debugging flag."
msgstr "内部のデバッグフラグ。"

#. type: tbl table
#: build/C/man7/netdevice.7:98
#, no-wrap
msgid "IFF_LOOPBACK"
msgstr "IFF_LOOPBACK"

#. type: tbl table
#: build/C/man7/netdevice.7:98
#, no-wrap
msgid "Interface is a loopback interface."
msgstr "インターフェースはループバックである。"

#. type: tbl table
#: build/C/man7/netdevice.7:99
#, no-wrap
msgid "IFF_POINTOPOINT"
msgstr "IFF_POINTOPOINT"

#. type: tbl table
#: build/C/man7/netdevice.7:99
#, no-wrap
msgid "Interface is a point-to-point link."
msgstr "インターフェースは point-to-point リンクである。"

#. type: tbl table
#: build/C/man7/netdevice.7:100
#, no-wrap
msgid "IFF_RUNNING"
msgstr "IFF_RUNNING"

#. type: tbl table
#: build/C/man7/netdevice.7:100
#, no-wrap
msgid "Resources allocated."
msgstr "リソースが割り当て済み。"

#. type: tbl table
#: build/C/man7/netdevice.7:101
#, no-wrap
msgid "IFF_NOARP"
msgstr "IFF_NOARP"

#. type: tbl table
#: build/C/man7/netdevice.7:103
#, no-wrap
msgid "No arp protocol, L2 destination address not set."
msgstr "arp プロトコルがない。 L2 宛先アドレスが設定されていない。"

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "IFF_PROMISC"
msgstr "IFF_PROMISC"

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "Interface is in promiscuous mode."
msgstr "インターフェースは promiscuous モードである。"

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "IFF_NOTRAILERS"
msgstr "IFF_NOTRAILERS"

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "Avoid use of trailers."
msgstr "trailer の利用を避ける。"

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "IFF_ALLMULTI"
msgstr "IFF_ALLMULTI"

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "Receive all multicast packets."
msgstr "全てのマルチキャストパケットを受信する。"

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "IFF_MASTER"
msgstr "IFF_MASTER"

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "Master of a load balancing bundle."
msgstr "負荷分散グループのマスターである。"

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "IFF_SLAVE"
msgstr "IFF_SLAVE"

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "Slave of a load balancing bundle."
msgstr "負荷分散グループのスレーブである。"

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "IFF_MULTICAST"
msgstr "IFF_MULTICAST"

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "Supports multicast"
msgstr "マルチキャストをサポートしている。"

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "IFF_PORTSEL"
msgstr "IFF_PORTSEL"

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "Is able to select media type via ifmap."
msgstr "ifmap によってメディアタイプを選択できる。"

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "IFF_AUTOMEDIA"
msgstr "IFF_AUTOMEDIA"

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "Auto media selection active."
msgstr "自動メディア選択が有効になっている。"

#. type: tbl table
#: build/C/man7/netdevice.7:112
#, no-wrap
msgid "IFF_DYNAMIC"
msgstr "IFF_DYNAMIC"

#. type: tbl table
#: build/C/man7/netdevice.7:114
#, no-wrap
msgid "The addresses are lost when the interface goes down."
msgstr "このインターフェースが閉じると、アドレスは失われる。"

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "IFF_LOWER_UP"
msgstr "IFF_LOWER_UP"

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "Driver signals L1 up (since Linux 2.6.17)"
msgstr "ドライバからの L1 アップの通知 (Linux 2.6.17 以降)"

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "IFF_DORMANT"
msgstr "IFF_DORMANT"

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "Driver signals dormant (since Linux 2.6.17)"
msgstr "ドライバからの休止状態の通知 (Linux 2.6.17 以降)"

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "IFF_ECHO"
msgstr "IFF_ECHO"

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "Echo sent packets (since Linux 2.6.25)"
msgstr "送られたパケットをエコーする (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/netdevice.7:123
msgid ""
"Setting the active flag word is a privileged operation, but any process may "
"read it."
msgstr ""
"active フラグワードの設定は特権が必要な操作である。\n"
"読み出しはどんなプロセスからも可能である。"

#. type: TP
#: build/C/man7/netdevice.7:123
#, no-wrap
msgid "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"
msgstr "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"

#. type: Plain text
#: build/C/man7/netdevice.7:128
msgid ""
"Get or set extended (private) flags for the device.  I<ifr_flags> contains a "
"bit mask of the following values:"
msgstr ""
"デバイスの拡張 (プライベート) フラグを取得または設定する。\n"
"I<ifr_flags> には以下の値のビットマスクが入る。"

#. type: tbl table
#: build/C/man7/netdevice.7:132
#, no-wrap
msgid "Private flags"
msgstr "プライベートフラグ"

#. type: tbl table
#: build/C/man7/netdevice.7:133
#, no-wrap
msgid "IFF_802_1Q_VLAN"
msgstr "IFF_802_1Q_VLAN"

#. type: tbl table
#: build/C/man7/netdevice.7:133
#, no-wrap
msgid "Interface is 802.1Q VLAN device."
msgstr "インターフェースは 802.1Q VLAN デバイスである。"

#. type: tbl table
#: build/C/man7/netdevice.7:134
#, no-wrap
msgid "IFF_EBRIDGE"
msgstr "IFF_EBRIDGE"

#. type: tbl table
#: build/C/man7/netdevice.7:134
#, no-wrap
msgid "Interface is Ethernet bridging device."
msgstr "インターフェースは Ethernet ブリッジデバイスである。"

#. type: tbl table
#: build/C/man7/netdevice.7:135
#, no-wrap
msgid "IFF_SLAVE_INACTIVE"
msgstr "IFF_SLAVE_INACTIVE"

#. type: tbl table
#: build/C/man7/netdevice.7:135
#, no-wrap
msgid "Interface is inactive bonding slave."
msgstr "インターフェースは非アクティブな bonding のスレーブである。"

#. type: tbl table
#: build/C/man7/netdevice.7:136
#, no-wrap
msgid "IFF_MASTER_8023AD"
msgstr "IFF_MASTER_8023AD"

#. type: tbl table
#: build/C/man7/netdevice.7:136
#, no-wrap
msgid "Interface is 802.3ad bonding master."
msgstr "インターフェースは 802.3ad bonding のマスターである。"

#. type: tbl table
#: build/C/man7/netdevice.7:137
#, no-wrap
msgid "IFF_MASTER_ALB"
msgstr "IFF_MASTER_ALB"

#. type: tbl table
#: build/C/man7/netdevice.7:137
#, no-wrap
msgid "Interface is balanced-alb bonding master."
msgstr "インターフェースは balanced-alb bonding のマスターである。"

#. type: tbl table
#: build/C/man7/netdevice.7:138
#, no-wrap
msgid "IFF_BONDING"
msgstr "IFF_BONDING"

#. type: tbl table
#: build/C/man7/netdevice.7:138
#, no-wrap
msgid "Interface is a bonding master or slave."
msgstr "インターフェースは bonding のマスターかスレーブである。"

#. type: tbl table
#: build/C/man7/netdevice.7:139
#, no-wrap
msgid "IFF_SLAVE_NEEDARP"
msgstr "IFF_SLAVE_NEEDARP"

#. type: tbl table
#: build/C/man7/netdevice.7:139
#, no-wrap
msgid "Interface needs ARPs for validation."
msgstr "インターフェースは検証に APR が必要である。"

#. type: tbl table
#: build/C/man7/netdevice.7:140
#, no-wrap
msgid "IFF_ISATAP"
msgstr "IFF_ISATAP"

#. type: tbl table
#: build/C/man7/netdevice.7:140
#, no-wrap
msgid "Interface is RFC4214 ISATAP interface."
msgstr "インターフェースは RFC4214 ISATAP インターフェースである。"

#. type: Plain text
#: build/C/man7/netdevice.7:144
msgid ""
"Setting the extended (private) interface flags is a privileged operation."
msgstr "拡張 (プライベート) インターフェースフラグの設定には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:144
#, no-wrap
msgid "B<SIOCGIFADDR>, B<SIOCSIFADDR>"
msgstr "B<SIOCGIFADDR>, B<SIOCSIFADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:152
msgid ""
"Get or set the address of the device using I<ifr_addr>.  Setting the "
"interface address is a privileged operation.  For compatibility, only "
"B<AF_INET> addresses are accepted or returned."
msgstr ""
"I<ifr_addr> を用いてデバイスのアドレスの設定/取得を行う。\n"
"インターフェースのアドレスの設定は特権が必要な操作である。\n"
"互換性確保のため、設定/取得ができるのは B<AF_INET> アドレスだけである。"

#. type: TP
#: build/C/man7/netdevice.7:152
#, no-wrap
msgid "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"
msgstr "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:160
msgid ""
"Get or set the destination address of a point-to-point device using "
"I<ifr_dstaddr>.  For compatibility, only B<AF_INET> addresses are accepted "
"or returned.  Setting the destination address is a privileged operation."
msgstr ""
"point-to-point デバイスの宛先アドレスを I<ifr_dstaddr> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"宛先アドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:160
#, no-wrap
msgid "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"
msgstr "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:168
msgid ""
"Get or set the broadcast address for a device using I<ifr_brdaddr>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the broadcast address is a privileged operation."
msgstr ""
"デバイスのブロードキャストアドレスを I<ifr_brdaddr> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"ブロードキャストアドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:168
#, no-wrap
msgid "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"
msgstr "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"

#. type: Plain text
#: build/C/man7/netdevice.7:176
msgid ""
"Get or set the network mask for a device using I<ifr_netmask>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the network mask is a privileged operation."
msgstr ""
"デバイスのネットワークマスクを I<ifr_netmask> を用いて\n"
"設定/取得する。互換性確保のため、\n"
"設定/取得ができるのは B<AF_INET> アドレスだけである。\n"
"ネットワークマスクの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:176
#, no-wrap
msgid "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"
msgstr "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"

#. type: Plain text
#: build/C/man7/netdevice.7:185
msgid ""
"Get or set the metric of the device using I<ifr_metric>.  This is currently "
"not implemented; it sets I<ifr_metric> to 0 if you attempt to read it and "
"returns B<EOPNOTSUPP> if you attempt to set it."
msgstr ""
"デバイスのメトリックを I<ifr_metric> を用いて取得・設定する。 これはまだ実装"
"されていない。読み出そうとすると I<ifr_metric> に 0 をセットして返り、設定し"
"ようとすると B<EOPNOTSUPP> が返る。"

#. type: TP
#: build/C/man7/netdevice.7:185
#, no-wrap
msgid "B<SIOCGIFMTU>, B<SIOCSIFMTU>"
msgstr "B<SIOCGIFMTU>, B<SIOCSIFMTU>"

#. type: Plain text
#: build/C/man7/netdevice.7:192
msgid ""
"Get or set the MTU (Maximum Transfer Unit) of a device using I<ifr_mtu>.  "
"Setting the MTU is a privileged operation.  Setting the MTU to too small "
"values may cause kernel crashes."
msgstr ""
"デバイスの MTU (Maximum Transfer Unit) を I<ifr_mtu> を用いて取得・設定す"
"る。 MTU の設定は特権が必要な操作である。 MTU の値を小さくしすぎるとカーネル"
"がクラッシュするかもしれない。"

#. type: TP
#: build/C/man7/netdevice.7:192
#, no-wrap
msgid "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"
msgstr "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"

#. type: Plain text
#: build/C/man7/netdevice.7:203
msgid ""
"Get or set the hardware address of a device using I<ifr_hwaddr>.  The "
"hardware address is specified in a struct I<sockaddr>.  I<sa_family> "
"contains the ARPHRD_* device type, I<sa_data> the L2 hardware address "
"starting from byte 0.  Setting the hardware address is a privileged "
"operation."
msgstr ""
"デバイスのハードウェアアドレスを I<ifr_hwaddr> を用いて取得・設定する。 ハー"
"ドウェアアドレスは I<sockaddr> 構造体に設定される。 I<sa_family> には "
"ARPHRD_* デバイスタイプが入り、 I<sa_data> にはバイト 0 から始まる L2 ハード"
"ウェアアドレスが入る。 ハードウェアアドレスの設定は特権が必要な操作である。"

#. type: TP
#: build/C/man7/netdevice.7:203
#, no-wrap
msgid "B<SIOCSIFHWBROADCAST>"
msgstr "B<SIOCSIFHWBROADCAST>"

#. type: Plain text
#: build/C/man7/netdevice.7:208
msgid ""
"Set the hardware broadcast address of a device from I<ifr_hwaddr>.  This is "
"a privileged operation."
msgstr ""
"デバイスのハードウェアブロードキャストアドレスを I<ifr_hwaddr> の値に設定す"
"る。この操作には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:208
#, no-wrap
msgid "B<SIOCGIFMAP>, B<SIOCSIFMAP>"
msgstr "B<SIOCGIFMAP>, B<SIOCSIFMAP>"

#. type: Plain text
#: build/C/man7/netdevice.7:213
msgid ""
"Get or set the interface's hardware parameters using I<ifr_map>.  Setting "
"the parameters is a privileged operation."
msgstr ""
"インターフェースのハードウェアのパラメーターを I<ifr_map> を用いて取得・設定"
"する。 パラメーターの設定は特権が必要な操作である。"

#. type: Plain text
#: build/C/man7/netdevice.7:224
#, no-wrap
msgid ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"
msgstr ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:229
msgid ""
"The interpretation of the ifmap structure depends on the device driver and "
"the architecture."
msgstr "ifmap 構造体の解釈はデバイスドライバとアーキテクチャーに依存する。"

#. type: TP
#: build/C/man7/netdevice.7:229
#, no-wrap
msgid "B<SIOCADDMULTI>, B<SIOCDELMULTI>"
msgstr "B<SIOCADDMULTI>, B<SIOCDELMULTI>"

#. type: Plain text
#: build/C/man7/netdevice.7:238
msgid ""
"Add an address to or delete an address from the device's link layer "
"multicast filters using I<ifr_hwaddr>.  These are privileged operations.  "
"See also B<packet>(7)  for an alternative."
msgstr ""
"デバイスのリンク層のマルチキャストフィルターから、 I<ifr_hwaddr> のアドレスを"
"追加・削除する。これらの操作には特権が必要である。 別の方法が B<packet>(7)  "
"で解説されている。"

#. type: TP
#: build/C/man7/netdevice.7:238
#, no-wrap
msgid "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"
msgstr "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"

#. type: Plain text
#: build/C/man7/netdevice.7:243
msgid ""
"Get or set the transmit queue length of a device using I<ifr_qlen>.  Setting "
"the transmit queue length is a privileged operation."
msgstr ""
"デバイスの送信キューの長さを I<ifr_qlen> に取得・設定する。送信キューの長さの"
"設定には特権が必要である。"

#. type: TP
#: build/C/man7/netdevice.7:243
#, no-wrap
msgid "B<SIOCSIFNAME>"
msgstr "B<SIOCSIFNAME>"

#. type: Plain text
#: build/C/man7/netdevice.7:252
msgid ""
"Changes the name of the interface specified in I<ifr_name> to "
"I<ifr_newname>.  This is a privileged operation.  It is allowed only when "
"the interface is not up."
msgstr ""
"I<ifr_name> で指定したインターフェースの名前を I<ifr_newname> に変更する。こ"
"の操作には特権が必要である。インターフェースが up していない 時にのみ使用でき"
"る。"

#. type: TP
#: build/C/man7/netdevice.7:252
#, no-wrap
msgid "B<SIOCGIFCONF>"
msgstr "B<SIOCGIFCONF>"

#. type: Plain text
#: build/C/man7/netdevice.7:262
msgid ""
"Return a list of interface (network layer) addresses.  This currently means "
"only addresses of the B<AF_INET> (IPv4) family for compatibility.  Unlike "
"the others, this ioctl passes an I<ifconf> structure:"
msgstr "インターフェースの (ネットワーク層の) アドレスのリストを返す。 現在のところ、互換性のため返されるのは B<AF_INET> (IPv4) 系のアドレスだけである。 他の操作と違い、この ioctl では I<ifconf> 構造体を渡す。"

#. type: Plain text
#: build/C/man7/netdevice.7:272
#, no-wrap
msgid ""
"struct ifconf {\n"
"    int                 ifc_len; /* size of buffer */\n"
"    union {\n"
"        char           *ifc_buf; /* buffer address */\n"
"        struct ifreq   *ifc_req; /* array of structures */\n"
"    };\n"
"};\n"
msgstr ""
"struct ifconf {\n"
"    int                 ifc_len; /* バッファーサイズ */\n"
"    union {\n"
"        char           *ifc_buf; /* バッファーアドレス */\n"
"        struct ifreq   *ifc_req; /* 構造体の配列 */\n"
"    };\n"
"};\n"

#. type: Plain text
#: build/C/man7/netdevice.7:298
msgid ""
"If I<ifc_req> is NULL, B<SIOCGIFCONF> returns the necessary buffer size in "
"bytes for receiving all available addresses in I<ifc_len>.  Otherwise, "
"I<ifc_req> contains a pointer to an array of I<ifreq> structures to be "
"filled with all currently active L3 interface addresses.  I<ifc_len> "
"contains the size of the array in bytes.  Within each I<ifreq> structure, "
"I<ifr_name> will receive the interface name, and I<ifr_addr> the address.  "
"The actual number of bytes transferred is returned in I<ifc_len>."
msgstr ""
"I<ifc_req> が NULL の場合、 B<SIOCGIFCONF> はすべての取得できるアドレスを受け"
"取るのに必要なバッファーサイズ (バイト数) を I<ifc_len> に格納して返す。 それ"
"以外の場合は、I<ifc_req> には I<ifreq> 構造体の配列へのポインターを渡す。 こ"
"の構造体の配列には現在アクティブな L3 インターフェースアドレスがすべて格納さ"
"れる。 I<ifc_len> はバイト単位の配列のサイズを渡す。 I<ifreq> 構造体内では、 "
"I<ifr_name> にインターフェース名が、 I<ifr_addr> にそのアドレスが入る。 実際"
"に格納されたバイト数は I<ifc_len> で返される。"

#. type: Plain text
#: build/C/man7/netdevice.7:314
msgid ""
"If the size specified by I<ifc_len> is insufficient to store all the "
"addresses, the kernel will skip the exceeding ones and return success.  "
"There is no reliable way of detecting this condition once it has occurred.  "
"It is therefore recommended to either determine the necessary buffer size "
"beforehand by calling B<SIOCGIFCONF> with I<ifc_req> set to NULL, or to "
"retry the call with a bigger buffer whenever I<ifc_len> upon return differs "
"by less than I<sizeof(struct ifreq)> from its original value."
msgstr ""
"I<ifc_len> で指定されたサイズがすべてのアドレスを格納するのに不十分な場合、 "
"カーネルは超過分をスキップし、成功を返す。 この状況になった場合、それを検出す"
"る信頼できる方法はない。 したがって、 前もって I<ifc_req> を NULL に設定して "
"B<SIOCGIFCONF> を呼び出して必要なバッファーサイズを決定するか、 返された "
"I<ifc_len> と元の値の差分が I<sizeof(struct ifreq)> よりも小さい場合は必ず"
"バッファーを大きくして再度呼び出すか、 のいずれかを行うことが推奨される。 "

#.  Slaving isn't supported in 2.2
#.  .
#.  .TP
#.  .BR SIOCGIFSLAVE ", " SIOCSIFSLAVE
#.  Get or set the slave device using
#.  .IR ifr_slave .
#.  Setting the slave device is a privileged operation.
#.  .PP
#.  FIXME . add amateur radio stuff.
#. type: Plain text
#: build/C/man7/netdevice.7:331
msgid ""
"If an error occurs accessing the I<ifconf> or I<ifreq> structures, B<EFAULT> "
"will be returned."
msgstr ""
"I<ifconf> か I<ifreq> 構造体へのアクセスでエラーが置こった場合には B<EFAULT> "
"が返される。"

#. type: Plain text
#: build/C/man7/netdevice.7:337
msgid ""
"Most protocols support their own ioctls to configure protocol-specific "
"interface options.  See the protocol man pages for a description.  For "
"configuring IP addresses, see B<ip>(7)."
msgstr ""
"ほとんどのプロトコルには、専用のインターフェースオプションを 設定するための独"
"自の ioctl が存在する。 説明は各プロトコルの man ページを見よ。 IP アドレスの"
"設定に関しては B<ip>(7) を参照。"

#. type: Plain text
#: build/C/man7/netdevice.7:340
msgid ""
"In addition, some devices support private ioctls.  These are not described "
"here."
msgstr ""
"さらに、デバイスによってはプライベートな ioctl がある。 これらはここでは説明"
"しない。"

#. type: Plain text
#: build/C/man7/netdevice.7:347
#, fuzzy
#| msgid ""
#| "Strictly speaking, B<SIOCGIFCONF> and the other ioctls that accept or "
#| "return only B<AF_INET> socket addresses, are IP-specific and belong in "
#| "B<ip>(7)."
msgid ""
"B<SIOCGIFCONF> and the other ioctls that accept or return only B<AF_INET> "
"socket addresses are IP-specific and perhaps should rather be documented in "
"B<ip>(7)."
msgstr ""
"厳密にいうと、 B<SIOCGIFCONF> や、 B<AF_INET> ソケットアドレスだけを\n"
"引数に取ったり返したりする他の ioctl は IP 固有であり、 B<ip>(7) \n"
"に属する。"

#. type: Plain text
#: build/C/man7/netdevice.7:352
msgid ""
"The names of interfaces with no addresses or that don't have the "
"B<IFF_RUNNING> flag set can be found via I</proc/net/dev>."
msgstr ""
"アドレスがなかったり、 B<IFF_RUNNING> フラグがセットされていないインター"
"フェースの名前は I</proc/net/dev> で知ることができる。"

#. type: Plain text
#: build/C/man7/netdevice.7:357
msgid ""
"Local IPv6 IP addresses can be found via I</proc/net> or via B<rtnetlink>(7)."
msgstr ""
"ローカル IPV6 IP アドレスは I</proc/net> か B<rtnetlink>(7)  で知ることができ"
"る。"

#. type: Plain text
#: build/C/man7/netdevice.7:363
msgid ""
"glibc 2.1 is missing the I<ifr_newname> macro in I<E<lt>net/if.hE<gt>>.  Add "
"the following to your program as a workaround:"
msgstr ""
"glibc 2.1 では I<E<lt>net/if.hE<gt>> に I<ifr_newname> マクロがない。 とりあ"
"えずの対応策として、以下のコードを追加しておくこと。"

#. type: Plain text
#: build/C/man7/netdevice.7:369
#, no-wrap
msgid ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"
msgstr ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"

#. type: Plain text
#: build/C/man7/netdevice.7:376
msgid "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"
msgstr "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "NETWORKS"
msgstr "NETWORKS"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "2008-09-04"
msgstr "2008-09-04"

#. type: TH
#: build/C/man5/networks.5:26
#, no-wrap
msgid "GNU/Linux"
msgstr "GNU/Linux"

#. type: Plain text
#: build/C/man5/networks.5:29
msgid "networks - network name information"
msgstr "networks - ネットワーク名の情報"

#. type: Plain text
#: build/C/man5/networks.5:35
msgid ""
"The file I</etc/networks> is a plain ASCII file that describes known DARPA "
"networks and symbolic names for these networks.  Each line represents a "
"network and has the following structure:"
msgstr ""
"I</etc/networks> ファイルは、通常の ASCII ファイルで、よく使われる\n"
"DARPA ネットワークとその分かりやすい名前を記載したファイルである。\n"
"各行が一つのネットワークを表し、以下の構造となっている。"

#. type: Plain text
#: build/C/man5/networks.5:38
msgid "I<name number aliases ...>"
msgstr "I<name number aliases ...>"

#. type: Plain text
#: build/C/man5/networks.5:46
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"The hash character (B<#>) indicates the start of a comment: this character, "
"and the remaining characters up to the end of the current line, are ignored "
"by library functions that process the file."
msgstr ""
"フィールドはスペースかタブで区切られる。空行は無視される。\n"
"ハッシュ文字 (B<#>) はコメントの開始を示し、このファイルを処理する\n"
"ライブラリ関数はこの文字とその行のそれ以降の文字を無視する。"

#. type: Plain text
#: build/C/man5/networks.5:48 build/C/man5/protocols.5:59
msgid "The field descriptions are:"
msgstr "フィールドの説明は以下のとおり。"

#. type: TP
#: build/C/man5/networks.5:48
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
#: build/C/man5/networks.5:53
msgid ""
"The symbolic name for the network.  Network names can contain any printable "
"characters except white-space characters or the comment character."
msgstr ""
"ネットワークの分かりやすい名前 (symbolic name)。 ネットワーク名には、ホワイト"
"スペースとコメント文字以外の印字可能な文字を使うことができる。"

#. type: TP
#: build/C/man5/networks.5:53 build/C/man5/protocols.5:67
#, no-wrap
msgid "I<number>"
msgstr "I<number>"

#. type: Plain text
#: build/C/man5/networks.5:58
msgid ""
"The official number for this network in numbers-and-dots notation (see "
"B<inet>(3)).  The trailing \".0\" (for the host component of the network "
"address) may be omitted."
msgstr ""
"このネットワークの正式な数字での値。\n"
"ドット区切りの数字表記 (B<inet>(3) 参照) で記載する。\n"
"末尾の \".0\" (ネットワークアドレスのホスト部分) は省略してもよい。"

#. type: TP
#: build/C/man5/networks.5:58 build/C/man5/protocols.5:71
#: build/C/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr "I<aliases>"

#. type: Plain text
#: build/C/man5/networks.5:61
msgid "Optional aliases for the network."
msgstr "そのネットワークの別名 (省略可能)。"

#. type: Plain text
#: build/C/man5/networks.5:70
msgid ""
"This file is read by the B<route>(8)  and B<netstat>(8)  utilities.  Only "
"Class A, B or C networks are supported, partitioned networks (i.e., "
"network/26 or network/28) are not supported by this file."
msgstr "このファイルは、 B<route>(8) と B<netstat>(8) ユーティリティにより利用される。クラス A, B, C のネットワークだけがサポートされており、 (network/26 や network/28 といった) 分割されたネットワークはこのファイルではサポートされていない。"

#. type: Plain text
#: build/C/man5/networks.5:74
msgid "The networks definition file."
msgstr "ネットワーク定義ファイル。"

#. type: Plain text
#: build/C/man5/networks.5:80
msgid ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"
msgstr ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "NSCD"
msgstr "NSCD"

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "2015-05-07"
msgstr "2015-05-07"

#. type: Plain text
#: build/C/man8/nscd.8:26
msgid "nscd - name service cache daemon"
msgstr "nscd - ネームサービスキャッシュデーモン"

#. type: Plain text
#: build/C/man8/nscd.8:35
msgid ""
"B<nscd> is a daemon that provides a cache for the most common name service "
"requests.  The default configuration file, I</etc/nscd.conf>, determines the "
"behavior of the cache daemon.  See B<nscd.conf>(5)."
msgstr "B<nscd> は一般的なネームサービスに必要な多くのものを キャッシュとして提供するデーモンである。 デフォルトの設定ファイル I</etc/nscd.conf> でキャッシュデーモンの動作を決定する。 B<nscd.conf>(5)  を見よ。"

#. type: Plain text
#: build/C/man8/nscd.8:51
#, fuzzy
#| msgid ""
#| "Nscd provides caching for accesses of the B<passwd>(5), B<group>(5), and "
#| "B<hosts>(5)  databases through standard libc interfaces, such as "
#| "B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), B<getgrgid>(3), "
#| "B<gethostbyname>(3), and others."
msgid ""
"B<nscd> provides caching for accesses of the B<passwd>(5), B<group>(5), "
"B<hosts>(5)  B<services>(5)  and I<netgroup> databases through standard libc "
"interfaces, such as B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), "
"B<getgrgid>(3), B<gethostbyname>(3), and others."
msgstr ""
"nscd は B<passwd>(5), B<group>(5), B<hosts>(5)  データベースへのアクセスの"
"キャッシュを B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), B<getgrgid>(3), "
"B<gethostbyname>(3)  などの標準 libc インターフェースを通して提供する。"

#. type: Plain text
#: build/C/man8/nscd.8:60
msgid ""
"There are two caches for each database: a positive one for items found, and "
"a negative one for items not found.  Each cache has a separate TTL (time-to-"
"live)  period for its data.  Note that the shadow file is specifically not "
"cached.  B<getspnam>(3)  calls remain uncached as a result."
msgstr ""
"各データベースには 2 つのキャッシュがある。 肯定的 (positive) なキャッシュは"
"見つかったアイテムをキャッシュし、 否定的 (negative) なキャッシュは見つからな"
"かったアイテムをキャッシュする。 各キャッシュはデータの TTL (time-to-live, 生"
"存時間) を個別に持っている。 特例として shadow ファイルはキャッシュされない点"
"に注意すること。 B<getspnam>(3)  を呼び出しても結果としてキャッシュされないま"
"まになる。"

#. type: TP
#: build/C/man8/nscd.8:61
#, no-wrap
msgid "B<--help>"
msgstr "B<--help>"

#. type: Plain text
#: build/C/man8/nscd.8:64
msgid "will give you a list with all options and what they do."
msgstr "全てのオプションとその動作をリストして表示する。"

#. type: Plain text
#: build/C/man8/nscd.8:87
msgid ""
"The daemon will try to watch for changes in configuration files appropriate "
"for each database (e.g., I</etc/passwd> for the I<passwd> database or I</etc/"
"hosts> and I</etc/resolv.conf> for the I<hosts> database), and flush the "
"cache when these are changed.  However, this will happen only after a short "
"delay (unless the B<inotify>(7)  mechanism is available and glibc 2.9 or "
"later is available), and this auto-detection does not cover configuration "
"files required by nonstandard NSS modules, if any are specified in I</etc/"
"nsswitch.conf>.  In that case, you need to run the following command after "
"changing the configuration file of the database so that B<nscd> invalidates "
"its cache:"
msgstr ""
"デーモンは( I<passwd> データベースについては I</etc/passwd>、 I<hosts> データ"
"ベースについては I</etc/hosts> と I</etc/resolv.conf> というような)それぞれの"
"データベースのための設定ファイルを見張って、 これらが変更されるとキャッシュを"
"フラッシュする。 しかし、これは( B<inotify>(7)  が利用可能で、glibc 2.9 以降"
"が利用可能な場合を除いて)  短い遅延の後に起こり、またこの自動検出は非標準 "
"NSS モジュールが I</etc/nsswitch.conf> で指定されている場合はその設定ファイル"
"には対応しない。 この場合、データベースの設定ファイルを変更した後、 B<nscd> "
"のキャッシュを無効にするために以下のコマンドを実行する必要がある:"

#. type: Plain text
#: build/C/man8/nscd.8:91
#, no-wrap
msgid "$ B<nscd -i> I<E<lt>databaseE<gt>>\n"
msgstr "$ B<nscd -i> I<E<lt>databaseE<gt>>\n"

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man8/nscd.8:99
msgid "B<nscd.conf>(5), B<nsswitch.conf>(5)"
msgstr "B<nscd.conf>(5), B<nsswitch.conf>(5)"

#. type: TH
#: build/C/man5/nscd.conf.5:20
#, no-wrap
msgid "NSCD.CONF"
msgstr "NSCD.CONF"

#. type: Plain text
#: build/C/man5/nscd.conf.5:23
msgid "nscd.conf - name service cache daemon configuration file"
msgstr "nscd.conf - ネームサービスキャッシュデーモンの設定ファイル"

#. type: Plain text
#: build/C/man5/nscd.conf.5:36
msgid ""
"The file I</etc/nscd.conf> is read from B<nscd>(8)  at startup.  Each line "
"specifies either an attribute and a value, or an attribute, service, and a "
"value.  Fields are separated either by SPACE or TAB characters.  A \\(aq#"
"\\(aq (number sign) indicates the beginning of a comment; following "
"characters, up to the end of the line, are not interpreted by nscd."
msgstr ""
"B<nscd>(8)  は起動時にファイル I</etc/nscd.conf> を読み込む。 各行には「属"
"性・値」または「属性・サービス・値」を指定する。 フィールドはスペース文字また"
"はタブ文字で区切られる。 \\(aq#\\(aq (ナンバー記号) はコメントの始まりを表"
"す。 この記号から行末までは nscd によって解釈されない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:39
msgid ""
"Valid services are I<passwd>, I<group>, I<hosts>, I<services>, or "
"I<netgroup>."
msgstr ""
"指定可能なサービスは I<passwd>, I<group>, I<hosts>, I<services>, I<netgroup> "
"である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:42
msgid "B<logfile> I<debug-file-name>"
msgstr "B<logfile> I<debug-file-name>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:44
msgid "Specifies name of the file to which debug info should be written."
msgstr "デバッグ情報が書き込まれるファイルの名前を指定する。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:48
msgid "B<debug-level> I<value>"
msgstr "B<debug-level> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:51
msgid "Sets the desired debug level.  The default is 0."
msgstr "希望するデバッグレベルを設定する。デフォルトは 0。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:55
msgid "B<threads> I<number>"
msgstr "B<threads> I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:59
msgid ""
"This is the number of threads that are started to wait for requests.  At "
"least five threads will always be created."
msgstr ""
"スレッドをいくつ起動してリクエストを待つのかを指定する。 少なくとも 5 つのス"
"レッドが常に作成される。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:63
msgid "B<max-threads> I<number>"
msgstr "B<max-threads> I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:66
msgid "Specifies the maximum number of threads.  The default is 32."
msgstr "スレッドの最大数を指定する。デフォルトは 32。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:70
msgid "B<server-user> I<user>"
msgstr "B<server-user> I<user>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:74
msgid ""
"If this option is set, nscd will run as this user and not as root.  If a "
"separate cache for every user is used (-S parameter), this option is ignored."
msgstr ""
"このオプションが設定されると、 nscd は root ではなく、この user として実行さ"
"れる。 (-S パラメーターにより) 各ユーザー毎に別々のキャッシュが使われる場"
"合、 このオプションは無視される。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:78
msgid "B<stat-user> I<user>"
msgstr "B<stat-user> I<user>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:80
msgid "Specifies the user who is allowed to request statistics."
msgstr "統計情報の参照を許可するユーザーを指定する。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:85
msgid "B<reload-count> unlimited | I<number>"
msgstr "B<reload-count> unlimited | I<number>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:89
msgid ""
"Limit on the number of times a cached entry gets reloaded without being used "
"before it gets removed.  The default is 5."
msgstr ""
"キャッシュされたエントリーが使用されなかったときに、 削除される前に何回リロー"
"ドされるかを設定する。デフォルトは 5。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:93
msgid "B<paranoia> I<E<lt>yes|noE<gt>>"
msgstr "B<paranoia> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:96
msgid ""
"Enabling paranoia mode causes nscd to restart itself periodically.  The "
"default is no."
msgstr ""
"パラノイアモードを有効にする。 パラノイアモードでは nscd を定期的に再起動す"
"る。デフォルトは無効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:100
msgid "B<restart-interval> I<time>"
msgstr "B<restart-interval> I<time>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:108
msgid ""
"Sets the restart interval to I<time> seconds if periodic restart is enabled "
"by enabling B<paranoia> mode.  The default is 3600."
msgstr ""
"パラノイアモードが有効で定期的に再起動する場合の、 再起動間隔を I<time> 秒に"
"設定する。デフォルトは 3600。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:113
msgid "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:118
msgid "Enables or disables the specified I<service> cache.  The default is no."
msgstr ""
"指定した I<service> のキャッシュを有効または無効にする。デフォルトは無効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:123
msgid "B<positive-time-to-live> I<service> I<value>"
msgstr "B<positive-time-to-live> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:131
msgid ""
"Sets the TTL (time-to-live) for positive entries (successful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Larger values "
"increase cache hit rates and reduce mean response times, but increase "
"problems with cache coherence."
msgstr ""
"指定した I<service> のキャッシュにあるポジティブエントリー (成功した問い合わ"
"せ) の TTL (time-to-live) を設定する。 I<value> の単位は秒である。 値を大きく"
"すると、ヒット率が高くなり平均応答時間を短くできるが、 キャッシュのコヒーレン"
"ス (coherence, キャッシュが実際のデータと一致していること) に問題が生じる。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:136
msgid "B<negative-time-to-live> I<service> I<value>"
msgstr "B<negative-time-to-live> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:146
msgid ""
"Sets the TTL (time-to-live) for negative entries (unsuccessful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Can result in "
"significant performance improvements if there are several files owned by "
"UIDs (user IDs) not in system databases (for example untarring the Linux "
"kernel sources as root); should be kept small to reduce cache coherency "
"problems."
msgstr ""
"指定した I<service> のキャッシュにあるネガティブエントリー (失敗した問い合わ"
"せ) の TTL (time-to-live) を設定する。 I<value> の単位は秒である。 システム"
"データベースにない UID (ユーザーID) で所有されるファイル (たとえば root で "
"tar を展開した Linux カーネルのソース) が少ないと、 顕著な性能の向上が見られ"
"る。 キャッシュのコヒーレンス問題を少なくするために小さな値にすべきである。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:151
msgid "B<suggested-size> I<service> I<value>"
msgstr "B<suggested-size> I<service> I<value>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:156
msgid ""
"This is the internal hash table size, I<value> should remain a prime number "
"for optimum efficiency.  The default is 211."
msgstr ""
"内部ハッシュテーブルの大きさを指定する。 効率を最適にするために I<value> は素"
"数にしておくべきである。デフォルトは 211 である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:161
msgid "B<check-files> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<check-files> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:173
msgid ""
"Enables or disables checking the file belonging to the specified I<service> "
"for changes.  The files are I</etc/passwd>, I</etc/group>, I</etc/hosts>, I</"
"etc/services>, and I</etc/netgroup>.  The default is yes."
msgstr ""
"指定した I<service> に関連するファイルの変更のチェックを有効または無効にす"
"る。 ファイルは I</etc/passwd>, I</etc/group>, I</etc/hosts> である。デフォル"
"トは有効。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:178
msgid "B<persistent> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<persistent> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:185
msgid ""
"Keep the content of the cache for I<service> over server restarts; useful "
"when B<paranoia> mode is set.  The default is no."
msgstr ""
"サーバの再起動の前後で I<service> のキャッシュ内容を保持する。 B<paranoia> "
"モードが有効の場合に便利である。デフォルトは保持しない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:190
msgid "B<shared> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<shared> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:197
msgid ""
"The memory mapping of the nscd databases for I<service> is shared with the "
"clients so that they can directly search in them instead of having to ask "
"the daemon over the socket each time a lookup is performed.  The default is "
"no."
msgstr ""
"I<service> の nscd データベースのメモリーマッピングをクライアント間で共有す"
"る。 これにより、検索を実行する度にソケット経由でデーモンに問い合わせを 行わ"
"ずに、直接データベースを検索できるようになる。デフォルトは共有しない。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:202
msgid "B<max-db-size> I<service> I<bytes>"
msgstr "B<max-db-size> I<service> I<bytes>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:206
msgid ""
"The maximum allowable size, in bytes, of the database files for the "
"I<service>.  The default is 33554432."
msgstr ""
"I<service> のデータベースファイルの最大許容サイズ (バイト単位)。 デフォルト値"
"は 33554432 である。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:211
msgid "B<auto-propagate> I<service> I<E<lt>yes|noE<gt>>"
msgstr "B<auto-propagate> I<service> I<E<lt>yes|noE<gt>>"

#. type: Plain text
#: build/C/man5/nscd.conf.5:231
msgid ""
"When set to I<no> for I<passwd> or I<group> service, then the I<.byname> "
"requests are not added to I<passwd.byuid> or I<group.bygid> cache.  This can "
"help with tables containing multiple records for the same ID.  The default "
"is yes.  This option is valid only for services I<passwd> and I<group>."
msgstr ""
"サービス I<passwd> か I<group> で I<no> に設定すると、 I<.byname> 要求は "
"I<passwd.byuid> や I<group.bygid> のキャッシュに追加されない。 このオプション"
"は、 同じ ID を持つレコードが複数あるテーブルの場合に役に立つ。 デフォルトは "
"yes である。 このオプションはサービス I<passwd> と I<group> でのみ有効であ"
"る。"

#. type: Plain text
#: build/C/man5/nscd.conf.5:239
msgid ""
"The default values stated in this manual page originate from the source code "
"of B<nscd>(8)  and are used if not overridden in the configuration file.  "
"The default values used in the configuration file of your distribution might "
"differ."
msgstr ""
"このマニュアルページに書かれているデフォルト値は B<nscd>(8) のソースコードに"
"書かれている値で、 設定ファイルで上書きされなかった場合に使用される。 あなた"
"が利用しているディストリビューションの設定ファイルのデフォルト値は違っている"
"かもしれない。"

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man5/nscd.conf.5:244
msgid "B<nscd>(8)"
msgstr "B<nscd>(8)"

#. type: TH
#: build/C/man5/nss.5:19
#, no-wrap
msgid "NSS"
msgstr "NSS"

#. type: Plain text
#: build/C/man5/nss.5:22
msgid "nss - Name Service Switch configuration file"
msgstr "nss - 名前サービス切り替え (Name Service Switch) の設定ファイル"

#. type: Plain text
#: build/C/man5/nss.5:29
msgid ""
"Each call to a function which retrieves data from a system database like the "
"password or group database is handled by the Name Service Switch "
"implementation in the GNU C library.  The various services provided are "
"implemented by independent modules, each of which naturally varies widely "
"from the other."
msgstr ""
"パスワードやグループのデータベースなどのシステムデータベースからのデータ取得"
"の関数の呼び出しは、 GNU C ライブラリの名前サービス切り替えの実装により処理さ"
"れる。 提供されている様々なサービスは個別のモジュールにより実装されており、 "
"各モジュールは本質的に大きく異なっている。"

#. type: Plain text
#: build/C/man5/nss.5:38
msgid ""
"The default implementations coming with the GNU C library are by default "
"conservative and do not use unsafe data.  This might be very costly in some "
"situations, especially when the databases are large.  Some modules allow the "
"system administrator to request taking shortcuts if these are known to be "
"safe.  It is then the system administrator's responsibility to ensure the "
"assumption is correct."
msgstr ""
"GNU C ライブラリでのデフォルト実装は、 デフォルトでは保守的になっており、 安"
"全でないデータは使用しない。 これはいくつかの状況、 特にデータベースが大きい"
"場合、では非常にコストがかかることがある。 いくつかのモジュールでは、 安全で"
"あると分かっている場合、 システム管理者がショットカットを使うようにすることが"
"できる。 この前提が正しいことを保証するのはシステム管理者の責任である。"

#. type: Plain text
#: build/C/man5/nss.5:42
msgid ""
"There are other modules where the implementation changed over time.  If an "
"implementation used to sacrifice speed for memory consumption, it might "
"create problems if the preference is switched."
msgstr ""
"他には実装が時間を追って変化しているモジュールもある。 モジュールの実装がメモ"
"リー使用量を優先してスピードを犠牲にしていた場合、 優先度を変更すると問題が起"
"こる場合がある。"

#. type: Plain text
#: build/C/man5/nss.5:51
msgid ""
"The I</etc/default/nss> file contains a number of variable assignments.  "
"Each variable controls the behavior of one or more NSS modules.  White "
"spaces are ignored.  Lines beginning with \\(aq#\\(aq are treated as "
"comments."
msgstr ""
"I</etc/default/nss> ファイルには変数がいくつかある。 各変数は一つもしくは複数"
"の NSS モジュールの動作を制御する。 ホワイトスペースは無視される。 \\(aq#"
"\\(aq で始まる行はコメントとして扱われる。"

#. type: Plain text
#: build/C/man5/nss.5:53
msgid "The variables currently recognized are:"
msgstr "現在のところ認識される変数は次の通り。"

#. type: TP
#: build/C/man5/nss.5:53
#, no-wrap
msgid "B<NETID_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr "B<NETID_AUTHORITATIVE => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:68
msgid ""
"If set to TRUE, the NIS backend for the B<initgroups>(3)  function will "
"accept the information from the I<netid.byname> NIS map as authoritative.  "
"This can speed up the function significantly if the I<group.byname> map is "
"large.  The content of the I<netid.byname> map is used B<as is>.  The system "
"administrator has to make sure it is correctly generated."
msgstr ""
"TRUE に設定されると、 B<initgroups>(3) 関数の NIS バックエンドが I<netid."
"byname> NIS マップからの情報を信頼できるものとして受け取る。 I<group.byname> "
"マップが大きい場合、 これによりこの関数を大きくスピードアップできる。 "
"I<netid.byname> マップの内容はB<そのまま>使用される。 システム管理者は内容が"
"正しく生成されていることを保証しなければならない。"

#. type: TP
#: build/C/man5/nss.5:68
#, no-wrap
msgid "B<SERVICES_AUTHORITATIVE => I<TRUE>|I<FALSE>"
msgstr "B<SERVICES_AUTHORITATIVE => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:80
msgid ""
"If set to TRUE, the NIS backend for the B<getservbyname>(3)  and "
"B<getservbyname_r>(3)  functions will assume that the I<services."
"byservicename> NIS map exists and is authoritative, particularly that it "
"contains both keys with /proto and without /proto for both primary service "
"names and service aliases.  The system administrator has to make sure it is "
"correctly generated."
msgstr ""
"TRUE に設定されると、 関数 B<getservbyname>(3) と B<getservbyname_r>(3) の "
"NIS バックエンドが I<services.byservicename> NIS マップが存在し、その情報を信"
"頼できるものとみなす。 特に、 サービス名とサービス別名の両方に対して /proto "
"ありと /proto なしの両方のキーが含まれているとみなす。 システム管理者は内容が"
"正しく生成されていることを保証しなければならない。"

#. type: TP
#: build/C/man5/nss.5:80
#, no-wrap
msgid "B<SETENT_BATCH_READ => I<TRUE>|I<FALSE>"
msgstr "B<SETENT_BATCH_READ => I<TRUE>|I<FALSE>"

#. type: Plain text
#: build/C/man5/nss.5:98
msgid ""
"If set to TRUE, the NIS backend for the B<setpwent>(3)  and B<setgrent>(3)  "
"functions will read the entire database at once and then hand out the "
"requests one by one from memory with every corresponding B<getpwent>(3)  or "
"B<getgrent>(3)  call respectively.  Otherwise, each B<getpwent>(3)  or "
"B<getgrent>(3)  call might result in a network communication with the server "
"to get the next entry."
msgstr ""
"TRUE に設定されると、 関数 B<setpwent>(3) と B<setgrent>(3) の NIS バックエン"
"ドは、 全データベースを一度に読み込み、 それから対応する B<getpwent>(3) や "
"B<getgrent>(3) の呼び出しで一つ一つ要求を処理する。 TRUE でない場合、 "
"B<getpwent>(3) や B<getgrent>(3) の各々の呼び出しで、 次のエントリーを取得す"
"るためにサーバーとのネットワーク通信が発生する。"

#. type: Plain text
#: build/C/man5/nss.5:100
msgid "I</etc/default/nss>"
msgstr "I</etc/default/nss>"

#. type: Plain text
#: build/C/man5/nss.5:102
msgid ""
"The default configuration corresponds to the following configuration file:"
msgstr "デフォルト設定は、 以下の設定ファイルと同じである。"

#. type: Plain text
#: build/C/man5/nss.5:108
#, no-wrap
msgid ""
"NETID_AUTHORITATIVE=FALSE\n"
"SERVICES_AUTHORITATIVE=FALSE\n"
"SETENT_BATCH_READ=FALSE\n"
msgstr ""
"NETID_AUTHORITATIVE=FALSE\n"
"SERVICES_AUTHORITATIVE=FALSE\n"
"SETENT_BATCH_READ=FALSE\n"

#. type: Plain text
#: build/C/man5/nss.5:115
msgid "I<nsswitch.conf>"
msgstr "I<nsswitch.conf>"

#. type: TH
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "NSSWITCH.CONF"
msgstr "NSSWITCH.CONF"

#. type: TH
#: build/C/man5/nsswitch.conf.5:25
#, no-wrap
msgid "2017-05-03"
msgstr "2017-05-03"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:28
msgid "nsswitch.conf - Name Service Switch configuration file"
msgstr "nsswitch.conf - ネームサービススイッチの設定ファイル"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:36
#, fuzzy
#| msgid ""
#| "The Name Service Switch (NSS) configuration file, I</etc/nsswitch.conf>, "
#| "is used by the GNU C Library to determine the sources from which to "
#| "obtain name-service information in a range of categories, and in what "
#| "order.  Each category of information is identified by a database name."
msgid ""
"The Name Service Switch (NSS) configuration file, I</etc/nsswitch.conf>, is "
"used by the GNU C Library and certain other applications to determine the "
"sources from which to obtain name-service information in a range of "
"categories, and in what order.  Each category of information is identified "
"by a database name."
msgstr ""
"ネームサービススイッチ (Name Service Switch; NSS) の設定ファイル\n"
"I</etc/nsswitch.conf> は、 GNU C ライブラリが\n"
"いろいろなカテゴリーの名前サービス情報を、どの情報源から\n"
"どの順序で取得するかを判断するのに使用される\n"
"(情報の各カテゴリーはデータベース名で識別される)。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:42
msgid ""
"The file is plain ASCII text, with columns separated by spaces or tab "
"characters.  The first column specifies the database name.  The remaining "
"columns describe the order of sources to query and a limited set of actions "
"that can be performed by lookup result."
msgstr ""
"設定ファイルは通常の ASCII テキストで、列はスペースかタブ文字で\n"
"区切られる。最初の列はデータベース名を示す。\n"
"残りの列は、情報を問い合わせる情報源の順序と、\n"
"検索結果に対して実行するアクションを規定する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:44
msgid "The following databases are understood by the GNU C Library:"
msgstr "GNU C ライブラリでは以下のデータベースを扱うことができる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:49
msgid "Mail aliases, used by B<getaliasent>(3)  and related functions."
msgstr "メールのエイリアス。 B<getaliasent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:52
msgid "Ethernet numbers."
msgstr "イーサーネット番号。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:57
msgid "Groups of users, used by B<getgrent>(3)  and related functions."
msgstr "ユーザーのグループ。 B<getgrent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:62
msgid ""
"Host names and numbers, used by B<gethostbyname>(3)  and related functions."
msgstr "ホスト名とホスト番号。 B<gethostbyname>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:67
msgid "Supplementary group access list, used by B<getgrouplist>(3)  function."
msgstr "補助グループアクセスリスト。 B<getgrouplist>(3) 関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:71
msgid ""
"Network-wide list of hosts and users, used for access rules.  C libraries "
"before glibc 2.1 supported netgroups only over NIS."
msgstr ""
"ネットワークワイドに用いられるホストやユーザーのリスト。アクセス制限に利用\n"
"される。 glibc 2.1 より前の C ライブラリは、 NIS による netgroup のみを\n"
"サポートしていた。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:76
msgid ""
"Network names and numbers, used by B<getnetent>(3)  and related functions."
msgstr "ネットワーク名と番号。 B<getnetent>(3) と関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:81
msgid "User passwords, used by B<getpwent>(3)  and related functions."
msgstr "ユーザーパスワード。 B<getpwent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:86
msgid "Network protocols, used by B<getprotoent>(3)  and related functions."
msgstr "ネットワークプロトコル。 B<getprotoent>(3) や関連する関数が使用する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:86 build/C/man5/nsswitch.conf.5:399
#, no-wrap
msgid "B<publickey>"
msgstr "B<publickey>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:89
msgid "Public and secret keys for Secure_RPC used by NFS and NIS+."
msgstr "NIS+ と NFS によって用いられる secure_rpc の公開鍵と秘密鍵。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:94
msgid ""
"Remote procedure call names and numbers, used by B<getrpcbyname>(3)  and "
"related functions."
msgstr ""
"リモート手続き呼び出し (remote procedure call) の名前と番号。 \n"
"B<getrpcbyname>(3) と関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:99
msgid "Network services, used by B<getservent>(3)  and related functions."
msgstr "ネットワークサービス。 B<getservent>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:104
msgid "Shadow user passwords, used by B<getspnam>(3)  and related functions."
msgstr "シャドウユーザーパスワード。 B<getspnam>(3) や関連する関数が使用する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:112
msgid ""
"The GNU C Library ignores databases with unknown names.  Some applications "
"use this to implement special handling for their own databases.  For "
"example, B<sudo>(8)  consults the B<sudoers> database."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:116
msgid "Here is an example I</etc/nsswitch.conf> file:"
msgstr "以下は I</etc/nsswitch.conf> ファイルの例である。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:122
#, no-wrap
msgid ""
"passwd:         compat\n"
"group:          compat\n"
"shadow:         compat\n"
msgstr ""
"passwd:         compat\n"
"group:          compat\n"
"shadow:         compat\n"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:129
#, no-wrap
msgid ""
"hosts:          dns [!UNAVAIL=return] files\n"
"networks:       nis [NOTFOUND=return] files\n"
"ethers:         nis [NOTFOUND=return] files\n"
"protocols:      nis [NOTFOUND=return] files\n"
"rpc:            nis [NOTFOUND=return] files\n"
"services:       nis [NOTFOUND=return] files\n"
msgstr ""
"hosts:          dns [!UNAVAIL=return] files\n"
"networks:       nis [NOTFOUND=return] files\n"
"ethers:         nis [NOTFOUND=return] files\n"
"protocols:      nis [NOTFOUND=return] files\n"
"rpc:            nis [NOTFOUND=return] files\n"
"services:       nis [NOTFOUND=return] files\n"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:134
msgid "The first column is the database name.  The remaining columns specify:"
msgstr ""
"最初の列はデータベース名である。\n"
"残りの列で以下を指定する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:138
msgid ""
"One or more service specifications, for example, \"files\", \"db\", or \"nis"
"\".  The order of the services on the line determines the order in which "
"those services will be queried, in turn, until a result is found."
msgstr ""
"1 個以上のサービス指定 (例: \"files\", \"db\", \"nis\")。この行に記載された\n"
"サービスの順序で、結果が得られるまで、指定されたサービスに対する\n"
"問い合わせが順番に行われる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:141
msgid ""
"Optional actions to perform if a particular result is obtained from the "
"preceding service, for example, \"[NOTFOUND=return]\"."
msgstr ""
"特定の結果が直前のサービスで得られた場合に実行されるアクション\n"
"(例: \"[NOTFOUND=return]\")。アクションは省略可能である。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:167
msgid ""
"The service specifications supported on your system depend on the presence "
"of shared libraries, and are therefore extensible.  Libraries called I</lib/"
"libnss_SERVICE.so.>B<X> will provide the named I<SERVICE>.  On a standard "
"installation, you can use \"files\", \"db\", \"nis\", and \"nisplus\".  For "
"the B<hosts> database, you can additionally specify \"dns\".  For the "
"B<passwd>, B<group>, and B<shadow> databases, you can additionally specify "
"\"compat\" (see B<Compatibility mode> below).  The version number B<X> may "
"be 1 for glibc 2.0, or 2 for glibc 2.1 and later.  On systems with "
"additional libraries installed, you may have access to further services such "
"as \"hesiod\", \"ldap\", \"winbind\" and \"wins\"."
msgstr ""
"利用しているシステムでどのサービス指定が利用できるかは、共有ライブラリ\n"
"があるかどうかに依存しており、そのためサービス指定は拡張できるように\n"
"なっている。I</lib/libnss_SERVICE.so.>B<X> という名前のライブラリが\n"
"I<SERVICE> という名前のサービスを提供する。標準のインストールを行った\n"
"場合、\"files\", \"db\", \"nis\", \"nisplus\" が利用できる。\n"
"データベース B<hosts> の場合には、追加で \"dns\" も指定できる。\n"
"データベース B<passwd>, B<group>, B<shadow> の場合には、追加で\n"
"\"compat\" (下記の B<互換モード> を参照)。バージョン番号 B<X> は、\n"
"glibc 2.0 の場合は 1、glibc 2.1 の場合は 2 で、それ以降も同様である。\n"
"追加のライブラリがインストールされているシステムでは、\"hesiod\",\n"
"\"ldap\", \"winbind\", \"wins\" などの追加のサービスが利用できる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:172
msgid ""
"An action may also be specified following a service specification.  The "
"action modifies the behavior following a result obtained from the preceding "
"data source.  Action items take the general form:"
msgstr ""
"サービス指定の次にアクションを指定することもできる。アクションを\n"
"使うと、直前のデータ源から結果が得られた後の動作を変更できる。\n"
"アクション指定は、一般的には以下の形式となる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:175
msgid "[I<STATUS>=I<ACTION>]"
msgstr "[I<STATUS>=I<ACTION>]"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:177
msgid "[!I<STATUS>=I<ACTION>]"
msgstr "[!I<STATUS>=I<ACTION>]"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:180
msgid "where"
msgstr "STATUS と ACTION はそれぞれ以下の値を取る。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:191
msgid "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"
msgstr "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:199
msgid "I<ACTION> =E<gt> B<return> | B<continue> | B<merge>"
msgstr "I<ACTION> =E<gt> B<return> | B<continue> | B<merge>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:204
msgid ""
"The ! negates the test, matching all possible results except the one "
"specified.  The case of the keywords is not significant."
msgstr ""
"! はテスト結果を反転させる。\n"
"つまり、指定された以外の全ての結果にマッチする。\n"
"キーワードの大文字、小文字は無視される。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:209
msgid ""
"The I<STATUS> value is matched against the result of the lookup function "
"called by the preceding service specification, and can be one of:"
msgstr ""
"I<STATUS> は、直前のサービス指定で呼び出しされた検索処理の結果に\n"
"対して照合が行われる。 I<STATUS> には以下のいずれかを指定できる。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:210
#, no-wrap
msgid "B<success>"
msgstr "B<success>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:214
msgid ""
"No error occurred and the requested entry is returned.  The default action "
"for this condition is \"return\"."
msgstr ""
"エラーは発生せず、要求されたエントリーが返された。\n"
"この場合のデフォルトのアクションは \"return\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:214
#, no-wrap
msgid "B<notfound>"
msgstr "B<notfound>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:218
msgid ""
"The lookup succeeded, but the requested entry was not found.  The default "
"action for this condition is \"continue\"."
msgstr ""
"検索は成功したが、要求されたエントリーが見つからなかった。\n"
"この場合のデフォルトのアクションは \"continue\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:218
#, no-wrap
msgid "B<unavail>"
msgstr "B<unavail>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:225
msgid ""
"The service is permanently unavailable.  This can mean either that the "
"required file cannot be read, or, for network services, that the server is "
"not available or does not allow queries.  The default action for this "
"condition is \"continue\"."
msgstr ""
"サービスが永続的に利用できない。\n"
"必要なファイルを読み込むことができない、\n"
"ネットワークサービスの場合には、サーバが利用できないとか、\n"
"サーバが問い合わせを許可していない、などが考えられる。\n"
"この場合のデフォルトのアクションは \"continue\" である。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:225
#, no-wrap
msgid "B<tryagain>"
msgstr "B<tryagain>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:231
msgid ""
"The service is temporarily unavailable.  This could mean a file is locked or "
"a server currently cannot accept more connections.  The default action for "
"this condition is \"continue\"."
msgstr ""
"サービスが一時的に利用できない。\n"
"ファイルがロックされている、サーバがこれ以上接続を受け付けることができな"
"い、\n"
"などが考えられる。デフォル トのアクションは \"continue\" である。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:236
msgid "The I<ACTION> value can be one of:"
msgstr "I<ACTION> には以下のいずれかを指定できる。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:237
#, no-wrap
msgid "B<return>"
msgstr "B<return>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:249
msgid ""
"Return a result now.  Do not call any further lookup functions.  However, "
"for compatibility reasons, if this is the selected action for the B<group> "
"database and the B<notfound> status, and the configuration file does not "
"contain the B<initgroups> line, the next lookup function is always called, "
"without affecting the search result."
msgstr ""
"結果をすぐに返す。 これ以上検索処理は呼び出されない。 ただし、互換性のため、 "
"選択されたアクションが B<group> データベースに対するもので、 ステータスが "
"B<notfound> であった場合で、 設定ファイルに B<initgroups> の行が含まれていな"
"い場合には、次の検索処理は常に呼び出される (検索結果への影響はない)。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:249
#, no-wrap
msgid "B<continue>"
msgstr "B<continue>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:252
msgid "Call the next lookup function."
msgstr "次の検索処理を呼び出す。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:252
#, no-wrap
msgid "B<merge>"
msgstr "B<merge>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:266
msgid ""
"I<[SUCCESS=merge]> is used between two database entries.  When a group is "
"located in the first of the two group entries, processing will continue on "
"to the next one.  If the group is also found in the next entry (and the "
"group name and GID are an exact match), the member list of the second entry "
"will be added to the group object to be returned.  Available since glibc "
"2.24.  Note that merging will not be done for B<getgrent>(3)  nor will "
"duplicate members be pruned when they occur in both entries being merged."
msgstr ""

#. type: SS
#: build/C/man5/nsswitch.conf.5:267
#, no-wrap
msgid "Compatibility mode (compat)"
msgstr "互換モード (compat)"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:272
#, fuzzy
#| msgid ""
#| "The NSS \"compat\" service is similar to \"files\" except that it "
#| "additionally permits special entries in I</etc/passwd> for granting users "
#| "or members of netgroups access to the system.  The following entries are "
#| "valid in this mode:"
msgid ""
"The NSS \"compat\" service is similar to \"files\" except that it "
"additionally permits special entries in corresponding files for granting "
"users or members of netgroups access to the system.  The following entries "
"are valid in this mode:"
msgstr ""
"NSS \"compat\" サービスは \"files\" と似ているが、システムにアクセスできる\n"
"ユーザーやネットグループ (netgroup) のメンバの指定に I</etc/passwd> で\n"
"特別なエントリーを追加で使うことができる点が異なる。\n"
"このモードでは、以下のエントリーを使うことができる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:279
msgid "For B<passwd> and B<shadow> databases:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:280
#, no-wrap
msgid "B<+>I<user>"
msgstr "B<+>I<user>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:285
msgid "Include the specified I<user> from the NIS passwd/shadow map."
msgstr "NIS パスワード/shadow マップの指定された I<user> を含める。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:285
#, no-wrap
msgid "B<+@>I<netgroup>"
msgstr "B<+@>I<netgroup>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:289
msgid "Include all users in the given I<netgroup>."
msgstr "指定された I<netgroup> の全ユーザーを含める。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:289
#, no-wrap
msgid "B<->I<user>"
msgstr "B<->I<user>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:294
msgid "Exclude the specified I<user> from the NIS passwd/shadow map."
msgstr "NIS パスワード/shadow マップの指定された I<user> を除外する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:294
#, no-wrap
msgid "B<-@>I<netgroup>"
msgstr "B<-@>I<netgroup>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:298
msgid "Exclude all users in the given I<netgroup>."
msgstr "指定された I<netgroup> の全ユーザーを除外する。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:298 build/C/man5/nsswitch.conf.5:318
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:302
#, fuzzy
#| msgid ""
#| "Include every user, except previously excluded ones, from the NIS passwd "
#| "map."
msgid ""
"Include every user, except previously excluded ones, from the NIS passwd/"
"shadow map."
msgstr ""
"NIS パスワードマップのユーザーのうち、\n"
"それまでに除外されていない全てのユーザーを含める。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:307
msgid "For B<group> database:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:308
#, no-wrap
msgid "B<+>I<group>"
msgstr "B<+>I<group>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:313
msgid "Include the specified I<group> from the NIS group map."
msgstr "NIS グループマップの指定された I<group> を含める。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:313
#, no-wrap
msgid "B<->I<group>"
msgstr "B<->I<group>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:318
msgid "Exclude the specified I<group> from the NIS group map."
msgstr "NIS グループマップの指定された I<group> を除外する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:322
msgid ""
"Include every group, except previously excluded ones, from the NIS group map."
msgstr "NIS グループマップのグループのうち、それまでに除外されていない全てのグループを含める。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:332
#, fuzzy
#| msgid ""
#| "By default the source is \"nis\", but this may be overridden by "
#| "specifying \"nisplus\" as the source for the pseudo-databases "
#| "B<passwd_compat>, B<group_compat>, and B<shadow_compat>."
msgid ""
"By default, the source is \"nis\", but this may be overridden by specifying "
"any NSS service except \"compat\" itself as the source for the pseudo-"
"databases B<passwd_compat>, B<group_compat>, and B<shadow_compat>."
msgstr ""
"デフォルトでは、データ源は \"nis\" だが、\n"
"擬似データベース B<passwd_compat>, B<group_compat>, B<shadow_compat>\n"
"ではデータ源として \"nisplus\" を指定することもできる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:339
msgid ""
"A service named I<SERVICE> is implemented by a shared object library named "
"I<libnss_SERVICE.so.>B<X> that resides in I</lib>."
msgstr ""
"I<SERVICE> という名前のサービスは I<libnss_SERVICE.so.>B<X> という\n"
"名前の共有オブジェクトライブラリで実装されている。\n"
"これは I</lib> に置かれる。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:344
msgid "NSS configuration file."
msgstr "NSS の設定ファイル。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:344
#, no-wrap
msgid "I</lib/libnss_compat.so.>B<X>"
msgstr "I</lib/libnss_compat.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:347
msgid "implements \"compat\" source."
msgstr "\"compat\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:347
#, no-wrap
msgid "I</lib/libnss_db.so.>B<X>"
msgstr "I</lib/libnss_db.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:350
msgid "implements \"db\" source."
msgstr "\"db\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:350
#, no-wrap
msgid "I</lib/libnss_dns.so.>B<X>"
msgstr "I</lib/libnss_dns.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:353
msgid "implements \"dns\" source."
msgstr "\"dns\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:353
#, no-wrap
msgid "I</lib/libnss_files.so.>B<X>"
msgstr "I</lib/libnss_files.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:356
msgid "implements \"files\" source."
msgstr "\"files\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:356
#, no-wrap
msgid "I</lib/libnss_hesiod.so.>B<X>"
msgstr "I</lib/libnss_hesiod.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:359
msgid "implements \"hesiod\" source."
msgstr "\"hesoid\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:359
#, no-wrap
msgid "I</lib/libnss_nis.so.>B<X>"
msgstr "I</lib/libnss_nis.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:362
msgid "implements \"nis\" source."
msgstr "\"nis\" ソースを実装したもの。"

#. type: TP
#: build/C/man5/nsswitch.conf.5:362
#, no-wrap
msgid "I</lib/libnss_nisplus.so.>B<X>"
msgstr "I</lib/libnss_nisplus.so.>B<X>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:365
msgid "implements \"nisplus\" source."
msgstr "\"nisplus\" ソースを実装したもの。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:370
msgid ""
"The following files are read when \"files\" source is specified for "
"respective databases:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:375
msgid "I</etc/aliases>"
msgstr "I</etc/aliases>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:378
msgid "I</etc/ethers>"
msgstr "I</etc/ethers>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:381 build/C/man5/nsswitch.conf.5:387
msgid "I</etc/group>"
msgstr "I</etc/group>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:390 build/C/man3/setnetgrent.3:93
msgid "I</etc/netgroup>"
msgstr "I</etc/netgroup>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:396
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:402
msgid "I</etc/publickey>"
msgstr "I</etc/publickey>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:405
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:411
msgid "I</etc/shadow>"
msgstr "I</etc/shadow>"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:419
msgid ""
"Within each process that uses B<nsswitch.conf>, the entire file is read only "
"once.  If the file is later changed, the process will continue using the old "
"configuration."
msgstr ""
"I<nsswitch.conf> を利用するプロセスは、ファイルは一度しか読み込まない。\n"
"その後で nsswitch.conf が書き換えられても、そのプロセスは古い設定のままで\n"
"動作を継続する。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:432
msgid ""
"Traditionally, there was only a single source for service information, often "
"in the form of a single configuration file (e.g., I</etc/passwd>).  However, "
"as other name services, such as the Network Information Service (NIS) and "
"the Domain Name Service (DNS), became popular, a method was needed that "
"would be more flexible than fixed search orders coded into the C library.  "
"The Name Service Switch mechanism, which was based on the mechanism used by "
"Sun Microsystems in the Solaris 2 C library, introduced a cleaner solution "
"to the problem."
msgstr ""
"伝統的には、サービス情報の情報源は一つだけであり、\n"
"その設定ファイルの形式も一つであった (例えば I</etc/passwd>)。\n"
"一方で、 Network Information Service (NIS) や Domain Name Service\n"
"(DNS) などの他の名前サービスが一般的になるに連れて、C ライブラリに埋め\n"
"込まれた固定順序ではなく、検索順序を柔軟に指定する方法が必要になった。\n"
"ネームサービススイッチ機構は、この問題に対するよりきれいな解決方法と\n"
"なっている。ネームサービススイッチ機構は、 Sun Microsystems が \n"
"Solaris 2 の C ライブラリで使った機構が基になっている。"

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:435
msgid "B<getent>(1), B<nss>(5)"
msgstr "B<getent>(1), B<nss>(5)"

#. type: TH
#: build/C/man7/packet.7:12
#, no-wrap
msgid "PACKET"
msgstr "PACKET"

#. type: Plain text
#: build/C/man7/packet.7:15
msgid "packet - packet interface on device level"
msgstr "packet - デバイスレベルのパケットインターフェース"

#. type: Plain text
#: build/C/man7/packet.7:20
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/if_packet.hE<gt>>\n"
"B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/if_packet.hE<gt>>\n"
"B<#include E<lt>net/ethernet.hE<gt> /* L2 プロトコル */>\n"

#. type: Plain text
#: build/C/man7/packet.7:22
#, no-wrap
msgid "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"
msgstr "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"

#. type: Plain text
#: build/C/man7/packet.7:28
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""
"packet ソケットは、デバイスドライバ (OSI レイヤ 2) レベルで 生のパケット "
"(raw packet) を送受信するために用いられる。 packet ソケットを使うと、ユーザー"
"空間で物理層の上に プロトコルモジュールを実装することができる。"

#. type: Plain text
#: build/C/man7/packet.7:50
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the link-"
"level header or B<SOCK_DGRAM> for cooked packets with the link-level header "
"removed.  The link-level header information is available in a common format "
"in a I<sockaddr_ll> structure.  I<protocol> is the IEEE 802.3 protocol "
"number in network byte order.  See the I<E<lt>linux/if_ether.hE<gt>> include "
"file for a list of allowed protocols.  When protocol is set to "
"B<htons(ETH_P_ALL)>, then all protocols are received.  All incoming packets "
"of that protocol type will be passed to the packet socket before they are "
"passed to the protocols implemented in the kernel."
msgstr "I<socket_type> には B<SOCK_RAW> と B<SOCK_DGRAM> のいずれかを指定する。 B<SOCK_RAW> はリンクレベルヘッダーを含む raw パケットを、 B<SOCK_DGRAM> はリンクレベルヘッダーが削除された加工済みパケットを示す。 リンクレベルヘッダー情報は I<sockaddr_ll> 構造体で共通のフォーマットで入手できる。 I<protocol> には IEEE 802.3 プロトコル番号を ネットワークバイトオーダーで指定する。 指定できるプロトコルのリストは、インクルードファイル I<E<lt>linux/if_ether.hE<gt>> を参照。プロトコルを B<htons(ETH_P_ALL)> にすると、全てのプロトコルが受信される。 外部から来たパケットのうち指定したプロトコルのものは、 カーネルに実装されているプロトコルに渡される前の段階で、 packet ソケットに渡される。"

#. type: Plain text
#: build/C/man7/packet.7:54
msgid ""
"In order to create a packet socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:72
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user-supplied buffer should contain the physical-"
"layer header.  That packet is then queued unmodified to the network driver "
"of the interface defined by the destination address.  Some device drivers "
"always add other headers.  B<SOCK_RAW> is similar to but not compatible with "
"the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""
"B<SOCK_RAW> パケットでは、パケットをデバイスドライバと受け渡しする際、 パケッ"
"トデータに変更が行われることはない。 パケットの受信時には、アドレスの解析だけ"
"は行われ、 標準的な I<sockaddr_ll> アドレス構造体に渡される。パケットの送信時"
"には、ユーザーが指定する バッファーに物理層のヘッダーが含まれている必要があ"
"る。 パケットはそのまま修正を受けずに、行き先アドレスから決定される インター"
"フェースのネットワークドライバにキューイングされる。 デバイスドライバによって"
"は、他のヘッダーを常に追加するものもある。 B<SOCK_RAW> は Linux 2.0 の "
"obosolete な B<AF_INET/SOCK_PACKET> と似ているが、互換性があるわけではない。"

#. type: Plain text
#: build/C/man7/packet.7:82
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical-layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""
"B<SOCK_DGRAM> はやや高位のレベルで動作する。物理ヘッダーは、パケットがユー"
"ザーに 渡される前に削除される。 B<SOCK_DGRAM> の packet ソケットを通して送ら"
"れるパケットは、 I<sockaddr_ll> の行き先アドレスの情報に基づき、適切な物理層"
"のヘッダーが付加されてから、 キューに送られる。"

#. type: Plain text
#: build/C/man7/packet.7:97
#, fuzzy
#| msgid ""
#| "By default all packets of the specified protocol type are passed to a "
#| "packet socket.  To get packets only from a specific interface use "
#| "B<bind>(2)  specifying an address in a I<struct sockaddr_ll> to bind the "
#| "packet socket to an interface.  Only the I<sll_protocol> and the "
#| "I<sll_ifindex> address fields are used for purposes of binding."
msgid ""
"By default, all packets of the specified protocol type are passed to a "
"packet socket.  To get packets only from a specific interface use "
"B<bind>(2)  specifying an address in a I<struct sockaddr_ll> to bind the "
"packet socket to an interface.  Fields used for binding are I<sll_family> "
"(should be B<AF_PACKET>), I<sll_protocol>, and I<sll_ifindex>."
msgstr ""
"デフォルトでは、指定したプロトコル型のパケットはすべて packet ソケットに送ら"
"れる。特定のインターフェースからのパケットだけを 取得したい場合には、 "
"I<struct sockaddr_ll> にアドレスを指定して B<bind>(2)  を呼び、 packet ソケッ"
"トをそのインターフェースに結び付ける (バインドする)。 バインドの際には、アド"
"レスフィールドのうち I<sll_protocol> と I<sll_ifindex> だけが用いられる。"

#. type: Plain text
#: build/C/man7/packet.7:101
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr "B<connect>(2)  操作は packet ソケットではサポートされていない。"

#. type: Plain text
#: build/C/man7/packet.7:111
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), or "
"B<recvfrom>(2), the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""
"B<MSG_TRUNC> フラグが B<recvmsg>(2), B<recv>(2), B<recvfrom>(2)  に渡される"
"と、 (バッファーサイズより大きかったとしても) 常に実際に通信された パケットの"
"長さが返される。"

#. type: SS
#: build/C/man7/packet.7:111
#, no-wrap
msgid "Address types"
msgstr "アドレスのタイプ"

#. type: Plain text
#: build/C/man7/packet.7:115
msgid ""
"The I<sockaddr_ll> structure is a device-independent physical-layer address."
msgstr "I<sockaddr_ll> 構造体はデバイスに依存しない物理層のアドレスである。"

#. type: Plain text
#: build/C/man7/packet.7:127
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical-layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical-layer address */\n"
"};\n"
msgstr ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* 常に AF_PACKET */\n"
"    unsigned short sll_protocol; /* 物理層のプロトコル */\n"
"    int            sll_ifindex;  /* インターフェース番号 */\n"
"    unsigned short sll_hatype;   /* ARP ハードウェア種別 */\n"
"    unsigned char  sll_pkttype;  /* パケット種別 */\n"
"    unsigned char  sll_halen;    /* アドレスの長さ */\n"
"    unsigned char  sll_addr[8];  /* 物理層のアドレス */\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:131
msgid "The fields of this structure are as follows:"
msgstr "この構造体のフィールドは以下の通りである。"

#. type: Plain text
#: build/C/man7/packet.7:138
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network byte order "
"as defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults "
"to the socket's protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:148
msgid ""
"I<sll_ifindex> is the interface index of the interface (see "
"B<netdevice>(7)); 0 matches any interface (only permitted for binding).  "
"I<sll_hatype> is an ARP type as defined in the I<E<lt>linux/if_arp.hE<gt>> "
"include file."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:165
#, fuzzy
#| msgid ""
#| "I<sll_protocol> is the standard ethernet protocol type in network byte "
#| "order as defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It "
#| "defaults to the socket's protocol.  I<sll_ifindex> is the interface index "
#| "of the interface (see B<netdevice>(7)); 0 matches any interface (only "
#| "permitted for binding).  I<sll_hatype> is an ARP type as defined in the "
#| "I<E<lt>linux/if_arp.hE<gt>> include file.  I<sll_pkttype> contains the "
#| "packet type.  Valid types are B<PACKET_HOST> for a packet addressed to "
#| "the local host, B<PACKET_BROADCAST> for a physical layer broadcast "
#| "packet, B<PACKET_MULTICAST> for a packet sent to a physical layer "
#| "multicast address, B<PACKET_OTHERHOST> for a packet to some other host "
#| "that has been caught by a device driver in promiscuous mode, and "
#| "B<PACKET_OUTGOING> for a packet originated from the local host that is "
#| "looped back to a packet socket.  These types make sense only for "
#| "receiving.  I<sll_addr> and I<sll_halen> contain the physical layer (e."
#| "g., IEEE 802.3) address and its length.  The exact interpretation depends "
#| "on the device."
msgid ""
"I<sll_pkttype> contains the packet type.  Valid types are B<PACKET_HOST> for "
"a packet addressed to the local host, B<PACKET_BROADCAST> for a physical-"
"layer broadcast packet, B<PACKET_MULTICAST> for a packet sent to a physical-"
"layer multicast address, B<PACKET_OTHERHOST> for a packet to some other host "
"that has been caught by a device driver in promiscuous mode, and "
"B<PACKET_OUTGOING> for a packet originating from the local host that is "
"looped back to a packet socket.  These types make sense only for receiving."
msgstr ""
"I<sll_protocol> は標準的なイーサネットプロトコルのタイプで、 ネットワーク\n"
"バイトオーダーで記述する。 インクルードファイル\n"
"I<E<lt>linux/if_ether.hE<gt>> で定義されている。 これがこのソケットのプロト\n"
"コルのデフォルトとなる。 I<sll_ifindex> はそのインターフェースの interface\n"
"index である (B<netdevice>(7) を参照)。 0 は (バインドが許可されている) 任\n"
"意のインターフェースにマッチする。 I<sll_hatype> は、インクルードファイル\n"
"I<E<lt>linux/if_arp.hE<gt>> で定義されている ARP 種別である。\n"
"I<sll_pkttype> はパケット種別である。指定できる種別は以下のいずれかである:\n"
"B<PACKET_HOST> (ローカルホスト向けのパケット)、 B<PACKET_BORADCAST> (物理層\n"
"のブロードキャストパケット)、 B<PACKET_MULTICAST> (物理層のマルチキャストア\n"
"ドレスに送るパケット)、 B<PACKET_OTHERHOST> (他のホストに向けられたパケット\n"
"のうち、 無差別モード (promiscuous mode: 後述) のデバイスドライバにより補足\n"
"されたもの)、 B<PACKET_OUTGOING> (ローカルホストから発信され、 packet ソ"
"ケッ\n"
"トにループバックしてきたパケット)。 これらの種別が意味を持つのは受信時のみ\n"
"である。 I<sll_addr> と I<sll_halen> は、物理層の (つまり IEEE 802.3 の) \n"
"アドレスとその長さである。 厳密な解釈はデバイスに依存する。"

#. type: Plain text
#: build/C/man7/packet.7:171
msgid ""
"I<sll_addr> and I<sll_halen> contain the physical-layer (e.g., IEEE 802.3) "
"address and its length.  The exact interpretation depends on the device."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:184
msgid ""
"When you send packets, it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>, and I<sll_protocol>.  The other fields should "
"be 0.  I<sll_hatype> and I<sll_pkttype> are set on received packets for your "
"information."
msgstr "パケットを送る場合は、 I<sll_family>, I<sll_addr>, I<sll_halen>, I<sll_ifindex>, I<sll_protocol> を指定すれば十分である。 その他のフィールドは 0 にしておくべきである。 I<sll_hatype> と I<sll_pkttype> には受信したパケットの情報が設定される。"

#. type: Plain text
#: build/C/man7/packet.7:189
msgid ""
"Packet socket options are configured by calling B<setsockopt>(2)  with level "
"B<SOL_PACKET>."
msgstr ""
"パケットソケットのオプションは、レベル B<SOL_PACKET> を指定して "
"B<setsockopt>(2) を呼び出すことで設定できる。"

#. type: TP
#: build/C/man7/packet.7:189
#, no-wrap
msgid "B<PACKET_ADD_MEMBERSHIP>"
msgstr "B<PACKET_ADD_MEMBERSHIP>"

#. type: TP
#: build/C/man7/packet.7:192
#, no-wrap
msgid "B<PACKET_DROP_MEMBERSHIP>"
msgstr "B<PACKET_DROP_MEMBERSHIP>"

#. type: Plain text
#: build/C/man7/packet.7:204
msgid ""
"Packet sockets can be used to configure physical-layer multicasting and "
"promiscuous mode.  B<PACKET_ADD_MEMBERSHIP> adds a binding and "
"B<PACKET_DROP_MEMBERSHIP> drops it.  They both expect a I<packet_mreq> "
"structure as argument:"
msgstr ""
"packet ソケットは、物理層のマルチキャストや 無差別モード (promiscuous mode) "
"を設定して使うことができる。 B<PACKET_ADD_MEMBERSHIP> はバインドを追加し、 "
"B<PACKET_DROP_MEMBERSHIP> はバインドを削除する。これらはいずれも "
"I<packet_mreq> 構造体を引数に取る。"

#. type: Plain text
#: build/C/man7/packet.7:213
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical-layer address */\n"
"};\n"
msgstr ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* インターフェース番号 */\n"
"    unsigned short mr_type;       /* 動作 */\n"
"    unsigned short mr_alen;       /* アドレスの長さ */\n"
"    unsigned char  mr_address[8]; /* 物理層のアドレス */\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:234
msgid ""
"I<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The I<mr_type> field specifies which action to perform.  "
"B<PACKET_MR_PROMISC> enables receiving all packets on a shared medium (often "
"known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds the socket to "
"the physical-layer multicast group specified in I<mr_address> and "
"I<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr "I<mr_ifindex> は、ステータスを変更したいインターフェースの インターフェース番号である。 I<mr_type> フィールドは実行する動作を指定する: B<PACKET_MR_PROMISC> は、共有している媒体からの全てのパケットを受信できるようにする (しばしば \"無差別モード (promiscuous mode)\" と呼ばれる)。 B<PACKET_MR_MULTICAST> は、そのソケットを、 I<mr_address> と I<mr_alen> で指定される物理層のマルチキャストブループにバインドする。 B<PACKET_MR_ALLMULTI> は socket を up にして、そのインターフェースに到達したすべての マルチキャストパケットを受信できるようにする。"

#. type: Plain text
#: build/C/man7/packet.7:240
msgid ""
"In addition, the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""
"昔からある ioctl だけでなく、 B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> を同じ目的に用いることができる。"

#. type: TP
#: build/C/man7/packet.7:240
#, no-wrap
msgid "B<PACKET_AUXDATA> (since Linux 2.6.21)"
msgstr "B<PACKET_AUXDATA> (Linux 2.6.21 以降)"

#.  commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
#. type: Plain text
#: build/C/man7/packet.7:250
msgid ""
"If this binary option is enabled, the packet socket passes a metadata "
"structure along with each packet in the B<recvmsg>(2)  control field.  The "
"structure can be read with B<cmsg>(3).  It is defined as"
msgstr ""
"ブール値のオプションを有効すると、 パケットソケットは、パケットと一緒にメタ"
"データ構造体を B<recvmsg>(2) コントロールフィールドで渡す。 この構造体は "
"B<cmsg>(3) を使って読むことができる。 定義は以下の通りである。"

#.  commit a0cdfcf39362410d5ea983f4daf67b38de129408 added tp_vlan_tpid
#. type: Plain text
#: build/C/man7/packet.7:264
#, fuzzy, no-wrap
#| msgid ""
#| "struct tpacket_auxdata {\n"
#| "    __u32 tp_status;\n"
#| "    __u32 tp_len;      /* packet length */\n"
#| "    __u32 tp_snaplen;  /* captured length */\n"
#| "    __u16 tp_mac;\n"
#| "    __u16 tp_net;\n"
#| "    __u16 tp_vlan_tci;\n"
#| "    __u16 tp_padding;\n"
#| "};\n"
msgid ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* packet length */\n"
"    __u32 tp_snaplen;  /* captured length */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_vlan_tpid; /* Since Linux 3.14; earlier, these\n"
"                           were unused padding bytes */\n"
"};\n"
msgstr ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* パケット長 */\n"
"    __u32 tp_snaplen;  /* キャプチャした長さ */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_padding;\n"
"};\n"

#. type: TP
#: build/C/man7/packet.7:266
#, no-wrap
msgid "B<PACKET_FANOUT> (since Linux 3.1)"
msgstr "B<PACKET_FANOUT> (Linux 3.1 以降)"

#.  commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
#. type: Plain text
#: build/C/man7/packet.7:288
msgid ""
"To scale processing across threads, packet sockets can form a fanout group.  "
"In this mode, each matching packet is enqueued onto only one socket in the "
"group.  A socket joins a fanout group by calling B<setsockopt>(2)  with "
"level B<SOL_PACKET> and option B<PACKET_FANOUT>.  Each network namespace can "
"have up to 65536 independent groups.  A socket selects a group by encoding "
"the ID in the first 16 bits of the integer option value.  The first packet "
"socket to join a group implicitly creates it.  To successfully join an "
"existing group, subsequent packet sockets must have the same protocol, "
"device settings, fanout mode and flags (see below).  Packet sockets can "
"leave a fanout group only by closing the socket.  The group is deleted when "
"the last socket is closed."
msgstr ""
"スレッドにまたがって処理をスケールさせるため、 パケットソケットはファンアウト"
"グループを構成することができる。 このモードでは、 マッチしたそれぞれのパケッ"
"トはグループ内のいずれか一つのソケットにだけキューイングされる。 ソケットを"
"ファンアウトグループに参加させるには、 レベル B<SOL_PACKET> でオプション "
"B<PACKET_FANOUT> を指定して B<setsockopt>(2) を呼び出す。 ネットワーク名前空"
"間毎に最大 65536 個の独立したグループを持つことができる。 整数のオプション値"
"の先頭 16 ビットに ID をエンコードすることで、 ソケットはグループを選択す"
"る。 あるグループへの最初のパケットソケットの参加があった時点で、 グループは"
"暗黙のうちに作成される。 既存のグループへの参加が成功するためには、 それ以降"
"にそのグループに参加しようとするパケットソケットは、 プロトコロ、 デバイス設"
"定、ファンアウトモード、フラグが同じである必要がある (下記参照)。 パケットソ"
"ケットがファンアウトグループから抜けるのは、 そのソケットをクローズした場合だ"
"けである。 ファンアウトグループは最後のソケットがクローズした場合に削除され"
"る。"

#. type: Plain text
#: build/C/man7/packet.7:291
msgid ""
"Fanout supports multiple algorithms to spread traffic between sockets, as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:300
msgid ""
"The default mode, B<PACKET_FANOUT_HASH>, sends packets from the same flow to "
"the same socket to maintain per-flow ordering.  For each packet, it chooses "
"a socket by taking the packet flow hash modulo the number of sockets in the "
"group, where a flow hash is a hash over network-layer address and optional "
"transport-layer port fields."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:304
msgid ""
"The load-balance mode B<PACKET_FANOUT_LB> implements a round-robin algorithm."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:307
msgid ""
"B<PACKET_FANOUT_CPU> selects the socket based on the CPU that the packet "
"arrived on."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:311
msgid ""
"B<PACKET_FANOUT_ROLLOVER> processes all data on a single socket, moving to "
"the next when one becomes backlogged."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:314
msgid ""
"B<PACKET_FANOUT_RND> selects the socket using a pseudo-random number "
"generator."
msgstr ""

#.  commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
#. type: Plain text
#: build/C/man7/packet.7:319
msgid ""
"B<PACKET_FANOUT_QM> (available since Linux 3.14)  selects the socket using "
"the recorded queue_mapping of the received skb."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:335
msgid ""
"Fanout modes can take additional options.  IP fragmentation causes packets "
"from the same flow to have different flow hashes.  The flag "
"B<PACKET_FANOUT_FLAG_DEFRAG>, if set, causes packets to be defragmented "
"before fanout is applied, to preserve order even in this case.  Fanout mode "
"and options are communicated in the second 16 bits of the integer option "
"value.  The flag B<PACKET_FANOUT_FLAG_ROLLOVER> enables the roll over "
"mechanism as a backup strategy: if the original fanout algorithm selects a "
"backlogged socket, the packet rolls over to the next available one."
msgstr ""
"ファンアウトモードでは追加のオプションがある。 IP フラグメンテーションが起こ"
"ると、 同じフローのパケットのフローハッシュが異なるハッシュを持つことにな"
"る。 フラグ B<PACKET_FANOUT_FLAG_DEFRAG> をセットすると、 パケットはファンア"
"ウトを行う前にフラグメント再構築が行われるようになり、 フラグメントがあった場"
"合でも順序が維持される。 ファンアウトモードとオプションは、 整数のオプション"
"値の下位 16 ビットで指定される。 フラグ B<PACKET_FANOUT_FLAG_ROLLOVER> を指定"
"すると、 バックアップ戦略としてロールオーバー方式が有効になる。 元のファンア"
"ウトアルゴリズムが backlog ソケットを選択していれば、 パケットは次の利用可能"
"なソケットにロールオーバーされる。"

#. type: TP
#: build/C/man7/packet.7:335
#, no-wrap
msgid "B<PACKET_LOSS> (with B<PACKET_TX_RING>)"
msgstr "B<PACKET_LOSS> (B<PACKET_TX_RING> で使用)"

#. type: Plain text
#: build/C/man7/packet.7:358
msgid ""
"When a malformed packet is encountered on a transmit ring, the default is to "
"reset its I<tp_status> to B<TP_STATUS_WRONG_FORMAT> and abort the "
"transmission immediately.  The malformed packet blocks itself and "
"subsequently enqueued packets from being sent.  The format error must be "
"fixed, the associated I<tp_status> reset to B<TP_STATUS_SEND_REQUEST>, and "
"the transmission process restarted via B<send>(2).  However, if "
"B<PACKET_LOSS> is set, any malformed packet will be skipped, its "
"I<tp_status> reset to B<TP_STATUS_AVAILABLE>, and the transmission process "
"continued."
msgstr ""
"送信リングで不正な形式のパケットに遭遇した場合、 デフォルトではそのリングの "
"I<tp_status> を B<TP_STATUS_WRONG_FORMAT> に戻し、その送信を直ちに中止する。 "
"不正な形式のパケットにより、そのパケット自身とその以降にキューに入れられたパ"
"ケットの送信がブロックされる。形式エラーを修正し、関連する I<tp_status> を "
"B<TP_STATUS_SEND_REQUEST> に設定し直し、B<send>(2) を使って送信処理を再開しな"
"ければならない。 しかしながら、 B<PACKET_LOSS> がセットされている場合、 不正"
"な形式のパケットはすべてスキップされ、 その送信リングの I<tp_status> は "
"B<TP_STATUS_AVAILABLE> に設定し直され、送信処理は継続される。"

#. type: TP
#: build/C/man7/packet.7:358
#, no-wrap
msgid "B<PACKET_RESERVE> (with B<PACKET_RX_RING>)"
msgstr "B<PACKET_RESERVE> (B<PACKET_RX_RING> で使用)"

#. type: Plain text
#: build/C/man7/packet.7:363
msgid ""
"By default, a packet receive ring writes packets immediately following the "
"metadata structure and alignment padding.  This integer option reserves "
"additional headroom."
msgstr ""
"デフォルトでは、パケット受信リングはメタデータ構造体とアライメント用のパディ"
"ングの直後にパケットを書き込む。 この整数オプションを設定すると、パケットの前"
"に追加で領域が予約される。"

#. type: TP
#: build/C/man7/packet.7:363
#, no-wrap
msgid "B<PACKET_RX_RING>"
msgstr "B<PACKET_RX_RING>"

#. type: Plain text
#: build/C/man7/packet.7:405
msgid ""
"Create a memory-mapped ring buffer for asynchronous packet reception.  The "
"packet socket reserves a contiguous region of application address space, "
"lays it out into an array of packet slots and copies packets (up to "
"I<tp_snaplen>)  into subsequent slots.  Each packet is preceded by a "
"metadata structure similar to I<tpacket_auxdata>.  The protocol fields "
"encode the offset to the data from the start of the metadata header.  "
"I<tp_net> stores the offset to the network layer.  If the packet socket is "
"of type B<SOCK_DGRAM>, then I<tp_mac> is the same.  If it is of type "
"B<SOCK_RAW>, then that field stores the offset to the link-layer frame.  "
"Packet socket and application communicate the head and tail of the ring "
"through the I<tp_status> field.  The packet socket owns all slots with "
"I<tp_status> equal to B<TP_STATUS_KERNEL>.  After filling a slot, it changes "
"the status of the slot to transfer ownership to the application.  During "
"normal operation, the new I<tp_status> value has at least the "
"B<TP_STATUS_USER> bit set to signal that a received packet has been stored.  "
"When the application has finished processing a packet, it transfers "
"ownership of the slot back to the socket by setting I<tp_status> equal to "
"B<TP_STATUS_KERNEL>."
msgstr "非同期でのパケット受信用のメモリーマップされたリングバッファーを作成する。 パケットソケットはアプリケーションのアドレス空間に連続する領域を確保し、 そこにパケットスロットの配列を構成し、 (最大 I<tp_snaplen> 個の) パケットを順にスロットにコピーする。 各パケットの前には I<tpacket_auxdata> に似たメタデータ構造体が置かれる。 プロトコルフィールドには、データの、メタデータヘッダーの先頭からのオフセットが入る。 I<tp_net> にはネットワーク層へのオフセットが格納される。 パケットソケットが B<SOCK_DGRAM> 型の場合、 I<tp_mac> も同じである。 B<SOCK_RAW> 型の場合、 I<tp_net> にはリンク層のフレームへのオフセットが入る。 パケットソケットとアプリケーションは I<tp_status> フィールドを通してリングの先頭 (head) と末尾 (tail) の情報を受け渡す。 パケットソケットは I<tp_status> が B<TP_STATUS_KERNEL> のすべてのスロットを所有しており、 スロットにデータが入ると、 パケットソケットはそのスロットのステータスをアプリケーションに所有権を渡す状態に変更する。 通常の動作では、 新しい I<tp_status> で少なくとも B<TP_STATUS_USER> ビットがセットされていれば、 受信されたパケットが格納されたことを示している。 アプリケーションがパケットの処理を終えると、アプリケーションはそのスロットの B<tp_status> を B<TP_STATUS_KERNEL> に設定し、そのスロットの所有権をソケットに返す。"

#. type: Plain text
#: build/C/man7/packet.7:410
msgid ""
"Packet sockets implement multiple variants of the packet ring.  The "
"implementation details are described in I<Documentation/networking/"
"packet_mmap.rst> in the Linux kernel source tree."
msgstr "パケットソケットは、複数バージョンのパケットリングを実装している。 実装の詳細は Linux カーネルソースツリーの I<Documentation/networking/packet_mmap.txt> で説明されている。"

#. type: TP
#: build/C/man7/packet.7:410
#, no-wrap
msgid "B<PACKET_STATISTICS>"
msgstr "B<PACKET_STATISTICS>"

#. type: Plain text
#: build/C/man7/packet.7:413
msgid "Retrieve packet socket statistics in the form of a structure"
msgstr "パケットソケットの統計情報を次の構造体形式で取得する。"

#. type: Plain text
#: build/C/man7/packet.7:420
#, no-wrap
msgid ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* Total packet count */\n"
"    unsigned int tp_drops;    /* Dropped packet count */\n"
"};\n"
msgstr ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* 総パケット数 */\n"
"    unsigned int tp_drops;    /* ドロップパケット数 */\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:426
msgid ""
"Receiving statistics resets the internal counters.  The statistics structure "
"differs when using a ring of variant B<TPACKET_V3>."
msgstr ""
"統計情報を取得すると、内部カウンターはリセットされる。 B<TPACKET_V3> のリング"
"を使う場合には、統計情報構造体は違うものになる。"

#. type: TP
#: build/C/man7/packet.7:426
#, no-wrap
msgid "B<PACKET_TIMESTAMP> (with B<PACKET_RX_RING>; since Linux 2.6.36)"
msgstr "B<PACKET_TIMESTAMP> (B<PACKET_RX_RING> で使用; Linux 2.6.36 以降)"

#.  commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
#. type: Plain text
#: build/C/man7/packet.7:436
msgid ""
"The packet receive ring always stores a timestamp in the metadata header.  "
"By default, this is a software generated timestamp generated when the packet "
"is copied into the ring.  This integer option selects the type of "
"timestamp.  Besides the default, it support the two hardware formats "
"described in I<Documentation/networking/timestamping.rst> in the Linux "
"kernel source tree."
msgstr "パケット受信リングでは常にタイムスタンプがメタデータヘッダーに格納される。 デフォルトでは、タイムスタンプはパケットがリングにコピーされた時点で生成されるソフトウェアによるタイムスタンプである。 この整数オプションによりタイムスタンプの種類を選択できる。 デフォルト以外では、 Linux カーネルソースツリーの I<Documentation/networking/timestamping.rst> に説明がある 2 種類のハードウェアフォーマットがサポートされている。"

#. type: TP
#: build/C/man7/packet.7:436
#, no-wrap
msgid "B<PACKET_TX_RING> (since Linux 2.6.31)"
msgstr "B<PACKET_TX_RING> (Linux 2.6.31 以降)"

#.  commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
#. type: Plain text
#: build/C/man7/packet.7:471
msgid ""
"Create a memory-mapped ring buffer for packet transmission.  This option is "
"similar to B<PACKET_RX_RING> and takes the same arguments.  The application "
"writes packets into slots with I<tp_status> equal to B<TP_STATUS_AVAILABLE> "
"and schedules them for transmission by changing I<tp_status> to "
"B<TP_STATUS_SEND_REQUEST>.  When packets are ready to be transmitted, the "
"application calls B<send>(2)  or a variant thereof.  The I<buf> and I<len> "
"fields of this call are ignored.  If an address is passed using "
"B<sendto>(2)  or B<sendmsg>(2), then that overrides the socket default.  On "
"successful transmission, the socket resets I<tp_status> to "
"B<TP_STATUS_AVAILABLE>.  It immediately aborts the transmission on error "
"unless B<PACKET_LOSS> is set."
msgstr ""
"パケット送信用のメモリーマップされたリングバッファーを作成する。 このオプショ"
"ンは B<PACKET_RX_RING> と同様で、同じ引数を取る。 アプリケーションは "
"I<tp_status> が B<TP_STATUS_AVAILABLE> のスロットにパケットを書き込み、 "
"I<tp_status> を B<TP_STATUS_SEND_REQUEST> に変更することでそのパケットの送信"
"を予約する。 パケットの送信準備ができたら、アプリケーションは続けて "
"B<send>(2) 系のシステムコールを呼び出す。 システムコールの引数 I<buf> と "
"I<len> は無視される。 B<sendto>(2) や B<sendmsg>(2) を使ってアドレスが渡され"
"た場合、 ソケットのデフォルト値ではなくそのアドレスが使用される。 送信に成功"
"すると、ソケットはそのスロットの I<tp_status> を B<TP_STATUS_AVAILABLE> に戻"
"す。 エラーの場合、 B<PACKET_LOSS> がセットされていなければ、 直ちに送信を中"
"断しエラーを上げる。"

#. type: TP
#: build/C/man7/packet.7:471
#, no-wrap
msgid "B<PACKET_VERSION> (with B<PACKET_RX_RING>; since Linux 2.6.27)"
msgstr "B<PACKET_VERSION> (B<PACKET_RX_RING> で使用; Linux 2.6.27 以降)"

#.  commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
#. type: Plain text
#: build/C/man7/packet.7:480
msgid ""
"By default, B<PACKET_RX_RING> creates a packet receive ring of variant "
"B<TPACKET_V1>.  To create another variant, configure the desired variant by "
"setting this integer option before creating the ring."
msgstr ""
"デフォルトでは、 B<PACKET_RX_RING> は B<TPACKET_V1> のパケット受信リングを作"
"成する。別のバージョンのリングを作成するには、そのリングを作成する前に希望す"
"るバージョンが使われるようにこの整数オプションを設定すること。"

#. type: TP
#: build/C/man7/packet.7:480
#, no-wrap
msgid "B<PACKET_QDISC_BYPASS> (since Linux 3.14)"
msgstr "B<PACKET_QDISC_BYPASS> (Linux 3.14 以降)"

#.  commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
#. type: Plain text
#: build/C/man7/packet.7:495
msgid ""
"By default, packets sent through packet sockets pass through the kernel's "
"qdisc (traffic control) layer, which is fine for the vast majority of use "
"cases.  For traffic generator appliances using packet sockets that intend to "
"brute-force flood the network\\(emfor example, to test devices under load in "
"a similar fashion to pktgen\\(emthis layer can be bypassed by setting this "
"integer option to 1.  A side effect is that packet buffering in the qdisc "
"layer is avoided, which will lead to increased drops when network device "
"transmit queues are busy; therefore, use at your own risk."
msgstr ""
"デフォルトでは、パケットはカーネルの qdisc (トラフィック制御) レイヤー経由で"
"渡される。 これは大半のユースケースに合っている。 ネットワークに対して可能な"
"限りパケットを送信する (例えば pkggen と同様の方法で負荷対象のデバイスを試験"
"する) のにパケットソケットを使うトラフィック生成アプライアンスでは、この整数"
"オプションを 1 に設定することで qdisc レイヤーを飛ばすことができる。 qdisc レ"
"イヤーでのパケットバッファーが行われなくなるという副作用がある。 これによ"
"り、 ネットワークデバイスの送信キューの使用量が高い場合にパケット廃棄が起きや"
"すくなる。"

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: build/C/man7/packet.7:502
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval> variable."
msgstr ""
"B<SIOCGSTAMP> を用いると、最後に受信したパケットのタイムスタンプを得ることが"
"できる。 引数は I<struct timeval> 型の変数である。"

#. type: Plain text
#: build/C/man7/packet.7:508
msgid ""
"In addition, all standard ioctls defined in B<netdevice>(7)  and "
"B<socket>(7)  are valid on packet sockets."
msgstr ""
"さらに、 B<netdevice>(7)  および B<socket>(7)  で定義されている標準の ioctl "
"はいずれも packet ソケットに指定可能である。"

#. type: SS
#: build/C/man7/packet.7:508 build/C/man7/raw.7:136 build/C/man7/tcp.7:1324
#: build/C/man7/udp.7:103
#, no-wrap
msgid "Error handling"
msgstr "エラー処理"

#. type: Plain text
#: build/C/man7/packet.7:512
msgid ""
"Packet sockets do no error handling other than errors occurred while passing "
"the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""
"packet ソケットは、パケットをデバイスドライバに渡すときに 起きたエラーしか処"
"理しない。遅延エラー (pending error)  に関する概念は持っていない。"

#. type: Plain text
#: build/C/man7/packet.7:516
msgid "Unknown multicast group address passed."
msgstr "不明なマルチキャストグループアドレスが渡された。"

#. type: Plain text
#: build/C/man7/packet.7:519
msgid "User passed invalid memory address."
msgstr "ユーザーが渡したメモリーアドレスが不正。"

#. type: Plain text
#: build/C/man7/packet.7:522 build/C/man7/raw.7:160
msgid "Invalid argument."
msgstr "引数が不正。"

#. type: Plain text
#: build/C/man7/packet.7:525
msgid "Packet is bigger than interface MTU."
msgstr "パケットがインターフェースの MTU より大きい。"

#. type: TP
#: build/C/man7/packet.7:525
#, no-wrap
msgid "B<ENETDOWN>"
msgstr "B<ENETDOWN>"

#. type: Plain text
#: build/C/man7/packet.7:528
msgid "Interface is not up."
msgstr "インターフェースが up でない。"

#. type: Plain text
#: build/C/man7/packet.7:531
msgid "Not enough memory to allocate the packet."
msgstr "パケットに割り当てるメモリーが足りない。"

#. type: Plain text
#: build/C/man7/packet.7:534
msgid "Unknown device name or interface index specified in interface address."
msgstr ""
"デバイス名が不明。あるいはインターフェースアドレスで指定された インターフェー"
"スインデックスが不明。"

#. type: Plain text
#: build/C/man7/packet.7:537
msgid "No packet received."
msgstr "パケットを一つも受信していない。"

#. type: Plain text
#: build/C/man7/packet.7:540
msgid "No interface address passed."
msgstr "インターフェースアドレスが渡されなかった。"

#. type: TP
#: build/C/man7/packet.7:540
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man7/packet.7:543
msgid "Interface address contained an invalid interface index."
msgstr ""
"インターフェースアドレスに不正なインターフェースインデックスが含まれている。"

#. type: Plain text
#: build/C/man7/packet.7:546
msgid "User has insufficient privileges to carry out this operation."
msgstr "この操作を行うのに必要な権限をユーザーが持っていない。"

#. type: Plain text
#: build/C/man7/packet.7:548
msgid "In addition, other errors may be generated by the low-level driver."
msgstr "上記以外のエラーが、低レベルのドライバで生成されることがある。"

#. type: Plain text
#: build/C/man7/packet.7:553
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""
"B<AF_PACKET> は Linux 2.2 の新機能である。これより古いバージョンの Linux で"
"は B<SOCK_PACKET> のみをサポートしていた。"

#. type: Plain text
#: build/C/man7/packet.7:562
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this covers only a subset of the B<AF_PACKET> features."
msgstr ""
"移植性の必要なプログラムでは、 B<pcap>(3)  経由で B<AF_PACKET> を用いることを"
"お薦めする。ただし、この方法では B<AF_PACKET> の機能すべてを利用することはで"
"きない。"

#. type: Plain text
#: build/C/man7/packet.7:583
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE "
"802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the "
"length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the DSAP/"
"SSAP protocol fields; instead they are supplied to the user as protocol "
"B<ETH_P_802_2> with the LLC header prefixed.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""
"B<SOCK_DGRAM> packet ソケットは、IEEE 802.3 フレームの IEEE 802.2 LLC ヘッ"
"ダーの 生成や解析を行おうとしない。 B<ETH_P_802_3> が送信プロトコルに指定され"
"ると、カーネルは 802.3 フレームを 生成して length フィールドに書き込む。 完全"
"に準拠したパケットを得るためにはユーザーが LLC ヘッダーを 与える必要がある。"
"到着した 802.3 パケットでは、 DSAP/SSAP protocol の各フィールドは多重化 "
"(multiplex) されていない。 代わりにこれらは LLC ヘッダーが前置された "
"B<ETH_P_802_2> プロトコルとして与えられる。したがって、 B<ETH_P_802_3> にバイ"
"ンドすることはできない。かわりに B<ETH_P_802_2> にバインドし、自分自身でプロ"
"トコルの多重化を行うこと。 送信のデフォルトは、プロトコルフィールドを持つ 標"
"準の Ethernet DIX encapsulation である。"

#. type: Plain text
#: build/C/man7/packet.7:585
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr "packet ソケットは入出力の firewall chain に影響をうけない。"

#. type: Plain text
#: build/C/man7/packet.7:587
msgid "In Linux 2.0, the only way to get a packet socket was with the call:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:589
#, no-wrap
msgid "    socket(AF_INET, SOCK_PACKET, protocol)\n"
msgstr "    socket(AF_INET, SOCK_PACKET, protocol)\n"

#. type: Plain text
#: build/C/man7/packet.7:597
#, fuzzy
#| msgid ""
#| "In Linux 2.0, the only way to get a packet socket was by calling "
#| "B<socket(AF_INET, SOCK_PACKET, >I<protocol>B<)>.  This is still supported "
#| "but strongly deprecated.  The main difference between the two methods is "
#| "that B<SOCK_PACKET> uses the old I<struct sockaddr_pkt> to specify an "
#| "interface, which doesn't provide physical layer independence."
msgid ""
"This is still supported, but deprecated and strongly discouraged.  The main "
"difference between the two methods is that B<SOCK_PACKET> uses the old "
"I<struct sockaddr_pkt> to specify an interface, which doesn't provide "
"physical-layer independence."
msgstr ""
"Linux 2.0 では、 packet ソケットを得る方法は B<socket(AF_INET, SOCK_PACKET, "
">I<protocol>B<)> を呼ぶやり方しかなかった。この方法はまだサポートされている"
"が、 用いないことを強く推奨する。現在の方法との主な違いは、 B<SOCK_PACKET> で"
"はインターフェースの指定に古い I<struct sockaddr_pkt> を用いる点である。これ"
"には物理層からの独立性がない。"

#. type: Plain text
#: build/C/man7/packet.7:605
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"

#. type: Plain text
#: build/C/man7/packet.7:617
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""
"I<spkt_family> はデバイスのタイプ、 I<spkt_protocol> は I<E<lt>sys/if_ether."
"hE<gt>> で定義されている IEEE 802.3 プロトコルタイプ、 I<spkt_device> はデバ"
"イスの名前をヌル終端された文字列で与えたもの (例: eth0) である。"

#. type: Plain text
#: build/C/man7/packet.7:619
msgid "This structure is obsolete and should not be used in new code."
msgstr ""
"この構造体は obsolete であり、 新しくコードを書く時には用いるべきでない。"

#. type: Plain text
#: build/C/man7/packet.7:621
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr "IEEE 802.2/803.3 の LLC の扱い方は、バグと考えても良いだろう。"

#. type: Plain text
#: build/C/man7/packet.7:623
msgid "Socket filters are not documented."
msgstr "ソケットフィルターについて記載されていない。"

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: build/C/man7/packet.7:635
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""
"B<MSG_TRUNC> B<recvmsg>(2)  拡張は非常にまずい対処であり、制御メッセージで置"
"き換えるべきである。 今のところ B<SOCK_DGRAM> 経由でパケットについていた宛先"
"アドレスを得る方法がない。"

#. type: Plain text
#: build/C/man7/packet.7:642
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"
msgstr ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"

#. type: Plain text
#: build/C/man7/packet.7:645
msgid ""
"RFC\\ 894 for the standard IP Ethernet encapsulation.  RFC\\ 1700 for the "
"IEEE 802.3 IP encapsulation."
msgstr ""
"標準 IP Ethernet encapsulation に関しては RFC\\ 894 を、 IEEE 802.3 IP "
"encapsulation に関しては RFC\\ 1700 を参照。"

#. type: Plain text
#: build/C/man7/packet.7:649
msgid ""
"The I<E<lt>linux/if_ether.hE<gt>> include file for physical-layer protocols."
msgstr ""
"物理層のプロトコルに関する記述は I<E<lt>linux/if_ether.hE<gt>> インクルード"
"ファイルにある。"

#. type: Plain text
#: build/C/man7/packet.7:658
msgid ""
"The Linux kernel source tree.  I<Documentation/networking/filter.rst> "
"describes how to apply Berkeley Packet Filters to packet sockets.  I<tools/"
"testing/selftests/net/psock_tpacket.c> contains example source code for all "
"available versions of B<PACKET_RX_RING> and B<PACKET_TX_RING>."
msgstr "Linux カーネルのソースツリー。 I<Documentation/networking/filter.rst> には Berkeley Packet Filters をパケットソケットにどのように適用するかの説明がある。 I</tools/testing/selftests/net/psock_tpacket.c> には、 B<PACKET_RX_RING> と B<PACKET_TX_RING> の利用可能なすべてのバージョンのサンプルソースコードがある。"

#. type: TH
#: build/C/man5/protocols.5:29
#, no-wrap
msgid "PROTOCOLS"
msgstr "PROTOCOLS"

#. type: TH
#: build/C/man5/protocols.5:29
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: build/C/man5/protocols.5:32
msgid "protocols - protocols definition file"
msgstr "protocols - プロトコル定義ファイル"

#. type: Plain text
#: build/C/man5/protocols.5:40
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr ""
"このファイルは ASCII ファイルで、TCP/IP サブシステムから利用できる いろいろ"
"な DARPA インターネットプロトコルを記述している。 ARPA 関連のインクルードファ"
"イル内の数値を使うべきではないし、 単に推測した値を使うのはさらに良くない。 "
"代わりにこのファイルに問い合わせるべきである。 これらの数値は IP ヘッダーのプ"
"ロトコルフィールドに現れる。"

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: build/C/man5/protocols.5:46
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr ""
"このファイルは変更しないこと。変更すると IP パッケージが不正になる。 プロトコ"
"ル番号とプロトコル名は IANA (Internet Assigned Numbers Authority) によって指"
"定される。"

#. type: Plain text
#: build/C/man5/protocols.5:48
msgid "Each line is of the following format:"
msgstr "それぞれの行は次のフォーマットである。"

#. type: Plain text
#: build/C/man5/protocols.5:51
msgid "I<protocol number aliases ...>"
msgstr "I<protocol number aliases ...>"

#. type: Plain text
#: build/C/man5/protocols.5:57
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"If a line contains a hash mark (#), the hash mark and the part of the line "
"following it are ignored."
msgstr ""
"各フィールドは空白かタブで区切られていて、空行は無視される。 行にハッシュ記号"
"(#)が含まれる場合、 ハッシュ記号を含むその行の残りは無視される。"

#. type: TP
#: build/C/man5/protocols.5:59 build/C/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr "I<protocol>"

#. type: Plain text
#: build/C/man5/protocols.5:67
msgid ""
"the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr "プロトコルの固有名。たとえば I<ip>, I<tcp>, I<udp> など。"

#. type: Plain text
#: build/C/man5/protocols.5:71
msgid ""
"the official number for this protocol as it will appear within the IP header."
msgstr "プロトコルの公式番号、IP ヘッダーに現れる。"

#. type: Plain text
#: build/C/man5/protocols.5:74
msgid "optional aliases for the protocol."
msgstr "プロトコルの別名、オプション。"

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: build/C/man5/protocols.5:77 build/C/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""
"このファイルは Yellow Pages/NIS や BIND/Hesiod のようなネットワーク上の名前"
"サービスを用いて、ネットワークを通じて配布される可能性もある。"

#. type: Plain text
#: build/C/man5/protocols.5:81
msgid "The protocols definition file."
msgstr "プロトコル定義ファイル。"

#. type: Plain text
#: build/C/man5/protocols.5:83
msgid "B<getprotoent>(3)"
msgstr "B<getprotoent>(3)"

#. type: Plain text
#: build/C/man5/protocols.5:86
msgid "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"
msgstr "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"

#. type: TH
#: build/C/man7/raw.7:12
#, no-wrap
msgid "RAW"
msgstr "RAW"

#. type: Plain text
#: build/C/man7/raw.7:15
msgid "raw - Linux IPv4 raw sockets"
msgstr "raw - Linux の IPv4 raw ソケット"

#. type: Plain text
#: build/C/man7/raw.7:21
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/raw.7:25
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw "
"socket receives or sends the raw datagram not including link level headers."
msgstr ""
"raw ソケットを使うと、新しい IPv4 プロトコルをユーザー空間で 実装できるように"
"なる。 raw ソケットは、リンクレベルヘッダーを 含まない raw データグラムの送受"
"信ができる。"

#. type: Plain text
#: build/C/man7/raw.7:31
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving, the IP header is "
"always included in the packet."
msgstr ""
"IPv4 レイヤは、扱っているソケットで B<IP_HDRINCL> ソケットオプションが有効に"
"なっていなければ、 パケットを送信するときに IP ヘッダーを生成する。 "
"B<IP_HDRINCL> オプションが有効になっているときは、パケットには IP ヘッダーが"
"含まれていなければならない。 受信時には、 IP ヘッダーは常にパケットに含まれて"
"いる。"

#. type: Plain text
#: build/C/man7/raw.7:35
msgid ""
"In order to create a raw socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:46
#, fuzzy
#| msgid ""
#| "All packets or errors matching the I<protocol> number specified for the "
#| "raw socket are passed to this socket.  For a list of the allowed "
#| "protocols see RFC\\ 1700 assigned numbers and B<getprotobyname>(3)."
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols, see "
"the IANA list of assigned protocol numbers at E<.UR http://www.iana.org/"
"assignments/protocol-numbers/> E<.UE> and B<getprotobyname>(3)."
msgstr ""
"この raw ソケットに指定された I<protocol> 番号にマッチする全てのパケットとエ"
"ラーとが、このソケットに渡される。 許可されているプロトコルのリストは RFC\\ "
"1700 の割り当て番号と B<getprotobyname>(3)  を見よ。"

#. type: Plain text
#: build/C/man7/raw.7:56
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""
"B<IPPROTO_RAW> のプロトコルは暗黙のうちに B<IP_HDRINCL> を有効にするので、 渡"
"されたヘッダーで指定された、あらゆる IP プロトコルを送信できる。 "
"B<IPPROTO_RAW> 経由でのあらゆる IP プロトコルの受信は、 raw ソケットを用いて"
"は行えない。"

#. type: tbl table
#: build/C/man7/raw.7:61
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>"
msgstr "IP ヘッダーフィールド。 B<IP_HDRINCL> によって送信時に変更される。"

#. type: tbl table
#: build/C/man7/raw.7:62
#, no-wrap
msgid "IP Checksum"
msgstr "IP チェックサム"

#. type: tbl table
#: build/C/man7/raw.7:62 build/C/man7/raw.7:65
#, no-wrap
msgid "Always filled in"
msgstr "常に変更される"

#. type: tbl table
#: build/C/man7/raw.7:63
#, no-wrap
msgid "Source Address"
msgstr "ソースアドレス"

#. type: tbl table
#: build/C/man7/raw.7:63 build/C/man7/raw.7:64
#, no-wrap
msgid "Filled in when zero"
msgstr "元の値が 0 の時に変更される"

#. type: tbl table
#: build/C/man7/raw.7:64
#, no-wrap
msgid "Packet ID"
msgstr "パケット ID"

#. type: tbl table
#: build/C/man7/raw.7:65
#, no-wrap
msgid "Total Length"
msgstr "全体の長さ"

#. type: Plain text
#: build/C/man7/raw.7:79
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address, then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""
"B<IP_HERINCL> が指定されていて、 IP ヘッダーに 0 でない送信先アドレスが記入さ"
"れていた場合は、 その送信先アドレスがパケットの経路を決めるのに用いられる。 "
"B<MSG_DONTROUTE> が指定されている時には、 送信先アドレスはローカルなインター"
"フェースを参照するものでなければならない。 さもないと、ルーティングテーブルの"
"参照はいずれにせよ行われるが、 ゲートウェイが必要な経路は無視される。"

#. type: Plain text
#: build/C/man7/raw.7:87
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets "
"with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""
"B<IP_HDRINCL> がセットされていなければ、 raw ソケットの IP ヘッダーオプション"
"を B<setsockopt>(2)  を用いて設定することができる。詳細な情報は B<ip>(7)  を"
"見よ。"

#. type: Plain text
#: build/C/man7/raw.7:92
msgid ""
"Starting with Linux 2.2, all IP header fields and options can be set using "
"IP socket options.  This means raw sockets are usually needed only for new "
"protocols or protocols with no user interface (like ICMP)."
msgstr "Linux 2.2 以降では、 IP ヘッダーの全てのフィールドとオプションとを IP ソケットオプションによって設定できる。したがって raw ソケットが必要になるのは、新しいプロトコルを設計する場合か、 ユーザーインターフェースを持たないプロトコル (ICMP など) を扱う場合に 限られる。"

#. type: Plain text
#: build/C/man7/raw.7:96
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""
"パケットは、受信されるとまずプロトコルにバインドしている raw ソケットに渡さ"
"れ、 その後で他のプロトコルハンドラー (カーネルのプロトコルモジュールなど)  "
"に渡される。"

#.  commit f59fc7f30b710d45aadf715460b3e60dbe9d3418
#. type: Plain text
#: build/C/man7/raw.7:114
#, fuzzy
#| msgid ""
#| "Raw sockets use the standard I<sockaddr_in> address structure defined in "
#| "B<ip>(7).  The I<sin_port> field could be used to specify the IP protocol "
#| "number, but it is ignored for sending in Linux 2.2 and should be always "
#| "set to 0 (see BUGS).  For incoming packets, I<sin_port> is set to the "
#| "protocol of the packet.  See the I<E<lt>netinet/in.hE<gt>> include file "
#| "for valid IP protocols."
msgid ""
"For sending and receiving datagrams (B<sendto>(2), B<recvfrom>(2), and "
"similar), raw sockets use the standard I<sockaddr_in> address structure "
"defined in B<ip>(7).  The I<sin_port> field could be used to specify the IP "
"protocol number, but it is ignored for sending in Linux 2.2 and later, and "
"should be always set to 0 (see BUGS).  For incoming packets, I<sin_port> is "
"set to zero."
msgstr ""
"raw ソケットは標準の I<sockaddr_in> アドレス構造体を用いる。定義は B<ip>(7)  "
"でなされている。 I<sin_port> フィールドを IP プロトコル番号の指定に用いること"
"ができるが、 Linux 2.2 ではこれは送信時には無視され、常に 0 にされる (バグ の"
"項を参照)。 受信パケットに対しては、 I<sin_port> はそのパケットのプロトコルに"
"セットされる。 用いることのできる IP プロトコルは、インクルードファイル "
"I<E<lt>netinet/in.hE<gt>> を見よ。"

#.  Or SOL_RAW on Linux
#. type: Plain text
#: build/C/man7/raw.7:123
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""
"raw ソケットのオプションは、 B<IPPROTO_RAW> ファミリーフラグを与えて "
"B<setsockopt>(2)  を呼べば設定でき、 B<getsockopt>(2)  を呼べば取得できる。"

#. type: TP
#: build/C/man7/raw.7:123
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr "B<ICMP_FILTER>"

#. type: Plain text
#: build/C/man7/raw.7:131
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""
"B<IPPROTO_ICMP> プロトコルにバインドされた raw ソケットのための特殊なフィルタ"
"を有効にする。 この値は ICMP メッセージのタイプそれぞれに対して、どれをフィル"
"ターアウト するかを表したビットセットである。デフォルトでは ICMP メッセージは"
"全くフィルターしない。"

#. type: Plain text
#: build/C/man7/raw.7:136
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""
"さらに、データグラムソケットに使える全ての B<ip>(7)  B<SOL_IP> ソケットオプ"
"ションがサポートされている。"

#. type: Plain text
#: build/C/man7/raw.7:149
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""
"ネットワークで生じたエラーがユーザーに渡されるのは、 ソケットが接続済みの場合"
"か B<IP_RECVERR> フラグが有効になっている場合に限られる。 接続済みのソケット"
"に対しては、 B<EMSGSIZE> および B<EPROTO> だけが渡される (互換性のため)。 "
"B<IP_RECVERR> を設定すると、全てのネットワークエラーがエラーキューに保存され"
"る。"

#. type: Plain text
#: build/C/man7/raw.7:154
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""
"ユーザーが broadcast フラグを設定していないソケットを用いて ブロードキャスト"
"アドレスに送信を行おうとした。"

#. type: Plain text
#: build/C/man7/raw.7:157
msgid "An invalid memory address was supplied."
msgstr "不正なメモリーアドレスが与えられた。"

#. type: Plain text
#: build/C/man7/raw.7:167
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64\\ kB."
msgstr "パケットが大きすぎる。 Path MTU Discoverry が有効になっている (B<IP_MTU_DISCOVER> ソケットフラグ) か、パケットのサイズが IPv4 で許されている パケットサイズの最大値 64\\ KB を越えている。"

#. type: TP
#: build/C/man7/raw.7:167 build/C/man7/unix.7:734
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man7/raw.7:171
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr "ソケット呼び出しに不正なフラグ (B<MSG_OOB> など) が渡された。"

#. type: Plain text
#: build/C/man7/raw.7:177
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""
"ユーザーは raw ソケットをオープンする権限を持っていない。 実行ユーザー ID が "
"0 のプロセスか、 B<CAP_NET_RAW> 属性を持つプロセスだけがこれを行うことができ"
"る。"

#. type: TP
#: build/C/man7/raw.7:177
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: build/C/man7/raw.7:180
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr "パラメーターの問題を報告する ICMP エラーを受け取った。"

#. type: Plain text
#: build/C/man7/raw.7:186
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""
"B<IP_RECVERR> と B<ICMP_FILTER> は Linux 2.2 で登場した。これらは Linux での"
"拡張であり、 移植性の必要なプログラムでは用いるべきでない。"

#. type: Plain text
#: build/C/man7/raw.7:192
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set; since Linux 2.2, this "
"option no longer has that effect."
msgstr ""
"Linux 2.0 では B<SO_BSDCOMPAT> ソケットオプションをセットすると、 BSD の raw "
"ソケットにあるバグに互換性を取ることができた \\(em Linux 2.2 以降では、このオ"
"プションはもはや効力を持たない。"

#. type: Plain text
#: build/C/man7/raw.7:210
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"デフォルトでは、raw ソケットは Path MTU Discovery を行う。 つまり、カーネルは"
"特定の宛先 IP アドレスの MTU (Maximum Transmission Unit; 最大転送単位) を記録"
"し、raw パケットの書き込みが MTU を超えた場合 B<EMSGSIZE> を返す。 "
"B<EMSGSIZE> を返された場合、アプリケーションはパケットサイズを小さくすべきで"
"ある。 ソケットオプション B<IP_MTU_DISCOVER> または I</proc/sys/net/ipv4/"
"ip_no_pmtu_disc> ファイルを使って Path MTU Discovery を無効にすることもでき"
"る (詳細は B<ip>(7)  を参照)。 Path MTU Discovery を無効にした場合は、パケッ"
"トサイズが インターフェースの MTU よりも大きいと raw ソケットはそのパケット"
"を フラグメント化して送出する。 しかしながら、性能と信頼性の理由から Path "
"MTU Discovery を 無効にするのは推奨できない。"

#. type: Plain text
#: build/C/man7/raw.7:219
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a raw socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""
"B<bind>(2)  システムコールを用いると、 raw ソケットを 特定のローカルアドレス"
"にバインドさせることができる。 このバインドがされていない場合は、指定した IP "
"プロトコルの すべてのパケットが受信される。 さらに、 B<SO_BINDTODEVICE> を用"
"いれば raw ソケットを特定のネットワークデバイスに バインドさせることもでき"
"る。 B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/raw.7:230
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP "
"packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""
"B<IPPROTO_RAW> ソケットは送信専用である。もしどうしてもすべての IP パケット"
"を 受信したい場合は、 B<packet>(7)  ソケットを B<ETH_P_IP> プロトコルで用いる"
"こと。 packet ソケットは raw ソケットのように IP フラグメントを再構成しないこ"
"とに注意。"

#. type: Plain text
#: build/C/man7/raw.7:236
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""
"datagram ソケットに対するすべての ICMP パケットを受信したい場合は、 特定のソ"
"ケットに対して B<IP_RECVERR> を用いるほうが良い場合が多い。 B<ip>(7)  を見"
"よ。"

#. type: Plain text
#: build/C/man7/raw.7:243
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not "
"be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""
"raw ソケットは、 Linux のすべての IP プロトコルを受信することができる。 ICMP "
"や TCP のように、カーネル内部にプロトコルモジュールを持つような ものも可能で"
"ある。この場合には、パケットはカーネルモジュールと raw ソケットの両方に渡され"
"る (raw ソケットが複数あればそれぞれに渡される)。 移植性の必要なプログラムで"
"はこの機能に依存するべきではない。 他の多くの BSD におけるソケットの実装では"
"この点において制限がある。"

#. type: Plain text
#: build/C/man7/raw.7:248
msgid ""
"Linux never changes headers passed from the user (except for filling in some "
"zeroed fields as described for B<IP_HDRINCL>).  This differs from many other "
"implementations of raw sockets."
msgstr ""
"Linux はユーザーから渡されたヘッダーを決して変更しない (ただし B<IP_HDRINCL> "
"の説明にあるように、 0 をいくつか埋める場合を除く)。 これは他の多くの raw ソ"
"ケットの実装では異なる。"

#. type: Plain text
#: build/C/man7/raw.7:251
msgid ""
"Raw sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""
"一般に raw ソケットは移植性がないことが多いので、 移植性が必要なプログラムで"
"は避けるべきである。"

#. type: Plain text
#: build/C/man7/raw.7:257
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""
"raw ソケットへの送信では、 IP プロトコルを I<sin_port> から取得できなければな"
"らない。この機能は Linux 2.2 では使えなくなった。 B<IP_HDRINCL> を用いれば同"
"様のことが実現できる。"

#. type: Plain text
#: build/C/man7/raw.7:259
msgid "Transparent proxy extensions are not described."
msgstr "透過プロクシ (transparent proxy) 拡張については記述していない。"

#. type: Plain text
#: build/C/man7/raw.7:264
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""
"B<IP_HDRINCL> オプションがセットされているとデータグラムはフラグメント化され"
"ず、 インターフェースの MTU の大きさに制限される。"

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/raw.7:274
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""
"送信用の IP プロトコルの設定を I<sin_port> にしておく機能は Linux 2.2 から使"
"えなくなった。 ソケットにバインドされているプロトコルか、最初の "
"B<socket>(2)  コールによって指定されたプロトコルが常に用いられる。"

#. type: Plain text
#: build/C/man7/raw.7:280
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"

#. type: Plain text
#: build/C/man7/raw.7:287
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the I<E<lt>linux/ip."
"hE<gt>> header file for the IP protocol."
msgstr ""
"Path MTU discovery に関しては B<RFC\\ 1191> を参照。 IP プロトコルに関しては "
"B<RFC\\ 791> とインクルードファイル I<E<lt>linux/ip.hE<gt>> を参照。"

#. type: TH
#: build/C/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr "RCMD"

#. type: Plain text
#: build/C/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, \n"
"ruserok_af - リモートコマンドにストリームを返す関数群"

#. type: Plain text
#: build/C/man3/rcmd.3:51
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems */\n"
msgstr "B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems */\n"

#. type: Plain text
#: build/C/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<,>\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<,>\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr "B<int rresvport(int *>I<port>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<,>\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<,>\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<,>\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<,>\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<,>\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<,>\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<,>\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rcmd.3:95
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: build/C/man3/rcmd.3:116
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a file descriptor to a socket "
"with an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr "B<rcmd>() 関数は、スーパーユーザーがリモートマシンでコマンドを実行するために 用いられる。このとき特権ポート番号をもとにした認証スキームが 用いられる。 B<rresvport>() 関数は、特権ポート空間のアドレスを持つソケットのファイルディスクリプターを返す。 B<iruserok>() 関数と B<ruserok>() 関数は、 B<rcmd>() でサービス要求を行ったクライアントの認証を行うために サーバーが用いる関数である。 以上の 4 つの関数は、 B<rshd>(8) サーバーによって (他の関数とともに) 利用される。"

#. type: SS
#: build/C/man3/rcmd.3:116
#, no-wrap
msgid "rcmd()"
msgstr "rcmd()"

#. type: Plain text
#: build/C/man3/rcmd.3:131
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""
"B<rcmd>()  関数は B<gethostbyname>(3)  を用いて I<*ahost> の参照を行う。ホス"
"トが存在しない場合は -1 を返す。 見つかった場合は I<*ahost> にホストの標準名 "
"(standard name) をセットして、 予約されているインターネットポート I<inport> "
"経由でサーバーへの接続を確立する。"

#. type: Plain text
#: build/C/man3/rcmd.3:160
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be set up, and a file descriptor for it will be "
"placed in I<*fd2p>.  The control process will return diagnostic output from "
"the command (unit 2) on this channel, and will also accept bytes on this "
"channel as being UNIX signal numbers, to be forwarded to the process group "
"of the command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote "
"command) will be made the same as the I<stdout> and no provision is made for "
"sending arbitrary signals to the remote process, although you may be able to "
"get its attention by using out-of-band data."
msgstr "接続に成功したら、インターネットドメインに存在するタイプ B<SOCK_STREAM> のソケットが呼び出しもとに返される。 このソケットの相手側はリモートコマンドの I<stdin> および I<stdout> に接続される。 I<fd2p> がゼロでない場合は、制御プロセスへの接続がもう一つ用意され、 そのファイルディスクリプターが I<*fd2p> にセットされる。 制御プロセスはリモートコマンドからの標準エラー出力 (unit 2) を このチャンネルに返す。 また制御プロセスはこの接続から受け取ったバイトデータを UNIX シグナルの番号として扱い、リモートコマンドのプロセス グループへとシグナルを送る。 I<fd2p> がゼロの場合は、 I<stderr> (リモートコマンドの unit 2) は I<stdout> と一緒にまとめられる。またこの場合はリモートプロセスへ 任意のシグナルを送ることはできなくなる。 ただし帯域外 (out-of-band) データを用いれば、 リモートプロセスの注意を引くことはできるかもしれない。"

#. type: Plain text
#: build/C/man3/rcmd.3:163
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr "プロトコルの詳細は B<rshd>(8)  に記述されている。"

#. type: SS
#: build/C/man3/rcmd.3:163
#, no-wrap
msgid "rresvport()"
msgstr "rresvport()"

#. type: Plain text
#: build/C/man3/rcmd.3:186
#, fuzzy
#| msgid ""
#| "The B<rresvport>()  function is used to obtain a socket with a privileged "
#| "port bound to it.  This socket is suitable for use by B<rcmd>()  and "
#| "several other functions.  Privileged ports are those in the range 0 to "
#| "1023.  Only a privileged process (B<CAP_NET_BIND_SERVICE>)  is allowed to "
#| "bind to a privileged port.  In the glibc implementation, this function "
#| "restricts its search to the ports from 512 to 1023.  The I<port> argument "
#| "is value-result: the value it supplies to the call is used as the "
#| "starting point for a circular search of the port range; on (successful) "
#| "return, it contains the port number that was bound to."
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several "
"other functions.  Privileged ports are those in the range 0 to 1023.  Only a "
"privileged process (on Linux: a process that has the B<CAP_NET_BIND_SERVICE> "
"capability in the user namespace governing its network namespace).  is "
"allowed to bind to a privileged port.  In the glibc implementation, this "
"function restricts its search to the ports from 512 to 1023.  The I<port> "
"argument is value-result: the value it supplies to the call is used as the "
"starting point for a circular search of the port range; on (successful) "
"return, it contains the port number that was bound to."
msgstr ""
"B<rresvport>() 関数は特権ポートにバインドされたソケットを取得するために\n"
"用いられる。 このソケットは B<rcmd>() などの関数での利用に適している。\n"
"インターネットポートの特権ポートは、 0 から 1023 の範囲である。特権プロ\n"
"セス (B<CAP_NET_BIND_SERVICE>) だけが特権ポートをバインドすることができ\n"
"る。 glibc の実装では、この関数は特権ポートの検索範囲を 512 から 1023\n"
"までの範囲に制限している。 I<port> 引数は入出力両用で使用される。呼び\n"
"出し時にこの引数で渡された値は特権ポートを巡回検索する際の開始ポイン\n"
"トとして使用され、(成功で) 返る際にはこの引数にバインドされたポート\n"
"番号が格納される。"

#. type: SS
#: build/C/man3/rcmd.3:186
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr "iruserok() と ruserok()"

#. type: Plain text
#: build/C/man3/rcmd.3:203
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not> "
"the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""
"B<iruserok>()  と B<ruserok>()  関数は、まず以下の引数を取る: リモートホスト "
"(B<iruserok>()  は IP アドレスで、 B<ruserok>()  はホスト名で指定)、 2 つの"
"ユーザー名、ローカルユーザーの名前が スーパーユーザーのものであるかどうかを示"
"すフラグ、である。 もしユーザーがB<スーパーユーザーではない>場合は、これらの"
"関数は I</etc/hosts.equiv> ファイルをチェックする。ファイルが見つからなかった"
"り、 内容のチェックに失敗した場合には、 ローカルユーザーのホームディレクトリ"
"にある I<.rhosts> ファイルをチェックして、サービス要求が許可されているかどう"
"か調べる。"

#. type: Plain text
#: build/C/man3/rcmd.3:219
#, fuzzy
#| msgid ""
#| "If this file does not exist, is not a regular file, is owned by anyone "
#| "other than the user or the superuser, or is writable by anyone other than "
#| "the owner, the check automatically fails.  Zero is returned if the "
#| "machine name is listed in the I<hosts.equiv> file, or the host and remote "
#| "username are found in the I<.rhosts> file; otherwise B<iruserok>()  and "
#| "B<ruserok>()  return -1.  If the local domain (as obtained from "
#| "B<gethostname>(2))  is the same as the remote domain, only the machine "
#| "name need be specified."
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other "
"than the user or the superuser, is writable by anyone other than the owner, "
"or is hardlinked anywhere, the check automatically fails.  Zero is returned "
"if the machine name is listed in the I<hosts.equiv> file, or the host and "
"remote username are found in the I<.rhosts> file; otherwise B<iruserok>()  "
"and B<ruserok>()  return -1.  If the local domain (as obtained from "
"B<gethostname>(2))  is the same as the remote domain, only the machine name "
"need be specified."
msgstr ""
"このファイルが存在しなかったり、 通常ファイル (regular file) ではなかった"
"り、 指定ユーザーまたはスーパーユーザー以外の所有だったり、 所有者以外から書"
"き込み可能だったりした場合には、 このチェックは自動的に失敗する。 マシンの名"
"前が I<hosts.equiv> にリストされていたり、 ホストとリモートユーザーの名前が "
"I<.rhosts> ファイルに書かれていた場合には 0 が返される。 それ以外の場合に"
"は、 B<iruserok>()  と B<ruserok>()  は -1 を返す。 (B<gethostname>(2)  に"
"よって取得される) ローカルドメインがリモートのドメインと同じ場合は、 マシンの"
"名前だけを指定すればよい。"

#. type: Plain text
#: build/C/man3/rcmd.3:225
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used "
"in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""
"リモートホストの IP アドレスがわかっている場合は、 B<ruserok>()  よりも "
"B<iruserok>()B<を用いる方が良いだろう。> B<ruserok>()  はリモートホストの所属"
"するドメインの DNS サーバーが信頼できなくても 使用できるからである。"

#. type: SS
#: build/C/man3/rcmd.3:225
#, no-wrap
msgid "*_af() variants"
msgstr "*_af() 版"

#. type: Plain text
#: build/C/man3/rcmd.3:241
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports "
"the use of B<AF_UNSPEC>."
msgstr ""
"上記で述べた関数は全て IPv4 (B<AF_INET>) ソケットで動作する。\n"
"\"_af\" 版では追加の引数があり、この引数でソケットアドレス\n"
"ファミリーを指定できる。これらの関数では、 I<af> 引数には \n"
"B<AF_INET> か B<AF_INET6> が指定できる。\n"
"B<rcmd_af>() では追加で B<AF_UNSPEC> も指定できる。"

#. type: Plain text
#: build/C/man3/rcmd.3:247
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""
"B<rcmd>()  関数は成功すると有効なソケットディスクリプターを返す。 失敗すると "
"-1 を返し、標準エラー出力に診断メッセージを 表示する。"

#. type: Plain text
#: build/C/man3/rcmd.3:258
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded "
"to mean \"All network ports in use.\""
msgstr ""
"B<rresvport>()  関数は、成功するとバインドされた有効なソケットディスクリプ"
"ターを返す。 失敗すると -1 を返し、グローバル変数 I<errno> をエラーの原因に対"
"応する値にセットする。 エラーコード B<EAGAIN> は、この関数においては「すべて"
"のネットワークポートが使用中」 という意味を表す。"

#. type: Plain text
#: build/C/man3/rcmd.3:264
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr "B<ruserok>() と B<iruserok>() の返り値については、上述の説明を参照。"

#. type: Plain text
#: build/C/man3/rcmd.3:272
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""
"関数 B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(),\n"
"B<ruserok_af>() は glibc バージョン 2.2 以降で提供されている。"

#. type: tbl table
#: build/C/man3/rcmd.3:283
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>()"
msgstr ""
"B<rcmd>(),\n"
"B<rcmd_af>()"

#. type: tbl table
#: build/C/man3/rcmd.3:287
#, no-wrap
msgid ""
"B<rresvport>(),\n"
"B<rresvport_af>()"
msgstr ""
"B<rresvport>(),\n"
"B<rresvport_af>()"

#. type: tbl table
#: build/C/man3/rcmd.3:291
#, no-wrap
msgid ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"
msgstr ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"

#. type: tbl table
#: build/C/man3/rcmd.3:294
#, no-wrap
msgid ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"
msgstr ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"

#. type: Plain text
#: build/C/man3/rcmd.3:305
msgid ""
"Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""
"POSIX.1 にはない。 BSD 系、Solaris や他の多くのシステムに存在する。\n"
"これらの関数は 4.2BSD で登場した。 \"_af\" が付くバージョンはより最近に\n"
"追加されたもので、あまり多くのシステムには存在しない。"

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: build/C/man3/rcmd.3:312
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""
"B<iruserok>() と B<iruserok_af>() は glibc バージョン 2.12 以降のヘッダー\n"
"でのみ宣言されている。"

#. type: Plain text
#: build/C/man3/rcmd.3:319
msgid ""
"B<rlogin>(1), B<rsh>(1), B<rexec>(3), B<rexecd>(8), B<rlogind>(8), B<rshd>(8)"
msgstr "B<rlogin>(1), B<rsh>(1), B<rexec>(3), B<rexecd>(8), B<rlogind>(8), B<rshd>(8)"

#. type: TH
#: build/C/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr "RESOLV.CONF"

#. type: Plain text
#: build/C/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr "resolv.conf - レゾルバ設定ファイル"

#. type: Plain text
#: build/C/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr "B</etc/resolv.conf>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:42
#, fuzzy
#| msgid ""
#| "The I<resolver> is a set of routines in the C library that provide access "
#| "to the Internet Domain Name System (DNS).  The resolver configuration "
#| "file contains information that is read by the resolver routines the first "
#| "time they are invoked by a process.  The file is designed to be human "
#| "readable and contains a list of keywords with values that provide various "
#| "types of resolver information.  The configuration file is considered a "
#| "trusted source of DNS information (e.g., DNSSEC AD-bit information will "
#| "be returned unmodified from this source)."
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to "
"the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information.  The configuration file is considered a trusted source "
"of DNS information; see the B<trust-ad> option below for details."
msgstr ""
"I<resolver> は、インターネットのドメインネームシステム (DNS) へのアクセスを提"
"供する C ライブラリのルーチン群である。 レゾルバ設定ファイルには、レゾルバ"
"ルーチンがプロセスによって最初に 起動されたときに読み込まれる情報が格納されて"
"いる。 このファイルは人間に可読なように設計されている。 キーワードと値のリス"
"トが含まれ、いろいろなタイプのレゾルバ情報を提供する。 設定ファイルは DNS 情"
"報の信頼できる情報源とみなされる (例えば、このファイルからの DNSSEC AD ビット"
"情報は変更されずにそのまま返される)。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:46
#, fuzzy
#| msgid ""
#| "If this file does not exist, only the name server on the local machine "
#| "will be queried; the domain name is determined from the hostname and the "
#| "domain search path is constructed from the domain name."
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried, and the search list contains the local domain name determined "
"from the hostname."
msgstr ""
"このファイルが存在しない場合、問い合わせはローカルマシン上の\n"
"ネームサーバに対してのみ行われる。ドメイン名はホスト名から決定され、\n"
"ドメインの検索パスはドメイン名から作成される。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:48
msgid "The different configuration options are:"
msgstr "この状態を変更するための設定オプションには、以下のようなものがある。"

#. type: TP
#: build/C/man5/resolv.conf.5:48
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr "B<nameserver> ネームサーバの IP アドレス"

#. type: Plain text
#: build/C/man5/resolv.conf.5:65
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers, "
"then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""
"レゾルバが問い合わせをするネームサーバのインターネットアドレス。 アドレスに"
"は IPv4 アドレスか IPv6 アドレスを指定する。 IPv4 アドレスはドット表記で、 "
"IPv6 アドレスは RFC 2373 で定められたコロン表記 (おそらくドット表記も可) で指"
"定する。 このキーワード 1 つごとに 1 台づつ、 B<MAXNS> 台 (現状では 3 台、"
"I<E<lt>resolv.hE<gt>> を参照) までのネームサーバをリストできる。 複数のサーバ"
"が指定された場合、レゾルバライブラリは リストされた順に問い合わせを行う。 "
"B<nameserver> エントリーがない場合、 デフォルトではローカルマシン上のネーム"
"サーバが使われる。 (ここで使われるアルゴリズムは以下のようなものである。 はじ"
"めにネームサーバに問い合わせを試みる。 この問い合わせがタイムアウトになった場"
"合、 次のネームサーバに問い合わせを試みる。 これをネームサーバがなくなるまで"
"続ける。 それでも応答がない場合は、リトライ最大回数に達するまで 全てのネーム"
"サーバに問い合わせを繰り返す。)"

#. type: TP
#: build/C/man5/resolv.conf.5:65
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr "B<search> ホスト名ルックアップのための検索リスト"

#. type: Plain text
#: build/C/man5/resolv.conf.5:74
#, fuzzy
#| msgid ""
#| "Most queries for names within this domain can use short names relative to "
#| "the local domain.  If set to \\(aq.\\(aq, the root domain is considered.  "
#| "If no B<domain> entry is present, the domain is determined from the local "
#| "hostname returned by B<gethostname>(2); the domain part is taken to be "
#| "everything after the first \\(aq.\\(aq.  Finally, if the hostname does "
#| "not contain a domain part, the root domain is assumed."
msgid ""
"By default, the search list contains one entry, the local domain name.  It "
"is determined from the local hostname returned by B<gethostname>(2); the "
"local domain name is taken to be everything after the first \\(aq.\\(aq.  "
"Finally, if the hostname does not contain a \\(aq.\\(aq, the root domain is "
"assumed as the local domain name."
msgstr ""
"このドメインにある名前の問い合わせのほとんどに、 このローカルドメインに対する"
"短い名前を使用することができる。 \\(aq.\\(aq が設定された場合、 ルートドメイ"
"ンが指定されたとみなされる。 B<domain> エントリーがない場合、ドメイン名は "
"B<gethostname>(2)  で返されるローカルホスト名から決定され、 最初の \\(aq."
"\\(aq 以降の全ての部分がドメイン名とされる。 このホスト名にもドメイン部を含ん"
"でいない場合、ルートドメインが仮定される。"

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: build/C/man5/resolv.conf.5:101
msgid ""
"This may be changed by listing the desired domain search path following the "
"I<search> keyword with spaces or tabs separating the names.  Resolver "
"queries having fewer than I<ndots> dots (default is 1) in them will be "
"attempted using each component of the search path in turn until a match is "
"found.  For environments with multiple subdomains please read B<options "
"ndots:>I<n> below to avoid man-in-the-middle attacks and unnecessary traffic "
"for the root-dns-servers.  Note that this process may be slow and will "
"generate a lot of network traffic if the servers for the listed domains are "
"not local, and that queries will time out if no server is available for one "
"of the domains."
msgstr "これを変更するには、I<search> キーワードの後に 希望するドメイン検索パスをスペースまたはタブで区切ってリストすればよい。 ドットの数が I<ndots> (デフォルトでは 1) より少ないレゾルバの問い合わせは、 一致するものが見つかるまで検索パスの各要素を順に使って試す。 複数のサブドメインを持つ環境では、 第三者による攻撃 (man-in-the-middle attack) と ルート DNS サーバへの不必要なトラフィックを避けるために、 以下の B<options ndots:>I<n> を読んでほしい。 このプロセスは遅く、リストされたドメインがローカルのものでない場合、 多大なネットワークトラフィックを発生させることに注意すること。 さらに、これらのドメインのいずれかひとつにでも適切なサーバがない場合、 問い合わせがタイムアウトになる点にも注意すること。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:105
msgid ""
"If there are multiple B<search> directives, only the search list from the "
"last instance is used."
msgstr ""

#.  glibc commit 3f853f22c87f0b671c0366eb290919719fa56c0e
#. type: Plain text
#: build/C/man5/resolv.conf.5:111
#, fuzzy
#| msgid ""
#| "The search list is currently limited to six domains with a total of 256 "
#| "characters."
msgid ""
"In glibc 2.25 and earlier, the search list is limited to six domains with a "
"total of 256 characters.  Since glibc 2.26, the search list is unlimited."
msgstr "現状では、検索リストは 6 ドメイン・計 256 文字に制限されている。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:117
msgid ""
"The B<domain> directive is an obsolete name for the B<search> directive that "
"handles one search list entry only."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:117
#, no-wrap
msgid "B<sortlist>"
msgstr "B<sortlist>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:130
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted.  "
"A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and "
"optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""
"このオプションを使うと、 B<gethostbyname>(3)  で返されるアドレスをソートさせ"
"ることができる。 sortlist は IP アドレスとネットマスクのペアで指定される。 "
"ネットマスクは省略可能であり、 デフォルトではネットに対するデフォルトのネット"
"マスクである。 IP アドレスとオプションのネットマスクのペアはスラッシュで区切"
"る。 最大 10 組のペアを指定できる。 以下に例を示す。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:133
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"

#. type: TP
#: build/C/man5/resolv.conf.5:134
#, no-wrap
msgid "B<options>"
msgstr "B<options>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:138
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""
"options により、レゾルバの内部変数を変更することができる。 書式は以下の通りで"
"ある。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:141
msgid "B<options> I<option> I<...>"
msgstr "B<options> I<option> I<...>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:143
msgid "where I<option> is one of the following:"
msgstr "ここで I<option> は次のうちのいずれかである。"

#. type: TP
#: build/C/man5/resolv.conf.5:143
#, no-wrap
msgid "B<debug>"
msgstr "B<debug>"

#.  Since glibc 2.2?
#. type: Plain text
#: build/C/man5/resolv.conf.5:152
msgid ""
"Sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with "
"debug support; see B<resolver>(3))."
msgstr ""
"B<RES_DEBUG> を I<_res.options> にセットする (glibc がデバッグを有効にしてコ"
"ンパイルされている場合にのみ有効である; B<resolver>(3) を参照)。"

#. type: TP
#: build/C/man5/resolv.conf.5:152
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr "B<ndots:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:166
msgid ""
"Sets a threshold for the number of dots which must appear in a name given to "
"B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots "
"in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""
"「I<最初の完全な名前での問い合わせ>が実行される前に、 B<res_query>(3)  "
"(B<resolver>(3)  を参照) に与えられる名前に含まれているべきドットの数の閾値」"
"を設定する。 I<n> のデフォルトは 1 である。 これは、名前にドットがある場合、"
"I<search list> の要素が付加される前に、 その名前が完全な名前として最初に試さ"
"れるということを意味している。 このオプションの値の上限は 15 であり、黙ってこ"
"の値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:166
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr "B<timeout:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:181
#, fuzzy
#| msgid ""
#| "sets the amount of time the resolver will wait for a response from a "
#| "remote name server before retrying the query via a different name "
#| "server.  Measured in seconds, the default is B<RES_TIMEOUT> (currently 5, "
#| "see I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped "
#| "to 30."
msgid ""
"Sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server.  This may "
"B<not> be the total time taken by any resolver API call and there is no "
"guarantee that a single resolver API call maps to a single timeout.  "
"Measured in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""
"「レゾルバが他のネームサーバで問い合わせをリトライする前に、 リモートネーム"
"サーバからの応答を待つ時間」を設定する。 単位は秒で、デフォルトは "
"B<RES_TIMEOUT> である (現状では 5 秒、I<E<lt>resolv.hE<gt>> を参照)。 このオ"
"プションの値の上限は 30 であり、黙ってこの値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:181
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr "B<attempts:>I<n>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:190
msgid ""
"Sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""
"「レゾルバが諦めて呼び出し元のアプリケーションにエラーを返すまでに、 ネーム"
"サーバに問い合わせを行う回数」を設定する。 デフォルトは B<RES_DFLRETRY> 回で"
"ある (現状では 2 回、I<E<lt>resolv.hE<gt>> を参照)。 このオプションの値の上限"
"は 5 であり、黙ってこの値まで切り詰められる。"

#. type: TP
#: build/C/man5/resolv.conf.5:190
#, no-wrap
msgid "B<rotate>"
msgstr "B<rotate>"

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:200
msgid ""
"Sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of "
"name servers from among those listed.  This has the effect of spreading the "
"query load among all listed servers, rather than having all clients try the "
"first listed server first every time."
msgstr ""
"I<_res.options> に RES_ROTATE を設定する。リストされているネームサーバから選"
"ぶときに、ラウンドロビン (round-robin) 選択を行わせる。リストされている全ての"
"サーバで問い合わせの負荷を分散する効果があり、最初にリストされたサーバに全て"
"のクライアントが毎回最初に問い合わせを行うわけではなくなる。"

#. type: TP
#: build/C/man5/resolv.conf.5:200
#, no-wrap
msgid "B<no-check-names>"
msgstr "B<no-check-names>"

#.  since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:210
msgid ""
"Sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as "
"underscore (_), non-ASCII, or control characters."
msgstr ""
"I<_res.options> に B<RES_NOCHECKNAME> を設定する。 入ってくるホスト名とメール"
"アドレスに、 アンダースコア (_)・ASCII 以外の文字・制御文字といった 不正な文"
"字が含まれていないかを調べる 最近の BIND のチェックを無効にする。"

#. type: TP
#: build/C/man5/resolv.conf.5:210
#, no-wrap
msgid "B<inet6>"
msgstr "B<inet6>"

#.  Since glibc 2.2
#.  b76e065991ec01299225d9da90a627ebe6c1ac97
#. type: Plain text
#: build/C/man5/resolv.conf.5:227
#, fuzzy
#| msgid ""
#| "sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying "
#| "a AAAA query before an A query inside the B<gethostbyname>(3)  function, "
#| "and of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
#| "records are found but an A record set exists."
msgid ""
"Sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying an "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists.  Since glibc 2.25, this option is "
"deprecated; applications should use B<getaddrinfo>(3), rather than "
"B<gethostbyname>(3)."
msgstr ""
"I<_res.options> に B<RES_USE_INET6> を設定する。このオプションが設定される"
"と、 B<gethostbyname>(3)  関数の内部で A レコードの問い合わせを行う前に AAAA "
"レコードの問い合わせを行うようになる。 また、AAAA レコードは見つからないが A "
"レコードセットが存在する場合に、 IPv4 の応答を IPv6「トンネル形式」にマップす"
"るようになる。"

#. type: TP
#: build/C/man5/resolv.conf.5:227
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4 to 2.24)"
msgstr "B<ip6-bytestring> (glibc 2.3.4 から 2.24 まで)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:239
#, fuzzy
#| msgid ""
#| "sets B<RES_USE_BSTRING> in I<_res.options>.  This causes reverse IPv6 "
#| "lookups to be made using the bit-label format described in RFC\\ 2673; if "
#| "this option is not set, then nibble format is used."
msgid ""
"Sets B<RES_USEBSTRING> in I<_res.options>.  This causes reverse IPv6 lookups "
"to be made using the bit-label format described in RFC\\ 2673; if this "
"option is not set (which is the default), then nibble format is used.  This "
"option was removed in glibc 2.25, since it relied on a backward-incompatible "
"DNS extension that was never deployed on the Internet."
msgstr ""
"I<_res.options> に B<RES_USE_BSTRING> を設定する。このオプションが設定される"
"と、IPv6 アドレスの逆引きで RFC\\ 2673 で規定された bit-label 形式が使用され"
"るようになる。 このオプションが設定されない場合、nibble 形式が使用される。"

#. type: TP
#: build/C/man5/resolv.conf.5:239
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 to 2.24)"
msgstr "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 から 2.24 まで)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:262
#, fuzzy
#| msgid ""
#| "Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is "
#| "clear (B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  "
#| "I<ip6.int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 "
#| "lookups are made in the I<ip6.arpa> zone by default.  This option is set "
#| "by default."
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  I<ip6."
"int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 lookups "
"are made in the I<ip6.arpa> zone by default.  These options are available in "
"glibc versions up to 2.24, where B<no-ip6-dotint> is the default.  Since "
"B<ip6-dotint> support long ago ceased to be available on the Internet, these "
"options were removed in glibc 2.25."
msgstr ""
"I<_res.options> への B<RES_NOIP6DOTINT> のセット/クリアを行う。 このオプショ"
"ンがクリアされると (B<ip6-dotint>)、 IPv6 アドレスの逆引きが (非推奨の)  "
"I<ip6.int> ゾーンで行われるようになり、 このオプションがセットされると (B<no-"
"ip6-dotint>)、 IPv6 アドレスの逆引きがデフォルトの I<ip6.arpa> ゾーンで行われ"
"るようになる。 このオプションはデフォルトでセットされる。"

#. type: TP
#: build/C/man5/resolv.conf.5:262
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr "B<edns0> (glibc 2.6 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:269
msgid ""
"Sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""
"I<_res.options> に B<RES_USE_EDNSO> をセットする。これにより、RFC\\ 2671 で規"
"定されている DNS 拡張のサポートが有効になる。"

#. type: TP
#: build/C/man5/resolv.conf.5:269
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr "B<single-request> (glibc 2.10 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:282
msgid ""
"Sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and "
"IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""
"I<_res.options> に B<RES_SNGLKUP> をセットする。\n"
"glibc バージョン 2.9 以降では、 glibc はデフォルトでは\n"
"IPv4 と IPv6 の検索を並行して実行する。\n"
"アプライアンス DNS サーバの中には、このような問い合わせを\n"
"適切に処理できず、検索要求がタイムアウトになってしまう。\n"
"このオプションをセットすると、このデフォルトの動作が無効になり、\n"
"glibc は IPv6 と IPv4 の検索を順番に実行するようになる\n"
"(名前解決処理が若干遅くなるというデメリットがある)。"

#. type: TP
#: build/C/man5/resolv.conf.5:282
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr "B<single-request-reopen> (glibc 2.9 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:294
msgid ""
"Sets B<RES_SNGLKUPREOP> in I<_res.options>.  The resolver uses the same "
"socket for the A and AAAA requests.  Some hardware mistakenly sends back "
"only one reply.  When that happens the client system will sit and wait for "
"the second reply.  Turning this option on changes this behavior so that if "
"two requests from the same port are not handled correctly it will close the "
"socket and open a new one before sending the second request."
msgstr "I<_res.options> に B<RES_SNGLKUPREOP> をセットする。リゾルバは同じソケットを使って A レコードと AAAA レコードの検索要求を行う。 いくつかのハードウェアは実装が間違っており、応答を一つしか返さない。 この状況になると、クライアントシステムは 2 番目の応答を待ち続けてしまう。 このオプションを有効にすると、この動作が変更され、 同じポートからの 2 つの検索要求が正しく処理されなかった場合、 2 番目の検索要求を送信する前にソケットをクローズし 新しいソケットをオープンするようになる。"

#. type: TP
#: build/C/man5/resolv.conf.5:294
#, no-wrap
msgid "B<no-tld-query> (since glibc 2.14)"
msgstr "B<no-tld-query> (glibc 2.14 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:307
msgid ""
"Sets B<RES_NOTLDQUERY> in I<_res.options>.  This option causes "
"B<res_nsearch>()  to not attempt to resolve an unqualified name as if it "
"were a top level domain (TLD).  This option can cause problems if the site "
"has ``localhost'' as a TLD rather than having localhost on one or more "
"elements of the search list.  This option has no effect if neither "
"RES_DEFNAMES or RES_DNSRCH is set."
msgstr ""
"RES_NOTLDQUERY を I<_res.options> にセットする。 このオプションを設定する"
"と、 B<res_nsearch>() が完全なドメイン名ではない名前のトップレベルドメイン "
"(TLD) としての検索を行わなくなる。 これにより、localhost に検索リストの要素を"
"つけるのではなく、``localhost'' を TLD として設定しているようなサイトでは問題"
"が起こる可能性がある。 RES_DEFNAMES も RES_DNSRCH もセットされていない場合に"
"は、このオプションは効果はない。"

#. type: TP
#: build/C/man5/resolv.conf.5:307
#, no-wrap
msgid "B<use-vc> (since glibc 2.14)"
msgstr "B<use-vc> (glibc 2.14 以降)"

#.  aef16cc8a4c670036d45590877d411a97f01e0cd
#. type: Plain text
#: build/C/man5/resolv.conf.5:315
#, fuzzy
#| msgid ""
#| "sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the "
#| "DNS extensions described in RFC\\ 2671."
msgid ""
"Sets B<RES_USEVC> in I<_res.options>.  This option forces the use of TCP for "
"DNS resolutions."
msgstr ""
"I<_res.options> に B<RES_USE_EDNSO> をセットする。これにより、RFC\\ 2671 で規"
"定されている DNS 拡張のサポートが有効になる。"

#. type: TP
#: build/C/man5/resolv.conf.5:315
#, no-wrap
msgid "B<no-reload> (since glibc 2.26)"
msgstr "B<no-reload> (glibc 2.26 以降)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:322
msgid ""
"Sets B<RES_NORELOAD> in I<_res.options>.  This option disables automatic "
"reloading of a changed configuration file."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:322
#, no-wrap
msgid "B<trust-ad> (since glibc 2.31)"
msgstr "B<trust-ad> (glibc 2.31 以降)"

#.  446997ff1433d33452b81dfa9e626b8dccf101a4
#. type: Plain text
#: build/C/man5/resolv.conf.5:346
msgid ""
"Sets B<RES_TRUSTAD> in I<_res.options>.  This option controls the AD bit "
"behavior of the stub resolver.  If a validating resolver sets the AD bit in "
"a response, it indicates that the data in the response was verified "
"according to the DNSSEC protocol.  In order to rely on the AD bit, the local "
"system has to trust both the DNSSEC-validating resolver and the network path "
"to it, which is why an explicit opt-in is required.  If the B<trust-ad> "
"option is active, the stub resolver sets the AD bit in outgoing DNS queries "
"(to enable AD bit support), and preserves the AD bit in responses.  Without "
"this option, the AD bit is not set in queries, and it is always removed from "
"responses before they are returned to the application.  This means that "
"applications can trust the AD bit in responses if the B<trust-ad> option has "
"been set correctly."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:350
msgid ""
"In glibc version 2.30 and earlier, the AD is not set automatically in "
"queries, and is passed through unchanged to applications in responses."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:356
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on "
"a per-process basis by setting the environment variable B<LOCALDOMAIN> to a "
"space-separated list of search domains."
msgstr ""
"システムの I<resolv.conf> ファイルにある I<search> キーワードは、 スペースで"
"区切った検索ドメインのリストを 環境変数 B<LOCALDOMAIN> に設定することにより、"
"各プロセス毎に上書きすることができる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:362
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a "
"per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under B<options>."
msgstr ""
"システムの I<resolv.conf> ファイルにある I<options> キーワードは、 上の "
"B<options> セクションで説明したように、 スペースで区切ったレゾルバオプション"
"のリストを 環境変数 B<RES_OPTIONS> に設定することにより、各プロセス毎に修正す"
"ることができる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:366
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""
"キーワードと値は同じ行に書かなければならない。 また、(B<nameserver> のよう"
"な) キーワードが行の先頭になければならない。 値はキーワードの後にスペースで区"
"切って続ける。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:369
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr "セミコロン (;) かハッシュ文字 (#) で始まる行はコメントとして扱われる。"

#. type: Plain text
#: build/C/man5/resolv.conf.5:372
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"

#. type: Plain text
#: build/C/man5/resolv.conf.5:380
msgid ""
"B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), "
"B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"
msgstr "B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: build/C/man5/resolv.conf.5:382
msgid "Name Server Operations Guide for BIND"
msgstr "BIND のネームサーバオペレーションガイド"

#. type: TH
#: build/C/man3/resolver.3:33
#, no-wrap
msgid "RESOLVER"
msgstr "RESOLVER"

#. type: Plain text
#: build/C/man3/resolver.3:38
msgid ""
"res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, "
"res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, "
"res_mkquery, res_send, dn_comp, dn_expand - resolver routines"
msgstr "res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, dn_comp, dn_expand - レゾルバルーチン"

#. type: Plain text
#: build/C/man3/resolver.3:43
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
msgstr ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/resolver.3:46
#, no-wrap
msgid ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"
msgstr ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"

#. type: Plain text
#: build/C/man3/resolver.3:48
#, no-wrap
msgid "B<int res_ninit(res_state >I<statep>B<);>\n"
msgstr "B<int res_ninit(res_state >I<statep>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:50
#, no-wrap
msgid "B<void res_nclose(res_state >I<statep>B<);>\n"
msgstr "B<void res_nclose(res_state >I<statep>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:54
#, no-wrap
msgid ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:58
#, no-wrap
msgid ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:63
#, no-wrap
msgid ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:69
#, no-wrap
msgid ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:77
#, no-wrap
msgid ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"
msgstr ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:82
#, no-wrap
msgid ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"
msgstr ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"

#. type: SS
#: build/C/man3/resolver.3:84
#, no-wrap
msgid "Deprecated"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:87
#, no-wrap
msgid "B<extern struct __res_state _res;>\n"
msgstr "B<extern struct __res_state _res;>\n"

#. type: Plain text
#: build/C/man3/resolver.3:89
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr "B<int res_init(void);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:92
#, no-wrap
msgid ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:95
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:99
#, no-wrap
msgid ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:104
#, no-wrap
msgid ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:107
#, no-wrap
msgid ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: build/C/man3/resolver.3:114
msgid ""
"B<Note:> This page is incomplete (various resolver functions provided by "
"glibc are not described) and likely out of date."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:117
#, fuzzy
#| msgid ""
#| "These functions make queries to and interpret the responses from Internet "
#| "domain name servers."
msgid ""
"The functions described below make queries to and interpret the responses "
"from Internet domain name servers."
msgstr ""
"これらの関数はインターネットのドメインネームサーバーに問い合わせ、 その応答を"
"解釈する。"

#. type: Plain text
#: build/C/man3/resolver.3:133
msgid ""
"The API consists of a set of more modern, reentrant functions and an older "
"set of nonreentrant functions that have been superseded.  The traditional "
"resolver interfaces such as B<res_init>()  and B<res_query>()  use some "
"static (global) state stored in the I<_res> structure, rendering these "
"functions non-thread-safe.  BIND 8.2 introduced a set of new interfaces "
"B<res_ninit>(), B<res_nquery>(), and so on, which take a I<res_state> as "
"their first argument, so you can use a per-thread resolver state."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:159
#, fuzzy
#| msgid ""
#| "The B<res_init>()  function reads the configuration files (see B<resolv."
#| "conf>(5))  to get the default domain name, search order and name server "
#| "address(es).  If no server is given, the local host is tried.  If no "
#| "domain is given, that associated with the local host is used.  It can be "
#| "overridden with the environment variable B<LOCALDOMAIN>.  B<res_init>()  "
#| "is normally executed by the first call to one of the other functions."
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions read the configuration "
"files (see B<resolv.conf>(5))  to get the default domain name and name "
"server address(es).  If no server is given, the local host is tried.  If no "
"domain is given, that associated with the local host is used.  It can be "
"overridden with the environment variable B<LOCALDOMAIN>.  B<res_ninit>()  or "
"B<res_init>()  is normally executed by the first call to one of the other "
"functions.  Every call to B<res_ninit>()  requires a corresponding call to "
"B<res_nclose>()  to free memory allocated by B<res_ninit>()  and subsequent "
"calls to B<res_nquery>()."
msgstr ""
"B<res_init>()  関数は、デフォルトのドメイン名、検索順、ネームサーバー アドレ"
"スを得るために設定ファイル (B<resolv.conf>(5) 参照) を読む。 もしサーバーが示"
"されていなければローカルホストを試す。 ドメインが示されていなければローカルホ"
"ストに付けられたドメインを用いる。 環境変数 B<LOCALDOMAIN> でオーバーライドで"
"きる。 B<res_init>()  は、後述する関数のどれかが最初に呼び出された時、その関"
"数 から実行される。"

#. type: Plain text
#: build/C/man3/resolver.3:169
msgid ""
"The B<res_nquery>()  and B<res_query>()  functions query the name server for "
"the fully qualified domain name I<name> of specified I<type> and I<class>.  "
"The reply is left in the buffer I<answer> of length I<anslen> supplied by "
"the caller."
msgstr "関数 B<res_nquery>() と B<res_query>() は、指定された I<type> と I<class> の 完全修飾ドメイン名 (FQDN) I<name> を、ネームサーバーへ問い合わせる。 応答は、呼び出した側によって用意される長さ I<anslen> の I<answer> バッファーに残される。"

#. type: Plain text
#: build/C/man3/resolver.3:185
#, fuzzy
#| msgid ""
#| "The B<res_search>()  function makes a query and waits for the response "
#| "like B<res_query>(), but in addition implements the default and search "
#| "rules controlled by B<RES_DEFNAMES> and B<RES_DNSRCH> (see description of "
#| "I<_res> options below)."
msgid ""
"The B<res_nsearch>()  and B<res_search>()  functions make a query and waits "
"for the response like B<res_nquery>()  and B<res_query>(), but in addition "
"they implement the default and search rules controlled by B<RES_DEFNAMES> "
"and B<RES_DNSRCH> (see description of I<_res> options below)."
msgstr ""
"B<res_search>()  関数は、問い合わせを行い B<res_query>()  同様その応答を 待つ"
"が、さらにデフォルトを実装しており B<RES_DEFNAMES> と B<RES_DNSRCH> によって"
"規定される検索ルールを適用する。 (下記 I<_res> オプションの説明を参照)"

#. type: Plain text
#: build/C/man3/resolver.3:193
msgid ""
"The B<res_nquerydomain>()  and B<res_querydomain>()  functions make a query "
"using B<res_nquery>()/B<res_query>()  on the concatenation of I<name> and "
"I<domain>."
msgstr "関数 B<res_nquerydomain>() と B<res_querydomain>() は、 I<name> と I<domain> の結合にそれぞれ B<res_nquery>()/B<res_query>()  を用いて問い合わせを行う。"

#. type: Plain text
#: build/C/man3/resolver.3:196
msgid ""
"The following functions are lower-level routines used by B<res_nquery>()/"
"B<res_query>()."
msgstr "次の関数は、 B<res_nquery>()/B<res_query>() で使われる下位ルーチンである。"

#. type: Plain text
#: build/C/man3/resolver.3:206
#, fuzzy
#| msgid ""
#| "The B<res_mkquery>()  function constructs a query message in I<buf> of "
#| "length I<buflen> for the domain name I<dname>.  The query type I<op> is "
#| "usually B<QUERY>, but can be any of the types defined in I<E<lt>arpa/"
#| "nameser.hE<gt>>.  I<newrr> is currently unused."
msgid ""
"The B<res_nmkquery>()  and B<res_mkquery>()  functions construct a query "
"message in I<buf> of length I<buflen> for the domain name I<dname>.  The "
"query type I<op> is one of the following (typically B<QUERY>):"
msgstr ""
"B<res_mkquery>()  関数は、ドメイン名 I<dname> の為に、長さ I<buflen> の "
"I<buf> に問い合わせるメッセージを作成する。 問い合わせの型 I<op> は通常 "
"B<QUERY> だが、 I<E<lt>arpa/nameser.hE<gt>> で定義された型のどれでも良い。 "
"I<newrr> は現在使用されていない。"

#. type: TP
#: build/C/man3/resolver.3:206
#, no-wrap
msgid "B<QUERY>"
msgstr "B<QUERY>"

#. type: Plain text
#: build/C/man3/resolver.3:209
msgid "Standard query."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:209
#, no-wrap
msgid "B<IQUERY>"
msgstr "B<IQUERY>"

#.  commit e4e794841e3140875f2aa86b90e2ada3d61e1244
#. type: Plain text
#: build/C/man3/resolver.3:215
msgid ""
"Inverse query.  This option was removed in glibc 2.26, since it has not been "
"supported by DNS servers for a very long time."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:215
#, no-wrap
msgid "B<NS_NOTIFY_OP>"
msgstr "B<NS_NOTIFY_OP>"

#. type: Plain text
#: build/C/man3/resolver.3:218
msgid "Notify secondary of SOA (Start of Authority) change."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:220
msgid "I<newrr> is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:231
#, fuzzy
#| msgid ""
#| "The B<res_send>()  function sends a preformatted query given in I<msg> of "
#| "length I<msglen> and returns the answer in I<answer> which is of length "
#| "I<anslen>.  It will call B<res_init>(), if it has not already been called."
msgid ""
"The B<res_nsend>()  and B<res_send>()  function send a preformatted query "
"given in I<msg> of length I<msglen> and returns the answer in I<answer> "
"which is of length I<anslen>.  They will call B<res_ninit>()/B<res_init>()  "
"if it has not already been called."
msgstr ""
"B<res_send>()  関数は、長さ I<msglen> の I<msg> に決められた書式 で問い合わ"
"せ、I<answer> に長さ I<anslen> の回答を返す。 まだ呼び出されていなければ "
"B<res_init>()  を呼び出す。"

#. type: Plain text
#: build/C/man3/resolver.3:244
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""
"B<dn_comp>()  関数はドメイン名 I<exp_dn> を圧縮して、長さ I<length> のバッ"
"ファー I<comp_dn> に保存する。 圧縮にはポインター配列 I<dnptrs> を用いる。 こ"
"れらのポインターは、現在のメッセージの中にある以前に圧縮された名前を指す。 最"
"初のポインターはメッセージの冒頭を指し、そのリストは NULL で終わる。 配列の範"
"囲は I<lastdnptr> で決められる。 I<dnptr> が NULL ならばドメイン名は圧縮され"
"ない。 I<lastdnptr> が NULL ならば、そのラベルのリストはアップデートされな"
"い。"

#. type: Plain text
#: build/C/man3/resolver.3:253
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""
"B<dn_expand>()  関数は、圧縮されたドメイン名 I<comp_dn> からサイズ が "
"I<length> の I<exp_dn> バッファーに正式なドメイン名を展開する。 その圧縮され"
"た名前は、問い合わせ、または応答メッセージに含まれていて、 I<msg> がメッセー"
"ジの冒頭を指す。"

#. type: Plain text
#: build/C/man3/resolver.3:268
#, fuzzy
#| msgid ""
#| "The resolver routines use global configuration and state information "
#| "contained in the structure I<_res>, which is defined in I<E<lt>resolv."
#| "hE<gt>>.  The only field that is normally manipulated by the user is "
#| "I<_res.options>.  This field can contain the bitwise \"OR\" of the "
#| "following options:"
msgid ""
"The resolver routines use configuration and state information contained in a "
"I<__res_state> structure (either passed as the I<statep> argument, or in the "
"global variable I<_res>, in the case of the older nonreentrant functions).  "
"The only field of this structure that is normally manipulated by the user is "
"the I<options> field.  This field can contain the bitwise \"OR\" of the "
"following options:"
msgstr ""
"レゾルバルーチンは、I<E<lt>resolv.hE<gt>> に定義された I<_res> 構造体に 含ま"
"れている全体的な設定と状態の情報を使用する。 通常ユーザーに操作できる項目は "
"I<_res.options> だけである。 この項目は以下のオプションのビット単位の論理和に"
"できる。"

#. type: TP
#: build/C/man3/resolver.3:268
#, no-wrap
msgid "B<RES_INIT>"
msgstr "B<RES_INIT>"

#. type: Plain text
#: build/C/man3/resolver.3:275
msgid "True if B<res_ninit>()  or B<res_init>()  has been called."
msgstr "B<res_ninit>() か B<res_init>() が呼び出されていれば真。"

#. type: TP
#: build/C/man3/resolver.3:275
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr "B<RES_DEBUG>"

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: build/C/man3/resolver.3:282
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""
"デバッグ情報を表示する。このオプションは、 glibc がデバッグを有効にしてコンパ"
"イルされている場合にのみ利用できる。 デフォルトでは glibc のデバッグは有効に"
"なっていない。"

#. type: TP
#: build/C/man3/resolver.3:282
#, no-wrap
msgid "B<RES_AAONLY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:290
#, fuzzy
#| msgid ""
#| "Accept authoritative answers only.  B<res_send>()  continues until it "
#| "finds an authoritative answer or returns an error.  [Not currently "
#| "implemented]."
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""
"権威付けされた (authoritative) 回答のみ受け入れる。 B<res_send>()  は、最終的"
"に権威付けされた回答を得られるか、エラーが返される まで続行する。 [現在実装さ"
"れていない]"

#. type: TP
#: build/C/man3/resolver.3:290
#, no-wrap
msgid "B<RES_USEVC>"
msgstr "B<RES_USEVC>"

#. type: Plain text
#: build/C/man3/resolver.3:293
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr "問い合わせに UDP データグラムではなく TCP 接続を用いる。"

#. type: TP
#: build/C/man3/resolver.3:293
#, no-wrap
msgid "B<RES_PRIMARY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:298
msgid ""
"Query primary domain name server only.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:298
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr "B<RES_IGNTC>"

#. type: Plain text
#: build/C/man3/resolver.3:302
msgid "Ignore truncation errors.  Don't retry with TCP."
msgstr "切り詰めエラー (truncation error) を無視する。TCP でリトライしない。"

#. type: TP
#: build/C/man3/resolver.3:302
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr "B<RES_RECURSE>"

#. type: Plain text
#: build/C/man3/resolver.3:309
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""
"再帰要求 (recursion desired) ビットを問い合わせに設定する。 再帰は "
"B<res_send>()  ではなくドメインネームサーバーによって行われる。 [デフォルトで"
"有効]"

#. type: TP
#: build/C/man3/resolver.3:309
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr "B<RES_DEFNAMES>"

#. type: Plain text
#: build/C/man3/resolver.3:316
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names\\(emthat is, those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""
"設定されていれば、 B<res_search>()  はデフォルトのドメイン名を一部分 のみから"
"なる名前、すなわちドットを含まない名前に付け加える。 [デフォルトで有効]"

#. type: TP
#: build/C/man3/resolver.3:316
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr "B<RES_STAYOPEN>"

#. type: Plain text
#: build/C/man3/resolver.3:321
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr "問い合わせ中に TCP 接続を保つため B<RES_USEVC> と共に用いられる。"

#. type: TP
#: build/C/man3/resolver.3:321
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr "B<RES_DNSRCH>"

#. type: Plain text
#: build/C/man3/resolver.3:330
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and "
"in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled by "
"default]."
msgstr ""
"設定されていれば、 B<res_search>()  は現在のドメインおよび親ドメインの ホスト"
"名を探す。このオプションは B<gethostbyname>(3)  で用いられる。 [デフォルトで"
"有効]"

#. type: TP
#: build/C/man3/resolver.3:330
#, no-wrap
msgid "B<RES_INSECURE1>"
msgstr "B<RES_INSECURE1>"

#. type: Plain text
#: build/C/man3/resolver.3:337
msgid ""
"Accept a response from a wrong server.  This can be used to detect potential "
"security hazards, but you need to compile glibc with debugging enabled and "
"use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:337
#, no-wrap
msgid "B<RES_INSECURE2>"
msgstr "B<RES_INSECURE2>"

#. type: Plain text
#: build/C/man3/resolver.3:344
msgid ""
"Accept a response which contains a wrong query.  This can be used to detect "
"potential security hazards, but you need to compile glibc with debugging "
"enabled and use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:344
#, no-wrap
msgid "B<RES_NOALIASES>"
msgstr "B<RES_NOALIASES>"

#. type: Plain text
#: build/C/man3/resolver.3:349
msgid "Disable usage of B<HOSTALIASES> environment variable."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:349
#, no-wrap
msgid "B<RES_USE_INET6>"
msgstr "B<RES_USE_INET6>"

#. type: Plain text
#: build/C/man3/resolver.3:361
#, fuzzy
#| msgid ""
#| "sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying "
#| "a AAAA query before an A query inside the B<gethostbyname>(3)  function, "
#| "and of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
#| "records are found but an A record set exists."
msgid ""
"Try an AAAA query before an A query inside the B<gethostbyname>(3)  "
"function, and map IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
"records are found but an A record set exists.  Since glibc 2.25, this option "
"is deprecated, and its usage produces a warning; applications should use "
"B<getaddrinfo>(3), rather than B<gethostbyname>(3)."
msgstr ""
"I<_res.options> に B<RES_USE_INET6> を設定する。このオプションが設定される"
"と、 B<gethostbyname>(3)  関数の内部で A レコードの問い合わせを行う前に AAAA "
"レコードの問い合わせを行うようになる。 また、AAAA レコードは見つからないが A "
"レコードセットが存在する場合に、 IPv4 の応答を IPv6「トンネル形式」にマップす"
"るようになる。"

#. type: TP
#: build/C/man3/resolver.3:361
#, no-wrap
msgid "B<RES_ROTATE>"
msgstr "B<RES_ROTATE>"

#. type: Plain text
#: build/C/man3/resolver.3:367
msgid ""
"Causes round-robin selection of name servers from among those listed.  This "
"has the effect of spreading the query load among all listed servers, rather "
"than having all clients try the first listed server first every time."
msgstr "リストされているネームサーバから選ぶときに、ラウンドロビン (round-robin) 選択を行わせる。リストされている全てのサーバで問い合わせの負荷を分散する効果があり、最初にリストされたサーバに全てのクライアントが毎回最初に問い合わせを行うわけではなくなる。"

#. type: TP
#: build/C/man3/resolver.3:367
#, no-wrap
msgid "B<RES_NOCHECKNAME> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:374
#, fuzzy
#| msgid ""
#| "sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern "
#| "BIND checking of incoming hostnames and mail names for invalid characters "
#| "such as underscore (_), non-ASCII, or control characters."
msgid ""
"Disable the modern BIND checking of incoming hostnames and mail names for "
"invalid characters such as underscore (_), non-ASCII, or control "
"characters.  This option was present in glibc until version 2.24; since "
"glibc 2.25, it is deprecated, and its usage produces a warning."
msgstr ""
"I<_res.options> に B<RES_NOCHECKNAME> を設定する。 入ってくるホスト名とメール"
"アドレスに、 アンダースコア (_)・ASCII 以外の文字・制御文字といった 不正な文"
"字が含まれていないかを調べる 最近の BIND のチェックを無効にする。"

#. type: TP
#: build/C/man3/resolver.3:374
#, no-wrap
msgid "B<RES_KEEPTSIG> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:379
msgid ""
"Do not strip TSIG records.  This option was present but unimplemented in "
"glibc until version 2.24; since glibc 2.25, it is deprecated, and its usage "
"produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:379
#, no-wrap
msgid "B<RES_BLAST> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:384
msgid ""
"Send each query simultaneously and recursively to all servers.  This option "
"was present but unimplemented in glibc until version 2.24; since glibc 2.25, "
"it is deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:384
#, no-wrap
msgid "B<RES_USEBSTRING> (glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:391
msgid ""
"Make reverse IPv6 lookups using the bit-label format described in RFC 2673; "
"if this option is not set (which is the default), then nibble format is "
"used.  This option was removed in glibc 2.25, since it relied on a backward-"
"incompatible DNS extension that was never deployed on the Internet."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:391
#, no-wrap
msgid "B<RES_NOIP6DOTINT> (glibc 2.24 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:401
msgid ""
"Use I<ip6.arpa> zone in IPv6 reverse lookup instead of I<ip6.int>, which is "
"deprecated since glibc 2.3.4.  This option is present in glibc up to and "
"including version 2.24, where it is enabled by default.  In glibc 2.25, this "
"option was removed."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:401
#, no-wrap
msgid "B<RES_USE_EDNS0> (since glibc 2.6)"
msgstr "B<RES_USE_EDNS0> (glibc 2.6 以降)"

#. type: Plain text
#: build/C/man3/resolver.3:404
msgid "Enables support for the DNS extensions (EDNS0) described in RFC 2671."
msgstr "RFC 2671 で規定されている DNS 拡張 (EDNS0) のサポートが有効になる。"

#. type: TP
#: build/C/man3/resolver.3:404
#, no-wrap
msgid "B<RES_SNGLKUP> (since glibc 2.10)"
msgstr "B<RES_SNGLKUP> (glibc 2.10 以降)"

#. type: Plain text
#: build/C/man3/resolver.3:413
msgid ""
"By default, glibc performs IPv4 and IPv6 lookups in parallel since version "
"2.9.  Some appliance DNS servers cannot handle these queries properly and "
"make the requests time out.  This option disables the behavior and makes "
"glibc perform the IPv6 and IPv4 requests sequentially (at the cost of some "
"slowdown of the resolving process)."
msgstr "glibc バージョン 2.9 以降では、 glibc はデフォルトでは IPv4 と IPv6 の検索を並行して実行する。アプライアンス DNS サーバの中には、このような問い合わせを適切に処理できず、検索要求がタイムアウトになってしまう。このオプションをセットすると、このデフォルトの動作が無効になり、 glibc は IPv6 と IPv4 の検索を順番に実行するようになる (名前解決処理が若干遅くなるというデメリットがある)。"

#. type: TP
#: build/C/man3/resolver.3:413
#, no-wrap
msgid "B<RES_SNGLKUPREOP>"
msgstr "B<RES_SNGLKUPREOP>"

#. type: Plain text
#: build/C/man3/resolver.3:418
msgid ""
"When B<RES_SNGLKUP> option is enabled, opens a new socket for the each "
"request."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:418
#, no-wrap
msgid "B<RES_USE_DNSSEC>"
msgstr "B<RES_USE_DNSSEC>"

#. type: Plain text
#: build/C/man3/resolver.3:423
msgid ""
"Use DNSSEC with OK bit in OPT record.  This option implies B<RES_USE_EDNS0>."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:423
#, no-wrap
msgid "B<RES_NOTLDQUERY>"
msgstr "B<RES_NOTLDQUERY>"

#. type: Plain text
#: build/C/man3/resolver.3:426
msgid "Do not look up unqualified name as a top-level domain (TLD)."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:426
#, no-wrap
msgid "B<RES_DEFAULT>"
msgstr "B<RES_DEFAULT>"

#. type: Plain text
#: build/C/man3/resolver.3:435
msgid ""
"Default option which implies: B<RES_RECURSE>, B<RES_DEFNAMES>, "
"B<RES_DNSRCH>, and B<RES_NOIP6DOTINT>."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:442
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions return 0 on success, or -1 "
"if an error occurs."
msgstr "関数 B<res_ninit>() と B<res_init>() は成功すれば 0 を、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:457
#, fuzzy
#| msgid ""
#| "The B<res_query>(), B<res_search>(), B<res_querydomain>(), "
#| "B<res_mkquery>()  and B<res_send>()  functions return the length of the "
#| "response, or -1 if an error occurs."
msgid ""
"The B<res_nquery>(), B<res_query>(), B<res_nsearch>(), B<res_search>(), "
"B<res_nquerydomain>(), B<res_querydomain>(), B<res_nmkquery>(), "
"B<res_mkquery>(), B<res_nsend>(), and B<res_send>()  functions return the "
"length of the response, or -1 if an error occurs."
msgstr ""
"B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>(), "
"B<res_send>()  関数は応答の長さを返す。 また、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:464
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""
"B<dn_comp>()  と B<dn_expand>()  関数は圧縮されたドメイン名の長さを返す。 ま"
"た、エラーが発生すれば -1 を返す。"

#. type: Plain text
#: build/C/man3/resolver.3:478
msgid ""
"In the case of an error return from B<res_nquery>(), B<res_query>(), "
"B<res_nsearch>(), B<res_search>(), B<res_nquerydomain>(), or "
"B<res_querydomain>(), the global variable I<h_errno> (see "
"B<gethostbyname>(3))  can be consulted to determine the cause of the error."
msgstr ""

#. type: tbl table
#: build/C/man3/resolver.3:497
#, no-wrap
msgid ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"
msgstr ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"

#. type: tbl table
#: build/C/man3/resolver.3:501
#, no-wrap
msgid ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"
msgstr ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"

#. type: tbl table
#: build/C/man3/resolver.3:505
#, no-wrap
msgid ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"
msgstr ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"

#. type: tbl table
#: build/C/man3/resolver.3:507
#, no-wrap
msgid "B<dn_expand>()"
msgstr "B<dn_expand>()"

#. type: Plain text
#: build/C/man3/resolver.3:512
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/resolver.3:518
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"

#. type: Plain text
#: build/C/man3/resolver.3:521
msgid "The GNU C library source file I<resolv/README>."
msgstr ""

#. type: TH
#: build/C/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr "REXEC"

#. type: Plain text
#: build/C/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr "rexec, rexec_af - リモートコマンドへのストリームを返す"

#. type: Plain text
#: build/C/man3/rexec.3:50
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<,>\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<,>\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: build/C/man3/rexec.3:54
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<,>\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<,>\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: build/C/man3/rexec.3:58
msgid "B<rexec>(), B<rexec_af>():"
msgstr "B<rexec>(), B<rexec_af>():"

#. type: Plain text
#: build/C/man3/rexec.3:67
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr "このインターフェースは B<rcmd>(3)  によって置き換えられた。"

#. type: Plain text
#: build/C/man3/rexec.3:86
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the I<.netrc> file in "
"user's home directory are searched for appropriate information.  If all this "
"fails, the user is prompted for the information."
msgstr ""
"B<rexec>()  関数は B<gethostbyname>(3)  を使ってホスト I<*ahost> を探す。ホス"
"トが存在しない場合は -1 を返し、それ以外の場合には I<*ahost> にそのホストの標"
"準的な名前を設定する。 ユーザー名とパスワードの両方が指定された場合には、これ"
"らは 接続先のホストへの認証に利用される。そうでない場合には、 適切な情報を入"
"手するために、環境変数と、そのユーザーの ホームディレクトリの I<.netrc> ファ"
"イルが検索される。情報が見つからなかった時には、 ユーザーに対して情報を入力す"
"るプロンプトが表示される。"

#. type: Plain text
#: build/C/man3/rexec.3:97
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for "
"the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""
"ポート I<inport> には、接続に使用する DARPA Internet の well-known ポートを指"
"定する。 I<getservbyname(\"exec\", \"tcp\")> を呼び出すと構造体へのポインター"
"が返され (B<getservent>(3)  参照)、この構造体には必要なポートが入っている。 "
"接続に使用されるプロトコルについての詳細は B<rexecd>(8)  に書かれている (訳"
"注: 現在のところ存在しない)。"

#. type: Plain text
#: build/C/man3/rexec.3:130
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be setup, and a file descriptor for it will be placed "
"in I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr "接続に成功すると、インターネットドメインの B<SOCK_STREAM> 型のソケットが返され、そのソケットはリモートコマンドの 標準入力および標準出力となる。 I<fd2p> が 0 以外の場合、制御プロセスへの補助チャンネルがセットアップされ、 補助チャンネルのファイルディスクリプターが I<*fd2p> に書かれる。 制御プロセスはコマンドからの診断メッセージ出力 (ファイルディスクリプター 2)  をこのチャンネルで返す。また、このチャンネル経由で UNIX のシグナル番号を示すバイトを受信する。受信したシグナルは コマンドが属すプロセスグループに転送される。 診断情報にはリモートの認証失敗は含まれない。なぜなら、認証の確認が行われた 後で補助チャンネルの接続はセットアップされるからである。 I<fd2p> が 0 の場合、標準エラー (リモートコマンドのファイルディスクリプター 2) は 標準出力と同様に扱われ、リモートプロセスに任意のシグナルを送るための 手段は提供されない。但し、リモートプロセスに対してトリガーをかけるために、 帯域外データ (out-of-band data) を使うことはできる。"

#. type: SS
#: build/C/man3/rexec.3:130
#, no-wrap
msgid "rexec_af()"
msgstr "rexec_af()"

#. type: Plain text
#: build/C/man3/rexec.3:146
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""
"B<rexec>() 関数は IPv4 (B<AF_INET>) 上で動作する。\n"
"これに対して、 B<rexec_af>() 関数は追加の引数 I<af> があり、\n"
"この引数で呼び出し側がプロトコルを選択できる。\n"
"この引数には B<AF_INET>, B<AF_INET6>, B<AF_UNSPEC> を指定できる\n"
"(B<AF_UNSPEC> は実装側がプロトコルを選択することを意味する)。"

#. type: Plain text
#: build/C/man3/rexec.3:150
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr "B<rexec_af>() 関数は glibc バージョン 2.9 で追加された。"

#. type: tbl table
#: build/C/man3/rexec.3:161
#, no-wrap
msgid ""
"B<rexec>(),\n"
"B<rexec_af>()"
msgstr ""
"B<rexec>(),\n"
"B<rexec_af>()"

#. type: Plain text
#: build/C/man3/rexec.3:172
msgid ""
"These functions are not in POSIX.1.  The B<rexec>()  function first appeared "
"in 4.2BSD, and is present on the BSDs, Solaris, and many other systems.  The "
"B<rexec_af>()  function is more recent, and less widespread."
msgstr ""
"これらの関数は POSIX.1 にはない。B<rexec>() 関数は 4.2BSD で始めて\n"
"登場し、BSD 系、Solaris や他の多くのシステムに存在する。B<rexec_af>()\n"
"関数はもっと新しく、それほど広く使われているわけではない。"

#. type: Plain text
#: build/C/man3/rexec.3:176
msgid ""
"The B<rexec>()  function sends the unencrypted password across the network."
msgstr ""
"B<rexec>()  関数はネットワークに暗号化されていないパスワードを送信する。"

#. type: Plain text
#: build/C/man3/rexec.3:181
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""
"基礎的なサービスにおいては大きなセキュリティホールと考えられるため、 \n"
"多くのサイトで無効になっている。詳細は B<rexecd>(8) を参照。"

#. type: Plain text
#: build/C/man3/rexec.3:184
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr "B<rcmd>(3), B<rexecd>(8)"

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr "SERVICES"

#. type: TH
#: build/C/man5/services.5:34 build/C/man7/udp.7:12
#, no-wrap
msgid "2020-04-11"
msgstr "2020-04-11"

#. type: Plain text
#: build/C/man5/services.5:37
msgid "services - Internet network services list"
msgstr "services - インターネット ネットワークサービス リスト"

#. type: Plain text
#: build/C/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly "
"textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr ""
"B<services> は、人が分かりやすい形のインターネットサービスの名前と、 それらの"
"サービスに割り当てられたポート番号や プロトコル種別の対応関係が書かれているテ"
"キストファイルである。 ネットワーク上で動作するプログラムはすべて、 そのサー"
"ビスに対応するポート番号 (とプロトコル) を得るために、 このファイルを調べる必"
"要がある。 C ライブラリ関数である B<getservent>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<setservent>(3), B<endservent>(3)  を利用することで、プ"
"ログラムはこのファイルを調べることができる。"

#. type: Plain text
#: build/C/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority), "
"and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr ""
"ポート番号は、IANA (Internet Assigned Numbers Authority) によって 割り当てら"
"れており、現在はポート番号を割り当てる際に TCP と UDP の両方のプロトコルを割"
"り当てることになっている。 そのため、ほとんどのサービスに対して、 たとえ TCP "
"だけのサービスの場合であっても、対応する項目が二つあることになる。"

#. type: Plain text
#: build/C/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can be bound to "
"only by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients "
"connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr ""
"1024 より小さいポート番号 (いわゆる \"low numbered\" ポート) は 管理者 "
"(root) 権限によってのみ使用することができる (B<bind>(2), B<tcp>(7), "
"B<udp>(7)  参照)。 これは、これらのポートに接続するクライアントに対して、 そ"
"のポートで動いているサービスが標準的な実装であり、 その計算機のユーザーが動か"
"している 不正なサービスではないことを保証するためである。 IANA に明記されてい"
"るよく使用されるポート番号は、 通常このような管理者だけが使用できる範囲に配置"
"される。"

#. type: Plain text
#: build/C/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr ""
"B<services> ファイルにあるサービスに対する項目があっても、必ずしもそのサービ"
"スが現 在その計算機で動いている訳ではない。利用可能なインターネットサービスの"
"設定に ついては B<inetd.conf>(5)  に記述されている。ただし、すべてのサービス"
"が B<inetd>(8)  によって起動されるわけではないので、 B<inetd.conf>(5)  には書"
"かれていないサービスもあることに注意する必要がある。 特に、ネットニュース "
"(NNTP) や メール (SMTP) のサーバーは、システム起動時の スクリプトから起動され"
"ることが多い。"

#. type: Plain text
#: build/C/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr ""
"B<services> ファイルの場所は、 I<E<lt>netdb.hE<gt>> 中の B<_PATH_SERVICES> に"
"よって定義されている。 この値は通常 I</etc/services> に設定されている。"

#. type: Plain text
#: build/C/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr "1 行につき 1 サービスが記述されており、以下の形式である。"

#. type: Plain text
#: build/C/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"

#. type: TP
#: build/C/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr "各項目は以下の通り。"

#. type: TP
#: build/C/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr "I<service-name>"

#. type: Plain text
#: build/C/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the I<service-"
"name>."
msgstr ""
"サービスを表す分かりやすい名前であり、検索の際にも使用される。 大文字と小文字"
"は区別される。 クライアントプログラムは I<service-name> にちなんで名付けられ"
"ることが多い。"

#. type: TP
#: build/C/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr "I<port>"

#. type: Plain text
#: build/C/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr "サービスに対して使用されるポート番号。10 進数で指定する。"

#. type: Plain text
#: build/C/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the "
"B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr ""
"使用されるプロトコルの種類。この欄は、 B<protocols>(5)  ファイルの中の項目と"
"一致している必要がある。 通常使用される値は、 B<tcp> と B<udp> である。"

#. type: Plain text
#: build/C/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service.  "
"Again, the names are case sensitive."
msgstr ""
"サービスに対する別名のリスト (区切はスペースまたはタブ) で、この欄は 必要にな"
"らば書くことができる。 また、別名は大文字と小文字は区別される。"

#. type: Plain text
#: build/C/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr "それぞれの欄の区切りには、スペースまたはタブが使用される。"

#. type: Plain text
#: build/C/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr ""
"コメントはシャープ (#) で始まり、その行の終わりまでがコメントとみなされる。 "
"空行は飛ばされる。"

#. type: Plain text
#: build/C/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  For example, "
"a-z, 0-9, and hyphen (-) would seem a sensible choice."
msgstr ""
"行の始めのスペースは無視されないので、 I<service-name> は、行頭から書かなけれ"
"ばならない。 I<service-names> は、スペースとタブ以外の印字可能な文字なら何で"
"もよいが、しかしながら 互換性の問題を少なくするような文字を選択すべきであ"
"る。 例えば、a-z 、0-9 、ハイフォン (-) を使用するのが無難と思われる。"

#. type: Plain text
#: build/C/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  However, this behavior should "
"not be relied on.)"
msgstr ""
"指定された形式に合わない行はあってはならない (現在は、そのような行は "
"B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3)  によって無視され"
"る。しかし、その場合の挙動は信頼できない)。"

#. type: Plain text
#: build/C/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr "B<services> ファイルの見本を以下に示す。"

#. type: Plain text
#: build/C/man5/services.5:181
#, no-wrap
msgid ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"
msgstr ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"

#. type: Plain text
#: build/C/man5/services.5:187
msgid "The Internet network services list"
msgstr "インターネット ネットワークサービスのリスト"

#. type: TP
#: build/C/man5/services.5:187
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr "I<E<lt>netdb.hE<gt>>"

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: build/C/man5/services.5:208
msgid "Definition of B<_PATH_SERVICES>"
msgstr "B<_PATH_SERVICES> の定義"

#. type: Plain text
#: build/C/man5/services.5:218
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"

#. type: Plain text
#: build/C/man5/services.5:220
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)."
msgstr ""
"ポート番号の割り当てを定めている RFC (最新版は RFC\\ 1700、別名 STD0002)"

#. type: TH
#: build/C/man3/setnetgrent.3:10
#, no-wrap
msgid "SETNETGRENT"
msgstr "SETNETGRENT"

#. type: Plain text
#: build/C/man3/setnetgrent.3:14
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - ネットワーク"
"グループのエントリーを操作する"

#. type: Plain text
#: build/C/man3/setnetgrent.3:19
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr "B<int setnetgrent(const char *>I<netgroup>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:21
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr "B<void endnetgrent(void);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:23
#, no-wrap
msgid "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"
msgstr "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:26
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
msgstr ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:29
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:46
#, no-wrap
msgid ""
"B<setnetgrent>(),\n"
"B<endnetgrent>(),\n"
"B<getnetgrent>(),\n"
"B<getnetgrent_r>(),\n"
"B<innetgr>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<setnetgrent>(),\n"
"B<endnetgrent>(),\n"
"B<getnetgrent>(),\n"
"B<getnetgrent_r>(),\n"
"B<innetgr>():\n"
"    glibc 2.19 以降:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 以前:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: build/C/man3/setnetgrent.3:60
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup "
"databases.  The file I</etc/nsswitch.conf> defines what database is searched."
msgstr ""
"I<netgroup> は SunOS で考案されたものである。ネットグループのデータベースの "
"エントリーは、 3 つの文字列のリスト (I<hostname>, I<username>, "
"I<domainname>)  もしくはネットグループ名である。 前記のリストの各要素は空で"
"あってもよい。 空は何とでも一致することを意味する。 本ページで説明する関数を"
"使うことで、ネットグループのデータベースに アクセスすることができる。どのデー"
"タベースが検索されるかは I</etc/nsswitch.conf> ファイルで定義されている。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:80
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>, "
"I<domain>.  A null pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied "
"buffer.  To free all allocated buffers use B<endnetgrent>()."
msgstr ""
"B<setnetgrent>()  コールは、この後で呼ばれる B<getnetgrent>()  コールが検索す"
"るネットグループを定める。 B<getnetgrent>()  関数はネットグループの次のエント"
"リーを取得し、 I<host>, I<user>, I<domain> にポインターを入れて返る。ヌルポイ"
"ンターは、対応するエントリーがどんな文字列とも一致することを意味する。 得られ"
"たポインターは、ネットグループ関係の関数のいずれかが呼ばれるまでの 間だけ有効"
"である。この問題を避けるためには GNU 拡張の関数 B<getnetgrent_r>()  を使うと"
"よい。この関数は呼び出し側が用意したバッファーに 文字列を格納する。割り当て済"
"のバッファーを全て解放するには B<endnetgrent>()  を使用する。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:89
msgid ""
"In most cases you want to check only if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a null pointer is a wildcard and matches any string.  The "
"function is thread-safe."
msgstr ""
"ほとんどの場合、 (I<hostname>, I<username>, I<domainname>)  の3要素の組がネッ"
"トグループのメンバーかどうかを確認したいだけであろう。 B<innetgr>()  関数を使"
"うと、上記の3つの関数を呼び出さずにこの目的を達成できる。 もう一度書いておく"
"が、NULL ポインターはワイルドカードであり、 あらゆる文字列と一致する。この関"
"数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:91
msgid "These functions return 1 on success and 0 for failure."
msgstr "これらの関数は成功すると 1 を、失敗すると 0 を返す。"

#. type: tbl table
#: build/C/man3/setnetgrent.3:105
#, no-wrap
msgid "B<setnetgrent>(),\n"
msgstr "B<setnetgrent>(),\n"

#. type: tbl table
#: build/C/man3/setnetgrent.3:107
#, no-wrap
msgid "B<getnetgrent_r>(),\n"
msgstr "B<getnetgrent_r>(),\n"

#. type: tbl table
#: build/C/man3/setnetgrent.3:109
#, no-wrap
msgid "B<innetgr>()"
msgstr "B<innetgr>()"

#. type: tbl table
#: build/C/man3/setnetgrent.3:111 build/C/man3/setnetgrent.3:121
#, no-wrap
msgid "MT-Unsafe race:netgrent\n"
msgstr "MT-Unsafe race:netgrent\n"

#. type: tbl table
#: build/C/man3/setnetgrent.3:116
#, no-wrap
msgid "B<endnetgrent>()"
msgstr "B<endnetgrent>()"

#. type: tbl table
#: build/C/man3/setnetgrent.3:116
#, no-wrap
msgid "MT-Unsafe race:netgrent"
msgstr "MT-Unsafe race:netgrent"

#. type: tbl table
#: build/C/man3/setnetgrent.3:119
#, no-wrap
msgid "B<getnetgrent>()"
msgstr "B<getnetgrent>()"

#. type: tbl table
#: build/C/man3/setnetgrent.3:123
#, no-wrap
msgid "race:netgrentbuf locale"
msgstr "race:netgrentbuf locale"

#. type: Plain text
#: build/C/man3/setnetgrent.3:139
msgid ""
"In the above table, I<netgrent> in I<race:netgrent> signifies that if any of "
"the functions B<setnetgrent>(), B<getnetgrent_r>(), B<innetgr>(), "
"B<getnetgrent>(), or B<endnetgrent>()  are used in parallel in different "
"threads of a program, then data races could occur."
msgstr ""

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: build/C/man3/setnetgrent.3:150
msgid ""
"These functions are not in POSIX.1, but B<setnetgrent>(), B<endnetgrent>(), "
"B<getnetgrent>(), and B<innetgr>()  are available on most UNIX systems.  "
"B<getnetgrent_r>()  is not widely available on other systems."
msgstr "これらの関数は POSIX.1 にはないが、 setnetgrent (), endnetgrent (), getnetgrent (), innetgr ()  はほとんどの UNIX システムで利用可能である。 B<getnetgrent_r>()  は広く他のシステムで利用できるわけではない。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:154
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr "BSD の実装では B<setnetgrent>()  は void を返す。"

#. type: Plain text
#: build/C/man3/setnetgrent.3:158
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr "SHUTDOWN"

#. type: TH
#: build/C/man2/shutdown.2:40
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: build/C/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr "shutdown - 全二重接続の一部を閉じる"

#. type: Plain text
#: build/C/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"

#. type: Plain text
#: build/C/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""
"B<shutdown>()  は、 I<sockfd> に関連づけられているソケットによる全二重接続 "
"(full-duplex connection)  の一部または全てを閉じる。 I<how> が B<SHUT_RD> な"
"らば、それ以降の受信を禁止する。 I<how> が B<SHUT_WR> ならば、それ以降の送信"
"を禁止する。 I<how> が B<SHUT_RDWR> ならば、それ以降の送受信を禁止する。"

#. type: Plain text
#: build/C/man2/shutdown.2:79
msgid "I<sockfd> is not a valid file descriptor."
msgstr "I<sockfd> が有効なファイルディスクリプターでない。"

#. type: Plain text
#: build/C/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr "I<how> に無効な値が指定された (バグが参照)。"

#. type: Plain text
#: build/C/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr "指定されたソケットは接続されていない。"

#. type: Plain text
#: build/C/man2/shutdown.2:96
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<shutdown>()  first appeared in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<shutdown>() は 4.2BSD で初めて登場した)。"

#. type: Plain text
#: build/C/man2/shutdown.2:105
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""
"B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> の各定数 (それぞれ 0, 1, 2 の値を持つ) "
"は glibc-2.1.91 以降、 I<E<lt>sys/socket.hE<gt>> で定義されている。"

#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#.  commit fc61b928dc4d72176cf4bd4d30bf1d22e599aefc
#.  and for DECnet sockets in commit 46b66d7077b89fb4917ceef19b3f7dd86055c94a
#. type: Plain text
#: build/C/man2/shutdown.2:116
#, fuzzy
#| msgid ""
#| "As currently implemented, checks for the validity of I<how> are done in "
#| "domain-specific code, and not all domains perform these checks.  Most "
#| "notably, UNIX domain sockets simply ignore invalid values; this may "
#| "change in the future."
msgid ""
"Checks for the validity of I<how> are done in domain-specific code, and "
"before Linux 3.7 not all domains performed these checks.  Most notably, UNIX "
"domain sockets simply ignored invalid values.  This problem was fixed for "
"UNIX domain sockets in Linux 3.7."
msgstr ""
"現在の実装では I<how> の妥当性チェックはドメイン固有のコードの中で行われてい"
"るが、 すべてのドメインでこれらのチェックが行われている訳ではない。 中でも注"
"意すべきは、 UNIX ドメインソケットでは無効な値は単に無視される点である。 これ"
"は将来変更されるかもしれない。"

#. type: Plain text
#: build/C/man2/shutdown.2:121
msgid "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man7/tcp.7:96
#, no-wrap
msgid "TCP"
msgstr "TCP"

#. type: Plain text
#: build/C/man7/tcp.7:99
msgid "tcp - TCP protocol"
msgstr "tcp - TCP プロトコル"

#. type: Plain text
#: build/C/man7/tcp.7:105
msgid "B<#include E<lt>netinet/tcp.hE<gt>>"
msgstr "B<#include E<lt>netinet/tcp.hE<gt>>"

#. type: Plain text
#: build/C/man7/tcp.7:107
msgid "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"

#. type: Plain text
#: build/C/man7/tcp.7:120
msgid ""
"This is an implementation of the TCP protocol defined in RFC\\ 793, RFC\\ "
"1122 and RFC\\ 2001 with the NewReno and SACK extensions.  It provides a "
"reliable, stream-oriented, full-duplex connection between two sockets on top "
"of B<ip>(7), for both v4 and v6 versions.  TCP guarantees that the data "
"arrives in order and retransmits lost packets.  It generates and checks a "
"per-packet checksum to catch transmission errors.  TCP does not preserve "
"record boundaries."
msgstr ""
"これは RFC\\ 793, RFC\\ 1122, RFC\\ 2001 で定義されている TCP プロトコルを "
"NewReno 拡張と SACK 拡張を含めて実装したものである。 TCP は、 B<ip>(7)  上の"
"二つのソケット間に、信頼性の高い、ストリーム指向の全二重 (full-duplex) 通信を"
"提供する。 v4 と v6 の両方のバージョンの B<ip>(7)  に対応している。 TCP は、"
"データが順序を守って到着すること、途中で失われたパケットが 再送されることを保"
"証する。また、パケット単位にチェックサムを 生成、検査することで、転送エラーを"
"検知する。 TCP はレコード境界 (record boundary) を保存しない。"

#. type: Plain text
#: build/C/man7/tcp.7:139
msgid ""
"A newly created TCP socket has no remote or local address and is not fully "
"specified.  To create an outgoing TCP connection use B<connect>(2)  to "
"establish a connection to another TCP socket.  To receive new incoming "
"connections, first B<bind>(2)  the socket to a local address and port and "
"then call B<listen>(2)  to put the socket into the listening state.  After "
"that a new socket for each incoming connection can be accepted using "
"B<accept>(2).  A socket which has had B<accept>(2)  or B<connect>(2)  "
"successfully called on it is fully specified and may transmit data.  Data "
"cannot be transmitted on listening or not yet connected sockets."
msgstr ""
"新しく生成されたばかりの TCP ソケットは、 リモートアドレスかローカルアドレス"
"がなく、 したがって詳細が完全に指定された状態ではない。 外部への TCP 接続を生"
"成するには、 B<connect>(2)  を用いてもう一方の TCP ソケットへの接続を確立す"
"る。 外部からの新たな接続を受けるには、まず B<bind>(2)  でソケットをローカル"
"なアドレスとポートに結びつけ、次に B<listen>(2)  を呼んでソケットを接続待ち受"
"け状態にする。 その後、到着した接続要求に対して B<accept>(2)  を用い、ソケッ"
"トを新しく生成する。 B<accept>(2)  または B<connect>(2)  のコールが成功したソ"
"ケットは、詳細が完全に指定された状態となり、 データのやりとりが可能となる。接"
"続待ち受け状態の (listening) ソケットや、 接続 (connect) されていないソケット"
"を通してデータをやりとりすることはできない。"

#. type: Plain text
#: build/C/man7/tcp.7:159
msgid ""
"Linux supports RFC\\ 1323 TCP high performance extensions.  These include "
"Protection Against Wrapped Sequence Numbers (PAWS), Window Scaling and "
"Timestamps.  Window scaling allows the use of large (E<gt> 64\\ kB) TCP "
"windows in order to support links with high latency or bandwidth.  To make "
"use of them, the send and receive buffer sizes must be increased.  They can "
"be set globally with the I</proc/sys/net/ipv4/tcp_wmem> and I</proc/sys/net/"
"ipv4/tcp_rmem> files, or on individual sockets by using the B<SO_SNDBUF> and "
"B<SO_RCVBUF> socket options with the B<setsockopt>(2)  call."
msgstr "Linux は RFC\\ 1323 の TCP high performance 拡張をサポートしている。 これには、Protection Against Wrapped Sequence Numbers (PAWS)、 ウィンドウスケーリング、タイムスタンプなどが含まれている。 ウィンドウスケーリングを利用すると、遅延または帯域の大きな接続で、 (64\\ K 以上の) 巨大な TCP ウィンドウを用いることが可能となる。 これを用いるには、送受信のバッファーサイズを大きくしなければならない。 システム全体に対するバッファーサイズの変更は、ファイル I</proc/sys/net/ipv4/tcp_wmem> と I</proc/sys/net/ipv4/tcp_rmem> を用いて行うことができる。 また、個々のソケットのみを大きくしたい場合には、 B<SO_SNDBUF> や B<SO_RCVBUF> ソケットオプションを用いて B<setsockopt>(2)  コールを用いて設定すればよい。"

#. type: Plain text
#: build/C/man7/tcp.7:190
msgid ""
"The maximum sizes for socket buffers declared via the B<SO_SNDBUF> and "
"B<SO_RCVBUF> mechanisms are limited by the values in the I</proc/sys/net/"
"core/rmem_max> and I</proc/sys/net/core/wmem_max> files.  Note that TCP "
"actually allocates twice the size of the buffer requested in the "
"B<setsockopt>(2)  call, and so a succeeding B<getsockopt>(2)  call will not "
"return the same size of buffer as requested in the B<setsockopt>(2)  call.  "
"TCP uses the extra space for administrative purposes and internal kernel "
"structures, and the I</proc> file values reflect the larger sizes compared "
"to the actual TCP windows.  On individual connections, the socket buffer "
"size must be set prior to the B<listen>(2)  or B<connect>(2)  calls in order "
"to have it take effect.  See B<socket>(7)  for more information."
msgstr ""
"B<SO_SNDBUF> や B<SO_RCVBUF> のメカニズムで宣言されるソケットバッファーの最大"
"サイズは、ファイル I</proc/sys/net/core/rmem_max> や I</proc/sys/net/core/"
"wmem_max> で指定されたシステムとしての制限値を超えることはできない。 TCP は実"
"際には B<setsockopt>(2)  コールが要求したバッファーサイズの二倍を割り当て"
"る。 そのため、この後で B<getsockopt>(2)  コールを行うと、 B<setsockopt>(2)  "
"で要求したバッファーサイズとは異なる値が返る。 TCP はこの余分な空間を、管理目"
"的やカーネル内部の構造体に用いている。 I</proc> ファイルの値は、これらを反映"
"し、実際の TCP ウィンドウよりも大きな値となる。 各接続におけるソケットのバッ"
"ファーサイズ変更を有効にするには、 B<listen>(2)  や B<connect>(2)  コールの前"
"に設定しなければならない。 より詳しい情報は B<socket>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/tcp.7:222
msgid ""
"TCP supports urgent data.  Urgent data is used to signal the receiver that "
"some important message is part of the data stream and that it should be "
"processed as soon as possible.  To send urgent data specify the B<MSG_OOB> "
"option to B<send>(2).  When urgent data is received, the kernel sends a "
"B<SIGURG> signal to the process or process group that has been set as the "
"socket \"owner\" using the B<SIOCSPGRP> or B<FIOSETOWN> ioctls (or the "
"POSIX.1-specified B<fcntl>(2)  B<F_SETOWN> operation).  When the "
"B<SO_OOBINLINE> socket option is enabled, urgent data is put into the normal "
"data stream (a program can test for its location using the B<SIOCATMARK> "
"ioctl described below), otherwise it can be received only when the "
"B<MSG_OOB> flag is set for B<recv>(2)  or B<recvmsg>(2)."
msgstr "TCP は緊急データ (urgent data) をサポートしている。緊急データは 何らかの重要なメッセージがデータストリームに含まれていること、 そのデータをできるだけ早く処理すべきこと、を受信者に伝えるために用いられる。 緊急データを送るには、 B<send>(2)  に B<MSG_OOB> オプションを指定する。 緊急データを受信すると、カーネルは B<SIGURG> シグナルを送信する。送信先は B<SIOCSPGRP> や B<FIOSETOWN> ioctl (や POSIX.1 で規定されている B<fcntl>(2)  B<F_SETOWN> 操作) を用いてそのソケットの「所有者」として設定された プロセスかプロセスグループである。 B<SO_OOBINLINE> ソケットオプションが有効になっていると、緊急データは 通常のデータストリームの中に混ぜて送られる (プログラムは下記の B<SIOCATMARK> ioctl を使って緊急データの場所を調べることができる)。 無効になっている場合には、 B<recv>(2)  や B<recvmsg>(2)  で B<MSG_OOB> フラグがセットされているときにのみ、緊急データを受信できる。"

#. type: Plain text
#: build/C/man7/tcp.7:230
msgid ""
"When out-of-band data is present, B<select>(2)  indicates the file "
"descriptor as having an exceptional condition and I<poll (2)> indicates a "
"B<POLLPRI> event."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:238
msgid ""
"Linux 2.4 introduced a number of changes for improved throughput and "
"scaling, as well as enhanced functionality.  Some of these features include "
"support for zero-copy B<sendfile>(2), Explicit Congestion Notification, new "
"management of TIME_WAIT sockets, keep-alive socket options and support for "
"Duplicate SACK extensions."
msgstr ""
"Linux 2.4 では多くの変更がなされ、 スループットとスケーリングが向上し、機能も"
"高まった。 これらの機能には、ゼロコピー B<sendfile>(2)、 Explicit Congestion "
"Notification、 TIME_WAIT ソケットの新しい管理法、 keep-alive ソケットオプショ"
"ン、 Duplicate SACK 拡張のサポートなどがある。"

#. type: SS
#: build/C/man7/tcp.7:238
#, no-wrap
msgid "Address formats"
msgstr "アドレスのフォーマット"

#. type: Plain text
#: build/C/man7/tcp.7:247
msgid ""
"TCP is built on top of IP (see B<ip>(7)).  The address formats defined by "
"B<ip>(7)  apply to TCP.  TCP supports point-to-point communication only; "
"broadcasting and multicasting are not supported."
msgstr ""
"TCP は IP の上層に構築されている (B<ip>(7)  を参照)。 B<ip>(7)  に定義されて"
"いるアドレスフォーマットは TCP にも適用される。 TCP は point-to-point の通信"
"だけをサポートする。 ブロードキャストやマルチキャストはサポートしない。"

#. type: Plain text
#: build/C/man7/tcp.7:259
msgid ""
"System-wide TCP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>.  In addition, most IP I</proc> interfaces also apply "
"to TCP; see B<ip>(7).  Variables described as I<Boolean> take an integer "
"value, with a nonzero value (\"true\") meaning that the corresponding option "
"is enabled, and a zero value (\"false\")  meaning that the option is "
"disabled."
msgstr ""
"システム全体に対する TCP パラメーターの設定には、 I</proc/sys/net/ipv4/> ディ"
"レクトリ内のファイルによりアクセスできる。 さらに、IP に関連する I</proc> イ"
"ンターフェースのほとんどは TCP についても適用される。 B<ip>(7)  を参照のこ"
"と。 I<Boolean> は整数値で、 0 以外の値 (\"true\") は対応するオプションが有"
"効、 0 値 (\"false\") は無効、であることを意味する。"

#. type: TP
#: build/C/man7/tcp.7:259
#, no-wrap
msgid "I<tcp_abc> (Integer; default: 0; Linux 2.6.15 to Linux 3.8)"
msgstr "I<tcp_abc> (Integer; default: 0; Linux 2.6.15 から 3.8 まで)"

#.  Since 2.6.15; removed in 3.9
#.  commit ca2eb5679f8ddffff60156af42595df44a315ef0
#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:269
msgid ""
"Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a way "
"of increasing the congestion window (I<cwnd>)  more slowly in response to "
"partial acknowledgments.  Possible values are:"
msgstr ""
"RFC 3465 で定義されている Appropriate Byte Count (ABC) を制御する。 ABC は、"
"部分的な ACK に応じた輻輳ウィンドウ (I<cwnd>)  の増加をより緩やかにする方法で"
"ある。 以下の値を指定できる。"

#. type: IP
#: build/C/man7/tcp.7:270 build/C/man7/tcp.7:432 build/C/man7/tcp.7:486
#: build/C/man7/tcp.7:510 build/C/man7/tcp.7:669 build/C/man7/tcp.7:853
#: build/C/man7/tcp.7:869
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man7/tcp.7:274
msgid "increase I<cwnd> once per acknowledgment (no ABC)"
msgstr "ACK を受信する毎に I<cwnd> を増やす (ABC なし)。"

#. type: IP
#: build/C/man7/tcp.7:274 build/C/man7/tcp.7:436 build/C/man7/tcp.7:489
#: build/C/man7/tcp.7:517 build/C/man7/tcp.7:671 build/C/man7/tcp.7:855
#: build/C/man7/tcp.7:871
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man7/tcp.7:278
msgid "increase I<cwnd> once per acknowledgment of full sized segment"
msgstr "フルサイズのセグメントの ACK を受信する毎に I<cwnd> を増やす。"

#. type: IP
#: build/C/man7/tcp.7:278 build/C/man7/tcp.7:439 build/C/man7/tcp.7:491
#: build/C/man7/tcp.7:524 build/C/man7/tcp.7:673 build/C/man7/tcp.7:857
#: build/C/man7/tcp.7:874
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man7/tcp.7:283
msgid ""
"allow increase I<cwnd> by two if acknowledgment is of two segments to "
"compensate for delayed acknowledgments."
msgstr ""
"ACK が遅延 ACK (delayed acknowledgment) を相殺するための 2 セグメントに 対す"
"る ACK の場合に、 I<cwnd> を 2 増やすことができる。"

#. type: TP
#: build/C/man7/tcp.7:284
#, no-wrap
msgid "I<tcp_abort_on_overflow> (Boolean; default: disabled; since Linux 2.4)"
msgstr "I<tcp_abort_on_overflow> (ブール値; デフォルト: 無効; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:296
msgid ""
"Enable resetting connections if the listening service is too slow and unable "
"to keep up and accept them.  It means that if overflow occurred due to a "
"burst, the connection will recover.  Enable this option I<only> if you are "
"really sure that the listening daemon cannot be tuned to accept connections "
"faster.  Enabling this option can harm the clients of your server."
msgstr ""
"接続を待ち受けているサービスが遅すぎて、受信についていけない場合に、 接続をリ"
"セットできるようにする。 これを用いると、バーストによってオーバーフローが起"
"こったときに、 接続を回復できるようになる。このオプションを用いるのは、 受信"
"デーモンを高速化できない場合に「限定する」こと。 このオプションを用いると、そ"
"のサーバに接続しているクライアント にとっては害になることがある。"

#. type: TP
#: build/C/man7/tcp.7:296
#, no-wrap
msgid "I<tcp_adv_win_scale> (integer; default: 2; since Linux 2.4)"
msgstr "I<tcp_adv_win_scale> (integer; default: 2; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:308
msgid ""
"Count buffering overhead as I<bytes/2^tcp_adv_win_scale>, if "
"I<tcp_adv_win_scale> is greater than 0; or I<bytes-bytes/2^(-"
"tcp_adv_win_scale)>, if I<tcp_adv_win_scale> is less than or equal to zero."
msgstr ""
"バッファーリングのオーバーヘッドの計算方法を、 I<tcp_adv_win_scale> が正の場"
"合は I<bytes/2^tcp_adv_win_scale> に、 I<tcp_adv_win_scale> が負か 0 の場合"
"は I<bytes-bytes/2^(-tcp_adv_win_scale)> とする。"

#. type: Plain text
#: build/C/man7/tcp.7:321
msgid ""
"The socket receive buffer space is shared between the application and "
"kernel.  TCP maintains part of the buffer as the TCP window, this is the "
"size of the receive window advertised to the other end.  The rest of the "
"space is used as the \"application\" buffer, used to isolate the network "
"from scheduling and application latencies.  The I<tcp_adv_win_scale> default "
"value of 2 implies that the space used for the application buffer is one "
"fourth that of the total."
msgstr ""
"ソケットの受信バッファー空間はアプリケーションとカーネルで共有される。 TCP は"
"バッファーの一部を TCP ウィンドウとして管理し、 これを受信ウィンドウとして接"
"続の他端に通知する。 空間の残りは「アプリケーション」バッファーとして用いら"
"れ、 スケジューリングやアプリケーションの遅延からネットワークを隔離する。 "
"I<tcp_adv_win_scale> のデフォルト値は 2 であり、 この場合アプリケーションバッ"
"ファーは全体の 1/4 になる。"

#. type: TP
#: build/C/man7/tcp.7:321
#, no-wrap
msgid "I<tcp_allowed_congestion_control> (String; default: see text; since Linux 2.4.20)"
msgstr "I<tcp_allowed_congestion_control> (String; default: see text; Linux 2.4.20 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:334
msgid ""
"Show/set the congestion control algorithm choices available to unprivileged "
"processes (see the description of the B<TCP_CONGESTION> socket option).  The "
"items in the list are separated by white space and terminated by a newline "
"character.  The list is a subset of those listed in "
"I<tcp_available_congestion_control>.  The default value for this list is "
"\"reno\" plus the default setting of I<tcp_congestion_control>."
msgstr ""
"非特権プロセスで利用できる輻輳制御アルゴリズムの選択肢を表示/設定する "
"(B<TCP_CONGESTION> ソケットオプションの説明を参照のこと)。 このリストの要素は"
"ホワイトスペースで区切られ、改行文字で終端される。 このリストは "
"I<tcp_available_congestion_control> で表示されるリストの部分集合となる。 この"
"リストのデフォルト値は、\"reno\" と I<tcp_congestion_control> のデフォルト設"
"定をあわせたものとなる。"

#. type: TP
#: build/C/man7/tcp.7:334
#, no-wrap
msgid "I<tcp_autocorking> (Boolean; default: enabled; since Linux 3.14)"
msgstr "I<tcp_autocorking> (ブール値; デフォルト: 有効; Linux 3.14 以降)"

#.  commit f54b311142a92ea2e42598e347b84e1655caf8e3
#.  Text heavily based on Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:351
msgid ""
"If this option is enabled, the kernel tries to coalesce small writes (from "
"consecutive B<write>(2)  and B<sendmsg>(2)  calls) as much as possible, in "
"order to decrease the total number of sent packets.  Coalescing is done if "
"at least one prior packet for the flow is waiting in Qdisc queues or device "
"transmit queue.  Applications can still use the B<TCP_CORK> socket option to "
"obtain optimal behavior when they know how/when to uncork their sockets."
msgstr ""
"このオプションを有効にすると、 送信総パケット数を減らすため、 カーネルは小さ"
"な write (連続する B<write>(2) や B<sendmsg>(2) の呼び出し) を可能な限り結合"
"しようとする。 パケットの結合が行われるのは、そのフローの前のパケットが少なく"
"とも一つは qdisc キューかデバイスの送信キューで送信待ちの場合である。 このオ"
"プションが有効な場合でも B<TCP_CORK> オプションを使うことができ、アプリケー"
"ションがソケットの「コルク解除」(送信待ち状態の解除) をいつどのように行えばよ"
"いか分かっている場合には、最適な動作をさせることができる。"

#. type: TP
#: build/C/man7/tcp.7:351
#, no-wrap
msgid "I<tcp_available_congestion_control> (String; read-only; since Linux 2.4.20)"
msgstr "I<tcp_available_congestion_control> (String; read-only; Linux 2.4.20 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:362
msgid ""
"Show a list of the congestion-control algorithms that are registered.  The "
"items in the list are separated by white space and terminated by a newline "
"character.  This list is a limiting set for the list in "
"I<tcp_allowed_congestion_control>.  More congestion-control algorithms may "
"be available as modules, but not loaded."
msgstr ""
"登録されている輻輳制御アルゴリズムのリストを表示する。 このリストの要素はホワ"
"イトスペースで区切られ、改行文字で終端される。 このリストに載っているものだけ"
"が、 I<tcp_allowed_congestion_control> に表示される。 他の輻輳制御アルゴリズ"
"ムがモジュールとして利用可能だが、 モジュールがロードされていないこともある。"

#. type: TP
#: build/C/man7/tcp.7:362
#, no-wrap
msgid "I<tcp_app_win> (integer; default: 31; since Linux 2.4)"
msgstr "I<tcp_app_win> (integer; default: 31; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:367
msgid ""
"This variable defines how many bytes of the TCP window are reserved for "
"buffering overhead."
msgstr ""
"この変数は、TCP ウィンドウの何バイト分を バッファーリングのオーバーヘッド用に"
"予約するかを指定する。"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:373
msgid ""
"A maximum of (I<window/2^tcp_app_win>, mss) bytes in the window are reserved "
"for the application buffer.  A value of 0 implies that no amount is reserved."
msgstr ""
"そのウィンドウの I<window/2^tcp_app_win> と mss の大きいほう (バイト単位)  が"
"アプリケーションバッファーとして予約される。 0 を指定すると一切予約領域を取ら"
"ない。"

#. type: TP
#: build/C/man7/tcp.7:373
#, no-wrap
msgid "I<tcp_base_mss> (Integer; default: 512; since Linux 2.6.17)"
msgstr "I<tcp_base_mss> (Integer; default: 512; Linux 2.6.17 以降)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:382
msgid ""
"The initial value of I<search_low> to be used by the packetization layer "
"Path MTU discovery (MTU probing).  If MTU probing is enabled, this is the "
"initial MSS used by the connection."
msgstr ""
"パケット化レイヤの Path MTU discovery (MTU probing) で、 I<search_low> の初期"
"値と使用される値。 MTU probing が有効な場合、この値はその接続の MSS の初期値"
"となる。"

#. type: TP
#: build/C/man7/tcp.7:382
#, no-wrap
msgid "I<tcp_bic> (Boolean; default: disabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic> (ブール値; デフォルト: 無効; Linux 2.4.27/2.6.6 から 2.6.13 まで)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:396
msgid ""
"Enable BIC TCP congestion control algorithm.  BIC-TCP is a sender-side-only "
"change that ensures a linear RTT fairness under large windows while offering "
"both scalability and bounded TCP-friendliness.  The protocol combines two "
"schemes called additive increase and binary search increase.  When the "
"congestion window is large, additive increase with a large increment ensures "
"linear RTT fairness as well as good scalability.  Under small congestion "
"windows, binary search increase provides TCP friendliness."
msgstr ""
"BIC TCP 輻輳制御アルゴリズムを有効にする。 BIC-TCP は送信側のみの変更で、 ス"
"ケーラビリティと TCP 親和性 (friendliness) の両方を提供しつつ、 大きなウィン"
"ドウの下での線形な RTT 公平性を保証するものである。 このプロトコルでは "
"additive increase (追加的な増加) と binary search increase (二分探索増加) と"
"いわれる二つの仕組みを 組み合わせている。輻輳ウィンドウが大きいときは、増分の"
"大きい additive increase により、スケーラビリティを確保しながら 線形な RTT 公"
"平性を保証する。 輻輳ウィンドウが小さいときには binary search increase によ"
"り TCP 親和性を達成している。"

#. type: TP
#: build/C/man7/tcp.7:396
#, no-wrap
msgid "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 以降 2.6.13 まで)"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:403
msgid ""
"Set the threshold window (in packets) where BIC TCP starts to adjust the "
"congestion window.  Below this threshold BIC TCP behaves the same as the "
"default TCP Reno."
msgstr ""
"BIC TCP が輻輳ウィンドウの調整を開始する閾値ウィンドウ (パケット単位)  を設定"
"する。この閾値を下回る場合、BIC TCP はデフォルトの TCP Reno と 同じ動作をす"
"る。"

#. type: TP
#: build/C/man7/tcp.7:403
#, no-wrap
msgid "I<tcp_bic_fast_convergence> (Boolean; default: enabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr "I<tcp_bic_fast_convergence> (ブール値; デフォルト: 有効; Linux 2.4.27/2.6.6 以降 2.6.13 まで)"

#. type: Plain text
#: build/C/man7/tcp.7:407
msgid ""
"Force BIC TCP to more quickly respond to changes in congestion window.  "
"Allows two flows sharing the same connection to converge more rapidly."
msgstr ""
"BIC TCP が輻輳ウィンドウの変化により速く反応するようにする。 同じコネクション"
"を共有する二つのフローが一つにまとまるのを より速く行うようにする。"

#. type: TP
#: build/C/man7/tcp.7:407
#, no-wrap
msgid "I<tcp_congestion_control> (String; default: see text; since Linux 2.4.13)"
msgstr "I<tcp_congestion_control> (String; default: 説明参照; Linux 2.4.13 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:414
msgid ""
"Set the default congestion-control algorithm to be used for new "
"connections.  The algorithm \"reno\" is always available, but additional "
"choices may be available depending on kernel configuration.  The default "
"value for this file is set as part of kernel configuration."
msgstr ""
"新規の接続で使用されるデフォルトの輻輳制御アルゴリズムを設定する。 \"reno\" "
"アルゴリズムは常に利用可能だが、 カーネル設定次第では別の選択肢が利用できるこ"
"ともある。 このファイルのデフォルト値はカーネル設定の一つとして設定される。"

#. type: TP
#: build/C/man7/tcp.7:414
#, no-wrap
msgid "I<tcp_dma_copybreak> (integer; default: 4096; since Linux 2.6.24)"
msgstr "I<tcp_dma_copybreak> (integer; default: 4096; Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:421
msgid ""
"Lower limit, in bytes, of the size of socket reads that will be offloaded to "
"a DMA copy engine, if one is present in the system and the kernel was "
"configured with the B<CONFIG_NET_DMA> option."
msgstr ""
"システムに DMA コピーエンジンが存在し、カーネルで B<CONFIG_NET_DMA> オプショ"
"ンが有効になっている場合に、 DMA コピーエンジンにオフロードされるソケットの読"
"み込みサイズの下限値 (バイト単位)。"

#. type: TP
#: build/C/man7/tcp.7:421
#, no-wrap
msgid "I<tcp_dsack> (Boolean; default: enabled; since Linux 2.4)"
msgstr "I<tcp_dsack> (ブール値; デフォルト: 有効; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:425
msgid "Enable RFC\\ 2883 TCP Duplicate SACK support."
msgstr "RFC\\ 2883 の TCP Duplicate SACK のサポートを有効にする。"

#. type: TP
#: build/C/man7/tcp.7:425
#, no-wrap
msgid "I<tcp_ecn> (Integer; default: see below; since Linux 2.4)"
msgstr "I<tcp_ecn> (integer; default: see below; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:429
msgid "Enable RFC\\ 3168 Explicit Congestion Notification."
msgstr "RFC\\ 3168 Explicit Congestion Notification を有効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:431 build/C/man7/tcp.7:485
msgid "This file can have one of the following values:"
msgstr "このファイルは以下のいずれかの値を取ることができる。"

#. type: Plain text
#: build/C/man7/tcp.7:436
msgid ""
"Disable ECN.  Neither initiate nor accept ECN.  This was the default up to "
"and including Linux 2.6.30."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:439
msgid ""
"Enable ECN when requested by incoming connections and also request ECN on "
"outgoing connection attempts."
msgstr ""

#.  commit 255cac91c3c9ce7dca7713b93ab03c75b7902e0e
#. type: Plain text
#: build/C/man7/tcp.7:444
msgid ""
"Enable ECN when requested by incoming connections, but do not request ECN on "
"outgoing connections.  This value is supported, and is the default, since "
"Linux 2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:453
msgid ""
"When enabled, connectivity to some destinations could be affected due to "
"older, misbehaving middle boxes along the path, causing connections to be "
"dropped.  However, to facilitate and encourage deployment with option 1, and "
"to work around such buggy equipment, the B<tcp_ecn_fallback> option has been "
"introduced."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:453
#, no-wrap
msgid "I<tcp_ecn_fallback> (Boolean; default: enabled; since Linux 4.1)"
msgstr "I<tcp_ecn_fallback> (ブール値; デフォルト: 有効; Linux 4.1 以降)"

#.  commit 492135557dc090a1abb2cfbe1a412757e3ed68ab
#. type: Plain text
#: build/C/man7/tcp.7:460
msgid ""
"Enable RFC\\ 3168, Section 6.1.1.1. fallback.  When enabled, outgoing ECN-"
"setup SYNs that time out within the normal SYN retransmission timeout will "
"be resent with CWR and ECE cleared."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:460
#, no-wrap
msgid "I<tcp_fack> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_fack> (ブール値; デフォルト: 有効; Linux 2.2 以降)"

#.  Since 2.1.92
#. type: Plain text
#: build/C/man7/tcp.7:464
msgid "Enable TCP Forward Acknowledgement support."
msgstr "TCP Forward Acknowledgement のサポートを有効にする。"

#. type: TP
#: build/C/man7/tcp.7:464
#, no-wrap
msgid "I<tcp_fin_timeout> (integer; default: 60; since Linux 2.2)"
msgstr "I<tcp_fin_timeout> (integer; default: 60; Linux 2.2 以降)"

#.  Since 2.1.53
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:474
msgid ""
"This specifies how many seconds to wait for a final FIN packet before the "
"socket is forcibly closed.  This is strictly a violation of the TCP "
"specification, but required to prevent denial-of-service attacks.  In Linux "
"2.2, the default value was 180."
msgstr ""
"ソケットを強制的にクローズする前に、 最後の FIN パケットを待つ時間を秒単位で"
"指定する。 これは厳密には TCP の仕様を満たしていないが、 DoS 攻撃 (denial of "
"service attack) から身を守るために必要である。 Linux 2.2 ではデフォルト値は "
"180 であった。"

#. type: TP
#: build/C/man7/tcp.7:474
#, no-wrap
msgid "I<tcp_frto> (integer; default: see below; since Linux 2.4.21/2.6)"
msgstr "I<tcp_frto> (integer; default: 下記参照; Linux 2.4.21/2.6 以降)"

#.  Since 2.4.21/2.5.43
#. type: Plain text
#: build/C/man7/tcp.7:483
msgid ""
"Enable F-RTO, an enhanced recovery algorithm for TCP retransmission timeouts "
"(RTOs).  It is particularly beneficial in wireless environments where packet "
"loss is typically due to random radio interference rather than intermediate "
"router congestion.  See RFC 4138 for more details."
msgstr ""
"F-RTO を有効にする。F-RTO は TCP 再送タイムアウト (RTO) からの 復旧性能を向上"
"させたアルゴリズムである。 この機能は無線環境で特に効果を発揮する。 無線環境"
"では、通常は、中間ルーターの輻輳ではなくランダムな無線の干渉 によりパケットロ"
"スが発生する。 詳細は RFC\\ 4138 を参照。"

#. type: Plain text
#: build/C/man7/tcp.7:489
msgid "Disabled.  This was the default up to and including Linux 2.6.23."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:491
msgid "The basic version F-RTO algorithm is enabled."
msgstr "基本版の F-RTO アルゴリズムを有効にする。"

#.  commit c96fd3d461fa495400df24be3b3b66f0e0b152f9
#. type: Plain text
#: build/C/man7/tcp.7:498
#, fuzzy
#| msgid ""
#| "Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be "
#| "used also when SACK is in use though in that case scenario(s) exists "
#| "where F-RTO interacts badly with the packet counting of the SACK-enabled "
#| "TCP flow."
msgid ""
"Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used "
"also when SACK is in use though in that case scenario(s) exists where F-RTO "
"interacts badly with the packet counting of the SACK-enabled TCP flow.  This "
"value is the default since Linux 2.6.24."
msgstr ""
"そのフローで SACK を使用する場合、SACK 拡張版の F-RTO を有効にする。 基本版"
"の F-RTO も SACK が使用されている場合にも使用できるが、 基本版の場合には F-"
"RTO が SACK が有効になった TCP フローでの パケット数計測と、相性が悪く相互干"
"渉が起こる場面が存在する。"

#. type: Plain text
#: build/C/man7/tcp.7:502
msgid ""
"Before Linux 2.6.22, this parameter was a Boolean value, supporting just "
"values 0 and 1 above."
msgstr ""
"Linu 2.6.22 より前では、このパラメーターはブール値であり、 上記の 0 と 1 のみ"
"をサポートしていた。"

#. type: TP
#: build/C/man7/tcp.7:502
#, no-wrap
msgid "I<tcp_frto_response> (integer; default: 0; since Linux 2.6.22)"
msgstr "I<tcp_frto_response> (integer; default: 0; Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:509
msgid ""
"When F-RTO has detected that a TCP retransmission timeout was spurious (i."
"e., the timeout would have been avoided had TCP set a longer retransmission "
"timeout), TCP has several options concerning what to do next.  Possible "
"values are:"
msgstr ""
"F-RTO が TCP 再送タイムアウトが偽物だと検出した場合 (つまり、TCP がもっと長い"
"再送タイムアウトを設定していれば タイムアウトが避けられた場合)、 次にどうする"
"かに関して選択肢がいくつかある。 以下の値を選択できる。"

#. type: Plain text
#: build/C/man7/tcp.7:517
msgid ""
"Rate halving based; a smooth and conservative response, results in halved "
"congestion window (I<cwnd>)  and slow-start threshold (I<ssthresh>)  after "
"one RTT."
msgstr ""
"レートを元の半分にする。 滑らかで、保守的な反応を行い、RTT 1回分の時間後に 輻"
"輳ウィンドウ (I<cwnd>)  とスロースタートの閾値 (I<ssthresh>)  が半分になる。"

#. type: Plain text
#: build/C/man7/tcp.7:524
msgid ""
"Very conservative response; not recommended because even though being valid, "
"it interacts poorly with the rest of Linux TCP; halves I<cwnd> and "
"I<ssthresh> immediately."
msgstr ""
"非常に保守的な反応。このオプションの使用は推奨されない。 反応が正しかった場合"
"であっても、Linux TCP の他の部分と うまく連携できないからである。 I<cwnd> と "
"I<ssthresh> は直ちに半分にされる。"

#. type: Plain text
#: build/C/man7/tcp.7:533
msgid ""
"Aggressive response; undoes congestion-control measures that are now known "
"to be unnecessary (ignoring the possibility of a lost retransmission that "
"would require TCP to be more cautious); I<cwnd> and I<ssthresh> are restored "
"to the values prior to timeout."
msgstr ""
"積極的な反応。 不要と判明した輻輳制御の測定情報を取り消す (TCP がもっと注意深"
"く扱うべき再送が失われる可能性を無視する)。 。 I<cwnd> と I<ssthresh> はタイ"
"ムアウト前の値に戻される。"

#. type: TP
#: build/C/man7/tcp.7:534
#, no-wrap
msgid "I<tcp_keepalive_intvl> (integer; default: 75; since Linux 2.4)"
msgstr "I<tcp_keepalive_intvl> (integer; default: 75; Linux 2.4 以降)"

#.  Since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:538
msgid "The number of seconds between TCP keep-alive probes."
msgstr "TCP keep-alive のプローブを送る間隔 (秒単位)。"

#. type: TP
#: build/C/man7/tcp.7:538
#, no-wrap
msgid "I<tcp_keepalive_probes> (integer; default: 9; since Linux 2.2)"
msgstr "I<tcp_keepalive_probes> (integer; default: 9; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:544
msgid ""
"The maximum number of TCP keep-alive probes to send before giving up and "
"killing the connection if no response is obtained from the other end."
msgstr ""
"TCP keep-alive プローブの最大回数。 この回数だけ試しても接続先から反応が得ら"
"れない場合は、 あきらめて接続を切断する。"

#. type: TP
#: build/C/man7/tcp.7:544
#, no-wrap
msgid "I<tcp_keepalive_time> (integer; default: 7200; since Linux 2.2)"
msgstr "I<tcp_keepalive_time> (integer; default: 7200; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:556
msgid ""
"The number of seconds a connection needs to be idle before TCP begins "
"sending out keep-alive probes.  Keep-alives are sent only when the "
"B<SO_KEEPALIVE> socket option is enabled.  The default value is 7200 seconds "
"(2 hours).  An idle connection is terminated after approximately an "
"additional 11 minutes (9 probes an interval of 75 seconds apart) when keep-"
"alive is enabled."
msgstr ""
"接続がアイドル状態になってから、keep-alive プローブを送信するまでの時間を秒単"
"位で指定する。 B<SO_KEEPALIVE> ソケットオプションが有効になっている場合のみ "
"keep-alive は送信される。 デフォルト値は 7200 秒 (2 時間)。 keep-alive が有効"
"になっている場合、 さらにおよそ 11 分 (75 秒間隔の 9 プローブ分)  経過すると"
"アイドル状態の接続は終了させられる。"

#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:561
msgid ""
"Note that underlying connection tracking mechanisms and application timeouts "
"may be much shorter."
msgstr ""
"下層にある接続追跡機構やアプリケーションでのタイムアウトは、 もっとずっと短い"
"かもしれない。"

#. type: TP
#: build/C/man7/tcp.7:561
#, fuzzy, no-wrap
#| msgid "I<tcp_low_latency> (Boolean; default: disabled; since Linux 2.4.21/2.6)"
msgid "I<tcp_low_latency> (Boolean; default: disabled; since Linux 2.4.21/2.6; obsolete since Linux 4.14)"
msgstr "I<tcp_low_latency> (ブール値; デフォルト: 無効; Linux 2.4.21/2.6 以降)"

#.  Since 2.4.21/2.5.60
#.  commit b6690b14386698ce2c19309abad3f17656bdfaea
#. type: Plain text
#: build/C/man7/tcp.7:573
#, fuzzy
#| msgid ""
#| "If enabled, the TCP stack makes decisions that prefer lower latency as "
#| "opposed to higher throughput.  It this option is disabled, then higher "
#| "throughput is preferred.  An example of an application where this default "
#| "should be changed would be a Beowulf compute cluster."
msgid ""
"If enabled, the TCP stack makes decisions that prefer lower latency as "
"opposed to higher throughput.  It this option is disabled, then higher "
"throughput is preferred.  An example of an application where this default "
"should be changed would be a Beowulf compute cluster.  Since Linux 4.14, "
"this file still exists, but its value is ignored."
msgstr ""
"有効にすると、TCP スタックはスループットを高くするよりも 遅延を少なくすること"
"を優先して判断を行う。 このオプションを無効にすると、スループットを高くするこ"
"とが優先される。 このデフォルト値を変更した方がよいアプリケーションの例として"
"は Beowulf コンピュータクラスタが挙げられるだろう。"

#. type: TP
#: build/C/man7/tcp.7:573
#, no-wrap
msgid "I<tcp_max_orphans> (integer; default: see below; since Linux 2.4)"
msgstr "I<tcp_max_orphans> (integer; default: see below; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:587
msgid ""
"The maximum number of orphaned (not attached to any user file handle) TCP "
"sockets allowed in the system.  When this number is exceeded, the orphaned "
"connection is reset and a warning is printed.  This limit exists only to "
"prevent simple denial-of-service attacks.  Lowering this limit is not "
"recommended.  Network conditions might require you to increase the number of "
"orphans allowed, but note that each orphan can eat up to \\(ti64\\ kB of "
"unswappable memory.  The default initial value is set equal to the kernel "
"parameter NR_FILE.  This initial default is adjusted depending on the memory "
"in the system."
msgstr "システムが許容する、 orphan な (どのユーザーファイルハンドルにもアタッチされていない)  TCP ソケットの最大数。 この数を越えると、orphan な接続はリセットされ、警告が表示される。 この制限が存在するのは、単純な使用不能 (denial-of-service) 攻撃を 防ぐために過ぎない。この値を小さくすることは推奨しない。 ネットワークの条件によっては、この数値を大きくしないといけないかもしれないが、 orphan なソケットひとつあたり 64\\ K 程度のスワップ不可能なメモリーを消費することも注意せよ。 デフォルトの初期値はカーネルパラメーターの NR_FILE と等しい。 この初期デフォルト値はシステムのメモリーに応じて調整される。"

#. type: TP
#: build/C/man7/tcp.7:587
#, no-wrap
msgid "I<tcp_max_syn_backlog> (integer; default: see below; since Linux 2.2)"
msgstr "I<tcp_max_syn_backlog> (integer; default: 下記参照; Linux 2.2 以降)"

#.  Since 2.1.53
#. type: Plain text
#: build/C/man7/tcp.7:598
#, fuzzy
#| msgid ""
#| "The maximum number of queued connection requests which have still not "
#| "received an acknowledgement from the connecting client.  If this number "
#| "is exceeded, the kernel will begin dropping requests.  The default value "
#| "of 256 is increased to 1024 when the memory present in the system is "
#| "adequate or greater (E<gt>= 128Mb), and reduced to 128 for those systems "
#| "with very low memory (E<lt>= 32Mb).  It is recommended that if this needs "
#| "to be increased above 1024, TCP_SYNQ_HSIZE in I<include/net/tcp.h> be "
#| "modified to keep TCP_SYNQ_HSIZE*16E<lt>=tcp_max_syn_backlog, and the "
#| "kernel be recompiled."
msgid ""
"The maximum number of queued connection requests which have still not "
"received an acknowledgement from the connecting client.  If this number is "
"exceeded, the kernel will begin dropping requests.  The default value of 256 "
"is increased to 1024 when the memory present in the system is adequate or "
"greater (E<gt>= 128\\ MB), and reduced to 128 for those systems with very "
"low memory (E<lt>= 32\\ MB)."
msgstr ""
"接続してきているクライアントから ack を受信していない状態の接続リクエストを"
"キューに置ける最大数。 この数値を越えると、カーネルはリクエストを捨て始め"
"る。 デフォルトの値は 256 で、 システムに充分なメモリーがある (128Mb 以上) 場"
"合は 1024 になり、 メモリーが非常に少ない場合 (32 Mb 以下) は 128 になる。 こ"
"の数値を 1024 以上に増やしたい場合は、 I<include/net/tcp.h> の "
"TCP_SYNQ_HSIZE を TCP_SYNQ_HSIZE*16E<lt>=tcp_max_syn_backlog のように修正"
"し、 カーネルを再コンパイルすることを奨める。"

#.  commit 72a3effaf633bcae9034b7e176bdbd78d64a71db
#. type: Plain text
#: build/C/man7/tcp.7:607
msgid ""
"Prior to Linux 2.6.20, it was recommended that if this needed to be "
"increased above 1024, the size of the SYNACK hash table (B<TCP_SYNQ_HSIZE>)  "
"in I<include/net/tcp.h> should be modified to keep"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:609
#, no-wrap
msgid "    TCP_SYNQ_HSIZE * 16 E<lt>= tcp_max_syn_backlog\n"
msgstr "    TCP_SYNQ_HSIZE * 16 E<lt>= tcp_max_syn_backlog\n"

#. type: Plain text
#: build/C/man7/tcp.7:615
msgid ""
"and the kernel should be recompiled.  In Linux 2.6.20, the fixed sized "
"B<TCP_SYNQ_HSIZE> was removed in favor of dynamic sizing."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:615
#, no-wrap
msgid "I<tcp_max_tw_buckets> (integer; default: see below; since Linux 2.4)"
msgstr "I<tcp_max_tw_buckets> (integer; default: 下記参照; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:625
msgid ""
"The maximum number of sockets in TIME_WAIT state allowed in the system.  "
"This limit exists only to prevent simple denial-of-service attacks.  The "
"default value of NR_FILE*2 is adjusted depending on the memory in the "
"system.  If this number is exceeded, the socket is closed and a warning is "
"printed."
msgstr ""
"システムが許容する TIME_WAIT 状態にあるソケットの最大数。 この制限が存在する"
"のは、 単純な使用不能 (denial-of-service) 攻撃を防ぐために過ぎない。 デフォル"
"ト値は NR_FILE*2 で、システムのメモリーに応じて調整される。 この数値を越える"
"と、そのようなソケットはクローズされ、警告が表示される。"

#. type: TP
#: build/C/man7/tcp.7:625
#, no-wrap
msgid "I<tcp_moderate_rcvbuf> (Boolean; default: enabled; since Linux 2.4.17/2.6.7)"
msgstr "I<tcp_moderate_rcvbuf> (ブール値; デフォルト: 有効; Linux 2.4.17/2.6.7 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:632
msgid ""
"If enabled, TCP performs receive buffer auto-tuning, attempting to "
"automatically size the buffer (no greater than I<tcp_rmem[2]>)  to match the "
"size required by the path for full throughput."
msgstr ""
"有効にすると、TCP は受信バッファーの自動調整を行う。 具体的には、 "
"(I<tcp_rmem[2]> を超えない範囲で) バッファーの大きさを自動的に変化させ、 その"
"経路で最大のスループットを達成するのに必要な大きさに合わせようとする。"

#. type: TP
#: build/C/man7/tcp.7:632
#, no-wrap
msgid "I<tcp_mem> (since Linux 2.4)"
msgstr "I<tcp_mem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:644
msgid ""
"This is a vector of 3 integers: [low, pressure, high].  These bounds, "
"measured in units of the system page size, are used by TCP to track its "
"memory usage.  The defaults are calculated at boot time from the amount of "
"available memory.  (TCP can only use I<low memory> for this, which is "
"limited to around 900 megabytes on 32-bit systems.  64-bit systems do not "
"suffer this limitation.)"
msgstr ""
"これは 3 つの整数 [low, pressure, high] からなるベクトル値である。 これらは "
"TCP がメモリー使用量を追跡するために用いられる (使用量はシステムのページサイ"
"ズ単位で計測される)。 デフォルトはブート時に利用できるメモリーの量から計算さ"
"れる。 (実際には、TCP は I<low memory> のみを使用する。値は 32ビットシステム"
"では約 900 メガバイトに制限される。 64 ビットシステムではこの制限はない。)"

#. type: TP
#: build/C/man7/tcp.7:645
#, no-wrap
msgid "I<low>"
msgstr "I<low>"

#. type: Plain text
#: build/C/man7/tcp.7:649
msgid ""
"TCP doesn't regulate its memory allocation when the number of pages it has "
"allocated globally is below this number."
msgstr ""
"TCP は、グローバルにアロケートしたページがこの数値以下の場合は、 メモリーアロ"
"ケーションを調整しない。"

#. type: TP
#: build/C/man7/tcp.7:649 build/C/man7/udp.7:151
#, no-wrap
msgid "I<pressure>"
msgstr "I<pressure>"

#. type: Plain text
#: build/C/man7/tcp.7:658
msgid ""
"When the amount of memory allocated by TCP exceeds this number of pages, TCP "
"moderates its memory consumption.  This memory pressure state is exited once "
"the number of pages allocated falls below the I<low> mark."
msgstr ""
"TCP がアロケートしたメモリーがこの数値分のページ数を越えると、 TCP はメモリー"
"消費を抑えるようになる。 アロケートしたページ数が I<low> 以下になると、このメ"
"モリー圧迫状態から脱する。"

#. type: TP
#: build/C/man7/tcp.7:658
#, no-wrap
msgid "I<high>"
msgstr "I<high>"

#. type: Plain text
#: build/C/man7/tcp.7:662
msgid ""
"The maximum number of pages, globally, that TCP will allocate.  This value "
"overrides any other limits imposed by the kernel."
msgstr ""
"TCP がグローバルに割り当てるページ数の最大値。 この値はカーネルによって課され"
"るあらゆる制限よりも優先される。"

#. type: TP
#: build/C/man7/tcp.7:663
#, no-wrap
msgid "I<tcp_mtu_probing> (integer; default: 0; since Linux 2.6.17)"
msgstr "I<tcp_mtu_probing> (integer; default: 0; Linux 2.6.17 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:668
msgid ""
"This parameter controls TCP Packetization-Layer Path MTU Discovery.  The "
"following values may be assigned to the file:"
msgstr ""
"このパラメーターは、TCP のパケット化レイヤの Path MTU discovery を制御する。 "
"このファイルには以下の値を設定できる。"

#. type: Plain text
#: build/C/man7/tcp.7:671
msgid "Disabled"
msgstr "無効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:673
msgid "Disabled by default, enabled when an ICMP black hole detected"
msgstr ""
"デフォルトでは無効だが、ICMP ブラックホールが検出された場合は有効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:676
msgid "Always enabled, use initial MSS of I<tcp_base_mss>."
msgstr "常に有効にする。 MSS の初期値として I<tcp_base_mss> が使用される。"

#. type: TP
#: build/C/man7/tcp.7:677
#, no-wrap
msgid "I<tcp_no_metrics_save> (Boolean; default: disabled; since Linux 2.6.6)"
msgstr "I<tcp_no_metrics_save> (ブール値; デフォルト: 無効; Linux 2.6.6 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:688
msgid ""
"By default, TCP saves various connection metrics in the route cache when the "
"connection closes, so that connections established in the near future can "
"use these to set initial conditions.  Usually, this increases overall "
"performance, but it may sometimes cause performance degradation.  If "
"I<tcp_no_metrics_save> is enabled, TCP will not cache metrics on closing "
"connections."
msgstr ""
"デフォルトでは、TCP は接続クローズ時に各種の接続パラメーターを ルートキャッ"
"シュ (route cache) に保存し、近い将来に接続が確立された際に これらの情報を初"
"期状態として使用できるようになっている。 通常は、これにより全体として性能が向"
"上するが、 時として性能の劣化を引き起こすこともある。 I<tcp_no_metrics_save> "
"を有効にすると、TCP は接続クローズ時に接続パラメーターをキャッシュ しなくな"
"る。"

#. type: TP
#: build/C/man7/tcp.7:688
#, no-wrap
msgid "I<tcp_orphan_retries> (integer; default: 8; since Linux 2.4)"
msgstr "I<tcp_orphan_retries> (integer; default: 8; Linux 2.4 以降)"

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:693
msgid ""
"The maximum number of attempts made to probe the other end of a connection "
"which has been closed by our end."
msgstr "こちらからクローズした接続について、 先方をプローブする最大試行数。"

#. type: TP
#: build/C/man7/tcp.7:693
#, no-wrap
msgid "I<tcp_reordering> (integer; default: 3; since Linux 2.4)"
msgstr "I<tcp_reordering> (integer; default: 3; Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:702
msgid ""
"The maximum a packet can be reordered in a TCP packet stream without TCP "
"assuming packet loss and going into slow start.  It is not advisable to "
"change this number.  This is a packet reordering detection metric designed "
"to minimize unnecessary back off and retransmits provoked by reordering of "
"packets on a connection."
msgstr ""
"TCP パケットストリームでパケット順序の逆転が発生しただけであり、 パケットロス"
"が起こったとはみなさない、パケット数の最大値。 この値を超えてパケットの順序逆"
"転が起こると、パケットロスが生じたと みなし、slow start に入る。 この数値は変"
"更しないほうが良い。 これは、接続中のパケットの並び替えによって生じる 不必要"
"な速度低下や再送を最小化するように設計された、 パケット並び替え (packet "
"reordering) の検知メトリックなのである。"

#. type: TP
#: build/C/man7/tcp.7:702
#, no-wrap
msgid "I<tcp_retrans_collapse> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_retrans_collapse> (ブール値; デフォルト: 有効; Linux 2.2 以降)"

#.  Since 2.1.96
#. type: Plain text
#: build/C/man7/tcp.7:706
msgid "Try to send full-sized packets during retransmit."
msgstr "再送の際にフルサイズのパケットを送ろうとする。"

#. type: TP
#: build/C/man7/tcp.7:706
#, no-wrap
msgid "I<tcp_retries1> (integer; default: 3; since Linux 2.2)"
msgstr "I<tcp_retries1> (integer; default: 3; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:716
msgid ""
"The number of times TCP will attempt to retransmit a packet on an "
"established connection normally, without the extra effort of getting the "
"network layers involved.  Once we exceed this number of retransmits, we "
"first have the network layer update the route if possible before each new "
"retransmit.  The default is the RFC specified minimum of 3."
msgstr ""
"普通に確立されている接続上に、 TCP がネットワーク層を巻き込まずに再送を試みる"
"回数。 再送がこの回数を越えると、まず最初に、 新しい再送を送る前に可能なら"
"ネットワーク層に経路を更新させる。 デフォルトは RFC が指定している最少数であ"
"る 3。"

#. type: TP
#: build/C/man7/tcp.7:716
#, no-wrap
msgid "I<tcp_retries2> (integer; default: 15; since Linux 2.2)"
msgstr "I<tcp_retries2> (integer; default: 15; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:726
msgid ""
"The maximum number of times a TCP packet is retransmitted in established "
"state before giving up.  The default value is 15, which corresponds to a "
"duration of approximately between 13 to 30 minutes, depending on the "
"retransmission timeout.  The RFC\\ 1122 specified minimum limit of 100 "
"seconds is typically deemed too short."
msgstr ""
"確立状態の接続に、この回数 TCP パケットの再送信を 行なってもだめな場合はあき"
"らめる。 デフォルト値は 15 で、これは (再送のタイムアウトに依存するが)  およ"
"そ 13〜30 分程度の期間に対応する。 RFC\\ 1122 は最小の限界を 100 秒と置いてい"
"るが、 これはたいていの場合には短すぎると思われる。"

#. type: TP
#: build/C/man7/tcp.7:726
#, no-wrap
msgid "I<tcp_rfc1337> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<tcp_rfc1337> (ブール値; デフォルト: 無効; Linux 2.2 以降)"

#.  Since 2.1.90
#. type: Plain text
#: build/C/man7/tcp.7:734
msgid ""
"Enable TCP behavior conformant with RFC\\ 1337.  When disabled, if a RST is "
"received in TIME_WAIT state, we close the socket immediately without waiting "
"for the end of the TIME_WAIT period."
msgstr ""
"TCP の動作を RFC\\ 1337 に準拠させる。 無効にすると、TIME_WAIT 状態のときに "
"RST が受信された場合、 TIME_WAIT 期間の終了を待たずにそのソケットを直ちにク"
"ローズする。"

#. type: TP
#: build/C/man7/tcp.7:734
#, no-wrap
msgid "I<tcp_rmem> (since Linux 2.4)"
msgstr "I<tcp_rmem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:742
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate receive buffer sizes.  TCP dynamically adjusts the "
"size of the receive buffer from the defaults listed below, in the range of "
"these values, depending on memory available in the system."
msgstr ""
"これは 3 つの整数 [min, default, max] からなるベクトル値である。 これらは "
"TCP が受信バッファーサイズを調整するために用いられる。 TCP は、システムで利用"
"できるメモリーに応じて、 受信バッファーのサイズをこれらの変数の範囲で 以下に"
"示すデフォルトから動的に調整する。"

#. type: TP
#: build/C/man7/tcp.7:743 build/C/man7/tcp.7:953 build/C/man7/udp.7:145
#, no-wrap
msgid "I<min>"
msgstr "I<min>"

#. type: Plain text
#: build/C/man7/tcp.7:758
msgid ""
"minimum size of the receive buffer used by each TCP socket.  The default "
"value is the system page size.  (On Linux 2.4, the default value is 4\\ kB, "
"lowered to B<PAGE_SIZE> bytes in low-memory systems.)  This value is used to "
"ensure that in memory pressure mode, allocations below this size will still "
"succeed.  This is not used to bound the size of the receive buffer declared "
"using B<SO_RCVBUF> on a socket."
msgstr "各 TCP ソケットが用いる受信バッファーの最小サイズ。 デフォルト値はシステムのページサイズである (Linux 2.4 では、デフォルト値は 4\\ K バイトで、 メモリーの少ないシステムでは B<PAGE_SIZE> バイトに減らされる)。 この値は、メモリー圧迫モードにおいても、 このサイズの割り当てが成功することを保証するために用いられる。 これは、 B<SO_RCVBUF> を用いてソケットの最低受信バッファーサイズを宣言する際には用いられない。"

#. type: TP
#: build/C/man7/tcp.7:758 build/C/man7/tcp.7:963
#, no-wrap
msgid "I<default>"
msgstr "I<default>"

#. type: Plain text
#: build/C/man7/tcp.7:772
msgid ""
"the default size of the receive buffer for a TCP socket.  This value "
"overwrites the initial default buffer size from the generic global I<net."
"core.rmem_default> defined for all protocols.  The default value is 87380 "
"bytes.  (On Linux 2.4, this will be lowered to 43689 in low-memory "
"systems.)  If larger receive buffer sizes are desired, this value should be "
"increased (to affect all sockets).  To employ large TCP windows, the I<net."
"ipv4.tcp_window_scaling> must be enabled (default)."
msgstr ""
"TCP ソケットの受信バッファーのデフォルトサイズ。 この値は、すべてのプロトコル"
"に対して定義されている、 ジェネリックなグローバルのデフォルトバッファーサイ"
"ズ I<net.core.rmem_default> より優先される。 デフォルト値は 87380 バイトであ"
"る (Linux 2.4 では、メモリーの少ないシステムの場合 43689 まで減らされる)。 大"
"きな受信バッファーサイズが必要な場合は、 この値を増やすべきである (すべてのソ"
"ケットに影響する)。 大きな TCP ウィンドウを用いるには、 I<net.ipv4."
"tcp_window_scaling> を有効にしておかなければならない (デフォルトは有効)。"

#. type: TP
#: build/C/man7/tcp.7:772 build/C/man7/tcp.7:977 build/C/man7/udp.7:157
#, no-wrap
msgid "I<max>"
msgstr "I<max>"

#. type: Plain text
#: build/C/man7/tcp.7:781
msgid ""
"the maximum size of the receive buffer used by each TCP socket.  This value "
"does not override the global I<net.core.rmem_max>.  This is not used to "
"limit the size of the receive buffer declared using B<SO_RCVBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""
"各 TCP ソケットで用いる受信バッファーの最大サイズ。 この値よりもグローバルの "
"I<net.core.rmem_max> が優先される。 これは、 B<SO_RCVBUF> を用いてソケットの"
"受信バッファーサイズ制限を宣言する際には用いられない。 デフォルト値は以下の式"
"で計算される。"

#. type: Plain text
#: build/C/man7/tcp.7:783
#, no-wrap
msgid "    max(87380, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr "    max(87380, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"

#. type: Plain text
#: build/C/man7/tcp.7:786
msgid ""
"(On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory "
"systems)."
msgstr ""
"(Linux 2.4 では、デフォルト値は 87380*2 バイトで、 メモリーの少ないシステムで"
"は 87380 まで減らされる。)"

#. type: TP
#: build/C/man7/tcp.7:787
#, no-wrap
msgid "I<tcp_sack> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_sack> (ブール値; デフォルト: 有効; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:791
msgid "Enable RFC\\ 2018 TCP Selective Acknowledgements."
msgstr "RFC\\ 2018 の TCP Selective Acknowledgements を有効にする。"

#. type: TP
#: build/C/man7/tcp.7:791
#, no-wrap
msgid "I<tcp_slow_start_after_idle> (Boolean; default: enabled; since Linux 2.6.18)"
msgstr "I<tcp_slow_start_after_idle> (ブール値; デフォルト: 有効; Linux 2.6.18 以降)"

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:799
msgid ""
"If enabled, provide RFC 2861 behavior and time out the congestion window "
"after an idle period.  An idle period is defined as the current RTO "
"(retransmission timeout).  If disabled, the congestion window will not be "
"timed out after an idle period."
msgstr ""
"有効にすると、RFC 2861 の動作が行われ、 アイドル時間経過後に輻輳ウィンドウを"
"タイムアウトさせる。 アイドル時間は現在の RTO (再送タイムアウト) で定義され"
"る。 無効にすると、輻輳ウィンドウはアイドル時間経過後もタイムアウトされない。"

#. type: TP
#: build/C/man7/tcp.7:799
#, no-wrap
msgid "I<tcp_stdurg> (Boolean; default: disabled; since Linux 2.2)"
msgstr "I<tcp_stdurg> (ブール値; デフォルト: 無効; Linux 2.2 以降)"

#.  Since 2.1.44
#.  RFC 793 was ambiguous in its specification of the meaning of the
#.  urgent pointer.  RFC 1122 (and RFC 961) fixed on a particular
#.  resolution of this ambiguity (unfortunately the "wrong" one).
#. type: Plain text
#: build/C/man7/tcp.7:813
msgid ""
"If this option is enabled, then use the RFC\\ 1122 interpretation of the TCP "
"urgent-pointer field.  According to this interpretation, the urgent pointer "
"points to the last byte of urgent data.  If this option is disabled, then "
"use the BSD-compatible interpretation of the urgent pointer: the urgent "
"pointer points to the first byte after the urgent data.  Enabling this "
"option may lead to interoperability problems."
msgstr ""
"このオプションを有効にすると、 TCP 緊急ポインター (urgent-pointer)  フィール"
"ドを RFC\\ 1122 に従った解釈を行う。 この解釈に従うと、緊急ポインターは緊急"
"データの最後のバイトを指す。 このオプションを無効にすると、緊急ポインターの解"
"釈が BSD 互換の方法で 行われる: 緊急ポインターは緊急データの後の最初のバイト"
"を指す。 このオプションを有効にすると、相互運用性に問題が生じるかもしれない。"

#. type: TP
#: build/C/man7/tcp.7:813
#, no-wrap
msgid "I<tcp_syn_retries> (integer; default: 6; since Linux 2.2)"
msgstr "I<tcp_syn_retries> (integer; default: 6; Linux 2.2 以降)"

#.  Since 2.1.38
#.  commit 6c9ff979d1921e9fd05d89e1383121c2503759b9
#. type: Plain text
#: build/C/man7/tcp.7:826
#, fuzzy
#| msgid ""
#| "The maximum number of times initial SYNs for an active TCP connection "
#| "attempt will be retransmitted.  This value should not be higher than "
#| "255.  The default value is 5, which corresponds to approximately 180 "
#| "seconds."
msgid ""
"The maximum number of times initial SYNs for an active TCP connection "
"attempt will be retransmitted.  This value should not be higher than 255.  "
"The default value is 6, which corresponds to retrying for up to "
"approximately 127 seconds.  Before Linux 3.7, the default value was 5, which "
"(in conjunction with calculation based on other kernel parameters)  "
"corresponded to approximately 180 seconds."
msgstr ""
"アクティブな TCP 接続に初期 SYN の再送を試みる最大回数。 この数値は 255 より"
"も大きくすべきではない。 デフォルトの値は 5 で、およそ 180 秒に対応する。"

#. type: TP
#: build/C/man7/tcp.7:826
#, no-wrap
msgid "I<tcp_synack_retries> (integer; default: 5; since Linux 2.2)"
msgstr "I<tcp_synack_retries> (integer; default: 5; Linux 2.2 以降)"

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:832
msgid ""
"The maximum number of times a SYN/ACK segment for a passive TCP connection "
"will be retransmitted.  This number should not be higher than 255."
msgstr ""
"passive な TCP 接続の SYN/ACK セグメントで再送を試みる最大数。 この数値は "
"255 よりも大きくすべきではない。"

#. type: TP
#: build/C/man7/tcp.7:832
#, no-wrap
msgid "I<tcp_syncookies> (integer; default: 1; since Linux 2.2)"
msgstr "I<tcp_syncookies> (integer; default: 1; Linux 2.2 以降)"

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:852
#, fuzzy
#| msgid ""
#| "Enable TCP syncookies.  The kernel must be compiled with "
#| "B<CONFIG_SYN_COOKIES>.  Send out syncookies when the syn backlog queue of "
#| "a socket overflows.  The syncookies feature attempts to protect a socket "
#| "from a SYN flood attack.  This should be used as a last resort, if at "
#| "all.  This is a violation of the TCP protocol, and conflicts with other "
#| "areas of TCP such as TCP extensions.  It can cause problems for clients "
#| "and relays.  It is not recommended as a tuning mechanism for heavily "
#| "loaded servers to help with overloaded or misconfigured conditions.  For "
#| "recommended alternatives see I<tcp_max_syn_backlog>, "
#| "I<tcp_synack_retries>, and I<tcp_abort_on_overflow>."
msgid ""
"Enable TCP syncookies.  The kernel must be compiled with "
"B<CONFIG_SYN_COOKIES>.  The syncookies feature attempts to protect a socket "
"from a SYN flood attack.  This should be used as a last resort, if at all.  "
"This is a violation of the TCP protocol, and conflicts with other areas of "
"TCP such as TCP extensions.  It can cause problems for clients and relays.  "
"It is not recommended as a tuning mechanism for heavily loaded servers to "
"help with overloaded or misconfigured conditions.  For recommended "
"alternatives see I<tcp_max_syn_backlog>, I<tcp_synack_retries>, and "
"I<tcp_abort_on_overflow>.  Set to one of the following values:"
msgstr ""
"TCP syncookies を有効にする。カーネルは B<CONFIG_SYNCOOKIES> をつけてコンパイ"
"ルしておかなければならない。 ソケットのバックログキューがオーバーフローする"
"と、 syncookies が送信される。 syncookies 機能は、SYN flood 攻撃からソケット"
"を守ろうとする。 これはいずれにしても、最終手段として用いるべきである。 これ"
"は TCP プロトコルに違反しており、 TCP 拡張のような、TCP の他の部分と衝突して"
"しまう。 クライアントやリレーで問題が起こることもある。 過負荷や設定間違いに"
"よって負荷の大きな状態にあるサーバを調整して救うための 機構とみなすべきではな"
"い。 そのような用途には、代わりに I<tcp_max_syn_backlog>, "
"I<tcp_synack_retries>, I<tcp_abort_on_overflow> などの使用を考えること。"

#. type: Plain text
#: build/C/man7/tcp.7:855
msgid "Disable TCP syncookies."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:857
msgid "Send out syncookies when the syn backlog queue of a socket overflows."
msgstr ""

#.  commit 5ad37d5deee1ff7150a2d0602370101de158ad86
#. type: Plain text
#: build/C/man7/tcp.7:862
msgid ""
"(since Linux 3.12)  Send out syncookies unconditionally.  This can be useful "
"for network testing."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:863
#, no-wrap
msgid "I<tcp_timestamps> (integer; default: 1; since Linux 2.2)"
msgstr "I<tcp_timestamps> (integer; default: 1; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:868
msgid ""
"Set to one of the following values to enable or disable RFC\\ 1323 TCP "
"timestamps:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:871
msgid "Disable timestamps."
msgstr "timestamps を有効にする。"

#. type: Plain text
#: build/C/man7/tcp.7:874
msgid ""
"Enable timestamps as defined in RFC1323 and use random offset for each "
"connection rather than only using the current time."
msgstr ""

#.  commit 25429d7b7dca01dc4f17205de023a30ca09390d0
#. type: Plain text
#: build/C/man7/tcp.7:880
msgid ""
"As for the value 1, but without random offsets.  Setting I<tcp_timestamps> "
"to this value is meaningful since Linux 4.10."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:881
#, no-wrap
msgid "I<tcp_tso_win_divisor> (integer; default: 3; since Linux 2.6.9)"
msgstr "I<tcp_tso_win_divisor> (integer; default: 3; Linux 2.6.9 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:887
msgid ""
"This parameter controls what percentage of the congestion window can be "
"consumed by a single TCP Segmentation Offload (TSO) frame.  The setting of "
"this parameter is a tradeoff between burstiness and building larger TSO "
"frames."
msgstr ""
"このパラメーターは、一つの TCP Segmentation Offload (TSO) フレームで 消費でき"
"る輻輳ウィンドウの割合 (パーセント) を制御する。 バースト性と、どれだけ大き"
"な TSO フレームを構築するかのはトレードオフであり、 このパラメーターはその度"
"合いを設定する。"

#. type: TP
#: build/C/man7/tcp.7:887
#, no-wrap
msgid "I<tcp_tw_recycle> (Boolean; default: disabled; Linux 2.4 to 4.11)"
msgstr "I<tcp_tw_recycle> (ブール値; デフォルト: 無効; Linux 2.4 以降 4.11 まで)"

#
#.  Since 2.3.15
#.  removed in 4.12; commit 4396e46187ca5070219b81773c4e65088dac50cc
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:899
#, fuzzy
#| msgid ""
#| "Enable fast recycling of TIME_WAIT sockets. Enabling this option is not "
#| "recommended for devices communicating with the general Internet or using "
#| "NAT (Network Address Translation). Since some NAT gateways pass through "
#| "IP timestamp values, one IP can appear to have non-increasing timestamps. "
#| "See RFC 1323 (PAWS), RFC 6191."
msgid ""
"Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not "
"recommended as the remote IP may not use monotonically increasing timestamps "
"(devices behind NAT, devices with per-connection timestamp offsets).  See "
"RFC 1323 (PAWS) and RFC 6191."
msgstr ""
"TIME_WAIT ソケットの素早い再利用 (fast recycling) を有効にする。 通常のイン"
"ターネットと通信したり NAT (ネットワークアドレス変換) を使うデバイスでは、 こ"
"のオプションを有効にするのは推奨されない。 いくつかの NAT ゲートウェイでは "
"IP タイムスタンプをそのまま通過させるので、 一つの IP が増加しないタイムスタ"
"ンプを持つように見える。 RFC 1323 (PAWS), RFC 6191 を参照。"

#. type: TP
#: build/C/man7/tcp.7:899
#, no-wrap
msgid "I<tcp_tw_reuse> (Boolean; default: disabled; since Linux 2.4.19/2.6)"
msgstr "I<tcp_tw_reuse> (ブール値; デフォルト: 無効; Linux 2.4.19/2.6 以降)"

#.  Since 2.4.19/2.5.43
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:907
msgid ""
"Allow to reuse TIME_WAIT sockets for new connections when it is safe from "
"protocol viewpoint.  It should not be changed without advice/request of "
"technical experts."
msgstr ""
"プロトコルの面から見て問題ない場合に新規コネクションに TIME_WAIT 状態のソケッ"
"トを再利用することを許可する。技術的に詳しい人の助言や 要請なしにこのオプショ"
"ンを変更すべきではない。"

#. type: TP
#: build/C/man7/tcp.7:907
#, no-wrap
msgid "I<tcp_vegas_cong_avoid> (Boolean; default: disabled; Linux 2.2 to 2.6.13)"
msgstr "I<tcp_vegas_cong_avoid> (ブール値; デフォルト: 無効; Linux 2.2 から 2.6.13 まで)"

#.  Since 2.1.8; removed in 2.6.13
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:918
msgid ""
"Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a sender-side-"
"only change to TCP that anticipates the onset of congestion by estimating "
"the bandwidth.  TCP Vegas adjusts the sending rate by modifying the "
"congestion window.  TCP Vegas should provide less packet loss, but it is not "
"as aggressive as TCP Reno."
msgstr ""
"TCP Vegas 輻輳制御アルゴリズムを有効にする。 TCP Vegas は帯域を推測することで"
"輻輳の起こり始めを予想するように TCP の送信側のみに変更を加えたものである。 "
"TCP Vegas は輻輳ウィンドウを修正することで、送信レートを調整する。 TCP Vegas "
"は TCP Reno と比べてパケットロスは少ないが、 TCP Reno ほど積極的な挙動はしな"
"い。"

#. type: TP
#: build/C/man7/tcp.7:918
#, no-wrap
msgid "I<tcp_westwood> (Boolean; default: disabled; Linux 2.4.26/2.6.3 to 2.6.13)"
msgstr "I<tcp_westwood> (ブール値; デフォルト: 無効; Linux 2.4.26/2.6.3 から 2.6.13 まで)"

#. type: Plain text
#: build/C/man7/tcp.7:930
msgid ""
"Enable TCP Westwood+ congestion control algorithm.  TCP Westwood+ is a "
"sender-side-only modification of the TCP Reno protocol stack that optimizes "
"the performance of TCP congestion control.  It is based on end-to-end "
"bandwidth estimation to set congestion window and slow start threshold after "
"a congestion episode.  Using this estimation, TCP Westwood+ adaptively sets "
"a slow start threshold and a congestion window which takes into account the "
"bandwidth used at the time congestion is experienced.  TCP Westwood+ "
"significantly increases fairness with respect to TCP Reno in wired networks "
"and throughput over wireless links."
msgstr ""
"TCP Westwood+ 輻輳制御アルゴリズムを有効にする。 TCP Westwood+ は TCP 輻輳制"
"御の性能を最適化するように TCP Reno の プロトコルスタックの送信側のみに修正を"
"加えたものである。 輻輳が起こった後で、輻輳ウィンドウや slow start の閾値を "
"通信両端間の帯域の推測に基づいて設定する。 この推測を使って、TCP Westwood+ は"
"輻輳が発生した時に使っていた 帯域を考慮に入れた slow start の閾値と輻輳ウィン"
"ドウを設定する。 TCP Westwood+ は、有線ネットワークにおける TCP Reno の公平"
"性 (fairness) と、無線リンクでのスループットを大きく向上する。"

#. type: TP
#: build/C/man7/tcp.7:930
#, no-wrap
msgid "I<tcp_window_scaling> (Boolean; default: enabled; since Linux 2.2)"
msgstr "I<tcp_window_scaling> (ブール値; デフォルト: 有効; Linux 2.2 以降)"

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:944
msgid ""
"Enable RFC\\ 1323 TCP window scaling.  This feature allows the use of a "
"large window (E<gt> 64\\ kB) on a TCP connection, should the other end "
"support it.  Normally, the 16 bit window length field in the TCP header "
"limits the window size to less than 64\\ kB.  If larger windows are desired, "
"applications can increase the size of their socket buffers and the window "
"scaling option will be employed.  If I<tcp_window_scaling> is disabled, TCP "
"will not negotiate the use of window scaling with the other end during "
"connection setup."
msgstr "RFC\\ 1323 の TCP ウィンドウスケーリングを有効にする。 この機能を用いると、接続先が対応していれば、 TCP 接続で大きな (64\\ K 以上の) ウィンドウが使えるようになる。 通常は TCP ヘッダーのウインドウ長フィールドは 16 ビットなので、 ウィンドウサイズは 64\\ K バイト以下に限られる。 もっと大きなウィンドウを使いたい場合は、 アプリケーションはソケットバッファーのサイズを増やして、 ウィンドウスケーリングのオプションを利用すればよい。 I<tcp_window_scaling> を無効にしていると、 TCP は他端との接続設定の際に、 ウィンドウスケーリングのネゴシエーションを行なわない。"

#. type: TP
#: build/C/man7/tcp.7:944
#, no-wrap
msgid "I<tcp_wmem> (since Linux 2.4)"
msgstr "I<tcp_wmem> (Linux 2.4 以降)"

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:952
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate send buffer sizes.  TCP dynamically adjusts the size "
"of the send buffer from the default values listed below, in the range of "
"these values, depending on memory available."
msgstr ""
"これは 3 つの整数 [min, default, max] からなるベクトル値である。 これらは "
"TCP が送信バッファーサイズを調整するために用いられる。 TCP は、システムで利用"
"できるメモリーに応じて、送信バッファーのサイズを これらの変数の範囲で以下に示"
"すデフォルトから動的に調整する。"

#. type: Plain text
#: build/C/man7/tcp.7:963
msgid ""
"Minimum size of the send buffer used by each TCP socket.  The default value "
"is the system page size.  (On Linux 2.4, the default value is 4\\ kB.)  This "
"value is used to ensure that in memory pressure mode, allocations below this "
"size will still succeed.  This is not used to bound the size of the send "
"buffer declared using B<SO_SNDBUF> on a socket."
msgstr "各 TCP ソケットが用いる送信バッファーの最小サイズ。 デフォルト値はシステムのページサイズである (Linux 2.4 では、デフォルト値は 4\\ K である)。 この値は、メモリー圧迫モードにおいても、 このサイズ以下の割り当てが成功することを保証するために用いられる。 これは、 B<SO_SNDBUF> を用いてソケットの最低送信バッファーサイズを宣言する際には用いられない。"

#.  True in Linux 2.4 and 2.6
#. type: Plain text
#: build/C/man7/tcp.7:977
msgid ""
"The default size of the send buffer for a TCP socket.  This value overwrites "
"the initial default buffer size from the generic global I</proc/sys/net/core/"
"wmem_default> defined for all protocols.  The default value is 16\\ kB.  If "
"larger send buffer sizes are desired, this value should be increased (to "
"affect all sockets).  To employ large TCP windows, the I</proc/sys/net/ipv4/"
"tcp_window_scaling> must be set to a nonzero value (default)."
msgstr "TCP ソケットの送信バッファーのデフォルトサイズ。 この値は、すべてのプロトコルに対して定義されている、 ジェネリックなグローバルのデフォルトバッファーサイズ I</proc/sys/net/core/wmem_default> より優先される。 デフォルト値は 16\\ K バイトである。 大きな送信バッファーサイズが必要な場合は、 この値を増やすべきである (すべてのソケットに影響する)。 大きな TCP ウィンドウを用いるには、 I</proc/sys/net/ipv4/tcp_window_scaling> を 0 以外の値 (デフォルト値) にしておかなければならない。"

#. type: Plain text
#: build/C/man7/tcp.7:986
msgid ""
"The maximum size of the send buffer used by each TCP socket.  This value "
"does not override the value in I</proc/sys/net/core/wmem_max>.  This is not "
"used to limit the size of the send buffer declared using B<SO_SNDBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""
"各 TCP ソケットで用いる送信バッファーの最大サイズ。 この値よりも I</proc/sys/"
"net/core/wmem_max> が優先される。 これは B<SO_SNDBUF> を用いてソケットの送信"
"バッファーサイズ制限を宣言する際には用いられない。 デフォルト値は以下の式で計"
"算される。"

#. type: Plain text
#: build/C/man7/tcp.7:988
#, no-wrap
msgid "    max(65536, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr "    max(65536, min(4\\ MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"

#. type: Plain text
#: build/C/man7/tcp.7:991
msgid ""
"(On Linux 2.4, the default value is 128\\ kB, lowered 64\\ kB depending on "
"low-memory systems.)"
msgstr "(Linux 2.4 では、デフォルト値は 128\\ K バイトで、 メモリーの少ないシステムでは 64\\ K にまで減らされる。)"

#. type: TP
#: build/C/man7/tcp.7:992
#, no-wrap
msgid "I<tcp_workaround_signed_windows> (Boolean; default: disabled; since Linux 2.6.26)"
msgstr "I<tcp_workaround_signed_windows> (ブール値; デフォルト: 無効; Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:998
msgid ""
"If enabled, assume that no receipt of a window-scaling option means that the "
"remote TCP is broken and treats the window as a signed quantity.  If "
"disabled, assume that the remote TCP is not broken even if we do not receive "
"a window scaling option from it."
msgstr ""
"有効にすると、ウィンドウスケーリングオプションを受信しないのは、 接続相手の "
"TCP が壊れていると考え、ウィンドウを符号付きの量とみなす。 無効にすると、接続"
"相手からウィンドウスケーリングオプションを受信しなかった 場合であっても、接続"
"相手の TCP が壊れているとはみなさない。"

#.  or SOL_TCP on Linux
#. type: Plain text
#: build/C/man7/tcp.7:1016
msgid ""
"To set or get a TCP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_TCP>.  Unless otherwise noted, I<optval> is a pointer to an "
"I<int>.  In addition, most B<IPPROTO_IP> socket options are valid on TCP "
"sockets.  For more information see B<ip>(7)."
msgstr ""
"TCP ソケットのオプションは、 オプションレベル引数に I<IPPROTO_TCP> を指定し"
"た B<setsockopt>(2)  で設定でき、 B<getsockopt>(2)  で取得できる。 注釈がない"
"限り、 I<optval> は I<int> へのポインターである。 さらに、ほとんどの "
"B<IPPROTO_IP> ソケットオプションも TCP ソケットに対して有効である。詳細は "
"B<ip>(7)  を見よ。"

#. type: Plain text
#: build/C/man7/tcp.7:1021
msgid ""
"Following is a list of TCP-specific socket options.  For details of some "
"other socket options that are also applicable for TCP sockets, see "
"B<socket>(7)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1021
#, no-wrap
msgid "B<TCP_CONGESTION> (since Linux 2.6.13)"
msgstr "B<TCP_CONGESTION> (Linux 2.6.13 以降)"

#. 	    commit 5f8ef48d240963093451bcf83df89f1a1364f51d
#. 	    Author: Stephen Hemminger <shemminger@osdl.org>
#. type: Plain text
#: build/C/man7/tcp.7:1037
msgid ""
"The argument for this option is a string.  This option allows the caller to "
"set the TCP congestion control algorithm to be used, on a per-socket basis.  "
"Unprivileged processes are restricted to choosing one of the algorithms in "
"I<tcp_allowed_congestion_control> (described above).  Privileged processes "
"(B<CAP_NET_ADMIN>)  can choose from any of the available congestion-control "
"algorithms (see the description of I<tcp_available_congestion_control> "
"above)."
msgstr ""
"このオプションの引数は文字列である。 このオプションを使うと、呼び出し元がソ"
"ケット単位に使用する TCP 輻輳制御アルゴリズムを設定することができる。 非特権"
"プロセスが使用できるアルゴリズムは (上述の) "
"I<tcp_allowed_congestion_control> で設定されたものだけに制限される。 特権プロ"
"セス (B<CAP_NET_ADMIN>) は任意の輻輳制御アルゴリズムを選択することができる "
"(上記の B<tcp_available_congestion_control> の説明を参照)。"

#. type: TP
#: build/C/man7/tcp.7:1037
#, no-wrap
msgid "B<TCP_CORK> (since Linux 2.2)"
msgstr "B<TCP_CORK> (Linux 2.2 以降)"

#.  precisely: since 2.1.127
#. type: Plain text
#: build/C/man7/tcp.7:1053
msgid ""
"If set, don't send out partial frames.  All queued partial frames are sent "
"when the option is cleared again.  This is useful for prepending headers "
"before calling B<sendfile>(2), or for throughput optimization.  As currently "
"implemented, there is a 200 millisecond ceiling on the time for which output "
"is corked by B<TCP_CORK>.  If this ceiling is reached, then queued data is "
"automatically transmitted.  This option can be combined with B<TCP_NODELAY> "
"only since Linux 2.5.71.  This option should not be used in code intended to "
"be portable."
msgstr ""
"セットされると、 partial フレームを送信しない。 このオプションが解除される"
"と、 キューイングされた partial フレームが送られる。これは B<sendfile>(2)  を"
"呼ぶ前にヘッダーを前置したり、 スループットを最適化したい場合に便利である。 "
"現在の実装では、 B<TCP_CORK> で出力を抑えることができる時間の上限は 200 ミリ"
"秒である。 この上限に達すると、キューイングされたデータは自動的に送信され"
"る。 Linux 2.5.71 以降においてのみ、このオプションを B<TCP_NODELAY> と同時に"
"用いることができる。 移植性の必要なプログラムではこのオプションを用いるべきで"
"はない。"

#. type: TP
#: build/C/man7/tcp.7:1053
#, no-wrap
msgid "B<TCP_DEFER_ACCEPT> (since Linux 2.4)"
msgstr "B<TCP_DEFER_ACCEPT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.38
#.  Useful references:
#.  http://www.techrepublic.com/article/take-advantage-of-tcp-ip-options-to-optimize-data-transmission/
#.  http://unix.stackexchange.com/questions/94104/real-world-use-of-tcp-defer-accept
#. type: Plain text
#: build/C/man7/tcp.7:1064
msgid ""
"Allow a listener to be awakened only when data arrives on the socket.  Takes "
"an integer value (seconds), this can bound the maximum number of attempts "
"TCP will make to complete the connection.  This option should not be used in "
"code intended to be portable."
msgstr ""
"これを用いると、リスナはデータがソケットに到着した時のみ目覚めるようになる。 "
"整数値 (秒) をとり、 TCP が接続を完了しようと試みる回数を制限できる。 移植性"
"の必要なプログラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1064
#, no-wrap
msgid "B<TCP_INFO> (since Linux 2.4)"
msgstr "B<TCP_INFO> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:1070
msgid ""
"Used to collect information about this socket.  The kernel returns a "
"I<struct tcp_info> as defined in the file I</usr/include/linux/tcp.h>.  This "
"option should not be used in code intended to be portable."
msgstr ""
"このソケットの情報を収集するのに用いる。 カーネルは I</usr/include/linux/tcp."
"h> ファイルで定義されている I<struct tcp_info> を返す。 移植性の必要なプログ"
"ラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1070
#, no-wrap
msgid "B<TCP_KEEPCNT> (since Linux 2.4)"
msgstr "B<TCP_KEEPCNT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1077
msgid ""
"The maximum number of keepalive probes TCP should send before dropping the "
"connection.  This option should not be used in code intended to be portable."
msgstr ""
"接続を落とす前に TCP が試みる keepalive プローブの最大回数。 移植性の必要なプ"
"ログラムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1077
#, no-wrap
msgid "B<TCP_KEEPIDLE> (since Linux 2.4)"
msgstr "B<TCP_KEEPIDLE> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1086
msgid ""
"The time (in seconds) the connection needs to remain idle before TCP starts "
"sending keepalive probes, if the socket option B<SO_KEEPALIVE> has been set "
"on this socket.  This option should not be used in code intended to be "
"portable."
msgstr ""
"この時間 (秒単位) を越えて接続がアイドル状態に留まっていると、 このソケット"
"に B<SO_KEEPALIVE> ソケットオプションが設定されている場合、 TCP は keepalive "
"プローブを送りはじめる。 移植性の必要なプログラムではこのオプションを用いるべ"
"きではない。"

#. type: TP
#: build/C/man7/tcp.7:1086
#, no-wrap
msgid "B<TCP_KEEPINTVL> (since Linux 2.4)"
msgstr "B<TCP_KEEPINTVL> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1091
msgid ""
"The time (in seconds) between individual keepalive probes.  This option "
"should not be used in code intended to be portable."
msgstr ""
"各 keepalive プローブの間隔 (秒単位)。 移植性の必要なプログラムではこのオプ"
"ションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1091
#, no-wrap
msgid "B<TCP_LINGER2> (since Linux 2.4)"
msgstr "B<TCP_LINGER2> (Linux 2.4 以降)"

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:1103
msgid ""
"The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used "
"to override the system-wide setting in the file I</proc/sys/net/ipv4/"
"tcp_fin_timeout> for this socket.  This is not to be confused with the "
"B<socket>(7)  level option B<SO_LINGER>.  This option should not be used in "
"code intended to be portable."
msgstr ""
"orphan された FIN_WAIT2 状態のソケットの寿命。 このオプションを用いると、シス"
"テム全体に適用されるファイル I</proc/sys/net/ipv4/tcp_fin_timeout> の値を、こ"
"のソケットに対してのみ変更できる。 B<socket>(7)  レベルのオプション "
"B<SO_LINGER> と混同しないこと。 移植性の必要なプログラムではこのオプションを"
"用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1103
#, no-wrap
msgid "B<TCP_MAXSEG>"
msgstr "B<TCP_MAXSEG>"

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:1113
msgid ""
"The maximum segment size for outgoing TCP packets.  In Linux 2.2 and "
"earlier, and in Linux 2.6.28 and later, if this option is set before "
"connection establishment, it also changes the MSS value announced to the "
"other end in the initial packet.  Values greater than the (eventual) "
"interface MTU have no effect.  TCP will also impose its minimum and maximum "
"bounds over the value provided."
msgstr ""
"送出 TCP パケットの最大セグメントサイズ。 Linux 2.2 以前と Linux\n"
"2.6.28 以降では、このオプションを接続確立の前に設定すると、初期パケット\n"
"で他端にアナウンスする MSS の値も変化する。インターフェースの MTU より\n"
"も大きな (あるいは大きくなってしまった) 値は効果を持たない。 また TCP\n"
"は、この値よりも最小・最大の制限の方を優先する。"

#. type: TP
#: build/C/man7/tcp.7:1113
#, no-wrap
msgid "B<TCP_NODELAY>"
msgstr "B<TCP_NODELAY>"

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:1130
msgid ""
"If set, disable the Nagle algorithm.  This means that segments are always "
"sent as soon as possible, even if there is only a small amount of data.  "
"When not set, data is buffered until there is a sufficient amount to send "
"out, thereby avoiding the frequent sending of small packets, which results "
"in poor utilization of the network.  This option is overridden by "
"B<TCP_CORK>; however, setting this option forces an explicit flush of "
"pending output, even if B<TCP_CORK> is currently set."
msgstr ""
"設定すると Nagle アルゴリズムを無効にする。 すなわち、データ量が少ない場合で"
"も 各セグメントは可能な限り早く送信される。 設定されていないと、 送信する分だ"
"け溜まるまでデータはバッファーされ、 小さなパケットを頻繁に送らずにすみ、 "
"ネットワークを有効に利用できる。 このオプションは B<TCP_CORK> により上書きさ"
"れる。しかしながら、 B<TCP_CORK> が設定されている場合であっても、このオプショ"
"ンを設定すると、 送信待ちの出力を明示的に掃き出す (flush) ことになる。"

#. type: TP
#: build/C/man7/tcp.7:1130
#, no-wrap
msgid "B<TCP_QUICKACK> (since Linux 2.4.4)"
msgstr "B<TCP_QUICKACK> (Linux 2.4.4 以降)"

#. type: Plain text
#: build/C/man7/tcp.7:1145
msgid ""
"Enable quickack mode if set or disable quickack mode if cleared.  In "
"quickack mode, acks are sent immediately, rather than delayed if needed in "
"accordance to normal TCP operation.  This flag is not permanent, it only "
"enables a switch to or from quickack mode.  Subsequent operation of the TCP "
"protocol will once again enter/leave quickack mode depending on internal "
"protocol processing and factors such as delayed ack timeouts occurring and "
"data transfer.  This option should not be used in code intended to be "
"portable."
msgstr ""
"設定されていると quickack モードを有効にし、クリアされると無効にする。 通常"
"の TCP 動作では ack は必要に応じて遅延されるのに対し、 quickack モードでは "
"ack はすぐに送信される。 このフラグは永続的なものではなく、 quickack モードか"
"ら/モードへ切り替えるためのものである。 これ以降の TCP プロトコルの動作によっ"
"ては、 内部のプロトコル処理や、遅延 ack タイムアウトの発生、 データ転送などの"
"要因によって、 再び quickack から出たり入ったりする。 移植性の必要なプログラ"
"ムではこのオプションを用いるべきではない。"

#. type: TP
#: build/C/man7/tcp.7:1145
#, no-wrap
msgid "B<TCP_SYNCNT> (since Linux 2.4)"
msgstr "B<TCP_SYNCNT> (Linux 2.4 以降)"

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:1152
msgid ""
"Set the number of SYN retransmits that TCP should send before aborting the "
"attempt to connect.  It cannot exceed 255.  This option should not be used "
"in code intended to be portable."
msgstr ""
"接続の試行を中止させる前に TCP が送る SYN 再送数を設定する。 これは 255 より"
"大きくはできない。 移植性の必要なプログラムではこのオプションを用いるべきでは"
"ない。"

#. type: TP
#: build/C/man7/tcp.7:1152
#, no-wrap
msgid "B<TCP_USER_TIMEOUT> (since Linux 2.6.37)"
msgstr "B<TCP_USER_TIMEOUT> (Linux 2.6.37 以降)"

#. 	    commit dca43c75e7e545694a9dd6288553f55c53e2a3a3
#. 	    Author: Jerry Chu <hkchu@google.com>
#.  The following text taken nearly verbatim from Jerry Chu's (excellent)
#.  commit message.
#. type: Plain text
#: build/C/man7/tcp.7:1170
msgid ""
"This option takes an I<unsigned int> as an argument.  When the value is "
"greater than 0, it specifies the maximum amount of time in milliseconds that "
"transmitted data may remain unacknowledged before TCP will forcibly close "
"the corresponding connection and return B<ETIMEDOUT> to the application.  If "
"the option value is specified as 0, TCP will use the system default."
msgstr ""
"このオプションは I<unsigned int> 型の引数を取る。 値が 0 より大きい場合、そ"
"の値は、 どのくらいの時間、送信されたデータが ACK を受信しないままの状態が続"
"くと、 TCP がその接続を強制的にクローズし、アプリケーションに B<ETIMEDOUT> を"
"返すかを、 ミリ秒単位で指定する。 オプションの値が 0 の場合、TCP はシステムの"
"デフォルト値を使用する。"

#. type: Plain text
#: build/C/man7/tcp.7:1177
msgid ""
"Increasing user timeouts allows a TCP connection to survive extended periods "
"without end-to-end connectivity.  Decreasing user timeouts allows "
"applications to \"fail fast\", if so desired.  Otherwise, failure may take "
"up to 20 minutes with the current system defaults in a normal WAN "
"environment."
msgstr ""
"ユーザータイムアウトを長くすると、 通信の両端での接続性がない場合でも長い時"
"間 TCP 接続が維持されるようになる。 ユーザータイムアウトを短くすると、 アプリ"
"ケーションは必要であれば「早く失敗」できるようになる。 設定しなかった場合"
"は、 通常の WAN 環境では現在のシステムのデフォルトの 20 分で失敗することにな"
"る。"

#. type: Plain text
#: build/C/man7/tcp.7:1187
msgid ""
"This option can be set during any state of a TCP connection, but is "
"effective only during the synchronized states of a connection (ESTABLISHED, "
"FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, and LAST-ACK).  Moreover, when "
"used with the TCP keepalive (B<SO_KEEPALIVE>)  option, B<TCP_USER_TIMEOUT> "
"will override keepalive to determine when to close a connection due to "
"keepalive failure."
msgstr ""
"このオプションは TCP 接続がどの状態の場合でも設定することができるが、 接続が"
"同期状態 (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-"
"ACK) の場合のみ効果がある。 また、 TCP keepalive (B<SO_KEEPALIVE>) オプション"
"とともに使用された場合、 B<TCP_USER_TIMEOUT> は keepalive 失敗による接続ク"
"ローズを判定するための keepalive 値を上書きする。"

#. type: Plain text
#: build/C/man7/tcp.7:1190
msgid ""
"The option has no effect on when TCP retransmits a packet, nor when a "
"keepalive probe is sent."
msgstr ""
"このオプションは TCP がパケットを再送する際や keepalive プローブを送信する際"
"には影響を及ぼさない。"

#. type: Plain text
#: build/C/man7/tcp.7:1194
msgid ""
"This option, like many others, will be inherited by the socket returned by "
"B<accept>(2), if it was set on the listening socket."
msgstr ""
"他の多くのオプション同様、リッスン中のソケットでこのオプションがセットされて"
"いれば B<accept>(2) が返すソケットにオプションが継承される。"

#. type: Plain text
#: build/C/man7/tcp.7:1197
msgid ""
"Further details on the user timeout feature can be found in RFC\\ 793 and RFC"
"\\ 5482 (\"TCP User Timeout Option\")."
msgstr ""
"ユーザータイムアウト機能の詳細は RFC\\ 793 と  RFC\\ 5482 (\"TCP User "
"Timeout Option\") に書かれている。"

#. type: TP
#: build/C/man7/tcp.7:1197
#, no-wrap
msgid "B<TCP_WINDOW_CLAMP> (since Linux 2.4)"
msgstr "B<TCP_WINDOW_CLAMP> (Linux 2.4 以降)"

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:1204
msgid ""
"Bound the size of the advertised window to this value.  The kernel imposes a "
"minimum size of SOCK_MIN_RCVBUF/2.  This option should not be used in code "
"intended to be portable."
msgstr ""
"広報するウィンドウのサイズをこの値に固定する。 カーネルによって最小サイズは "
"SOCK_MIN_RCVBUF/2 に制限されている。 このオプションは移植性の必要なコードでは"
"用いるべきでない。"

#. type: SS
#: build/C/man7/tcp.7:1204 build/C/man7/unix.7:417
#, no-wrap
msgid "Sockets API"
msgstr "ソケット API"

#. type: Plain text
#: build/C/man7/tcp.7:1213
msgid ""
"TCP provides limited support for out-of-band data, in the form of (a single "
"byte of) urgent data.  In Linux this means if the other end sends newer out-"
"of-band data the older urgent data is inserted as normal data into the "
"stream (even when B<SO_OOBINLINE> is not set).  This differs from BSD-based "
"stacks."
msgstr ""
"TCP は帯域外データ (out-of-band data) を限定的にサポートしており、 (1 バイト"
"の) 緊急データという形である。 つまり Linux においては、 接続先が (新しいやり"
"方の) 帯域外データを送ってきた場合、 (古いやり方の)  緊急データは通常のデータ"
"としてストリームに挿入されることになる (これは B<SO_OOBINLINE> がセットされて"
"いる場合でも同様である)。 これは BSD ベースのスタックとは異なる。"

#. type: Plain text
#: build/C/man7/tcp.7:1220
msgid ""
"Linux uses the BSD compatible interpretation of the urgent pointer field by "
"default.  This violates RFC\\ 1122, but is required for interoperability "
"with other stacks.  It can be changed via I</proc/sys/net/ipv4/tcp_stdurg>."
msgstr ""
"Linux は、デフォルトでは urgent ポインターフィールドの解釈に BSD 互換の方法を"
"用いる。これは RFC\\ 1122 に反しているが、 他のスタックと同時に動作させるには"
"やむを得ない。これは I</proc/sys/net/ipv4/tcp_stdurg> によって変更できる。"

#. type: Plain text
#: build/C/man7/tcp.7:1225
msgid ""
"It is possible to peek at out-of-band data using the B<recv>(2)  B<MSG_PEEK> "
"flag."
msgstr ""
"B<recv>(2)  の B<MSG_PEEK> フラグを使うと、帯域外データを覗き見することができ"
"る。"

#. type: Plain text
#: build/C/man7/tcp.7:1241
msgid ""
"Since version 2.4, Linux supports the use of B<MSG_TRUNC> in the I<flags> "
"argument of B<recv>(2)  (and B<recvmsg>(2)).  This flag causes the received "
"bytes of data to be discarded, rather than passed back in a caller-supplied "
"buffer.  Since Linux 2.4.4, B<MSG_TRUNC> also has this effect when used in "
"conjunction with B<MSG_OOB> to receive out-of-band data."
msgstr ""
"Linux 2.4 以降では、 B<recv>(2)  (や B<recvmsg>(2))  の I<flags> 引数に "
"B<MSG_TRUNC> を使うことができる。 このフラグを指定すると、受信データは、呼び"
"出し元から渡されたバッファー にコピーされて返されるのではなく、廃棄されるよう"
"になる。 Linux 2.4.4 以降では、 B<MSG_TRUNC> を、帯域外データを受信するため"
"の B<MSG_OOB> と組み合わせて使った場合にも、これと同じ効果を持つようになって"
"いる。"

#. type: Plain text
#: build/C/man7/tcp.7:1247 build/C/man7/unix.7:642
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""
"以下の B<ioctl>(2) 呼び出しは I<value> に情報を入れて返す。\n"
"正しい書式は以下の通り。"

#. type: Plain text
#: build/C/man7/tcp.7:1252
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
#: build/C/man7/tcp.7:1257
msgid "I<ioctl_type> is one of the following:"
msgstr "I<ioctl_type> は以下のいずれか一つである:"

#. type: TP
#: build/C/man7/tcp.7:1257 build/C/man7/unix.7:652
#, no-wrap
msgid "B<SIOCINQ>"
msgstr "B<SIOCINQ>"

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1273
msgid ""
"Returns the amount of queued unread data in the receive buffer.  The socket "
"must not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCINQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""
"受信バッファーのキューにある、まだ読んでいないデータの量を返す。ソケットは\n"
"LISTEN 状態にあってはならず、さもないとエラー (B<EINVAL>) が返る。\n"
"B<SIOCINQ> は I<E<lt>linux/sockios.hE<gt>> で定義されている。\n"
"代わりに、I<E<lt>sys/ioctl.hE<gt>> で定義されている、同義語の B<FIONREAD>\n"
"を使うこともできる。"

#. type: TP
#: build/C/man7/tcp.7:1273
#, no-wrap
msgid "B<SIOCATMARK>"
msgstr "B<SIOCATMARK>"

#. type: Plain text
#: build/C/man7/tcp.7:1278
msgid ""
"Returns true (i.e., I<value> is nonzero) if the inbound data stream is at "
"the urgent mark."
msgstr ""
"受信データストリームが緊急マークの位置であれば、真を返す (つまり I<value> が "
"0 以外)。"

#. type: Plain text
#: build/C/man7/tcp.7:1294
msgid ""
"If the B<SO_OOBINLINE> socket option is set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the urgent data.  If the "
"B<SO_OOBINLINE> socket option is not set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the bytes following the "
"urgent data (to actually read the urgent data requires the B<recv(MSG_OOB)> "
"flag)."
msgstr ""
"B<SO_OOBINLINE> ソケットオプションが設定されていて、 B<SIOCATMARK> が真を返し"
"た場合、次のソケットからの読み込みでは緊急データが 返される。 "
"B<SO_OOBINLINE> ソケットオプションが設定されておらず、 B<SIOCATMARK> が真を返"
"した場合、次のソケットからの読み込みでは緊急データに 続くデータが返される (実"
"際に緊急データを読み込むには B<recv(MSG_OOB)> とフラグをつける必要がある)。"

#. type: Plain text
#: build/C/man7/tcp.7:1308
msgid ""
"Note that a read never reads across the urgent mark.  If an application is "
"informed of the presence of urgent data via B<select>(2)  (using the "
"I<exceptfds> argument) or through delivery of a B<SIGURG> signal, then it "
"can advance up to the mark using a loop which repeatedly tests B<SIOCATMARK> "
"and performs a read (requesting any number of bytes) as long as "
"B<SIOCATMARK> returns false."
msgstr ""
"データの一回の読み込みでは緊急マークを跨がっての読み込みは行われない。 アプリ"
"ケーションが緊急データの存在を (I<exceptfds> 引数を使って)  B<select>(2)  "
"経由または B<SIGURG> シグナルの配送を通じて知らされた場合、 B<SIOCATMARK> の"
"チェックと読み込み (何バイト読み込み要求をしてもよい) を B<SIOCATMARK> が偽を"
"返さなくなるまで繰り返し行うことで、緊急マークの位置まで 読み進めることができ"
"る。"

#. type: TP
#: build/C/man7/tcp.7:1308
#, no-wrap
msgid "B<SIOCOUTQ>"
msgstr "B<SIOCOUTQ>"

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCOUTQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1324
msgid ""
"Returns the amount of unsent data in the socket send queue.  The socket must "
"not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCOUTQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<TIOCOUTQ>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""
"ソケットの送信キューに残っている未送信データの量を返す。ソケットは LISTEN "
"状\n"
"態にあってはならない。 LISTEN 状態の場合にはエラー (B<EINVAL>) となる。\n"
"B<SIOCOUTQ> は I<E<lt>linux/sockios.hE<gt>> で定義されている。\n"
"代わりに、I<E<lt>sys/ioctl.hE<gt>> で定義されている、同義語の B<TIOCOUTQ> "
"を\n"
"使うこともできる。"

#. type: Plain text
#: build/C/man7/tcp.7:1329
msgid ""
"When a network error occurs, TCP tries to resend the packet.  If it doesn't "
"succeed after some time, either B<ETIMEDOUT> or the last received error on "
"this connection is reported."
msgstr ""
"ネットワークエラーが起こると、 TCP はパケットの再送を試みる。 何回かやっても"
"成功しなければ、この接続に対して B<ETIMEOUT> エラーか最後に受信したエラーが返"
"される。"

#. type: Plain text
#: build/C/man7/tcp.7:1340
msgid ""
"Some applications require a quicker error notification.  This can be enabled "
"with the B<IPPROTO_IP> level B<IP_RECVERR> socket option.  When this option "
"is enabled, all incoming errors are immediately passed to the user program.  "
"Use this option with care \\(em it makes TCP less tolerant to routing "
"changes and other normal network conditions."
msgstr ""
"アプリケーションによっては、もっと早くエラーを知らせてほしい場合がある。 これ"
"には B<IPPROTO_IP> レベルの B<IP_RECVERR> ソケットオプションを用いると良い。"
"このオプションが有効になっていると、 到着したエラーはすべてただちにユーザープ"
"ログラムに渡される。 このオプションは慎重に用いること \\(em ルーティングの変"
"更など、 通常ありうるネットワーク状態に対して TCP をより脆弱にしてしまう。"

#. type: TP
#: build/C/man7/tcp.7:1341
#, no-wrap
msgid "B<EAFNOTSUPPORT>"
msgstr "B<EAFNOTSUPPORT>"

#. type: Plain text
#: build/C/man7/tcp.7:1347
msgid "Passed socket address type in I<sin_family> was not B<AF_INET>."
msgstr ""
"I<sin_family> に渡されたソケットアドレスのタイプが B<AF_INET> ではなかった。"

#. type: Plain text
#: build/C/man7/tcp.7:1351
msgid ""
"The other end closed the socket unexpectedly or a read is executed on a shut "
"down socket."
msgstr ""
"接続先が予期しなかったかたちでソケットをクローズした。 またはシャットダウンさ"
"れたソケットに読み込みが実行された。"

#. type: TP
#: build/C/man7/tcp.7:1351
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man7/tcp.7:1354
msgid "The other end didn't acknowledge retransmitted data after some time."
msgstr "接続先が、何回かデータを再送しても反応しない。"

#. type: Plain text
#: build/C/man7/tcp.7:1358
msgid ""
"Any errors defined for B<ip>(7)  or the generic socket layer may also be "
"returned for TCP."
msgstr ""
"B<ip>(7)  で定義されているエラーや、ジェネリックなソケット層におけるエラーも "
"TCP に返されることがある。"

#. type: Plain text
#: build/C/man7/tcp.7:1365
msgid ""
"Support for Explicit Congestion Notification, zero-copy B<sendfile>(2), "
"reordering support and some SACK extensions (DSACK) were introduced in 2.4.  "
"Support for forward acknowledgement (FACK), TIME_WAIT recycling, and per-"
"connection keepalive socket options were introduced in 2.3."
msgstr ""
"Explicit Congestion Notification、zero-copy の B<sendfile>(2)、 並び替えのサ"
"ポート、SACK 拡張 (DSACK) などのサポートは 2.4 で導入された。 フォワード確認 "
"(FACK)、TIME_WAIT リサイクル、接続ごとの keepalive に対するソケットオプション"
"は 2.3 で導入された。"

#. type: Plain text
#: build/C/man7/tcp.7:1367
msgid "Not all errors are documented."
msgstr "まだ説明されていないエラーがある。"

#.  Only a single Linux kernel version is described
#.  Info for 2.2 was lost. Should be added again,
#.  or put into a separate page.
#.  .SH AUTHORS
#.  This man page was originally written by Andi Kleen.
#.  It was updated for 2.4 by Nivedita Singhvi with input from
#.  Alexey Kuznetsov's Documentation/networking/ip-sysctl.txt
#.  document.
#. type: Plain text
#: build/C/man7/tcp.7:1377
msgid "IPv6 is not described."
msgstr "IPv6 に関する記述がない。"

#. type: Plain text
#: build/C/man7/tcp.7:1389
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"

#. type: Plain text
#: build/C/man7/tcp.7:1394
msgid "RFC\\ 793 for the TCP specification."
msgstr "RFC\\ 793: TCP の仕様。"

#. type: Plain text
#: build/C/man7/tcp.7:1396
msgid ""
"RFC\\ 1122 for the TCP requirements and a description of the Nagle algorithm."
msgstr "RFC\\ 1122: TCP の要求事項と Nagle アルゴリズムの記述。"

#. type: Plain text
#: build/C/man7/tcp.7:1398
msgid "RFC\\ 1323 for TCP timestamp and window scaling options."
msgstr "RFC\\ 1323: TCP のタイムスタンプ・ウィンドウスケーリング各オプション。"

#. type: Plain text
#: build/C/man7/tcp.7:1400
msgid "RFC\\ 1337 for a description of TIME_WAIT assassination hazards."
msgstr "RFC\\ 1337: TIME_WAIT assassination hazard に関する説明。"

#. type: Plain text
#: build/C/man7/tcp.7:1402
msgid "RFC\\ 3168 for a description of Explicit Congestion Notification."
msgstr "RFC\\ 3168: Explicit Congestion Notification に関する説明。"

#. type: Plain text
#: build/C/man7/tcp.7:1404
msgid "RFC\\ 2581 for TCP congestion control algorithms."
msgstr "RFC\\ 2581: TCP 輻輳制御アルゴリズム。"

#. type: Plain text
#: build/C/man7/tcp.7:1406
msgid "RFC\\ 2018 and RFC\\ 2883 for SACK and extensions to SACK."
msgstr "RFC\\ 2018 と RFC\\ 2883: SACK とその拡張。"

#. type: TH
#: build/C/man7/udp.7:12
#, no-wrap
msgid "UDP"
msgstr "UDP"

#. type: Plain text
#: build/C/man7/udp.7:15
msgid "udp - User Datagram Protocol for IPv4"
msgstr "udp - IPv4 の ユーザーデータグラムプロトコル"

#. type: Plain text
#: build/C/man7/udp.7:21
msgid "B<#include E<lt>netinet/udp.hE<gt>>"
msgstr "B<#include E<lt>netinet/udp.hE<gt>>"

#. type: Plain text
#: build/C/man7/udp.7:23
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"

#. type: Plain text
#: build/C/man7/udp.7:29
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""
"これは RFC\\ 768 で記述されている User Datagram Protocol の実装である。 UDP "
"はコネクションレスの、信頼性の低いデータパケットサービスである。 パケットは到"
"着前に並び替えられたり複製されたりする。 UDP は転送エラーを検出するために"
"チェックサムを生成・チェックする。"

#. type: Plain text
#: build/C/man7/udp.7:58
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise, the socket layer will automatically assign "
"a free local port out of the range defined by I</proc/sys/net/ipv4/"
"ip_local_port_range> and bind the socket to B<INADDR_ANY>."
msgstr ""
"UDP ソケットが生成されるとき、 ローカルアドレスやリモートアドレスは指定されな"
"い。 正しい行き先アドレスを引数として B<sendto>(2)  や B<sendmsg>(2)  を呼べ"
"ば、データグラムはただちに送信される。 ソケットに対して B<connect>(2)  を呼ぶ"
"と、デフォルトの行き先アドレスが設定され、 B<send>(2)  や B<write>(2)  を使っ"
"て、行き先アドレスの指定なしにデータグラムを送信できるようになる。 この場合で"
"も、行き先アドレスを B<sendto>(2)  や B<sendmsg>(2)  に渡せば、デフォルト以外"
"のアドレスに送信可能である。 パケットを受信するために、まずソケットを "
"B<bind>(2)  を用いてローカルなアドレスにバインドさせることもできる。 そうでな"
"い場合は、ソケット層は自動的に I</proc/sys/net/ipv4/ip_local_port_range> で定"
"義されている範囲の外で空いているローカルなポートを割り当て、 ソケットを "
"B<INADDR_ANY> にバインドする。"

#. type: Plain text
#: build/C/man7/udp.7:66
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is "
"not supported."
msgstr ""
"受信動作はパケットを一つだけ返す。渡したバッファーよりもパケットが 小さけれ"
"ば、そのパケットの大きさのデータだけが返される。 逆にバッファーよりも大きい場"
"合はパケットは丸められ、 B<MSG_TRUNC> フラグがセットされる。 B<MSG_WAITALL> "
"はサポートしていない。"

#. type: Plain text
#: build/C/man7/udp.7:75
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are processed by the kernel only when the appropriate I</"
"proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""
"IP オプションは、 B<ip>(7)  に記述されているソケットオプションを用いて読み書"
"きできる。 これらは適切な I</proc> パラメーターが有効な場合に限ってカーネルに"
"よって処理される (しかし無効になっている場合でもユーザーには渡される)。 "
"B<ip>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/udp.7:80
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is sent only to that "
"interface."
msgstr ""
"B<MSG_DONTROUTE> フラグが送信時にセットされている場合には、 行き先アドレスは"
"ローカルなインターフェースアドレスから 参照できなければならない。パケットはそ"
"のインターフェースにしか送られない。"

#. type: Plain text
#: build/C/man7/udp.7:98
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"デフォルトでは、Linux の UDP は Path MTU Discovery を行う。 つまり、カーネル"
"は特定の宛先 IP アドレスの MTU (Maximum Transmission Unit; 最大転送単位) を記"
"録し、UDP パケットの書き込みが MTU を超えた場合 B<EMSGSIZE> を返す。 "
"B<EMSGSIZE> を返された場合、アプリケーションはパケットサイズを小さくすべきで"
"ある。 ソケットオプション B<IP_MTU_DISCOVER> または I</proc/sys/net/ipv4/"
"ip_no_pmtu_disc> ファイルを使って Path MTU Discovery を無効にすることもでき"
"る (詳細は B<ip>(7)  を参照)。 Path MTU Discovery を無効にした場合は、パケッ"
"トサイズが インターフェースの MTU よりも大きいと UDP はそのパケットを フラグ"
"メント化して送出する。 しかしながら、性能と信頼性の理由から Path MTU "
"Discovery を 無効にするのは推奨できない。"

#. type: Plain text
#: build/C/man7/udp.7:103
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""
"UDP は IPv4 の I<sockaddr_in> アドレスフォーマットを用いる。これは B<ip>(7)  "
"に記述されている。"

#. type: Plain text
#: build/C/man7/udp.7:114
msgid ""
"All fatal errors will be passed to the user as an error return even when the "
"socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected.  "
"Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""
"致命的なエラーは、たとえソケットが接続されていなくても、 すべてエラー戻り値と"
"してユーザーに渡される。 これにはネットワークから受け取る非同期エラーも含まれ"
"る。 同じソケットを使って送信した昔のパケットに関するエラーを受け取るかもしれ"
"ない。 この振る舞いは他の BSD ソケットの実装の多くとは異なる。 これらではソ"
"ケットが接続されていない場合はエラーを全く返さない。 Linux の振る舞いは B<RFC"
"\\ 1122> での指定に従ったものである。"

#. type: Plain text
#: build/C/man7/udp.7:128
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""
"Linux 2.0 と 2.2 では、古いコードとの互換性のために、 B<SO_BSDCOMPAT> "
"B<SOL_SOCKET> オプションを設定すれば、ソケットが接続されている 場合に限ってリ"
"モートのエラーを受信するようにできた (B<EPROTO> と B<EMSGSIZE> を除く)。 ロー"
"カルで生成されたエラーは常に渡される。 このソケットオプションのサポートはそれ"
"以降のバージョンの Linux で 削除された。詳細は B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man7/udp.7:137
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""
"B<IP_RECVERR> オプションが有効になっていると、 すべてのエラーはソケットのエ"
"ラーキューに保存される。 これは B<MSG_ERRQUEUE> フラグをセットして "
"B<recvmsg>(2)  を呼べば受信できる。"

#. type: Plain text
#: build/C/man7/udp.7:140
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>."
msgstr ""
"システム全体の UDP パラメーター設定には、 I</proc/sys/net/ipv4/> ディレクトリ"
"内のファイルの読み書きでアクセスできる。"

#. type: TP
#: build/C/man7/udp.7:140
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr "I<udp_mem> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:144
msgid ""
"This is a vector of three integers governing the number of pages allowed for "
"queueing by all UDP sockets."
msgstr ""
"これは 3 つの整数からなるベクトル値で、 UDP の全ソケットのキューで利用可能な"
"ページ数を制御する。"

#. type: Plain text
#: build/C/man7/udp.7:151
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""
"このページ数より少なければ、UDP はそのメモリー使用に関して 干渉されない。 "
"UDP に割り当てられたメモリー総量がこの値を超過すると、 UDP はメモリー使用量を"
"調整し始める。"

#. type: Plain text
#: build/C/man7/udp.7:157
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see B<tcp>(7))."
msgstr ""
"この値は I<tcp_mem> の形式 (B<tcp>(7)  参照) と合わせるために導入された"

#. type: Plain text
#: build/C/man7/udp.7:160
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr "UDP の全ソケットのキューで利用可能なページ数。"

#. type: Plain text
#: build/C/man7/udp.7:164
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""
"これらの 3 つの値のデフォルト値は、 ブート時に利用可能なメモリー総量から計算"
"される。"

#. type: TP
#: build/C/man7/udp.7:164
#, no-wrap
msgid "I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_rmem_min> (integer; デフォルト値: PAGE_SIZE; Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:171
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"メモリー使用量の調整中に、UDP ソケットが使用できる受信バッファーの最小値 (バ"
"イト単位)。 UDP の全ソケットのページ使用量の合計が I<udp_mem> pressure を超過"
"している場合であっても、 各 UDP ソケットはデータの受信にこのサイズ分だけは使"
"用することができる。"

#. type: TP
#: build/C/man7/udp.7:171
#, no-wrap
msgid "I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_wmem_min> (integer; デフォルト値: PAGE_SIZE; Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/udp.7:178
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"メモリー使用量の調整中に、UDP ソケットが使用できる送信バッファーの最小値 (バ"
"イト単位)。 UDP の全ソケットのページ使用量の合計が I<udp_mem> pressure を超過"
"している場合であっても、 各 UDP ソケットはデータの送信にこのサイズ分だけは使"
"用することができる。"

#. type: Plain text
#: build/C/man7/udp.7:189
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""
"UDP ソケットオプションを設定または取得するには、 取得には B<getsockopt>(2)  "
"を、設定には B<setsockopt>(2)  をオプションレベル引数に B<IPPROTO_UDP> を指定"
"して呼び出す。 注釈がない限り、 I<optval> は I<int> へのポインターである。"

#. type: Plain text
#: build/C/man7/udp.7:194
msgid ""
"Following is a list of UDP-specific socket options.  For details of some "
"other socket options that are also applicable for UDP sockets, see "
"B<socket>(7)."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:194
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr "B<UDP_CORK> (Linux 2.5.44 以降)"

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.      UDP_ENCAP_ESPINUDP_NON_IKE draft-ietf-ipsec-nat-t-ike-00/01
#.      UDP_ENCAP_ESPINUDP draft-ietf-ipsec-udp-encaps-06
#.      UDP_ENCAP_L2TPINUDP rfc2661
#.  FIXME Document UDP_NO_CHECK6_TX and UDP_NO_CHECK6_RX, added in Linux 3.16
#. type: Plain text
#: build/C/man7/udp.7:207
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""
"このオプションが指定されると、このソケットの全てのデータ出力は 一つのデータグ"
"ラムに蓄積され、このオプションが無効化された時に 送信される。 このオプション"
"は移植性を考慮したコードでは用いるべきではない。"

#. type: Plain text
#: build/C/man7/udp.7:211
msgid "These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr ""
"以下に示す ioctl は B<ioctl>(2)  を使ってアクセスできる。 正しい文法は以下の"
"通り。"

#. type: Plain text
#: build/C/man7/udp.7:216
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: TP
#: build/C/man7/udp.7:218
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr "B<FIONREAD> (B<SIOCINQ>)"

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: build/C/man7/udp.7:236
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending.  "
"B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""
"整数へのポインターを引数に取り、そのポインターに、次の処理待ちのデータグラ"
"ムの\n"
"サイズをバイト単位で返す。処理待ちのデータグラムがない場合は 0 を返す。\n"
"B<警告>: B<FIONREAD> を使った場合、処理待ちのデータグラムがない場合と、\n"
"次の処理待ちデータグラムが 0 バイトのデータの場合を区別することができない。\n"
"この両者を区別したい場合は、B<select>(2), B<poll>(2), B<epoll>(7) \n"
"を使う方が安全である。"

#. type: TP
#: build/C/man7/udp.7:236
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr "B<TIOCOUTQ> (B<SIOCOUTQ>)"

#. type: Plain text
#: build/C/man7/udp.7:240
msgid ""
"Returns the number of data bytes in the local send queue.  Supported only "
"with Linux 2.4 and above."
msgstr ""
"ローカル送信キューにあるデータサイズをバイト単位で返す。 Linux 2.4 以上でのみ"
"対応している。"

#. type: Plain text
#: build/C/man7/udp.7:246
msgid ""
"In addition, all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""
"さらに、 B<ip>(7)  と B<socket>(7)  で述べられている全ての ioctl も対応してい"
"る。"

#. type: Plain text
#: build/C/man7/udp.7:252
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""
"B<socket>(7)  や B<ip>(7)  に記述されている全てのエラーが、 UDP ソケットの送"
"受信で返される可能性がある。"

#. type: TP
#: build/C/man7/udp.7:252 build/C/man7/unix.7:697
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: build/C/man7/udp.7:256
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""
"行き先アドレスに関連づけられている受信者がいない。 これは以前のパケットがその"
"パケットを 上書き送信してしまっているからであることが多い。"

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/udp.7:261
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr "B<IP_RECVERR> は Linux 2.2 の新しい機能である。"

#. type: Plain text
#: build/C/man7/udp.7:266
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"

#. type: Plain text
#: build/C/man7/udp.7:271
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr "RFC\\ 768 : User Datagram Protocol"

#. type: Plain text
#: build/C/man7/udp.7:273
msgid "RFC\\ 1122 for the host requirements."
msgstr "RFC\\ 1122 : ホストの必要条件"

#. type: Plain text
#: build/C/man7/udp.7:275
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr "RFC\\ 1191 : path MTU discovery の記述"

#. type: TH
#: build/C/man7/udplite.7:27
#, no-wrap
msgid "UDPLITE"
msgstr "UDPLITE"

#. type: Plain text
#: build/C/man7/udplite.7:30
msgid "udplite - Lightweight User Datagram Protocol"
msgstr "udplite - 軽量なユーザーデータグラムプロトコル"

#. type: Plain text
#: build/C/man7/udplite.7:38
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"

#. type: Plain text
#: build/C/man7/udplite.7:41
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol (UDP-"
"Lite), as described in RFC\\ 3828."
msgstr ""
"これは RFC\\ 3828 に書かれている軽量なユーザーデータグラムプロトコル "
"(Lightweight User Datagram Protocol; UDP-Lite) の実装である。"

#. type: Plain text
#: build/C/man7/udplite.7:47
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""
"UDP-Lite は UDP (RFC\\ 768) の拡張で、可変長のチェックサムをサポートしてい"
"る。 このプロトコルが効果を発揮するのは、少しだけ壊れたデータグラムがあった場"
"合に、 そのデータグラムを下位レイヤーのプロトコルに廃棄させるのではなく、 そ"
"れを利用することができるような、ある種のマルチメディア転送においてである。"

#. type: Plain text
#: build/C/man7/udplite.7:53
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  "
"option.  If this option is not set, the only difference from UDP is in using "
"a different IP protocol identifier (IANA number 136)."
msgstr ""
"可変長のチェックサムの対象範囲は B<setsockopt>(2)  オプション経由で設定され"
"る。 このオプションが設定されていない場合、UDP と異なるのは 違う IP プロトコ"
"ル識別子 (IANA 番号 136) を使用する点だけである。"

#. type: Plain text
#: build/C/man7/udplite.7:58
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7)\\(emthat is, it "
"shares the same API and API behavior, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""
"UDP-Lite の実装は B<udp>(7)  の完全な拡張、すなわち API と API の動作は同じで"
"ある。 これに加えて、2 つのソケットオプションがチェックサムの対象範囲を 制御"
"するために提供されている。"

#. type: Plain text
#: build/C/man7/udplite.7:67
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""
"UDP-Litev4 は B<ip>(7)  で説明されている I<sockaddr_in> アドレスを使用する。 "
"UDP-Litev6 は B<ipv6>(7)  で説明されている I<sockaddr_in6> アドレスを使用す"
"る。"

#. type: Plain text
#: build/C/man7/udplite.7:80
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""
"UDP-Lite のソケットオプションを設定/取得するには、 オプションレベル引数に "
"B<IPPROTO_UDPLITE> を指定して、取得時には B<getsockopt>(2)  を、設定時には "
"B<setsockopt>(2)  を呼び出す。さらに、全ての B<IPPROTO_UDP> のソケットオプ"
"ションが UDP-Lite ソケットでも使用できる。 詳細は B<udp>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man7/udplite.7:82
msgid "The following two options are specific to UDP-Lite."
msgstr "以下の 2 つが UDP-Lite に固有のオプションである。"

#. type: TP
#: build/C/man7/udplite.7:82
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr "B<UDPLITE_SEND_CSCOV>"

#. type: Plain text
#: build/C/man7/udplite.7:87
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""
"このオプションは送信側のチェックサムの対象範囲を設定する。 I<int> 型を引数"
"として取り、設定可能な値の範囲は 0 から 2^16-1 までである。"

#. type: Plain text
#: build/C/man7/udplite.7:91
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage "
"of 8."
msgstr ""
"値 0 はデータグラム全体が常にチェックサムの対象となることを意味する。 値 1〜"
"7 は不正であり (RFC\\ 3828 の 3.1 章)、範囲の設定として最小値である 8 に切り"
"上げられる。"

#. type: Plain text
#: build/C/man7/udplite.7:97
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""
"IPv6 の jumbograms (巨大なデータグラム; RFC\\ 2675) の場合には、 UDP-Litev6 "
"のチェックサムの対象範囲は、RFC\\ 3828 の 3.5 章にあるように、 先頭から "
"2^16-1 オクテットまでに限定される。 そのため、それより大きな値は 2^16-1 に"
"黙って切り詰められる。 現在の対象範囲の値を知りたければ、いつでも "
"B<getsockopt>(2)  を使って値を問い合わせることができる。"

#. type: TP
#: build/C/man7/udplite.7:97
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr "B<UDPLITE_RECV_CSCOV>"

#. type: Plain text
#: build/C/man7/udplite.7:108
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable "
"traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have "
"a coverage I<less> than the specified coverage value."
msgstr ""
"これは受信側のチェックサムの対象範囲を設定するもので、 使用される引数形式と"
"値の範囲は B<UDPLITE_SEND_CSCOV> と同じである。 このオプションは、部分的な"
"チェックサム対象範囲を持つトラフィックを 有効にするのに必要なわけではなく、ト"
"ラフィックフィルターとして機能する。 このオプションが有効にすると、カーネルは"
"指定されたチェックサム対象範囲 よりも「短かい」対象範囲を持つパケットを全て廃"
"棄するようになる。"

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: build/C/man7/udplite.7:121
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in "
"the system log."
msgstr ""
"B<UDPLITE_RECV_CSCOV> の値が実際のパケットのチェックサム対象範囲よりも大きい"
"場合、 受信したパケットは黙って廃棄される。 ただし、システムログに対して警告"
"メッセージが生成されるかもしれない。"

#. type: Plain text
#: build/C/man7/udplite.7:126
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add "
"further errors."
msgstr ""
"B<udp>(7)  について書かれている全てのエラーは返る可能性がある。 UDP-Lite 自体"
"は新たなエラーは追加していない。"

#. type: TP
#: build/C/man7/udplite.7:127
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr "I</proc/net/snmp>"

#. type: Plain text
#: build/C/man7/udplite.7:130
msgid "Basic UDP-Litev4 statistics counters."
msgstr "UDP-Litev4 の基本的な統計情報カウンター。"

#. type: TP
#: build/C/man7/udplite.7:130
#, no-wrap
msgid "I</proc/net/snmp6>"
msgstr "I</proc/net/snmp6>"

#. type: Plain text
#: build/C/man7/udplite.7:133
msgid "Basic UDP-Litev6 statistics counters."
msgstr "UDP-Litev6 の基本的な統計情報カウンター。"

#. type: Plain text
#: build/C/man7/udplite.7:135
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr "UDP-Litev4/v6 は Linux 2.6.20 で初めて登場した。"

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: build/C/man7/udplite.7:138
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr "glibc によるサポートがない場合は、以下の定義を行う必要がある。"

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: build/C/man7/udplite.7:145
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"

#. type: Plain text
#: build/C/man7/udplite.7:152
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"

#. type: Plain text
#: build/C/man7/udplite.7:154
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."
msgstr "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."

#. type: Plain text
#: build/C/man7/udplite.7:157
msgid "I<Documentation/networking/udplite.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/networking/udplite.txt>"

#. type: TH
#: build/C/man7/unix.7:20
#, no-wrap
msgid "UNIX"
msgstr "UNIX"

#. type: Plain text
#: build/C/man7/unix.7:23
msgid "unix - sockets for local interprocess communication"
msgstr "unix - ローカルな プロセス間通信用のソケット"

#. type: Plain text
#: build/C/man7/unix.7:27
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr "B<#include E<lt>sys/un.hE<gt>>"

#. type: Plain text
#: build/C/man7/unix.7:29
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"

#. type: Plain text
#: build/C/man7/unix.7:31
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"

#. type: Plain text
#: build/C/man7/unix.7:42
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""
"B<AF_UNIX> (B<AF_LOCAL> とも言われる) ソケットファミリーは、同じマシン上で\n"
"プロセス同士が 効率的に通信するために用いられる。伝統的に、UNIX ドメイン\n"
"ソケットは、名前なしにもできるし、 (ソケット型であると印のついた) ファイル\n"
"システムのパス名に 結び付けることもできる。さらに Linux では、ファイル\n"
"システムに依存しない抽象名前空間 (abstract namespace) もサポートしている。"

#. type: Plain text
#: build/C/man7/unix.7:55
#, fuzzy
#| msgid ""
#| "Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a stream-"
#| "oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
#| "preserves message boundaries (as on most UNIX implementations, UNIX "
#| "domain datagram sockets are always reliable and don't reorder datagrams); "
#| "and (since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a connection-oriented "
#| "socket that preserves message boundaries and delivers messages in the "
#| "order that they were sent."
msgid ""
"Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a stream-"
"oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
"preserves message boundaries (as on most UNIX implementations, UNIX domain "
"datagram sockets are always reliable and don't reorder datagrams); and "
"(since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a sequenced-packet socket that "
"is connection-oriented, preserves message boundaries, and delivers messages "
"in the order that they were sent."
msgstr ""
"UNIX ドメインに指定できるソケットタイプは以下の通りである。 B<SOCK_STREAM> "
"は、 ストリーム指向のソケットで有効である。 B<SOCK_DGRAM> は、 メッセージ境界"
"を保存するデータグラム指向のソケットで有効である (ほとんどの UNIX の実装で"
"は、 UNIX ドメインデータグラムソケットは常に信頼でき、 データグラムの並び替え"
"は行わない)。 B<SOCK_SEQPACKET> は、 メッセージ境界を保存し送信された順序で"
"メッセージを届ける接続指向ソケットで有効である (Linux 2.6.4 以降で利用でき"
"る)。"

#. type: Plain text
#: build/C/man7/unix.7:58
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""
"UNIX ドメインソケットでは、補助データを使って ファイルディスクリプターや\n"
"プロセスの信任状 (credential) を 送受信することもできる。"

#. type: Plain text
#: build/C/man7/unix.7:60
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr "UNIX ドメインソケットのアドレスは以下の構造体で表現される。"

#.  #define UNIX_PATH_MAX    108
#. type: Plain text
#: build/C/man7/unix.7:69
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* Pathname */\n"
"};\n"
msgstr ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* Pathname */\n"
"};\n"

#. type: Plain text
#: build/C/man7/unix.7:79
#, fuzzy
#| msgid "The I<sun_family> field always contains B<AF_UNIX>."
msgid ""
"The I<sun_family> field always contains B<AF_UNIX>.  On Linux, I<sun_path> "
"is 108 bytes in size; see also NOTES, below."
msgstr "I<sun_family> フィールドには必ず B<AF_UNIX> が入っている。"

#. type: Plain text
#: build/C/man7/unix.7:95
msgid ""
"Various systems calls (for example, B<bind>(2), B<connect>(2), and "
"B<sendto>(2))  take a I<sockaddr_un> argument as input.  Some other system "
"calls (for example, B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), "
"and B<accept>(2))  return an argument of this type."
msgstr ""
"様々なシステムコール (例えば B<bind>(2), B<connect>(2), B<sendto>(2)) は入力"
"として I<sockaddr_un> 引数を取る。 他のいくつかのシステムコール (例えば "
"B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), B<accept>(2)) はこの型"
"の引数を返す。"

#. type: Plain text
#: build/C/man7/unix.7:99
msgid ""
"Three types of address are distinguished in the I<sockaddr_un> structure:"
msgstr "I<sockaddr_un> 構造体では 3 種類のアドレスが区別される。"

#. type: Plain text
#: build/C/man7/unix.7:107
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated "
"filesystem pathname using B<bind>(2).  When the address of a pathname socket "
"is returned (by one of the system calls noted above), its length is"
msgstr ""
"I<pathname (パス名)>: B<bind>(2) を使って、UNIX ドメインソケットを、 ヌル終端"
"されたファイルシステム上のパス名に結び付けることができる。 (上述のいずれかの"
"システムコールにより) ソケットのアドレスが返される際、 その長さは"

#. type: Plain text
#: build/C/man7/unix.7:109
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"

#. type: Plain text
#: build/C/man7/unix.7:122
msgid ""
"and I<sun_path> contains the null-terminated pathname.  (On Linux, the above "
"B<offsetof>()  expression equates to the same value as "
"I<sizeof(sa_family_t)>, but some other implementations include other fields "
"before I<sun_path>, so the B<offsetof>()  expression more portably describes "
"the size of the address structure.)"
msgstr ""
"であり、 I<sun_path> にはヌル終端されたパス名が格納される。 (Linux では、上記"
"の B<offsetof>() 式は I<sizeof(sa_family_t)> の値と同じだが、 他の実装では "
"I<sun_path> の前に他のフィールドが含まれる場合もある。 そのため、 "
"B<offsetof>() 式を使う方がより移植性のある方法でアドレス構造体のサイズを知る"
"ことができる。)"

#. type: Plain text
#: build/C/man7/unix.7:124
msgid "For further details of pathname sockets, see below."
msgstr "パス名ソケットの詳細については、後で説明する。"

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: build/C/man7/unix.7:140
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned, its length is I<sizeof(sa_family_t)>, and I<sun_path> should not "
"be inspected."
msgstr ""
"I<unnamed (名前なし)>: B<bind>(2)  を使ってパス名に結び付けることができないス"
"トリーム型のソケットは 名前を持たない。同様に、 B<socketpair>(2)  で作成され"
"る 2 つのソケットも名前を持たない。 名前なしのソケットのアドレスを返す際に"
"は、 その長さは I<sizeof(sa_family_t)> であり、 I<sun_path> は検査すべきでは"
"ない。"

#. type: Plain text
#: build/C/man7/unix.7:162
msgid ""
"I<abstract>: an abstract socket address is distinguished (from a pathname "
"socket)  by the fact that I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  "
"The socket's address in this namespace is given by the additional bytes in "
"I<sun_path> that are covered by the specified length of the address "
"structure.  (Null bytes in the name have no special significance.)  The name "
"has no connection with filesystem pathnames.  When the address of an "
"abstract socket is returned, the returned I<addrlen> is greater than "
"I<sizeof(sa_family_t)> (i.e., greater than 2), and the name of the socket is "
"contained in the first I<(addrlen - sizeof(sa_family_t))> bytes of "
"I<sun_path>."
msgstr "I<abstract (抽象)>: 抽象ソケットアドレスは、 I<sun_path[0]> がヌルバイト (\\(aq\\e0\\(aq) であることから (パス名ソケットから) 区別できる。 この名前空間におけるソケットのアドレスは、 I<sun_path> の残りのバイトの、 アドレス構造体の指定された長さの範囲で表される (名前中のヌルバイトには特別な意味はない)。 この名前はファイルシステムのパス名とは何の関係もない。 抽象ソケットのアドレスを返される際には、 返される I<addrlen> は I<sizeof(sa_family_t)> より大きく (つまり 2 より大きく)、 ソケットの名前は I<sun_path> の最初の I<(addrlen - sizeof(sa_family_t))> バイトに格納される。"

#. type: SS
#: build/C/man7/unix.7:162
#, no-wrap
msgid "Pathname sockets"
msgstr "パス名ソケット"

#. type: Plain text
#: build/C/man7/unix.7:165
msgid ""
"When binding a socket to a pathname, a few rules should be observed for "
"maximum portability and ease of coding:"
msgstr ""
"ソケットにパス名を結びつける際に、 最大限の移植性を持たせ、コーディングを簡単"
"にするためのルールがいくつかある。"

#. type: Plain text
#: build/C/man7/unix.7:169
msgid "The pathname in I<sun_path> should be null-terminated."
msgstr "I<sun_path> のパス名はヌル終端すべきである。"

#. type: Plain text
#: build/C/man7/unix.7:173
msgid ""
"The length of the pathname, including the terminating null byte, should not "
"exceed the size of I<sun_path>."
msgstr ""
"終端のヌルバイトを含めたパス名の長さは I<sun_path> の大きさを超えないようにす"
"べきである。"

#. type: Plain text
#: build/C/man7/unix.7:179
msgid ""
"The I<addrlen> argument that describes the enclosing I<sockaddr_un> "
"structure should have a value of at least:"
msgstr ""
"I<sockaddr_un> 構造体の終わりを示す I<addrlen> 引数は最低でも以下の値を持つ"
"べきである。"

#. type: Plain text
#: build/C/man7/unix.7:182
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"

#. type: Plain text
#: build/C/man7/unix.7:188
msgid ""
"or, more simply, I<addrlen> can be specified as I<sizeof(struct "
"sockaddr_un)>."
msgstr ""
"もしくは、もっと簡単には、 I<addrlen> に I<sizeof(struct sockaddr_un)> を指定"
"することもできる。"

#.  Linux does this, including for the case where the supplied path
#.  is 108 bytes
#. type: Plain text
#: build/C/man7/unix.7:196
msgid ""
"There is some variation in how implementations handle UNIX domain socket "
"addresses that do not follow the above rules.  For example, some (but not "
"all) implementations append a null terminator if none is present in the "
"supplied I<sun_path>."
msgstr ""
"UNIX ドメインソケットアドレスの扱いが上記のルールに従っていない実装もいくつか"
"ある。 (全部ではないが) いくつかの実装では、 I<sun_path> に文字列終端の NULL "
"がなかった場合に終端の NULL が追加される。"

#.  HP-UX
#.  Modern BSDs generally have 104, Tru64 and AIX have 104,
#.  Solaris and Irix have 108
#. type: Plain text
#: build/C/man7/unix.7:205
msgid ""
"When coding portable applications, keep in mind that some implementations "
"have I<sun_path> as short as 92 bytes."
msgstr ""
"移植性があるアプリケーションを作成する際には、 いくつかの実装では "
"I<sun_path> は 92 バイトしかないという点にも留意しておくとよい。"

#. type: Plain text
#: build/C/man7/unix.7:224
msgid ""
"Various system calls (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2))  return socket address structures.  When applied to UNIX "
"domain sockets, the value-result I<addrlen> argument supplied to the call "
"should be initialized as above.  Upon return, the argument is set to "
"indicate the I<actual> size of the address structure.  The caller should "
"check the value returned in this argument: if the output value exceeds the "
"input value, then there is no guarantee that a null terminator is present in "
"I<sun_path>.  (See BUGS.)"
msgstr ""
"様々なシステムコール (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2)) がソケットアドレス構造体を返す。 これらのシステムコールが "
"UNIX ドメインソケットに対して呼ばれた際には、 これらの呼び出しに渡す "
"I<addrlen> 引数は上記の説明のように初期化すべきである。 リターン時には、こ"
"の引数にはアドレス構造体の「実際の」サイズが設定される。 呼び出し側ではこの"
"引数で返された値を確認すべきである。 返された値が入力値よりも大きい場合、 "
"I<sun_path> に終端の NULL バイトが存在する保証はない (「バグ」を参照)。"

#. type: SS
#: build/C/man7/unix.7:224
#, no-wrap
msgid "Pathname socket ownership and permissions"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:229
msgid ""
"In the Linux implementation, pathname sockets honor the permissions of the "
"directory they are in.  Creation of a new socket fails if the process does "
"not have write and search (execute) permission on the directory in which the "
"socket is created."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:239
msgid ""
"On Linux, connecting to a stream socket object requires write permission on "
"that socket; sending a datagram to a datagram socket likewise requires write "
"permission on that socket.  POSIX does not make any statement about the "
"effect of the permissions on a socket file, and on some systems (e.g., older "
"BSDs), the socket permissions are ignored.  Portable programs should not "
"rely on this feature for security."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:245
msgid ""
"When creating a new socket, the owner and group of the socket file are set "
"according to the usual rules.  The socket file has all permissions enabled, "
"other than those that are turned off by the process B<umask>(2)."
msgstr ""

#.  However, fchown() and fchmod() do not seem to have an effect
#. type: Plain text
#: build/C/man7/unix.7:252
msgid ""
"The owner, group, and permissions of a pathname socket can be changed (using "
"B<chown>(2)  and B<chmod>(2))."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:252
#, no-wrap
msgid "Abstract sockets"
msgstr "抽象ソケット"

#. type: Plain text
#: build/C/man7/unix.7:262
msgid ""
"Socket permissions have no meaning for abstract sockets: the process "
"B<umask>(2)  has no effect when binding an abstract socket, and changing the "
"ownership and permissions of the object (via B<fchown>(2)  and "
"B<fchmod>(2))  has no effect on the accessibility of the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:265
msgid ""
"Abstract sockets automatically disappear when all open references to the "
"socket are closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:268
msgid "The abstract socket namespace is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:281
msgid ""
"For historical reasons, these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""
"歴史的な理由により、これらのオプションは たとえ B<AF_UNIX> 固有のオプションで"
"あっても B<SOL_SOCKET> 型で指定する。 ソケットファミリーとして B<SOL_SOCKET> "
"を指定すると、 B<setsockopt>(2)  でオプションが設定でき、 B<getsockopt>(2)  "
"で取得ができる。"

#. type: TP
#: build/C/man7/unix.7:281
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
#: build/C/man7/unix.7:293
msgid ""
"Enabling this socket option causes receipt of the credentials of the sending "
"process in an B<SCM_CREDENTIALS ancillary> message in each subsequently "
"received message.  The returned credentials are those specified by the "
"sender using B<SCM_CREDENTIALS>, or a default that includes the sender's "
"PID, real user ID, and real group ID, if the sender did not specify "
"B<SCM_CREDENTIALS> ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:296
msgid ""
"When this option is set and the socket is not yet connected, a unique name "
"in the abstract namespace will be generated automatically."
msgstr "このオプションがセットされていて、まだソケットが接続されていないと、抽象名前空間に他と重ならない名前が自動的に生成される。"

#. type: TP
#: build/C/man7/unix.7:302
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr "B<SO_PASSSEC>"

#. type: Plain text
#: build/C/man7/unix.7:308
msgid ""
"Enables receiving of the SELinux security label of the peer socket in an "
"ancillary message of type B<SCM_SECURITY> (see below)."
msgstr ""

#.  commit 877ce7c1b3afd69a9b1caeb1b9964c992641f52a
#.  commit 37a9a8df8ce9de6ea73349c9ac8bdf6ba4ec4f70
#. type: Plain text
#: build/C/man7/unix.7:323
msgid ""
"The B<SO_PASSSEC> option is supported for UNIX domain datagram sockets since "
"Linux 2.6.18; support for UNIX domain stream sockets was added in Linux 4.2."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:323
#, no-wrap
msgid "B<SO_PEEK_OFF>"
msgstr "B<SO_PEEK_OFF>"

#. type: Plain text
#: build/C/man7/unix.7:327
msgid "See B<socket>(7)."
msgstr "B<socket>(7) を参照。"

#. type: TP
#: build/C/man7/unix.7:327
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: build/C/man7/unix.7:336
msgid ""
"This read-only socket option returns the credentials of the peer process "
"connected to this socket.  The returned credentials are those that were in "
"effect at the time of the call to B<connect>(2)  or B<socketpair>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:345
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a I<ucred> structure; "
"define the B<_GNU_SOURCE> feature test macro to obtain the definition of "
"that structure from I<E<lt>sys/socket.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:352
msgid ""
"The use of this option is possible only for connected B<AF_UNIX> stream "
"sockets and for B<AF_UNIX> stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:352
#, no-wrap
msgid "B<SO_PEERSEC>"
msgstr "B<SO_PEERSEC>"

#. type: Plain text
#: build/C/man7/unix.7:359
msgid ""
"This read-only socket option returns the security context of the peer socket "
"connected to this socket.  By default, this will be the same as the security "
"context of the process that created the peer socket unless overridden by the "
"policy or by a process with the required permissions."
msgstr ""

#.  commit 0b811db2cb2aabc910e53d34ebb95a15997c33e7
#. type: Plain text
#: build/C/man7/unix.7:397
msgid ""
"The use of this option for sockets in the B<AF_UNIX> address family is "
"supported since Linux 2.6.2 for connected stream sockets, and since Linux "
"4.18 also for stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:397
#, no-wrap
msgid "Autobind feature"
msgstr "自動バインド (autobind) 機能"

#.  i.e., sizeof(short)
#. type: Plain text
#: build/C/man7/unix.7:417
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""
"B<bind>(2) 呼び出しで I<sizeof(sa_family_t)> として I<addrlen> を指定する"
"か、\n"
"アドレスに明示的にバインドされていないソケットに対して\n"
"B<SO_PASSCRED> ソケットオプションが指定されていた場合、\n"
"そのソケットは抽象アドレスに自動的にバインドされる。\n"
"このアドレスは、1 個のヌルバイトの後に、文字集合 I<[0-9a-f]> のバイトが\n"
"5 個続く形式である。したがって、自動的にバインドされるアドレス数には\n"
"2^20 個という上限が存在する。\n"
"(Linux 2.1.15 以降で、自動バインド機能が追加されたときには、\n"
"8 バイトが使われており、自動バインドアドレス数の上限は 2^32 であった。\n"
"Linux 2.3.15 で 5 バイトに変更された。)"

#. type: Plain text
#: build/C/man7/unix.7:420
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""
"この節では、Linux の UNIX ドメインソケットでの、ドメイン固有の詳細仕様と\n"
"ソケット API でサポートされていない機能について説明する。"

#. type: Plain text
#: build/C/man7/unix.7:428
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""
"UNIX ドメインソケットでは、帯域外データ (out-of-band data) の 送信\n"
"(B<send>(2) と B<recv>(2) の B<MSG_OOB> フラグ) はサポートされていない。"

#. type: Plain text
#: build/C/man7/unix.7:433
msgid ""
"The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""
"B<send>(2) B<MSG_MORE> フラグは UNIX ドメインソケットではサポートされていな"
"い。"

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: build/C/man7/unix.7:443
msgid ""
"Before Linux 3.4, the use of B<MSG_TRUNC> in the I<flags> argument of "
"B<recv>(2)  was not supported by UNIX domain sockets."
msgstr "Linux 3.4 より前では、 B<recv>(2) の I<flags> 引数での B<MSG_TRUNC> の使用は UNIX ドメインソケットではサポートされていなかった。"

#. type: Plain text
#: build/C/man7/unix.7:455
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""
"B<SO_SNDBUF> ソケットオプションは UNIX ドメインソケットで効果を持つが、\n"
"B<SO_RCVBUF> は効果がない。 データグラムソケットでは、 B<SO_SNDBUF> の値が\n"
"出力データグラムの上限サイズとなる。 実際の上限値は、 B<SO_SNDBUF> オプショ"
"ン\n"
"として設定された値の 2倍 (B<socket>(7) 参照) からオーバヘッドとして使用され"
"る\n"
"32 バイトを引いた値となる。"

#. type: SS
#: build/C/man7/unix.7:455
#, no-wrap
msgid "Ancillary messages"
msgstr "補助メッセージ"

#. type: Plain text
#: build/C/man7/unix.7:477
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons, the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them, set the I<cmsg_level> field of the struct "
"I<cmsghdr> to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For "
"more information, see B<cmsg>(3)."
msgstr ""
"補助データを送受するには、 B<sendmsg>(2)  や B<recvmsg>(2)  を使用する。 歴史"
"的な理由により、以下に示す補助メッセージの型は たとえ B<AF_UNIX> 固有のもので"
"あっても B<SOL_SOCKET> 型で指定する。 これらを送るには、構造体 I<cmsghdr> の "
"I<cmsg_level> フィールドに B<SOL_SOCKET> をセットし、 I<cmsg_type> フィールド"
"にタイプをセットする。 詳細は B<cmsg>(3)  を見よ。"

#. type: TP
#: build/C/man7/unix.7:477
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr "B<SCM_RIGHTS>"

#. type: Plain text
#: build/C/man7/unix.7:481
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors."
msgstr "他のプロセスでオープンされたファイルディスクリプターのセットを送受信する。 データ部分にファイルディスクリプターの整数配列が入っている。"

#. type: Plain text
#: build/C/man7/unix.7:492
msgid ""
"Commonly, this operation is referred to as \"passing a file descriptor\" to "
"another process.  However, more accurately, what is being passed is a "
"reference to an open file description (see B<open>(2)), and in the receiving "
"process it is likely that a different file descriptor number will be used.  "
"Semantically, this operation is equivalent to duplicating (B<dup>(2))  a "
"file descriptor into the file descriptor table of another process."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:498
msgid ""
"If the buffer used to receive the ancillary data containing file descriptors "
"is too small (or is absent), then the ancillary data is truncated (or "
"discarded)  and the excess file descriptors are automatically closed in the "
"receiving process."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:506
msgid ""
"If the number of file descriptors received in the ancillary data would cause "
"the process to exceed its B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2)), the excess file descriptors are automatically closed in "
"the receiving process."
msgstr ""

#.  commit bba14de98753cb6599a2dae0e520714b2153522d
#. type: Plain text
#: build/C/man7/unix.7:519
msgid ""
"The kernel constant B<SCM_MAX_FD> defines a limit on the number of file "
"descriptors in the array.  Attempting to send an array larger than this "
"limit causes B<sendmsg>(2)  to fail with the error B<EINVAL>.  B<SCM_MAX_FD> "
"has the value 253 (or 255 in kernels before 2.6.38)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:519
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr "B<SCM_CREDENTIALS>"

#. type: Plain text
#: build/C/man7/unix.7:529
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  This "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""
"UNIX 信任状を送受信する。これは認証に用いることができる。\n"
"信任状は I<struct ucred> の補助メッセージとして渡される。\n"
"この構造体は I<E<lt>sys/socket.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man7/unix.7:537
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* Process ID of the sending process */\n"
"    uid_t uid;    /* User ID of the sending process */\n"
"    gid_t gid;    /* Group ID of the sending process */\n"
"};\n"
msgstr ""
"struct ucred {\n"
"    pid_t pid;    /* Process ID of the sending process */\n"
"    uid_t uid;    /* User ID of the sending process */\n"
"    gid_t gid;    /* Group ID of the sending process */\n"
"};\n"

#. type: Plain text
#: build/C/man7/unix.7:546
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""
"glibc 2.8 以降では、この構造体の定義を得るためには\n"
"(I<どの>ヘッダーファイルをインクルードするよりも前に)\n"
"機能検査マクロ B<_GNU_SOURCE> を定義しなければならない。"

#. type: Plain text
#: build/C/man7/unix.7:557
#, fuzzy
#| msgid ""
#| "The credentials which the sender specifies are checked by the kernel.  A "
#| "process with effective user ID 0 is allowed to specify values that do not "
#| "match its own.  The sender must specify its own process ID (unless it has "
#| "the capability B<CAP_SYS_ADMIN>), its user ID, effective user ID, or "
#| "saved set-user-ID (unless it has B<CAP_SETUID>), and its group ID, "
#| "effective group ID, or saved set-group-ID (unless it has B<CAP_SETGID>).  "
#| "To receive a I<struct ucred> message the B<SO_PASSCRED> option must be "
#| "enabled on the socket."
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"privileged process is allowed to specify values that do not match its own.  "
"The sender must specify its own process ID (unless it has the capability "
"B<CAP_SYS_ADMIN>, in which case the PID of any existing process may be "
"specified), its real user ID, effective user ID, or saved set-user-ID "
"(unless it has B<CAP_SETUID>), and its real group ID, effective group ID, or "
"saved set-group-ID (unless it has B<CAP_SETGID>)."
msgstr ""
"送信側が指定した信任状は、カーネルがチェックする。 実効ユーザー ID が 0 のプ"
"ロセスには、 自分自身以外の値を指定する事が許される。 送信側は以下の 3 つを指"
"定しなければならない。 1) 自分自身のプロセス ID (B<CAP_SYS_ADMIN> 権限を持っ"
"ていない場合)、 2) 自分自身のユーザー ID あるいは実効ユーザー ID か保存 set-"
"user-ID (B<CAP_SETUID> 権限を持っていない場合)、 3) 自分自身のグループ ID あ"
"るいは実行グループ ID か保存 set-group-ID (B<CAP_SETGID> を持っていない場"
"合)。 I<struct ucred> メッセージを受信するためには、ソケットに対し "
"B<SO_PASSCRED> オプションを有効にしなくてはならない。"

#. type: Plain text
#: build/C/man7/unix.7:563
msgid ""
"To receive a I<struct ucred> message, the B<SO_PASSCRED> option must be "
"enabled on the socket."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:563
#, no-wrap
msgid "B<SCM_SECURITY>"
msgstr "B<SCM_SECURITY>"

#. type: Plain text
#: build/C/man7/unix.7:572
msgid ""
"Receive the SELinux security context (the security label)  of the peer "
"socket.  The received ancillary data is a null-terminated string containing "
"the security context.  The receiver should allocate at least B<NAME_MAX> "
"bytes in the data portion of the ancillary message for this data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:576
msgid ""
"To receive the security context, the B<SO_PASSSEC> option must be enabled on "
"the socket (see above)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:580
msgid ""
"When sending ancillary data with B<sendmsg>(2), only one item of each of the "
"above types may be included in the sent message."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:588
msgid ""
"At least one byte of real data should be sent when sending ancillary data.  "
"On Linux, this is required to successfully send ancillary data over a UNIX "
"domain stream socket.  When sending ancillary data over a UNIX domain "
"datagram socket, it is not necessary on Linux to send any accompanying real "
"data.  However, portable applications should also include at least one byte "
"of real data when sending ancillary data over a datagram socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:592
msgid ""
"When receiving from a stream socket, ancillary data forms a kind of barrier "
"for the received data.  For example, suppose that the sender transmits as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:598 build/C/man7/unix.7:604
msgid "B<sendmsg>(2)  of four bytes, with no ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:601
msgid "B<sendmsg>(2)  of one byte, with ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:615
msgid ""
"Suppose that the receiver now performs B<recvmsg>(2)  calls each with a "
"buffer size of 20 bytes.  The first call will receive five bytes of data, "
"along with the ancillary data sent by the second B<sendmsg>(2)  call.  The "
"next call will receive the remaining four bytes of data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:636
msgid ""
"If the space allocated for receiving incoming ancillary data is too small "
"then the ancillary data is truncated to the number of headers that will fit "
"in the supplied buffer (or, in the case of an B<SCM_RIGHTS> file descriptor "
"list, the list of file descriptors may be truncated).  If no buffer is "
"provided for incoming ancillary data (i.e., the I<msg_control> field of the "
"I<msghdr> structure supplied to B<recvmsg>(2)  is NULL), then the incoming "
"ancillary data is discarded.  In both of these cases, the B<MSG_CTRUNC> flag "
"will be set in the I<msg.msg_flags> value returned by B<recvmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:647
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
#: build/C/man7/unix.7:652
msgid "I<ioctl_type> can be:"
msgstr "I<ioctl_type> には以下を指定できる:"

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: build/C/man7/unix.7:683
#, fuzzy
#| msgid ""
#| "Returns the amount of queued unread data in the receive buffer.  The "
#| "socket must not be in LISTEN state, otherwise an error (B<EINVAL>)  is "
#| "returned.  B<SIOCINQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  "
#| "Alternatively, you can use the synonymous B<FIONREAD>, defined in "
#| "I<E<lt>sys/ioctl.hE<gt>>."
msgid ""
"For B<SOCK_STREAM> sockets, this call returns the number of unread bytes in "
"the receive buffer.  The socket must not be in LISTEN state, otherwise an "
"error (B<EINVAL>)  is returned.  B<SIOCINQ> is defined in I<E<lt>linux/"
"sockios.hE<gt>>.  Alternatively, you can use the synonymous B<FIONREAD>, "
"defined in I<E<lt>sys/ioctl.hE<gt>>.  For B<SOCK_DGRAM> sockets, the "
"returned value is the same as for Internet domain datagram sockets; see "
"B<udp>(7)."
msgstr ""
"受信バッファーのキューにある、まだ読んでいないデータの量を返す。ソケットは\n"
"LISTEN 状態にあってはならず、さもないとエラー (B<EINVAL>) が返る。\n"
"B<SIOCINQ> は I<E<lt>linux/sockios.hE<gt>> で定義されている。\n"
"代わりに、I<E<lt>sys/ioctl.hE<gt>> で定義されている、同義語の B<FIONREAD>\n"
"を使うこともできる。"

#. type: Plain text
#: build/C/man7/unix.7:688
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""
"指定したローカルアドレスが既に使用されているか、ファイルシステムの\n"
"ソケットオブジェクトが既に存在している。"

#. type: Plain text
#: build/C/man7/unix.7:697
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above), and indicates that the file descriptor number that is "
"being sent is not valid (e.g., it is not an open file descriptor)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:703
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target pathname is not a socket."
msgstr ""
"B<connect>(2) により指定されたリモートアドレスが接続待ちソケットではなかっ"
"た。 このエラーはターゲットのパス名がソケットでなかった場合にも発生する。"

#. type: TP
#: build/C/man7/unix.7:703
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: build/C/man7/unix.7:706
msgid "Remote socket was unexpectedly closed."
msgstr "リモートソケットが予期しないかたちでクローズされた。"

#. type: Plain text
#: build/C/man7/unix.7:709
msgid "User memory address was not valid."
msgstr "ユーザーメモリーアドレスが不正。"

#. type: Plain text
#: build/C/man7/unix.7:718
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""
"渡した引数が不正。よくある原因としては、渡したアドレスの I<sun_type> フィー"
"ル\n"
"ドに B<AF_UNIX> が指定されていなかった、行おうとした操作に対してソケットが"
"有\n"
"効な状態ではなかった、など。"

#. type: Plain text
#: build/C/man7/unix.7:723
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""
"既に接続されているソケットに対して B<connect>(2)  が呼ばれた。または、指定し"
"たターゲットアドレスが 既に接続済みのソケットだった。"

#. type: Plain text
#: build/C/man7/unix.7:728
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not exist."
msgstr "B<connect>(2) に指定されたリモートアドレスのパス名が存在しなかった。"

#. type: TP
#: build/C/man7/unix.7:728
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man7/unix.7:734
msgid ""
"Socket operation needs a target address, but the socket is not connected."
msgstr ""
"ソケット操作にターゲットアドレスが必要だが、 このソケットは接続されていない。"

#. type: Plain text
#: build/C/man7/unix.7:738
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""
"ストリーム指向でないソケットに対してストリーム操作が呼び出された。 または帯域"
"外データオプションを用いようとした。"

#. type: Plain text
#: build/C/man7/unix.7:742
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr "送信者が I<struct ucred> に不正な信任状を渡した。"

#. type: Plain text
#: build/C/man7/unix.7:754
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<send>(2)  or B<sendmsg>(2)."
msgstr "リモートソケットがストリームソケット上でクローズされた。 可能な場合は B<SIGPIPE> も同時に送られる。これを避けるには B<MSG_NOSIGNAL> フラグを B<send>(2)  や B<sendmsg>(2)  に渡す。"

#. type: TP
#: build/C/man7/unix.7:754
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: build/C/man7/unix.7:758
msgid "Passed protocol is not B<AF_UNIX>."
msgstr "渡されたプロトコルが B<AF_UNIX> でない。"

#. type: TP
#: build/C/man7/unix.7:758
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: build/C/man7/unix.7:764
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)."
msgstr ""
"リモートソケットとローカルソケットのタイプが一致していなかった "
"(B<SOCK_DGRAM> と B<SOCK_STREAM>)。"

#. type: Plain text
#: build/C/man7/unix.7:767
msgid "Unknown socket type."
msgstr "未知のソケットタイプ。"

#. type: TP
#: build/C/man7/unix.7:767
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man7/unix.7:772
msgid ""
"While sending an ancillary message containing credentials "
"(B<SCM_CREDENTIALS>), the caller specified a PID that does not match any "
"existing process."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:772
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr "B<ETOOMANYREFS>"

#. type: Plain text
#: build/C/man7/unix.7:789
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above).  It occurs if the number of \"in-flight\" file "
"descriptors exceeds the B<RLIMIT_NOFILE> resource limit and the caller does "
"not have the B<CAP_SYS_RESOURCE> capability.  An in-flight file descriptor "
"is one that has been sent using B<sendmsg>(2)  but has not yet been accepted "
"in the recipient process using B<recvmsg>(2)."
msgstr ""

#.  commit 712f4aad406bb1ed67f3f98d04c044191f0ff593
#. type: Plain text
#: build/C/man7/unix.7:800
msgid ""
"This error is diagnosed since mainline Linux 4.5 (and in some earlier kernel "
"versions where the fix has been backported).  In earlier kernel versions, it "
"was possible to place an unlimited number of file descriptors in flight, by "
"sending each file descriptor with B<sendmsg>(2)  and then closing the file "
"descriptor so that it was not accounted against the B<RLIMIT_NOFILE> "
"resource limit."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:804
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate "
"manual pages for more information."
msgstr ""
"他にも汎用のソケット層でエラーが起こったり、 ファイルシステム上にソケットオブ"
"ジェクトを作ろうとした場合に ファイルシステムのエラーが起こることがある。 そ"
"れぞれの詳細は適切な man ページを参照すること。"

#. type: Plain text
#: build/C/man7/unix.7:810
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""
"B<SCM_CREDENTIALS> と抽象名前空間は、Linux 2.2 で導入された。 移植性が必要な"
"プログラムでは使うべきではない。 (BSD 由来のシステムの中にも信任状の送受信を"
"サポートしているものがあるが、 その実装の詳細はシステムによって異なる)"

#. type: Plain text
#: build/C/man7/unix.7:818
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the filesystem when "
"the last reference to it is closed."
msgstr ""
"ファイル名を指定してソケットにバインドすると、ファイルシステムにソケットが\n"
"生成される。これは必要なくなったときに呼びだしたユーザーが削除しなければ\n"
"ならない (B<unlink>(2) を用いる)。 UNIX で通常使われる「背後で閉じる方式」\n"
"が適用される。ソケットはいつでも unlink することができ、最後の参照が\n"
"クローズされたときにファイルシステムから削除される。"

#. type: Plain text
#: build/C/man7/unix.7:827
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM> socket, you "
"must to send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr "B<SOCK_STREAM> ソケット上でファイルディスクリプターや信任状を渡すためには、同じ B<sendmsg>(2)  や B<recvmsg>(2)  コールで補助データ以外のデータを少なくとも 1 バイト送信/受信しなければならない。"

#. type: Plain text
#: build/C/man7/unix.7:830
msgid ""
"UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""
"UNIX ドメインのストリームソケットでは、 帯域外データの概念はサポートされな"
"い。"

#.  The behavior on Solaris is quite similar.
#. type: Plain text
#: build/C/man7/unix.7:855
msgid ""
"When binding a socket to an address, Linux is one of the implementations "
"that appends a null terminator if none is supplied in I<sun_path>.  In most "
"cases this is unproblematic: when the socket address is retrieved, it will "
"be one byte longer than that supplied when the socket was bound.  However, "
"there is one case where confusing behavior can result: if 108 non-null bytes "
"are supplied when a socket is bound, then the addition of the null "
"terminator takes the length of the pathname beyond I<sizeof(sun_path)>.  "
"Consequently, when retrieving the socket address (for example, via "
"B<accept>(2)), if the input I<addrlen> argument for the retrieving call is "
"specified as I<sizeof(struct sockaddr_un)>, then the returned address "
"structure I<won't> have a null terminator in I<sun_path>."
msgstr ""
"ソケットをアドレスに結びつける際、 Linux は終端の NULL が I<sun_path> にな"
"かった場合に追加する実装の一つである。 ほとんどの場合、 これは問題にならな"
"い。 ソケットアドレスが取得された際、ソケットをバインドしたときに指定したもの"
"より 1 バイト長くなるだけである。 しかしながら、紛らわしい動作が起こる場合が"
"一つある。 ソケットをバインドした際に 108 個の NULL でないバイトを指定した場"
"合、 終端の NULL が追加されるとパス名の長さが I<sizeof(sun_path)> を超えてし"
"まう。 結果として、(例えば B<accept>(2) で) ソケットアドレスを取得した際に、 "
"値を取得する呼び出しの入力の I<address> 引数に I<sizeof(struct "
"sockaddr_un)> を指定したとすると、 返されるアドレス構造体は I<sun_path> に終"
"端の NULL を「含まない」ことになる。"

#.  i.e., traditional BSD
#. type: Plain text
#: build/C/man7/unix.7:865
msgid ""
"In addition, some implementations don't require a null terminator when "
"binding a socket (the I<addrlen> argument is used to determine the length of "
"I<sun_path>)  and when the socket address is retrieved on these "
"implementations, there is no null terminator in I<sun_path>."
msgstr ""
"さらに、 いくつかの実装では、ソケットをバインドする際に終端の NULL が必要では"
"なく (I<addrlen> 引数を使って I<sun_path> の長さが判定される)、 このような"
"実装でソケットアドレスを取得する際には、 I<sun_path> に終端の NULL は存在しな"
"い。"

#. type: Plain text
#: build/C/man7/unix.7:870
msgid ""
"Applications that retrieve socket addresses can (portably) code to handle "
"the possibility that there is no null terminator in I<sun_path> by "
"respecting the fact that the number of valid bytes in the pathname is:"
msgstr ""
"ソケットアドレスを取得するアプリケーションでは、 I<sun_path> に終端の NULL が"
"存在しないという移植性の問題を、 パス名の有効なバイト数が以下のようになると事"
"実を考慮することで取り扱うことができる。"

#
#.  The following patch to amend kernel behavior was rejected:
#.  http://thread.gmane.org/gmane.linux.kernel.api/2437
#.  Subject: [patch] Fix handling of overlength pathname in AF_UNIX sun_path
#.  2012-04-17
#.  And there was a related discussion in the Austin list:
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/5735
#.  Subject: Having a sun_path with no null terminator
#.  2012-04-18
#.  FIXME . Track http://austingroupbugs.net/view.php?id=561
#. type: Plain text
#: build/C/man7/unix.7:882
#, no-wrap
msgid "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"
msgstr "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"

#. type: Plain text
#: build/C/man7/unix.7:894
msgid ""
"Alternatively, an application can retrieve the socket address by allocating "
"a buffer of size I<sizeof(struct sockaddr_un)+1> that is zeroed out before "
"the retrieval.  The retrieving call can specify I<addrlen> as "
"I<sizeof(struct sockaddr_un)>, and the extra zero byte ensures that there "
"will be a null terminator for the string returned in I<sun_path>:"
msgstr ""
"他の方法としては、 アプリケーションがソケットアドレスを取得する際、 取得の呼"
"び出しを行う前に、 大きさが I<sizeof(struct sockaddr_un)+1> のバッファーを割"
"り当てることもできる。 取得の呼び出しでは I<addrlen> に I<sizeof(struct "
"sockaddr_un)> を指定すると、 余分な一つの 0 バイトにより I<sun_path> で返され"
"る文字列に終端の NULL が含まれることが保証される。"

#. type: Plain text
#: build/C/man7/unix.7:898
#, no-wrap
msgid "void *addrp;\n"
msgstr "void *addrp;\n"

#. type: Plain text
#: build/C/man7/unix.7:904
#, no-wrap
msgid ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"
msgstr ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"

#. type: Plain text
#: build/C/man7/unix.7:907
#, no-wrap
msgid ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"
msgstr ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"

#. type: Plain text
#: build/C/man7/unix.7:909
#, no-wrap
msgid "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"
msgstr "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"

#. type: Plain text
#: build/C/man7/unix.7:917
msgid ""
"This sort of messiness can be avoided if it is guaranteed that the "
"applications that I<create> pathname sockets follow the rules outlined above "
"under I<Pathname sockets>."
msgstr ""
"アプリケーションが「パス名ソケット」の節で説明したルールにしたがってパス名を"
"「作成」していれば、 このような分かりにくさは避けることができる。"

#. type: Plain text
#: build/C/man7/unix.7:929
msgid ""
"The following code demonstrates the use of sequenced-packet sockets for "
"local interprocess communication.  It consists of two programs.  The server "
"program waits for a connection from the client program.  The client sends "
"each of its command-line arguments in separate messages.  The server treats "
"the incoming messages as integers and adds them up.  The client sends the "
"command string \"END\".  The server sends back a message containing the sum "
"of the client's integers.  The client prints the sum and exits.  The server "
"waits for the next client to connect.  To stop the server, the client is "
"called with the command-line argument \"DOWN\"."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:933
msgid ""
"The following output was recorded while running the server in the background "
"and repeatedly executing the client.  Execution of the server program ends "
"when it receives the \"DOWN\" command."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:933
#, no-wrap
msgid "Example output"
msgstr "出力例"

#. type: Plain text
#: build/C/man7/unix.7:946
#, no-wrap
msgid ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"
msgstr ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"

#. type: Plain text
#: build/C/man7/unix.7:954
#, no-wrap
msgid ""
"/*\n"
" * File connection.h\n"
" */\n"
msgstr ""
"/*\n"
" * File connection.h\n"
" */\n"

#. type: Plain text
#: build/C/man7/unix.7:957
#, no-wrap
msgid ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"
msgstr ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"

#. type: Plain text
#: build/C/man7/unix.7:961
#, no-wrap
msgid ""
"/*\n"
" * File server.c\n"
" */\n"
msgstr ""
"/*\n"
" * File server.c\n"
" */\n"

#. type: Plain text
#: build/C/man7/unix.7:969
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#: build/C/man7/unix.7:980
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#: build/C/man7/unix.7:982 build/C/man7/unix.7:1115
#, no-wrap
msgid "    /* Create local socket. */\n"
msgstr "    /* Create local socket. */\n"

#. type: Plain text
#: build/C/man7/unix.7:988
#, no-wrap
msgid ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:994 build/C/man7/unix.7:1127
#, no-wrap
msgid ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"

#. type: Plain text
#: build/C/man7/unix.7:996
#, no-wrap
msgid "    memset(&name, 0, sizeof(name));\n"
msgstr "    memset(&name, 0, sizeof(name));\n"

#. type: Plain text
#: build/C/man7/unix.7:998
#, no-wrap
msgid "    /* Bind socket to socket name. */\n"
msgstr "    /* Bind socket to socket name. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1001
#, no-wrap
msgid ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"
msgstr ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"

#. type: Plain text
#: build/C/man7/unix.7:1008
#, no-wrap
msgid ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(name));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(name));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1014
#, no-wrap
msgid ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"

#. type: Plain text
#: build/C/man7/unix.7:1020
#, no-wrap
msgid ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1022
#, no-wrap
msgid "    /* This is the main loop for handling connections. */\n"
msgstr "    /* This is the main loop for handling connections. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1024
#, no-wrap
msgid "    for (;;) {\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#: build/C/man7/unix.7:1026
#, no-wrap
msgid "        /* Wait for incoming connection. */\n"
msgstr "        /* Wait for incoming connection. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1032
#, no-wrap
msgid ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/unix.7:1035
#, no-wrap
msgid ""
"        result = 0;\n"
"        for (;;) {\n"
msgstr ""
"        result = 0;\n"
"        for (;;) {\n"

#. type: Plain text
#: build/C/man7/unix.7:1037
#, no-wrap
msgid "            /* Wait for next data packet. */\n"
msgstr "            /* Wait for next data packet. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1043
#, no-wrap
msgid ""
"            ret = read(data_socket, buffer, sizeof(buffer));\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            ret = read(data_socket, buffer, sizeof(buffer));\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: build/C/man7/unix.7:1045
#, no-wrap
msgid "            /* Ensure buffer is 0-terminated. */\n"
msgstr "            /* Ensure buffer is 0-terminated. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1047
#, no-wrap
msgid "            buffer[sizeof(buffer) - 1] = 0;\n"
msgstr "            buffer[sizeof(buffer) - 1] = 0;\n"

#. type: Plain text
#: build/C/man7/unix.7:1049
#, no-wrap
msgid "            /* Handle commands. */\n"
msgstr "            /* Handle commands. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1054
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"DOWN\", sizeof(buffer))) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"DOWN\", sizeof(buffer))) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: build/C/man7/unix.7:1058
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"END\", sizeof(buffer))) {\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"END\", sizeof(buffer))) {\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: build/C/man7/unix.7:1060
#, no-wrap
msgid "            /* Add received summand. */\n"
msgstr "            /* Add received summand. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1063
#, no-wrap
msgid ""
"            result += atoi(buffer);\n"
"        }\n"
msgstr ""
"            result += atoi(buffer);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/unix.7:1065
#, no-wrap
msgid "        /* Send result. */\n"
msgstr "        /* Send result. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1072
#, no-wrap
msgid ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, sizeof(buffer));\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, sizeof(buffer));\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man7/unix.7:1074
#, no-wrap
msgid "        /* Close socket. */\n"
msgstr "        /* Close socket. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1076
#, no-wrap
msgid "        close(data_socket);\n"
msgstr "        close(data_socket);\n"

#. type: Plain text
#: build/C/man7/unix.7:1078
#, no-wrap
msgid "        /* Quit on DOWN command. */\n"
msgstr "        /* Quit on DOWN command. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1083
#, no-wrap
msgid ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1085
#, no-wrap
msgid "    close(connection_socket);\n"
msgstr "    close(connection_socket);\n"

#. type: Plain text
#: build/C/man7/unix.7:1087
#, no-wrap
msgid "    /* Unlink the socket. */\n"
msgstr "    /* Unlink the socket. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1089
#, no-wrap
msgid "    unlink(SOCKET_NAME);\n"
msgstr "    unlink(SOCKET_NAME);\n"

#. type: Plain text
#: build/C/man7/unix.7:1096
#, no-wrap
msgid ""
"/*\n"
" * File client.c\n"
" */\n"
msgstr ""
"/*\n"
" * File client.c\n"
" */\n"

#. type: Plain text
#: build/C/man7/unix.7:1105
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#: build/C/man7/unix.7:1113
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#: build/C/man7/unix.7:1121
#, no-wrap
msgid ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1129
#, no-wrap
msgid "    memset(&addr, 0, sizeof(addr));\n"
msgstr "    memset(&addr, 0, sizeof(addr));\n"

#. type: Plain text
#: build/C/man7/unix.7:1131
#, no-wrap
msgid "    /* Connect socket to socket address */\n"
msgstr "    /* Connect socket to socket address */\n"

#. type: Plain text
#: build/C/man7/unix.7:1134
#, no-wrap
msgid ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"
msgstr ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"

#. type: Plain text
#: build/C/man7/unix.7:1141
#, no-wrap
msgid ""
"    ret = connect(data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(addr));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = connect(data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(addr));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1143
#, no-wrap
msgid "    /* Send arguments. */\n"
msgstr "    /* Send arguments. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1151
#, no-wrap
msgid ""
"    for (int i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"    for (int i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1153
#, no-wrap
msgid "    /* Request result. */\n"
msgstr "    /* Request result. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1160
#, no-wrap
msgid ""
"    strcpy(buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    strcpy(buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1162
#, no-wrap
msgid "    /* Receive result. */\n"
msgstr "    /* Receive result. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1168
#, no-wrap
msgid ""
"    ret = read(data_socket, buffer, sizeof(buffer));\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = read(data_socket, buffer, sizeof(buffer));\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/unix.7:1170
#, no-wrap
msgid "    /* Ensure buffer is 0-terminated. */\n"
msgstr "    /* Ensure buffer is 0-terminated. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1172
#, no-wrap
msgid "    buffer[sizeof(buffer) - 1] = 0;\n"
msgstr "    buffer[sizeof(buffer) - 1] = 0;\n"

#. type: Plain text
#: build/C/man7/unix.7:1174
#, no-wrap
msgid "    printf(\"Result = %s\\en\", buffer);\n"
msgstr "    printf(\"Result = %s\\en\", buffer);\n"

#. type: Plain text
#: build/C/man7/unix.7:1176
#, no-wrap
msgid "    /* Close socket. */\n"
msgstr "    /* Close socket. */\n"

#. type: Plain text
#: build/C/man7/unix.7:1178
#, no-wrap
msgid "    close(data_socket);\n"
msgstr "    close(data_socket);\n"

#. type: Plain text
#: build/C/man7/unix.7:1187
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr "B<SCM_RIGHTS> の使用例については B<cmsg>(3) を参照。"

#. type: Plain text
#: build/C/man7/unix.7:1197
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"
msgstr "B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"

#. type: TH
#: build/C/man7/x25.7:12
#, no-wrap
msgid "X25"
msgstr "X25"

#. type: Plain text
#: build/C/man7/x25.7:15
msgid "x25 - ITU-T X.25 / ISO-8208 protocol interface"
msgstr "x25 - ITU-T X.25 / ISO-8208 プロトコルインターフェース"

#. type: Plain text
#: build/C/man7/x25.7:19
msgid "B<#include E<lt>linux/x25.hE<gt>>"
msgstr "B<#include E<lt>linux/x25.hE<gt>>"

#. type: Plain text
#: build/C/man7/x25.7:21
msgid "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"
msgstr "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"

#. type: Plain text
#: build/C/man7/x25.7:30
msgid ""
"X25 sockets provide an interface to the X.25 packet layer protocol.  This "
"allows applications to communicate over a public X.25 data network as "
"standardized by International Telecommunication Union's recommendation X.25 "
"(X.25 DTE-DCE mode).  X25 sockets can also be used for communication without "
"an intermediate X.25 network (X.25 DTE-DTE mode) as described in ISO-8208."
msgstr ""
"X25 ソケットは X.25 パケット層プロトコルに対するインターフェースを提供する。 "
"これにより、アプリケーションはパブリックな X.25 データネットワークで 通信する"
"ことができるようになる。 X.25 は International Telecommunication Union's "
"recommendation X.25 (X.25 DTE-DCE mode) で標準化されている。 X25 ソケットは、"
"中間層のない X.25 ネットワーク (X.25 DTE-DTE mode)  での通信にも用いることが"
"できる。 DTE-DTE モードは ISO-8208 に記述されている。"

#. type: Plain text
#: build/C/man7/x25.7:47
msgid ""
"Message boundaries are preserved \\(em a B<read>(2)  from a socket will "
"retrieve the same chunk of data as output with the corresponding "
"B<write>(2)  to the peer socket.  When necessary, the kernel takes care of "
"segmenting and reassembling long messages by means of the X.25 M-bit.  There "
"is no hard-coded upper limit for the message size.  However, reassembling of "
"a long message might fail if there is a temporary lack of system resources "
"or when other constraints (such as socket memory or buffer size limits) "
"become effective.  If that occurs, the X.25 connection will be reset."
msgstr ""
"メッセージ境界は保存される。ソケットからの B<read>(2)  は、反対側のソケットか"
"らの対応する B<write>(2)  と同じ大きさのデータを受け取り、出力する。 必要があ"
"る場合は、カーネルが長いメッセージの 分割 (segmenting) と再構成 "
"(reassembling) を行う。 これには X.25 の M ビットが用いられる。 メッセージサ"
"イズには、ハードコーディングされた上限はない。 しかし、一時的にシステムリソー"
"スが足りなかったり、 他の制約 (ソケットメモリーバッファーのサイズ制限など) "
"が 効いてしまうと、長いメッセージの再構成には失敗するかもしれない。 この場"
"合、その X.25 接続はリセットされることになる。"

#. type: SS
#: build/C/man7/x25.7:47
#, no-wrap
msgid "Socket addresses"
msgstr "ソケットアドレス"

#. type: Plain text
#: build/C/man7/x25.7:54
msgid ""
"The B<AF_X25> socket address family uses the I<struct sockaddr_x25> for "
"representing network addresses as defined in ITU-T recommendation X.121."
msgstr ""
"B<AF_X25> ソケットアドレスファミリーは、ネットワークアドレスを表すために "
"I<struct sockaddr_x25> を用いる。これは ITU-T recommendation X.121 で定義され"
"ている。"

#. type: Plain text
#: build/C/man7/x25.7:61
#, no-wrap
msgid ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"
msgstr ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"

#. type: Plain text
#: build/C/man7/x25.7:72
msgid ""
"I<sx25_addr> contains a char array I<x25_addr[]> to be interpreted as a null-"
"terminated string.  I<sx25_addr.x25_addr[]> consists of up to 15 (not "
"counting the terminating null byte) ASCII characters forming the X.121 "
"address.  Only the decimal digit characters from \\(aq0\\(aq to \\(aq9\\(aq "
"are allowed."
msgstr ""
"I<sx25_addr> には char 配列 I<x25_addr[]> を含まれる。これは 0 で終端する文字"
"列として解釈される。 I<sx25_addr.x25_addr[]> は 15 個までの ASCII 文字を含む"
"ことができ (終端のヌルバイトは含まない)、 これが X.121 アドレスをなす。 10 進"
"の数文字、\\(aq0\\(aq から \\(aq9\\(aq までだけが許される。"

#. type: Plain text
#: build/C/man7/x25.7:81
msgid ""
"The following X.25-specific socket options can be set by using "
"B<setsockopt>(2)  and read with B<getsockopt>(2)  with the I<level> argument "
"set to B<SOL_X25>."
msgstr ""
"以下の X.25 特有のソケットオプションは、 B<setsockopt>(2)  で設定でき、 "
"B<getsockopt>(2)  で取得できる。このとき I<level> 引数には B<SOL_X25> を指"
"定する。"

#. type: TP
#: build/C/man7/x25.7:81
#, no-wrap
msgid "B<X25_QBITINCL>"
msgstr "B<X25_QBITINCL>"

#. type: Plain text
#: build/C/man7/x25.7:100
msgid ""
"Controls whether the X.25 Q-bit (Qualified Data Bit) is accessible by the "
"user.  It expects an integer argument.  If set to 0 (default), the Q-bit is "
"never set for outgoing packets and the Q-bit of incoming packets is "
"ignored.  If set to 1, an additional first byte is prepended to each message "
"read from or written to the socket.  For data read from the socket, a 0 "
"first byte indicates that the Q-bits of the corresponding incoming data "
"packets were not set.  A first byte with value 1 indicates that the Q-bit of "
"the corresponding incoming data packets was set.  If the first byte of the "
"data written to the socket is 1, the Q-bit of the corresponding outgoing "
"data packets will be set.  If the first byte is 0, the Q-bit will not be set."
msgstr ""
"X.25 の Q ビット (Qualified データビット) にユーザーがアクセス できるかどうか"
"をコントロールする。整数の引数を取る。 0 にセットすると、 Q ビットは発信パ"
"ケットには決してセットされず、 受信パケットでは無視される (デフォルト)。 1 に"
"セットすると、ソケットから読む、あるいはソケットに送る メッセージそれぞれに先"
"頭バイトが前置される。 ソケットから読んだデータでは、先頭バイトが 0 だと、 こ"
"の到着データパケットに対応する Q ビットはセットされていなかったことになる。 "
"先頭バイトが 1 だと、到着データパケットの Q ビットがセットされていたことにな"
"る。 ソケットに書き込むデータの先頭バイトが 1 だと、 その発信パケットの Q "
"ビットをセットする。 0 だと、 Q ビットをセットしない。"

#. type: Plain text
#: build/C/man7/x25.7:102
msgid "The AF_X25 protocol family is a new feature of Linux 2.2."
msgstr "AF_X25 プロトコルファミリーは Linux 2.2 の新機能である。"

#. type: Plain text
#: build/C/man7/x25.7:105
msgid "Plenty, as the X.25 PLP implementation is B<CONFIG_EXPERIMENTAL>."
msgstr "X.25 PLP 実装は B<CONFIG_EXPERIMENTAL> なので、たくさんあるだろう。"

#. type: Plain text
#: build/C/man7/x25.7:107
msgid "This man page is incomplete."
msgstr "この man ページは完成していない。"

#. type: Plain text
#: build/C/man7/x25.7:114
msgid ""
"There is no dedicated application programmer's header file yet; you need to "
"include the kernel header file I<E<lt>linux/x25.hE<gt>>.  "
"B<CONFIG_EXPERIMENTAL> might also imply that future versions of the "
"interface are not binary compatible."
msgstr ""
"まだアプリケーションプログラマー用のヘッダーファイルがない。 カーネルのヘッ"
"ダーファイル I<E<lt>linux/x25.hE<gt>> をインクルードしなければならない。 "
"B<CONFIG_EXPERIMENTAL> なので、将来のバージョンのインターフェースでは バイナ"
"リ互換性が失われるかもしれない。"

#. type: Plain text
#: build/C/man7/x25.7:118
msgid ""
"X.25 N-Reset events are not propagated to the user process yet.  Thus, if a "
"reset occurred, data might be lost without notice."
msgstr ""
"X.25 N-Reset イベントは、まだユーザープロセスに伝播しない。 したがってリセッ"
"トが起こると、データは通知無しに失われる。"

#. type: Plain text
#: build/C/man7/x25.7:121
msgid "B<socket>(2), B<socket>(7)"
msgstr "B<socket>(2), B<socket>(7)"

#. type: Plain text
#: build/C/man7/x25.7:127
msgid ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of X.25."
"\\(rq The URL is E<.UR ftp://ftp.pspt.fi\\:/pub\\:/ham\\:/linux\\:/ax25\\:/"
"x25doc.tgz> E<.UE .>"
msgstr ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of X.25."
"\\(rq The URL is E<.UR ftp://ftp.pspt.fi\\:/pub\\:/ham\\:/linux\\:/ax25\\:/"
"x25doc.tgz> E<.UE .>"

#~ msgid "Multithreading (see pthreads(7))"
#~ msgstr "マルチスレッディング (pthreads(7) 参照)"

#~ msgid "B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>"
#~ msgstr "B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>"

#~ msgid ""
#~ "B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<, struct cmsghdr "
#~ "*>I<cmsg>B<);>"
#~ msgstr ""
#~ "B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<, struct cmsghdr "
#~ "*>I<cmsg>B<);>"

#~ msgid "B<size_t CMSG_ALIGN(size_t >I<length>B<);>"
#~ msgstr "B<size_t CMSG_ALIGN(size_t >I<length>B<);>"

#~ msgid "B<size_t CMSG_SPACE(size_t >I<length>B<);>"
#~ msgstr "B<size_t CMSG_SPACE(size_t >I<length>B<);>"

#~ msgid "B<size_t CMSG_LEN(size_t >I<length>B<);>"
#~ msgstr "B<size_t CMSG_LEN(size_t >I<length>B<);>"

#~ msgid "B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>"
#~ msgstr "B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>"

#~ msgid ""
#~ "B<CMSG_DATA>()  returns a pointer to the data portion of a I<cmsghdr>."
#~ msgstr "B<CMSG_DATA>()  は、 I<cmsghdr> のデータ部分へのポインターを返す。"

#~ msgid ""
#~ "When the control message buffer is too short to store all messages, the "
#~ "B<MSG_CTRUNC> flag is set in the I<msg_flags> member of the I<msghdr>."
#~ msgstr ""
#~ "制御メッセージバッファーが全てのメッセージを納めるのには短すぎる場合、 "
#~ "I<msghdr> の I<msg_flags> メンバーに B<MSG_CTRUNC> フラグがセットされる。"

#~ msgid "2008-11-20"
#~ msgstr "2008-11-20"

#~ msgid ""
#~ "B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
#~ "B<#include E<lt>endian.hE<gt>>\n"
#~ msgstr ""
#~ "B<#define _BSD_SOURCE>             /* feature_test_macros(7) 参照 */\n"
#~ "B<#include E<lt>endian.hE<gt>>\n"

#~ msgid "2014-07-08"
#~ msgstr "2014-07-08"

#~ msgid "2013-02-13"
#~ msgstr "2013-02-13"

#~ msgid "2014-04-06"
#~ msgstr "2014-04-06"

#~ msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
#~ msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#~ msgid "2014-05-28"
#~ msgstr "2014-05-28"

#~ msgid "2014-03-11"
#~ msgstr "2014-03-11"

#~ msgid "/* System V/POSIX extension */\n"
#~ msgstr "/* System V/POSIX 拡張 */\n"

#~ msgid "Since glibc 2.8:"
#~ msgstr "glibc 2.8 以降:"

#~ msgid ""
#~ "The domain name queries carried out by B<gethostbyname>()  and "
#~ "B<gethostbyaddr>()  use a combination of any or all of the name server "
#~ "B<named>(8), a broken out line from I</etc/hosts>, and the Network "
#~ "Information Service (NIS or YP), depending upon the contents of the "
#~ "I<order> line in I</etc/host.conf>.  The default action is to query "
#~ "B<named>(8), followed by I</etc/hosts>."
#~ msgstr ""
#~ "B<gethostbyname>()  と B<gethostbyaddr>()  によって実行されるドメイン名の"
#~ "問い合わせでは、ネームサーバ B<named>(8)、 I</etc/hosts> のデータ行、およ"
#~ "び Network Information Service (NIS または YP)  が組み合わせて使用される。"
#~ "何が使用されるかは、 I</etc/host.conf> の I<order> 行の内容により決まる。 "
#~ "デフォルトでは、まず B<named>(8)  に問い合わせを行い、次いで I</etc/"
#~ "hosts> を参照する。"

#~ msgid "B<NO_ADDRESS> or B<NO_DATA>"
#~ msgstr "B<NO_ADDRESS  または  NO_DATA>"

#~ msgid "The requested name is valid but does not have an IP address."
#~ msgstr "指定した名前は有効だが IP アドレスを持っていない。"

#~ msgid "2010-09-04"
#~ msgstr "2010-09-04"

#~ msgid "/etc/hosts"
#~ msgstr "/etc/hosts"

#~ msgid "/etc/nsswitch.conf"
#~ msgstr "/etc/nsswitch.conf"

#~ msgid "/etc/resolv.conf"
#~ msgstr "/etc/resolv.conf"

#~ msgid "RFC\\ 2553, POSIX.1-2001."
#~ msgstr "RFC\\ 2553, POSIX.1-2001."

#~ msgid "4.3BSD, POSIX.1-2001."
#~ msgstr "4.3BSD, POSIX.1-2001."

#~ msgid "2013-02-12"
#~ msgstr "2013-02-12"

#~ msgid ""
#~ "SVr4, 4.4BSD (the B<getpeername>()  function call first appeared in "
#~ "4.2BSD), POSIX.1-2001."
#~ msgstr ""
#~ "SVr4, 4.4BSD (B<getpeername>()  関数は 4.2BSD で登場した), POSIX.1-2001."

#~ msgid ""
#~ "The third argument of B<getpeername>()  is in reality an I<int\\ *> (and "
#~ "this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
#~ "resulted in the present I<socklen_t>, also used by glibc.  See also "
#~ "B<accept>(2)."
#~ msgstr ""
#~ "B<getpeername>()  の三番目の引数は実際には I<`int\\ *'> である (4.x "
#~ "BSD, libc4, libc5 では このようになっている)。 POSIX では紆余曲折を経て現"
#~ "在の I<socklen_t> になっており、 glibc でも I<socklen_t> を使っている。 "
#~ "B<accept>(2)  も参照のこと。"

#~ msgid "2003-08-23"
#~ msgstr "2003-08-23"

#~ msgid "B<gethostbyname>(3), B<hostname>(7), B<named>(8), B<resolv+>(8)"
#~ msgstr "B<gethostbyname>(3), B<hostname>(7), B<named>(8), B<resolv+>(8)"

#~ msgid "2003-08-24"
#~ msgstr "2003-08-24"

#~ msgid "I<[ + | - ]> I<[hostname]> I<[username]>"
#~ msgstr "I<[ + | - ]> I<[hostname]> I<[username]>"

#~ msgid "B<ip>(7)"
#~ msgstr "B<ip>(7)"

#~ msgid "B<inet_aton>(), B<inet_ntoa>(): _BSD_SOURCE || _SVID_SOURCE"
#~ msgstr "B<inet_aton>(), B<inet_ntoa>(): _BSD_SOURCE || _SVID_SOURCE"

#~ msgid "2008-11-11"
#~ msgstr "2008-11-11"

#~ msgid "2008-06-18"
#~ msgstr "2008-06-18"

#~ msgid "2014-05-10"
#~ msgstr "2014-05-10"

#~ msgid ""
#~ "An IP socket is created by calling the B<socket>(2)  function as "
#~ "B<socket(AF_INET, >I<socket_type>B<, >I<protocol>B<)>.  Valid socket "
#~ "types are B<SOCK_STREAM> to open a B<tcp>(7)  socket, B<SOCK_DGRAM> to "
#~ "open a B<udp>(7)  socket, or B<SOCK_RAW> to open a B<raw>(7)  socket to "
#~ "access the IP protocol directly.  I<protocol> is the IP protocol in the "
#~ "IP header to be received or sent.  The only valid values for I<protocol> "
#~ "are 0 and B<IPPROTO_TCP> for TCP sockets, and 0 and B<IPPROTO_UDP> for "
#~ "UDP sockets.  For B<SOCK_RAW> you may specify a valid IANA IP protocol "
#~ "defined in RFC\\ 1700 assigned numbers."
#~ msgstr ""
#~ "IP ソケットは、 B<socket>(2) 関数を B<socket(AF_INET, >I<socket_type>B<, "
#~ ">\n"
#~ "I<protocol>B<)> のように呼び出すことで生成される。指定できるソケットタイプ"
#~ "は\n"
#~ "3 つあり、 B<tcp>(7) ソケットをオープンする場合 B<SOCK_STREAM>、 "
#~ "B<udp>(7)\n"
#~ "ソケットをオープンする場合 B<SOCK_DGRAM>、 IP プロトコルに直接アクセスす"
#~ "る\n"
#~ "ために B<raw>(7) ソケットをオープンする場合には B<SOCK_RAW> である。 \n"
#~ "I<protocol> は送受信される IP ヘッダーに書かれる IP プロトコルである。\n"
#~ "指定できる値は、 TCP ソケットには 0 か B<IPPROTO_TCP>、 UDP ソケットに"
#~ "は \n"
#~ "0 か B<IPPROTO_UDP> に限られる。 B<SOCK_RAW> に対しては、 RFC\\ 1700 で定"
#~ "義\n"
#~ "されている有効な IANA IP プロトコルを、 割り当てられている番号で指定する\n"
#~ "ことができる。"

#~ msgid ""
#~ "Retrieve the current known path MTU of the current socket.  Valid only "
#~ "when the socket has been connected.  Returns an integer.  Only valid as a "
#~ "B<getsockopt>(2)."
#~ msgstr ""
#~ "ソケットの、既知の path MTU を取得する。 ソケットが接続している場合のみ有"
#~ "効である。 B<getsockopt>(2)  でのみ使える。"

#~ msgid ""
#~ "Set the local device for a multicast socket.  Argument is an I<ip_mreqn> "
#~ "or I<ip_mreq> (since Linux 3.5)  structure similar to "
#~ "B<IP_ADD_MEMBERSHIP>."
#~ msgstr ""
#~ "ローカルデバイスをマルチキャストソケットとして設定する。引数は "
#~ "B<IP_ADD_MEMBERSHIP> と同様に I<ip_mreqn> 構造体か I<ip_mreq> 構造体 "
#~ "(Linux 3.5 以降) である。"

#~ msgid "When an invalid socket option is passed, B<ENOPROTOOPT> is returned."
#~ msgstr "不正なソケットオプションが渡されると、 B<ENOPROTOOPT> が返される。"

#~ msgid ""
#~ "An connection operation on a nonblocking socket is already in progress."
#~ msgstr "非ブロッキングソケットに対する接続操作が既に実行中である。"

#~ msgid "2014-08-19"
#~ msgstr "2014-08-19"

#~ msgid "2014-01-24"
#~ msgstr "2014-01-24"

#~ msgid "2014-02-07"
#~ msgstr "2014-02-07"

#~ msgid "passwd:"
#~ msgstr "passwd:"

#~ msgid "compat"
#~ msgstr "compat"

#~ msgid "group:"
#~ msgstr "group:"

#~ msgid "shadow:"
#~ msgstr "shadow:"

#~ msgid "hosts:"
#~ msgstr "hosts:"

#~ msgid "dns [!UNAVAIL=return] files"
#~ msgstr "dns [!UNAVAIL=return] files"

#~ msgid "networks:"
#~ msgstr "networks:"

#~ msgid "nis [NOTFOUND=return] files"
#~ msgstr "nis [NOTFOUND=return] files"

#~ msgid "ethers:"
#~ msgstr "ethers:"

#~ msgid "protocols:"
#~ msgstr "protocols:"

#~ msgid "rpc:"
#~ msgstr "rpc:"

#~ msgid "services:"
#~ msgstr "services:"

#~ msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
#~ msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#~ msgid "B<#include E<lt>linux/if_packet.hE<gt>>\n"
#~ msgstr "B<#include E<lt>linux/if_packet.hE<gt>>\n"

#~ msgid "B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
#~ msgstr "B<#include E<lt>net/ethernet.hE<gt> /* L2 プロトコル */>\n"

#~ msgid ""
#~ "Only processes with effective UID 0 or the B<CAP_NET_RAW> capability may "
#~ "open packet sockets."
#~ msgstr ""
#~ "packet ソケットをオープンできるのは、 実効ユーザーID が 0 のプロセスか、 "
#~ "B<CAP_NET_RAW> ケーパビリティを持つプロセスだけである。"

#~ msgid ""
#~ "Fanout supports multiple algorithms to spread traffic between sockets.  "
#~ "The default mode, B<PACKET_FANOUT_HASH>, sends packets from the same flow "
#~ "to the same socket to maintain per-flow ordering.  For each packet, it "
#~ "chooses a socket by taking the packet flow hash modulo the number of "
#~ "sockets in the group, where a flow hash is a hash over network-layer "
#~ "address and optional transport-layer port fields.  The load-balance mode "
#~ "B<PACKET_FANOUT_LB> implements a round-robin algorithm.  "
#~ "B<PACKET_FANOUT_CPU> selects the socket based on the CPU that the packet "
#~ "arrived on.  B<PACKET_FANOUT_ROLLOVER> processes all data on a single "
#~ "socket, moves to the next when one becomes backlogged.  "
#~ "B<PACKET_FANOUT_RND> selects the socket using a pseudo-random number "
#~ "generator.  B<PACKET_FANOUT_QM> (available since Linux 3.14)  selects the "
#~ "socket using the recorded queue_mapping of the received skb."
#~ msgstr ""
#~ "ファンアウトでは、 複数のソケットにトラフィックを分散させるアルゴリズムを"
#~ "複数サポートしている。 デフォルトのモードである B<PACKET_FANOUT_HASH> で"
#~ "は、同じフローのパケットは同じソケットに送信され、 フロー単位の順序が維持"
#~ "される。 パケットごとに、パケットフローのハッシュの、そのグループのソケッ"
#~ "ト数に対する剰余が計算され、ソケットが選択される。 なお、フローハッシュは"
#~ "ネットワーク層のアドレスとトランスポート層のポートフィールドに対するハッ"
#~ "シュである (トランスポート層ポートは存在する場合のみ)。 負荷分散モード "
#~ "B<PACKET_FANOUT_LB> はラウンドロビンアルゴリズムが採用されている。 "
#~ "B<PACKET_FANOUT_CPU> では、 パケットが到着した CPU に基づいてソケットを選"
#~ "択する。 B<PACKET_FANOUT_ROLLOVER> はすべてのデータを一つのソケットで処理"
#~ "し、 そのソケットで処理待ち (backlog) が発生した場合に次のソケットに移"
#~ "る。 B<PACKET_FANOUT_RND> では擬似乱数発生器を使ってソケットが選択され"
#~ "る。 B<PACKET_FANOUT_QM> (Linux 3.14 以降で利用可能) では受信 skb に記録さ"
#~ "れた queue_mapping を使ってソケットが選択される。"

#~ msgid ""
#~ "glibc 2.1 does not have a define for B<SOL_PACKET>.  The suggested "
#~ "workaround is to use:"
#~ msgstr ""
#~ "glibc 2.1 には B<SOL_PACKET> の定義がない。回避策としては、以下のようにす"
#~ "るとよい。"

#~ msgid ""
#~ "#ifndef SOL_PACKET\n"
#~ "#define SOL_PACKET 263\n"
#~ "#endif\n"
#~ msgstr ""
#~ "#ifndef SOL_PACKET\n"
#~ "#define SOL_PACKET 263\n"
#~ "#endif\n"

#~ msgid "This is fixed in later glibc versions."
#~ msgstr "この問題はそれ以降のバージョンの glibc では修正されている。"

#~ msgid ""
#~ "Only processes with an effective user ID of 0 or the B<CAP_NET_RAW> "
#~ "capability are allowed to open raw sockets."
#~ msgstr ""
#~ "実効ユーザー ID が 0 のプロセスか、 B<CAP_NET_RAW> 権限を持つプロセスだけ"
#~ "が raw ソケットをオープンすることができる。"

#~ msgid "B<domain> Local domain name."
#~ msgstr "B<domain> ローカルドメイン名"

#~ msgid ""
#~ "The I<domain> and I<search> keywords are mutually exclusive.  If more "
#~ "than one instance of these keywords is present, the last instance wins."
#~ msgstr ""
#~ "I<domain> と I<search> キーワードは、互いに排他的である。 これらのキーワー"
#~ "ドが 2 つ以上記述されている場合、 最後に記述されているものが有効になる。"

#~ msgid "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"
#~ msgstr "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"

#~ msgid "B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
#~ msgstr "B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#~ msgid "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
#~ msgstr "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#~ msgid "B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
#~ msgstr "B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#~ msgid "B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
#~ msgstr "B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"

#~ msgid "B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
#~ msgstr "B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"

#~ msgid "B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
#~ msgstr "B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"

#~ msgid "B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
#~ msgstr "B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"

#~ msgid "B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char **>I<lastdnptr>B<);>\n"
#~ msgstr "B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char **>I<lastdnptr>B<);>\n"

#~ msgid "B<int dn_expand(const unsigned char *>I<msg>B<, const unsigned char *>I<eomorig>B<,>\n"
#~ msgstr "B<int dn_expand(const unsigned char *>I<msg>B<, const unsigned char *>I<eomorig>B<,>\n"

#~ msgid ""
#~ "B<const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
#~ "B<int >I<length>B<);>\n"
#~ msgstr ""
#~ "B<const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
#~ "B<int >I<length>B<);>\n"

#~ msgid "B<RES_PRIMARY>"
#~ msgstr "B<RES_PRIMARY>"

#~ msgid "Query primary domain name server only."
#~ msgstr "プライマリドメインネームサーバーのみ問い合わせる。"

#~ msgid ""
#~ "This list is not complete.  You can find some other flags described in "
#~ "B<resolv.conf>(5)."
#~ msgstr ""
#~ "このリストは完全なものではない。\n"
#~ "B<resolv.conf>(5) には他にいくつかのフラグが記載されている。"

#~ msgid ""
#~ "/etc/resolv.conf          resolver configuration file\n"
#~ "/etc/host.conf            resolver configuration file\n"
#~ msgstr ""
#~ "/etc/resolv.conf          レゾルバ設定ファイル\n"
#~ "/etc/host.conf            レゾルバ設定ファイル\n"

#~ msgid ""
#~ "B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
#~ "B<#include E<lt>netdb.hE<gt>>\n"
#~ msgstr ""
#~ "B<#define _BSD_SOURCE>             /* feature_test_macros(7) 参照 */\n"
#~ "B<#include E<lt>netdb.hE<gt>>\n"

#~ msgid "The B<rexec>()  and B<rexec_af>()  functions are not thread-safe."
#~ msgstr "関数 B<rexec>() と B<rexec_af>() はスレッドセーフではない。"

#~ msgid "2010-05-22"
#~ msgstr "2010-05-22"

#~ msgid "2012-09-06"
#~ msgstr "2012-09-06"

#~ msgid "I<sockfd> is a file, not a socket."
#~ msgstr "I<sockfd> がソケットでなくファイルである。"

#~ msgid "I<tcp_ecn> (Boolean; default: disabled; since Linux 2.4)"
#~ msgstr "I<tcp_ecn> (ブール値; デフォルト: 無効; Linux 2.4 以降)"

#~ msgid ""
#~ "Enable RFC\\ 2884 Explicit Congestion Notification.  When enabled, "
#~ "connectivity to some destinations could be affected due to older, "
#~ "misbehaving routers along the path causing connections to be dropped."
#~ msgstr ""
#~ "RFC\\ 2884 の Explicit Congestion Notification を有効にする。 これを有効に"
#~ "すると、間違った振舞いをする古いルーターが 経路の途中にあるような接続先に"
#~ "対して影響が生じ、 場合によっては接続が落ちるかもしれない。"

#~ msgid "Disabled."
#~ msgstr "F-RTO を無効にする。"

#~ msgid "I<tcp_syncookies> (Boolean; since Linux 2.2)"
#~ msgstr "I<tcp_syncookies> (Boolean; Linux 2.2 以降)"

#~ msgid "I<tcp_timestamps> (Boolean; default: enabled; since Linux 2.2)"
#~ msgstr "I<tcp_timestamps> (ブール値; デフォルト: 有効; Linux 2.2 以降)"

#~ msgid "2013-07-31"
#~ msgstr "2013-07-31"

#~ msgid "#define UNIX_PATH_MAX    108\n"
#~ msgstr "#define UNIX_PATH_MAX    108\n"

#~ msgid ""
#~ "In the Linux implementation, sockets which are visible in the filesystem "
#~ "honor the permissions of the directory they are in.  Their owner, group, "
#~ "and permissions can be changed.  Creation of a new socket will fail if "
#~ "the process does not have write and search (execute) permission on the "
#~ "directory the socket is created in.  Connecting to the socket object "
#~ "requires read/write permission.  This behavior differs from many BSD-"
#~ "derived systems which ignore permissions for UNIX domain sockets.  "
#~ "Portable programs should not rely on this feature for security."
#~ msgstr ""
#~ "Linux の実装では、 ファイルシステム上から見えるソケットは、 それらが置かれ"
#~ "ているディレクトリのパーミッションに従う。 ソケットの所有者、 グループ、 "
#~ "パーミッションは変更できる。 新しいソケットを作るとき、 作ろうとするディレ"
#~ "クトリに対して プロセスが書き込みと検索 (実行) 権限を持っていなければ、 作"
#~ "成に失敗する。 ソケットオブジェクトに接続するには、 read/write 権限が必要"
#~ "である。 この動作は、 多くの BSD 由来のシステムとは異なっている (BSD では "
#~ "UNIX ドメインソケットに対してはパーミッションを無視する)。 移植性の必要な"
#~ "プログラムでは、セキュリティをこの仕様に依存してはならない。"

#~ msgid "See B<bind>(2)."
#~ msgstr "B<bind>(2)  参照。"
